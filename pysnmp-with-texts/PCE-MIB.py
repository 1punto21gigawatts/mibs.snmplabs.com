#
# PySNMP MIB module PCE-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/PCE-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:37:50 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsIntersection, SingleValueConstraint, ConstraintsUnion, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsIntersection", "SingleValueConstraint", "ConstraintsUnion", "ValueRangeConstraint")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
IpAddress, Counter64, Integer32, Counter32, enterprises, NotificationType, MibIdentifier, ObjectIdentity, iso, Bits, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, Unsigned32, ModuleIdentity, NotificationType, Gauge32 = mibBuilder.importSymbols("SNMPv2-SMI", "IpAddress", "Counter64", "Integer32", "Counter32", "enterprises", "NotificationType", "MibIdentifier", "ObjectIdentity", "iso", "Bits", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "Unsigned32", "ModuleIdentity", "NotificationType", "Gauge32")
PhysAddress, DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "PhysAddress", "DisplayString", "TextualConvention")
pce = MibIdentifier((1, 3, 6, 1, 4, 1, 866))
products = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 1))
manager = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 2))
systemDescription = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 3))
projects = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 4))
frxSoftware = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20))
frxConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1))
frxManagement = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 10))
frxDiagnostic = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 20))
vcxSoftware = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 30))
vcxConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 30, 1))
dvbConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 30, 20))
mmxSoftware = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 40))
compacProxySoftware = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 51))
compacV9toV11 = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 1, 1))
transProduct = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 1, 10))
netAccessProduct = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 1, 20))
adaptis = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 1, 20, 10))
vpx10 = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 1, 20, 20))
vpx20 = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 1, 20, 21))
mcx103 = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 1, 20, 30))
mcx104 = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 1, 20, 31))
atLan = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 1, 20, 40))
mcx300 = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 1, 20, 50))
frx300 = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 1, 20, 60))
vcx100 = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 1, 20, 90))
avb1002_EM = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 1, 20, 200)).setLabel("avb1002-EM")
avb1002_FXS_FXO = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 1, 20, 201)).setLabel("avb1002-FXS-FXO")
sc103_3W = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 1, 20, 210)).setLabel("sc103-3W")
sc103_6W = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 1, 20, 211)).setLabel("sc103-6W")
sc103_6W_M = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 1, 20, 212)).setLabel("sc103-6W-M")
sc104 = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 1, 20, 220))
sc106 = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 1, 20, 225))
sc112 = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 1, 20, 226))
sc300_1W_1E = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 1, 20, 230)).setLabel("sc300-1W-1E")
sc300_3W_1E = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 1, 20, 231)).setLabel("sc300-3W-1E")
sc300_4W = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 1, 20, 232)).setLabel("sc300-4W")
sc310_8W = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 1, 20, 240)).setLabel("sc310-8W")
sc310_12W = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 1, 20, 241)).setLabel("sc310-12W")
sc320_4W_1TR = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 1, 20, 250)).setLabel("sc320-4W-1TR")
sc320_8W_1TR = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 1, 20, 251)).setLabel("sc320-8W-1TR")
sc330 = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 1, 20, 254))
sc1200 = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 1, 20, 255))
netConcentratorProduct = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 1, 30))
mcx09 = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 1, 30, 20))
mcx109 = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 1, 30, 21))
mcx106 = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 1, 30, 30))
mcx112 = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 1, 30, 35))
mcx212 = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 1, 30, 40))
mcx212Y = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 1, 30, 41))
mcx512 = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 1, 30, 45))
mcx512Y = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 1, 30, 46))
lmx506 = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 1, 30, 50))
frx800 = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 1, 30, 60))
sc512 = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 1, 30, 210))
sc512Y = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 1, 30, 211))
hpb1025_8W = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 1, 30, 220)).setLabel("hpb1025-8W")
hpb1025_12W = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 1, 30, 221)).setLabel("hpb1025-12W")
spb1033 = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 1, 30, 250))
dvb1008 = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 1, 30, 270))
netBackboneProduct = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 1, 40))
npx09 = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 1, 40, 20))
npx90 = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 1, 40, 21))
frx1000 = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 1, 40, 60))
frx2000 = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 1, 40, 65))
frx2000Y = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 1, 40, 70))
mmx5000 = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 1, 40, 100))
mmx10000 = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 1, 40, 105))
sc5000 = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 1, 40, 200))
netCentralSiteProduct = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 1, 50))
fpb2025 = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 1, 50, 200))
rpb2025 = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 1, 50, 201))
spb2033 = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 1, 50, 250))
dvb2030 = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 1, 50, 270))
nodeName = MibScalar((1, 3, 6, 1, 4, 1, 866, 2, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeName.setStatus('mandatory')
if mibBuilder.loadTexts: nodeName.setDescription('This describes the name of the node whose status has changed.')
nodeStatus = MibScalar((1, 3, 6, 1, 4, 1, 866, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(8, 1, 2, 3, 4, 6, 7))).clone(namedValues=NamedValues(("notMonitored", 8), ("inService", 1), ("serviceInterrupted", 2), ("unknown", 3), ("crippled", 4), ("functionOccupied", 6), ("callForBackupAddress", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeStatus.setStatus('mandatory')
if mibBuilder.loadTexts: nodeStatus.setDescription('This describes the status of the node.')
portLabel = MibScalar((1, 3, 6, 1, 4, 1, 866, 2, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portLabel.setStatus('mandatory')
if mibBuilder.loadTexts: portLabel.setDescription('This describes the label of the port whose status has changed.')
portNumber = MibScalar((1, 3, 6, 1, 4, 1, 866, 2, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portNumber.setStatus('mandatory')
if mibBuilder.loadTexts: portNumber.setDescription('This describes the number of the port whose status has changed.')
portStatus = MibScalar((1, 3, 6, 1, 4, 1, 866, 2, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(8, 1, 2, 3, 5))).clone(namedValues=NamedValues(("notMonitored", 8), ("inService", 1), ("serviceInterrupted", 2), ("unknown", 3), ("shiftToPstn", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portStatus.setStatus('mandatory')
if mibBuilder.loadTexts: portStatus.setDescription('This describes the status of the port.')
changeDescription = MibScalar((1, 3, 6, 1, 4, 1, 866, 2, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: changeDescription.setStatus('mandatory')
if mibBuilder.loadTexts: changeDescription.setDescription('Description of the status report.')
nodeStatusChanged = NotificationType((1, 3, 6, 1, 4, 1, 866) + (0,0)).setObjects(("PCE-MIB", "nodeName"), ("PCE-MIB", "nodeStatus"), ("PCE-MIB", "changeDescription"))
if mibBuilder.loadTexts: nodeStatusChanged.setDescription('')
lineStatusChanged = NotificationType((1, 3, 6, 1, 4, 1, 866) + (0,1)).setObjects(("PCE-MIB", "nodeName"), ("PCE-MIB", "portNumber"), ("PCE-MIB", "portLabel"), ("PCE-MIB", "portStatus"), ("PCE-MIB", "changeDescription"))
if mibBuilder.loadTexts: lineStatusChanged.setDescription('')
fcControl = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 1))
fcCtlConfigurationState = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 10, 11, 20, 21))).clone(namedValues=NamedValues(("noChange", 1), ("notReady", 2), ("limitedReset", 10), ("reboot", 11), ("savingInProgress", 20), ("loadingInProgress", 21)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcCtlConfigurationState.setStatus('mandatory')
if mibBuilder.loadTexts: fcCtlConfigurationState.setDescription("The value of this object indicates the current state of the configuration (see fcCtlConfigurationCommand to manage this configuration) : noChange : not any objects has been modified since the last 'load' command or the last boot, notReady : this configuration can not be saved because it has not been checked or it has been checked but it contains some errors, limitedReset : this configuration may be saved and it may be taken into account by a 'hotReset' command, reboot : this configuration may be saved and it will be taken into account by the next 'reboot' command (the 'hotReset' command is not enough complete), savingInProgress : this configuration is beeing saved, do not modify any parameter while this saving is being processed, loadingInProgress : a new configuration is beeing loaded, do not modify any parameter while this loading is being processed.")
fcCtlStateCheckingResults = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcCtlStateCheckingResults.setStatus('mandatory')
if mibBuilder.loadTexts: fcCtlStateCheckingResults.setDescription('The value of this object indicates the results of the checking controls of the configuration. This message is also recorded in fcCtlErrorTable.')
fcCtlConfigurationCommand = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 5, 6, 7, 10, 20))).clone(namedValues=NamedValues(("ready", 1), ("check", 2), ("load", 5), ("save", 6), ("erase", 7), ("hotReset", 10), ("reboot", 20)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcCtlConfigurationCommand.setStatus('mandatory')
if mibBuilder.loadTexts: fcCtlConfigurationCommand.setDescription("The value of this object is the command used to manage the current configuration : ready : this value is always returned by the equipment in response to a GET request, check : a SET to this value starts the global checking of the current configuration (the possible errors are described in fcCtlStateCheckingResults), determines which ports are concerned by the modifications (see fcCtlAlteredLpTable and fcCtlAlteredIfTable for the list of these ports) and sets fcCtlConfigurationState to 'notReady', 'limitedReset' or 'reboot', load : a SET to this value starts the loading of the configuration from fcCtlStorageDevice, this configuration replaces the current one (do not modify any parameter while this loading is being processed), save : a SET to this value starts the saving of the current configuration to fcCtlStorageDevice (do not modify any parameter while this saving is being processed). This saving procedure must follow a checking command with correct results. erase : not available, hotReset : a SET to this value resets (i.e., disconnects and connects) the ports, the parameters of which have been changed (see fcCtlAlteredLpTable and fcCtlAlteredIfTable for the list of these ports), this is possible only if fcCtlConfigurationState is equal to 'limitedReset', reboot : a SET to this value reboots the equipment, the configuration taken into account is specified by fcCtlBootDevice. When the current configuration is going to be modified, it is advisable to save a valid one on the backupNvram to avoid the loss of accessibility to the equipment. The default value is 'ready'.")
fcCtlBootDevice = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("normalNvram", 1), ("backupNvram", 2), ("startCard", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcCtlBootDevice.setStatus('mandatory')
if mibBuilder.loadTexts: fcCtlBootDevice.setDescription("The value of this object is the device containing the configuration which will be used by the equipment at next boot time. When the equipment fails to boot because of an inconsistent configuration, it will retry to boot with another one as following : normalNvram : normal non volatile random access memory (i.e., first part of the EEPROM), when it boots the equipment tries to use the configuration from : 1st time : normalNvram, 2nd time normalNvram, 3rd time backupNvram, 4th time flashMemory. backupNvram : backup non volatile random access memory (i.e., second part of the EEPROM), when it boots the equipment tries to use the configuration from : 1st time backupNvram, 2nd time backupNvram, 3rd time flashMemory. startCard : start card, when it boots the equipment tries to use the configuration from : 1st time startCard, 2nd time startCard, 3rd time backupNvram, 4th time flashMemory. The default value is 'normalNvram'.")
fcCtlStorageDevice = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("normalNvram", 1), ("backupNvram", 2), ("startCard", 3), ("flashMemory", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcCtlStorageDevice.setStatus('mandatory')
if mibBuilder.loadTexts: fcCtlStorageDevice.setDescription("The value of this object is the device where the next load or save command will operate : normalNvram : normal non volatile random access memory (i.e., first part of the EEPROM), backupNvram : backup non volatile random access memory (i.e., second part of the EEPROM), startCard : start card, flashMemory : flash memory, this device is not available for the save command (this configuration is a minimum one). The default value is 'normalNvram'.")
fcCtlAlteredLpTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 1, 30), )
if mibBuilder.loadTexts: fcCtlAlteredLpTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcCtlAlteredLpTable.setDescription('This table contains the logical ports that will be reinitialized by the next hotReset command.')
fcCtlAlteredLpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 1, 30, 1), ).setIndexNames((0, "PCE-MIB", "fcCtlAlteredLpId"))
if mibBuilder.loadTexts: fcCtlAlteredLpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcCtlAlteredLpEntry.setDescription('An entry of fcCtlAlteredLpTable.')
fcCtlAlteredLpId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 1, 30, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcCtlAlteredLpId.setStatus('mandatory')
if mibBuilder.loadTexts: fcCtlAlteredLpId.setDescription('The value of this object identifies one and only one logical port which will be reinitialized by the next hotReset command (see fcCtlConfigurationCommand).')
fcCtlAlteredDlciTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 1, 31), )
if mibBuilder.loadTexts: fcCtlAlteredDlciTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcCtlAlteredDlciTable.setDescription('')
fcCtlAlteredDlciEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 1, 31, 1), ).setIndexNames((0, "PCE-MIB", "fcCtlAlteredDlciPpId"), (0, "PCE-MIB", "fcCtlAlteredDlciNum"))
if mibBuilder.loadTexts: fcCtlAlteredDlciEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcCtlAlteredDlciEntry.setDescription('An entry of fcCtlAlteredDlciTable.')
fcCtlAlteredDlciPpId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 1, 31, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcCtlAlteredDlciPpId.setStatus('mandatory')
if mibBuilder.loadTexts: fcCtlAlteredDlciPpId.setDescription('PP id')
fcCtlAlteredDlciNum = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 1, 31, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcCtlAlteredDlciNum.setStatus('mandatory')
if mibBuilder.loadTexts: fcCtlAlteredDlciNum.setDescription('DLCI')
fcCtlAlteredDlciState = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 1, 31, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("added", 1), ("notchanged", 2), ("modified", 3), ("suppressed", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcCtlAlteredDlciState.setStatus('mandatory')
if mibBuilder.loadTexts: fcCtlAlteredDlciState.setDescription('Etat')
fcCtlAlteredIfTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 1, 32), )
if mibBuilder.loadTexts: fcCtlAlteredIfTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcCtlAlteredIfTable.setDescription('This table contains the interfaces that will be reinitialized by the next hotReset command.')
fcCtlAlteredIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 1, 32, 1), ).setIndexNames((0, "PCE-MIB", "fcCtlAlteredIfId"))
if mibBuilder.loadTexts: fcCtlAlteredIfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcCtlAlteredIfEntry.setDescription('An entry of fcCtlAlteredIfTable.')
fcCtlAlteredIfId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 1, 32, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcCtlAlteredIfId.setStatus('mandatory')
if mibBuilder.loadTexts: fcCtlAlteredIfId.setDescription('The value of this object identifies one and only one interface which will be reinitialized by the next hotReset command (see fcCtlConfigurationCommand).')
fcCtlErrorTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 1, 40), )
if mibBuilder.loadTexts: fcCtlErrorTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcCtlErrorTable.setDescription('This table contains the last 8 configuration messages. The last message is the first one in the table (fcCtlErrorIndex = 1), the oldest is the last one (fcCtlErrorIndex = 8).')
fcCtlErrorEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 1, 40, 1), ).setIndexNames((0, "PCE-MIB", "fcCtlErrorIndex"))
if mibBuilder.loadTexts: fcCtlErrorEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcCtlErrorEntry.setDescription('An entry of fcCtlErrorTable.')
fcCtlErrorIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 1, 40, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcCtlErrorIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fcCtlErrorIndex.setDescription("The value of this object identifies one and only one message. '1' identifies the last message and '8' the oldest one.")
fcCtlErrorCode = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 1, 40, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcCtlErrorCode.setStatus('mandatory')
if mibBuilder.loadTexts: fcCtlErrorCode.setDescription("The value of this object is the error code for this error. '0' means that this message does not contain an error but some useful informations.")
fcCtlErrorMessage = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 1, 40, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcCtlErrorMessage.setStatus('mandatory')
if mibBuilder.loadTexts: fcCtlErrorMessage.setDescription('The value of this object is the textual description of this message.')
fcCtlErrorTime = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 1, 40, 1, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcCtlErrorTime.setStatus('mandatory')
if mibBuilder.loadTexts: fcCtlErrorTime.setDescription('The value of this object is the value of sysUpTime when this message was recorded.')
fcCtlHRCheckMessagesTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 1, 50), )
if mibBuilder.loadTexts: fcCtlHRCheckMessagesTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcCtlHRCheckMessagesTable.setDescription('This table contains .')
fcCtlHRCheckMessagesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 1, 50, 1), ).setIndexNames((0, "PCE-MIB", "fcCtlHRCheckMsgIndex"))
if mibBuilder.loadTexts: fcCtlHRCheckMessagesEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcCtlHRCheckMessagesEntry.setDescription('An entry of fcCtlHRCheckMessagesTable.')
fcCtlHRCheckMsgIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 1, 50, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcCtlHRCheckMsgIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fcCtlHRCheckMsgIndex.setDescription('The value of this object identifies one and only one message.')
fcCtlHRCheckMsgCode = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 1, 50, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcCtlHRCheckMsgCode.setStatus('mandatory')
if mibBuilder.loadTexts: fcCtlHRCheckMsgCode.setDescription('The value of this object is .')
fcCtlHRCheckMessage = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 1, 50, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcCtlHRCheckMessage.setStatus('mandatory')
if mibBuilder.loadTexts: fcCtlHRCheckMessage.setDescription('The value of this object is .')
fcSystem = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 2))
fcsConfigDescription = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 2, 1))
fcsConfigDescName = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsConfigDescName.setStatus('mandatory')
if mibBuilder.loadTexts: fcsConfigDescName.setDescription("The value of this object is a textual comment. It can be used to store a little description of the configuration or of the equipment. This is a 0 to 8 ASCII characters string. The default value is 'Default'.")
fcsConfigDescAuthor = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsConfigDescAuthor.setStatus('mandatory')
if mibBuilder.loadTexts: fcsConfigDescAuthor.setDescription("The value of this object is a textual comment. It can be used to store the name of the person who creates the configuration. This is a 0 to 8 ASCII characters string. The default value is 'PCE'.")
fcsConfigDescDate = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 2, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(3, 3)).setFixedLength(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsConfigDescDate.setStatus('mandatory')
if mibBuilder.loadTexts: fcsConfigDescDate.setDescription("The value of this object is an octet string comment. It can be used to store the date when the configuration is created. This is a three-bytes octet string with digits in the range 0 to 9. The default value is '01 01 96'.")
fcsConfigDescVersion = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 254))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsConfigDescVersion.setStatus('mandatory')
if mibBuilder.loadTexts: fcsConfigDescVersion.setDescription("The value of this object can be used to store the version of the configuration. This is a decimal integer in the range 1 to 254. The default value is '1'.")
fcsHardwareDescription = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 2, 2))
fcsHardDescReplicatedMode = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 2, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 4))).clone(namedValues=NamedValues(("off", 1), ("onTwoModules", 3), ("onThreeModules", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsHardDescReplicatedMode.setStatus('mandatory')
if mibBuilder.loadTexts: fcsHardDescReplicatedMode.setDescription("The value of this object indicates whether the replicated mode is enabled (on two or three modules) or not. The replicated mode permits, inside a unit with two or three modules, to backup all the lines of a breakdown module on the remaining ones. This feature can be enabled only on a particular hardware. The default value is 'off'.")
fcsModuleTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 2, 5), )
if mibBuilder.loadTexts: fcsModuleTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcsModuleTable.setDescription('This table defines for each module of the subscriber number of the bridge and routers entities, and which of these entities must be initialized (i.e., must reserve resources). It is not possible to add or delete an entry of this table.')
fcsModuleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 2, 5, 1), ).setIndexNames((0, "PCE-MIB", "fcsModuleId"))
if mibBuilder.loadTexts: fcsModuleEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcsModuleEntry.setDescription('An entry of fcsModuleTable.')
fcsModuleId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 2, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcsModuleId.setStatus('mandatory')
if mibBuilder.loadTexts: fcsModuleId.setDescription('The value of this object identifies one and only one module.')
fcsModuleSubscriberNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 2, 5, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsModuleSubscriberNumber.setStatus('mandatory')
if mibBuilder.loadTexts: fcsModuleSubscriberNumber.setDescription("The value of this object is the subscriber number added to the DNICZO of the equipment to make the calling address in a call sent from the bridge or routers entities of this module. This is a one-byte octet string with 2 digits in the range 0 to 9. The default values are '93' for the module 0, '94' for the module 1, '95' for the module 2.")
fcsModuleBridgeInit = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 2, 5, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsModuleBridgeInit.setStatus('mandatory')
if mibBuilder.loadTexts: fcsModuleBridgeInit.setDescription("The value of this object indicates whether the bridge entity is initialized on this module or not. When not initialized this entity does not reserve resources that thus are available for other entities. The default value is 'off' for each of the three modules.")
fcsModuleIpxRouterInit = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 2, 5, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsModuleIpxRouterInit.setStatus('mandatory')
if mibBuilder.loadTexts: fcsModuleIpxRouterInit.setDescription("The value of this object indicates whether the IPX router entity is initialized on this module or not. When not initialized this entity does not reserve resources that thus are available for other entities. The default value is 'off' for each of the three modules.")
fcsModuleClnpRouterInit = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 2, 5, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsModuleClnpRouterInit.setStatus('mandatory')
if mibBuilder.loadTexts: fcsModuleClnpRouterInit.setDescription("The value of this object indicates whether the CLNP router entity is initialized on this module or not. When not initialized this entity does not reserve resources that thus are available for other entities. The default value is 'off' for each of the three modules.")
fcManagement = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 3))
fcmManagementFunctions = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 3, 1))
fcmMgtFctActivationTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 3, 1, 1), )
if mibBuilder.loadTexts: fcmMgtFctActivationTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcmMgtFctActivationTable.setDescription('This table indicates the activation of each management function. It is not possible to add or delete an entry of this table.')
fcmMgtFctActivationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 3, 1, 1, 1), ).setIndexNames((0, "PCE-MIB", "fcmMgfActName"))
if mibBuilder.loadTexts: fcmMgtFctActivationEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcmMgtFctActivationEntry.setDescription('An entry of fcmMgtFctActivationTable.')
fcmMgfActName = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 3, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 8, 10, 11, 12, 17))).clone(namedValues=NamedValues(("trafficGeneration", 1), ("observation", 2), ("statistics", 3), ("outstandingEvents", 4), ("fileTransfer", 5), ("telemaintenance", 6), ("alarm", 8), ("userInterface", 10), ("billing", 11), ("extendedStatistics", 12), ("exploitationAccess", 17)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcmMgfActName.setStatus('mandatory')
if mibBuilder.loadTexts: fcmMgfActName.setDescription('The value of this object identifies oneand only one management function.')
fcmMgfActAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 3, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcmMgfActAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fcmMgfActAdminStatus.setDescription('The value of this object indicates whether this management function is initialized or not. When not initialized this management function does not reserve resources that thus are available for other entities. The default values are : trafficGeneration : on, observation : on, statistics : on, outstandingEvents : on, fileTransfer : on, telemaintenance : on, alarm : off, userInterface : on, billing : on, extendedStatistics : off, exploitationAccess : on.')
fcmMgfActPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 3, 1, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 6))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcmMgfActPassword.setStatus('mandatory')
if mibBuilder.loadTexts: fcmMgfActPassword.setDescription("The value of this object is the password needed to enable this management function. This password takes place in the call user data of a call to this management function. It must contains 1 to 6 alphanumeric characters (except for 'alarm' which can not be called and then does not use a password). The default values are : trafficGeneration : GG, observation : OO, statistics : SS, outstandingEvents : EE, fileTransfer : TT, telemaintenance : MM, alarm : (empty), userInterface : RR, billing : TX, extendedStatistics : SC, exploitationAccess : PP.")
fcmMgtFctParameters = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 3, 1, 2))
fcmMgfGeneratorCount = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 3, 1, 2, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcmMgfGeneratorCount.setStatus('mandatory')
if mibBuilder.loadTexts: fcmMgfGeneratorCount.setDescription("The value of this object is the maximum number of traffic generators that may be enabled. This is a decimal integer in the range 1 to 15. The default value is '1'.")
fcmMgfGeneratorsAction = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 3, 1, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("output", 1), ("input", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcmMgfGeneratorsAction.setStatus('mandatory')
if mibBuilder.loadTexts: fcmMgfGeneratorsAction.setDescription("The value of this object indicates whether the generators send traffic ('output') or receive traffic ('input'). The default value is 'output'.")
fcmMgfGeneratorsDelay = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 3, 1, 2, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 98))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcmMgfGeneratorsDelay.setStatus('mandatory')
if mibBuilder.loadTexts: fcmMgfGeneratorsDelay.setDescription("The value of this object indicates, when the generators send traffic, the delay in seconds between two successive sent packets. This is a decimal integer in the range 0 to 98. The default value is '1'.")
fcmMgfAlarmsSubscriber1 = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 3, 1, 2, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcmMgfAlarmsSubscriber1.setStatus('mandatory')
if mibBuilder.loadTexts: fcmMgfAlarmsSubscriber1.setDescription("The value of this object indicates the X121 address of the main manager to which the alarms will be sent. This is a eight-bytes octet string with up to 15 digits in the range 0 to 9. It must be padded with 'F' digits for a total of 16 digits. The equipment configurator does not need this final padding. The default value is 'FF FF FF FF FF FF FF FF' meaning 'empty value' (blank value on the equipment configurator).")
fcmMgfAlarmsSubscriber2 = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 3, 1, 2, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcmMgfAlarmsSubscriber2.setStatus('mandatory')
if mibBuilder.loadTexts: fcmMgfAlarmsSubscriber2.setDescription("The value of this object indicates the X121 address of the backup manager to which the alarms will be sent. This is a eight-bytes octet string with up to 15 digits in the range 0 to 9. It must be padded with 'F' digits for a total of 16 digits. The equipment configurator does not need this final padding. The default value is 'FF FF FF FF FF FF FF FF' meaning 'empty value' (blank value on the equipment configurator).")
fcmMgfStatSummingPeriod = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 3, 1, 2, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 990))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcmMgfStatSummingPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: fcmMgfStatSummingPeriod.setDescription("The value of this object indicates the period, in seconds, during which the statistics are calculated in the 'notInfinite' summing mode (see fmsCtrlSumming). This is a decimal integer in the range 10 to 990 by step of 10. The default value is '10'.")
fcmMgfStatBufferThreshold = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 3, 1, 2, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcmMgfStatBufferThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: fcmMgfStatBufferThreshold.setDescription("The value of this object indicates a threshold in percents used by the statistics management function. The statistics management function calculates how long more than fcmMgfStatBufferThreshold percents of buffers are used and how long more than fcmMgfStatBufferThreshold percents of CPU is busy. This is a decimal integer in the range 0 to 100. The default value is '75'.")
fcmMgfStatThroughputSamplingPeriod = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 3, 1, 2, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 1800))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcmMgfStatThroughputSamplingPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: fcmMgfStatThroughputSamplingPeriod.setDescription("The value of this object indicates a sampling period in seconds used by the statistics management function. The statistics management function determines the observed throughput by counting the octets sent or received on a line during this sampling period. More this sampling period is small, more precise is the evaluated throughput. This is a decimal integer in the range 10 to 1800 by step of 10. The default value is '60'.")
fcmMgfStatOutputThreshold = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 3, 1, 2, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcmMgfStatOutputThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: fcmMgfStatOutputThreshold.setDescription("The value of this object indicates a threshold in percents used by the statistics management function. The statistics management function calculates how long the observed outgoing throughput is superior to fcmMgfStatOuputThreshold percents of the maximum throughput of the line. This is a decimal integer in the range 0 to 100. The default value is '75'.")
fcmMgfStatInputThreshold = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 3, 1, 2, 27), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcmMgfStatInputThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: fcmMgfStatInputThreshold.setDescription("The value of this object indicates a threshold in percents used by the statistics management function. The statistics management function calculates how long the observed incoming throughput is superior to fcmMgfStatOuputThreshold percents of the maximum throughput of the line. This is a decimal integer in the range 0 to 100. The default value is '75'.")
fcmMgfStatLogChannelSamplingPeriod = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 3, 1, 2, 30), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 1800))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcmMgfStatLogChannelSamplingPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: fcmMgfStatLogChannelSamplingPeriod.setDescription("The value of this object indicates a period in seconds used by the statistics management function. The statistics management function periodically counts the busy logical channels on a line every fcmMgfStatLogChannelSamplingPeriod seconds. This is a decimal integer in the range 10 to 1800 by step of 10. The default value is '60'.")
fcmMgfStatLogChannelThreshold = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 3, 1, 2, 31), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcmMgfStatLogChannelThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: fcmMgfStatLogChannelThreshold.setDescription("The value of this object indicates a threshold in percents used by the statistics management function. The statistics management function calculates how long the observed number of the busy logical channels is superior to fcmMgfStatLogChannelThreshold percents of the maximum number of logical channels for a line. This is a decimal integer in the range 0 to 100. The default value is '75'.")
fcmMgfConversionAimedPoint = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 3, 1, 2, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcmMgfConversionAimedPoint.setStatus('mandatory')
if mibBuilder.loadTexts: fcmMgfConversionAimedPoint.setDescription('Conversion adresse : point vise')
fcmMgfConversionIncomingCall = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 3, 1, 2, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("off", 1), ("callingAddress", 2), ("calledAddress", 3), ("callingAddressAndCalledAddress", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcmMgfConversionIncomingCall.setStatus('mandatory')
if mibBuilder.loadTexts: fcmMgfConversionIncomingCall.setDescription("Conversion d'adresse sur appel entrant")
fcmMgfConversionOutgoingCall = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 3, 1, 2, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("off", 1), ("callingAddress", 2), ("calledAddress", 3), ("callingAddressAndCalledAddress", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcmMgfConversionOutgoingCall.setStatus('mandatory')
if mibBuilder.loadTexts: fcmMgfConversionOutgoingCall.setDescription('Conversion adresse sur appel sortant')
fcmMgfConversionAddressCheck = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 3, 1, 2, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("off", 1), ("onIncomingCall", 2), ("onOutgoingCall", 3), ("onIncomingCallAndOutgoingCall", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcmMgfConversionAddressCheck.setStatus('mandatory')
if mibBuilder.loadTexts: fcmMgfConversionAddressCheck.setDescription('Conversion adresse : controle de la presence dans les tables de conversion')
fcmMgfConvMultiCalledAddrInCall = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 3, 1, 2, 36), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcmMgfConvMultiCalledAddrInCall.setStatus('mandatory')
if mibBuilder.loadTexts: fcmMgfConvMultiCalledAddrInCall.setDescription("Numero d'identification pour conversion d'adresse d'appele multi-criteres en entree")
fcmMgfConvMultiCallingAddrInCall = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 3, 1, 2, 37), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcmMgfConvMultiCallingAddrInCall.setStatus('mandatory')
if mibBuilder.loadTexts: fcmMgfConvMultiCallingAddrInCall.setDescription("Numero d'identification pour conversion d'adresse d'appelant multi-criteres en entree")
fcmMgfConvMultiCalledAddrOutCall = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 3, 1, 2, 38), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcmMgfConvMultiCalledAddrOutCall.setStatus('mandatory')
if mibBuilder.loadTexts: fcmMgfConvMultiCalledAddrOutCall.setDescription("Numero d'identification pour conversion d'adresse d'appele multi-criteres en sortie")
fcmMgfConvMultiCallingAddrOutCall = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 3, 1, 2, 39), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcmMgfConvMultiCallingAddrOutCall.setStatus('mandatory')
if mibBuilder.loadTexts: fcmMgfConvMultiCallingAddrOutCall.setDescription("Numero d'identification pour conversion d'adresse d'appelant multi-criteres en sortie")
fcmMgfBISDNChannelOpening = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 3, 1, 2, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcmMgfBISDNChannelOpening.setStatus('mandatory')
if mibBuilder.loadTexts: fcmMgfBISDNChannelOpening.setDescription("The value of this object describes the way ISDN backup will operate : off: B ISDN channel opening is automatic on: B ISDN channel opening is under management center control. A comparison is done between the calling address and the Manager and backup addresses defined in the management functions. If one of these addresses matches, the B ISDN channel is opened, otherwise the restart works only if the B channel is already open. The default value is 'off'.")
fcmMgfCallAcceptwithReverseCharging = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 3, 1, 2, 41), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcmMgfCallAcceptwithReverseCharging.setStatus('mandatory')
if mibBuilder.loadTexts: fcmMgfCallAcceptwithReverseCharging.setDescription('Acceptation appel avec TAD')
fcmMgfClosedUserGroup = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 3, 1, 2, 42), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 1, 3, 4))).clone(namedValues=NamedValues(("noCheck", 2), ("clear", 1), ("subscribe", 3), ("subscribeAndRemove", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcmMgfClosedUserGroup.setStatus('mandatory')
if mibBuilder.loadTexts: fcmMgfClosedUserGroup.setDescription('GFA')
fcmMgtFctCugTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 3, 1, 3), )
if mibBuilder.loadTexts: fcmMgtFctCugTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcmMgtFctCugTable.setDescription('This table defines the configuration of four couples internal GFU / external GFU for each operating function. ')
fcmMgtFctCugEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 3, 1, 3, 1), ).setIndexNames((0, "PCE-MIB", "fcmMgtFctCugFunctionId"), (0, "PCE-MIB", "fcmMgtFctCugGroupId"))
if mibBuilder.loadTexts: fcmMgtFctCugEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcmMgtFctCugEntry.setDescription('An entry of fcmMgtFctCugTable.')
fcmMgtFctCugFunctionId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 3, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 7, 8, 10, 11, 14))).clone(namedValues=NamedValues(("observation", 1), ("statistics", 2), ("outstandingEvents", 3), ("alarm", 4), ("trafficGeneration", 5), ("telemaintenance", 7), ("configuration", 8), ("billing", 10), ("extendedStatistics", 11), ("pae", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcmMgtFctCugFunctionId.setStatus('mandatory')
if mibBuilder.loadTexts: fcmMgtFctCugFunctionId.setDescription('The value of this object defines the operating function')
fcmMgtFctCugGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 3, 1, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcmMgtFctCugGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: fcmMgtFctCugGroupId.setDescription("The value of this object defines the number of the group for each couple internal GFU / external GFU This is a decimal integer in the range 0 to 3. The default value is '0'. ")
fcmMgtFctCugClosedUserGroupExt = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 3, 1, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 99))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcmMgtFctCugClosedUserGroupExt.setStatus('mandatory')
if mibBuilder.loadTexts: fcmMgtFctCugClosedUserGroupExt.setDescription("GFU externe This is a decimal integer in the range 0 to 99. The default value is ' '. ")
fcmMgtFctCugClosedUserGroupInt = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 3, 1, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 99))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcmMgtFctCugClosedUserGroupInt.setStatus('mandatory')
if mibBuilder.loadTexts: fcmMgtFctCugClosedUserGroupInt.setDescription("GFU interne The value of this object indicates a This is a decimal integer in the range 0 to 99. The default value is ' '. ")
fcmMgtFctCugChecking = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 3, 1, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 1))).clone(namedValues=NamedValues(("onOutgoingCall", 3), ("onIncomingCallAndOutgoingCall", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcmMgtFctCugChecking.setStatus('mandatory')
if mibBuilder.loadTexts: fcmMgtFctCugChecking.setDescription("The value of this object defines on which call the equipment checks this CUG. The default values is 'onIncomingCallAndOutgoingCall'.")
fcmAlarms = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 3, 2))
fcmAlrmEventTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 3, 2, 1), )
if mibBuilder.loadTexts: fcmAlrmEventTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcmAlrmEventTable.setDescription('This table defines, for each family, the selection of events which may be sent as alarms on the one hand, and as SNMP traps on the other hand. For most of these families, their events are sent for the physical ports selected in fcmAlrmPhysPortTable. It is not possible to add or delete an entry of this table.')
fcmAlrmEventEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 3, 2, 1, 1), ).setIndexNames((0, "PCE-MIB", "fcmAlrmEvtFamilyId"))
if mibBuilder.loadTexts: fcmAlrmEventEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcmAlrmEventEntry.setDescription('An entry of fcmAlrmEventTable.')
fcmAlrmEvtFamilyId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 3, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28))).clone(namedValues=NamedValues(("troubleReport-00", 1), ("management-01", 2), ("synchronousSignalling-02", 3), ("x25SynchronousProcedure-03", 4), ("synchronousLink-04", 5), ("linePhysicalLevel-05", 6), ("asynchronousProtocolLevel-06", 7), ("asynchronousCommandSyntax-07", 8), ("asynchronousSemanticLevel-08", 9), ("sdlcProcedure-09", 10), ("vipProcedure-0A", 11), ("tvipFradBscProcedure-0B", 12), ("dlcBscProcedure-0C", 13), ("mlp-0D", 14), ("pstnProcedure-0E", 15), ("securizedVcEsv-0F", 16), ("securizedVcN4-10", 17), ("securizedVcIr-11", 18), ("isdnDChannelProcedure-12", 19), ("x29Rerouting-13", 20), ("ethernetBridgeAndIpRouterFunctions-14", 21), ("dlcMtrFrad-15", 22), ("compressionProcedure-16", 23), ("dlmFunction-17", 24), ("configurationFunction-18", 25), ("lmiFunction-19", 26), ("ppp-1A", 27), ("frameRelaySna-1B", 28)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcmAlrmEvtFamilyId.setStatus('mandatory')
if mibBuilder.loadTexts: fcmAlrmEvtFamilyId.setDescription('The value of this object identifies one and only one events family (the hexadecimal code of this family is the last part of the value-name). This entry selects events of this family which may be sent as alarms on the one hand, and as SNMP traps on the other hand.')
fcmAlrmEvtEventSelection = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 3, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("mentioned", 1), ("all", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcmAlrmEvtEventSelection.setStatus('mandatory')
if mibBuilder.loadTexts: fcmAlrmEvtEventSelection.setDescription("The value of this object indicates whether all the events of this family are selected or only those mentioned for this family (in this case one to seven events may be selected). The default value is 'mentioned'.")
fcmAlrmEvtEvent1 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 3, 2, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcmAlrmEvtEvent1.setStatus('mandatory')
if mibBuilder.loadTexts: fcmAlrmEvtEvent1.setDescription("The value of this object is an event of this family which is selected when fcmAlrmEvtEventSelection is set to 'mentioned'. This is a one-byte octet string with 2 digits in the range 0 to F. The default value is 'FF' meaning 'empty value' (blank value on the equipment configurator).")
fcmAlrmEvtEvent2 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 3, 2, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcmAlrmEvtEvent2.setStatus('mandatory')
if mibBuilder.loadTexts: fcmAlrmEvtEvent2.setDescription("The value of this object is an event of this family which is selected when fcmAlrmEvtEventSelection is set to 'mentioned'. This is a one-byte octet string with 2 digits in the range 0 to F. The default value is 'FF' meaning 'empty value' (blank value on the equipment configurator).")
fcmAlrmEvtEvent3 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 3, 2, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcmAlrmEvtEvent3.setStatus('mandatory')
if mibBuilder.loadTexts: fcmAlrmEvtEvent3.setDescription("The value of this object is an event of this family which is selected when fcmAlrmEvtEventSelection is set to 'mentioned'. This is a one-byte octet string with 2 digits in the range 0 to F. The default value is 'FF' meaning 'empty value' (blank value on the equipment configurator).")
fcmAlrmEvtEvent4 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 3, 2, 1, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcmAlrmEvtEvent4.setStatus('mandatory')
if mibBuilder.loadTexts: fcmAlrmEvtEvent4.setDescription("The value of this object is an event of this family which is selected when fcmAlrmEvtEventSelection is set to 'mentioned'. This is a one-byte octet string with 2 digits in the range 0 to F. The default value is 'FF' meaning 'empty value' (blank value on the equipment configurator).")
fcmAlrmEvtEvent5 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 3, 2, 1, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcmAlrmEvtEvent5.setStatus('mandatory')
if mibBuilder.loadTexts: fcmAlrmEvtEvent5.setDescription("The value of this object is an event of this family which is selected when fcmAlrmEvtEventSelection is set to 'mentioned'. This is a one-byte octet string with 2 digits in the range 0 to F. The default value is 'FF' meaning 'empty value' (blank value on the equipment configurator).")
fcmAlrmEvtEvent6 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 3, 2, 1, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcmAlrmEvtEvent6.setStatus('mandatory')
if mibBuilder.loadTexts: fcmAlrmEvtEvent6.setDescription("The value of this object is an event of this family which is selected when fcmAlrmEvtEventSelection is set to 'mentioned'. This is a one-byte octet string with 2 digits in the range 0 to F. The default value is 'FF' meaning 'empty value' (blank value on the equipment configurator).")
fcmAlrmEvtEvent7 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 3, 2, 1, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcmAlrmEvtEvent7.setStatus('mandatory')
if mibBuilder.loadTexts: fcmAlrmEvtEvent7.setDescription("The value of this object is an event of this family which is selected when fcmAlrmEvtEventSelection is set to 'mentioned'. This is a one-byte octet string with 2 digits in the range 0 to F. The default value is 'FF' meaning 'empty value' (blank value on the equipment configurator).")
fcmAlrmPhysPortTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 3, 2, 2), )
if mibBuilder.loadTexts: fcmAlrmPhysPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcmAlrmPhysPortTable.setDescription('This table defines, for each family, the selection of lines from which the events selected in fcmAlrmEventTable will be sent as alarms on the one hand, and as SNMP traps on the other hand. It is not possible to add or delete an entry of this table.')
fcmAlrmPhysPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 3, 2, 2, 1), ).setIndexNames((0, "PCE-MIB", "fcmAlrmPpFamilyId"))
if mibBuilder.loadTexts: fcmAlrmPhysPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcmAlrmPhysPortEntry.setDescription('An entry of fcmAlrmPhysPortTable.')
fcmAlrmPpFamilyId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 3, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 19, 22, 23, 24, 25, 26, 27, 28))).clone(namedValues=NamedValues(("troubleReport-00", 1), ("management-01", 2), ("synchronousSignalling-02", 3), ("x25SynchronousProcedure-03", 4), ("synchronousLink-04", 5), ("linePhysicalLevel-05", 6), ("asynchronousProtocolLevel-06", 7), ("asynchronousCommandSyntax-07", 8), ("asynchronousSemanticLevel-08", 9), ("sdlcProcedure-09", 10), ("vipProcedure-0A", 11), ("tvipFradBscProcedure-0B", 12), ("dlcBscProcedure-0C", 13), ("mlp-0D", 14), ("pstnProcedure-0E", 15), ("isdnDChannelProcedure-12", 19), ("dlcMtrFrad-15", 22), ("compressionProcedure-16", 23), ("dlmFunction-17", 24), ("configurationFunction-18", 25), ("lmiFunction-19", 26), ("ppp-1A", 27), ("frameRelaySna-1B", 28)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcmAlrmPpFamilyId.setStatus('mandatory')
if mibBuilder.loadTexts: fcmAlrmPpFamilyId.setDescription('The value of this object identifies one and only one events family (the hexadecimal code of this family is the last part of the value-name). This entry selects lines from which the events selected in fcmAlrmEventTable will be sent as alarms on the one hand, and as SNMP traps on the other hand.')
fcmAlrmPpPhysPortSelection = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 3, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("mentioned", 1), ("allExceptMentioned", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcmAlrmPpPhysPortSelection.setStatus('mandatory')
if mibBuilder.loadTexts: fcmAlrmPpPhysPortSelection.setDescription("The value of this object indicates whether the selected events of this family are sent only for the physical ports mentioned for this family or for all the physical ports except those mentioned (note in this second case that all the physical ports are selected when none is specified). The default value is 'mentioned'.")
fcmAlrmPpPhysPort1 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 3, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcmAlrmPpPhysPort1.setStatus('mandatory')
if mibBuilder.loadTexts: fcmAlrmPpPhysPort1.setDescription("The value of this object is a physical port for which the selected events of this family will be or will not be sent according to fcmAlrmPpPhysPortSelection. This is a decimal integer in the range 0 to 35. The default value is '255' meaning 'empty value' (blank value on the equipment configurator).")
fcmAlrmPpPhysPort2 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 3, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcmAlrmPpPhysPort2.setStatus('mandatory')
if mibBuilder.loadTexts: fcmAlrmPpPhysPort2.setDescription("The value of this object is a physical port for which the selected events of this family will be or will not be sent according to fcmAlrmPpPhysPortSelection. This is a decimal integer in the range 0 to 35. The default value is '255' meaning 'empty value' (blank value on the equipment configurator).")
fcmAlrmPpPhysPort3 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 3, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcmAlrmPpPhysPort3.setStatus('mandatory')
if mibBuilder.loadTexts: fcmAlrmPpPhysPort3.setDescription("The value of this object is a physical port for which the selected events of this family will be or will not be sent according to fcmAlrmPpPhysPortSelection. This is a decimal integer in the range 0 to 35. The default value is '255' meaning 'empty value' (blank value on the equipment configurator).")
fcmAlrmPpPhysPort4 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 3, 2, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcmAlrmPpPhysPort4.setStatus('mandatory')
if mibBuilder.loadTexts: fcmAlrmPpPhysPort4.setDescription("The value of this object is a physical port for which the selected events of this family will be or will not be sent according to fcmAlrmPpPhysPortSelection. This is a decimal integer in the range 0 to 35. The default value is '255' meaning 'empty value' (blank value on the equipment configurator).")
fcmAlrmPpPhysPort5 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 3, 2, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcmAlrmPpPhysPort5.setStatus('mandatory')
if mibBuilder.loadTexts: fcmAlrmPpPhysPort5.setDescription("The value of this object is a physical port for which the selected events of this family will be or will not be sent according to fcmAlrmPpPhysPortSelection. This is a decimal integer in the range 0 to 35. The default value is '255' meaning 'empty value' (blank value on the equipment configurator).")
fcmAlrmPpPhysPort6 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 3, 2, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcmAlrmPpPhysPort6.setStatus('mandatory')
if mibBuilder.loadTexts: fcmAlrmPpPhysPort6.setDescription("The value of this object is a physical port for which the selected events of this family will be or will not be sent according to fcmAlrmPpPhysPortSelection. This is a decimal integer in the range 0 to 35. The default value is '255' meaning 'empty value' (blank value on the equipment configurator).")
fcmAlrmPpPhysPort7 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 3, 2, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcmAlrmPpPhysPort7.setStatus('mandatory')
if mibBuilder.loadTexts: fcmAlrmPpPhysPort7.setDescription("The value of this object is a physical port for which the selected events of this family will be or will not be sent according to fcmAlrmPpPhysPortSelection. This is a decimal integer in the range 0 to 35. The default value is '255' meaning 'empty value' (blank value on the equipment configurator).")
fcInterfaces = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 10))
fcfPhysicalPortTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 1), )
if mibBuilder.loadTexts: fcfPhysicalPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcfPhysicalPortTable.setDescription('This table defines how the physical ports of the equipment are used to build the interfaces. It is not possible to add or delete an entry of this table.')
fcfPhysicalPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 1, 1), ).setIndexNames((0, "PCE-MIB", "fcfPhysPortId"))
if mibBuilder.loadTexts: fcfPhysicalPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcfPhysicalPortEntry.setDescription('An entry of fcfPhysicalPortTable.')
fcfPhysPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 36))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcfPhysPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fcfPhysPortId.setDescription('The value of this object identifies one and only one physical port. A physical port has the same number than the physical connector which it goes with (this number is indicated on the equipment). This is a decimal integer in the range 0 to the number of the physical ports minus 1 (36 at the most).')
fcfPhysPortConnector = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("ethernet", 1), ("db25orRj45", 2), ("link", 3), ("db9orRj45", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcfPhysPortConnector.setStatus('mandatory')
if mibBuilder.loadTexts: fcfPhysPortConnector.setDescription('The value of this object indicates whether the connector type is Ethernet or DB25 or RJ45.')
fcfInterfaceType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("unUsed", 1), ("ethernetAuto", 2), ("ethernet10baseT", 3), ("ethernetAui", 4), ("line", 5), ("isdnBChannel", 6), ("isdnDChannel", 7), ("interUnitLinks", 8), ("e1", 9), ("ds1", 10), ("isdnPri", 11), ("lineorB", 12), ("tokenRing", 13)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfInterfaceType.setStatus('mandatory')
if mibBuilder.loadTexts: fcfInterfaceType.setDescription("The value of this object indicates how this physical port is used to build an interface (the interface identifiers are set by the equipment) : unUsed : this physical port is not used, ethernetAui : this physical port will support an ethernet interface with the same identifier (AUI connector for 10 base 5 ethernet), ethernet10baseT : this physical port will support an ethernet interface with the same identifier (RJ 45 connector for 10 base T ethernet), ethernetAuto : this physical port will support an ethernet interface with the same identifier (automatic detection between 10 base 5 and 10 base T), line : this physical port will support a serial line interface with the same identifier (the characteristics of this serial line interface are described in fcfLineTable), isdnBChannel : this physical port will support a B-channel of an ISDN Basic Rate Interface, isdnDChannel : this physical port will support a D-channel of an ISDN Basic Rate Interface with the same identifier (the characteristics of this ISDN BRI are described in fcfIsdnBasicRateInterfaceTable). interUnitLinks : this physical port will support a UnitLinks Interface, e1 : this physical port will support a E1 Interface, ds1 : this physical port will support a DS1 Interface, isdnPri : this physical port will support a Primary Rate Interface, tokenRing : this physical port will support a token ring Interface, analogVoiceEM : this physical port will support a EM analog voice Interface, analogVoiceFxs : this physical port will support a Fxs analog voice Interface, analogVoiceFxo : this physical port will support a Fxo analog voice Interface, isdnBri : this physical port will support a Basic Rate Interface, Each equipment has its own characteristics and the building of the interfaces must be done according to its hardware limitations. The default value is 'unUsed'.")
fcfLines = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2))
fcfLineTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 1), )
if mibBuilder.loadTexts: fcfLineTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineTable.setDescription("This table defines the characteristics of the serial line interfaces. It is not possible to add or delete an entry of this table (each entry corresponds, in fcfPhysicalPortTable, to one instance of fcfInterfaceType equal to 'line').")
fcfLineEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 1, 1), ).setIndexNames((0, "PCE-MIB", "fcfLineInterfaceId"))
if mibBuilder.loadTexts: fcfLineEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineEntry.setDescription('An entry of fcfLineTable.')
fcfLineInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcfLineInterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineInterfaceId.setDescription("The value of this object identifies one and only one serial line interface. Each serial line interface corresponds, in fcfPhysicalPortTable, to one instance of fcfInterfaceType equal to 'line'. This is a decimal integer in the range 0 to 35.")
fcfLineType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("synchroneV28Dte", 1), ("synchroneV28Dce", 2), ("asynchroneV28Dte", 3), ("asynchroneV28Dce", 4), ("v11Dte", 5), ("v11Dce", 6), ("v35Dte", 7), ("v35Dce", 8), ("g703", 9)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfLineType.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineType.setDescription("The value of this object indicates which DTE/DCE interface characteristics (physical layer) are used on this serial line interface : synchronousV28Dte : Synchronous, V28, the equipment is a DTE, synchronousV28Dce : Synchronous, V28, the equipment is a DCE, asynchronousV28Dte : Asynchronous, V28, the equipment is a DTE, asynchronousV28Dce : Asynchronous, V28, the equipment is a DCE, v11Dte : Synchronous, V11, the equipment is a DTE, v11Dce : Synchronous, V11, the equipment is a DCE, v35Dte : Synchronous, V35, the equipment is a DTE, v35Dce : Synchronous, V35, the equipment is a DCE, g703 : G703. The selection of this type must be done according to the hardware characteristics of this serial line interface. The default value is 'synchronousV28Dte'.")
fcfLineModemManagement = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfLineModemManagement.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineModemManagement.setDescription("The value of this object indicates whether a modem is drived by the equipment or not. The characteristics of the modem are described in fcfLineModemTable. The default value is 'off'.")
fcfLineSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(23, 2, 3, 6, 7, 8, 10, 9, 11, 26, 12, 13, 14, 24, 15, 16, 25, 17, 18, 19, 20, 21, 22))).clone(namedValues=NamedValues(("s300", 23), ("s600", 2), ("s1200", 3), ("s2400", 6), ("s3200", 7), ("s4800", 8), ("s9600", 10), ("s14400", 9), ("s19200", 11), ("s28800", 26), ("s38400", 12), ("s48000", 13), ("s56000", 14), ("s57600", 24), ("s64000", 15), ("s72000", 16), ("s115200", 25), ("s128000", 17), ("s144000", 18), ("s256000", 19), ("s512000", 20), ("s1024000", 21), ("s2048000", 22)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfLineSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineSpeed.setDescription("The value of this object indicates the speed in bits per second used on this serial line interface. The values s300, s57600 and s115200 can not be used on synchronous serial line interfaces. The default value is 's19200'.")
fcfLineLinkCheckPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(200, 50800))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfLineLinkCheckPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineLinkCheckPeriod.setDescription("The value of this object indicates a period in milliseconds used to look after the circuits of this serial line interface. Each circuit state is checked every fcfLineLinkCheckPeriod milliseconds and when it changes and remains changed after fcfLineCheckPeriodCount checkings, this new state is delivered to the upper level. This is a decimal integer in the range 200 to 50800 by step of 200. The default value is '2000'.")
fcfLineCheckPeriodCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 250))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfLineCheckPeriodCount.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineCheckPeriodCount.setDescription("The value of this object indicates the number of checkings of the circuits of this serial line interface. Each circuit state is checked every fcfLineLinkCheckPeriod milliseconds and when it changes and remains changed after fcfLineCheckPeriodCount checkings, this new state is delivered to the upper level. This is a decimal integer in the range 1 to 250. The default value is '3'.")
fcfLineV28AsynOutDteSignalTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 5), )
if mibBuilder.loadTexts: fcfLineV28AsynOutDteSignalTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV28AsynOutDteSignalTable.setDescription("This table defines how the outgoing circuits are used on asynchronous V28 serial line interfaces when the equipment is a DTE. It is not possible to add or delete an entry of this table (each entry corresponds, in fcfLineTable, to one instance of fcfLineType equal to 'asynchronousV28Dte').")
fcfLineV28AsynOutDteSignalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 5, 1), ).setIndexNames((0, "PCE-MIB", "fcfLineV28AsynOutDteInterfaceId"))
if mibBuilder.loadTexts: fcfLineV28AsynOutDteSignalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV28AsynOutDteSignalEntry.setDescription('An entry of fcfLineV28AsynOutDteSignalTable.')
fcfLineV28AsynOutDteInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcfLineV28AsynOutDteInterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV28AsynOutDteInterfaceId.setDescription("The value of this object identifies one and only one asynchronous V28 DTE serial line interface. Each asynchronous V28 DTE serial line interface corresponds, in fcfLineTable, to one instance of fcfLineType equal to 'asynchronousV28Dte'. This is a decimal integer in the range 0 to 35.")
fcfLineV28AsynOutDteRts105 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfLineV28AsynOutDteRts105.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV28AsynOutDteRts105.setDescription("The value of this object defines whether the circuit 105 (request to send) is set, in any case, to 'on' or to 'off'. The default value is 'on'.")
fcfLineV28AsynOutDteDtr108 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfLineV28AsynOutDteDtr108.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV28AsynOutDteDtr108.setDescription("The value of this object defines whether the circuit 108 (108/1 : connect data set to line or 108/2 : data terminal ready) is set, in any case, to 'on' or to 'off'. The default value is 'on'.")
fcfLineV28AsynOutDteDrs111 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 5, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfLineV28AsynOutDteDrs111.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV28AsynOutDteDrs111.setDescription("The value of this object defines whether the circuit 111 (data signalling rate selector) is set, in any case, to 'on' or to 'off'. The default value is 'on'.")
fcfLineV28AsynOutDteRil140 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 5, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfLineV28AsynOutDteRil140.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV28AsynOutDteRil140.setDescription("The value of this object defines whether the circuit 140 (loopback / maintance test) is set, in any case, to 'on' or to 'off'. The default value is 'off'.")
fcfLineV28AsynOutDteLl141 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 5, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfLineV28AsynOutDteLl141.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV28AsynOutDteLl141.setDescription("The value of this object defines whether the circuit 141 (local loopback) is set, in any case, to 'on' or to 'off'. The default value is 'off'.")
fcfLineV28AsynOutDceSignalTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 6), )
if mibBuilder.loadTexts: fcfLineV28AsynOutDceSignalTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV28AsynOutDceSignalTable.setDescription("This table defines how the outgoing circuits are used on asynchronous V28 serial line interfaces when the equipment is a DCE. It is not possible to add or delete an entry of this table (each entry corresponds, in fcfLineTable, to one instance of fcfLineType equal to 'asynchronousV28Dce').")
fcfLineV28AsynOutDceSignalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 6, 1), ).setIndexNames((0, "PCE-MIB", "fcfLineV28AsynOutDceInterfaceId"))
if mibBuilder.loadTexts: fcfLineV28AsynOutDceSignalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV28AsynOutDceSignalEntry.setDescription('An entry of fcfLineV28AsynOutDceSignalTable.')
fcfLineV28AsynOutDceInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcfLineV28AsynOutDceInterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV28AsynOutDceInterfaceId.setDescription("The value of this object identifies one and only one asynchronous V28 DCE serial line interface. Each asynchronous V28 DCE serial line interface corresponds, in fcfLineTable, to one instance of fcfLineType equal to 'asynchronousV28Dce'. This is a decimal integer in the range 0 to 35.")
fcfLineV28AsynOutDceCts106 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfLineV28AsynOutDceCts106.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV28AsynOutDceCts106.setDescription("The value of this object defines whether the circuit 106 (ready for sending) is set, in any case, to 'on' or to 'off'. The default value is 'on'.")
fcfLineV28AsynOutDceDsr107 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfLineV28AsynOutDceDsr107.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV28AsynOutDceDsr107.setDescription("The value of this object defines whether the circuit 107 (data set ready) is set, in any case, to 'on' or to 'off'. The default value is 'on'.")
fcfLineV28AsynOutDceDcd109 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 6, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfLineV28AsynOutDceDcd109.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV28AsynOutDceDcd109.setDescription("The value of this object defines whether the circuit 109 (data channel received line signal detector) is set, in any case, to 'on' or to 'off'. The default value is 'on'.")
fcfLineV28AsynOutDceSi117 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 6, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfLineV28AsynOutDceSi117.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV28AsynOutDceSi117.setDescription("The value of this object defines whether the circuit 117 (standby indicator) is set, in any case, to 'on' or to 'off'. The default value is 'off'.")
fcfLineV28AsynOutDceTi142 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 6, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfLineV28AsynOutDceTi142.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV28AsynOutDceTi142.setDescription("The value of this object defines whether the circuit 142 (test indicator) is set, in any case, to 'on' or to 'off'. The default value is 'off'.")
fcfLineV28AsynInDteSignalTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 7), )
if mibBuilder.loadTexts: fcfLineV28AsynInDteSignalTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV28AsynInDteSignalTable.setDescription("This table defines how the incoming circuits are interpreted on asynchronous V28 serial line interfaces when the equipment is a DTE. It is not possible to add or delete an entry of this table (each entry corresponds, in fcfLineTable, to one instance of fcfLineType equal to 'asynchronousV28Dte').")
fcfLineV28AsynInDteSignalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 7, 1), ).setIndexNames((0, "PCE-MIB", "fcfLineV28AsynInDteInterfaceId"))
if mibBuilder.loadTexts: fcfLineV28AsynInDteSignalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV28AsynInDteSignalEntry.setDescription('An entry of fcfLineV28AsynInDteSignalTable.')
fcfLineV28AsynInDteInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 7, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcfLineV28AsynInDteInterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV28AsynInDteInterfaceId.setDescription("The value of this object identifies one and only one asynchronous V28 DTE serial line interface. Each asynchronous V28 DTE serial line interface corresponds, in fcfLineTable, to one instance of fcfLineType equal to 'asynchronousV28Dte'. This is a decimal integer in the range 0 to 35.")
fcfLineV28AsynInDteEnablingSig1 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 7, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 33, 2, 9, 34, 41, 10, 42))).clone(namedValues=NamedValues(("none", 1), ("cts106", 33), ("dsr107", 2), ("dcd109", 9), ("cts106-dsr107", 34), ("cts106-dcd109", 41), ("dsr107-dcd109", 10), ("cts106-dsr107-dcd109", 42)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfLineV28AsynInDteEnablingSig1.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV28AsynInDteEnablingSig1.setDescription("The value of this object defines which circuits are scanned to determine whether this serial line interface is up or down. Secondary circuits may also be simultaneously scanned (see fcfLineV28AsynInDteEnablingSig2). none : the circuits 106, 107, 109 are not used. If also the circuits 117 and 142 are not used the state of this interface is determined by another method, cts106 : the circuit 106 (ready for sending) is used, dsr107 : the circuit 107 (data set ready) is used, dcd109 : the circuit 109 (data channel received line signal detector) is used, cts106-dsr107 : both circuits 106 and 107 are used, cts106-dcd109 : both circuits 106 and 109 are used, dsr107-dcd109 : both circuits 107 and 109 are used, cts106-dsr107-dcd109 : both circuits 106, 107 and 109 are used. The default value is 'cts106'.")
fcfLineV28AsynInDteEnablingSig2 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 7, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 5, 3))).clone(namedValues=NamedValues(("none", 1), ("si117", 5), ("ti142", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfLineV28AsynInDteEnablingSig2.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV28AsynInDteEnablingSig2.setDescription("The value of this object defines which circuits are scanned to determine whether this serial line interface is up or down. Main circuits may also be simultaneously scanned (see fcfLineV28AsynInDteEnablingSig1). none : the circuits 117, 142 are not used. If also the circuits 106, 107 and 109 are not used the state of this interface is determined by another method, si117 : the circuit 117 (standby indicator) is used, ti142 : the circuit 142 (test indicator) is used. The default value is 'none'.")
fcfLineV28AsynInDteSigMonitored1 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 7, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 33, 2, 9, 34, 41, 10, 42))).clone(namedValues=NamedValues(("none", 1), ("cts106", 33), ("dsr107", 2), ("dcd109", 9), ("cts106-dsr107", 34), ("cts106-dcd109", 41), ("dsr107-dcd109", 10), ("cts106-dsr107-dcd109", 42)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfLineV28AsynInDteSigMonitored1.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV28AsynInDteSigMonitored1.setDescription("The value of this object defines which circuits are monitored to eventually generate the corresponding event when the state of one of them changes. Secondary circuits may also be simultaneously monitored (see fcfLineV28AsynInDteMonitored2). none : the circuits 106, 107, 109 are not monitored, cts106 : the circuit 106 (ready for sending) is monitored, dsr107 : the circuit 107 (data set ready) is monitored, dcd109 : the circuit 109 (data channel received line signal detector) is monitored, cts106-dsr107 : both circuits 106 and 107 are monitored, cts106-dcd109 : both circuits 106 and 109 are monitored, dsr107-dcd109 : both circuits 107 and 109 are monitored, cts106-dsr107-dcd109 : both circuits 106, 107 and 109 are monitored. The default value is 'cts106'.")
fcfLineV28AsynInDteSigMonitored2 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 7, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 5, 3))).clone(namedValues=NamedValues(("none", 1), ("si117", 5), ("ti142", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfLineV28AsynInDteSigMonitored2.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV28AsynInDteSigMonitored2.setDescription("The value of this object defines which circuits are monitored to eventually generate the corresponding event when the state of one of them changes. Main circuits may also be simultaneously monitored (see fcfLineV28AsynInDteMonitored1). none : the circuits 117, 142 are not monitored, si117 : the circuit 117 (standby indicator) is monitored, ti142 : the circuit 142 (test indicator) is monitored. The default value is 'none'.")
fcfLineV28AsynInDceSignalTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 8), )
if mibBuilder.loadTexts: fcfLineV28AsynInDceSignalTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV28AsynInDceSignalTable.setDescription("This table defines how the incoming circuits are interpreted on asynchronous V28 serial line interfaces when the equipment is a DCE. It is not possible to add or delete an entry of this table (each entry corresponds, in fcfLineTable, to one instance of fcfLineType equal to 'asynchronousV28Dce').")
fcfLineV28AsynInDceSignalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 8, 1), ).setIndexNames((0, "PCE-MIB", "fcfLineV28AsynInDceInterfaceId"))
if mibBuilder.loadTexts: fcfLineV28AsynInDceSignalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV28AsynInDceSignalEntry.setDescription('An entry of fcfLineV28AsynInDceSignalTable.')
fcfLineV28AsynInDceInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 8, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcfLineV28AsynInDceInterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV28AsynInDceInterfaceId.setDescription("The value of this object identifies one and only one asynchronous V28 DCE serial line interface. Each asynchronous V28 DCE serial line interface corresponds, in fcfLineTable, to one instance of fcfLineType equal to 'asynchronousV28Dce'. This is a decimal integer in the range 0 to 35.")
fcfLineV28AsynInDceEnablingSig1 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 8, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 9, 33, 41))).clone(namedValues=NamedValues(("none", 1), ("rts105", 9), ("dtr108", 33), ("rts105-dtr108", 41)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfLineV28AsynInDceEnablingSig1.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV28AsynInDceEnablingSig1.setDescription("The value of this object defines which circuits are scanned to determine whether this serial line interface is up or down. Secondary circuits may also be simultaneously scanned (see fcfLineV28AsynInDceEnablingSig2). none : the circuits 105, 108 are not used. If also the circuits 111, 140 and 141 are not used the state of this interface is determined by another method, rts105 : the circuit 105 (request to send) is used, dtr108 : the circuit 108 (108/1 connect data set to line, 108/2 data terminal ready) is used, rts105-dtr108 : both circuits 105 and 108 are used. The default value is 'rts105'.")
fcfLineV28AsynInDceEnablingSig2 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 8, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 5))).clone(namedValues=NamedValues(("none", 1), ("drs111", 2), ("ril140", 3), ("ll141", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfLineV28AsynInDceEnablingSig2.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV28AsynInDceEnablingSig2.setDescription("The value of this object defines which circuits are scanned to determine whether this serial line interface is up or down. Main circuits may also be simultaneously scanned (see fcfLineV28AsynInDceEnablingSig1). none : the circuits 111, 140, 141 are not used. If also the circuits 105 and 108 are not used the state of this interface is determined by another method, drs111 : the circuit 111 (data signal rate selector) is used, ril140 : the circuit 140 (loopback / maintenance test) is used, ll141 : the circuit 141 (local loopback) is used. The default value is 'none'.")
fcfLineV28AsynInDceSigMonitored1 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 8, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 9, 33, 41))).clone(namedValues=NamedValues(("none", 1), ("rts105", 9), ("dtr108", 33), ("rts105-dtr108", 41)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfLineV28AsynInDceSigMonitored1.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV28AsynInDceSigMonitored1.setDescription("The value of this object defines which circuits are monitored to eventually generate the corresponding event when the state of one of them changes. Secondary circuits may also be simultaneously monitored (see fcfLineV28AsynInDceMonitored2). none : the circuits 105, 108 are not monitored, rts105 : the circuit 105 (request to send) is monitored, dtr108 : the circuit 108 (108/1 connect data set to line, 108/2 data terminal ready) is monitored, rts105-dtr108 : both circuits 105 and 108 are monitored. The default value is 'rts105'.")
fcfLineV28AsynInDceSigMonitored2 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 8, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 5))).clone(namedValues=NamedValues(("none", 1), ("rts111", 2), ("ril140", 3), ("ll141", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfLineV28AsynInDceSigMonitored2.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV28AsynInDceSigMonitored2.setDescription("The value of this object defines which circuits are monitored to eventually generate the corresponding event when the state of one of them changes. Main circuits may also be simultaneously monitored (see fcfLineV28AsynInDceMonitored1). none : the circuits 111, 140, 141 are not monitored, drs111 : the circuit 111 (data signal rate selector) is monitored, ril140 : the circuit 140 (loopback / maintenance test) is monitored, ll141 : the circuit 141 (local loopback) is monitored. The default value is 'none'.")
fcfLineV28DteSignalTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 11), )
if mibBuilder.loadTexts: fcfLineV28DteSignalTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV28DteSignalTable.setDescription("This table defines how the incoming circuits are monitored and interpreted on synchronous V28 serial line interfaces when the equipment is a DTE. It is not possible to add or delete an entry of this table (each entry corresponds, in fcfLineTable, to one instance of fcfLineType equal to 'synchronousV28Dte').")
fcfLineV28DteSignalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 11, 1), ).setIndexNames((0, "PCE-MIB", "fcfLineV28DteInterfaceId"))
if mibBuilder.loadTexts: fcfLineV28DteSignalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV28DteSignalEntry.setDescription('An entry of fcfLineV28DteSignalTable.')
fcfLineV28DteInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 11, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcfLineV28DteInterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV28DteInterfaceId.setDescription("The value of this object identifies one and only one synchronous V28 DTE serial line interface. Each synchronous V28 DTE serial line interface corresponds, in fcfLineTable, to one instance of fcfLineType equal to 'synchronousV28Dte'. This is a decimal integer in the range 0 to 35.")
fcfLineV28DteCts106 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notMonitored", 1), ("monitoredNotSignificant", 2), ("monitoredOff", 3), ("monitoredOn", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfLineV28DteCts106.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV28DteCts106.setDescription("The value of this object defines how the circuit 106 (ready fo sending) is monitored to eventually generate the corresponding event when its state changes and, when it is monitored, how it is scanned to determine whether this serial line interface is up or down. notMonitored : this circuit is not used, monitoredNotSignificant : this circuit is monitored (eventually events are generated) but it is not scanned to determine the state of this serial line interface, monitoredOff : this circuit is monitored (eventually events are generated) and it must be in the OFF condition to determine that this serial line interface is in the UP state, monitoredOn : this circuit is monitored (eventually events are generated) and it must be in the ON condition to determine that this serial line interface is in the UP state. The default value is 'monitoredOn'.")
fcfLineV28DteDsr107 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 11, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notMonitored", 1), ("monitoredNotSignificant", 2), ("monitoredOff", 3), ("monitoredOn", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfLineV28DteDsr107.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV28DteDsr107.setDescription("The value of this object defines how the circuit 107 (data set ready) is monitored to eventually generate the corresponding event when its state changes and, when it is monitored, how it is scanned to determine whether this serial line interface is up or down. notMonitored : this circuit is not used, monitoredNotSignificant : this circuit is monitored (eventually events are generated) but it is not scanned to determine the state of this serial line interface, monitoredOff : this circuit is monitored (eventually events are generated) and it must be in the OFF condition to determine that this serial line interface is in the UP state, monitoredOn : this circuit is monitored (eventually events are generated) and it must be in the ON condition to determine that this serial line interface is in the UP state. The default value is 'notMonitored'.")
fcfLineV28DteDcd109 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 11, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notMonitored", 1), ("monitoredNotSignificant", 2), ("monitoredOff", 3), ("monitoredOn", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfLineV28DteDcd109.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV28DteDcd109.setDescription("The value of this object defines how the circuit 109 (data channel received line signal detector) is monitored to eventually generate the corresponding event when its state changes and, when it is monitored, how it is scanned to determine whether this serial line interface is up or down. notMonitored : this circuit is not used, monitoredNotSignificant : this circuit is monitored (eventually events are generated) but it is not scanned to determine the state of this serial line interface, monitoredOff : this circuit is monitored (eventually events are generated) and it must be in the OFF condition to determine that this serial line interface is in the UP state, monitoredOn : this circuit is monitored (eventually events are generated) and it must be in the ON condition to determine that this serial line interface is in the UP state. The default value is 'monitoredOn'.")
fcfLineV28DteSi117 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 11, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notMonitored", 1), ("monitoredNotSignificant", 2), ("monitoredOff", 3), ("monitoredOn", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfLineV28DteSi117.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV28DteSi117.setDescription("The value of this object defines how the circuit 117 (standby indicator) is monitored to eventually generate the corresponding event when its state changes and, when it is monitored, how it is scanned to determine whether this serial line interface is up or down. notMonitored : this circuit is not used, monitoredNotSignificant : this circuit is monitored (eventually events are generated) but it is not scanned to determine the state of this serial line interface, monitoredOff : this circuit is monitored (eventually events are generated) and it must be in the OFF condition to determine that this serial line interface is in the UP state, monitoredOn : this circuit is monitored (eventually events are generated) and it must be in the ON condition to determine that this serial line interface is in the UP state. The default value is 'notMonitored'.")
fcfLineV28DteTi142 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 11, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notMonitored", 1), ("monitoredNotSignificant", 2), ("monitoredOff", 3), ("monitoredOn", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfLineV28DteTi142.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV28DteTi142.setDescription("The value of this object defines how the circuit 142 (test indicator) is monitored to eventually generate the corresponding event when its state changes and, when it is monitored, how it is scanned to determine whether this serial line interface is up or down. notMonitored : this circuit is not used, monitoredNotSignificant : this circuit is monitored (eventually events are generated) but it is not scanned to determine the state of this serial line interface, monitoredOff : this circuit is monitored (eventually events are generated) and it must be in the OFF condition to determine that this serial line interface is in the UP state, monitoredOn : this circuit is monitored (eventually events are generated) and it must be in the ON condition to determine that this serial line interface is in the UP state. The default value is 'notMonitored'.")
fcfLineV28DteSyn = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 11, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notMonitored", 1), ("monitoredOff", 2), ("monitoredOn", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfLineV28DteSyn.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV28DteSyn.setDescription("The value of this object defines how the flags are checked to determine whether this serial line interface is up or down. notMonitored : the flags are not checked, monitoredOff : the flags are checked and they must be not present to determine that this serial line interface is in the UP state, monitoredOn : the flags are checked and they must be present to determine that this serial line interface is in the UP state. The default value is 'monitoredOn'.")
fcfLineV28DceSignalTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 12), )
if mibBuilder.loadTexts: fcfLineV28DceSignalTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV28DceSignalTable.setDescription("This table defines how the incoming circuits are monitored and interpreted on synchronous V28 serial line interfaces when the equipment is a DCE. It is not possible to add or delete an entry of this table (each entry corresponds, in fcfLineTable, to one instance of fcfLineType equal to 'synchronousV28Dce').")
fcfLineV28DceSignalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 12, 1), ).setIndexNames((0, "PCE-MIB", "fcfLineV28DceInterfaceId"))
if mibBuilder.loadTexts: fcfLineV28DceSignalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV28DceSignalEntry.setDescription('An entry of fcfLineV28DceSignalTable.')
fcfLineV28DceInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 12, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcfLineV28DceInterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV28DceInterfaceId.setDescription("The value of this object identifies one and only one synchronous V28 DCE serial line interface. Each synchronous V28 DCE serial line interface corresponds, in fcfLineTable, to one instance of fcfLineType equal to 'synchronousV28Dce'. This is a decimal integer in the range 0 to 35.")
fcfLineV28DceRts105 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notMonitored", 1), ("monitoredNotSignificant", 2), ("monitoredOff", 3), ("monitoredOn", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfLineV28DceRts105.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV28DceRts105.setDescription("The value of this object defines how the circuit 105 (request to send) is monitored to eventually generate the corresponding event when its state changes and, when it is monitored, how it is scanned to determine whether this serial line interface is up or down. notMonitored : this circuit is not used, monitoredNotSignificant : this circuit is monitored (eventually events are generated) but it is not scanned to determine the state of this serial line interface, monitoredOff : this circuit is monitored (eventually events are generated) and it must be in the OFF condition to determine that this serial line interface is in the UP state, monitoredOn : this circuit is monitored (eventually events are generated) and it must be in the ON condition to determine that this serial line interface is in the UP state. The default value is 'monitoredOn'.")
fcfLineV28DceDtr108 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notMonitored", 1), ("monitoredNotSignificant", 2), ("monitoredOff", 3), ("monitoredOn", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfLineV28DceDtr108.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV28DceDtr108.setDescription("The value of this object defines how the circuit 108 (108/1 connect data set to line, 108/2 data terminal ready) is monitored to eventually generate the corresponding event when its state changes and, when it is monitored, how it is scanned to determine whether this serial line interface is up or down. notMonitored : this circuit is not used, monitoredNotSignificant : this circuit is monitored (eventually events are generated) but it is not scanned to determine the state of this serial line interface, monitoredOff : this circuit is monitored (eventually events are generated) and it must be in the OFF condition to determine that this serial line interface is in the UP state, monitoredOn : this circuit is monitored (eventually events are generated) and it must be in the ON condition to determine that this serial line interface is in the UP state. The default value is 'monitoredOn'.")
fcfLineV28DceDrs111 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 12, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notMonitored", 1), ("monitoredNotSignificant", 2), ("monitoredOff", 3), ("monitoredOn", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfLineV28DceDrs111.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV28DceDrs111.setDescription("The value of this object defines how the circuit 111 (data signal rate selector) is monitored to eventually generate the corresponding event when its state changes and, when it is monitored, how it is scanned to determine whether this serial line interface is up or down. notMonitored : this circuit is not used, monitoredNotSignificant : this circuit is monitored (eventually events are generated) but it is not scanned to determine the state of this serial line interface, monitoredOff : this circuit is monitored (eventually events are generated) and it must be in the OFF condition to determine that this serial line interface is in the UP state, monitoredOn : this circuit is monitored (eventually events are generated) and it must be in the ON condition to determine that this serial line interface is in the UP state. The default value is 'notMonitored'.")
fcfLineV28DceRil140 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 12, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notMonitored", 1), ("monitoredNotSignificant", 2), ("monitoredOff", 3), ("monitoredOn", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfLineV28DceRil140.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV28DceRil140.setDescription("The value of this object defines how the circuit 140 (loopback / maintenance test) is monitored to eventually generate the corresponding event when its state changes and, when it is monitored, how it is scanned to determine whether this serial line interface is up or down. notMonitored : this circuit is not used, monitoredNotSignificant : this circuit is monitored (eventually events are generated) but it is not scanned to determine the state of this serial line interface, monitoredOff : this circuit is monitored (eventually events are generated) and it must be in the OFF condition to determine that this serial line interface is in the UP state, monitoredOn : this circuit is monitored (eventually events are generated) and it must be in the ON condition to determine that this serial line interface is in the UP state. The default value is 'notMonitored'.")
fcfLineV28DceLl141 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 12, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notMonitored", 1), ("monitoredNotSignificant", 2), ("monitoredOff", 3), ("monitoredOn", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfLineV28DceLl141.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV28DceLl141.setDescription("The value of this object defines how the circuit 141 (local loopback) is monitored to eventually generate the corresponding event when its state changes and, when it is monitored, how it is scanned to determine whether this serial line interface is up or down. notMonitored : this circuit is not used, monitoredNotSignificant : this circuit is monitored (eventually events are generated) but it is not scanned to determine the state of this serial line interface, monitoredOff : this circuit is monitored (eventually events are generated) and it must be in the OFF condition to determine that this serial line interface is in the UP state, monitoredOn : this circuit is monitored (eventually events are generated) and it must be in the ON condition to determine that this serial line interface is in the UP state. The default value is 'notMonitored'.")
fcfLineV28DceSyn = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 12, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notMonitored", 1), ("monitoredOff", 2), ("monitoredOn", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfLineV28DceSyn.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV28DceSyn.setDescription("The value of this object defines how the flags are checked to determine whether this serial line interface is up or down. notMonitored : the flags are not checked, monitoredOff : the flags are checked and they must be not present to determine that this serial line interface is in the UP state, monitoredOn : the flags are checked and they must be present to determine that this serial line interface is in the UP state. The default value is 'monitoredOn'.")
fcfLineV11DteSignalTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 15), )
if mibBuilder.loadTexts: fcfLineV11DteSignalTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV11DteSignalTable.setDescription("This table defines how the incoming circuits are monitored and interpreted on synchronous V11 serial line interfaces when the equipment is a DTE. It is not possible to add or delete an entry of this table (each entry corresponds, in fcfLineTable, to one instance of fcfLineType equal to 'synchronousV11Dte').")
fcfLineV11DteSignalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 15, 1), ).setIndexNames((0, "PCE-MIB", "fcfLineV11DteInterfaceId"))
if mibBuilder.loadTexts: fcfLineV11DteSignalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV11DteSignalEntry.setDescription('An entry of fcfLineV11DteSignalTable.')
fcfLineV11DteInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 15, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcfLineV11DteInterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV11DteInterfaceId.setDescription("The value of this object identifies one and only one synchronous V11 DTE serial line interface. Each synchronous V11 DTE serial line interface corresponds, in fcfLineTable, to one instance of fcfLineType equal to 'synchronousV11Dte'. This is a decimal integer in the range 0 to 35.")
fcfLineV11DteIndication109 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 15, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notMonitored", 1), ("monitoredNotSignificant", 2), ("monitoredOff", 3), ("monitoredOn", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfLineV11DteIndication109.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV11DteIndication109.setDescription("The value of this object defines how the circuit 109 (I, indication) is monitored to eventually generate the corresponding event when its state changes and, when it is monitored, how it is scanned to determine whether this serial line interface is up or down. notMonitored : this circuit is not used, monitoredNotSignificant : this circuit is monitored (eventually events are generated) but it is not scanned to determine the state of this serial line interface, monitoredOff : this circuit is monitored (eventually events are generated) and it must be in the OFF condition to determine that this serial line interface is in the UP state, monitoredOn : this circuit is monitored (eventually events are generated) and it must be in the ON condition to determine that this serial line interface is in the UP state. The default value is 'monitoredOn'.")
fcfLineV11DteSyn = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 15, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notMonitored", 1), ("monitoredOff", 2), ("monitoredOn", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfLineV11DteSyn.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV11DteSyn.setDescription("The value of this object defines how the flags are checked to determine whether this serial line interface is up or down. notMonitored : the flags are not checked, monitoredOff : the flags are checked and they must be not present to determine that this serial line interface is in the UP state, monitoredOn : the flags are checked and they must be present to determine that this serial line interface is in the UP state. The default value is 'notMonitored'.")
fcfLineV11DceSignalTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 16), )
if mibBuilder.loadTexts: fcfLineV11DceSignalTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV11DceSignalTable.setDescription("This table defines how the incoming circuits are monitored and interpreted on synchronous V11 serial line interfaces when the equipment is a DCE. It is not possible to add or delete an entry of this table (each entry corresponds, in fcfLineTable, to one instance of fcfLineType equal to 'synchronousV11Dce').")
fcfLineV11DceSignalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 16, 1), ).setIndexNames((0, "PCE-MIB", "fcfLineV11DceInterfaceId"))
if mibBuilder.loadTexts: fcfLineV11DceSignalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV11DceSignalEntry.setDescription('An entry of fcfLineV11DceSignalTable.')
fcfLineV11DceInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 16, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcfLineV11DceInterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV11DceInterfaceId.setDescription("The value of this object identifies one and only one synchronous V11 DCE serial line interface. Each synchronous V11 DCE serial line interface corresponds, in fcfLineTable, to one instance of fcfLineType equal to 'synchronousV11Dce'. This is a decimal integer in the range 0 to 35.")
fcfLineV11DceControl105 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 16, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notMonitored", 1), ("monitoredNotSignificant", 2), ("monitoredOff", 3), ("monitoredOn", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfLineV11DceControl105.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV11DceControl105.setDescription("The value of this object defines how the circuit 105 (C, control) is monitored to eventually generate the corresponding event when its state changes and, when it is monitored, how it is scanned to determine whether this serial line interface is up or down. notMonitored : this circuit is not used, monitoredNotSignificant : this circuit is monitored (eventually events are generated) but it is not scanned to determine the state of this serial line interface, monitoredOff : this circuit is monitored (eventually events are generated) and it must be in the OFF condition to determine that this serial line interface is in the UP state, monitoredOn : this circuit is monitored (eventually events are generated) and it must be in the ON condition to determine that this serial line interface is in the UP state. The default value is 'monitoredOn'.")
fcfLineV11DceSyn = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 16, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notMonitored", 1), ("monitoredOff", 2), ("monitoredOn", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfLineV11DceSyn.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV11DceSyn.setDescription("The value of this object defines how the flags are checked to determine whether this serial line interface is up or down. notMonitored : the flags are not checked, monitoredOff : the flags are checked and they must be not present to determine that this serial line interface is in the UP state, monitoredOn : the flags are checked and they must be present to determine that this serial line interface is in the UP state. The default value is 'notMonitored'.")
fcfLineV35DteSignalTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 19), )
if mibBuilder.loadTexts: fcfLineV35DteSignalTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV35DteSignalTable.setDescription("This table defines how the incoming circuits are monitored and interpreted on V35 serial line interfaces when the equipment is a DTE. It is not possible to add or delete an entry of this table (each entry corresponds, in fcfLineTable, to one instance of fcfLineType equal to 'v35Dte').")
fcfLineV35DteSignalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 19, 1), ).setIndexNames((0, "PCE-MIB", "fcfLineV35DteInterfaceId"))
if mibBuilder.loadTexts: fcfLineV35DteSignalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV35DteSignalEntry.setDescription('An entry of fcfLineV35DteSignalTable.')
fcfLineV35DteInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 19, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcfLineV35DteInterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV35DteInterfaceId.setDescription("The value of this object identifies one and only one V35 DTE serial line interface. Each V35 DTE serial line interface corresponds, in fcfLineTable, to one instance of fcfLineType equal to 'v35Dte'. This is a decimal integer in the range 0 to 35.")
fcfLineV35DteD106 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 19, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notMonitored", 1), ("monitoredNotSignificant", 2), ("monitoredOff", 3), ("monitoredOn", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfLineV35DteD106.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV35DteD106.setDescription("The value of this object defines how the circuit 106 (pin D, ready fo sending) is monitored to eventually generate the corresponding event when its state changes and, when it is monitored, how it is scanned to determine whether this serial line interface is up or down. notMonitored : this circuit is not used, monitoredNotSignificant : this circuit is monitored (eventually events are generated) but it is not scanned to determine the state of this serial line interface, monitoredOff : this circuit is monitored (eventually events are generated) and it must be in the OFF condition to determine that this serial line interface is in the UP state, monitoredOn : this circuit is monitored (eventually events are generated) and it must be in the ON condition to determine that this serial line interface is in the UP state. The default value is 'monitoredOn'.")
fcfLineV35DteE107 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 19, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notMonitored", 1), ("monitoredNotSignificant", 2), ("monitoredOff", 3), ("monitoredOn", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfLineV35DteE107.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV35DteE107.setDescription("The value of this object defines how the circuit 107 (pin E, data set ready) is monitored to eventually generate the corresponding event when its state changes and, when it is monitored, how it is scanned to determine whether this serial line interface is up or down. notMonitored : this circuit is not used, monitoredNotSignificant : this circuit is monitored (eventually events are generated) but it is not scanned to determine the state of this serial line interface, monitoredOff : this circuit is monitored (eventually events are generated) and it must be in the OFF condition to determine that this serial line interface is in the UP state, monitoredOn : this circuit is monitored (eventually events are generated) and it must be in the ON condition to determine that this serial line interface is in the UP state. The default value is 'notMonitored'.")
fcfLineV35DteF109 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 19, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notMonitored", 1), ("monitoredNotSignificant", 2), ("monitoredOff", 3), ("monitoredOn", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfLineV35DteF109.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV35DteF109.setDescription("The value of this object defines how the circuit 109 (pin F, data channel received line signal detector) is monitored to eventually generate the corresponding event when its state changes and, when it is monitored, how it is scanned to determine whether this serial line interface is up or down. notMonitored : this circuit is not used, monitoredNotSignificant : this circuit is monitored (eventually events are generated) but it is not scanned to determine the state of this serial line interface, monitoredOff : this circuit is monitored (eventually events are generated) and it must be in the OFF condition to determine that this serial line interface is in the UP state, monitoredOn : this circuit is monitored (eventually events are generated) and it must be in the ON condition to determine that this serial line interface is in the UP state. The default value is 'monitoredOn'.")
fcfLineV35DteTi142 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 19, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notMonitored", 1), ("monitoredNotSignificant", 2), ("monitoredOff", 3), ("monitoredOn", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfLineV35DteTi142.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV35DteTi142.setDescription("The value of this object defines how the circuit 142 (pin NN, test indicator) is monitored to eventually generate the corresponding event when its state changes and, when it is monitored, how it is scanned to determine whether this serial line interface is up or down. notMonitored : this circuit is not used, monitoredNotSignificant : this circuit is monitored (eventually events are generated) but it is not scanned to determine the state of this serial line interface, monitoredOff : this circuit is monitored (eventually events are generated) and it must be in the OFF condition to determine that this serial line interface is in the UP state, monitoredOn : this circuit is monitored (eventually events are generated) and it must be in the ON condition to determine that this serial line interface is in the UP state. The default value is 'notMonitored'.")
fcfLineV35DteSyn = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 19, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notMonitored", 1), ("monitoredOff", 2), ("monitoredOn", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfLineV35DteSyn.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV35DteSyn.setDescription("The value of this object defines how the flags are checked to determine whether this serial line interface is up or down. notMonitored : the flags are not checked, monitoredOff : the flags are checked and they must be not present to determine that this serial line interface is in the UP state, monitoredOn : the flags are checked and they must be present to determine that this serial line interface is in the UP state. The default value is 'monitoredOn'..")
fcfLineV35DceSignalTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 20), )
if mibBuilder.loadTexts: fcfLineV35DceSignalTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV35DceSignalTable.setDescription("This table defines how the incoming circuits are monitored and interpreted on V35 serial line interfaces when the equipment is a DCE. It is not possible to add or delete an entry of this table (each entry corresponds, in fcfLineTable, to one instance of fcfLineType equal to 'v35Dce').")
fcfLineV35DceSignalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 20, 1), ).setIndexNames((0, "PCE-MIB", "fcfLineV35DceInterfaceId"))
if mibBuilder.loadTexts: fcfLineV35DceSignalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV35DceSignalEntry.setDescription('An entry of fcfLineV35DceSignalTable.')
fcfLineV35DceInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 20, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcfLineV35DceInterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV35DceInterfaceId.setDescription("The value of this object identifies one and only one V35 DCE serial line interface. Each V35 DCE serial line interface corresponds, in fcfLineTable, to one instance of fcfLineType equal to 'v35Dce'. This is a decimal integer in the range 0 to 35.")
fcfLineV35DceC105 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 20, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notMonitored", 1), ("monitoredNotSignificant", 2), ("monitoredOff", 3), ("monitoredOn", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfLineV35DceC105.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV35DceC105.setDescription("The value of this object defines how the circuit 105 (pin C, request to send) is monitored to eventually generate the corresponding event when its state changes and, when it is monitored, how it is scanned to determine whether this serial line interface is up or down. notMonitored : this circuit is not used, monitoredNotSignificant : this circuit is monitored (eventually events are generated) but it is not scanned to determine the state of this serial line interface, monitoredOff : this circuit is monitored (eventually events are generated) and it must be in the OFF condition to determine that this serial line interface is in the UP state, monitoredOn : this circuit is monitored (eventually events are generated) and it must be in the ON condition to determine that this serial line interface is in the UP state. The default value is 'monitoredOn'.")
fcfLineV35DceH108 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 20, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notMonitored", 1), ("monitoredNotSignificant", 2), ("monitoredOff", 3), ("monitoredOn", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfLineV35DceH108.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV35DceH108.setDescription("The value of this object defines how the circuit 108 (pin H, 108/1 connect data set to line, 108/2 data terminal ready) is monitored to eventually generate the corresponding event when its state changes and, when it is monitored, how it is scanned to determine whether this serial line interface is up or down. notMonitored : this circuit is not used, monitoredNotSignificant : this circuit is monitored (eventually events are generated) but it is not scanned to determine the state of this serial line interface, monitoredOff : this circuit is monitored (eventually events are generated) and it must be in the OFF condition to determine that this serial line interface is in the UP state, monitoredOn : this circuit is monitored (eventually events are generated) and it must be in the ON condition to determine that this serial line interface is in the UP state. The default value is 'monitoredOn'.")
fcfLineV35DceRil140 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 20, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notMonitored", 1), ("monitoredNotSignificant", 2), ("monitoredOff", 3), ("monitoredOn", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfLineV35DceRil140.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV35DceRil140.setDescription("The value of this object defines how the circuit 140 (pin N, loopback / maintenance test) is monitored to eventually generate the corresponding event when its state changes and, when it is monitored, how it is scanned to determine whether this serial line interface is up or down. notMonitored : this circuit is not used, monitoredNotSignificant : this circuit is monitored (eventually events are generated) but it is not scanned to determine the state of this serial line interface, monitoredOff : this circuit is monitored (eventually events are generated) and it must be in the OFF condition to determine that this serial line interface is in the UP state, monitoredOn : this circuit is monitored (eventually events are generated) and it must be in the ON condition to determine that this serial line interface is in the UP state. The default value is 'notMonitored'.")
fcfLineV35DceLl141 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 20, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notMonitored", 1), ("monitoredNotSignificant", 2), ("monitoredOff", 3), ("monitoredOn", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfLineV35DceLl141.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV35DceLl141.setDescription("The value of this object defines how the circuit 141 (pin L, local loopback) is monitored to eventually generate the corresponding event when its state changes and, when it is monitored, how it is scanned to determine whether this serial line interface is up or down. notMonitored : this circuit is not used, monitoredNotSignificant : this circuit is monitored (eventually events are generated) but it is not scanned to determine the state of this serial line interface, monitoredOff : this circuit is monitored (eventually events are generated) and it must be in the OFF condition to determine that this serial line interface is in the UP state, monitoredOn : this circuit is monitored (eventually events are generated) and it must be in the ON condition to determine that this serial line interface is in the UP state. The default value is 'notMonitored'.")
fcfLineV35DceSyn = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 20, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notMonitored", 1), ("monitoredOff", 2), ("monitoredOn", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfLineV35DceSyn.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineV35DceSyn.setDescription("The value of this object defines how the flags are checked to determine whether this serial line interface is up or down. notMonitored : the flags are not checked, monitoredOff : the flags are checked and they must be not present to determine that this serial line interface is in the UP state, monitoredOn : the flags are checked and they must be present to determine that this serial line interface is in the UP state. The default value is 'monitoredOn'.")
fcfLineModem = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 30))
fcfLineModemTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 30, 1), )
if mibBuilder.loadTexts: fcfLineModemTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineModemTable.setDescription("This table defines, for each serial line interface facing to a modem, how this modem is managed. It is not possible to add or delete an entry of this table (each entry corresponds, in fcfLineTable, to one instance of fcfLineModemManagement equal to 'on').")
fcfLineModemEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 30, 1, 1), ).setIndexNames((0, "PCE-MIB", "fcfLineModInterfaceId"))
if mibBuilder.loadTexts: fcfLineModemEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineModemEntry.setDescription('An entry of fcfLineModemTable.')
fcfLineModInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 30, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcfLineModInterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineModInterfaceId.setDescription("The value of this object identifies one and only one serial line interface facing to a modem. Each of these serial line interfaces corresponds, in fcfLineTable, to one instance of fcfLineModemManagement equal to 'on'. This is a decimal integer in the range 0 to 35.")
fcfLineModType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 30, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("direct", 1), ("addressedAt", 2), ("addressedV25Bis", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfLineModType.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineModType.setDescription("The value of this object defines how the automatic calling and/or answering data stations is operated on this serial line interface : direct : The 'direct call and/or answer controlled by the DTE (circuit 108/1)' mode gives to the equipment (in DTE mode) the capacity of calling a number pre-recorded in the modem (in DCE mode), by means of the 108/1 control circuit. It gives also to the equipment the capacity of accepting incoming calls on a'per call' basis. addressedAt : The 'addressed call and/or answer authorized by the DTE (circuit 108/2)' mode gives to the equipment (in DTE mode) extensive facilities by means of instructions exchanged between the DTE and the DCE on circuits 103 (transmitted data) and 104 (received data). It gives also to the equipment the capacity to accept 'a priori' an incoming call. The commands / indications use the AT format. addressedV25Bis : The 'addressed call and/or answer authorized by the DTE (circuit 108/2)' mode gives to the equipment (in DTE mode) extensive facilities by means of instructions exchanged between the DTE and the DCE on circuits 103 (transmitted data) and 104 (received data). It gives also to the equipment the capacity to accept 'a priori' an incoming call. The commands / indications use the ITU-T V.25 bis recommendation format. The default value is 'addressedV25Bis'.")
fcfLineModLinkUpTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 30, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 250))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfLineModLinkUpTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineModLinkUpTimer.setDescription("The value of this object is the management timer in seconds for this serial line interface. It starts when the first call request is sent to the modem and it is normally stopped when the serial line interface is 'up'. The serial line interface state is set to 'down' when this timer runs out. The value of this timer must be larger than the total duration of the successive dialling attempts to not interrupt this processing (see fcfLineModNewDiallingTimer and fcfLineModDiallingCount). This is a decimal integer in the range 1 to 250. The default value is '180'.")
fcfLineModNewDiallingTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 30, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2500))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfLineModNewDiallingTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineModNewDiallingTimer.setDescription("The value of this object is the dialling timer in seconds for this serial line interface. It starts when a call request is sent to the modem and it is normally stopped when the call is successfull or when the modem answers with an error message. The call request is sent again when this timer runs out. After transmission of the call request fcfLineModDiallingCount times the serial line interface state is set to 'down'. This is a decimal integer in the range 0 to 2500 by step of 10. The default value is '30'.")
fcfLineModDiallingCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 30, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 250))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfLineModDiallingCount.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineModDiallingCount.setDescription("The value of this object is the maximum number of attempts to complete a sucessfull call for this serial line interface. A new call request is sent to the modem when fcfLineModNewDiallingTimer runs out. This is a decimal integer in the range 0 to 250. The default value is '3'.")
fcfLineModUnuseTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 30, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 254))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfLineModUnuseTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineModUnuseTimer.setDescription("The value of this object is the unuse timer in seconds for this serial line interface. This function is specified in order to clear a call when no communications are established on it. This timer starts upon the clearing of the last communication using this call and it is normally stopped when a new one is initiated. The equipment clears the call when this timer runs out. The value '0' disables the processing of this timer. This is a decimal integer in the range 0 to 250 by step of 10. The default value is '10'.")
fcfLineModSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 30, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 9, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("s150", 1), ("s300", 2), ("s600", 3), ("s1200", 4), ("s2400", 5), ("s4800", 9), ("s9600", 11), ("s19200", 12), ("s28800", 13), ("s38400", 14), ("s57600", 15), ("s115200", 16)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfLineModSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineModSpeed.setDescription("The value of this object indicates the speed in bits per second used between the equipment and the modem for this serial line interface. The other characteristics of this communication are : no parity, one stop bit, eight bits per character. The default value is 's9600'.")
fcfLineModCallDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 30, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 2, 1))).clone(namedValues=NamedValues(("calling", 3), ("called", 2), ("auto", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfLineModCallDirection.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineModCallDirection.setDescription("The value of this object defines the mode used to establish the connection with the remote system for this serial line interface : calling : the caller is the equipment, called : the caller is the remote system, auto : automatic choise between 'calling' and 'called' (not accepted when fcfLineModType is set to 'direct'). The default value is 'auto'.")
fcfLineModInitString = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 30, 1, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 50))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfLineModInitString.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineModInitString.setDescription("The value of this object is a characters string sent by the equipment to the modem when the state of this serial line interface becomes 'up'. This is a 0 to 50 ASCII characters string. The default value is the empty string.")
fcfLineModOutputXidString = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 30, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfLineModOutputXidString.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineModOutputXidString.setDescription("The value of this object indicates, for this serial line interface, whether an XID string is sent by the equipment or not prior to the estblishment of any virtual call (exchange identification procedure). This XID string is defined by fcfLineModOutputXidStringId. This mechanism may be enabled only when this serial line interface is used by the X25 protocol. The default value is 'off'.")
fcfLineModOutputXidStringId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 30, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfLineModOutputXidStringId.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineModOutputXidStringId.setDescription("The value of this object indicates, for this serial line interface, which XID string will be sent by the equipment prior to the estblishment of any virtual call (exchange identification procedure). This XID string is defined in fcfLineModXidStringTable. This is a decimal integer in the range 0 to 3. The default value is '255' meaning 'empty value' (blank value on the equipment configurator).")
fcfLineModInputXidString = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 30, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfLineModInputXidString.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineModInputXidString.setDescription("The value of this object indicates, for this serial line interface, whether an XID string will be received by the equipment or not prior to the estblishment of any virtual call (exchange identification procedure). If yes fcfLineModInputXidStringCount defines how many XID strings will be received. This mechanism may be enabled only when this serial line interface is used by the X25 protocol. The default value is 'off'.")
fcfLineModInputXidStringCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 30, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 250))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfLineModInputXidStringCount.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineModInputXidStringCount.setDescription("The value of this object defines, for this serial line interface, how many XID strings will be received by the equipment prior to the estblishment of any virtual call (exchange identification procedure) if this mechanism is enabled (see fcfLineModInputXidString). This is a decimal integer in the range 0 to 250. The default value is '1'.")
fcfLineModXidStringTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 30, 2), )
if mibBuilder.loadTexts: fcfLineModXidStringTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineModXidStringTable.setDescription("This table contains the XID strings that are sent by the equipment prior to the estblishment of any virtual call (exchange identification procedure) on serial line interfaces according to fcfLineModOutputXidString. An XID string, identified by fcfLineModXidStringId, is the concatenation, in ascending order of fcfLineModXidStringEltNum, of 1 to 4 elements of 0 to 32 bytes. Set any writable object(s) of this table to valid value(s) with a new index value to create an entry (the objects of the entry not present in this SET REQUEST will take their default values). Set fcfLineModXidStringEltStatus to 'invalid' to delete an entry.")
fcfLineModXidStringEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 30, 2, 1), ).setIndexNames((0, "PCE-MIB", "fcfLineModXidStringId"), (0, "PCE-MIB", "fcfLineModXidStringEltNum"))
if mibBuilder.loadTexts: fcfLineModXidStringEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineModXidStringEntry.setDescription('An entry of fcfLineModXidStringTable.')
fcfLineModXidStringId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 30, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcfLineModXidStringId.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineModXidStringId.setDescription('The value of this object identifies one and only one XID string which is sent by the equipment prior to the estblishment of any virtual call (exchange identification procedure) on serial line interfaces according to fcfLineModOutputXidString. This XID string is the concatenation, in ascending order of fcfLineModXidStringEltNum, of 1 to 4 elements of 0 to 32 bytes. This is a decimal integer in the range 0 to 3.')
fcfLineModXidStringEltNum = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 30, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcfLineModXidStringEltNum.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineModXidStringEltNum.setDescription('The value of this object identifies one and only one element of this XID string. The whole XID string is the concatenation, in ascending order of this value, of all of its elements. This is a decimal integer in the range 1 to 4.')
fcfLineModXidStringEltStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 30, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfLineModXidStringEltStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineModXidStringEltStatus.setDescription("The value of this object indicates the state of the entry of this table. It must be set to 'invalid' to delete the entry. The default value is 'valid'.")
fcfLineModXidStringElement = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 30, 2, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(33, 33)).setFixedLength(33)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfLineModXidStringElement.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineModXidStringElement.setDescription("The value of this object contains the bytes of this element of this XID string. The whole XID string is the concatenation, in ascending order of fcfLineModXidStringEltNum, of all of its elements. This is a thirty-three-bytes octet string with up to 66 digits in the range 0 to F. The first byte contains the number of following useful bytes. It must be padded with 'F' digits for a total of 66 digits. The equipment configurator does not need this final padding neither the first byte (which is automatically updated). The default value is 'empty' : first byte set to '00', others set to 'FF' (blank value on the equipment configurator).")
fcfLineDVBTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 31), )
if mibBuilder.loadTexts: fcfLineDVBTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineDVBTable.setDescription('')
fcfLineDVBEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 31, 1), ).setIndexNames((0, "PCE-MIB", "fcfLineDVBInterfaceId"))
if mibBuilder.loadTexts: fcfLineDVBEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineDVBEntry.setDescription('An entry of fcfLineDVBTable.')
fcfLineDVBInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 31, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcfLineDVBInterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineDVBInterfaceId.setDescription('IF id')
fcfLineDVBStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 31, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfLineDVBStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineDVBStatus.setDescription('Status')
fcfLineDVBConnection = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 2, 31, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("lsForDvb1", 2), ("lsForDvb2", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfLineDVBConnection.setStatus('mandatory')
if mibBuilder.loadTexts: fcfLineDVBConnection.setDescription('Link with DVB')
fcfIsdn = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 5))
fcfIsdnBasicRateInterfaceTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 5, 1), )
if mibBuilder.loadTexts: fcfIsdnBasicRateInterfaceTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcfIsdnBasicRateInterfaceTable.setDescription("This table defines the characteristics of the integrated services digital network (ISDN) basic rate interfaces (BRI). It is not possible to add or delete an entry of this table (each entry corresponds, in fcfPhysicalPortTable, to one instance of fcfInterfaceType equal to 'isdnDChannel').")
fcfIsdnBasicRateInterfaceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 5, 1, 1), ).setIndexNames((0, "PCE-MIB", "fcfIsdnBasicRateInterfaceId"))
if mibBuilder.loadTexts: fcfIsdnBasicRateInterfaceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcfIsdnBasicRateInterfaceEntry.setDescription('An entry of fcfIsdnBasicRateInterfaceTable.')
fcfIsdnBasicRateInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcfIsdnBasicRateInterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: fcfIsdnBasicRateInterfaceId.setDescription("The value of this object identifies one and only one integrated services digital network (ISDN) basic rate interface (BRI). Each ISDN BRI corresponds, in fcfPhysicalPortTable, to one instance of fcfInterfaceType equal to 'isdnDChannel' or 'isdnBri'. This is a decimal integer in the range 0 to 35.")
fcfIsdnBriSignalling = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfIsdnBriSignalling.setStatus('mandatory')
if mibBuilder.loadTexts: fcfIsdnBriSignalling.setDescription("The value of this object indicates, for this basic rate interface, whether signalling is enabled or not. It must be set to 'on' to use the B-channels. The default value is 'on'.")
fcfIsdnBriCountry = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 5, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("franceVn2", 1), ("franceVn3", 2), ("unitedKingdom", 3), ("switzerland", 4), ("europeanIsdn", 5), ("japan", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfIsdnBriCountry.setStatus('mandatory')
if mibBuilder.loadTexts: fcfIsdnBriCountry.setDescription("The value of this object permits to take into account the national characteristics of some ISDN implementations : franceVn2 : France VN 2 implementation, franceVn3 : France VN 3 implementation, franceVn4 : France VN 4 implementation, unitedKingdom : France VN 2 implementation, switzerland : Switzerland implementation, europeanIsdn : Europe implementation. japan : japan implementation. usa : usa implementation. The default value is 'europeanIsdn'.")
fcfIsdnBriInterfaceCheckPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 5, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 51000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfIsdnBriInterfaceCheckPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: fcfIsdnBriInterfaceCheckPeriod.setDescription("The value of this object indicates a period in milliseconds of detection of power source 1 or power source 2, whichever may be provided for this basic rate interface. The power source is checked every fcfIsdnBriInterfaceCheckPeriod milliseconds and when it changes and remains changed after fcfIsdnBriFilterRepeatCount checkings, this new state is delivered to the upper level. This is a decimal integer in the range 0 to 51000 by step of 200. The default value is '200'.")
fcfIsdnBriFilterRepeatCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 5, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfIsdnBriFilterRepeatCount.setStatus('mandatory')
if mibBuilder.loadTexts: fcfIsdnBriFilterRepeatCount.setDescription("The value of this object indicates the number of detections of power source 1 or power source 2, whichever may be provided for this basic rate interface. The power source is checked every fcfIsdnBriInterfaceCheckPeriod milliseconds and when it changes and remains changed after fcfIsdnBriFilterRepeatCount checkings, this new state is delivered to the upper level. This is a decimal integer in the range 0 to 255. The default value is '2'.")
fcfIsdnBriEnablingTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 5, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(200, 30000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfIsdnBriEnablingTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fcfIsdnBriEnablingTimer.setDescription("The value of this object is the activation timer in milliseconds for this basic rate interface (timer 3). The deactivation function is specified in order to permit this interface and the network-side interface to be placed in a low power consumption mode when no calls are in progress. This timer starts upon the reception of an ACTIVATE REQUEST by the layer 1 and it is normally stopped when the ACTIVATED state is reached. The equipment sends DEACTIVATE INDICATIONS when this timer runs out This is a decimal integer in the range 200 to 30000 by step of 200. The default value is '10000'.")
fcfIsdnBriDisablingTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 5, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfIsdnBriDisablingTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fcfIsdnBriDisablingTimer.setDescription("The value of this object is the deactivation delay in milliseconds for this basic rate interface. The deactivation function is specified in order to permit this interface and the network-side interface to be placed in a low power consumption mode when no calls are in progress. The layer 2 is informed of the reception of an DEACTIVATE INDICATION by the layer 1 when this delay runs out. This is a decimal integer in the range 0 to 1000 by step of 200. The default value is '600'.")
fcfIsdnPrimaryRateInterfaceTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 5, 2), )
if mibBuilder.loadTexts: fcfIsdnPrimaryRateInterfaceTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcfIsdnPrimaryRateInterfaceTable.setDescription('')
fcfIsdnPrimaryRateInterfaceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 5, 2, 1), ).setIndexNames((0, "PCE-MIB", "fcfIsdnPrimaryRateInterfaceId"))
if mibBuilder.loadTexts: fcfIsdnPrimaryRateInterfaceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcfIsdnPrimaryRateInterfaceEntry.setDescription('An entry of fcfIsdnPrimaryRateInterfaceTable.')
fcfIsdnPrimaryRateInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 5, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcfIsdnPrimaryRateInterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: fcfIsdnPrimaryRateInterfaceId.setDescription("The value of this object identifies one and only one integrated services digital network (ISDN) primary rate interface (PRI). Each ISDN PRI corresponds, in fcfPhysicalPortTable, to one instance of fcfInterfaceType equal to 'isdnPri'. This is a decimal integer in the range 0 to 35.")
fcfIsdnPriSignalling = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 5, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfIsdnPriSignalling.setStatus('mandatory')
if mibBuilder.loadTexts: fcfIsdnPriSignalling.setDescription("The value of this object indicates, for this primary rate interface, whether signalling is enabled or not. It must be set to 'on' to use the B-channels. The default value is 'on'.")
fcfIsdnPriCountry = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 5, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("franceVn2", 1), ("franceVn3", 2), ("unitedKingdom", 3), ("switzerland", 4), ("europeanIsdn", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfIsdnPriCountry.setStatus('mandatory')
if mibBuilder.loadTexts: fcfIsdnPriCountry.setDescription("The value of this object permits to take into account the national characteristics of some ISDN implementations : franceVn2 : France VN 2 implementation, franceVn3 : France VN 3 implementation, franceVn4 : France VN 4 implementation, unitedKingdom : France VN 2 implementation, switzerland : Switzerland implementation, europeanIsdn : Europe implementation. japan : japan implementation. usa : usa implementation. The default value is 'europeanIsdn'.")
fcfIsdnPriINbBChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 5, 2, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfIsdnPriINbBChannel.setStatus('mandatory')
if mibBuilder.loadTexts: fcfIsdnPriINbBChannel.setDescription("The value of this object is the number of B channels for this ISDN primary rate interface. This is a decimal integer in the range 0 to 30 by step of 1. The default value is '30'.")
fcfIsdnPriCrc4 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 5, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfIsdnPriCrc4.setStatus('mandatory')
if mibBuilder.loadTexts: fcfIsdnPriCrc4.setDescription("The value of this object indicates, for this primary rate interface, whether cyclic redundancy code management is enabled or not. The default value is 'off'.")
fcfIsdnDChannelSignallingTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 5, 10), )
if mibBuilder.loadTexts: fcfIsdnDChannelSignallingTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcfIsdnDChannelSignallingTable.setDescription("This table defines the signalling characteristics of the integrated services digital network (ISDN) basic rate interfaces (BRI). It is not possible to add or delete an entry of this table (each entry corresponds, in fcfIsdnBasicRateInterfaceTable, to one instance of fcfIsdnBriSignalling equal to 'on').")
fcfIsdnDChannelSignallingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 5, 10, 1), ).setIndexNames((0, "PCE-MIB", "fcfIsdnDSigIsdnInterfaceId"))
if mibBuilder.loadTexts: fcfIsdnDChannelSignallingEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcfIsdnDChannelSignallingEntry.setDescription('An entry of fcfIsdnDChannelSignallingTable.')
fcfIsdnDSigIsdnInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 5, 10, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcfIsdnDSigIsdnInterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: fcfIsdnDSigIsdnInterfaceId.setDescription("The value of this object identifies one and only one integrated services digital network (ISDN) basic rate interface (BRI) with signalling procedures. Each ISDN BRI corresponds, in fcfIsdnBasicRateInterfaceTable, to one instance of fcfIsdnBriSignalling equal to 'on'. This is a decimal integer in the range 0 to 35.")
fcfIsdnDSigIsdnNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 5, 10, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(11, 11)).setFixedLength(11)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfIsdnDSigIsdnNumber.setStatus('mandatory')
if mibBuilder.loadTexts: fcfIsdnDSigIsdnNumber.setDescription("The value of this object indicates the ISDN address (the ISDN number and the optional subaddress) of this basic rate interface. This is a eleven-bytes octet string with : up to 16 digits in the range 0 to 9 for the ISDN number, an optional separator marking the end of the ISDN number and the beginning of the ISDN subaddress : digit 'A' (':' on the equipment configurator), optional 1 to 4 digits in the range 0 to 9 for the ISDN subaddress, mandatory 'F' digits to pad the value until a total of 22 digits (the equipment configurator does not need this final padding). The default value is 'FF FF FF FF FF FF FF FF FF FF FF' meaning 'empty value' (blank value on the equipment configurator).")
fcfIsdnDSigUnuseTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 5, 10, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2550))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfIsdnDSigUnuseTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fcfIsdnDSigUnuseTimer.setDescription("The value of this object is the unuse timer in seconds for this basic rate interface. This function is specified in order to clear a call when no communications are established on it. This timer starts upon the clearing of the last communication using this call and it is normally stopped when a new one is initiated. The equipment clears the call when this timer runs out. The value '0' disables the processing of this timer. This is a decimal integer in the range 0 to 2550 by step of 10. The default value is '10'.")
fcfIsdnDSigCalledSubAddressCheck = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 5, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfIsdnDSigCalledSubAddressCheck.setStatus('mandatory')
if mibBuilder.loadTexts: fcfIsdnDSigCalledSubAddressCheck.setDescription("The value of this object indicates, for this basic rate interface, whether ISDN subaddresses are checked or not. When it is set to 'on' the incoming calls are cleared if the called party subaddress is not present in the SETUP message. The default value is 'off'.")
fcfIsdnDSigDirectInwardDialingCheck = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 5, 10, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfIsdnDSigDirectInwardDialingCheck.setStatus('mandatory')
if mibBuilder.loadTexts: fcfIsdnDSigDirectInwardDialingCheck.setDescription("The value of this object indicates, for this basic rate interface, whether the direct dialling-in (DDI) service is used or not. When the direct dialling-in is in use, this basic rate interface accepts only the incoming calls with the called party number equal to its own ISDN number defined by fcfIsdnDSigIsdnNumber (the ISDN subaddress is not concerned). The default value is 'off'.")
fcfIsdnDSigInactivityTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 5, 10, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 120))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfIsdnDSigInactivityTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fcfIsdnDSigInactivityTimer.setDescription("The value of this object is the inactivity timer in seconds for this basic rate interface. This timer starts upon the establishment of the call and it restarts at each expiry if no trafic has been using it during this period.. The value '0' disables the processing of this timer. This is a decimal integer in the range 0 to 120. The default value is '0'.")
fcfIsdnDSigMulDialsRetryTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 5, 10, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 254))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfIsdnDSigMulDialsRetryTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fcfIsdnDSigMulDialsRetryTimer.setDescription("The value of this object is the retry timer in seconds for this basic rate interface. To reach a particular destination the equipment may successively try one or several times to call one remote ISDN interfaces. This timer starts when a call is initiated towards a particular remote ISDN interface and it is normally stopped when this call is successfull. A new call towards this remote ISDN interface is initated when this timer runs out. This is a decimal integer in the range 1 to 254. The default value is '5'.")
fcfIsdnDSigMulDialsCycleTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 5, 10, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 254))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfIsdnDSigMulDialsCycleTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fcfIsdnDSigMulDialsCycleTimer.setDescription("The value of this object is the cycle timer in seconds for this basic rate interface. To reach a particular destination the equipment may successively try one or several times to call one or several remote ISDN interfaces. This is a cycle of calls and there may be several identical cycles. The cycle timer starts when a cycle of calls is initiated and it is normally stopped when one call is successfull. A new cycle of calls is initated when this timer runs out. This is a decimal integer in the range 1 to 254. The default value is '10'.")
fcfIsdnDSigMulDialsCycleCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 5, 10, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfIsdnDSigMulDialsCycleCount.setStatus('mandatory')
if mibBuilder.loadTexts: fcfIsdnDSigMulDialsCycleCount.setDescription("The value of this object is the maximum number of cycle of calls for this basic rate interface. To reach a particular destination the equipment may successively try one or several times to call one or several remote ISDN interfaces. This is a cycle of calls and there may be several identical cycles. This is a decimal integer in the range 1 to 255. The default value is '3'.")
fcfIsdnDSigMulDialsTotalDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 5, 10, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfIsdnDSigMulDialsTotalDuration.setStatus('mandatory')
if mibBuilder.loadTexts: fcfIsdnDSigMulDialsTotalDuration.setDescription("The value of this object is, for this basic rate interface, the maximum duration in seconds of successive tries to reach a destination. To reach a particular destination the equipment may successively try one or several times to call one or several remote ISDN interfaces. This is a cycle of calls and there may be several identical cycles. This timer starts when the first cycle of calls is initiated and it is normally stopped when one call is successfull. If this timer runs out the destination is said unreachable. This is a decimal integer in the range 5 to 100. The default value is '100'.")
fcfIsdnDSigLowLayerCompatibility = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 5, 10, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notTransmittedAndNotChecked", 1), ("transmittedAndNotChecked", 2), ("notTransmittedAndChecked", 3), ("transmittedAndChecked", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfIsdnDSigLowLayerCompatibility.setStatus('mandatory')
if mibBuilder.loadTexts: fcfIsdnDSigLowLayerCompatibility.setDescription("The value of this object indicates whether the low layer compatibility information element (LLC IE) is present or not in the CONNECT and SETUP call establishment messages sent from this basic rate interface (outgoing call) and whether it is checked or not in the same messages received by this basic rate interface (incoming call). The checking of LLC IE in the incoming calls is made as described below : the coding standard must be set to 'CCITT standardized coding', the information transfer capability must be set to 'unrestricted digital information', the transfer mode must be set to 'circuit mode', the information transfer rate must be set to '64 kbit/s', the user information layer 1 protocol must be set to 'CCITT standardized rate adaption X.31 HDLC flag stuffing', the user information layer 2 protocol must be set to 'CCITT Recommendation X.25 link layer' or 'CCITT Recommendation X.25 multilink', the user information layer 3 protocol must be set to 'CCITT Recommendation X.25 packet layer', the other octets of the LLC IE are not checked, This object may be set to one of the following values : notTransmittedAndNotChecked : the LLC IE is not present in the outgoing calls and it is not checked in the incoming calls, transmittedAndNotChecked : the LLC IE is present in the outgoing calls and it is not checked in the incoming calls, notTransmittedAndChecked : the LLC IE is not present in the outgoing calls and it is checked in the incoming calls, transmittedAndChecked : the LLC IE is present in the outgoing calls and it is checked in the incoming calls. The default value is 'notTransmittedAndChecked'.")
fcfIsdnDSigHighLayerCompatibility = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 5, 10, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notTransmittedAndNotChecked", 1), ("transmittedAndNotChecked", 2), ("notTransmittedAndChecked", 3), ("transmittedAndChecked", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfIsdnDSigHighLayerCompatibility.setStatus('mandatory')
if mibBuilder.loadTexts: fcfIsdnDSigHighLayerCompatibility.setDescription("The value of this object indicates whether the high layer compatibility information element (HLC IE) is present or not in the SETUP call establishment messages sent from this basic rate interface (outgoing call) and whether it is checked or not in the same messages received by this basic rate interface (incoming call). The checking of HLC IE in the incoming calls consists in verifying that the HLC IE is equal to the value of fcfIsdnDSigHighLayerCharactIdent. This object may be set to one of the following values : notTransmittedAndNotChecked : the HLC IE is not present in the outgoing calls and it is not checked in the incoming calls, transmittedAndNotChecked : the HLC IE is present in the outgoing calls and it is not checked in the incoming calls, notTransmittedAndChecked : the HLC IE is not present in the outgoing calls and it is checked in the incoming calls, transmittedAndChecked : the HLC IE is present in the outgoing calls and it is checked in the incoming calls. The default value is 'notTransmittedAndChecked'.")
fcfIsdnDSigHighLayerCharactIdent = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 5, 10, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(193, 128, 255))).clone(namedValues=NamedValues(("ccittOsiApplication", 193), ("nationalUnknownNetworkedService", 128), ("nationalNotStandardizedApplication", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfIsdnDSigHighLayerCharactIdent.setStatus('mandatory')
if mibBuilder.loadTexts: fcfIsdnDSigHighLayerCharactIdent.setDescription("The value of this object indicates the value of the high layer compatibility information element (HLC IE) which must be present in the SETUP call establishment messages received by this basic rate interface (incoming call) when the checking is enabled (see fcfIsdnDSigHighLayerCompatibility) : ccittOsiApplication : the coding standard must be set to 'CCITT standardized coding', the interpretation must be set to 'first (primary only) high layer characteristics identification to be used in the call', the presentation method of protocol profile must be set to 'high layer protocol profile (without specification of attributes)', the high layer characteristics identification must be set to 'OSI application (recommendation X.200 series)', nationalUnknownNetworkedService : the coding standard must be set to 'national standard (only when the desired HLC cannot be represented with the CCITT-standardized coding)', the interpretation must be set to 'first (primary only) high layer characteristics identification to be used in the call', the presentation method of protocol profile must be set to 'high layer protocol profile (without specification of attributes)', the high layer characteristics identification must be set to 'unknown networked service', nationalNotStandardizedApplication : the coding standard must be set to 'national standard (only when the desired HLC cannot be represented with the CCITT-standardized coding)', the interpretation must be set to 'first (primary only) high layer characteristics identification to be used in the call', the presentation method of protocol profile must be set to 'high layer protocol profile (without specification of attributes)', the high layer characteristics identification must be set to 'not standardized application', The default value is 'notTransmittedAndChecked'.")
fcfIsdnDChannelSigTimerTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 5, 11), )
if mibBuilder.loadTexts: fcfIsdnDChannelSigTimerTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcfIsdnDChannelSigTimerTable.setDescription("This table defines the signalling timers of the integrated services digital network (ISDN) basic rate interfaces (BRI). It is not possible to add or delete an entry of this table (each entry corresponds, in fcfIsdnBasicRateInterfaceTable, to one instance of fcfIsdnBriSignalling equal to 'on').")
fcfIsdnDChannelSigTimerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 5, 11, 1), ).setIndexNames((0, "PCE-MIB", "fcfIsdnDTimIsdnInterfaceId"))
if mibBuilder.loadTexts: fcfIsdnDChannelSigTimerEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcfIsdnDChannelSigTimerEntry.setDescription('An entry of fcfIsdnDChannelSigTimerTable.')
fcfIsdnDTimIsdnInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 5, 11, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcfIsdnDTimIsdnInterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: fcfIsdnDTimIsdnInterfaceId.setDescription("The value of this object identifies one and only one integrated services digital network (ISDN) basic rate interface (BRI) with signalling procedures. Each ISDN BRI corresponds, in fcfIsdnBasicRateInterfaceTable, to one instance of fcfIsdnBriSignalling equal to 'on'. This is a decimal integer in the range 0 to 35.")
fcfIsdnDTimBChannelUpTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 5, 11, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2550))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfIsdnDTimBChannelUpTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fcfIsdnDTimBChannelUpTimer.setDescription("The value of this object is the up state timer in seconds for this basic rate interface. This timer starts when the ISDN call is successfull (i.e., a B-channel is established) and it is normally stopped when the protocol stack layered on this B-channel is in the up state. The call is cleared when this timer runs out. This is a decimal integer in the range 1 to 2550 by step of 10. The default value is '60'.")
fcfIsdnDTimT301AlertConnectTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 5, 11, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2550))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfIsdnDTimT301AlertConnectTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fcfIsdnDTimT301AlertConnectTimer.setDescription("The value of this object is the T301 timer in seconds for this basic rate interface. This timer starts when an ALERTING call establishment message is received and it is normally stopped when a CONNECT message is received. The call is cleared when this timer runs out. This is a decimal integer in the range 1 to 2550 by step of 10. The default value is '20'.")
fcfIsdnDTimT303SetupResponseTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 5, 11, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfIsdnDTimT303SetupResponseTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fcfIsdnDTimT303SetupResponseTimer.setDescription("The value of this object is the T303 timer in seconds for this basic rate interface. This timer starts when a SETUP call establishment message is sent and it is normally stopped when an ALERTING, CONNECT, SETUP ACKNOWLEDGE, CALL PROCEEDING or RELEASE COMPLETE message is received. When this timer runs out for the first time the equipment retransmits the SETUP message and restarts this timer. When this timer runs out for the second time the equipment clears the call. This is a decimal integer in the range 1 to 255. The default value is '4'.")
fcfIsdnDTimT305DisconnectResponseTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 5, 11, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfIsdnDTimT305DisconnectResponseTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fcfIsdnDTimT305DisconnectResponseTimer.setDescription("The value of this object is the T305 timer in seconds for this basic rate interface. This timer starts when a DISCONNECT call clearing message is sent and it is normally stopped when a RELEASE or DISCONNECT message is received. When this timer runs out the equipment sent a RELEASE message. This is a decimal integer in the range 1 to 255. The default value is '30'.")
fcfIsdnDTimT308ReleaseResponseTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 5, 11, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfIsdnDTimT308ReleaseResponseTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fcfIsdnDTimT308ReleaseResponseTimer.setDescription("The value of this object is the T308 timer in seconds for this basic rate interface. This timer starts when a RELEASE call clearing message is sent and it is normally stopped when a RELEASE COMPLETE or RELEASE message is received. When this timer runs out for the first time the equipment retransmits the RELEASE message and restarts this timer. When this timer runs out for the second time the equipment places the B-channel in maintenance condition. This is a decimal integer in the range 1 to 255. The default value is '4'.")
fcfIsdnDTimT309DataLinkFailureTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 5, 11, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 180))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfIsdnDTimT309DataLinkFailureTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fcfIsdnDTimT309DataLinkFailureTimer.setDescription("The value of this object is the T309 timer in seconds for this basic rate interface. This timer starts when the data link is disconnected and it is normally stopped when it is reconnected. The call is cleared when this timer runs out. This is a decimal integer in the range 0 to 180. The default value is '60'.")
fcfIsdnDTimT310CallProceedingTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 5, 11, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfIsdnDTimT310CallProceedingTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fcfIsdnDTimT310CallProceedingTimer.setDescription("The value of this object is the T310 timer in seconds for this basic rate interface. This timer starts when a CALL PROCEEDING call establishment message is received and it is normally stopped when an ALERTING, CONNECT, DISCONNECT or PROGRESS message is received. The DISCONNECT message is sent when this timer runs out. This is a decimal integer in the range 1 to 255. The default value is '40'.")
fcfIsdnDTimT313ConnectAcknowledgeTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 5, 11, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfIsdnDTimT313ConnectAcknowledgeTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fcfIsdnDTimT313ConnectAcknowledgeTimer.setDescription("The value of this object is the T313 timer in seconds for this basic rate interface. This timer starts when a CONNECT call establishment message is sent and it is normally stopped when a CONNECT ACKNOWLEDGE message is received. The DISCONNECT message is sent when this timer runs out. This is a decimal integer in the range 1 to 255. The default value is '4'.")
fcfIsdnRemotePeerTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 5, 20), )
if mibBuilder.loadTexts: fcfIsdnRemotePeerTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcfIsdnRemotePeerTable.setDescription("This table contains the interfaces which may be connected to the equipment through an ISDN. Each of these remote ISDN interfaces is identified by a decimal integer in the range 0 to 249. Set any writable object(s) of this table to valid value(s) with a new index value to create an entry (the objects of the entry not present in this SET REQUEST will take their default values). Set fcfIsdnRemStatus to 'invalid' to delete an entry.")
fcfIsdnRemotePeerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 5, 20, 1), ).setIndexNames((0, "PCE-MIB", "fcfIsdnRemRemotePeerId"))
if mibBuilder.loadTexts: fcfIsdnRemotePeerEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcfIsdnRemotePeerEntry.setDescription('An entry of fcfIsdnRemotePeerTable.')
fcfIsdnRemRemotePeerId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 5, 20, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 999))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcfIsdnRemRemotePeerId.setStatus('mandatory')
if mibBuilder.loadTexts: fcfIsdnRemRemotePeerId.setDescription('The value of this object identifies one and only one remote ISDN interface which may be connected to the equipment through an ISDN. This is a decimal integer in the range 0 to 249 in releases before 4.2, in the range 0 to 999 after.')
fcfIsdnRemStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 5, 20, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfIsdnRemStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fcfIsdnRemStatus.setDescription("The value of this object indicates the state of the entry of this table. It must be set to 'invalid' to delete the entry. The default value is 'valid'.")
fcfIsdnRemIsdnNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 5, 20, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(11, 11)).setFixedLength(11)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfIsdnRemIsdnNumber.setStatus('mandatory')
if mibBuilder.loadTexts: fcfIsdnRemIsdnNumber.setDescription("The value of this object is the ISDN address (the ISDN number and the optional subaddress) of this remote ISDN interface. This is a eleven-bytes octet string with : up to 16 digits in the range 0 to 9 for the ISDN number, an optional separator marking the end of the ISDN number and the beginning of the ISDN subaddress : digit 'A' (':' on the equipment configurator), optional 1 to 4 digits in the range 0 to 9 for the ISDN subaddress, mandatory 'F' digits to pad the value until a total of 22 digits (the equipment configurator does not need this final padding). This value is automatically completed by a selection of digits from the X121 address when this X121 address contains two digits 'A' (':' on the equipment configurator) to make the complete ISDN address. See, in the fcLogicalPorts group, the tables which defines the connections to the ISDN remote interfaces. The default value is 'FF FF FF FF FF FF FF FF FF FF FF' meaning 'empty value' (blank value on the equipment configurator).")
fcfIsdnRemCallDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 5, 20, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(32, 16, 48))).clone(namedValues=NamedValues(("calling", 32), ("called", 16), ("auto", 48)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfIsdnRemCallDirection.setStatus('mandatory')
if mibBuilder.loadTexts: fcfIsdnRemCallDirection.setDescription("The value of this object defines the mode used to establish the call with this remote ISDN interface : calling : the caller is one of the ISDN interface of the equipment, called : the caller is this remote ISDN interface, auto : automatic choise between 'calling' and 'called'. The default value is 'auto'.")
fcfE1Ds1 = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 15))
fcfE1Ds1PhysTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 15, 1), )
if mibBuilder.loadTexts: fcfE1Ds1PhysTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcfE1Ds1PhysTable.setDescription('')
fcfE1Ds1PhysEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 15, 1, 1), ).setIndexNames((0, "PCE-MIB", "fcfE1Ds1PhysIfId"))
if mibBuilder.loadTexts: fcfE1Ds1PhysEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcfE1Ds1PhysEntry.setDescription('An entry of fcfE1Ds1PhysTable.')
fcfE1Ds1PhysIfId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 15, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcfE1Ds1PhysIfId.setStatus('mandatory')
if mibBuilder.loadTexts: fcfE1Ds1PhysIfId.setDescription('IF E1 ou DS1 Physique id')
fcfE1Ds1PhysStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 15, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfE1Ds1PhysStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fcfE1Ds1PhysStatus.setDescription('Status')
fcfE1Ds1PhysPhysicalPort = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 15, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfE1Ds1PhysPhysicalPort.setStatus('mandatory')
if mibBuilder.loadTexts: fcfE1Ds1PhysPhysicalPort.setDescription('PP E1 ou DS1')
fcfE1PhysPortTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 15, 3), )
if mibBuilder.loadTexts: fcfE1PhysPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcfE1PhysPortTable.setDescription('')
fcfE1PhysPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 15, 3, 1), ).setIndexNames((0, "PCE-MIB", "fcfE1PhysPortId"))
if mibBuilder.loadTexts: fcfE1PhysPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcfE1PhysPortEntry.setDescription('An entry of fcfE1PhysPortTable.')
fcfE1PhysPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 15, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcfE1PhysPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fcfE1PhysPortId.setDescription('PP E1 If id')
fcfE1PhysPortSynchSrc = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 15, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("network", 1), ("freeRun", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfE1PhysPortSynchSrc.setStatus('mandatory')
if mibBuilder.loadTexts: fcfE1PhysPortSynchSrc.setDescription('Synchronisation Source')
fcfE1PhysPortFraming = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 15, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("doubleframe", 1), ("multiframeWithCrc4", 2), ("extendedCrc4", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfE1PhysPortFraming.setStatus('mandatory')
if mibBuilder.loadTexts: fcfE1PhysPortFraming.setDescription('Framing')
fcfE1PhysPortFlowType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 15, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("data", 1), ("voice", 2), ("voiceAndData", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfE1PhysPortFlowType.setStatus('mandatory')
if mibBuilder.loadTexts: fcfE1PhysPortFlowType.setDescription('Type de flux')
fcfE1Ds1ChannelTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 15, 5), )
if mibBuilder.loadTexts: fcfE1Ds1ChannelTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcfE1Ds1ChannelTable.setDescription('')
fcfE1Ds1ChannelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 15, 5, 1), ).setIndexNames((0, "PCE-MIB", "fcfE1Ds1ChannelIfId"))
if mibBuilder.loadTexts: fcfE1Ds1ChannelEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcfE1Ds1ChannelEntry.setDescription('An entry of fcfE1Ds1ChannelTable.')
fcfE1Ds1ChannelIfId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 15, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(42, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcfE1Ds1ChannelIfId.setStatus('mandatory')
if mibBuilder.loadTexts: fcfE1Ds1ChannelIfId.setDescription('IF E1 ou DS1 Canal id')
fcfE1Ds1ChannelStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 15, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfE1Ds1ChannelStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fcfE1Ds1ChannelStatus.setDescription('Status')
fcfE1Ds1ChannelPhysIf = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 15, 5, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfE1Ds1ChannelPhysIf.setStatus('mandatory')
if mibBuilder.loadTexts: fcfE1Ds1ChannelPhysIf.setDescription('Interface E1 ou DS1 Physique')
fcfE1Ds1ChannelSlots = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 15, 5, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 24))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfE1Ds1ChannelSlots.setStatus('mandatory')
if mibBuilder.loadTexts: fcfE1Ds1ChannelSlots.setDescription('Slots')
fcfE1Ds1DropInsertTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 15, 10), )
if mibBuilder.loadTexts: fcfE1Ds1DropInsertTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcfE1Ds1DropInsertTable.setDescription('')
fcfE1Ds1DropInsertEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 15, 10, 1), ).setIndexNames((0, "PCE-MIB", "fcfE1Ds1DropInsertIf1"), (0, "PCE-MIB", "fcfE1Ds1DropInsertIf2"))
if mibBuilder.loadTexts: fcfE1Ds1DropInsertEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcfE1Ds1DropInsertEntry.setDescription('An entry of fcfE1Ds1DropInsertTable.')
fcfE1Ds1DropInsertIf1 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 15, 10, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(42, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcfE1Ds1DropInsertIf1.setStatus('mandatory')
if mibBuilder.loadTexts: fcfE1Ds1DropInsertIf1.setDescription('Interface Canal 1')
fcfE1Ds1DropInsertIf2 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 15, 10, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(42, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcfE1Ds1DropInsertIf2.setStatus('mandatory')
if mibBuilder.loadTexts: fcfE1Ds1DropInsertIf2.setDescription('Interface Canal 2')
fcfE1Ds1DropInsertStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 15, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfE1Ds1DropInsertStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fcfE1Ds1DropInsertStatus.setDescription('Status')
fcfTokenRing = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 20))
fcfTokenRingTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 20, 1), )
if mibBuilder.loadTexts: fcfTokenRingTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcfTokenRingTable.setDescription('')
fcfTokenRingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 20, 1, 1), ).setIndexNames((0, "PCE-MIB", "fcfTokenRingInterfaceId"))
if mibBuilder.loadTexts: fcfTokenRingEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcfTokenRingEntry.setDescription('An entry of fcfTokenRingTable.')
fcfTokenRingInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 20, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcfTokenRingInterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: fcfTokenRingInterfaceId.setDescription('IF id')
fcfTokenRingSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 20, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("s4000000", 1), ("s16000000", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfTokenRingSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: fcfTokenRingSpeed.setDescription('Vitesse')
fcfTokenRingLinkCheckPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 20, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfTokenRingLinkCheckPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: fcfTokenRingLinkCheckPeriod.setDescription('Periode de surveillance jonction (msec)')
fcfTokenRingCheckPeriodCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 10, 20, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 250))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcfTokenRingCheckPeriodCount.setStatus('mandatory')
if mibBuilder.loadTexts: fcfTokenRingCheckPeriodCount.setDescription('Confirmation au bout de n periodes')
fcFrameRelaySwitch = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 15))
fcFrSwitchingTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 15, 1), )
if mibBuilder.loadTexts: fcFrSwitchingTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcFrSwitchingTable.setDescription('This table defines the static part of ralaying table used by the frame relay switch to establish bi-directional connections between PVC (Permanenent Virtual Circuit) end points. A PVC end point is defined by the couple (interface identifier, data link connection identifier).')
fcFrSwitchingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 15, 1, 1), ).setIndexNames((0, "PCE-MIB", "fcFrSwInputInterfaceId"), (0, "PCE-MIB", "fcFrSwInputDlci"))
if mibBuilder.loadTexts: fcFrSwitchingEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcFrSwitchingEntry.setDescription('An entry of fcFrSwitchingTable.')
fcFrSwInputInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 15, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFrSwInputInterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: fcFrSwInputInterfaceId.setDescription("The value of this object is the interface identifier for this PVC end point. The possible values are : '0..35'. If it is unused, the value of this parameter is '255'.")
fcFrSwInputDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 15, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 991))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFrSwInputDlci.setStatus('mandatory')
if mibBuilder.loadTexts: fcFrSwInputDlci.setDescription("The value of this object is the Data Link Connection Identifier for this PVC end point. The possible values are : '0..1023. If it is unused, the value of this parameter is '65535'. The PVC end point connected to this PVC end point is defined by fcFrSwOutputInterfaceId and fcFrSwOutputDlci.")
fcFrSwStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 15, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcFrSwStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fcFrSwStatus.setDescription("The value of this object indicates the state of the entry of this table. The default value is 'valid'. It must be set to 'invalid' to delete the entry.")
fcFrSwOutputInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 15, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcFrSwOutputInterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: fcFrSwOutputInterfaceId.setDescription("The value of this object is the interface identifier for the connected PVC end point. The possible values are : '0..35'. If it is unused, the value of this parameter is '255'.")
fcFrSwOutputDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 15, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 991))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcFrSwOutputDlci.setStatus('mandatory')
if mibBuilder.loadTexts: fcFrSwOutputDlci.setDescription("The value of this object is the Data Link Connection Identifier for the connected PVC end point. The possible values are : '0..1023. If it is unused, the value of this parameter is '65535'.")
fcFrSwPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 15, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcFrSwPriority.setStatus('mandatory')
if mibBuilder.loadTexts: fcFrSwPriority.setDescription("The value of this object indicates if this PVC end point connection is foreground. The default value is 'off'.")
fcLogicalPorts = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 20))
fclLogicalPortTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 1), )
if mibBuilder.loadTexts: fclLogicalPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclLogicalPortTable.setDescription('This table defines the parameters of a logical port. A logical port permits the transmission between systems with a specific stack of protocols, over one physical port or more.')
fclLogicalPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 1, 1), ).setIndexNames((0, "PCE-MIB", "fclLogPortId"))
if mibBuilder.loadTexts: fclLogicalPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclLogicalPortEntry.setDescription('An entry of fclLogicalPortTable.')
fclLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclLogPortId.setDescription("The value of this object identifies one and only one logical port. The possible values are : '0..131. If it is unused, the value of this parameter is '255'.")
fclLogPortStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclLogPortStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fclLogPortStatus.setDescription("The value of this object indicates the state of the entry of this table. The default value is 'valid'. It must be set to 'invalid' to delete the entry.")
fclLogPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 10, 11, 12, 13, 14, 15, 16, 17, 20, 21, 22, 23, 24, 25, 30, 31, 32, 40, 41, 42, 45, 50))).clone(namedValues=NamedValues(("ethernet-tr", 1), ("asynchronous", 10), ("fra", 11), ("hdlc", 12), ("sdlc", 13), ("vip", 14), ("bsc3270", 15), ("bsc2780or3780", 16), ("bscSCT", 17), ("x25Access", 20), ("x25InDIsdn", 21), ("x25InBIsdn", 22), ("x25InPstn", 23), ("x25InterNode", 24), ("x25Mlp", 25), ("pppSerialLink", 30), ("pppPstn", 31), ("pppIsdn", 32), ("frCe", 40), ("frTe", 41), ("frSe", 42), ("frSeInBIsdn", 45), ("interUnitLink", 50)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclLogPortType.setStatus('mandatory')
if mibBuilder.loadTexts: fclLogPortType.setDescription("The value of this object identifies the stack of protocols used by this logical port. The default value is 'x25InterNode'.")
fclEthernet = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 2))
fclEthernetTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 2, 1), )
if mibBuilder.loadTexts: fclEthernetTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclEthernetTable.setDescription('This table defines the parameters of an ethernet logical port.')
fclEthernetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 2, 1, 1), ).setIndexNames((0, "PCE-MIB", "fclEthLogPortId"))
if mibBuilder.loadTexts: fclEthernetEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclEthernetEntry.setDescription('An entry of fclEthernetTable.')
fclEthLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclEthLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclEthLogPortId.setDescription("The value of this object identifies one and only one ethernet logical port. The possible values are : '0..131'. If it is unused, the value of this parameter is '255'.")
fclEthInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclEthInterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: fclEthInterfaceId.setDescription("The value of this object identifies the ethernet interface used by this logical port. The possible values are : '0..35'. If it is unused, the value of this parameter is '255'.")
fclAsynchronousAccessLogPort = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5))
fclAsynLogPortTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 1), )
if mibBuilder.loadTexts: fclAsynLogPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynLogPortTable.setDescription('This table defines the general parameters of asynchronous logical ports.')
fclAsynLogPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 1, 1), ).setIndexNames((0, "PCE-MIB", "fclAsynLpLogPortId"))
if mibBuilder.loadTexts: fclAsynLogPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynLogPortEntry.setDescription('An entry of fclAsynLogPortTable.')
fclAsynLpLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclAsynLpLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynLpLogPortId.setDescription("The value of this object identifies one and only one asynchronous logical port. The possible values are : '0..131'. If it is unused, the value of this parameter is '255'.")
fclAsynLpInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynLpInterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynLpInterfaceId.setDescription("The value of this object identifies the line interface used by this asynchronous logical port. The possible values are : '0..35'. If it is unused, the value of this parameter is '255'. The default value is '255'.")
fclAsynLpSubscriberNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynLpSubscriberNumber.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynLpSubscriberNumber.setDescription("The value of this object is the SB number added to the DNICZO of the equipment to make the calling address in a call sent from this logical port. The value must contain 2 digits (digits 0..9). The default value is 'FF'.")
fclAsynLpConfigId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynLpConfigId.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynLpConfigId.setDescription("The value of this object identifies the asynchronous configuration used by this asynchronous logical port. This asynchronous configuration must be present in fclAsynCfgConfigTable. The possible values are : '0..199. If it is unused, the value of this parameter is '255'.")
fclAsynLpTerminalType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 7, 6, 20))).clone(namedValues=NamedValues(("pad", 1), ("videotext", 2), ("lowSpeedComputerPort", 3), ("lowSpeedComputerPortWithAutoCalls", 4), ("kioskClient", 7), ("multiStandardPad", 6), ("x28Plus", 20)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynLpTerminalType.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynLpTerminalType.setDescription("The value of this object is the type of the terminal connected to this asynchronous logical port. The default value is 'pad'.")
fclAsynPadLogPort = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 2))
fclAsynPadLpTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 2, 1), )
if mibBuilder.loadTexts: fclAsynPadLpTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynPadLpTable.setDescription("This table defines the specific parameters of an asynchronous logical port when the terminal type is 'pad'.")
fclAsynPadLpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 2, 1, 1), ).setIndexNames((0, "PCE-MIB", "fclAsynPadLpLogPortId"))
if mibBuilder.loadTexts: fclAsynPadLpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynPadLpEntry.setDescription('An entry of fclAsynPadLpTable.')
fclAsynPadLpLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclAsynPadLpLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynPadLpLogPortId.setDescription("The value of this object identifies one and only one asynchronous logical port used to connect a 'pad' terminal. The possible values are : '0..131'. If it is unused, the value of this parameter is '255'.")
fclAsynPadLpLink = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("pstn", 1), ("leasedLine", 2), ("direct", 3), ("directWithRtsCtsFlowCtrl", 4), ("pstnV25bis", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynPadLpLink.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynPadLpLink.setDescription("The value of this object indicates the type of link used to connect the terminal to the equipment. The default value is 'direct'.")
fclAsynPadLpSpeedDetection = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynPadLpSpeedDetection.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynPadLpSpeedDetection.setDescription("The value of this object indicates if the automatic speed detection is used. The default value is 'off'.")
fclAsynPadLpEquipment = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("hpHost", 2), ("hpTerminal", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynPadLpEquipment.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynPadLpEquipment.setDescription("The value of this object indicates the terminal in facing. 'other' means 'all equipment except Hewlett Packard'. The default value is 'other'.")
fclAsynPadLpMnemonicType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("pad", 1), ("vdxRemoteAuth", 2), ("vdxTeletel", 3), ("vdxLocalAuth", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynPadLpMnemonicType.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynPadLpMnemonicType.setDescription("The value of this object indicates the mnemonic type. When set to 'pad' the mnemonic must begin with a point, the call command is allowed, the X28 command is allowed, the call data and the password are checked by the remote host. When set to 'vdxRemoteAuth' the mnemonic may optionaly begin with a point, the call command is forbidden, the X28 command is forbidden, the call data and the password are checked by the remote host. When set to 'vdxTeletel' the mnemonic may optionaly begin with a point, the call command is allowed, the X28 command is forbidden, the call data and the password are checked by the remote host. When set to 'vdxLocalAuth' the mnemonic may optionaly begin with a point, the call command is forbidden, the X28 command is forbidden, the call data and the password are checked by the pad. The default is 'pad'.")
fclAsynPadLpNui = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 7, 6, 4, 2, 3, 5, 11))).clone(namedValues=NamedValues(("none", 1), ("none-rc", 7), ("optional-transmitOrRc", 6), ("optional-checkNuaOrRc", 4), ("mandatory-check", 2), ("mandatory-check-nua", 3), ("mandatory-transmit", 5), ("command-transmitOrRc", 11)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynPadLpNui.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynPadLpNui.setDescription("The value of this object indicates the treatment of the NUI (Network User Identifier). The authorized values are 'none' (not checking), 'none-rc' (not checking, but reverse charging), 'optional-transmitOrRc' (The NUI is optional. If it is present, the NUI is transmitted, else reverse charging), 'optional-checkNuaOrRc' (The NUI is optional, if the NUI is present then it is checked else reverse charging), 'mandatory-check' (The NUI is mandatory and checked), 'mandatory-check-nua' (The NUI is mandatory and checked. After checking, the NUI is coded in NUA), 'mandatory-transmit' (The NUI is mandatory but not checked, and it is transmitted), 'command-transmitOrRc' (NUI ON or NUI OFF is manadatory before a communication). The default value is 'none'.")
fclAsynPadLpCombinedFlowCtrl = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynPadLpCombinedFlowCtrl.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynPadLpCombinedFlowCtrl.setDescription("The value of this object indicates wheter combined flow control (by XON/XOFF and RTS/CTS) is enabled or not. The default value is 'off'.")
fclAsynPadHomePageTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 2, 10), )
if mibBuilder.loadTexts: fclAsynPadHomePageTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynPadHomePageTable.setDescription('This table defines the home page of the PAD. The home page is made of blocks. Each block contains a message and its graphical attributes.')
fclAsynPadHomePageEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 2, 10, 1), ).setIndexNames((0, "PCE-MIB", "fclAsynPadPageBlocId"))
if mibBuilder.loadTexts: fclAsynPadHomePageEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynPadHomePageEntry.setDescription('An entry of fclAsynPadHomePageTable.')
fclAsynPadPageBlocId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 19))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclAsynPadPageBlocId.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynPadPageBlocId.setDescription("The value of this object is the block identifier. The possible values are '0..99'. If it is unused, the value is '255'.")
fclAsynPadPageStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynPadPageStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynPadPageStatus.setDescription("The value of this object indicates the state of the entry of this table. The default value is 'valid'. It must be set to 'invalid' to delete the entry.")
fclAsynPadPageMessage = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 2, 10, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 12))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynPadPageMessage.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynPadPageMessage.setDescription('The value of this object is the message. This message may contains from 0 to 12 characters. The default value is the empty string.')
fclAsynPadPageAttributes = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 2, 10, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(11, 11)).setFixedLength(11)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynPadPageAttributes.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynPadPageAttributes.setDescription("The value of this object defines the attributes used to display the message. 11 bytes from 00 to FF must be specified. The first byte contains the number of following useful bytes. The trailing bytes must be set to 'FF'. The equipment configurator does not need this final completion. The default value is 'empty' (first byte set to '00').")
fclAsynVdxLogPort = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 3))
fclAsynVdxLpTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 3, 1), )
if mibBuilder.loadTexts: fclAsynVdxLpTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynVdxLpTable.setDescription("This table defines the specific parameters of an asynchronous logical port when the terminal type is 'videotext'.")
fclAsynVdxLpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 3, 1, 1), ).setIndexNames((0, "PCE-MIB", "fclAsynVdxLpLogPortId"))
if mibBuilder.loadTexts: fclAsynVdxLpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynVdxLpEntry.setDescription('An entry of fclAsynVdxLpTable.')
fclAsynVdxLpLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclAsynVdxLpLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynVdxLpLogPortId.setDescription("The value of this object identifies one and only one asynchronous logical port used to connect a 'videotext' terminal. The possible values are : '0..131'. If it is unused, the value of this parameter is '255'.")
fclAsynVdxLpLink = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("pstn", 1), ("leasedLine", 2), ("direct", 3), ("directWithRtsCtsFlowCtrl", 4), ("pstnV25bis", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynVdxLpLink.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynVdxLpLink.setDescription("The value of this object indicates the type of link used to connect the terminal to the equipment. The default value is 'direct'.")
fclAsynVdxLpMnemonicType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("pad", 1), ("vdxRemoteAuth", 2), ("vdxTeletel", 3), ("vdxLocalAuth", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynVdxLpMnemonicType.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynVdxLpMnemonicType.setDescription("The value of this object indicates the mnemonic type. When set to 'pad' the mnemonic must begin with a point, the call command is allowed, the X28 command is allowed, the call data and the password are checked by the remote host. When set to 'vdxRemoteAuth' the mnemonic may optionaly begin with a point, the call command is forbidden, the X28 command is forbidden, the call data and the password are checked by the remote host. When set to 'vdxTeletel' the mnemonic may optionaly begin with a point, the call command is allowed, the X28 command is forbidden, the call data and the password are checked by the remote host. When set to 'vdxLocalAuth' the mnemonic may optionaly begin with a point, the call command is forbidden, the X28 command is forbidden, the call data and the password are checked by the pad. The default is 'pad'.")
fclAsynVdxLpNui = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 7, 6, 4, 2, 3, 5, 11))).clone(namedValues=NamedValues(("none", 1), ("none-rc", 7), ("optional-transmitOrRc", 6), ("optional-checkNuaOrRc", 4), ("mandatory-check", 2), ("mandatory-check-nua", 3), ("mandatory-transmit", 5), ("command-transmitOrRc", 11)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynVdxLpNui.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynVdxLpNui.setDescription("The value of this object indicates the treatment of the NUI (Network User Identifier). The authorized values are 'none' (not checking), 'none-rc' (not checking, but reverse charging), 'optional-transmitOrRc' (The NUI is optional. If it is present, the NUI is transmitted, else reverse charging), 'optional-checkNuaOrRc' (The NUI is optional, if the NUI is present then it is checked else reverse charging), 'mandatory-check' (The NUI is mandatory and checked), 'mandatory-check-nua' (The NUI is mandatory and checked. After checking, the NUI is coded in NUA), 'mandatory-transmit' (The NUI is mandatory but not checked, and it is transmitted), 'command-transmitOrRc' (NUI ON or NUI OFF is manadatory before a communication). The default value is 'none'.")
fclAsynVdxLpParityBit = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("none", 1), ("setTo1", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynVdxLpParityBit.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynVdxLpParityBit.setDescription('Parite X25')
fclAsynVdxLpPceSubThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 3, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 254))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynVdxLpPceSubThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynVdxLpPceSubThreshold.setDescription('Seuil de Comptage SUB (PCE)')
fclAsynVdxLpPceNackTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 3, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(100, 25400))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynVdxLpPceNackTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynVdxLpPceNackTimer.setDescription("Tempo d'emission NACK (PCE) msec")
fclAsynVdxHomePageTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 3, 10), )
if mibBuilder.loadTexts: fclAsynVdxHomePageTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynVdxHomePageTable.setDescription('This table defines the home page of the VIDEOTEXT PAD. The home page is made of blocks. Each block contains a message and its graphical attributes.')
fclAsynVdxHomePageEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 3, 10, 1), ).setIndexNames((0, "PCE-MIB", "fclAsynVdxPageBlocId"))
if mibBuilder.loadTexts: fclAsynVdxHomePageEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynVdxHomePageEntry.setDescription('An entry of fclAsynVdxHomePageTable.')
fclAsynVdxPageBlocId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 3, 10, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 99))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclAsynVdxPageBlocId.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynVdxPageBlocId.setDescription("The value of this object is the block identifier. The possible values are '0..99'. If it is unused, the value is '255'.")
fclAsynVdxPageStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 3, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynVdxPageStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynVdxPageStatus.setDescription("The value of this object indicates the state of the entry of this table. The default value is 'valid'. It must be set to 'invalid' to delete the entry.")
fclAsynVdxPageMessage = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 3, 10, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 12))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynVdxPageMessage.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynVdxPageMessage.setDescription('The value of this object is the message. This message may contains from 0 to 12 characters. The default value is the empty string.')
fclAsynVdxPageAttributes = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 3, 10, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(11, 11)).setFixedLength(11)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynVdxPageAttributes.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynVdxPageAttributes.setDescription("The value of this object defines the attributes used to display the message. 11 bytes from 00 to FF must be specified. The first byte contains the number of following useful bytes. The trailing bytes must be set to 'FF'. The equipment configurator does not need this final completion. The values are defined by the TELETEL standard. The default value is 'empty' (first byte set to '00').")
fclAsynLowSpeedCpLogPort = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 4))
fclAsynLscpLpTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 4, 1), )
if mibBuilder.loadTexts: fclAsynLscpLpTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynLscpLpTable.setDescription("This table defines the specific parameters of an asynchronous logical port when the terminal type is 'lowSpeedComputerPort' or 'lowSpeedComputerPortWithAutoCalls'.")
fclAsynLscpLpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 4, 1, 1), ).setIndexNames((0, "PCE-MIB", "fclAsynLscpLpLogPortId"))
if mibBuilder.loadTexts: fclAsynLscpLpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynLscpLpEntry.setDescription('An entry of fclAsynLscpLpTable.')
fclAsynLscpLpLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclAsynLscpLpLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynLscpLpLogPortId.setDescription("The value of this object identifies one and only one asynchronous logical port used to connect a 'lowSpeedComputerPort' terminal. The possible values are : '0..131'. If it is unused, the value of this parameter is '255'.")
fclAsynLscpLpLink = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("leasedLine", 2), ("direct", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynLscpLpLink.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynLscpLpLink.setDescription("The value of this object indicates the type of link used to connect the terminal to the equipment. The default value is 'direct'.")
fclAsynLscpLpEquipment = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("hpHost", 2), ("hpTerminal", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynLscpLpEquipment.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynLscpLpEquipment.setDescription("The value of this object indicates the terminal in facing. 'other' means 'all equipment except Hewlett Packard'. The default value is 'other'.")
fclAsynMultiStandardPadLogPort = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 5))
fclAsynMultiLpTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 5, 1), )
if mibBuilder.loadTexts: fclAsynMultiLpTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynMultiLpTable.setDescription("This table defines the specific parameters of an asynchronous logical port when the terminal type is 'multiStandardPad'.")
fclAsynMultiLpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 5, 1, 1), ).setIndexNames((0, "PCE-MIB", "fclAsynMultiLpLogPortId"))
if mibBuilder.loadTexts: fclAsynMultiLpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynMultiLpEntry.setDescription('An entry of fclAsynMultiLpTable.')
fclAsynMultiLpLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclAsynMultiLpLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynMultiLpLogPortId.setDescription("The value of this object identifies one and only one asynchronous logical port used to connect a 'multiStandardPad' terminal. The possible values are : '0..131'. If it is unused, the value of this parameter is '255'.")
fclAsynMultiLpAuthStep1 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 5, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("undefined", 1), ("tfi-noParity", 2), ("tfi-evenParity", 3), ("enquire", 4), ("ter", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynMultiLpAuthStep1.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynMultiLpAuthStep1.setDescription("The value of this object defines the treatment used in the first step of authentication. 'undefined' means 'no treatment. The default value is 'undefined'.")
fclAsynMultiLpAuthStep2 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 5, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("undefined", 1), ("tfi-noParity", 2), ("tfi-evenParity", 3), ("enquire", 4), ("ter", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynMultiLpAuthStep2.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynMultiLpAuthStep2.setDescription("The value of this object defines the treatment used in the second step of authentication. 'undefined' means 'no treatment. The default value is 'undefined'.")
fclAsynMultiLpAuthStep3 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 5, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("undefined", 1), ("tfi-noParity", 2), ("tfi-evenParity", 3), ("enquire", 4), ("ter", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynMultiLpAuthStep3.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynMultiLpAuthStep3.setDescription("The value of this object defines the treatment used in the third step of authentication. 'undefined' means 'no treatment. The default value is 'undefined'.")
fclAsynMultiLpAuthStep4 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 5, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("undefined", 1), ("tfi-noParity", 2), ("tfi-evenParity", 3), ("enquire", 4), ("ter", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynMultiLpAuthStep4.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynMultiLpAuthStep4.setDescription("The value of this object defines the treatment used in the fourth step of authentication. 'undefined' means 'no treatment. The default value is 'undefined'.")
fclAsynX28PlusLogPort = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6))
fclAsynX28PlusLpTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6, 1), )
if mibBuilder.loadTexts: fclAsynX28PlusLpTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynX28PlusLpTable.setDescription("This table defines the specific parameters of an asynchronous logical port when the terminal type is 'x28plus'.")
fclAsynX28PlusLpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6, 1, 1), ).setIndexNames((0, "PCE-MIB", "fclAsynX28PlusLpLogPortId"))
if mibBuilder.loadTexts: fclAsynX28PlusLpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynX28PlusLpEntry.setDescription('An entry of fclAsynX28PlusLpTable.')
fclAsynX28PlusLpLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclAsynX28PlusLpLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynX28PlusLpLogPortId.setDescription("The value of this object identifies one and only one asynchronous logical port used to connect a 'x28plus' terminal. The possible values are : '0..131'. If it is unused, the value of this parameter is '255'.")
fclAsynX28PlusLpLink = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("pstn", 1), ("leasedLine", 2), ("direct", 3), ("directWithRtsCtsFlowCtrl", 4), ("pstnV25bis", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynX28PlusLpLink.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynX28PlusLpLink.setDescription("The value of this object indicates the type of link used to connect the terminal to the equipment. The default value is 'direct'.")
fclAsynX28PlusLpSpeedDetection = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynX28PlusLpSpeedDetection.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynX28PlusLpSpeedDetection.setDescription("The value of this object indicates if the automatic speed detection is used. The default value is 'on'.")
fclAsynX28PlusLpEquipment = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("hpHost", 2), ("hpTerminal", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynX28PlusLpEquipment.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynX28PlusLpEquipment.setDescription("The value of this object indicates the terminal in facing. 'other' means 'all equipment except Hewlett Packard'. The default value is 'other'.")
fclAsynX28PlusLpMnemonicType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("pad", 1), ("vdxRemoteAuth", 2), ("vdxTeletel", 3), ("vdxLocalAuth", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynX28PlusLpMnemonicType.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynX28PlusLpMnemonicType.setDescription("The value of this object indicates the mnemonic type. When set to 'pad' the mnemonic must begin with a point, the call command is allowed, the X28 command is allowed, the call data and the password are checked by the remote host. When set to 'vdxRemoteAuth' the mnemonic may optionaly begin with a point, the call command is forbidden, the X28 command is forbidden, the call data and the password are checked by the remote host. When set to 'vdxTeletel' the mnemonic may optionaly begin with a point, the call command is allowed, the X28 command is forbidden, the call data and the password are checked by the remote host. When set to 'vdxLocalAuth' the mnemonic may optionaly begin with a point, the call command is forbidden, the X28 command is forbidden, the call data and the password are checked by the pad. The default is 'pad'.")
fclAsynX28PlusLpFullDuplex = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynX28PlusLpFullDuplex.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynX28PlusLpFullDuplex.setDescription("The value of this object indicates whether the line is in full duplex (with echo) or half duplex (without echo). The echo of a transfer mode character is also defined by the X3 parameter number 2. The authorized values are 'off' (line in half duplex), 'on' (line in full duplex). The default value is 'on'.")
fclAsynX28PlusLpIdleTimerSelection = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynX28PlusLpIdleTimerSelection.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynX28PlusLpIdleTimerSelection.setDescription("The value of this object indicates whether the timers fclAsynCfgX3P04IdleTimerDelay and fclAsynX28PlusLpIdleTimerDelay are enabled or not. The data are sent upon when one of these two timers expires. The default value is 'on'.")
fclAsynX28PlusLpIdleTimerDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 12750))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynX28PlusLpIdleTimerDelay.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynX28PlusLpIdleTimerDelay.setDescription("The value of this object defines the data forwarding time-out in milliseconds. This timer is started at reception time of the first character. When this time-out expires, the PAD sends the received characters to the network. The time-out is restarted upon reception of the first character to follow. The authorized values are '0..12750' milliseconds. The default value is '0'.")
fclAsynX28PlusLpX3Mode = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("transparent", 1), ("networkVirtualTerminal", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynX28PlusLpX3Mode.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynX28PlusLpX3Mode.setDescription("The value of this object indicates the X3 mode. The authorized value are 'transparent' (X3 parameters 1, 13 and 15 are interpreted : case of escape, no LF insertion after CR) or 'networkVirtualTerminal' (X3 parameters 1, 13 and 15 are not inhibited). The default value is 'networkVirtualTerminal'.")
fclAsynX28PlusLpEscapeDigit = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynX28PlusLpEscapeDigit.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynX28PlusLpEscapeDigit.setDescription("Digit d'echappement")
fclAsynX28PlusLpConIdTelenet = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynX28PlusLpConIdTelenet.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynX28PlusLpConIdTelenet.setDescription('Config ID TELENET')
fclAsynX28PlusLpConIdRemote = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6, 1, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynX28PlusLpConIdRemote.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynX28PlusLpConIdRemote.setDescription('Config ID Remote X3 et TELENET')
fclAsynX28PlusLpRemPrSentOnCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("never", 1), ("inBound", 2), ("outBound", 3), ("both", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynX28PlusLpRemPrSentOnCalls.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynX28PlusLpRemPrSentOnCalls.setDescription('Envoi du profil distant')
fclAsynX28PlusLpEasyMnemo = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynX28PlusLpEasyMnemo.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynX28PlusLpEasyMnemo.setDescription('Facilite mnemonique')
fclAsynX28PlusLpMonSignalCTS = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynX28PlusLpMonSignalCTS.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynX28PlusLpMonSignalCTS.setDescription('Gestion du signal sortant106CTS (DCE)/108DTR(DTE)')
fclAsynX28PlusLpMonSignalDSR = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6, 1, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynX28PlusLpMonSignalDSR.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynX28PlusLpMonSignalDSR.setDescription('Gestion du signal sortant 107DSR (DCE)/111DRS(DTE)')
fclAsynX28PlusLpMonSignalDCD = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6, 1, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynX28PlusLpMonSignalDCD.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynX28PlusLpMonSignalDCD.setDescription('Gestion du signal sortant 109DCD(DCE)/105RTS(DTE)')
fclAsynX28PlusGeneralParameters = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6, 2))
fclAsynX28PlusGenParDNIC = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6, 2, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynX28PlusGenParDNIC.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynX28PlusGenParDNIC.setDescription('DNIC pour adresse abregee')
fclAsynX28PlusConfTELENETTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6, 3), )
if mibBuilder.loadTexts: fclAsynX28PlusConfTELENETTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynX28PlusConfTELENETTable.setDescription('')
fclAsynX28PlusConfTELENETEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6, 3, 1), ).setIndexNames((0, "PCE-MIB", "fclAsynX28PlusCfgTELENETConfigId"))
if mibBuilder.loadTexts: fclAsynX28PlusConfTELENETEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynX28PlusConfTELENETEntry.setDescription('An entry of fclAsynX28PlusConfTELENETTable.')
fclAsynX28PlusCfgTELENETConfigId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclAsynX28PlusCfgTELENETConfigId.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynX28PlusCfgTELENETConfigId.setDescription('Config Id')
fclAsynX28PlusCfgTELENETDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6, 3, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynX28PlusCfgTELENETDescription.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynX28PlusCfgTELENETDescription.setDescription('Description')
fclAsynX28PlusParTELENETTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6, 4), )
if mibBuilder.loadTexts: fclAsynX28PlusParTELENETTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynX28PlusParTELENETTable.setDescription('')
fclAsynX28PlusParTELENETEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6, 4, 1), ).setIndexNames((0, "PCE-MIB", "fclAsynX28PlusParTelConfigId"))
if mibBuilder.loadTexts: fclAsynX28PlusParTELENETEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynX28PlusParTELENETEntry.setDescription('An entry of fclAsynX28PlusParTELENETTable.')
fclAsynX28PlusParTelConfigId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclAsynX28PlusParTelConfigId.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynX28PlusParTelConfigId.setDescription('Config Id')
fclAsynX28PlusParTelLpFullDuplex = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6, 4, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynX28PlusParTelLpFullDuplex.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynX28PlusParTelLpFullDuplex.setDescription('Ligne FullDuplex')
fclAsynX28PlusParTelLpIdleTimerSelection = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6, 4, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynX28PlusParTelLpIdleTimerSelection.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynX28PlusParTelLpIdleTimerSelection.setDescription('Envoi sur tempo')
fclAsynX28PlusParTelLpIdleTimerDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6, 4, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 12750))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynX28PlusParTelLpIdleTimerDelay.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynX28PlusParTelLpIdleTimerDelay.setDescription("Tempo d'envoi de donnees")
fclAsynX28PlusParTelLpX3Mode = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6, 4, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("transparent", 1), ("networkVirtualTerminal", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynX28PlusParTelLpX3Mode.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynX28PlusParTelLpX3Mode.setDescription('Terminal Virtuel')
fclAsynX28PlusConfRemoteTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6, 5), )
if mibBuilder.loadTexts: fclAsynX28PlusConfRemoteTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynX28PlusConfRemoteTable.setDescription('')
fclAsynX28PlusConfRemoteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6, 5, 1), ).setIndexNames((0, "PCE-MIB", "fclAsynX28PlusRemoteConfigId"))
if mibBuilder.loadTexts: fclAsynX28PlusConfRemoteEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynX28PlusConfRemoteEntry.setDescription('An entry of fclAsynX28PlusConfRemoteTable.')
fclAsynX28PlusRemoteConfigId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclAsynX28PlusRemoteConfigId.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynX28PlusRemoteConfigId.setDescription('Config Id')
fclAsynX28PlusRemoteCfgDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6, 5, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynX28PlusRemoteCfgDescription.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynX28PlusRemoteCfgDescription.setDescription('Description')
fclAsynX28PlusRemoteCfgX3Part1Table = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6, 6), )
if mibBuilder.loadTexts: fclAsynX28PlusRemoteCfgX3Part1Table.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynX28PlusRemoteCfgX3Part1Table.setDescription('')
fclAsynX28PlusRemoteCfgX3Part1Entry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6, 6, 1), ).setIndexNames((0, "PCE-MIB", "fclAsynX28PlusRemConfigId"))
if mibBuilder.loadTexts: fclAsynX28PlusRemoteCfgX3Part1Entry.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynX28PlusRemoteCfgX3Part1Entry.setDescription('An entry of fclAsynX28PlusRemoteCfgX3Part1Table.')
fclAsynX28PlusRemConfigId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclAsynX28PlusRemConfigId.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynX28PlusRemConfigId.setDescription('Config Id')
fclAsynX28PlusRemCfgX3P01EscapeChar = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6, 6, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 126))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynX28PlusRemCfgX3P01EscapeChar.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynX28PlusRemCfgX3P01EscapeChar.setDescription("Caractere d'echappement")
fclAsynX28PlusRemCfgX3P02Echo = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6, 6, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("val0-off", 1), ("val1-on", 2), ("not-used", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynX28PlusRemCfgX3P02Echo.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynX28PlusRemCfgX3P02Echo.setDescription('Echo')
fclAsynX28PlusRemCfgX3P03ForwardingChar = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6, 6, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 7, 19, 33, 127, 128, 129, 254, 255))).clone(namedValues=NamedValues(("val0-none", 1), ("val2-cr", 3), ("val6-crEscBelEnqAck", 7), ("val18-crEotEtx", 19), ("val32-htLfVtFf", 33), ("val126-allCtrlChars", 127), ("val127-allChars", 128), ("val128-allCtrlChars-vdxFunctionKeys", 129), ("val253-encapsCharacSLIP", 254), ("not-used", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynX28PlusRemCfgX3P03ForwardingChar.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynX28PlusRemCfgX3P03ForwardingChar.setDescription("Caractere d'envoi des donnees")
fclAsynX28PlusRemCfgX3P04IdleTimerDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6, 6, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 250))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynX28PlusRemCfgX3P04IdleTimerDelay.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynX28PlusRemCfgX3P04IdleTimerDelay.setDescription("Delai d'envoi (en 1/20eme de seconde)")
fclAsynX28PlusRemCfgX3P05OutputFlowCtrl = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6, 6, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 9, 255))).clone(namedValues=NamedValues(("val0-none", 1), ("val1-xonXoffInTransfer", 2), ("val2-xonXoff", 3), ("val8-rtsCtsInTransfer", 9), ("not-used", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynX28PlusRemCfgX3P05OutputFlowCtrl.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynX28PlusRemCfgX3P05OutputFlowCtrl.setDescription('Control de flux PAD vers Terminal')
fclAsynX28PlusRemCfgX3P06ServiceSignals = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6, 6, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 6, 10, 14, 255))).clone(namedValues=NamedValues(("val0-none", 1), ("val1-servSignal-stdFormat", 2), ("val5-servSignalAndPrompt-stdFormat", 6), ("val9-servSignal-explicitFormat", 10), ("val13-servSignalAndPrompt-explicitFormat", 14), ("not-used", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynX28PlusRemCfgX3P06ServiceSignals.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynX28PlusRemCfgX3P06ServiceSignals.setDescription('Transmission des indications par le PAD')
fclAsynX28PlusRemCfgX3P07BreakHandling = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6, 6, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 5, 6, 9, 22, 255))).clone(namedValues=NamedValues(("val0-forwardingChar", 1), ("val1-interrupt", 2), ("val2-reset", 3), ("val4-breakIndication", 5), ("val5-interrupt-breakIndication", 6), ("val8-escapeFromTransfer", 9), ("val21-interrupt-breakIndication-discardOutput", 22), ("not-used", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynX28PlusRemCfgX3P07BreakHandling.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynX28PlusRemCfgX3P07BreakHandling.setDescription('Reaction sur Break')
fclAsynX28PlusRemCfgX3P08OutputDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6, 6, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("val0-off", 1), ("val1-on", 2), ("not-used", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynX28PlusRemCfgX3P08OutputDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynX28PlusRemCfgX3P08OutputDiscard.setDescription('Arret de la remise des donnees')
fclAsynX28PlusRemCfgX3P09CrPadding = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6, 6, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 250))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynX28PlusRemCfgX3P09CrPadding.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynX28PlusRemCfgX3P09CrPadding.setDescription('Bourrage apres RC')
fclAsynX28PlusRemCfgX3P10LineFolding = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6, 6, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 250))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynX28PlusRemCfgX3P10LineFolding.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynX28PlusRemCfgX3P10LineFolding.setDescription('Pliage de ligne')
fclAsynX28PlusRemCfgX3P11BinarySpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6, 6, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 24, 18, 21, 22, 23, 255))).clone(namedValues=NamedValues(("val0-110", 1), ("val1-134-5", 2), ("val2-300", 3), ("val3-1200", 4), ("val4-600", 5), ("val5-75", 6), ("val6-150", 7), ("val7-1800", 8), ("val8-200", 9), ("val9-100", 10), ("val10-50", 11), ("val11-in75Out1200", 12), ("val12-2400", 13), ("val13-4800", 14), ("val14-9600", 15), ("val15-19200", 16), ("val23-28800", 24), ("val17-57600", 18), ("val20-38400", 21), ("val21-out1200In75", 22), ("val22-115200", 23), ("not-used", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynX28PlusRemCfgX3P11BinarySpeed.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynX28PlusRemCfgX3P11BinarySpeed.setDescription('Debit binaire (en bit/s)')
fclAsynX28PlusRemoteCfgX3Part2Table = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6, 7), )
if mibBuilder.loadTexts: fclAsynX28PlusRemoteCfgX3Part2Table.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynX28PlusRemoteCfgX3Part2Table.setDescription('')
fclAsynX28PlusRemoteCfgX3Part2Entry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6, 7, 1), ).setIndexNames((0, "PCE-MIB", "fclAsynX28PlusRemCfgX3Part2ConfigId"))
if mibBuilder.loadTexts: fclAsynX28PlusRemoteCfgX3Part2Entry.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynX28PlusRemoteCfgX3Part2Entry.setDescription('An entry of fclAsynX28PlusRemoteCfgX3Part2Table.')
fclAsynX28PlusRemCfgX3Part2ConfigId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6, 7, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclAsynX28PlusRemCfgX3Part2ConfigId.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynX28PlusRemCfgX3Part2ConfigId.setDescription('Config Id')
fclAsynX28PlusRemCfgX3P12InputFlowCtrl = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6, 7, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 9, 255))).clone(namedValues=NamedValues(("val0-none", 1), ("val1-xonXoff", 2), ("val8-rtsCts", 9), ("not-used", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynX28PlusRemCfgX3P12InputFlowCtrl.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynX28PlusRemCfgX3P12InputFlowCtrl.setDescription('Control de flux Terminal vers PAD')
fclAsynX28PlusRemCfgX3P13LfInsertion = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6, 7, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 255))).clone(namedValues=NamedValues(("val0-none", 1), ("val1-outCr", 2), ("val2-inCr", 3), ("val3-outCr-inCr", 4), ("val4-outCrEcho", 5), ("val5-outCr-outCrEcho", 6), ("val6-inCr-outCrEcho", 7), ("val7-outCr-inCr-outCrEcho", 8), ("not-used", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynX28PlusRemCfgX3P13LfInsertion.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynX28PlusRemCfgX3P13LfInsertion.setDescription('Insertion de LF apres RC')
fclAsynX28PlusRemCfgX3P14LfPadding = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6, 7, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 250))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynX28PlusRemCfgX3P14LfPadding.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynX28PlusRemCfgX3P14LfPadding.setDescription('Bourrage apres LF')
fclAsynX28PlusRemCfgX3P15Editing = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6, 7, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("val0-off", 1), ("val1-on", 2), ("not-used", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynX28PlusRemCfgX3P15Editing.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynX28PlusRemCfgX3P15Editing.setDescription('Edition')
fclAsynX28PlusRemCfgX3P16CharDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6, 7, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynX28PlusRemCfgX3P16CharDelete.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynX28PlusRemCfgX3P16CharDelete.setDescription("Caractere d'effacement d'un caractere")
fclAsynX28PlusRemCfgX3P17LineDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6, 7, 1, 27), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynX28PlusRemCfgX3P17LineDelete.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynX28PlusRemCfgX3P17LineDelete.setDescription("Caractere d'effacement d'une ligne")
fclAsynX28PlusRemCfgX3P18LineDisplay = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6, 7, 1, 28), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynX28PlusRemCfgX3P18LineDisplay.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynX28PlusRemCfgX3P18LineDisplay.setDescription("Caractere d'affichage d'une ligne")
fclAsynX28PlusRemCfgX3P19EditingSignal = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6, 7, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 255))).clone(namedValues=NamedValues(("val0-none", 1), ("val1-printingTerminal", 2), ("val2-displayTerminal", 3), ("not-used", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynX28PlusRemCfgX3P19EditingSignal.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynX28PlusRemCfgX3P19EditingSignal.setDescription("Indication d'edition")
fclAsynX28PlusRemCfgX3P20EchoMask = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6, 7, 1, 30), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynX28PlusRemCfgX3P20EchoMask.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynX28PlusRemCfgX3P20EchoMask.setDescription("Masque d'echo")
fclAsynX28PlusRemCfgX3P21Parity = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6, 7, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 255))).clone(namedValues=NamedValues(("val0-none", 1), ("val1-check", 2), ("val2-generate", 3), ("val3-check-generate", 4), ("not-used", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynX28PlusRemCfgX3P21Parity.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynX28PlusRemCfgX3P21Parity.setDescription('Traitement de la parite')
fclAsynX28PlusRemCfgX3P22PageWait = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6, 7, 1, 32), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynX28PlusRemCfgX3P22PageWait.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynX28PlusRemCfgX3P22PageWait.setDescription('Attente en fin de page')
fclAsynX28PlusRemoteTELENETTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6, 8), )
if mibBuilder.loadTexts: fclAsynX28PlusRemoteTELENETTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynX28PlusRemoteTELENETTable.setDescription('')
fclAsynX28PlusRemoteTELENETEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6, 8, 1), ).setIndexNames((0, "PCE-MIB", "fclAsynX28PlusRemCfgTELENETConfigId"))
if mibBuilder.loadTexts: fclAsynX28PlusRemoteTELENETEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynX28PlusRemoteTELENETEntry.setDescription('An entry of fclAsynX28PlusRemoteTELENETTable.')
fclAsynX28PlusRemCfgTELENETConfigId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6, 8, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclAsynX28PlusRemCfgTELENETConfigId.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynX28PlusRemCfgTELENETConfigId.setDescription('Config Id')
fclAsynX28PlusRemLpFullDuplex = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6, 8, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("off", 1), ("on", 2), ("not-used", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynX28PlusRemLpFullDuplex.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynX28PlusRemLpFullDuplex.setDescription('Ligne FullDuplex')
fclAsynX28PlusRemLpIdleTimerSelection = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6, 8, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("off", 1), ("on", 2), ("not-used", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynX28PlusRemLpIdleTimerSelection.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynX28PlusRemLpIdleTimerSelection.setDescription('Envoi sur tempo')
fclAsynX28PlusRemLpIdleTimerDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6, 8, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 12750))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynX28PlusRemLpIdleTimerDelay.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynX28PlusRemLpIdleTimerDelay.setDescription("Tempo d'envoi de donnees")
fclAsynX28PlusRemLpX3Mode = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 6, 8, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("transparent", 1), ("networkVirtualTerminal", 2), ("not-used", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynX28PlusRemLpX3Mode.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynX28PlusRemLpX3Mode.setDescription('Terminal Virtuel')
fclAsynGeneralParameters = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 7))
fclAsynGenParLanguageType = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 7, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("french", 1), ("english", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynGenParLanguageType.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynGenParLanguageType.setDescription('Type de langue')
fclAsynConfiguration = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10))
fclAsynCfgConfigTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 1), )
if mibBuilder.loadTexts: fclAsynCfgConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgConfigTable.setDescription('This table contains the asynchronous configurations used in the asynchronous logical port table.')
fclAsynCfgConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 1, 1), ).setIndexNames((0, "PCE-MIB", "fclAsynCfgConfigId"))
if mibBuilder.loadTexts: fclAsynCfgConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgConfigEntry.setDescription('An entry of fclAsynCfgConfigTable.')
fclAsynCfgConfigId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclAsynCfgConfigId.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgConfigId.setDescription("The value of this object identifies one and only one asynchronous configuration. This configuration may be referenced by fclAsynLpConfigId in the asynchronous logical port table. The possible values are : '0..199. If it is unused, the value of this parameter is '255'. The configuration parameters are described in : fclAsynCfgX3Part1Table : X3 part 1, fclAsynCfgX3Part2Table : X3 part 2, fclAsynCfgConnLinkTable : data link level (connection part), fclAsynCfgConnFacilityTable : facility level (connection part), fclAsynCfgConnServiceTable : service level (connection part). When creating a new configuration each parameter takes its default value. Setting a profile allows the user to fill all the parameters with values pre-defined in this profile but each one may also be individually modified.")
fclAsynCfgStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgStatus.setDescription("The value of this object indicates the state of the entry of this table. The default value is 'valid'. It must be set to 'invalid' to delete the entry.")
fclAsynCfgDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgDescription.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgDescription.setDescription("The value of this object stores a text description of the configuration elaborated by the user. This description may contains from 0 to 32 characters. The default value is 'TTY'.")
fclAsynCfgX3ProfileId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgX3ProfileId.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgX3ProfileId.setDescription("The value of this object is the profile number used to automatically valorize all the X3 parameters in an entry of the two tables which composes the X3 part of asynchronous configurations (see fclAsynCfgConfigId). The possible values are : 00 Plain terminal, 01 Transparent terminal or LSCP, 02 LSCP, 03 Terminal communicating with LSCP, 04 Same as profile 03 with send time-out and padding, 05 Terminal with control by PAD, 06 Same es profile 00 with special break and break, 08 Same as profile 05 with echo, 09 Telex terminals, 10 Same as profile 05 without control by PAD, 11 Same as profile 02 without control by PAD, 12 Same as profile 00 without echo, 13 Block mode terminal controlled by PAD without send time-out, 14 Same as profile 13 with authorized DLE, 15 Same as profile 13 without control, 16 Host HEWLETT PACKARD, 17 Terminal HEWLETT PACKARD, 20 Same as profile 00 with control and teleprinter adapted editing, 21 Same as profile 20 with display-terminal adapted editing, 22 Same as profile 13 with control bye DTE-C, 23 Same as profile 21 for data base application, 30 VIDEOTEX terminal, 32 Multi-standard VIDEOTEX terminal, 80 User defined profile : the values in this profile are defined by the user (they may be specified in groups fclAsynCfgX3UserProfilePart1 and fclAsynCfgX3UserProfilePart2, 89 Special terminal, 90 Plain terminal without padding or send time-out, 91 Plain transparent LSCP. If it is unused, the value of this parameter is '255'. The default value is '89' (meaning that default values of X3 parameters are those pre-defined in profile number 89).")
fclAsynCfgX3ModifCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclAsynCfgX3ModifCount.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgX3ModifCount.setDescription('The value of this object indicates how many X3 parameters have not the value defined in the profile specified by fclAsynCfgX3ProfileId (i.e how many individual modifications).')
fclAsynCfgConnectionProfileId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgConnectionProfileId.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgConnectionProfileId.setDescription("The value of this object is the profile number used to automatically valorize all the connection parameters in an entry of the three tables which composes the connection part of asynchronous configurations (see fclAsynCfgConfigId). The possible values are : 07 Terminal with automatic baud rate detect, 08 Direct connected terminal, 09 Terminal connection PSTN, 10 Terminal connected by dedicated line, 11 LSCP terminal - direct connection, 12 LSCP terminal - dedicated line connection, 13 LSCP-A terminal - direct connection, 14 LSCP-A terminal - dedicated line connection, 15 Minitel terminal - direct connection, 16 Minitel terminal - PSTN connection, 34 TTY terminal - PSTN connection (V.25 bis), 35 Minitel terminal - PSTN connection (V.25 bis), 36 Minitel terminal - PSTN connection (modem turnaround), 37 Multistandard videotex terminal, 38 Kiosk micro computer, If it is unused, the value of this parameter is '255'. The default value is '8' (meaning that default values of connection parameters are those pre-defined in profile number 08).")
fclAsynCfgConnModifCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclAsynCfgConnModifCount.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgConnModifCount.setDescription('The value of this object indicates how many connection parameters have not the value defined in the profile specified by fclAsynCfgConnectionProfileId (i.e how many individual modifications).')
fclAsynCfgX3Part1Table = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 11), )
if mibBuilder.loadTexts: fclAsynCfgX3Part1Table.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgX3Part1Table.setDescription('This table contains the X3 parameters (part 1) of asynchronous configurations.')
fclAsynCfgX3Part1Entry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 11, 1), ).setIndexNames((0, "PCE-MIB", "fclAsynCfgX3Part1ConfigId"))
if mibBuilder.loadTexts: fclAsynCfgX3Part1Entry.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgX3Part1Entry.setDescription('An entry of fclAsynCfgX3Part1Table.')
fclAsynCfgX3Part1ConfigId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 11, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclAsynCfgX3Part1ConfigId.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgX3Part1ConfigId.setDescription("The value of this object identifies one and only one asynchronous configuration. The possible values are : '0..199. If it is unused, the value of this parameter is '255'.")
fclAsynCfgX3Part1ProfileId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 11, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclAsynCfgX3Part1ProfileId.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgX3Part1ProfileId.setDescription('The value of this object is the X3 profile number used to create this configuration.')
fclAsynCfgX3P01EscapeChar = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 11, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 126))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgX3P01EscapeChar.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgX3P01EscapeChar.setDescription("The value of this object is the character to escape from the data transfer state and to recall the PAD. The authorized values are '0..126'. The value '0' indicates no escape. The value '1' is the DLE character. The values '2..126' are the ASCII code of the character. The default value is '1'.")
fclAsynCfgX3P02Echo = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 11, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("val0-off", 1), ("val1-on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgX3P02Echo.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgX3P02Echo.setDescription("The value of this object indicates whether the echo is local not. The authorized values are 'off' (echoing by the terminal), 'on' (echoing by the equipment). The default value is 'on'.")
fclAsynCfgX3P03ForwardingChar = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 11, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 7, 19, 33, 127, 128, 129, 254, 255))).clone(namedValues=NamedValues(("val0-none", 1), ("val2-cr", 3), ("val6-crEscBelEnqAck", 7), ("val18-crEotEtx", 19), ("val32-htLfVtFf", 33), ("val126-allCtrlChars", 127), ("val127-allChars", 128), ("val128-allCtrlChars-vdxFunctionKeys", 129), ("val253-encapsCharacSLIP", 254), ("val254-encapsCharacPPP", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgX3P03ForwardingChar.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgX3P03ForwardingChar.setDescription("The value of this object is the data forwarding character(s). The authorized values are 'none' (no character), 'CR' (Carriage Return), 'CR ESC BEL ENQ ACK' (Carriage Return, Escape, Bell, Enquire, Acknowledge), 'CR EOT ETX' (Carriage Return, End Of Text, End Of Transmission), 'HT LF VT FF' (Horizontal Tabulation, Line Feed, Vertical Tabulation, Form Feed), 'all Ctrl Chars' (all control characters), 'all Chars' (all characters), 'all Ctrl Chars vdxFunctionKeys' (all control characters and videotext function keys), 'encapsCharacSLIP', 'encapsCharacPPP'. The default value is 'all Ctrl Chars'.")
fclAsynCfgX3P04IdleTimerDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 11, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 250))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgX3P04IdleTimerDelay.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgX3P04IdleTimerDelay.setDescription("The value of this object is the idle timer delay in twentieths of a second. The authorized values are '0..250'. The value '0' will indicate that no data forwarding on time-out is required. The default value is '0'.")
fclAsynCfgX3P05OutputFlowCtrl = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 11, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 9))).clone(namedValues=NamedValues(("val0-none", 1), ("val1-xonXoffInTransfer", 2), ("val2-xonXoff", 3), ("val8-rtsCtsInTransfer", 9)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgX3P05OutputFlowCtrl.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgX3P05OutputFlowCtrl.setDescription("The value of this object indicates the flow control type from the equipment to the terminal. The authorized values are 'none' (no use of XON and XOFF), 'xonXoffInTransfer' (use of XON and XOFF in data transfer), 'xonXoff' (use of XON and XOFF in data transfer and command), 'rtsCtsInTransfer' (use of CTS and RTS signals in transfer). The default value is 'none'.")
fclAsynCfgX3P06ServiceSignals = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 11, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 6, 10, 14))).clone(namedValues=NamedValues(("val0-none", 1), ("val1-servSignal-stdFormat", 2), ("val5-servSignalAndPrompt-stdFormat", 6), ("val9-servSignal-explicitFormat", 10), ("val13-servSignalAndPrompt-explicitFormat", 14)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgX3P06ServiceSignals.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgX3P06ServiceSignals.setDescription("The value of this object is the control of service signals and command signals sent by the equipment. The authorized values are 'none' (no service signals are transmitted to the start-stop mode DTE), 'servSignal-stdFormat' (service signals other than the prompt PAD service signal are transmitted in the standard format), 'servSignalAndPrompt-stdFormat' (service signals and the prompt service signal are transmitted in the standard format), 'servSignal-explicitFormat' (service signals other than the prompt service signal are transmitted in the explicit format), 'servSignalAndPrompt-explicitFormat' (service signals and the prompt service signal are transmitted in the explicit format). The default value is 'servSignalAndPrompt-explicitFormat'.")
fclAsynCfgX3P07BreakHandling = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 11, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 5, 6, 9, 22))).clone(namedValues=NamedValues(("val0-forwardingChar", 1), ("val1-interrupt", 2), ("val2-reset", 3), ("val4-breakIndication", 5), ("val5-interrupt-breakIndication", 6), ("val8-escapeFromTransfer", 9), ("val21-interrupt-breakIndication-discardOutput", 22)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgX3P07BreakHandling.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgX3P07BreakHandling.setDescription("The value of this object is the selection of equipment operations on receipt of break signal from the start-stop mode DTE. The authorized values are 'forwardingChar' (no particular operation), 'interrupt' (send to packet mode DTE or other PAD an interrupt packet), 'reset' (reset), 'interrupt-breakIndication' (send to packet mode DTE or other PAD an interrupt packet and an indication of break PAD message), 'escapeFromTransfer' (escape from data transfer state), 'interrupt-breakIndication-discardOutput' (send to packet mode DTE or other PAD an interrupt packet and an indication of break PAD message, and discard output to start-stop mode DTE). The default value is 'reset'.")
fclAsynCfgX3P08OutputDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 11, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("val0-off", 1), ("val1-on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgX3P08OutputDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgX3P08OutputDiscard.setDescription("The value of this object indicates whether data are sent to the terminal or not. The authorized values are 'off' (normal data delivery to the start-stop mode DTE), 'on' (discard output to start-stop mode DTE). The default value is 'off'.")
fclAsynCfgX3P09CrPadding = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 11, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 250))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgX3P09CrPadding.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgX3P09CrPadding.setDescription("The value of this object indicates the padding after carriage return. The authorized values are '0..250'. A value between '0' and '250' will indicate the number of padding characters to be generated by the equipment after a carriage return character is transmitted to the start-stop mode DTE. When the value of this parameter is '0', there will be no padding except that PAD service signals will contain a number of padding characters according to the data rate of the start-stop mode DTE. The default value is '4'.")
fclAsynCfgX3P10LineFolding = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 11, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 250))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgX3P10LineFolding.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgX3P10LineFolding.setDescription("The value of this object indicates the line folding. The authorized values are '0..250'. The value '0' indicates no line folding. A value between '1' and '250' will indicate the number of graphic characters per line that will be transmitted by the equipment without inserting appropriate format effectors. The default value is '0'.")
fclAsynCfgX3P11BinarySpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 11, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 24, 18, 21, 22, 23))).clone(namedValues=NamedValues(("val0-110", 1), ("val1-134-5", 2), ("val2-300", 3), ("val3-1200", 4), ("val4-600", 5), ("val5-75", 6), ("val6-150", 7), ("val7-1800", 8), ("val8-200", 9), ("val9-100", 10), ("val10-50", 11), ("val11-in75Out1200", 12), ("val12-2400", 13), ("val13-4800", 14), ("val14-9600", 15), ("val15-19200", 16), ("val23-28800", 24), ("val17-57600", 18), ("val20-38400", 21), ("val21-out1200In75", 22), ("val22-115200", 23)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgX3P11BinarySpeed.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgX3P11BinarySpeed.setDescription('The value of this object is the binary speed in bits per second.')
fclAsynCfgX3Part2Table = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 12), )
if mibBuilder.loadTexts: fclAsynCfgX3Part2Table.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgX3Part2Table.setDescription('This table contains the X3 parameters (part 2) of asynchronous configurations.')
fclAsynCfgX3Part2Entry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 12, 1), ).setIndexNames((0, "PCE-MIB", "fclAsynCfgX3Part2ConfigId"))
if mibBuilder.loadTexts: fclAsynCfgX3Part2Entry.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgX3Part2Entry.setDescription('An entry of fclAsynCfgX3Part2Table.')
fclAsynCfgX3Part2ConfigId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 12, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclAsynCfgX3Part2ConfigId.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgX3Part2ConfigId.setDescription("The value of this object identifies one and only one asynchronous configuration. The possible values are : '0..199. If it is unused, the value of this parameter is '255'.")
fclAsynCfgX3Part2ProfileId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 12, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclAsynCfgX3Part2ProfileId.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgX3Part2ProfileId.setDescription('The value of this object is the X3 profile number used to create this configuration.')
fclAsynCfgX3P12InputFlowCtrl = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 12, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 9))).clone(namedValues=NamedValues(("val0-none", 1), ("val1-xonXoff", 2), ("val8-rtsCts", 9)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgX3P12InputFlowCtrl.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgX3P12InputFlowCtrl.setDescription("The value of this object indicates the flow control type from the start-stop mode DTE to the equipment. The authorized values are 'none' (no use of XON and XOFF for flow control), 'xonXoff' (use of XON and XOFF for flow control), 'rtsCts' (use of RTS and CTS for flow control). The default value is 'xonXoff'.")
fclAsynCfgX3P13LfInsertion = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 12, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("val0-none", 1), ("val1-outCr", 2), ("val2-inCr", 3), ("val3-outCr-inCr", 4), ("val4-outCrEcho", 5), ("val5-outCr-outCrEcho", 6), ("val6-inCr-outCrEcho", 7), ("val7-outCr-inCr-outCrEcho", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgX3P13LfInsertion.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgX3P13LfInsertion.setDescription("The value of this object indicates where there is the Line Feed insertion after Carriage Return. The authorized values are 'none' (no Line Feed insertion), 'outCr' (insert Line Feed after each Carriage Return in the data stream to the start-stop mode DTE), 'inCr' (insert Line Feed after each Carriage Return in the data stream from the start-stop mode DTE), 'outCr-inCr' (insert Line Feed after each Carriage Return in the data stream from and to the start-stop mode DTE), 'outCrEcho' (insert Line Feed after each Carriage Return in the echo stream to the start-stop mode DTE), 'outCr-outCrEcho' ('outCr' + 'outCrEcho'), 'inCr-outCrEcho' ('inCr' + 'outCrEcho'), 'outCr-inCr-outCrEcho' ('outCr-inCr' + 'outCrEcho'). The default value is 'none'.")
fclAsynCfgX3P14LfPadding = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 12, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 250))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgX3P14LfPadding.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgX3P14LfPadding.setDescription("The value of this object is the Line Feed padding. The authorized values are '0..250'. A value between '0' and '250' will indicate the number of padding characters to be generated by the equipement after a Line Feed character transmitted to the start-stop mode DTE during the data transfer state. The default value is '0'.")
fclAsynCfgX3P15Editing = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 12, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("val0-off", 1), ("val1-on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgX3P15Editing.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgX3P15Editing.setDescription("The value of this object indicates the editing mode. The authorized values are 'off', 'on'. The default value is 'on'.")
fclAsynCfgX3P16CharDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 12, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgX3P16CharDelete.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgX3P16CharDelete.setDescription("The value of this object is the 'character delete' character. The authorized values are '0..128'. The default value is '127'.")
fclAsynCfgX3P17LineDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 12, 1, 27), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgX3P17LineDelete.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgX3P17LineDelete.setDescription("The value of this object is the 'line delete' character. The authorized values are '0..128'. The default value is '24'.")
fclAsynCfgX3P18LineDisplay = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 12, 1, 28), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgX3P18LineDisplay.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgX3P18LineDisplay.setDescription("The value of this object is the 'line display' character. The authorized values are '0..127'. The default value is '0'.")
fclAsynCfgX3P19EditingSignal = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 12, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("val0-none", 1), ("val1-printingTerminal", 2), ("val2-displayTerminal", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgX3P19EditingSignal.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgX3P19EditingSignal.setDescription("The value of this object defines the editing PAD service signals. The authorized values are 'none' (no editing PAD service signals), 'printingTerminal' (editing PAD service signals for printing terminals), 'displayTerminal' (editing PAD service signals for display terminals). The default value is 'displayTerminal'.")
fclAsynCfgX3P20EchoMask = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 12, 1, 30), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgX3P20EchoMask.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgX3P20EchoMask.setDescription("The value of this object is the echo mask. The authorized values are '0..255'. The default value is '64'.")
fclAsynCfgX3P21Parity = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 12, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("val0-none", 1), ("val1-check", 2), ("val2-generate", 3), ("val3-check-generate", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgX3P21Parity.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgX3P21Parity.setDescription("The value of this object indicates the parity treatment. The authorized values are 'none' (no parity checking or generation), 'check' (parity checking), 'generate' (parity generation), 'check-generate' (parity checking and generation). The default value is 'none'.")
fclAsynCfgX3P22PageWait = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 12, 1, 32), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgX3P22PageWait.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgX3P22PageWait.setDescription("The value of this object defines the page wait. The authorized values are '0..127'. The value '0' indicates that the page wait is disabled. A value between '1' and '127' is the number of Line Feed characters sent by the equipment to the start-stop mode DTE. The default value is '0'.")
fclAsynCfgX3UserProfilePart1 = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 15))
fclAsynCfgX3UserProfileId = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 15, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclAsynCfgX3UserProfileId.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgX3UserProfileId.setDescription('The value of this object is 80 the number of the user profile. This profile may be used, as any other X3 profile, to make a new asynchronous configuration in fclAsynCfgConfigTable.')
fclAsynCfgX3UserProfileDesc = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 15, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgX3UserProfileDesc.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgX3UserProfileDesc.setDescription("The value of this object stores a text description of the user profile elaborated by the user. This description may contains from 0 to 32 characters. The default value is 'User profile'.")
fclAsynCfgX3UserP01EscapeChar = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 15, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 126))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgX3UserP01EscapeChar.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgX3UserP01EscapeChar.setDescription("The value of this object is the character to escape from the data transfer state and to recall the PAD. The authorized values are '0..126'. The value '0' indicates no escape. The value '1' is the DLE character. The values '2..126' are the ASCII code of the character. The default value is '1'.")
fclAsynCfgX3UserP02Echo = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 15, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("val0-off", 1), ("val1-on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgX3UserP02Echo.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgX3UserP02Echo.setDescription("The value of this object indicates whether the echo is local not. The authorized values are 'off' (echoing by the terminal), 'on' (echoing by the equipment). The default value is 'on'.")
fclAsynCfgX3UserP03ForwardingChar = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 15, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 7, 19, 33, 127, 128, 129, 254, 255))).clone(namedValues=NamedValues(("val0-none", 1), ("val2-cr", 3), ("val6-crEscBelEnqAck", 7), ("val18-crEotEtx", 19), ("val32-htLfVtFf", 33), ("val126-allCtrlChars", 127), ("val127-allChars", 128), ("val128-allCtrlChars-vdxFunctionKeys", 129), ("val253-encapsCharacSLIP", 254), ("val254-encapsCharacPPP", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgX3UserP03ForwardingChar.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgX3UserP03ForwardingChar.setDescription("The value of this object is the data forwarding character(s). The authorized values are 'none' (no character), 'CR' (Carriage Return), 'CR ESC BEL ENQ ACK' (Carriage Return, Escape, Bell, Enquire, Acknowledge), 'CR EOT ETX' (Carriage Return, End Of Text, End Of Transmission), 'HT LF VT FF' (Horizontal Tabulation, Line Feed, Vertical Tabulation, Form Feed), 'all Ctrl Chars' (all control characters), 'all Chars' (all characters), 'all Ctrl Chars vdxFunctionKeys' (all control characters and videotext function keys) 'encapsCharacSLIP', 'encapsCharacPPP'. The default value is 'all Ctrl Chars'.")
fclAsynCfgX3UserP04IdleTimerDelay = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 15, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 250))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgX3UserP04IdleTimerDelay.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgX3UserP04IdleTimerDelay.setDescription("The value of this object is the idle timer delay in twentieths of a second. The authorized values are '0..250'. The value '0' will indicate that no data forwarding on time-out is required. The default value is '0'.")
fclAsynCfgX3UserP05OutputFlowCtrl = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 15, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 9))).clone(namedValues=NamedValues(("val0-none", 1), ("val1-xonXoffInTransfer", 2), ("val2-xonXoff", 3), ("val8-rtsCtsInTransfer", 9)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgX3UserP05OutputFlowCtrl.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgX3UserP05OutputFlowCtrl.setDescription("The value of this object indicates the flow control type from the equipment to the terminal. The authorized values are 'none' (no use of XON and XOFF), 'xonXoffInTransfer' (use of XON and XOFF in data transfer), 'xonXoff' (use of XON and XOFF in data transfer and command), 'rtsCtsInTransfer' (use of CTS and RTS signals in transfer). The default value is 'none'.")
fclAsynCfgX3UserP06ServiceSignals = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 15, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 6, 10, 14))).clone(namedValues=NamedValues(("val0-none", 1), ("val1-servSignal-stdFormat", 2), ("val5-servSignalAndPrompt-stdFormat", 6), ("val9-servSignal-explicitFormat", 10), ("val13-servSignalAndPrompt-explicitFormat", 14)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgX3UserP06ServiceSignals.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgX3UserP06ServiceSignals.setDescription("The value of this object is the control of service signals and command signals sent by the equipment. The authorized values are 'none' (no service signals are transmitted to the start-stop mode DTE), 'servSignal-stdFormat' (service signals other than the prompt PAD service signal are transmitted in the standard format), 'servSignalAndPrompt-stdFormat' (service signals and the prompt service signal are transmitted in the standard format), 'servSignal-explicitFormat' (service signals other than the prompt service signal are transmitted in the explicit format), 'servSignalAndPrompt-explicitFormat' (service signals and the prompt service signal are transmitted in the explicit format). The default value is 'servSignalAndPrompt-explicitFormat'.")
fclAsynCfgX3UserP07BreakHandling = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 15, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 5, 6, 9, 22))).clone(namedValues=NamedValues(("val0-forwardingChar", 1), ("val1-interrupt", 2), ("val2-reset", 3), ("val4-breakIndication", 5), ("val5-interrupt-breakIndication", 6), ("val8-escapeFromTransfer", 9), ("val21-interrupt-breakIndication-discardOutput", 22)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgX3UserP07BreakHandling.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgX3UserP07BreakHandling.setDescription("The value of this object is the selection of equipment operations on receipt of break signal from the start-stop mode DTE. The authorized values are 'forwardingChar' (no particular operation), 'interrupt' (send to packet mode DTE or other PAD an interrupt packet), 'reset' (reset), 'interrupt-breakIndication' (send to packet mode DTE or other PAD an interrupt packet and an indication of break PAD message), 'escapeFromTransfer' (escape from data transfer state), 'interrupt-breakIndication-discardOutput' (send to packet mode DTE or other PAD an interrupt packet and an indication of break PAD message, and discard output to start-stop mode DTE). The default value is 'reset'.")
fclAsynCfgX3UserP08OutputDiscard = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 15, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("val0-off", 1), ("val1-on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgX3UserP08OutputDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgX3UserP08OutputDiscard.setDescription("The value of this object indicates whether data are sent to the terminal or not. The authorized values are 'off' (normal data delivery to the start-stop mode DTE), 'on' (discard output to start-stop mode DTE). The default value is 'off'.")
fclAsynCfgX3UserP09CrPadding = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 15, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 250))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgX3UserP09CrPadding.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgX3UserP09CrPadding.setDescription("The value of this object indicates the padding after carriage return. The authorized values are '0..250'. A value between '0' and '250' will indicate the number of padding characters to be generated by the equipment after a carriage return character is transmitted to the start-stop mode DTE. When the value of this parameter is '0', there will be no padding except that PAD service signals will contain a number of padding characters according to the data rate of the start-stop mode DTE. The default value is '4'.")
fclAsynCfgX3UserP10LineFolding = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 15, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 250))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgX3UserP10LineFolding.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgX3UserP10LineFolding.setDescription("The value of this object indicates the line folding. The authorized values are '0..250'. The value '0' indicates no line folding. A value between '1' and '250' will indicate the number of graphic characters per line that will be transmitted by the equipment without inserting appropriate format effectors. The default value is '0'.")
fclAsynCfgX3UserP11BinarySpeed = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 15, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 24, 18, 21, 22, 23))).clone(namedValues=NamedValues(("val0-110", 1), ("val1-134-5", 2), ("val2-300", 3), ("val3-1200", 4), ("val4-600", 5), ("val5-75", 6), ("val6-150", 7), ("val7-1800", 8), ("val8-200", 9), ("val9-100", 10), ("val10-50", 11), ("val11-75-1200", 12), ("val12-2400", 13), ("val13-4800", 14), ("val14-9600", 15), ("val15-19200", 16), ("val23-28800", 24), ("val17-57600", 18), ("val20-38400", 21), ("val21-1200-75", 22), ("val22-115200", 23)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgX3UserP11BinarySpeed.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgX3UserP11BinarySpeed.setDescription('The value of this object is the binary speed in bits per second.')
fclAsynCfgX3UserProfilePart2 = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 16))
fclAsynCfgX3UserP12InputFlowCtrl = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 16, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 9))).clone(namedValues=NamedValues(("val0-none", 1), ("val1-xonXoff", 2), ("val8-rtsCts", 9)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgX3UserP12InputFlowCtrl.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgX3UserP12InputFlowCtrl.setDescription("The value of this object indicates the flow control type from the start-stop mode DTE to the equipment. The authorized values are 'none' (no use of XON and XOFF for flow control), 'xonXoff' (use of XON and XOFF for flow control), 'rtsCts' (use of RTS and CTS for flow control). The default value is 'xonXoff'.")
fclAsynCfgX3UserP13LfInsertion = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 16, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("val0-none", 1), ("val1-outCr", 2), ("val2-inCr", 3), ("val3-outCr-inCr", 4), ("val4-outCrEcho", 5), ("val5-outCr-outCrEcho", 6), ("val6-inCr-outCrEcho", 7), ("val7-outCr-inCr-outCrEcho", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgX3UserP13LfInsertion.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgX3UserP13LfInsertion.setDescription("The value of this object indicates where there is the Line Feed insertion after Carriage Return. The authorized values are 'none' (no Line Feed insertion), 'outCr' (insert Line Feed after each Carriage Return in the data stream to the start-stop mode DTE), 'inCr' (insert Line Feed after each Carriage Return in the data stream from the start-stop mode DTE), 'outCr-inCr' (insert Line Feed after each Carriage Return in the data stream from and to the start-stop mode DTE), 'outCrEcho' (insert Line Feed after each Carriage Return in the echo stream to the start-stop mode DTE), 'outCr-outCrEcho' ('outCr' + 'outCrEcho'), 'inCr-outCrEcho' ('inCr' + 'outCrEcho'), 'outCr-inCr-outCrEcho' ('outCr-inCr' + 'outCrEcho'). The default value is 'none'.")
fclAsynCfgX3UserP14LfPadding = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 16, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 250))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgX3UserP14LfPadding.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgX3UserP14LfPadding.setDescription("The value of this object is the Line Feed padding. The authorized values are '0..250'. A value between '0' and '250' will indicate the number of padding characters to be generated by the equipement after a Line Feed character transmitted to the start-stop mode DTE during the data transfer state. The default value is '0'.")
fclAsynCfgX3UserP15Editing = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 16, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("val0-off", 1), ("val1-on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgX3UserP15Editing.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgX3UserP15Editing.setDescription("The value of this object indicates the editing mode. The authorized values are 'off', 'on'. The default value is 'on'.")
fclAsynCfgX3UserP16CharDelete = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 16, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgX3UserP16CharDelete.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgX3UserP16CharDelete.setDescription("The value of this object is the 'character delete' character. The authorized values are '0..128'. The default value is '127'.")
fclAsynCfgX3UserP17LineDelete = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 16, 27), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgX3UserP17LineDelete.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgX3UserP17LineDelete.setDescription("The value of this object is the 'line delete' character. The authorized values are '0..128'. The default value is '24'.")
fclAsynCfgX3UserP18LineDisplay = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 16, 28), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgX3UserP18LineDisplay.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgX3UserP18LineDisplay.setDescription("The value of this object is the 'line display' character. The authorized values are '0..127'. The default value is '0'.")
fclAsynCfgX3UserP19EditingSignal = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 16, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("val0-none", 1), ("val1-printingTerminal", 2), ("val2-displayTerminal", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgX3UserP19EditingSignal.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgX3UserP19EditingSignal.setDescription("The value of this object defines the editing PAD service signals. The authorized values are 'none' (no editing PAD service signals), 'printingTerminal' (editing PAD service signals for printing terminals), 'displayTerminal' (editing PAD service signals for display terminals). The default value is 'displayTerminal'.")
fclAsynCfgX3UserP20EchoMask = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 16, 30), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgX3UserP20EchoMask.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgX3UserP20EchoMask.setDescription("The value of this object is the echo mask. The authorized values are '0..255'. The default value is '64'.")
fclAsynCfgX3UserP21Parity = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 16, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("val0-none", 1), ("val1-check", 2), ("val2-generate", 3), ("val3-check-generate", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgX3UserP21Parity.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgX3UserP21Parity.setDescription("The value of this object indicates the parity treatment. The authorized values are 'none' (no parity checking or generation), 'check' (parity checking), 'generate' (parity generation), 'check-generate' (parity checking and generation). The default value is 'none'.")
fclAsynCfgX3UserP22PageWait = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 16, 32), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgX3UserP22PageWait.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgX3UserP22PageWait.setDescription("The value of this object defines the page wait. The authorized values are '0..127'. The value '0' indicates that the page wait is disabled. A value between '1' and '127' is the number of Line Feed characters sent by the equipment to the start-stop mode DTE. The default value is '0'.")
fclAsynCfgConnLinkTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 21), )
if mibBuilder.loadTexts: fclAsynCfgConnLinkTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgConnLinkTable.setDescription('This table contains the connection parameters (link part) of asynchronous configurations.')
fclAsynCfgConnLinkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 21, 1), ).setIndexNames((0, "PCE-MIB", "fclAsynCfgLinkConfigId"))
if mibBuilder.loadTexts: fclAsynCfgConnLinkEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgConnLinkEntry.setDescription('An entry of fclAsynCfgConnLinkTable.')
fclAsynCfgLinkConfigId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 21, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclAsynCfgLinkConfigId.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgLinkConfigId.setDescription("The value of this object identifies one and only one asynchronous configuration. The possible values are : '0..199. If it is unused, the value of this parameter is '255'.")
fclAsynCfgLinkXonXoffParity = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 21, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 1, 2))).clone(namedValues=NamedValues(("none", 3), ("even", 1), ("odd", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgLinkXonXoffParity.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgLinkXonXoffParity.setDescription("The value of this object indicates the XON/XOFF parity. The default value is 'even'.")
fclAsynCfgLinkServSignalParity = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 21, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 1, 2))).clone(namedValues=NamedValues(("none", 3), ("even", 1), ("odd", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgLinkServSignalParity.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgLinkServSignalParity.setDescription("The value of this object indicates the signals parity. The default value is 'even'.")
fclAsynCfgLinkDataParity = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 21, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4, 2))).clone(namedValues=NamedValues(("none", 1), ("even", 4), ("odd", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgLinkDataParity.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgLinkDataParity.setDescription("The value of this object indicates the data parity. The default value is 'even'.")
fclAsynCfgLinkBitCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 21, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(7, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgLinkBitCount.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgLinkBitCount.setDescription("The value of this object indicates the number of bits by characters. The authorized values are '7' or '8'. The default value is '7'.")
fclAsynCfgLinkStopBitCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 21, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4, 8, 12))).clone(namedValues=NamedValues(("one", 4), ("oneAndAHalf", 8), ("two", 12)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgLinkStopBitCount.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgLinkStopBitCount.setDescription("The value of this object defines the number of stop bits. The default value is 'one'.")
fclAsynCfgLinkXonXoffSignal = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 21, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgLinkXonXoffSignal.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgLinkXonXoffSignal.setDescription("The value of this object indicates if there are a transmission of XOFF when moving to the command mode and a transmission of XON when moving to the data transmission mode. The default value is 'on'.")
fclAsynCfgLinkInactivityTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 21, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2500))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgLinkInactivityTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgLinkInactivityTimer.setDescription("The value of this object defines the line inactivity time-out in transfer state. When the time-out expires, the call is cleared. For a Minitel using a PSTN profile, the telephone communication is cut when the VC is cleared (This after T/2 seconds). The authorized values are '0..2500'. The value '0' indicates no time-out. The default value is '0'.")
fclAsynCfgLinkBlockSize = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 21, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgLinkBlockSize.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgLinkBlockSize.setDescription("The value of this object indicates the number of bytes received by the equipment in the receive buffers. The authorized values are '1..128'. The default value is '128'.")
fclAsynCfgLinkCallResponseTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 21, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 2500))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgLinkCallResponseTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgLinkCallResponseTimer.setDescription("The value of this object is the supervision time-out for response to a call request packet sent on the link. A clear packet is sent if there is no response after this period. The authorized values are '10..2500'. The default value is '20'.")
fclAsynCfgConnFacilityTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 25), )
if mibBuilder.loadTexts: fclAsynCfgConnFacilityTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgConnFacilityTable.setDescription('This table contains the connection parameters (facility part) of asynchronous configurations.')
fclAsynCfgConnFacilityEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 25, 1), ).setIndexNames((0, "PCE-MIB", "fclAsynCfgFacConfigId"))
if mibBuilder.loadTexts: fclAsynCfgConnFacilityEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgConnFacilityEntry.setDescription('An entry of fclAsynCfgConnFacilityTable.')
fclAsynCfgFacConfigId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 25, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclAsynCfgFacConfigId.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgFacConfigId.setDescription("The value of this object identifies one and only one asynchronous configuration. The possible values are : '0..199. If it is unused, the value of this parameter is '255'.")
fclAsynCfgFacClosedUserGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 25, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 1, 3))).clone(namedValues=NamedValues(("noCheck", 2), ("clear", 1), ("subscribe", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgFacClosedUserGroup.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgFacClosedUserGroup.setDescription("The value of this object specifies the behaviour of the equipment with respect to the Closed User Group (CUG) facility. There are 3 possible values : noCheck : the CUG is not checked, clear : clearing if the CUG is present in the call packet, subscribe : clearing if the CUG is not present in the call packet. The default value is 'noCheck'.")
fclAsynCfgFacReverseCharging = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 25, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("refuse", 1), ("accept", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgFacReverseCharging.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgFacReverseCharging.setDescription("The value of this object specifies the behaviour of the equipment with respect to the reverse charging facility. If the called subscriber doesn't accept the reverse charging, the call is not transmitted and a clear is sent. The default value is 'refuse'.")
fclAsynCfgFacThroughputClass = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 25, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clear", 1), ("subscribe", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgFacThroughputClass.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgFacThroughputClass.setDescription("The value of this object indicates if the subscriber connected to the link has subscribed to throughput class negociation facility. The authorized values are 'clear' (not subscriber) or 'subscribe'. The default value is 'clear'.")
fclAsynCfgFacDefOutThroughputClass = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 25, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("t75", 3), ("t150", 4), ("t300", 5), ("t600", 6), ("t1200", 7), ("t2400", 8), ("t4800", 9), ("t9600", 10), ("t19200", 11), ("t48000", 12), ("t64000", 13), ("t128000", 14), ("t192000", 15)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgFacDefOutThroughputClass.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgFacDefOutThroughputClass.setDescription('The value of this object indicates the default throughput class in transmit direction (equipment to remote peer). The default value is 9600 bits per second.')
fclAsynCfgFacDefInThroughputClass = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 25, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("t75", 3), ("t150", 4), ("t300", 5), ("t600", 6), ("t1200", 7), ("t2400", 8), ("t4800", 9), ("t9600", 10), ("t19200", 11), ("t48000", 12), ("t64000", 13), ("t128000", 14), ("t192000", 15)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgFacDefInThroughputClass.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgFacDefInThroughputClass.setDescription('The value of this object indicates the default throughput class in receive direction (remote peer to equipment). The default value is 9600 bits per second.')
fclAsynCfgFacMaxOutThroughputClass = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 25, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("t75", 3), ("t150", 4), ("t300", 5), ("t600", 6), ("t1200", 7), ("t2400", 8), ("t4800", 9), ("t9600", 10), ("t19200", 11), ("t48000", 12), ("t64000", 13), ("t128000", 14), ("t192000", 15)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgFacMaxOutThroughputClass.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgFacMaxOutThroughputClass.setDescription('The value of this object indicates the maximum throughput class in transmit direction (equipment to remote peer). The default value is 9600 bits per second.')
fclAsynCfgFacMaxInThroughputClass = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 25, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("t75", 3), ("t150", 4), ("t300", 5), ("t600", 6), ("t1200", 7), ("t2400", 8), ("t4800", 9), ("t9600", 10), ("t19200", 11), ("t48000", 12), ("t64000", 13), ("t128000", 14), ("t192000", 15)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgFacMaxInThroughputClass.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgFacMaxInThroughputClass.setDescription('The value of this object indicates the maximum throughput class in receive direction (remote peer to equipment). The default value is 9600 bits per second.')
fclAsynCfgFacPacketSize = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 25, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clear", 1), ("subscribe", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgFacPacketSize.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgFacPacketSize.setDescription("The value of this object indicates if the subscriber connected to the link has subscribed to packet size negociation facility. The authorized values are 'clear' (not subscriber) or 'subscribe'. The default value is 'clear'.")
fclAsynCfgFacDefOutPacketSize = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 25, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("s16", 4), ("s32", 5), ("s64", 6), ("s128", 7), ("s256", 8), ("s512", 9), ("s1024", 10), ("s2048", 11), ("s4096", 12), ("s8192", 13)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgFacDefOutPacketSize.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgFacDefOutPacketSize.setDescription('The value of this object indicates the default packet size in transmit direction (equipment to remote peer). The default value is 128 octets.')
fclAsynCfgFacDefInPacketSize = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 25, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("s16", 4), ("s32", 5), ("s64", 6), ("s128", 7), ("s256", 8), ("s512", 9), ("s1024", 10), ("s2048", 11), ("s4096", 12), ("s8192", 13)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgFacDefInPacketSize.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgFacDefInPacketSize.setDescription('The value of this object indicates the default packet size in receive direction (remote peer to equipment). The default value is 128 octets.')
fclAsynCfgFacMaxOutPacketSize = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 25, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("s16", 4), ("s32", 5), ("s64", 6), ("s128", 7), ("s256", 8), ("s512", 9), ("s1024", 10), ("s2048", 11), ("s4096", 12), ("s8192", 13)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgFacMaxOutPacketSize.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgFacMaxOutPacketSize.setDescription('The value of this object indicates the maximum packet size in transmit direction (equipment to remote peer). The default value is 128 octets.')
fclAsynCfgFacMaxInPacketSize = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 25, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("s16", 4), ("s32", 5), ("s64", 6), ("s128", 7), ("s256", 8), ("s512", 9), ("s1024", 10), ("s2048", 11), ("s4096", 12), ("s8192", 13)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgFacMaxInPacketSize.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgFacMaxInPacketSize.setDescription('The value of this object indicates the maximum packet size in receive direction (remote peer to equipment). The default value is 128 octets.')
fclAsynCfgFacMinOutPacketSize = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 25, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("s16", 4), ("s32", 5), ("s64", 6), ("s128", 7), ("s256", 8), ("s512", 9), ("s1024", 10), ("s2048", 11), ("s4096", 12), ("s8192", 13)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgFacMinOutPacketSize.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgFacMinOutPacketSize.setDescription('The value of this object indicates the minimum packet size in transmit direction (equipment to remote peer). The default value is 16 octets.')
fclAsynCfgFacMinInPacketSize = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 25, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("s16", 4), ("s32", 5), ("s64", 6), ("s128", 7), ("s256", 8), ("s512", 9), ("s1024", 10), ("s2048", 11), ("s4096", 12), ("s8192", 13)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgFacMinInPacketSize.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgFacMinInPacketSize.setDescription('The value of this object indicates the minimum packet size in receive direction (remote peer to equipment). The default value is 16 octets.')
fclAsynCfgFacWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 25, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clear", 1), ("subscribe", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgFacWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgFacWindowSize.setDescription("The value of this object indicates if the subscriber connected to the link has subscribed to the negociation of the transmit window size facility. The authorized values are 'clear' (not subscriber) or 'subscribe'. The default value is 'clear'.")
fclAsynCfgFacDefOutWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 25, 1, 31), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgFacDefOutWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgFacDefOutWindowSize.setDescription("The value of this object indicates the default window size in transmit direction (equipment to remote peer). The authorized values are '1..7'. The default value is '2'.")
fclAsynCfgFacDefInWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 25, 1, 32), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgFacDefInWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgFacDefInWindowSize.setDescription("The value of this object indicates the default window size in receive direction (remote peer to equipment). The authorized values are '1..7'. The default value is '4'.")
fclAsynCfgFacMaxOutWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 25, 1, 33), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgFacMaxOutWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgFacMaxOutWindowSize.setDescription("The value of this object indicates the maximum window size in transmit direction (equipment to remote peer). The authorized values are '1..7'. The default value is '3'.")
fclAsynCfgFacMaxInWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 25, 1, 34), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgFacMaxInWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgFacMaxInWindowSize.setDescription("The value of this object indicates the maximum window size in receive direction (remote peer to equipment). The authorized values are '1..7'. The default value is '4'.")
fclAsynCfgConnServiceTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 30), )
if mibBuilder.loadTexts: fclAsynCfgConnServiceTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgConnServiceTable.setDescription('This table contains the connection parameters (service part) of asynchronous configurations.')
fclAsynCfgConnServiceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 30, 1), ).setIndexNames((0, "PCE-MIB", "fclAsynCfgSerConfigId"))
if mibBuilder.loadTexts: fclAsynCfgConnServiceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgConnServiceEntry.setDescription('An entry of fclAsynCfgConnServiceTable.')
fclAsynCfgSerConfigId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 30, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclAsynCfgSerConfigId.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgSerConfigId.setDescription("The value of this object identifies one and only one asynchronous configuration. The possible values are : '0..199. If it is unused, the value of this parameter is '255'.")
fclAsynCfgSerCompression = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 30, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("off", 1), ("networkToSubscriber", 2), ("subscriberToNetwork", 3), ("bothway", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgSerCompression.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgSerCompression.setDescription("The value of this object indicates the compression enabling for each direction. The authorized values are : off : no compression, networkToSubscriber : compression of the flow from the remote peer to the equipment, subscriberToNetwork : compression of the flow from the equipment to the remote peer, bothway : compression of the two flows from and to the equipment. The default value is 'off'.")
fclAsynCfgSerCompressNegociation = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 30, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("onOptionalCompression", 2), ("onMandatoryCompression", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgSerCompressNegociation.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgSerCompressNegociation.setDescription("The value of this object indicates whether the compression facility is negociated or not and, if negociated, the optional/obligatory status. The authorized values are : off' :no negociation, onOptionalCompression : negociation but compression is optional, onMandatoryCompression : negociation and compression is mandatory. The default value is 'off'.")
fclAsynCfgSerCompressScrambling = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 30, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgSerCompressScrambling.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgSerCompressScrambling.setDescription("The value of this object indicates, when the compression is active, whether the scrambling is enabled or not. The default value is 'off'.")
fclAsynCfgSerCompressMultiPacketsTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 30, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1500))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgSerCompressMultiPacketsTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgSerCompressMultiPacketsTimer.setDescription("The value of this object defines the maximum waiting time, in milliseconds by steps of 100 milliseconds , which, if there is not another packet to compress, the packet of compressed packets is sent beyond (this permits to reduce the number of packets transmitted to the remote peer). The authorized values are '0..1500'. '0' means no packets grouping (i. e. : each packet is individually compressed and sent). The default value is '0'.")
fclAsynCfgSerX29Reselection = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 30, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgSerX29Reselection.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgSerX29Reselection.setDescription("The value of this object indicates whether the subscriber connected to the link has subscribed to X29 reselection or not. The default value is 'off'.")
fclAsynCfgSerCallReturnTransmission = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 30, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3))).clone(namedValues=NamedValues(("off", 1), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgSerCallReturnTransmission.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgSerCallReturnTransmission.setDescription("The value of this object indicates whether the 'call return' packet may be sent on this link or not. The 'call return' packet, sent to the previous equipment, makes this equipments search for another route to join the called DTE. The defaut value is 'on'.")
fclAsynCfgSerDBitModification = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 30, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("clear", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgSerDBitModification.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgSerDBitModification.setDescription("The value of this object specifies the management of the D bit. The authorized values are 'off' or 'clear' (in this case, there is clearing ....) or 'on'. The default value is 'on'.")
fclAsynCfgSerReliableVc = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 30, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 2, 4))).clone(namedValues=NamedValues(("off", 1), ("clear", 3), ("subscribe", 2), ("check", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgSerReliableVc.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgSerReliableVc.setDescription("The value of this object is used to enable the Reliable Virtual Circuit service. The authorized values are : off : no RVC, the VCs are considered as normal VCs, no particular processing, clear : RVCs are not allowed for the subscriber, each attempt to establish a RVC provokes a clear of the connection, subscribe : all calls transmitted by the subscriber establish RVCs, it is also possible to receive calls with RVC option, check : for a link to a subscriber : when a call with RVC option is received, a RVC is established for a link to a network : the RVC option is ignored when it is present in a call sent by a local subscriber, the connection is cleared when the RVC option is present in a call sent by the network. The default value is 'off'.")
fclAsynCfgSerCos = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 30, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 1))).clone(namedValues=NamedValues(("ubr", 3), ("vbr", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgSerCos.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgSerCos.setDescription('COS')
fclAsynCfgSerCir = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 30, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(600, 2048000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgSerCir.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgSerCir.setDescription('Entrant CIR')
fclAsynCfgSerMinCir = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 30, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgSerMinCir.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgSerMinCir.setDescription('Entrant CIR mini')
fclAsynCfgSerConversionAimedPoint = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 30, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgSerConversionAimedPoint.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgSerConversionAimedPoint.setDescription('Conversion adresse : point vise')
fclAsynCfgSerConversionIncomingCall = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 30, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("off", 1), ("callingAddress", 2), ("calledAddress", 3), ("callingAddressAndCalledAddress", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgSerConversionIncomingCall.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgSerConversionIncomingCall.setDescription("Conversion d'adresse sur appel entrant")
fclAsynCfgSerConversionOutgoingCall = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 30, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("off", 1), ("callingAddress", 2), ("calledAddress", 3), ("callingAddressAndCalledAddress", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgSerConversionOutgoingCall.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgSerConversionOutgoingCall.setDescription('Conversion adresse sur appel sortant')
fclAsynCfgSerConversionAddressCheck = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 10, 30, 1, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("off", 1), ("onIncomingCall", 2), ("onOutgoingCall", 3), ("onIncomingCallAndOutgoingCall", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynCfgSerConversionAddressCheck.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynCfgSerConversionAddressCheck.setDescription('Conversion adresse : controle de la presence dans les tables de conversion')
fclAsynAutoCalls = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 20))
fclAsynAutoCallTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 20, 1), )
if mibBuilder.loadTexts: fclAsynAutoCallTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynAutoCallTable.setDescription("This table contains the asynchronous logical ports for which a call is automatically sent when the operational state of this LP becomes 'up'. For each LP this table defines the addres of the called remote peer and the different parameters of the call processing.")
fclAsynAutoCallEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 20, 1, 1), ).setIndexNames((0, "PCE-MIB", "fclAsynAutoLogPortId"))
if mibBuilder.loadTexts: fclAsynAutoCallEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynAutoCallEntry.setDescription('An entry of fclAsynAutoCallTable.')
fclAsynAutoLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 20, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclAsynAutoLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynAutoLogPortId.setDescription("The value of this object identifies one and only one asynchronous logical port. The possible values are : '0..131'. If it is unused, the value of this parameter is '255'.")
fclAsynAutoStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 20, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynAutoStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynAutoStatus.setDescription("The value of this object indicates the state of the entry of this table. The default value is 'valid'. It must be set to 'invalid' to delete the entry.")
fclAsynAutoCalledAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 20, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynAutoCalledAddr.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynAutoCalledAddr.setDescription("The value of this object is the X121 address of the called remote peer. This value is the called address specified in the call packet sent from this logical port. The value may contain up to 15 digits (digits 0..9). The value must be completed with 'F' digits for a total of 16 digits. The equipment configurator does not need final completion. The default value is 'FF FF FF FF FF FF FF FF' meaning 'empty value' (blank value on the equipment configurator).")
fclAsynAutoFacility = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 20, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 1), ("reverseCharging", 2), ("cug", 3), ("reverseCharging-cug", 4), ("throughputClass", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynAutoFacility.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynAutoFacility.setDescription("The value of this object indicates the facilities set in the call packet. The authorized values are 'none' (no facility), 'reverseCharging' (code '0101'), 'cug' (code '0300'), 'reverseCharging-cug' (code '01010300'), 'throughputClass' (code '02xx' where 'x' is the throughput class code defined by fclAsynAutoFacThroughputClass). The default value is 'none'.")
fclAsynAutoFacThroughputClass = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 20, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("t75", 3), ("t150", 4), ("t300", 5), ("t600", 6), ("t1200", 7), ("t2400", 8), ("t4800", 9), ("t9600", 10), ("t19200", 11), ("t48000", 12), ("t64000", 13), ("t128000", 14), ("t192000", 15)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynAutoFacThroughputClass.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynAutoFacThroughputClass.setDescription("The value of this object indicates the throughput class facility set in the call packet when the object fclAsynAutoFacility is set to 'throughputClass'. The authorized values, in bits per second, are 75 (code '3'), 150 (code '4'), 300 (code '5'), 600 (code '6'), 1200 (code '7'), 2400 (code '8'), 4800 (code '9'), 9600 (code 'A'), 19200 (code 'B'), 48000 (code 'C'), 64000 (code 'D'), 128000 (code 'E'), 192000 (code 'F'). The default value is 'none'.")
fclAsynAutoCallUserDataAscii = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 20, 1, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 12))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynAutoCallUserDataAscii.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynAutoCallUserDataAscii.setDescription('The value of this object is the call user data specified in DisplayString format. When both objects fclAsynAutoCallUserDataAscii and fclAsynAutoCallUserDataAscii are not empty the first one is ignored. The value may contain up to 12 characters. The default value is an empty string.')
fclAsynAutoCallUserDataHexa = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 20, 1, 1, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(13, 13)).setFixedLength(13)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynAutoCallUserDataHexa.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynAutoCallUserDataHexa.setDescription("The value of this object is the call user data specified in OCTET STRING format. When both objects fclAsynAutoCallUserDataAscii and fclAsynAutoCallUserDataAscii are not empty the first one is ignored. 13 bytes from 00 to FF must be specified. The first byte contains the number of following useful bytes. The trailing bytes must be set to 'FF'. The equipment configurator does not need this final completion. The default value is 'empty' (first byte set to '00').")
fclAsynAutoMinimumRecallTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 20, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 990))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynAutoMinimumRecallTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynAutoMinimumRecallTimer.setDescription("The value of this object specifies the minimum recall time (in seconds) between two successive calls. The authorized values are '0..990' by step of 10. The default value is '0'.")
fclAsynAutoDiscardCharDuringTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 20, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynAutoDiscardCharDuringTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynAutoDiscardCharDuringTimer.setDescription("The value of this object specifies the reaction of the equipment receiving a character from the asynchronous device during the recall time : either stops the timer and lets the operator with his asynchronous device to type any X28 command ('No' value), or discards the character and lets go on the recall timer('Yes' value). The authorized values are 'Yes' or 'No'. The default value is 'No'.")
fclAsynAutoVdxKeyTranslationTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 20, 2), )
if mibBuilder.loadTexts: fclAsynAutoVdxKeyTranslationTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynAutoVdxKeyTranslationTable.setDescription("This table contains the logical ports for which a call is automatically sent when the operational state of this LP becomes 'up'. This table describes how the videotext keyboard function keys are translated.")
fclAsynAutoVdxKeyTranslationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 20, 2, 1), ).setIndexNames((0, "PCE-MIB", "fclAsynAutoTransLpId"))
if mibBuilder.loadTexts: fclAsynAutoVdxKeyTranslationEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynAutoVdxKeyTranslationEntry.setDescription('An entry of fclAsynAutoVdxKeyTranslationTable.')
fclAsynAutoTransLpId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 20, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclAsynAutoTransLpId.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynAutoTransLpId.setDescription("The value of this object identifies one and only one asynchronous logical port. The possible values are : '0..131'. If it is unused, the value of this parameter is '255'.")
fclAsynAutoTransTranscoding = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 20, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynAutoTransTranscoding.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynAutoTransTranscoding.setDescription("The value of this object indicates whether the videotext keyboard function keys are transcoded or not. The default value is 'off'.")
fclAsynAutoTransProfile = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 20, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("p1", 1), ("p2", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynAutoTransProfile.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynAutoTransProfile.setDescription("The value of this object is the X3 profile number used during the transfert. The authorized values are 'p1' (profile number 1), 'p2' (profile number 2). The default value is 'p1'.")
fclAsynAutoTransAutoTermMode = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 20, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynAutoTransAutoTermMode.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynAutoTransAutoTermMode.setDescription("The value of this object indicates whether the automatic changeover to data communication standard during data transfert is enabled or not. The default value is 'off'.")
fclAsynAutoTransCFKeyHandling = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 20, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("local", 1), ("remote", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynAutoTransCFKeyHandling.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynAutoTransCFKeyHandling.setDescription("The value of this object indicates the handling of the videotext keyboard 'connexion/fin' key. The authorized values are 'local' (.....), 'remote' (....). The default value is 'local'.")
fclAsynAutoTransClearHangUp = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 20, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynAutoTransClearHangUp.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynAutoTransClearHangUp.setDescription("The value of this object indicates whether the local communication is hang up (case PSTN link) when a clear packet is received or not. The default value is 'off'.")
fclAsynMnemonic = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 21))
fclAsynMnemonicTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 21, 1), )
if mibBuilder.loadTexts: fclAsynMnemonicTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynMnemonicTable.setDescription('This table contains mnemonics that permit to associate names to remote peer. For each name this table defines the addres of the called remote peer and the different parameters of the call processing.')
fclAsynMnemonicEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 21, 1, 1), ).setIndexNames((0, "PCE-MIB", "fclAsynMneMnemonicId"))
if mibBuilder.loadTexts: fclAsynMnemonicEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynMnemonicEntry.setDescription('An entry of fclAsynMnemonicTable.')
fclAsynMneMnemonicId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 21, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 99))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclAsynMneMnemonicId.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynMneMnemonicId.setDescription("The value of this object identifies one and only one mnemonic (this value is used as index of this table instead of the mnemonic name to make the SNMP managers handle correctly this table). The possible values are : '0..99'. If it is unused, the value of this parameter is '255'.")
fclAsynMneStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 21, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynMneStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynMneStatus.setDescription("The value of this object indicates the state of the entry of this table. The default value is 'valid'. It must be set to 'invalid' to delete the entry.")
fclAsynMneName = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 21, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 6))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynMneName.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynMneName.setDescription('The value of this object is the mnemonic name. The value may contain up to 6 characters. The default value is an empty string.')
fclAsynMneCalledAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 21, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynMneCalledAddr.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynMneCalledAddr.setDescription("The value of this object is the X121 address of the called remote peer. This value is the called address specified in the call packet sent from this logical port. The value may contain up to 15 digits (digits 0..9). The value must be completed with 'F' digits for a total of 16 digits. The equipment configurator does not need final completion. The default value is 'FF FF FF FF FF FF FF FF' meaning 'empty value' (blank value on the equipment configurator).")
fclAsynMneFacility = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 21, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 1), ("reverseCharging", 2), ("cug", 3), ("reverseCharging-cug", 4), ("throughputClass", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynMneFacility.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynMneFacility.setDescription("The value of this object indicates the facilities set in the call packet. The authorized values are 'none' (no facility), 'reverseCharging' (code '0101'), 'cug' (code '0300'), 'reverseCharging-cug' (code '01010300'), 'throughputClass' (code '02xx' where 'x' is the throughput class code defined by fclAsynMneFacThroughputClass). The default value is 'none'.")
fclAsynMneFacThroughputClass = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 21, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("t75", 3), ("t150", 4), ("t300", 5), ("t600", 6), ("t1200", 7), ("t2400", 8), ("t4800", 9), ("t9600", 10), ("t19200", 11), ("t48000", 12), ("t64000", 13), ("t128000", 14), ("t192000", 15)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynMneFacThroughputClass.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynMneFacThroughputClass.setDescription("The value of this object indicates the throughput class facility set in the call packet when the object fclAsynMneFacility is set to 'throughputClass'. The authorized values, in bits per second, are 75 (code '3'), 150 (code '4'), 300 (code '5'), 600 (code '6'), 1200 (code '7'), 2400 (code '8'), 4800 (code '9'), 9600 (code 'A'), 19200 (code 'B'), 48000 (code 'C'), 64000 (code 'D'), 128000 (code 'E'), 192000 (code 'F'). The default value is 'none'.")
fclAsynMneCallUserDataAscii = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 21, 1, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 12))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynMneCallUserDataAscii.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynMneCallUserDataAscii.setDescription('The value of this object is the call user data specified in DisplayString format. When both objects fclAsynMneCallUserDataAscii and fclAsynMneCallUserDataAscii are not empty the first one is ignored. The value may contain up to 12 characters. The default value is an empty string.')
fclAsynMneCallUserDataHexa = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 21, 1, 1, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(13, 13)).setFixedLength(13)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynMneCallUserDataHexa.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynMneCallUserDataHexa.setDescription("The value of this object is the call user data specified in OCTET STRING format. When both objects fclAsynMneCallUserDataAscii and fclAsynMneCallUserDataAscii are not empty the first one is ignored. 13 bytes from 00 to FF must be specified. The first byte contains the number of following useful bytes. The trailing bytes must be set to 'FF'. The equipment configurator does not need this final completion. The default value is 'empty' (first byte set to '00').")
fclAsynMneVdxKeyTranslationTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 21, 2), )
if mibBuilder.loadTexts: fclAsynMneVdxKeyTranslationTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynMneVdxKeyTranslationTable.setDescription('This table contains mnemonics that permit to associate names to remote peer. This table describes how the videotext keyboard function keys are translated.')
fclAsynMneVdxKeyTranslationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 21, 2, 1), ).setIndexNames((0, "PCE-MIB", "fclAsynMneTransMnemonicId"))
if mibBuilder.loadTexts: fclAsynMneVdxKeyTranslationEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynMneVdxKeyTranslationEntry.setDescription('An entry of fclAsynMneVdxKeyTranslationTable.')
fclAsynMneTransMnemonicId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 21, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 99))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclAsynMneTransMnemonicId.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynMneTransMnemonicId.setDescription("The value of this object identifies one and only one mnemonic (this value is used as index of this table instead of the mnemonic name to make the SNMP managers handle correctly this table). The possible values are : '0..99. If it is unused, the value of this parameter is '255'.")
fclAsynMneTransName = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 21, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 6))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclAsynMneTransName.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynMneTransName.setDescription('The value of this object is the mnemonic name.')
fclAsynMneTransTranscoding = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 21, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynMneTransTranscoding.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynMneTransTranscoding.setDescription("The value of this object indicates whether the videotext keyboard function keys are transcoded or not. The default value is 'off'.")
fclAsynMneTransProfile = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 21, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("p1", 1), ("p2", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynMneTransProfile.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynMneTransProfile.setDescription("The value of this object is the X3 profile number used during the transfert. The authorized values are 'p1' (profile number 1), 'p2' (profile number 2). The default value is 'p1'.")
fclAsynMneTransAutoTermMode = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 21, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynMneTransAutoTermMode.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynMneTransAutoTermMode.setDescription("The value of this object indicates whether the automatic changeover to data communication standard during data transfert is enabled or not. The default value is 'off'.")
fclAsynMneTransCFKeyHandling = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 21, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("local", 1), ("remote", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynMneTransCFKeyHandling.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynMneTransCFKeyHandling.setDescription("The value of this object indicates the handling of the videotext keyboard 'connexion/fin' key. The authorized values are 'local' (.....), 'remote' (....). The default value is 'local'.")
fclAsynMneTransClearHangUp = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 21, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynMneTransClearHangUp.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynMneTransClearHangUp.setDescription("The value of this object indicates whether the local communication is hang up (case PSTN link) when a clear packet is received or not. The default value is 'off'.")
fclAsynPstnRemotePeerTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 25), )
if mibBuilder.loadTexts: fclAsynPstnRemotePeerTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynPstnRemotePeerTable.setDescription('This table contains the remote peers to call by Public Switched Telephone Network way.')
fclAsynPstnRemotePeerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 25, 1), ).setIndexNames((0, "PCE-MIB", "fclAsynPstnRemX121Addr"))
if mibBuilder.loadTexts: fclAsynPstnRemotePeerEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynPstnRemotePeerEntry.setDescription('An entry of fclAsynPstnRemotePeerTable.')
fclAsynPstnRemX121Addr = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 25, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclAsynPstnRemX121Addr.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynPstnRemX121Addr.setDescription("The value of this object is the X121 address of the called remote peer. The value may contain up to 15 digits (digits 0..9, B, D). The digits 'B', 'D' (respectively characters '*', '?' on the equipment configurator) have special meanings : 'B' matches any address. When used it must be the only digit specified (with final completion as explained below). 'D' matches any single digit. The value must be completed with 'F' digits for a total of 16 digits. The equipment configurator does not need final completion. The default value is 'FF FF FF FF FF FF FF FF' meaning 'empty value' (blank value on the equipment configurator).")
fclAsynPstnRemStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 25, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynPstnRemStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynPstnRemStatus.setDescription('Status')
fclAsynPstnRemPstnNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 25, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(14, 14)).setFixedLength(14)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynPstnRemPstnNumber.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynPstnRemPstnNumber.setDescription("The value of this object is the PSTN address of the called remote peer. The value may contain up to 28 digits (digits 0..E). The digits 'A', 'B', 'C', 'D', 'E' (respectively characters 'W', ',', 'P', 'T', '!' on the equipment configurator) have special meanings : 'A' means 'attente de tonalite', 'B' means 'pause of 2 seconds', 'C' means 'numerotation decimale', 'D' means 'numerotation multifrequence', 'E' means 'raccrocher 0.5 second'. The value must be completed with 'F' digits for a total of 28 digits. The equipment configurator does not need final completion. The default value is 'FF FF FF FF FF FF FF FF' meaning 'empty value' (blank value on the equipment configurator).")
fclAsynNetUserTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 26), )
if mibBuilder.loadTexts: fclAsynNetUserTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynNetUserTable.setDescription('This table contains user identifications.')
fclAsynNetUserEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 26, 1), ).setIndexNames((0, "PCE-MIB", "fclAsynNetUserId"))
if mibBuilder.loadTexts: fclAsynNetUserEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynNetUserEntry.setDescription('An entry of fclAsynNetUserTable.')
fclAsynNetUserId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 26, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 254))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclAsynNetUserId.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynNetUserId.setDescription("The value of this object identifies one and only one user (this value is used as index of this table instead of the NUI to make the SNMP managers handle correctly this table). The possible values are : '0..254'. If it is unused, the value of this parameter is '255'.")
fclAsynNetStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 26, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynNetStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynNetStatus.setDescription("The value of this object indicates the state of the entry of this table. The default value is 'valid'. It must be set to 'invalid' to delete the entry.")
fclAsynNetNui = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 26, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 6))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynNetNui.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynNetNui.setDescription('The value of this object is the NUI (Network User Identifier). The authorized values are all the alphabetical characters strings on 6 characters. The default value is the empty string.')
fclAsynNetNua = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 5, 26, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9999))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclAsynNetNua.setStatus('mandatory')
if mibBuilder.loadTexts: fclAsynNetNua.setDescription("The value of this object is the NUA (Network User Access). The authorized values are '0..9999'. If it is unused, the value is '65535'. The default value is '65535'.")
fclFrameRelayAccessLogPort = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 13))
fclFraLogPortTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 13, 1), )
if mibBuilder.loadTexts: fclFraLogPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclFraLogPortTable.setDescription('This table defines the general parameters of Frame Relay Access logical ports. These FRA logical ports are used when X25 Virtual Channel must be established between local FR PVC (Frame Relay Permanent Virtual Circuit) end points and remote FR PVC end points through a X25 network. They are not adapted to cross a Frame Relay network (see FR CE logical ports in this case).')
fclFraLogPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 13, 1, 1), ).setIndexNames((0, "PCE-MIB", "fclFraLpLogPortId"))
if mibBuilder.loadTexts: fclFraLogPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclFraLogPortEntry.setDescription('An entry of fclFraLogPortTable.')
fclFraLpLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 13, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclFraLpLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclFraLpLogPortId.setDescription("The value of this object identifies one and only one Frame Relay Access logical port. The possible values are : '0..131'. If it is unused, the value of this parameter is '255'. The default value is '255'.")
fclFraLpInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 13, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFraLpInterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: fclFraLpInterfaceId.setDescription("The value of this object identifies the line interface used by this FRA logical port. The possible values are : '0..35'. If it is unused, the value of this parameter is '255'. The default value is '255'.")
fclFraLpLmi = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 13, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("lmiUni", 2), ("lmiNui", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFraLpLmi.setStatus('mandatory')
if mibBuilder.loadTexts: fclFraLpLmi.setDescription("The value of this object defines which kind of signalling is used on this FRA logical port. The possible values are 'off' (no signalling), lmiUni (Link Management Interface - User to Network Interface : the equipment performs user-side procedures), lmiNui (Link Management Interface - Network to User Interface : the equipment performs network-side procedures). The default value is '255'.")
fclFraLpGroupingThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 13, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 97))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFraLpGroupingThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: fclFraLpGroupingThreshold.setDescription("The value of this object is the input resource threshold over which several input frames coming from a FR PVC end point are grouped in a single X25 packet to cross the X25 network. The enabling of this grouping is PVC end point specific (see fclFraPvcEncapsulation). The possible values are : '1..97'. The thresholds must be set as following : fclFraLpGroupingThreshold < fclFraLpFecnBecnThreshold < fclFraLpDeDiscardThreshold < fclFraLpAllDiscardThreshold. The default value is '1'.")
fclFraLpFecnBecnThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 13, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 98))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFraLpFecnBecnThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: fclFraLpFecnBecnThreshold.setDescription("The value of this object is the input resource threshold over which bits FECN (Forward Explicit Congestion Notification) of input frames and BECN (Backward Explicit Congestion Notification) of output frames are set to 1. The possible values are : '2..98'. The thresholds must be set as following : fclFraLpGroupingThreshold < fclFraLpFecnBecnThreshold < fclFraLpDeDiscardThreshold < fclFraLpAllDiscardThreshold. The default value is '10'.")
fclFraLpDeDiscardThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 13, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(3, 99))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFraLpDeDiscardThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: fclFraLpDeDiscardThreshold.setDescription("The value of this object is the input resource threshold over which input frames with bit DE (Discard Eligible) set to 1 are discarded (i.e. : not sent accross the X25 network). The possible values are : '3..99'. The thresholds must be set as following : fclFraLpGroupingThreshold < fclFraLpFecnBecnThreshold < fclFraLpDeDiscardThreshold < fclFraLpAllDiscardThreshold. The default value is '15'.")
fclFraLpAllDiscardThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 13, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(4, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFraLpAllDiscardThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: fclFraLpAllDiscardThreshold.setDescription("The value of this object is the input resource threshold over which all input frames are discarded (i.e. : not sent accross the X25 network). The possible values are : '4..100'. The thresholds must be set as following : fclFraLpGroupingThreshold < fclFraLpFecnBecnThreshold < fclFraLpDeDiscardThreshold < fclFraLpAllDiscardThreshold. The default value is '20'.")
fclFraLpX25InterframeFlagCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 13, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFraLpX25InterframeFlagCount.setStatus('mandatory')
if mibBuilder.loadTexts: fclFraLpX25InterframeFlagCount.setDescription("The value of this object is the number of interframe flags (it concerns the framing aspects of link access procedures of X25 and not the fact to put several frames coming from a FR PVC end point in a single X25 packet). The possible values are : '1..15'. The default value is '1'.")
fclFraLpInactivityCheckDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 13, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 254))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFraLpInactivityCheckDelay.setStatus('mandatory')
if mibBuilder.loadTexts: fclFraLpInactivityCheckDelay.setDescription("The value of this object is the inactivity check delay in minutes.............. The possible values are : '0..254'. The value '0' disables this clearing mechanism. The default value is '0'.")
fclFraLpCompression = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 13, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("off", 1), ("networkToSubscriber", 2), ("subscriberToNetwork", 3), ("bothway", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFraLpCompression.setStatus('mandatory')
if mibBuilder.loadTexts: fclFraLpCompression.setDescription("The value of this object indicates the compression enabling for each direction. The authorized values are : off : no compression, networkToSubscriber : compression of the flow from the remote peer to the equipment, subscriberToNetwork : compression of the flow from the equipment to the remote peer, bothway : compression of the two flows from and to the equipment. The default value is 'off'.")
fclFraLpCompressNegotiation = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 13, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("onOptionalCompression", 2), ("onMandatoryCompression", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFraLpCompressNegotiation.setStatus('mandatory')
if mibBuilder.loadTexts: fclFraLpCompressNegotiation.setDescription("The value of this object indicates whether the compression facility is negociated or not and, if negociated, the optional/obligatory status. The authorized values are : off' :no negociation, onOptionalCompression : negociation but compression is optional, onMandatoryCompression : negociation and compression is mandatory. The default value is 'off'.")
fclFraLpCompressScrambling = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 13, 1, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFraLpCompressScrambling.setStatus('mandatory')
if mibBuilder.loadTexts: fclFraLpCompressScrambling.setDescription("The value of this object indicates, when the compression is active, whether the scrambling is enabled or not. The default value is 'off'.")
fclFraLpCompressMultiPacketsTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 13, 1, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1500))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFraLpCompressMultiPacketsTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclFraLpCompressMultiPacketsTimer.setDescription("The value of this object defines the maximum waiting time, in milliseconds by steps of 100 milliseconds , which, if there is not another packet to compress, the packet of compressed packets is sent beyond (this permits to reduce the number of packets transmitted to the remote peer). The authorized values are '0..1500'. '0' means no packets grouping (i. e. : each packet is individually compressed and sent). The default value is '0'.")
fclFraLpReliableVc = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 13, 1, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 2, 4))).clone(namedValues=NamedValues(("off", 1), ("clear", 3), ("subscribe", 2), ("check", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFraLpReliableVc.setStatus('mandatory')
if mibBuilder.loadTexts: fclFraLpReliableVc.setDescription("The value of this object is used to enable the Reliable Virtual Circuit service. The authorized values are : off : no RVC, the VCs are considered as normal VCs, no particular processing, clear : RVCs are not allowed for the subscriber, each attempt to establish a RVC provokes a clear of the connection, subscribe : all calls transmitted by the subscriber establish RVCs, it is also possible to receive calls with RVC option, check : for a link to a subscriber : when a call with RVC option is received, a RVC is established for a link to a network : the RVC option is ignored when it is present in a call sent by a local subscriber, the connection is cleared when the RVC option is present in a call sent by the network. The default value is 'off'.")
fclFraLmiTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 13, 2), )
if mibBuilder.loadTexts: fclFraLmiTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclFraLmiTable.setDescription('This table defines the LMI (Link Management Interface) parameters of Frame Relay Access logical ports with LMI signalling.')
fclFraLmiEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 13, 2, 1), ).setIndexNames((0, "PCE-MIB", "fclFraLmiLogPortId"))
if mibBuilder.loadTexts: fclFraLmiEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclFraLmiEntry.setDescription('An entry of fclFraLmiTable.')
fclFraLmiLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 13, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclFraLmiLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclFraLmiLogPortId.setDescription("The value of this object identifies one and only one Frame Relay Access logical port with LMI (Link Management Interface) signalling. The possible values are : '0..131'. If it is unused, the value of this parameter is '255'. The default value is '255'.")
fclFraLmiDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 13, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dlci0", 1), ("dlci1023", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFraLmiDlci.setStatus('mandatory')
if mibBuilder.loadTexts: fclFraLmiDlci.setDescription("The value of this object is the DLCI Data Link Connection Identifier of the Frame Relay PVC (Permanent Virtual Circuit) used by LMI to exchange management datas with the facing peer. The possible values are '0' or '1023'. The default value is '0'.")
fclFraLmiLmiStandard = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 13, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ansiT1-617d", 1), ("itutQ933a", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFraLmiLmiStandard.setStatus('mandatory')
if mibBuilder.loadTexts: fclFraLmiLmiStandard.setDescription("The value of this object defines which standard is used. The possible values are 'ansiT1-617d' (ANSI T1.617 Annex D) or 'itutQ933a' (ITU-T Q.933 Annex A). The default value is 'ansiT1-617d'.")
fclFraLmiAccessibilityCondition = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 13, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("fast", 1), ("n393", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFraLmiAccessibilityCondition.setStatus('mandatory')
if mibBuilder.loadTexts: fclFraLmiAccessibilityCondition.setDescription("The value of this object defines calculation mode of the 'up' operational status of the logical port. The operational state may be deducted using the N393 mechanism (value 'n393') or, more rapidly, withoutis using this mechanism (value 'fast'). The default value is 'fast'.")
fclFraLmiN391FullStatusPollCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 13, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 254))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFraLmiN391FullStatusPollCount.setStatus('mandatory')
if mibBuilder.loadTexts: fclFraLmiN391FullStatusPollCount.setDescription("The value of this object identifies the user-side N391 full status polling cycle value for this logical port. This the number of status enquiry intervals that pass before issuance of full status enquiry message. If the logical port is not performing user-side procedures, then this value is meaningless. The authorized values are '1..254'. The default value is '6'.")
fclFraLmiN392ErrorThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 13, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFraLmiN392ErrorThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: fclFraLmiN392ErrorThreshold.setDescription("The value of this object identifies the user-side or network-side N392 error threshold value for this logical port. This is the maximum number of unanswered Status Enquiries the equipment shall accept before declaring the logical port down. The authorized values are '1..10. The default value is '3'.")
fclFraLmiN393MonitoredEventCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 13, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFraLmiN393MonitoredEventCount.setStatus('mandatory')
if mibBuilder.loadTexts: fclFraLmiN393MonitoredEventCount.setDescription("The value of this object identifies the user-side or network-side N393 monitored events count value for this logical port. This is the number of status polling intervals over which the error threshold is counted. For example if within 'MonitoredEvents' number of events the equipment receives 'ErrorThreshold' number of errors, the logical port is marked as down. The authorized values are '1..10. The default value is '4'.")
fclFraLmiT391LinkIntegPollTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 13, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFraLmiT391LinkIntegPollTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclFraLmiT391LinkIntegPollTimer.setDescription("The value of this object identifies the user-side T391 link integrity verification polling timer value for this logical port. This is the number of seconds between successive status enquiry messages. If the logical port is not performing user-side procedures, then this value is meaningless. The authorized values are '5..30'. The default value is '10'.")
fclFraLmiT392PollingVerifTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 13, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFraLmiT392PollingVerifTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclFraLmiT392PollingVerifTimer.setDescription("The value of this object identifies the network-side T392 polling verification timer value (nT2 for LMI) for this logical port. This value is expressed in seconds. If the logical port is not performing network-side procedures, then this value is meaningless. The authorized values are '5..30'. The default value is '15'")
fclFraPvcEndPointTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 13, 3), )
if mibBuilder.loadTexts: fclFraPvcEndPointTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclFraPvcEndPointTable.setDescription('This table defines the Frame Relay PVC (Permananent Virtual Circuit) end points on Frame Relay Access logical ports. For each PVC end point this table defines the addres of the called remote peer and the different parameters of the call processing.')
fclFraPvcEndPointEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 13, 3, 1), ).setIndexNames((0, "PCE-MIB", "fclFraPvcLogPortId"), (0, "PCE-MIB", "fclFraPvcDlci"))
if mibBuilder.loadTexts: fclFraPvcEndPointEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclFraPvcEndPointEntry.setDescription('An entry of fclFraPvcEndPointTable.')
fclFraPvcLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 13, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclFraPvcLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclFraPvcLogPortId.setDescription("The value of this object identifies one and only one Frame Relay Access logical port. This is the logical port this PVC (Permanent Virtual Circuit) end point is layered onto. The possible values are : '0..131'. If it is unused, the value of this parameter is '255'. The default value is '255'.")
fclFraPvcDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 13, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 991))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclFraPvcDlci.setStatus('mandatory')
if mibBuilder.loadTexts: fclFraPvcDlci.setDescription("The value of this object is equal to the DLCI (Data Link Connection Identifier) value for this PVC (Permanent Virtual Circuit) end point. The possible values are : '0..1023. If it is unused, the value of this parameter is '65535'. The default value is '65535'.")
fclFraPvcStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 13, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFraPvcStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fclFraPvcStatus.setDescription("The value of this object indicates the state of the entry of this table. The default value is 'valid'. It must be set to 'invalid' to delete the entry.")
fclFraPvcCalledAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 13, 3, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFraPvcCalledAddr.setStatus('mandatory')
if mibBuilder.loadTexts: fclFraPvcCalledAddr.setDescription("The value of this object is the X121 address of the called remote peer PVC end point. This value is the called address specified in the call packet sent from this PVC end point. The value may contain up to 15 digits (digits 0..9). The value must be completed with 'F' digits for a total of 16 digits. The equipment configurator does not need final completion. The default value is 'FF FF FF FF FF FF FF FF' meaning 'empty value' (blank value on the equipment configurator).")
fclFraPvcSubscriberNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 13, 3, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9999))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFraPvcSubscriberNumber.setStatus('mandatory')
if mibBuilder.loadTexts: fclFraPvcSubscriberNumber.setDescription("The value of this object is the SB number added to the DNICZO of the equipment to make the calling address in a call sent from this PVC end point. The value must contain 4 digits (digits 0..9). The default value is 'FF FF'.")
fclFraPvcCallDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 13, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("calling", 1), ("called", 2), ("auto", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFraPvcCallDirection.setStatus('mandatory')
if mibBuilder.loadTexts: fclFraPvcCallDirection.setDescription("The value of this object defines the mode used to establish the X25 VC between this PVC end point and the remote one on the other side of the X25 network. The authorized values are 'calling' (the caller is this PVC end point), 'called' (the caller is the remote PVC end point), 'auto' (automatic choise between 'calling' and 'called'). The default value is 'auto'.")
fclFraPvcEncapsulation = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 13, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("fastSelect", 2), ("fastSelect-frHeader", 3), ("fastSelect-frHeader-grouping", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFraPvcEncapsulation.setStatus('mandatory')
if mibBuilder.loadTexts: fclFraPvcEncapsulation.setDescription("The value of this object defines how FR frames are transported in the X25 VC between this PVC end point and the remote one on the other side of the X25 network. The authorized values are 'none' (each FR frame is put in one X25 packet without any particular treatment), 'fastSelect' (Fast select is requested in the call packet), 'fastSelect-frHeader' (Fast select is requested in the call packet, the FR header is also transported), 'fastSelect-frHeader-grouping' (Fast select is requested in the call packet, the FR header is also transported, several FR frames may be grouped in only one X25 packet). The default value is 'none'.")
fclFraPvcMinRecallTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 13, 3, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 990))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFraPvcMinRecallTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclFraPvcMinRecallTimer.setDescription("The value of this object specifies the minimum recall time (in seconds) between two successive calls. The authorized values are '0..990' by step of 10. The default value is '0'.")
fclFraPvcInactivityTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 13, 3, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2540))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFraPvcInactivityTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclFraPvcInactivityTimer.setDescription("The value of this object is the inactivity time in seconds.............. The possible values are : '0..2540'. This clearing mechanism is enabled or disabled on the logical port (see fclFraLpInactivityCheckDelay). The default value is '30'.")
fclHdlcAccessLogPort = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 14))
fclHdlcLogPortTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 14, 1), )
if mibBuilder.loadTexts: fclHdlcLogPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclHdlcLogPortTable.setDescription('This table defines the general parameters of HDLC (High-level Data Link Control) access logical ports.')
fclHdlcLogPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 14, 1, 1), ).setIndexNames((0, "PCE-MIB", "fclHdlcLpLogPortId"))
if mibBuilder.loadTexts: fclHdlcLogPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclHdlcLogPortEntry.setDescription('An entry of fclHdlcLogPortTable.')
fclHdlcLpLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 14, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclHdlcLpLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclHdlcLpLogPortId.setDescription("The value of this object identifies one and only one HDLC (High-level Data Link Control) access logical port. The possible values are : '0..131'. If it is unused, the value of this parameter is '255'. The default value is '255'.")
fclHdlcLpInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 14, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclHdlcLpInterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: fclHdlcLpInterfaceId.setDescription("The value of this object identifies the line interface used by this HDLC logical port. The possible values are : '0..35'. If it is unused, the value of this parameter is '255'. The default value is '255'.")
fclHdlcLpCrcTransport = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 14, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 1))).clone(namedValues=NamedValues(("off", 2), ("on", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclHdlcLpCrcTransport.setStatus('mandatory')
if mibBuilder.loadTexts: fclHdlcLpCrcTransport.setDescription("The value of this object indicates whether the CRC (Cyclic Redundancy Check) is transported or not. The default value is 'off'.")
fclHdlcLpGroupingThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 14, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 97))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclHdlcLpGroupingThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: fclHdlcLpGroupingThreshold.setDescription("The value of this object is the input resource threshold over which several input frames coming from this HDLC logical port are grouped in a single X25 packet. See fclHdlcAutoEncapsulation to enable this grouping. The possible values are : '1..97'. The thresholds must be set as following : fclHdlcLpGroupingThreshold < fclHdlcLpAllDiscardThreshold. The default value is '1'.")
fclHdlcLpAllDiscardThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 14, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(4, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclHdlcLpAllDiscardThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: fclHdlcLpAllDiscardThreshold.setDescription("The value of this object is the input resource threshold over which all input frames are discarded (i.e. : not sent accross the network). The possible values are : '4..100'. The thresholds must be set as following : fclHdlcLpGroupingThreshold < fclHdlcLpAllDiscardThreshold. The default value is '20'.")
fclHdlcLpX25InterframeFlagCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 14, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclHdlcLpX25InterframeFlagCount.setStatus('mandatory')
if mibBuilder.loadTexts: fclHdlcLpX25InterframeFlagCount.setDescription("The value of this object is the number of interframe flags (it concerns the framing aspects of link access procedures of X25 and not the fact to put several frames coming from this HDLC logical port in a single X25 packet). The possible values are : '1..15'. The default value is '1'.")
fclHdlcLpInactivityCheckDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 14, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 254))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclHdlcLpInactivityCheckDelay.setStatus('mandatory')
if mibBuilder.loadTexts: fclHdlcLpInactivityCheckDelay.setDescription("The value of this object is the inactivity check delay in minutes.............. The possible values are : '0..254'. The value '0' disables this clearing mechanism. The default value is '0'.")
fclHdlcLpCompression = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 14, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("off", 1), ("networkToSubscriber", 2), ("subscriberToNetwork", 3), ("bothway", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclHdlcLpCompression.setStatus('mandatory')
if mibBuilder.loadTexts: fclHdlcLpCompression.setDescription("The value of this object indicates the compression enabling for each direction. The authorized values are : off : no compression, networkToSubscriber : compression of the flow from the remote peer to the equipment, subscriberToNetwork : compression of the flow from the equipment to the remote peer, bothway : compression of the two flows from and to the equipment. The default value is 'off'.")
fclHdlcLpCompressNegotiation = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 14, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("onOptionalCompression", 2), ("onMandatoryCompression", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclHdlcLpCompressNegotiation.setStatus('mandatory')
if mibBuilder.loadTexts: fclHdlcLpCompressNegotiation.setDescription("The value of this object indicates whether the compression facility is negociated or not and, if negociated, the optional/obligatory status. The authorized values are : off' :no negociation, onOptionalCompression : negociation but compression is optional, onMandatoryCompression : negociation and compression is mandatory. The default value is 'off'.")
fclHdlcLpCompressScrambling = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 14, 1, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclHdlcLpCompressScrambling.setStatus('mandatory')
if mibBuilder.loadTexts: fclHdlcLpCompressScrambling.setDescription("The value of this object indicates, when the compression is active, whether the scrambling is enabled or not. The default value is 'off'.")
fclHdlcLpCompressMultiPacketsTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 14, 1, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1500))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclHdlcLpCompressMultiPacketsTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclHdlcLpCompressMultiPacketsTimer.setDescription("The value of this object defines the maximum waiting time, in milliseconds by steps of 100 milliseconds , which, if there is not another packet to compress, the packet of compressed packets is sent beyond (this permits to reduce the number of packets transmitted to the remote peer). The authorized values are '0..1500'. '0' means no packets grouping (i. e. : each packet is individually compressed and sent). The default value is '0'.")
fclHdlcLpReliableVc = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 14, 1, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 2, 4))).clone(namedValues=NamedValues(("off", 1), ("clear", 3), ("subscribe", 2), ("check", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclHdlcLpReliableVc.setStatus('mandatory')
if mibBuilder.loadTexts: fclHdlcLpReliableVc.setDescription("The value of this object is used to enable the Reliable Virtual Circuit service. The authorized values are : off : no RVC, the VCs are considered as normal VCs, no particular processing, clear : RVCs are not allowed for the subscriber, each attempt to establish a RVC provokes a clear of the connection, subscribe : all calls transmitted by the subscriber establish RVCs, it is also possible to receive calls with RVC option, check : for a link to a subscriber : when a call with RVC option is received, a RVC is established for a link to a network : the RVC option is ignored when it is present in a call sent by a local subscriber, the connection is cleared when the RVC option is present in a call sent by the network. The default value is 'off'.")
fclHdlcLpCos = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 14, 1, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 2, 1))).clone(namedValues=NamedValues(("ubr", 3), ("vbr-rt", 2), ("vbr", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclHdlcLpCos.setStatus('mandatory')
if mibBuilder.loadTexts: fclHdlcLpCos.setDescription('COS')
fclHdlcLpCir = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 14, 1, 1, 31), Integer32().subtype(subtypeSpec=ValueRangeConstraint(600, 2048000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclHdlcLpCir.setStatus('mandatory')
if mibBuilder.loadTexts: fclHdlcLpCir.setDescription('Entrant CIR')
fclHdlcLpMinCir = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 14, 1, 1, 32), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclHdlcLpMinCir.setStatus('mandatory')
if mibBuilder.loadTexts: fclHdlcLpMinCir.setDescription('Entrant CIR mini')
fclHdlcAutoCallTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 14, 2), )
if mibBuilder.loadTexts: fclHdlcAutoCallTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclHdlcAutoCallTable.setDescription("This table contains the HDLC logical ports for which a call is automatically sent when the operational state of this LP becomes 'up'. For each LP this table defines the addres of the called remote peer and the different parameters of the call processing.")
fclHdlcAutoCallEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 14, 2, 1), ).setIndexNames((0, "PCE-MIB", "fclHdlcAutoLogPortId"))
if mibBuilder.loadTexts: fclHdlcAutoCallEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclHdlcAutoCallEntry.setDescription('An entry of fclHdlcAutoCallTable.')
fclHdlcAutoLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 14, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclHdlcAutoLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclHdlcAutoLogPortId.setDescription("The value of this object identifies one and only one HDLC logical port. The possible values are : '0..131'. If it is unused, the value of this parameter is '255'.")
fclHdlcAutoCalledAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 14, 2, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclHdlcAutoCalledAddr.setStatus('mandatory')
if mibBuilder.loadTexts: fclHdlcAutoCalledAddr.setDescription("The value of this object is the X121 address of the called remote peer. This value is the called address specified in the call packet sent from this logical port. The value may contain up to 15 digits (digits 0..9). The value must be completed with 'F' digits for a total of 16 digits. The equipment configurator does not need final completion. The default value is 'FF FF FF FF FF FF FF FF' meaning 'empty value' (blank value on the equipment configurator).")
fclHdlcAutoSubscriberNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 14, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 99))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclHdlcAutoSubscriberNumber.setStatus('mandatory')
if mibBuilder.loadTexts: fclHdlcAutoSubscriberNumber.setDescription("The value of this object is the SB number added to the DNICZO of the equipment to make the calling address in a call sent from this HDLC logical port. The value must contain 2 digits (digits 0..9). The default value is 'FF FF'.")
fclHdlcAutoCallDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 14, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("calling", 1), ("called", 2), ("auto", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclHdlcAutoCallDirection.setStatus('mandatory')
if mibBuilder.loadTexts: fclHdlcAutoCallDirection.setDescription("The value of this object defines the mode used to establish the X25 VC between this HDLC logical port and the remote one on the other side of the network. The authorized values are 'calling' (the caller is this HDLC logical port), 'called' (the caller is this remote HDLC logical port), 'auto' (automatic choise between 'calling' and 'called'). The default value is 'auto'.")
fclHdlcAutoEncapsulation = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 14, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4))).clone(namedValues=NamedValues(("none", 1), ("fastSelect", 2), ("fastSelect-grouping", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclHdlcAutoEncapsulation.setStatus('mandatory')
if mibBuilder.loadTexts: fclHdlcAutoEncapsulation.setDescription("The value of this object defines how HDLC frames are transported in the X25 VC between this HDLC logical port and the remote one on the other side of the network. The authorized values are 'none' (each FR frame is put in one packet without any particular treatment), 'fastSelect' (Fast select is requested in the call packet), 'fastSelect-frHeader' (Fast select is requested in the call packet, the FR header is also transported), 'fastSelect-frHeader-grouping' (Fast select is requested in the call packet, the FR header is also transported, several FR frames may be grouped in only one packet). The default value is 'none'.")
fclHdlcAutoMinRecallTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 14, 2, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 990))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclHdlcAutoMinRecallTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclHdlcAutoMinRecallTimer.setDescription("The value of this object specifies the minimum recall time (in seconds) between two successive calls. The authorized values are '0..990' by step of 10. The default value is '0'.")
fclHdlcAutoInactivityTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 14, 2, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2540))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclHdlcAutoInactivityTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclHdlcAutoInactivityTimer.setDescription("The value of this object is the inactivity time in seconds.............. The possible values are : '0..2540'. See fclHdlcLpInactivityCheckDelay to enable or disable this clearing. The default value is '30'.")
fclSdlcLogPort = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 15))
fclSdlcLogPortTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 15, 1), )
if mibBuilder.loadTexts: fclSdlcLogPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclSdlcLogPortTable.setDescription('This table defines the general parameters of SDLC (Synchronous Data Link Control) access logical ports. These SDLC logical ports are used in SNA (Systems Network Architecture) to cross X25 or Frame Relay networks.')
fclSdlcLogPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 15, 1, 1), ).setIndexNames((0, "PCE-MIB", "fclSdlcLpLogPortId"))
if mibBuilder.loadTexts: fclSdlcLogPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclSdlcLogPortEntry.setDescription('An entry of fclSdlcLogPortTable.')
fclSdlcLpLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 15, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclSdlcLpLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclSdlcLpLogPortId.setDescription("The value of this object identifies one and only one SDLC (Synchronous Data Link Control) access logical port in SNA (Systems Network Architecture). The possible values are : '0..131'. If it is unused, the value of this parameter is '255'. The default value is '255'.")
fclSdlcLpInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 15, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclSdlcLpInterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: fclSdlcLpInterfaceId.setDescription("The value of this object identifies the line interface used by this SDLC logical port. The possible values are : '0..35'. If it is unused, the value of this parameter is '255'. The default value is '255'.")
fclSdlcLpPhysicalUnitType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 15, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(18, 17))).clone(namedValues=NamedValues(("primary", 18), ("secondary", 17)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclSdlcLpPhysicalUnitType.setStatus('mandatory')
if mibBuilder.loadTexts: fclSdlcLpPhysicalUnitType.setDescription("The value of this object indicates the type of the physical unit(s) which are in front of this SDLC logical port. The PU may be 'primary' or 'secondary'. Primary PUs poll secondary Pus in a predetermined order and then secondaries transmit if they have outgoing data. The equipment acts as a primary PU in front of secondaries PU and, on the other side, it acts as secondaries PU in front of a primary PU. The default value is 'secondary' (so the equipment acts as primary PU).")
fclSdlcLpSubscriberNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 15, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclSdlcLpSubscriberNumber.setStatus('mandatory')
if mibBuilder.loadTexts: fclSdlcLpSubscriberNumber.setDescription("The value of this object is the SB number added to the DNICZO of the equipment to make the calling address in a call sent from this logical port. The value must contain 2 digits (digits 0..9). The default value is 'FF'.")
fclSdlcLpBitEncoding = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 15, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("nrz", 1), ("nrzInverse", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclSdlcLpBitEncoding.setStatus('mandatory')
if mibBuilder.loadTexts: fclSdlcLpBitEncoding.setDescription("The value of this object indicates whether the coding format is NRZ (Non Return to Zero) or NRZI (Non Return to Zero Inverted) The default value is 'nrz'.")
fclSdlcLpUnknownPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 15, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clear", 1), ("delete", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclSdlcLpUnknownPackets.setStatus('mandatory')
if mibBuilder.loadTexts: fclSdlcLpUnknownPackets.setDescription("The value of this object indicates, when the equipment receives an unknown packet on this logical port, whether it clears the WAN connection or it deletes this packet (i.e. it does not transmit this packet over the network). The default value is 'nrz'.")
fclSdlcLpLogicalLinkProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 15, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("qllc", 1), ("psh", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclSdlcLpLogicalLinkProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: fclSdlcLpLogicalLinkProtocol.setDescription("The value of this object indicates which transport protocol is used over the network. QLLC (...) or PSH (...) may be used. The default value is 'qllc'.")
fclSdlcLpPacketSize = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 15, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("s16", 4), ("s32", 5), ("s64", 6), ("s128", 7), ("s256", 8), ("s512", 9), ("s1024", 10), ("s2048", 11), ("s4096", 12)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclSdlcLpPacketSize.setStatus('mandatory')
if mibBuilder.loadTexts: fclSdlcLpPacketSize.setDescription('The value of this object indicates the packet size used across the network. When PSH is used as transport protocol the packet size must be 128 or 256 octets. The default value is 128 octets.')
fclSdlcLpWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 15, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclSdlcLpWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: fclSdlcLpWindowSize.setDescription("The value of this object indicates the window size used across the network. The authorized values are '1..7'. The default value is '7'.")
fclSdlcLpCompression = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 15, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("off", 1), ("networkToSubscriber", 2), ("subscriberToNetwork", 3), ("bothway", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclSdlcLpCompression.setStatus('mandatory')
if mibBuilder.loadTexts: fclSdlcLpCompression.setDescription("The value of this object indicates the compression enabling for each direction. The authorized values are : off : no compression, networkToSubscriber : compression of the flow from the remote peer to the equipment, subscriberToNetwork : compression of the flow from the equipment to the remote peer, bothway : compression of the two flows from and to the equipment. The default value is 'off'.")
fclSdlcLpCompressNegotiation = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 15, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("onOptionalCompression", 2), ("onMandatoryCompression", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclSdlcLpCompressNegotiation.setStatus('mandatory')
if mibBuilder.loadTexts: fclSdlcLpCompressNegotiation.setDescription("The value of this object indicates whether the compression facility is negociated or not and, if negociated, the optional/obligatory status. The authorized values are : off' :no negociation, onOptionalCompression : negociation but compression is optional, onMandatoryCompression : negociation and compression is mandatory. The default value is 'off'.")
fclSdlcLpCompressScrambling = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 15, 1, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclSdlcLpCompressScrambling.setStatus('mandatory')
if mibBuilder.loadTexts: fclSdlcLpCompressScrambling.setDescription("The value of this object indicates, when the compression is active, whether the scrambling is enabled or not. The default value is 'off'.")
fclSdlcLpCompressMultiPacketsTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 15, 1, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1500))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclSdlcLpCompressMultiPacketsTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclSdlcLpCompressMultiPacketsTimer.setDescription("The value of this object defines the maximum waiting time, in milliseconds by steps of 100 milliseconds , which, if there is not another packet to compress, the packet of compressed packets is sent beyond (this permits to reduce the number of packets transmitted to the remote peer). The authorized values are '0..1500'. '0' means no packets grouping (i. e. : each packet is individually compressed and sent). The default value is '0'.")
fclSdlcLpReliableVc = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 15, 1, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 2, 4))).clone(namedValues=NamedValues(("off", 1), ("clear", 3), ("subscribe", 2), ("check", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclSdlcLpReliableVc.setStatus('mandatory')
if mibBuilder.loadTexts: fclSdlcLpReliableVc.setDescription("The value of this object is used to enable the Reliable Virtual Circuit service. The authorized values are : off : no RVC, the VCs are considered as normal VCs, no particular processing, clear : RVCs are not allowed for the subscriber, each attempt to establish a RVC provokes a clear of the connection, subscribe : all calls transmitted by the subscriber establish RVCs, it is also possible to receive calls with RVC option, check : for a link to a subscriber : when a call with RVC option is received, a RVC is established for a link to a network : the RVC option is ignored when it is present in a call sent by a local subscriber, the connection is cleared when the RVC option is present in a call sent by the network. The default value is 'off'.")
fclSdlcLpCos = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 15, 1, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 1))).clone(namedValues=NamedValues(("ubr", 3), ("vbr", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclSdlcLpCos.setStatus('mandatory')
if mibBuilder.loadTexts: fclSdlcLpCos.setDescription('COS')
fclSdlcLpCir = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 15, 1, 1, 31), Integer32().subtype(subtypeSpec=ValueRangeConstraint(600, 2048000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclSdlcLpCir.setStatus('mandatory')
if mibBuilder.loadTexts: fclSdlcLpCir.setDescription('Entrant CIR')
fclSdlcLpMinCir = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 15, 1, 1, 32), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclSdlcLpMinCir.setStatus('mandatory')
if mibBuilder.loadTexts: fclSdlcLpMinCir.setDescription('Entrant CIR mini')
fclSdlcLpBe = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 15, 1, 1, 33), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclSdlcLpBe.setStatus('mandatory')
if mibBuilder.loadTexts: fclSdlcLpBe.setDescription('Entrant BE')
fclSdlcPrimaryPuLogPort = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 15, 2))
fclSdlcPriLogPortTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 15, 2, 1), )
if mibBuilder.loadTexts: fclSdlcPriLogPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclSdlcPriLogPortTable.setDescription('This table defines the parameters of SDLC access logical ports which are in front of primaries Physical Units.')
fclSdlcPriLogPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 15, 2, 1, 1), ).setIndexNames((0, "PCE-MIB", "fclSdlcPriLpLogPortId"))
if mibBuilder.loadTexts: fclSdlcPriLogPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclSdlcPriLogPortEntry.setDescription('An entry of fclSdlcPriLogPortTable.')
fclSdlcPriLpLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 15, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclSdlcPriLpLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclSdlcPriLpLogPortId.setDescription("The value of this object identifies one and only one SDLC access logical port which is in front of primaries Physical Units. The possible values are : '0..131'. If it is unused, the value of this parameter is '255'. The default value is '255'.")
fclSdlcPriLpLinkType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 15, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(25, 20, 16, 22, 27, 30))).clone(namedValues=NamedValues(("pu4-pu4", 25), ("pu4-pu21", 20), ("pu4-pu20", 16), ("pu21-pu21", 22), ("nixd-pu20", 27), ("rwsi-pu20", 30)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclSdlcPriLpLinkType.setStatus('mandatory')
if mibBuilder.loadTexts: fclSdlcPriLpLinkType.setDescription("The value of this object indicates which kind of link is estblished over the network. In this description the primary PU in front of this logical port is said 'local', the secondary PU on the other side of the network is said 'remote'. The values are expressed with the format 'local-remote' : pu4-pu4 : PU 4 to PU 4, pu4-pu21 PU 4 to PU 2.1, pu4-pu20 : PU 4 to PU 2.0, pu21-pu21 : PU 2.1 to PU 2.1, nixd-pu20 : Nixdorf PU to PU 2.0, rwsi-pu20 : RWSI to PU 2.0. The default value is 'pu4-pu20'.")
fclSdlcPriLpRemPuIdentification = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 15, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("proprietary", 1), ("calledAddr", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclSdlcPriLpRemPuIdentification.setStatus('mandatory')
if mibBuilder.loadTexts: fclSdlcPriLpRemPuIdentification.setDescription("The value of this object indicates whether the remote secondary PU is identified by a proprietary way or by using the called address field of call packets. The default value is 'proprietary'.")
fclSdlcPriLpPollingGroupResponse = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 15, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclSdlcPriLpPollingGroupResponse.setStatus('mandatory')
if mibBuilder.loadTexts: fclSdlcPriLpPollingGroupResponse.setDescription("The value of this object indicates whether the equipment answers to the polling group when this feature is used by the local primary PU as a normal secondary PU should do. The address used by this polling group is defined in fclSdlcPriLpPollingGroupAddress. The default value is 'off'.")
fclSdlcPriLpPollingGroupAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 15, 2, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclSdlcPriLpPollingGroupAddress.setStatus('mandatory')
if mibBuilder.loadTexts: fclSdlcPriLpPollingGroupAddress.setDescription("The value of this object defines the address used by the polling group (if the equipment must answer according to fclSdlcPriLpPollingGroupResponse). The value must contain 2 digits (digits 0..F). The default value is 'FF'.")
fclSdlcPriClusterTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 15, 2, 2), )
if mibBuilder.loadTexts: fclSdlcPriClusterTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclSdlcPriClusterTable.setDescription('')
fclSdlcPriClusterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 15, 2, 2, 1), ).setIndexNames((0, "PCE-MIB", "fclSdlcPriClusterLogPortId"), (0, "PCE-MIB", "fclSdlcPriClusterAddress"))
if mibBuilder.loadTexts: fclSdlcPriClusterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclSdlcPriClusterEntry.setDescription('An entry of fclSdlcPriClusterTable.')
fclSdlcPriClusterLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 15, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclSdlcPriClusterLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclSdlcPriClusterLogPortId.setDescription('LP Id')
fclSdlcPriClusterAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 15, 2, 2, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclSdlcPriClusterAddress.setStatus('mandatory')
if mibBuilder.loadTexts: fclSdlcPriClusterAddress.setDescription('Adresse du cluster')
fclSdlcPriClusterStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 15, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclSdlcPriClusterStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fclSdlcPriClusterStatus.setDescription('Status')
fclSdlcPriClusterRemPu2CalledAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 15, 2, 2, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclSdlcPriClusterRemPu2CalledAddr.setStatus('mandatory')
if mibBuilder.loadTexts: fclSdlcPriClusterRemPu2CalledAddr.setDescription('Adresse X121 si identification PU2 distant par adresse appelee')
fclSdlcSecondaryPuLogPort = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 15, 3))
fclSdlcSecLogPortTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 15, 3, 1), )
if mibBuilder.loadTexts: fclSdlcSecLogPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclSdlcSecLogPortTable.setDescription('')
fclSdlcSecLogPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 15, 3, 1, 1), ).setIndexNames((0, "PCE-MIB", "fclSdlcSecLpLogPortId"))
if mibBuilder.loadTexts: fclSdlcSecLogPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclSdlcSecLogPortEntry.setDescription('An entry of fclSdlcSecLogPortTable.')
fclSdlcSecLpLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 15, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclSdlcSecLpLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclSdlcSecLpLogPortId.setDescription("The value of this object identifies one and only one SDLC access logical port which is in front of primaries Physical Units. The possible values are : '0..131'. If it is unused, the value of this parameter is '255'. The default value is '255'.")
fclSdlcSecLpLinkType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 15, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(26, 21, 23, 17, 28, 31, 34))).clone(namedValues=NamedValues(("pu4-pu4", 26), ("pu21-pu4", 21), ("pu21-pu21", 23), ("pu20-pu4", 17), ("pu20-nixd", 28), ("pu20-rwsi", 31), ("terminal-pu4", 34)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclSdlcSecLpLinkType.setStatus('mandatory')
if mibBuilder.loadTexts: fclSdlcSecLpLinkType.setDescription("The value of this object indicates which kind of link is estblished over the network. In this description the secondary PU in front of this logical port is said 'local', the primary PU on the other side of the network is said 'remote'. The values are expressed with the format 'local-remote' : pu4-pu4 : PU 4 to PU 4, pu21-pu4 PU 2.1 to PU 4, pu21-pu21 : PU 2.1 to PU 2.1, pu20-pu4 : PU 2.0 to PU 4, pu20-nixd : PU 2.0 to Nixdorf PU, pu20-rwsi : PU 2.0 to RWSI. terminal to pu4. The default value is 'pu20-pu4'.")
fclSdlcSecLpRemPuIdentification = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 15, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("proprietary", 1), ("calledAddr", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclSdlcSecLpRemPuIdentification.setStatus('mandatory')
if mibBuilder.loadTexts: fclSdlcSecLpRemPuIdentification.setDescription("The value of this object indicates whether the remote secondary PU is identified by a proprietary way or by using the called address field of call packets. The default value is 'proprietary'.")
fclSdlcSecLpT1AcknowledgeTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 15, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(200, 25000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclSdlcSecLpT1AcknowledgeTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclSdlcSecLpT1AcknowledgeTimer.setDescription('T1 Reply timer. A SDLC link-station uses T1 to detect a failure to receive a required acknowlegment or response. T1 runs when there are acknowlegments outstanding, it is reset when acknowlegments are received.')
fclSdlcSecLpN2RetryCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 15, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 250))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclSdlcSecLpN2RetryCount.setStatus('mandatory')
if mibBuilder.loadTexts: fclSdlcSecLpN2RetryCount.setDescription('The maximum number of transmissions. If the reply timer expires for whatever reason, an S-frame with poll bit set is sent to sollicit a response from remote SDLC link-station. If there is still no response after N2 retry, the link is deemed to be inoperative.')
fclSdlcSecLpCallRetryCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 15, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 99))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclSdlcSecLpCallRetryCount.setStatus('mandatory')
if mibBuilder.loadTexts: fclSdlcSecLpCallRetryCount.setDescription('The maximum number of calls. If the call confirm is not received, the network layer will repeat a call packet. If there is still no response after n calls, the network layer will then start a slow call.')
fclSdlcSecLpPollingTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 15, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 12800))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclSdlcSecLpPollingTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclSdlcSecLpPollingTimer.setDescription('Timer between two polling of all stations in a list.')
fclSdlcSecLpPollingMaxCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 15, 3, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclSdlcSecLpPollingMaxCount.setStatus('mandatory')
if mibBuilder.loadTexts: fclSdlcSecLpPollingMaxCount.setDescription('Number of polling counts before to poll the station with SNRM')
fclSdlcSecClusterTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 15, 3, 2), )
if mibBuilder.loadTexts: fclSdlcSecClusterTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclSdlcSecClusterTable.setDescription('')
fclSdlcSecClusterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 15, 3, 2, 1), ).setIndexNames((0, "PCE-MIB", "fclSdlcSecClusterLogPortId"), (0, "PCE-MIB", "fclSdlcSecClusterAddress"))
if mibBuilder.loadTexts: fclSdlcSecClusterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclSdlcSecClusterEntry.setDescription('An entry of fclSdlcSecClusterTable.')
fclSdlcSecClusterLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 15, 3, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclSdlcSecClusterLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclSdlcSecClusterLogPortId.setDescription("The value of this object identifies one and only one SDLC access logical port which is in front of primaries Physical Units. The possible values are : '0..131'. If it is unused, the value of this parameter is '255'. The default value is '255'.")
fclSdlcSecClusterAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 15, 3, 2, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclSdlcSecClusterAddress.setStatus('mandatory')
if mibBuilder.loadTexts: fclSdlcSecClusterAddress.setDescription("This is the poll address of the controller. You must make sure this address matches the one assignedto the attached controller. Range is '01 to FF'")
fclSdlcSecClusterStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 15, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclSdlcSecClusterStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fclSdlcSecClusterStatus.setDescription('Status')
fclSdlcSecClusterCalledAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 15, 3, 2, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclSdlcSecClusterCalledAddr.setStatus('mandatory')
if mibBuilder.loadTexts: fclSdlcSecClusterCalledAddr.setDescription('Called X121 address. X121 Address of the corresponding Hpad element.')
fclSdlcSecClusterFacility = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 15, 3, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 1), ("reverseCharging", 2), ("cug", 3), ("reverseCharging-cug", 4), ("throughputClass", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclSdlcSecClusterFacility.setStatus('mandatory')
if mibBuilder.loadTexts: fclSdlcSecClusterFacility.setDescription("The value of this object indicates the X25 call packet facility. The possible values are : none : no facility in the call packet, reverseCharging : Reverse Charging, cug : Closed User Group, reverseCharging -cug : Closed User Group, Reverse Charging. The default value is 'none'.")
fclSdlcSecClusterFacThroughputClass = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 15, 3, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("t75", 3), ("t150", 4), ("t300", 5), ("t600", 6), ("t1200", 7), ("t2400", 8), ("t4800", 9), ("t9600", 10), ("t19200", 11), ("t48000", 12), ("t64000", 13), ("t128000", 14), ("t192000", 15)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclSdlcSecClusterFacThroughputClass.setStatus('mandatory')
if mibBuilder.loadTexts: fclSdlcSecClusterFacThroughputClass.setDescription('Throughput Class')
fclSdlcSecClusterMinRecallTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 15, 3, 2, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 990))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclSdlcSecClusterMinRecallTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclSdlcSecClusterMinRecallTimer.setDescription('Slow call timer')
fclSdlcSecClusterRemPvcLogChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 15, 3, 2, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 250))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclSdlcSecClusterRemPvcLogChannel.setStatus('mandatory')
if mibBuilder.loadTexts: fclSdlcSecClusterRemPvcLogChannel.setDescription('PVC number')
fclSdlcSecClusterXidStringResponse = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 15, 3, 2, 1, 12), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclSdlcSecClusterXidStringResponse.setStatus('mandatory')
if mibBuilder.loadTexts: fclSdlcSecClusterXidStringResponse.setDescription("This field enables you to assign a PU XID. The unit uses XID's to establish and negociate PU application session. If the PU cannot respond to an XID request from the Host, the unit uses this assigned XID value.")
fclSdlcSecClusterCos = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 15, 3, 2, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 1, 2))).clone(namedValues=NamedValues(("ubr", 3), ("vbr", 1), ("vbr-rt", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclSdlcSecClusterCos.setStatus('mandatory')
if mibBuilder.loadTexts: fclSdlcSecClusterCos.setDescription('COS Class Of Service VBR')
fclSdlcSecClusterCir = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 15, 3, 2, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclSdlcSecClusterCir.setStatus('mandatory')
if mibBuilder.loadTexts: fclSdlcSecClusterCir.setDescription('CIR Committed information Rate is the maximum number of bits per seconds which an end station can transmit into the network . This is the access rate of the user-network interface and it is limited by the line speed of the user-network connection and established by subscription.')
fclSdlcSecClusterCirmin = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 15, 3, 2, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclSdlcSecClusterCirmin.setStatus('mandatory')
if mibBuilder.loadTexts: fclSdlcSecClusterCirmin.setDescription('CIRmin If the end station is informed about the congestion of the network, this is the minimum CIR that the end station can transmit into the network.')
fclSdlcSecClusterBc = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 15, 3, 2, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclSdlcSecClusterBc.setStatus('mandatory')
if mibBuilder.loadTexts: fclSdlcSecClusterBc.setDescription('Bc The Committed Burst Size is a measure for the volume of data for which the network will garantee message delivery under normal conditions. It is measured during the committed rate measurement interval (Tc).')
fclSdlcSecClusterBe = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 15, 3, 2, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclSdlcSecClusterBe.setStatus('mandatory')
if mibBuilder.loadTexts: fclSdlcSecClusterBe.setDescription('Be The Excess Burst Size is the maximum amount of uncommitted data in access of Bc that the network will attemp to deliver during a time interval (Tc). End stations are allowed to transmit data in excess of the committed burst rate.')
fclVipLogPort = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 16))
fclVipLogPortTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 16, 1), )
if mibBuilder.loadTexts: fclVipLogPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclVipLogPortTable.setDescription('This table defines the general parameters of VIP (Visual Information Projection) access logical ports. These VIP logical ports are used in HONEYWELL -BULL systems to cross X25 or Frame Relay networks')
fclVipLogPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 16, 1, 1), ).setIndexNames((0, "PCE-MIB", "fclVipLpLogPortId"))
if mibBuilder.loadTexts: fclVipLogPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclVipLogPortEntry.setDescription('An entry of fclVipLogPortTable.')
fclVipLpLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 16, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclVipLpLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclVipLpLogPortId.setDescription("The value of this object identifies one and only one VIP(Visual Information Projection) access logical port in BULL network architecture. The possible values are : '0..131'. If it is unused, the value of this parameter is '255'. The default value is '255'.")
fclVipLpInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 16, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclVipLpInterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: fclVipLpInterfaceId.setDescription("The value of this object identifies the line interface used by this VIP logical port. The possible values are : '0..35'. If it is unused, the value of this parameter is '255'. The default value is '255'.")
fclVipLpEmulationType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 16, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(50, 51))).clone(namedValues=NamedValues(("tpad", 50), ("hpad", 51)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclVipLpEmulationType.setStatus('mandatory')
if mibBuilder.loadTexts: fclVipLpEmulationType.setDescription("The value of this object indicates the type of unit which are in front of this VIP logical port. The unit may be 'Host' or 'Cluster'. Host units poll cluster units in a predetermined order and then clusters transmit if they have outgoing data. The COMPAC equipment acts as a Cluster in front of a host(HPAD emulation) and, on the other side, it acts as a host in front of a cluster(TPAD emulation). The TPAD always originates the link circuit request .The HPAD is waiting for the link circuit indication. The default value is 'HPAD'(so the equipment acts as Cluster).")
fclVipLpResponseSurveyPollingTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 16, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(100, 25000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclVipLpResponseSurveyPollingTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclVipLpResponseSurveyPollingTimer.setDescription('Supervision line watchdog. If this timeout matures, the line is considered as beeing out of order. The default value is 300ms.')
fclVipLpScreenRetryTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 16, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 2500))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclVipLpScreenRetryTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclVipLpScreenRetryTimer.setDescription("Value of screen message transmission Time Out. The default value is '10' s")
fclVipLpPrinterRetryTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 16, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 2500))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclVipLpPrinterRetryTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclVipLpPrinterRetryTimer.setDescription("Value of printer message retransmission Time Out. The default value is '70' s")
fclVipLpMessageRetryNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 16, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclVipLpMessageRetryNumber.setStatus('mandatory')
if mibBuilder.loadTexts: fclVipLpMessageRetryNumber.setDescription("Number of message retransmissions. The default value is '5'.")
fclVipLpPrinterMessagesManagement = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 16, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("local", 1), ("transparent", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclVipLpPrinterMessagesManagement.setStatus('mandatory')
if mibBuilder.loadTexts: fclVipLpPrinterMessagesManagement.setDescription("'Local management' or 'transparency'of printer messages. Local management It is the standard functionning. When a printer message is received from the HOST , it is not immediateley aknowledged by the COMPAC HPAD.It will be acknowledged when the fclVipLpHosPrinterRetryTimer time out elapses. Transparency. It is an end to end aknowlegement, the printer aknowlege is conveyed through the network(transparency). The default value is 'local management'.")
fclVipHostPadLogPort = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 16, 2))
fclVipHosLogPortTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 16, 2, 1), )
if mibBuilder.loadTexts: fclVipHosLogPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclVipHosLogPortTable.setDescription('This table defines the parameters of VIP access logical ports which are in front of Host Units')
fclVipHosLogPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 16, 2, 1, 1), ).setIndexNames((0, "PCE-MIB", "fclVipHosLpLogPortId"))
if mibBuilder.loadTexts: fclVipHosLogPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclVipHosLogPortEntry.setDescription('An entry of fclVipHosLogPortTable.')
fclVipHosLpLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 16, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclVipHosLpLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclVipHosLpLogPortId.setDescription("The value of this object identifies one and only one VIP access logical port which is in front of a HOST. The possible values are : '0..131'. If it is unused, the value of this parameter is '255'. The default value is '255'.")
fclVipHosLpWaitTimeOutForPrinter = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 16, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(100, 12800))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclVipHosLpWaitTimeOutForPrinter.setStatus('mandatory')
if mibBuilder.loadTexts: fclVipHosLpWaitTimeOutForPrinter.setDescription("Value of inter-polling time-out for printer. The default value is '300' ms.")
fclVipHosLpRepAEot = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 16, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclVipHosLpRepAEot.setStatus('mandatory')
if mibBuilder.loadTexts: fclVipHosLpRepAEot.setDescription("EOT response or not from the HPAD on polls of the HOST and in case the virtual circuit with the TPAD has not been established. The default value is 'EOT response on the polls'.")
fclVipHosLpFtbcc = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 16, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclVipHosLpFtbcc.setStatus('mandatory')
if mibBuilder.loadTexts: fclVipHosLpFtbcc.setDescription("Special treatment or not for the 'PENQ (printer Enquiry)sequence'(seen with customer FTBCC ITALY). The default value is 'no special treatement'.")
fclVipHosElementTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 16, 2, 2), )
if mibBuilder.loadTexts: fclVipHosElementTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclVipHosElementTable.setDescription('')
fclVipHosElementEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 16, 2, 2, 1), ).setIndexNames((0, "PCE-MIB", "fclVipHosElementId"))
if mibBuilder.loadTexts: fclVipHosElementEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclVipHosElementEntry.setDescription('An entry of fclVipHosElementTable.')
fclVipHosElementId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 16, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 200))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclVipHosElementId.setStatus('mandatory')
if mibBuilder.loadTexts: fclVipHosElementId.setDescription("Ident Element. The value of this object identifies one identificable addressable entity. The possible values are : '0..200'.")
fclVipHosElemStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 16, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclVipHosElemStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fclVipHosElemStatus.setDescription('Status.')
fclVipHosElemLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 16, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclVipHosElemLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclVipHosElemLogPortId.setDescription('LpId. Logical Port Identifier.')
fclVipHosElemType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 16, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("cluster", 1), ("isolatedstation", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclVipHosElemType.setStatus('mandatory')
if mibBuilder.loadTexts: fclVipHosElemType.setDescription('Element Type. Cluster or Isolated Station.')
fclVipHosElemAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 16, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclVipHosElemAddress.setStatus('mandatory')
if mibBuilder.loadTexts: fclVipHosElemAddress.setDescription("Element Address. Vip Address of The Entity Between '0' and '31'.")
fclVipHosStationTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 16, 2, 3), )
if mibBuilder.loadTexts: fclVipHosStationTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclVipHosStationTable.setDescription('')
fclVipHosStationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 16, 2, 3, 1), ).setIndexNames((0, "PCE-MIB", "fclVipHosStatElementId"), (0, "PCE-MIB", "fclVipHosStatStationAddress"))
if mibBuilder.loadTexts: fclVipHosStationEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclVipHosStationEntry.setDescription('An entry of fclVipHosStationTable.')
fclVipHosStatElementId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 16, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 200))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclVipHosStatElementId.setStatus('mandatory')
if mibBuilder.loadTexts: fclVipHosStatElementId.setDescription("Ident Element.The value of this object identifies one identificable addressable entity. The possible values are : '0..200'.")
fclVipHosStatStationAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 16, 2, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclVipHosStatStationAddress.setStatus('mandatory')
if mibBuilder.loadTexts: fclVipHosStatStationAddress.setDescription('Station Address. Vip Address of the cluster defined in the previous table (case when element type=Cluster).')
fclVipHosStatStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 16, 2, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclVipHosStatStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fclVipHosStatStatus.setDescription('Status.')
fclVipClusterLogPort = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 16, 3))
fclVipCluLogPortTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 16, 3, 1), )
if mibBuilder.loadTexts: fclVipCluLogPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclVipCluLogPortTable.setDescription('This table defines the parameters of VIP access logical ports which are in front of Cluster Units')
fclVipCluLogPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 16, 3, 1, 1), ).setIndexNames((0, "PCE-MIB", "fclVipCluLpLogPortId"))
if mibBuilder.loadTexts: fclVipCluLogPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclVipCluLogPortEntry.setDescription('An entry of fclVipCluLogPortTable.')
fclVipCluLpLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 16, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclVipCluLpLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclVipCluLpLogPortId.setDescription("The value of this object identifies one and only one VIP access logical port which is in front of a HOST. The possible values are : '0..131'. If it is unused, the value of this parameter is '255'. The default value is '255'.")
fclVipCluLpPollingTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 16, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(100, 12800))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclVipCluLpPollingTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclVipCluLpPollingTimer.setDescription('Value of interpolling wait time-out (retransmission of polling frame on expiry of time out).')
fclVipCluLpFailedPollingMaxNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 16, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 250))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclVipCluLpFailedPollingMaxNumber.setStatus('mandatory')
if mibBuilder.loadTexts: fclVipCluLpFailedPollingMaxNumber.setDescription("Maximum number of unanswered polls The default value is '6'.")
fclVipCluLpPollingTypeAfterSelect = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 16, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("stationPoll", 1), ("clusterPoll", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclVipCluLpPollingTypeAfterSelect.setStatus('mandatory')
if mibBuilder.loadTexts: fclVipCluLpPollingTypeAfterSelect.setDescription("Polling Type after select Station polling. After a select the Tpad sends a station poll in order to directly receive from it an immediate aknowledgement . Cluster polling. After a select , the Tpad sends a cluster select. Although less efficient it is sometimes used in certain configurations. The default value is 'station poll'.")
fclVipCluLpScreenKeepTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 16, 3, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2550))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclVipCluLpScreenKeepTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclVipCluLpScreenKeepTimer.setDescription('Screen message Blocking Duration of the blocking of the screen flow .After reception of a screen message , transmitted by a VIP station ,the message flow from that station to the screen is blocked .The station is released when a screen message is received from the Host or when the protection time-out expires. The default value is no blocking.')
fclVipCluElementTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 16, 3, 2), )
if mibBuilder.loadTexts: fclVipCluElementTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclVipCluElementTable.setDescription('')
fclVipCluElementEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 16, 3, 2, 1), ).setIndexNames((0, "PCE-MIB", "fclVipCluElementId"))
if mibBuilder.loadTexts: fclVipCluElementEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclVipCluElementEntry.setDescription('An entry of fclVipCluElementTable.')
fclVipCluElementId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 16, 3, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 200))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclVipCluElementId.setStatus('mandatory')
if mibBuilder.loadTexts: fclVipCluElementId.setDescription('LP Id')
fclVipCluElemStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 16, 3, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclVipCluElemStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fclVipCluElemStatus.setDescription('Status.')
fclVipCluElemLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 16, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclVipCluElemLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclVipCluElemLogPortId.setDescription('LpId. Logical Port Identifier')
fclVipCluElemType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 16, 3, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("cluster", 1), ("isolatedstation", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclVipCluElemType.setStatus('mandatory')
if mibBuilder.loadTexts: fclVipCluElemType.setDescription('Element Type. Cluster or Isolated Station.')
fclVipCluElemAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 16, 3, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclVipCluElemAddress.setStatus('mandatory')
if mibBuilder.loadTexts: fclVipCluElemAddress.setDescription("Element Address. Vip Adress of the Entity between '0' and '31'.")
fclVipCluElemCalledAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 16, 3, 2, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclVipCluElemCalledAddr.setStatus('mandatory')
if mibBuilder.loadTexts: fclVipCluElemCalledAddr.setDescription('Called X121 address. X121 Address of the corresponding Hpad element.')
fclVipCluElemMinRecallTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 16, 3, 2, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 990))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclVipCluElemMinRecallTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclVipCluElemMinRecallTimer.setDescription('Call Retransmission timing value. If a call fails, this timer is started. When it matures, an other call is made.')
fclVipCluStationTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 16, 3, 3), )
if mibBuilder.loadTexts: fclVipCluStationTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclVipCluStationTable.setDescription('')
fclVipCluStationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 16, 3, 3, 1), ).setIndexNames((0, "PCE-MIB", "fclVipCluStatElementId"), (0, "PCE-MIB", "fclVipCluStatStationAddress"))
if mibBuilder.loadTexts: fclVipCluStationEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclVipCluStationEntry.setDescription('An entry of fclVipCluStationTable.')
fclVipCluStatElementId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 16, 3, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 200))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclVipCluStatElementId.setStatus('mandatory')
if mibBuilder.loadTexts: fclVipCluStatElementId.setDescription("Ident Element. The value of this objetc identifies one identifiable and addressable entity. The possible values are : '0..200'.")
fclVipCluStatStationAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 16, 3, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclVipCluStatStationAddress.setStatus('mandatory')
if mibBuilder.loadTexts: fclVipCluStatStationAddress.setDescription('Station Address. Vip adress of the cluster defined in the previuos table (case when element type=cluster).')
fclVipCluStatStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 16, 3, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclVipCluStatStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fclVipCluStatStatus.setDescription('Status.')
fclBsc3270LogPort = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 17))
fclB3270LogPortTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 17, 1), )
if mibBuilder.loadTexts: fclB3270LogPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclB3270LogPortTable.setDescription('')
fclB3270LogPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 17, 1, 1), ).setIndexNames((0, "PCE-MIB", "fclB3270LpLogPortId"))
if mibBuilder.loadTexts: fclB3270LogPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclB3270LogPortEntry.setDescription('An entry of fclB3270LogPortTable.')
fclB3270LpLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 17, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclB3270LpLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclB3270LpLogPortId.setDescription('LP Id')
fclB3270LpInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 17, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclB3270LpInterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: fclB3270LpInterfaceId.setDescription('IF Id (type ligne)')
fclB3270LpEmulationType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 17, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(60, 61))).clone(namedValues=NamedValues(("tpad", 60), ("hpad", 61)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclB3270LpEmulationType.setStatus('mandatory')
if mibBuilder.loadTexts: fclB3270LpEmulationType.setDescription("Type d'emulation")
fclB3270LpCodingParityType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 17, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ebcdic", 1), ("asciioddparity", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclB3270LpCodingParityType.setStatus('mandatory')
if mibBuilder.loadTexts: fclB3270LpCodingParityType.setDescription('Type de codage parite')
fclB3270LpNoAnswerWatchDog = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 17, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(100, 25000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclB3270LpNoAnswerWatchDog.setStatus('mandatory')
if mibBuilder.loadTexts: fclB3270LpNoAnswerWatchDog.setDescription('Temporisation de non reponse')
fclB3270LpMessageRetryNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 17, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclB3270LpMessageRetryNumber.setStatus('mandatory')
if mibBuilder.loadTexts: fclB3270LpMessageRetryNumber.setDescription('Nombre de reemission de message')
fclB3270HostPadLogPort = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 17, 2))
fclB3270HosLogPortTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 17, 2, 1), )
if mibBuilder.loadTexts: fclB3270HosLogPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclB3270HosLogPortTable.setDescription('')
fclB3270HosLogPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 17, 2, 1, 1), ).setIndexNames((0, "PCE-MIB", "fclB3270HosLpLogPortId"))
if mibBuilder.loadTexts: fclB3270HosLogPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclB3270HosLogPortEntry.setDescription('An entry of fclB3270HosLogPortTable.')
fclB3270HosLpLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 17, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclB3270HosLpLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclB3270HosLpLogPortId.setDescription('LP Id')
fclB3270HosLpLineWatchDog = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 17, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 2500))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclB3270HosLpLineWatchDog.setStatus('mandatory')
if mibBuilder.loadTexts: fclB3270HosLpLineWatchDog.setDescription('Tempo de surveillance de ligne')
fclB3270HosLpWackTransmission = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 17, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclB3270HosLpWackTransmission.setStatus('mandatory')
if mibBuilder.loadTexts: fclB3270HosLpWackTransmission.setDescription('Emission WACK')
fclB3270HosLpAnswerToPolling = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 17, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("always", 1), ("onlinkup", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclB3270HosLpAnswerToPolling.setStatus('mandatory')
if mibBuilder.loadTexts: fclB3270HosLpAnswerToPolling.setDescription('Reponse au poll systematique')
fclB3270HosClusterTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 17, 2, 2), )
if mibBuilder.loadTexts: fclB3270HosClusterTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclB3270HosClusterTable.setDescription('')
fclB3270HosClusterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 17, 2, 2, 1), ).setIndexNames((0, "PCE-MIB", "fclB3270HosClusterLogPortId"), (0, "PCE-MIB", "fclB3270HosClusterCluAdd"), (0, "PCE-MIB", "fclB3270HosClusterStaAdd"))
if mibBuilder.loadTexts: fclB3270HosClusterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclB3270HosClusterEntry.setDescription('An entry of fclB3270HosClusterTable.')
fclB3270HosClusterLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 17, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclB3270HosClusterLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclB3270HosClusterLogPortId.setDescription('LP Id')
fclB3270HosClusterCluAdd = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 17, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclB3270HosClusterCluAdd.setStatus('mandatory')
if mibBuilder.loadTexts: fclB3270HosClusterCluAdd.setDescription('Adresse du cluster')
fclB3270HosClusterStaAdd = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 17, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclB3270HosClusterStaAdd.setStatus('mandatory')
if mibBuilder.loadTexts: fclB3270HosClusterStaAdd.setDescription('Adresse station')
fclB3270HosClusterStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 17, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclB3270HosClusterStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fclB3270HosClusterStatus.setDescription('Status')
fclB3270ClusterLogPort = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 17, 3))
fclB3270CluLogPortTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 17, 3, 1), )
if mibBuilder.loadTexts: fclB3270CluLogPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclB3270CluLogPortTable.setDescription('')
fclB3270CluLogPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 17, 3, 1, 1), ).setIndexNames((0, "PCE-MIB", "fclB3270CluLpLogPortId"))
if mibBuilder.loadTexts: fclB3270CluLogPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclB3270CluLogPortEntry.setDescription('An entry of fclB3270CluLogPortTable.')
fclB3270CluLpLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 17, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclB3270CluLpLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclB3270CluLpLogPortId.setDescription('LP Id')
fclB3270CluLpPollingTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 17, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(100, 25000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclB3270CluLpPollingTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclB3270CluLpPollingTimer.setDescription("Temporisation d'interpolling")
fclB3270CluLpMaxNumberOfUnwPolls = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 17, 3, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclB3270CluLpMaxNumberOfUnwPolls.setStatus('mandatory')
if mibBuilder.loadTexts: fclB3270CluLpMaxNumberOfUnwPolls.setDescription('Nombre maximum de non reponse au polling')
fclB3270CluLpReconnectionType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 17, 3, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("automatic", 1), ("ondata", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclB3270CluLpReconnectionType.setStatus('mandatory')
if mibBuilder.loadTexts: fclB3270CluLpReconnectionType.setDescription('Type de reconnexion ')
fclB3270CluClusterTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 17, 3, 2), )
if mibBuilder.loadTexts: fclB3270CluClusterTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclB3270CluClusterTable.setDescription('')
fclB3270CluClusterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 17, 3, 2, 1), ).setIndexNames((0, "PCE-MIB", "fclB3270CluClusterLogPortId"), (0, "PCE-MIB", "fclB3270CluClusterCluAdd"), (0, "PCE-MIB", "fclB3270CluClusterStaAdd"))
if mibBuilder.loadTexts: fclB3270CluClusterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclB3270CluClusterEntry.setDescription('An entry of fclB3270CluClusterTable.')
fclB3270CluClusterLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 17, 3, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclB3270CluClusterLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclB3270CluClusterLogPortId.setDescription('LP Id')
fclB3270CluClusterCluAdd = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 17, 3, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclB3270CluClusterCluAdd.setStatus('mandatory')
if mibBuilder.loadTexts: fclB3270CluClusterCluAdd.setDescription('Adresse du cluster')
fclB3270CluClusterStaAdd = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 17, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclB3270CluClusterStaAdd.setStatus('mandatory')
if mibBuilder.loadTexts: fclB3270CluClusterStaAdd.setDescription('Adresse station')
fclB3270CluClusterStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 17, 3, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclB3270CluClusterStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fclB3270CluClusterStatus.setDescription('Status')
fclB3270CluCallTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 17, 3, 3), )
if mibBuilder.loadTexts: fclB3270CluCallTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclB3270CluCallTable.setDescription('')
fclB3270CluCallEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 17, 3, 3, 1), ).setIndexNames((0, "PCE-MIB", "fclB3270CluCallLogPortId"), (0, "PCE-MIB", "fclB3270CluCallCluAdd"))
if mibBuilder.loadTexts: fclB3270CluCallEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclB3270CluCallEntry.setDescription('An entry of fclB3270CluCallTable.')
fclB3270CluCallLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 17, 3, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclB3270CluCallLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclB3270CluCallLogPortId.setDescription('LP Id')
fclB3270CluCallCluAdd = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 17, 3, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclB3270CluCallCluAdd.setStatus('mandatory')
if mibBuilder.loadTexts: fclB3270CluCallCluAdd.setDescription('Adresse du cluster')
fclB3270CluCallStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 17, 3, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclB3270CluCallStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fclB3270CluCallStatus.setDescription('Status')
fclB3270CluCallCallAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 17, 3, 3, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclB3270CluCallCallAddr.setStatus('mandatory')
if mibBuilder.loadTexts: fclB3270CluCallCallAddr.setDescription('Adresse X121 appelee')
fclB3270CluCallMinRecallTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 17, 3, 3, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 990))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclB3270CluCallMinRecallTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclB3270CluCallMinRecallTimer.setDescription("Tempo de retransmission d'appel")
fclBscX780LogPort = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 18))
fclBX780LogPortTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 18, 1), )
if mibBuilder.loadTexts: fclBX780LogPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclBX780LogPortTable.setDescription('')
fclBX780LogPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 18, 1, 1), ).setIndexNames((0, "PCE-MIB", "fclBX780LpLogPortId"))
if mibBuilder.loadTexts: fclBX780LogPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclBX780LogPortEntry.setDescription('An entry of fclBX780LogPortTable.')
fclBX780LpLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 18, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclBX780LpLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclBX780LpLogPortId.setDescription('LP Id')
fclBX780LpInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 18, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclBX780LpInterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: fclBX780LpInterfaceId.setDescription('IF Id (type ligne)')
fclBX780LpProtocolType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 18, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("bsc2780", 1), ("bsc3780", 2), ("bsc3780onPSTN", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclBX780LpProtocolType.setStatus('mandatory')
if mibBuilder.loadTexts: fclBX780LpProtocolType.setDescription('Type de BSC')
fclBX780LpCallDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 18, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("calling", 1), ("called", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclBX780LpCallDirection.setStatus('mandatory')
if mibBuilder.loadTexts: fclBX780LpCallDirection.setDescription("Mode d'appel")
fclBX780LpDeconnectTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 18, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2500))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclBX780LpDeconnectTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclBX780LpDeconnectTimer.setDescription('Tempo de deconnexion')
fclBX780LpSurveyTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 18, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2500))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclBX780LpSurveyTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclBX780LpSurveyTimer.setDescription('Tempo de surveillance')
fclBX780LpCodingParityType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 18, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ebcdic", 1), ("asciioddparity", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclBX780LpCodingParityType.setStatus('mandatory')
if mibBuilder.loadTexts: fclBX780LpCodingParityType.setDescription('Type de codage parite')
fclBX780LpEquipementType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 18, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("term-term", 1), ("term-cpu", 2), ("cpu-cpu", 3), ("cpu-term", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclBX780LpEquipementType.setStatus('mandatory')
if mibBuilder.loadTexts: fclBX780LpEquipementType.setDescription('Type de couple')
fclBX780LpENQRetransTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 18, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(100, 25000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclBX780LpENQRetransTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclBX780LpENQRetransTimer.setDescription('Tempo de retransmission du ENQ')
fclBX780LpAuthorAnswerTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 18, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(100, 25000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclBX780LpAuthorAnswerTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclBX780LpAuthorAnswerTimer.setDescription('Tempo de reponse auteur')
fclBX780LpNoAnswerWatchDog = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 18, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(100, 25000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclBX780LpNoAnswerWatchDog.setStatus('mandatory')
if mibBuilder.loadTexts: fclBX780LpNoAnswerWatchDog.setDescription('Temporisation de non reponse')
fclBX780LpMessageRetryNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 18, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclBX780LpMessageRetryNumber.setStatus('mandatory')
if mibBuilder.loadTexts: fclBX780LpMessageRetryNumber.setDescription('Nombre de reemission de message')
fclBX780ConnectionTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 18, 2), )
if mibBuilder.loadTexts: fclBX780ConnectionTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclBX780ConnectionTable.setDescription('')
fclBX780ConnectionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 18, 2, 1), ).setIndexNames((0, "PCE-MIB", "fclBX780ConnLogPortId"))
if mibBuilder.loadTexts: fclBX780ConnectionEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclBX780ConnectionEntry.setDescription('An entry of fclBX780ConnectionTable.')
fclBX780ConnLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 18, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclBX780ConnLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclBX780ConnLogPortId.setDescription('LP Id')
fclBX780ConnCalledAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 18, 2, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclBX780ConnCalledAddr.setStatus('mandatory')
if mibBuilder.loadTexts: fclBX780ConnCalledAddr.setDescription('WAN adresse appelee')
fclBX780ConnMinimumRecallTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 18, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 990))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclBX780ConnMinimumRecallTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclBX780ConnMinimumRecallTimer.setDescription("Tempo de retransmission d'appel")
fclBX780IdentTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 18, 3), )
if mibBuilder.loadTexts: fclBX780IdentTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclBX780IdentTable.setDescription('')
fclBX780IdentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 18, 3, 1), ).setIndexNames((0, "PCE-MIB", "fclBX780IdentLogPortId"), (0, "PCE-MIB", "fclBX780IdentTermId"))
if mibBuilder.loadTexts: fclBX780IdentEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclBX780IdentEntry.setDescription('An entry of fclBX780IdentTable.')
fclBX780IdentLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 18, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclBX780IdentLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclBX780IdentLogPortId.setDescription('LP Id')
fclBX780IdentTermId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 18, 3, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclBX780IdentTermId.setStatus('mandatory')
if mibBuilder.loadTexts: fclBX780IdentTermId.setDescription('Ident du terminal')
fclBX780IdentStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 18, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclBX780IdentStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fclBX780IdentStatus.setDescription('Status')
fclBscSctLogPort = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 19))
fclBSctLogPortTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 19, 1), )
if mibBuilder.loadTexts: fclBSctLogPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclBSctLogPortTable.setDescription('')
fclBSctLogPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 19, 1, 1), ).setIndexNames((0, "PCE-MIB", "fclBSctLpLogPortId"))
if mibBuilder.loadTexts: fclBSctLogPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclBSctLogPortEntry.setDescription('An entry of fclBSctLogPortTable.')
fclBSctLpLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 19, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclBSctLpLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclBSctLpLogPortId.setDescription('LP Id')
fclBSctLpInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 19, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclBSctLpInterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: fclBSctLpInterfaceId.setDescription('IF Id (type ligne)')
fclBSctLpLinkType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 19, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("dte", 1), ("dce", 2), ("tpc", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclBSctLpLinkType.setStatus('mandatory')
if mibBuilder.loadTexts: fclBSctLpLinkType.setDescription('Type de liaison')
fclBSctLpNumberOfSYN = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 19, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 4))).clone(namedValues=NamedValues(("trans-of-2-SYN", 2), ("trans-of-4-SYN", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclBSctLpNumberOfSYN.setStatus('mandatory')
if mibBuilder.loadTexts: fclBSctLpNumberOfSYN.setDescription('Nombre de SYN avant la trame')
fclBSctLpSignalEnvelope = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 19, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclBSctLpSignalEnvelope.setStatus('mandatory')
if mibBuilder.loadTexts: fclBSctLpSignalEnvelope.setDescription('Enveloppe de trame')
fclBSctLpCodingParityType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 19, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ebcdic", 1), ("asciioddparity", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclBSctLpCodingParityType.setStatus('mandatory')
if mibBuilder.loadTexts: fclBSctLpCodingParityType.setDescription('Type de codage parite')
fclBSctLpMaxFrameNumberIn = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 19, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 254))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclBSctLpMaxFrameNumberIn.setStatus('mandatory')
if mibBuilder.loadTexts: fclBSctLpMaxFrameNumberIn.setDescription('Nombre de trame acceptee en entree')
fclBSctLpUnderrunManagement = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 19, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclBSctLpUnderrunManagement.setStatus('mandatory')
if mibBuilder.loadTexts: fclBSctLpUnderrunManagement.setDescription('Gestion de l underrun')
fclBSctLpOnePadSuppressed = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 19, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclBSctLpOnePadSuppressed.setStatus('mandatory')
if mibBuilder.loadTexts: fclBSctLpOnePadSuppressed.setDescription('Suppression d un pad')
fclBSctConnectionTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 19, 2), )
if mibBuilder.loadTexts: fclBSctConnectionTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclBSctConnectionTable.setDescription('')
fclBSctConnectionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 19, 2, 1), ).setIndexNames((0, "PCE-MIB", "fclBSctConnLogPortId"))
if mibBuilder.loadTexts: fclBSctConnectionEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclBSctConnectionEntry.setDescription('An entry of fclBSctConnectionTable.')
fclBSctConnLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 19, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclBSctConnLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclBSctConnLogPortId.setDescription('LP Id')
fclBSctConnCalledAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 19, 2, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclBSctConnCalledAddr.setStatus('mandatory')
if mibBuilder.loadTexts: fclBSctConnCalledAddr.setDescription('WAN adresse appele')
fclBSctConnCallDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 19, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("calling", 1), ("called", 2), ("auto", 3), ("datagram", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclBSctConnCallDirection.setStatus('mandatory')
if mibBuilder.loadTexts: fclBSctConnCallDirection.setDescription('Mode d appel')
fclBSctConnSubscriberNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 19, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9999))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclBSctConnSubscriberNumber.setStatus('mandatory')
if mibBuilder.loadTexts: fclBSctConnSubscriberNumber.setDescription("Numero d'abonne")
fclBSctConnMinimumRecallTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 19, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 990))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclBSctConnMinimumRecallTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclBSctConnMinimumRecallTimer.setDescription("Tempo de retransmission d'appel")
fclBSctProtocolDefinition1Table = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 19, 3), )
if mibBuilder.loadTexts: fclBSctProtocolDefinition1Table.setStatus('mandatory')
if mibBuilder.loadTexts: fclBSctProtocolDefinition1Table.setDescription('')
fclBSctProtocolDefinition1Entry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 19, 3, 1), ).setIndexNames((0, "PCE-MIB", "fclBSctProtDef1LogPortId"))
if mibBuilder.loadTexts: fclBSctProtocolDefinition1Entry.setStatus('mandatory')
if mibBuilder.loadTexts: fclBSctProtocolDefinition1Entry.setDescription('An entry of fclBSctProtocolDefinition1Table.')
fclBSctProtDef1LogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 19, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclBSctProtDef1LogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclBSctProtDef1LogPortId.setDescription('LP Id')
fclBSctProtDef1PermanentDelimiter1 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 19, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("none", 1), ("enq", 2), ("nak", 3), ("eot", 4), ("stx", 5), ("soh", 6), ("etx", 7), ("etb", 8), ("pad", 9), ("ack", 10), ("dle", 11), ("esc", 12), ("bel", 13)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclBSctProtDef1PermanentDelimiter1.setStatus('mandatory')
if mibBuilder.loadTexts: fclBSctProtDef1PermanentDelimiter1.setDescription('1 e Delimiteur Permanent')
fclBSctProtDef1PermanentDelimiter2 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 19, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("none", 1), ("enq", 2), ("nak", 3), ("eot", 4), ("stx", 5), ("soh", 6), ("etx", 7), ("etb", 8), ("pad", 9), ("ack", 10), ("dle", 11), ("esc", 12), ("bel", 13)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclBSctProtDef1PermanentDelimiter2.setStatus('mandatory')
if mibBuilder.loadTexts: fclBSctProtDef1PermanentDelimiter2.setDescription('2 e Delimiteur Permanent')
fclBSctProtDef1PermanentDelimiter3 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 19, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("none", 1), ("enq", 2), ("nak", 3), ("eot", 4), ("stx", 5), ("soh", 6), ("etx", 7), ("etb", 8), ("pad", 9), ("ack", 10), ("dle", 11), ("esc", 12), ("bel", 13)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclBSctProtDef1PermanentDelimiter3.setStatus('mandatory')
if mibBuilder.loadTexts: fclBSctProtDef1PermanentDelimiter3.setDescription('3 e Delimiteur Permanent')
fclBSctProtDef1PermanentDelimiter4 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 19, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("none", 1), ("enq", 2), ("nak", 3), ("eot", 4), ("stx", 5), ("soh", 6), ("etx", 7), ("etb", 8), ("pad", 9), ("ack", 10), ("dle", 11), ("esc", 12), ("bel", 13)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclBSctProtDef1PermanentDelimiter4.setStatus('mandatory')
if mibBuilder.loadTexts: fclBSctProtDef1PermanentDelimiter4.setDescription('4 e Delimiteur Permanent')
fclBSctProtDef1PermanentDelimiter5 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 19, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("none", 1), ("enq", 2), ("nak", 3), ("eot", 4), ("stx", 5), ("soh", 6), ("etx", 7), ("etb", 8), ("pad", 9), ("ack", 10), ("dle", 11), ("esc", 12), ("bel", 13)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclBSctProtDef1PermanentDelimiter5.setStatus('mandatory')
if mibBuilder.loadTexts: fclBSctProtDef1PermanentDelimiter5.setDescription('5 e Delimiteur Permanent')
fclBSctProtDef1StartFrameDelimiter1 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 19, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("none", 1), ("enq", 2), ("nak", 3), ("eot", 4), ("stx", 5), ("soh", 6), ("etx", 7), ("etb", 8), ("pad", 9), ("ack", 10), ("dle", 11), ("esc", 12), ("bel", 13)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclBSctProtDef1StartFrameDelimiter1.setStatus('mandatory')
if mibBuilder.loadTexts: fclBSctProtDef1StartFrameDelimiter1.setDescription('1 e delimiteur de debut de trame')
fclBSctProtDef1StartFrameDelimiter2 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 19, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("none", 1), ("enq", 2), ("nak", 3), ("eot", 4), ("stx", 5), ("soh", 6), ("etx", 7), ("etb", 8), ("pad", 9), ("ack", 10), ("dle", 11), ("esc", 12), ("bel", 13)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclBSctProtDef1StartFrameDelimiter2.setStatus('mandatory')
if mibBuilder.loadTexts: fclBSctProtDef1StartFrameDelimiter2.setDescription('2 e delimiteur de debut de trame')
fclBSctProtDef1StartFrameDelimiter3 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 19, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("none", 1), ("enq", 2), ("nak", 3), ("eot", 4), ("stx", 5), ("soh", 6), ("etx", 7), ("etb", 8), ("pad", 9), ("ack", 10), ("dle", 11), ("esc", 12), ("bel", 13)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclBSctProtDef1StartFrameDelimiter3.setStatus('mandatory')
if mibBuilder.loadTexts: fclBSctProtDef1StartFrameDelimiter3.setDescription('3 e delimiteur de debut de trame')
fclBSctProtDef1NbCharInhibited = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 19, 3, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclBSctProtDef1NbCharInhibited.setStatus('mandatory')
if mibBuilder.loadTexts: fclBSctProtDef1NbCharInhibited.setDescription('nombre de caracteres a iniber')
fclBSctProtDef1StFrDelimiterInhib1 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 19, 3, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("none", 1), ("enq", 2), ("nak", 3), ("eot", 4), ("stx", 5), ("soh", 6), ("etx", 7), ("etb", 8), ("pad", 9), ("ack", 10), ("dle", 11), ("esc", 12), ("bel", 13)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclBSctProtDef1StFrDelimiterInhib1.setStatus('mandatory')
if mibBuilder.loadTexts: fclBSctProtDef1StFrDelimiterInhib1.setDescription('1 e delimiteur de debut de trame avec inibition')
fclBSctProtDef1StFrDelimiterInhib2 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 19, 3, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("none", 1), ("enq", 2), ("nak", 3), ("eot", 4), ("stx", 5), ("soh", 6), ("etx", 7), ("etb", 8), ("pad", 9), ("ack", 10), ("dle", 11), ("esc", 12), ("bel", 13)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclBSctProtDef1StFrDelimiterInhib2.setStatus('mandatory')
if mibBuilder.loadTexts: fclBSctProtDef1StFrDelimiterInhib2.setDescription('2 e delimiteur de debut de trame avec inibition')
fclBSctProtocolDefinition2Table = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 19, 4), )
if mibBuilder.loadTexts: fclBSctProtocolDefinition2Table.setStatus('mandatory')
if mibBuilder.loadTexts: fclBSctProtocolDefinition2Table.setDescription('')
fclBSctProtocolDefinition2Entry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 19, 4, 1), ).setIndexNames((0, "PCE-MIB", "fclBSctProtDef2LogPortId"))
if mibBuilder.loadTexts: fclBSctProtocolDefinition2Entry.setStatus('mandatory')
if mibBuilder.loadTexts: fclBSctProtocolDefinition2Entry.setDescription('An entry of fclBSctProtocolDefinition2Table.')
fclBSctProtDef2LogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 19, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclBSctProtDef2LogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclBSctProtDef2LogPortId.setDescription('LP Id')
fclBSctProtDef2DataFrameTerminator1 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 19, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("none", 1), ("enq", 2), ("nak", 3), ("eot", 4), ("stx", 5), ("soh", 6), ("etx", 7), ("etb", 8), ("pad", 9), ("ack", 10), ("dle", 11), ("esc", 12), ("bel", 13)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclBSctProtDef2DataFrameTerminator1.setStatus('mandatory')
if mibBuilder.loadTexts: fclBSctProtDef2DataFrameTerminator1.setDescription('1 e Terminateur de trame de donnees')
fclBSctProtDef2DataFrameTerminator2 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 19, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("none", 1), ("enq", 2), ("nak", 3), ("eot", 4), ("stx", 5), ("soh", 6), ("etx", 7), ("etb", 8), ("pad", 9), ("ack", 10), ("dle", 11), ("esc", 12), ("bel", 13)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclBSctProtDef2DataFrameTerminator2.setStatus('mandatory')
if mibBuilder.loadTexts: fclBSctProtDef2DataFrameTerminator2.setDescription('2 e Terminateur de trame de donnees')
fclBSctProtDef2DataFrameTerminator3 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 19, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("none", 1), ("enq", 2), ("nak", 3), ("eot", 4), ("stx", 5), ("soh", 6), ("etx", 7), ("etb", 8), ("pad", 9), ("ack", 10), ("dle", 11), ("esc", 12), ("bel", 13)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclBSctProtDef2DataFrameTerminator3.setStatus('mandatory')
if mibBuilder.loadTexts: fclBSctProtDef2DataFrameTerminator3.setDescription('3 e Terminateur de trame de donnees')
fclBSctProtDef2ControlFrameTerminator1 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 19, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("none", 1), ("enq", 2), ("nak", 3), ("eot", 4), ("stx", 5), ("soh", 6), ("etx", 7), ("etb", 8), ("pad", 9), ("ack", 10), ("dle", 11), ("esc", 12), ("bel", 13)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclBSctProtDef2ControlFrameTerminator1.setStatus('mandatory')
if mibBuilder.loadTexts: fclBSctProtDef2ControlFrameTerminator1.setDescription('1 e Terminateur de trame de controle')
fclBSctProtDef2ControlFrameTerminator2 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 19, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("none", 1), ("enq", 2), ("nak", 3), ("eot", 4), ("stx", 5), ("soh", 6), ("etx", 7), ("etb", 8), ("pad", 9), ("ack", 10), ("dle", 11), ("esc", 12), ("bel", 13)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclBSctProtDef2ControlFrameTerminator2.setStatus('mandatory')
if mibBuilder.loadTexts: fclBSctProtDef2ControlFrameTerminator2.setDescription('2 e Terminateur de trame de controle')
fclBSctProtDef2ACK0 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 19, 4, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclBSctProtDef2ACK0.setStatus('mandatory')
if mibBuilder.loadTexts: fclBSctProtDef2ACK0.setDescription('ACK0')
fclBSctProtDef2ACK1 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 19, 4, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclBSctProtDef2ACK1.setStatus('mandatory')
if mibBuilder.loadTexts: fclBSctProtDef2ACK1.setDescription('ACK1')
fclBSctProtDef2WACK = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 19, 4, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclBSctProtDef2WACK.setStatus('mandatory')
if mibBuilder.loadTexts: fclBSctProtDef2WACK.setDescription('WACK')
fclBSctProtDef2RVI = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 19, 4, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclBSctProtDef2RVI.setStatus('mandatory')
if mibBuilder.loadTexts: fclBSctProtDef2RVI.setDescription('RVI')
fclBSctProtDef2WABT = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 19, 4, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclBSctProtDef2WABT.setStatus('mandatory')
if mibBuilder.loadTexts: fclBSctProtDef2WABT.setDescription('WABT')
fclX25SlpAccess = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 20))
fclX25SlpAccessTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 20, 1), )
if mibBuilder.loadTexts: fclX25SlpAccessTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25SlpAccessTable.setDescription('This table defines the general parameters of X25 SLP (Single Link Protocol) access logical ports.')
fclX25SlpAccessEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 20, 1, 1), ).setIndexNames((0, "PCE-MIB", "fclX25AccLogPortId"))
if mibBuilder.loadTexts: fclX25SlpAccessEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25SlpAccessEntry.setDescription('An entry of fclX25SlpAccessTable.')
fclX25AccLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 20, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclX25AccLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25AccLogPortId.setDescription("The value of this object identifies one and only one X25 SLP (Single Link Protocol) access logical port. The possible values are : '0..131'. If it is unused, the value of this parameter is '255'. The default value is '255'.")
fclX25AccInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 20, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25AccInterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25AccInterfaceId.setDescription("The value of this object identifies the line interface used by this X25 access logical port. The possible values are : '0..35'. If it is unused, the value of this parameter is '255'. The default value is '255'.")
fclX25AccConnectionType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 20, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("subscriber", 1), ("publicNetwork", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25AccConnectionType.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25AccConnectionType.setDescription("The value of this object indicates which is the system connected to this X25 access logical port. The possible values are : subscriber : this X25 access logical port logical port is facing to a X25 subscriber, fclX25AccSubscriberNumber is used, fclX25AccPdnLinkAddress is not used, publicNetwork : this logical port is facing to a X25 Public Data Network, fclX25AccSubscriberNumber is not used, fclX25AccPdnLinkAddress is used. The default value is 'subscriber'.")
fclX25AccSubscriberNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 20, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25AccSubscriberNumber.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25AccSubscriberNumber.setDescription("The value of this object is the SB number added to the DNICZO of the equipment to make the calling address in a call sent from this X25 access logical port (if fclX25AccConnectionType is set to 'subscriber'). The value must contain 2 digits (digits 0..9). The default value is 'FF'.")
fclX25AccPdnLinkAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 20, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25AccPdnLinkAddress.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25AccPdnLinkAddress.setDescription("The value of this object is the X121 address of the equipment on the connected network (if fclX25AccConnectionType is set to 'publicNetwork'). The value may contain up to 15 digits (digits 0..9). The value must be completed with 'F' digits for a total of 16 digits. The equipment configurator does not need final completion. The default value is 'FF FF FF FF FF FF FF FF' meaning 'empty value' (blank value on the equipment configurator).")
fclX25AccX25AccessConfigId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 20, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25AccX25AccessConfigId.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25AccX25AccessConfigId.setDescription("The value of this object identifies the X25 access configuration used by this X25 access logical port. This X25 access configuration must be present in fclX25ConfigAccessTable. The possible values are : '0..199. If it is unused, the value of this parameter is '255'.")
fclX25AccIsdnBackupEnabling = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 20, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 7))).clone(namedValues=NamedValues(("off", 1), ("onWhileActivity", 2), ("onWhileLpDown", 3), ("onWhileExcessTraffic", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25AccIsdnBackupEnabling.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25AccIsdnBackupEnabling.setDescription('Secours RNIS')
fclX25AccPstnBackupEnabling = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 20, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 7))).clone(namedValues=NamedValues(("off", 1), ("onWhileActivity", 2), ("onWhileLpDown", 3), ("onWhileExcessTraffic", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25AccPstnBackupEnabling.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25AccPstnBackupEnabling.setDescription('Secours RTC')
fclX25AccPrivateNetTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 20, 2), )
if mibBuilder.loadTexts: fclX25AccPrivateNetTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25AccPrivateNetTable.setDescription('This table defines the X25 access logical ports for which some X25 call packet fields are saved in X25 facility field. The restoration of these field takes place on the other side of the network in a symetric X25 SLP access logical port.')
fclX25AccPrivateNetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 20, 2, 1), ).setIndexNames((0, "PCE-MIB", "fclX25AccPrivLogPortId"))
if mibBuilder.loadTexts: fclX25AccPrivateNetEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25AccPrivateNetEntry.setDescription('An entry of fclX25AccPrivateNetTable.')
fclX25AccPrivLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 20, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclX25AccPrivLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25AccPrivLogPortId.setDescription("The value of this object identifies one and only one X25 access logical port.The possible values are : '0..131'. If it is unused, the value of this parameter is '255'. The default value is '255'.")
fclX25AccPrivX25FieldsSave = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 20, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4, 8, 16))).clone(namedValues=NamedValues(("off", 1), ("addr", 4), ("addrCug", 8), ("addrCugRc", 16)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25AccPrivX25FieldsSave.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25AccPrivX25FieldsSave.setDescription("The value of this object indicates which X25 call packet fields are saved in X25 facility field for this X25 access logical port. The save operation is made on X25 call packets sent over the network and the restore operation is made on X25 packets received from the network. The possible values are : off : no save/restore procedure, addr : called and calling addresses, addrCug : called and calling addresses, Closed User Group, addrCugRc : called and calling addresses, Closed User Group, Reverse Charging. The default value is 'off'.")
fclX25AccPrivX25FieldsChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 20, 2, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(25, 25)).setFixedLength(25)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25AccPrivX25FieldsChanges.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25AccPrivX25FieldsChanges.setDescription("The value of this object describes X25 fields modifications. The syntaxe is <Modification>[value]. There are 3 possible modifications : BF : adds a facility at output, DA : deletes caller's address at input, CE : changes called party address. Example : DA CE 90 40 21 80 BF 70 10 00, DA deletes the calling address, CE 90 40 21 80 changes the called address to 90402180, BF 70 10 00 adds the facility 701000 at output of switch. 25 bytes from 00 to FF must be specified. The first byte contains the number of following useful bytes. The trailing bytes must be set to 'FF'. The equipment configurator does not need this final completion. The default value is 'empty' (first byte set to '00').")
fclX25AccPermanentVcTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 20, 3), )
if mibBuilder.loadTexts: fclX25AccPermanentVcTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25AccPermanentVcTable.setDescription('This table defines the X25 PVC (Permananent Virtual Circuits) on X25 Access logical ports. For each PVC this table defines the addres of the called remote peer and the different parameters of the call processing.')
fclX25AccPermanentVcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 20, 3, 1), ).setIndexNames((0, "PCE-MIB", "fclX25AccPvcLogPortId"), (0, "PCE-MIB", "fclX25AccPvcLocalLogChannel"))
if mibBuilder.loadTexts: fclX25AccPermanentVcEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25AccPermanentVcEntry.setDescription('An entry of fclX25AccPermanentVcTable.')
fclX25AccPvcLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 20, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclX25AccPvcLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25AccPvcLogPortId.setDescription("The value of this object identifies one and only one X25 Access logical port. This is the logical port this PVC (Permanent Virtual Circuit) is layered onto. The possible values are : '0..131'. If it is unused, the value of this parameter is '255'. The default value is '255'.")
fclX25AccPvcLocalLogChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 20, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 250))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclX25AccPvcLocalLogChannel.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25AccPvcLocalLogChannel.setDescription("The value of this object is equal to the logical channel value for this PVC. The possible values are '0..250'. The default value is '255'.")
fclX25AccPvcStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 20, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25AccPvcStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25AccPvcStatus.setDescription("The value of this object indicates the state of the entry of this table. The default value is 'valid'. It must be set to 'invalid' to delete the entry.")
fclX25AccPvcCalledAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 20, 3, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25AccPvcCalledAddr.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25AccPvcCalledAddr.setDescription("The value of this object is the X121 address of the called remote peer PVC. This value is the called address specified in the call packet sent from this PVC. The value may contain up to 15 digits (digits 0..9). The value must be completed with 'F' digits for a total of 16 digits. The equipment configurator does not need final completion. The default value is 'FF FF FF FF FF FF FF FF' meaning 'empty value' (blank value on the equipment configurator).")
fclX25AccPvcRemoteLogChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 20, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 250))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25AccPvcRemoteLogChannel.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25AccPvcRemoteLogChannel.setDescription("The value of this object is equal to the logical channel value for the remote peer PVC. The possible values are '0..250'. The default value is '255'.")
fclX25AccPvcMinimumRecallTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 20, 3, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 990))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25AccPvcMinimumRecallTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25AccPvcMinimumRecallTimer.setDescription("The value of this object specifies the minimum recall time (in seconds) between two successive calls. The authorized values are '0..990' by step of 10. The default value is '0'.")
fclX25AccPvcCallDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 20, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("calling", 1), ("called", 2), ("auto", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25AccPvcCallDirection.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25AccPvcCallDirection.setDescription("The value of this object defines the mode used to establish the X25 VC between this PVC and the remote one on the other side of the network. The authorized values are 'calling' (the caller is this PVC), 'called' (the caller is the remote PVC), 'auto' (automatic choise between 'calling' and 'called'). The default value is 'auto'.")
fclX25AccPvcFacility = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 20, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("none", 1), ("throughputClass", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25AccPvcFacility.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25AccPvcFacility.setDescription('Facilites')
fclX25AccPvcFacThroughputClass = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 20, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("t75", 3), ("t150", 4), ("t300", 5), ("t600", 6), ("t1200", 7), ("t2400", 8), ("t4800", 9), ("t9600", 10), ("t19200", 11), ("t48000", 12), ("t64000", 13), ("t128000", 14), ("t192000", 15)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25AccPvcFacThroughputClass.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25AccPvcFacThroughputClass.setDescription('Classe de debit eventuelle')
fclX25AccSwitchOverTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 20, 4), )
if mibBuilder.loadTexts: fclX25AccSwitchOverTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25AccSwitchOverTable.setDescription('')
fclX25AccSwitchOverEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 20, 4, 1), ).setIndexNames((0, "PCE-MIB", "fclX25AccSwLogPortId"))
if mibBuilder.loadTexts: fclX25AccSwitchOverEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25AccSwitchOverEntry.setDescription('An entry of fclX25AccSwitchOverTable.')
fclX25AccSwLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 20, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclX25AccSwLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25AccSwLogPortId.setDescription('LP id')
fclX25AccSwMeasureCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 20, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 249))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25AccSwMeasureCount.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25AccSwMeasureCount.setDescription('Nombre de mesures avant basculement')
fclX25AccSwSwitchThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 20, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25AccSwSwitchThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25AccSwSwitchThreshold.setDescription('Seuil haut (en pourcentage)')
fclX25AccSwSwitchBackThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 20, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25AccSwSwitchBackThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25AccSwSwitchBackThreshold.setDescription('Seuil bas (en pourcentage)')
fclX25AccIsdnBackupTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 20, 5), )
if mibBuilder.loadTexts: fclX25AccIsdnBackupTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25AccIsdnBackupTable.setDescription('')
fclX25AccIsdnBackupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 20, 5, 1), ).setIndexNames((0, "PCE-MIB", "fclX25AccIsdnBackLogPortId"), (0, "PCE-MIB", "fclX25AccIsdnBackIsdnInterfaceId"))
if mibBuilder.loadTexts: fclX25AccIsdnBackupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25AccIsdnBackupEntry.setDescription('An entry of fclX25AccIsdnBackupTable.')
fclX25AccIsdnBackLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 20, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclX25AccIsdnBackLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25AccIsdnBackLogPortId.setDescription('LP id')
fclX25AccIsdnBackIsdnInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 20, 5, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclX25AccIsdnBackIsdnInterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25AccIsdnBackIsdnInterfaceId.setDescription('IF id (type RNIS)')
fclX25AccIsdnBackStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 20, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25AccIsdnBackStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25AccIsdnBackStatus.setDescription('Status')
fclX25AccIsdnRemotePeerTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 20, 6), )
if mibBuilder.loadTexts: fclX25AccIsdnRemotePeerTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25AccIsdnRemotePeerTable.setDescription('')
fclX25AccIsdnRemotePeerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 20, 6, 1), ).setIndexNames((0, "PCE-MIB", "fclX25AccIsdnRemLogPortId"), (0, "PCE-MIB", "fclX25AccIsdnRemIsdnInterfaceId"))
if mibBuilder.loadTexts: fclX25AccIsdnRemotePeerEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25AccIsdnRemotePeerEntry.setDescription('An entry of fclX25AccIsdnRemotePeerTable.')
fclX25AccIsdnRemLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 20, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclX25AccIsdnRemLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25AccIsdnRemLogPortId.setDescription('LP id')
fclX25AccIsdnRemIsdnInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 20, 6, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclX25AccIsdnRemIsdnInterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25AccIsdnRemIsdnInterfaceId.setDescription('Interface RNIS distante id')
fclX25AccIsdnRemStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 20, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25AccIsdnRemStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25AccIsdnRemStatus.setDescription('Status')
fclX25AccIsdnRemX25AccessConfigId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 20, 6, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25AccIsdnRemX25AccessConfigId.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25AccIsdnRemX25AccessConfigId.setDescription('Configuration X25 acces id')
fclX25AccIsdnRemPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 20, 6, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25AccIsdnRemPriority.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25AccIsdnRemPriority.setDescription('Priorite')
fclX25AccIsdnRemCallRetryCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 20, 6, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25AccIsdnRemCallRetryCount.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25AccIsdnRemCallRetryCount.setDescription('Nb de tentatives appel')
fclX25AccPstnBackupTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 20, 7), )
if mibBuilder.loadTexts: fclX25AccPstnBackupTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25AccPstnBackupTable.setDescription('')
fclX25AccPstnBackupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 20, 7, 1), ).setIndexNames((0, "PCE-MIB", "fclX25AccPstnBackLogPortId"))
if mibBuilder.loadTexts: fclX25AccPstnBackupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25AccPstnBackupEntry.setDescription('An entry of fclX25AccPstnBackupTable.')
fclX25AccPstnBackLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 20, 7, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclX25AccPstnBackLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25AccPstnBackLogPortId.setDescription('LP id')
fclX25AccPstnBackStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 20, 7, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25AccPstnBackStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25AccPstnBackStatus.setDescription('Status')
fclX25AccPstnBackInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 20, 7, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25AccPstnBackInterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25AccPstnBackInterfaceId.setDescription('IF id (type ligne)')
fclX25AccPstnBackPstnNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 20, 7, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(14, 14)).setFixedLength(14)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25AccPstnBackPstnNumber.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25AccPstnBackPstnNumber.setDescription('Numero RTC')
fclX25AccPstnBackX25AccessConfigId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 20, 7, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25AccPstnBackX25AccessConfigId.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25AccPstnBackX25AccessConfigId.setDescription('Configuration X25 acces id')
fclX25InDIsdn = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 21))
fclX25InDIsdnTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 21, 1), )
if mibBuilder.loadTexts: fclX25InDIsdnTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25InDIsdnTable.setDescription('This table defines the general parameters of X25 SLP (Single Link Protocol) in ISDN D channel access logical ports.')
fclX25InDIsdnEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 21, 1, 1), ).setIndexNames((0, "PCE-MIB", "fclX25InDLogPortId"))
if mibBuilder.loadTexts: fclX25InDIsdnEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25InDIsdnEntry.setDescription('An entry of fclX25InDIsdnTable.')
fclX25InDLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 21, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclX25InDLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25InDLogPortId.setDescription("The value of this object identifies one and only one X25 in ISDN D Channel logical port. The possible values are : '0..131'. If it is unused, the value of this parameter is '255'. The default value is '255'.")
fclX25InDIsdnInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 21, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25InDIsdnInterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25InDIsdnInterfaceId.setDescription("The value of this object identifies the ISDN Basic Rate Interface used by this X25 in ISDN-D logical port. The possible values are : '0..35'. If it is unused, the value of this parameter is '255'. The default value is '255'.")
fclX25InDTei = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 21, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25InDTei.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25InDTei.setDescription("The value of this object defines the TEI (Terminal Endpoint Identifier) used by this X25 in ISDN-D logical port. The authorized values are '1..63'. The default value is '255'.")
fclX25InDBackupEnabling = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 21, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 7))).clone(namedValues=NamedValues(("off", 1), ("onWhileActivity", 2), ("onWhileLpDown", 3), ("onWhileExcessTraffic", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25InDBackupEnabling.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25InDBackupEnabling.setDescription("The value of this object defines how this X25 in ISDN-D logical port may be backuped by an ISDN-B channel. The possible values are : off : backup is never enabled, onWhileActivity : when the logical port is DOWN, backup is enabled on reception of a new call and remains active while at least one X25 VC is using this way. When no VC is active, the backup is disabled and the next VC will be established on the logical port (if it is UP obviously). onWhileLpDown : when the logical port is DOWN, backup is enabled on reception of a new call and remains active while the logical port is DOWN. The backup is disabled (meaning clearing of all VCs using this way) when the logical port comes back UP and the next VC will be established on the logical port. onWhileExcessTraffic : when the traffic overtakes the fclX25InDSwSwitchThreshold value the logical port state is marked DOWN (meaning clearing of all VCs), backup is enabled on reception of a new call and remains active while the traffic is overtaking the fclX25InDSwSwitchBackThreshold value. When the traffic does not overtake any more the fclX25InDSwSwitchBackThreshold value, the logical port is marked UP and the backup is disabled (meaning clearing of all VCs using this way) so the next VC will be established on the logical port. This Switch Over mechanism permits to transmit temporay excess traffic which could not be transmitted on the ISDN-D Channel because of an insufficient bandwith (16 kbit/s against 64 kbits/s for an ISDN-B Channel). The default value is 'off'.")
fclX25InDConnectionType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 21, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("subscriber", 1), ("publicNetwork", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25InDConnectionType.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25InDConnectionType.setDescription("The value of this object indicates which is the system connected to this X25 in ISDN-D logical port. The possible values are : subscriber : this X25 ISDN-D logical port logical port is facing to a X25 subscriber, fclX25InDSubscriberNumber is used, fclX25InDPdnLinkAddress is not used, publicNetwork : this logical port is facing to a X25 Public Data Network, fclX25InDSubscriberNumber is not used, fclX25InDPdnLinkAddress is used. The default value is 'subscriber'.")
fclX25InDSubscriberNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 21, 1, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25InDSubscriberNumber.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25InDSubscriberNumber.setDescription("The value of this object is the SB number added to the DNICZO of the equipment to make the calling address in a call sent from this X25 in ISDN-D logical port (if fclX25InDConnectionType is set to 'subscriber'). The value must contain 2 digits (digits 0..9). The default value is 'FF'.")
fclX25InDPdnLinkAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 21, 1, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25InDPdnLinkAddress.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25InDPdnLinkAddress.setDescription("The value of this object is the X121 address of the equipment on the connected network (if fclX25InDConnectionType is set to 'publicNetwork'). The value may contain up to 15 digits (digits 0..9). The value must be completed with 'F' digits for a total of 16 digits. The equipment configurator does not need final completion. The default value is 'FF FF FF FF FF FF FF FF' meaning 'empty value' (blank value on the equipment configurator).")
fclX25InDX25AccessConfigId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 21, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25InDX25AccessConfigId.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25InDX25AccessConfigId.setDescription("The value of this object identifies the X25 access configuration used by this X25 in ISDN-D logical port. This X25 access configuration must be present in fclX25ConfigAccessTable. The possible values are : '0..199. If it is unused, the value of this parameter is '255'.")
fclX25InDInactivityTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 21, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 250))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25InDInactivityTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25InDInactivityTimer.setDescription("The value of this object defines the delay in seconds between the clearing of the last X25 VC using this ISDN-D logical port and the clearing of the ISDN connection. The authorized values are '0..250'. The default value is '0'.")
fclX25InDActiveLinkAtBootTime = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 21, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25InDActiveLinkAtBootTime.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25InDActiveLinkAtBootTime.setDescription("The value of this object indicates whether the equipment, when it has just started, must establish the ISDN connection or not. The default value is 'off'.")
fclX25InDSwitchOverTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 21, 2), )
if mibBuilder.loadTexts: fclX25InDSwitchOverTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25InDSwitchOverTable.setDescription('This table defines the switch over parameters of X25 in ISDN D channel access logical ports using the switch over mechanism.')
fclX25InDSwitchOverEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 21, 2, 1), ).setIndexNames((0, "PCE-MIB", "fclX25InDSwLogPortId"))
if mibBuilder.loadTexts: fclX25InDSwitchOverEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25InDSwitchOverEntry.setDescription('An entry of fclX25InDSwitchOverTable.')
fclX25InDSwLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 21, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclX25InDSwLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25InDSwLogPortId.setDescription("The value of this object identifies one and only one X25 in ISDN D Channel logical port using the switch over mechanism (fclX25InDBackupEnabling set to 'onWhileExcessTraffic'). The possible values are : '0..131'. If it is unused, the value of this parameter is '255'. The default value is '255'.")
fclX25InDSwMeasureCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 21, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 249))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25InDSwMeasureCount.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25InDSwMeasureCount.setDescription("The value of this object is the number of traffic measures before switching. The measure duration is defined by fcwLoadAndTrafficSummingPeriod. The authorized values are '0..249'. The default value is '2'.")
fclX25InDSwSwitchThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 21, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25InDSwSwitchThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25InDSwSwitchThreshold.setDescription("The value of this object indicates the traffic threshold (in percents of bandwith of the main link of logical port) over which the switch over mechanism is enabled. The authorized values are '0..100'. The default value is '80'.")
fclX25InDSwSwitchBackThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 21, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25InDSwSwitchBackThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25InDSwSwitchBackThreshold.setDescription("The value of this object indicates the traffic threshold (in percents of bandwith of the main link of logical port) under which the switch over mechanism is disabled. The authorized values are '0..100'. The default value is '60'.")
fclX25InDIsdnBackupTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 21, 3), )
if mibBuilder.loadTexts: fclX25InDIsdnBackupTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25InDIsdnBackupTable.setDescription('This table defines which ISDN Basic Rate Interface may be used by each X25 in ISDN D channel access logical port when enabling backup on ISDN B-Channels.')
fclX25InDIsdnBackupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 21, 3, 1), ).setIndexNames((0, "PCE-MIB", "fclX25InDIsdnBackLogPortId"), (0, "PCE-MIB", "fclX25InDIsdnBackIsdnInterfaceId"))
if mibBuilder.loadTexts: fclX25InDIsdnBackupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25InDIsdnBackupEntry.setDescription('An entry of fclX25InDIsdnBackupTable.')
fclX25InDIsdnBackLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 21, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclX25InDIsdnBackLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25InDIsdnBackLogPortId.setDescription("The value of this object identifies one and only one X25 in ISDN D channel access logical port. One X25 X25 in ISDN D channel logical port may use backup with one or several ISDN Basic Rate Interfaces. The possible values are : '0..131'. If it is unused, the value of this parameter is '255'. The default value is '255'.")
fclX25InDIsdnBackIsdnInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 21, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclX25InDIsdnBackIsdnInterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25InDIsdnBackIsdnInterfaceId.setDescription("The value of this object identifies one ISDN Basic Rate Interface used by the X25 in ISDN D channel access logical port defined by fclX25InDIsdnBackLogPortId. The possible values are : '0..35'. If it is unused, the value of this parameter is '255'. The default value is '255'.")
fclX25InDIsdnBackStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 21, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25InDIsdnBackStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25InDIsdnBackStatus.setDescription("The value of this object indicates the state of the entry of this table. The default value is 'valid'. It must be set to 'invalid' to delete the entry.")
fclX25InDIsdnRemotePeerTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 21, 4), )
if mibBuilder.loadTexts: fclX25InDIsdnRemotePeerTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25InDIsdnRemotePeerTable.setDescription('This table defines the ISDN remote systems which may be connected to the equipment using the backup mechanism of X25 in ISDN D channel access logical ports .')
fclX25InDIsdnRemotePeerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 21, 4, 1), ).setIndexNames((0, "PCE-MIB", "fclX25InDIsdnRemLogPortId"), (0, "PCE-MIB", "fclX25InDIsdnRemIsdnInterfaceId"))
if mibBuilder.loadTexts: fclX25InDIsdnRemotePeerEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25InDIsdnRemotePeerEntry.setDescription('An entry of fclX25InDIsdnRemotePeerTable.')
fclX25InDIsdnRemLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 21, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclX25InDIsdnRemLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25InDIsdnRemLogPortId.setDescription("The value of this object identifies one and only one X25 in ISDN D channel access logical port. One X25 in ISDN D channel logical port may use backup mechanism with one or several ISDN remote systems (these ISDN systems can be on different equipments). The possible values are : '0..131'. If it is unused, the value of this parameter is '255'. The default value is '255'.")
fclX25InDIsdnRemIsdnInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 21, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 249))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclX25InDIsdnRemIsdnInterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25InDIsdnRemIsdnInterfaceId.setDescription("The value of this object identifies one and only one ISDN remote system. This ISDN remote system must exist in fclIsdnRemotePeerTable. There may be several ISDN remote system for only one X25 in ISDN D channel logical port (these ISDN systems can be on different equipments). The possible values are : '0..249'. If it is unused, the value of this parameter is '255'.")
fclX25InDIsdnRemStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 21, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25InDIsdnRemStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25InDIsdnRemStatus.setDescription("The value of this object indicates the state of the entry of this table. The default value is 'valid'. It must be set to 'invalid' to delete the entry.")
fclX25InDIsdnRemConnectionType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 21, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("subscriber", 1), ("publicNetwork", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25InDIsdnRemConnectionType.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25InDIsdnRemConnectionType.setDescription("The value of this object indicates which is the system connected by the backup mechanism to this X25 in ISDN-D logical port. The possible values are : subscriber : this X25 ISDN-D logical port logical port is facing to a X25 subscriber, fclX25InDIsdnRemSubscriberNumber is used, fclX25InDIsdnRemPdnLinkAddress is not used, publicNetwork : this logical port is facing to a X25 Public Data Network, fclX25InDIsdnRemSubscriberNumber is not used, fclX25InDIsdnRemPdnLinkAddress is used. The default value is 'subscriber'.")
fclX25InDIsdnRemSubscriberNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 21, 4, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25InDIsdnRemSubscriberNumber.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25InDIsdnRemSubscriberNumber.setDescription("The value of this object is the SB number added to the DNICZO of the equipment to make the calling address in a call sent from this X25 in ISDN-D logical port by the backup mechanism (if fclX25InDIsdnRemConnectionType is set to 'subscriber'). The value must contain 2 digits (digits 0..9). The default value is 'FF'.")
fclX25InDIsdnRemPdnLinkAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 21, 4, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25InDIsdnRemPdnLinkAddress.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25InDIsdnRemPdnLinkAddress.setDescription("The value of this object is the X121 address of the equipment on the connected network (if fclX25InDIsdnRemConnectionType is set to 'publicNetwork'). The value may contain up to 15 digits (digits 0..9). The value must be completed with 'F' digits for a total of 16 digits. The equipment configurator does not need final completion. The default value is 'FF FF FF FF FF FF FF FF' meaning 'empty value' (blank value on the equipment configurator).")
fclX25InDIsdnRemX25AccConfigId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 21, 4, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25InDIsdnRemX25AccConfigId.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25InDIsdnRemX25AccConfigId.setDescription("The value of this object identifies the X25 access configuration used by this X25 in ISDN-D logical port. backup link. This X25 access configuration must be present in fclX25ConfigAccessTable. The possible values are : '0..199. If it is unused, the value of this parameter is '255'.")
fclX25InDIsdnRemPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 21, 4, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25InDIsdnRemPriority.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25InDIsdnRemPriority.setDescription("The value of this object indicates, when there is several ISDN remote system for only one X25 in ISDN D channel logical port, in which order the equipment will try to call these several ISDN remote system to establish an ISDN B Channel. When a try to one ISDN remote system fails the equipment continues, in the increasing order of this parameter, with the following in the list until the end of the list. The possible values are : '0..15'. The default value is '0' (meaning 'first of the list').")
fclX25InDIsdnRemCallRetryCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 21, 4, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25InDIsdnRemCallRetryCount.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25InDIsdnRemCallRetryCount.setDescription("The value of this object indicates how many times the equipment will try to call this particular ISDN remote system to establish an ISDN B Channel. The possible values are : '1..15'. The default value is '1'.")
fclX25InBIsdn = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 22))
fclX25InBIsdnTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 22, 1), )
if mibBuilder.loadTexts: fclX25InBIsdnTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25InBIsdnTable.setDescription('This table defines the general parameters of X25 SLP (Single Link Protocol) in ISDN B channel logical ports.')
fclX25InBIsdnEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 22, 1, 1), ).setIndexNames((0, "PCE-MIB", "fclX25InBLogPortId"))
if mibBuilder.loadTexts: fclX25InBIsdnEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25InBIsdnEntry.setDescription('An entry of fclX25InBIsdnTable.')
fclX25InBLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 22, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclX25InBLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25InBLogPortId.setDescription("The value of this object identifies one and only one X25 in ISDN B Channel logical port. The possible values are : '0..131'. If it is unused, the value of this parameter is '255'. The default value is '255'.")
fclX25InBIsdnInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 22, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25InBIsdnInterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25InBIsdnInterfaceId.setDescription("The value of this object identifies the ISDN Basic Rate Interface used by this X25 in ISDN-B logical port. The possible values are : '0..35'. If it is unused, the value of this parameter is '255'. The default value is '255'.")
fclX25InBRemotePeerTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 22, 2), )
if mibBuilder.loadTexts: fclX25InBRemotePeerTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25InBRemotePeerTable.setDescription('This table defines the ISDN remote systems which may be connected to the equipment using an X25 in ISDN B channel logical ports .')
fclX25InBRemotePeerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 22, 2, 1), ).setIndexNames((0, "PCE-MIB", "fclX25InBRemX121Addr"), (0, "PCE-MIB", "fclX25InBRemPeerId"))
if mibBuilder.loadTexts: fclX25InBRemotePeerEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25InBRemotePeerEntry.setDescription('An entry of fclX25InBRemotePeerTable.')
fclX25InBRemX121Addr = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 22, 2, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclX25InBRemX121Addr.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25InBRemX121Addr.setDescription("The value of this object is the X121 address of one or several ISDN remote systems. The value may contain up to 15 digits (digits 0..9, A,B,D). The digits 'A', 'B', 'D' (respectively characters ':', '*', '?' on the equipment configurator) have special meanings : 'A' is a separator used to defines which digits of this X121 address are added to the value of fcfIsdnRemIsdnNumber corresponding to fclX25InBRemPeerId to make the complete ISDN address. When used there must be exactly two separators to mark the beginning and the end of the digits selection. 'B' matches any address. When used it must be the only digit specified (with final completion as explained below). 'D' matches any single digit. The value must be completed with 'F' digits for a total of 16 digits. The equipment configurator does not need final completion. The default value is 'FF FF FF FF FF FF FF FF' meaning 'empty value' (blank value on the equipment configurator).")
fclX25InBRemPeerId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 22, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 999))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclX25InBRemPeerId.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25InBRemPeerId.setDescription("The value of this object identifies one and only one ISDN remote system. This ISDN remote system must exist in fclIsdnRemotePeerTable. There may be several ISDN remote system for only one X121 address. The possible values are : '0..249' in releases before 4.2, '0..999' after. If it is unused, the value of this parameter is '255' or '65535'.")
fclX25InBRemStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 22, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25InBRemStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25InBRemStatus.setDescription("The value of this object indicates the state of the entry of this table. The default value is 'valid'. It must be set to 'invalid' to delete the entry.")
fclX25InBRemConnectionType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 22, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("subscriber", 1), ("publicNetwork", 2), ("interNode", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25InBRemConnectionType.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25InBRemConnectionType.setDescription("The value of this object indicates which is the ISDN remote system connected to one of the X25 in ISDN-B logical port. The possible values are : subscriber : this X25 ISDN-B logical port logical port is facing to a X25 subscriber, fclX25InBRemSubscriberNumber is used, fclX25InBRemPdnLinkAddress is not used, publicNetwork : this logical port is facing to a X25 Public Data Network, fclX25InBRemSubscriberNumber is not used, fclX25InBRemPdnLinkAddress is used. interNode : this logical port is used as inter-node ling (i.e. inside an X25 network), fclX25InBRemSubscriberNumber is not used, fclX25InBRemPdnLinkAddress is not used. The default value is 'subscriber'.")
fclX25InBRemSubscriberNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 22, 2, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25InBRemSubscriberNumber.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25InBRemSubscriberNumber.setDescription("The value of this object is the SB number added to the DNICZO of the equipment to make the calling address in a call sent to this ISDN remote system (if fclX25InBRemConnectionType is set to 'subscriber'). The value must contain 2 digits (digits 0..9). The default value is 'FF'.")
fclX25InBRemPdnLinkAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 22, 2, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25InBRemPdnLinkAddress.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25InBRemPdnLinkAddress.setDescription("The value of this object is the X121 address of the equipment on the connected network (if fclX25InBRemConnectionType is set to 'publicNetwork'). The value may contain up to 15 digits (digits 0..9). The value must be completed with 'F' digits for a total of 16 digits. The equipment configurator does not need final completion. The default value is 'FF FF FF FF FF FF FF FF' meaning 'empty value' (blank value on the equipment configurator).")
fclX25InBRemX25ConfigId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 22, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25InBRemX25ConfigId.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25InBRemX25ConfigId.setDescription("The value of this object identifies the X25 configuration used to establish the X25 VC towards the ISDN remote system. This X25 configuration must be present in fclX25ConfigAccessTable (case X25 access configuration if fclX25InBRemConnectionType is set to 'subscriber' or 'publicNetwork') or in fclX25ConfigInterNodeTable (case X25 inter-node configuration if fclX25InBRemConnectionType is set to 'interNode'). The possible values are : '0..199'. If it is unused, the value of this parameter is '255'.")
fclX25InBRemPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 22, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25InBRemPriority.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25InBRemPriority.setDescription("The value of this object indicates, when there is several ISDN remote system for only one X121 address, in which order the equipment will try to call these several ISDN remote system to establish an ISDN B Channel. When a try to one ISDN remote system fails the equipment continues, in the increasing order of this parameter, with the following in the list until the end of the list. The possible values are : '0..15'. The default value is '0' (meaning 'first of the list').")
fclX25InBRemCallRetryCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 22, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25InBRemCallRetryCount.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25InBRemCallRetryCount.setDescription("The value of this object indicates how many times the equipment will try to call this particular ISDN remote system to establish an ISDN B Channel. The possible values are : '1..15'. The default value is '1'.")
fclX25InBRemLinkCheckPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 22, 2, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(200, 50800))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25InBRemLinkCheckPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25InBRemLinkCheckPeriod.setDescription("The value of this object is the scanning time (in milliseconds) to detect the B-Channel state. The authorized values are '2000..50800' by steps of 200 msec. The default value is '200'.")
fclX25InBRemCheckPeriodCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 22, 2, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 250))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25InBRemCheckPeriodCount.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25InBRemCheckPeriodCount.setDescription("The value of this object is the number of periods of 'fclX25InBRemLinkCheckPeriod' milliseconds before declaring the state of the B-Channel. The authorized values are '1..250'. The default value is '3'.")
fclX25InPstn = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 23))
fclX25InPstnTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 23, 1), )
if mibBuilder.loadTexts: fclX25InPstnTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25InPstnTable.setDescription('This table defines the general parameters of X25 SLP (Single Link Protocol) in PSTN (Public Switched Telephone Network) link inter-node logical ports.')
fclX25InPstnEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 23, 1, 1), ).setIndexNames((0, "PCE-MIB", "fclX25PstnLogPortId"))
if mibBuilder.loadTexts: fclX25InPstnEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25InPstnEntry.setDescription('An entry of fclX25InPstnTable.')
fclX25PstnLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 23, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclX25PstnLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25PstnLogPortId.setDescription("The value of this object identifies one and only one X25 in PSTN link logical port. The possible values are : '0..131'. If it is unused, the value of this parameter is '255'. The default value is '255'.")
fclX25PstnInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 23, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25PstnInterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25PstnInterfaceId.setDescription("The value of this object identifies the line interface used by this X25 in PSTN logical port. The possible values are : '0..35'. If it is unused, the value of this parameter is '255'. The default value is '255'.")
fclX25PstnX25InterNodeConfigId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 23, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25PstnX25InterNodeConfigId.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25PstnX25InterNodeConfigId.setDescription("The value of this object identifies the X25 inter-node configuration used to establish the X25 VC towards the PSTN remote system. This X25 inter-node configuration must be present in fclX25ConfigInterNodeTable. The possible values are : '0..199'. If it is unused, the value of this parameter is '255'. The default value is '255'.")
fclX25PstnRemotePeerTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 23, 2), )
if mibBuilder.loadTexts: fclX25PstnRemotePeerTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25PstnRemotePeerTable.setDescription('This table defines the PSTN remote systems which may be called by the equipment using a X25 in PSTN link logical ports .')
fclX25PstnRemotePeerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 23, 2, 1), ).setIndexNames((0, "PCE-MIB", "fclX25PstnRemX121Addr"))
if mibBuilder.loadTexts: fclX25PstnRemotePeerEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25PstnRemotePeerEntry.setDescription('An entry of fclX25PstnRemotePeerTable.')
fclX25PstnRemX121Addr = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 23, 2, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclX25PstnRemX121Addr.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25PstnRemX121Addr.setDescription("The value of this object is the X121 address of one PSTN remote system. The value may contain up to 15 digits (digits 0..9, B, D). The digits 'B', 'D' (respectively characters '*', '?' on the equipment configurator) have special meanings : 'B' matches any address. When used it must be the only digit specified (with final completion as explained below). 'D' matches any single digit. The value must be completed with 'F' digits for a total of 16 digits. The equipment configurator does not need final completion. The default value is 'FF FF FF FF FF FF FF FF' meaning 'empty value' (blank value on the equipment configurator).")
fclX25PstnRemStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 23, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25PstnRemStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25PstnRemStatus.setDescription("The value of this object indicates the state of the entry of this table. The default value is 'valid'. It must be set to 'invalid' to delete the entry.")
fclX25PstnRemPstnNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 23, 2, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(14, 14)).setFixedLength(14)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25PstnRemPstnNumber.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25PstnRemPstnNumber.setDescription("The value of this object is the PSTN address of this PSTN remote system. The value may contain up to 28 digits (digits 0..E). The digits 'A', 'B', 'C', 'D', 'E' (respectively characters 'W', ',', 'P', 'T', '!' on the equipment configurator) have special meanings : 'A' means 'attente de tonalite', 'B' means 'pause of 2 seconds', 'C' means 'numerotation decimale', 'D' means 'numerotation multifrequence', 'E' means 'raccrocher 0.5 second'. The value must be completed with 'F' digits for a total of 28 digits. The equipment configurator does not need final completion. The default value is 'FF FF FF FF FF FF FF FF' meaning 'empty value' (blank value on the equipment configurator).")
fclX25SlpInterNode = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 24))
fclX25SlpInterNodeTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 24, 1), )
if mibBuilder.loadTexts: fclX25SlpInterNodeTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25SlpInterNodeTable.setDescription('This table defines the general parameters of X25 SLP (Single Link Protocol) inter-node logical ports.')
fclX25SlpInterNodeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 24, 1, 1), ).setIndexNames((0, "PCE-MIB", "fclX25SlpLogPortId"))
if mibBuilder.loadTexts: fclX25SlpInterNodeEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25SlpInterNodeEntry.setDescription('An entry of fclX25SlpInterNodeTable.')
fclX25SlpLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 24, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclX25SlpLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25SlpLogPortId.setDescription("The value of this object identifies one and only one X25 SLP (Single Link Protocol) inter-node logical port. The possible values are : '0..131'. If it is unused, the value of this parameter is '255'. The default value is '255'.")
fclX25SlpInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 24, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25SlpInterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25SlpInterfaceId.setDescription("The value of this object identifies the line interface used by this X25 inter-node logical port. The possible values are : '0..35'. If it is unused, the value of this parameter is '255'. The default value is '255'.")
fclX25SlpIsdnBackupEnabling = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 24, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 7))).clone(namedValues=NamedValues(("off", 1), ("onWhileActivity", 2), ("onWhileLpDown", 3), ("onWhileExcessTraffic", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25SlpIsdnBackupEnabling.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25SlpIsdnBackupEnabling.setDescription("The value of this object defines how this X25 inter-node logical port may be backuped by an ISDN-B channel. The possible values are : off : backup is never enabled, onWhileActivity : when the logical port is DOWN, backup is enabled on reception of a new call and remains active while at least one X25 VC is using this way. When no VC is active, the backup is disabled and the next VC will be established on the logical port (if it is UP obviously). onWhileLpDown : when the logical port is DOWN, backup is enabled on reception of a new call and remains active while the logical port is DOWN. The backup is disabled (meaning clearing of all VCs using this way) when the logical port comes back UP and the next VC will be established on the logical port. onWhileExcessTraffic : when the traffic overtakes the fclX25SlpSwSwitchThreshold value the logical port state is marked DOWN (meaning clearing of all VCs), backup is enabled on reception of a new call and remains active while the traffic is overtaking the fclX25SlpSwSwitchBackThreshold value. When the traffic does not overtake any more the fclX25SlpSwSwitchBackThreshold value, the logical port is marked UP and the backup is disabled (meaning clearing of all VCs using this way) so the next VC will be established on the logical port. This Switch Over mechanism permits to transmit temporay excess traffic which could not be transmitted on the logical port because of an insufficient bandwith on a line interface with a speed (fcfLineSpeed) inferior to 64 kbit/s. The default value is 'off'.")
fclX25SlpPstnBackupEnabling = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 24, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 7))).clone(namedValues=NamedValues(("off", 1), ("onWhileActivity", 2), ("onWhileLpDown", 3), ("onWhileExcessTraffic", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25SlpPstnBackupEnabling.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25SlpPstnBackupEnabling.setDescription("The value of this object defines how this X25 inter-node logical port may be backuped by a PSTN (Public Switched Telephone Network) link. The possible values are : off : backup is never enabled, onWhileActivity : when the logical port is DOWN, backup is enabled on reception of a new call and remains active while at least one X25 VC is using this way. When no VC is active, the backup is disabled and the next VC will be established on the logical port (if it is UP obviously). onWhileLpDown : when the logical port is DOWN, backup is enabled on reception of a new call and remains active while the logical port is DOWN. The backup is disabled (meaning clearing of all VCs using this way) when the logical port comes back UP and the next VC will be established on the logical port. onWhileExcessTraffic : when the traffic overtakes the fclX25SlpSwSwitchThreshold value the logical port state is marked DOWN (meaning clearing of all VCs), backup is enabled on reception of a new call and remains active while the traffic is overtaking the fclX25SlpSwSwitchBackThreshold value. When the traffic does not overtake any more the fclX25SlpSwSwitchBackThreshold value, the logical port is marked UP and the backup is disabled (meaning clearing of all VCs using this way) so the next VC will be established on the logical port. This Switch Over mechanism permits to transmit temporay excess traffic which could not be transmitted on the logical port because of an insufficient bandwith on a line interface with a speed (fcfLineSpeed) inferior to the speed of a PSTN link (depending on modem capability). The default value is 'off'.")
fclX25SlpX25InterNodeConfigId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 24, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25SlpX25InterNodeConfigId.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25SlpX25InterNodeConfigId.setDescription("The value of this object identifies the X25 inter-node configuration used by this X25 inter-node logical port. This X25 inter-node configuration must be present in fclX25ConfigInterNodeTable. The possible values are : '0..199. If it is unused, the value of this parameter is '255'.")
fclX25SlpDARApplicable = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 24, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25SlpDARApplicable.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25SlpDARApplicable.setDescription('Ligne utilisable par le RAD')
fclX25SlpBackupTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 24, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2540))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25SlpBackupTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25SlpBackupTimer.setDescription('Tempo de retour sur LS')
fclX25SlpSwitchOverTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 24, 2), )
if mibBuilder.loadTexts: fclX25SlpSwitchOverTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25SlpSwitchOverTable.setDescription('This table defines the switch over parameters of X25 inter-node logical ports using the switch over mechanism.')
fclX25SlpSwitchOverEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 24, 2, 1), ).setIndexNames((0, "PCE-MIB", "fclX25SlpSwLogPortId"))
if mibBuilder.loadTexts: fclX25SlpSwitchOverEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25SlpSwitchOverEntry.setDescription('An entry of fclX25SlpSwitchOverTable.')
fclX25SlpSwLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 24, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclX25SlpSwLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25SlpSwLogPortId.setDescription("The value of this object identifies one and only one X25 inter-node logical port using the switch over mechanism (fclX25SlpIsdnBackupEnabling or fclX25SlpPstnBackupEnabling set to 'onWhileExcessTraffic'). The possible values are : '0..131'. If it is unused, the value of this parameter is '255'. The default value is '255'.")
fclX25SlpSwMeasureCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 24, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 249))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25SlpSwMeasureCount.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25SlpSwMeasureCount.setDescription("The value of this object is the number of traffic measures before switching. The measure duration is defined by fcwLoadAndTrafficSummingPeriod. The authorized values are '0..249'. The default value is '2'.")
fclX25SlpSwSwitchThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 24, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25SlpSwSwitchThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25SlpSwSwitchThreshold.setDescription("The value of this object indicates the traffic threshold (in percents of bandwith of the main link of logical port) over which the switch over mechanism is enabled. The authorized values are '0..100'. The default value is '80'.")
fclX25SlpSwSwitchBackThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 24, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25SlpSwSwitchBackThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25SlpSwSwitchBackThreshold.setDescription("The value of this object indicates the traffic threshold (in percents of bandwith of the main link of logical port) under which the switch over mechanism is disabled. The authorized values are '0..100'. The default value is '60'.")
fclX25SlpIsdnBackupTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 24, 3), )
if mibBuilder.loadTexts: fclX25SlpIsdnBackupTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25SlpIsdnBackupTable.setDescription('This table defines which ISDN Basic Rate Interface may be used by each X25 inter-node logical port when enabling backup on ISDN B-Channels.')
fclX25SlpIsdnBackupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 24, 3, 1), ).setIndexNames((0, "PCE-MIB", "fclX25SlpIsdnBackLogPortId"), (0, "PCE-MIB", "fclX25SlpIsdnBackIsdnInterfaceId"))
if mibBuilder.loadTexts: fclX25SlpIsdnBackupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25SlpIsdnBackupEntry.setDescription('An entry of fclX25SlpIsdnBackupTable.')
fclX25SlpIsdnBackLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 24, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclX25SlpIsdnBackLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25SlpIsdnBackLogPortId.setDescription("The value of this object identifies one and only one X25 SLP (Single Link Protocol) inter-node logical port. One X25 inter-node logical port may use backup with one or several ISDN Basic Rate Interfaces. The possible values are : '0..131'. If it is unused, the value of this parameter is '255'. The default value is '255'.")
fclX25SlpIsdnBackIsdnInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 24, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclX25SlpIsdnBackIsdnInterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25SlpIsdnBackIsdnInterfaceId.setDescription("The value of this object identifies one ISDN Basic Rate Interface used by the X25 inter-node logical port defined by fclX25SlpIsdnBackLogPortId. The possible values are : '0..35'. If it is unused, the value of this parameter is '255'. The default value is '255'.")
fclX25SlpIsdnBackStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 24, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25SlpIsdnBackStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25SlpIsdnBackStatus.setDescription("The value of this object indicates the state of the entry of this table. The default value is 'valid'. It must be set to 'invalid' to delete the entry.")
fclX25SlpIsdnRemotePeerTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 24, 4), )
if mibBuilder.loadTexts: fclX25SlpIsdnRemotePeerTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25SlpIsdnRemotePeerTable.setDescription('This table defines the ISDN remote systems which may be connected to the equipment using the backup mechanism of X25 inter-node logical ports.')
fclX25SlpIsdnRemotePeerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 24, 4, 1), ).setIndexNames((0, "PCE-MIB", "fclX25SlpIsdnRemLogPortId"), (0, "PCE-MIB", "fclX25SlpIsdnRemIsdnInterfaceId"))
if mibBuilder.loadTexts: fclX25SlpIsdnRemotePeerEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25SlpIsdnRemotePeerEntry.setDescription('An entry of fclX25SlpIsdnRemotePeerTable.')
fclX25SlpIsdnRemLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 24, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclX25SlpIsdnRemLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25SlpIsdnRemLogPortId.setDescription("The value of this object identifies one and only one X25 SLP (Single Link Protocol) inter-node logical port. One X25 inter-node logical port may use backup mechanism with one or several ISDN remote systems (these ISDN systems can be on different equipments). The possible values are : '0..131'. If it is unused, the value of this parameter is '255'. The default value is '255'.")
fclX25SlpIsdnRemIsdnInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 24, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclX25SlpIsdnRemIsdnInterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25SlpIsdnRemIsdnInterfaceId.setDescription("The value of this object identifies one and only one ISDN remote system. This ISDN remote system must exist in fclIsdnRemotePeerTable. There may be several ISDN remote system for only one X25 inter-node logical port (these ISDN systems can be on different equipments). The possible values are : '0..249'. If it is unused, the value of this parameter is '255'.")
fclX25SlpIsdnRemStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 24, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25SlpIsdnRemStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25SlpIsdnRemStatus.setDescription("The value of this object indicates the state of the entry of this table. The default value is 'valid'. It must be set to 'invalid' to delete the entry.")
fclX25SlpIsdnRemX25InterNodeConfigId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 24, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25SlpIsdnRemX25InterNodeConfigId.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25SlpIsdnRemX25InterNodeConfigId.setDescription("The value of this object identifies the X25 inter-node configuration used by this X25 inter-node logical port backup link. This X25 inter-node configuration must be present in fclX25ConfigInterNodeTable. The possible values are : '0..199. If it is unused, the value of this parameter is '255'.")
fclX25SlpIsdnRemPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 24, 4, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25SlpIsdnRemPriority.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25SlpIsdnRemPriority.setDescription("The value of this object indicates, when there is several ISDN remote system for only one X25 inter-node logical port, in which order the equipment will try to call these several ISDN remote system to establish an ISDN B Channel. When a try to one ISDN remote system fails the equipment continues, in the increasing order of this parameter, with the following in the list until the end of the list. The possible values are : '0..15'. The default value is '0' (meaning 'first of the list').")
fclX25SlpIsdnRemCallRetryCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 24, 4, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25SlpIsdnRemCallRetryCount.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25SlpIsdnRemCallRetryCount.setDescription("The value of this object indicates how many times the equipment will try to call this particular ISDN remote system to establish an ISDN B Channel. The possible values are : '1..15'. The default value is '1'.")
fclX25SlpPstnBackupTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 24, 5), )
if mibBuilder.loadTexts: fclX25SlpPstnBackupTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25SlpPstnBackupTable.setDescription('This table defines which line interface may be used by each X25 inter-node logical ports when enabling backup mechanism on PSTN links.')
fclX25SlpPstnBackupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 24, 5, 1), ).setIndexNames((0, "PCE-MIB", "fclX25SlpPstnBackLogPortId"))
if mibBuilder.loadTexts: fclX25SlpPstnBackupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25SlpPstnBackupEntry.setDescription('An entry of fclX25SlpPstnBackupTable.')
fclX25SlpPstnBackLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 24, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclX25SlpPstnBackLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25SlpPstnBackLogPortId.setDescription("The value of this object identifies one and only one X25 SLP (Single Link Protocol) inter-node logical port. The possible values are : '0..131'. If it is unused, the value of this parameter is '255'. The default value is '255'.")
fclX25SlpPstnBackStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 24, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25SlpPstnBackStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25SlpPstnBackStatus.setDescription("The value of this object indicates the state of the entry of this table. The default value is 'valid'. It must be set to 'invalid' to delete the entry.")
fclX25SlpPstnBackInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 24, 5, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25SlpPstnBackInterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25SlpPstnBackInterfaceId.setDescription("The value of this object identifies the line interface used by the X25 inter-node logical port defined by fclX25SlpPstnBackLogPortId. The possible values are : '0..35'. If it is unused, the value of this parameter is '255'. The default value is '255'.")
fclX25SlpPstnBackPstnNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 24, 5, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(14, 14)).setFixedLength(14)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25SlpPstnBackPstnNumber.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25SlpPstnBackPstnNumber.setDescription("The value of this object is the PSTN address of this PSTN remote system. The value may contain up to 28 digits (digits 0..E). The digits 'A', 'B', 'C', 'D', 'E' (respectively characters 'W', ',', 'P', 'T', '!' on the equipment configurator) have special meanings : 'A' means 'attente de tonalite', 'B' means 'pause of 2 seconds', 'C' means 'numerotation decimale', 'D' means 'numerotation multifrequence', 'E' means 'raccrocher 0.5 second'. The value must be completed with 'F' digits for a total of 28 digits. The equipment configurator does not need final completion. The default value is 'FF FF FF FF FF FF FF FF' meaning 'empty value' (blank value on the equipment configurator).")
fclX25SlpPstnBackX25InterNodeConfigId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 24, 5, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25SlpPstnBackX25InterNodeConfigId.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25SlpPstnBackX25InterNodeConfigId.setDescription("The value of this object identifies the X25 inter-node configuration used by this X25 inter-node logical port backup link. This X25 inter-node configuration must be present in fclX25ConfigInterNodeTable. The possible values are : '0..199. If it is unused, the value of this parameter is '255'.")
fclX25Mlp = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 25))
fclX25MlpTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 25, 1), )
if mibBuilder.loadTexts: fclX25MlpTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25MlpTable.setDescription('This table defines the general parameters of X25 MLP (Multi-Link Protocol) inter-node logical ports.')
fclX25MlpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 25, 1, 1), ).setIndexNames((0, "PCE-MIB", "fclX25MlpLogPortId"))
if mibBuilder.loadTexts: fclX25MlpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25MlpEntry.setDescription('An entry of fclX25MlpTable.')
fclX25MlpLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 25, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclX25MlpLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25MlpLogPortId.setDescription("The value of this object identifies one and only one X25 MLP (Multi-Link Protocol) inter-node logical port. The possible values are : '0..131'. If it is unused, the value of this parameter is '255'. The default value is '255'.")
fclX25MlpLink1InterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 25, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25MlpLink1InterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25MlpLink1InterfaceId.setDescription("The value of this object identifies the first line interface used by this X25 MLP logical port. This line interface is mandatory. The possible values are : '0..35'. If it is unused, the value of this parameter is '255'. The default value is '255'.")
fclX25MlpLink2InterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 25, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25MlpLink2InterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25MlpLink2InterfaceId.setDescription("The value of this object identifies the second line interface used by this X25 MLP logical port. This line interface is optional. The possible values are : '0..35'. If it is unused, the value of this parameter is '255'. The default value is '255'.")
fclX25MlpLink3InterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 25, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25MlpLink3InterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25MlpLink3InterfaceId.setDescription("The value of this object identifies the third line interface used by this X25 MLP logical port. This line interface is optional. The possible values are : '0..35'. If it is unused, the value of this parameter is '255'. The default value is '255'.")
fclX25MlpLink4InterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 25, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25MlpLink4InterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25MlpLink4InterfaceId.setDescription("The value of this object identifies the fourth line interface used by this X25 MLP logical port. This line interface is optional. The possible values are : '0..35'. If it is unused, the value of this parameter is '255'. The default value is '255'.")
fclX25MlpIsdnOverflow = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 25, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 10, 11))).clone(namedValues=NamedValues(("off", 1), ("onSlave", 2), ("onMasterWhileActivity", 10), ("onMasterWhileExcessTraffic", 11)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25MlpIsdnOverflow.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25MlpIsdnOverflow.setDescription("The value of this object defines how this X25 MLP logical port may use additional ISDN-B channel to transmit temporary excess traffic (overflow mechanism). When opening or closing additional B-Channels the existing VCs are not cleared, so this overflow mechanism does not alter the communication between the two extremities. The possible values are : off : overflow is never enabled, onSlave : overflow is enabled by the connected equipment, onMasterWhileActivity : when the traffic overtakes the fclX25MlpOvOverflowThreshold value for all the links in use (line interfaces and eventual ISDN B-Channels), a new ISDN B-Channel is open by the equipment and remains active while at least one X25 VC is using this way. When no VC is active, this ISDN B-Channel is closed. onMasterWhileExcessTraffic : when the traffic overtakes the fclX25MlpOvOverflowThreshold value for all the links in use (line interfaces and eventual ISDN B-Channels), a new ISDN B-Channel is open by the equipment and remains active while the traffic is overtaking the fclX25SlpOvOverflowBackThreshold value. When the traffic does not overtake any more the fclX25SlpOvOverflowBackThreshold value, this ISDN B-Channel is closed. When one line interface is DOWN its bandwith is considered as being 0. So the overflow mechanism may be used as a backup mechanism which permits to not clear existing VCs. The default value is 'off'.")
fclX25MlpPstnOverflow = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 25, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 10, 11))).clone(namedValues=NamedValues(("off", 1), ("onSlave", 2), ("onMasterWhileActivity", 10), ("onMasterWhileExcessTraffic", 11)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25MlpPstnOverflow.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25MlpPstnOverflow.setDescription("The value of this object defines how this X25 MLP logical port may use additional PSTN links to transmit temporary excess traffic (overflow mechanism). When opening or closing additional PSTN links the existing VCs are not cleared, so this overflow mechanism does not alter the communication between the two extremities. The possible values are : off : overflow is never enabled, onSlave : overflow is enabled by the connected equipment, onMasterWhileActivity : when the traffic overtakes the fclX25MlpOvOverflowThreshold value for all the links in use (line interfaces and eventual PSTN links), a new PSTN link is open by the equipment and remains active while at least one X25 VC is using this way. When no VC is active, this PSTN link is closed. onMasterWhileExcessTraffic : when the traffic overtakes the fclX25MlpOvOverflowThreshold value for all the links in use (line interfaces and eventual PSTN links), a new PSTN link is open by the equipment and remains active while the traffic is overtaking the fclX25SlpOvOverflowBackThreshold value. When the traffic does not overtake any more the fclX25SlpOvOverflowBackThreshold value, this PSTN link is closed. When one line interface is DOWN its bandwith is considered as being 0. So the overflow mechanism may be used as a backup mechanism which permits to not clear existing VCs. The default value is 'off'.")
fclX25MlpX25InterNodeConfigId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 25, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25MlpX25InterNodeConfigId.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25MlpX25InterNodeConfigId.setDescription("The value of this object identifies the X25 inter-node configuration used by this X25 MLP logical port. This X25 inter-node configuration must be present in fclX25ConfigInterNodeTable. The possible values are : '0..199. If it is unused, the value of this parameter is '255'.")
fclX25MlpDARApplicable = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 25, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25MlpDARApplicable.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25MlpDARApplicable.setDescription('Ligne utilisable par le RAD')
fclX25MlpParameterTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 25, 2), )
if mibBuilder.loadTexts: fclX25MlpParameterTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25MlpParameterTable.setDescription('This table defines the MLP parameters of X25 MLP (Multi-Link Protocol) inter-node logical ports.')
fclX25MlpParameterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 25, 2, 1), ).setIndexNames((0, "PCE-MIB", "fclX25MlpParamLogPortId"))
if mibBuilder.loadTexts: fclX25MlpParameterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25MlpParameterEntry.setDescription('An entry of fclX25MlpParameterTable.')
fclX25MlpParamLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 25, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclX25MlpParamLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25MlpParamLogPortId.setDescription("The value of this object identifies one and only one X25 MLP (Multi-Link Protocol) inter-node logical port. The possible values are : '0..131'. If it is unused, the value of this parameter is '255'. The default value is '255'.")
fclX25MlpMwMultilinkWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 25, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25MlpMwMultilinkWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25MlpMwMultilinkWindowSize.setDescription("The value of this object is the maximum number (MW) of sequentially numbered multilink frames that the DCE or DTE may transfer which the lowest numbered multilink frame which has not yet been acknowledged beyond. This parameter shall have the same value for both switching points. The authorized values are '1..32'. The default value is '32'.")
fclX25MlpRxMlpMxWinGuardRegion = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 25, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25MlpRxMlpMxWinGuardRegion.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25MlpRxMlpMxWinGuardRegion.setDescription("The value of this object defines a guard region (MX) of multilink sequence numbers of fixed size. The range of MX shall be large enough for that the receiving MLP recognizes the highest numbered frame that it may receive after the multilink frame loss. The window MX must be smaller than or equal to the window MW. The authorized values are '1..32'. The default value is '32'.")
fclX25MlpMt1LostFrameTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 25, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25MlpMt1LostFrameTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25MlpMt1LostFrameTimer.setDescription("The value of this object defines the timer (MT1), in seconds, which a transmitted frames is declared lost beyond. The authorized values are '1..255'. The default value is '22'.")
fclX25MlpMt3ResetConfirmationTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 25, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25MlpMt3ResetConfirmationTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25MlpMt3ResetConfirmationTimer.setDescription("The value of this object defines the maximum time (MT3), in seconds, between a reset request and a reset confirmation, which the multilink resetting procedure restarts beyond. The authorized values are '1..255'. The default value is '10'.")
fclX25MlpMt4DownLinkDetectionTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 25, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25MlpMt4DownLinkDetectionTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25MlpMt4DownLinkDetectionTimer.setDescription("The value of this object defines the timer (MT4), in seconds, which the line is declared down beyond. The line is out if all the lines of the MLP group are down. The authorized values are '0..255'. The default value is '40'.")
fclX25MlpFramesMaxCountByLink = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 25, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25MlpFramesMaxCountByLink.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25MlpFramesMaxCountByLink.setDescription("The value of this object is the maximum number of transmitted frames on a line. The authorized values are '1..255'. The default value is '3'.")
fclX25MlpRestartTxAfterResetRx = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 25, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25MlpRestartTxAfterResetRx.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25MlpRestartTxAfterResetRx.setDescription("The value of this object indicates if there is recovery after MLP reset. The authorized values are 'off' or 'on'. The default value is 'on'.")
fclX25MlpTns3Level3CheckTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 25, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25MlpTns3Level3CheckTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25MlpTns3Level3CheckTimer.setDescription("The value of this object defines the timer, in seconds, between a sending of frames and the reception of its acknowledges, which the multilink resetting procedure restarts beyond. The authorized values are '0..255' by step of 10 seconds. The default value is '10'.")
fclX25MlpOverflowTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 25, 3), )
if mibBuilder.loadTexts: fclX25MlpOverflowTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25MlpOverflowTable.setDescription('This table defines the overflow parameters of X25 MLP logical ports enabling the overflow mechanism.')
fclX25MlpOverflowEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 25, 3, 1), ).setIndexNames((0, "PCE-MIB", "fclX25MlpOvLogPortId"))
if mibBuilder.loadTexts: fclX25MlpOverflowEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25MlpOverflowEntry.setDescription('An entry of fclX25MlpOverflowTable.')
fclX25MlpOvLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 25, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclX25MlpOvLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25MlpOvLogPortId.setDescription("The value of this object identifies one and only one X25 MLP logical port enabling the overflow mechanism (fclX25MlpIsdnOverflow or fclX25MlpPstnOverflow set to 'onMasterWhileActivity', 'onMasterWhileExcessTraffic'). The possible values are : '0..131'. If it is unused, the value of this parameter is '255'. The default value is '255'.")
fclX25MlpOvMeasureCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 25, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 249))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25MlpOvMeasureCount.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25MlpOvMeasureCount.setDescription("The value of this object is the number of traffic measures before opening an additional link. The measure duration is defined by fcwLoadAndTrafficSummingPeriod. The authorized values are '0..249'. The default value is '2'.")
fclX25MlpOvOverflowThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 25, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25MlpOvOverflowThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25MlpOvOverflowThreshold.setDescription("The value of this object indicates the traffic threshold (in percents of bandwith of alls the link in use by this logical port) over which a new link is open. The authorized values are '0..100'. The default value is '80'.")
fclX25MlpOvOverflowBackThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 25, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25MlpOvOverflowBackThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25MlpOvOverflowBackThreshold.setDescription("The value of this object indicates the traffic threshold (in percents of bandwith of alls the link in use by this logical port) under which the last open link is closed. The authorized values are '0..100'. The default value is '60'.")
fclX25MlpIsdnOverflowTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 25, 4), )
if mibBuilder.loadTexts: fclX25MlpIsdnOverflowTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25MlpIsdnOverflowTable.setDescription('This table defines which ISDN Basic Rate Interface may be used by each X25 MLP logical ports when enabling overflow mechanism on ISDN B-Channels.')
fclX25MlpIsdnOverflowEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 25, 4, 1), ).setIndexNames((0, "PCE-MIB", "fclX25MlpIsdnOverLogPortId"), (0, "PCE-MIB", "fclX25MlpIsdnOverIsdnInterfaceId"))
if mibBuilder.loadTexts: fclX25MlpIsdnOverflowEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25MlpIsdnOverflowEntry.setDescription('An entry of fclX25MlpIsdnOverflowTable.')
fclX25MlpIsdnOverLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 25, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclX25MlpIsdnOverLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25MlpIsdnOverLogPortId.setDescription("The value of this object identifies one and only one X25 MLP (Multi-Link Protocol) inter-node logical port. One X25 MLP logical port may use overflow mechanism with one or several ISDN Basic Rate Interfaces. The possible values are : '0..131'. If it is unused, the value of this parameter is '255'. The default value is '255'.")
fclX25MlpIsdnOverIsdnInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 25, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclX25MlpIsdnOverIsdnInterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25MlpIsdnOverIsdnInterfaceId.setDescription("The value of this object identifies one ISDN Basic Rate Interface used by the X25 MLP logical port defined by fclX25MlpIsdnOverLogPortId. The possible values are : '0..35'. If it is unused, the value of this parameter is '255'. The default value is '255'.")
fclX25MlpIsdnOverStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 25, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25MlpIsdnOverStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25MlpIsdnOverStatus.setDescription("The value of this object indicates the state of the entry of this table. The default value is 'valid'. It must be set to 'invalid' to delete the entry.")
fclX25MlpIsdnOverBChannelCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 25, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25MlpIsdnOverBChannelCount.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25MlpIsdnOverBChannelCount.setDescription("The value of this object is the number of B channels of this ISDN Basic Rate Interface that may be used. The authorized values are '1..30'. The default value is '2'.")
fclX25MlpIsdnRemotePeerTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 25, 5), )
if mibBuilder.loadTexts: fclX25MlpIsdnRemotePeerTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25MlpIsdnRemotePeerTable.setDescription('This table defines the ISDN remote systems which may be connected to the equipment using the overflow mechanism of X25 MLP logical ports.')
fclX25MlpIsdnRemotePeerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 25, 5, 1), ).setIndexNames((0, "PCE-MIB", "fclX25MlpIsdnRemLogPortId"), (0, "PCE-MIB", "fclX25MlpIsdnRemPeerId"))
if mibBuilder.loadTexts: fclX25MlpIsdnRemotePeerEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25MlpIsdnRemotePeerEntry.setDescription('An entry of fclX25MlpIsdnRemotePeerTable.')
fclX25MlpIsdnRemLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 25, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclX25MlpIsdnRemLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25MlpIsdnRemLogPortId.setDescription("The value of this object identifies one and only one X25 MLP (Multi-Link Protocol) inter-node logical port. One X25 MLP logical port may use overflow mechanism with one or several ISDN remote systems (but all these ISDN systems must be on the same equipment to make X25 MLP work correctly). The possible values are : '0..131'. If it is unused, the value of this parameter is '255'. The default value is '255'.")
fclX25MlpIsdnRemPeerId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 25, 5, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 249))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclX25MlpIsdnRemPeerId.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25MlpIsdnRemPeerId.setDescription("The value of this object identifies one and only one ISDN remote system. This ISDN remote system must exist in fclIsdnRemotePeerTable. There may be several ISDN remote system for only one X25 MLP logical port (but all these ISDN systems must be on the same equipment to make X25 MLP work correctly). The possible values are : '0..249'. If it is unused, the value of this parameter is '255'.")
fclX25MlpIsdnRemStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 25, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25MlpIsdnRemStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25MlpIsdnRemStatus.setDescription("The value of this object indicates the state of the entry of this table. The default value is 'valid'. It must be set to 'invalid' to delete the entry.")
fclX25MlpIsdnRemPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 25, 5, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25MlpIsdnRemPriority.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25MlpIsdnRemPriority.setDescription("The value of this object indicates, when there is several ISDN remote system for only one X25 MLP logical port, in which order the equipment will try to call these several ISDN remote system to establish an ISDN B Channel. When a try to one ISDN remote system fails the equipment continues, in the increasing order of this parameter, with the following in the list until the end of the list. The possible values are : '0..15'. The default value is '0' (meaning 'first of the list').")
fclX25MlpIsdnRemCallRetryCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 25, 5, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25MlpIsdnRemCallRetryCount.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25MlpIsdnRemCallRetryCount.setDescription("The value of this object indicates how many times the equipment will try to call this particular ISDN remote system to establish an ISDN B Channel. The possible values are : '1..15'. The default value is '1'.")
fclX25MlpPstnOverflowTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 25, 6), )
if mibBuilder.loadTexts: fclX25MlpPstnOverflowTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25MlpPstnOverflowTable.setDescription('This table defines which line interface may be used by each X25 MLP logical ports when enabling overflow mechanism on PSTN links.')
fclX25MlpPstnOverflowEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 25, 6, 1), ).setIndexNames((0, "PCE-MIB", "fclX25MlpPstnOvLogPortId"))
if mibBuilder.loadTexts: fclX25MlpPstnOverflowEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25MlpPstnOverflowEntry.setDescription('An entry of fclX25MlpPstnOverflowTable.')
fclX25MlpPstnOvLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 25, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclX25MlpPstnOvLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25MlpPstnOvLogPortId.setDescription("The value of this object identifies one and only one X25 MLP (Multi-Link Protocol) inter-node logical port. The possible values are : '0..131'. If it is unused, the value of this parameter is '255'. The default value is '255'.")
fclX25MlpPstnOvStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 25, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25MlpPstnOvStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25MlpPstnOvStatus.setDescription("The value of this object indicates the state of the entry of this table. The default value is 'valid'. It must be set to 'invalid' to delete the entry.")
fclX25MlpPstnOvInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 25, 6, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25MlpPstnOvInterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25MlpPstnOvInterfaceId.setDescription("The value of this object identifies the line interface used by the X25 MLP logical port defined by fclX25MlpPstnOverLogPortId. The possible values are : '0..35'. If it is unused, the value of this parameter is '255'. The default value is '255'.")
fclX25MlpPstnOvPstnNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 25, 6, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(14, 14)).setFixedLength(14)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25MlpPstnOvPstnNumber.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25MlpPstnOvPstnNumber.setDescription("The value of this object is the PSTN address of this PSTN remote system. The value may contain up to 28 digits (digits 0..E). The digits 'A', 'B', 'C', 'D', 'E' (respectively characters 'W', ',', 'P', 'T', '!' on the equipment configurator) have special meanings : 'A' means 'attente de tonalite', 'B' means 'pause of 2 seconds', 'C' means 'numerotation decimale', 'D' means 'numerotation multifrequence', 'E' means 'raccrocher 0.5 second'. The value must be completed with 'F' digits for a total of 28 digits. The equipment configurator does not need final completion. The default value is 'FF FF FF FF FF FF FF FF' meaning 'empty value' (blank value on the equipment configurator).")
fclPointToPointProtocol = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30))
fclPppSerialLinkAccess = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 1))
fclPppSerialLogPortTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 1, 1), )
if mibBuilder.loadTexts: fclPppSerialLogPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppSerialLogPortTable.setDescription('')
fclPppSerialLogPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 1, 1, 1), ).setIndexNames((0, "PCE-MIB", "fclPppSerLpLogPortId"))
if mibBuilder.loadTexts: fclPppSerialLogPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppSerialLogPortEntry.setDescription('An entry of fclPppSerialLogPortTable.')
fclPppSerLpLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclPppSerLpLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppSerLpLogPortId.setDescription('LP id')
fclPppSerLpInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclPppSerLpInterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppSerLpInterfaceId.setDescription('IF id (type ligne)')
fclPppSerLpLocalSubscriberNb = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 1, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclPppSerLpLocalSubscriberNb.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppSerLpLocalSubscriberNb.setDescription("Numero d'abonne")
fclPppSerLpConfigId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclPppSerLpConfigId.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppSerLpConfigId.setDescription('Config PPP id')
fclPppSerLpCos = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 1, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 1))).clone(namedValues=NamedValues(("ubr", 3), ("vbr", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclPppSerLpCos.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppSerLpCos.setDescription('COS')
fclPppSerLpCir = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 1, 1, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(600, 2048000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclPppSerLpCir.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppSerLpCir.setDescription('Entrant CIR')
fclPppSerLpMinCir = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 1, 1, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclPppSerLpMinCir.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppSerLpMinCir.setDescription('Entrant CIR mini')
fclPppSerLpBe = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 1, 1, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclPppSerLpBe.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppSerLpBe.setDescription('Entrant BE')
fclPppSerialAutoCallTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 1, 2), )
if mibBuilder.loadTexts: fclPppSerialAutoCallTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppSerialAutoCallTable.setDescription('')
fclPppSerialAutoCallEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 1, 2, 1), ).setIndexNames((0, "PCE-MIB", "fclPppSerAutoLogPortId"))
if mibBuilder.loadTexts: fclPppSerialAutoCallEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppSerialAutoCallEntry.setDescription('An entry of fclPppSerialAutoCallTable.')
fclPppSerAutoLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclPppSerAutoLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppSerAutoLogPortId.setDescription('LP id')
fclPppSerAutoStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclPppSerAutoStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppSerAutoStatus.setDescription('Status')
fclPppSerAutoRemoteAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 1, 2, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclPppSerAutoRemoteAddress.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppSerAutoRemoteAddress.setDescription('Adresse du point vise')
fclPppSerAutoMinimumRecallTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 1, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 990))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclPppSerAutoMinimumRecallTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppSerAutoMinimumRecallTimer.setDescription('Tempo de retransmission appel')
fclPppSerAutoInactivityTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 1, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2540))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclPppSerAutoInactivityTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppSerAutoInactivityTimer.setDescription('Duree de silence (Tb)')
fclPppSerAutoReliableVc = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 1, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 2))).clone(namedValues=NamedValues(("off", 3), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclPppSerAutoReliableVc.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppSerAutoReliableVc.setDescription('CV fiabilise')
fclPppSerAutoCompression = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 1, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("off", 1), ("networkToSubscriber", 2), ("subscriberToNetwork", 3), ("bothway", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclPppSerAutoCompression.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppSerAutoCompression.setDescription('Compression : abonnement et direction')
fclPppSerAutoCompressNegotiation = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 1, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("onOptionalCompression", 2), ("onMandatoryCompression", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclPppSerAutoCompressNegotiation.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppSerAutoCompressNegotiation.setDescription('Compression : negociation et caractere')
fclPppSerAutoCompressScrambling = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 1, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclPppSerAutoCompressScrambling.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppSerAutoCompressScrambling.setDescription('Compression : brouillage')
fclPppSerAutoCompressMultiPktTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 1, 2, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1500))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclPppSerAutoCompressMultiPktTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppSerAutoCompressMultiPktTimer.setDescription('Compression : tempo attente multi-paquet msec')
fclPppPstnAccess = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 2))
fclPppPstnLogPortTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 2, 1), )
if mibBuilder.loadTexts: fclPppPstnLogPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppPstnLogPortTable.setDescription('')
fclPppPstnLogPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 2, 1, 1), ).setIndexNames((0, "PCE-MIB", "fclPppPstnLpLogPortId"))
if mibBuilder.loadTexts: fclPppPstnLogPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppPstnLogPortEntry.setDescription('An entry of fclPppPstnLogPortTable.')
fclPppPstnLpLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclPppPstnLpLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppPstnLpLogPortId.setDescription('LP id')
fclPppPstnLpInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclPppPstnLpInterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppPstnLpInterfaceId.setDescription('IF id (de type ligne)')
fclPppPstnLpLocalSubscriberNb = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 2, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclPppPstnLpLocalSubscriberNb.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppPstnLpLocalSubscriberNb.setDescription("Numero d'abonne")
fclPppPstnLpConfigId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclPppPstnLpConfigId.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppPstnLpConfigId.setDescription('Config PPP id')
fclPppPstnRemotePeerTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 2, 2), )
if mibBuilder.loadTexts: fclPppPstnRemotePeerTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppPstnRemotePeerTable.setDescription('')
fclPppPstnRemotePeerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 2, 2, 1), ).setIndexNames((0, "PCE-MIB", "fclPppPstnRemX121Addr"))
if mibBuilder.loadTexts: fclPppPstnRemotePeerEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppPstnRemotePeerEntry.setDescription('An entry of fclPppPstnRemotePeerTable.')
fclPppPstnRemX121Addr = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 2, 2, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclPppPstnRemX121Addr.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppPstnRemX121Addr.setDescription('Adresse X121')
fclPppPstnRemStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclPppPstnRemStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppPstnRemStatus.setDescription('Status')
fclPppPstnRemPstnNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 2, 2, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(14, 14)).setFixedLength(14)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclPppPstnRemPstnNumber.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppPstnRemPstnNumber.setDescription('Numero RTC')
fclPppBIsdnAccess = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 3))
fclPppBIsdnLogPortTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 3, 1), )
if mibBuilder.loadTexts: fclPppBIsdnLogPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppBIsdnLogPortTable.setDescription('')
fclPppBIsdnLogPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 3, 1, 1), ).setIndexNames((0, "PCE-MIB", "fclPppBIsdnLpLogPortId"))
if mibBuilder.loadTexts: fclPppBIsdnLogPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppBIsdnLogPortEntry.setDescription('An entry of fclPppBIsdnLogPortTable.')
fclPppBIsdnLpLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclPppBIsdnLpLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppBIsdnLpLogPortId.setDescription('LP id')
fclPppBIsdnLpIsdnInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclPppBIsdnLpIsdnInterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppBIsdnLpIsdnInterfaceId.setDescription('IF id (de type RNIS S0)')
fclPppBIsdnLocalBriTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 3, 2), )
if mibBuilder.loadTexts: fclPppBIsdnLocalBriTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppBIsdnLocalBriTable.setDescription('')
fclPppBIsdnLocalBriEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 3, 2, 1), ).setIndexNames((0, "PCE-MIB", "fclPppBIsdnBriId"))
if mibBuilder.loadTexts: fclPppBIsdnLocalBriEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppBIsdnLocalBriEntry.setDescription('An entry of fclPppBIsdnLocalBriTable.')
fclPppBIsdnBriId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 3, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclPppBIsdnBriId.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppBIsdnBriId.setDescription('IF id (de type RNIS S0)')
fclPppBIsdnBriStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 3, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclPppBIsdnBriStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppBIsdnBriStatus.setDescription('Status')
fclPppBIsdnBriLocalSubsNb1 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 3, 2, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclPppBIsdnBriLocalSubsNb1.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppBIsdnBriLocalSubsNb1.setDescription("Numero d'abonne 1")
fclPppBIsdnBriLocalSubsNb2 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 3, 2, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclPppBIsdnBriLocalSubsNb2.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppBIsdnBriLocalSubsNb2.setDescription("Numero d'abonne 2")
fclPppBIsdnRemotePeerTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 3, 3), )
if mibBuilder.loadTexts: fclPppBIsdnRemotePeerTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppBIsdnRemotePeerTable.setDescription('')
fclPppBIsdnRemotePeerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 3, 3, 1), ).setIndexNames((0, "PCE-MIB", "fclPppBIsdnRemX121Addr"), (0, "PCE-MIB", "fclPppBIsdnRemPeerId"))
if mibBuilder.loadTexts: fclPppBIsdnRemotePeerEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppBIsdnRemotePeerEntry.setDescription('An entry of fclPppBIsdnRemotePeerTable.')
fclPppBIsdnRemX121Addr = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 3, 3, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclPppBIsdnRemX121Addr.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppBIsdnRemX121Addr.setDescription('Adresse X121')
fclPppBIsdnRemPeerId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 3, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 999))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclPppBIsdnRemPeerId.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppBIsdnRemPeerId.setDescription('Interface RNIS distante id')
fclPppBIsdnRemStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 3, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclPppBIsdnRemStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppBIsdnRemStatus.setDescription('Status')
fclPppBIsdnRemConfigId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 3, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclPppBIsdnRemConfigId.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppBIsdnRemConfigId.setDescription('Config PPP id')
fclPppBIsdnRemPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 3, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclPppBIsdnRemPriority.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppBIsdnRemPriority.setDescription('Priorite')
fclPppBIsdnRemCallRetryCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 3, 3, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclPppBIsdnRemCallRetryCount.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppBIsdnRemCallRetryCount.setDescription('Nb de tentatives appel')
fclPppBIsdnRemLinkCheckPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 3, 3, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(200, 50800))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclPppBIsdnRemLinkCheckPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppBIsdnRemLinkCheckPeriod.setDescription('Periode de surveillance jonction (msec)')
fclPppBIsdnRemCheckPeriodCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 3, 3, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 250))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclPppBIsdnRemCheckPeriodCount.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppBIsdnRemCheckPeriodCount.setDescription('Confirmation au bout de n periodes')
fclPppBIsdnLocalPriTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 3, 4), )
if mibBuilder.loadTexts: fclPppBIsdnLocalPriTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppBIsdnLocalPriTable.setDescription('')
fclPppBIsdnLocalPriEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 3, 4, 1), ).setIndexNames((0, "PCE-MIB", "fclPppBIsdnPriId"))
if mibBuilder.loadTexts: fclPppBIsdnLocalPriEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppBIsdnLocalPriEntry.setDescription('An entry of fclPppBIsdnLocalPriTable.')
fclPppBIsdnPriId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 3, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclPppBIsdnPriId.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppBIsdnPriId.setDescription('IF id (de type RNIS S2)')
fclPppBIsdnPriStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 3, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclPppBIsdnPriStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppBIsdnPriStatus.setDescription('Status')
fclPppBIsdnPriLocalSubs = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 3, 4, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 24))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclPppBIsdnPriLocalSubs.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppBIsdnPriLocalSubs.setDescription("Numero d'abonne")
fclPppConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 10))
fclPppConfigurationsTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 10, 10), )
if mibBuilder.loadTexts: fclPppConfigurationsTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppConfigurationsTable.setDescription('')
fclPppConfigurationsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 10, 10, 1), ).setIndexNames((0, "PCE-MIB", "fclPppCfgConfigId"))
if mibBuilder.loadTexts: fclPppConfigurationsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppConfigurationsEntry.setDescription('An entry of fclPppConfigurationsTable.')
fclPppCfgConfigId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 10, 10, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclPppCfgConfigId.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppCfgConfigId.setDescription('Config PPP id')
fclPppCfgStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 10, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclPppCfgStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppCfgStatus.setDescription('Status')
fclPppCfgDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 10, 10, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclPppCfgDescription.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppCfgDescription.setDescription('Description')
fclPppCfgLcpMagicNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 10, 10, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclPppCfgLcpMagicNumber.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppCfgLcpMagicNumber.setDescription('LCP Utilisation du Magic Number')
fclPppCfgLcpLocalMru = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 10, 10, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("mru100", 1), ("mru200", 2), ("mru300", 3), ("mru400", 4), ("mru500", 5), ("mru600", 6), ("mru700", 7), ("mru800", 8), ("mru900", 9), ("mru1000", 10), ("mru1100", 11), ("mru1200", 12), ("mru1300", 13), ("mru1400", 14), ("mru1500", 15), ("mru1600", 16)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclPppCfgLcpLocalMru.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppCfgLcpLocalMru.setDescription('LCP Local Maximum Receive Unit')
fclPppCfgLcpLocalMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 10, 10, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("mtu100", 1), ("mtu200", 2), ("mtu300", 3), ("mtu400", 4), ("mtu500", 5), ("mtu600", 6), ("mtu700", 7), ("mtu800", 8), ("mtu900", 9), ("mtu1000", 10), ("mtu1100", 11), ("mtu1200", 12), ("mtu1300", 13), ("mtu1400", 14), ("mtu1500", 15), ("mtu1600", 16)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclPppCfgLcpLocalMtu.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppCfgLcpLocalMtu.setDescription('LCP Local Maximum Transmit Unit')
fclPppCfgNcpBridge = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 10, 10, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclPppCfgNcpBridge.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppCfgNcpBridge.setDescription('Bridge NCP')
fclPppCfgNcpIp = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 10, 10, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclPppCfgNcpIp.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppCfgNcpIp.setDescription('IP NCP')
fclPppCfgNcpIpx = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 10, 10, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclPppCfgNcpIpx.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppCfgNcpIpx.setDescription('IPX NCP')
fclPppCfgNcpClnp = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 10, 10, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclPppCfgNcpClnp.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppCfgNcpClnp.setDescription('CLNP NCP')
fclPppCfgAuthentication = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 10, 10, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("off", 1), ("pap", 2), ("chap", 3), ("papAndChap", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclPppCfgAuthentication.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppCfgAuthentication.setDescription('Option authentification')
fclPppCfgAuthenticationMode = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 10, 10, 1, 41), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("master", 1), ("slave", 2), ("masterAndSlave", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclPppCfgAuthenticationMode.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppCfgAuthenticationMode.setDescription('Mode authentification')
fclPppCfgIpAddrAssignment = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 10, 10, 1, 42), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("byLocalSubscriber", 2), ("byRemotePeer", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclPppCfgIpAddrAssignment.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppCfgIpAddrAssignment.setDescription('Option adresse IP dynamique')
fclPppConfigTimersTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 10, 11), )
if mibBuilder.loadTexts: fclPppConfigTimersTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppConfigTimersTable.setDescription('')
fclPppConfigTimersEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 10, 11, 1), ).setIndexNames((0, "PCE-MIB", "fclPppCftConfigId"))
if mibBuilder.loadTexts: fclPppConfigTimersEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppConfigTimersEntry.setDescription('An entry of fclPppConfigTimersTable.')
fclPppCftConfigId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 10, 11, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclPppCftConfigId.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppCftConfigId.setDescription('Config PPP id')
fclPppCftLcpEchoRequestPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 10, 11, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 254))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclPppCftLcpEchoRequestPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppCftLcpEchoRequestPeriod.setDescription("Periode d'emission des echo requests LCP")
fclPppCftConnectionTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 10, 11, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 254))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclPppCftConnectionTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppCftConnectionTimer.setDescription('Temporisateur de surveillance')
fclPppCftRestartTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 10, 11, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 254))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclPppCftRestartTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppCftRestartTimer.setDescription('Tempo de reemission des messages ')
fclPppCftConfigureMaxCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 10, 11, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 254))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclPppCftConfigureMaxCount.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppCftConfigureMaxCount.setDescription('Nombre max de retransmission des configure request')
fclPppCftTerminateMaxCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 10, 11, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 254))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclPppCftTerminateMaxCount.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppCftTerminateMaxCount.setDescription('Nombre max de retransmission des terminate request')
fclPppCftFailureMaxCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 10, 11, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 254))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclPppCftFailureMaxCount.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppCftFailureMaxCount.setDescription('Nombre max de retransmission des configure nak')
fclPppConfigAuthentication = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 10, 20))
fclPppCfaLocalIdentifier = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 10, 20, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclPppCfaLocalIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppCfaLocalIdentifier.setDescription("Identite de l'equipement local")
fclPppCfaLocalPassword = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 10, 20, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclPppCfaLocalPassword.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppCfaLocalPassword.setDescription("Mot de passe de l'equipement local")
fclPppCfaRemotePeerTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 10, 20, 10), )
if mibBuilder.loadTexts: fclPppCfaRemotePeerTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppCfaRemotePeerTable.setDescription('')
fclPppCfaRemotePeerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 10, 20, 10, 1), ).setIndexNames((0, "PCE-MIB", "fclPppCfaRemPeerId"))
if mibBuilder.loadTexts: fclPppCfaRemotePeerEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppCfaRemotePeerEntry.setDescription('An entry of fclPppCfaRemotePeerTable.')
fclPppCfaRemPeerId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 10, 20, 10, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 249))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclPppCfaRemPeerId.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppCfaRemPeerId.setDescription('Distant Id')
fclPppCfaRemStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 10, 20, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclPppCfaRemStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppCfaRemStatus.setDescription('Status')
fclPppCfaRemIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 10, 20, 10, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclPppCfaRemIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppCfaRemIdentifier.setDescription("Identite de l'equipement distant")
fclPppCfaRemPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 30, 10, 20, 10, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclPppCfaRemPassword.setStatus('mandatory')
if mibBuilder.loadTexts: fclPppCfaRemPassword.setDescription("Mot de passe de l'equipement distant")
fclFrameRelay = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40))
fclFrCommunicationEquipment = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 1))
fclFrCeLogPortTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 1, 1), )
if mibBuilder.loadTexts: fclFrCeLogPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCeLogPortTable.setDescription('')
fclFrCeLogPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 1, 1, 1), ).setIndexNames((0, "PCE-MIB", "fclFrCeLpLogPortId"))
if mibBuilder.loadTexts: fclFrCeLogPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCeLogPortEntry.setDescription('An entry of fclFrCeLogPortTable.')
fclFrCeLpLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclFrCeLpLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCeLpLogPortId.setDescription('LP Id')
fclFrCeLpInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrCeLpInterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCeLpInterfaceId.setDescription('IF Id (type ligne)')
fclFrCeLpLocalAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 1, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrCeLpLocalAddress.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCeLpLocalAddress.setDescription("Adresse de localisation sur le plan d'adressage du routage (Numero d'abonne)")
fclFrCeLpConfigId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrCeLpConfigId.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCeLpConfigId.setDescription('Configuration FR-CE')
fclFrCeLpLmi = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 4))).clone(namedValues=NamedValues(("off", 1), ("lmiNui", 3), ("lmiNni", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrCeLpLmi.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCeLpLmi.setDescription('LMI')
fclFrCeParGenTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 1, 2), )
if mibBuilder.loadTexts: fclFrCeParGenTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCeParGenTable.setDescription('')
fclFrCeParGenEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 1, 2, 1), ).setIndexNames((0, "PCE-MIB", "fclFrCeParGenLogPortId"))
if mibBuilder.loadTexts: fclFrCeParGenEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCeParGenEntry.setDescription('An entry of fclFrCeParGenTable.')
fclFrCeParGenLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclFrCeParGenLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCeParGenLogPortId.setDescription('LP Id')
fclFrCeParGenDlcSetupAlarmThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 1, 2, 1, 30), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 250))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrCeParGenDlcSetupAlarmThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCeParGenDlcSetupAlarmThreshold.setDescription("A% Seuil alarmique d'acceptation des connexions (pourcentage du debit de la ligne)")
fclFrCeParGenDlcSetupDiscardThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 1, 2, 1, 31), Integer32().subtype(subtypeSpec=ValueRangeConstraint(100, 1100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrCeParGenDlcSetupDiscardThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCeParGenDlcSetupDiscardThreshold.setDescription("R% Seuil de refus d'etablissement des DLC VBR-NRT (pourcentage du debit de la ligne : 100 = pas de surbooking)")
fclFrCeParGenBookingUbrThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 1, 2, 1, 32), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrCeParGenBookingUbrThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCeParGenBookingUbrThreshold.setDescription('U% Bande passante reservee aux reseaux virtuels UBR (pourcentage du debit de la ligne)')
fclFrCeParGenBookingVbrRtThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 1, 2, 1, 33), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrCeParGenBookingVbrRtThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCeParGenBookingVbrRtThreshold.setDescription('V% Bande passante reservee aux COS VBR-RT (pourcentage du debit de la ligne)')
fclFrCeParGenVoiceMaxTransitDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 1, 2, 1, 34), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 250))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrCeParGenVoiceMaxTransitDelay.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCeParGenVoiceMaxTransitDelay.setDescription('PDN transit delay')
fclFrTerminalEquipment = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 2))
fclFrTeLogPortTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 2, 1), )
if mibBuilder.loadTexts: fclFrTeLogPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrTeLogPortTable.setDescription('')
fclFrTeLogPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 2, 1, 1), ).setIndexNames((0, "PCE-MIB", "fclFrTeLpLogPortId"))
if mibBuilder.loadTexts: fclFrTeLogPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrTeLogPortEntry.setDescription('An entry of fclFrTeLogPortTable.')
fclFrTeLpLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclFrTeLpLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrTeLpLogPortId.setDescription('LP Id')
fclFrTeLpInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrTeLpInterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrTeLpInterfaceId.setDescription('IF Id (type ligne)')
fclFrTeLpLocalAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 2, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrTeLpLocalAddress.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrTeLpLocalAddress.setDescription("Adresse de localisation sur le plan d'adressage du routage (Numero d'abonne)")
fclFrTeLpConfigId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrTeLpConfigId.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrTeLpConfigId.setDescription('Configuration FR-TE')
fclFrTeLpLmi = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 2, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4))).clone(namedValues=NamedValues(("off", 1), ("lmiUni", 2), ("lmiNni", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrTeLpLmi.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrTeLpLmi.setDescription('LMI')
fclFrTeLpFragmentation = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 2, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3))).clone(namedValues=NamedValues(("off", 1), ("optimized", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrTeLpFragmentation.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrTeLpFragmentation.setDescription('Segmentation')
fclFrTeLpLinkLayerConsolidation = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 2, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrTeLpLinkLayerConsolidation.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrTeLpLinkLayerConsolidation.setDescription('CLLM')
fclFrTeLpLogPortBackupEnabling = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 2, 1, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("off", 1), ("onWhileActivity", 2), ("onWhileDlciDown", 3), ("onWhileLpDown", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrTeLpLogPortBackupEnabling.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrTeLpLogPortBackupEnabling.setDescription('Secours')
fclFrTeLpFragFrameSize = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 2, 1, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 5, 9, 17, 33, 65))).clone(namedValues=NamedValues(("auto", 1), ("s128", 2), ("s256", 3), ("s512", 5), ("s1024", 9), ("s2048", 17), ("s4096", 33), ("s8192", 65)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrTeLpFragFrameSize.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrTeLpFragFrameSize.setDescription('Taille des trames pour la Segmentation')
fclFrTeLpBackupTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 2, 1, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2540))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrTeLpBackupTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrTeLpBackupTimer.setDescription('Tempo de retour su LS')
fclFrTeParGenTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 2, 4), )
if mibBuilder.loadTexts: fclFrTeParGenTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrTeParGenTable.setDescription('')
fclFrTeParGenEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 2, 4, 1), ).setIndexNames((0, "PCE-MIB", "fclFrTeParGenLogPortId"))
if mibBuilder.loadTexts: fclFrTeParGenEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrTeParGenEntry.setDescription('An entry of fclFrTeParGenTable.')
fclFrTeParGenLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 2, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclFrTeParGenLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrTeParGenLogPortId.setDescription('LP Id')
fclFrTeParGenDlcSetupAlarmThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 2, 4, 1, 30), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 250))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrTeParGenDlcSetupAlarmThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrTeParGenDlcSetupAlarmThreshold.setDescription("A% Seuil alarmique d'acceptation des connexions (pourcentage du debit de la ligne)")
fclFrTeParGenDlcSetupDiscardThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 2, 4, 1, 31), Integer32().subtype(subtypeSpec=ValueRangeConstraint(100, 1100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrTeParGenDlcSetupDiscardThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrTeParGenDlcSetupDiscardThreshold.setDescription("R% Seuil de refus d'etablissement des DLC VBR-NRT (pourcentage du debit de la ligne : 100 = pas de surbooking)")
fclFrTeParGenBookingUbrThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 2, 4, 1, 32), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrTeParGenBookingUbrThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrTeParGenBookingUbrThreshold.setDescription('U% Bande passante reservee aux reseaux virtuels UBR (pourcentage du debit de la ligne)')
fclFrTeParGenBookingVbrRtThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 2, 4, 1, 33), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrTeParGenBookingVbrRtThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrTeParGenBookingVbrRtThreshold.setDescription('V% Bande passante reservee aux COS VBR-RT (pourcentage du debit de la ligne)')
fclFrTeParGenVoiceMaxTransitDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 2, 4, 1, 34), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 250))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrTeParGenVoiceMaxTransitDelay.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrTeParGenVoiceMaxTransitDelay.setDescription('PDN transit delay')
fclFrTeParGenDynamicEir = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 2, 4, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrTeParGenDynamicEir.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrTeParGenDynamicEir.setDescription("The value 'off' of this object means the Burst Exceeded object configuration is used in the traffic management plan with respect agreement traffic. The value 'on' of this object allows the whole connection to have a fair share of the line bandwidth in the proportion of the Commited Information Rate. In this case, the Burst Exceeded used in the traffic control is made dynamically from the unloaded line in the prorata of the CIR. The default value is 'on'.")
fclFrTeParGenPredictionRoundTripDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 2, 4, 1, 36), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 250))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrTeParGenPredictionRoundTripDelay.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrTeParGenPredictionRoundTripDelay.setDescription('Prediction du delai de propagation')
fclFrTeParGenNetworkBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 2, 4, 1, 37), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 34))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrTeParGenNetworkBandwidth.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrTeParGenNetworkBandwidth.setDescription('Bande passante du reseau')
fclFrTeIsdnBackupTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 2, 11), )
if mibBuilder.loadTexts: fclFrTeIsdnBackupTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrTeIsdnBackupTable.setDescription('')
fclFrTeIsdnBackupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 2, 11, 1), ).setIndexNames((0, "PCE-MIB", "fclFrTeIsdnBackLogPortId"), (0, "PCE-MIB", "fclFrTeIsdnBackIsdnInterfaceId"))
if mibBuilder.loadTexts: fclFrTeIsdnBackupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrTeIsdnBackupEntry.setDescription('An entry of fclFrTeIsdnBackupTable.')
fclFrTeIsdnBackLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 2, 11, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclFrTeIsdnBackLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrTeIsdnBackLogPortId.setDescription('LP Id')
fclFrTeIsdnBackIsdnInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 2, 11, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 249))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclFrTeIsdnBackIsdnInterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrTeIsdnBackIsdnInterfaceId.setDescription('Interface RNIS locale id')
fclFrTeIsdnBackStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 2, 11, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrTeIsdnBackStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrTeIsdnBackStatus.setDescription('Status')
fclFrTeIsdnRemotePeerTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 2, 12), )
if mibBuilder.loadTexts: fclFrTeIsdnRemotePeerTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrTeIsdnRemotePeerTable.setDescription('')
fclFrTeIsdnRemotePeerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 2, 12, 1), ).setIndexNames((0, "PCE-MIB", "fclFrTeIsdnRemLogPortId"), (0, "PCE-MIB", "fclFrTeIsdnRemRemotePeerId"))
if mibBuilder.loadTexts: fclFrTeIsdnRemotePeerEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrTeIsdnRemotePeerEntry.setDescription('An entry of fclFrTeIsdnRemotePeerTable.')
fclFrTeIsdnRemLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 2, 12, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclFrTeIsdnRemLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrTeIsdnRemLogPortId.setDescription('LP Id')
fclFrTeIsdnRemRemotePeerId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 2, 12, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 249))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclFrTeIsdnRemRemotePeerId.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrTeIsdnRemRemotePeerId.setDescription('InterfaceRNIS distante id')
fclFrTeIsdnRemStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 2, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrTeIsdnRemStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrTeIsdnRemStatus.setDescription('Status')
fclFrTeIsdnRemPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 2, 12, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrTeIsdnRemPriority.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrTeIsdnRemPriority.setDescription('Priorite')
fclFrTeIsdnRemCallRetryCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 2, 12, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrTeIsdnRemCallRetryCount.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrTeIsdnRemCallRetryCount.setDescription("Nombre de tentatives d'appel")
fclFrTeIsdnRemProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 2, 12, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("frse", 1), ("frte", 2), ("main-line-protocol", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrTeIsdnRemProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrTeIsdnRemProtocol.setDescription('Type de protocole')
fclFrTeIsdnRemConfigId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 2, 12, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrTeIsdnRemConfigId.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrTeIsdnRemConfigId.setDescription('Configuration id')
fclFrSwitchEquipment = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 3))
fclFrSeLogPortTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 3, 1), )
if mibBuilder.loadTexts: fclFrSeLogPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrSeLogPortTable.setDescription('')
fclFrSeLogPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 3, 1, 1), ).setIndexNames((0, "PCE-MIB", "fclFrSeLpLogPortId"))
if mibBuilder.loadTexts: fclFrSeLogPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrSeLogPortEntry.setDescription('An entry of fclFrSeLogPortTable.')
fclFrSeLpLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclFrSeLpLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrSeLpLogPortId.setDescription('LP Id')
fclFrSeLpInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrSeLpInterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrSeLpInterfaceId.setDescription('IF Id (type ligne)')
fclFrSeLpConfigId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrSeLpConfigId.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrSeLpConfigId.setDescription('Configuration FR-SE')
fclFrSeLpLogPortBackupEnabling = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 3, 1, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("onWhileActivity", 2), ("onWhileLpDown", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrSeLpLogPortBackupEnabling.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrSeLpLogPortBackupEnabling.setDescription('Secours')
fclFrSeLpBackupTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 3, 1, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2540))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrSeLpBackupTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrSeLpBackupTimer.setDescription('Tempo de retour sur LS')
fclFrSeIsdnBackupTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 3, 11), )
if mibBuilder.loadTexts: fclFrSeIsdnBackupTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrSeIsdnBackupTable.setDescription('')
fclFrSeIsdnBackupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 3, 11, 1), ).setIndexNames((0, "PCE-MIB", "fclFrSeIsdnBackLogPortId"), (0, "PCE-MIB", "fclFrSeIsdnBackIsdnInterfaceId"))
if mibBuilder.loadTexts: fclFrSeIsdnBackupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrSeIsdnBackupEntry.setDescription('An entry of fclFrSeIsdnBackupTable.')
fclFrSeIsdnBackLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 3, 11, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclFrSeIsdnBackLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrSeIsdnBackLogPortId.setDescription('LP Id')
fclFrSeIsdnBackIsdnInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 3, 11, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 249))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclFrSeIsdnBackIsdnInterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrSeIsdnBackIsdnInterfaceId.setDescription('Interface RNIS locale id')
fclFrSeIsdnBackStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 3, 11, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrSeIsdnBackStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrSeIsdnBackStatus.setDescription('Status')
fclFrSeIsdnRemotePeerTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 3, 12), )
if mibBuilder.loadTexts: fclFrSeIsdnRemotePeerTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrSeIsdnRemotePeerTable.setDescription('')
fclFrSeIsdnRemotePeerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 3, 12, 1), ).setIndexNames((0, "PCE-MIB", "fclFrSeIsdnRemLogPortId"), (0, "PCE-MIB", "fclFrSeIsdnRemRemotePeerId"))
if mibBuilder.loadTexts: fclFrSeIsdnRemotePeerEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrSeIsdnRemotePeerEntry.setDescription('An entry of fclFrSeIsdnRemotePeerTable.')
fclFrSeIsdnRemLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 3, 12, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclFrSeIsdnRemLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrSeIsdnRemLogPortId.setDescription('LP Id')
fclFrSeIsdnRemRemotePeerId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 3, 12, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 249))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclFrSeIsdnRemRemotePeerId.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrSeIsdnRemRemotePeerId.setDescription('Interface RNIS distante id')
fclFrSeIsdnRemStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 3, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrSeIsdnRemStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrSeIsdnRemStatus.setDescription('Status')
fclFrSeIsdnRemConfigId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 3, 12, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrSeIsdnRemConfigId.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrSeIsdnRemConfigId.setDescription('Configuration FR-SE')
fclFrSeIsdnRemPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 3, 12, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrSeIsdnRemPriority.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrSeIsdnRemPriority.setDescription('Priorite')
fclFrSeIsdnRemCallRetryCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 3, 12, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrSeIsdnRemCallRetryCount.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrSeIsdnRemCallRetryCount.setDescription("Nombre de tentatives d'appel")
fclFrSeInBIsdn = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 13))
fclFrSeInBIsdnLogPortTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 13, 1), )
if mibBuilder.loadTexts: fclFrSeInBIsdnLogPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrSeInBIsdnLogPortTable.setDescription('')
fclFrSeInBIsdnLogPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 13, 1, 1), ).setIndexNames((0, "PCE-MIB", "fclFrSeInBLpLogPortId"))
if mibBuilder.loadTexts: fclFrSeInBIsdnLogPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrSeInBIsdnLogPortEntry.setDescription('An entry of fclFrSeInBIsdnLogPortTable.')
fclFrSeInBLpLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 13, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclFrSeInBLpLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrSeInBLpLogPortId.setDescription('LP Id')
fclFrSeInBLpIsdnInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 13, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrSeInBLpIsdnInterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrSeInBLpIsdnInterfaceId.setDescription('IF Id (type RNIS)')
fclFrSeInBRemotePeerTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 13, 2), )
if mibBuilder.loadTexts: fclFrSeInBRemotePeerTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrSeInBRemotePeerTable.setDescription('')
fclFrSeInBRemotePeerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 13, 2, 1), ).setIndexNames((0, "PCE-MIB", "fclFrSeInBRemRemoteAddress"), (0, "PCE-MIB", "fclFrSeInBRemPeerId"))
if mibBuilder.loadTexts: fclFrSeInBRemotePeerEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrSeInBRemotePeerEntry.setDescription('An entry of fclFrSeInBRemotePeerTable.')
fclFrSeInBRemRemoteAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 13, 2, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclFrSeInBRemRemoteAddress.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrSeInBRemRemoteAddress.setDescription('Adresse visee')
fclFrSeInBRemPeerId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 13, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 999))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclFrSeInBRemPeerId.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrSeInBRemPeerId.setDescription('Interface RNIS distante id')
fclFrSeInBRemStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 13, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrSeInBRemStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrSeInBRemStatus.setDescription('Status')
fclFrSeInBRemPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 13, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrSeInBRemPriority.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrSeInBRemPriority.setDescription('Priorite')
fclFrSeInBRemCallRetryCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 13, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrSeInBRemCallRetryCount.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrSeInBRemCallRetryCount.setDescription('Nb de tentatives appel')
fclFrSeInBRemConfigId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 13, 2, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrSeInBRemConfigId.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrSeInBRemConfigId.setDescription('Configuration FR-SE')
fclFrPvcEndPoint = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 20))
fclFrPvcEndPointTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 20, 1), )
if mibBuilder.loadTexts: fclFrPvcEndPointTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcEndPointTable.setDescription('')
fclFrPvcEndPointEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 20, 1, 1), ).setIndexNames((0, "PCE-MIB", "fclFrPvcLinkType"), (0, "PCE-MIB", "fclFrPvcLinkId"), (0, "PCE-MIB", "fclFrPvcDlci"))
if mibBuilder.loadTexts: fclFrPvcEndPointEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcEndPointEntry.setDescription('An entry of fclFrPvcEndPointTable.')
fclFrPvcLinkType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 20, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("logicalPort", 1), ("bChannelIsdn", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclFrPvcLinkType.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcLinkType.setDescription('Type de liaison (=logicalPort en v2.1)')
fclFrPvcLinkId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 20, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 249))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclFrPvcLinkId.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcLinkId.setDescription('Liaison Id (=LogPortId en v2.1)')
fclFrPvcDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 20, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 991))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclFrPvcDlci.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcDlci.setDescription('DLCI')
fclFrPvcStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 20, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrPvcStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcStatus.setDescription('Status')
fclFrPvcCalledAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 20, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrPvcCalledAddress.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcCalledAddress.setDescription('Adresse distante (non utilisee si encapsulation X25)')
fclFrPvcCallDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 20, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 5, 3, 4))).clone(namedValues=NamedValues(("calling", 1), ("called", 2), ("calledMulti", 5), ("auto", 3), ("datagram", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrPvcCallDirection.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcCallDirection.setDescription("Mode d'appel (non utilise si encapsulation X25)")
fclFrPvcEncapsulation = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 20, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("none", 1), ("lanProtocols", 2), ("x25", 3), ("sna", 4), ("snaBan", 5), ("voice", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrPvcEncapsulation.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcEncapsulation.setDescription('Encapsulation')
fclFrPvcBackupEnabling = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 20, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrPvcBackupEnabling.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcBackupEnabling.setDescription('Terminaison de PVC a secourir')
fclFrPvcBackupDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 20, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 991))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrPvcBackupDlci.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcBackupDlci.setDescription('DLCI de secours')
fclFrPvcTrafficManagementStrategy = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 20, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 4))).clone(namedValues=NamedValues(("discardButNotDelay", 1), ("delayButNotDiscard-Bc", 3), ("delayButNotDiscard-BcBe", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrPvcTrafficManagementStrategy.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcTrafficManagementStrategy.setDescription('Traffic management strategy')
fclFrPvcNetworkTransport = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 20, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(36, 32))).clone(namedValues=NamedValues(("transparent", 36), ("ansiT1-617-G", 32)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrPvcNetworkTransport.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcNetworkTransport.setDescription('FR Network transport')
fclFrPvcQualityOfServiceTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 20, 2), )
if mibBuilder.loadTexts: fclFrPvcQualityOfServiceTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcQualityOfServiceTable.setDescription('')
fclFrPvcQualityOfServiceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 20, 2, 1), ).setIndexNames((0, "PCE-MIB", "fclFrPvcQosLinkType"), (0, "PCE-MIB", "fclFrPvcQosLinkId"), (0, "PCE-MIB", "fclFrPvcQosDlci"))
if mibBuilder.loadTexts: fclFrPvcQualityOfServiceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcQualityOfServiceEntry.setDescription('An entry of fclFrPvcQualityOfServiceTable.')
fclFrPvcQosLinkType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 20, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("logicalPort", 1), ("bChannelIsdn", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclFrPvcQosLinkType.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcQosLinkType.setDescription('Type de liaison (=logicalPort en v2.1)')
fclFrPvcQosLinkId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 20, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 249))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclFrPvcQosLinkId.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcQosLinkId.setDescription('Liaison Id (=LogPortId en v2.1)')
fclFrPvcQosDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 20, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 991))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclFrPvcQosDlci.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcQosDlci.setDescription('DLCI')
fclFrPvcQosCos = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 20, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 1, 2))).clone(namedValues=NamedValues(("ubr", 3), ("vbr", 1), ("vbr-rt", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrPvcQosCos.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcQosCos.setDescription('COS')
fclFrPvcQosInBc = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 20, 2, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrPvcQosInBc.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcQosInBc.setDescription('Entrant BC')
fclFrPvcQosInBe = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 20, 2, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrPvcQosInBe.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcQosInBe.setDescription('Entrant BE')
fclFrPvcQosInCir = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 20, 2, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrPvcQosInCir.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcQosInCir.setDescription('Entrant CIR')
fclFrPvcQosInMinCir = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 20, 2, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrPvcQosInMinCir.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcQosInMinCir.setDescription('Entrant CIR mini')
fclFrPvcQosOutBc = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 20, 2, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrPvcQosOutBc.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcQosOutBc.setDescription('Sortant BC')
fclFrPvcQosOutBe = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 20, 2, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrPvcQosOutBe.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcQosOutBe.setDescription('Sortant BE')
fclFrPvcQosOutCir = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 20, 2, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrPvcQosOutCir.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcQosOutCir.setDescription('Sortant CIR')
fclFrPvcQosOutMinCir = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 20, 2, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrPvcQosOutMinCir.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcQosOutMinCir.setDescription('Sortant CIR mini')
fclFrPvcX25EncapsulationTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 20, 10), )
if mibBuilder.loadTexts: fclFrPvcX25EncapsulationTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcX25EncapsulationTable.setDescription('')
fclFrPvcX25EncapsulationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 20, 10, 1), ).setIndexNames((0, "PCE-MIB", "fclFrPvcX25LinkType"), (0, "PCE-MIB", "fclFrPvcX25LinkId"), (0, "PCE-MIB", "fclFrPvcX25Dlci"))
if mibBuilder.loadTexts: fclFrPvcX25EncapsulationEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcX25EncapsulationEntry.setDescription('An entry of fclFrPvcX25EncapsulationTable.')
fclFrPvcX25LinkType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 20, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("logicalPort", 1), ("bChannelIsdn", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclFrPvcX25LinkType.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcX25LinkType.setDescription('Type de liaison (=logicalPort en v2.1)')
fclFrPvcX25LinkId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 20, 10, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 249))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclFrPvcX25LinkId.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcX25LinkId.setDescription('Liaison Id (=LogPortId en v2.1)')
fclFrPvcX25Dlci = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 20, 10, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 991))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclFrPvcX25Dlci.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcX25Dlci.setDescription('DLCI')
fclFrPvcX25AssociatedAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 20, 10, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrPvcX25AssociatedAddress.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcX25AssociatedAddress.setDescription('Adresse associee')
fclFrPvcX25InterNodeConfigId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 20, 10, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrPvcX25InterNodeConfigId.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcX25InterNodeConfigId.setDescription('Configuration X25')
fclFrPvcSnaEncapsulationTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 20, 11), )
if mibBuilder.loadTexts: fclFrPvcSnaEncapsulationTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcSnaEncapsulationTable.setDescription('')
fclFrPvcSnaEncapsulationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 20, 11, 1), ).setIndexNames((0, "PCE-MIB", "fclFrPvcSnaLinkType"), (0, "PCE-MIB", "fclFrPvcSnaLinkId"), (0, "PCE-MIB", "fclFrPvcSnaDlci"))
if mibBuilder.loadTexts: fclFrPvcSnaEncapsulationEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcSnaEncapsulationEntry.setDescription('An entry of fclFrPvcSnaEncapsulationTable.')
fclFrPvcSnaLinkType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 20, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("logicalPort", 1), ("bChannelIsdn", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclFrPvcSnaLinkType.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcSnaLinkType.setDescription('Type de liaison (=logicalPort en v2.1)')
fclFrPvcSnaLinkId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 20, 11, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 249))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclFrPvcSnaLinkId.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcSnaLinkId.setDescription('Liaison Id (=LogPortId en v2.1)')
fclFrPvcSnaDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 20, 11, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 991))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclFrPvcSnaDlci.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcSnaDlci.setDescription('DLCI')
fclFrPvcSnaConnTestEnabling = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 20, 11, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrPvcSnaConnTestEnabling.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcSnaConnTestEnabling.setDescription("Initiative d'etablissement de connexion par une trame test")
fclFrPvcSnaLevel3Pid = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 20, 11, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("subArea", 1), ("peripheral", 2), ("appn", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrPvcSnaLevel3Pid.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcSnaLevel3Pid.setDescription('L3 PID')
fclFrPvcSnaDestinationSap = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 20, 11, 1, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrPvcSnaDestinationSap.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcSnaDestinationSap.setDescription('DSAP')
fclFrPvcSnaSourceSap = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 20, 11, 1, 12), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrPvcSnaSourceSap.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcSnaSourceSap.setDescription('SSAP')
fclFrPvcSnaT1ReplyTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 20, 11, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(100, 25000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrPvcSnaT1ReplyTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcSnaT1ReplyTimer.setDescription('Timer T1 attente une trame U')
fclFrPvcSnaN2RetryCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 20, 11, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrPvcSnaN2RetryCount.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcSnaN2RetryCount.setDescription('N2 Nombre maximum de retransmissions')
fclFrPvcSnaT2ReceiverAckTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 20, 11, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(100, 15000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrPvcSnaT2ReceiverAckTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcSnaT2ReceiverAckTimer.setDescription('Timer T2 acquittement des trames I')
fclFrPvcSnaN3AcknowledgedCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 20, 11, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrPvcSnaN3AcknowledgedCount.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcSnaN3AcknowledgedCount.setDescription('N3 Nombre de trames ok avant acquittement')
fclFrPvcSnaNwIncrementAckCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 20, 11, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrPvcSnaNwIncrementAckCount.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcSnaNwIncrementAckCount.setDescription('NW congestion : nombre de trames ok avant incrementer la fenetre de travail')
fclFrPvcSnaTwTransmitWinSize = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 20, 11, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrPvcSnaTwTransmitWinSize.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcSnaTwTransmitWinSize.setDescription('TW Fenetre en emission')
fclFrPvcSnaRwReceiveWinSize = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 20, 11, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrPvcSnaRwReceiveWinSize.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcSnaRwReceiveWinSize.setDescription('RW fenetre reception')
fclFrSnaBan = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 20, 12))
fclFrNbStationDlci = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 20, 12, 1))
fclFrNbStationByDlci = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 20, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("nb0", 1), ("nb16", 2), ("nb32", 3), ("nb64", 4), ("nb128", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrNbStationByDlci.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrNbStationByDlci.setDescription('Nombre de stations par DLCI BAN Frontal')
fclFrPvcSnaBanEncapsulationTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 20, 12, 10), )
if mibBuilder.loadTexts: fclFrPvcSnaBanEncapsulationTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcSnaBanEncapsulationTable.setDescription('')
fclFrPvcSnaBanEncapsulationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 20, 12, 10, 1), ).setIndexNames((0, "PCE-MIB", "fclFrPvcSnaBanLinkType"), (0, "PCE-MIB", "fclFrPvcSnaBanLinkId"), (0, "PCE-MIB", "fclFrPvcSnaBanDlci"))
if mibBuilder.loadTexts: fclFrPvcSnaBanEncapsulationEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcSnaBanEncapsulationEntry.setDescription('An entry of fclFrPvcSnaBanEncapsulationTable.')
fclFrPvcSnaBanLinkType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 20, 12, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("logicalPort", 1), ("bChannelIsdn", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclFrPvcSnaBanLinkType.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcSnaBanLinkType.setDescription('Type de liaison (=logicalPort en v2.1)')
fclFrPvcSnaBanLinkId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 20, 12, 10, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 249))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclFrPvcSnaBanLinkId.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcSnaBanLinkId.setDescription('Liaison Id (=LogPortId en v2.1)')
fclFrPvcSnaBanDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 20, 12, 10, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 991))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclFrPvcSnaBanDlci.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcSnaBanDlci.setDescription('DLCI')
fclFrPvcSnaBanPuId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 20, 12, 10, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1999))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrPvcSnaBanPuId.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcSnaBanPuId.setDescription('Pu id')
fclFrPvcSnaBanConnTestEnabling = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 20, 12, 10, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrPvcSnaBanConnTestEnabling.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcSnaBanConnTestEnabling.setDescription("Initiative d'etablissement de connexion par une trame test")
fclFrPvcSnaBanLink = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 20, 12, 10, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("frontal", 1), ("remote", 2), ("auto", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrPvcSnaBanLink.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcSnaBanLink.setDescription('Type de ligne')
fclFrPvcSnaBanT1ReplyTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 20, 12, 10, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(100, 25000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrPvcSnaBanT1ReplyTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcSnaBanT1ReplyTimer.setDescription('Timer T1 attente une trame U')
fclFrPvcSnaBanN2RetryCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 20, 12, 10, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrPvcSnaBanN2RetryCount.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcSnaBanN2RetryCount.setDescription('N2 Nombre maximum de retransmissions')
fclFrPvcSnaBanT2ReceiverAckTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 20, 12, 10, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(100, 15000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrPvcSnaBanT2ReceiverAckTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcSnaBanT2ReceiverAckTimer.setDescription('Timer T2 acquittement des trames I')
fclFrPvcSnaBanN3AcknowledgedCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 20, 12, 10, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrPvcSnaBanN3AcknowledgedCount.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcSnaBanN3AcknowledgedCount.setDescription('N3 Nombre de trames ok avant acquittement')
fclFrPvcSnaBanNwIncrementAckCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 20, 12, 10, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrPvcSnaBanNwIncrementAckCount.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcSnaBanNwIncrementAckCount.setDescription('NW congestion : nombre de trames ok avant incrementer la fenetre de travail')
fclFrPvcSnaBanTwTransmitWinSize = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 20, 12, 10, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrPvcSnaBanTwTransmitWinSize.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcSnaBanTwTransmitWinSize.setDescription('TW Fenetre en emission')
fclFrPvcSnaBanRwReceiveWinSize = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 20, 12, 10, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrPvcSnaBanRwReceiveWinSize.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcSnaBanRwReceiveWinSize.setDescription('RW fenetre reception')
fclFrPvcSnaBanMinRecallTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 20, 12, 10, 1, 27), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 990))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrPvcSnaBanMinRecallTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcSnaBanMinRecallTimer.setDescription('Minimum recall timer ')
fclFrPvcSpecific = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 25))
fclFrPvcTunEndPointTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 25, 1), )
if mibBuilder.loadTexts: fclFrPvcTunEndPointTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcTunEndPointTable.setDescription('')
fclFrPvcTunEndPointEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 25, 1, 1), ).setIndexNames((0, "PCE-MIB", "fclFrPvcTunLinkType"), (0, "PCE-MIB", "fclFrPvcTunLinkId"), (0, "PCE-MIB", "fclFrPvcTunDlci"))
if mibBuilder.loadTexts: fclFrPvcTunEndPointEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcTunEndPointEntry.setDescription('An entry of fclFrPvcTunEndPointTable.')
fclFrPvcTunLinkType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 25, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("logicalPort", 1), ("bChannelIsdn", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclFrPvcTunLinkType.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcTunLinkType.setDescription('Type de liaison (=logicalPort en v2.1)')
fclFrPvcTunLinkId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 25, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 249))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclFrPvcTunLinkId.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcTunLinkId.setDescription('Liaison Id (=LogPortId en v2.1)')
fclFrPvcTunDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 25, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 991))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclFrPvcTunDlci.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcTunDlci.setDescription('DLCI')
fclFrPvcTunStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 25, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrPvcTunStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcTunStatus.setDescription('Status')
fclFrPvcTunInCir = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 25, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrPvcTunInCir.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcTunInCir.setDescription('Entrant CIR')
fclFrPvcTunOutCir = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 25, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrPvcTunOutCir.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcTunOutCir.setDescription('Sortant CIR')
fclFrPvcTunBackupEnabling = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 25, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrPvcTunBackupEnabling.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcTunBackupEnabling.setDescription('Terminaison de PVC a secourir')
fclFrPvcTunBackupDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 25, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 991))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrPvcTunBackupDlci.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcTunBackupDlci.setDescription('DLCI de secours')
fclFrPvcTunAssociatedAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 25, 1, 1, 15), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrPvcTunAssociatedAddress.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcTunAssociatedAddress.setDescription('Adresse associee')
fclFrPvcTunFrseConfiguration = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 25, 1, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrPvcTunFrseConfiguration.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrPvcTunFrseConfiguration.setDescription('Configuration FRSE')
fclFrameRelayBackup = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 27))
fclFrBackupTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 27, 1), )
if mibBuilder.loadTexts: fclFrBackupTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrBackupTable.setDescription('')
fclFrBackupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 27, 1, 1), ).setIndexNames((0, "PCE-MIB", "fclFrMainLPId"), (0, "PCE-MIB", "fclFrMainDlci"), (0, "PCE-MIB", "fclFrBackupLPId"), (0, "PCE-MIB", "fclFrBackupDlci"))
if mibBuilder.loadTexts: fclFrBackupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrBackupEntry.setDescription('An entry of fclFrBackupTable.')
fclFrMainLPId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 27, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 99))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclFrMainLPId.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrMainLPId.setDescription('LP principale')
fclFrMainDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 27, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclFrMainDlci.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrMainDlci.setDescription('DLCI principal')
fclFrBackupLPId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 27, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 99))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclFrBackupLPId.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrBackupLPId.setDescription('LP secours')
fclFrBackupDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 27, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclFrBackupDlci.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrBackupDlci.setDescription('DLCI secours')
fclFrBackupStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 27, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrBackupStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrBackupStatus.setDescription('Status')
fclFrConfigurationCeTe = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 30))
fclFrConfigCeTeTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 30, 1), )
if mibBuilder.loadTexts: fclFrConfigCeTeTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrConfigCeTeTable.setDescription('')
fclFrConfigCeTeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 30, 1, 1), ).setIndexNames((0, "PCE-MIB", "fclFrCfcConfigId"))
if mibBuilder.loadTexts: fclFrConfigCeTeEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrConfigCeTeEntry.setDescription('An entry of fclFrConfigCeTeTable.')
fclFrCfcConfigId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 30, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclFrCfcConfigId.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfcConfigId.setDescription('Configuration id')
fclFrCfcStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 30, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrCfcStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfcStatus.setDescription('Status')
fclFrCfcDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 30, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrCfcDescription.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfcDescription.setDescription('Description')
fclFrCfcProfileId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 30, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrCfcProfileId.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfcProfileId.setDescription("The value of this object is the profile number used to automatically valorize all the FR parameters in an entry of the two tables which composes FR-CE or FR-TE configurations (see fclFrCfcConfigId). The possible values are : 84 FRTE interface, 85 FRCE interface, If it is unused, the value of this parameter is '255'. The default value is '85' (meaning that default values of FR parameters are those pre-defined in profile number 85).")
fclFrCfcModificationCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 30, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclFrCfcModificationCount.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfcModificationCount.setDescription('Nombre de parametres modifies par rapport au profil')
fclFrCfcGeneralParameterTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 30, 10), )
if mibBuilder.loadTexts: fclFrCfcGeneralParameterTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfcGeneralParameterTable.setDescription('')
fclFrCfcGeneralParameterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 30, 10, 1), ).setIndexNames((0, "PCE-MIB", "fclFrCfcGenConfigId"))
if mibBuilder.loadTexts: fclFrCfcGeneralParameterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfcGeneralParameterEntry.setDescription('An entry of fclFrCfcGeneralParameterTable.')
fclFrCfcGenConfigId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 30, 10, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclFrCfcGenConfigId.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfcGenConfigId.setDescription('Configuration id')
fclFrCfcGenMinimumRecallTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 30, 10, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2540))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrCfcGenMinimumRecallTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfcGenMinimumRecallTimer.setDescription('Tempo de slow call (Tsc) en secondes')
fclFrCfcGenInactivityCheckDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 30, 10, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 254))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrCfcGenInactivityCheckDelay.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfcGenInactivityCheckDelay.setDescription('Inactivity check delay (Ta) en minutes')
fclFrCfcGenInactivityTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 30, 10, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2540))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrCfcGenInactivityTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfcGenInactivityTimer.setDescription('Inactivity timer (Tb) en secondes')
fclFrCfcGenUnuseTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 30, 10, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2550))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrCfcGenUnuseTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfcGenUnuseTimer.setDescription('Tempo 0 CV en secondes (0 = pas de surveillance)')
fclFrCfcGenSVC = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 30, 10, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrCfcGenSVC.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfcGenSVC.setDescription('SVC')
fclFrCfcSignallingParameterTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 30, 15), )
if mibBuilder.loadTexts: fclFrCfcSignallingParameterTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfcSignallingParameterTable.setDescription('')
fclFrCfcSignallingParameterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 30, 15, 1), ).setIndexNames((0, "PCE-MIB", "fclFrCfcSigConfigId"))
if mibBuilder.loadTexts: fclFrCfcSignallingParameterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfcSignallingParameterEntry.setDescription('An entry of fclFrCfcSignallingParameterTable.')
fclFrCfcSigConfigId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 30, 15, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclFrCfcSigConfigId.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfcSigConfigId.setDescription('Configuration id')
fclFrCfcSigOuputTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 30, 15, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 51000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrCfcSigOuputTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfcSigOuputTimeout.setDescription('Tempo de surveillance de ligne en emission en millisecondes')
fclFrCfcSigSignalOutputWinSize = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 30, 15, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrCfcSigSignalOutputWinSize.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfcSigSignalOutputWinSize.setDescription("Fenetre d'emission DLCI de signalisation")
fclFrCfcSigN200RetransMaxCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 30, 15, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrCfcSigN200RetransMaxCount.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfcSigN200RetransMaxCount.setDescription('N 200 : Nombre de repetition trames')
fclFrCfcSigT200RetransTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 30, 15, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 25500))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrCfcSigT200RetransTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfcSigT200RetransTimer.setDescription('T 200 : Tempo de retransmission en millisecondes')
fclFrCfcSigT203InactivityTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 30, 15, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrCfcSigT203InactivityTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfcSigT203InactivityTimer.setDescription('T 203 : Polling RR en secondes')
fclFrCfcSigT303SetupResponseTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 30, 15, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrCfcSigT303SetupResponseTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfcSigT303SetupResponseTimer.setDescription('T 303 : Tempo attente de reponse a un etablissement sortant en secondes')
fclFrCfcSigT305DisconnectResponseTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 30, 15, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrCfcSigT305DisconnectResponseTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfcSigT305DisconnectResponseTimer.setDescription('T 305 : Tempo attente de reponse a une demande de deconnexion en secondes')
fclFrCfcSigT308ReleaseResponseTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 30, 15, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrCfcSigT308ReleaseResponseTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfcSigT308ReleaseResponseTimer.setDescription('T 308 : Tempo attente de reponse a une demande de liberation en secondes')
fclFrCfcSigT310CallProceedingTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 30, 15, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrCfcSigT310CallProceedingTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfcSigT310CallProceedingTimer.setDescription('T 310 : Tempo entre un appel recu et une alerte ou une connexion en secondes')
fclFrCfcSigT316RestartAcknowledgeTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 30, 15, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrCfcSigT316RestartAcknowledgeTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfcSigT316RestartAcknowledgeTimer.setDescription('T 316 : Tempo de reponse au RESTART en secondes (0 = pas de RESTART)')
fclFrCfcSigConversionAimedPoint = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 30, 15, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrCfcSigConversionAimedPoint.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfcSigConversionAimedPoint.setDescription('Conversion adresse : point vise')
fclFrCfcEiCodingTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 30, 16), )
if mibBuilder.loadTexts: fclFrCfcEiCodingTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfcEiCodingTable.setDescription('')
fclFrCfcEiCodingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 30, 16, 1), ).setIndexNames((0, "PCE-MIB", "fclFrCfcEiCodConfigId"))
if mibBuilder.loadTexts: fclFrCfcEiCodingEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfcEiCodingEntry.setDescription('An entry of fclFrCfcEiCodingTable.')
fclFrCfcEiCodConfigId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 30, 16, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclFrCfcEiCodConfigId.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfcEiCodConfigId.setDescription('Configuration id')
fclFrCfcEiCodCalledTypNum = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 30, 16, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unknown", 1), ("international-number", 2), ("national-number", 3), ("complementary-address", 4), ("network-specific", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrCfcEiCodCalledTypNum.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfcEiCodCalledTypNum.setDescription('Called Type of number')
fclFrCfcEiCodCalledNumPlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 30, 16, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 9))).clone(namedValues=NamedValues(("unknown", 1), ("e164", 2), ("x121", 3), ("private-num-plan", 9)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrCfcEiCodCalledNumPlanId.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfcEiCodCalledNumPlanId.setDescription('Called Numbering plan identification')
fclFrCfcEiCodCallingTypNum = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 30, 16, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unknown", 1), ("international-number", 2), ("national-number", 3), ("complementary-address", 4), ("network-specific", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrCfcEiCodCallingTypNum.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfcEiCodCallingTypNum.setDescription('Calling Type of number')
fclFrCfcEiCodCallingNumPlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 30, 16, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 9))).clone(namedValues=NamedValues(("unknown", 1), ("e164", 2), ("x121", 3), ("private-num-plan", 9)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrCfcEiCodCallingNumPlanId.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfcEiCodCallingNumPlanId.setDescription('Calling Numbering plan identification')
fclFrCfcLmiParameterTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 30, 21), )
if mibBuilder.loadTexts: fclFrCfcLmiParameterTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfcLmiParameterTable.setDescription('')
fclFrCfcLmiParameterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 30, 21, 1), ).setIndexNames((0, "PCE-MIB", "fclFrCfcLmiConfigId"))
if mibBuilder.loadTexts: fclFrCfcLmiParameterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfcLmiParameterEntry.setDescription('An entry of fclFrCfcLmiParameterTable.')
fclFrCfcLmiConfigId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 30, 21, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclFrCfcLmiConfigId.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfcLmiConfigId.setDescription('Configuration id')
fclFrCfcLmiDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 30, 21, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dlci0", 1), ("dlci1023", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrCfcLmiDlci.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfcLmiDlci.setDescription('DLCI utilise')
fclFrCfcLmiStandard = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 30, 21, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ansiT1-617d", 1), ("itutQ933a", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrCfcLmiStandard.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfcLmiStandard.setDescription('Standard LMI')
fclFrCfcLmiAccessibilityCondition = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 30, 21, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("fast", 1), ("n393", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrCfcLmiAccessibilityCondition.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfcLmiAccessibilityCondition.setDescription('Critere de disponibilite')
fclFrCfcLmiN391FullStatusPollCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 30, 21, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 254))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrCfcLmiN391FullStatusPollCount.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfcLmiN391FullStatusPollCount.setDescription('N 391 (User) Cycle interrogation prealable')
fclFrCfcLmiN392ErrorThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 30, 21, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrCfcLmiN392ErrorThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfcLmiN392ErrorThreshold.setDescription('N 392 (User/Net) Seuil erreur')
fclFrCfcLmiN393MonitoredEventCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 30, 21, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrCfcLmiN393MonitoredEventCount.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfcLmiN393MonitoredEventCount.setDescription('N393 (User/Net) Compteur des evenements controles')
fclFrCfcLmiT391LinkIntegPollTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 30, 21, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrCfcLmiT391LinkIntegPollTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfcLmiT391LinkIntegPollTimer.setDescription('T 391 (User) Tempo de polling status')
fclFrCfcLmiT392PollingVerifTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 30, 21, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrCfcLmiT392PollingVerifTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfcLmiT392PollingVerifTimer.setDescription('T 392 (Net) Tempo attente de la demande etat')
fclFrCfcLmiAsynchronousStatusReport = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 30, 21, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrCfcLmiAsynchronousStatusReport.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfcLmiAsynchronousStatusReport.setDescription('Envoi du status asynchrone')
fclFrConfigurationSe = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 40))
fclFrConfigSeTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 40, 1), )
if mibBuilder.loadTexts: fclFrConfigSeTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrConfigSeTable.setDescription('')
fclFrConfigSeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 40, 1, 1), ).setIndexNames((0, "PCE-MIB", "fclFrCfsConfigId"))
if mibBuilder.loadTexts: fclFrConfigSeEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrConfigSeEntry.setDescription('An entry of fclFrConfigSeTable.')
fclFrCfsConfigId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 40, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclFrCfsConfigId.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfsConfigId.setDescription('Configuration id')
fclFrCfsStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 40, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrCfsStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfsStatus.setDescription('Status')
fclFrCfsDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 40, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrCfsDescription.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfsDescription.setDescription('Description')
fclFrCfsProfileId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 40, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrCfsProfileId.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfsProfileId.setDescription("The value of this object is the profile number used to automatically valorize all the FR parameters in an entry of the two tables which composes FR-SE configurations (see fclFrCfsConfigId). The possible values are : 80 FRSE interface. If it is unused, the value of this parameter is '255'. The default value is '80' (meaning that default values of FR parameters are those pre-defined in profile number 80).")
fclFrCfsModificationCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 40, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclFrCfsModificationCount.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfsModificationCount.setDescription('Nombre de parametres modifies par rapport au profil')
fclFrCfsGeneralParameterTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 40, 10), )
if mibBuilder.loadTexts: fclFrCfsGeneralParameterTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfsGeneralParameterTable.setDescription('')
fclFrCfsGeneralParameterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 40, 10, 1), ).setIndexNames((0, "PCE-MIB", "fclFrCfsGenConfigId"))
if mibBuilder.loadTexts: fclFrCfsGeneralParameterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfsGeneralParameterEntry.setDescription('An entry of fclFrCfsGeneralParameterTable.')
fclFrCfsGenConfigId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 40, 10, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclFrCfsGenConfigId.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfsGenConfigId.setDescription('Configuration id')
fclFrCfsGenCallReturnTransmission = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 40, 10, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 4))).clone(namedValues=NamedValues(("off", 1), ("onIfFailed", 3), ("onIfFailedOrBusy", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrCfsGenCallReturnTransmission.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfsGenCallReturnTransmission.setDescription("Retour d'appel")
fclFrCfsGenUnuseTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 40, 10, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2550))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrCfsGenUnuseTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfsGenUnuseTimer.setDescription('Tempo 0 CV en secondes (0 = pas de surveillance)')
fclFrCfsGenDlcSetupAlarmThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 40, 10, 1, 30), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 250))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrCfsGenDlcSetupAlarmThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfsGenDlcSetupAlarmThreshold.setDescription("A% Seuil alarmique d'acceptation des connexions (pourcentage du debit de la ligne)")
fclFrCfsGenDlcSetupDiscardThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 40, 10, 1, 31), Integer32().subtype(subtypeSpec=ValueRangeConstraint(100, 1100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrCfsGenDlcSetupDiscardThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfsGenDlcSetupDiscardThreshold.setDescription("R% Seuil de refus d'etablissement des DLC VBR-NRT (pourcentage du debit de la ligne : 100 = pas de surbooking)")
fclFrCfsGenBookingUbrThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 40, 10, 1, 32), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrCfsGenBookingUbrThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfsGenBookingUbrThreshold.setDescription('U% Bande passante reservee aux reseaux virtuels UBR (pourcentage du debit de la ligne)')
fclFrCfsGenBookingVbrRtThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 40, 10, 1, 33), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrCfsGenBookingVbrRtThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfsGenBookingVbrRtThreshold.setDescription('V% Bande passante reservee aux COS VBR-RT (pourcentage du debit de la ligne)')
fclFrCfsGenBehavior = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 40, 10, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("svc-endpoint", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrCfsGenBehavior.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfsGenBehavior.setDescription('Type de comportement')
fclFrCfsGenDynamicEir = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 40, 10, 1, 41), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrCfsGenDynamicEir.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfsGenDynamicEir.setDescription("The value 'off' of this object means the Burst Exceeded object configuration is used in the traffic management plan with respect agreement traffic. The value 'on' of this object allows the whole connection to have a fair share of the line bandwidth in the proportion of the Commited Information Rate. In this case, the Burst Exceeded used in the traffic control is made dynamically from the unloaded line in the prorata of the CIR. The default value is 'on'.")
fclFrCfsGenPredictionRoundTripDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 40, 10, 1, 42), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 250))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrCfsGenPredictionRoundTripDelay.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfsGenPredictionRoundTripDelay.setDescription('Prediction du delai de propagation')
fclFrCfsGenNetworkBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 40, 10, 1, 43), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 34))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrCfsGenNetworkBandwidth.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfsGenNetworkBandwidth.setDescription('Bande passante du reseau')
fclFrCfsSignallingTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 40, 20), )
if mibBuilder.loadTexts: fclFrCfsSignallingTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfsSignallingTable.setDescription('')
fclFrCfsSignallingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 40, 20, 1), ).setIndexNames((0, "PCE-MIB", "fclFrCfsSigConfigId"))
if mibBuilder.loadTexts: fclFrCfsSignallingEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfsSignallingEntry.setDescription('An entry of fclFrCfsSignallingTable.')
fclFrCfsSigConfigId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 40, 20, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclFrCfsSigConfigId.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfsSigConfigId.setDescription('Configuration id')
fclFrCfsSigOuputTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 40, 20, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 51000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrCfsSigOuputTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfsSigOuputTimeout.setDescription('Tempo de surveillance de ligne en emission en millisecondes')
fclFrCfsSigSignalOutputWinSize = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 40, 20, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrCfsSigSignalOutputWinSize.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfsSigSignalOutputWinSize.setDescription("Fenetre d'emission DLCI de signalisation")
fclFrCfsSigN200RetransMaxCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 40, 20, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrCfsSigN200RetransMaxCount.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfsSigN200RetransMaxCount.setDescription('N 200 : Nombre de repetition trames')
fclFrCfsSigT200RetransTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 40, 20, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 25500))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrCfsSigT200RetransTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfsSigT200RetransTimer.setDescription('T 200 : Tempo de retransmission en millisecondes')
fclFrCfsSigT203InactivityTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 40, 20, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrCfsSigT203InactivityTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfsSigT203InactivityTimer.setDescription('T 203 : Polling RR en secondes')
fclFrCfsSigT303SetupResponseTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 40, 20, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrCfsSigT303SetupResponseTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfsSigT303SetupResponseTimer.setDescription('T 303 : Tempo attente de reponse a un etablissement sortant en secondes')
fclFrCfsSigT305DisconnectResponseTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 40, 20, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrCfsSigT305DisconnectResponseTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfsSigT305DisconnectResponseTimer.setDescription('T 305 : Tempo attente de reponse a une demande de deconnexion en secondes')
fclFrCfsSigT308ReleaseResponseTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 40, 20, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrCfsSigT308ReleaseResponseTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfsSigT308ReleaseResponseTimer.setDescription('T 308 : Tempo attente de reponse a une demande de liberation en secondes')
fclFrCfsSigT310CallProceedingTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 40, 20, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrCfsSigT310CallProceedingTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfsSigT310CallProceedingTimer.setDescription('T 310 : Tempo entre un appel recu et une alerte ou une connexion en secondes')
fclFrCfsSigT316RestartAcknowledgeTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 40, 40, 20, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclFrCfsSigT316RestartAcknowledgeTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclFrCfsSigT316RestartAcknowledgeTimer.setDescription('T 316 : Tempo de reponse au RESTART en secondes (0 = pas de RESTART)')
fclInterUnitLink = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 45))
fclInterUnitLinkTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 45, 1), )
if mibBuilder.loadTexts: fclInterUnitLinkTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclInterUnitLinkTable.setDescription('')
fclInterUnitLinkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 45, 1, 1), ).setIndexNames((0, "PCE-MIB", "fclIulLogPortId"))
if mibBuilder.loadTexts: fclInterUnitLinkEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclInterUnitLinkEntry.setDescription('An entry of fclInterUnitLinkTable.')
fclIulLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 45, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(36, 41))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclIulLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclIulLogPortId.setDescription('LP id')
fclIulInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 45, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(36, 41))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclIulInterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: fclIulInterfaceId.setDescription('IF id (type LIU)')
fclIulCallReturnTransmission = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 45, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3))).clone(namedValues=NamedValues(("off", 1), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclIulCallReturnTransmission.setStatus('mandatory')
if mibBuilder.loadTexts: fclIulCallReturnTransmission.setDescription("Autorisation retour d'appel")
fclIulConversionAimedPoint = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 45, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclIulConversionAimedPoint.setStatus('mandatory')
if mibBuilder.loadTexts: fclIulConversionAimedPoint.setDescription('Conversion adresse : point vise')
fclIulConversionIncomingCall = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 45, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("off", 1), ("callingAddress", 2), ("calledAddress", 3), ("callingAddressAndCalledAddress", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclIulConversionIncomingCall.setStatus('mandatory')
if mibBuilder.loadTexts: fclIulConversionIncomingCall.setDescription("Conversion d'adresse sur appel entrant")
fclIulConversionOutgoingCall = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 45, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("off", 1), ("callingAddress", 2), ("calledAddress", 3), ("callingAddressAndCalledAddress", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclIulConversionOutgoingCall.setStatus('mandatory')
if mibBuilder.loadTexts: fclIulConversionOutgoingCall.setDescription('Conversion adresse sur appel sortant')
fclIulConversionAddressCheck = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 45, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("off", 1), ("onIncomingCall", 2), ("onOutgoingCall", 3), ("onIncomingCallAndOutgoingCall", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclIulConversionAddressCheck.setStatus('mandatory')
if mibBuilder.loadTexts: fclIulConversionAddressCheck.setDescription('Conversion adresse : controle de la presence dans les tables de conversion')
fclX25Configurations = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50))
fclX25ConfigAccess = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1))
fclX25ConfigAccessTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 1), )
if mibBuilder.loadTexts: fclX25ConfigAccessTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25ConfigAccessTable.setDescription('This table contains the X25 access configurations used by X25 access links.')
fclX25ConfigAccessEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 1, 1), ).setIndexNames((0, "PCE-MIB", "fclX25CfaConfigId"))
if mibBuilder.loadTexts: fclX25ConfigAccessEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25ConfigAccessEntry.setDescription('An entry of fclX25ConfigAccessTable.')
fclX25CfaConfigId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclX25CfaConfigId.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaConfigId.setDescription("The value of this object identifies one and only one X25 access configuration. This configuration may be referenced by fclX25AccX25AccessConfigId, fclX25InDX25AccessConfigId, fclX25InDIsdnRemX25AccConfigId or fclX25InBRemX25ConfigId. The possible values are : '0..199. If it is unused, the value of this parameter is '255'. The X25 access configuration parameters are described in : fclX25CfaDataLinkNetworkTable : data link and network levels, fclX25CfaFacilityTable : facility level, fclX25CfaNegotiatedFacilityTable : facility level (negotiaitions), fclX25CfaSignallingTable : signalling level, fclX25CfaServiceTable : services level. When creating a new configuration each parameter takes its default value. Setting a profile allows the user to fill all the parameters with values pre-defined in this profile but each one may also be individually modified.")
fclX25CfaStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaStatus.setDescription("The value of this object indicates the state of the entry of this table. The default value is 'valid'. It must be set to 'invalid' to delete the entry.")
fclX25CfaDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaDescription.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaDescription.setDescription("The value of this object stores a text description of the X25 access configuration elaborated by the user. This description may contains from 0 to 32 characters. The default value is 'Subscriber with facilities'.")
fclX25CfaProfileId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaProfileId.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaProfileId.setDescription("The value of this object is the profile number used to automatically valorize all the X25 parameters in an entry of the five tables which composes X25 access configurations (see fclX25CfaConfigId). The possible values are : 00 Public network with facilities, 01 Subscribers without facilities, 02 Subscribers with facilities, 03 PSTN, 19 PSTN VX.32 (TRANSPAC), If it is unused, the value of this parameter is '255'. The default value is '2' (meaning that default values of X25 parameters are those pre-defined in profile number 02).")
fclX25CfaModificationCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclX25CfaModificationCount.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaModificationCount.setDescription('The value of this object indicates how many X25 parameters have not the value defined in the profile specified by fclX25CfaProfileId (i.e how many individual modifications).')
fclX25CfaDataLinkNetworkTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 10), )
if mibBuilder.loadTexts: fclX25CfaDataLinkNetworkTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaDataLinkNetworkTable.setDescription('This table contains the data link and network levels parameters of X25 access configurations.')
fclX25CfaDataLinkNetworkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 10, 1), ).setIndexNames((0, "PCE-MIB", "fclX25CfaDlnConfigId"))
if mibBuilder.loadTexts: fclX25CfaDataLinkNetworkEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaDataLinkNetworkEntry.setDescription('An entry of fclX25CfaDataLinkNetworkTable.')
fclX25CfaDlnConfigId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 10, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclX25CfaDlnConfigId.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaDlnConfigId.setDescription("The value of this object identifies one and only one X25 access configuration. The possible values are : '0..199. If it is unused, the value of this parameter is '255'.")
fclX25CfaDlnStationType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dte", 1), ("dce", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaDlnStationType.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaDlnStationType.setDescription("The value of this object defines the type of the interface at the data link layer (and not at the physical layer which is defined in fcfLineType). The equipment can acts as a DTE (Data Terminal Equipment) or as a DCE (Data Circuit-terminating Equipment). The default value is 'dce'.")
fclX25CfaDlnNetworkType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 5, 9, 13, 17, 21, 25, 29, 33, 37, 41, 45, 53, 61, 65, 69, 73, 77, 93))).clone(namedValues=NamedValues(("x25", 1), ("transpac", 5), ("telenet", 9), ("tymnet", 13), ("infoSwitch", 17), ("datapac", 21), ("dn1", 25), ("pss", 29), ("germanyDatexP", 33), ("dcs", 37), ("itapac", 41), ("austpac", 45), ("uninet", 53), ("telepac", 61), ("iberpac", 65), ("datapak", 69), ("helpac", 73), ("entel", 77), ("austriaDatexP", 93)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaDlnNetworkType.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaDlnNetworkType.setDescription("The value of this parameter defines the type of the network which the equipment is working with. The authorized values are : x25, 'transpac' in France, 'telenet' in the USA, 'tymnet' in the USA, 'infoSwitch' in Canada, 'datapac' in Canada, 'dn1' in the Netherlands, 'pss' in Great Britain, 'germanyDatexP' in Germany, 'dcs' in Belgium, 'itapac' in Italy, 'austpac' in Australia, 'uninet' in the USA, 'telepac' in Switzerland, 'iberpac' in Spain, 'datapak' in Sweden, 'helpac' in Greece, 'entel' in Argentina, 'austriaDatexP' in Austria. The default value is 'transpac'.")
fclX25CfaDlnN2RetryCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 10, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 250))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaDlnN2RetryCount.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaDlnN2RetryCount.setDescription("The value of this object indicates the maximum number (N2) of attempts made by the equipment to complete the successfull transmission of a frame. The authorized values are '2..250'. The default value is '10'.")
fclX25CfaDlnT1AcknowledgeTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 10, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(200, 25000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaDlnT1AcknowledgeTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaDlnT1AcknowledgeTimer.setDescription("The value of this object indicates the period (T1), in milliseconds, at the end of which retransmission of a frame may be initiated. The authorized values are '200..25000'. The default value is '1600'.")
fclX25CfaDlnT2AcknwledgeDelayTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 10, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(100, 12700))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaDlnT2AcknwledgeDelayTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaDlnT2AcknwledgeDelayTimer.setDescription("The value of this object indicates the amount of time available (T2), in milliseconds, before the acknowledging frame must be initiated. This parameter must be smaller than T1. The authorized values are '100..12700'. The default value is '100'.")
fclX25CfaDlnKWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 10, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaDlnKWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaDlnKWindowSize.setDescription("The value of this object indicates the maximum number (K) of sequentially numbered I frames that the equipment may have outstanding (i.e.. unacknowledged) at any given time. The authorized values are '1..127'. The default value is '4'.")
fclX25CfaDlnEachPacketAcknowledgement = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 10, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaDlnEachPacketAcknowledgement.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaDlnEachPacketAcknowledgement.setDescription("The value of this object indicates whether each frame is acknowledged or not. The default value is 'off'.")
fclX25CfaDlnLowestIncomingChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 10, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaDlnLowestIncomingChannel.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaDlnLowestIncomingChannel.setDescription("The value of this object is the Lowest Incoming one-way logical Channel (LIC).The authorized values are '0..4095'. The default value is '26'.")
fclX25CfaDlnIncomingChannelCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 10, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaDlnIncomingChannelCount.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaDlnIncomingChannelCount.setDescription("The value of this object is the Number of Incoming one-way logical Channels (NIC). So the Highest Incoming one-way logical Channel (HIC) is : HIC = LIC + NIC - 1. The authorized values are '0..4096'. The default value is '0'.")
fclX25CfaDlnLowestTwoWayChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 10, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaDlnLowestTwoWayChannel.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaDlnLowestTwoWayChannel.setDescription("The value of this object is the Lowest Two-way logical Channel (LTC). The authorized values are '0..4095'. The default value is '1'.")
fclX25CfaDlnTwoWayChannelCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 10, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaDlnTwoWayChannelCount.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaDlnTwoWayChannelCount.setDescription("The value of this object is the Number of Two-way logical Channels. So the Highest Two-way logical Channel (HTC) is : HTC = LTC + NTC - 1. The authorized values are '0..4096'. The default value is '25'.")
fclX25CfaDlnLowestOutgoingChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 10, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaDlnLowestOutgoingChannel.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaDlnLowestOutgoingChannel.setDescription("The value of this object is the Lowest Outgoing one-way logical Channel (LOC). The authorized values are '0..4095'. The default value is '1'.")
fclX25CfaDlnOutgoingChannelCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 10, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaDlnOutgoingChannelCount.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaDlnOutgoingChannelCount.setDescription("The value of this object is the Number of Outgoing one-way logical Channels (NOC). So the Highest Outgoing one-way logical Channel (HOC) is : HOC = LOC + NOC - 1. The authorized values are '0..4096'. The default value is '0'.")
fclX25CfaDlnOutgoingChannelNumbering = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 10, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("decremental", 1), ("incremental", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaDlnOutgoingChannelNumbering.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaDlnOutgoingChannelNumbering.setDescription("The value of this object indicates whether the equipment searches for a logical channel from the lowest one to the highest one (incremental order) or from the highest one to the lowest one (decremental order). The default value is 'incremental'.")
fclX25CfaDlnDBitModification = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 10, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("clear", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaDlnDBitModification.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaDlnDBitModification.setDescription("The value of this object indicates how the equipment manages the D bit (Delivery Confirmation Bit). When it receives a call from a DTE wishing to receive an end-to-end acknowledgement of delivery the equipment may : ignore this D bit procedure ('off' value), ??? indicate clearing ('clear' value), ??? ('on' value), The default value is 'on'.")
fclX25CfaFacilityTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 20), )
if mibBuilder.loadTexts: fclX25CfaFacilityTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaFacilityTable.setDescription('This table contains the facility level parameters of X25 access configurations (except fast select, throughput class, packet size and window size which take place in fclX25CfaNegotiatedFacilityTable).')
fclX25CfaFacilityEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 20, 1), ).setIndexNames((0, "PCE-MIB", "fclX25CfaFacConfigId"))
if mibBuilder.loadTexts: fclX25CfaFacilityEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaFacilityEntry.setDescription('An entry of fclX25CfaFacilityTable.')
fclX25CfaFacConfigId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 20, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclX25CfaFacConfigId.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaFacConfigId.setDescription("The value of this object identifies one and only one X25 access configuration. The possible values are : '0..199. If it is unused, the value of this parameter is '255'.")
fclX25CfaFacClosedUserGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 20, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 1, 3, 4))).clone(namedValues=NamedValues(("noCheck", 2), ("clear", 1), ("subscribe", 3), ("subscribeAndRemove", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaFacClosedUserGroup.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaFacClosedUserGroup.setDescription("The value of this object specifies the behaviour of the equipment with respect to the Closed User Group (CUG) facility. There are 4 possible values : noCheck : the CUG is not checked, clear : clearing if the CUG is present in a call packet from a subscriber, subscribe : clearing if the CUG is not present in a call packet from a subcriber, subscribeAndRemove : clearing if the CUG is not present in a call packet from a subcriber, suppression of the CUG in a call packet to a subcriber. The default value is 'noCheck'.")
fclX25CfaFacReverseCharging = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 20, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("refuse", 1), ("accept", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaFacReverseCharging.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaFacReverseCharging.setDescription("The value of this object specifies the behaviour of the equipment with respect to the reverse charging facility. If the called subscriber doesn't accept the reverse charging, the call is not transmitted and a clear is sent. The default value is 'refuse'.")
fclX25CfaFacTransitDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 20, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 2))).clone(namedValues=NamedValues(("noCheck", 1), ("clear", 3), ("subscribe", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaFacTransitDelay.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaFacTransitDelay.setDescription("The value of this object specifies the behaviour of the equipment with respect to the transit delay facility. The authorized values are : noCheck : no checking clear : clearing subscribe : according to the following table : ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ | packet |from network|from subscriber| |~~~~~~~~~~~~~~|~~~~~~~~~~~~|~~~~~~~~~~~~~~~| | call |no checking | no checking | |~~~~~~~~~~~~~~|~~~~~~~~~~~~|~~~~~~~~~~~~~~~| |call connected|no checking | clearing (2) | |~~~~~~~~~~~~~~|~~~~~~~~~~~~|~~~~~~~~~~~~~~~| | clear |clearing (1)| clearing (2) | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ (1) : diagnostic = 05 41 (2) : diagnostic to local equipment = 03 41, diagnostic to remote equipment = 03 41 The default value is 'noCheck'.")
fclX25CfaFacOutputMarkers = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 20, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noCheck", 1), ("check", 2), ("remove", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaFacOutputMarkers.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaFacOutputMarkers.setDescription("The value of this object specifies the behaviour of the equipment with respect to the outgoing facility markers. The authorized values are : noCheck : no checking, remove : the markers are not transmitted, check : according to the following table : ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ | packet | facility marker | | |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ | | 0000 (1) | 00FF (2) | 000F (3) | |~~~~~~~~~|~~~~~~~~~~~~|~~~~~~~~~~~~|~~~~~~~~~~~| | call |no checking |clearing (5)|no checking| |~~~~~~~~~|~~~~~~~~~~~~|~~~~~~~~~~~~|~~~~~~~~~~~| | call | | | | |connected|clearing (4)|no checking |no checking| |~~~~~~~~~|~~~~~~~~~~~~|~~~~~~~~~~~~|~~~~~~~~~~~| | clear | - | - |no checking| ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ (1) : registration codes, non-x25 facilities provided by the network in case of intranetwork calls, non-x25 facilities provided by the network to which the calling DTE is connected in case of internetwork calls (2) : non-x25 facilities provided by the network to which the calling DTE is connected in case of intranetwork calls (3) : CCITT-specified DTE facilities (4) : diagnostic to local equipment = 03 42, diagnostic to remote equipment = 11 42 (5) : diagnostic to local equipment = 03 42 The default value is 'noCheck'.")
fclX25CfaFacInputMarkers = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 20, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noCheck", 1), ("check", 2), ("remove", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaFacInputMarkers.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaFacInputMarkers.setDescription('Marqueurs en reception')
fclX25CfaFacOutputUnknownFacility = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 20, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 2))).clone(namedValues=NamedValues(("noCheck", 1), ("clear", 3), ("remove", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaFacOutputUnknownFacility.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaFacOutputUnknownFacility.setDescription("The value of this object specifies the behaviour of the equipment with respect to an outgoing unknown facility. The authorized values are : noCheck : no checking, remove : the unknown facility is not sent, clear : clearing. The default value is 'noCheck'.")
fclX25CfaFacInputUnknownFacility = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 20, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 2))).clone(namedValues=NamedValues(("noCheck", 1), ("clear", 3), ("remove", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaFacInputUnknownFacility.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaFacInputUnknownFacility.setDescription("The value of this object specifies the behaviour of the equipment with respect to an incoming unknown facility. The authorized values are : noCheck : no checking, remove : the unknown facility is not sent, clear : clearing. The default value is 'noCheck'.")
fclX25CfaNegotiatedFacilityTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 21), )
if mibBuilder.loadTexts: fclX25CfaNegotiatedFacilityTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaNegotiatedFacilityTable.setDescription('This table contains the facility level parameters of X25 access configurations (except closed user group, reverse charging, transit delay, markers, unknown facility which take place in fclX25CfaFacilityTable).')
fclX25CfaNegotiatedFacilityEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 21, 1), ).setIndexNames((0, "PCE-MIB", "fclX25CfaNegConfigId"))
if mibBuilder.loadTexts: fclX25CfaNegotiatedFacilityEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaNegotiatedFacilityEntry.setDescription('An entry of fclX25CfaNegotiatedFacilityTable.')
fclX25CfaNegConfigId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 21, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclX25CfaNegConfigId.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaNegConfigId.setDescription("The value of this object identifies one and only one X25 access configuration. The possible values are : '0..199. If it is unused, the value of this parameter is '255'.")
fclX25CfaNegOutputFastSelect = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 21, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 1, 2))).clone(namedValues=NamedValues(("noCheck", 3), ("clear", 1), ("subscribe", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaNegOutputFastSelect.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaNegOutputFastSelect.setDescription("The value of this object specifies the behaviour of the equipment with respect to the fast select facility in outgoing call. The authorized values are 'noCheck' (no checking), 'clear' (clearing), 'subscribe'. The default value is 'noCheck'.")
fclX25CfaNegInputFastSelect = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 21, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 4))).clone(namedValues=NamedValues(("subscribe", 2), ("longUserData", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaNegInputFastSelect.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaNegInputFastSelect.setDescription("The value of this object is the maximum size of the call user data field in a received call request packet not containing the fast select facility. The authorized values are 'subscribe' (up to 16 bytes) or 'longUserData' (up to 128 bytes). The default value is 'subscribe'.")
fclX25CfaNegThroughputClass = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 21, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clear", 1), ("subscribe", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaNegThroughputClass.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaNegThroughputClass.setDescription("The value of this object indicates whether the subscriber connected to the link has subscribed to throughput class negociation facility or not. The authorized values are 'clear' (not subscriber) or 'subscribe'. The default value is 'subscribe'.")
fclX25CfaNegDefOutThroughputClass = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 21, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("t75", 3), ("t150", 4), ("t300", 5), ("t600", 6), ("t1200", 7), ("t2400", 8), ("t4800", 9), ("t9600", 10), ("t19200", 11), ("t48000", 12), ("t64000", 13), ("t128000", 14), ("t192000", 15)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaNegDefOutThroughputClass.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaNegDefOutThroughputClass.setDescription('The value of this object indicates the default throughput class in transmit direction (equipment to remote peer). The default value is 4800 bits per second.')
fclX25CfaNegDefInThroughputClass = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 21, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("t75", 3), ("t150", 4), ("t300", 5), ("t600", 6), ("t1200", 7), ("t2400", 8), ("t4800", 9), ("t9600", 10), ("t19200", 11), ("t48000", 12), ("t64000", 13), ("t128000", 14), ("t192000", 15)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaNegDefInThroughputClass.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaNegDefInThroughputClass.setDescription('The value of this object indicates the default throughput class in receive direction (remote peer to equipment). The default value is 4800 bits per second.')
fclX25CfaNegMaxOutThroughputClass = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 21, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("t75", 3), ("t150", 4), ("t300", 5), ("t600", 6), ("t1200", 7), ("t2400", 8), ("t4800", 9), ("t9600", 10), ("t19200", 11), ("t48000", 12), ("t64000", 13), ("t128000", 14), ("t192000", 15)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaNegMaxOutThroughputClass.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaNegMaxOutThroughputClass.setDescription('The value of this object indicates the maximum throughput class in transmit direction (equipment to remote peer). The default value is 4800 bits per second.')
fclX25CfaNegMaxInThroughputClass = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 21, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("t75", 3), ("t150", 4), ("t300", 5), ("t600", 6), ("t1200", 7), ("t2400", 8), ("t4800", 9), ("t9600", 10), ("t19200", 11), ("t48000", 12), ("t64000", 13), ("t128000", 14), ("t192000", 15)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaNegMaxInThroughputClass.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaNegMaxInThroughputClass.setDescription('The value of this object indicates the maximum throughput class in receive direction (equipment to remote peer). The default value is 4800 bits per second.')
fclX25CfaNegPacketSize = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 21, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clear", 1), ("subscribe", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaNegPacketSize.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaNegPacketSize.setDescription("The value of this object indicates whether the subscriber connected to the link has subscribed to packet size negociation facility or not. The authorized values are 'clear' (not subscriber) or 'subscribe'. The default value is 'subscribe'.")
fclX25CfaNegDefOutPacketSize = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 21, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("s16", 4), ("s32", 5), ("s64", 6), ("s128", 7), ("s256", 8), ("s512", 9), ("s1024", 10), ("s2048", 11), ("s4096", 12), ("s8192", 13)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaNegDefOutPacketSize.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaNegDefOutPacketSize.setDescription('The value of this object indicates the default packet size in transmit direction (equipment to remote peer). The default value is 128 octets.')
fclX25CfaNegDefInPacketSize = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 21, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("s16", 4), ("s32", 5), ("s64", 6), ("s128", 7), ("s256", 8), ("s512", 9), ("s1024", 10), ("s2048", 11), ("s4096", 12), ("s8192", 13)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaNegDefInPacketSize.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaNegDefInPacketSize.setDescription('The value of this object indicates the default packet size in receive direction (remote peer to equipment). The default value is 128 octets.')
fclX25CfaNegMaxOutPacketSize = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 21, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("s16", 4), ("s32", 5), ("s64", 6), ("s128", 7), ("s256", 8), ("s512", 9), ("s1024", 10), ("s2048", 11), ("s4096", 12), ("s8192", 13)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaNegMaxOutPacketSize.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaNegMaxOutPacketSize.setDescription('The value of this object indicates the maximum packet size in transmit direction (equipment to remote peer). The default value is 256 octets.')
fclX25CfaNegMaxInPacketSize = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 21, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("s16", 4), ("s32", 5), ("s64", 6), ("s128", 7), ("s256", 8), ("s512", 9), ("s1024", 10), ("s2048", 11), ("s4096", 12), ("s8192", 13)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaNegMaxInPacketSize.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaNegMaxInPacketSize.setDescription('The value of this object indicates the maximum packet size in receive direction (remote peer to equipment). The default value is 256 octets.')
fclX25CfaNegMinOutPacketSize = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 21, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("s16", 4), ("s32", 5), ("s64", 6), ("s128", 7), ("s256", 8), ("s512", 9), ("s1024", 10), ("s2048", 11), ("s4096", 12), ("s8192", 13)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaNegMinOutPacketSize.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaNegMinOutPacketSize.setDescription('The value of this object indicates the minimum packet size in transmit direction (equipment to remote peer). The default value is 32 octets.')
fclX25CfaNegMinInPacketSize = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 21, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("s16", 4), ("s32", 5), ("s64", 6), ("s128", 7), ("s256", 8), ("s512", 9), ("s1024", 10), ("s2048", 11), ("s4096", 12), ("s8192", 13)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaNegMinInPacketSize.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaNegMinInPacketSize.setDescription('The value of this object indicates the minimum packet size in receive direction (remote peer to equipment). The default value is 32 octets.')
fclX25CfaNegWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 21, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clear", 1), ("subscribe", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaNegWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaNegWindowSize.setDescription("The value of this object indicates whether the subscriber connected to the link has subscribed to the negociation of the transmit window size facility or not. The authorized values are 'clear' (not subscriber) or 'subscribe'. The default value is 'subscribe'.")
fclX25CfaNegDefOutWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 21, 1, 31), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaNegDefOutWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaNegDefOutWindowSize.setDescription("The value of this object indicates the default window size in transmit direction (equipment to remote peer). The authorized values are '1..7'. The default value is '2'.")
fclX25CfaNegDefInWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 21, 1, 32), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaNegDefInWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaNegDefInWindowSize.setDescription("The value of this object indicates the default window size in receive direction (remote peer to equipment). The authorized values are '1..7'. The default value is '4'.")
fclX25CfaNegMaxOutWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 21, 1, 33), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaNegMaxOutWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaNegMaxOutWindowSize.setDescription("The value of this object indicates the maximum window size in transmit direction (equipment to remote peer). The authorized values are '1..7'. The default value is '4'.")
fclX25CfaNegMaxInWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 21, 1, 34), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaNegMaxInWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaNegMaxInWindowSize.setDescription("The value of this object indicates the maximum window size in receive direction (remote peer to equipment). The authorized values are '1..7'. The default value is '4'.")
fclX25CfaSignallingTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 30), )
if mibBuilder.loadTexts: fclX25CfaSignallingTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaSignallingTable.setDescription('This table contains the signalling level parameters of X25 access configurations.')
fclX25CfaSignallingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 30, 1), ).setIndexNames((0, "PCE-MIB", "fclX25CfaSigConfigId"))
if mibBuilder.loadTexts: fclX25CfaSignallingEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaSignallingEntry.setDescription('An entry of fclX25CfaSignallingTable.')
fclX25CfaSigConfigId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 30, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclX25CfaSigConfigId.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaSigConfigId.setDescription("The value of this object identifies one and only one X25 access configuration. The possible values are : '0..199. If it is unused, the value of this parameter is '255'.")
fclX25CfaSigType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 30, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("x25Network", 1), ("x25Subscriber", 2), ("x75", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaSigType.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaSigType.setDescription("The value of this object defines the signalling processing behaviour over the connected line. The authorized values are 'x25Network', 'x25Subscriber', 'x75'. The default value is 'x25Subscriber'.")
fclX25CfaSigPacketAddressCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 30, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaSigPacketAddressCount.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaSigPacketAddressCount.setDescription("The value of this object is the number of addresses in call request packets sent or received. The authorized values are '1..2'. The '1' value indicates that one of two addressing fields (calling address for packets from subscriber, called address for packets to subscriber) contains only the suffix (after DNIC ZO AB). The '2' value indicates that both addressing fields of each of the two types of call request packet (calling, called) contain the complete addresses. If fclX25CfaSigType is set to 'x25Network', the value of this object must be '2'. The default value is '1'.")
fclX25CfaSigSubAddressTransmission = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 30, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaSigSubAddressTransmission.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaSigSubAddressTransmission.setDescription("The value of this object indicates whether the sub-address of the called address field of the call request packet received on a PDNL (Public Data Network Link) is retransmitted on the outgoing line or not. The default value is 'off'.")
fclX25CfaSigPdnIndicator = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 30, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 5, 3, 4))).clone(namedValues=NamedValues(("off", 1), ("pdnWithoutAddressTransmission", 2), ("pdnWithAddressTransmission", 5), ("dedicatedLaPoste", 3), ("dedicatedTranspac", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaSigPdnIndicator.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaSigPdnIndicator.setDescription("The value of this object specifies the behaviour of the equipment with respect to a PDNL (Public Data Network Link). The authorized values are : off : it is not a PDNL, pdnWithoutAddressTransmission : for a PDNL with address transport, pdnWithAddressTransmission : for a PDNL with address packing, dedicatedLaPoste : for Muse network, dedicatedTranspac : for Transpac network. The default value is 'off'.")
fclX25CfaSigConversionAimedPoint = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 30, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaSigConversionAimedPoint.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaSigConversionAimedPoint.setDescription("The value of this object indicates whether the 'aimed point' address conversion is enabled or not. This conversion consists in making the routing process work not with the called address from the call packet but with a substituted address according to the address conversion table (see fcwAddrConvIncomingCallTable). Therefore this reduces the number of entries of the routing tables if several called addresses are converted to same 'aimed point' address. The default value is 'off'.")
fclX25CfaSigConversionIncomingCall = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 30, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("off", 1), ("callingAddress", 2), ("calledAddress", 3), ("callingAddressAndCalledAddress", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaSigConversionIncomingCall.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaSigConversionIncomingCall.setDescription("The value of this object indicates which address field are converted on an incoming call. The authorized values are : off : no address field conversion, callingAddress : conversion of the calling address field according to the contains of fcwAddrConvIncomingCallTable, calledAddress : conversion of the called address field according to the contains of fcwAddrConvIncomingCallTable, callingAddressAndCalledAddress : conversion of the calling and called address fields according to the contains of fcwAddrConvIncomingCallTable. The default value is 'off'.")
fclX25CfaSigConversionOutgoingCall = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 30, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("off", 1), ("callingAddress", 2), ("calledAddress", 3), ("callingAddressAndCalledAddress", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaSigConversionOutgoingCall.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaSigConversionOutgoingCall.setDescription("The value of this object indicates which address field are converted on an outgoing call. The authorized values are : off : no address field conversion, callingAddress : conversion of the calling address field according to the contains of fcwAddrConvOutgoingCallTable, calledAddress : conversion of the called address field according to the contains of fcwAddrConvOutgoingCallTable, callingAddressAndCalledAddress : conversion of the calling and called address fields according to the contains of fcwAddrConvOutgoingCallTable. The default value is 'off'.")
fclX25CfaSigConversionAddressCheck = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 30, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("off", 1), ("onIncomingCall", 2), ("onOutgoingCall", 3), ("onIncomingCallAndOutgoingCall", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaSigConversionAddressCheck.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaSigConversionAddressCheck.setDescription("The value of this object indicates the behaviour of the equipment when a requested address conversion can not be made because the address is not found in the address conversion tables (fcwAddrConvIncomingCallTable or fcwAddrConvOutgoingCallTable). In this case the call will be cleared when 'checking' is enabled. The authorized values are : off : no checking, onIncomingCall : checking on incoming calls, onOutgoingCall : checking on outgoing calls, onIcomingCallAndOutgoingCall : checking on incoming and outgoing calls. The default value is 'off'.")
fclX25CfaSigConvMultiCalledAddrInCall = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 30, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaSigConvMultiCalledAddrInCall.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaSigConvMultiCalledAddrInCall.setDescription("Numero d'identification pour conversion d'adresse d'appele multi-criteres en entree")
fclX25CfaSigConvMultiCallingAddrInCall = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 30, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaSigConvMultiCallingAddrInCall.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaSigConvMultiCallingAddrInCall.setDescription("Numero d'identification pour conversion d'adresse d'appelant multi-criteres en entree")
fclX25CfaSigConvMultiCalledAddrOutCall = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 30, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaSigConvMultiCalledAddrOutCall.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaSigConvMultiCalledAddrOutCall.setDescription("Numero d'identification pour conversion d'adresse d'appele multi-criteres en sortie")
fclX25CfaSigConvMultiCallingAddrOutCall = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 30, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaSigConvMultiCallingAddrOutCall.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaSigConvMultiCallingAddrOutCall.setDescription("Numero d'identification pour conversion d'adresse d'appelant multi-criteres en sortie")
fclX25CfaSigOutPacketCauseField = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 30, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noModify", 1), ("setToZero", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaSigOutPacketCauseField.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaSigOutPacketCauseField.setDescription("The value of this object describes which operation the equipment makes on the cause field of reset, clear, and restart request and indication outgoing packets. The authorized values are : noModify : no operation, setToZero : the cause field is set to 0 (meaning 'DTE originated'). The default value is 'noModify'.")
fclX25CfaSigInPacketCauseField = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 30, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("noModify", 1), ("setToZero", 2), ("setToZeroIfLowerThan128", 3), ("modify", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaSigInPacketCauseField.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaSigInPacketCauseField.setDescription("The value of this object describes which operation the equipment makes on the cause field of reset, clear, and restart request and indication incoming packets. The authorized values are : noModify : no operation, setToZero : the cause field is set to 'DTE originated'. setToZeroIfLowerThan128 : the cause field is set to 'DTE originated' only if the bit 8 is 0 (i.e. if the bits 7 to 1 are those included by the remote DTE). modify : if the cause field is 'Invalid facility request' or 'Local procedure error' then it is changed to 'Network congestion' else no operation. The default value is 'noModify'.")
fclX25CfaSigT11CallResponseTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 30, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 2500))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaSigT11CallResponseTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaSigT11CallResponseTimer.setDescription("The value of this object is the maximum time (in seconds) the equipment will wait for a response to a call request packet sent on the link. A clear packet is sent if there is no response after this time. The authorized values are '10..2500' by step of 10. The default value is '200'.")
fclX25CfaSigCallAcceptedFormat = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 30, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 2, 4, 1))).clone(namedValues=NamedValues(("noFacilitiesNoAddresses", 3), ("facilitiesNoAddresses", 2), ("facilitiesNotCheckedAddresses", 4), ("facilitiesCheckedAddresses", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaSigCallAcceptedFormat.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaSigCallAcceptedFormat.setDescription("The value of this object defines the format of an outgoing call connected packet. The authorized values are : noFacilitiesNoAddresses : no facility length and facility fields, calling and called DTE address lengths set to 0, facilitiesNoAddresses : facility length and facility fields, calling and called DTE address lengths set to 0, facilitiesNoCheckedAdresses : facility length and facility fields, calling and called DTE address lengths different from 0, addresses are not checked (???), facilitiesCheckedAddresses : facility length and facility fields, calling and called DTE address lengths different from 0, addresses are checked (???), The default value is 'noFacilitiesNoAddresses'.")
fclX25CfaSigClearFormat = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 30, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 2, 4, 1))).clone(namedValues=NamedValues(("noFacilitiesNoAddresses", 3), ("facilitiesNoAddresses", 2), ("facilitiesNotCheckedAddresses", 4), ("facilitiesCheckedAddresses", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaSigClearFormat.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaSigClearFormat.setDescription("The value of this object defines the format of an outgoing call connected packet. The authorized values are : noFacilitiesNoAddresses : no facility length and facility fields, calling and called DTE address lengths set to 0, facilitiesNoAddresses : facility length and facility fields, calling and called DTE address lengths set to 0, facilitiesNoCheckedAdresses : facility length and facility fields, calling and called DTE address lengths different from 0, addresses are not checked (???), facilitiesCheckedAddresses : facility length and facility fields, calling and called DTE address lengths different from 0, addresses are checked (???), The default value is 'noFacilitiesNoAddresses'.")
fclX25CfaServiceTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 40), )
if mibBuilder.loadTexts: fclX25CfaServiceTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaServiceTable.setDescription('This table contains the services level parameters of X25 access configurations.')
fclX25CfaServiceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 40, 1), ).setIndexNames((0, "PCE-MIB", "fclX25CfaSerConfigId"))
if mibBuilder.loadTexts: fclX25CfaServiceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaServiceEntry.setDescription('An entry of fclX25CfaServiceTable.')
fclX25CfaSerConfigId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 40, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclX25CfaSerConfigId.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaSerConfigId.setDescription("The value of this object identifies one and only one X25 access configuration. The possible values are : '0..199. If it is unused, the value of this parameter is '255'.")
fclX25CfaSerReliableVc = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 40, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 2, 4))).clone(namedValues=NamedValues(("off", 1), ("clear", 3), ("subscribe", 2), ("check", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaSerReliableVc.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaSerReliableVc.setDescription("The value of this object is used to enable the Reliable Virtual Circuit service. The authorized values are : off : no RVC, the VCs are considered as normal VCs, no particular processing, clear : RVCs are not allowed for the subscriber, each attempt to establish a RVC provokes a clear of the connection, subscribe : all calls transmitted by the subscriber establish RVCs, it is also possible to receive calls with RVC option, check : for a link to a subscriber : when a call with RVC option is received, a RVC is established for a link to a network : the RVC option is ignored when it is present in a call sent by a local subscriber, the connection is cleared when the RVC option is present in a call sent by the network. The default value is 'off'.")
fclX25CfaSerCharging = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 40, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("overall", 2), ("detailed", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaSerCharging.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaSerCharging.setDescription("The value of this object is used to enable the charging service. The authorized values are : off : no charging, overall : charging (a charging ticket is made of informations from all the lines of the equipment), detailed : charging (a charging ticket is made of informations from one virtual circuit), The default value is 'off'.")
fclX25CfaSerX29Reselection = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 40, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaSerX29Reselection.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaSerX29Reselection.setDescription("The value of this object indicates whether the subscriber connected to the link has subscribed to X29 reselection or not. The default value is 'off'.")
fclX25CfaSerRemoteExclusiveLink = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 40, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaSerRemoteExclusiveLink.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaSerRemoteExclusiveLink.setDescription("The value of this object indicates whether this link is the only way to join the facing equipment (exclusive link = yes, the equipment answers to a call packet with a clear packet) or there is another way to join it (exclusive link = no, the equipment answers to a call packet with a 'call return' packet, to make the previous equipments search for another route). The default value is 'off'.")
fclX25CfaSerStatLoadAndTraffic = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 40, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaSerStatLoadAndTraffic.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaSerStatLoadAndTraffic.setDescription("The value of this object indicates whether, for this link, the load and traffic informations recording of the statistics management function is enabled or not. The default value is 'off'.")
fclX25CfaSerStatSignalling = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 40, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaSerStatSignalling.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaSerStatSignalling.setDescription("The value of this object indicates whether, for this link, the signalling informations recording of the statistics management function is enabled or not. The default value is 'off'.")
fclX25CfaSerStatTotalizer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 40, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaSerStatTotalizer.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaSerStatTotalizer.setDescription("The value of this object indicates whether, for this link, the frames counting informations recording of the statistics management function is enabled or not. The default value is 'off'.")
fclX25CfaSerStatCompression = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 40, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaSerStatCompression.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaSerStatCompression.setDescription("The value of this object indicates whether, for this link, the compression informations recording of the statistics management function is enabled or not. The default value is 'off'.")
fclX25CfaSerCompression = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 40, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("off", 1), ("networkToSubscriber", 2), ("subscriberToNetwork", 3), ("bothway", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaSerCompression.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaSerCompression.setDescription("The value of this object indicates the compression enabling for each direction. The authorized values are : off : no compression, networkToSubscriber : compression of the flow from the remote peer to the equipment, subscriberToNetwork : compression of the flow from the equipment to the remote peer, bothway : compression of the two flows from and to the equipment. The default value is 'off'.")
fclX25CfaSerCompressNegotiation = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 40, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("onOptionalCompression", 2), ("onMandatoryCompression", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaSerCompressNegotiation.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaSerCompressNegotiation.setDescription("The value of this object indicates whether the compression facility is negociated or not and, if negociated, the optional/obligatory status. The authorized values are : off' :no negociation, onOptionalCompression : negociation but compression is optional, onMandatoryCompression : negociation and compression is mandatory. The default value is 'off'.")
fclX25CfaSerCompressScrambling = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 40, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaSerCompressScrambling.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaSerCompressScrambling.setDescription("The value of this object indicates, when the compression is active, whether the scrambling is enabled or not. The default value is 'off'.")
fclX25CfaSerCompressMultiPacketsTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 40, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1500))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaSerCompressMultiPacketsTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaSerCompressMultiPacketsTimer.setDescription("The value of this object defines the maximum waiting time, in milliseconds by steps of 100 milliseconds , which, if there is not another packet to compress, the packet of compressed packets is sent beyond (this permits to reduce the number of packets transmitted to the remote peer). The authorized values are '0..1500'. '0' means no packets grouping (i. e. : each packet is individually compressed and sent). The default value is '0'.")
fclX25CfaSerCos = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 40, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 1))).clone(namedValues=NamedValues(("ubr", 3), ("vbr", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaSerCos.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaSerCos.setDescription('COS')
fclX25CfaSerCir = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 40, 1, 31), Integer32().subtype(subtypeSpec=ValueRangeConstraint(600, 2048000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaSerCir.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaSerCir.setDescription('Entrant CIR')
fclX25CfaSerMinCir = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 40, 1, 32), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaSerMinCir.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaSerMinCir.setDescription('Entrant CIR mini')
fclX25CfaSerBe = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 40, 1, 33), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaSerBe.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaSerBe.setDescription('Entrant BE')
fclX25CfaPackingAddresses = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 50))
fclX25CfaPackOutSubAddressCheck = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 50, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaPackOutSubAddressCheck.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaPackOutSubAddressCheck.setDescription("The value of this object indicates whether the packing mechanism (see fclX25CfaPackingTable) is enabled for the outgoing call packets or not. The default value is 'on'.")
fclX25CfaPackOutSubAddressSize = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 50, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaPackOutSubAddressSize.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaPackOutSubAddressSize.setDescription("The value of this object defines the length of the substituted sub-address used by the packing mechanism (see fclX25CfaPackSubAddress). The authorized values are '1..4'. The default value is '2'.")
fclX25CfaPackPdnCallingSubAddress = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 50, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("pack", 1), ("remove", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaPackPdnCallingSubAddress.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaPackPdnCallingSubAddress.setDescription("The value of this object indicates, when using the packing mechanism, whether the calling address is packed or is removed (i.e. there is no calling sub-address). The default value is 'remove'.")
fclX25CfaPackingTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 50, 4), )
if mibBuilder.loadTexts: fclX25CfaPackingTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaPackingTable.setDescription("This table defines the association between the ZO SB part of the DNIC ZO SB address and the substituted sub-address (i.e. the 'packed ZO SB'). This substitution is enabled on a link when fclX25CfaSigPdnIndicator is set to 'pdnWithAddressTransmission'.")
fclX25CfaPackingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 50, 4, 1), ).setIndexNames((0, "PCE-MIB", "fclX25CfaPackPrivateZoSb"))
if mibBuilder.loadTexts: fclX25CfaPackingEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaPackingEntry.setDescription('An entry of fclX25CfaPackingTable.')
fclX25CfaPackPrivateZoSb = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 50, 4, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclX25CfaPackPrivateZoSb.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaPackPrivateZoSb.setDescription("The value of this object is the ZO SB part of the DNIC ZO SB address which is replaced by the sub-address defined in fclX25CfaPackSubAddress. The value may contain up to 4 digits (digits 0..9). The value must be completed with 'F' digits for a total of 4 digits. The equipment configurator does not need final completion. The default value is 'FF FF' meaning 'empty value' (blank value on the equipment configurator).")
fclX25CfaPackStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 50, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaPackStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaPackStatus.setDescription("The value of this object indicates the state of the entry of this table. The default value is 'valid'. It must be set to 'invalid' to delete the entry.")
fclX25CfaPackSubAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 50, 4, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaPackSubAddress.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaPackSubAddress.setDescription("The value of this object is the substituted sub-address (i.e. the 'packed ZO SB') which replaces the ZO SB part of the DNIC ZO SB address defined in fclX25CfaPackPrivateZoSb. The value may contain up to 'fclX25CfaPackOutSubAddressSize' digits (digits 0..9). The value must be completed with 'F' digits for a total of 4 digits. The equipment configurator does not need final completion. The default value is 'FF FF' meaning 'empty value' (blank value on the equipment configurator).")
fclX25CfaClosedUserGroupTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 51), )
if mibBuilder.loadTexts: fclX25CfaClosedUserGroupTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaClosedUserGroupTable.setDescription("This table defines the Closed User Groups to which belong the subscribers. This table is used on a link when fclX25CfaFacClosedUserGroup is set to 'subscribe' or 'subscribeAndRemove'.")
fclX25CfaClosedUserGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 51, 1), ).setIndexNames((0, "PCE-MIB", "fclX25CfaCugLogPortId"), (0, "PCE-MIB", "fclX25CfaCugClosedUserGroupId"))
if mibBuilder.loadTexts: fclX25CfaClosedUserGroupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaClosedUserGroupEntry.setDescription('An entry of fclX25CfaClosedUserGroupTable.')
fclX25CfaCugLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 51, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclX25CfaCugLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaCugLogPortId.setDescription("The value of this object identifies one and only one access logical port. There may up to 28 CUG for only one logical port. The possible values are : '0..131'. If it is unused, the value of this parameter is '255'. The default value is '255'.")
fclX25CfaCugClosedUserGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 51, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 99))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclX25CfaCugClosedUserGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaCugClosedUserGroupId.setDescription("This value defines one CUG associated to the logical port defined in fclX25CfaCugLogPortId. The possible values are : '0..99. If it is unused, the value of this parameter is '255'. The default value is '255'.")
fclX25CfaCugStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 51, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaCugStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaCugStatus.setDescription("The value of this object indicates the state of the entry of this table. The default value is 'valid'. It must be set to 'invalid' to delete the entry.")
fclX25CfaCugChecking = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 51, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 1))).clone(namedValues=NamedValues(("onIncomingCall", 2), ("onOutgoingCall", 3), ("onIncomingCallAndOutgoingCall", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaCugChecking.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaCugChecking.setDescription("The value of this object defines on which call the equipment checks this CUG. The default values is 'onIncomingCallAndOutgoingCall'.")
fclX25CfaCugClosedUserGroupExt = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 1, 51, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 99))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfaCugClosedUserGroupExt.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfaCugClosedUserGroupExt.setDescription('GFU externe')
fclX25ConfigInterNode = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10))
fclX25ConfigInterNodeTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 1), )
if mibBuilder.loadTexts: fclX25ConfigInterNodeTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25ConfigInterNodeTable.setDescription('This table contains the X25 inter-node configurations used by X25 inter-node links.')
fclX25ConfigInterNodeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 1, 1), ).setIndexNames((0, "PCE-MIB", "fclX25CfnConfigId"))
if mibBuilder.loadTexts: fclX25ConfigInterNodeEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25ConfigInterNodeEntry.setDescription('An entry of fclX25ConfigInterNodeTable.')
fclX25CfnConfigId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclX25CfnConfigId.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfnConfigId.setDescription("The value of this object identifies one and only one X25 inter-node configuration. This configuration may be referenced by fclX25InBRemX25ConfigId, fclX25PstnX25InterNodeConfigId, fclX25SlpX25InterNodeConfigId, fclX25SlpIsdnRemX25InterNodeConfigId, fclX25SlpPstnBackX25InterNodeConfigId, fclX25MlpX25InterNodeConfigId or fclFrPvcX25InterNodeConfigId. The possible values are : '0..199. If it is unused, the value of this parameter is '255'. The X25 inter-node configuration parameters are described in : fclX25CfnaDataLinkNetworkTable : data link and network levels, fclX25CfnNegotiatedFacilityTable : facility level, fclX25CfnSignallingTable : signalling level, fclX25CfnServiceTable : services level. When creating a new configuration each parameter takes its default value. Setting a profile allows the user to fill all the parameters with values pre-defined in this profile but each one may also be individually modified.")
fclX25CfnStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfnStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfnStatus.setDescription("The value of this object indicates the state of the entry of this table. The default value is 'valid'. It must be set to 'invalid' to delete the entry.")
fclX25CfnDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfnDescription.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfnDescription.setDescription("The value of this object stores a text description of the X25 inter-node configuration elaborated by the user. This description may contains from 0 to 32 characters. The default value is 'DTE inter-node'.")
fclX25CfnProfileId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfnProfileId.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfnProfileId.setDescription("The value of this object is the profile number used to automatically valorize all the X25 parameters in an entry of the four tables which composes X25 inter-node configurations (see fclX25CfnConfigId). The possible values are : 04 DTE inter-node, 05 DCE inter-node, 20 DTE PSTN back-up auto modem, 21 DCE PSTN back-up auto modem, 24 Inter-node (TRANSPAC), 24 Inter-node (TRANSPAC), 40 DTE PSTN back-up V.25bis modem, 1 DCE PSTN back-up V.25bis modem, 74 DTE inter-node X.75 physical, 75 DCE inter-node X.75 physical, 86 DTE FR network (p transac), 87 DCE FR network (p transac), 88 DTE FR Network (no priority), 89 DCE FR Network (no priority), If it is unused, the value of this parameter is '255'. The default value is '4' (meaning that default values of X25 parameters are those pre-defined in profile number 04).")
fclX25CfnModificationCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclX25CfnModificationCount.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfnModificationCount.setDescription('The value of this object indicates how many X25 parameters have not the value defined in the profile specified by fclX25CfnProfileId (i.e how many individual modifications).')
fclX25CfnDataLinkNetworkTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 10), )
if mibBuilder.loadTexts: fclX25CfnDataLinkNetworkTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfnDataLinkNetworkTable.setDescription('This table contains the data link and network levels parameters of X25 inter-node configurations.')
fclX25CfnDataLinkNetworkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 10, 1), ).setIndexNames((0, "PCE-MIB", "fclX25CfnDlnConfigId"))
if mibBuilder.loadTexts: fclX25CfnDataLinkNetworkEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfnDataLinkNetworkEntry.setDescription('An entry of fclX25CfnDataLinkNetworkTable.')
fclX25CfnDlnConfigId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 10, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclX25CfnDlnConfigId.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfnDlnConfigId.setDescription("The value of this object identifies one and only one X25 inter-node configuration. The possible values are : '0..199. If it is unused, the value of this parameter is '255'.")
fclX25CfnDlnStationType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dte", 1), ("dce", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfnDlnStationType.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfnDlnStationType.setDescription("The value of this object defines the type of the interface at the data link layer (and not at the physical layer which is defined in fcfLineType). The equipment can acts as a DTE (Data Terminal Equipment) or as a DCE (Data Circuit-terminating Equipment). The default value is 'dce'.")
fclX25CfnDlnN2RetryCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 10, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 250))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfnDlnN2RetryCount.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfnDlnN2RetryCount.setDescription("The value of this object indicates the maximum number (N2) of attempts made by the equipment to complete the successfull transmission of a frame. The authorized values are '2..250'. The default value is '10'.")
fclX25CfnDlnT1AcknowledgeTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 10, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(200, 25000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfnDlnT1AcknowledgeTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfnDlnT1AcknowledgeTimer.setDescription("The value of this object indicates the period (T1), in milliseconds, at the end of which retransmission of a frame may be initiated. The authorized values are '200..25000'. The default value is '800'.")
fclX25CfnDlnT2AcknowledgeDelayTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 10, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(100, 12700))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfnDlnT2AcknowledgeDelayTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfnDlnT2AcknowledgeDelayTimer.setDescription("The value of this object indicates the amount of time available (T2), in milliseconds, before the acknowledging frame must be initiated. This parameter must be smaller than T1. The authorized values are '100..12700'. The default value is '400'.")
fclX25CfnDlnKWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 10, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfnDlnKWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfnDlnKWindowSize.setDescription("The value of this object indicates the maximum number (K) of sequentially numbered I frames that the equipment may have outstanding (i.e.. unacknowledged) at any given time. The authorized values are '1..127'. The default value is '7'.")
fclX25CfnDlnEachPacketAcknowledgement = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 10, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfnDlnEachPacketAcknowledgement.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfnDlnEachPacketAcknowledgement.setDescription("The value of this object indicates whether each frame is acknowledged or not. The default value is 'off'.")
fclX25CfnDlnLowestIncomingChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 10, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfnDlnLowestIncomingChannel.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfnDlnLowestIncomingChannel.setDescription("The value of this object is the Lowest Incoming one-way logical Channel (LIC).The authorized values are '0..4095'. The default value is '0'.")
fclX25CfnDlnIncomingChannelCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 10, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfnDlnIncomingChannelCount.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfnDlnIncomingChannelCount.setDescription("The value of this object is the Number of Incoming one-way logical Channels (NIC). So the Highest Incoming one-way logical Channel (HIC) is : HIC = LIC + NIC - 1. The authorized values are '0..4096'. The default value is '0'.")
fclX25CfnDlnLowestTwoWayChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 10, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfnDlnLowestTwoWayChannel.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfnDlnLowestTwoWayChannel.setDescription("The value of this object is the Lowest Two-way logical Channel (LTC). The authorized values are '0..4095'. The default value is '0'.")
fclX25CfnDlnTwoWayChannelCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 10, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfnDlnTwoWayChannelCount.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfnDlnTwoWayChannelCount.setDescription("The value of this object is the Number of Two-way logical Channels. So the Highest Two-way logical Channel (HTC) is : HTC = LTC + NTC - 1. The authorized values are '0..4096'. The default value is '20'.")
fclX25CfnDlnLowestOutgoingChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 10, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfnDlnLowestOutgoingChannel.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfnDlnLowestOutgoingChannel.setDescription("The value of this object is the Lowest Outgoing one-way logical Channel (LOC). The authorized values are '0..4095'. The default value is '20'.")
fclX25CfnDlnOutgoingChannelCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 10, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfnDlnOutgoingChannelCount.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfnDlnOutgoingChannelCount.setDescription("The value of this object is the Number of Outgoing one-way logical Channels (NOC). So the Highest Outgoing one-way logical Channel (HOC) is : HOC = LOC + NOC - 1. The authorized values are '0..4096'. The default value is '0'.")
fclX25CfnDlnOutgoingChannelNumbering = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 10, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("decremental", 1), ("incremental", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfnDlnOutgoingChannelNumbering.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfnDlnOutgoingChannelNumbering.setDescription("The value of this object indicates whether the equipment searches for a logical channel from the lowest one to the highest one (incremental order) or from the highest one to the lowest one (decremental order). The default value is 'decremental'.")
fclX25CfnDlnDBitModification = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 10, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("clear", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfnDlnDBitModification.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfnDlnDBitModification.setDescription("The value of this object indicates how the equipment manages the D bit (Delivery Confirmation Bit). When it receives a call from a DTE wishing to receive an end-to-end acknowledgement of delivery the equipment may : ignore this D bit procedure ('off' value), ??? indicate clearing ('clear' value), ??? ('on' value), The default value is 'off'.")
fclX25CfnNegotiatedFacilityTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 11), )
if mibBuilder.loadTexts: fclX25CfnNegotiatedFacilityTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfnNegotiatedFacilityTable.setDescription('This table contains the facility level parameters of X25 inter-node configurations.')
fclX25CfnNegotiatedFacilityEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 11, 1), ).setIndexNames((0, "PCE-MIB", "fclX25CfnNegConfigId"))
if mibBuilder.loadTexts: fclX25CfnNegotiatedFacilityEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfnNegotiatedFacilityEntry.setDescription('An entry of fclX25CfnNegotiatedFacilityTable.')
fclX25CfnNegConfigId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 11, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclX25CfnNegConfigId.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfnNegConfigId.setDescription("The value of this object identifies one and only one X25 inter-node configuration. The possible values are : '0..199. If it is unused, the value of this parameter is '255'.")
fclX25CfnNegOutputFastSelect = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 1, 2))).clone(namedValues=NamedValues(("noCheck", 3), ("clear", 1), ("subscribe", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfnNegOutputFastSelect.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfnNegOutputFastSelect.setDescription("The value of this object specifies the behaviour of the equipment with respect to the fast select facility in outgoing call. The authorized values are 'noCheck' (no checking), 'clear' (clearing), 'subscribe'. The default value is 'noCheck'.")
fclX25CfnNegInputFastSelect = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 11, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 4))).clone(namedValues=NamedValues(("subscribe", 2), ("longUserData", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfnNegInputFastSelect.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfnNegInputFastSelect.setDescription("The value of this object is the maximum size of the call user data field in a received call request packet not containing the fast select facility. The authorized values are 'subscribe' (up to 16 bytes) or 'longUserData' (up to 128 bytes). The default value is 'subscribe'.")
fclX25CfnNegThroughputClass = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 11, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clear", 1), ("subscribe", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfnNegThroughputClass.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfnNegThroughputClass.setDescription("The value of this object indicates whether the subscriber connected to the link has subscribed to throughput class negociation facility or not. The authorized values are 'clear' (not subscriber) or 'subscribe'. The default value is 'subscribe'.")
fclX25CfnNegDefOutThroughputClass = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 11, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("t75", 3), ("t150", 4), ("t300", 5), ("t600", 6), ("t1200", 7), ("t2400", 8), ("t4800", 9), ("t9600", 10), ("t19200", 11), ("t48000", 12), ("t64000", 13), ("t128000", 14), ("t192000", 15)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfnNegDefOutThroughputClass.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfnNegDefOutThroughputClass.setDescription('The value of this object indicates the default throughput class in transmit direction (equipment to remote peer). The default value is 9600 bits per second.')
fclX25CfnNegDefInThroughputClass = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 11, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("t75", 3), ("t150", 4), ("t300", 5), ("t600", 6), ("t1200", 7), ("t2400", 8), ("t4800", 9), ("t9600", 10), ("t19200", 11), ("t48000", 12), ("t64000", 13), ("t128000", 14), ("t192000", 15)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfnNegDefInThroughputClass.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfnNegDefInThroughputClass.setDescription('The value of this object indicates the default throughput class in receive direction (remote peer to equipment). The default value is 9600 bits per second.')
fclX25CfnNegMaxOutThroughputClass = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 11, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("t75", 3), ("t150", 4), ("t300", 5), ("t600", 6), ("t1200", 7), ("t2400", 8), ("t4800", 9), ("t9600", 10), ("t19200", 11), ("t48000", 12), ("t64000", 13), ("t128000", 14), ("t192000", 15)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfnNegMaxOutThroughputClass.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfnNegMaxOutThroughputClass.setDescription('The value of this object indicates the maximum throughput class in transmit direction (equipment to remote peer). The default value is 9600 bits per second.')
fclX25CfnNegMaxInThroughputClass = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 11, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("t75", 3), ("t150", 4), ("t300", 5), ("t600", 6), ("t1200", 7), ("t2400", 8), ("t4800", 9), ("t9600", 10), ("t19200", 11), ("t48000", 12), ("t64000", 13), ("t128000", 14), ("t192000", 15)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfnNegMaxInThroughputClass.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfnNegMaxInThroughputClass.setDescription('The value of this object indicates the maximum throughput class in receive direction (equipment to remote peer). The default value is 9600 bits per second.')
fclX25CfnNegPacketSize = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 11, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clear", 1), ("subscribe", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfnNegPacketSize.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfnNegPacketSize.setDescription("The value of this object indicates whether the subscriber connected to the link has subscribed to packet size negociation facility or not. The authorized values are 'clear' (not subscriber) or 'subscribe'. The default value is 'subscribe'.")
fclX25CfnNegDefOutPacketSize = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 11, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("s16", 4), ("s32", 5), ("s64", 6), ("s128", 7), ("s256", 8), ("s512", 9), ("s1024", 10), ("s2048", 11), ("s4096", 12), ("s8192", 13)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfnNegDefOutPacketSize.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfnNegDefOutPacketSize.setDescription('The value of this object indicates the default packet size in transmit direction (equipment to remote peer). The default value is 128 octets.')
fclX25CfnNegDefInPacketSize = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 11, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("s16", 4), ("s32", 5), ("s64", 6), ("s128", 7), ("s256", 8), ("s512", 9), ("s1024", 10), ("s2048", 11), ("s4096", 12), ("s8192", 13)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfnNegDefInPacketSize.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfnNegDefInPacketSize.setDescription('The value of this object indicates the default packet size in receive direction (remote peer to equipment). The default value is 128 octets.')
fclX25CfnNegMaxOutPacketSize = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 11, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("s16", 4), ("s32", 5), ("s64", 6), ("s128", 7), ("s256", 8), ("s512", 9), ("s1024", 10), ("s2048", 11), ("s4096", 12), ("s8192", 13)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfnNegMaxOutPacketSize.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfnNegMaxOutPacketSize.setDescription('The value of this object indicates the maximum packet size in transmit direction (equipment to remote peer). The default value is 256 octets.')
fclX25CfnNegMaxInPacketSize = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 11, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("s16", 4), ("s32", 5), ("s64", 6), ("s128", 7), ("s256", 8), ("s512", 9), ("s1024", 10), ("s2048", 11), ("s4096", 12), ("s8192", 13)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfnNegMaxInPacketSize.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfnNegMaxInPacketSize.setDescription('The value of this object indicates the maximum packet size in receive direction (remote peer to equipment). The default value is 256 octets.')
fclX25CfnNegMinOutPacketSize = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 11, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("s16", 4), ("s32", 5), ("s64", 6), ("s128", 7), ("s256", 8), ("s512", 9), ("s1024", 10), ("s2048", 11), ("s4096", 12), ("s8192", 13)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfnNegMinOutPacketSize.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfnNegMinOutPacketSize.setDescription('The value of this object indicates the minimum packet size in transmit direction (equipment to remote peer). The default value is 16 octets.')
fclX25CfnNegMinInPacketSize = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 11, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("s16", 4), ("s32", 5), ("s64", 6), ("s128", 7), ("s256", 8), ("s512", 9), ("s1024", 10), ("s2048", 11), ("s4096", 12), ("s8192", 13)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfnNegMinInPacketSize.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfnNegMinInPacketSize.setDescription('The value of this object indicates the minimum packet size in receive direction (remote peer to equipment). The default value is 16 octets.')
fclX25CfnNegWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 11, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clear", 1), ("subscribe", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfnNegWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfnNegWindowSize.setDescription("The value of this object indicates whether the subscriber connected to the link has subscribed to the negociation of the transmit window size facility or not. The authorized values are 'clear' (not subscriber) or 'subscribe'. The default value is 'subscribe'.")
fclX25CfnNegDefOutWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 11, 1, 31), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfnNegDefOutWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfnNegDefOutWindowSize.setDescription("The value of this object indicates the default window size in transmit direction (equipment to remote peer). The authorized values are '1..7'. The default value is '3'.")
fclX25CfnNegDefInWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 11, 1, 32), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfnNegDefInWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfnNegDefInWindowSize.setDescription("The value of this object indicates the default window size in receive direction (remote peer to equipment). The authorized values are '1..7'. The default value is '3'.")
fclX25CfnNegMaxOutWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 11, 1, 33), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfnNegMaxOutWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfnNegMaxOutWindowSize.setDescription("The value of this object indicates the maximum window size in transmit direction (equipment to remote peer). The authorized values are '1..7'. The default value is '4'.")
fclX25CfnNegMaxInWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 11, 1, 34), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfnNegMaxInWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfnNegMaxInWindowSize.setDescription("The value of this object indicates the maximum window size in receive direction (remote peer to equipment). The authorized values are '1..7'. The default value is '4'.")
fclX25CfnSignallingTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 30), )
if mibBuilder.loadTexts: fclX25CfnSignallingTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfnSignallingTable.setDescription('This table contains the signalling level parameters of X25 inter-node configurations.')
fclX25CfnSignallingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 30, 1), ).setIndexNames((0, "PCE-MIB", "fclX25CfnSigConfigId"))
if mibBuilder.loadTexts: fclX25CfnSignallingEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfnSignallingEntry.setDescription('An entry of fclX25CfnSignallingTable.')
fclX25CfnSigConfigId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 30, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclX25CfnSigConfigId.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfnSigConfigId.setDescription("The value of this object identifies one and only one X25 inter-node configuration. The possible values are : '0..199. If it is unused, the value of this parameter is '255'.")
fclX25CfnSigSubAddressTransmission = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 30, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfnSigSubAddressTransmission.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfnSigSubAddressTransmission.setDescription("The value of this object indicates whether the sub-address of the called address field of the call request packet received on a PDNL (Public Data Network Link) is retransmitted on the outgoing line or not. The default value is 'off'.")
fclX25CfnSigConversionAimedPoint = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 30, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfnSigConversionAimedPoint.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfnSigConversionAimedPoint.setDescription("The value of this object indicates whether the 'aimed point' address conversion is enabled or not. This conversion consists in making the routing process work not with the called address from the call packet but with a substituted address according to the address conversion table (see fcwAddrConvIncomingCallTable). Therefore this reduces the number of entries of the routing tables if several called addresses are converted to same 'aimed point' address. The default value is 'off'.")
fclX25CfnSigConversionIncomingCall = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 30, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("off", 1), ("callingAddress", 2), ("calledAddress", 3), ("callingAddressAndCalledAddress", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfnSigConversionIncomingCall.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfnSigConversionIncomingCall.setDescription("The value of this object indicates which address field are converted on an incoming call. The authorized values are : off : no address field conversion, callingAddress : conversion of the calling address field according to the contains of fcwAddrConvIncomingCallTable, calledAddress : conversion of the called address field according to the contains of fcwAddrConvIncomingCallTable, callingAddressAndCalledAddress : conversion of the calling and called address fields according to the contains of fcwAddrConvIncomingCallTable. The default value is 'off'.")
fclX25CfnSigConversionOutgoingCall = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 30, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("off", 1), ("callingAddress", 2), ("calledAddress", 3), ("callingAddressAndCalledAddress", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfnSigConversionOutgoingCall.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfnSigConversionOutgoingCall.setDescription("The value of this object indicates which address field are converted on an outgoing call. The authorized values are : off : no address field conversion, callingAddress : conversion of the calling address field according to the contains of fcwAddrConvOutgoingCallTable, calledAddress : conversion of the called address field according to the contains of fcwAddrConvOutgoingCallTable, callingAddressAndCalledAddress : conversion of the calling and called address fields according to the contains of fcwAddrConvOutgoingCallTable. The default value is 'off'.")
fclX25CfnSigConversionAddressCheck = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 30, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("off", 1), ("onIncomingCall", 2), ("onOutgoingCall", 3), ("onIncomingCallAndOutgoingCall", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfnSigConversionAddressCheck.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfnSigConversionAddressCheck.setDescription("The value of this object indicates the behaviour of the equipment when a requested address conversion can not be made because the address is not found in the address conversion tables (fcwAddrConvIncomingCallTable or fcwAddrConvOutgoingCallTable). In this case the call will be cleared when 'checking' is enabled. The authorized values are : off : no checking, onIncomingCall : checking on incoming calls, onOutgoingCall : checking on outgoing calls, onIcomingCallAndOutgoingCall : checking on incoming and outgoing calls. The default value is 'off'.")
fclX25CfnSigConvMultiCalledAddrInCall = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 30, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfnSigConvMultiCalledAddrInCall.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfnSigConvMultiCalledAddrInCall.setDescription("Numero d'identification pour conversion d'adresse d'appele multi-criteres en entree")
fclX25CfnSigConvMultiCallingAddrInCall = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 30, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfnSigConvMultiCallingAddrInCall.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfnSigConvMultiCallingAddrInCall.setDescription("Numero d'identification pour conversion d'adresse d'appelant multi-criteres en entree")
fclX25CfnSigConvMultiCalledAddrOutCall = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 30, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfnSigConvMultiCalledAddrOutCall.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfnSigConvMultiCalledAddrOutCall.setDescription("Numero d'identification pour conversion d'adresse d'appele multi-criteres en sortie")
fclX25CfnSigConvMultiCallingAddrOutCall = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 30, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfnSigConvMultiCallingAddrOutCall.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfnSigConvMultiCallingAddrOutCall.setDescription("Numero d'identification pour conversion d'adresse d'appelant multi-criteres en sortie")
fclX25CfnSigT11CallResponseTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 30, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 2500))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfnSigT11CallResponseTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfnSigT11CallResponseTimer.setDescription("The value of this object is the maximum time (in seconds) the equipment will wait for a response to a call request packet sent on the link. A clear packet is sent if there is no response after this time. The authorized values are '10..2500' by step of 10. The default value is '200'.")
fclX25CfnSigCallAcceptedFormat = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 30, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 2, 4, 1))).clone(namedValues=NamedValues(("noFacilitiesNoAddresses", 3), ("facilitiesNoAddresses", 2), ("facilitiesNotCheckedAddresses", 4), ("facilitiesCheckedAddresses", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfnSigCallAcceptedFormat.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfnSigCallAcceptedFormat.setDescription("The value of this object defines the format of an outgoing call connected packet. The authorized values are : noFacilitiesNoAddresses : no facility length and facility fields, calling and called DTE address lengths set to 0, facilitiesNoAddresses : facility length and facility fields, calling and called DTE address lengths set to 0, facilitiesNoCheckedAdresses : facility length and facility fields, calling and called DTE address lengths different from 0, addresses are not checked (???), facilitiesCheckedAddresses : facility length and facility fields, calling and called DTE address lengths different from 0, addresses are checked (???), The default value is 'noFacilitiesNoAddresses'.")
fclX25CfnServiceTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 40), )
if mibBuilder.loadTexts: fclX25CfnServiceTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfnServiceTable.setDescription('This table contains the services level parameters of X25 inter-node configurations.')
fclX25CfnServiceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 40, 1), ).setIndexNames((0, "PCE-MIB", "fclX25CfnSerConfigId"))
if mibBuilder.loadTexts: fclX25CfnServiceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfnServiceEntry.setDescription('An entry of fclX25CfnServiceTable.')
fclX25CfnSerConfigId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 40, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclX25CfnSerConfigId.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfnSerConfigId.setDescription("The value of this object identifies one and only one X25 inter-node configuration. The possible values are : '0..199. If it is unused, the value of this parameter is '255'.")
fclX25CfnSerReliableVc = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 40, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 2, 4))).clone(namedValues=NamedValues(("off", 1), ("clear", 3), ("subscribe", 2), ("check", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfnSerReliableVc.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfnSerReliableVc.setDescription("The value of this object is used to enable the Reliable Virtual Circuit service. The authorized values are : off : no RVC, the VCs are considered as normal VCs, no particular processing, clear : RVCs are not allowed for the subscriber, each attempt to establish a RVC provokes a clear of the connection, subscribe : all calls transmitted by the subscriber establish RVCs, it is also possible to receive calls with RVC option, check : for a link to a subscriber : when a call with RVC option is received, a RVC is established for a link to a network : the RVC option is ignored when it is present in a call sent by a local subscriber, the connection is cleared when the RVC option is present in a call sent by the network. The default value is 'off'.")
fclX25CfnSerCharging = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 40, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("overall", 2), ("detailed", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfnSerCharging.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfnSerCharging.setDescription("The value of this object is used to enable the charging service. The authorized values are : off : no charging, overall : charging (a charging ticket is made of informations from all the lines of the equipment), detailed : charging (a charging ticket is made of informations from one virtual circuit), The default value is 'off'.")
fclX25CfnSerX29Reselection = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 40, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfnSerX29Reselection.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfnSerX29Reselection.setDescription("The value of this object indicates whether the subscriber connected to the link has subscribed to X29 reselection or not. The default value is 'off'.")
fclX25CfnSerRemoteExclusiveLink = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 40, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfnSerRemoteExclusiveLink.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfnSerRemoteExclusiveLink.setDescription("The value of this object indicates whether this link is the only way to join the facing equipment (exclusive link = yes, the equipment answers to a call packet with a clear packet) or there is another way to join it (exclusive link = no, the equipment answers to a call packet with a 'call return' packet, to make the previous equipments search for another route). The default value is 'off'.")
fclX25CfnSerCallReturnTransmission = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 40, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3))).clone(namedValues=NamedValues(("off", 1), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfnSerCallReturnTransmission.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfnSerCallReturnTransmission.setDescription("The value of this object indicates whether the 'call return' packet may be sent on this link or not. The 'call return' packet, sent to the previous equipment, makes this equipments search for another route to join the called DTE. The defaut value is 'on'.")
fclX25CfnSerStatLoadAndTraffic = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 40, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfnSerStatLoadAndTraffic.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfnSerStatLoadAndTraffic.setDescription("The value of this object indicates whether, for this link, the load and traffic informations recording of the statistics management function is enabled or not. The default value is 'off'.")
fclX25CfnSerStatSignalling = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 40, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfnSerStatSignalling.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfnSerStatSignalling.setDescription("The value of this object indicates whether, for this link, the signalling informations recording of the statistics management function is enabled or not. The default value is 'off'.")
fclX25CfnSerStatTotalizer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 40, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfnSerStatTotalizer.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfnSerStatTotalizer.setDescription("The value of this object indicates whether, for this link, the frames counting informations recording of the statistics management function is enabled or not. The default value is 'off'.")
fclX25CfnSerStatCompression = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 10, 40, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfnSerStatCompression.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfnSerStatCompression.setDescription("The value of this object indicates whether, for this link, the compression informations recording of the statistics management function is enabled or not. The default value is 'off'.")
fclX25ConfigMiscellaneous = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 30))
fclX25CfmDiagnosticCodeField = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 30, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 1, 3))).clone(namedValues=NamedValues(("privateCoding", 2), ("publicCoding", 1), ("x75Coding", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfmDiagnosticCodeField.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfmDiagnosticCodeField.setDescription("The value of this object indicates how the diagnostic field is encoded. The default value is 'privateCoding'.")
fclX25CfmTransmitFlowControl = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 30, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("standard", 1), ("dedicatedTranspac", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfmTransmitFlowControl.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfmTransmitFlowControl.setDescription("The value of this object indicates whether the flow control is made according to the standard or according to fclX25CfmTransmitFlowControlTable (this way is used by TRANSPAC). The default value is 'standard'.")
fclX25CfmAddress14DigitsTruncation = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 30, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfmAddress14DigitsTruncation.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfmAddress14DigitsTruncation.setDescription("The value of this object indicates whether the addresses are truncated to 14 digits or not. The default value is 'off'.")
fclX25CfmTransmitFlowControlTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 30, 20), )
if mibBuilder.loadTexts: fclX25CfmTransmitFlowControlTable.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfmTransmitFlowControlTable.setDescription("This table defines non standard flow control. This table is used if fclX25CfmTransmitFlowControl is set to 'dedicatedTranspac'.")
fclX25CfmTransmitFlowControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 30, 20, 1), ).setIndexNames((0, "PCE-MIB", "fclX25CfmFlowCtrlPacketSize"))
if mibBuilder.loadTexts: fclX25CfmTransmitFlowControlEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfmTransmitFlowControlEntry.setDescription('An entry of fclX25CfmTransmitFlowControlTable.')
fclX25CfmFlowCtrlPacketSize = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 30, 20, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("s16", 4), ("s32", 5), ("s64", 6), ("s128", 7), ("s256", 8), ("s512", 9), ("s1024", 10), ("s2048", 11), ("s4096", 12), ("s8192", 13)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fclX25CfmFlowCtrlPacketSize.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfmFlowCtrlPacketSize.setDescription('The value of this object defines a packet size.')
fclX25CfmFlowCtrlMaxWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 20, 50, 30, 20, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fclX25CfmFlowCtrlMaxWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: fclX25CfmFlowCtrlMaxWindowSize.setDescription('The value of this object defines the maximum window size used for this packet size.')
fcWanSwitch = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 25))
fcwDnicZoAddress = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(3, 3)).setFixedLength(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwDnicZoAddress.setStatus('mandatory')
if mibBuilder.loadTexts: fcwDnicZoAddress.setDescription("The value of this object is the address of the equipment. This address , with a DNIC ZO format as explained below, must have 6 digits (0..9). The default value is '900000'. Address format : Eight digits (0..9) of X121 format are used as the network address numbering plan. This numbering plan has a hierarchical structure : 4 digits define the Data Network Identifier Code (DNIC) : DNIC identifies the region to which belongs the equipment, 2 digits define the zone (ZO) : ZO identifies the equipment inside the region, 2 digits define the subscriber (SB) : SB identifies a subscriber of the equipment. Therefore each subscriber is completely identified by its address of the form DNIC ZO SB and each equipment by its address of the form DNIC ZO.")
fcwMaxActiveCommunications = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(256, 4064))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwMaxActiveCommunications.setStatus('mandatory')
if mibBuilder.loadTexts: fcwMaxActiveCommunications.setDescription("The value of this object defines the maximum number of the simultaneous active communications. The authorized values are '32..2048'. The default value is '512'.")
fcwDataPacketsDiscardThreshold = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 99))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwDataPacketsDiscardThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: fcwDataPacketsDiscardThreshold.setDescription("The value of this object defines the busy memory threshold, in percentage of the total memory resources, beyond which the equipment discards the X25 data packets. The authorized values are '10..99'. The default value is '98'.")
fcwDataPacketsAcceptThreshold = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 99))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwDataPacketsAcceptThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: fcwDataPacketsAcceptThreshold.setDescription("The value of this object defines the busy memory threshold, in percentage of the total memory resources, under which the equipment does not discard any more the X25 data packets. The authorized values are '10..99'. The default value is '98'.")
fcwCallPacketsDiscardThreshold = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 99))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwCallPacketsDiscardThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: fcwCallPacketsDiscardThreshold.setDescription("The value of this object defines the busy memory threshold, in percentage of the total memory resources, beyond which the equipment discards the X25 call packets. The authorized values are '10..99'. The default value is '95'.")
fcwCallPacketsAcceptThreshold = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 99))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwCallPacketsAcceptThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: fcwCallPacketsAcceptThreshold.setDescription("The value of this object defines the busy memory threshold, in percentage of the total memory resources, under which the equipment does not discard any more the X25 call packets. The authorized values are '10..99'. The default value is '90'.")
fcwLocalCommunications = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("denied", 1), ("permitted", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwLocalCommunications.setStatus('mandatory')
if mibBuilder.loadTexts: fcwLocalCommunications.setDescription("The value of this object defines whether the local communications (i.e. between two subscribers to this equipment) are authorized or not. For instance, these communications are denied when it is neccessary to re-route them to a billing equipment. The route used in this case is defined by fcwLocalIncomingCallsRouteId. The default value is 'permitted'.")
fcwLocalIncomingCallsRouteId = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 31), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwLocalIncomingCallsRouteId.setStatus('mandatory')
if mibBuilder.loadTexts: fcwLocalIncomingCallsRouteId.setDescription("The value of this object defines the route used by the local incoming call packets when the local communications are forbidden (fcwLocalCommunications set to 'denied'). This route must exist in fcwRouteTable. The authorized values are '0..199'. The default value is '255'.")
fcwLoadAndTrafficSummingPeriod = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 40), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 2500))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwLoadAndTrafficSummingPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: fcwLoadAndTrafficSummingPeriod.setDescription("The value of this object is the period, in seconds, during which load and traffic quantity is summed and used by the switch over or overflow mechanisms. The authorized values are '10..2500' by step of 10. The default value is '20'.")
fcwLoadAndTrafficEventsTimer = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 41), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 2500))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwLoadAndTrafficEventsTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fcwLoadAndTrafficEventsTimer.setDescription("The value of this object defines the time, in seconds, between two load and traffic event generations. These event are generated by the switch over or overflow mechanisms when a threshold is crossed. The authorized values are '10..2500' by step of 10. The default value is '20'.")
fcwFrameRelay = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 45))
fcwFrDlcStatusChangeTrapEnabling = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 45, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwFrDlcStatusChangeTrapEnabling.setStatus('mandatory')
if mibBuilder.loadTexts: fcwFrDlcStatusChangeTrapEnabling.setDescription("Emission du TRAP 'changement d'etat d'une terminaison PVC' defini en RFC1315")
fcwFrAnnexeGInternalStacksMaxCount = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 45, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwFrAnnexeGInternalStacksMaxCount.setStatus('mandatory')
if mibBuilder.loadTexts: fcwFrAnnexeGInternalStacksMaxCount.setDescription("Nb max d'instances FRI disponible")
fcwFrEndPointMaxCount = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 45, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwFrEndPointMaxCount.setStatus('mandatory')
if mibBuilder.loadTexts: fcwFrEndPointMaxCount.setDescription('Nb max de terminaisons FR simultanees (SVC ou PVC)')
fcwFrFrameAcceptCpuThreshold = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 45, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwFrFrameAcceptCpuThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: fcwFrFrameAcceptCpuThreshold.setDescription("Seuil : CPU autorisee pour l'acceptation des trames")
fcwFrFrameAcceptMemoryThreshold = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 45, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwFrFrameAcceptMemoryThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: fcwFrFrameAcceptMemoryThreshold.setDescription("Seuil : Memoire autorisee pour l'acceptation des trames")
fcwFrDlcSetupAlarmThreshold = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 45, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 250))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwFrDlcSetupAlarmThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: fcwFrDlcSetupAlarmThreshold.setDescription("Seuil : A% seuil alarmique d'acceptation de connexions FR en terme de ressources")
fcwFrDlcSetupDiscardThreshold = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 45, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(100, 350))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwFrDlcSetupDiscardThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: fcwFrDlcSetupDiscardThreshold.setDescription("R% Seuil de refus d'etablissement des DLC VBR-NRT (pourcentage des ressources : 100 = pas de surbooking)")
fcwFrVoiceFrameSize = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 45, 40), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 250))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwFrVoiceFrameSize.setStatus('mandatory')
if mibBuilder.loadTexts: fcwFrVoiceFrameSize.setDescription('Longueur trames voix')
fcwFrVoiceMaxTransitDelay = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 45, 41), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 250))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwFrVoiceMaxTransitDelay.setStatus('mandatory')
if mibBuilder.loadTexts: fcwFrVoiceMaxTransitDelay.setDescription('Temps de transit maximum de bout en bout des communications de type voix en millisecondes')
fcwFrCongestionCheckTimer = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 45, 50), Integer32().subtype(subtypeSpec=ValueRangeConstraint(200, 4000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwFrCongestionCheckTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fcwFrCongestionCheckTimer.setDescription('Tempo de surveillance de la congestion du reseau FR (milisecondes)')
fcwFrCongestionCount = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 45, 51), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwFrCongestionCount.setStatus('mandatory')
if mibBuilder.loadTexts: fcwFrCongestionCount.setDescription('Critere de decongestion du reseau FR')
fcwFrCirTimer = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 45, 52), Integer32().subtype(subtypeSpec=ValueRangeConstraint(20, 400))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwFrCirTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fcwFrCirTimer.setDescription('Tempo echantillonage CIR (millisecondes)')
fcwFrEventOutput = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 45, 53), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 4, 5, 2))).clone(namedValues=NamedValues(("none", 1), ("oneOutOf16", 3), ("oneOutOf64", 4), ("oneOutOf256", 5), ("all", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwFrEventOutput.setStatus('mandatory')
if mibBuilder.loadTexts: fcwFrEventOutput.setDescription('Filtrage des EVR')
fcwFrSlowingDownThreshold = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 45, 54), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 250))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwFrSlowingDownThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: fcwFrSlowingDownThreshold.setDescription('S0 seuil de ralentissement du trafic sans positionner de bits de congestion (0 = pas de ralentissement)')
fcwFrFecnBecnOfDeFramesThreshold = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 45, 55), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 250))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwFrFecnBecnOfDeFramesThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: fcwFrFecnBecnOfDeFramesThreshold.setDescription('S1 seuil de positionnement des bits FECN BECN sur les trames DE (0 = calcule en fct de la vitesse de la ligne)')
fcwFrFecnBecnOfAllFramesThreshold = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 45, 56), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 250))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwFrFecnBecnOfAllFramesThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: fcwFrFecnBecnOfAllFramesThreshold.setDescription('S2 seuil de positionnement des bits FECN BECN sur toutes les trames (0 = calcule en fct de la vitesse de la ligne)')
fcwFrDeFramesDiscardThreshold = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 45, 57), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 250))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwFrDeFramesDiscardThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: fcwFrDeFramesDiscardThreshold.setDescription('S3 seuil de rejet des trames DE (0 = calcule en fct de la vitesse de la ligne)')
fcwFrAllFramesDiscardThreshold = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 45, 58), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 250))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwFrAllFramesDiscardThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: fcwFrAllFramesDiscardThreshold.setDescription('S4 seuil de rejet de toutes les trames (0 = calcule en fct de la vitesse de la ligne)')
fcwAddressConversion = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 48))
fcwAddrConvIncomingCallTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 48, 1), )
if mibBuilder.loadTexts: fcwAddrConvIncomingCallTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcwAddrConvIncomingCallTable.setDescription("This table defines, for the incoming call packets, the association between an X121 address pattern to be converted and the substituted address pattern. This substitution is used on the logical ports when *ConversionAimedPoint is set to 'on', *ConversionIncomingCall is not set to 'off' or *ConversionAddressCheck is set to 'onIncomingCall' or 'onIncomingCallAndOutgoingCall'. Two digits have special meanings : The digit 'C' ('$' on the equipment configurator) when simultaneously used in the address pattern to be converted AND in the converted address pattern matches any single digit which will be reported in the converted address. Example : fcwConvInExternalAddr = 1234C6C8FFFFFFF fcwConvInConvertedAddr = 900010CCFFFFFFF 1234567890 is converted to 9000105790 The digit 'D' ('?' on the equipment configurator) when used in the address pattern to be converted matches any single digit which will not be present in the converted address. Example : fcwConvInExternalAddr = 1234DD78FFFFFFF fcwConvInConvertedAddr = 9000FFFFFFFFFFF 1234567890 is converted to 900090, 1234007890 is converted to 900090, 1234560090 is not converted.")
fcwAddrConvIncomingCallEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 48, 1, 1), ).setIndexNames((0, "PCE-MIB", "fcwConvInExternalAddr"))
if mibBuilder.loadTexts: fcwAddrConvIncomingCallEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcwAddrConvIncomingCallEntry.setDescription('An entry of fcwAddrConvIncomingCallTable.')
fcwConvInExternalAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 48, 1, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcwConvInExternalAddr.setStatus('mandatory')
if mibBuilder.loadTexts: fcwConvInExternalAddr.setDescription("The value of this object identifies one and only one external address pattern to be converted. The value may contain up to 15 digits (digits 0..9, special digits C and D). The value must be completed with 'F' digits for a total of 16 digits. The equipment configurator does not need final completion. The default value is 'FF FF FF FF FF FF FF FF' meaning 'empty value' (blank value on the equipment configurator). The conversion mechanism is explained in the description of this table.")
fcwConvInStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 48, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwConvInStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fcwConvInStatus.setDescription("The value of this object indicates the state of the entry of this table. The default value is 'valid'. It must be set to 'invalid' to delete the entry.")
fcwConvInConvertedAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 48, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwConvInConvertedAddr.setStatus('mandatory')
if mibBuilder.loadTexts: fcwConvInConvertedAddr.setDescription("The value of this object defines the converted address pattern. The value may contain up to 15 digits (digits 0..9, special digit C). The value must be completed with 'F' digits for a total of 16 digits. The equipment configurator does not need final completion. The default value is 'FF FF FF FF FF FF FF FF' meaning 'empty value' (blank value on the equipment configurator). The conversion mechanism is explained in the description of this table.")
fcwConvInOrderNum = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 48, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwConvInOrderNum.setStatus('mandatory')
if mibBuilder.loadTexts: fcwConvInOrderNum.setDescription('No ordre')
fcwAddrConvOutgoingCallTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 48, 2), )
if mibBuilder.loadTexts: fcwAddrConvOutgoingCallTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcwAddrConvOutgoingCallTable.setDescription("This table defines, for the outgoing call packets, the association between an X121 address pattern to be converted and the substituted address pattern. This substitution is used on the logical ports when *ConversionOutgoingCall is not set to 'off' or *ConversionAddressCheck is set to 'onOutgoingCall' or 'onIncomingCallAndOutgoingCall'. Two digits have special meanings : The digit 'C' ('$' on the equipment configurator) when simultaneously used in the address pattern to be converted AND in the converted address pattern matches any single digit which will be reported in the converted address. Example : fcwConvOutExternalAddr = 1234C6C8FFFFFFF fcwConvOutConvertedAddr = 900010CCFFFFFFF 1234567890 is converted to 9000105790 The digit 'D' ('?' on the equipment configurator) when used in the address pattern to be converted matches any single digit which will not be present in the converted address. Example : fcwConvOutExternalAddr = 1234DD78FFFFFFF fcwConvOutConvertedAddr = 9000FFFFFFFFFFF 1234567890 is converted to 900090, 1234007890 is converted to 900090, 1234560090 is not converted.")
fcwAddrConvOutgoingCallEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 48, 2, 1), ).setIndexNames((0, "PCE-MIB", "fcwConvOutExternalAddr"))
if mibBuilder.loadTexts: fcwAddrConvOutgoingCallEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcwAddrConvOutgoingCallEntry.setDescription('An entry of fcwAddrConvOutgoingCallTable.')
fcwConvOutExternalAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 48, 2, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcwConvOutExternalAddr.setStatus('mandatory')
if mibBuilder.loadTexts: fcwConvOutExternalAddr.setDescription("The value of this object identifies one and only one external address pattern to be converted. The value may contain up to 15 digits (digits 0..9, special digits C and D). The value must be completed with 'F' digits for a total of 16 digits. The equipment configurator does not need final completion. The default value is 'FF FF FF FF FF FF FF FF' meaning 'empty value' (blank value on the equipment configurator). The conversion mechanism is explained in the description of this table.")
fcwConvOutStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 48, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwConvOutStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fcwConvOutStatus.setDescription("The value of this object indicates the state of the entry of this table. The default value is 'valid'. It must be set to 'invalid' to delete the entry.")
fcwConvOutConvertedAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 48, 2, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwConvOutConvertedAddr.setStatus('mandatory')
if mibBuilder.loadTexts: fcwConvOutConvertedAddr.setDescription("The value of this object defines the converted address pattern. The value may contain up to 15 digits (digits 0..9, special digit C). The value must be completed with 'F' digits for a total of 16 digits. The equipment configurator does not need final completion. The default value is 'FF FF FF FF FF FF FF FF' meaning 'empty value' (blank value on the equipment configurator). The conversion mechanism is explained in the description of this table.")
fcwConvOutOrderNum = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 48, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwConvOutOrderNum.setStatus('mandatory')
if mibBuilder.loadTexts: fcwConvOutOrderNum.setDescription('No ordre')
fcwAddrConvMultiCriterionInCallTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 48, 3), )
if mibBuilder.loadTexts: fcwAddrConvMultiCriterionInCallTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcwAddrConvMultiCriterionInCallTable.setDescription('')
fcwAddrConvMultiCriterionInCallEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 48, 3, 1), ).setIndexNames((0, "PCE-MIB", "fcwConvMultiInConvID"), (0, "PCE-MIB", "fcwConvMultiInExternalAddr"))
if mibBuilder.loadTexts: fcwAddrConvMultiCriterionInCallEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcwAddrConvMultiCriterionInCallEntry.setDescription('An entry of fcwAddrConvMultiCriterionInCallTable.')
fcwConvMultiInConvID = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 48, 3, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcwConvMultiInConvID.setStatus('mandatory')
if mibBuilder.loadTexts: fcwConvMultiInConvID.setDescription('Conversion ID ')
fcwConvMultiInExternalAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 48, 3, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcwConvMultiInExternalAddr.setStatus('mandatory')
if mibBuilder.loadTexts: fcwConvMultiInExternalAddr.setDescription('Prefixe adresse exterieur ')
fcwConvMultiInStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 48, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwConvMultiInStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fcwConvMultiInStatus.setDescription("The value of this object indicates the state of the entry of this table. The default value is 'valid'. It must be set to 'invalid' to delete the entry.")
fcwConvMultiInConvertedAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 48, 3, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwConvMultiInConvertedAddr.setStatus('mandatory')
if mibBuilder.loadTexts: fcwConvMultiInConvertedAddr.setDescription('Prefixe converti')
fcwConvMultiInOrderNum = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 48, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwConvMultiInOrderNum.setStatus('mandatory')
if mibBuilder.loadTexts: fcwConvMultiInOrderNum.setDescription('No ordre')
fcwAddrConvMultiCriterionOutCallTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 48, 4), )
if mibBuilder.loadTexts: fcwAddrConvMultiCriterionOutCallTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcwAddrConvMultiCriterionOutCallTable.setDescription('')
fcwAddrConvMultiCriterionOutCallEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 48, 4, 1), ).setIndexNames((0, "PCE-MIB", "fcwConvMultiOutConvID"), (0, "PCE-MIB", "fcwConvMultiOutExternalAddr"))
if mibBuilder.loadTexts: fcwAddrConvMultiCriterionOutCallEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcwAddrConvMultiCriterionOutCallEntry.setDescription('An entry of fcwAddrConvMultiCriterionOutCallTable.')
fcwConvMultiOutConvID = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 48, 4, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcwConvMultiOutConvID.setStatus('mandatory')
if mibBuilder.loadTexts: fcwConvMultiOutConvID.setDescription('Conversion ID ')
fcwConvMultiOutExternalAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 48, 4, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcwConvMultiOutExternalAddr.setStatus('mandatory')
if mibBuilder.loadTexts: fcwConvMultiOutExternalAddr.setDescription('Prefixe adresse exterieur')
fcwConvMultiOutStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 48, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwConvMultiOutStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fcwConvMultiOutStatus.setDescription("The value of this object indicates the state of the entry of this table. The default value is 'valid'. It must be set to 'invalid' to delete the entry.")
fcwConvMultiOutConvertedAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 48, 4, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwConvMultiOutConvertedAddr.setStatus('mandatory')
if mibBuilder.loadTexts: fcwConvMultiOutConvertedAddr.setDescription('Prefixe converti')
fcwConvMultiOutOrderNum = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 48, 4, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwConvMultiOutOrderNum.setStatus('mandatory')
if mibBuilder.loadTexts: fcwConvMultiOutOrderNum.setDescription('No ordre')
fcwAddrConvCondOutgoingCallTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 48, 5), )
if mibBuilder.loadTexts: fcwAddrConvCondOutgoingCallTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcwAddrConvCondOutgoingCallTable.setDescription('')
fcwAddrConvCondOutgoingCallEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 48, 5, 1), ).setIndexNames((0, "PCE-MIB", "fcwConvCondOutExternalAddr"), (0, "PCE-MIB", "fcwConvCondOutTryOn"))
if mibBuilder.loadTexts: fcwAddrConvCondOutgoingCallEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcwAddrConvCondOutgoingCallEntry.setDescription('An entry of fcwAddrConvCondOutgoingCallTable.')
fcwConvCondOutExternalAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 48, 5, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcwConvCondOutExternalAddr.setStatus('mandatory')
if mibBuilder.loadTexts: fcwConvCondOutExternalAddr.setDescription("The value of this object identifies one and only one external address pattern to be converted. The value may contain up to 12 digits (digits 0..9, special digits C and D). The equipment configurator does not need final completion. The default value is 'FF FF FF FF FF FF' meaning 'empty value' (blank value on the equipment configurator). The conversion mechanism is explained in the description of fcwAddrConvOutgoingCallTable.")
fcwConvCondOutTryOn = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 48, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("normalClear1", 1), ("backup", 2), ("all", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcwConvCondOutTryOn.setStatus('mandatory')
if mibBuilder.loadTexts: fcwConvCondOutTryOn.setDescription("The value of this object defines which kind of LP in the route table the entry is associated with : all : this conversion is for both primary LP with routing type normalClear1, and associated backup LP, normalClear1 : this conversion is only for primary LP with routing type normalClear1, backup : this conversion is only for backups of primary LP with routing type normalClear1, The default value is 'all'.")
fcwConvCondOutStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 48, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwConvCondOutStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fcwConvCondOutStatus.setDescription("The value of this object indicates the state of the entry of this table. The default value is 'valid'. It must be set to 'invalid' to delete the entry.")
fcwConvCondOutConvertedAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 48, 5, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwConvCondOutConvertedAddr.setStatus('mandatory')
if mibBuilder.loadTexts: fcwConvCondOutConvertedAddr.setDescription("The value of this object defines the converted address pattern. The value may contain up to 12 digits (digits 0..9, special digit C). The equipment configurator does not need final completion. The default value is 'FF FF FF FF FF' meaning 'empty value' (blank value on the equipment configurator The conversion mechanism is explained in the description of fcwAddrConvOutgoingCallTable.")
fcwRouteTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 50), )
if mibBuilder.loadTexts: fcwRouteTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcwRouteTable.setDescription('This table defines the routes which may be used by the call packets according to the routing tables. One route is composed of one or more logical ports. Most of times each logical port has only one channel and it is not necessary to indicates the channel identifier.')
fcwRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 50, 1), ).setIndexNames((0, "PCE-MIB", "fcwRoutRouteId"), (0, "PCE-MIB", "fcwRoutLogPortId"), (0, "PCE-MIB", "fcwRoutChannelId"))
if mibBuilder.loadTexts: fcwRouteEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcwRouteEntry.setDescription('An entry of fcwRouteTable.')
fcwRoutRouteId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 50, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcwRoutRouteId.setStatus('mandatory')
if mibBuilder.loadTexts: fcwRoutRouteId.setDescription("The value of this object identifies one and only one route. One route may be composed of one or several logical ports. The possible values are : '0..199'. If it is unused, the value of this parameter is '255'. The default value is '255'.")
fcwRoutLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 50, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcwRoutLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fcwRoutLogPortId.setDescription("The value of this object identifies one of the logical ports which compose the route defined by fcwRoutRouteId. The possible values are : '0..131'. If it is unused, the value of this parameter is '255'. The default value is '255'.")
fcwRoutChannelId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 50, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcwRoutChannelId.setStatus('mandatory')
if mibBuilder.loadTexts: fcwRoutChannelId.setDescription("The value of this object identifies one of the channels available on the logical port defined by fcwRoutLogPortId. Most of times each logical port has only one channel and it is not necessary to indicates this channel identifier. In some very particular cases a logical port may have several channels and the equipment is not able to choose the right one. So the channel identifier must be indicated. This happens, for instance, with a Frame Relay logical port which has several Permanent Virtual Circuit end points and when it is impossible to find which one must be used : the corresponding DLCI (Data Link Connection Identifier) must be indicated in fcwRoutChannelId. The possible values are : '0..1023'. If it is unused, the value of this parameter is '65535'. The default value is '65535'.")
fcwRoutStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 50, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwRoutStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fcwRoutStatus.setDescription("The value of this object indicates the state of the entry of this table. The default value is 'valid'. It must be set to 'invalid' to delete the entry.")
fcwRoutType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 50, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("normal", 1), ("normalPriorityModule", 2), ("backup1", 3), ("backup2", 4), ("backup3", 5), ("backup4", 6), ("backup5", 7), ("dynamic", 8), ("backupDynamic", 9), ("normalClear1", 10)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwRoutType.setStatus('mandatory')
if mibBuilder.loadTexts: fcwRoutType.setDescription("The value of this object indicates how the equipment will try to use this logical port (or this couple [logical port, channel]) which composes this route. The following combinations are possible : ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ |Route|LP|Type| Routing description | |~~~~~|~~|~~~~|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| | 1 | 1| n | -> on one LP | |~~~~~|~~|~~~~|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| | 2 | 1| n | -> 1 : on one main LP | | 2 | 2| b1 | \\ | | 2 | 3| b1 | > 2 : on three equal | | 2 | 4| b1 | / priority backup LPs | |~~~~~|~~|~~~~|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| | 3 | 1| n | \\ | | 3 | 2| n | | | | 3 | 3| n | > on five equal priority LPs | | 3 | 4| n | | | | 3 | 5| n | / | |~~~~~|~~|~~~~|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| | 4 | 1| n | -> 1 : on one main LP | | 4 | 2| b1 | -> 2 : on one first backup LP | | 4 | 3| b2 | -> 3 : on one second backup LP | | 4 | 4| b3 | -> 4 : on one third backup LP | |~~~~~|~~|~~~~|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| | 5 | 1| n | \\ on three equal | | 5 | 2| n | > 1 : priority main LPs | | 5 | 3| n | / | | 5 | 4| b1 | -> 2 : on one backup LP | |~~~~~|~~|~~~~|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| | 8 | 1| nM | each module of the equipment | | 8 | 2| b1 | considers its own LPs as having | | 8 |11| b2 | a higher priority than the | | 8 | 3| b3 | LPs of the other modules | | 8 |21| b4 | (see below) | | 8 |12| b5 | | |~~~~~|~~|~~~~|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| | 9 | 1| nC | -> 1 : on one main LP | |~~~~~|~~|~~~~|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| | 10 | 1| nC | -> 1 : on one main LP | | 10 | 2| b1 | -> 2 : on one first backup LP | | 10 | 3| b2 | -> 3 : on one second backup LP | | 10 | 4| b3 | -> 4 : on one third backup LP | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types : n : normal, nM : normalPriorityModule, b1 : backup1, b2 : backup2, b3 : backup3, b4 : backup4, b5 : backup5, dynamic, backupDynamic, nC : normalClear1. Interpretation of the route 8 : In this example let us suppose that LP 1, 2 and 3 belongs to the module 0, 11 and 12 to the module 1, and 21 to the module 2. The route 8 becomes : on the module 0 : LP : 1 2 3 11 21 12 Type : n b1 b2 b3 b4 b5 on the module 1 : LP : 11 12 1 2 3 21 Type : n b1 b2 b3 b4 b5 on the module 2 : LP : 21 1 2 11 3 12 Type : n b1 b2 b3 b4 b5 Interpretation of the route 9 : there must be at least 1 valid entry with try on = normalClear1 (or all) in the Clear cause/diagnostic table. The address is converted according to that entry. Interpretation of the route 10 : there must be at least 1 valid entry with try on = normalClear1 and 1 with try on = backup (or 1 with all) in the Clear cause/diagnostic table. The address is converted according to that entry. The default value is 'normal'.")
fcwDnicRoutingTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 60), )
if mibBuilder.loadTexts: fcwDnicRoutingTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcwDnicRoutingTable.setDescription('This table is the call packets routing table for the Data Network Identifier Code (DNIC) part of the X121 called address.')
fcwDnicRoutingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 60, 1), ).setIndexNames((0, "PCE-MIB", "fcwDnicDataNetworkIdentifierCode"), (0, "PCE-MIB", "fcwDnicRouteId"))
if mibBuilder.loadTexts: fcwDnicRoutingEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcwDnicRoutingEntry.setDescription('An entry of fcwDnicRoutingTable.')
fcwDnicDataNetworkIdentifierCode = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 60, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcwDnicDataNetworkIdentifierCode.setStatus('mandatory')
if mibBuilder.loadTexts: fcwDnicDataNetworkIdentifierCode.setDescription("The value of this object is the Data Network Identifier Code (DNIC) part of the X121 called address from the call packet to be routed. This address , with a DNIC format as explained below, may contain up to 4 digits (0..9, B). The digit 'B' (character '*' on the equipment configurator) have special meaning : 'B' matches any address. When used it must be the only digit specified (with final completion as explained below). The associated route is used only if the equipment does not find another possibility in this table. There must be only one route for each specified address but partial addresses are accepted. Example : If route 1 is specified for DNIC '1234', route 2 for DNIC '12' and route 3 for DNIC 'B', call packets to DNIC 1234 are routed on the route 1, call packets to DNIC 12xx (xx different from 34) are routed on the route 2 and all others are routed on the route 3. The value must be completed with 'F' digits for a total of 4 digits. The equipment configurator does not need final completion. The default value is 'FF FF' meaning 'empty value' (blank value on the equipment configurator). Address format : Eight digits (0..9) of X121 format are used as the network address numbering plan. This numbering plan has a hierarchical structure : 4 digits define the Data Network Identifier Code (DNIC) : DNIC identifies the region to which belongs the equipment, 2 digits define the zone (ZO) : ZO identifies the equipment inside the region, 2 digits define the subscriber (SB) : SB identifies a subscriber of the equipment. Therefore each subscriber is completely identified by its address of the form DNIC ZO SB and each equipment by its address of the form DNIC ZO.")
fcwDnicRouteId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 60, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcwDnicRouteId.setStatus('mandatory')
if mibBuilder.loadTexts: fcwDnicRouteId.setDescription("The value of this object defines the route associated to this address. This route must exist in fcwRouteTable. The authorized values are '0..199'. The default value is '255'.")
fcwDnicStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 60, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwDnicStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fcwDnicStatus.setDescription("The value of this object indicates the state of the entry of this table. The default value is 'valid'. It must be set to 'invalid' to delete the entry.")
fcwZoRoutingTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 61), )
if mibBuilder.loadTexts: fcwZoRoutingTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcwZoRoutingTable.setDescription('This table is the call packets routing table for the Zone (ZO) part of the X121 called address.')
fcwZoRoutingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 61, 1), ).setIndexNames((0, "PCE-MIB", "fcwZoZone"), (0, "PCE-MIB", "fcwZoRouteId"))
if mibBuilder.loadTexts: fcwZoRoutingEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcwZoRoutingEntry.setDescription('An entry of fcwZoRoutingTable.')
fcwZoZone = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 61, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcwZoZone.setStatus('mandatory')
if mibBuilder.loadTexts: fcwZoZone.setDescription("The value of this object is the Zone (ZO) part of the X121 called address from the call packet to be routed. This address , with a ZO format as explained below, must contains 2 digits (0..9, B). The digit 'B' (character '*' on the equipment configurator) have special meaning : 'B' matches any address. When used it must be the only digit specified (with final completion as explained below). The associated route is used only if the equipment does not find another possibility in this table. There must be only one route for each specified address. Example : If route 1 is specified for ZO '12', route 2 for ZO 'B', call packets to ZO 12 are routed on the route 1 and all others are routed on the route 2. The value must be completed with 'F' digits for a total of 2 digits (here only if the digit 'B' is used). The equipment configurator does not need final completion. The default value is 'FF' meaning 'empty value' (blank value on the equipment configurator). Address format : Eight digits (0..9) of X121 format are used as the network address numbering plan. This numbering plan has a hierarchical structure : 4 digits define the Data Network Identifier Code (DNIC) : DNIC identifies the region to which belongs the equipment, 2 digits define the zone (ZO) : ZO identifies the equipment inside the region, 2 digits define the subscriber (SB) : SB identifies a subscriber of the equipment. Therefore each subscriber is completely identified by its address of the form DNIC ZO SB and each equipment by its address of the form DNIC ZO.")
fcwZoRouteId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 61, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcwZoRouteId.setStatus('mandatory')
if mibBuilder.loadTexts: fcwZoRouteId.setDescription("The value of this object defines the route associated to this address. This route must exist in fcwRouteTable. The authorized values are '0..199'. The default value is '255'.")
fcwZoStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 61, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwZoStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fcwZoStatus.setDescription("The value of this object indicates the state of the entry of this table. The default value is 'valid'. It must be set to 'invalid' to delete the entry.")
fcwSbRoutingTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 62), )
if mibBuilder.loadTexts: fcwSbRoutingTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcwSbRoutingTable.setDescription('This table is the call packets routing table for the Subscriber (SB) part of the X121 called address.')
fcwSbRoutingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 62, 1), ).setIndexNames((0, "PCE-MIB", "fcwSbSubscriberNumber"), (0, "PCE-MIB", "fcwSbRouteId"))
if mibBuilder.loadTexts: fcwSbRoutingEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcwSbRoutingEntry.setDescription('An entry of fcwSbRoutingTable.')
fcwSbSubscriberNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 62, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcwSbSubscriberNumber.setStatus('mandatory')
if mibBuilder.loadTexts: fcwSbSubscriberNumber.setDescription("The value of this object is the Subscriber (SB) part of the X121 called address from the call packet to be routed. This address , with a SB format as explained below, must contains 2 digits (0..9, B). The digit 'B' (character '*' on the equipment configurator) have special meaning : 'B' matches any address. When used it must be the only digit specified (with final completion as explained below). The associated route is used only if the equipment does not find another possibility in this table. There must be only one route for each specified address. Example : If route 1 is specified for SB '12', route 2 for SB 'B', call packets to SB 12 are routed on the route 1 and all others are routed on the route 2. The value must be completed with 'F' digits for a total of 2 digits (here only if the digit 'B' is used). The equipment configurator does not need final completion. The default value is 'FF' meaning 'empty value' (blank value on the equipment configurator). Address format : Eight digits (0..9) of X121 format are used as the network address numbering plan. This numbering plan has a hierarchical structure : 4 digits define the Data Network Identifier Code (DNIC) : DNIC identifies the region to which belongs the equipment, 2 digits define the zone (ZO) : ZO identifies the equipment inside the region, 2 digits define the subscriber (SB) : SB identifies a subscriber of the equipment. Therefore each subscriber is completely identified by its address of the form DNIC ZO SB and each equipment by its address of the form DNIC ZO.")
fcwSbRouteId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 62, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcwSbRouteId.setStatus('mandatory')
if mibBuilder.loadTexts: fcwSbRouteId.setDescription("The value of this object defines the route associated to this address. This route must exist in fcwRouteTable. The authorized values are '0..199'. The default value is '255'.")
fcwSbStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 62, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwSbStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fcwSbStatus.setDescription("The value of this object indicates the state of the entry of this table. The default value is 'valid'. It must be set to 'invalid' to delete the entry.")
fcwServices = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 70))
fcwSerCompression = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 70, 1))
fcwSCompModule0CompressedVcCount = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 70, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwSCompModule0CompressedVcCount.setStatus('mandatory')
if mibBuilder.loadTexts: fcwSCompModule0CompressedVcCount.setDescription("The value of this object defines the maximum number of virtual circuits which may be simultaneously compressed by the module 0 of the equipment. The compression of virtual circuits may be enabled at the logical port level. The authorized values are '0..2048'. The default value is '0'.")
fcwSCompModule1CompressedVcCount = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 70, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwSCompModule1CompressedVcCount.setStatus('mandatory')
if mibBuilder.loadTexts: fcwSCompModule1CompressedVcCount.setDescription("The value of this object defines the maximum number of the virtual channels that may be simultaneously compressed by the module 0 of the equipment. The authorized values are '0..2048'. The default value is '1'.")
fcwSCompModule2CompressedVcCount = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 70, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwSCompModule2CompressedVcCount.setStatus('mandatory')
if mibBuilder.loadTexts: fcwSCompModule2CompressedVcCount.setDescription("The value of this object defines the maximum number of the virtual channels that may be simultaneously compressed by the module 0 of the equipment. The authorized values are '0..2048'. The default value is '2'.")
fcwSCompAlgorithmSelection = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 70, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("auto", 1), ("v9Compatible", 2), ("v10Compatible", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwSCompAlgorithmSelection.setStatus('mandatory')
if mibBuilder.loadTexts: fcwSCompAlgorithmSelection.setDescription("The value of this object which compression algorithm is used by the equipment. It can use an algorithm compatible to which one used on equipment with version 9 software or version 10 software. It can also choise the right one automatically. The default value is 'auto'.")
fcwSerReliableVirtualCircuits = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 70, 2))
fcwSRvcReliableVcCount = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 70, 2, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwSRvcReliableVcCount.setStatus('mandatory')
if mibBuilder.loadTexts: fcwSRvcReliableVcCount.setDescription("The value of this object defines the maximum number of simultaneously reliable virtual circuits in the equipment. The reliable virtual circuits may be enabled at the logical port level. The authorized values are '0..255. The default value is '20'.")
fcwSRvcFirstDataPacketTimer = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 70, 2, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 254))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwSRvcFirstDataPacketTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fcwSRvcFirstDataPacketTimer.setDescription("The value of this object is the waiting time between the call connected packet and the first data packet which there is clearing beyond. This parameter is pertinent only if the fast select facility is used. The authorized values are '1..254'. The default value is '12'.")
fcwSRvcRestoreOutgoingCallRetryCount = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 70, 2, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 254))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwSRvcRestoreOutgoingCallRetryCount.setStatus('mandatory')
if mibBuilder.loadTexts: fcwSRvcRestoreOutgoingCallRetryCount.setDescription("The value of this object indicates how many times the equipment will try to send a call packet to restore the virtual circuit wich has been unintentionnaly cleared. The possible values are : '1..254'. The default value is '10'.")
fcwSRvcRestoreMinimumRecallTimer = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 70, 2, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 254))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwSRvcRestoreMinimumRecallTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fcwSRvcRestoreMinimumRecallTimer.setDescription("The value of this object specifies the minimum recall time (in seconds) between two successive calls. The authorized values are '1..254'. The default value is '20'.")
fcwSRvcRestoreIncomingCallTimer = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 70, 2, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 2540))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwSRvcRestoreIncomingCallTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fcwSRvcRestoreIncomingCallTimer.setDescription("The value of this object is the time between a new connection request and the reception of the corresponding call connected packet which there is clearing beyond. The authorized values are '10..2540'. The default value is '120'.")
fcwSRvcRestoreOutgoingCallDelay = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 70, 2, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 2540))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwSRvcRestoreOutgoingCallDelay.setStatus('mandatory')
if mibBuilder.loadTexts: fcwSRvcRestoreOutgoingCallDelay.setDescription("When it is not possible to restore the network connection, the standard forces to not use the called reference number during the value of this object. The authorized values are '10..2540'. The default value is '120'.")
fcwSRvcKWindowSize = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 70, 2, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwSRvcKWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: fcwSRvcKWindowSize.setDescription("The value of this object indicates the maximum number (K) of sequentially numbered I frames that the equipment may have outstanding (i.e.. unacknowledged) at any given time. The authorized values are '1..127'. The default value is '10'.")
fcwSRvcFastSelectUse = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 70, 2, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwSRvcFastSelectUse.setStatus('mandatory')
if mibBuilder.loadTexts: fcwSRvcFastSelectUse.setDescription("The value of this object specifies whether the equipment uses the fast select facility or not. The default value is 'onk'.")
fcwSRvcOutputMarkers = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 70, 2, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noCheck", 1), ("check", 2), ("remove", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwSRvcOutputMarkers.setStatus('mandatory')
if mibBuilder.loadTexts: fcwSRvcOutputMarkers.setDescription("The value of this object specifies the behaviour of the equipment with respect to the outgoing facility markers. The authorized values are : noCheck : no checking, remove : the markers are not transmitted, check : according to the following table : ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ | packet | facility marker | | |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ | | 0000 (1) | 00FF (2) | 000F (3) | |~~~~~~~~~|~~~~~~~~~~~~|~~~~~~~~~~~~|~~~~~~~~~~~| | call |no checking |clearing (5)|no checking| |~~~~~~~~~|~~~~~~~~~~~~|~~~~~~~~~~~~|~~~~~~~~~~~| | call | | | | |connected|clearing (4)|no checking |no checking| |~~~~~~~~~|~~~~~~~~~~~~|~~~~~~~~~~~~|~~~~~~~~~~~| | clear | - | - |no checking| ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ (1) : registration codes, non-x25 facilities provided by the network in case of intranetwork calls, non-x25 facilities provided by the network to which the calling DTE is connected in case of internetwork calls (2) : non-x25 facilities provided by the network to which the calling DTE is connected in case of intranetwork calls (3) : CCITT-specified DTE facilities (4) : diagnostic to local equipment = 03 42, diagnostic to remote equipment = 11 42 (5) : diagnostic to local equipment = 03 42 The default value is 'noCheck'.")
fcwSRvcConversionAimedPoint = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 70, 2, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwSRvcConversionAimedPoint.setStatus('mandatory')
if mibBuilder.loadTexts: fcwSRvcConversionAimedPoint.setDescription("The value of this object indicates whether the 'aimed point' address conversion is enabled or not. This conversion consists in making the routing process work not with the called address from the call packet but with a substituted address according to the address conversion table (see fcwAddrConvIncomingCallTable). Therefore this reduces the number of entries of the routing tables if several called addresses are converted to same 'aimed point' address. The default value is 'off'.")
fcwSRvcConversionIncomingCall = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 70, 2, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("off", 1), ("callingAddress", 2), ("calledAddress", 3), ("callingAddressAndCalledAddress", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwSRvcConversionIncomingCall.setStatus('mandatory')
if mibBuilder.loadTexts: fcwSRvcConversionIncomingCall.setDescription("The value of this object indicates which address field are converted on an incoming call. The authorized values are : off : no address field conversion, callingAddress : conversion of the calling address field according to the contains of fcwAddrConvIncomingCallTable, calledAddress : conversion of the called address field according to the contains of fcwAddrConvIncomingCallTable, callingAddressAndCalledAddress : conversion of the calling and called address fields according to the contains of fcwAddrConvIncomingCallTable. The default value is 'off'.")
fcwSRvcConversionOutgoingCall = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 70, 2, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("off", 1), ("callingAddress", 2), ("calledAddress", 3), ("callingAddressAndCalledAddress", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwSRvcConversionOutgoingCall.setStatus('mandatory')
if mibBuilder.loadTexts: fcwSRvcConversionOutgoingCall.setDescription("The value of this object indicates which address field are converted on an outgoing call. The authorized values are : off : no address field conversion, callingAddress : conversion of the calling address field according to the contains of fcwAddrConvOutgoingCallTable, calledAddress : conversion of the called address field according to the contains of fcwAddrConvOutgoingCallTable, callingAddressAndCalledAddress : conversion of the calling and called address fields according to the contains of fcwAddrConvOutgoingCallTable. The default value is 'off'.")
fcwSRvcConversionAddressCheck = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 70, 2, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("off", 1), ("onIncomingCall", 2), ("onOutgoingCall", 3), ("onIncomingCallAndOutgoingCall", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwSRvcConversionAddressCheck.setStatus('mandatory')
if mibBuilder.loadTexts: fcwSRvcConversionAddressCheck.setDescription("The value of this object indicates the behaviour of the equipment when a requested address conversion can not be made because the address is not found in the address conversion tables (fcwAddrConvIncomingCallTable or fcwAddrConvOutgoingCallTable). In this case the call will be cleared when 'checking' is enabled. The authorized values are : off : no checking, onIncomingCall : checking on incoming calls, onOutgoingCall : checking on outgoing calls, onIcomingCallAndOutgoingCall : checking on incoming and outgoing calls. The default value is 'off'.")
fcwSerReselectionX29 = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 70, 3))
fcwSResLogChannelCount = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 70, 3, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwSResLogChannelCount.setStatus('mandatory')
if mibBuilder.loadTexts: fcwSResLogChannelCount.setDescription("The value of this object is the number of logical Channels. The authorized values are '0..255. The default value is '200'.")
fcwSResProtocolIdentifierTransmission = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 70, 3, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwSResProtocolIdentifierTransmission.setStatus('mandatory')
if mibBuilder.loadTexts: fcwSResProtocolIdentifierTransmission.setDescription("The value of this object indicates whether the protocol identifier is transmitted or not. The default value is 'off'.")
fcwSResConversionAimedPoint = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 70, 3, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwSResConversionAimedPoint.setStatus('mandatory')
if mibBuilder.loadTexts: fcwSResConversionAimedPoint.setDescription("The value of this object indicates whether the 'aimed point' address conversion is enabled or not. This conversion consists in making the routing process work not with the called address from the call packet but with a substituted address according to the address conversion table (see fcwAddrConvIncomingCallTable). Therefore this reduces the number of entries of the routing tables if several called addresses are converted to same 'aimed point' address. The default value is 'off'.")
fcwSResConversionIncomingCall = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 70, 3, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("off", 1), ("callingAddress", 2), ("calledAddress", 3), ("callingAddressAndCalledAddress", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwSResConversionIncomingCall.setStatus('mandatory')
if mibBuilder.loadTexts: fcwSResConversionIncomingCall.setDescription("The value of this object indicates which address field are converted on an incoming call. The authorized values are : off : no address field conversion, callingAddress : conversion of the calling address field according to the contains of fcwAddrConvIncomingCallTable, calledAddress : conversion of the called address field according to the contains of fcwAddrConvIncomingCallTable, callingAddressAndCalledAddress : conversion of the calling and called address fields according to the contains of fcwAddrConvIncomingCallTable. The default value is 'off'.")
fcwSResConversionOutgoingCall = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 70, 3, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("off", 1), ("callingAddress", 2), ("calledAddress", 3), ("callingAddressAndCalledAddress", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwSResConversionOutgoingCall.setStatus('mandatory')
if mibBuilder.loadTexts: fcwSResConversionOutgoingCall.setDescription("The value of this object indicates which address field are converted on an outgoing call. The authorized values are : off : no address field conversion, callingAddress : conversion of the calling address field according to the contains of fcwAddrConvOutgoingCallTable, calledAddress : conversion of the called address field according to the contains of fcwAddrConvOutgoingCallTable, callingAddressAndCalledAddress : conversion of the calling and called address fields according to the contains of fcwAddrConvOutgoingCallTable. The default value is 'off'.")
fcwSResConversionAddressCheck = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 70, 3, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("off", 1), ("onIncomingCall", 2), ("onOutgoingCall", 3), ("onIncomingCallAndOutgoingCall", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwSResConversionAddressCheck.setStatus('mandatory')
if mibBuilder.loadTexts: fcwSResConversionAddressCheck.setDescription("The value of this object indicates the behaviour of the equipment when a requested address conversion can not be made because the address is not found in the address conversion tables (fcwAddrConvIncomingCallTable or fcwAddrConvOutgoingCallTable). In this case the call will be cleared when 'checking' is enabled. The authorized values are : off : no checking, onIncomingCall : checking on incoming calls, onOutgoingCall : checking on outgoing calls, onIcomingCallAndOutgoingCall : checking on incoming and outgoing calls. The default value is 'off'.")
fcwSerDynamicRouting = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 70, 4))
fcwSDynDynamicRouting = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 70, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3))).clone(namedValues=NamedValues(("off", 1), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwSDynDynamicRouting.setStatus('mandatory')
if mibBuilder.loadTexts: fcwSDynDynamicRouting.setDescription('Mode de fonctionnement RAD')
fcwSDynPassword = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 70, 4, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 6))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwSDynPassword.setStatus('mandatory')
if mibBuilder.loadTexts: fcwSDynPassword.setDescription("Mode de passe fonction d'exploitation RAD")
fcwSDynNeighborMaxCount = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 70, 4, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 250))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwSDynNeighborMaxCount.setStatus('mandatory')
if mibBuilder.loadTexts: fcwSDynNeighborMaxCount.setDescription('Nb max de LSPDU memorisees')
fcwSDynLspAgingTimer = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 70, 4, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 2500))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwSDynLspAgingTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fcwSDynLspAgingTimer.setDescription("Duree de stockage d'un LSPDU")
fcwSDynLspRetransRequestTimer = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 70, 4, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 2500))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwSDynLspRetransRequestTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fcwSDynLspRetransRequestTimer.setDescription("Duree de stockage minimum declanchant une demande de mise a jour d'un LSPDU ")
fcwSDynLspRetransmissionTimer = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 70, 4, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 2500))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwSDynLspRetransmissionTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fcwSDynLspRetransmissionTimer.setDescription('Periode de diffusion de la topologie')
fcwSDynRouteCalculationTimer = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 70, 4, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 2500))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwSDynRouteCalculationTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fcwSDynRouteCalculationTimer.setDescription('Periode de calcul des routes')
fcwSDynRouteCalculLockingTimer = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 70, 4, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 2500))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwSDynRouteCalculLockingTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fcwSDynRouteCalculLockingTimer.setDescription('Duree de verrouillage du calcul des routes')
fcwSerClearAnalysisTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 70, 5), )
if mibBuilder.loadTexts: fcwSerClearAnalysisTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcwSerClearAnalysisTable.setDescription('')
fcwSerClearAnalysisEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 70, 5, 1), ).setIndexNames((0, "PCE-MIB", "fcwSClearAnalysId"))
if mibBuilder.loadTexts: fcwSerClearAnalysisEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcwSerClearAnalysisEntry.setDescription('An entry of fcwSerClearAnalysisTable.')
fcwSClearAnalysId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 70, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcwSClearAnalysId.setStatus('mandatory')
if mibBuilder.loadTexts: fcwSClearAnalysId.setDescription('The value of this object identifies one and only one entry in the table (index)')
fcwSClearAnalysStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 70, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwSClearAnalysStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fcwSClearAnalysStatus.setDescription("The value of this object indicates the state of the entry of this table. The default value is 'valid'. It must be set to 'invalid' to delete the entry.")
fcwSClearAnalysCause = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 70, 5, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 2))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwSClearAnalysCause.setStatus('mandatory')
if mibBuilder.loadTexts: fcwSClearAnalysCause.setDescription('The value of this object indicates which cause(s) is taken into account in case of clear indication. Possible values are : 00..FF TT (all DTE clear indications) TC (all DCE clear indications) * (any clearing cause)')
fcwSClearAnalysDiag = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 70, 5, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 2))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwSClearAnalysDiag.setStatus('mandatory')
if mibBuilder.loadTexts: fcwSClearAnalysDiag.setDescription('The value of this object indicates which diagnostic is taken into account in case of clear indication. Possible values are : 00..FF * (any clearing diagnostic)')
fcwSerQOSX25 = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 70, 10))
fcwSQOSX25Table = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 70, 10, 1), )
if mibBuilder.loadTexts: fcwSQOSX25Table.setStatus('mandatory')
if mibBuilder.loadTexts: fcwSQOSX25Table.setDescription('')
fcwSQOSX25Entry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 70, 10, 1, 1), ).setIndexNames((0, "PCE-MIB", "fcwSQOSX25CalledAddress"), (0, "PCE-MIB", "fcwSQOSX25CallingAddress"), (0, "PCE-MIB", "fcwSQOSX25CUDProfileId"))
if mibBuilder.loadTexts: fcwSQOSX25Entry.setStatus('mandatory')
if mibBuilder.loadTexts: fcwSQOSX25Entry.setDescription('An entry of fcwSQOSX25Table.')
fcwSQOSX25CalledAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 70, 10, 1, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcwSQOSX25CalledAddress.setStatus('mandatory')
if mibBuilder.loadTexts: fcwSQOSX25CalledAddress.setDescription('Called Address')
fcwSQOSX25CallingAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 70, 10, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcwSQOSX25CallingAddress.setStatus('mandatory')
if mibBuilder.loadTexts: fcwSQOSX25CallingAddress.setDescription('Calling Address')
fcwSQOSX25CUDProfileId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 70, 10, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcwSQOSX25CUDProfileId.setStatus('mandatory')
if mibBuilder.loadTexts: fcwSQOSX25CUDProfileId.setDescription('CUD Profile Id')
fcwSQOSX25Status = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 70, 10, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwSQOSX25Status.setStatus('mandatory')
if mibBuilder.loadTexts: fcwSQOSX25Status.setDescription('Status')
fcwSQOSX25PriorityLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 70, 10, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwSQOSX25PriorityLevel.setStatus('mandatory')
if mibBuilder.loadTexts: fcwSQOSX25PriorityLevel.setDescription('Priority Level')
fcwSQOSX25QOSProfileId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 70, 10, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwSQOSX25QOSProfileId.setStatus('mandatory')
if mibBuilder.loadTexts: fcwSQOSX25QOSProfileId.setDescription('QOS Profile Id')
fcwSQOSX25Cos = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 70, 10, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 1, 2))).clone(namedValues=NamedValues(("ubr", 3), ("vbr", 1), ("vbr-rt", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwSQOSX25Cos.setStatus('mandatory')
if mibBuilder.loadTexts: fcwSQOSX25Cos.setDescription('COS')
fcwSQOSX25TrafficManagementStrategy = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 70, 10, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 4))).clone(namedValues=NamedValues(("discardButNotDelay", 1), ("delayButNotDiscard-Bc", 3), ("delayButNotDiscard-BcBe", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwSQOSX25TrafficManagementStrategy.setStatus('mandatory')
if mibBuilder.loadTexts: fcwSQOSX25TrafficManagementStrategy.setDescription('Traffic Management Strategy')
fcwSCUDProfilesTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 70, 10, 2), )
if mibBuilder.loadTexts: fcwSCUDProfilesTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcwSCUDProfilesTable.setDescription('')
fcwSCUDProfilesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 70, 10, 2, 1), ).setIndexNames((0, "PCE-MIB", "fcwSCUDProfilesId"))
if mibBuilder.loadTexts: fcwSCUDProfilesEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcwSCUDProfilesEntry.setDescription('An entry of fcwSCUDProfilesTable.')
fcwSCUDProfilesId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 70, 10, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcwSCUDProfilesId.setStatus('mandatory')
if mibBuilder.loadTexts: fcwSCUDProfilesId.setDescription('CUD Profile Id')
fcwSCUDProfilesStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 70, 10, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwSCUDProfilesStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fcwSCUDProfilesStatus.setDescription('Status')
fcwSCUDProfilesCUD = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 70, 10, 2, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(13, 13)).setFixedLength(13)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwSCUDProfilesCUD.setStatus('mandatory')
if mibBuilder.loadTexts: fcwSCUDProfilesCUD.setDescription("Donnees d'appel hexa CUD")
fcwSQOSProfilesTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 70, 10, 3), )
if mibBuilder.loadTexts: fcwSQOSProfilesTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcwSQOSProfilesTable.setDescription('')
fcwSQOSProfilesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 70, 10, 3, 1), ).setIndexNames((0, "PCE-MIB", "fcwSQOSProfilesId"))
if mibBuilder.loadTexts: fcwSQOSProfilesEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcwSQOSProfilesEntry.setDescription('An entry of fcwSQOSProfilesTable.')
fcwSQOSProfilesId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 70, 10, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcwSQOSProfilesId.setStatus('mandatory')
if mibBuilder.loadTexts: fcwSQOSProfilesId.setDescription('QOS Profile Id')
fcwSQOSProfilesStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 70, 10, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwSQOSProfilesStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fcwSQOSProfilesStatus.setDescription('Status')
fcwSQOSProfilesCIR = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 70, 10, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwSQOSProfilesCIR.setStatus('mandatory')
if mibBuilder.loadTexts: fcwSQOSProfilesCIR.setDescription('CIR')
fcwSQOSProfilesCIRmin = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 70, 10, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwSQOSProfilesCIRmin.setStatus('mandatory')
if mibBuilder.loadTexts: fcwSQOSProfilesCIRmin.setDescription('CIRmin')
fcwSQOSProfilesBc = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 70, 10, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwSQOSProfilesBc.setStatus('mandatory')
if mibBuilder.loadTexts: fcwSQOSProfilesBc.setDescription('Bc')
fcwSQOSProfilesBe = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 25, 70, 10, 3, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcwSQOSProfilesBe.setStatus('mandatory')
if mibBuilder.loadTexts: fcwSQOSProfilesBe.setDescription('Be')
fcVirtualPorts = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 30))
fcvVirtualPortTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 30, 1), )
if mibBuilder.loadTexts: fcvVirtualPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcvVirtualPortTable.setDescription("This table defines the virtual ports. Through a virtual port the bridge and the IP, IPX and CLNP routers can communicate with bridges and routers taking place inside a particular virtual network. These communications may use a Local Area Network (LAN), namely the virtual network matches the LAN, or Wide Area Networks (WAN), namely the virtual network matches a group of remote bridges or routers. Each module of the equipment has its own virtual ports. The module 0 can enable bridge forwarding, IP (Internet Protocol) routing, IPX (Internetwork Packet eXchange : Novell protocol) routing and CLNP (ConnectionLess Network Protocol) routing. The modules 1 and 2 can only act as IP host. So each of these two modules needs one remote VP when its SNMP agent must exchange SNMP datas with an SNMP manager. Set any writable object(s) of this table to valid value(s) with a new index value to create an entry (the objects of the entry not present in this SET REQUEST will take their default values). Set fcvVpStatus to 'invalid' to delete an entry.")
fcvVirtualPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 30, 1, 1), ).setIndexNames((0, "PCE-MIB", "fcvVpVirtualPortId"))
if mibBuilder.loadTexts: fcvVirtualPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcvVirtualPortEntry.setDescription('An entry of fcvVirtualPortTable.')
fcvVpVirtualPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 30, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 11))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcvVpVirtualPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fcvVpVirtualPortId.setDescription('The value of this object identifies one and only one virtual port. Through a virtual port the bridge and the IP, IPX and CLNP routers can communicate with bridges and routers taking place inside a particular virtual network. These communications may use a Local Area Network (LAN), namely the virtual network matches the LAN, or Wide Area Networks (WAN), namely the virtual network matches a group of remote bridges or routers. This is a decimal integer in the range 0 to 11.')
fcvVpStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 30, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcvVpStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fcvVpStatus.setDescription("The value of this object indicates the state of the entry of this table. It must be set to 'invalid' to delete the entry. The default value is 'valid'.")
fcvVpType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 30, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("local", 1), ("remote", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcvVpType.setStatus('mandatory')
if mibBuilder.loadTexts: fcvVpType.setDescription("The value of this object indicates whether this virtual port is: local : the virtual network is a Local Area Network (LAN), or remote : the virtual network is a group of remote equipments which may be reached through Wide Area Networks (WAN). The default value is 'remote'.")
fcvVpModuleId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 30, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcvVpModuleId.setStatus('mandatory')
if mibBuilder.loadTexts: fcvVpModuleId.setDescription("The value of this object indicates the module of the equipment to which this virtual port belongs to. Each module of the equipment has its own virtual ports. The module 0 can enable bridge forwarding, IP (Internet Protocol) routing, IPX (Internetwork Packet eXchange : Novell protocol) routing and CLNP (ConnectionLess Network Protocol) routing. The modules 1 and 2 can only act as IP host. So each of these two modules needs one remote VP when its SNMP agent must exchange SNMP datas with an SNMP manager. This is a decimal integer in the range 0 to 2. The default value is '0'.")
fcvLocalVirtualPorts = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 30, 10))
fcvLocalVirtualPortTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 30, 10, 1), )
if mibBuilder.loadTexts: fcvLocalVirtualPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcvLocalVirtualPortTable.setDescription("This table defines the characteristics of the local virtual ports. It is not possible to add or delete an entry of this table (each entry corresponds, in fcvVirtualPortTable, to one instance of fcvVpType equal to 'local').")
fcvLocalVirtualPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 30, 10, 1, 1), ).setIndexNames((0, "PCE-MIB", "fcvLvpVirtualPortId"))
if mibBuilder.loadTexts: fcvLocalVirtualPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcvLocalVirtualPortEntry.setDescription('An entry of fcvLocalVirtualPortTable.')
fcvLvpVirtualPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 30, 10, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 11))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcvLvpVirtualPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fcvLvpVirtualPortId.setDescription("The value of this object identifies one and only one local virtual port. Each local virtual port corresponds, in fcvVirtualPortTable, to one instance of fcvVpType equal to 'local'. This is a decimal integer in the range 0 to 11.")
fcvLvpLogicalPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 30, 10, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcvLvpLogicalPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fcvLvpLogicalPortId.setDescription("The value of this object indicates the logical port to which this local virtual port is associated. This logical port must exist in fclEthernetTable. This is a decimal integer in the range 0 to 131. The default value is '255' meaning 'empty value' (blank value on the equipment configurator).")
fcvLvpFiltering = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 30, 10, 10))
fcvLvpFltConditionTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 30, 10, 10, 1), )
if mibBuilder.loadTexts: fcvLvpFltConditionTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcvLvpFltConditionTable.setDescription("This table defines the conditions which may be used to make filters in fcvLvpFltFilterTable. Set any writable object(s) of this table to valid value(s) with a new index value to create an entry (the objects of the entry not present in this SET REQUEST will take their default values). Set fcvLvpFltCondStatus to 'invalid' to delete an entry.")
fcvLvpFltConditionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 30, 10, 10, 1, 1), ).setIndexNames((0, "PCE-MIB", "fcvLvpFltCondConditionId"))
if mibBuilder.loadTexts: fcvLvpFltConditionEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcvLvpFltConditionEntry.setDescription('An entry of fcvLvpFltConditionTable.')
fcvLvpFltCondConditionId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 30, 10, 10, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 99))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcvLvpFltCondConditionId.setStatus('mandatory')
if mibBuilder.loadTexts: fcvLvpFltCondConditionId.setDescription('The value of this object identifies one and only one condition. This condition identifier is used in fcvFltFilterTable to make filters. This is a decimal integer in the range 0 to 99.')
fcvLvpFltCondStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 30, 10, 10, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcvLvpFltCondStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fcvLvpFltCondStatus.setDescription("The value of this object indicates the state of the entry of this table. It must be set to 'invalid' to delete the entry. The default value is 'valid'.")
fcvLvpFltCondOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 30, 10, 10, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1513))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcvLvpFltCondOffset.setStatus('mandatory')
if mibBuilder.loadTexts: fcvLvpFltCondOffset.setDescription("The value of this object selects the four bytes as of which are applied the mask defined by fcvLvpFltCondMask and the value defined by fcvLvpFltCondValue. Examples : Offset at MAC level : Destination MAC address (6 bytes): 0 Source MAC address (6 bytes) : 6 PID field (2 bytes) : 12 Offset at IP level with Ethernet encapsulation : Protocol (1 byte): 23 Source IP address (4 bytes): 26 Destination IP address (4 bytes): 30 This is a decimal integer in the range 0 to 1513. The default value is '0'.")
fcvLvpFltCondMask = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 30, 10, 10, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcvLvpFltCondMask.setStatus('mandatory')
if mibBuilder.loadTexts: fcvLvpFltCondMask.setDescription("The value of this object defines the mask indicating the bits of the four bytes selected by fcvLvpFltCondOffset which are to be compared with the bits of the four bytes defined by fcvLvpFltCondValue. This is a four-bytes octet string with 8 digits in the range 0 to F, The default value is 'FF FF FF FF'.")
fcvLvpFltCondValue = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 30, 10, 10, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcvLvpFltCondValue.setStatus('mandatory')
if mibBuilder.loadTexts: fcvLvpFltCondValue.setDescription("The value of this object defines the values of the bits with which are compared, according to the mask defined by fcvLvpFltCondMask, the bits of the four bytes selected by fcvLvpFltCondOffset. This is a four-bytes octet string with 8 digits in the range 0 to F, The default value is 'FF FF FF FF'.")
fcvLvpFltFilterTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 30, 10, 10, 2), )
if mibBuilder.loadTexts: fcvLvpFltFilterTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcvLvpFltFilterTable.setDescription("This table defines the filters which may be used in the filtering table (fcvLvpFltFilteringTable). One filter is a combination of up to three conditions from fcvLvpFltConditionTable. Set any writable object(s) of this table to valid value(s) with a new index value to create an entry (the objects of the entry not present in this SET REQUEST will take their default values). Set fcvLvpFltFilterStatus to 'invalid' to delete an entry.")
fcvLvpFltFilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 30, 10, 10, 2, 1), ).setIndexNames((0, "PCE-MIB", "fcvLvpFltFilterId"))
if mibBuilder.loadTexts: fcvLvpFltFilterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcvLvpFltFilterEntry.setDescription('An entry of fcvLvpFltFilterTable.')
fcvLvpFltFilterId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 30, 10, 10, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcvLvpFltFilterId.setStatus('mandatory')
if mibBuilder.loadTexts: fcvLvpFltFilterId.setDescription('The value of this object identifies one and only one filter. This filter is a combination of one, two or three conditions defined in fcvLvpFltConditionTable. A filter selects the received frames which simultaneously verify those of the three conditions which are actually used for this filter. When several filters are simultaneously used on the same virtual port, the equipment analyses them in the incremental order of this filter identifier until whether the current frame is selected by one of these filters or all of them are analysed. So the numbering order must be done with a particular attention. This is a decimal integer in the range 0 to 199.')
fcvLvpFltFilterStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 30, 10, 10, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcvLvpFltFilterStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fcvLvpFltFilterStatus.setDescription("The value of this object indicates the state of the entry of this table. It must be set to 'invalid' to delete the entry. The default value is 'valid'.")
fcvLvpFltFilterCondition1Id = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 30, 10, 10, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcvLvpFltFilterCondition1Id.setStatus('mandatory')
if mibBuilder.loadTexts: fcvLvpFltFilterCondition1Id.setDescription("The value of this object specifies a first condition used by this filter. This condition must exist in fcvLvpFltConditionTable. Important : by convention, the condition identifier increased by 100 allows the opposite condition to be applied : the received frames not verifying this condition are then selected.. This is a decimal integer in the range 0 to 199. The default value is '255' meaning 'empty value' (blank value on the equipment configurator).")
fcvLvpFltFilterCondition2Id = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 30, 10, 10, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcvLvpFltFilterCondition2Id.setStatus('mandatory')
if mibBuilder.loadTexts: fcvLvpFltFilterCondition2Id.setDescription("The value of this object specifies a second condition used by this filter. This condition must exist in fcvLvpFltConditionTable. Important : by convention, the condition identifier increased by 100 allows the opposite condition to be applied : the received frames not verifying this condition are then selected.. This is a decimal integer in the range 0 to 199. The default value is '255' meaning 'empty value' (blank value on the equipment configurator).")
fcvLvpFltFilterCondition3Id = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 30, 10, 10, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcvLvpFltFilterCondition3Id.setStatus('mandatory')
if mibBuilder.loadTexts: fcvLvpFltFilterCondition3Id.setDescription("The value of this object specifies a third condition used by this filter. This condition must exist in fcvLvpFltConditionTable. Important : by convention, the condition identifier increased by 100 allows the opposite condition to be applied : the received frames not verifying this condition are then selected.. This is a decimal integer in the range 0 to 199. The default value is '255' meaning 'empty value' (blank value on the equipment configurator).")
fcvLvpFltFilteringTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 30, 10, 10, 3), )
if mibBuilder.loadTexts: fcvLvpFltFilteringTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcvLvpFltFilteringTable.setDescription("This table is the filtering table. It defines which filters are used by each virtual port to select the frames to which is applied the reject/accept decision. By default, if no filter has been configured or if the frame is not selected by any filter, it is accepted. Set any writable object(s) of this table to valid value(s) with a new index value to create an entry (the objects of the entry not present in this SET REQUEST will take their default values). Set fcvLvpFltFilteringStatus to 'invalid' to delete an entry.")
fcvLvpFltFilteringEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 30, 10, 10, 3, 1), ).setIndexNames((0, "PCE-MIB", "fcvLvpFltFilteringVirtualPortId"), (0, "PCE-MIB", "fcvLvpFltFilteringFilterId"))
if mibBuilder.loadTexts: fcvLvpFltFilteringEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcvLvpFltFilteringEntry.setDescription('An entry of fcvLvpFltFilteringTable.')
fcvLvpFltFilteringVirtualPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 30, 10, 10, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 11))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcvLvpFltFilteringVirtualPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fcvLvpFltFilteringVirtualPortId.setDescription('The value of this object identifies one and only one local virtual port. This local virtual port must exist in fcvLocalVirtualPortTable. Each local virtual port may use several filters : the equipment analyses them in the incremental order of the filter identifier until whether the current frame is selected by one of these filters or all of them are analysed. This is a decimal integer in the range 0 to 11.')
fcvLvpFltFilteringFilterId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 30, 10, 10, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 200))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcvLvpFltFilteringFilterId.setStatus('mandatory')
if mibBuilder.loadTexts: fcvLvpFltFilteringFilterId.setDescription('The value of this object identifies one filter used by this local virtual port. This filter must exist in fcvFltFilterTable. When several filters are simultaneously used on the same virtual port, the equipment analyses them in the incremental order of this filter identifier. So the numbering order must be done with a particular attention. Important : , the value 200 designates a special filter grouping all the frames received by this VP which were not selected by the other filters applied to this VP. This special filter is the last analysed filter for this VP. This filtering process concerns all the traffic received on one of the IP, IPX or CNLP routers or bridge whereas the filtering described in fciFlowTable is made only at the IP level. This is a decimal integer in the range 0 to 200.')
fcvLvpFltFilteringStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 30, 10, 10, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcvLvpFltFilteringStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fcvLvpFltFilteringStatus.setDescription("The value of this object indicates the state of the entry of this table. It must be set to 'invalid' to delete the entry. The default value is 'valid'.")
fcvLvpFltFilteringType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 30, 10, 10, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("deny", 1), ("permit", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcvLvpFltFilteringType.setStatus('mandatory')
if mibBuilder.loadTexts: fcvLvpFltFilteringType.setDescription("The value of this object specifies whether the frames selected by the filter are rejected or accepted : deny : the frames selected by the filter are rejected, therefore the frames not selected are accepted, permit : the frames selected by the filter are accepted, therefore the frames not selected are rejected. The default value is 'deny'.")
fcvRemoteVirtualPorts = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 30, 20))
fcvRvpCompression = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 30, 20, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("off", 1), ("networkToSubscriber", 2), ("subscriberToNetwork", 3), ("bothway", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcvRvpCompression.setStatus('mandatory')
if mibBuilder.loadTexts: fcvRvpCompression.setDescription("For all the connections described in fcvRvpConnectionTable, the value of this object indicates the compression enabling for each direction : off : compression is disabled, networkToSubscriber : compression is enabled for the flow from the remote peer to the equipment, subscriberToNetwork : compression is enabled for the flow from the equipment to the remote peer, bothway : compression is enabled for the two flows from and to the equipment. The default value is 'off'.")
fcvRvpCompressNegotiation = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 30, 20, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("onOptionalCompression", 2), ("onMandatoryCompression", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcvRvpCompressNegotiation.setStatus('mandatory')
if mibBuilder.loadTexts: fcvRvpCompressNegotiation.setDescription("The value of this object indicates, when the compression is active, whether the compression facility is negociated or not and, if negociated, the optional/mandatory status : off : negociation is disabled, onOptionalCompression : negociation is enabled and compression is optional, onMandatoryCompression : negociation is enabled and compression is mandatory. The default value is 'off'.")
fcvRvpCompressScrambling = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 30, 20, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcvRvpCompressScrambling.setStatus('mandatory')
if mibBuilder.loadTexts: fcvRvpCompressScrambling.setDescription("The value of this object indicates, when the compression is active, whether the scrambling is enabled or not. @ The default value is 'off'.")
fcvRvpCompressMultiPacketsTimer = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 30, 20, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1500))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcvRvpCompressMultiPacketsTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fcvRvpCompressMultiPacketsTimer.setDescription("The value of this object is the multi-packets timer in milliseconds. When the compression is active, the multi-packets function is specified in order to reduce the number of single packets (i.e., without 'More Data mark' = bit M set to 0) transmitted to the remote peer by grouping several packets in an only one compressed output packet. The value 0 disables this function (i.e., each single packet is individually compressed and sent). So to enable this function this timer must be different from 0 on both the local equipment and the remote peer (even when the compression direction is set to 'subscriberToNetwork' or 'subscriberToNetwork'). This timer starts when the equipment begins to fill a new compressed output packet and it is normally stopped when this packet is sent. When this timer runs out the equipment sends this compressed packet even if it is not full. This is a decimal integer in the range 0 to 1500 by step of 100. The default value is '0'.")
fcvRvpReliableVirtualCircuit = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 30, 20, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcvRvpReliableVirtualCircuit.setStatus('mandatory')
if mibBuilder.loadTexts: fcvRvpReliableVirtualCircuit.setDescription("For all the connections described in fcvRvpConnectionTable, the value of this object indicates whether the Reliable Virtual Circuit (RVC) service is enabled or not : off : no RVC, the VCs are considered as normal VCs, no particular processing, on : all calls transmitted by the subscriber establish RVCs, it is also possible to receive calls with RVC option. The default value is 'off'.")
fcvRvpBe = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 30, 20, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcvRvpBe.setStatus('mandatory')
if mibBuilder.loadTexts: fcvRvpBe.setDescription('Entrant BE')
fcvRvpConversionAimedPoint = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 30, 20, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcvRvpConversionAimedPoint.setStatus('mandatory')
if mibBuilder.loadTexts: fcvRvpConversionAimedPoint.setDescription('Conversion adresse : point vise')
fcvRvpConversionIncomingCall = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 30, 20, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("off", 1), ("callingAddress", 2), ("calledAddress", 3), ("callingAddressAndCalledAddress", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcvRvpConversionIncomingCall.setStatus('mandatory')
if mibBuilder.loadTexts: fcvRvpConversionIncomingCall.setDescription("Conversion d'adresse sur appel entrant")
fcvRvpConversionOutgoingCall = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 30, 20, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("off", 1), ("callingAddress", 2), ("calledAddress", 3), ("callingAddressAndCalledAddress", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcvRvpConversionOutgoingCall.setStatus('mandatory')
if mibBuilder.loadTexts: fcvRvpConversionOutgoingCall.setDescription('Conversion adresse sur appel sortant')
fcvRvpConversionAddressCheck = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 30, 20, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("off", 1), ("onIncomingCall", 2), ("onOutgoingCall", 3), ("onIncomingCallAndOutgoingCall", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcvRvpConversionAddressCheck.setStatus('mandatory')
if mibBuilder.loadTexts: fcvRvpConversionAddressCheck.setDescription('Conversion adresse : controle de la presence dans les tables de conversion')
fcvRvpConvMultiCalledAddrInCall = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 30, 20, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcvRvpConvMultiCalledAddrInCall.setStatus('mandatory')
if mibBuilder.loadTexts: fcvRvpConvMultiCalledAddrInCall.setDescription("Numero d'identification pour conversion d'adresse d'appele multi-criteres en entree")
fcvRvpConvMultiCallingAddrInCall = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 30, 20, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcvRvpConvMultiCallingAddrInCall.setStatus('mandatory')
if mibBuilder.loadTexts: fcvRvpConvMultiCallingAddrInCall.setDescription("Numero d'identification pour conversion d'adresse d'appelant multi-criteres en entree")
fcvRvpConvMultiCalledAddrOutCall = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 30, 20, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcvRvpConvMultiCalledAddrOutCall.setStatus('mandatory')
if mibBuilder.loadTexts: fcvRvpConvMultiCalledAddrOutCall.setDescription("Numero d'identification pour conversion d'adresse d'appele multi-criteres en sortie")
fcvRvpConvMultiCallingAddrOutCall = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 30, 20, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcvRvpConvMultiCallingAddrOutCall.setStatus('mandatory')
if mibBuilder.loadTexts: fcvRvpConvMultiCallingAddrOutCall.setDescription("Numero d'identification pour conversion d'adresse d'appelant multi-criteres en sortie")
fcvRvpCallAcceptwithReverseCharging = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 30, 20, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcvRvpCallAcceptwithReverseCharging.setStatus('mandatory')
if mibBuilder.loadTexts: fcvRvpCallAcceptwithReverseCharging.setDescription('Acceptation appel avec TAD')
fcvRvpCos = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 30, 20, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 1))).clone(namedValues=NamedValues(("ubr", 3), ("vbr", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcvRvpCos.setStatus('mandatory')
if mibBuilder.loadTexts: fcvRvpCos.setDescription("For all the connections described in fcvRvpConnectionTable, the value of this object indicates the Class Of Service (COS) desired on a Frame Relay network. This object is meaningless if the call is established on another transport network. ubr : undefined bit rate, vbr : variable bit rate. The default value is 'ubr'.")
fcvRvpCir = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 30, 20, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(600, 2048000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcvRvpCir.setStatus('mandatory')
if mibBuilder.loadTexts: fcvRvpCir.setDescription("For all the connections described in fcvRvpConnectionTable, the value of this object indicates the Committed Infomation Rate (CIR) in bits per second desired on a Frame Relay network. This object is meaningless if the call is established on another transport network. The CIR is the subscriber data rate that the Frame Relay network commits to deliver under normal network conditions. This is a decimal integer in the range 600 to 2048000. Only the following values are valid : ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ | # | value | # | value | # | value | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ | 0 | 0 | 17 | 144000 | 33 | 1152000 | | 2 | 600 | 18 | 192000 | 34 | 1216000 | | 3 | 1200 | 19 | 256000 | 35 | 1280000 | | 4 | 2400 | 20 | 320000 | 36 | 1344000 | | 5 | 4800 | 21 | 384000 | 37 | 1408000 | | 6 | 9600 | 22 | 448000 | 38 | 1472000 | | 7 | 14400 | 23 | 512000 | 39 | 1536000 | | 8 | 19200 | 24 | 576000 | 40 | 1600000 | | 9 | 32000 | 25 | 640000 | 41 | 1664000 | | 10 | 38400 | 26 | 704000 | 42 | 1728000 | | 11 | 48000 | 27 | 768000 | 43 | 1792000 | | 12 | 56000 | 28 | 832000 | 44 | 1856000 | | 13 | 64000 | 29 | 896000 | 45 | 1920000 | | 14 | 72000 | 30 | 960000 | 46 | 1984000 | | 15 | 96000 | 31 | 1024000 | 47 | 2048000 | | 16 | 128000 | 32 | 1088000 | | | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ The default value is '4294967295' meaning 'empty value' (blank value on the equipment configurator).")
fcvRvpMinCir = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 30, 20, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcvRvpMinCir.setStatus('mandatory')
if mibBuilder.loadTexts: fcvRvpMinCir.setDescription("For all the connections described in fcvRvpConnectionTable, the value of this object indicates the minimum Committed Infomation Rate (CIR) in bits per second desired on a Frame Relay network. This object is meaningless if the call is established on another transport network. This is a decimal integer in the range 600 to 2048000. Only the following values are valid : ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ | # | value | # | value | # | value | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ | 0 | 0 | 17 | 144000 | 33 | 1152000 | | 2 | 600 | 18 | 192000 | 34 | 1216000 | | 3 | 1200 | 19 | 256000 | 35 | 1280000 | | 4 | 2400 | 20 | 320000 | 36 | 1344000 | | 5 | 4800 | 21 | 384000 | 37 | 1408000 | | 6 | 9600 | 22 | 448000 | 38 | 1472000 | | 7 | 14400 | 23 | 512000 | 39 | 1536000 | | 8 | 19200 | 24 | 576000 | 40 | 1600000 | | 9 | 32000 | 25 | 640000 | 41 | 1664000 | | 10 | 38400 | 26 | 704000 | 42 | 1728000 | | 11 | 48000 | 27 | 768000 | 43 | 1792000 | | 12 | 56000 | 28 | 832000 | 44 | 1856000 | | 13 | 64000 | 29 | 896000 | 45 | 1920000 | | 14 | 72000 | 30 | 960000 | 46 | 1984000 | | 15 | 96000 | 31 | 1024000 | 47 | 2048000 | | 16 | 128000 | 32 | 1088000 | | | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ The default value is '4294967295' meaning 'empty value' (blank value on the equipment configurator).")
fcvRvpConnectionTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 30, 20, 23), )
if mibBuilder.loadTexts: fcvRvpConnectionTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcvRvpConnectionTable.setDescription("This table defines the connections to each remote bridge or router on WAN virtual networks. Each connection is attached to one remote virtual port of a module of the equipment. Set any writable object(s) of this table to valid value(s) with a new index value to create an entry (the objects of the entry not present in this SET REQUEST will take their default values). Set fcvRvpConnStatus to 'invalid' to delete an entry.")
fcvRvpConnectionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 30, 20, 23, 1), ).setIndexNames((0, "PCE-MIB", "fcvRvpConnRemoteAddress"), (0, "PCE-MIB", "fcvRvpConnEncapsulation"), (0, "PCE-MIB", "fcvRvpConnConnectionId"))
if mibBuilder.loadTexts: fcvRvpConnectionEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcvRvpConnectionEntry.setDescription('An entry of fcvRvpConnectionTable.')
fcvRvpConnRemoteAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 30, 20, 23, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcvRvpConnRemoteAddress.setStatus('mandatory')
if mibBuilder.loadTexts: fcvRvpConnRemoteAddress.setDescription("The value of this object is the X121 address of the called remote bridge or router. This value is the called address specified in the call packet sent from this module. Several connections using different encapsulations may be established with the same remote equipment. But when multiplexing is used it must be the only encapsulation used with this particular remote equipment. This is a eight-bytes octet string with : up to 15 digits in the range 0 to 9, mandatory 'F' digits to pad the value until a total of 16 digits (the equipment configurator does not need this final padding).")
fcvRvpConnEncapsulation = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 30, 20, 23, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 10, 11, 20, 30, 31, 40))).clone(namedValues=NamedValues(("multiplexing", 1), ("bridge", 10), ("bridgeSpecific", 11), ("ip", 20), ("ipx", 30), ("ipxSpecific", 31), ("clnp", 40)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcvRvpConnEncapsulation.setStatus('mandatory')
if mibBuilder.loadTexts: fcvRvpConnEncapsulation.setDescription('The value of this object indicates the protocol(s) to be transferred on the connection : multiplexing : all protocols may be transported on this connection and it must be the only encapsulation specified for this X121 address, bridge : bridge protocol, bridgeSpecific : bridge specific protocol, ip : internet protocol, ipx : internetwork packet exchange protocol, ipxSpecific : specific internetwork packet exchange protocol, clnp : connectionless network protocol.')
fcvRvpConnConnectionId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 30, 20, 23, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcvRvpConnConnectionId.setStatus('mandatory')
if mibBuilder.loadTexts: fcvRvpConnConnectionId.setDescription("When several connections are established with the same encapsulation for the same remote equipment, the value of this object identifies this particular connection. This connection identifier must also be configured on the remote equipment. When only one connection is established with the same encapsulation for the same remote equipment, the value of this object is '255' (blank value on the equipment configurator) meaning 'unused'. This is a decimal integer in the range 1 to 8 or equal to 255.")
fcvRvpConnStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 30, 20, 23, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcvRvpConnStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fcvRvpConnStatus.setDescription("The value of this object indicates the state of the entry of this table. It must be set to 'invalid' to delete the entry. The default value is 'valid'.")
fcvRvpConnFlowTypeMask = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 30, 20, 23, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcvRvpConnFlowTypeMask.setStatus('mandatory')
if mibBuilder.loadTexts: fcvRvpConnFlowTypeMask.setDescription("The value of this object is a mask specifying the families (defined by fciFlowType) which have to transit via this connection. Example : let us suppose that fciFlowTable defines the content of families 2, 8, 16, 32 and 64 and this connection is set up to process families 8, 16 and 32. The mask therefore takes on value : 8 + 16 + 32 = 56. If two connections to the same address with the same encapsulation select the same family, the family will be oriented towards the first of these connections (increasing order of the connection identifiers). By convention, the value 255 selects, out of all the flows directed towards a WAN address, not only all the specified flows (i.e., defined in fciFlowTable) but also the unspecified flows (i.e., not defined in fciFlowTable). This is the default value to be used when flow separation is not being used. This is a decimal integer in the range 1 to 255. The default value is '255'.")
fcvRvpConnModule0VpId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 30, 20, 23, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 11))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcvRvpConnModule0VpId.setStatus('mandatory')
if mibBuilder.loadTexts: fcvRvpConnModule0VpId.setDescription("The value of this object indicates the virtual port used by the Bridge and Router functions of the module 0 to communicate with the remote equipment. This VP must exist in fcvVirtualPortTable and must be a remote VP. When this connection is not processed by the module 0 this value is set to '255' (blank value on the equipment configurator). This is a decimal integer in the range 0 to 11. The default value is '255'.")
fcvRvpConnModule1VpId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 30, 20, 23, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 11))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcvRvpConnModule1VpId.setStatus('mandatory')
if mibBuilder.loadTexts: fcvRvpConnModule1VpId.setDescription("The value of this object indicates the virtual port used by the Bridge and Router functions of the module 1 to communicate with the remote equipment. This VP must exist in fcvVirtualPortTable and must be a remote VP. When this connection is not processed by the module 1 this value is set to '255' (blank value on the equipment configurator). This is a decimal integer in the range 0 to 11. The default value is '255'.")
fcvRvpConnModule2VpId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 30, 20, 23, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 11))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcvRvpConnModule2VpId.setStatus('mandatory')
if mibBuilder.loadTexts: fcvRvpConnModule2VpId.setDescription("The value of this object indicates the virtual port used by the Bridge and Router functions of the module 2 to communicate with the remote equipment. This VP must exist in fcvVirtualPortTable and must be a remote VP. When this connection is not processed by the module 2 this value is set to '255' (blank value on the equipment configurator). This is a decimal integer in the range 0 to 11. The default value is '255'.")
fcvRvpConnCallDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 30, 20, 23, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("calling", 1), ("called", 2), ("auto", 3), ("datagram", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcvRvpConnCallDirection.setStatus('mandatory')
if mibBuilder.loadTexts: fcvRvpConnCallDirection.setDescription("The value of this object defines the mode used to establish this connection. The authorized values are : calling : the caller is this equipment (at initialization time), called : the caller is the remote this equipment (at initialization time), auto : automatic choise between 'calling' and 'called' (at initialization time with call collision processing), datagram : the caller is this equipment or the remote one (at any time) depending on which of them is the first one that wishes send datas. The default value is 'datagram'.")
fcvRvpConnGrouping = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 30, 20, 23, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcvRvpConnGrouping.setStatus('mandatory')
if mibBuilder.loadTexts: fcvRvpConnGrouping.setDescription("The value of this object indicates whether the frame grouping/separation service (according to a specific proprietary encapsulation) is enabled or not. It requires the configuration of the fast select facility accross the WAN network. The frame grouping option is compatible only with the bridgeSpecific and ip encapsulations (see fcvRvpConnEncapsulation). The default value is 'off'.")
fcvRvpConnMinimumRecallTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 30, 20, 23, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 990))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcvRvpConnMinimumRecallTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fcvRvpConnMinimumRecallTimer.setDescription("The value of this object is the minimum recall timer in seconds. This timer starts when the equipment initiates the call and it is normally stopped when this call is successfull. When this timer runs out the equipment initiates a new call. This is a decimal integer in the range 0 to 990 by step of 10. The default value is '100'.")
fcvRvpConnInactivityTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 30, 20, 23, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2540))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcvRvpConnInactivityTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fcvRvpConnInactivityTimer.setDescription("The value of this object is the inactivity timer in seconds. This timer starts one minute after the call is successfull. When this timer runs out, if there was traffic on this call during this period, this timer is re-started otherwise this call is cleared. This is a decimal integer in the range 0 to 2540 by step of 10. The default value is '30'.")
fcvRvpConnCir = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 30, 20, 23, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(600, 2048000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcvRvpConnCir.setStatus('mandatory')
if mibBuilder.loadTexts: fcvRvpConnCir.setDescription("The value of this object indicates, for this connection, the Committed Infomation Rate (CIR) in bits per second desired on a Frame Relay network. This object is meaningless if the call is established on another transport network. The CIR is the subscriber data rate that the Frame Relay network commits to deliver under normal network conditions. This is a decimal integer in the range 600 to 2048000. Only the following values are valid : ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ | # | value | # | value | # | value | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ | 0 | 0 | 17 | 144000 | 33 | 1152000 | | 2 | 600 | 18 | 192000 | 34 | 1216000 | | 3 | 1200 | 19 | 256000 | 35 | 1280000 | | 4 | 2400 | 20 | 320000 | 36 | 1344000 | | 5 | 4800 | 21 | 384000 | 37 | 1408000 | | 6 | 9600 | 22 | 448000 | 38 | 1472000 | | 7 | 14400 | 23 | 512000 | 39 | 1536000 | | 8 | 19200 | 24 | 576000 | 40 | 1600000 | | 9 | 32000 | 25 | 640000 | 41 | 1664000 | | 10 | 38400 | 26 | 704000 | 42 | 1728000 | | 11 | 48000 | 27 | 768000 | 43 | 1792000 | | 12 | 56000 | 28 | 832000 | 44 | 1856000 | | 13 | 64000 | 29 | 896000 | 45 | 1920000 | | 14 | 72000 | 30 | 960000 | 46 | 1984000 | | 15 | 96000 | 31 | 1024000 | 47 | 2048000 | | 16 | 128000 | 32 | 1088000 | | | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ The default value is '4294967295' meaning 'empty value' (blank value on the equipment configurator). ")
fcvRvpConnCos = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 30, 20, 23, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 1, 2))).clone(namedValues=NamedValues(("ubr", 3), ("global", 4), ("vbr", 1), ("vbr-rt", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcvRvpConnCos.setStatus('mandatory')
if mibBuilder.loadTexts: fcvRvpConnCos.setDescription('Requested Class of Service for this connection, the Cos can be configured more globally.')
fcvRvpConnBe = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 30, 20, 23, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcvRvpConnBe.setStatus('mandatory')
if mibBuilder.loadTexts: fcvRvpConnBe.setDescription('Be')
fcSna = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 32))
fcsnaLocalVirtualPort = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 1))
fcsnaLvpLocalLanPuTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 1, 1), )
if mibBuilder.loadTexts: fcsnaLvpLocalLanPuTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaLvpLocalLanPuTable.setDescription('')
fcsnaLvpLocalLanPuEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 1, 1, 1), ).setIndexNames((0, "PCE-MIB", "fcsnaLvpLlpVirtualPortId"), (0, "PCE-MIB", "fcsnaLvpLlpPuId"))
if mibBuilder.loadTexts: fcsnaLvpLocalLanPuEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaLvpLocalLanPuEntry.setDescription('An entry of fcsnaLvpLocalLanPuTable.')
fcsnaLvpLlpVirtualPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 11))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcsnaLvpLlpVirtualPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaLvpLlpVirtualPortId.setDescription('VP id')
fcsnaLvpLlpPuId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1999))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcsnaLvpLlpPuId.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaLvpLlpPuId.setDescription('Physical Unit id')
fcsnaLvpLlpStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsnaLvpLlpStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaLvpLlpStatus.setDescription('Status')
fcsnaLvpParameters = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 1, 10))
fcsnaLvpParamLinkType = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 1, 10, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("frontal", 1), ("remote", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsnaLvpParamLinkType.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaLvpParamLinkType.setDescription("The type of frontal must be connected to a primary link-station or negociable link station that will become the primary. The type of remote must be connected to a secondary link-station or negociable link station that will become the secondary. The default value is 'frontal'")
fcsnaLvpParamFrameFormat = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 1, 10, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("e802-3", 1), ("v2-DIX", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsnaLvpParamFrameFormat.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaLvpParamFrameFormat.setDescription('The unit supports IEEE 802.3 and V2 DIX Ethernet frame format.')
fcsnaLvpParamLocalTest = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 1, 10, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsnaLvpParamLocalTest.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaLvpParamLocalTest.setDescription("This feature is used in 'frontal' mode. If this feature is set to on, and when the internal connection is established, it will send a local test frame to the primary link-station.")
fcsnaLvpParamCallDirection = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 1, 10, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("called", 1), ("calling", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsnaLvpParamCallDirection.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaLvpParamCallDirection.setDescription('Frontal mode is called. Remote mode is calling.')
fcsnaLvpMacAddressTrans = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 1, 10, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsnaLvpMacAddressTrans.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaLvpMacAddressTrans.setDescription('MAC address translation.')
fcsnaLvpParamT1 = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 1, 10, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(100, 25000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsnaLvpParamT1.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaLvpParamT1.setDescription('T1 Reply timer. A link-station uses T1 to detect a failure to receive a required acknowlegment or response. T1 runs when there are acknowlegments outstanding, it is reset when acknowlegments are received.')
fcsnaLvpParamN2 = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 1, 10, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsnaLvpParamN2.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaLvpParamN2.setDescription('The maximum number of transmissions. If the reply timer expires for whatever reason, an S-frame with poll bit set is sent to sollicit a response from remote link-station. If there is still no response after N2 retry, the link is deemed to be inoperative.')
fcsnaLvpParamT2 = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 1, 10, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(100, 15000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsnaLvpParamT2.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaLvpParamT2.setDescription('Receiver acknowledge timer. The end station uses this timer to delay the seding of an acknowlegment for a received I-frame LPDU. The link-station starts T2 when it receives an I-frame and resets it when it sends an acknowlegment. T2 must be less than T1.')
fcsnaLvpParamN3 = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 1, 10, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsnaLvpParamN3.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaLvpParamN3.setDescription("Number of I-frame LPDU's received before sending an acknowledgment.")
fcsnaLvpParamNW = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 1, 10, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsnaLvpParamNW.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaLvpParamNW.setDescription('Number of acknowledgments needed to increment Ww.')
fcsnaLvpParamTW = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 1, 10, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsnaLvpParamTW.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaLvpParamTW.setDescription('LLC transmit window size. This is maximum number of sequentially numbered Iframe that the link-station may have outstanding at any given time.')
fcsnaLvpParamRW = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 1, 10, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsnaLvpParamRW.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaLvpParamRW.setDescription('LLC receive window size. This is the maximum number of unacknowlegment sequentially numbered I-frame the link-station can receive from the remote station.')
fcsnaLvpParamMinRecallTimer = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 1, 10, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 990))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsnaLvpParamMinRecallTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaLvpParamMinRecallTimer.setDescription('Slow call timer.')
fcsnaLvpParamSubscriberNumber = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 1, 10, 21), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsnaLvpParamSubscriberNumber.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaLvpParamSubscriberNumber.setDescription("The value of this object is the SB number added to the DNICZO of the equipment to make the calling address in a call sent from this logical port. The value must contain 2 digits (digits 0..9). The default value is '22'. ")
fcsnaLvpParamReliableVc = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 1, 10, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 2, 4))).clone(namedValues=NamedValues(("off", 1), ("clear", 3), ("subscribe", 2), ("check", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsnaLvpParamReliableVc.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaLvpParamReliableVc.setDescription("The value of this object is used to enable the Reliable Virtual Circuit service. The authorized values are : off : no RVC, the VCs are considered as normal VCs, no particular processing, clear : RVCs are not allowed for the subscriber, each attempt to establish a RVC provokes a clear of the connection, subscribe : all calls transmitted by the subscriber establish RVCs, it is also possible to receive calls with RVC option, check : for a link to a subscriber : when a call with RVC option is received, a RVC is established for a link to a network : the RVC option is ignored when it is present in a call sent by a local subscriber, the connection is cleared when the RVC option is present in a call sent by the network. The default value is 'off'. ")
fcsnaLvpParamCompression = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 1, 10, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("off", 1), ("networkToSubscriber", 2), ("subscriberToNetwork", 3), ("bothway", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsnaLvpParamCompression.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaLvpParamCompression.setDescription("The value of this object indicates the compression enabling for each direction. The authorized values are : off : no compression, networkToSubscriber : compression of the flow from the remote peer to the equipment, subscriberToNetwork : compression of the flow from the equipment to the remote peer, bothway : compression of the two flows from and to the equipment. The default value is 'off'.")
fcsnaLvpParamCompressNegotiation = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 1, 10, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("onOptionalCompression", 2), ("onMandatoryCompression", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsnaLvpParamCompressNegotiation.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaLvpParamCompressNegotiation.setDescription("The value of this object indicates whether the compression facility is negociated or not and, if negociated, the optional/obligatory status. The authorized values are : off' :no negociation, onOptionalCompression : negociation but compression is optional, onMandatoryCompression : negociation and compression is mandatory. The default value is 'off'.")
fcsnaLvpParamCompressScrambling = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 1, 10, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsnaLvpParamCompressScrambling.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaLvpParamCompressScrambling.setDescription("The value of this object indicates, when the compression is active, whether the scrambling is enabled or not. The default value is 'off'. ")
fcsnaLvpParamCompressMultiPacketsTimer = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 1, 10, 33), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1500))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsnaLvpParamCompressMultiPacketsTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaLvpParamCompressMultiPacketsTimer.setDescription("The value of this object defines the maximum waiting time, in milliseconds by steps of 100 milliseconds , which, if there is not another packet to compress, the packet of compressed packets is sent beyond (this permits to reduce the number of packets transmitted to the remote peer). The authorized values are '0..1500'. '0' means no packets grouping (i. e. : each packet is individually compressed and sent). The default value is '0'. ")
fcsnaLvpParamCos = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 1, 10, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 1))).clone(namedValues=NamedValues(("ubr", 3), ("vbr", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsnaLvpParamCos.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaLvpParamCos.setDescription('Class Of Service VBR or UBR.')
fcsnaLvpParamCir = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 1, 10, 41), Integer32().subtype(subtypeSpec=ValueRangeConstraint(600, 2048000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsnaLvpParamCir.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaLvpParamCir.setDescription('Committed information Rate is the maximum number of bits per seconds which an end station can transmit into the network . This is the access rate of the user-network interface and it is limited by the line speed of the user-network connection and established by subscription.')
fcsnaLvpParamCirMin = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 1, 10, 42), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsnaLvpParamCirMin.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaLvpParamCirMin.setDescription('If the end station is informed about the congestion of the network, this is the minimum CIR that the end station can transmit into the network.')
fcsnaLvpParamBc = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 1, 10, 43), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsnaLvpParamBc.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaLvpParamBc.setDescription('The Committed Burst Size is a measure for the volume of data for which the network will garantee message delivery under normal conditions. It is measured during the committed rate measurement interval (Tc).')
fcsnaLvpParamBe = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 1, 10, 44), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsnaLvpParamBe.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaLvpParamBe.setDescription('The Excess Burst Size is the maximum amount of uncommitted data in access of Bc that the network will attemp to deliver during a time interval (Tc). End stations are allowed to transmit data in excess of the committed burst rate.')
fcsnaLvpTrParameters = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 1, 20))
fcsnaLvpTrParamLinkType = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 1, 20, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("frontal", 1), ("remote", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsnaLvpTrParamLinkType.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaLvpTrParamLinkType.setDescription('frontal must be connected to the a primary link-station or negociable link-station that will become the primary, remote must be connected to the a decondary link-station or negociable link-station that will become the secondary')
fcsnaLvpTrParamBroadcastType = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 1, 20, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("all-routes", 2), ("single-route", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsnaLvpTrParamBroadcastType.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaLvpTrParamBroadcastType.setDescription('This field defines the type of broadcast test frame. The unit sends to a destination to determine the best route')
fcsnaLvpTrParamLocalTest = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 1, 20, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsnaLvpTrParamLocalTest.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaLvpTrParamLocalTest.setDescription("This feature is used in 'frontal' mode. If this feature is set to on, and when the internal connection is established, it will send a local test frame to the primary link-station. ")
fcsnaLvpTrParamCallDirection = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 1, 20, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("called", 1), ("calling", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsnaLvpTrParamCallDirection.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaLvpTrParamCallDirection.setDescription('Frontal mode is called. Remote mode is calling. ')
fcsnaLvpTrRingNo = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 1, 20, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsnaLvpTrRingNo.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaLvpTrRingNo.setDescription('This field identifies the ring number of the LAN to which the unit connects. ')
fcsnaLvpTrBridgeNo = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 1, 20, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsnaLvpTrBridgeNo.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaLvpTrBridgeNo.setDescription("A unit attached to a Token Ring LAN represents a bridge between the physical LAN ring and the network's virtual ring. ")
fcsnaLvpTrMacAddressTrans = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 1, 20, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsnaLvpTrMacAddressTrans.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaLvpTrMacAddressTrans.setDescription('MAC address translation')
fcsnaLvpTrParamT1 = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 1, 20, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(100, 25000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsnaLvpTrParamT1.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaLvpTrParamT1.setDescription('T1 Reply timer. A link-station uses T1 to detect a failure to receive a required acknowlegment or response. T1 runs when there are acknowlegments outstanding, it is reset when acknowlegments are received. ')
fcsnaLvpTrParamN2 = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 1, 20, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsnaLvpTrParamN2.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaLvpTrParamN2.setDescription('The maximum number of transmissions. If the reply timer expires for whatever reason, an S-frame with poll bit set is sent to sollicit a response from remote link-station. If there is still no response after N2 retry, the link is deemed to be inoperative. ')
fcsnaLvpTrParamT2 = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 1, 20, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(100, 15000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsnaLvpTrParamT2.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaLvpTrParamT2.setDescription('Receiver acknowledge timer. The end station uses this timer to delay the seding of an acknowlegment for a received I-frame LPDU. The link-station starts T2 when it receives an I-frame and resets it when it sends an acknowlegment. T2 must be less than T1.')
fcsnaLvpTrParamN3 = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 1, 20, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsnaLvpTrParamN3.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaLvpTrParamN3.setDescription("Number of I-frame LPDU's received before sending an acknowledgment ")
fcsnaLvpTrParamNW = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 1, 20, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsnaLvpTrParamNW.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaLvpTrParamNW.setDescription('Number of acknowledgments needed to increment Ww ')
fcsnaLvpTrParamTW = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 1, 20, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsnaLvpTrParamTW.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaLvpTrParamTW.setDescription('LLC transmit window size. This is maximum number of sequentially numbered Iframe that the link-station may have outstanding at any given time. ')
fcsnaLvpTrParamRW = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 1, 20, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsnaLvpTrParamRW.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaLvpTrParamRW.setDescription('LLC receive window size. This is the maximum number of unacknowlegment sequentially numbered I-frame the link-station can receive from the remote station. ')
fcsnaLvpTrParamMinRecallTimer = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 1, 20, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 990))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsnaLvpTrParamMinRecallTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaLvpTrParamMinRecallTimer.setDescription('Slow call timer.')
fcsnaLvpTrParamSubscriberNumber = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 1, 20, 21), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsnaLvpTrParamSubscriberNumber.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaLvpTrParamSubscriberNumber.setDescription("The value of this object is the SB number added to the DNICZO of the equipment to make the calling address in a call sent from this logical port. The value must contain 2 digits (digits 0..9). The default value is '22'.")
fcsnaLvpTrParamReliableVc = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 1, 20, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 2, 4))).clone(namedValues=NamedValues(("off", 1), ("clear", 3), ("subscribe", 2), ("check", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsnaLvpTrParamReliableVc.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaLvpTrParamReliableVc.setDescription("The value of this object is used to enable the Reliable Virtual Circuit service. The authorized values are : off : no RVC, the VCs are considered as normal VCs, no particular processing, clear : RVCs are not allowed for the subscriber, each attempt to establish a RVC provokes a clear of the connection, subscribe : all calls transmitted by the subscriber establish RVCs, it is also possible to receive calls with RVC option, check : for a link to a subscriber : when a call with RVC option is received, a RVC is established for a link to a network : the RVC option is ignored when it is present in a call sent by a local subscriber, the connection is cleared when the RVC option is present in a call sent by the network. The default value is 'off'. ")
fcsnaLvpTrParamCompression = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 1, 20, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("off", 1), ("networkToSubscriber", 2), ("subscriberToNetwork", 3), ("bothway", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsnaLvpTrParamCompression.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaLvpTrParamCompression.setDescription("The value of this object indicates the compression enabling for each direction. The authorized values are : off : no compression, networkToSubscriber : compression of the flow from the remote peer to the equipment, subscriberToNetwork : compression of the flow from the equipment to the remote peer, bothway : compression of the two flows from and to the equipment. The default value is 'off'. ")
fcsnaLvpTrParamCompressNegotiation = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 1, 20, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("onOptionalCompression", 2), ("onMandatoryCompression", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsnaLvpTrParamCompressNegotiation.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaLvpTrParamCompressNegotiation.setDescription("The value of this object indicates whether the compression facility is negociated or not and, if negociated, the optional/obligatory status. The authorized values are : off' :no negociation, onOptionalCompression : negociation but compression is optional, onMandatoryCompression : negociation and compression is mandatory. The default value is 'off'. ")
fcsnaLvpTrParamCompressScrambling = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 1, 20, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsnaLvpTrParamCompressScrambling.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaLvpTrParamCompressScrambling.setDescription("The value of this object indicates, when the compression is active, whether the scrambling is enabled or not. The default value is 'off'. ")
fcsnaLvpTrParamCompressMultiPacketsTimer = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 1, 20, 33), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1500))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsnaLvpTrParamCompressMultiPacketsTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaLvpTrParamCompressMultiPacketsTimer.setDescription("The value of this object defines the maximum waiting time, in milliseconds by steps of 100 milliseconds , which, if there is not another packet to compress, the packet of compressed packets is sent beyond (this permits to reduce the number of packets transmitted to the remote peer). The authorized values are '0..1500'. '0' means no packets grouping (i. e. : each packet is individually compressed and sent). The default value is '0'. ")
fcsnaLvpTrParamCos = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 1, 20, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 1))).clone(namedValues=NamedValues(("ubr", 3), ("vbr", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsnaLvpTrParamCos.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaLvpTrParamCos.setDescription('Class Of Service VBR or UBR.')
fcsnaLvpTrParamCir = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 1, 20, 41), Integer32().subtype(subtypeSpec=ValueRangeConstraint(600, 2048000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsnaLvpTrParamCir.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaLvpTrParamCir.setDescription('Committed information Rate is the maximum number of bits per seconds which an end station can transmit into the network . This is the access rate of the user-network interface and it is limited by the line speed of the user-network connection and established by subscription.')
fcsnaLvpTrParamCirMin = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 1, 20, 42), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsnaLvpTrParamCirMin.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaLvpTrParamCirMin.setDescription('If the end station is informed about the congestion of the network, this is the minimum CIR that the end station can transmit into the network. ')
fcsnaLvpTrParamBc = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 1, 20, 43), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsnaLvpTrParamBc.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaLvpTrParamBc.setDescription('The Committed Burst Size is a measure for the volume of data for which the network will garantee message delivery under normal conditions. It is measured during the committed rate measurement interval (Tc). ')
fcsnaLvpTrParamBe = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 1, 20, 44), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsnaLvpTrParamBe.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaLvpTrParamBe.setDescription('The Excess Burst Size is the maximum amount of uncommitted data in access of Bc that the network will attemp to deliver during a time interval (Tc). End stations are allowed to transmit data in excess of the committed burst rate. ')
fcsnaGeneralParameters = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 5))
fcsnaGpRoutingTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 5, 1), )
if mibBuilder.loadTexts: fcsnaGpRoutingTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaGpRoutingTable.setDescription('')
fcsnaGpRoutingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 5, 1, 1), ).setIndexNames((0, "PCE-MIB", "fcsnaGpRoutClusterPuId"), (0, "PCE-MIB", "fcsnaGpRoutHostPuId"))
if mibBuilder.loadTexts: fcsnaGpRoutingEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaGpRoutingEntry.setDescription('An entry of fcsnaGpRoutingTable.')
fcsnaGpRoutClusterPuId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 999))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcsnaGpRoutClusterPuId.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaGpRoutClusterPuId.setDescription('PU id cluster')
fcsnaGpRoutHostPuId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1000, 1999))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcsnaGpRoutHostPuId.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaGpRoutHostPuId.setDescription('PU id host')
fcsnaGpRoutStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 5, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsnaGpRoutStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaGpRoutStatus.setDescription('Status')
fcsnaGpRoutDsap = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 5, 1, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsnaGpRoutDsap.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaGpRoutDsap.setDescription('DSAP This field defines the service access point for the PU session. The unit uses this Address in conjunction withe the MAC address to to map the session to its destination. If the PU originates the call, this is the source SSAP. If the PU responds the call, this is The destionation DSAP.')
fcsnaGpRoutSsap = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 5, 1, 1, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsnaGpRoutSsap.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaGpRoutSsap.setDescription('SSAP This field defines the service access point for the PU session. The unit uses this Address in conjunction withe the MAC address to to map the session to its destination. If the PU originates the call, this is the source SSAP. If the PU responds the call, this is The destionation DSAP.')
fcsnaGpRoutCos = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 5, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 1, 2))).clone(namedValues=NamedValues(("ubr", 3), ("vbr", 1), ("vbr-rt", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsnaGpRoutCos.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaGpRoutCos.setDescription('COS Class Of Service VBR or UBR')
fcsnaGpRoutCir = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 5, 1, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsnaGpRoutCir.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaGpRoutCir.setDescription('CIR Committed information Rate is the maximum number of bits per seconds which an end station can transmit into the network . This is the access rate of the user-network interface and it is limited by the line speed of the user-network connection and established by subscription.')
fcsnaGpRoutCirmin = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 5, 1, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsnaGpRoutCirmin.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaGpRoutCirmin.setDescription('CIRmin If the end station is informed about the congestion of the network, this is the minimum CIR that the end station can transmit into the network.')
fcsnaGpRoutBc = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 5, 1, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsnaGpRoutBc.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaGpRoutBc.setDescription('Bc The Committed Burst Size is a measure for the volume of data for which the network will garantee message delivery under normal conditions. It is measured during the committed rate measurement interval (Tc) ')
fcsnaGpRoutBe = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 5, 1, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsnaGpRoutBe.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaGpRoutBe.setDescription('Be The Excess Burst Size is the maximum amount of uncommitted data in access of Bc that the network will attemp to deliver during a time interval (Tc). End stations are allowed to transmit data in excess of the committed burst rate.')
fcsnaGpRemotePuTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 5, 2), )
if mibBuilder.loadTexts: fcsnaGpRemotePuTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaGpRemotePuTable.setDescription('')
fcsnaGpRemotePuEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 5, 2, 1), ).setIndexNames((0, "PCE-MIB", "fcsnaGpRemPuPuId"))
if mibBuilder.loadTexts: fcsnaGpRemotePuEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaGpRemotePuEntry.setDescription('An entry of fcsnaGpRemotePuTable.')
fcsnaGpRemPuPuId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 5, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1999))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcsnaGpRemPuPuId.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaGpRemPuPuId.setDescription('Physical Unit id')
fcsnaGpRemPuStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 5, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsnaGpRemPuStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaGpRemPuStatus.setDescription('Status')
fcsnaGpRemPuProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 5, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("auto", 1), ("x25", 2), ("sdlc", 3), ("frban", 4), ("sna-ethernet", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsnaGpRemPuProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaGpRemPuProtocol.setDescription('Type de protocole The value of this object allows to interworking with an remote Equipement which uses another communication protocole as X25/QLLC, SDLC or Lan protocol SNA/LLC2.')
fcsnaGpSdlcTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 5, 3), )
if mibBuilder.loadTexts: fcsnaGpSdlcTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaGpSdlcTable.setDescription('')
fcsnaGpSdlcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 5, 3, 1), ).setIndexNames((0, "PCE-MIB", "fcsnaGpSdlcPuId"))
if mibBuilder.loadTexts: fcsnaGpSdlcEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaGpSdlcEntry.setDescription('An entry of fcsnaGpSdlcTable.')
fcsnaGpSdlcPuId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 5, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1999))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcsnaGpSdlcPuId.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaGpSdlcPuId.setDescription('Physical Unit id')
fcsnaGpSdlcStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 5, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsnaGpSdlcStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaGpSdlcStatus.setDescription('Status')
fcsnaGpSdlcLp = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 5, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 181))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsnaGpSdlcLp.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaGpSdlcLp.setDescription("Logical Port The value of this object identifies one and only one SDLC logical port. The possible values are : '0..131'. If it is unused, the value of this parameter is '255'. The default value is '255'.")
fcsnaGpSdlcCluster = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 5, 3, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsnaGpSdlcCluster.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaGpSdlcCluster.setDescription('Cluster This is the address of the PU of the controller.')
fcsnaGpX25Table = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 5, 4), )
if mibBuilder.loadTexts: fcsnaGpX25Table.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaGpX25Table.setDescription('')
fcsnaGpX25Entry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 5, 4, 1), ).setIndexNames((0, "PCE-MIB", "fcsnaGpX25PuId"))
if mibBuilder.loadTexts: fcsnaGpX25Entry.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaGpX25Entry.setDescription('An entry of fcsnaGpX25Table.')
fcsnaGpX25PuId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 5, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1999))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcsnaGpX25PuId.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaGpX25PuId.setDescription('Physical Unit id')
fcsnaGpX25Status = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 5, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsnaGpX25Status.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaGpX25Status.setDescription('Status')
fcsnaGpX25Address = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 5, 4, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsnaGpX25Address.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaGpX25Address.setDescription('Adresse X121 Called X121 address. X121 Address of the corresponding Hpad element')
fcsnaGpLanFrTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 5, 5), )
if mibBuilder.loadTexts: fcsnaGpLanFrTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaGpLanFrTable.setDescription('')
fcsnaGpLanFrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 5, 5, 1), ).setIndexNames((0, "PCE-MIB", "fcsnaGpLanFrPuId"))
if mibBuilder.loadTexts: fcsnaGpLanFrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaGpLanFrEntry.setDescription('An entry of fcsnaGpLanFrTable.')
fcsnaGpLanFrPuId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 5, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1999))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcsnaGpLanFrPuId.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaGpLanFrPuId.setDescription('Physical Unit id')
fcsnaGpLanFrStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 5, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsnaGpLanFrStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaGpLanFrStatus.setDescription('Status')
fcsnaGpLanFrMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 5, 5, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsnaGpLanFrMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaGpLanFrMacAddress.setDescription('Adresse MAC This parameter defines the PU MAC address.')
fcsnaGpMiscellaneousParameters = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 5, 10))
fcsnaGpMiscMacAddrLearningMode = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 32, 5, 10, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcsnaGpMiscMacAddrLearningMode.setStatus('mandatory')
if mibBuilder.loadTexts: fcsnaGpMiscMacAddrLearningMode.setDescription("The value of this object indicates whether automatic MAc address learning is enabled or not. The default value is 'off'.")
fcBridge = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 35))
fcbBridging = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 35, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("transparentBridge", 2), ("transparentBridgeStp", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcbBridging.setStatus('mandatory')
if mibBuilder.loadTexts: fcbBridging.setDescription("The value of this object indicates whether the bridge forwards data or not, and if it does whether the Spanning Tree Protocol (STP) is enabled or not. The default value is 'off'.")
fcbBridgingBetweenRemoteVp = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 35, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcbBridgingBetweenRemoteVp.setStatus('mandatory')
if mibBuilder.loadTexts: fcbBridgingBetweenRemoteVp.setDescription("The value of this object indicates whether the bridge forwards data between remote virtual ports or not. Disabling this possibility prevents from making a way between remote equipments on different virtual networks which should not exchange data. BRIDGING BETWEEN REMOTE VP IS NOT IMPLEMENTED IN THIS SOFTWARE VERSION. The default value is 'off'.")
fcbTransparentBridge = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 35, 10))
fcbBrdgVirtualPortTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 35, 10, 1), )
if mibBuilder.loadTexts: fcbBrdgVirtualPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcbBrdgVirtualPortTable.setDescription("This table defines the virtual ports used by the bridge. Set any writable object(s) of this table to valid value(s) with a new index value to create an entry (the objects of the entry not present in this SET REQUEST will take their default values). Set fcbBrdgVpStatus to 'invalid' to delete an entry.")
fcbBrdgVirtualPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 35, 10, 1, 1), ).setIndexNames((0, "PCE-MIB", "fcbBrdgVpVirtualPortId"))
if mibBuilder.loadTexts: fcbBrdgVirtualPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcbBrdgVirtualPortEntry.setDescription('An entry of fcbBrdgVirtualPortTable.')
fcbBrdgVpVirtualPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 35, 10, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 11))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcbBrdgVpVirtualPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fcbBrdgVpVirtualPortId.setDescription('The value of this object identifies one and only one virtual port. This virtual port must exist in fcvVirtualPortTable. This is a decimal integer in the range 0 to 11.')
fcbBrdgVpStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 35, 10, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcbBrdgVpStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fcbBrdgVpStatus.setDescription("The value of this object indicates the state of the entry of this table. It must be set to 'invalid' to delete the entry. The default value is 'valid'.")
fcbBrdgVpAgingTime = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 35, 10, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3600))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcbBrdgVpAgingTime.setStatus('mandatory')
if mibBuilder.loadTexts: fcbBrdgVpAgingTime.setDescription("The value of this object is the aging time in seconds for addresses learnt on this virtual port. This is a decimal integer in the range 0 to 3600. The default value is '300'.")
fcbBrdgVpBroadcasting = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 35, 10, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcbBrdgVpBroadcasting.setStatus('mandatory')
if mibBuilder.loadTexts: fcbBrdgVpBroadcasting.setDescription("The value of this object indicates whether broadcasting is enabled or not for this virtual port. This function may permit to limit the use of expansive WAN links. The default value is 'off'.")
fcbBrdgVpFcsPreservation = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 35, 10, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 2))).clone(namedValues=NamedValues(("off", 1), ("offTinygram", 3), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcbBrdgVpFcsPreservation.setStatus('mandatory')
if mibBuilder.loadTexts: fcbBrdgVpFcsPreservation.setDescription("The value of this object indicates whether the FCS (Frame Check Sequence) of MAC frames is transported over the WAN network or not through this virtual port. This value is meaningless for local virtual ports. The default value is 'off'.")
fcbBrdgRemoteAddressMappingTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 35, 10, 2), )
if mibBuilder.loadTexts: fcbBrdgRemoteAddressMappingTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcbBrdgRemoteAddressMappingTable.setDescription("This table contains the static entries of the address translation table. The transparent Bridge function learns dynamically the entries of the address translation table. Owing to speed considerations or the possibility of learning, it may be necessary to create static entries in this table. Set any writable object(s) of this table to valid value(s) with a new index value to create an entry (the objects of the entry not present in this SET REQUEST will take their default values). Set fcbBrdgMapStatus to 'invalid' to delete an entry.")
fcbBrdgRemoteAddressMappingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 35, 10, 2, 1), ).setIndexNames((0, "PCE-MIB", "fcbBrdgMapMacAddress"))
if mibBuilder.loadTexts: fcbBrdgRemoteAddressMappingEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcbBrdgRemoteAddressMappingEntry.setDescription('An entry of fcbBrdgRemoteAddressMappingTable.')
fcbBrdgMapMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 35, 10, 2, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcbBrdgMapMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: fcbBrdgMapMacAddress.setDescription('The value of this object is the MAC address of a remote station to be reached through WAN networks. This is a six-bytes octet string with 12 digits in the range 0 to F. Broadcasting (FF FF FF FF FF FF), null (00 00 00 00 00 00) and group (bit 0 of first byte equal to 1) addresses must not be used.')
fcbBrdgMapStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 35, 10, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcbBrdgMapStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fcbBrdgMapStatus.setDescription("The value of this object indicates the state of the entry of this table. It must be set to 'invalid' to delete the entry. The default value is 'valid'.")
fcbBrdgMapRemoteAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 35, 10, 2, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcbBrdgMapRemoteAddress.setStatus('mandatory')
if mibBuilder.loadTexts: fcbBrdgMapRemoteAddress.setDescription("The value of this object is the X121 address of a remote bridge able to reach this remote station. This address must exist in fcvRvpConnectionTable. This is a eight-bytes octet string with : up to 15 digits in the range 0 to 9, mandatory 'F' digits to pad the value until a total of 16 digits (the equipment configurator does not need this final padding). The default value is 'FF FF FF FF FF FF FF FF' meaning 'empty value' (blank value on the equipment configurator).")
fcbSpanningTreeProtocol = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 35, 20))
fcbStpPriority = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 35, 20, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcbStpPriority.setStatus('mandatory')
if mibBuilder.loadTexts: fcbStpPriority.setDescription("The value of this object is the Bridge Priority used in association with the MAC address of the Ethernet port by the STP algorithm so as to determine from among all the possibilities, the bridge that will be elected as topology root. The lower the value, the higher the bridge priority.. This is a decimal integer in the range 0 to 65535. The default value is '32768'.")
fcbStpMaxAge = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 35, 20, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(600, 4000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcbStpMaxAge.setStatus('mandatory')
if mibBuilder.loadTexts: fcbStpMaxAge.setDescription("The value of this object is the maximum age, in milliseconds, of STP information learned from the network on any virtual port before it is discarded. This value is used by all bridges when this bridge is acting as the root of the spanning tree. This maximum age is the life duration assigned to a Configuration bridge PDU issued at the initiative of the bridge. This life duration will be decremented by the various bridges crossed and will reach zero, causing the deletion of the Configuration bridge PDU. This is a decimal integer in the range 600 to 4000. The default value is '2000'.")
fcbStpHelloTime = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 35, 20, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(100, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcbStpHelloTime.setStatus('mandatory')
if mibBuilder.loadTexts: fcbStpHelloTime.setDescription("The value of this object is the hello time, in milliseconds. This is the amount of time between the transmissions of Configuration bridge PDUs by this node on any virtual port when it is the root of the spanning tree or trying to become so. This value is used by all bridges when this bridge is acting as the root. This is a decimal integer in the range 100 to 1000. The default value is '200'.")
fcbStpForwardDelay = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 35, 20, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(400, 3000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcbStpForwardDelay.setStatus('mandatory')
if mibBuilder.loadTexts: fcbStpForwardDelay.setDescription("The value of this object is the forward delay, in milliseconds. This time value controls how fast a virtual port changes its spanning state when moving towards the Forwarding state. The value determines how long the port stays in each of the Listening and Learning states, which precede the Forwarding state. This value is also used, when a topology change has been detected and is underway, to age all dynamic entries in the Forwarding Database. This value is the value that this bridge and all others would start using if/when this bridge were to become the root. The Forward Delay value corresponds to the time during which the bridge that has just been started does not provide its service; it waits until the STP has established its topology. During this period, only the Configuration bridge PDUs are bridged, the user frames are not processed and this time delay is also used as minimum duration of a bridge state. This is a decimal integer in the range 400 to 3000. The default value is '1500'.")
fcbStpVirtualPortTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 35, 20, 10), )
if mibBuilder.loadTexts: fcbStpVirtualPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcbStpVirtualPortTable.setDescription('This table defines the Spanning Tree Protocol parameters of virtual ports. It is not possible to add or delete an entry of this table (each entry corresponds, in fcbBrdgVirtualPortTable, to one instance of fcbBrdgVpVirtualPortId).')
fcbStpVirtualPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 35, 20, 10, 1), ).setIndexNames((0, "PCE-MIB", "fcbStpVpVirtualPortId"))
if mibBuilder.loadTexts: fcbStpVirtualPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcbStpVirtualPortEntry.setDescription('An entry of fcbStpVirtualPortTable.')
fcbStpVpVirtualPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 35, 20, 10, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 11))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcbStpVpVirtualPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fcbStpVpVirtualPortId.setDescription('The value of this object identifies one and only one virtual port. Each virtual port corresponds, in fcbBrdgVirtualPortTable, to one instance of fcbBrdgVpVirtualPortId. This is a decimal integer in the range 0 to 11.')
fcbStpVpPortPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 35, 20, 10, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcbStpVpPortPriority.setStatus('mandatory')
if mibBuilder.loadTexts: fcbStpVpPortPriority.setDescription("The value of this object is the priority field which is contained in the first (in network byte order) octet of the (2 octet long) Port ID. The other octet of the Port ID is given by the value of fcbStpVpVirtualPortId. The port priority is used with its extra cost and its MAC address for the STP algorithm in order to grade the ports of the bridge in order of preference. This concept is used by the STP algorithm to elect the root port and to detect a loop so as to determine the port to be cut off. This is a decimal integer in the range 0 to 255. The default value is '128'.")
fcbStpVpPortPathCost = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 35, 20, 10, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcbStpVpPortPathCost.setStatus('mandatory')
if mibBuilder.loadTexts: fcbStpVpPortPathCost.setDescription("The value of this object is the contribution of this port to the path cost of paths towards the spanning tree root which include this port. 802.1D-1990 recommends that the default value of this parameter be in inverse proportion to the speed of the attached virtual network. The path cost of the port is used jointly with its priority and its MAC address by the STP algorithm in order to classify the bridge ports in order of preference. Thge lower the cost, the better preferred is the port. This concept is used by the STP algorithm on initialization to elect the root port and when a loop is detected in order to determine which port is to be cut off. This is a decimal integer in the range 1 to 65535. The default value is '100'.")
fcbStpVpBpduEncapsulation = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 35, 20, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("mac", 1), ("bpdu", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcbStpVpBpduEncapsulation.setStatus('mandatory')
if mibBuilder.loadTexts: fcbStpVpBpduEncapsulation.setDescription("The value of this object indicates, for the remote virtual ports, how the STP frames are encapsulated on the WAN virtual network. This value is meaningless for local virtual ports : mac : STP frames are encapsulated in SNAP 802.3, bpdu : STP frames are encapsulated in SNAP BPDU. The default value is 'mac'.")
fcIpRouter = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 36))
fciIpRouting = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciIpRouting.setStatus('mandatory')
if mibBuilder.loadTexts: fciIpRouting.setDescription("The value of this object indicates whether the equipment is acting as an IP gateway in respect to the forwarding of IP datagrams received by, but not addressed to, this entity. IP gateways forward IP datagrams. IP hosts do not. The default value is 'off'.")
fciFastIpRouting = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciFastIpRouting.setStatus('mandatory')
if mibBuilder.loadTexts: fciFastIpRouting.setDescription("The value of this object indicates whether the optimized forwarding of IP datagrams is enabled or not. This optimization consist in reducing the validity checks carried out on each IP datagram. The default value is 'off'.")
fciIcmpRedirection = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciIcmpRedirection.setStatus('mandatory')
if mibBuilder.loadTexts: fciIcmpRedirection.setDescription("The value of this object indicates whether the ICMP (Internet Control Message Protocol) Redirect messages are sent or not. The default value is 'off'.")
fciSourceRouting = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciSourceRouting.setStatus('mandatory')
if mibBuilder.loadTexts: fciSourceRouting.setDescription("The value of this object indicates whether the Source Routing information is inserted in the forwarded IP datagrams or not. The default value is 'off'.")
fciVirtualPortTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 10), )
if mibBuilder.loadTexts: fciVirtualPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: fciVirtualPortTable.setDescription("This table defines the virtual ports used by the IP router. Set any writable object(s) of this table to valid value(s) with a new index value to create an entry (the objects of the entry not present in this SET REQUEST will take their default values). Set fciVpStatus to 'invalid' to delete an entry.")
fciVirtualPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 10, 1), ).setIndexNames((0, "PCE-MIB", "fciVpVirtualPortId"))
if mibBuilder.loadTexts: fciVirtualPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fciVirtualPortEntry.setDescription('An entry of fciVirtualPortTable.')
fciVpVirtualPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 10, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 11))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fciVpVirtualPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fciVpVirtualPortId.setDescription('The value of this object identifies one and only one virtual port. This virtual port must exist in fcvVirtualPortTable. This is a decimal integer in the range 0 to 11.')
fciVpStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciVpStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fciVpStatus.setDescription("The value of this object indicates the state of the entry of this table. It must be set to 'invalid' to delete the entry. The default value is 'valid'.")
fciVpIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 10, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciVpIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: fciVpIpAddress.setDescription("The value of this object is the IP address associated with this virtual port. This IP address must be a valid host address. The default value is '0.0.0.0'.")
fciVpNetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 10, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciVpNetMask.setStatus('mandatory')
if mibBuilder.loadTexts: fciVpNetMask.setDescription("The value of this object is the subnet mask associated with the IP address of this virtual port. The value of the mask is an IP address with all the network bits set to 1 and all the hosts bits set to 0. In the absence of subnets, the mask contains 255.0.0.0 for an address of class A, 255.255.0.0 for class B, 255.255.255.0 for class C. The default value is '255.255.255.0'.")
fciVpMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 10, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(576, 9180))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciVpMtu.setStatus('mandatory')
if mibBuilder.loadTexts: fciVpMtu.setDescription("The value of this object defines, in octets, the largest IP datagram (Maximum Transmit Unit) which can be sent/received on this virtual port. This is a decimal integer in the range 576 to 9180. The default value is '1500'.")
fciVpProxyArp = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciVpProxyArp.setStatus('mandatory')
if mibBuilder.loadTexts: fciVpProxyArp.setDescription("The value of this object indicates whether the proxy-ARP processing is enabled or not. The default value is 'off'.")
fciVpInverseArp = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 10, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciVpInverseArp.setStatus('mandatory')
if mibBuilder.loadTexts: fciVpInverseArp.setDescription("For all connections without IP address association on an IP VP, this parameter activate an InverseARP resolution. The default value is 'off'.")
fciLocalVirtualPortTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 11), )
if mibBuilder.loadTexts: fciLocalVirtualPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: fciLocalVirtualPortTable.setDescription("This table defines the local virtual ports used by the IP router. Set any writable object(s) of this table to valid value(s) with a new index value to create an entry (the objects of the entry not present in this SET REQUEST will take their default values). Set fciLvpStatus to 'invalid' to delete an entry.")
fciLocalVirtualPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 11, 1), ).setIndexNames((0, "PCE-MIB", "fciLvpVirtualPortId"))
if mibBuilder.loadTexts: fciLocalVirtualPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fciLocalVirtualPortEntry.setDescription('An entry of fciLocalVirtualPortTable.')
fciLvpVirtualPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 11, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 11))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fciLvpVirtualPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fciLvpVirtualPortId.setDescription('The value of this object identifies one and only one local virtual port. This local virtual port must exist in fciVirtualPortTable and in fcvLocalVirtualPortTable. This is a decimal integer in the range 0 to 11.')
fciLvpStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciLvpStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fciLvpStatus.setDescription("The value of this object indicates the state of the entry of this table. It must be set to 'invalid' to delete the entry. The default value is 'valid'.")
fciLvpEncapsulation = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 11, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("ethernet", 1), ("ieee802-3", 2), ("monoRing", 3), ("multiArb", 4), ("multiSrb", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciLvpEncapsulation.setStatus('mandatory')
if mibBuilder.loadTexts: fciLvpEncapsulation.setDescription("The value of this object indicates, for this local virtual ports, how the IP datagrams are encapsulated on the LAN virtual network : ethernet : IP datagrams are encapsulated according to Ethernet V2 standard, ieee802-3 : IP datagrams are encapsulated according to IEEE 802.3 standard. The default value is 'ethernet'.")
fciLocalClusterTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 12), )
if mibBuilder.loadTexts: fciLocalClusterTable.setStatus('mandatory')
if mibBuilder.loadTexts: fciLocalClusterTable.setDescription('')
fciLocalClusterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 12, 1), ).setIndexNames((0, "PCE-MIB", "fciLclVirtualPortId"), (0, "PCE-MIB", "fciLclClusterNumber"))
if mibBuilder.loadTexts: fciLocalClusterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fciLocalClusterEntry.setDescription('An entry of fciLocalClusterTable.')
fciLclVirtualPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 12, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 11))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fciLclVirtualPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fciLclVirtualPortId.setDescription('VP id')
fciLclClusterNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 12, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fciLclClusterNumber.setStatus('mandatory')
if mibBuilder.loadTexts: fciLclClusterNumber.setDescription('Cluster number')
fciLclStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciLclStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fciLclStatus.setDescription('Status')
fciLclVirtualIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 12, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciLclVirtualIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: fciLclVirtualIpAddress.setDescription('Virtual IP Address')
fciLclPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 12, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciLclPriority.setStatus('mandatory')
if mibBuilder.loadTexts: fciLclPriority.setDescription('Priority')
fciRemoteNetToMediaTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 15), )
if mibBuilder.loadTexts: fciRemoteNetToMediaTable.setStatus('mandatory')
if mibBuilder.loadTexts: fciRemoteNetToMediaTable.setDescription("This table contains the IP address translations used for mapping from IP address to X121 address for each IP router reachable through a WAN virtual network. Set any writable object(s) of this table to valid value(s) with a new index value to create an entry (the objects of the entry not present in this SET REQUEST will take their default values). Set fciRemStatus to 'invalid' to delete an entry.")
fciRemoteNetToMediaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 15, 1), ).setIndexNames((0, "PCE-MIB", "fciRemIpAddress"))
if mibBuilder.loadTexts: fciRemoteNetToMediaEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fciRemoteNetToMediaEntry.setDescription('An entry of fciRemoteNetToMediaTable.')
fciRemIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 15, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fciRemIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: fciRemIpAddress.setDescription('The value of this object is the IP address of one IP router reachable through a WAN virtual network. This IP address must be a valid host address.')
fciRemStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 15, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciRemStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fciRemStatus.setDescription("The value of this object indicates the state of the entry of this table. It must be set to 'invalid' to delete the entry. The default value is 'valid'.")
fciRemRemoteAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 15, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciRemRemoteAddress.setStatus('mandatory')
if mibBuilder.loadTexts: fciRemRemoteAddress.setDescription("The value of this object is the X121 address of the called remote IP router. This address must exist in fcvRvpConnectionTable. This is a eight-bytes octet string with : up to 15 digits in the range 0 to 9, mandatory 'F' digits to pad the value until a total of 16 digits (the equipment configurator does not need this final padding). The default value is 'FF FF FF FF FF FF FF FF' meaning 'empty value' (blank value on the equipment configurator).")
fciNetToMediaTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 16), )
if mibBuilder.loadTexts: fciNetToMediaTable.setStatus('mandatory')
if mibBuilder.loadTexts: fciNetToMediaTable.setDescription("ARP (Address Resolution Protocol) is in charge to dynamically manage the IP address translations used for mapping from IP address to MAC address for each IP host or IP router reachable through a LAN. This table contains translations which are statically added to the dynamic ones. Set any writable object(s) of this table to valid value(s) with a new index value to create an entry (the objects of the entry not present in this SET REQUEST will take their default values). Set fciNetToMediaStatus to 'invalid' to delete an entry.")
fciNetToMediaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 16, 1), ).setIndexNames((0, "PCE-MIB", "fciNetToMediaIpAddress"))
if mibBuilder.loadTexts: fciNetToMediaEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fciNetToMediaEntry.setDescription('An entry of fciNetToMediaTable.')
fciNetToMediaIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 16, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fciNetToMediaIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: fciNetToMediaIpAddress.setDescription('The value of this object is the IP address of one IP host or IP router reachable through a LAN virtual network. This IP address must be a valid host address.')
fciNetToMediaStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 16, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciNetToMediaStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fciNetToMediaStatus.setDescription("The value of this object indicates the state of the entry of this table. It must be set to 'invalid' to delete the entry. The default value is 'valid'.")
fciNetToMediaMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 16, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciNetToMediaMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: fciNetToMediaMacAddress.setDescription("The value of this object is the MAC address of this IP host or IP router. This is a six-bytes octet string with 12 digits in the range 0 to F. Broadcasting (FF FF FF FF FF FF), null (00 00 00 00 00 00) and group (bit 0 of first byte equal to 1) addresses must not be used. The default value is 'FF FF FF FF FF FF' meaning 'empty value' (blank value on the equipment configurator).")
fciIpRouteTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 20), )
if mibBuilder.loadTexts: fciIpRouteTable.setStatus('mandatory')
if mibBuilder.loadTexts: fciIpRouteTable.setDescription('RIP (Routing Information Protocol) or EGP (External Gateway Protocol) are in charge to dynamically manage the routes used by the IP router. This table contains routes which are statically added to the dynamic ones.')
fciIpRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 20, 1), ).setIndexNames((0, "PCE-MIB", "fciRouteDest"), (0, "PCE-MIB", "fciRouteMask"))
if mibBuilder.loadTexts: fciIpRouteEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fciIpRouteEntry.setDescription('An entry of fciIpRouteTable.')
fciRouteDest = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 20, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fciRouteDest.setStatus('mandatory')
if mibBuilder.loadTexts: fciRouteDest.setDescription("The value of this object is the destination IP address of this route. An entry with a value of 0.0.0.0 is considered a default route. This IP address may be a network address (hosts bits set to 0) or a host address (at least one hosts bit set to 1). The default value is '0.0.0.0'.")
fciRouteMask = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 20, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fciRouteMask.setStatus('mandatory')
if mibBuilder.loadTexts: fciRouteMask.setDescription("The value of this object is the subnet mask associated with the IP address of this virtual port. The value of the mask is an IP address with all the network bits set to 1 and all the hosts bits set to 0. In the absence of subnets, the mask contains 255.0.0.0 for an address of class A, 255.255.0.0 for class B, 255.255.255.0 for class C. If the value of fciRouteDest is 0.0.0.0 (a default route), then the mask value is also 0.0.0.0. The default value is '255.255.255.0'.")
fciRouteStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 20, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciRouteStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fciRouteStatus.setDescription("The value of this object indicates the state of the entry of this table. The default value is 'valid'. It must be set to 'invalid' to delete the entry.")
fciRouteNextHop = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 20, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciRouteNextHop.setStatus('mandatory')
if mibBuilder.loadTexts: fciRouteNextHop.setDescription("The value of this object is the IP address of the next hop of this route. This IP address must be a valid host address. The default value is '0.0.0.0'.")
fciRouteMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 20, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciRouteMetric.setStatus('mandatory')
if mibBuilder.loadTexts: fciRouteMetric.setDescription("The value of this object is the routing metric for this route. The search algorithm is based on metrics for choosing between several possible routes to reach the destination of an IP datagram. In the case of RIP, the metrics indicates the number of IP routers through which an IP datagram must pass to reach its destination. The algorithm chooses preferably the shortest metric route. The authorized values are '1..15'. The default value is '1'.")
fciFlowManagement = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 30))
fciFlowTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 30, 1), )
if mibBuilder.loadTexts: fciFlowTable.setStatus('mandatory')
if mibBuilder.loadTexts: fciFlowTable.setDescription('This table defines the flows. A flow is a selection of IP datagrams coming from a local virtual port (i.e., froma a LAN).')
fciFlowEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 30, 1, 1), ).setIndexNames((0, "PCE-MIB", "fciFlowFlowId"))
if mibBuilder.loadTexts: fciFlowEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fciFlowEntry.setDescription('An entry of fciFlowTable.')
fciFlowFlowId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 30, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fciFlowFlowId.setStatus('mandatory')
if mibBuilder.loadTexts: fciFlowFlowId.setDescription("The value of this object identifies one and only one flow. A flow is a selection of IP datagrams coming from a local virtual port (i.e., froma a LAN). Several flows may belong to the same family. This flow uses a combination of several conditions defined below. A flow selects the received IP datagrams which simultaneously verify those of the conditions which are meaningful for this flow. When several flows are defined for the same VP with overlapping conditions, the IP datagram belongs to the first (in increasing order of flow identifiers) of all the flows that select it. So the numbering order must be done with a particular attention. By convention, if none of the conditions of this entry is meaningful, then every IP datagram is selected (default flow). The authorized values are '0..199'. If it is unused, the value is '255'. The default value is '255'.")
fciFlowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 30, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciFlowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fciFlowStatus.setDescription("The value of this object indicates the state of the entry of this table. The default value is 'valid'. It must be set to 'invalid' to delete the entry.")
fciFlowType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 30, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciFlowType.setStatus('mandatory')
if mibBuilder.loadTexts: fciFlowType.setDescription("The value of this object indicates the family to which belong any IP datagram selected by the conditions defining this flow. Several flows may belong to the same family. The transmission of the family of IP datagrams over WAN virtual networks is defined by fcvRvpConnFlowTypeMask. By convention, the family 0 groups together all the IP datagrams that the router has to reject (filtering at the IP level) whereas the filtering described in fcvLvpFltFilteringTable concerns all the traffic received on one of the IP, IPX or CNLP routers or bridge. The authorized values are : 0, 1, 2, 4, 8, 16, 32, 64 and 128. The default value is '255'.")
fciFlowVpId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 30, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 11))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciFlowVpId.setStatus('mandatory')
if mibBuilder.loadTexts: fciFlowVpId.setDescription('The value of this object specifies the virtual port for which the flow is defined. Any IP datagram received on this VP will go through the evaluations of the meaningful conditions defined for this flow and it is selected if all these comparisons produce positive results.')
fciFlowSrcIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 30, 1, 1, 10), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciFlowSrcIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: fciFlowSrcIpAddress.setDescription("The value of this object specifies the value with which the source IP address field of all the IP datagrams received on this VP is compared. If the bits, selected by fciFlowSrcMask, from this value are equal to the same bits from the source IP address of a IP datagram then this IP datagram is selected. This condition on source IP address is meaningless if fciFlowSrcMask is equal to '0.0.0.0' (no bits selected). The authorized values are all four bytes integer with an IP address notation but this value is not necessarily a valid IP address (e.g. 0.0.0.41 or 255.0.0.0). The default value is '0.0.0.0'.")
fciFlowSrcMask = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 30, 1, 1, 11), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciFlowSrcMask.setStatus('mandatory')
if mibBuilder.loadTexts: fciFlowSrcMask.setDescription("The value of this object specifies the bits from fciFlowSrcIpAddress which are to be compared with the same bits from the source IP address field of all the IP datagrams received on this VP. This condition on source IP address is meaningless if this mask is equal to '0.0.0.0' (no bits selected). The authorized values are all four bytes integer with an IP address notation but this value is not necessarily a valid IP address mask (e.g., 0,0,0,127 or 0,255,0,0). The default value is '0.0.0.0'.")
fciFlowDestIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 30, 1, 1, 12), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciFlowDestIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: fciFlowDestIpAddress.setDescription("The value of this object specifies the value with which the destination IP address field of all the IP datagrams received on this VP is compared. If the bits, selected by fciFlowDestMask, from this value are equal to the same bits from the destination IP address of a IP datagram then this IP datagram is selected. This condition on destination IP address is meaningless if fciFlowDestMask is equal to '0.0.0.0' (no bits selected). The authorized values are all four bytes integer with an IP address notation but this value is not necessarily a valid IP address (e.g. 0.0.0.41 or 255.0.0.0). The default value is '0.0.0.0'.")
fciFlowDestMask = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 30, 1, 1, 13), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciFlowDestMask.setStatus('mandatory')
if mibBuilder.loadTexts: fciFlowDestMask.setDescription("The value of this object specifies the bits from fciFlowDestIpAddress which are to be compared with the same bits from the destination IP address field of all the IP datagrams received on this VP. This condition on destination IP address is meaningless if this mask is equal to '0.0.0.0' (no bits selected). The authorized values are all four bytes integer with an IP address notation but this value is not necessarily a valid IP address mask (e.g., 0,0,0,127 or 0,255,0,0). The default value is '0.0.0.0'.")
fciFlowProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 30, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciFlowProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: fciFlowProtocol.setDescription("The value of this object specifies the value with which the protocol field of all the IP datagrams received on this VP is compared. If these two values are equal then the IP datagram is selected. This field identifies the protocol transported by IP (see PROTOCOL NUMBERS in RFC 1700). E.g. 1 = ICMP, 6 = TCP, 8 = EGP, 17 = UDP ... This condition on protocol is meaningless if this value is equal to '0'. The authorized values are '0..255'. The default value is '0'.")
fciFlowPortMin = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 30, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciFlowPortMin.setStatus('mandatory')
if mibBuilder.loadTexts: fciFlowPortMin.setDescription("The value of this object specifies the minimum value with which the source port and destination port fields of all the TCP/IP or UDP/IP datagrams received on this VP are compared. When fciFlowPortMax > fciFlowPortMin > 0, if the value of at least one of the two fields from the IP datagram is included inside these limits then the IP datagram is selected. When fciFlowPortMax > 0 and fciFlowPortMin = 0, if the value of at least one of the two fields from the IP datagram is equal to fciFlowPortMax then the IP datagram is selected. When fciFlowPortMax = 0 and fciFlowPortMin > 0, if the value of at least one of the two fields from the IP datagram is equal to fciFlowPortMin then the IP datagram is selected. When fciFlowPortMax = fciFlowPortMin = 0, this condition on ports is meaningless. Examples : (see WELL KNOWN PORT NUMBERS in RFC 1700); 21 = ftp, 23 = telnet, 67 = bootp server, 68 = bootp client, 69 = ttfp, 161 = snmp, 162 = snmptrap. The authorized values are '0..65535'. The default value is '0'.")
fciFlowPortMax = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 30, 1, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciFlowPortMax.setStatus('mandatory')
if mibBuilder.loadTexts: fciFlowPortMax.setDescription("The value of this object specifies the maximum value with which the source port and destination port fields of all the TCP/IP or UDP/IP datagrams received on this VP are compared. When fciFlowPortMax > fciFlowPortMin > 0, if the value of at least one of the two fields from the IP datagram is included inside these limits then the IP datagram is selected. When fciFlowPortMax > 0 and fciFlowPortMin = 0, if the value of at least one of the two fields from the IP datagram is equal to fciFlowPortMax then the IP datagram is selected. When fciFlowPortMax = 0 and fciFlowPortMin > 0, if the value of at least one of the two fields from the IP datagram is equal to fciFlowPortMin then the IP datagram is selected. When fciFlowPortMax = fciFlowPortMin = 0, this condition on ports is meaningless. Examples : (see WELL KNOWN PORT NUMBERS in RFC 1700); 21 = ftp, 23 = telnet, 67 = bootp server, 68 = bootp client, 69 = ttfp, 161 = snmp, 162 = snmptrap. The authorized values are '0..65535'. The default value is '0'.")
fciFlowLengthMax = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 30, 1, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciFlowLengthMax.setStatus('mandatory')
if mibBuilder.loadTexts: fciFlowLengthMax.setDescription("The value of this object specifies the value with which the length of all the IP datagrams received on this VP are compared. If the number of octets in the IP datagram is less or equal to this value then the IP datagram is selected. This condition on length is meaningless if this value is equal to '0'. The authorized values are '0..65535'. The default value is '0'.")
fciFlowSegmented = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 30, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notChecked", 1), ("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciFlowSegmented.setStatus('mandatory')
if mibBuilder.loadTexts: fciFlowSegmented.setDescription("The value of this object specifies the selection of segmented IP datagrams received on this VP : notChecked : This condition on segmentation is meaningless. no : The IP datagrams not segmented are selected. yes : The IP datagrams segmented are selected. The default value is 'notChecked'.")
fciFlowAddrSubstituteTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 30, 2), )
if mibBuilder.loadTexts: fciFlowAddrSubstituteTable.setStatus('mandatory')
if mibBuilder.loadTexts: fciFlowAddrSubstituteTable.setDescription('This table is used for replacing the IP destination address contained in every IP datagram belonging to a specific flow by a precise IP address. This substitution takes place before the frame is examined by the IP routing. Therefore, it is possible, for instance, to orient the IP/UDP traffic distributed towards a specific recipient..')
fciFlowAddrSubstituteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 30, 2, 1), ).setIndexNames((0, "PCE-MIB", "fciFlowSubstFlowId"), (0, "PCE-MIB", "fciFlowSubstDestIpAddress"))
if mibBuilder.loadTexts: fciFlowAddrSubstituteEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fciFlowAddrSubstituteEntry.setDescription('An entry of fciFlowAddrSubstituteTable.')
fciFlowSubstFlowId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 30, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fciFlowSubstFlowId.setStatus('mandatory')
if mibBuilder.loadTexts: fciFlowSubstFlowId.setDescription("The value of this object identifies one and only one flow. A flow is a selection of IP datagrams coming from a local virtual port (i.e., froma a LAN). It must exist in fciFlowTable. The authorized values are '0..199'. If it is unused, the value is '255'. The default value is '255'.")
fciFlowSubstDestIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 30, 2, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fciFlowSubstDestIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: fciFlowSubstDestIpAddress.setDescription("The value of this object is the new destination IP address which replaces the existing one in all IP datagrams belonging to this flow. This IP address must be a broadcasting IP address (hosts bits set to 1) or a host address (at least one hosts bit set to 1). The default value is '0.0.0.0'.")
fciFlowSubstStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 30, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciFlowSubstStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fciFlowSubstStatus.setDescription("The value of this object indicates the state of the entry of this table. The default value is 'valid'. It must be set to 'invalid' to delete the entry.")
fciFlowRouteTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 30, 20), )
if mibBuilder.loadTexts: fciFlowRouteTable.setStatus('mandatory')
if mibBuilder.loadTexts: fciFlowRouteTable.setDescription('This table contains routes which are statically defined for particular flows (this permits to bypass the normal IP routing process).')
fciFlowRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 30, 20, 1), ).setIndexNames((0, "PCE-MIB", "fciFlowRouteFlowId"))
if mibBuilder.loadTexts: fciFlowRouteEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fciFlowRouteEntry.setDescription('An entry of fciFlowRouteTable.')
fciFlowRouteFlowId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 30, 20, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fciFlowRouteFlowId.setStatus('mandatory')
if mibBuilder.loadTexts: fciFlowRouteFlowId.setDescription("The value of this object identifies one and only one flow. A flow is a selection of IP datagrams coming from a local virtual port (i.e., froma a LAN). It must exist in fciFlowTable. The authorized values are '0..199'. If it is unused, the value is '255'. The default value is '255'.")
fciFlowRouteStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 30, 20, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciFlowRouteStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fciFlowRouteStatus.setDescription("The value of this object indicates the state of the entry of this table. The default value is 'valid'. It must be set to 'invalid' to delete the entry.")
fciFlowRouteNextHop = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 30, 20, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciFlowRouteNextHop.setStatus('mandatory')
if mibBuilder.loadTexts: fciFlowRouteNextHop.setDescription("The value of this object is the IP address of the next hop of the route used by this flow. This IP address must be a valid host address. The default value is '0.0.0.0'.")
fciRip = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 40))
fciRipAdminStatus = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 40, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("on", 2), ("quiet", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciRipAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fciRipAdminStatus.setDescription("The value of this object indicates whether RIP (Routing Information Protocol) is enabled or not : off : RIP is not enabled, on : RIP is enabled in 'active mode (it learns the routes transmitted by the adjacents routers to complete the routing table and itself distributes all or part of the routes contained in the routing table), quiet : RIP is enabled in 'passive mode (it learns the routes transmitted by the adjacents routers to complete the routing table but itself does not distribute anything). The default value is 'off'.")
fciRipStaticRoutesDistribution = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 40, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciRipStaticRoutesDistribution.setStatus('mandatory')
if mibBuilder.loadTexts: fciRipStaticRoutesDistribution.setDescription("The value of this object indicates whether RIP distributes static entries of the routing table (i.e., those defined in fciIpRouteTable) or not. The default value is 'off'.")
fciRipEgpRoutesDistribution = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 40, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciRipEgpRoutesDistribution.setStatus('mandatory')
if mibBuilder.loadTexts: fciRipEgpRoutesDistribution.setDescription("The value of this object indicates whether RIP distributes entries of the routing table learnt by EGP (Exterior Gateway Protocol) or not. The autonomous systems from which these routing informations are distributed are defined in fciRipEgpRoutesDistributionTable. The default value is 'off'.")
fciRipDistributionTimer = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 40, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(30, 3600))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciRipDistributionTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fciRipDistributionTimer.setDescription("The value of this object indicates the waiting time in seconds between two successive transmissions of informations from the routing table by RIP. The authorized values are '30..3600'. The default value is '30'.")
fciRipPreference = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 40, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciRipPreference.setStatus('mandatory')
if mibBuilder.loadTexts: fciRipPreference.setDescription(" The value of this object controls preference for routes learned (imported) by RIP, relative to routes to same destination learned by others protocols. '0' is high preference. '255' is low preference.")
fciRipOspfRoutesDistribution = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 40, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciRipOspfRoutesDistribution.setStatus('mandatory')
if mibBuilder.loadTexts: fciRipOspfRoutesDistribution.setDescription('The value of this object indicates whether RIP distributes entries of the routing table learnt by OSPF (Open Shortest Path First) protocol or not. The metric used is specified by the field fciRipOspfRoutesDistributionMetric.')
fciRipOspfRoutesDistributionMetric = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 40, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciRipOspfRoutesDistributionMetric.setStatus('mandatory')
if mibBuilder.loadTexts: fciRipOspfRoutesDistributionMetric.setDescription(' The value of this object indicates the metric used by RIP when propagating (exporting) routes learnt via OSPF. ')
fciRipStaticRoutesDistributionMetric = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 40, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciRipStaticRoutesDistributionMetric.setStatus('mandatory')
if mibBuilder.loadTexts: fciRipStaticRoutesDistributionMetric.setDescription('The value of this object indicates the metric used by RIP when propagating (exporting) static routes. ')
fciRipVirtualPortTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 40, 10), )
if mibBuilder.loadTexts: fciRipVirtualPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: fciRipVirtualPortTable.setDescription('This table defines the RIP parameters of virtual ports. This table is meaningless if there is at least one entry in fciRipNeighborTable (in this case RIP learns [and/or sends] routing informations only from [and/or to] the neighbors defined in that table).')
fciRipVirtualPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 40, 10, 1), ).setIndexNames((0, "PCE-MIB", "fciRipVpVirtualPortId"))
if mibBuilder.loadTexts: fciRipVirtualPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fciRipVirtualPortEntry.setDescription('An entry of fciRipVirtualPortTable.')
fciRipVpVirtualPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 40, 10, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fciRipVpVirtualPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fciRipVpVirtualPortId.setDescription("The value of this object identifies one and only one virtual port. The authorized values are '0..199'. If it is unused, the value is '255'. The default value is '255'.")
fciRipVpDistribution = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 40, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciRipVpDistribution.setStatus('mandatory')
if mibBuilder.loadTexts: fciRipVpDistribution.setDescription("The value of this object indicates whether performs its information exchanges on the IP network attached to this virtual port or not. The default value is 'on'.")
fciRipVpMetricOut = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 40, 10, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciRipVpMetricOut.setStatus('mandatory')
if mibBuilder.loadTexts: fciRipVpMetricOut.setDescription('The RIP output metric of this interface. This metric will be added to routes that are send via the interface. This parameter can be used to make other routers prefer other sources of RIP routes over this router.')
fciRipVpRipIn = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 40, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciRipVpRipIn.setStatus('mandatory')
if mibBuilder.loadTexts: fciRipVpRipIn.setDescription("The RIP input interface's administrative status. The value 'on' denotes that RIP packets received on this interface will be accepted. The value 'off' denotes that no RIP received packets will be accepted.")
fciRipVpMetricIn = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 40, 10, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciRipVpMetricIn.setStatus('mandatory')
if mibBuilder.loadTexts: fciRipVpMetricIn.setDescription('The RIP input metric of this interface. This metric will be added to incoming routes before they are installed in the routing table. This parameter can be used to make this router prefer RIP routes learned via the specified interface less than RIP routes from other interface.')
fciRipVpVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 40, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ripVersion1", 1), ("ripVersion2", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciRipVpVersion.setStatus('mandatory')
if mibBuilder.loadTexts: fciRipVpVersion.setDescription("The RIP output packets version. The value of this object indicates the version of RIP packets sent on the interface. The value 'ripVersion1' implies sending RIP updates compliant with RFC 1058. 'ripVersion2' implies sending RIP updates compliant with RFC 1388.")
fciRipVpMulticast = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 40, 10, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("on", 2), ("other", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciRipVpMulticast.setStatus('mandatory')
if mibBuilder.loadTexts: fciRipVpMulticast.setDescription("The RIP-2 multicast output interface's administrative status. The value 'on' implies sending RIP updates using the multicast capability.")
fciRipVpAuthType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 40, 10, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noAuthentication", 1), ("simplePassword", 2), ("other", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciRipVpAuthType.setStatus('mandatory')
if mibBuilder.loadTexts: fciRipVpAuthType.setDescription('Type of authentication shema used on the interface.')
fciRipVpAuthKey = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 40, 10, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciRipVpAuthKey.setStatus('mandatory')
if mibBuilder.loadTexts: fciRipVpAuthKey.setDescription('The value to be used as the Authentication Key whenever the corresponding instance of fciRipVpAuthType has the value simplePassword. A modification of the corresponding instance of fciRipVpAuthType does not modify the fciRipVpAuthKey value. If a string shorter than 16 octets is supplied, it will be left-justified and padded to 16 octets, on the right, with nulls (0x00). Reading this object always results in an OCTET STRING of length zero; authentication may not be bypassed by reading the MIB object.')
fciRipNeighborTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 40, 20), )
if mibBuilder.loadTexts: fciRipNeighborTable.setStatus('mandatory')
if mibBuilder.loadTexts: fciRipNeighborTable.setDescription('This table defines the neighbors (i.e., the adjacent routers with RIP enabled) with witch RIP exchange routing informations. If this table is empty RIP uses fciRipVirtualPortTable.')
fciRipNeighborEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 40, 20, 1), ).setIndexNames((0, "PCE-MIB", "fciRipNeighborIpAddress"))
if mibBuilder.loadTexts: fciRipNeighborEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fciRipNeighborEntry.setDescription('An entry of fciRipNeighborTable.')
fciRipNeighborIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 40, 20, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fciRipNeighborIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: fciRipNeighborIpAddress.setDescription("The value of this object is the IP address of a neighbor (i.e., an adjacent router with RIP enabled). This IP address must be a valid host address. The default value is '0.0.0.0'.")
fciRipNeighborStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 40, 20, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciRipNeighborStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fciRipNeighborStatus.setDescription("The value of this object indicates the state of the entry of this table. The default value is 'valid'. It must be set to 'invalid' to delete the entry.")
fciRipNeighborOutput = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 40, 20, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("off", 1), ("on", 2), ("bck", 3), ("on1", 4), ("bk1", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciRipNeighborOutput.setStatus('mandatory')
if mibBuilder.loadTexts: fciRipNeighborOutput.setDescription(" This flag indicates whether the neighbor is a gateway to which RIP will send RIP packets (value : on or on V1 ) or not (value : off ). If the value is bck or bck V1 , RIP will send packets only if all members of the RIP backup group are down. The value on or bck force RIP to send RIP V2 packets if the RIP output packets version on that VP is RIP V2, or to send RIP V1 packets if the RIP output packets version on that VP is RIP V1. The value on V1 or bck V1 , is used when the neighbor doesn't support RIP V2, that value force RIP to send RIP V1 compatible packets compliant with RFC 1388.")
fciRipNeighborInput = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 40, 20, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciRipNeighborInput.setStatus('mandatory')
if mibBuilder.loadTexts: fciRipNeighborInput.setDescription(' This flag indicates whether the neighbor is a gateway from which RIP will accept RIP packets or not. ')
fciRipNeighborBackupGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 40, 20, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciRipNeighborBackupGroup.setStatus('mandatory')
if mibBuilder.loadTexts: fciRipNeighborBackupGroup.setDescription(" This flag indicates the RIP backup group number of the neighbor. If the neighbor doesn't belong to a group, the value is 255 (default value).")
fciRipEgpRoutesDistributionTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 40, 30), )
if mibBuilder.loadTexts: fciRipEgpRoutesDistributionTable.setStatus('mandatory')
if mibBuilder.loadTexts: fciRipEgpRoutesDistributionTable.setDescription('As defined by fciRipEgpRoutesDistribution, when RIP distributes entries of the routing table learnt by EGP (Exterior Gateway Protocol), this table defines which of these entries are to be distributed. Only entries learnt from a router of an automous system specified in this table are distributed by RIP.')
fciRipEgpRoutesDistributionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 40, 30, 1), ).setIndexNames((0, "PCE-MIB", "fciRipEgpRoutesAsNumber"))
if mibBuilder.loadTexts: fciRipEgpRoutesDistributionEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fciRipEgpRoutesDistributionEntry.setDescription('An entry of fciRipEgpRoutesDistributionTable.')
fciRipEgpRoutesAsNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 40, 30, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65534))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fciRipEgpRoutesAsNumber.setStatus('mandatory')
if mibBuilder.loadTexts: fciRipEgpRoutesAsNumber.setDescription("The value of this object identifies an autonomous system containing routers delivering the routing information that RIP distributes. This AS must exist in fciEgpNeighborTable. The authorized values are '1..65534'. The default value is '0'.")
fciRipEgpRoutesStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 40, 30, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciRipEgpRoutesStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fciRipEgpRoutesStatus.setDescription("The value of this object indicates the state of the entry of this table. The default value is 'valid'. It must be set to 'invalid' to delete the entry.")
fciRipEgpRoutesMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 40, 30, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciRipEgpRoutesMetric.setStatus('mandatory')
if mibBuilder.loadTexts: fciRipEgpRoutesMetric.setDescription("The value of this object is the value indicated in the transmitted RIP datagrams concerning routing information learnt by EGP and coming from this autonomous system. The authorized values are '1..15'. The default value is '1'.")
fciOspf = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 41))
fciOspfGeneralParameters = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 41, 1))
fciOspfAdminStatus = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 41, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciOspfAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fciOspfAdminStatus.setDescription("OSPF administrative status. The administrative status of OSPF in the router. The value 'on' denotes that the OSPF Process is active on at least one interface ; 'off' disables OSPF on all interfaces.")
fciOspfRouterId = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 41, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciOspfRouterId.setStatus('mandatory')
if mibBuilder.loadTexts: fciOspfRouterId.setDescription("OSPF router Id. A 32-bit integer uniquely identifying the router in the autonomous system. By convention, to ensure uniqueness, this should default to the value of one of the router's IP interface addresses.")
fciOspfRoutesPreference = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 41, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciOspfRoutesPreference.setStatus('mandatory')
if mibBuilder.loadTexts: fciOspfRoutesPreference.setDescription('OSPF routes preference. Specifies the preference with which routes learned by OSPF are imported into the routing tables.')
fciOspfAsePreference = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 41, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciOspfAsePreference.setStatus('mandatory')
if mibBuilder.loadTexts: fciOspfAsePreference.setDescription('OSPF ASE preference. Specifies the preference with which routes external to the Autonomous System learned by OSPF are imported into the routing tables.')
fciOspfVirtualPortsTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 41, 10), )
if mibBuilder.loadTexts: fciOspfVirtualPortsTable.setStatus('mandatory')
if mibBuilder.loadTexts: fciOspfVirtualPortsTable.setDescription('OSPF Interface Table. The OSPF Interface Table augments the ifTable with OSPF specific information. Each OSPF Interface Entry describes one interface from the viewpoint of OSPF.')
fciOspfVirtualPortsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 41, 10, 1), ).setIndexNames((0, "PCE-MIB", "fciOspfVpId"))
if mibBuilder.loadTexts: fciOspfVirtualPortsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fciOspfVirtualPortsEntry.setDescription('An entry of fciOspfVirtualPortsTable.')
fciOspfVpId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 41, 10, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fciOspfVpId.setStatus('mandatory')
if mibBuilder.loadTexts: fciOspfVpId.setDescription('OSPF VP id. The VP id identifying this OSPF interface.')
fciOspfVpAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 41, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciOspfVpAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fciOspfVpAdminStatus.setDescription("OSPF VP administrative status. The OSPF interface's administrative status. The value 'on' denotes that neighbor relationships may be formed on the interface, and the interface will be advertised as an internal route to some area. The value 'off' denotes that the interface is external to OSPF. This parameter defaults to the value 'on'.")
fciOspfVpAreaId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 41, 10, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciOspfVpAreaId.setStatus('mandatory')
if mibBuilder.loadTexts: fciOspfVpAreaId.setDescription("OSPF VP area id. A 32-bit integer uniquely identifying the area to which the interface connects. This parameter defaults to the value '0.0.0.0' which is used for the OSPF backbone.")
fciOspfVpMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 41, 10, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciOspfVpMetric.setStatus('mandatory')
if mibBuilder.loadTexts: fciOspfVpMetric.setDescription("OSPF VP metric. The metric of using this type of service on this interface. The default value of the TOS 0 Metric is 10^8 / ifSpeed. The value FFFF is distinguished to mean 'no route via this TOS'.")
fciOspfVpType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 41, 10, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("broadcast", 1), ("nbma", 2), ("pointToPoint", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciOspfVpType.setStatus('mandatory')
if mibBuilder.loadTexts: fciOspfVpType.setDescription("OSPF VP type. The OSPF interface type. By way of a default, this field may be intuited from the corresponding value of ifType. Broadcast LANs, such as Ethernet and IEEE 802.5, take the value 'broadcast', X.25, Frame Relay, and similar technologies take the value 'nbma', and links that are definitively point to point take the value 'pointToPoint'.")
fciOspfVpDRPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 41, 10, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciOspfVpDRPriority.setStatus('mandatory')
if mibBuilder.loadTexts: fciOspfVpDRPriority.setDescription("OSPF VP DR priority. The priority of this interface. Used in multi-access networks, this field is used in the designated router election algorithm. The value 0 signifies that the router is not eligible to become the designated router on this particular network. In the event of a tie in this value, routers will use their router id as a tie breaker. This parameter defaults to the value '1'.")
fciOspfVpTransitDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 41, 10, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciOspfVpTransitDelay.setStatus('mandatory')
if mibBuilder.loadTexts: fciOspfVpTransitDelay.setDescription("OSPF VP transit delay. The estimated number of seconds it takes to transmit a link state update packet over this interface. This parameter defaults with the value '1'.")
fciOspfVpRetransmitInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 41, 10, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciOspfVpRetransmitInterval.setStatus('mandatory')
if mibBuilder.loadTexts: fciOspfVpRetransmitInterval.setDescription("OSPF VP retransmit interval. The number of seconds between link-state advertisement retransmissions, for adjacencies belonging to this interface. This value is also used when retransmitting database description and link-state request packets. This parameter defaults to the value '5'. ")
fciOspfVpHelloInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 41, 10, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciOspfVpHelloInterval.setStatus('mandatory')
if mibBuilder.loadTexts: fciOspfVpHelloInterval.setDescription("OSPF VP hello interval. The length of time, in seconds, between the Hello packets that the router sends on the interface. This value must be the same for all routers attached to a common network.This parameter defaults with the value '10'.")
fciOspfVpRouterDeadInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 41, 10, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciOspfVpRouterDeadInterval.setStatus('mandatory')
if mibBuilder.loadTexts: fciOspfVpRouterDeadInterval.setDescription("OSPF VP router dead interval. The number of seconds that a router's Hello packets have not been seen before it's neighbors declare the router down. This should be some multiple of the Hello interval. This value must be the same for all routers attached to a common network. This parameter defaults with the value '40'.")
fciOspfVpPollInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 41, 10, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciOspfVpPollInterval.setStatus('mandatory')
if mibBuilder.loadTexts: fciOspfVpPollInterval.setDescription("OSPF VP poll interval. The larger time interval, in seconds, between the Hello packets sent to an inactive non-broadcast multi-access neighbor. This parameter defaults with the value '120'.")
fciOspfVpAuthenticationKey = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 41, 10, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciOspfVpAuthenticationKey.setStatus('mandatory')
if mibBuilder.loadTexts: fciOspfVpAuthenticationKey.setDescription("OSPF VP authentication key. The Authentication Key. If the Area's Authentication Type is simplePassword, and the key length is shorter than 8 octets, the agent will left adjust and zero fill to 8 octets. When read, ospfIfAuthKey always returns an Octet String of length zero. This parameter defaults with the value '0000000000000000h'.")
fciOspfNeighborsTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 41, 20), )
if mibBuilder.loadTexts: fciOspfNeighborsTable.setStatus('mandatory')
if mibBuilder.loadTexts: fciOspfNeighborsTable.setDescription('OSPF Neighbors Table. The OSPF Neighbors Table describes all neighbors in the locality of the subject router. Each entry contains the information regarding a single neighbor.')
fciOspfNeighborsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 41, 20, 1), ).setIndexNames((0, "PCE-MIB", "fciOspfNeighborIpAddress"))
if mibBuilder.loadTexts: fciOspfNeighborsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fciOspfNeighborsEntry.setDescription('An entry of fciOspfNeighborsTable.')
fciOspfNeighborIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 41, 20, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fciOspfNeighborIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: fciOspfNeighborIpAddress.setDescription('Neighbor IP address. The IP address of this neighbor.')
fciOspfNeighborStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 41, 20, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciOspfNeighborStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fciOspfNeighborStatus.setDescription("Status. The value of this object indicates the state of the entry of this table. The default value is 'valid'. It must be set to 'invalid' to delete the entry.")
fciOspfNeighborEligibleStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 41, 20, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciOspfNeighborEligibleStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fciOspfNeighborEligibleStatus.setDescription('Neighbor eligible status. This parameter indicates whether the neighbor is eligible for DR election.')
fciOspfAreasTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 41, 30), )
if mibBuilder.loadTexts: fciOspfAreasTable.setStatus('mandatory')
if mibBuilder.loadTexts: fciOspfAreasTable.setDescription("The OSPF Area Data Structure contains informations regarding the various areas. The interfaces and the virtual links are configured as part of these areas. Area 0.0.0.0, by definition, is the Backbone Area. Each entry describes the configured parameters of one of the router's attached areas.")
fciOspfAreasEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 41, 30, 1), ).setIndexNames((0, "PCE-MIB", "fciOspfAreaId"))
if mibBuilder.loadTexts: fciOspfAreasEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fciOspfAreasEntry.setDescription('An entry of fciOspfAreasTable.')
fciOspfAreaId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 41, 30, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fciOspfAreaId.setStatus('mandatory')
if mibBuilder.loadTexts: fciOspfAreaId.setDescription("Area id. A 32-bit integer uniquely identifying an area. This parameter defaults to the value '0.0.0.0' which is used to identify the OSPF backbone.")
fciOspfAreaStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 41, 30, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciOspfAreaStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fciOspfAreaStatus.setDescription("Status. The value of this object indicates the state of the entry of this table. The default value is 'valid'. It must be set to 'invalid' to delete the entry.")
fciOspfAreaAuthType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 41, 30, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("none", 1), ("simplePassword", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciOspfAreaAuthType.setStatus('mandatory')
if mibBuilder.loadTexts: fciOspfAreaAuthType.setDescription("Area authentication type. The authentication type specified for an area. This parameter defaults to the 'none' value and can take the value 'simplePassword' to enable authentication into the area.")
fciOspfAreaStubStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 41, 30, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciOspfAreaStubStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fciOspfAreaStubStatus.setDescription('Area stub status. This parameter indicates whether the area is a stub area or not.')
fciOspfAreaStubMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 41, 30, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciOspfAreaStubMetric.setStatus('mandatory')
if mibBuilder.loadTexts: fciOspfAreaStubMetric.setDescription('Area stub metric. The OSPF metric associated to the stub area.')
fciOspfAreaRangesTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 41, 33), )
if mibBuilder.loadTexts: fciOspfAreaRangesTable.setStatus('mandatory')
if mibBuilder.loadTexts: fciOspfAreaRangesTable.setDescription('OSPF Address Range Table. The Address Range Table acts as an adjunct to the Area Table ; It describes those Address Range Summaries that are configured to be propagated from an Area to reduce the amount of information about it which is known beyond its borders. A range of IP addresses is specified by an IP address/IP network mask pair. For example, Class B address range of X.X.X.X with a network mask of 255.255.0.0 includes all IP addresses from X.X.0.0 to X.X.255.255.')
fciOspfAreaRangesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 41, 33, 1), ).setIndexNames((0, "PCE-MIB", "fciOspfAreaRangeIpAddress"), (0, "PCE-MIB", "fciOspfAreaRangeIpMask"))
if mibBuilder.loadTexts: fciOspfAreaRangesEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fciOspfAreaRangesEntry.setDescription('An entry of fciOspfAreaRangesTable.')
fciOspfAreaRangeIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 41, 33, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fciOspfAreaRangeIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: fciOspfAreaRangeIpAddress.setDescription('Area range IP address. The IP Address of the Net or Subnet indicated by the range.')
fciOspfAreaRangeIpMask = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 41, 33, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fciOspfAreaRangeIpMask.setStatus('mandatory')
if mibBuilder.loadTexts: fciOspfAreaRangeIpMask.setDescription('Area range IP mask. The Subnet Mask that pertains to the Net or Subnet.')
fciOspfAreaRangeStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 41, 33, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciOspfAreaRangeStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fciOspfAreaRangeStatus.setDescription("Status. The value of this object indicates the state of the entry of this table. The default value is 'valid'. It must be set to 'invalid' to delete the entry.")
fciOspfAreaRangeAreaId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 41, 33, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciOspfAreaRangeAreaId.setStatus('mandatory')
if mibBuilder.loadTexts: fciOspfAreaRangeAreaId.setDescription('Area range area id. The Area the Address Range is to be found within.')
fciOspfAreaRangeRestrict = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 41, 33, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciOspfAreaRangeRestrict.setStatus('mandatory')
if mibBuilder.loadTexts: fciOspfAreaRangeRestrict.setDescription("Restriction. The value 'off' indicates that intra-area LSAs that fall within the specified range are not advertised into other areas as inter-area routes. Instead, the specified range are advertised as summary network LSAs. The value 'on' specifies that the summary network LSAs are not advertised.")
fciOspfVirtualLinksTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 41, 36), )
if mibBuilder.loadTexts: fciOspfVirtualLinksTable.setStatus('mandatory')
if mibBuilder.loadTexts: fciOspfVirtualLinksTable.setDescription('OSPF Virtual Link Table. The Virtual Link Table describes the virtual links that the OSPF Process is configured to carry on.')
fciOspfVirtualLinksEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 41, 36, 1), ).setIndexNames((0, "PCE-MIB", "fciOspfVlNeighborId"), (0, "PCE-MIB", "fciOspfVlTransitAreaId"))
if mibBuilder.loadTexts: fciOspfVirtualLinksEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fciOspfVirtualLinksEntry.setDescription('An entry of fciOspfVirtualLinksTable.')
fciOspfVlNeighborId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 41, 36, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fciOspfVlNeighborId.setStatus('mandatory')
if mibBuilder.loadTexts: fciOspfVlNeighborId.setDescription('VL neighbor id. The Router ID of the Virtual Neighbor.')
fciOspfVlTransitAreaId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 41, 36, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fciOspfVlTransitAreaId.setStatus('mandatory')
if mibBuilder.loadTexts: fciOspfVlTransitAreaId.setDescription('VL transit area id. The Transit Area that the Virtual Link traverses. By definition, this is not 0.0.0.0.')
fciOspfVlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 41, 36, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciOspfVlStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fciOspfVlStatus.setDescription("Status. The value of this object indicates the state of the entry of this table. The default value is 'valid'. It must be set to 'invalid' to delete the entry.")
fciOspfVlDRPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 41, 36, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciOspfVlDRPriority.setStatus('mandatory')
if mibBuilder.loadTexts: fciOspfVlDRPriority.setDescription("VL DR priority. The priority of this virtual link. Used in multi-access networks, this field is used in the designated router election algorithm. The value 0 signifies that the router is not eligible to become the designated router on this particular network. In the event of a tie in this value, routers will use their router id as a tie breaker. This parameter defaults to the value '1'.")
fciOspfVlTransitDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 41, 36, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciOspfVlTransitDelay.setStatus('mandatory')
if mibBuilder.loadTexts: fciOspfVlTransitDelay.setDescription('VL transit delay. The estimated number of seconds it takes to transmit a link-state update packet over this interface.')
fciOspfVlRetransmitInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 41, 36, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciOspfVlRetransmitInterval.setStatus('mandatory')
if mibBuilder.loadTexts: fciOspfVlRetransmitInterval.setDescription('VL retransmit interval. The number of seconds between link-state advertisement retransmissions, for adjacencies belonging to this interface. This value is also used when retransmitting database description and link-state request packets. This value should be well over the expected round-trip.')
fciOspfVlHelloInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 41, 36, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciOspfVlHelloInterval.setStatus('mandatory')
if mibBuilder.loadTexts: fciOspfVlHelloInterval.setDescription('VL hello interval. The length of time, in seconds, between the Hello packets that the router sends on the interface. This value must be the same for the virtual neighbor.')
fciOspfVlRouterDeadInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 41, 36, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciOspfVlRouterDeadInterval.setStatus('mandatory')
if mibBuilder.loadTexts: fciOspfVlRouterDeadInterval.setDescription("VL router dead interval. The number of seconds that a router's Hello packets have not been seen before it's neighbors declare the router down. This should be some multiple of the Hello interval. This value must be the same for the virtual neighbor.")
fciOspfVlAuthenticationKey = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 41, 36, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciOspfVlAuthenticationKey.setStatus('mandatory')
if mibBuilder.loadTexts: fciOspfVlAuthenticationKey.setDescription('VL authentication key. If Authentication Type is simplePassword, the device will left adjust and zero fill to 8 octets. When read, ospfVifAuthKey always returns a string of length zero.')
fciOspfExportingGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 41, 40))
fciOspfAseExportInterval = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 41, 40, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciOspfAseExportInterval.setStatus('mandatory')
if mibBuilder.loadTexts: fciOspfAseExportInterval.setDescription('ASE flow packets interval. Together with fciOspfAseExportLimit, controls the rate at which Autonomous System External (ASE) routes are imported. The rate is defined as the ratio of fciOspfAseExportLimit and fciOspfAseExportInterval, in number of routes per second. By default, ASE routes are imported at the rate of 100 ASEs per second.')
fciOspfAseExportLimit = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 41, 40, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciOspfAseExportLimit.setStatus('mandatory')
if mibBuilder.loadTexts: fciOspfAseExportLimit.setDescription('ASE flow packets limit. Together with fciOspfAseExportInterval, controls the rate at which Autonomous System External (ASE) routes are imported. The rate is defined as the ratio of fciOspfAseExportLimit and fciOspfAseExportInterval, in number of routes per second. By default, ASE routes are imported at the rate of 100 ASEs per second.')
fciOspfAseExportStaticsStatus = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 41, 40, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciOspfAseExportStaticsStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fciOspfAseExportStaticsStatus.setDescription('Statics ASE export status. ')
fciOspfAseExportStaticsMetric = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 41, 40, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciOspfAseExportStaticsMetric.setStatus('mandatory')
if mibBuilder.loadTexts: fciOspfAseExportStaticsMetric.setDescription('Statics ASE export metric. The default metric (or cost) used by OSPF when propagating (exporting) routes learned via other protocols.')
fciOspfAseExportStaticsTag = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 41, 40, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483648))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciOspfAseExportStaticsTag.setStatus('mandatory')
if mibBuilder.loadTexts: fciOspfAseExportStaticsTag.setDescription('Statics ASE export tag. The OSPF tag to be placed on all routes exported by OSPF. Specifies one way of generating OSPF tags.')
fciOspfAseExportStaticsType = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 41, 40, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciOspfAseExportStaticsType.setStatus('mandatory')
if mibBuilder.loadTexts: fciOspfAseExportStaticsType.setDescription("Statics ASE export type The OSPF external routes type used to export static routes. The value '1' indicates that the metric of the static routes exported are directly comparable with OSPF metric. The value '2' indicates the contrary. ")
fciOspfAseExportRipStatus = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 41, 40, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciOspfAseExportRipStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fciOspfAseExportRipStatus.setDescription('RIP ASE export status. ')
fciOspfAseExportRipMetric = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 41, 40, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciOspfAseExportRipMetric.setStatus('mandatory')
if mibBuilder.loadTexts: fciOspfAseExportRipMetric.setDescription('RIP ASE export metric. The default metric (or cost) used by OSPF when propagating (exporting) routes learned via other protocols.')
fciOspfAseExportRipTag = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 41, 40, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483648))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciOspfAseExportRipTag.setStatus('mandatory')
if mibBuilder.loadTexts: fciOspfAseExportRipTag.setDescription('RIP ASE export tag. The OSPF tag to be placed on all routes exported by OSPF. Specifies one way of generating OSPF tags.')
fciOspfAseExportRipType = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 41, 40, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciOspfAseExportRipType.setStatus('mandatory')
if mibBuilder.loadTexts: fciOspfAseExportRipType.setDescription("RIP ASE export type The OSPF external routes type used to export RIP routes. The value '1' indicates that the metric of the static routes exported are directly comparable with OSPF metric. The value '2' indicates the contrary.")
fciEgp = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 45))
fciEgpAdminStatus = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 45, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciEgpAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fciEgpAdminStatus.setDescription("The value of this object indicates whether EGP (Exterior Gateway Protocol) is enabled or not. fciEgpNeighborTable must contain at least one entry. The default value is 'off'.")
fciEgpAutonomousSystemNumber = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 45, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65534))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciEgpAutonomousSystemNumber.setStatus('mandatory')
if mibBuilder.loadTexts: fciEgpAutonomousSystemNumber.setDescription("The value of this object defines the autonomous system to which belongs this IP router. The authorized values are '1..65534'. The default value is '1'.")
fciEgpStaticRoutesDistribution = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 45, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciEgpStaticRoutesDistribution.setStatus('mandatory')
if mibBuilder.loadTexts: fciEgpStaticRoutesDistribution.setDescription("The value of this object indicates whether EGP distributes static entries of the routing table (i.e., those defined in fciIpRouteTable) or not.. The autonomous systems to which these routing informations are distributed are defined in fciEgpTargetAsDistributionTable. The default value is 'off'.")
fciEgpRipRoutesDistribution = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 45, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciEgpRipRoutesDistribution.setStatus('mandatory')
if mibBuilder.loadTexts: fciEgpRipRoutesDistribution.setDescription("The value of this object indicates whether EGP distributes entries of the routing table learnt by RIP (Routing Information Protocol) or not. The autonomous systems to which these routing informations are distributed are defined in fciEgpTargetAsDistributionTable. The default value is 'off'.")
fciEgpMetricDistribution = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 45, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciEgpMetricDistribution.setStatus('mandatory')
if mibBuilder.loadTexts: fciEgpMetricDistribution.setDescription("The value of this object is the value indicated in the transmitted EGP datagrams concerning routing information learnt by RIP. The authorized values are '1..255'. The default value is '128'.")
fciEgpNeighborTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 45, 10), )
if mibBuilder.loadTexts: fciEgpNeighborTable.setStatus('mandatory')
if mibBuilder.loadTexts: fciEgpNeighborTable.setDescription('This table defines the EGP neighbors with witch EGP exchanges routing informations.')
fciEgpNeighborEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 45, 10, 1), ).setIndexNames((0, "PCE-MIB", "fciEgpNeighborIpAddress"))
if mibBuilder.loadTexts: fciEgpNeighborEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fciEgpNeighborEntry.setDescription('An entry of fciEgpNeighborTable.')
fciEgpNeighborIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 45, 10, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fciEgpNeighborIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: fciEgpNeighborIpAddress.setDescription("The value of this object is the IP address of an EGP neighbor. This IP address must be a valid host address. The default value is '0.0.0.0'.")
fciEgpNeighborStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 45, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciEgpNeighborStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fciEgpNeighborStatus.setDescription("The value of this object indicates the state of the entry of this table. The default value is 'valid'. It must be set to 'invalid' to delete the entry.")
fciEgpNeighborAsNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 45, 10, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65534))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciEgpNeighborAsNumber.setStatus('mandatory')
if mibBuilder.loadTexts: fciEgpNeighborAsNumber.setDescription("The value of this object defines the autonomous system to which belongs this EGP neighbor. The authorized values are '1..65534'. The default value is '1'.")
fciEgpTargetAsDistributionTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 45, 15), )
if mibBuilder.loadTexts: fciEgpTargetAsDistributionTable.setStatus('mandatory')
if mibBuilder.loadTexts: fciEgpTargetAsDistributionTable.setDescription('As defined by fciEgpStaticRoutesDistribution and fciEgpRipRoutesDistribution, when EGP distributes static entries or entries of the routing table learnt by RIP (Routing Information Protocol), this table defines to which autonomous systems these entries are to be distributed. Only neighbors of an automous system specified in this table will receive these routing informations.')
fciEgpTargetAsDistributionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 45, 15, 1), ).setIndexNames((0, "PCE-MIB", "fciEgpTargetAsNumber"))
if mibBuilder.loadTexts: fciEgpTargetAsDistributionEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fciEgpTargetAsDistributionEntry.setDescription('An entry of fciEgpTargetAsDistributionTable.')
fciEgpTargetAsNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 45, 15, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65534))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fciEgpTargetAsNumber.setStatus('mandatory')
if mibBuilder.loadTexts: fciEgpTargetAsNumber.setDescription("The value of this object identifies an autonomous system containing routers to which EGP distributes the routing informations. This AS must exist in fciEgpNeighborTable. The authorized values are '1..65534'. The default value is '0'.")
fciEgpTargetAsStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 45, 15, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciEgpTargetAsStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fciEgpTargetAsStatus.setDescription("The value of this object indicates the state of the entry of this table. The default value is 'valid'. It must be set to 'invalid' to delete the entry.")
fciSnmp = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 50))
fciSnmpCommunityStringReadOnly = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 50, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 14))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciSnmpCommunityStringReadOnly.setStatus('mandatory')
if mibBuilder.loadTexts: fciSnmpCommunityStringReadOnly.setDescription("The value of this object is the string which identifies the 'public' community. The managers of this community have only 'read-only' access rights even on the objects with read-write access. The SNMP agent of this equipment compares the community string of a received GetRequest or GetNextRequest to this value to know whether it makes a GetResponse or not. This value may contain up to 14 printable characters. The default value is 'public'.")
fciSnmpCommunityStringReadWrite = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 50, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 14))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciSnmpCommunityStringReadWrite.setStatus('mandatory')
if mibBuilder.loadTexts: fciSnmpCommunityStringReadWrite.setDescription("The value of this object is the string which identifies the 'administrator' community. The managers of this community have complete access rights (i.e. they have the rights which are defined in the MIB). The SNMP agent of this equipment compares the community string of a received GetRequest, GetNextRequest or SetRequest to this value to know whether it makes a GetResponse or not. This value may contain up to 14 printable characters. The default value is 'private'.")
fciSnmpCommunityStringTrap = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 50, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 14))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciSnmpCommunityStringTrap.setStatus('mandatory')
if mibBuilder.loadTexts: fciSnmpCommunityStringTrap.setDescription("The value of this object is the string which identifies the 'alarm' community. The managers of this community may filter the received Traps according of this community string. The SNMP agent of this equipment sets the community string of all the sent Trap to this value. It sends traps to the managers defined in fciSnmpManagerTable. This value may contain up to 14 printable characters. The default value is 'private'.")
fciSnmpAuthenticationFailureTrap = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 50, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciSnmpAuthenticationFailureTrap.setStatus('mandatory')
if mibBuilder.loadTexts: fciSnmpAuthenticationFailureTrap.setDescription("The value of this object specifies whether the SNMP agent sends the authenticationFailure trap or not. When enabled, this trap is sent with each reception of an unauthorized SNMP request (erroneous community string or manager not authorized). It can be useful to disable this sending when unauthorized SNMP managers polls very often the SNMP agent because the quantity of authenticationFailure trap is then very important and prevents the 'good' manager to show correctly the significant traps. The default value is 'off'.")
fciSnmpModule0TrapSourceAddrVpId = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 50, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 11))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciSnmpModule0TrapSourceAddrVpId.setStatus('mandatory')
if mibBuilder.loadTexts: fciSnmpModule0TrapSourceAddrVpId.setDescription("The SNMP agent of module 0 indicates, as the source address of each TRAP, the IP address associated with the virtual port identified by this value. This virtual port must exist in fciVirtualPortTable. The authorized values are '0..199'. The default value is '0'.")
fciSnmpModule1TrapSourceAddrVpId = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 50, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 11))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciSnmpModule1TrapSourceAddrVpId.setStatus('mandatory')
if mibBuilder.loadTexts: fciSnmpModule1TrapSourceAddrVpId.setDescription("The SNMP agent of module 1 indicates, as the source address of each TRAP, the IP address associated with the virtual port identified by this value. This virtual port must exist in fciVirtualPortTable. The authorized values are '0..199'. The default value is '255' meaning 'empty value' (blank value on the equipment configurator).")
fciSnmpModule2TrapSourceAddrVpId = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 50, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 11))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciSnmpModule2TrapSourceAddrVpId.setStatus('mandatory')
if mibBuilder.loadTexts: fciSnmpModule2TrapSourceAddrVpId.setDescription("The SNMP agent of module 1 indicates, as the source address of each TRAP, the IP address associated with the virtual port identified by this value. This virtual port must exist in fciVirtualPortTable. The authorized values are '0..199'. The default value is '255' meaning 'empty value' (blank value on the equipment configurator).")
fciSnmpManagerFiltering = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 50, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciSnmpManagerFiltering.setStatus('mandatory')
if mibBuilder.loadTexts: fciSnmpManagerFiltering.setDescription("The value of this object specifies whether the SNMP agent answers to all the SNMP managers or only to those defined in fciSnmpManagerTable. When set to 'on' the SNMP agent sends an authenticationFailure trap (if enabled) each time it receives a request from a manager not in the table. The default value is 'off' (i.e., no filtering : access for all managers)..")
fciSnmpManagerTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 50, 20), )
if mibBuilder.loadTexts: fciSnmpManagerTable.setStatus('mandatory')
if mibBuilder.loadTexts: fciSnmpManagerTable.setDescription("This table contains the SNMP managers to which SNMP traps may be sent. This table is also used to define the authorized managers when fciSnmpManagerFiltering is set to 'on'.")
fciSnmpManagerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 50, 20, 1), ).setIndexNames((0, "PCE-MIB", "fciSnmpManagerIpAddress"))
if mibBuilder.loadTexts: fciSnmpManagerEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fciSnmpManagerEntry.setDescription('An entry of fciSnmpManagerTable.')
fciSnmpManagerIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 50, 20, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fciSnmpManagerIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: fciSnmpManagerIpAddress.setDescription("The value of this object is the IP address of an SNMP manager. This IP address must be a valid host address. The default value is '0.0.0.0'.")
fciSnmpManagerStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 50, 20, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciSnmpManagerStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fciSnmpManagerStatus.setDescription("The value of this object indicates the state of the entry of this table. The default value is 'valid'. It must be set to 'invalid' to delete the entry.")
fciSnmpManagerSendTraps = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 50, 20, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciSnmpManagerSendTraps.setStatus('mandatory')
if mibBuilder.loadTexts: fciSnmpManagerSendTraps.setDescription("The value of this object specifies whether the SNMP agent sends the traps to this SNMP manager or not. The default value is 'on'.")
fciSnmpManagerTrapsUdpPort = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 50, 20, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciSnmpManagerTrapsUdpPort.setStatus('mandatory')
if mibBuilder.loadTexts: fciSnmpManagerTrapsUdpPort.setDescription("The value of this object indicates the UDP port to which are sent the SNMP traps. This value must be the value used by this SNMP manager when it listens for SNMP traps. The authorized values are '0..65535'. The default value is '162'.")
fciBootP = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 60))
fciBootPClient = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 60, 1))
fciBootPClientStart = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 60, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciBootPClientStart.setStatus('mandatory')
if mibBuilder.loadTexts: fciBootPClientStart.setDescription("The value of this object identifies start mode of equipement. The default value is 'no'.")
fciBootPClientServer = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 60, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciBootPClientServer.setStatus('mandatory')
if mibBuilder.loadTexts: fciBootPClientServer.setDescription('The value of this object identifies server name. This value may contain up to 64 printable characters. The default value is an empty string.')
fciBootPClientBootFile = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 60, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciBootPClientBootFile.setStatus('mandatory')
if mibBuilder.loadTexts: fciBootPClientBootFile.setDescription('The value of this object identifies generic name of bootfile. This value may contain up to 64 printable characters. The default value is an empty string.')
fciBootPClientBootTime = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 60, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(15, 900))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciBootPClientBootTime.setStatus('mandatory')
if mibBuilder.loadTexts: fciBootPClientBootTime.setDescription("The value of this object identifies time to wait before bootp launching. Time is specified in seconds. The authorized values are '15..900'. The default value is '180'.")
fciBootPClientRetransNb = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 60, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciBootPClientRetransNb.setStatus('mandatory')
if mibBuilder.loadTexts: fciBootPClientRetransNb.setDescription("The value of this object identifies numbers of retransmissions of bootrequest packet. The authorized values are '0..10'. The default value is '5'.")
fciBootPInterfaceTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 60, 1, 20), )
if mibBuilder.loadTexts: fciBootPInterfaceTable.setStatus('mandatory')
if mibBuilder.loadTexts: fciBootPInterfaceTable.setDescription('This table describes the parameters of BootP Virtual Ports. It offers a solution to link many servers on the bootp client or relay.')
fciBootPInterfaceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 60, 1, 20, 1), ).setIndexNames((0, "PCE-MIB", "fciBootPInterfaceVpId"), (0, "PCE-MIB", "fciBootPInterfaceIpAddress"))
if mibBuilder.loadTexts: fciBootPInterfaceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fciBootPInterfaceEntry.setDescription('An entry of fciBootPInterfaceTable.')
fciBootPInterfaceVpId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 60, 1, 20, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 11))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fciBootPInterfaceVpId.setStatus('mandatory')
if mibBuilder.loadTexts: fciBootPInterfaceVpId.setDescription("The value of this object identifies one virtual port. The default value is '255'.")
fciBootPInterfaceIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 60, 1, 20, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fciBootPInterfaceIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: fciBootPInterfaceIpAddress.setDescription("The value of this object is the IP address associated to one bootp interface. The default value is '255.255.255.255'.")
fciBootPInterfaceStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 60, 1, 20, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciBootPInterfaceStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fciBootPInterfaceStatus.setDescription("The value of this object indicates the state of the entry of this table. The default value is 'valid'. It must be set to 'invalid' to delete the entry.")
fciBootPInterfaceType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 60, 1, 20, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("client", 1), ("relay", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciBootPInterfaceType.setStatus('mandatory')
if mibBuilder.loadTexts: fciBootPInterfaceType.setDescription("The value of this object indicates the fonctionnality of the equipement. The authorized values are 'client' or 'relay'. The default value is 'client'.")
fciTelnet = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 70))
fciTelnetConfiguration = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 70, 1))
fciTelnetMaxSession = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 70, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 50))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciTelnetMaxSession.setStatus('mandatory')
if mibBuilder.loadTexts: fciTelnetMaxSession.setDescription('Maximum number of telnet session that the equipment would accept. This number include the telnet session issuing from the equipment. The modification of this parameter need a reboot of the equipment. The default value is 6.')
fciTelnetTimer = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 70, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3600))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciTelnetTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fciTelnetTimer.setDescription('This parameter is global to all connection and set the timer that make a session to be disconnected if no traffic is send or receive in the telnet session. The modification of the parameter takes effect after a hot reset and is used for new connections ')
fciTelnetPwd = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 70, 10))
fciTelnetPwdP0 = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 70, 10, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciTelnetPwdP0.setStatus('mandatory')
if mibBuilder.loadTexts: fciTelnetPwdP0.setDescription("This parameter set the password to access to a priority 0 level. All the user set to a priority 0 level have to uses this password. The modification of the parameter takes effect after a hot reset and is used for new connections The default value is 'root'.")
fciTelnetPwdP1 = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 70, 10, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciTelnetPwdP1.setStatus('mandatory')
if mibBuilder.loadTexts: fciTelnetPwdP1.setDescription("This parameter set the password to access to a priority 1 level. All the user set to a priority 1 level have to uses this password. The modification of the parameter takes effect after a hot reset and is used for new connections The default value is 'user'.")
fciTelnetPwdP2 = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 70, 10, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciTelnetPwdP2.setStatus('mandatory')
if mibBuilder.loadTexts: fciTelnetPwdP2.setDescription("This parameter set the password to access to a priority 2 level. All the user set to a priority 2 level have to uses this password. The modification of the parameter takes effect after a hot reset and is used for new connections The default value is 'user'.")
fciTelnetPwdP3 = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 70, 10, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciTelnetPwdP3.setStatus('mandatory')
if mibBuilder.loadTexts: fciTelnetPwdP3.setDescription("This parameter set the password to access to a priority 3 level. All the user set to a priority 3 level have to uses this password. The modification of the parameter takes effect after a hot reset and is used for new connections The default value is 'user'.")
fciTelnetPwdP4 = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 70, 10, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciTelnetPwdP4.setStatus('mandatory')
if mibBuilder.loadTexts: fciTelnetPwdP4.setDescription("This parameter set the password to access to a priority 4 level. All the user set to a priority 4 level have to uses this password. The modification of the parameter takes effect after a hot reset and is used for new connections The default value is 'user'.")
fciTelnetPwdP5 = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 70, 10, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciTelnetPwdP5.setStatus('mandatory')
if mibBuilder.loadTexts: fciTelnetPwdP5.setDescription("This parameter set the password to access to a priority 5 level. All the user set to a priority 5 level have to uses this password. The modification of the parameter takes effect after a hot reset and is used for new connections The default value is 'user'.")
fciTelnetPwdP6 = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 70, 10, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciTelnetPwdP6.setStatus('mandatory')
if mibBuilder.loadTexts: fciTelnetPwdP6.setDescription("This parameter set the password to access to a priority 6 level. All the user set to a priority 6 level have to uses this password. The modification of the parameter takes effect after a hot reset and is used for new connections The default value is 'user'.")
fciTelnetPwdP7 = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 70, 10, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciTelnetPwdP7.setStatus('mandatory')
if mibBuilder.loadTexts: fciTelnetPwdP7.setDescription("This parameter set the password to access to a priority 7 level. All the user set to a priority 7 level have to uses this password. The modification of the parameter takes effect after a hot reset and is used for new connections The default value is 'user'.")
fciTelnetPwdP8 = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 70, 10, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciTelnetPwdP8.setStatus('mandatory')
if mibBuilder.loadTexts: fciTelnetPwdP8.setDescription("This parameter set the password to access to a priority 8 level. All the user set to a priority 8 level have to uses this password. The modification of the parameter takes effect after a hot reset and is used for new connections The default value is 'user'.")
fciTelnetPwdP9 = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 70, 10, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciTelnetPwdP9.setStatus('mandatory')
if mibBuilder.loadTexts: fciTelnetPwdP9.setDescription("This parameter set the password to access to a priority 9 level. All the user set to a priority 9 level have to uses this password. The modification of the parameter takes effect after a hot reset and is used for new connections The default value is 'user'.")
fciTelnetUserTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 70, 30), )
if mibBuilder.loadTexts: fciTelnetUserTable.setStatus('mandatory')
if mibBuilder.loadTexts: fciTelnetUserTable.setDescription('')
fciTelnetUserEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 70, 30, 1), ).setIndexNames((0, "PCE-MIB", "fciTelnetUserId"))
if mibBuilder.loadTexts: fciTelnetUserEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fciTelnetUserEntry.setDescription('An entry of fciTelnetUserTable.')
fciTelnetUserId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 70, 30, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 49))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fciTelnetUserId.setStatus('mandatory')
if mibBuilder.loadTexts: fciTelnetUserId.setDescription('This parameter identify the user.')
fciTelnetUserStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 70, 30, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciTelnetUserStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fciTelnetUserStatus.setDescription('This parameter set the status of the raw')
fciTelnetUserLogin = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 70, 30, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciTelnetUserLogin.setStatus('mandatory')
if mibBuilder.loadTexts: fciTelnetUserLogin.setDescription('This parameter set the login identification of the user. The password ask to the user would the associated priority password. The modification of the parameter takes effect after a hot reset and is used for new connections.')
fciTelnetUserPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 36, 70, 30, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fciTelnetUserPriority.setStatus('mandatory')
if mibBuilder.loadTexts: fciTelnetUserPriority.setDescription('This parameter associate a priority level to a user. The priority level give access right to different service. The default value is set to the lower priority level. The modification of the parameter takes effect after a hot reset and is used for new connections.')
fcIpx = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 37))
fcxInstance = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 1))
fcxIpxRouting = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxIpxRouting.setStatus('mandatory')
if mibBuilder.loadTexts: fcxIpxRouting.setDescription('Activation')
fcxBasicSysName = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 47))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxBasicSysName.setStatus('mandatory')
if mibBuilder.loadTexts: fcxBasicSysName.setDescription('ipxBasicSysName')
fcxAdvSysMaxPathSplits = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxAdvSysMaxPathSplits.setStatus('mandatory')
if mibBuilder.loadTexts: fcxAdvSysMaxPathSplits.setDescription('ipxAdvSysMaxPathSplits')
fcxAdvSysMaxHops = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxAdvSysMaxHops.setStatus('mandatory')
if mibBuilder.loadTexts: fcxAdvSysMaxHops.setDescription('ipxAdvSysMaxHops')
fcxCircuits = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 10))
fcxCircuitTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 10, 1), )
if mibBuilder.loadTexts: fcxCircuitTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcxCircuitTable.setDescription('')
fcxCircuitEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 10, 1, 1), ).setIndexNames((0, "PCE-MIB", "fcxCircCircuitId"))
if mibBuilder.loadTexts: fcxCircuitEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcxCircuitEntry.setDescription('An entry of fcxCircuitTable.')
fcxCircCircuitId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 10, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 199))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcxCircCircuitId.setStatus('mandatory')
if mibBuilder.loadTexts: fcxCircCircuitId.setDescription('Circuit id')
fcxCircStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 10, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxCircStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fcxCircStatus.setDescription('Status')
fcxCircVirtualPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 10, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 11))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxCircVirtualPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fcxCircVirtualPortId.setDescription('VP id')
fcxCircOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 10, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("down", 1), ("up", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxCircOperState.setStatus('mandatory')
if mibBuilder.loadTexts: fcxCircOperState.setDescription('ipxCircOperState')
fcxCircName = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 10, 1, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 24))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxCircName.setStatus('mandatory')
if mibBuilder.loadTexts: fcxCircName.setDescription('ipxCircName')
fcxCircType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 10, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 6))).clone(namedValues=NamedValues(("broadcast", 2), ("ptToPt", 3), ("dynamic", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxCircType.setStatus('mandatory')
if mibBuilder.loadTexts: fcxCircType.setDescription('ipxCircType')
fcxCircLocalMaxPacketSize = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 10, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(512, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxCircLocalMaxPacketSize.setStatus('mandatory')
if mibBuilder.loadTexts: fcxCircLocalMaxPacketSize.setDescription('ipxCircLocalMaxPacketSize')
fcxCircNetNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 10, 1, 1, 14), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxCircNetNumber.setStatus('mandatory')
if mibBuilder.loadTexts: fcxCircNetNumber.setDescription('ipxCircNetNumber')
fcxCircChecksumEnabling = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 10, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxCircChecksumEnabling.setStatus('mandatory')
if mibBuilder.loadTexts: fcxCircChecksumEnabling.setDescription('Calcul du checksum')
fcxCircuitLocalVpTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 10, 2), )
if mibBuilder.loadTexts: fcxCircuitLocalVpTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcxCircuitLocalVpTable.setDescription('')
fcxCircuitLocalVpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 10, 2, 1), ).setIndexNames((0, "PCE-MIB", "fcxCircLvpCircuitId"))
if mibBuilder.loadTexts: fcxCircuitLocalVpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcxCircuitLocalVpEntry.setDescription('An entry of fcxCircuitLocalVpTable.')
fcxCircLvpCircuitId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 10, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 199))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcxCircLvpCircuitId.setStatus('mandatory')
if mibBuilder.loadTexts: fcxCircLvpCircuitId.setDescription('Circuit id')
fcxCircLvpStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 10, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxCircLvpStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fcxCircLvpStatus.setDescription('Status')
fcxCircLvpEncapsulation = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 10, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("ethernet", 1), ("ether802-3", 2), ("ether802-2", 3), ("etherSnap", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxCircLvpEncapsulation.setStatus('mandatory')
if mibBuilder.loadTexts: fcxCircLvpEncapsulation.setDescription('Encapsulation')
fcxCircuitRemoteVpTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 10, 3), )
if mibBuilder.loadTexts: fcxCircuitRemoteVpTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcxCircuitRemoteVpTable.setDescription('')
fcxCircuitRemoteVpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 10, 3, 1), ).setIndexNames((0, "PCE-MIB", "fcxCircRvpCircuitId"))
if mibBuilder.loadTexts: fcxCircuitRemoteVpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcxCircuitRemoteVpEntry.setDescription('An entry of fcxCircuitRemoteVpTable.')
fcxCircRvpCircuitId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 10, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 199))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcxCircRvpCircuitId.setStatus('mandatory')
if mibBuilder.loadTexts: fcxCircRvpCircuitId.setDescription('Circuit id')
fcxCircRvpStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 10, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxCircRvpStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fcxCircRvpStatus.setDescription('Status')
fcxCircRvpRemoteAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 10, 3, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxCircRvpRemoteAddress.setStatus('mandatory')
if mibBuilder.loadTexts: fcxCircRvpRemoteAddress.setDescription('Adresse WAN')
fcxCircRvpLocalNode = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 10, 3, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxCircRvpLocalNode.setStatus('mandatory')
if mibBuilder.loadTexts: fcxCircRvpLocalNode.setDescription('Adresse locale')
fcxRouting = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 20))
fcxRoutInstance = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 20, 1))
fcxRoutType20PacketBroadcasting = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 20, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("onLanOnly", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxRoutType20PacketBroadcasting.setStatus('mandatory')
if mibBuilder.loadTexts: fcxRoutType20PacketBroadcasting.setDescription('Diffusion des paquets IPX de type 20')
fcxRoutCircuitTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 20, 10), )
if mibBuilder.loadTexts: fcxRoutCircuitTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcxRoutCircuitTable.setDescription('')
fcxRoutCircuitEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 20, 10, 1), ).setIndexNames((0, "PCE-MIB", "fcxRoutCircCircuitId"))
if mibBuilder.loadTexts: fcxRoutCircuitEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcxRoutCircuitEntry.setDescription('An entry of fcxRoutCircuitTable.')
fcxRoutCircCircuitId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 20, 10, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 199))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcxRoutCircCircuitId.setStatus('mandatory')
if mibBuilder.loadTexts: fcxRoutCircCircuitId.setDescription('Circuit id')
fcxRoutCircNcpSpoofing = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 20, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxRoutCircNcpSpoofing.setStatus('mandatory')
if mibBuilder.loadTexts: fcxRoutCircNcpSpoofing.setDescription('Netware Core Protocol Spoofing')
fcxRoutCircType20PacketBroadcasting = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 20, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxRoutCircType20PacketBroadcasting.setStatus('mandatory')
if mibBuilder.loadTexts: fcxRoutCircType20PacketBroadcasting.setDescription('Diffusion des paquets IPX de type 20')
fcxRoutCircAddressFiltering = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 20, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("permitted", 2), ("denied", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxRoutCircAddressFiltering.setStatus('mandatory')
if mibBuilder.loadTexts: fcxRoutCircAddressFiltering.setDescription('Filtrage sur adresse IPX')
fcxRoutIpxStaticRouteTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 20, 20), )
if mibBuilder.loadTexts: fcxRoutIpxStaticRouteTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcxRoutIpxStaticRouteTable.setDescription('')
fcxRoutIpxStaticRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 20, 20, 1), ).setIndexNames((0, "PCE-MIB", "fcxRoutStaticRouteCircuitId"), (0, "PCE-MIB", "fcxRoutStaticRouteNetNum"))
if mibBuilder.loadTexts: fcxRoutIpxStaticRouteEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcxRoutIpxStaticRouteEntry.setDescription('An entry of fcxRoutIpxStaticRouteTable.')
fcxRoutStaticRouteCircuitId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 20, 20, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 199))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcxRoutStaticRouteCircuitId.setStatus('mandatory')
if mibBuilder.loadTexts: fcxRoutStaticRouteCircuitId.setDescription('ipxStaticRouteCircIndex')
fcxRoutStaticRouteNetNum = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 20, 20, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcxRoutStaticRouteNetNum.setStatus('mandatory')
if mibBuilder.loadTexts: fcxRoutStaticRouteNetNum.setDescription('ipxStaticRouteNetNum')
fcxRoutStaticRouteStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 20, 20, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxRoutStaticRouteStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fcxRoutStaticRouteStatus.setDescription('Status')
fcxRoutStaticRouteTicks = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 20, 20, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxRoutStaticRouteTicks.setStatus('mandatory')
if mibBuilder.loadTexts: fcxRoutStaticRouteTicks.setDescription('ipxStaticRouteTicks en 1/60eme de seconde')
fcxRoutStaticRouteHopCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 20, 20, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxRoutStaticRouteHopCount.setStatus('mandatory')
if mibBuilder.loadTexts: fcxRoutStaticRouteHopCount.setDescription('ipxStaticRouteHopCount')
fcxRoutAddressFilteringTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 20, 30), )
if mibBuilder.loadTexts: fcxRoutAddressFilteringTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcxRoutAddressFilteringTable.setDescription('')
fcxRoutAddressFilteringEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 20, 30, 1), ).setIndexNames((0, "PCE-MIB", "fcxRoutAddrFltCircuitId"), (0, "PCE-MIB", "fcxRoutAddrFltFilterId"))
if mibBuilder.loadTexts: fcxRoutAddressFilteringEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcxRoutAddressFilteringEntry.setDescription('An entry of fcxRoutAddressFilteringTable.')
fcxRoutAddrFltCircuitId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 20, 30, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 199))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcxRoutAddrFltCircuitId.setStatus('mandatory')
if mibBuilder.loadTexts: fcxRoutAddrFltCircuitId.setDescription('Circuit id')
fcxRoutAddrFltFilterId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 20, 30, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcxRoutAddrFltFilterId.setStatus('mandatory')
if mibBuilder.loadTexts: fcxRoutAddrFltFilterId.setDescription('Filtre id')
fcxRoutAddrFltStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 20, 30, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxRoutAddrFltStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fcxRoutAddrFltStatus.setDescription('Status')
fcxRoutAddrFltFiltering = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 20, 30, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxRoutAddrFltFiltering.setStatus('mandatory')
if mibBuilder.loadTexts: fcxRoutAddrFltFiltering.setDescription('Activation du filtre')
fcxRoutAddrFltField = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 20, 30, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("sourceNetAddress", 1), ("destNetAddress", 2), ("sourceSocket", 3), ("destSocket", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxRoutAddrFltField.setStatus('mandatory')
if mibBuilder.loadTexts: fcxRoutAddrFltField.setDescription('Champ')
fcxRoutAddrFltMask = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 20, 30, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxRoutAddrFltMask.setStatus('mandatory')
if mibBuilder.loadTexts: fcxRoutAddrFltMask.setDescription('Masque')
fcxRoutAddrFltValue = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 20, 30, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxRoutAddrFltValue.setStatus('mandatory')
if mibBuilder.loadTexts: fcxRoutAddrFltValue.setDescription('Valeur')
fcxRoutingInformationProtocol = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 25))
fcxRipInstance = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 25, 1))
fcxRipSysState = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 25, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxRipSysState.setStatus('mandatory')
if mibBuilder.loadTexts: fcxRipSysState.setDescription('ripSysState')
fcxRipInputFiltering = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 25, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("permitted", 2), ("denied", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxRipInputFiltering.setStatus('mandatory')
if mibBuilder.loadTexts: fcxRipInputFiltering.setDescription('Filtrage RIP en entree')
fcxRipCircuitTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 25, 10), )
if mibBuilder.loadTexts: fcxRipCircuitTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcxRipCircuitTable.setDescription('')
fcxRipCircuitEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 25, 10, 1), ).setIndexNames((0, "PCE-MIB", "fcxRipCircCircuitId"))
if mibBuilder.loadTexts: fcxRipCircuitEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcxRipCircuitEntry.setDescription('An entry of fcxRipCircuitTable.')
fcxRipCircCircuitId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 25, 10, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 199))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcxRipCircCircuitId.setStatus('mandatory')
if mibBuilder.loadTexts: fcxRipCircCircuitId.setDescription('Circuit id')
fcxRipCircState = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 25, 10, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxRipCircState.setStatus('mandatory')
if mibBuilder.loadTexts: fcxRipCircState.setDescription('ripCircState')
fcxRipCircPace = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 25, 10, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxRipCircPace.setStatus('mandatory')
if mibBuilder.loadTexts: fcxRipCircPace.setDescription('ripCircPace')
fcxRipCircUpdate = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 25, 10, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxRipCircUpdate.setStatus('mandatory')
if mibBuilder.loadTexts: fcxRipCircUpdate.setDescription('ripCircUpdate')
fcxRipCircAgeMultiplier = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 25, 10, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxRipCircAgeMultiplier.setStatus('mandatory')
if mibBuilder.loadTexts: fcxRipCircAgeMultiplier.setDescription('ripCircAgeMultiplier')
fcxRipCircPacketSize = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 25, 10, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(512, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxRipCircPacketSize.setStatus('mandatory')
if mibBuilder.loadTexts: fcxRipCircPacketSize.setDescription('ripCircPacketSize')
fcxRipCircOutputFiltering = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 25, 10, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("permitted", 2), ("denied", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxRipCircOutputFiltering.setStatus('mandatory')
if mibBuilder.loadTexts: fcxRipCircOutputFiltering.setDescription('Filtrage RIP en sortie')
fcxRipInputFilteringTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 25, 11), )
if mibBuilder.loadTexts: fcxRipInputFilteringTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcxRipInputFilteringTable.setDescription('')
fcxRipInputFilteringEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 25, 11, 1), ).setIndexNames((0, "PCE-MIB", "fcxRipInFltFilterId"))
if mibBuilder.loadTexts: fcxRipInputFilteringEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcxRipInputFilteringEntry.setDescription('An entry of fcxRipInputFilteringTable.')
fcxRipInFltFilterId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 25, 11, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcxRipInFltFilterId.setStatus('mandatory')
if mibBuilder.loadTexts: fcxRipInFltFilterId.setDescription('Filtre id')
fcxRipInFltStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 25, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxRipInFltStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fcxRipInFltStatus.setDescription('Status')
fcxRipInFltFiltering = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 25, 11, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxRipInFltFiltering.setStatus('mandatory')
if mibBuilder.loadTexts: fcxRipInFltFiltering.setDescription('Activation du filtre')
fcxRipInFltNetAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 25, 11, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxRipInFltNetAddress.setStatus('mandatory')
if mibBuilder.loadTexts: fcxRipInFltNetAddress.setDescription('Adresse reseau')
fcxRipInFltMask = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 25, 11, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxRipInFltMask.setStatus('mandatory')
if mibBuilder.loadTexts: fcxRipInFltMask.setDescription('Masque adresse')
fcxRipOutputFilteringTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 25, 12), )
if mibBuilder.loadTexts: fcxRipOutputFilteringTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcxRipOutputFilteringTable.setDescription('')
fcxRipOutputFilteringEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 25, 12, 1), ).setIndexNames((0, "PCE-MIB", "fcxRipOutFltCircuitId"), (0, "PCE-MIB", "fcxRipOutFltFilterId"))
if mibBuilder.loadTexts: fcxRipOutputFilteringEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcxRipOutputFilteringEntry.setDescription('An entry of fcxRipOutputFilteringTable.')
fcxRipOutFltCircuitId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 25, 12, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 199))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcxRipOutFltCircuitId.setStatus('mandatory')
if mibBuilder.loadTexts: fcxRipOutFltCircuitId.setDescription('Circuit id')
fcxRipOutFltFilterId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 25, 12, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcxRipOutFltFilterId.setStatus('mandatory')
if mibBuilder.loadTexts: fcxRipOutFltFilterId.setDescription('Filtre id')
fcxRipOutFltStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 25, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxRipOutFltStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fcxRipOutFltStatus.setDescription('Status')
fcxRipOutFltFiltering = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 25, 12, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxRipOutFltFiltering.setStatus('mandatory')
if mibBuilder.loadTexts: fcxRipOutFltFiltering.setDescription('Activation du filtre')
fcxRipOutFltNetAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 25, 12, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxRipOutFltNetAddress.setStatus('mandatory')
if mibBuilder.loadTexts: fcxRipOutFltNetAddress.setDescription('Adresse reseau')
fcxRipOutFltMask = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 25, 12, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxRipOutFltMask.setStatus('mandatory')
if mibBuilder.loadTexts: fcxRipOutFltMask.setDescription('Masque adresse')
fcxServices = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 30))
fcxServInstance = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 30, 1))
fcxServSapSysState = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 30, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxServSapSysState.setStatus('mandatory')
if mibBuilder.loadTexts: fcxServSapSysState.setDescription('sapSysState')
fcxServSapInputFiltering = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 30, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("permitted", 2), ("denied", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxServSapInputFiltering.setStatus('mandatory')
if mibBuilder.loadTexts: fcxServSapInputFiltering.setDescription('Filtrage SAP en entree')
fcxServCircuitTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 30, 10), )
if mibBuilder.loadTexts: fcxServCircuitTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcxServCircuitTable.setDescription('')
fcxServCircuitEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 30, 10, 1), ).setIndexNames((0, "PCE-MIB", "fcxServCircSapCircuitId"))
if mibBuilder.loadTexts: fcxServCircuitEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcxServCircuitEntry.setDescription('An entry of fcxServCircuitTable.')
fcxServCircSapCircuitId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 30, 10, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 199))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcxServCircSapCircuitId.setStatus('mandatory')
if mibBuilder.loadTexts: fcxServCircSapCircuitId.setDescription('sapCircIndex')
fcxServCircSapState = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 30, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxServCircSapState.setStatus('mandatory')
if mibBuilder.loadTexts: fcxServCircSapState.setDescription('sapCircState')
fcxServCircSapPace = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 30, 10, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxServCircSapPace.setStatus('mandatory')
if mibBuilder.loadTexts: fcxServCircSapPace.setDescription('sapCircPace')
fcxServCircSapUpdate = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 30, 10, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxServCircSapUpdate.setStatus('mandatory')
if mibBuilder.loadTexts: fcxServCircSapUpdate.setDescription('sapCircUpdate')
fcxServCircSapAgeMultiplier = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 30, 10, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxServCircSapAgeMultiplier.setStatus('mandatory')
if mibBuilder.loadTexts: fcxServCircSapAgeMultiplier.setDescription('sapCircAgeMultiplier')
fcxServCircSapPacketSize = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 30, 10, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(512, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxServCircSapPacketSize.setStatus('mandatory')
if mibBuilder.loadTexts: fcxServCircSapPacketSize.setDescription('sapCircPacketSize')
fcxServCircSapGetNearestServerReply = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 30, 10, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxServCircSapGetNearestServerReply.setStatus('mandatory')
if mibBuilder.loadTexts: fcxServCircSapGetNearestServerReply.setDescription('sapCircGetNearestServerReply')
fcxServCircSapOutputFiltering = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 30, 10, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("permitted", 2), ("denied", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxServCircSapOutputFiltering.setStatus('mandatory')
if mibBuilder.loadTexts: fcxServCircSapOutputFiltering.setDescription('Filtrage SAP en sortie')
fcxServStaticServiceTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 30, 20), )
if mibBuilder.loadTexts: fcxServStaticServiceTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcxServStaticServiceTable.setDescription('')
fcxServStaticServiceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 30, 20, 1), ).setIndexNames((0, "PCE-MIB", "fcxServStaticServiceId"))
if mibBuilder.loadTexts: fcxServStaticServiceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcxServStaticServiceEntry.setDescription('An entry of fcxServStaticServiceTable.')
fcxServStaticServiceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 30, 20, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcxServStaticServiceId.setStatus('mandatory')
if mibBuilder.loadTexts: fcxServStaticServiceId.setDescription('Service Id')
fcxServStaticStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 30, 20, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxServStaticStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fcxServStaticStatus.setDescription('Status')
fcxServStaticCircuitId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 30, 20, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 199))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxServStaticCircuitId.setStatus('mandatory')
if mibBuilder.loadTexts: fcxServStaticCircuitId.setDescription('ipxStaticServCircIndex')
fcxServStaticName = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 30, 20, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 47))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxServStaticName.setStatus('mandatory')
if mibBuilder.loadTexts: fcxServStaticName.setDescription('ipxStaticServName')
fcxServStaticType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 30, 20, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxServStaticType.setStatus('mandatory')
if mibBuilder.loadTexts: fcxServStaticType.setDescription('ipxStaticServType')
fcxServStaticNetNum = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 30, 20, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxServStaticNetNum.setStatus('mandatory')
if mibBuilder.loadTexts: fcxServStaticNetNum.setDescription('ipxStaticServNetNum')
fcxServStaticNode = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 30, 20, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxServStaticNode.setStatus('mandatory')
if mibBuilder.loadTexts: fcxServStaticNode.setDescription('ipxStaticServNode')
fcxServStaticSocket = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 30, 20, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxServStaticSocket.setStatus('mandatory')
if mibBuilder.loadTexts: fcxServStaticSocket.setDescription('ipxStaticServSocket')
fcxServStaticHopCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 30, 20, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxServStaticHopCount.setStatus('mandatory')
if mibBuilder.loadTexts: fcxServStaticHopCount.setDescription('ipxStaticServHopCount')
fcxServSapInputFilteringTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 30, 30), )
if mibBuilder.loadTexts: fcxServSapInputFilteringTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcxServSapInputFilteringTable.setDescription('')
fcxServSapInputFilteringEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 30, 30, 1), ).setIndexNames((0, "PCE-MIB", "fcxServSapInFltFilterId"))
if mibBuilder.loadTexts: fcxServSapInputFilteringEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcxServSapInputFilteringEntry.setDescription('An entry of fcxServSapInputFilteringTable.')
fcxServSapInFltFilterId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 30, 30, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcxServSapInFltFilterId.setStatus('mandatory')
if mibBuilder.loadTexts: fcxServSapInFltFilterId.setDescription('Filtre id')
fcxServSapInFltStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 30, 30, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxServSapInFltStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fcxServSapInFltStatus.setDescription('Status')
fcxServSapInFltFiltering = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 30, 30, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxServSapInFltFiltering.setStatus('mandatory')
if mibBuilder.loadTexts: fcxServSapInFltFiltering.setDescription('Activation du filtre')
fcxServSapInFltCheckedField = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 30, 30, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("name", 1), ("type", 2), ("nameAndType", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxServSapInFltCheckedField.setStatus('mandatory')
if mibBuilder.loadTexts: fcxServSapInFltCheckedField.setDescription('Champ evalue')
fcxServSapInFltServiceNameType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 30, 30, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("fullName", 1), ("beginningPattern", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxServSapInFltServiceNameType.setStatus('mandatory')
if mibBuilder.loadTexts: fcxServSapInFltServiceNameType.setDescription('Type de nom de service')
fcxServSapInFltServiceName = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 30, 30, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 47))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxServSapInFltServiceName.setStatus('mandatory')
if mibBuilder.loadTexts: fcxServSapInFltServiceName.setDescription('Nom de service')
fcxServSapInFltServiceType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 30, 30, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxServSapInFltServiceType.setStatus('mandatory')
if mibBuilder.loadTexts: fcxServSapInFltServiceType.setDescription('Type de service')
fcxServSapOutputFilteringTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 30, 31), )
if mibBuilder.loadTexts: fcxServSapOutputFilteringTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcxServSapOutputFilteringTable.setDescription('')
fcxServSapOutputFilteringEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 30, 31, 1), ).setIndexNames((0, "PCE-MIB", "fcxServSapOutFltCircuitId"), (0, "PCE-MIB", "fcxServSapOutFltFilterId"))
if mibBuilder.loadTexts: fcxServSapOutputFilteringEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcxServSapOutputFilteringEntry.setDescription('An entry of fcxServSapOutputFilteringTable.')
fcxServSapOutFltCircuitId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 30, 31, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 199))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcxServSapOutFltCircuitId.setStatus('mandatory')
if mibBuilder.loadTexts: fcxServSapOutFltCircuitId.setDescription('Circuit id')
fcxServSapOutFltFilterId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 30, 31, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcxServSapOutFltFilterId.setStatus('mandatory')
if mibBuilder.loadTexts: fcxServSapOutFltFilterId.setDescription('Filtre id')
fcxServSapOutFltStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 30, 31, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxServSapOutFltStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fcxServSapOutFltStatus.setDescription('Status')
fcxServSapOutFltFiltering = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 30, 31, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxServSapOutFltFiltering.setStatus('mandatory')
if mibBuilder.loadTexts: fcxServSapOutFltFiltering.setDescription('Activation du filtre')
fcxServSapOutFltCheckedField = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 30, 31, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("name", 1), ("type", 2), ("nameAndType", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxServSapOutFltCheckedField.setStatus('mandatory')
if mibBuilder.loadTexts: fcxServSapOutFltCheckedField.setDescription('Champ evalue')
fcxServSapOutFltServiceNameType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 30, 31, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("fullName", 1), ("beginningPattern", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxServSapOutFltServiceNameType.setStatus('mandatory')
if mibBuilder.loadTexts: fcxServSapOutFltServiceNameType.setDescription('Type de nom de service')
fcxServSapOutFltServiceName = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 30, 31, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 47))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxServSapOutFltServiceName.setStatus('mandatory')
if mibBuilder.loadTexts: fcxServSapOutFltServiceName.setDescription('Nom de service')
fcxServSapOutFltServiceType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 37, 30, 31, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcxServSapOutFltServiceType.setStatus('mandatory')
if mibBuilder.loadTexts: fcxServSapOutFltServiceType.setDescription('Type de service')
fcClnp = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 1, 38))
fccClnpRouting = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 38, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fccClnpRouting.setStatus('mandatory')
if mibBuilder.loadTexts: fccClnpRouting.setDescription('AdminStatus')
fccLocalNetworkEntityTitle = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 38, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(22, 22)).setFixedLength(22)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fccLocalNetworkEntityTitle.setStatus('mandatory')
if mibBuilder.loadTexts: fccLocalNetworkEntityTitle.setDescription('LocalNet')
fccErrorFramesSending = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 1, 38, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fccErrorFramesSending.setStatus('mandatory')
if mibBuilder.loadTexts: fccErrorFramesSending.setDescription('ErrorFrames')
fccVirtualPortTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 38, 10), )
if mibBuilder.loadTexts: fccVirtualPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: fccVirtualPortTable.setDescription('')
fccVirtualPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 38, 10, 1), ).setIndexNames((0, "PCE-MIB", "fccVpVirtualPortId"))
if mibBuilder.loadTexts: fccVirtualPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fccVirtualPortEntry.setDescription('An entry of fccVirtualPortTable.')
fccVpVirtualPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 38, 10, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 11))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fccVpVirtualPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fccVpVirtualPortId.setDescription('VP id')
fccVpStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 38, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fccVpStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fccVpStatus.setDescription('Status')
fccVpMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 38, 10, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(512, 1600))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fccVpMtu.setStatus('mandatory')
if mibBuilder.loadTexts: fccVpMtu.setDescription('MTU')
fccLocalVirtualPortTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 38, 11), )
if mibBuilder.loadTexts: fccLocalVirtualPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: fccLocalVirtualPortTable.setDescription('')
fccLocalVirtualPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 38, 11, 1), ).setIndexNames((0, "PCE-MIB", "fccLvpVirtualPortId"))
if mibBuilder.loadTexts: fccLocalVirtualPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fccLocalVirtualPortEntry.setDescription('An entry of fccLocalVirtualPortTable.')
fccLvpVirtualPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 38, 11, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 11))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fccLvpVirtualPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fccLvpVirtualPortId.setDescription('VP id')
fccLvpStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 38, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fccLvpStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fccLvpStatus.setDescription('Status')
fccLvpEsIsRedirection = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 38, 11, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fccLvpEsIsRedirection.setStatus('mandatory')
if mibBuilder.loadTexts: fccLvpEsIsRedirection.setDescription('EsIsRedirects')
fccLvpEsIsConfigTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 38, 11, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fccLvpEsIsConfigTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fccLvpEsIsConfigTimer.setDescription('EsIsConfigTimer')
fccLvpEsIsHoldingTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 38, 11, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fccLvpEsIsHoldingTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fccLvpEsIsHoldingTimer.setDescription('EsIsHoldingTimer')
fccNeighborTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 38, 20), )
if mibBuilder.loadTexts: fccNeighborTable.setStatus('mandatory')
if mibBuilder.loadTexts: fccNeighborTable.setDescription('')
fccNeighborEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 38, 20, 1), ).setIndexNames((0, "PCE-MIB", "fccNeighNeighborId"))
if mibBuilder.loadTexts: fccNeighborEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fccNeighborEntry.setDescription('An entry of fccNeighborTable.')
fccNeighNeighborId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 38, 20, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fccNeighNeighborId.setStatus('mandatory')
if mibBuilder.loadTexts: fccNeighNeighborId.setDescription('Neighbor id')
fccNeighStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 38, 20, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fccNeighStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fccNeighStatus.setDescription('Status')
fccNeighType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 38, 20, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("es", 1), ("is", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fccNeighType.setStatus('mandatory')
if mibBuilder.loadTexts: fccNeighType.setDescription('Type')
fccNeighVirtualPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 38, 20, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 11))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fccNeighVirtualPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fccNeighVirtualPortId.setDescription('VP id')
fccNeighClnpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 38, 20, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(22, 22)).setFixedLength(22)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fccNeighClnpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: fccNeighClnpAddress.setDescription('Adresse IP-ISO')
fccLocalNeighborTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 38, 21), )
if mibBuilder.loadTexts: fccLocalNeighborTable.setStatus('mandatory')
if mibBuilder.loadTexts: fccLocalNeighborTable.setDescription('')
fccLocalNeighborEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 38, 21, 1), ).setIndexNames((0, "PCE-MIB", "fccLneighNeighborId"))
if mibBuilder.loadTexts: fccLocalNeighborEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fccLocalNeighborEntry.setDescription('An entry of fccLocalNeighborTable.')
fccLneighNeighborId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 38, 21, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fccLneighNeighborId.setStatus('mandatory')
if mibBuilder.loadTexts: fccLneighNeighborId.setDescription('Neighbor id')
fccLneighStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 38, 21, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fccLneighStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fccLneighStatus.setDescription('Status')
fccLneighMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 38, 21, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fccLneighMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: fccLneighMacAddress.setDescription('Adresse MAC')
fccRemoteNeighborTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 38, 22), )
if mibBuilder.loadTexts: fccRemoteNeighborTable.setStatus('mandatory')
if mibBuilder.loadTexts: fccRemoteNeighborTable.setDescription('')
fccRemoteNeighborEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 38, 22, 1), ).setIndexNames((0, "PCE-MIB", "fccRneighNeighborId"))
if mibBuilder.loadTexts: fccRemoteNeighborEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fccRemoteNeighborEntry.setDescription('An entry of fccRemoteNeighborTable.')
fccRneighNeighborId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 38, 22, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fccRneighNeighborId.setStatus('mandatory')
if mibBuilder.loadTexts: fccRneighNeighborId.setDescription('Neighbor id')
fccRneighStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 38, 22, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fccRneighStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fccRneighStatus.setDescription('Status')
fccRneighRemoteAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 38, 22, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fccRneighRemoteAddress.setStatus('mandatory')
if mibBuilder.loadTexts: fccRneighRemoteAddress.setDescription('Adresse WAN')
fccClnpRouteTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 1, 38, 30), )
if mibBuilder.loadTexts: fccClnpRouteTable.setStatus('mandatory')
if mibBuilder.loadTexts: fccClnpRouteTable.setDescription('')
fccClnpRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 1, 38, 30, 1), ).setIndexNames((0, "PCE-MIB", "fccRoutRouteId"))
if mibBuilder.loadTexts: fccClnpRouteEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fccClnpRouteEntry.setDescription('An entry of fccClnpRouteTable.')
fccRoutRouteId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 38, 30, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fccRoutRouteId.setStatus('mandatory')
if mibBuilder.loadTexts: fccRoutRouteId.setDescription('Route id')
fccRoutStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 38, 30, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fccRoutStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fccRoutStatus.setDescription('Status')
fccRoutDestClnpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 38, 30, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(22, 22)).setFixedLength(22)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fccRoutDestClnpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: fccRoutDestClnpAddress.setDescription('Adresse IP-ISO destination')
fccRoutNextHopNeighborId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 1, 38, 30, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 199))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fccRoutNextHopNeighborId.setStatus('mandatory')
if mibBuilder.loadTexts: fccRoutNextHopNeighborId.setDescription('Next Hop neighbor id')
fmEvents = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 10, 5))
fmeTroubleReport = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 10, 5, 1))
fmeTrblEventType = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 5, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("startAfterUnintentionalCrash", 1), ("startAfterDeliberateCrash", 2), ("startAfterHardwareResetOrStartUp", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmeTrblEventType.setStatus('mandatory')
if mibBuilder.loadTexts: fmeTrblEventType.setDescription('The value of this object is the cause of the system starting.')
fmeTroubleReportInfoTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 10, 5, 1, 2), )
if mibBuilder.loadTexts: fmeTroubleReportInfoTable.setStatus('mandatory')
if mibBuilder.loadTexts: fmeTroubleReportInfoTable.setDescription("This table contains the additional information about the trouble report. It's the fatal error zone : the snapshot of the memory and registers when there is a trouble. It contains the registers state, the system stack ...")
fmeTroubleReportInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 10, 5, 1, 2, 1), ).setIndexNames((0, "PCE-MIB", "fmeTrblInfoIndex"))
if mibBuilder.loadTexts: fmeTroubleReportInfoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fmeTroubleReportInfoEntry.setDescription('An entry of fmeTroubleReportInfoTable.')
fmeTrblInfoIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 5, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 194))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmeTrblInfoIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fmeTrblInfoIndex.setDescription('The value of this object identifies one and only one element of the trouble report.')
fmeTrblInfoData = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 5, 1, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmeTrblInfoData.setStatus('mandatory')
if mibBuilder.loadTexts: fmeTrblInfoData.setDescription('The value of this object is the data of this element of the trouble report.')
fmeFamilyTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 10, 5, 2), )
if mibBuilder.loadTexts: fmeFamilyTable.setStatus('mandatory')
if mibBuilder.loadTexts: fmeFamilyTable.setDescription('This table contains general information about the families of the outstanding events. For one family, the maximum number of stored events is 6, but all the families can store simultaneously at most 3 events. So, the maximum number can fluctuate following the busy memory. When one event is added to the list of one family, the oldest event is kept in memory, and the event is added at the end of the list, with the possibility of a rotation of the stored events if there is no free memory.')
fmeFamilyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 10, 5, 2, 1), ).setIndexNames((0, "PCE-MIB", "fmeFamFamilyId"))
if mibBuilder.loadTexts: fmeFamilyEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fmeFamilyEntry.setDescription('An entry of fmeFamilyTable.')
fmeFamFamilyId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 5, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29))).clone(namedValues=NamedValues(("troubleReport-00", 1), ("management-01", 2), ("synchronousSignalling-02", 3), ("x25SynchronousProcedure-03", 4), ("synchronousLink-04", 5), ("linePhysicalLevel-05", 6), ("asynchronousProtocolLevel-06", 7), ("asynchronousCommandSyntax-07", 8), ("asynchronousSemanticLevel-08", 9), ("sdlcProcedure-09", 10), ("vipProcedure-0A", 11), ("tvipFradBscProcedure-0B", 12), ("dlcBscProcedure-0C", 13), ("mlp-0D", 14), ("pstnProcedure-0E", 15), ("securizedVcEsv-0F", 16), ("securizedVcN4-10", 17), ("securizedVcIr-11", 18), ("isdnDChannelProcedure-12", 19), ("x29Rerouting-13", 20), ("ethernetBridgeAndIpRouterFunctions-14", 21), ("dlcMtrFrad-15", 22), ("compressionProcedure-16", 23), ("dlmFunction-17", 24), ("configurationFunction-18", 25), ("lmiFunction-19", 26), ("ppp-1A", 27), ("frameRelaySna-1B", 28), ("tokenRing-1C", 29)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmeFamFamilyId.setStatus('mandatory')
if mibBuilder.loadTexts: fmeFamFamilyId.setDescription('The value of this object identifies one and only one family.')
fmeFamStoredEventsCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 5, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 6))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmeFamStoredEventsCount.setStatus('mandatory')
if mibBuilder.loadTexts: fmeFamStoredEventsCount.setDescription('The value of this object how many events are stored for this family.')
fmeFamStoredEventsCommand = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 5, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ready", 1), ("delete", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fmeFamStoredEventsCommand.setStatus('mandatory')
if mibBuilder.loadTexts: fmeFamStoredEventsCommand.setDescription("The value of this object permits, when it is set to 'delete', to destroy the stored events of this family. The equipment answers always with the value 'ready' to a GetRequest on this object.")
fmeEventTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 10, 5, 3), )
if mibBuilder.loadTexts: fmeEventTable.setStatus('mandatory')
if mibBuilder.loadTexts: fmeEventTable.setDescription('This table contains the stored outstanding events.')
fmeEventEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 10, 5, 3, 1), ).setIndexNames((0, "PCE-MIB", "fmeEvtFamilyId"), (0, "PCE-MIB", "fmeEvtEventIndex"))
if mibBuilder.loadTexts: fmeEventEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fmeEventEntry.setDescription('An entry of fmeEventTable.')
fmeEvtFamilyId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 5, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29))).clone(namedValues=NamedValues(("troubleReport-00", 1), ("management-01", 2), ("synchronousSignalling-02", 3), ("x25SynchronousProcedure-03", 4), ("synchronousLink-04", 5), ("linePhysicalLevel-05", 6), ("asynchronousProtocolLevel-06", 7), ("asynchronousCommandSyntax-07", 8), ("asynchronousSemanticLevel-08", 9), ("sdlcProcedure-09", 10), ("vipProcedure-0A", 11), ("tvipFradBscProcedure-0B", 12), ("dlcBscProcedure-0C", 13), ("mlp-0D", 14), ("pstnProcedure-0E", 15), ("securizedVcEsv-0F", 16), ("securizedVcN4-10", 17), ("securizedVcIr-11", 18), ("isdnDChannelProcedure-12", 19), ("x29Rerouting-13", 20), ("ethernetBridgeAndIpRouterFunctions-14", 21), ("dlcMtrFrad-15", 22), ("compressionProcedure-16", 23), ("dlmFunction-17", 24), ("configurationFunction-18", 25), ("lmiFunction-19", 26), ("ppp-1A", 27), ("frameRelaySna-1B", 28), ("tokenRing-1C", 29)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmeEvtFamilyId.setStatus('mandatory')
if mibBuilder.loadTexts: fmeEvtFamilyId.setDescription('The value of this object identifies one and only one family. This is the family this outstanding event belongs to.')
fmeEvtEventIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 5, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 6))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmeEvtEventIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fmeEvtEventIndex.setDescription('The value of this object identifies one and only one outstanding event of this familty.')
fmeEvtEventType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 5, 3, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmeEvtEventType.setStatus('mandatory')
if mibBuilder.loadTexts: fmeEvtEventType.setDescription('The value of this object is the event type. See the management function manual for more information on the description of the events.')
fmeEvtTime = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 5, 3, 1, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmeEvtTime.setStatus('mandatory')
if mibBuilder.loadTexts: fmeEvtTime.setDescription('The value of this object is the value of sysUpTime when this event was stored.')
fmeEvtLineId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 5, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmeEvtLineId.setStatus('mandatory')
if mibBuilder.loadTexts: fmeEvtLineId.setDescription("The value of this object is the identifier of the line where this event takes place. The value '255' means 'general' (i.e., not a particular line).")
fmeEvtData = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 5, 3, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmeEvtData.setStatus('mandatory')
if mibBuilder.loadTexts: fmeEvtData.setDescription('The value of this object contains additional data for this event.')
fmeTrapInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 10, 5, 4))
fmeTrapLineId = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 5, 4, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmeTrapLineId.setStatus('mandatory')
if mibBuilder.loadTexts: fmeTrapLineId.setDescription("The value of this object is the identifier of the line where the event takes place. The value '255' means 'general' (i.e., not a particular line). This object is only used in a Trap PDU and is not accessible by GET requests.")
fmeTrapFamilyId = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 5, 4, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28))).clone(namedValues=NamedValues(("troubleReport-00", 1), ("management-01", 2), ("synchronousSignalling-02", 3), ("x25SynchronousProcedure-03", 4), ("synchronousLink-04", 5), ("linePhysicalLevel-05", 6), ("asynchronousProtocolLevel-06", 7), ("asynchronousCommandSyntax-07", 8), ("asynchronousSemanticLevel-08", 9), ("sdlcProcedure-09", 10), ("vipProcedure-0A", 11), ("tvipFradBscProcedure-0B", 12), ("dlcBscProcedure-0C", 13), ("mlp-0D", 14), ("pstnProcedure-0E", 15), ("securizedVcEsv-0F", 16), ("securizedVcN4-10", 17), ("securizedVcIr-11", 18), ("isdnDChannelProcedure-12", 19), ("x29Rerouting-13", 20), ("ethernetBridgeAndIpRouterFunctions-14", 21), ("dlcMtrFrad-15", 22), ("compressionProcedure-16", 23), ("dlmFunction-17", 24), ("configurationFunction-18", 25), ("lmiFunction-19", 26), ("ppp-1A", 27), ("frameRelaySna-1B", 28)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmeTrapFamilyId.setStatus('mandatory')
if mibBuilder.loadTexts: fmeTrapFamilyId.setDescription('The value of this object identifies one and only one family. This is the family the outstanding event belongs to. This object is only used in a Trap PDU and is not accessible by GET requests.')
fmeTrapEventType = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 5, 4, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmeTrapEventType.setStatus('mandatory')
if mibBuilder.loadTexts: fmeTrapEventType.setDescription('The value of this object is the event type. See the management function manual for more information on the description of the events. This object is only used in a Trap PDU and is not accessible by GET requests.')
fmeTrapEventData = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 5, 4, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmeTrapEventData.setStatus('mandatory')
if mibBuilder.loadTexts: fmeTrapEventData.setDescription('The value of this object contains additional data for the event. This object is only used in a Trap PDU and is not accessible by GET requests.')
fmStat = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 10, 10))
fmStatControl = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 1))
fmsCtrlStatus = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("inProgress", 1), ("notInProgress", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsCtrlStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fmsCtrlStatus.setDescription("The value of this object indicates the processing state of the statistics. The value 'notInProgress' indicates that there is only a SNMP access at the management function. The value 'InProgress' indicates that there is an access to the management function which is not a SNMP access.")
fmsCtrlSumming = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("infinite", 1), ("notInfinite", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fmsCtrlSumming.setStatus('mandatory')
if mibBuilder.loadTexts: fmsCtrlSumming.setDescription("The value of this object is the summing mode of the statistics. The value 'infinite' indicates that the statistics are calculated since the last counters reset. With the value 'notInfinite', the statistics are calculated on the configurable period, which there is an automatic counters reset beyond. The default value is 'notInfinite'.")
fmsCtrlCountersCommand = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ready", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fmsCtrlCountersCommand.setStatus('mandatory')
if mibBuilder.loadTexts: fmsCtrlCountersCommand.setDescription("The value of this object permits, when it is set to 'reset', to re-initialize all the counters except those in fmStatEthOutputTrafficTable, fmStatEthInputTrafficTable and fmStatEthManagementTable. The equipment answers always with the value 'ready' to a GetRequest on this object.")
fmsCtrlResetTime = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 1, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsCtrlResetTime.setStatus('mandatory')
if mibBuilder.loadTexts: fmsCtrlResetTime.setDescription("The value of this object is the value of sysUpTime when the counters were re-initialized by a 'reset' command (see fmsCtrlCountersCommand).")
fmStatGlobal = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 10))
fmsGlobInitBuffCount = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 10, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsGlobInitBuffCount.setStatus('mandatory')
if mibBuilder.loadTexts: fmsGlobInitBuffCount.setDescription('The value of this object is the total number of the buffers created when initializing.')
fmsGlobFreeBuffCount = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 10, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsGlobFreeBuffCount.setStatus('mandatory')
if mibBuilder.loadTexts: fmsGlobFreeBuffCount.setDescription('The value of this object is the total number of the free buffers.')
fmsGlobCpuA = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 10, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsGlobCpuA.setStatus('mandatory')
if mibBuilder.loadTexts: fmsGlobCpuA.setDescription('The value of this object is the maximum instant load of the CPU A on all the modules.')
fmsGlobCpuB = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 10, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsGlobCpuB.setStatus('mandatory')
if mibBuilder.loadTexts: fmsGlobCpuB.setDescription('The value of this object is the maximum instant load of the CPU B on all the modules.')
fmsGlobVcInUseCount = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 10, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsGlobVcInUseCount.setStatus('mandatory')
if mibBuilder.loadTexts: fmsGlobVcInUseCount.setDescription('The value of this object is the number of the virtual circuits established.')
fmsGlobGeneratorsInUseCount = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 10, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsGlobGeneratorsInUseCount.setStatus('mandatory')
if mibBuilder.loadTexts: fmsGlobGeneratorsInUseCount.setDescription('The value of this object is the number of the busy traffic generators.')
fmsGlobCompressOctetGain = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 10, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsGlobCompressOctetGain.setStatus('mandatory')
if mibBuilder.loadTexts: fmsGlobCompressOctetGain.setDescription('The value of this object is the total gain, in volume (in bytes), generated by the compression/scrambling function.')
fmsGlobCompressBillGain = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 10, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsGlobCompressBillGain.setStatus('mandatory')
if mibBuilder.loadTexts: fmsGlobCompressBillGain.setDescription('The value of this object is the total gain, in billing (in segments), generated by the compression/scrambling function.')
fmsGlobLanCpu = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 10, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsGlobLanCpu.setStatus('mandatory')
if mibBuilder.loadTexts: fmsGlobLanCpu.setDescription('The value of this object is the transputer CPU load.')
fmsGlobCongCpuLostBlocks = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 10, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsGlobCongCpuLostBlocks.setStatus('mandatory')
if mibBuilder.loadTexts: fmsGlobCongCpuLostBlocks.setDescription('Nb de blocs de 0 a N octets rejetes sur congestion CPU (N = 160 en v2.1)')
fmsGlobCongRamLostBlocks = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 10, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsGlobCongRamLostBlocks.setStatus('mandatory')
if mibBuilder.loadTexts: fmsGlobCongRamLostBlocks.setDescription('Nb de blocs de 0 a N octets rejetes sur congestion memoire (N = 160 en v2.1)')
fmStatInputTraffic = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 11))
fmsInputDataPktsCounter = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 11, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsInputDataPktsCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsInputDataPktsCounter.setDescription('The value of this object is the total number of the data packets received by the internal switch from the beginning of the collection period.')
fmsInputDataBytesCounter = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 11, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsInputDataBytesCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsInputDataBytesCounter.setDescription('The value of this object is the total number of the data bytes received by the internal switch from the beginning of the collection period.')
fmsInputIntrPktsCounter = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 11, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsInputIntrPktsCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsInputIntrPktsCounter.setDescription('The value of this object is the total number of the interrupt packets received by the internal switch from the beginning of the collection period.')
fmsInputReinitPktsCounter = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 11, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsInputReinitPktsCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsInputReinitPktsCounter.setDescription('The value of this object is the total number of the reset packets received by the internal switch from the beginning of the collection period.')
fmsInputCallPktsCounter = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 11, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsInputCallPktsCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsInputCallPktsCounter.setDescription('The value of this object is the total number of the call packets received by the internal switch from the beginning of the collection period.')
fmsInputCallConfPktsCounter = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 11, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsInputCallConfPktsCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsInputCallConfPktsCounter.setDescription('The value of this object is the total number of the call confirmation received and successfully processed by the internal switch from the beginning of the collection period. This object is therefore the number of the virtual circuits established from the beginning of the collection period.')
fmStatLineTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 12), )
if mibBuilder.loadTexts: fmStatLineTable.setStatus('mandatory')
if mibBuilder.loadTexts: fmStatLineTable.setDescription('This table contains the information about the statistics by line.')
fmStatLineEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 12, 1), ).setIndexNames((0, "PCE-MIB", "fmsLineId"))
if mibBuilder.loadTexts: fmStatLineEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fmStatLineEntry.setDescription('An entry of fmStatLineTable.')
fmsLineId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 12, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 55))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsLineId.setStatus('mandatory')
if mibBuilder.loadTexts: fmsLineId.setDescription('The value of this object is the one line identifier.')
fmsLineState = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 1, 4, 5))).clone(namedValues=NamedValues(("down", 2), ("disconnectedByDiag", 3), ("layer1Up", 1), ("layer2Up", 4), ("layer3Up", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsLineState.setStatus('mandatory')
if mibBuilder.loadTexts: fmsLineState.setDescription('The value of this object is the state of this line.')
fmsLineLcInUseCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 12, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsLineLcInUseCount.setStatus('mandatory')
if mibBuilder.loadTexts: fmsLineLcInUseCount.setDescription('The value of this object is the total number of the busy logical channels.')
fmsLineReinitsCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 12, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsLineReinitsCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsLineReinitsCounter.setDescription('The value of this object is the total number of the resets of this line from the beginning of the collection period.')
fmsLineIncidentsCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 12, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsLineIncidentsCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsLineIncidentsCounter.setDescription('The value of this object is the total number of the incidents of this line from the beginning of the collection period.')
fmsLineInputOctetsCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 12, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsLineInputOctetsCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsLineInputOctetsCounter.setDescription('The value of this object is the total number of the bytes received over this line from the beginning of the collection period.')
fmsLineOutputOctetsCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 12, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsLineOutputOctetsCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsLineOutputOctetsCounter.setDescription('The value of this object is the total number of bytes sent over this line from the beginning of the collection period.')
fmsLineType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 12, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 6, 7, 8, 14, 15, 16, 17, 19, 20, 21, 23, 27, 28, 30, 39, 40, 50, 51))).clone(namedValues=NamedValues(("x25Synchronous", 1), ("asynchronous", 2), ("asynchronousSdlc", 4), ("synchronousVipCharacter", 6), ("synchronousBscTransparentCharacter", 7), ("characterSynchronousBsc3270Or2780-3780", 8), ("isdnDChannel", 14), ("isdnBChannelWithSignalling", 15), ("isdnBChannelWithoutSignalling", 16), ("isdnDChannelWithPll", 17), ("frameRelayTypeTransit", 19), ("hdlc", 20), ("frameRelaySubscriber", 21), ("lanConnection", 23), ("lanIpRouter", 27), ("lanBridgeOrIpRouter", 28), ("asynchronousX28", 30), ("synchronousPpp", 39), ("asynchronousPpp", 40), ("moduleLink", 50), ("unitLink", 51)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsLineType.setStatus('mandatory')
if mibBuilder.loadTexts: fmsLineType.setDescription('The value of this object indicates the type of this line.')
fmsLineTestState = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 12, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsLineTestState.setStatus('mandatory')
if mibBuilder.loadTexts: fmsLineTestState.setDescription('The value of this object indicates the test state of this line.')
fmStatSignalTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 13), )
if mibBuilder.loadTexts: fmStatSignalTable.setStatus('mandatory')
if mibBuilder.loadTexts: fmStatSignalTable.setDescription('This table contains the information about the lines signals.')
fmStatSignalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 13, 1), ).setIndexNames((0, "PCE-MIB", "fmsSigPhysPortId"))
if mibBuilder.loadTexts: fmStatSignalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fmStatSignalEntry.setDescription('An entry of fmStatSignalTable.')
fmsSigPhysPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 13, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsSigPhysPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fmsSigPhysPortId.setDescription('The value of this object is the one physical line identifier.')
fmsSigState = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 13, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("down", 1), ("up", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsSigState.setStatus('mandatory')
if mibBuilder.loadTexts: fmsSigState.setDescription('The value of this object indictates the state of this line.')
fmsSigDceOrDte = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 13, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dce", 1), ("dte", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsSigDceOrDte.setStatus('mandatory')
if mibBuilder.loadTexts: fmsSigDceOrDte.setDescription('The value of this object indicates whether the equipment is DTE or DCE for this line.')
fmsSig105 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 13, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsSig105.setStatus('mandatory')
if mibBuilder.loadTexts: fmsSig105.setDescription('The value of this object indicates the state of the signal 105 on this line.')
fmsSig106 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 13, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsSig106.setStatus('mandatory')
if mibBuilder.loadTexts: fmsSig106.setDescription('The value of this object indicates the state of the signal 106 on this line.')
fmsSig107 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 13, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsSig107.setStatus('mandatory')
if mibBuilder.loadTexts: fmsSig107.setDescription('The value of this object indicates the state of the signal 107 on this line.')
fmsSig108 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 13, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsSig108.setStatus('mandatory')
if mibBuilder.loadTexts: fmsSig108.setDescription('The value of this object indicates the state of the signal 108 on this line.')
fmsSig109 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 13, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsSig109.setStatus('mandatory')
if mibBuilder.loadTexts: fmsSig109.setDescription('The value of this object indicates the state of the signal 109 on this line.')
fmsSig111 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 13, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsSig111.setStatus('mandatory')
if mibBuilder.loadTexts: fmsSig111.setDescription('The value of this object indicates the state of the signal 111 on this line.')
fmsSig125 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 13, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsSig125.setStatus('mandatory')
if mibBuilder.loadTexts: fmsSig125.setDescription('The value of this object indicates the state of the signal 125 on this line.')
fmsSig140 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 13, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsSig140.setStatus('mandatory')
if mibBuilder.loadTexts: fmsSig140.setDescription('The value of this object indicates the state of the signal 140 on this line.')
fmsSig141 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 13, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsSig141.setStatus('mandatory')
if mibBuilder.loadTexts: fmsSig141.setDescription('The value of this object indicates the state of the signal 141 on this line.')
fmsSig142 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 13, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsSig142.setStatus('mandatory')
if mibBuilder.loadTexts: fmsSig142.setDescription('The value of this object indicates the state of the signal 142 on this line.')
fmsSigSyn = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 13, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("undefined", 1), ("off", 2), ("on", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsSigSyn.setStatus('mandatory')
if mibBuilder.loadTexts: fmsSigSyn.setDescription('The value of this object indicates the state of the signal SYN on this line.')
fmStatLinesSummary = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 15))
fmsLinesSummState = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 15, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsLinesSummState.setStatus('mandatory')
if mibBuilder.loadTexts: fmsLinesSummState.setDescription('This object indicates the state of each line of the equipment with the following format,. each line using three octets (i.e., 24 bits) : bit 0 : physical level (0 = down, 1 = up), bit 1: level 3 (0 = down, 1 = up), bits 2 to 8 : protocol (1 = X25 synchronous, 2 = asynchronous, 4 = asynchronous SDLC, 6 = asynchronous VIP character, 7 = BSC Transparent character, 8 = asynchronous on BSC 3270 or 2780/3780, 14 = ISDN D-Channel with or without PLL, 15 = ISDN B-Channel with signalling, 16 = ISDN B-Channel without signalling, 19 = Frame Relay transit or FR-TE, 20 = HDLC-T, 21 = Frame Relay subscriber, FRA, 23 = Ethernet, 30 = asynchronous X28+), bits 9 to 20 : number of active logical channels (0 to 4095), bits 20 to 23 : unused.')
fmStatStateTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 20), )
if mibBuilder.loadTexts: fmStatStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: fmStatStateTable.setDescription('This table contains the information about the type and the state of the lines.')
fmStatStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 20, 1), ).setIndexNames((0, "PCE-MIB", "fmsStateLine"))
if mibBuilder.loadTexts: fmStatStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fmStatStateEntry.setDescription('An entry of fmStatStateTable.')
fmsStateLine = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 20, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 55))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsStateLine.setStatus('mandatory')
if mibBuilder.loadTexts: fmsStateLine.setDescription('The value of this object is the one line identifier.')
fmsStateLineType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 20, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 6, 7, 8, 14, 15, 16, 17, 19, 20, 21, 23, 27, 28, 30, 39, 40, 50, 51))).clone(namedValues=NamedValues(("x25Synchronous", 1), ("asynchronous", 2), ("asynchronousSdlc", 4), ("synchronousVipCharacter", 6), ("synchronousBscTransparentCharacter", 7), ("characterSynchronousBsc3270Or2780-3780", 8), ("isdnDChannel", 14), ("isdnBChannelWithSignalling", 15), ("isdnBChannelWithoutSignalling", 16), ("isdnDChannelWithPll", 17), ("frameRelayTypeTransit", 19), ("hdlc", 20), ("frameRelaySubscriber", 21), ("lanConnection", 23), ("lanIpRouter", 27), ("lanBridgeOrIpRouter", 28), ("asynchronousX28", 30), ("synchronousPpp", 39), ("asynchronousPpp", 40), ("moduleLink", 50), ("unitLink", 51)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsStateLineType.setStatus('mandatory')
if mibBuilder.loadTexts: fmsStateLineType.setDescription('The value of this object indicates the type of this line.')
fmsStateOsiState = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 20, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("down", 1), ("layer1Up", 2), ("layer2Up", 3), ("layer3Up", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsStateOsiState.setStatus('mandatory')
if mibBuilder.loadTexts: fmsStateOsiState.setDescription('The value of this object indicates the state and the ISO layer of this line. If this line is up, the value indicated is the ISO layer.')
fmsStateTestState = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 20, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notUnderTest", 1), ("lineDisconnectedByTelemaintenance", 2), ("underTest", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsStateTestState.setStatus('mandatory')
if mibBuilder.loadTexts: fmsStateTestState.setDescription('The value of this object indicates the test state of this line.')
fmsStateMlpTrunkMainLine = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 20, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsStateMlpTrunkMainLine.setStatus('mandatory')
if mibBuilder.loadTexts: fmsStateMlpTrunkMainLine.setDescription('The value of this object indicates if this line is the main line of a MLP trunk.')
fmsStateMlpTrunkNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 20, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsStateMlpTrunkNumber.setStatus('mandatory')
if mibBuilder.loadTexts: fmsStateMlpTrunkNumber.setDescription('The value of this object is the identifier of the MLP trunk.')
fmsStateMlpTrunkState = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 20, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("down", 1), ("up", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsStateMlpTrunkState.setStatus('mandatory')
if mibBuilder.loadTexts: fmsStateMlpTrunkState.setDescription('The value of this object is the MLP trunk state.')
fmStatMlpTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 30), )
if mibBuilder.loadTexts: fmStatMlpTable.setStatus('mandatory')
if mibBuilder.loadTexts: fmStatMlpTable.setDescription('This table contains the information about the MLP trunks.')
fmStatMlpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 30, 1), ).setIndexNames((0, "PCE-MIB", "fmsMlpTrunkNumber"), (0, "PCE-MIB", "fmsMlpLineId"))
if mibBuilder.loadTexts: fmStatMlpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fmStatMlpEntry.setDescription('An entry of fmStatMlpTable.')
fmsMlpTrunkNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 30, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsMlpTrunkNumber.setStatus('mandatory')
if mibBuilder.loadTexts: fmsMlpTrunkNumber.setDescription('The value of this object is the identifier of the MLP trunk.')
fmsMlpLineId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 30, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsMlpLineId.setStatus('mandatory')
if mibBuilder.loadTexts: fmsMlpLineId.setDescription('The value of this object is the one line identifier.')
fmsMlpLineType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 30, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("mainDown", 1), ("mainUp", 2), ("secondaryDown", 3), ("secondaryUp", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsMlpLineType.setStatus('mandatory')
if mibBuilder.loadTexts: fmsMlpLineType.setDescription('The value of this object indicates if this line is the main line of this MLP trunk.')
fmStatEthernet = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 40))
fmStatEthernetTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 40, 1), )
if mibBuilder.loadTexts: fmStatEthernetTable.setStatus('mandatory')
if mibBuilder.loadTexts: fmStatEthernetTable.setDescription('This table contains the general information about the Ethernet physical ports.')
fmStatEthernetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 40, 1, 1), ).setIndexNames((0, "PCE-MIB", "fmsEthLineId"))
if mibBuilder.loadTexts: fmStatEthernetEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fmStatEthernetEntry.setDescription('An entry of fmStatEthernetTable.')
fmsEthLineId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 40, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsEthLineId.setStatus('mandatory')
if mibBuilder.loadTexts: fmsEthLineId.setDescription('The value of this object is the identifier of one physical port.')
fmsEthPhysAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 40, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsEthPhysAddr.setStatus('mandatory')
if mibBuilder.loadTexts: fmsEthPhysAddr.setDescription('The value of this object is the MAC address of the equipment.')
fmsEthOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 40, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("down", 1), ("up", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsEthOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fmsEthOperStatus.setDescription('The value of this object is the state of the LAN function.')
fmsEthInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 40, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ethernet10base5", 1), ("ethernet10BaseT", 2), ("ethernetAuto", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsEthInterface.setStatus('mandatory')
if mibBuilder.loadTexts: fmsEthInterface.setDescription('The value of this object is the ethernet connector type.')
fmsEthAutoPortSelection = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 40, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsEthAutoPortSelection.setStatus('mandatory')
if mibBuilder.loadTexts: fmsEthAutoPortSelection.setDescription('The value of this object indicates whether the selection of the LAN port is automatic or not.')
fmsEthPolarityCorrection = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 40, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsEthPolarityCorrection.setStatus('mandatory')
if mibBuilder.loadTexts: fmsEthPolarityCorrection.setDescription('The value of this object indicates the state of the polarity spontaneous correction.')
fmsEthPolarityInversion = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 40, 1, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsEthPolarityInversion.setStatus('mandatory')
if mibBuilder.loadTexts: fmsEthPolarityInversion.setDescription('The value of this object indicates if there is inversion of the polarity.')
fmsEthLinkIntegrity = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 40, 1, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("down", 2), ("up", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsEthLinkIntegrity.setStatus('mandatory')
if mibBuilder.loadTexts: fmsEthLinkIntegrity.setDescription('The value of this object indicates the state of the link integrity function.')
fmsEthTestLoopback = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 40, 1, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsEthTestLoopback.setStatus('mandatory')
if mibBuilder.loadTexts: fmsEthTestLoopback.setDescription('The value of this object indicates if the loopback test is used.')
fmsEthJabber = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 40, 1, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsEthJabber.setStatus('mandatory')
if mibBuilder.loadTexts: fmsEthJabber.setDescription('The value of this object is the state of the bus taking time control function (Jabber).')
fmsEthTestMode = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 40, 1, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("continousSending", 2), ("standby", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsEthTestMode.setStatus('mandatory')
if mibBuilder.loadTexts: fmsEthTestMode.setDescription("The value of this object is the mode of the test. The value 'continousSending' indicates that frames are sent continously during the test. The value 'standby' indicates that no frames are sent during the test.")
fmsEthTdrState = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 40, 1, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("ok", 1), ("transceiverProblem", 2), ("openCircuit", 3), ("shortCircuit", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsEthTdrState.setStatus('mandatory')
if mibBuilder.loadTexts: fmsEthTdrState.setDescription('The value of this object (Time Domain Reflectometry) indicates the problem type of the connectors system.')
fmsEthTdrLoc = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 40, 1, 1, 28), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2047))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsEthTdrLoc.setStatus('mandatory')
if mibBuilder.loadTexts: fmsEthTdrLoc.setDescription("The value of this object (Time Domain Reflectometry) indicates the tracing of connectors system problem. The value '2047' is not significant.")
fmsEthUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 40, 1, 1, 29), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsEthUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: fmsEthUpTime.setDescription('The value of this object is the time elapsing since the last start-up of the LAN interface. When the equipment starts, the value of this object is 0.')
fmStatEthInputTrafficTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 40, 2), )
if mibBuilder.loadTexts: fmStatEthInputTrafficTable.setStatus('mandatory')
if mibBuilder.loadTexts: fmStatEthInputTrafficTable.setDescription("This table contains the information about the statistics, in reception, of a LAN line. The values of all this counters are not reseted by the command 'reset' of fmsCtrlCountersCommand.")
fmStatEthInputTrafficEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 40, 2, 1), ).setIndexNames((0, "PCE-MIB", "fmsEthInLineId"))
if mibBuilder.loadTexts: fmStatEthInputTrafficEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fmStatEthInputTrafficEntry.setDescription('An entry of fmStatEthInputTrafficTable.')
fmsEthInLineId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 40, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsEthInLineId.setStatus('mandatory')
if mibBuilder.loadTexts: fmsEthInLineId.setDescription('The value of this object is the one line identifier.')
fmsEthInOctetsCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 40, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsEthInOctetsCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsEthInOctetsCounter.setDescription('The value of this object is the number of the bytes received over this line.')
fmsEthInPktsCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 40, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsEthInPktsCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsEthInPktsCounter.setDescription('The value of this object is the number of the frames received over this line.')
fmsEthInNoErrCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 40, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsEthInNoErrCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsEthInNoErrCounter.setDescription('The value of this object is the number of the frames received with no error over this line.')
fmsEthInUcastPktsCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 40, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsEthInUcastPktsCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsEthInUcastPktsCounter.setDescription('The value of this object is the number of the frames received over this line and correctly sent to the upper layer.')
fmsEthInAlignmentErrorsCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 40, 2, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsEthInAlignmentErrorsCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsEthInAlignmentErrorsCounter.setDescription('The value of this object is the number of the frames received with an error of alignment (number of bits not multiple of 8) over this line.')
fmsEthInFCSErrorsCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 40, 2, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsEthInFCSErrorsCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsEthInFCSErrorsCounter.setDescription('The value of this object is the number of the frames received with an error of CRC over this line.')
fmsEthInPktsTooLongsCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 40, 2, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsEthInPktsTooLongsCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsEthInPktsTooLongsCounter.setDescription('The value of this object is the number of the frames received with a length too long over this line.')
fmsEthInPktsTooShortsCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 40, 2, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsEthInPktsTooShortsCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsEthInPktsTooShortsCounter.setDescription('The value of this object is the number of the frames received with a length too short over this line.')
fmsEthInErrOutOfResourcesCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 40, 2, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsEthInErrOutOfResourcesCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsEthInErrOutOfResourcesCounter.setDescription('The value of this object is the number of the frames received with an error of resources too short over this line.')
fmsEthInErrDmaOverrunCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 40, 2, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsEthInErrDmaOverrunCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsEthInErrDmaOverrunCounter.setDescription("The value of this object is the number of the frames received with the error 'DMA overrun' (no reply when expected by the memory bus to a DMA cycle) over this line.")
fmsEthInErrCollCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 40, 2, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsEthInErrCollCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsEthInErrCollCounter.setDescription("The value of this object is the number of the frames received with the error 'receive collision' (frames received but invalided because of a collision detection during the reception) over this line.")
fmsEthInErrOverFlowCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 40, 2, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsEthInErrOverFlowCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsEthInErrOverFlowCounter.setDescription('The value of this object is the number of the frames received over this line and not sent to the upper layer because of the resources overflow.')
fmStatEthOutputTrafficTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 40, 3), )
if mibBuilder.loadTexts: fmStatEthOutputTrafficTable.setStatus('mandatory')
if mibBuilder.loadTexts: fmStatEthOutputTrafficTable.setDescription("This table contains the information about the statistics, in sending, of one LAN line. The values of all this counters are not reseted by the command 'reset' of fmsCtrlCountersCommand.")
fmStatEthOutputTrafficEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 40, 3, 1), ).setIndexNames((0, "PCE-MIB", "fmsEthOutLineId"))
if mibBuilder.loadTexts: fmStatEthOutputTrafficEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fmStatEthOutputTrafficEntry.setDescription('An entry of fmStatEthOutputTrafficTable.')
fmsEthOutLineId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 40, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsEthOutLineId.setStatus('mandatory')
if mibBuilder.loadTexts: fmsEthOutLineId.setDescription('The value of this object is the one line identifier.')
fmsEthOutOctetsCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 40, 3, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsEthOutOctetsCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsEthOutOctetsCounter.setDescription('The value of this object is the number of the bytes sent over this line.')
fmsEthOutPktsCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 40, 3, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsEthOutPktsCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsEthOutPktsCounter.setDescription('The value of this object is the number of the frames sent over this line.')
fmsEthOutNoErrCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 40, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsEthOutNoErrCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsEthOutNoErrCounter.setDescription('The value of this object is the number of the frames sent without error over this line.')
fmsEthOutSingleCollisionFramesCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 40, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsEthOutSingleCollisionFramesCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsEthOutSingleCollisionFramesCounter.setDescription('The value of this object is the number of the frames sent after one collision over this line.')
fmsEthOutMultipleCollisionFramesCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 40, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsEthOutMultipleCollisionFramesCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsEthOutMultipleCollisionFramesCounter.setDescription('The value of this object is the number of the frames sent after two collisions or more over this line.')
fmsEthOutDeferredTransmissionsCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 40, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsEthOutDeferredTransmissionsCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsEthOutDeferredTransmissionsCounter.setDescription('The value of this object is the number of the frames sent late over this line because the ethernet bus is busy.')
fmsEthOutSQETestErrorsCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 40, 3, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsEthOutSQETestErrorsCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsEthOutSQETestErrorsCounter.setDescription("The value of this object is the number of the frames sent with error of no heartbeat over this line. The heartbeat function of the ethernet transmitter is used to indicate to the LAN driver the status of its collision detector. If following a transmission, the transmitter does not send the SQE signal of the heartbeat function to the equipment, then the frame is considered to be sent with 'no heartbeat' error.")
fmsEthOutLateCollisionsCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 40, 3, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsEthOutLateCollisionsCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsEthOutLateCollisionsCounter.setDescription("The value of this object is the number of the frames not sent because of the error 'late collision' (collision detection after the end of the slot time) over this line.")
fmsEthOutExcessiveCollisionsCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 40, 3, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsEthOutExcessiveCollisionsCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsEthOutExcessiveCollisionsCounter.setDescription('The value of this object is the number of the frames not sent because of the collisions detections at all the attempts over this line.')
fmsEthOutCarrierSenseErrorsCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 40, 3, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsEthOutCarrierSenseErrorsCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsEthOutCarrierSenseErrorsCounter.setDescription("The value of this object is the number of the frames not sent because of the error 'no carrier sense' over this line.")
fmsEthOutErrExcdDelayCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 40, 3, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsEthOutErrExcdDelayCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsEthOutErrExcdDelayCounter.setDescription('The value of this object is the number of the frames not sent over this line because the bus is busy during a long time.')
fmsEthOutErrCtsLossCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 40, 3, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsEthOutErrCtsLossCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsEthOutErrCtsLossCounter.setDescription('The value of this object is the number of the frames not sent over this line because of the loss of the CTS (Clear To Send) signal.')
fmsEthOutErrDmaUnderrunCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 40, 3, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsEthOutErrDmaUnderrunCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsEthOutErrDmaUnderrunCounter.setDescription("The value of this object is the number of the frames not sent over this line because of the error 'DMA underrun' (no reply when expected by the memory bus to a DMA cycle).")
fmStatEthManagementTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 40, 4), )
if mibBuilder.loadTexts: fmStatEthManagementTable.setStatus('mandatory')
if mibBuilder.loadTexts: fmStatEthManagementTable.setDescription("This table contains the information about the monitoring, the reset and the filtering for each port. The values of all this counters are not reseted by the command 'reset' of fmsCtrlCountersCommand.")
fmStatEthManagementEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 40, 4, 1), ).setIndexNames((0, "PCE-MIB", "fmsEthManLineId"))
if mibBuilder.loadTexts: fmStatEthManagementEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fmStatEthManagementEntry.setDescription('An entry of fmStatEthManagementTable.')
fmsEthManLineId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 40, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsEthManLineId.setStatus('mandatory')
if mibBuilder.loadTexts: fmsEthManLineId.setDescription('The value of this object is the one line identifier.')
fmsEthManSupervisionOkCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 40, 4, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsEthManSupervisionOkCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsEthManSupervisionOkCounter.setDescription('The value of this object is the number of the OK supervision frames over this line.')
fmsEthManSupervisionNokCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 40, 4, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsEthManSupervisionNokCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsEthManSupervisionNokCounter.setDescription('The value of this object is the number of the not OK supervision frames over this line.')
fmsEthManInputResetCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 40, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsEthManInputResetCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsEthManInputResetCounter.setDescription('The value of this object is the number of the reception resets over this line.')
fmsEthManFilterPermitCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 40, 4, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsEthManFilterPermitCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsEthManFilterPermitCounter.setDescription('The value of this object is the number of the frames accepted by the bridge filtering over this line.')
fmsEthManFilterDenyCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 40, 4, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsEthManFilterDenyCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsEthManFilterDenyCounter.setDescription('The value of this object is the number of the frames refused by the bridge filtering over this line.')
fmStatWanConnectionsTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 45), )
if mibBuilder.loadTexts: fmStatWanConnectionsTable.setStatus('mandatory')
if mibBuilder.loadTexts: fmStatWanConnectionsTable.setDescription('This table contains the information about the WAN connections.')
fmStatWanConnectionsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 45, 1), ).setIndexNames((0, "PCE-MIB", "fmsWanConnId"))
if mibBuilder.loadTexts: fmStatWanConnectionsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fmStatWanConnectionsEntry.setDescription('An entry of fmStatWanConnectionsTable.')
fmsWanConnId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 45, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsWanConnId.setStatus('mandatory')
if mibBuilder.loadTexts: fmsWanConnId.setDescription('The value of this object is the one SLL (Switched Logical Link) identifier.')
fmsWanConnRemoteAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 45, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsWanConnRemoteAddr.setStatus('mandatory')
if mibBuilder.loadTexts: fmsWanConnRemoteAddr.setDescription('The value of this object is the X121 address of the remote equipment.')
fmsWanConnEncapsulation = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 45, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(9, 20))).clone(namedValues=NamedValues(("rilBridge", 9), ("ip", 20)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsWanConnEncapsulation.setStatus('mandatory')
if mibBuilder.loadTexts: fmsWanConnEncapsulation.setDescription('The value of this object indicates the encapsulation type over this SLL (Switched Logical Link).')
fmsWanConnStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 45, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("down", 1), ("up", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsWanConnStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fmsWanConnStatus.setDescription('The value of this object is the state of this SLL (Switched Logical Link).')
fmsWanConnGrouping = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 45, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 2))).clone(namedValues=NamedValues(("off", 1), ("multiFrames", 3), ("grouping", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsWanConnGrouping.setStatus('mandatory')
if mibBuilder.loadTexts: fmsWanConnGrouping.setDescription('The value of this object indicates if the grouping function is used over this SLL (Switched Logical Link).')
fmsWanConnLocalSbNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 45, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 99))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsWanConnLocalSbNumber.setStatus('mandatory')
if mibBuilder.loadTexts: fmsWanConnLocalSbNumber.setDescription('The value of this object is the subscriber local number AB (in the DNIC ZO AB plan) of the LAN coupling function.')
fmsWanConnInPktsCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 45, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsWanConnInPktsCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsWanConnInPktsCounter.setDescription('The value of this object is the number of frames received over this SLL (Switched Logical Link).')
fmsWanConnInErrPktsCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 45, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsWanConnInErrPktsCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsWanConnInErrPktsCounter.setDescription('The value of this object is the number of frames lost because they are erroneous over this SLL (Switched Logical Link).')
fmsWanConnInOctetsCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 45, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsWanConnInOctetsCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsWanConnInOctetsCounter.setDescription('The value of this object is the number of bytes received over this SLL (Switched Logical Link).')
fmsWanConnOutPktsCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 45, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsWanConnOutPktsCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsWanConnOutPktsCounter.setDescription('The value of this object is the number of frames sent over this SLL (Switched Logical Link).')
fmsWanConnOutOctetsCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 45, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsWanConnOutOctetsCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsWanConnOutOctetsCounter.setDescription('The value of this object is the number of bytes sent over this SLL (Switched Logical Link).')
fmStatRemoteVirtualPorts = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 46))
fmStatRvpConnectionsTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 46, 1), )
if mibBuilder.loadTexts: fmStatRvpConnectionsTable.setStatus('mandatory')
if mibBuilder.loadTexts: fmStatRvpConnectionsTable.setDescription('This table contains the information about the remote virtual ports.')
fmStatRvpConnectionsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 46, 1, 1), ).setIndexNames((0, "PCE-MIB", "fmsRvpConnRemoteAddr"), (0, "PCE-MIB", "fmsRvpConnEncapsulation"), (0, "PCE-MIB", "fmsRvpConnId"))
if mibBuilder.loadTexts: fmStatRvpConnectionsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fmStatRvpConnectionsEntry.setDescription('An entry of fmStatRvpConnectionsTable.')
fmsRvpConnRemoteAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 46, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsRvpConnRemoteAddr.setStatus('mandatory')
if mibBuilder.loadTexts: fmsRvpConnRemoteAddr.setDescription('The value of this object is the X121 address of the remote equipment.')
fmsRvpConnEncapsulation = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 46, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 10, 11, 20, 30, 31, 40))).clone(namedValues=NamedValues(("multiplexing", 1), ("bridge", 10), ("bridgeSpecific", 11), ("ip", 20), ("ipx", 30), ("ipxSpecific", 31), ("clnp", 40)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsRvpConnEncapsulation.setStatus('mandatory')
if mibBuilder.loadTexts: fmsRvpConnEncapsulation.setDescription('The value of this object indicates the encapsulation type.')
fmsRvpConnId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 46, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsRvpConnId.setStatus('mandatory')
if mibBuilder.loadTexts: fmsRvpConnId.setDescription('The value of this object is the one connection identifier.')
fmsRvpConnStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 46, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("down", 1), ("up", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsRvpConnStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fmsRvpConnStatus.setDescription('The value of this object is the state of this connection.')
fmsRvpConnGrouping = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 46, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsRvpConnGrouping.setStatus('mandatory')
if mibBuilder.loadTexts: fmsRvpConnGrouping.setDescription('The value of this object indicates if the grouping function is used.')
fmsRvpConnLocalSbNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 46, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 99))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsRvpConnLocalSbNumber.setStatus('mandatory')
if mibBuilder.loadTexts: fmsRvpConnLocalSbNumber.setDescription('The value of this object is the subscriber local number AB (in the DNIC ZO AB plan) of this connection.')
fmsRvpConnInPktsCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 46, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsRvpConnInPktsCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsRvpConnInPktsCounter.setDescription('The value of this object is the number of frames received over this connection.')
fmsRvpConnInErrPktsCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 46, 1, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsRvpConnInErrPktsCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsRvpConnInErrPktsCounter.setDescription('The value of this object is the number of frames lost because they are erroneous over this connection.')
fmsRvpConnInOctetsCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 46, 1, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsRvpConnInOctetsCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsRvpConnInOctetsCounter.setDescription('The value of this object is the number of bytes received over this connection.')
fmsRvpConnOutPktsCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 46, 1, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsRvpConnOutPktsCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsRvpConnOutPktsCounter.setDescription('The value of this object is the number of frames sent over this connection.')
fmsRvpConnOutOctetsCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 46, 1, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsRvpConnOutOctetsCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsRvpConnOutOctetsCounter.setDescription('The value of this object is the number of bytes sent over this connection.')
fmStatBridge = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 50))
fmsBridgeState = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 50, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("transparentBridge", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsBridgeState.setStatus('mandatory')
if mibBuilder.loadTexts: fmsBridgeState.setDescription('The value of this object is the state of the bridging function.')
fmStatBrdgTraffic = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 50, 18))
fmsBrdgTrafInPktsCounter = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 50, 18, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsBrdgTrafInPktsCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsBrdgTrafInPktsCounter.setDescription('The value of this object is the number of the frames received by the bridge.')
fmsBrdgTrafOutPktsCounter = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 50, 18, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsBrdgTrafOutPktsCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsBrdgTrafOutPktsCounter.setDescription('The value of this object is the number of the frames sent by the bridge.')
fmsBrdgTrafOutBroadcastPktsCounter = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 50, 18, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsBrdgTrafOutBroadcastPktsCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsBrdgTrafOutBroadcastPktsCounter.setDescription('The value of this object is the number of the data frames diffusions.')
fmsBrdgTrafInServCounter = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 50, 18, 50), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsBrdgTrafInServCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsBrdgTrafInServCounter.setDescription('The value of this object is the number of the RIL service frames received by the bridge.')
fmsBrdgTrafOutServCounter = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 50, 18, 51), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsBrdgTrafOutServCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsBrdgTrafOutServCounter.setDescription('The value of this object is the number of the RIL service frames sent by the bridge.')
fmsBrdgTrafOutBroadcastServCounter = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 50, 18, 52), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsBrdgTrafOutBroadcastServCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsBrdgTrafOutBroadcastServCounter.setDescription('The value of this object is the number of the service frames diffusions.')
fmStatIpRouter = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 51))
fmsIpRouterState = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 51, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsIpRouterState.setStatus('mandatory')
if mibBuilder.loadTexts: fmsIpRouterState.setDescription('The value of this object is the state of the IP routing function.')
fmStatIpTraffic = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 51, 18))
fmsIpTrafInReceivesCounter = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 51, 18, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsIpTrafInReceivesCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsIpTrafInReceivesCounter.setDescription('The value of this object is the number of the IP datagrams received.')
fmsIpTrafOutRequestsCounter = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 51, 18, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsIpTrafOutRequestsCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsIpTrafOutRequestsCounter.setDescription('The value of this object is the number of the IP datagrams sent.')
fmsIpTrafInOctetsCounter = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 51, 18, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsIpTrafInOctetsCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsIpTrafInOctetsCounter.setDescription('The value of this object is the number of the bytes received with the IP protocol.')
fmsIpTrafOutOctetsCounter = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 51, 18, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsIpTrafOutOctetsCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsIpTrafOutOctetsCounter.setDescription('The value of this object is the number of the bytes sent with the IP protocol.')
fmsIpTrafInUnknownProtosCounter = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 51, 18, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsIpTrafInUnknownProtosCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsIpTrafInUnknownProtosCounter.setDescription('The value of this object is the number of the IP datagrams received and lost because of an unknown protocol.')
fmsIpTrafNoRoutesCounter = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 51, 18, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsIpTrafNoRoutesCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsIpTrafNoRoutesCounter.setDescription('The value of this object is the number of the IP datagrams received and lost because of an impossible routing.')
fmsIpTrafInHdrErrorsCounter = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 51, 18, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsIpTrafInHdrErrorsCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsIpTrafInHdrErrorsCounter.setDescription('The value of this object is the number of the IP datagrams received and lost because they are erroneous.')
fmsIpTrafOutForwDatagramsCounter = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 51, 18, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsIpTrafOutForwDatagramsCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsIpTrafOutForwDatagramsCounter.setDescription('The value of this object is the number of the IP datagrams received and correctly routed.')
fmsIpTrafOutForwDefRouteCounter = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 51, 18, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsIpTrafOutForwDefRouteCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsIpTrafOutForwDefRouteCounter.setDescription('The value of this object is the number of the IP datagrams received and routed on the default route.')
fmsIpTrafIcmpOutMsgsCounter = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 51, 18, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsIpTrafIcmpOutMsgsCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsIpTrafIcmpOutMsgsCounter.setDescription('The value of this object is the number of the ICMP datagrams sent.')
fmsIpTrafIcmpInMsgsCounter = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 51, 18, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsIpTrafIcmpInMsgsCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsIpTrafIcmpInMsgsCounter.setDescription('The value of this object is the number of the ICMP datagrams received.')
fmStatIpLanTraffic = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 51, 19))
fmsIpLanIpAddr = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 51, 19, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsIpLanIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: fmsIpLanIpAddr.setDescription('fmStatIpLanTraffic 0 The value of this object is the IP address of the LAN interface.')
fmsIpLanNetMask = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 51, 19, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsIpLanNetMask.setStatus('mandatory')
if mibBuilder.loadTexts: fmsIpLanNetMask.setDescription('The value of this object is the sub-network mask of the LAN interface.')
fmsIpLanOutRequestsCounter = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 51, 19, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsIpLanOutRequestsCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsIpLanOutRequestsCounter.setDescription('The value of this object is the number of the IP datagrams sent on the LAN interface.')
fmsIpLanInReceivesCounter = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 51, 19, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsIpLanInReceivesCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsIpLanInReceivesCounter.setDescription('The value of this object is the number of the IP datagrams received on the LAN interface.')
fmsIpLanOutOctetsIpCounter = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 51, 19, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsIpLanOutOctetsIpCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsIpLanOutOctetsIpCounter.setDescription('The value of this object is the number of the bytes sent with the IP protocol on the LAN interface.')
fmsIpLanInOctetsIpCounter = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 51, 19, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsIpLanInOctetsIpCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsIpLanInOctetsIpCounter.setDescription('The value of this object is the number of the bytes received with the IP protocol on the LAN interface.')
fmsIpLanNoRoutesCounter = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 51, 19, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsIpLanNoRoutesCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsIpLanNoRoutesCounter.setDescription('The value of this object is the number of the IP datagrams received and lost because of impossible routing, on the LAN interface.')
fmsIpLanInHdrErrorsCounter = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 51, 19, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsIpLanInHdrErrorsCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsIpLanInHdrErrorsCounter.setDescription('The value of this object is the number of the IP datagrams received and lost because of they are erroneous, on the LAN interface.')
fmsIpLanArpFailedCounter = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 51, 19, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsIpLanArpFailedCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsIpLanArpFailedCounter.setDescription('The value of this object is the number of the not solved ARP request, on the LAN interface.')
fmStatIpClusterStateTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 51, 25), )
if mibBuilder.loadTexts: fmStatIpClusterStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: fmStatIpClusterStateTable.setDescription('')
fmStatIpClusterStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 51, 25, 1), ).setIndexNames((0, "PCE-MIB", "fmsIpCluVpId"), (0, "PCE-MIB", "fmsIpCluClusterNumber"))
if mibBuilder.loadTexts: fmStatIpClusterStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fmStatIpClusterStateEntry.setDescription('An entry of fmStatIpClusterStateTable.')
fmsIpCluVpId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 51, 25, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 11))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsIpCluVpId.setStatus('mandatory')
if mibBuilder.loadTexts: fmsIpCluVpId.setDescription('VP id')
fmsIpCluClusterNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 51, 25, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsIpCluClusterNumber.setStatus('mandatory')
if mibBuilder.loadTexts: fmsIpCluClusterNumber.setDescription('Cluster number')
fmsIpCluVirtualIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 51, 25, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsIpCluVirtualIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: fmsIpCluVirtualIpAddress.setDescription('Virtual IP Address')
fmsIpCluOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 51, 25, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("backup", 2), ("master", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsIpCluOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fmsIpCluOperStatus.setDescription('Operation State')
fmsIpCluAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 51, 25, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fmsIpCluAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fmsIpCluAdminStatus.setDescription('Administration State')
fmsIpCluLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 51, 25, 1, 6), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsIpCluLastChange.setStatus('mandatory')
if mibBuilder.loadTexts: fmsIpCluLastChange.setDescription('Time from the Last Change')
fmStatFrameRelay = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60))
fmsFrSwitch = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 1))
fmsFrSwDataLinkConnEstablished = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 1, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrSwDataLinkConnEstablished.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrSwDataLinkConnEstablished.setDescription('Nb de connexions FR etablis (svc-svc, pvc-svc, proto-svc).')
fmsFrSwBookingInputThrouhput = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 1, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrSwBookingInputThrouhput.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrSwBookingInputThrouhput.setDescription('Debit reserve (somme des CIR abonnes vers reseau).')
fmsFrSwOverBookingThrouhput = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 1, 12), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrSwOverBookingThrouhput.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrSwOverBookingThrouhput.setDescription('Debit reserve par les SVC en surbooking.')
fmsFrLogicalPort = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 2))
fmsFrLpLogPortTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 2, 1), )
if mibBuilder.loadTexts: fmsFrLpLogPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrLpLogPortTable.setDescription('')
fmsFrLpLogPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 2, 1, 1), ).setIndexNames((0, "PCE-MIB", "fmsFrLpLogPortId"))
if mibBuilder.loadTexts: fmsFrLpLogPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrLpLogPortEntry.setDescription('An entry of fmsFrLpLogPortTable.')
fmsFrLpLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrLpLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrLpLogPortId.setDescription('LP id.')
fmsFrLpInterfaceType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("frCe", 1), ("frTe", 2), ("frSe", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrLpInterfaceType.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrLpInterfaceType.setDescription('Type.')
fmsFrLpNumPlan = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 2, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("e164", 2), ("x121", 3), ("none", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrLpNumPlan.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrLpNumPlan.setDescription('The value of this object identifies the network address numbering plan for this logical port. The network address is the object ifPhysAddress. The value none implies that there is no ifPhysAddress. The SNMP agent will return an octet string of zero length for ifPhysAddress. The value other means that an address has been assigned to this interface, but the numbering plan is not enumerated here.')
fmsFrLpAddrDlciLen = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 2, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("twoOctets10Bits", 1), ("threeOctets10Bits", 2), ("threeOctets16Bits", 3), ("fourOctets17Bits", 4), ("fourOctets23Bits", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrLpAddrDlciLen.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrLpAddrDlciLen.setDescription('The value of this object identifies the Q.922 Address field length and DLCI length for this logical port.')
fmsFrLpVcSigProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 2, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("none", 1), ("lmi", 2), ("ansiT1617D", 3), ("ansiT1617B", 4), ("itutQ933A", 5), ("itutQ933", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrLpVcSigProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrLpVcSigProtocol.setDescription('The value of this object identifies the Local In-Channel Signaling Protocol that is used for this frame relay logical port.')
fmsFrLpIncomingTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 2, 2), )
if mibBuilder.loadTexts: fmsFrLpIncomingTable.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrLpIncomingTable.setDescription('')
fmsFrLpIncomingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 2, 2, 1), ).setIndexNames((0, "PCE-MIB", "fmsFrLpInLogPortId"))
if mibBuilder.loadTexts: fmsFrLpIncomingEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrLpIncomingEntry.setDescription('An entry of fmsFrLpIncomingTable.')
fmsFrLpInLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrLpInLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrLpInLogPortId.setDescription('LP id.')
fmsFrLpInOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 2, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrLpInOctets.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrLpInOctets.setDescription('The number of received octets. This counter only counts octets from the beginning of the frame relay header field to the end of user data.')
fmsFrLpInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 2, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrLpInFrames.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrLpInFrames.setDescription('The number of received unerrored, unicast frames.')
fmsFrLpInErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 2, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrLpInErrors.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrLpInErrors.setDescription('The number of received frames that are discarded, because of an error. Possible errors can be the following: the frame relay frames were too long or were too short.')
fmsFrLpInFrHeaderErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 2, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrLpInFrHeaderErrors.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrLpInFrHeaderErrors.setDescription('The number of received frames that are discarded, because of an error. Possible errors can be the following: the frames had an invalid or unrecognized DLCI values, or incorrect header values.')
fmsFrLpInFecnFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 2, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrLpInFecnFrames.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrLpInFecnFrames.setDescription('Number of frames received indicating forward congestion.')
fmsFrLpInBecnFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 2, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrLpInBecnFrames.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrLpInBecnFrames.setDescription('Number of frames received indicating backward congestion.')
fmsFrLpInExcessFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 2, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrLpInExcessFrames.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrLpInExcessFrames.setDescription('Only on FR-CE or FR-TE logical ports : The number of frames received by the equipment (ingress) for this logical port which were treated as excess traffic. Frames which are sent to the equipment with DE set to zero are treated as excess when more than Bc bits are submitted to the equipment during the Committed Information Rate Measurement Interval (Tc). Excess traffic may or may not be discarded at the ingress if more than Bc + Be bits are submitted to the equipment during Tc. Traffic discarded at the ingress is not recorded in this object. Frames which are sent to the equipement with DE set to one are also treated as excess traffic.')
fmsFrLpInDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 2, 2, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrLpInDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrLpInDiscards.setDescription('Only on FR-CE or FR-TE logical ports : The number of frames received by the equipment (ingress) that were discarded due to traffic enforcement for this logical port.')
fmsFrLpOutgoingTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 2, 3), )
if mibBuilder.loadTexts: fmsFrLpOutgoingTable.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrLpOutgoingTable.setDescription('')
fmsFrLpOutgoingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 2, 3, 1), ).setIndexNames((0, "PCE-MIB", "fmsFrLpOutLogPortId"))
if mibBuilder.loadTexts: fmsFrLpOutgoingEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrLpOutgoingEntry.setDescription('An entry of fmsFrLpOutgoingTable.')
fmsFrLpOutLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrLpOutLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrLpOutLogPortId.setDescription('LP id.')
fmsFrLpOutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 2, 3, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrLpOutOctets.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrLpOutOctets.setDescription('The number of transmitted octets. This counter only counts octets from the beginning of the frame relay header field to the end of user data.')
fmsFrLpOutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 2, 3, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrLpOutFrames.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrLpOutFrames.setDescription('The number of frames sent.')
fmsFrLpOutFecnFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 2, 3, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrLpOutFecnFrames.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrLpOutFecnFrames.setDescription('Number of frames sent indicating forward congestion.')
fmsFrLpOutLocalCongFecnFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 2, 3, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrLpOutLocalCongFecnFrames.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrLpOutLocalCongFecnFrames.setDescription('Number of frames sent indicating forward congestion due to traffic enforcement on this logical port.')
fmsFrLpOutBecnFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 2, 3, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrLpOutBecnFrames.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrLpOutBecnFrames.setDescription('Number of frames sent indicating backward congestion.')
fmsFrLpOutLocalCongBecnFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 2, 3, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrLpOutLocalCongBecnFrames.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrLpOutLocalCongBecnFrames.setDescription('Number of frames sent indicating backward congestion due to traffic enforcement on the incoming logical port.')
fmsFrLpOutLocalCongDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 2, 3, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrLpOutLocalCongDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrLpOutLocalCongDiscards.setDescription('The number of frames not sent by the equipment (egress) due to traffic enforcement on this logical port.')
fmsFrLpLmiTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 2, 4), )
if mibBuilder.loadTexts: fmsFrLpLmiTable.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrLpLmiTable.setDescription('')
fmsFrLpLmiEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 2, 4, 1), ).setIndexNames((0, "PCE-MIB", "fmsFrLpLmiLogPortId"))
if mibBuilder.loadTexts: fmsFrLpLmiEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrLpLmiEntry.setDescription('An entry of fmsFrLpLmiTable.')
fmsFrLpLmiLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 2, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 254))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrLpLmiLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrLpLmiLogPortId.setDescription('LP id.')
fmsFrLpLmiProced = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 2, 4, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("u2nNet", 1), ("bidirect", 2), ("u2nUser", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrLpLmiProced.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrLpLmiProced.setDescription('The value of this object identifies the Local In-Channel Signaling Procedure that is used for this logical port. The logical port can be performing user-to-network network-side procedures, bidirectional procedures or user-to-network user-side procedures.')
fmsFrLpLmiUserN391 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 2, 4, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrLpLmiUserN391.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrLpLmiUserN391.setDescription('The value of this object identifies the User-side N391 full status polling cycle value for this logical port. If the logical port is not performing user-side procedures, then this value is not significant. This object applies to Q.933 Annex A and T1.617 Annex D.')
fmsFrLpLmiUserN392 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 2, 4, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrLpLmiUserN392.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrLpLmiUserN392.setDescription('The value of this object identifies the User-side N392 error threshold value for this logical port. If the logical port is not performing user-side procedures, then this value is not significant. This object applies to Q.933 Annex A and T1.617 Annex D.')
fmsFrLpLmiUserN393 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 2, 4, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrLpLmiUserN393.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrLpLmiUserN393.setDescription('The value of this object identifies the User-side N393 monitored events count value for this logical port. If the logical port is not performing user-side procedures, then this value is not significant. This object applies to Q.933 Annex A and T1.617 Annex D.')
fmsFrLpLmiUserT391 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 2, 4, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrLpLmiUserT391.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrLpLmiUserT391.setDescription('The value of this object identifies the User-side T391 link integrity verification polling timer value for this logical port. If the logical port is not performing user-side procedures, then this value is not significant. This object applies to Q.933 Annex A and T1.617 Annex D.')
fmsFrLpLmiNetN392 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 2, 4, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrLpLmiNetN392.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrLpLmiNetN392.setDescription('The value of this object identifies the Network-side N392 error threshold value (nN2 for LMI) for this logical port. If the logical port is not performing network-side procedures, then this value is not significant. This object applies to Q.933 Annex A, T1.617 Annex D and LMI.')
fmsFrLpLmiNetN393 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 2, 4, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrLpLmiNetN393.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrLpLmiNetN393.setDescription('The value of this object identifies the Network-side N393 monitored events count value (nN3 for LMI) for this logical port. If the logical port is not performing network-side procedures, then this value is not significant. This object applies to Q.933 Annex A, T1.617 Annex D and LMI.')
fmsFrLpLmiNetT392 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 2, 4, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrLpLmiNetT392.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrLpLmiNetT392.setDescription('The value of this object identifies the Network-side T392 polling verification timer value (nT2 for LMI) for this logical port. If the logical port is not performing network-side procedures, then this value is not significant. This object applies to Q.933 Annex A, T1.617 Annex D and LMI.')
fmsFrLpLmiUserLinkRelErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 2, 4, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrLpLmiUserLinkRelErrors.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrLpLmiUserLinkRelErrors.setDescription('VCSigUserLinkRelErrors')
fmsFrLpLmiUserProtErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 2, 4, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrLpLmiUserProtErrors.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrLpLmiUserProtErrors.setDescription('VCSigUserProtErrors')
fmsFrLpLmiUserChanInactive = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 2, 4, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrLpLmiUserChanInactive.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrLpLmiUserChanInactive.setDescription('VCSigUserChanInactive')
fmsFrLpLmiNetLinkRelErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 2, 4, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrLpLmiNetLinkRelErrors.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrLpLmiNetLinkRelErrors.setDescription('VCSigNetLinkRelErrors')
fmsFrLpLmiNetProtErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 2, 4, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrLpLmiNetProtErrors.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrLpLmiNetProtErrors.setDescription('VCSigNetProtErrors')
fmsFrLpLmiNetChanInactive = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 2, 4, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrLpLmiNetChanInactive.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrLpLmiNetChanInactive.setDescription('VCSigNetChanInactiveErrors')
fmsFrLpSvcSignallingTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 2, 5), )
if mibBuilder.loadTexts: fmsFrLpSvcSignallingTable.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrLpSvcSignallingTable.setDescription('')
fmsFrLpSvcSignallingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 2, 5, 1), ).setIndexNames((0, "PCE-MIB", "fmsFrLpSvcLogPortId"))
if mibBuilder.loadTexts: fmsFrLpSvcSignallingEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrLpSvcSignallingEntry.setDescription('An entry of fmsFrLpSvcSignallingTable.')
fmsFrLpSvcLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 2, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 254))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrLpSvcLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrLpSvcLogPortId.setDescription('LP id.')
fmsFrLpSvcDlcInitialized = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 2, 5, 1, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrLpSvcDlcInitialized.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrLpSvcDlcInitialized.setDescription('Nb de Data Link Connexion correctement initialises.')
fmsFrLpSvcDlcUbr = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 2, 5, 1, 12), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrLpSvcDlcUbr.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrLpSvcDlcUbr.setDescription('Nb de DLC UBR etablies.')
fmsFrLpSvcDlcVbr = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 2, 5, 1, 13), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrLpSvcDlcVbr.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrLpSvcDlcVbr.setDescription('Nb de DLC VBR etablies.')
fmsFrLpSvcDlcVbrRt = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 2, 5, 1, 14), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrLpSvcDlcVbrRt.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrLpSvcDlcVbrRt.setDescription('Nb de DLC VBR-RT etablies.')
fmsFrLpSvcBookingVbrThroughput = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 2, 5, 1, 20), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrLpSvcBookingVbrThroughput.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrLpSvcBookingVbrThroughput.setDescription('Debit reserve VBR (en octets/s).')
fmsFrLpSvcBookingVbrRtThroughput = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 2, 5, 1, 21), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrLpSvcBookingVbrRtThroughput.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrLpSvcBookingVbrRtThroughput.setDescription('Debit reserve VBR-RT (en octets/s).')
fmsFrLpSvcOverBookingThroughput = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 2, 5, 1, 22), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrLpSvcOverBookingThroughput.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrLpSvcOverBookingThroughput.setDescription('Debit total avec surbooking (en octets/s).')
fmsFrLpSvcBookingRate = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 2, 5, 1, 23), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrLpSvcBookingRate.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrLpSvcBookingRate.setDescription('Taux de reservation.')
fmsFrDataLinkConnection = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 3))
fmsFrDlcTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 3, 1), )
if mibBuilder.loadTexts: fmsFrDlcTable.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrDlcTable.setDescription('')
fmsFrDlcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 3, 1, 1), ).setIndexNames((0, "PCE-MIB", "fmsFrDlcLogPortId"), (0, "PCE-MIB", "fmsFrDlcDlci"))
if mibBuilder.loadTexts: fmsFrDlcEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrDlcEntry.setDescription('An entry of fmsFrDlcTable.')
fmsFrDlcLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrDlcLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrDlcLogPortId.setDescription('LP Id.')
fmsFrDlcDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrDlcDlci.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrDlcDlci.setDescription('DLCI.')
fmsFrDlcState = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("invalid", 1), ("active", 2), ("inactive", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrDlcState.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrDlcState.setDescription('Indicates whether the particular virtual circuit is operational.')
fmsFrDlcRcvdSigStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("deleted", 1), ("active", 2), ("inactive", 3), ("none", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrDlcRcvdSigStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrDlcRcvdSigStatus.setDescription('PVC end point received status')
fmsFrDlcCos = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ubr", 1), ("vbr", 2), ("vbr-rt", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrDlcCos.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrDlcCos.setDescription('COS.')
fmsFrDlcIncomingTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 3, 2), )
if mibBuilder.loadTexts: fmsFrDlcIncomingTable.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrDlcIncomingTable.setDescription('')
fmsFrDlcIncomingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 3, 2, 1), ).setIndexNames((0, "PCE-MIB", "fmsFrDlcInLogPortId"), (0, "PCE-MIB", "fmsFrDlcInDlci"))
if mibBuilder.loadTexts: fmsFrDlcIncomingEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrDlcIncomingEntry.setDescription('An entry of fmsFrDlcIncomingTable.')
fmsFrDlcInLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 3, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrDlcInLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrDlcInLogPortId.setDescription('LP Id.')
fmsFrDlcInDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 3, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrDlcInDlci.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrDlcInDlci.setDescription('The value of this object is equal to the DLCI value for this Data Link Connection.')
fmsFrDlcInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 3, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrDlcInFrames.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrDlcInFrames.setDescription('The number of frames received by the equipment (ingress) for this Data Link Connection. This includes any frames discarded by the equipment due to submitting more than Bc + Be data or due to any network congestion recovery procedure.')
fmsFrDlcInOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 3, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrDlcInOctets.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrDlcInOctets.setDescription('The number of octets received by the equipment (ingress) for this Data Link Connection. This counter only counts octets from the beginning of the frame relay header field to the end of user data.')
fmsFrDlcInDeFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 3, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrDlcInDeFrames.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrDlcInDeFrames.setDescription('The number of frames received by the equipment (ingress) with the DE bit set to (1) for this Data Link Connection.')
fmsFrDlcInFecnFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 3, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrDlcInFecnFrames.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrDlcInFecnFrames.setDescription('Number of frames received by the equipment indicating forward congestion for this Data Link Connection.')
fmsFrDlcInBecnFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 3, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrDlcInBecnFrames.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrDlcInBecnFrames.setDescription('Number of frames received by the equipment indicating backward congestion for this Data Link Connection')
fmsFrDlcInExcessFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 3, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrDlcInExcessFrames.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrDlcInExcessFrames.setDescription('The number of frames received by the equipment (ingress) for this Data Link Connection which were treated as excess traffic. Frames which are sent to the equipment with DE set to zero are treated as excess when more than Bc bits are submitted to the network during the Committed Information Rate Measurement Interval (Tc). Excess traffic may or may not be discarded at the ingress if more than Bc + Be bits are submitted to the equipment during Tc. Traffic discarded at the ingress is not recorded in this object. Frames which are sent to the equipment with DE set to one are also treated as excess traffic.')
fmsFrDlcInDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 3, 2, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrDlcInDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrDlcInDiscards.setDescription('The number of frames received by the equipment (ingress) that were discarded due to traffic enforcement for this Data Link Connection.')
fmsFrDlcInLostFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 3, 2, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrDlcInLostFrames.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrDlcInLostFrames.setDescription('Nb de trames perdues dans le reseau (evalue par le mecanisme de segmentation / reassemblage).')
fmsFrDlcInLostSegments = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 3, 2, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrDlcInLostSegments.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrDlcInLostSegments.setDescription('Nb de segments perdus dans le reseau (evalue par le mecanisme de segmentation / reassemblage).')
fmsFrDlcOutgoingTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 3, 3), )
if mibBuilder.loadTexts: fmsFrDlcOutgoingTable.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrDlcOutgoingTable.setDescription('')
fmsFrDlcOutgoingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 3, 3, 1), ).setIndexNames((0, "PCE-MIB", "fmsFrDlcOutLogPortId"), (0, "PCE-MIB", "fmsFrDlcOutDlci"))
if mibBuilder.loadTexts: fmsFrDlcOutgoingEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrDlcOutgoingEntry.setDescription('An entry of fmsFrDlcOutgoingTable.')
fmsFrDlcOutLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 3, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrDlcOutLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrDlcOutLogPortId.setDescription('LP Id.')
fmsFrDlcOutDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 3, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrDlcOutDlci.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrDlcOutDlci.setDescription('The value of this object is equal to the DLCI value for this Data Link Connection.')
fmsFrDlcOutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 3, 3, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrDlcOutFrames.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrDlcOutFrames.setDescription('The number of frames sent by the equipment (egress) regardless of whether they are Bc or Be frames for this Data Link Connection.')
fmsFrDlcOutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 3, 3, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrDlcOutOctets.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrDlcOutOctets.setDescription('The number of octets sent by the equipment (egress) for this Data Link Connection. This counter only counts octets from the beginning of the frame relay header field to the end of user data.')
fmsFrDlcOutFecnFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 3, 3, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrDlcOutFecnFrames.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrDlcOutFecnFrames.setDescription('Number of frames sent by the equipment indicating forward congestion for this Data Link Connection.')
fmsFrDlcOutBecnFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 3, 3, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrDlcOutBecnFrames.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrDlcOutBecnFrames.setDescription('Number of frames sent by the equipment indicating backward congestion for this Data Link Connection.')
fmsFrDlcOutExcessFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 3, 3, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrDlcOutExcessFrames.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrDlcOutExcessFrames.setDescription('The number of frames sent by the equipment (egress) for this Data Link Connection which were treated as excess traffic. (The DE bit may be set to one.).')
fmsFrDlcOutDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 3, 3, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrDlcOutDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrDlcOutDiscards.setDescription('Number of frames not sent by the equipment due to congestion for this Data Link Connection.')
fmStatFrLineTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 20), )
if mibBuilder.loadTexts: fmStatFrLineTable.setStatus('mandatory')
if mibBuilder.loadTexts: fmStatFrLineTable.setDescription('This table contains the information about the Frame Relay lines.')
fmStatFrLineEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 20, 1), ).setIndexNames((0, "PCE-MIB", "fmsFrLineId"))
if mibBuilder.loadTexts: fmStatFrLineEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fmStatFrLineEntry.setDescription('An entry of fmStatFrLineTable.')
fmsFrLineId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 20, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrLineId.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrLineId.setDescription('The value of this object is the one physical line identifier.')
fmsFrLineStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 20, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("down", 1), ("up", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrLineStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrLineStatus.setDescription('The value of this object indicates the state of this physical line.')
fmsFrLineLmiStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 20, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("down", 2), ("up", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrLineLmiStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrLineLmiStatus.setDescription('The value of this object indicates the LMI state.')
fmsFrLineCircuitCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 20, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrLineCircuitCount.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrLineCircuitCount.setDescription('The value of this object indicates the total number of the DLCI on this physical line.')
fmsFrLineActiveCircuitCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 20, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrLineActiveCircuitCount.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrLineActiveCircuitCount.setDescription('The value of this objects is the number of active DLCI on this physical line.')
fmStatFrCircuitTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 21), )
if mibBuilder.loadTexts: fmStatFrCircuitTable.setStatus('mandatory')
if mibBuilder.loadTexts: fmStatFrCircuitTable.setDescription('This table contains the information about each circuit.')
fmStatFrCircuitEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 21, 1), ).setIndexNames((0, "PCE-MIB", "fmsFrCircuitLineId"), (0, "PCE-MIB", "fmsFrCircuitDlci"))
if mibBuilder.loadTexts: fmStatFrCircuitEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fmStatFrCircuitEntry.setDescription('An entry of fmStatFrCircuitTable.')
fmsFrCircuitLineId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 21, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrCircuitLineId.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrCircuitLineId.setDescription('The value of this object is the one physical line identifier.')
fmsFrCircuitDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 21, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrCircuitDlci.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrCircuitDlci.setDescription('The value of this object is the identifier of one circuit. It is the DLCI.')
fmsFrCircuitStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 21, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrCircuitStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrCircuitStatus.setDescription('The value of this object is the state of this circuit.')
fmsFrCircuitAge = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 21, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("old", 1), ("new", 2), ("indeterminate", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrCircuitAge.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrCircuitAge.setDescription('The value of this object indicates the age of this circuit.')
fmsFrCircuitOutOctetsCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 21, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrCircuitOutOctetsCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrCircuitOutOctetsCounter.setDescription('The value of this object is the number of octets sent on this circuit.')
fmsFrCircuitInOctetsCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 21, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrCircuitInOctetsCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrCircuitInOctetsCounter.setDescription('The value of this object is the number of octets received on this circuit.')
fmsFrCommIdentification = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 30))
fmsFrCommStorageTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 30, 1), )
if mibBuilder.loadTexts: fmsFrCommStorageTable.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrCommStorageTable.setDescription('This table contains')
fmsFrCommStorageEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 30, 1, 1), ).setIndexNames((0, "PCE-MIB", "fmsFrcStoragePhysIfId"), (0, "PCE-MIB", "fmsFrcStorageChannelId"), (0, "PCE-MIB", "fmsFrcStorageDlci"), (0, "PCE-MIB", "fmsFrcStorageSubDlci"))
if mibBuilder.loadTexts: fmsFrCommStorageEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrCommStorageEntry.setDescription('An entry of fmsFrCommStorageTable.')
fmsFrcStoragePhysIfId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 30, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrcStoragePhysIfId.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrcStoragePhysIfId.setDescription('Interface physique')
fmsFrcStorageChannelId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 30, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrcStorageChannelId.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrcStorageChannelId.setDescription('Channel ID')
fmsFrcStorageDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 30, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrcStorageDlci.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrcStorageDlci.setDescription('DLCI')
fmsFrcStorageSubDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 30, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrcStorageSubDlci.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrcStorageSubDlci.setDescription('Channel')
fmsFrcStorageTypeOfDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 30, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("unknown", 1), ("svc", 2), ("pvc", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrcStorageTypeOfDlci.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrcStorageTypeOfDlci.setDescription('Type de DLCI')
fmsFrcStorageDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 30, 1, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrcStorageDirection.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrcStorageDirection.setDescription('Direction')
fmsFrcStorageTypeOfTransport = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 30, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(19, 32, 34, 36, 99, 255))).clone(namedValues=NamedValues(("tunnel", 19), ("annexG", 32), ("frsna", 34), ("frt", 36), ("switch", 99), ("unknown", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrcStorageTypeOfTransport.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrcStorageTypeOfTransport.setDescription('Type de transport')
fmsFrcStoragePvcStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 30, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2), ("unknown", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrcStoragePvcStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrcStoragePvcStatus.setDescription('PVC Status')
fmsFrcStorageDestAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 30, 1, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrcStorageDestAddr.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrcStorageDestAddr.setDescription('Destinataire')
fmsFrcStorageSrcAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 30, 1, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrcStorageSrcAddr.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrcStorageSrcAddr.setDescription('Adresse source')
fmsFrcStorageCos = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 30, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 255))).clone(namedValues=NamedValues(("vbr", 1), ("vbr-rt", 2), ("ubr", 3), ("unknown", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrcStorageCos.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrcStorageCos.setDescription('COS')
fmsFrcStorageCir = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 30, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrcStorageCir.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrcStorageCir.setDescription('CIR')
fmsFrcStorageMinCir = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 30, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrcStorageMinCir.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrcStorageMinCir.setDescription('CIR Min')
fmsFrcStorageBc = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 30, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrcStorageBc.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrcStorageBc.setDescription('BC')
fmsFrcStorageBe = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 30, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsFrcStorageBe.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrcStorageBe.setDescription('BE')
fmsFrCommFilter = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 30, 2))
fmsFrcFilterPhysIfId = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 30, 2, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fmsFrcFilterPhysIfId.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrcFilterPhysIfId.setDescription('Interface physique')
fmsFrcFilterChannelId = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 30, 2, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fmsFrcFilterChannelId.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrcFilterChannelId.setDescription('Channel ID')
fmsFrcFilterDlci = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 30, 2, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fmsFrcFilterDlci.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrcFilterDlci.setDescription('DLCI')
fmsFrcFilterAction = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 60, 30, 2, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("setFilter", 1), ("activateFilter", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fmsFrcFilterAction.setStatus('mandatory')
if mibBuilder.loadTexts: fmsFrcFilterAction.setDescription('Action')
fmStatPointToPointProtocol = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 71))
fmStatPppPhysLineTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 71, 1), )
if mibBuilder.loadTexts: fmStatPppPhysLineTable.setStatus('mandatory')
if mibBuilder.loadTexts: fmStatPppPhysLineTable.setDescription('This table contains the general information about PPP lines.')
fmStatPppPhysLineEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 71, 1, 1), ).setIndexNames((0, "PCE-MIB", "fmsPppPhysLineId"))
if mibBuilder.loadTexts: fmStatPppPhysLineEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fmStatPppPhysLineEntry.setDescription('An entry of fmStatPppPhysLineTable.')
fmsPppPhysLineId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 71, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsPppPhysLineId.setStatus('mandatory')
if mibBuilder.loadTexts: fmsPppPhysLineId.setDescription('The value of this object is the one physical port identifier.')
fmsPppPhysLocalMru = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 71, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(100, 1600))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsPppPhysLocalMru.setStatus('mandatory')
if mibBuilder.loadTexts: fmsPppPhysLocalMru.setDescription('The value of this object is the current value of the MRU (Maximum Receive Unit) for the local PPP entity. This value is the MRU that the remote entity is using when sending packets to the local PPP entity. The value of this object is meaningful only when the link has reached the open state (ifOperStatus is up).')
fmsPppPhysRemoteMru = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 71, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(100, 1600))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsPppPhysRemoteMru.setStatus('mandatory')
if mibBuilder.loadTexts: fmsPppPhysRemoteMru.setDescription('The value of this object is the current value of the MRU (Maximum Receive Unit) for the remote PPP entity. This value is the MRU that the local entity is using when sending packets to the remote PPP entity. The value of this object is meaningful only when the link has reached the open state (ifOperStatus is up).')
fmsPppPhysMagicNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 71, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("used", 1), ("notUsed", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsPppPhysMagicNumber.setStatus('mandatory')
if mibBuilder.loadTexts: fmsPppPhysMagicNumber.setDescription("The value of this object indicates the magic number state. If 'used' then the local node will attempt to perform Magic Number negotiation with the remote node. If 'notUsed' then this negotiation is not performed. In any event, the local node will comply with any magic number negotiations attempted by the remote node, per the PPP specification. Changing this object will have an effect when the link is next restarted.")
fmStatPppProtocolStatusTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 71, 2), )
if mibBuilder.loadTexts: fmStatPppProtocolStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: fmStatPppProtocolStatusTable.setDescription('This table contains the information about the protocol layers (LCP and NCP level) for each PPP line.')
fmStatPppProtocolStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 71, 2, 1), ).setIndexNames((0, "PCE-MIB", "fmsPppProtoLineId"))
if mibBuilder.loadTexts: fmStatPppProtocolStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fmStatPppProtocolStatusEntry.setDescription('An entry of fmStatPppProtocolStatusTable.')
fmsPppProtoLineId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 71, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsPppProtoLineId.setStatus('mandatory')
if mibBuilder.loadTexts: fmsPppProtoLineId.setDescription('The value of this object is the one PPP line identifier.')
fmsPppProtoLcpStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 71, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("stop", 1), ("wait", 2), ("opening", 3), ("up", 4), ("down", 5), ("closed", 6), ("freeze", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsPppProtoLcpStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fmsPppProtoLcpStatus.setDescription('The value of this object is the current state of the LCP layer.')
fmsPppProtoLcpDiag = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 71, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("ok", 1), ("timeOut", 2), ("underlyingLayerDown", 3), ("protocol", 4), ("rejected", 5), ("authenticationFailure", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsPppProtoLcpDiag.setStatus('mandatory')
if mibBuilder.loadTexts: fmsPppProtoLcpDiag.setDescription('The value of this object is the LCP layer diagnostic report.')
fmsPppProtoIpNcpStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 71, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("stop", 1), ("wait", 2), ("opening", 3), ("up", 4), ("down", 5), ("closed", 6), ("freeze", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsPppProtoIpNcpStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fmsPppProtoIpNcpStatus.setDescription('The value of this object is the current state of the IP NCP layer.')
fmsPppProtoIpNcpDiag = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 71, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("ok", 1), ("timeOut", 2), ("underlyingLayerDown", 3), ("protocol", 4), ("rejected", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsPppProtoIpNcpDiag.setStatus('mandatory')
if mibBuilder.loadTexts: fmsPppProtoIpNcpDiag.setDescription('The value of this object is the IP NCP layer diagnostic report.')
fmsPppProtoBrdgNcpStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 71, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("stop", 1), ("wait", 2), ("opening", 3), ("up", 4), ("down", 5), ("closed", 6), ("freeze", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsPppProtoBrdgNcpStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fmsPppProtoBrdgNcpStatus.setDescription('The value of this object is the current state of the Bridge NCP layer.')
fmsPppProtoBrdgNcpDiag = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 71, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("ok", 1), ("timeOut", 2), ("underlyingLayerDown", 3), ("protocol", 4), ("rejected", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsPppProtoBrdgNcpDiag.setStatus('mandatory')
if mibBuilder.loadTexts: fmsPppProtoBrdgNcpDiag.setDescription('The value of this object is the Bridge NCP layer diagnostic report.')
fmsPppProtoIpxNcpStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 71, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("stop", 1), ("wait", 2), ("opening", 3), ("up", 4), ("down", 5), ("closed", 6), ("freeze", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsPppProtoIpxNcpStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fmsPppProtoIpxNcpStatus.setDescription('The value of this object is the current state of the IPX NCP layer.')
fmsPppProtoIpxNcpDiag = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 71, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("ok", 1), ("timeOut", 2), ("underlyingLayerDown", 3), ("protocol", 4), ("rejected", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsPppProtoIpxNcpDiag.setStatus('mandatory')
if mibBuilder.loadTexts: fmsPppProtoIpxNcpDiag.setDescription('The value of this object is the IPX NCP layer diagnostic report.')
fmsPppProtoClnpNcpStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 71, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("stop", 1), ("wait", 2), ("opening", 3), ("up", 4), ("down", 5), ("closed", 6), ("freeze", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsPppProtoClnpNcpStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fmsPppProtoClnpNcpStatus.setDescription('The value of this object is the current state of the CLNP NCP layer.')
fmsPppProtoClnpNcpDiag = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 71, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("ok", 1), ("timeOut", 2), ("underlyingLayerDown", 3), ("protocol", 4), ("rejected", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsPppProtoClnpNcpDiag.setStatus('mandatory')
if mibBuilder.loadTexts: fmsPppProtoClnpNcpDiag.setDescription('The value of this object is the CLNP NCP layer diagnostic report.')
fmStatPppAuthenticationTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 71, 10), )
if mibBuilder.loadTexts: fmStatPppAuthenticationTable.setStatus('mandatory')
if mibBuilder.loadTexts: fmStatPppAuthenticationTable.setDescription('')
fmStatPppAuthenticationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 71, 10, 1), ).setIndexNames((0, "PCE-MIB", "fmsPppAuthLineId"))
if mibBuilder.loadTexts: fmStatPppAuthenticationEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fmStatPppAuthenticationEntry.setDescription('An entry of fmStatPppAuthenticationTable.')
fmsPppAuthLineId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 71, 10, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsPppAuthLineId.setStatus('mandatory')
if mibBuilder.loadTexts: fmsPppAuthLineId.setDescription('Numero de la ligne PPP.')
fmsPppAuthMasterAuthentication = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 71, 10, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("pap", 2), ("chap", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsPppAuthMasterAuthentication.setStatus('mandatory')
if mibBuilder.loadTexts: fmsPppAuthMasterAuthentication.setDescription("Authentifieur : Protocole d'authentification.")
fmsPppAuthMasterSuccessCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 71, 10, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsPppAuthMasterSuccessCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsPppAuthMasterSuccessCounter.setDescription("Authentifieur : Nb d'authentifications reussies.")
fmsPppAuthMasterFailureCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 71, 10, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsPppAuthMasterFailureCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsPppAuthMasterFailureCounter.setDescription("Authentifieur : Nb d'authentifications echouees.")
fmsPppAuthSlaveAuthentication = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 71, 10, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("pap", 2), ("chap", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsPppAuthSlaveAuthentication.setStatus('mandatory')
if mibBuilder.loadTexts: fmsPppAuthSlaveAuthentication.setDescription("Authentifie : Protocole d'authentification.")
fmsPppAuthSlaveSuccessCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 71, 10, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsPppAuthSlaveSuccessCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsPppAuthSlaveSuccessCounter.setDescription("Authentifie : Nb d'authentifications reussies.")
fmsPppAuthSlaveFailureCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 71, 10, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsPppAuthSlaveFailureCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fmsPppAuthSlaveFailureCounter.setDescription("Authentifie : Nb d'authentifications echouees.")
fmStatPppIpAddrAssignmentTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 71, 11), )
if mibBuilder.loadTexts: fmStatPppIpAddrAssignmentTable.setStatus('mandatory')
if mibBuilder.loadTexts: fmStatPppIpAddrAssignmentTable.setDescription('')
fmStatPppIpAddrAssignmentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 71, 11, 1), ).setIndexNames((0, "PCE-MIB", "fmsPppIpAddrLineId"))
if mibBuilder.loadTexts: fmStatPppIpAddrAssignmentEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fmStatPppIpAddrAssignmentEntry.setDescription('An entry of fmStatPppIpAddrAssignmentTable.')
fmsPppIpAddrLineId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 71, 11, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsPppIpAddrLineId.setStatus('mandatory')
if mibBuilder.loadTexts: fmsPppIpAddrLineId.setDescription('Numero de la ligne PPP.')
fmsPppIpAddrReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 71, 11, 1, 10), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsPppIpAddrReceived.setStatus('mandatory')
if mibBuilder.loadTexts: fmsPppIpAddrReceived.setDescription('Adresse IP recue.')
fmsPppIpAddrSent = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 71, 11, 1, 11), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsPppIpAddrSent.setStatus('mandatory')
if mibBuilder.loadTexts: fmsPppIpAddrSent.setDescription('Adresse IP attribuee.')
fmStatE1 = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 80))
fmStatE1Ds1ChannelNumber = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 80, 1))
fmsE1Ds1ChIfNumber = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 80, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsE1Ds1ChIfNumber.setStatus('mandatory')
if mibBuilder.loadTexts: fmsE1Ds1ChIfNumber.setDescription('Nombre de canaux E1 ou DS1')
fmStatE1Ds1ChannelTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 80, 2), )
if mibBuilder.loadTexts: fmStatE1Ds1ChannelTable.setStatus('mandatory')
if mibBuilder.loadTexts: fmStatE1Ds1ChannelTable.setDescription('This table contains')
fmStatE1Ds1ChannelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 80, 2, 1), ).setIndexNames((0, "PCE-MIB", "fmsE1Ds1ChIfPhysId"), (0, "PCE-MIB", "fmsE1Ds1ChIfChannelId"))
if mibBuilder.loadTexts: fmStatE1Ds1ChannelEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fmStatE1Ds1ChannelEntry.setDescription('An entry of fmStatE1Ds1ChannelTable.')
fmsE1Ds1ChIfPhysId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 80, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsE1Ds1ChIfPhysId.setStatus('mandatory')
if mibBuilder.loadTexts: fmsE1Ds1ChIfPhysId.setDescription('Interface physique E1')
fmsE1Ds1ChIfChannelId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 80, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(42, 131))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsE1Ds1ChIfChannelId.setStatus('mandatory')
if mibBuilder.loadTexts: fmsE1Ds1ChIfChannelId.setDescription('Interface canal E1')
fmsE1Ds1ChIfType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 80, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 5, 23, 32, 100))).clone(namedValues=NamedValues(("other", 1), ("rfc877-x25", 5), ("ppp", 23), ("frame-relay", 32), ("hdlc-t", 100)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsE1Ds1ChIfType.setStatus('mandatory')
if mibBuilder.loadTexts: fmsE1Ds1ChIfType.setDescription("Type de l'interface")
fmsE1Ds1ChIfDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 80, 2, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsE1Ds1ChIfDescr.setStatus('mandatory')
if mibBuilder.loadTexts: fmsE1Ds1ChIfDescr.setDescription('Description')
fmsE1Ds1ChIfMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 80, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsE1Ds1ChIfMtu.setStatus('mandatory')
if mibBuilder.loadTexts: fmsE1Ds1ChIfMtu.setDescription("Taille maximum d'une trame")
fmsE1Ds1ChIfSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 80, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsE1Ds1ChIfSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: fmsE1Ds1ChIfSpeed.setDescription("Debit de l'interface")
fmsE1Ds1ChIfPhysAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 80, 2, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsE1Ds1ChIfPhysAddress.setStatus('mandatory')
if mibBuilder.loadTexts: fmsE1Ds1ChIfPhysAddress.setDescription('Adresse physique')
fmsE1Ds1ChIfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 80, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fmsE1Ds1ChIfAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fmsE1Ds1ChIfAdminStatus.setDescription("Etat desire de l'interface")
fmsE1Ds1ChIfOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 80, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsE1Ds1ChIfOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fmsE1Ds1ChIfOperStatus.setDescription("Etat operationnel de l'interface")
fmsE1Ds1ChIfLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 80, 2, 1, 10), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsE1Ds1ChIfLastChange.setStatus('mandatory')
if mibBuilder.loadTexts: fmsE1Ds1ChIfLastChange.setDescription("Valeur de sysUpTime au moment ou l'interface est passe dans l'etat operationnel courant")
fmsE1Ds1ChIfInOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 80, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsE1Ds1ChIfInOctets.setStatus('mandatory')
if mibBuilder.loadTexts: fmsE1Ds1ChIfInOctets.setDescription("Nombre d'octets recus")
fmsE1Ds1ChIfInUcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 80, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsE1Ds1ChIfInUcastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: fmsE1Ds1ChIfInUcastPkts.setDescription('Nombre de paquets Unicast recus')
fmsE1Ds1ChIfInNUcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 80, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsE1Ds1ChIfInNUcastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: fmsE1Ds1ChIfInNUcastPkts.setDescription('Nombre de paquets non Unicast recus')
fmsE1Ds1ChIfInDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 80, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsE1Ds1ChIfInDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: fmsE1Ds1ChIfInDiscards.setDescription('Nombre de paquets recus detruits')
fmsE1Ds1ChIfInErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 80, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsE1Ds1ChIfInErrors.setStatus('mandatory')
if mibBuilder.loadTexts: fmsE1Ds1ChIfInErrors.setDescription('Nombre de paquets recus en erreur')
fmsE1Ds1ChIfInUnknownProtos = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 80, 2, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsE1Ds1ChIfInUnknownProtos.setStatus('mandatory')
if mibBuilder.loadTexts: fmsE1Ds1ChIfInUnknownProtos.setDescription('Nombre de paquets recus avec protocole inconnu')
fmsE1Ds1ChIfOutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 80, 2, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsE1Ds1ChIfOutOctets.setStatus('mandatory')
if mibBuilder.loadTexts: fmsE1Ds1ChIfOutOctets.setDescription("Nombre d'octets emis")
fmsE1Ds1ChIfOutUcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 80, 2, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsE1Ds1ChIfOutUcastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: fmsE1Ds1ChIfOutUcastPkts.setDescription('Nombre de paquets Unicast emis')
fmsE1Ds1ChIfOutNUcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 80, 2, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsE1Ds1ChIfOutNUcastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: fmsE1Ds1ChIfOutNUcastPkts.setDescription('Nombre de paquets non Unicast emis')
fmsE1Ds1ChIfOutDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 80, 2, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsE1Ds1ChIfOutDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: fmsE1Ds1ChIfOutDiscards.setDescription('Nombre de paquets emis detruits')
fmsE1Ds1ChIfOutErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 80, 2, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsE1Ds1ChIfOutErrors.setStatus('mandatory')
if mibBuilder.loadTexts: fmsE1Ds1ChIfOutErrors.setDescription('Nombre de paquets emis en erreur')
fmsE1Ds1ChIfOutQLen = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 80, 2, 1, 22), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsE1Ds1ChIfOutQLen.setStatus('mandatory')
if mibBuilder.loadTexts: fmsE1Ds1ChIfOutQLen.setDescription('Longueur de la file des paquets emis')
fmsE1Ds1ChIfSpecific = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 80, 2, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsE1Ds1ChIfSpecific.setStatus('mandatory')
if mibBuilder.loadTexts: fmsE1Ds1ChIfSpecific.setDescription('OID de la MIB de reference')
fmStatS2 = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 90))
fmStatS2BChannelTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 90, 1), )
if mibBuilder.loadTexts: fmStatS2BChannelTable.setStatus('mandatory')
if mibBuilder.loadTexts: fmStatS2BChannelTable.setDescription('')
fmStatS2BChannelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 90, 1, 1), ).setIndexNames((0, "PCE-MIB", "fmsS2BChPhysIfId"), (0, "PCE-MIB", "fmsS2BChChannelId"))
if mibBuilder.loadTexts: fmStatS2BChannelEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fmStatS2BChannelEntry.setDescription('An entry of fmStatS2BChannelTable.')
fmsS2BChPhysIfId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 90, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsS2BChPhysIfId.setStatus('mandatory')
if mibBuilder.loadTexts: fmsS2BChPhysIfId.setDescription('Interface physique associee au canal')
fmsS2BChChannelId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 90, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsS2BChChannelId.setStatus('mandatory')
if mibBuilder.loadTexts: fmsS2BChChannelId.setDescription('Numero de canal')
fmsS2BChProto = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 90, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 5, 23, 32))).clone(namedValues=NamedValues(("other", 1), ("rfc877-x25", 5), ("ppp", 23), ("frame-relay", 32)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsS2BChProto.setStatus('mandatory')
if mibBuilder.loadTexts: fmsS2BChProto.setDescription('Protocole associe au canal')
fmsS2BChIfSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 90, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsS2BChIfSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: fmsS2BChIfSpeed.setDescription('Debit du canal')
fmsS2BChAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 90, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fmsS2BChAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fmsS2BChAdminStatus.setDescription('Etat desire du canal')
fmsS2BChOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 90, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsS2BChOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fmsS2BChOperStatus.setDescription('Etat operationnel du canal')
fmsS2BChIfLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 90, 1, 1, 7), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsS2BChIfLastChange.setStatus('mandatory')
if mibBuilder.loadTexts: fmsS2BChIfLastChange.setDescription("Valeur de sysUpTime au moment ou le canal est passe dans l'etat operationnel courant")
fmsS2BChIfInOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 90, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsS2BChIfInOctets.setStatus('mandatory')
if mibBuilder.loadTexts: fmsS2BChIfInOctets.setDescription("Nombre d'octets recus")
fmsS2BChIfOutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 90, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsS2BChIfOutOctets.setStatus('mandatory')
if mibBuilder.loadTexts: fmsS2BChIfOutOctets.setDescription("Nombre d'octets emis")
fmsS2BChIfCalledAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 90, 1, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(15, 15)).setFixedLength(15)).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsS2BChIfCalledAddress.setStatus('mandatory')
if mibBuilder.loadTexts: fmsS2BChIfCalledAddress.setDescription('Adresse appelee')
fmsS2BChIfCallingAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 90, 1, 1, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(15, 15)).setFixedLength(15)).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsS2BChIfCallingAddress.setStatus('mandatory')
if mibBuilder.loadTexts: fmsS2BChIfCallingAddress.setDescription('Adresse appelante')
fmStatS0 = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 91))
fmStatS0BChannelTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 91, 1), )
if mibBuilder.loadTexts: fmStatS0BChannelTable.setStatus('mandatory')
if mibBuilder.loadTexts: fmStatS0BChannelTable.setDescription('')
fmStatS0BChannelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 91, 1, 1), ).setIndexNames((0, "PCE-MIB", "fmsS0BChPhysIfId"), (0, "PCE-MIB", "fmsS0BChChannelId"))
if mibBuilder.loadTexts: fmStatS0BChannelEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fmStatS0BChannelEntry.setDescription('An entry of fmStatS0BChannelTable.')
fmsS0BChPhysIfId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 91, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 6))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsS0BChPhysIfId.setStatus('mandatory')
if mibBuilder.loadTexts: fmsS0BChPhysIfId.setDescription('The value of this object is the number of the physical port the basic rate interface B channel is related to.')
fmsS0BChChannelId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 91, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 9))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsS0BChChannelId.setStatus('mandatory')
if mibBuilder.loadTexts: fmsS0BChChannelId.setDescription('The value of this object is the identification number of the basic rate interface B channel.')
fmsS0BChProto = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 91, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 5, 23, 32))).clone(namedValues=NamedValues(("other", 1), ("rfc877-x25", 5), ("ppp", 23), ("frame-relay", 32)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsS0BChProto.setStatus('mandatory')
if mibBuilder.loadTexts: fmsS0BChProto.setDescription('The value of this object is the protocol related to the basic rate interface B channel.')
fmsS0BChIfSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 91, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsS0BChIfSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: fmsS0BChIfSpeed.setDescription('The value of this object is the speed of the basic rate interface B channel.')
fmsS0BChAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 91, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fmsS0BChAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fmsS0BChAdminStatus.setDescription('The value of this object is the operational state wanted for the basic rate interface B channel.')
fmsS0BChOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 91, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsS0BChOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fmsS0BChOperStatus.setDescription('The value of this object is the current operational state of the basic rate interface B channel.')
fmsS0BChIfLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 91, 1, 1, 7), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsS0BChIfLastChange.setStatus('mandatory')
if mibBuilder.loadTexts: fmsS0BChIfLastChange.setDescription('The value of this object is the value of the sysUpTime at the time when the basic rate interface B channel took its current operational state.')
fmsS0BChIfInOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 91, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsS0BChIfInOctets.setStatus('mandatory')
if mibBuilder.loadTexts: fmsS0BChIfInOctets.setDescription('The value of this object is the number of bytes received on the basic rate interface B channel.')
fmsS0BChIfOutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 91, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsS0BChIfOutOctets.setStatus('mandatory')
if mibBuilder.loadTexts: fmsS0BChIfOutOctets.setDescription('The value of this object is the number of bytes sent on the basic rate interface B channel.')
fmsS0BChIfCalledAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 91, 1, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(15, 15)).setFixedLength(15)).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsS0BChIfCalledAddress.setStatus('mandatory')
if mibBuilder.loadTexts: fmsS0BChIfCalledAddress.setDescription('The value of this object is the called address.')
fmsS0BChIfCallingAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 10, 91, 1, 1, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(15, 15)).setFixedLength(15)).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsS0BChIfCallingAddress.setStatus('mandatory')
if mibBuilder.loadTexts: fmsS0BChIfCallingAddress.setDescription('The value of this object is the caller address.')
fmOsi = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 10, 15))
fmOsiCLNP = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 1))
fmOsiCLNPSystem = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 1, 1))
fmOsiForwarding = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOsiForwarding.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiForwarding.setDescription('Forwarding')
fmOsiCLNPSysOutPDUs = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 1, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOsiCLNPSysOutPDUs.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiCLNPSysOutPDUs.setDescription('clnpSysOutPDUs')
fmOsiCLNPSysInPDUs = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 1, 1, 35), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOsiCLNPSysInPDUs.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiCLNPSysInPDUs.setDescription('clnpSysInPDUs')
fmOsiCLNPSysErrMemFails = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 1, 1, 40), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOsiCLNPSysErrMemFails.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiCLNPSysErrMemFails.setDescription('clnpSysErrMemFails')
fmOsiCLNPCircuitTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 1, 5), )
if mibBuilder.loadTexts: fmOsiCLNPCircuitTable.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiCLNPCircuitTable.setDescription('')
fmOsiCLNPCircuitEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 1, 5, 1), ).setIndexNames((0, "PCE-MIB", "fmOsiCLNPCircIndex"))
if mibBuilder.loadTexts: fmOsiCLNPCircuitEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiCLNPCircuitEntry.setDescription('An entry of fmOsiCLNPCircuitTable.')
fmOsiCLNPCircIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 1, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOsiCLNPCircIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiCLNPCircIndex.setDescription('clnpCircIndex')
fmOsiCLNPCircOutPDUs = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 1, 5, 1, 35), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOsiCLNPCircOutPDUs.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiCLNPCircOutPDUs.setDescription('clnpCircOutPDUs')
fmOsiCLNPCircInPDUs = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 1, 5, 1, 40), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOsiCLNPCircInPDUs.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiCLNPCircInPDUs.setDescription('clnpCircInPDUs')
fmOsiESIS = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 5))
fmOsiESISSystem = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 5, 1))
fmOsiESISSysOutPDUs = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 5, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOsiESISSysOutPDUs.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiESISSysOutPDUs.setDescription('esisSysOutPDUs')
fmOsiESISSysInPDUs = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 5, 1, 35), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOsiESISSysInPDUs.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiESISSysInPDUs.setDescription('esisSysInPDUs')
fmOsiESISCircuitTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 5, 5), )
if mibBuilder.loadTexts: fmOsiESISCircuitTable.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiESISCircuitTable.setDescription('')
fmOsiESISCircuitEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 5, 5, 1), ).setIndexNames((0, "PCE-MIB", "fmOsiESISCircIndex"))
if mibBuilder.loadTexts: fmOsiESISCircuitEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiESISCircuitEntry.setDescription('An entry of fmOsiESISCircuitTable.')
fmOsiESISCircIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 5, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOsiESISCircIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiESISCircIndex.setDescription('esisCircIndex')
fmOsiESISCircOutPDUs = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 5, 5, 1, 35), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOsiESISCircOutPDUs.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiESISCircOutPDUs.setDescription('esisCircOutPDUs')
fmOsiESISCircInPDUs = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 5, 5, 1, 40), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOsiESISCircInPDUs.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiESISCircInPDUs.setDescription('esisCircInPDUs')
fmOsiISIS = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 10))
fmOsiISISSystem = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 10, 1))
fmOsiISISSysOutPdu = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 10, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOsiISISSysOutPdu.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiISISSysOutPdu.setDescription('isisSysOutPDUs')
fmOsiISISSysInPdu = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 10, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOsiISISSysInPdu.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiISISSysInPdu.setDescription('isisSysInPDUs')
fmOsiISISSysL1State = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 10, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("on", 2), ("waiting", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOsiISISSysL1State.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiISISSysL1State.setDescription('isisSysL1State')
fmOsiISISSysCorrLSP = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 10, 1, 37), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOsiISISSysCorrLSP.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiISISSysCorrLSP.setDescription('isisSysCorrLSPs')
fmOsiISISSysL1DbaseOloads = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 10, 1, 40), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOsiISISSysL1DbaseOloads.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiISISSysL1DbaseOloads.setDescription('isisSysLSPL1DbaseOloads')
fmOsiISISSysttmpToExMaxSaqNums = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 10, 1, 42), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOsiISISSysttmpToExMaxSaqNums.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiISISSysttmpToExMaxSaqNums.setDescription('isisSysAttmptToExMaxSeqNums')
fmOsiISISSysSeqNumSkips = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 10, 1, 44), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOsiISISSysSeqNumSkips.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiISISSysSeqNumSkips.setDescription('isisSysSeqNumSkips')
fmOsiISISSysOwnLSPPurges = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 10, 1, 46), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOsiISISSysOwnLSPPurges.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiISISSysOwnLSPPurges.setDescription('isisSysOwnLSPPurges')
fmOsiISISSysISFieldLenMismatches = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 10, 1, 48), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOsiISISSysISFieldLenMismatches.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiISISSysISFieldLenMismatches.setDescription('isisSysIDFieldLenMismatches')
fmOsiISISSysMaxAreaAddrMismatches = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 10, 1, 50), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOsiISISSysMaxAreaAddrMismatches.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiISISSysMaxAreaAddrMismatches.setDescription('isisSysMaxAreaAddrMismatches')
fmOsiISISSysL2State = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 10, 1, 52), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("on", 2), ("waiting", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOsiISISSysL2State.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiISISSysL2State.setDescription('isisSysL2State')
fmOsiISISSysLSPL2DbaseOloads = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 10, 1, 54), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOsiISISSysLSPL2DbaseOloads.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiISISSysLSPL2DbaseOloads.setDescription('isisSysLSPL2DbaseOloads')
fmOsiISISSysAuthFails = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 10, 1, 56), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOsiISISSysAuthFails.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiISISSysAuthFails.setDescription('isisSysAuthFails')
fmOsiISISLogAdjcencyStateChanges = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 10, 1, 58), Counter32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fmOsiISISLogAdjcencyStateChanges.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiISISLogAdjcencyStateChanges.setDescription('isisLogAdjacencyStateChanges')
fmOsiISISCircuitTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 10, 5), )
if mibBuilder.loadTexts: fmOsiISISCircuitTable.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiISISCircuitTable.setDescription('')
fmOsiISISCircuitEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 10, 5, 1), ).setIndexNames((0, "PCE-MIB", "fmOsiISISCircIndex"))
if mibBuilder.loadTexts: fmOsiISISCircuitEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiISISCircuitEntry.setDescription('An entry of fmOsiISISCircuitTable.')
fmOsiISISCircIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 10, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOsiISISCircIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiISISCircIndex.setDescription('isisCircIndex')
fmOsiISISCircOutPdu = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 10, 5, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOsiISISCircOutPdu.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiISISCircOutPdu.setDescription('isisCircOutPDUs')
fmOsiISISCircInPdu = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 10, 5, 1, 35), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOsiISISCircInPdu.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiISISCircInPdu.setDescription('isisCircInPDUs')
fmOsiISISCircAdjChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 10, 5, 1, 40), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOsiISISCircAdjChanges.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiISISCircAdjChanges.setDescription('isisCircAdjChanges')
fmOsiISISCircInitFails = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 10, 5, 1, 42), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOsiISISCircInitFails.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiISISCircInitFails.setDescription('isisCircInitFails')
fmOsiISISCircRejAdjs = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 10, 5, 1, 44), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOsiISISCircRejAdjs.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiISISCircRejAdjs.setDescription('isisCircRejAdjs')
fmOsiISISCircOutCtrlPdu = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 10, 5, 1, 46), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOsiISISCircOutCtrlPdu.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiISISCircOutCtrlPdu.setDescription('isisCircOutCtrlPDUs')
fmOsiISISCircInCrtlPdu = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 10, 5, 1, 48), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOsiISISCircInCrtlPdu.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiISISCircInCrtlPdu.setDescription('isisCircInCtrlPDUs')
fmOsiISISCircIDFieldLenMismatches = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 10, 5, 1, 50), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOsiISISCircIDFieldLenMismatches.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiISISCircIDFieldLenMismatches.setDescription('isisCircIDFieldLenMismatches')
fmOsiISISCircMaxAreaAddrMismatches = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 10, 5, 1, 52), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOsiISISCircMaxAreaAddrMismatches.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiISISCircMaxAreaAddrMismatches.setDescription('isisCircMaxAreaAddrMismatches')
fmOsiISISCircL1DesIS = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 10, 5, 1, 54), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOsiISISCircL1DesIS.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiISISCircL1DesIS.setDescription('isisCircL1DesIS')
fmOsiISISCircLANL1DesISChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 10, 5, 1, 56), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOsiISISCircLANL1DesISChanges.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiISISCircLANL1DesISChanges.setDescription('isisCircLANL1DesISChanges')
fmOsiISISCircL2DesIS = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 10, 5, 1, 58), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOsiISISCircL2DesIS.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiISISCircL2DesIS.setDescription('isisCircL2DesIS')
fmOsiISISCircLANL2DesISChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 10, 5, 1, 60), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOsiISISCircLANL2DesISChanges.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiISISCircLANL2DesISChanges.setDescription('isisCircLANL2DesISChanges')
fmOsiISISCircAuthFails = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 10, 5, 1, 62), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOsiISISCircAuthFails.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiISISCircAuthFails.setDescription('isisCircAuthFails')
fmOsiISISAreaTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 10, 10), )
if mibBuilder.loadTexts: fmOsiISISAreaTable.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiISISAreaTable.setDescription('')
fmOsiISISAreaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 10, 10, 1), ).setIndexNames((0, "PCE-MIB", "fmOsiISISAreaAddress"))
if mibBuilder.loadTexts: fmOsiISISAreaEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiISISAreaEntry.setDescription('An entry of fmOsiISISAreaTable.')
fmOsiISISAreaAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 10, 10, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 46))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOsiISISAreaAddress.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiISISAreaAddress.setDescription('Area Address')
fmOsiISISISAdjacencyTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 10, 15), )
if mibBuilder.loadTexts: fmOsiISISISAdjacencyTable.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiISISISAdjacencyTable.setDescription('')
fmOsiISISISAdjacencyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 10, 15, 1), ).setIndexNames((0, "PCE-MIB", "fmOsiISISISAdjCircIndex"), (0, "PCE-MIB", "fmOsiISISISAdjIndex"))
if mibBuilder.loadTexts: fmOsiISISISAdjacencyEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiISISISAdjacencyEntry.setDescription('An entry of fmOsiISISISAdjacencyTable.')
fmOsiISISISAdjCircIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 10, 15, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOsiISISISAdjCircIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiISISISAdjCircIndex.setDescription('Circuit Index')
fmOsiISISISAdjIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 10, 15, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOsiISISISAdjIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiISISISAdjIndex.setDescription('Adjacency Index')
fmOsiISISISAdjSysID = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 10, 15, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOsiISISISAdjSysID.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiISISISAdjSysID.setDescription('System ID')
fmOsiISISISAdjState = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 10, 15, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("initializing", 1), ("up", 2), ("failed", 3), ("down", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOsiISISISAdjState.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiISISISAdjState.setDescription('State')
fmOsiISISISAdjSNPAAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 10, 15, 1, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 46))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOsiISISISAdjSNPAAddress.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiISISISAdjSNPAAddress.setDescription('SNPA Address')
fmOsiISISISAdjType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 10, 15, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("automatic", 1), ("manual", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOsiISISISAdjType.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiISISISAdjType.setDescription('Type')
fmOsiISISISAdjUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 10, 15, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("undefined", 1), ("level1", 2), ("level2", 3), ("level1and2", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOsiISISISAdjUsage.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiISISISAdjUsage.setDescription('Usage')
fmOsiISISISAdjHoldTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 10, 15, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOsiISISISAdjHoldTimer.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiISISISAdjHoldTimer.setDescription('Holding Timer')
fmOsiISISISAdjPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 10, 15, 1, 30), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOsiISISISAdjPriority.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiISISISAdjPriority.setDescription('Priority')
fmOsiISISISAdjacencyAreaAddressTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 10, 17), )
if mibBuilder.loadTexts: fmOsiISISISAdjacencyAreaAddressTable.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiISISISAdjacencyAreaAddressTable.setDescription('')
fmOsiISISISAdjacencyAreaAddressEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 10, 17, 1), ).setIndexNames((0, "PCE-MIB", "fmOsiISISISAdjAreaAddrCircIndex"), (0, "PCE-MIB", "fmOsiISISISAdjAreaAddrAdjIndex"), (0, "PCE-MIB", "fmOsiISISISAdjAreaAddress"))
if mibBuilder.loadTexts: fmOsiISISISAdjacencyAreaAddressEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiISISISAdjacencyAreaAddressEntry.setDescription('An entry of fmOsiISISISAdjacencyAreaAddressTable.')
fmOsiISISISAdjAreaAddrCircIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 10, 17, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOsiISISISAdjAreaAddrCircIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiISISISAdjAreaAddrCircIndex.setDescription('Circuit Index')
fmOsiISISISAdjAreaAddrAdjIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 10, 17, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOsiISISISAdjAreaAddrAdjIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiISISISAdjAreaAddrAdjIndex.setDescription('Adjacency Index')
fmOsiISISISAdjAreaAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 10, 17, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 46))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOsiISISISAdjAreaAddress.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiISISISAdjAreaAddress.setDescription('Area Address')
fmOsiISISESAdjacencyTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 10, 20), )
if mibBuilder.loadTexts: fmOsiISISESAdjacencyTable.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiISISESAdjacencyTable.setDescription('')
fmOsiISISESAdjacencyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 10, 20, 1), ).setIndexNames((0, "PCE-MIB", "fmOsiISISESAdjCircIndex"), (0, "PCE-MIB", "fmOsiISISESAdjAdjIndex"))
if mibBuilder.loadTexts: fmOsiISISESAdjacencyEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiISISESAdjacencyEntry.setDescription('An entry of fmOsiISISESAdjacencyTable.')
fmOsiISISESAdjCircIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 10, 20, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOsiISISESAdjCircIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiISISESAdjCircIndex.setDescription('Circuit Index')
fmOsiISISESAdjAdjIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 10, 20, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOsiISISESAdjAdjIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiISISESAdjAdjIndex.setDescription('Adjacency Index')
fmOsiISISESAdjESID = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 10, 20, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOsiISISESAdjESID.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiISISESAdjESID.setDescription('System ID')
fmOsiISISESAdjState = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 10, 20, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("initializing", 1), ("up", 2), ("failed", 3), ("down", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOsiISISESAdjState.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiISISESAdjState.setDescription('State')
fmOsiISISESAdjNeighSNPAAdress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 10, 20, 1, 15), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 46))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOsiISISESAdjNeighSNPAAdress.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiISISESAdjNeighSNPAAdress.setDescription('SNPA Address')
fmOsiISISESAdjType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 10, 20, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("automatic", 1), ("manual", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOsiISISESAdjType.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiISISESAdjType.setDescription('Type')
fmOsiISISReachableAddressTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 10, 25), )
if mibBuilder.loadTexts: fmOsiISISReachableAddressTable.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiISISReachableAddressTable.setDescription('')
fmOsiISISReachableAddressEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 10, 25, 1), ).setIndexNames((0, "PCE-MIB", "fmOsiISISRASystemType"), (0, "PCE-MIB", "fmOsiISISRAAddress"), (0, "PCE-MIB", "fmOsiISISRAMetric"), (0, "PCE-MIB", "fmOsiISISRAPathIdentifier"))
if mibBuilder.loadTexts: fmOsiISISReachableAddressEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiISISReachableAddressEntry.setDescription('An entry of fmOsiISISReachableAddressTable.')
fmOsiISISRASystemType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 10, 25, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("es", 1), ("l1IS", 2), ("l2IS", 3), ("prefix", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOsiISISRASystemType.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiISISRASystemType.setDescription('System Type')
fmOsiISISRAAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 10, 25, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 46))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOsiISISRAAddress.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiISISRAAddress.setDescription('Reachable Address ')
fmOsiISISRAMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 10, 25, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("default", 1), ("delay", 2), ("expense", 3), ("error", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOsiISISRAMetric.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiISISRAMetric.setDescription('Metric ')
fmOsiISISRAPathIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 10, 25, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOsiISISRAPathIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiISISRAPathIdentifier.setDescription('Path Idendifier ')
fmOsiISISRAType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 10, 25, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("automatic", 1), ("manual", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOsiISISRAType.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiISISRAType.setDescription('Type')
fmOsiISISRACircuitId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 10, 25, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOsiISISRACircuitId.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiISISRACircuitId.setDescription('Circuit Id')
fmOsiISISRAAdjacencyId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 10, 25, 1, 35), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOsiISISRAAdjacencyId.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiISISRAAdjacencyId.setDescription('Adjacency Id')
fmOsiISISRAPathCost = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 10, 25, 1, 40), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOsiISISRAPathCost.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiISISRAPathCost.setDescription('Path Cost')
fmOsiISISRASNPAAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 15, 10, 25, 1, 45), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 46))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOsiISISRASNPAAddress.setStatus('mandatory')
if mibBuilder.loadTexts: fmOsiISISRASNPAAddress.setDescription('SNPA Address')
fmPing = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 10, 16))
fmPingTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 10, 16, 1), )
if mibBuilder.loadTexts: fmPingTable.setStatus('mandatory')
if mibBuilder.loadTexts: fmPingTable.setDescription('')
fmPingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 10, 16, 1, 1), ).setIndexNames((0, "PCE-MIB", "fmPingIdentifier"))
if mibBuilder.loadTexts: fmPingEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fmPingEntry.setDescription('An entry of fmPingTable.')
fmPingIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 16, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fmPingIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: fmPingIdentifier.setDescription('Identifier')
fmPingProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 16, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 8, 14))).clone(namedValues=NamedValues(("ip", 1), ("clnp", 8), ("novell", 14)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fmPingProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: fmPingProtocol.setDescription('Protocol')
fmPingAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 16, 1, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 46))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fmPingAddress.setStatus('mandatory')
if mibBuilder.loadTexts: fmPingAddress.setDescription('Address')
fmPingCountRequest = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 16, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fmPingCountRequest.setStatus('mandatory')
if mibBuilder.loadTexts: fmPingCountRequest.setDescription('CountRequest')
fmPingPacketSize = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 16, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(64, 1500))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fmPingPacketSize.setStatus('mandatory')
if mibBuilder.loadTexts: fmPingPacketSize.setDescription('PacketSize')
fmPingDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 16, 1, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3600000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fmPingDelay.setStatus('mandatory')
if mibBuilder.loadTexts: fmPingDelay.setDescription('Delay')
fmPingTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 16, 1, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3600000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fmPingTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: fmPingTimeout.setDescription('Timeout')
fmPingPermanent = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 16, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fmPingPermanent.setStatus('mandatory')
if mibBuilder.loadTexts: fmPingPermanent.setDescription('Permanent Flag')
fmPingSentPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 16, 1, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmPingSentPackets.setStatus('mandatory')
if mibBuilder.loadTexts: fmPingSentPackets.setDescription('Sent Packets')
fmPingReceivedPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 16, 1, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmPingReceivedPackets.setStatus('mandatory')
if mibBuilder.loadTexts: fmPingReceivedPackets.setDescription('Received Packets')
fmPingMinRoundTrip = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 16, 1, 1, 40), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmPingMinRoundTrip.setStatus('mandatory')
if mibBuilder.loadTexts: fmPingMinRoundTrip.setDescription('Min Round Trip')
fmPingAvgRoundTrip = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 16, 1, 1, 41), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmPingAvgRoundTrip.setStatus('mandatory')
if mibBuilder.loadTexts: fmPingAvgRoundTrip.setDescription('Avg Round Trip')
fmPingMaxRoundTrip = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 16, 1, 1, 42), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmPingMaxRoundTrip.setStatus('mandatory')
if mibBuilder.loadTexts: fmPingMaxRoundTrip.setDescription('Max Round Trip')
fmPingCompletedFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 16, 1, 1, 48), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmPingCompletedFlag.setStatus('mandatory')
if mibBuilder.loadTexts: fmPingCompletedFlag.setDescription('Ping completed flag')
fmPingOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 16, 1, 1, 50), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 75))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fmPingOwner.setStatus('mandatory')
if mibBuilder.loadTexts: fmPingOwner.setDescription('Owner description')
fmPingAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 16, 1, 1, 52), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("active", 1), ("notInService", 2), ("notReady", 3), ("createAndGo", 4), ("createAndWait", 5), ("destroy", 6), ("stop", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fmPingAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: fmPingAdminState.setDescription('AdminState')
fmRip2 = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 10, 17))
fmRip2GlobalGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 10, 17, 1))
fmRip2GlobalRouteChanges = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 17, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmRip2GlobalRouteChanges.setStatus('mandatory')
if mibBuilder.loadTexts: fmRip2GlobalRouteChanges.setDescription('RIP2 Global Route Changes. The number of changes made to the IP Route Database by RIP.')
fmRip2GlobalQueries = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 17, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmRip2GlobalQueries.setStatus('mandatory')
if mibBuilder.loadTexts: fmRip2GlobalQueries.setDescription('RIP2 Global Queries. The number of responses sent to RIP queries from other systems.')
fmRip2IfStatTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 10, 17, 2), )
if mibBuilder.loadTexts: fmRip2IfStatTable.setStatus('mandatory')
if mibBuilder.loadTexts: fmRip2IfStatTable.setDescription('A list of subnets which require separate status monitoring in RIP')
fmRip2IfStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 10, 17, 2, 1), ).setIndexNames((0, "PCE-MIB", "fmRip2IfStatAddress"))
if mibBuilder.loadTexts: fmRip2IfStatEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fmRip2IfStatEntry.setDescription('An entry of fmRip2IfStatTable.')
fmRip2IfStatAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 17, 2, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmRip2IfStatAddress.setStatus('mandatory')
if mibBuilder.loadTexts: fmRip2IfStatAddress.setDescription('RIP2 Interface Stat Ip Address. The IP Address of this system on the indicated subnet')
fmRip2IfStatRcvBadPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 17, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmRip2IfStatRcvBadPackets.setStatus('mandatory')
if mibBuilder.loadTexts: fmRip2IfStatRcvBadPackets.setDescription('RIP2 Interface Stat Received Bad Packets. The number of RIP response packets received bythe RIP process which were subsequently discarded for any reason (e.g. a version 0 packet, or an unknown command type). ')
fmRip2IfStatRcvBadRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 17, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmRip2IfStatRcvBadRoutes.setStatus('mandatory')
if mibBuilder.loadTexts: fmRip2IfStatRcvBadRoutes.setDescription('RIP2 Interface Stat Received Bad Routes. The number of routes, in valid RIP packets,which were ignored for any reason (e.g. unknown address family, or invalid metric).')
fmRip2IfStatSentUpdates = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 17, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmRip2IfStatSentUpdates.setStatus('mandatory')
if mibBuilder.loadTexts: fmRip2IfStatSentUpdates.setDescription('RIP2 Interface Stat Sent Updates. The number of triggered RIP updates actually sent on this interface. This explicitly does NOT include full updates sent containing new information.')
fmRip2IfStatStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 17, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmRip2IfStatStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fmRip2IfStatStatus.setDescription('RIP2 Interface Stat Status. Writing invalid has the effect of deleting this interface.')
fmRip2IfConfTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 10, 17, 3), )
if mibBuilder.loadTexts: fmRip2IfConfTable.setStatus('mandatory')
if mibBuilder.loadTexts: fmRip2IfConfTable.setDescription('A list of subnets which require separate configuration in RIP.')
fmRip2IfConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 10, 17, 3, 1), ).setIndexNames((0, "PCE-MIB", "fmRip2IfConfAddress"))
if mibBuilder.loadTexts: fmRip2IfConfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fmRip2IfConfEntry.setDescription('An entry of fmRip2IfConfTable.')
fmRip2IfConfAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 17, 3, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmRip2IfConfAddress.setStatus('mandatory')
if mibBuilder.loadTexts: fmRip2IfConfAddress.setDescription('RIP2 Interface Conf Ip Address. The IP Address of this system on the indicated subnet.')
fmRip2IfConfDomain = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 17, 3, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmRip2IfConfDomain.setStatus('mandatory')
if mibBuilder.loadTexts: fmRip2IfConfDomain.setDescription('RIP2 Interface Conf Domain. Value inserted into the Routing Domain field of all RIP packets sent on this interface.')
fmRip2IfConfAuthType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 17, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noAuthentication", 1), ("simplePassword", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmRip2IfConfAuthType.setStatus('mandatory')
if mibBuilder.loadTexts: fmRip2IfConfAuthType.setDescription('RIP2 Interface Conf Authentiction Type. The type of Authentication used on this interface.')
fmRip2IfConfAuthKey = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 17, 3, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmRip2IfConfAuthKey.setStatus('mandatory')
if mibBuilder.loadTexts: fmRip2IfConfAuthKey.setDescription('RIP2 Interface Conf Authentication Key. The value to be used as the Authentication Key whenever the corresponding instance of rip2IfConfAuthType has the value simplePassword. A modification of the corresponding instance of rip2IfConfAuthType does not modify the rip2IfConfAuthKey value. If a string shorter than 16 octets is supplied, it will be left-justified and padded to 16 octets, on the right, with nulls (0x00). Reading this object always results in an OCTET STRING of length zero; authentication may not be bypassed by reading the MIB object.')
fmRip2IfConfSend = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 17, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("doNotSend", 1), ("ripVersion1", 2), ("rip1Compatible", 3), ("ripVersion2", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmRip2IfConfSend.setStatus('mandatory')
if mibBuilder.loadTexts: fmRip2IfConfSend.setDescription('RIP2 Interface Conf Send. What the router sends on this interface. ripVersion1 implies sending RIP updates compliant with RFC 1058. rip1Compatible implies broadcasting RIP-2 updates using RFC 1058 route subsumption rules. ripVersion2 implies multicasting RIP-2 updates.')
fmRip2IfConfReceive = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 17, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("rip1", 1), ("rip2", 2), ("rip1OrRip2", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmRip2IfConfReceive.setStatus('mandatory')
if mibBuilder.loadTexts: fmRip2IfConfReceive.setDescription('RIP2 Interface Conf Receive. This indicates which version of RIP updates are to be accepted. Note that rip2 and rip1OrRip2 implies reception of multicast packets.')
fmRip2IfConfDefaultMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 17, 3, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmRip2IfConfDefaultMetric.setStatus('mandatory')
if mibBuilder.loadTexts: fmRip2IfConfDefaultMetric.setDescription('RIP2 Interface Conf Default Metric. This variable indicates what metric is to be used as a default route in RIP updates originated on this interface. A value of zero indicates that no default route should be originated; in this case, a default route via another router may be propagated.')
fmRip2IfConfStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 17, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmRip2IfConfStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fmRip2IfConfStatus.setDescription('RIP2 Interface Conf Status. Writing invalid has the effect of deleting this interface.')
fmRip2PeerTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 10, 17, 4), )
if mibBuilder.loadTexts: fmRip2PeerTable.setStatus('mandatory')
if mibBuilder.loadTexts: fmRip2PeerTable.setDescription('A list of RIP Peers.')
fmRip2PeerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 10, 17, 4, 1), ).setIndexNames((0, "PCE-MIB", "fmRip2PeerAddress"), (0, "PCE-MIB", "fmRip2PeerDomain"))
if mibBuilder.loadTexts: fmRip2PeerEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fmRip2PeerEntry.setDescription('An entry of fmRip2PeerTable.')
fmRip2PeerAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 17, 4, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmRip2PeerAddress.setStatus('mandatory')
if mibBuilder.loadTexts: fmRip2PeerAddress.setDescription('RIP2 Peer Ip Address. The IP Address of the Peer System.')
fmRip2PeerDomain = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 17, 4, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmRip2PeerDomain.setStatus('mandatory')
if mibBuilder.loadTexts: fmRip2PeerDomain.setDescription('RIP2 Peer Domain. The value in the Routing Domain field in RIP packets received from the peer ')
fmRip2PeerLastUpdate = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 17, 4, 1, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmRip2PeerLastUpdate.setStatus('mandatory')
if mibBuilder.loadTexts: fmRip2PeerLastUpdate.setDescription('RIP2 Peer Last Update. The value of sysUpTime when the most recent RIP update was received from this system.')
fmRip2PeerVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 17, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmRip2PeerVersion.setStatus('mandatory')
if mibBuilder.loadTexts: fmRip2PeerVersion.setDescription('RIP2 Peer Version. The RIP version number in the header of the last RIP packet received.')
fmRip2PeerRcvBadPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 17, 4, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmRip2PeerRcvBadPackets.setStatus('mandatory')
if mibBuilder.loadTexts: fmRip2PeerRcvBadPackets.setDescription('RIP2 Peer Received Bad Packets. The number of RIP response packets from this peer discarded as invalid. ')
fmRip2PeerRcvBadRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 17, 4, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmRip2PeerRcvBadRoutes.setStatus('mandatory')
if mibBuilder.loadTexts: fmRip2PeerRcvBadRoutes.setDescription('RIP2 Peer Received Bad Routes. The number of routes from this peer that were ignored because the entry format was invalid.')
fmOspf = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 10, 18))
fmOspfStandard = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1))
fmOspfStandardGeneralGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 1))
fmOspfStandardRouterId = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardRouterId.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardRouterId.setDescription("OSPF Router Id. A 32-bit integer uniquely identifying the router in the Autonomous System. By convention, to ensure uniqueness, this should default to the value of one of the router's IP interface addresses.")
fmOspfStandardAdminStat = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardAdminStat.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardAdminStat.setDescription("OSPF Administrative Status. The administrative status of OSPF in the router. The value 'enabled' denotes that the OSPF Process is active on at least one interface; 'disabled' disables it on all interfaces.")
fmOspfStandardVersionNumber = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("version1", 1), ("version2", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardVersionNumber.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardVersionNumber.setDescription('OSPF Version Number. The current version number of the OSPF protocol is 2.')
fmOspfStandardAreaBdrRtrStatus = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardAreaBdrRtrStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardAreaBdrRtrStatus.setDescription('OSPF Area Border Router Status. A flag to note whether this router is an area border router.')
fmOspfStandardASBdrRtrStatus = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardASBdrRtrStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardASBdrRtrStatus.setDescription('OSPF AS Border Router Status A flag to note whether this router is an Autonomous System border router.')
fmOspfStandardExternLSACount = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardExternLSACount.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardExternLSACount.setDescription('OSPF Extern LSA Count. The number of external (LS type 5) link-state advertisements in the link-state database.')
fmOspfStandardExternLSACksumSum = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardExternLSACksumSum.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardExternLSACksumSum.setDescription("OSPF Extern LSA Checksum. The 32-bit unsigned sum of the LS checksums of the external link-state advertisements contained in the link-state database. This sum can be used to determine if there has been a change in a router's link state database, and to compare the link-state database of two routers.")
fmOspfStandardTOSSupport = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardTOSSupport.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardTOSSupport.setDescription("OSPF TOS Support. The router's support for type-of-service routing.")
fmOspfStandardOriginateNewLSAs = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardOriginateNewLSAs.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardOriginateNewLSAs.setDescription('OSPF Originate New LSAs. The number of new link-state advertisements that have been originated. This number is incremented each time the router originates a new LSA.')
fmOspfStandardRxNewLSAs = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardRxNewLSAs.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardRxNewLSAs.setDescription('OSPF Receive New LSAs. The number of link-state advertisements received determined to be new instantiations. This number does not include newer instantiations of self-originated link-state advertisements. ')
fmOspfStandardAreaTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 2), )
if mibBuilder.loadTexts: fmOspfStandardAreaTable.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardAreaTable.setDescription("Information describing the configured parameters and cumulative statistics of the router's attached areas.")
fmOspfStandardAreaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 2, 1), ).setIndexNames((0, "PCE-MIB", "fmOspfStandardAreaId"))
if mibBuilder.loadTexts: fmOspfStandardAreaEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardAreaEntry.setDescription('An entry of fmOspfStandardAreaTable.')
fmOspfStandardAreaId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 2, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardAreaId.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardAreaId.setDescription('OSPF Area Id. A 32-bit integer uniquely identifying an area. Area ID 0.0.0.0 is used for the OSPF backbone.')
fmOspfStandardAuthType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardAuthType.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardAuthType.setDescription('OSPF Area Authentication Type. The authentication type specified for an area. Additional authentication types may be assigned locally on a per Area basis.')
fmOspfStandardImportASExtern = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardImportASExtern.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardImportASExtern.setDescription("OSPF Area Import AS Extern. The area's support for importing AS external link-state advertisements.")
fmOspfStandardSpfRuns = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardSpfRuns.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardSpfRuns.setDescription("OSPF Area SPF Runs. The number of times that the intra-area route table has been calculated using this area's link-state database. This is typically done using Dijkstra's algorithm.")
fmOspfStandardAreaBdrRtrCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 2, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardAreaBdrRtrCount.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardAreaBdrRtrCount.setDescription('OSPF Area Border Router Count. The total number of area border routers reachable within this area. This is initially zero, and is calculated in each SPF Pass.')
fmOspfStandardASBdrRtrCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 2, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardASBdrRtrCount.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardASBdrRtrCount.setDescription('OSPF Area AS Border Router Count. The total number of Autonomous System border routers reachable within this area. This is initially zero, and is calculated in each SPF Pass.')
fmOspfStandardAreaLSACount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 2, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardAreaLSACount.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardAreaLSACount.setDescription("OSPF Area LSA Count. The total number of link-state advertisements in this area's link-state database, excluding AS External LSA's.")
fmOspfStandardAreaLSACksumSum = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardAreaLSACksumSum.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardAreaLSACksumSum.setDescription("OSPF Area LSA Checksum Sum. The 32-bit unsigned sum of the link-state advertisements' LS checksums contained in this area's link-state database. This sum excludes external (LS type 5) link-state advertisements. The sum can be used to determine if there has been a change in a router's link state database, and to compare the link-state database of two routers.")
fmOspfStandardStubAreaTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 3), )
if mibBuilder.loadTexts: fmOspfStandardStubAreaTable.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardStubAreaTable.setDescription('The set of metrics that will be advertised by a default Area Border Router into a stub area')
fmOspfStandardStubAreaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 3, 1), ).setIndexNames((0, "PCE-MIB", "fmOspfStandardStubAreaID"), (0, "PCE-MIB", "fmOspfStandardStubTOS"))
if mibBuilder.loadTexts: fmOspfStandardStubAreaEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardStubAreaEntry.setDescription('An entry of fmOspfStandardStubAreaTable.')
fmOspfStandardStubAreaID = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 3, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardStubAreaID.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardStubAreaID.setDescription('OSPF Stub Area Id. The 32 bit identifier for the Stub Area. On creation, this can be derived from the instance. ')
fmOspfStandardStubTOS = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardStubTOS.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardStubTOS.setDescription('OSPF Stub Area TOS. The Type of Service associated with the metric. On creation, this can be derived from the instance.')
fmOspfStandardStubMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardStubMetric.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardStubMetric.setDescription('OSPF Stub Area Metric. The metric value applied at the indicated type of service. By default, this equals the least metric at the type of service among the interfaces to other areas.')
fmOspfStandardStubStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardStubStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardStubStatus.setDescription("OSPF Stub Area Status. This variable displays the validity or invalidity of the entry. Setting it to 'invalid' has the effect of rendering it inoperative. The internal effect (row removal) is implementation dependent .")
fmOspfStandardLsdbTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 4), )
if mibBuilder.loadTexts: fmOspfStandardLsdbTable.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardLsdbTable.setDescription("The OSPF Process's Links State Database.")
fmOspfStandardLsdbEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 4, 1), ).setIndexNames((0, "PCE-MIB", "fmOspfStandardLsdbAreaId"), (0, "PCE-MIB", "fmOspfStandardLsdbType"))
if mibBuilder.loadTexts: fmOspfStandardLsdbEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardLsdbEntry.setDescription('An entry of fmOspfStandardLsdbTable.')
fmOspfStandardLsdbAreaId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 4, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardLsdbAreaId.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardLsdbAreaId.setDescription("OSPF Link State Database Area Id The OSPF Process's Links State Database.")
fmOspfStandardLsdbType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("routerLink", 1), ("networkLink", 2), ("summaryLink", 3), ("asSummaryLink", 4), ("asExternalLink", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardLsdbType.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardLsdbType.setDescription('OSPF Link State Database LS Type. The type of the link state advertisement. Each link state type has a separate advertisement format. ')
fmOspfStandardLsdbLSID = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 4, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardLsdbLSID.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardLsdbLSID.setDescription('OSPF Link State Database LS Id. The Link State ID is an LS Type Specific field containing either a Router ID or an IP Address; it identifies the piece of the routing domain that is being described by the advertisement.')
fmOspfStandardLsdbRouterId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 4, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardLsdbRouterId.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardLsdbRouterId.setDescription('OSPF Link State Database Router Id. The 32 bit number that uniquely identifies the originating router in the Autonomous System. ')
fmOspfStandardLsdbSequence = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 4, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardLsdbSequence.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardLsdbSequence.setDescription('OSPF Link State Database Sequence. The sequence number field is a signed 32-bit integer. It is used to detect old and duplicate link state advertisements. The space of sequence numbers is linearly ordered. The larger the sequence number the more recent the advertisement.')
fmOspfStandardLsdbAge = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 4, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardLsdbAge.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardLsdbAge.setDescription('OSPF Link State Database Age. This field is the age of the link state advertisement in seconds. ')
fmOspfStandardLsdbChecksum = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 4, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardLsdbChecksum.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardLsdbChecksum.setDescription("OSPF Link State Database Checksum. This field is the checksum of the complete contents of the advertisement, excepting the age field. The age field is excepted so that an advertisement's age can be incremented without updating the checksum. The checksum used is the same that is used for ISO connectionless datagrams; it is commonly referred to as the Fletcher checksum. ")
fmOspfStandardLsdbAdvertisement = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 4, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardLsdbAdvertisement.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardLsdbAdvertisement.setDescription('OSPF Link State Database Advertisement. The entire Link State Advertisement, including its header. ')
fmOspfStandardAreaRangeTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 5), )
if mibBuilder.loadTexts: fmOspfStandardAreaRangeTable.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardAreaRangeTable.setDescription('A range if IP addresses specified by an IP address/IP network mask pair. For example, class B address range of X.X.X.X with a network mask of 255.255.0.0 includes all IP addresses from X.X.0.0 to X.X.255.255.')
fmOspfStandardAreaRangeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 5, 1), ).setIndexNames((0, "PCE-MIB", "fmOspfStandardAreaRangeAreaID"), (0, "PCE-MIB", "fmOspfStandardAreaRangeNet"))
if mibBuilder.loadTexts: fmOspfStandardAreaRangeEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardAreaRangeEntry.setDescription('An entry of fmOspfStandardAreaRangeTable.')
fmOspfStandardAreaRangeAreaID = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 5, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardAreaRangeAreaID.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardAreaRangeAreaID.setDescription('OSPF Area Range Area Id. The Area the Address Range is to be found within.')
fmOspfStandardAreaRangeNet = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 5, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardAreaRangeNet.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardAreaRangeNet.setDescription('OSPF Area Range Net. The IP Address of the Net or Subnet indicated by the range.')
fmOspfStandardAreaRangeMask = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 5, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardAreaRangeMask.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardAreaRangeMask.setDescription('OSPF Area Range Mask. The Subnet Mask that pertains to the Net or Subnet.')
fmOspfStandardAreaRangeStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 5, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardAreaRangeStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardAreaRangeStatus.setDescription("OSPF Area Range Status. This variable displays the validity or invalidity of the entry. Setting it to 'invalid' has the effect of rendering it inoperative. The internal effect (row removal) is implementation dependent.")
fmOspfStandardHostTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 6), )
if mibBuilder.loadTexts: fmOspfStandardHostTable.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardHostTable.setDescription('The list of Hosts, and their metrics, that the router will advertise as host routes.')
fmOspfStandardHostEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 6, 1), ).setIndexNames((0, "PCE-MIB", "fmOspfStandardHostIpAddress"), (0, "PCE-MIB", "fmOspfStandardHostTOS"))
if mibBuilder.loadTexts: fmOspfStandardHostEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardHostEntry.setDescription('An entry of fmOspfStandardHostTable.')
fmOspfStandardHostIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 6, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardHostIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardHostIpAddress.setDescription('OSPF Host Ip Address. The IP Address of the Host.')
fmOspfStandardHostTOS = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 6, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardHostTOS.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardHostTOS.setDescription('OSPF Host TOS. The Type of Service of the route being configured.')
fmOspfStandardHostMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 6, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardHostMetric.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardHostMetric.setDescription('OSPF Host Metric. The Metric to be advertised.')
fmOspfStandardHostStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 6, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardHostStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardHostStatus.setDescription("OSPF Host Status. This variable displays the validity or invalidity of the entry. Setting it to 'invalid' has the effect of rendering it inoperative. The internal effect (row removal) is implementation dependent.")
fmOspfStandardIfTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 7), )
if mibBuilder.loadTexts: fmOspfStandardIfTable.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardIfTable.setDescription('The OSPF Interface Table describes the interfaces from the viewpoint of OSPF.')
fmOspfStandardIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 7, 1), ).setIndexNames((0, "PCE-MIB", "fmOspfStandardIfIpAddress"), (0, "PCE-MIB", "fmOspfStandardAddressLessIf"))
if mibBuilder.loadTexts: fmOspfStandardIfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardIfEntry.setDescription('An entry of fmOspfStandardIfTable.')
fmOspfStandardIfIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 7, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardIfIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardIfIpAddress.setDescription('OSPF Interface Ip Address. The IP address of this OSPF interface.')
fmOspfStandardAddressLessIf = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 7, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardAddressLessIf.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardAddressLessIf.setDescription('OSPF Interface Address Less If. For the purpose of easing the instancing of addressed and addressless interfaces; This variable takes the value 0 on interfaces with IP Addresses, and the corresponding value of ifIndex for interfaces having no IP Address.')
fmOspfStandardIfAreaId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 7, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardIfAreaId.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardIfAreaId.setDescription('OSPF Interface Area Id. A 32-bit integer uniquely identifying the area to which the interface connects. Area ID 0.0.0.0 is used for the OSPF backbone.')
fmOspfStandardIfType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 7, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("broadcast", 1), ("nbma", 2), ("pointToPoint", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardIfType.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardIfType.setDescription("OSPF Interface Type. The OSPF interface type. By way of a default, this field may be intuited from the corresponding value of ifType. Broadcast LANs, such as Ethernet and IEEE 802.5, take the value 'broadcast', X.25, Frame Relay, and similar technologies take the value 'nbma', and links that are definitively point to point take the value 'pointToPoint'")
fmOspfStandardIfAdminStat = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 7, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardIfAdminStat.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardIfAdminStat.setDescription("OSPF Interface Administrative Status. The OSPF interface's administrative status. The value 'enabled' denotes that neighbor relationships may be formed on the interface, and the interface will be advertised as an internal route to some area. The value 'disabled' denotes that the interface is external to OSPF.")
fmOspfStandardIfRtrPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 7, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardIfRtrPriority.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardIfRtrPriority.setDescription('OSPF Interface Router Priority. The priority of this interface. Used in multi-access networks, this field is used in the designated router election algorithm. The value 0 signifies that the router is not eligible to become the designated router on this particular network. In the event of a tie in this value, routers will use their router id as a tie breaker')
fmOspfStandardIfTransitDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 7, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardIfTransitDelay.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardIfTransitDelay.setDescription('OSPF Interface Transit Delay. The estimated number of seconds it takes to transmit a link- state update packet over this interface.')
fmOspfStandardIfRetransInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 7, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardIfRetransInterval.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardIfRetransInterval.setDescription('OSPF Interface Retransmit Interval. The number of seconds between link-state advertisement retransmissions, for adjacencies belonging to this interface. This value is also used when retransmitting database description and link-state request packets.')
fmOspfStandardIfHelloInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 7, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardIfHelloInterval.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardIfHelloInterval.setDescription('OSPF Interface Hello Interval. The length of time, in seconds, between the Hello packets that the router sends on the interface. This value must be the same for all routers attached to a common network.')
fmOspfStandardIfRtrDeadInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 7, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardIfRtrDeadInterval.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardIfRtrDeadInterval.setDescription("OSPF Interface Dead Interval. The number of seconds that a router's Hello packets have not been seen before it's neighbors declare the router down. This should be some multiple of the Hello interval. This value must be the same for all routers attached to a common network.")
fmOspfStandardIfPollInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 7, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardIfPollInterval.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardIfPollInterval.setDescription('OSPF Interface Poll Interval. The larger time interval, in seconds, between the Hello packets sent to an inactive non-broadcast multi- access neighbor.')
fmOspfStandardIfState = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 7, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("down", 1), ("loopback", 2), ("waiting", 3), ("pointToPoint", 4), ("designatedRouter", 5), ("backupDesignatedRouter", 6), ("otherDesignatedRouter", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardIfState.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardIfState.setDescription('OSPF Interface State. The OSPF Interface State.')
fmOspfStandardIfDesignatedRouter = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 7, 1, 13), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardIfDesignatedRouter.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardIfDesignatedRouter.setDescription('OSPF Interface Designated Router. The IP Address of the Designated Router.')
fmOspfStandardIfBackupDesignatedRouter = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 7, 1, 14), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardIfBackupDesignatedRouter.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardIfBackupDesignatedRouter.setDescription('OSPF Interface Backup Designated Router. The IP Address of the Backup Designated Router. ')
fmOspfStandardIfEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 7, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardIfEvents.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardIfEvents.setDescription('OSPF Interface Events. The number of times this OSPF interface has changed its state, or an error has occurred. ')
fmOspfStandardIfAuthKey = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 7, 1, 16), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardIfAuthKey.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardIfAuthKey.setDescription("OSPF Interface Authentication Key. The Authentication Key. If the Area's Authorization Type is simplePassword, and the key length is shorter than 8 octets, the agent will left adjust and zero fill to 8 octets. When read, it always returns an Octet String of length zero.")
fmOspfStandardIfMetricTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 8), )
if mibBuilder.loadTexts: fmOspfStandardIfMetricTable.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardIfMetricTable.setDescription('The TOS metrics for a non-virtual interface identified by the interface index.')
fmOspfStandardIfMetricEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 8, 1), ).setIndexNames((0, "PCE-MIB", "fmOspfStandardIfMetricIpAddress"), (0, "PCE-MIB", "fmOspfStandardIfMetricAddressLessIf"), (0, "PCE-MIB", "fmOspfStandardIfMetricTOS"))
if mibBuilder.loadTexts: fmOspfStandardIfMetricEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardIfMetricEntry.setDescription('An entry of fmOspfStandardIfMetricTable.')
fmOspfStandardIfMetricIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 8, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardIfMetricIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardIfMetricIpAddress.setDescription('OSPF Interface Metric Ip Address. The IP address of this OSPF interface. On row creation, this can be derived from the instance.')
fmOspfStandardIfMetricAddressLessIf = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 8, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardIfMetricAddressLessIf.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardIfMetricAddressLessIf.setDescription('OSPF Interface Metric Address Less If. For the purpose of easing the instancing of addressed and addressless interfaces; This variable takes the value 0 on interfaces with IP Addresses, and the value of ifIndex for interfaces having no IP Address. On row creation, this can be derived from the instance.')
fmOspfStandardIfMetricTOS = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 8, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardIfMetricTOS.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardIfMetricTOS.setDescription('OSPF Interface Metric TOS. The type of service metric being referenced. On row creation, this can be derived from the instance.')
fmOspfStandardIfMetricMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 8, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardIfMetricMetric.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardIfMetricMetric.setDescription("OSPF Interface Metric Metric. The metric of using this type of service on this interface. The default value of the TOS 0 Metric is 10^8 / ifSpeed. The value FFFF is distinguished to mean 'no route via this TOS.")
fmOspfStandardIfMetricStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 8, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardIfMetricStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardIfMetricStatus.setDescription("ID FMSIPOSPF Interface Metric Status. This variable displays the validity or invalidity of the entry. Setting it to 'invalid' has the effect of rendering it inoperative. he internal effect (row removal) is implementation dependent.")
fmOspfStandardVirtIfTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 9), )
if mibBuilder.loadTexts: fmOspfStandardVirtIfTable.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardVirtIfTable.setDescription("Information about this router's virtual interfaces.")
fmOspfStandardVirtIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 9, 1), ).setIndexNames((0, "PCE-MIB", "fmOspfStandardVirtIfAreaID"), (0, "PCE-MIB", "fmOspfStandardVirtIfNeighbor"))
if mibBuilder.loadTexts: fmOspfStandardVirtIfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardVirtIfEntry.setDescription('An entry of fmOspfStandardVirtIfTable.')
fmOspfStandardVirtIfAreaID = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 9, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardVirtIfAreaID.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardVirtIfAreaID.setDescription('OSPF Virtual Interface Area ID. The Transit Area that the Virtual Link traverses. By definition, this is not 0.0.0.0')
fmOspfStandardVirtIfNeighbor = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 9, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardVirtIfNeighbor.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardVirtIfNeighbor.setDescription('OSPF Virtual Interface Neighbor. The Router ID of the Virtual Neighbor.')
fmOspfStandardVirtIfTransitDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 9, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardVirtIfTransitDelay.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardVirtIfTransitDelay.setDescription('OSPF Virtual Interface Transit Delay. The estimated number of seconds it takes to transmit a link- state update packet over this interface.')
fmOspfStandardVirtIfRetransInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 9, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardVirtIfRetransInterval.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardVirtIfRetransInterval.setDescription('OSPF Virtual Interface Retransmit Interval. The number of seconds between link-state advertisement retransmissions, for adjacencies belonging to this interface. This value is also used when retransmitting database description and link-state request packets. This value should be well over the expected round-trip time.')
fmOspfStandardVirtIfHelloInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 9, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardVirtIfHelloInterval.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardVirtIfHelloInterval.setDescription('OSPF Virtual Interface Hello Interval. The length of time, in seconds, between the Hello packets that the router sends on the interface. This value must be the same for the virtual neighbor.')
fmOspfStandardVirtIfRtrDeadInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 9, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardVirtIfRtrDeadInterval.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardVirtIfRtrDeadInterval.setDescription("OSPF Virtual Interface Router Dead Interval. The number of seconds that a router's Hello packets have not been seen before it's neighbors declare the router down. This should be some multiple of the Hello interval. This value must be the same for the virtual neighbor.")
fmOspfStandardVirtIfState = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 9, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4))).clone(namedValues=NamedValues(("down", 1), ("pointToPoint", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardVirtIfState.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardVirtIfState.setDescription('OSPF Virtual Interface State. OSPF virtual interface states.')
fmOspfStandardVirtIfEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 9, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardVirtIfEvents.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardVirtIfEvents.setDescription('OSPF Virtual Interface Events. The number of state changes or error events on this Virtual Link.')
fmOspfStandardVirtIfAuthKey = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 9, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardVirtIfAuthKey.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardVirtIfAuthKey.setDescription('OSPF Virtual Interface Authentication Type. If Authentication Type is simplePassword, the device will left adjust and zero fill to 8 octets. When read, ospfVifAuthKey always returns a string of length zero.')
fmOspfStandardVirtIfStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 9, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardVirtIfStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardVirtIfStatus.setDescription("OSPF Virtual Interface Status. This variable displays the validity or invalidity of the entry. Setting it to 'invalid' has the effect of rendering it inoperative. The internal effect (row removal) is implementation dependent.")
fmOspfStandardNbrTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 10), )
if mibBuilder.loadTexts: fmOspfStandardNbrTable.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardNbrTable.setDescription('A table of non-virtual neighbor information.')
fmOspfStandardNbrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 10, 1), ).setIndexNames((0, "PCE-MIB", "fmOspfStandardNbrIpAddress"), (0, "PCE-MIB", "fmOspfStandardNbrAddressLessIndex"))
if mibBuilder.loadTexts: fmOspfStandardNbrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardNbrEntry.setDescription('An entry of fmOspfStandardNbrTable.')
fmOspfStandardNbrIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 10, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardNbrIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardNbrIpAddress.setDescription('OSPF Neighbor Ip Address. The IP address of this neighbor.')
fmOspfStandardNbrAddressLessIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 10, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardNbrAddressLessIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardNbrAddressLessIndex.setDescription('OSPF Neighbor Address Less Index. On an interface having an IP Address, zero. On addressless interfaces, the corresponding value of ifIndex in the Internet Standard MIB. On row creation, this can be derived from the instance.')
fmOspfStandardNbrRtrId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 10, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardNbrRtrId.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardNbrRtrId.setDescription('OSPF Neighbor Router Id. A 32-bit integer (represented as a type IpAddress) uniquely identifying the neighboring router in the Autonomous System.')
fmOspfStandardNbrOptions = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 10, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardNbrOptions.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardNbrOptions.setDescription("OSPF Neighbor Options. A Bit Mask corresponding to the neighbor's options field. Bit 0, if set, indicates that the area accepts and operates on external information; if zero, it is a stub area. Bit 1, if set, indicates that the system will operate on Type of Service metrics other than TOS 0. If zero, the neighbor will ignore all metrics except the TOS 0 metric.")
fmOspfStandardNbrPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 10, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardNbrPriority.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardNbrPriority.setDescription('OSPF Neighbor Priority. The priority of this neighbor in the designated router election algorithm. The value 0 signifies that the neighbor is not eligible to become the designated router on this particular network. ')
fmOspfStandardNbrState = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("down", 1), ("attempt", 2), ("init", 3), ("twoWay", 4), ("exchangeStart", 5), ("exchange", 6), ("loading", 7), ("full", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardNbrState.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardNbrState.setDescription('OSPF Neighbor State. The State of the relationship with this Neighbor.')
fmOspfStandardNbrEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 10, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardNbrEvents.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardNbrEvents.setDescription('OSPF Neighbor Events. The number of times this neighbor relationship has changed state, or an error has occurred.')
fmOspfStandardNbrLSRetransQLen = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 10, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardNbrLSRetransQLen.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardNbrLSRetransQLen.setDescription('OSPF Neighbor LS Retransmit Queue Length. The current length of the retransmission queue. ')
fmOspfStandardNBMANbrStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 10, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardNBMANbrStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardNBMANbrStatus.setDescription("OSPF Neighbor Status. This variable displays the validity or invalidity of the entry. Setting it to 'invalid' has the effect of rendering it inoperative. The internal effect (row removal) is implementation dependent. ")
fmOspfStandardVirtNbrTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 11), )
if mibBuilder.loadTexts: fmOspfStandardVirtNbrTable.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardVirtNbrTable.setDescription('A table of virtual neighbor information.')
fmOspfStandardVirtNbrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 11, 1), ).setIndexNames((0, "PCE-MIB", "fmOspfStandardVirtNbrArea"), (0, "PCE-MIB", "fmOspfStandardVirtNbrRtrId"))
if mibBuilder.loadTexts: fmOspfStandardVirtNbrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardVirtNbrEntry.setDescription('An entry of fmOspfStandardVirtNbrTable.')
fmOspfStandardVirtNbrArea = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 11, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardVirtNbrArea.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardVirtNbrArea.setDescription('OSPF Virtual Neighbor Area. The Transit Area Identifier.')
fmOspfStandardVirtNbrRtrId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 11, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardVirtNbrRtrId.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardVirtNbrRtrId.setDescription('OSPF Virtual Neighbor Router Id. A 32-bit integer uniquely identifying the neighboring router in the Autonomous System.')
fmOspfStandardVirtNbrIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 11, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardVirtNbrIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardVirtNbrIpAddr.setDescription('OSPF Virtual Neighbor Ip Address. The IP address this Virtual Neighbor is using.')
fmOspfStandardVirtNbrOptions = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 11, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardVirtNbrOptions.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardVirtNbrOptions.setDescription("OSPF Virtual Neighbor Options. A bit map corresponding to the neighbor's options field. Thus, Bit 1, if set, indicates that the neighbor supports Type of Service Routing; if zero, no metrics other than TOS 0 are in use by the neighbor.")
fmOspfStandardVirtNbrState = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 11, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("down", 1), ("attempt", 2), ("init", 3), ("twoWay", 4), ("exchangeStart", 5), ("exchange", 6), ("loading", 7), ("full", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardVirtNbrState.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardVirtNbrState.setDescription('OSPF Virtual Neighbor State. The state of the Virtual Neighbor Relationship.')
fmOspfStandardVirtNbrEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 11, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardVirtNbrEvents.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardVirtNbrEvents.setDescription('OSPF Virtual Neighbor Events. The number of times this virtual link has changed its state, or an error has occurred.')
fmOspfStandardVirtNbrLSRetransQLen = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 18, 1, 11, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmOspfStandardVirtNbrLSRetransQLen.setStatus('mandatory')
if mibBuilder.loadTexts: fmOspfStandardVirtNbrLSRetransQLen.setDescription('OSPF Virtual Neighbor LS Retransmit Queue Length. The current length of the retransmission queue. ')
fmUsersRights = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 10, 20))
fmuVersionRight = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 10, 20, 1))
fmuVersMax = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 20, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmuVersMax.setStatus('mandatory')
if mibBuilder.loadTexts: fmuVersMax.setDescription('Version max autorisee')
fmuLineAccess = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 10, 20, 5))
fmuAccessLineNbMax = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 20, 5, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmuAccessLineNbMax.setStatus('mandatory')
if mibBuilder.loadTexts: fmuAccessLineNbMax.setDescription('Nombre max de lignes autorises')
fmuAccessX25PlsLineNbMax = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 20, 5, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmuAccessX25PlsLineNbMax.setStatus('mandatory')
if mibBuilder.loadTexts: fmuAccessX25PlsLineNbMax.setDescription('Nombre max de lignes X25 PLS')
fmuAccessX25MlpLineNbMax = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 20, 5, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmuAccessX25MlpLineNbMax.setStatus('mandatory')
if mibBuilder.loadTexts: fmuAccessX25MlpLineNbMax.setDescription('Nombre max de lignes X25 MLP')
fmuAccessAsynLineNbMax = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 20, 5, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmuAccessAsynLineNbMax.setStatus('mandatory')
if mibBuilder.loadTexts: fmuAccessAsynLineNbMax.setDescription('Nombre max de lignes Asyn')
fmuAccessVipLineNbMax = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 20, 5, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmuAccessVipLineNbMax.setStatus('mandatory')
if mibBuilder.loadTexts: fmuAccessVipLineNbMax.setDescription('Nombre max de lignes VIP')
fmuAccessSdlcLineNbMax = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 20, 5, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmuAccessSdlcLineNbMax.setStatus('mandatory')
if mibBuilder.loadTexts: fmuAccessSdlcLineNbMax.setDescription('Nombre max de lignes SDLC')
fmuAccessBsc3270LineNbMax = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 20, 5, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmuAccessBsc3270LineNbMax.setStatus('mandatory')
if mibBuilder.loadTexts: fmuAccessBsc3270LineNbMax.setDescription('Nombre max de lignes BSC 3270')
fmuAccessBsc2780LineNbMax = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 20, 5, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmuAccessBsc2780LineNbMax.setStatus('mandatory')
if mibBuilder.loadTexts: fmuAccessBsc2780LineNbMax.setDescription('Nombre max de lignes BSC 2780/3780')
fmuAccessBscTranspLineNbMax = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 20, 5, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmuAccessBscTranspLineNbMax.setStatus('mandatory')
if mibBuilder.loadTexts: fmuAccessBscTranspLineNbMax.setDescription('Nombre max de lignes BSC transparent')
fmuAccessRnisChannelBNbMax = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 20, 5, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmuAccessRnisChannelBNbMax.setStatus('mandatory')
if mibBuilder.loadTexts: fmuAccessRnisChannelBNbMax.setDescription('Nombre de canaux B avec signalisation')
fmuAccessRnisChannelDNbMax = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 20, 5, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmuAccessRnisChannelDNbMax.setStatus('mandatory')
if mibBuilder.loadTexts: fmuAccessRnisChannelDNbMax.setDescription('Nombre de canaux D')
fmuAccessHdlcTranspLineNbMax = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 20, 5, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmuAccessHdlcTranspLineNbMax.setStatus('mandatory')
if mibBuilder.loadTexts: fmuAccessHdlcTranspLineNbMax.setDescription('Nombre de lignes HDLC transparent')
fmuAccessFrSuscribLineNbMax = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 20, 5, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmuAccessFrSuscribLineNbMax.setStatus('mandatory')
if mibBuilder.loadTexts: fmuAccessFrSuscribLineNbMax.setDescription('Nombre de lignes Frame Relay abonne')
fmuAccessFrPublicNetworkLineNbMax = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 20, 5, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmuAccessFrPublicNetworkLineNbMax.setStatus('mandatory')
if mibBuilder.loadTexts: fmuAccessFrPublicNetworkLineNbMax.setDescription('Nombre de lignes Frame Relay parmi FRSE FRTE FRCE')
fmuAccessFrseLineNbMax = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 20, 5, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmuAccessFrseLineNbMax.setStatus('mandatory')
if mibBuilder.loadTexts: fmuAccessFrseLineNbMax.setDescription('Nombre max de lignes FR SE')
fmuAccessX29ReroutLineNbMax = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 20, 5, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmuAccessX29ReroutLineNbMax.setStatus('mandatory')
if mibBuilder.loadTexts: fmuAccessX29ReroutLineNbMax.setDescription('Nombre de lignes avec reroutage X29')
fmuAccessCvfLineNbMax = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 20, 5, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmuAccessCvfLineNbMax.setStatus('mandatory')
if mibBuilder.loadTexts: fmuAccessCvfLineNbMax.setDescription('Nombre de lignes abonnees CVF')
fmuAccessX75LineNbMax = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 20, 5, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmuAccessX75LineNbMax.setStatus('mandatory')
if mibBuilder.loadTexts: fmuAccessX75LineNbMax.setDescription('Nombre max de lignes X75')
fmuAccessPaviLineNbMax = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 20, 5, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmuAccessPaviLineNbMax.setStatus('mandatory')
if mibBuilder.loadTexts: fmuAccessPaviLineNbMax.setDescription('Nombre max de lignes PAVI')
fmuAccessX28PlusLineNbMax = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 20, 5, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmuAccessX28PlusLineNbMax.setStatus('mandatory')
if mibBuilder.loadTexts: fmuAccessX28PlusLineNbMax.setDescription('Nombre max de lignes X28 Plus')
fmuAccessPadLineNbMax = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 20, 5, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmuAccessPadLineNbMax.setStatus('mandatory')
if mibBuilder.loadTexts: fmuAccessPadLineNbMax.setDescription('Nombre max de lignes PAD multinormes')
fmuAccessPppaLineNbMax = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 20, 5, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmuAccessPppaLineNbMax.setStatus('mandatory')
if mibBuilder.loadTexts: fmuAccessPppaLineNbMax.setDescription('Nombre max de lignes PPPA')
fmuAccessPppsLineNbMax = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 20, 5, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmuAccessPppsLineNbMax.setStatus('mandatory')
if mibBuilder.loadTexts: fmuAccessPppsLineNbMax.setDescription('Nombre max de lignes PPPS')
fmuFunctionRight = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 10, 20, 10))
fmuFunctionRouterAndBridge = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 20, 10, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("mcx104-64kbs", 1), ("pont", 2), ("routeurIP", 3), ("pontAndRouteurIP", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmuFunctionRouterAndBridge.setStatus('mandatory')
if mibBuilder.loadTexts: fmuFunctionRouterAndBridge.setDescription('Comlan bridge ou routeur')
fmuFunctionMemTypeForMCXType4 = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 20, 10, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("flash2Mo-ram2Mo", 1), ("flash4Mo-ram2Mo", 2), ("flash2Mo-ram4Mo", 3), ("flash4Mo-ram4Mo", 4), ("obsolete-object", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmuFunctionMemTypeForMCXType4.setStatus('mandatory')
if mibBuilder.loadTexts: fmuFunctionMemTypeForMCXType4.setDescription('Types de memoires (MCX type 4)')
fmuFunctionAccessFrProtoco = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 20, 10, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmuFunctionAccessFrProtoco.setStatus('mandatory')
if mibBuilder.loadTexts: fmuFunctionAccessFrProtoco.setDescription('Autorisation protocoles FRSNA FRIP FRI FRT')
fmuFunctionBridgeAndStp = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 20, 10, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmuFunctionBridgeAndStp.setStatus('mandatory')
if mibBuilder.loadTexts: fmuFunctionBridgeAndStp.setDescription('Fonction Pont et STP')
fmuFunctionIpRouter = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 20, 10, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmuFunctionIpRouter.setStatus('mandatory')
if mibBuilder.loadTexts: fmuFunctionIpRouter.setDescription('Fonction Routeur IP')
fmuFunctionIpxRouter = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 20, 10, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmuFunctionIpxRouter.setStatus('mandatory')
if mibBuilder.loadTexts: fmuFunctionIpxRouter.setDescription('Fonction Routeur IPX')
fmuFunctionClnpRouter = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 20, 10, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmuFunctionClnpRouter.setStatus('mandatory')
if mibBuilder.loadTexts: fmuFunctionClnpRouter.setDescription('Fonction Routeur CLNP')
fmuFunctionLz77Compression = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 20, 10, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmuFunctionLz77Compression.setStatus('mandatory')
if mibBuilder.loadTexts: fmuFunctionLz77Compression.setDescription('Compression LZ77')
fmuFunctionLz78Compression = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 20, 10, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmuFunctionLz78Compression.setStatus('mandatory')
if mibBuilder.loadTexts: fmuFunctionLz78Compression.setDescription('Compression LZ78')
fmuFunctionSecurCard = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 20, 10, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmuFunctionSecurCard.setStatus('mandatory')
if mibBuilder.loadTexts: fmuFunctionSecurCard.setDescription('Droit securise')
fmuFunctionLoadStat = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 20, 10, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmuFunctionLoadStat.setStatus('mandatory')
if mibBuilder.loadTexts: fmuFunctionLoadStat.setDescription('Statistiques de charge')
fmuFunctionOverflowResc = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 20, 10, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmuFunctionOverflowResc.setStatus('mandatory')
if mibBuilder.loadTexts: fmuFunctionOverflowResc.setDescription('Secours-debordement')
fmuFunctionPae = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 20, 10, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmuFunctionPae.setStatus('mandatory')
if mibBuilder.loadTexts: fmuFunctionPae.setDescription('PAE')
fmuFunctionOnlineFileTransfer = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 20, 10, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmuFunctionOnlineFileTransfer.setStatus('mandatory')
if mibBuilder.loadTexts: fmuFunctionOnlineFileTransfer.setDescription('Transfert de fichiers on line')
fmuFunctionDPacket = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 20, 10, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmuFunctionDPacket.setStatus('mandatory')
if mibBuilder.loadTexts: fmuFunctionDPacket.setDescription('Paquet dans D')
fmuFunctionExploitMibUse = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 20, 10, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmuFunctionExploitMibUse.setStatus('mandatory')
if mibBuilder.loadTexts: fmuFunctionExploitMibUse.setDescription("Droits d'utilisation de la MIB exploitation")
fmuFunctionLlcOnEthernet = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 20, 10, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmuFunctionLlcOnEthernet.setStatus('mandatory')
if mibBuilder.loadTexts: fmuFunctionLlcOnEthernet.setDescription('Autorisation LLC sur Ethernet')
fmHardwareId = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 10, 25))
fmhTechnicalsFeatures = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 10, 25, 1))
fmhTechnicEquipmType = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 25, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("lmx506-type1", 1), ("mcx104", 2), ("lmx506-3", 3), ("mcx-type1", 4), ("mcx-type2", 5), ("lmx506-type2", 6), ("mcx300B", 7), ("mcx300H", 8), ("cmd-chd", 9), ("frx-msb2-1", 10), ("frx-msb2-s2", 11), ("vpb", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmhTechnicEquipmType.setStatus('mandatory')
if mibBuilder.loadTexts: fmhTechnicEquipmType.setDescription('Type de machine')
fmhTechnicLineNb = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 25, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(3, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmhTechnicLineNb.setStatus('mandatory')
if mibBuilder.loadTexts: fmhTechnicLineNb.setDescription('Nombre de lignes')
fmhTechnicPromFlashSize = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 25, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21))).clone(namedValues=NamedValues(("flash-512K", 1), ("flash-768K", 2), ("flash-1M", 3), ("flash-1M256", 4), ("flash-1M512", 5), ("flash-1M768", 6), ("flash-2M", 7), ("flash-2M256", 8), ("flash-2M512", 9), ("flash-2M768", 10), ("flash-3M", 11), ("flash-3M256", 12), ("flash-3M512", 13), ("flash-3M768", 14), ("flash-4M", 15), ("flash-6M", 16), ("flash-8M", 17), ("flash-10M", 18), ("flash-12M", 19), ("flash-14M", 20), ("flash-16M", 21)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmhTechnicPromFlashSize.setStatus('mandatory')
if mibBuilder.loadTexts: fmhTechnicPromFlashSize.setDescription('Taille de la PROM Flash')
fmhTechnicRamSize = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 25, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("ram-512K", 1), ("ram-1M", 2), ("ram-1M512", 3), ("ram-2M", 4), ("ram-4M", 5), ("ram-8M", 6), ("ram-16M", 7), ("ram-32M", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmhTechnicRamSize.setStatus('mandatory')
if mibBuilder.loadTexts: fmhTechnicRamSize.setDescription('Taille de la RAM')
fmhTechnicEepromSize = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 25, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("eeprom-32K", 1), ("eeprom-64K", 2), ("eeprom-128K", 3), ("eeprom-256K", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmhTechnicEepromSize.setStatus('mandatory')
if mibBuilder.loadTexts: fmhTechnicEepromSize.setDescription("Taille de l'EEPROM")
fmhTechnicTransputerPresence = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 25, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notpresent", 1), ("present", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmhTechnicTransputerPresence.setStatus('mandatory')
if mibBuilder.loadTexts: fmhTechnicTransputerPresence.setDescription('Presence Transputer')
fmhTechnicEthernetPresence = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 25, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notpresent", 1), ("present", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmhTechnicEthernetPresence.setStatus('mandatory')
if mibBuilder.loadTexts: fmhTechnicEthernetPresence.setDescription('Presence Ethernet')
fmhTechnicTokenRingPresence = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 25, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notpresent", 1), ("present", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmhTechnicTokenRingPresence.setStatus('mandatory')
if mibBuilder.loadTexts: fmhTechnicTokenRingPresence.setDescription('Presence Token Ring')
fmhTechnicMacAdress = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 25, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmhTechnicMacAdress.setStatus('mandatory')
if mibBuilder.loadTexts: fmhTechnicMacAdress.setDescription('Adresse MAC')
fmhEquipmentId = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 10, 25, 5))
fmhEqIdReference = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 25, 5, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmhEqIdReference.setStatus('mandatory')
if mibBuilder.loadTexts: fmhEqIdReference.setDescription("Reference de l'equipement")
fmhEqIdSerialNbEncodingType = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 25, 5, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("bcd", 1), ("hexa", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmhEqIdSerialNbEncodingType.setStatus('mandatory')
if mibBuilder.loadTexts: fmhEqIdSerialNbEncodingType.setDescription("Type de codage du numero de serie de l'equipement")
fmhEqIdSerialNb = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 25, 5, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmhEqIdSerialNb.setStatus('mandatory')
if mibBuilder.loadTexts: fmhEqIdSerialNb.setDescription("Numero de serie de l'equipement")
fmhEqIdFactoryReleaseDate = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 25, 5, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(3, 3)).setFixedLength(3)).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmhEqIdFactoryReleaseDate.setStatus('mandatory')
if mibBuilder.loadTexts: fmhEqIdFactoryReleaseDate.setDescription("Date de sortie d'usine")
fmhEqIdFirstFactoryReturnDate = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 25, 5, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(3, 3)).setFixedLength(3)).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmhEqIdFirstFactoryReturnDate.setStatus('mandatory')
if mibBuilder.loadTexts: fmhEqIdFirstFactoryReturnDate.setDescription('Premiere date de retour usine')
fmhEqIdSecondFactoryReturnDate = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 25, 5, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(3, 3)).setFixedLength(3)).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmhEqIdSecondFactoryReturnDate.setStatus('mandatory')
if mibBuilder.loadTexts: fmhEqIdSecondFactoryReturnDate.setDescription('Deuxieme date de retour usine')
fmhEqIdThirdFactoryReturnDate = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 25, 5, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(3, 3)).setFixedLength(3)).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmhEqIdThirdFactoryReturnDate.setStatus('mandatory')
if mibBuilder.loadTexts: fmhEqIdThirdFactoryReturnDate.setDescription('Troisieme date de retour usine')
fmhEqIdFourthFactoryReturnDate = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 25, 5, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(3, 3)).setFixedLength(3)).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmhEqIdFourthFactoryReturnDate.setStatus('mandatory')
if mibBuilder.loadTexts: fmhEqIdFourthFactoryReturnDate.setDescription('Quatrieme date de retour usine')
fmhEqIdFifthFactoryReturnDate = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 25, 5, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(3, 3)).setFixedLength(3)).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmhEqIdFifthFactoryReturnDate.setStatus('mandatory')
if mibBuilder.loadTexts: fmhEqIdFifthFactoryReturnDate.setDescription('Cinquieme date de retour usine')
fmhE1S2ModuleDescription = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 10, 25, 10))
fmhE1S2ModDescSoftwareVersion = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 25, 10, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmhE1S2ModDescSoftwareVersion.setStatus('mandatory')
if mibBuilder.loadTexts: fmhE1S2ModDescSoftwareVersion.setDescription('Version logicielle')
fmhE1S2ModDescHardwareVersion = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 25, 10, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmhE1S2ModDescHardwareVersion.setStatus('mandatory')
if mibBuilder.loadTexts: fmhE1S2ModDescHardwareVersion.setDescription('Version materielle')
fmsInverseArp = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 10, 26))
fmsInArpVirtualPortTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 10, 26, 1), )
if mibBuilder.loadTexts: fmsInArpVirtualPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: fmsInArpVirtualPortTable.setDescription('')
fmsInArpVirtualPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 10, 26, 1, 1), ).setIndexNames((0, "PCE-MIB", "fmsInArpVpConnX121"))
if mibBuilder.loadTexts: fmsInArpVirtualPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fmsInArpVirtualPortEntry.setDescription('An entry of fmsInArpVirtualPortTable.')
fmsInArpVpConnX121 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 26, 1, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsInArpVpConnX121.setStatus('mandatory')
if mibBuilder.loadTexts: fmsInArpVpConnX121.setDescription('X121 address on which an inverse ARP has been done.')
fmsInArpVpVirtualPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 26, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 11))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsInArpVpVirtualPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fmsInArpVpVirtualPortId.setDescription('Virtual Port Identifier of the Inverse ARP statistic.')
fmsInArpVpOutRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 26, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsInArpVpOutRequests.setStatus('mandatory')
if mibBuilder.loadTexts: fmsInArpVpOutRequests.setDescription('Number of Inverse ARP request sent on this connection.')
fmsInArpVpInResponses = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 26, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsInArpVpInResponses.setStatus('mandatory')
if mibBuilder.loadTexts: fmsInArpVpInResponses.setDescription('Number of Inverse ARP reply received on the connection.')
fmsInArpVpInRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 26, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsInArpVpInRequests.setStatus('mandatory')
if mibBuilder.loadTexts: fmsInArpVpInRequests.setDescription('Number of Inverse ARP request received on the connection.')
fmsInArpVpOutResponses = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 26, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsInArpVpOutResponses.setStatus('mandatory')
if mibBuilder.loadTexts: fmsInArpVpOutResponses.setDescription('Number of Inverse ARP reply sent on the connection.')
fmsInArpVpInverseArpStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 26, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("unsuccessful", 1), ("successful", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsInArpVpInverseArpStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fmsInArpVpInverseArpStatus.setDescription('State of the inverse ARP resolution.')
fmsInArpVpRemoteIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 26, 1, 1, 8), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsInArpVpRemoteIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: fmsInArpVpRemoteIpAddr.setDescription('Associated remote IP address.')
fmsInArpVpLocalIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 26, 1, 1, 9), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsInArpVpLocalIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: fmsInArpVpLocalIpAddr.setDescription('Associated local IP address.')
fmsBootP = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 10, 27))
fmsBootPClient = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 10, 27, 1))
fmsBootPClientStatus = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 27, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notLaunched", 1), ("inProgress", 2), ("succeed", 3), ("failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsBootPClientStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fmsBootPClientStatus.setDescription('The value of this object identifies result of BootP transaction.')
fmsBootPClientFileName = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 27, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsBootPClientFileName.setStatus('mandatory')
if mibBuilder.loadTexts: fmsBootPClientFileName.setDescription('The value of this object identifies the file name received after bootreply reception.')
fmsBootPClientServerIpAddr = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 27, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsBootPClientServerIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: fmsBootPClientServerIpAddr.setDescription('The value of this object identifies the server IP address which has contacted bootp client manager.')
fmsBootPClientGatewayIpAddr = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 10, 27, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsBootPClientGatewayIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: fmsBootPClientGatewayIpAddr.setDescription('The value of this object identifies the gateway IP address. This field is used in optional cross-gateway booting.')
fmsBootPRelayTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 10, 27, 10), )
if mibBuilder.loadTexts: fmsBootPRelayTable.setStatus('mandatory')
if mibBuilder.loadTexts: fmsBootPRelayTable.setDescription('This table describes the parameters used in BootP Relay mode. It gives statistics of BootP packets transfers.')
fmsBootPRelayEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 10, 27, 10, 1), ).setIndexNames((0, "PCE-MIB", "fmsBootPRelayVirtualPortId"))
if mibBuilder.loadTexts: fmsBootPRelayEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fmsBootPRelayEntry.setDescription('An entry of fmsBootPRelayTable.')
fmsBootPRelayVirtualPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 27, 10, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 11))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsBootPRelayVirtualPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fmsBootPRelayVirtualPortId.setDescription('The value of this object identifies the Virtual Port Identifier of BootP Relay statistic.')
fmsBootPRelayRelayedPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 27, 10, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsBootPRelayRelayedPkts.setStatus('mandatory')
if mibBuilder.loadTexts: fmsBootPRelayRelayedPkts.setDescription('The value of this object identifies the number of packets routed by gateway in the case of BootP Relay mode.')
fmsBootPRelayDroppedPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 27, 10, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsBootPRelayDroppedPkts.setStatus('mandatory')
if mibBuilder.loadTexts: fmsBootPRelayDroppedPkts.setDescription('The value of this object identifies the number of destroyed packets.')
fmsBootPRelayRecRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 27, 10, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsBootPRelayRecRequests.setStatus('mandatory')
if mibBuilder.loadTexts: fmsBootPRelayRecRequests.setDescription('The value of this object identifies the number of received packets.')
fmsBootPRelayRecReplies = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 10, 27, 10, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fmsBootPRelayRecReplies.setStatus('mandatory')
if mibBuilder.loadTexts: fmsBootPRelayRecReplies.setDescription('The value of this object identifies the number of received responses.')
frxStateChange = NotificationType((1, 3, 6, 1, 4, 1, 866) + (0,5)).setObjects(("PCE-MIB", "fmeTrapLineId"), ("PCE-MIB", "fmeTrapFamilyId"), ("PCE-MIB", "fmeTrapEventType"), ("PCE-MIB", "fmeTrapEventData"))
if mibBuilder.loadTexts: frxStateChange.setDescription('A frxStateChange trap signifies that a outstanding events takes place. This event is not in frxNodeStateChange, frxLineStateChange, frxLoadAndTrafficEvent, frxManagementEvent, frxServicesStateChange.')
frxNodeStateChange = NotificationType((1, 3, 6, 1, 4, 1, 866) + (0,6)).setObjects(("PCE-MIB", "fmeTrapLineId"), ("PCE-MIB", "fmeTrapFamilyId"), ("PCE-MIB", "fmeTrapEventType"), ("PCE-MIB", "fmeTrapEventData"))
if mibBuilder.loadTexts: frxNodeStateChange.setDescription('A frxNodeStateChange trap signifies that a state changing takes place in the equipment or in a module.')
frxLineStateChange = NotificationType((1, 3, 6, 1, 4, 1, 866) + (0,7)).setObjects(("PCE-MIB", "fmeTrapLineId"), ("PCE-MIB", "fmeTrapFamilyId"), ("PCE-MIB", "fmeTrapEventType"), ("PCE-MIB", "fmeTrapEventData"))
if mibBuilder.loadTexts: frxLineStateChange.setDescription('A frxLineStateChange trap signifies that a state changing takes place over a SLL (Switched Logical Link), over the level 2 or 3 protocol of the line. It can indicate a charge overflow of the line.')
frxLoadAndTrafficEvent = NotificationType((1, 3, 6, 1, 4, 1, 866) + (0,8)).setObjects(("PCE-MIB", "fmeTrapLineId"), ("PCE-MIB", "fmeTrapFamilyId"), ("PCE-MIB", "fmeTrapEventType"), ("PCE-MIB", "fmeTrapEventData"))
if mibBuilder.loadTexts: frxLoadAndTrafficEvent.setDescription('A frxLoadAndTrafficEvent trap signifies that the maximum threshold, like the number of virtual circuits, the data frame rejection threshold ..., is reached.')
frxManagementEvent = NotificationType((1, 3, 6, 1, 4, 1, 866) + (0,9)).setObjects(("PCE-MIB", "fmeTrapLineId"), ("PCE-MIB", "fmeTrapFamilyId"), ("PCE-MIB", "fmeTrapEventType"), ("PCE-MIB", "fmeTrapEventData"))
if mibBuilder.loadTexts: frxManagementEvent.setDescription('A frxManagementEvent trap signifies that a configuration changing takes place or someone behaves on the system.')
frxServicesStateChange = NotificationType((1, 3, 6, 1, 4, 1, 866) + (0,10)).setObjects(("PCE-MIB", "fmeTrapLineId"), ("PCE-MIB", "fmeTrapFamilyId"), ("PCE-MIB", "fmeTrapEventType"), ("PCE-MIB", "fmeTrapEventData"))
if mibBuilder.loadTexts: frxServicesStateChange.setDescription('A frxServicesStateChange trap signifies that something about additional services (securized virtual circuit, compression, regrouping frames) takes place.')
fdPhysicalPorts = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 20, 10))
fdpIdentification = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 20, 10, 1))
fdpIdentPhysPortId = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 20, 10, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fdpIdentPhysPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fdpIdentPhysPortId.setDescription("The value of this object is the physical port number. This value may be modified only if fdpIdentPhysPortState is 'notConfigured', 'up' or 'down'.")
fdpIdentPhysPortState = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 20, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 10, 11, 12, 13))).clone(namedValues=NamedValues(("notConfigured", 1), ("up", 2), ("down", 3), ("loopBack0", 10), ("loopBack3", 11), ("remoteLoopBack2", 12), ("modemManagement", 13)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fdpIdentPhysPortState.setStatus('mandatory')
if mibBuilder.loadTexts: fdpIdentPhysPortState.setDescription('The value of this object is the state of the physical port identified by fdpIdentPhysPortId.')
fdpControl = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 20, 10, 2))
fdpCtrlCommand = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 20, 10, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ready", 1), ("up", 2), ("down", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fdpCtrlCommand.setStatus('mandatory')
if mibBuilder.loadTexts: fdpCtrlCommand.setDescription("The value of this object is the desired state of the physical port described in fdpIdentPhysPortId. The equipment answers always with the value 'ready' to a GetRequest on this object.")
fdpCtrlDiagCode = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 20, 10, 2, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("noError", 1), ("unknownCommand", 2), ("noSuchPhysPortId", 3), ("noSuchPhysPortType", 4), ("badLoopBackType", 5), ("deviceDown", 6), ("physPortIsTheLinkToManager", 7), ("physPortNotMonitored", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fdpCtrlDiagCode.setStatus('mandatory')
if mibBuilder.loadTexts: fdpCtrlDiagCode.setDescription('The value of this object is the result of the last SET on fdpCtrlCommand.')
fdpTest = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 20, 10, 3))
fdpTestLoopBackType = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 20, 10, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("loopBack0", 1), ("loopBack3", 2), ("remoteLoopBack2", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fdpTestLoopBackType.setStatus('mandatory')
if mibBuilder.loadTexts: fdpTestLoopBackType.setDescription('The value of this object is the desired loop type run on the physical port described in fdpIdentPhysPortId.')
fdpTestOutputPacketsCount = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 20, 10, 3, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 99))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fdpTestOutputPacketsCount.setStatus('mandatory')
if mibBuilder.loadTexts: fdpTestOutputPacketsCount.setDescription("The value of this object is the maximum number of messages to be sent during the test. '0' means 'infinite'.")
fdpTestMaxDuration = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 20, 10, 3, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 90))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fdpTestMaxDuration.setStatus('mandatory')
if mibBuilder.loadTexts: fdpTestMaxDuration.setDescription('The value of this object is the maximum duration of the test in seconds.')
fdpTestCommand = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 20, 10, 3, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ready", 1), ("start", 2), ("stop", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fdpTestCommand.setStatus('mandatory')
if mibBuilder.loadTexts: fdpTestCommand.setDescription("The value of this object permits to start or stop the loop test described in fdpTestLoopBackType, fdpTestOutputPacketsCount and fdpTestMaxDuration. The equipment answers always with the value 'ready' to a GetRequest on this object.")
fdpTestDiagCode = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 20, 10, 3, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30))).clone(namedValues=NamedValues(("noError", 1), ("unknownCommand", 2), ("noSuchPhysPortId", 3), ("noSuchPhysPortType", 4), ("badLoopBackType", 5), ("deviceDown", 6), ("physPortIsTheLinkToManager", 7), ("physPortNotMonitored", 8), ("testInProgress", 20), ("noTestInProgress", 21), ("testStopped", 22), ("waitingFirstStatusReport", 23), ("atLeastOneInputErrPacket", 24), ("atLeastOneLostPacket", 25), ("atLeastOneFailedOutputPacket", 26), ("noTestIndicator142", 27), ("unavailableTest", 28), ("loopBackBeforeTimeOut", 29), ("loopBackOk", 30)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fdpTestDiagCode.setStatus('mandatory')
if mibBuilder.loadTexts: fdpTestDiagCode.setDescription('The value of this object is the result of the last SET on fdpTestCommand.')
fdpTestState = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 20, 10, 3, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ready", 1), ("waitingFirstStatusReport", 2), ("waitingLastStatusReport", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fdpTestState.setStatus('mandatory')
if mibBuilder.loadTexts: fdpTestState.setDescription('The value of this object is the state of the last test started.')
fdpTestOutPktsCounter = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 20, 10, 3, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fdpTestOutPktsCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fdpTestOutPktsCounter.setDescription('The value of this object is the number of messages sent during the test.')
fdpTestInPktsCounter = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 20, 10, 3, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fdpTestInPktsCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fdpTestInPktsCounter.setDescription('The value of this object is the number of messages received during the test.')
fdpTestInErrPktsCounter = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 20, 10, 3, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fdpTestInErrPktsCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fdpTestInErrPktsCounter.setDescription('The value of this object is the number of incorrect messages received during the test.')
fdpTestInErrOctetsCounter = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 20, 10, 3, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fdpTestInErrOctetsCounter.setStatus('mandatory')
if mibBuilder.loadTexts: fdpTestInErrOctetsCounter.setDescription('The value of this object is the number of incorrect characters received during the test.')
fdpModemManagement = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 20, 20, 10, 4))
fdpModCommand = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 20, 10, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ready", 1), ("open", 2), ("close", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fdpModCommand.setStatus('mandatory')
if mibBuilder.loadTexts: fdpModCommand.setDescription("The value of this object permits to open or close a session with a modem connected on the physical port described in fdpIdentPhysPortId. The equipment answers always with the value 'ready' to a GetRequest on this object.")
fdpModControlData = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 20, 10, 4, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fdpModControlData.setStatus('mandatory')
if mibBuilder.loadTexts: fdpModControlData.setDescription('The value of this object is AT Commands to be sent to the modem')
fdpModDiagCode = MibScalar((1, 3, 6, 1, 4, 1, 866, 20, 20, 10, 4, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 40, 41, 42, 43, 44, 45, 46, 47))).clone(namedValues=NamedValues(("noError", 1), ("unknownCommand", 2), ("noSuchPhysPortId", 3), ("noSuchPhysPortType", 4), ("badLoopBackType", 5), ("deviceDown", 6), ("physPortIsTheLinkToManager", 7), ("physPortNotMonitored", 8), ("openingSequence", 40), ("modemStabilization", 41), ("sequenceOpen", 42), ("noResponseFromModem", 43), ("noSequenceOpen", 44), ("sequenceAlreadyOpen", 45), ("modemData", 46), ("openingSequenceWithoutAtCommand", 47)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fdpModDiagCode.setStatus('mandatory')
if mibBuilder.loadTexts: fdpModDiagCode.setDescription("The value of this object is the result of the last SET on fdpModCommand or fdpModControlData. The value 'modemData' means that the modem has sent one or several responses which may be seen in fdpModResponseTable.")
fdpModResponseTable = MibTable((1, 3, 6, 1, 4, 1, 866, 20, 20, 10, 4, 15), )
if mibBuilder.loadTexts: fdpModResponseTable.setStatus('mandatory')
if mibBuilder.loadTexts: fdpModResponseTable.setDescription('This table contents the result of the last AT commands described in fdpModControlData.')
fdpModResponseEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 20, 20, 10, 4, 15, 1), ).setIndexNames((0, "PCE-MIB", "fdpModRespEltNum"))
if mibBuilder.loadTexts: fdpModResponseEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fdpModResponseEntry.setDescription('An entry of fdpModResponseTable.')
fdpModRespEltNum = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 20, 10, 4, 15, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fdpModRespEltNum.setStatus('mandatory')
if mibBuilder.loadTexts: fdpModRespEltNum.setDescription('The value of this object is the identifier of one text line of a response of the modem.')
fdpModRespElement = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 20, 20, 10, 4, 15, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fdpModRespElement.setStatus('mandatory')
if mibBuilder.loadTexts: fdpModRespElement.setDescription('The value of this object contains the ASCII characters of this text line.')
cpcDiagnostic = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 51, 20))
cdPhysicalPorts = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 51, 20, 10))
cdpIdentification = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 51, 20, 10, 1))
cdpIdentPhysPortType = MibScalar((1, 3, 6, 1, 4, 1, 866, 51, 20, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("synchronous", 2), ("asynchronous", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cdpIdentPhysPortType.setStatus('mandatory')
if mibBuilder.loadTexts: cdpIdentPhysPortType.setDescription('Physical port type')
cpcManagement = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 51, 10))
cmEvents = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 51, 10, 5))
cmeEventSynchronize = MibScalar((1, 3, 6, 1, 4, 1, 866, 51, 10, 5, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("node", 1), ("local", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmeEventSynchronize.setStatus('mandatory')
if mibBuilder.loadTexts: cmeEventSynchronize.setDescription('Action.')
cmeClearVirtualCircuitInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 51, 10, 5, 5))
cmeClearX121Address = MibScalar((1, 3, 6, 1, 4, 1, 866, 51, 10, 5, 5, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmeClearX121Address.setStatus('mandatory')
if mibBuilder.loadTexts: cmeClearX121Address.setDescription('The value of this object is the X121 address of the remote equipment.')
cmeClearCallUserData = MibScalar((1, 3, 6, 1, 4, 1, 866, 51, 10, 5, 5, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmeClearCallUserData.setStatus('mandatory')
if mibBuilder.loadTexts: cmeClearCallUserData.setDescription('The value of this object is the call user data send to the Compac management function.')
cmeClearEvent = MibScalar((1, 3, 6, 1, 4, 1, 866, 51, 10, 5, 5, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("timeout", 1), ("x25ClearReceived", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmeClearEvent.setStatus('mandatory')
if mibBuilder.loadTexts: cmeClearEvent.setDescription('The value of this object is the type of X25 failed connection.')
cmeClearCause = MibScalar((1, 3, 6, 1, 4, 1, 866, 51, 10, 5, 5, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmeClearCause.setStatus('mandatory')
if mibBuilder.loadTexts: cmeClearCause.setDescription('The value of this object is the X25 clear cause number.')
cmeClearDiag = MibScalar((1, 3, 6, 1, 4, 1, 866, 51, 10, 5, 5, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmeClearDiag.setStatus('mandatory')
if mibBuilder.loadTexts: cmeClearDiag.setDescription('The value of this object is the X25 clear diagnostic number.')
cmeClearTimeStamp = MibScalar((1, 3, 6, 1, 4, 1, 866, 51, 10, 5, 5, 6), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmeClearTimeStamp.setStatus('mandatory')
if mibBuilder.loadTexts: cmeClearTimeStamp.setDescription('The value of this object is the sysUpTime at last disconnection time.')
cpcFileTransfer = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 51, 30))
cfFileTransferService = MibScalar((1, 3, 6, 1, 4, 1, 866, 51, 30, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("softwareIdentification", 1), ("configurationDownloading", 2), ("offLineSoftwareDownloading", 3), ("configurationUploading", 4), ("equipmentReset", 5), ("equipmentHalt", 6), ("hardwareIdentification", 7), ("softwareList", 8), ("onLineSoftwareDownloading", 9), ("onLineSoftwareDownloadingAndReset", 10)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cfFileTransferService.setStatus('mandatory')
if mibBuilder.loadTexts: cfFileTransferService.setDescription('File Transfer Service')
cfConfigurationFileToDownload = MibScalar((1, 3, 6, 1, 4, 1, 866, 51, 30, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cfConfigurationFileToDownload.setStatus('mandatory')
if mibBuilder.loadTexts: cfConfigurationFileToDownload.setDescription('Name of configuration file to download')
cfConfigurationFileToUpload = MibScalar((1, 3, 6, 1, 4, 1, 866, 51, 30, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cfConfigurationFileToUpload.setStatus('mandatory')
if mibBuilder.loadTexts: cfConfigurationFileToUpload.setDescription('Name of file in which configuration will be uploaded')
cfSoftwareFileToDownload = MibScalar((1, 3, 6, 1, 4, 1, 866, 51, 30, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cfSoftwareFileToDownload.setStatus('mandatory')
if mibBuilder.loadTexts: cfSoftwareFileToDownload.setDescription('Name of software file to download')
cfStartUpChoiceAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 866, 51, 30, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("withDefaultConfiguration", 1), ("withCopyOfDefaultToOperational", 2), ("withOperationalConfiguration", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cfStartUpChoiceAfterReset.setStatus('mandatory')
if mibBuilder.loadTexts: cfStartUpChoiceAfterReset.setDescription('Choice of start up after reset')
cfModuleToIdentify = MibScalar((1, 3, 6, 1, 4, 1, 866, 51, 30, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("module0", 1), ("module1", 2), ("module2", 3), ("calledModule", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cfModuleToIdentify.setStatus('mandatory')
if mibBuilder.loadTexts: cfModuleToIdentify.setDescription('Selection of module for hardware identification')
cfZoneToIdentify = MibScalar((1, 3, 6, 1, 4, 1, 866, 51, 30, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("manufacturerZone", 1), ("customerZone", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cfZoneToIdentify.setStatus('mandatory')
if mibBuilder.loadTexts: cfZoneToIdentify.setDescription('Selection of zone for hardware identification')
cfHardwareIdentificationPassword = MibScalar((1, 3, 6, 1, 4, 1, 866, 51, 30, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cfHardwareIdentificationPassword.setStatus('mandatory')
if mibBuilder.loadTexts: cfHardwareIdentificationPassword.setDescription('')
cfSoftwareListPassword = MibScalar((1, 3, 6, 1, 4, 1, 866, 51, 30, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cfSoftwareListPassword.setStatus('mandatory')
if mibBuilder.loadTexts: cfSoftwareListPassword.setDescription('')
cfServiceReport = MibScalar((1, 3, 6, 1, 4, 1, 866, 51, 30, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("normalEndOfService", 1), ("abnormalEndOfService", 2), ("sessionOpened", 3), ("sessionCleared", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfServiceReport.setStatus('mandatory')
if mibBuilder.loadTexts: cfServiceReport.setDescription('Report after service execution')
cfVersion = MibScalar((1, 3, 6, 1, 4, 1, 866, 51, 30, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfVersion.setStatus('mandatory')
if mibBuilder.loadTexts: cfVersion.setDescription('Version of equipment returned by software identification')
cfRevision = MibScalar((1, 3, 6, 1, 4, 1, 866, 51, 30, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfRevision.setStatus('mandatory')
if mibBuilder.loadTexts: cfRevision.setDescription('Revision of equipment returned by software identification')
cfEdition = MibScalar((1, 3, 6, 1, 4, 1, 866, 51, 30, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfEdition.setStatus('mandatory')
if mibBuilder.loadTexts: cfEdition.setDescription('Edition of equipment returned by software identification')
cfCpuBoardType = MibScalar((1, 3, 6, 1, 4, 1, 866, 51, 30, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfCpuBoardType.setStatus('mandatory')
if mibBuilder.loadTexts: cfCpuBoardType.setDescription('Type of CPU board returned by software identification')
cfProductType = MibScalar((1, 3, 6, 1, 4, 1, 866, 51, 30, 15), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfProductType.setStatus('mandatory')
if mibBuilder.loadTexts: cfProductType.setDescription('Type of product returned by software identification')
cfConfigurationVersion = MibScalar((1, 3, 6, 1, 4, 1, 866, 51, 30, 16), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfConfigurationVersion.setStatus('mandatory')
if mibBuilder.loadTexts: cfConfigurationVersion.setDescription('Version of configuration returned by software identification')
cfConfigurationRelease = MibScalar((1, 3, 6, 1, 4, 1, 866, 51, 30, 17), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfConfigurationRelease.setStatus('mandatory')
if mibBuilder.loadTexts: cfConfigurationRelease.setDescription('Release of configuration returned by software identification')
cfConfigurationEdition = MibScalar((1, 3, 6, 1, 4, 1, 866, 51, 30, 18), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfConfigurationEdition.setStatus('mandatory')
if mibBuilder.loadTexts: cfConfigurationEdition.setDescription('Edition of configuration returned by software identification')
cfConfigurationDate = MibScalar((1, 3, 6, 1, 4, 1, 866, 51, 30, 19), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfConfigurationDate.setStatus('mandatory')
if mibBuilder.loadTexts: cfConfigurationDate.setDescription('Date of configuration returned by software identification')
cfUserField = MibScalar((1, 3, 6, 1, 4, 1, 866, 51, 30, 20), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfUserField.setStatus('mandatory')
if mibBuilder.loadTexts: cfUserField.setDescription('User field returned by software identification')
cf12NcNumber35 = MibScalar((1, 3, 6, 1, 4, 1, 866, 51, 30, 21), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 13))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cf12NcNumber35.setStatus('mandatory')
if mibBuilder.loadTexts: cf12NcNumber35.setDescription('12NC Number in 35xxxx returned by software identification')
cf12NcNumber75 = MibScalar((1, 3, 6, 1, 4, 1, 866, 51, 30, 22), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 13))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cf12NcNumber75.setStatus('mandatory')
if mibBuilder.loadTexts: cf12NcNumber75.setDescription('12NC Number in 75xxxx returned by software identification')
cfField1 = MibScalar((1, 3, 6, 1, 4, 1, 866, 51, 30, 23), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 9))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfField1.setStatus('mandatory')
if mibBuilder.loadTexts: cfField1.setDescription('Field 1 returned by hardware identification')
cfField2 = MibScalar((1, 3, 6, 1, 4, 1, 866, 51, 30, 24), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 9))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfField2.setStatus('mandatory')
if mibBuilder.loadTexts: cfField2.setDescription('Field 2 returned by hardware identification')
cfField3 = MibScalar((1, 3, 6, 1, 4, 1, 866, 51, 30, 25), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 9))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfField3.setStatus('mandatory')
if mibBuilder.loadTexts: cfField3.setDescription('Field 3 returned by hardware identification')
cfField4 = MibScalar((1, 3, 6, 1, 4, 1, 866, 51, 30, 26), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 9))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfField4.setStatus('mandatory')
if mibBuilder.loadTexts: cfField4.setDescription('Field 4 returned by hardware identification')
cfFlashSize = MibScalar((1, 3, 6, 1, 4, 1, 866, 51, 30, 27), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 6))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfFlashSize.setStatus('mandatory')
if mibBuilder.loadTexts: cfFlashSize.setDescription('Flash size returned by hardware identification')
cfRamSize = MibScalar((1, 3, 6, 1, 4, 1, 866, 51, 30, 28), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 6))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfRamSize.setStatus('mandatory')
if mibBuilder.loadTexts: cfRamSize.setDescription('RAM size returned by hardware identification')
cfEepromSize = MibScalar((1, 3, 6, 1, 4, 1, 866, 51, 30, 29), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 6))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfEepromSize.setStatus('mandatory')
if mibBuilder.loadTexts: cfEepromSize.setDescription('EEPROM size returned by hardware identification')
cfNumberOfLines = MibScalar((1, 3, 6, 1, 4, 1, 866, 51, 30, 30), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfNumberOfLines.setStatus('mandatory')
if mibBuilder.loadTexts: cfNumberOfLines.setDescription('Number of lines returned by hardware identification')
cfTransputerPresence = MibScalar((1, 3, 6, 1, 4, 1, 866, 51, 30, 31), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfTransputerPresence.setStatus('mandatory')
if mibBuilder.loadTexts: cfTransputerPresence.setDescription('Presence of transputer on board returned by hardware identification')
cfMpbBoardReference255 = MibScalar((1, 3, 6, 1, 4, 1, 866, 51, 30, 32), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfMpbBoardReference255.setStatus('mandatory')
if mibBuilder.loadTexts: cfMpbBoardReference255.setDescription('Reference 255xxxx of the MPB returned by hardware identification')
cfMpbBoardSerialNumber = MibScalar((1, 3, 6, 1, 4, 1, 866, 51, 30, 33), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfMpbBoardSerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cfMpbBoardSerialNumber.setDescription('Serial number of the MPB board returned by hardware identification')
cfMtbBoardReference255 = MibScalar((1, 3, 6, 1, 4, 1, 866, 51, 30, 34), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfMtbBoardReference255.setStatus('mandatory')
if mibBuilder.loadTexts: cfMtbBoardReference255.setDescription('Reference 255xxxx of the MTB returned by hardware identification')
cfMtbBoardSerialNumber = MibScalar((1, 3, 6, 1, 4, 1, 866, 51, 30, 35), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfMtbBoardSerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cfMtbBoardSerialNumber.setDescription('Serial number of the MTB board returned by hardware identification')
cfReleaseDate = MibScalar((1, 3, 6, 1, 4, 1, 866, 51, 30, 36), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfReleaseDate.setStatus('mandatory')
if mibBuilder.loadTexts: cfReleaseDate.setDescription('Release date returned by hardware identification')
cfFactoryReturnDate1 = MibScalar((1, 3, 6, 1, 4, 1, 866, 51, 30, 37), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfFactoryReturnDate1.setStatus('mandatory')
if mibBuilder.loadTexts: cfFactoryReturnDate1.setDescription('Factory return date number 1 returned by hardware identification')
cfFactoryReturnDate2 = MibScalar((1, 3, 6, 1, 4, 1, 866, 51, 30, 38), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfFactoryReturnDate2.setStatus('mandatory')
if mibBuilder.loadTexts: cfFactoryReturnDate2.setDescription('Factory return date number 2 returned by hardware identification')
cfFactoryReturnDate3 = MibScalar((1, 3, 6, 1, 4, 1, 866, 51, 30, 39), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfFactoryReturnDate3.setStatus('mandatory')
if mibBuilder.loadTexts: cfFactoryReturnDate3.setDescription('Factory return date number 3 returned by hardware identification')
cfFactoryReturnDate4 = MibScalar((1, 3, 6, 1, 4, 1, 866, 51, 30, 40), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfFactoryReturnDate4.setStatus('mandatory')
if mibBuilder.loadTexts: cfFactoryReturnDate4.setDescription('Factory return date number 4 returned by hardware identification')
cfFactoryReturnDate5 = MibScalar((1, 3, 6, 1, 4, 1, 866, 51, 30, 41), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfFactoryReturnDate5.setStatus('mandatory')
if mibBuilder.loadTexts: cfFactoryReturnDate5.setDescription('Factory return date number 5 returned by hardware identification')
cfSoftwareList = MibScalar((1, 3, 6, 1, 4, 1, 866, 51, 30, 42), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 2048))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfSoftwareList.setStatus('mandatory')
if mibBuilder.loadTexts: cfSoftwareList.setDescription("List of software (user's right)")
cpcClearVirtualCircuitEvent = NotificationType((1, 3, 6, 1, 4, 1, 866) + (0,100)).setObjects(("PCE-MIB", "cmeClearX121Address"), ("PCE-MIB", "cmeClearCallUserData"), ("PCE-MIB", "cmeClearEvent"), ("PCE-MIB", "cmeClearCause"), ("PCE-MIB", "cmeClearDiag"))
if mibBuilder.loadTexts: cpcClearVirtualCircuitEvent.setDescription('A cpcClearVirtualCircuitEvent trap signifies a X25 failed connection between proxy agent and remote equipment.')
vcControl = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 30, 1, 1))
vcCtlDate = MibScalar((1, 3, 6, 1, 4, 1, 866, 30, 1, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(3, 3)).setFixedLength(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcCtlDate.setStatus('mandatory')
if mibBuilder.loadTexts: vcCtlDate.setDescription('')
vcCtlHour = MibScalar((1, 3, 6, 1, 4, 1, 866, 30, 1, 1, 2), TimeTicks()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcCtlHour.setStatus('mandatory')
if mibBuilder.loadTexts: vcCtlHour.setDescription('')
vcCtlConfigCom = MibScalar((1, 3, 6, 1, 4, 1, 866, 30, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 5, 6, 10))).clone(namedValues=NamedValues(("ready", 1), ("check", 2), ("load", 5), ("save", 6), ("hotReset", 10)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcCtlConfigCom.setStatus('mandatory')
if mibBuilder.loadTexts: vcCtlConfigCom.setDescription('')
vcCtlConfigLoad = MibScalar((1, 3, 6, 1, 4, 1, 866, 30, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 9))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcCtlConfigLoad.setStatus('mandatory')
if mibBuilder.loadTexts: vcCtlConfigLoad.setDescription('')
vcCtlErrorTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 1, 1, 10), )
if mibBuilder.loadTexts: vcCtlErrorTable.setStatus('mandatory')
if mibBuilder.loadTexts: vcCtlErrorTable.setDescription('')
vcCtlErrorEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 1, 1, 10, 1), ).setIndexNames((0, "PCE-MIB", "vcCtlErrorIndex"))
if mibBuilder.loadTexts: vcCtlErrorEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vcCtlErrorEntry.setDescription('An entry of vcCtlErrorTable.')
vcCtlErrorIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 1, 10, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcCtlErrorIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vcCtlErrorIndex.setDescription('')
vcCtlErrorCode = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 1, 10, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcCtlErrorCode.setStatus('mandatory')
if mibBuilder.loadTexts: vcCtlErrorCode.setDescription('')
vcCtlErrorMessage = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 1, 10, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcCtlErrorMessage.setStatus('mandatory')
if mibBuilder.loadTexts: vcCtlErrorMessage.setDescription('')
vcCtlErrorTime = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 1, 10, 1, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcCtlErrorTime.setStatus('mandatory')
if mibBuilder.loadTexts: vcCtlErrorTime.setDescription('')
vcSystem = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 30, 1, 5))
vcSysConfActive = MibScalar((1, 3, 6, 1, 4, 1, 866, 30, 1, 5, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28))).clone(namedValues=NamedValues(("s1", 1), ("s2", 2), ("s3", 3), ("s4", 4), ("s5", 5), ("s6", 6), ("s7", 7), ("s8", 8), ("s9", 9), ("w0", 10), ("w1", 11), ("w2", 12), ("w3", 13), ("w4", 14), ("w5", 15), ("w6", 16), ("w7", 17), ("w8", 18), ("w9", 19), ("w0-1", 20), ("w0-2", 21), ("w0-3", 22), ("w0-4", 23), ("w0-5", 24), ("w0-6", 25), ("w0-7", 26), ("w0-8", 27), ("w0-9", 28)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcSysConfActive.setStatus('mandatory')
if mibBuilder.loadTexts: vcSysConfActive.setDescription('')
vcSysConfDate = MibScalar((1, 3, 6, 1, 4, 1, 866, 30, 1, 5, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(3, 3)).setFixedLength(3)).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcSysConfDate.setStatus('mandatory')
if mibBuilder.loadTexts: vcSysConfDate.setDescription('')
vcSysConfHour = MibScalar((1, 3, 6, 1, 4, 1, 866, 30, 1, 5, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcSysConfHour.setStatus('mandatory')
if mibBuilder.loadTexts: vcSysConfHour.setDescription('')
vcManagement = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 30, 1, 10))
vcmAlrmGenTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 1, 10, 1), )
if mibBuilder.loadTexts: vcmAlrmGenTable.setStatus('mandatory')
if mibBuilder.loadTexts: vcmAlrmGenTable.setDescription('')
vcmAlrmGenEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 1, 10, 1, 1), ).setIndexNames((0, "PCE-MIB", "vcmAlrmGenFamilyId"), (0, "PCE-MIB", "vcmAlrmGenTyp"))
if mibBuilder.loadTexts: vcmAlrmGenEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vcmAlrmGenEntry.setDescription('An entry of vcmAlrmGenTable.')
vcmAlrmGenFamilyId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 10, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("f00System", 1), ("f01Tftp", 2), ("f02Junction", 3), ("f03Lmi", 4), ("f04Svc", 5), ("f05Compression", 6), ("f06ServiceCanal", 7), ("f07Fax", 8), ("f08Switching", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcmAlrmGenFamilyId.setStatus('mandatory')
if mibBuilder.loadTexts: vcmAlrmGenFamilyId.setDescription('')
vcmAlrmGenTyp = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 10, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("lnkReady208", 1), ("lnkNotReady209", 2), ("fatalError222", 3), ("reboot233", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcmAlrmGenTyp.setStatus('mandatory')
if mibBuilder.loadTexts: vcmAlrmGenTyp.setDescription('')
vcmAlrmGenTrapSend = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 10, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcmAlrmGenTrapSend.setStatus('mandatory')
if mibBuilder.loadTexts: vcmAlrmGenTrapSend.setDescription('')
vcmAlrmGenDisplay = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 10, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcmAlrmGenDisplay.setStatus('mandatory')
if mibBuilder.loadTexts: vcmAlrmGenDisplay.setDescription('')
vcmAlrmSCTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 1, 10, 2), )
if mibBuilder.loadTexts: vcmAlrmSCTable.setStatus('mandatory')
if mibBuilder.loadTexts: vcmAlrmSCTable.setDescription('')
vcmAlrmSCEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 1, 10, 2, 1), ).setIndexNames((0, "PCE-MIB", "vcmAlrmSCFamilyId"), (0, "PCE-MIB", "vcmAlrmSCTyp"))
if mibBuilder.loadTexts: vcmAlrmSCEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vcmAlrmSCEntry.setDescription('An entry of vcmAlrmSCTable.')
vcmAlrmSCFamilyId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 10, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("f00System", 1), ("f01Tftp", 2), ("f02Junction", 3), ("f03Lmi", 4), ("f04Svc", 5), ("f05Compression", 6), ("f06ServiceCanal", 7), ("f07Fax", 8), ("f08Switching", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcmAlrmSCFamilyId.setStatus('mandatory')
if mibBuilder.loadTexts: vcmAlrmSCFamilyId.setDescription('')
vcmAlrmSCTyp = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 10, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("scReady210", 1), ("scNotReady211", 2), ("frAddrError223", 3), ("dlciError224", 4), ("scNotFree225", 5), ("scDynamic226", 6), ("scReinit227", 7), ("unexpectedFrame230", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcmAlrmSCTyp.setStatus('mandatory')
if mibBuilder.loadTexts: vcmAlrmSCTyp.setDescription('')
vcmAlrmSCTrapSend = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 10, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcmAlrmSCTrapSend.setStatus('mandatory')
if mibBuilder.loadTexts: vcmAlrmSCTrapSend.setDescription('')
vcmAlrmSCDisplay = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 10, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcmAlrmSCDisplay.setStatus('mandatory')
if mibBuilder.loadTexts: vcmAlrmSCDisplay.setDescription('')
vcmAlrmVCTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 1, 10, 3), )
if mibBuilder.loadTexts: vcmAlrmVCTable.setStatus('mandatory')
if mibBuilder.loadTexts: vcmAlrmVCTable.setDescription('')
vcmAlrmVCEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 1, 10, 3, 1), ).setIndexNames((0, "PCE-MIB", "vcmAlrmVCFamilyId"), (0, "PCE-MIB", "vcmAlrmVCTyp"))
if mibBuilder.loadTexts: vcmAlrmVCEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vcmAlrmVCEntry.setDescription('An entry of vcmAlrmVCTable.')
vcmAlrmVCFamilyId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 10, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("f00System", 1), ("f01Tftp", 2), ("f02Junction", 3), ("f03Lmi", 4), ("f04Svc", 5), ("f05Compression", 6), ("f06ServiceCanal", 7), ("f07Fax", 8), ("f08Switching", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcmAlrmVCFamilyId.setStatus('mandatory')
if mibBuilder.loadTexts: vcmAlrmVCFamilyId.setDescription('')
vcmAlrmVCTyp = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 10, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("vcReady212", 1), ("vcNotReady213", 2), ("lossOfSync220", 3), ("syncBack221", 4), ("vcRejected231", 5), ("endOfReject232", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcmAlrmVCTyp.setStatus('mandatory')
if mibBuilder.loadTexts: vcmAlrmVCTyp.setDescription('')
vcmAlrmVCTrapSend = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 10, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcmAlrmVCTrapSend.setStatus('mandatory')
if mibBuilder.loadTexts: vcmAlrmVCTrapSend.setDescription('')
vcmAlrmVCDisplay = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 10, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcmAlrmVCDisplay.setStatus('mandatory')
if mibBuilder.loadTexts: vcmAlrmVCDisplay.setDescription('')
vcmAlrmLMITable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 1, 10, 4), )
if mibBuilder.loadTexts: vcmAlrmLMITable.setStatus('mandatory')
if mibBuilder.loadTexts: vcmAlrmLMITable.setDescription('')
vcmAlrmLMIEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 1, 10, 4, 1), ).setIndexNames((0, "PCE-MIB", "vcmAlrmLMIFamilyId"), (0, "PCE-MIB", "vcmAlrmLMITyp"))
if mibBuilder.loadTexts: vcmAlrmLMIEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vcmAlrmLMIEntry.setDescription('An entry of vcmAlrmLMITable.')
vcmAlrmLMIFamilyId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 10, 4, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("f00System", 1), ("f01Tftp", 2), ("f02Junction", 3), ("f03Lmi", 4), ("f04Svc", 5), ("f05Compression", 6), ("f06ServiceCanal", 7), ("f07Fax", 8), ("f08Switching", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcmAlrmLMIFamilyId.setStatus('mandatory')
if mibBuilder.loadTexts: vcmAlrmLMIFamilyId.setDescription('')
vcmAlrmLMITyp = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 10, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("dcnxLmi234", 1), ("cnxLmi235", 2), ("lmiDlciNotConf236", 3), ("lmiIntError237", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcmAlrmLMITyp.setStatus('mandatory')
if mibBuilder.loadTexts: vcmAlrmLMITyp.setDescription('')
vcmAlrmLMITrapSend = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 10, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcmAlrmLMITrapSend.setStatus('mandatory')
if mibBuilder.loadTexts: vcmAlrmLMITrapSend.setDescription('')
vcmAlrmLMIDisplay = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 10, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcmAlrmLMIDisplay.setStatus('mandatory')
if mibBuilder.loadTexts: vcmAlrmLMIDisplay.setDescription('')
vcmAlrmSwTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 1, 10, 5), )
if mibBuilder.loadTexts: vcmAlrmSwTable.setStatus('mandatory')
if mibBuilder.loadTexts: vcmAlrmSwTable.setDescription('')
vcmAlrmSwEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 1, 10, 5, 1), ).setIndexNames((0, "PCE-MIB", "vcmAlrmSwFamilyId"), (0, "PCE-MIB", "vcmAlrmSwTyp"))
if mibBuilder.loadTexts: vcmAlrmSwEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vcmAlrmSwEntry.setDescription('An entry of vcmAlrmSwTable.')
vcmAlrmSwFamilyId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 10, 5, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("f00System", 1), ("f01Tftp", 2), ("f02Junction", 3), ("f03Lmi", 4), ("f04Svc", 5), ("f05Compression", 6), ("f06ServiceCanal", 7), ("f07Fax", 8), ("f08Switching", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcmAlrmSwFamilyId.setStatus('mandatory')
if mibBuilder.loadTexts: vcmAlrmSwFamilyId.setDescription('')
vcmAlrmSwTyp = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 10, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("outgoingCall238", 1), ("incomingCall239", 2), ("localDisc240", 3), ("remoteDisc241", 4), ("backup242", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcmAlrmSwTyp.setStatus('mandatory')
if mibBuilder.loadTexts: vcmAlrmSwTyp.setDescription('')
vcmAlrmSwTrapSend = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 10, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcmAlrmSwTrapSend.setStatus('mandatory')
if mibBuilder.loadTexts: vcmAlrmSwTrapSend.setDescription('')
vcmAlrmSwDisplay = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 10, 5, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcmAlrmSwDisplay.setStatus('mandatory')
if mibBuilder.loadTexts: vcmAlrmSwDisplay.setDescription('')
vcmAlrmCmpTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 1, 10, 6), )
if mibBuilder.loadTexts: vcmAlrmCmpTable.setStatus('mandatory')
if mibBuilder.loadTexts: vcmAlrmCmpTable.setDescription('')
vcmAlrmCmpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 1, 10, 6, 1), ).setIndexNames((0, "PCE-MIB", "vcmAlrmCmpFamilyId"), (0, "PCE-MIB", "vcmAlrmCmpTyp"))
if mibBuilder.loadTexts: vcmAlrmCmpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vcmAlrmCmpEntry.setDescription('An entry of vcmAlrmCmpTable.')
vcmAlrmCmpFamilyId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 10, 6, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("f00System", 1), ("f01Tftp", 2), ("f02Junction", 3), ("f03Lmi", 4), ("f04Svc", 5), ("f05Compression", 6), ("f06ServiceCanal", 7), ("f07Fax", 8), ("f08Switching", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcmAlrmCmpFamilyId.setStatus('mandatory')
if mibBuilder.loadTexts: vcmAlrmCmpFamilyId.setDescription('')
vcmAlrmCmpTyp = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 10, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("compOn214", 1), ("compOff215", 2), ("algoCompNotOk228", 3), ("algoCompOk229", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcmAlrmCmpTyp.setStatus('mandatory')
if mibBuilder.loadTexts: vcmAlrmCmpTyp.setDescription('')
vcmAlrmCmpTrapSend = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 10, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcmAlrmCmpTrapSend.setStatus('mandatory')
if mibBuilder.loadTexts: vcmAlrmCmpTrapSend.setDescription('')
vcmAlrmCmpDisplay = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 10, 6, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcmAlrmCmpDisplay.setStatus('mandatory')
if mibBuilder.loadTexts: vcmAlrmCmpDisplay.setDescription('')
vcmAlrmFaxTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 1, 10, 7), )
if mibBuilder.loadTexts: vcmAlrmFaxTable.setStatus('mandatory')
if mibBuilder.loadTexts: vcmAlrmFaxTable.setDescription('')
vcmAlrmFaxEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 1, 10, 7, 1), ).setIndexNames((0, "PCE-MIB", "vcmAlrmFaxFamilyId"), (0, "PCE-MIB", "vcmAlrmFaxTyp"))
if mibBuilder.loadTexts: vcmAlrmFaxEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vcmAlrmFaxEntry.setDescription('An entry of vcmAlrmFaxTable.')
vcmAlrmFaxFamilyId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 10, 7, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("f00System", 1), ("f01Tftp", 2), ("f02Junction", 3), ("f03Lmi", 4), ("f04Svc", 5), ("f05Compression", 6), ("f06ServiceCanal", 7), ("f07Fax", 8), ("f08Switching", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcmAlrmFaxFamilyId.setStatus('mandatory')
if mibBuilder.loadTexts: vcmAlrmFaxFamilyId.setDescription('')
vcmAlrmFaxTyp = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 10, 7, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("faxStart218", 1), ("faxEnd219", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcmAlrmFaxTyp.setStatus('mandatory')
if mibBuilder.loadTexts: vcmAlrmFaxTyp.setDescription('')
vcmAlrmFaxTrapSend = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 10, 7, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcmAlrmFaxTrapSend.setStatus('mandatory')
if mibBuilder.loadTexts: vcmAlrmFaxTrapSend.setDescription('')
vcmAlrmFaxDisplay = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 10, 7, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcmAlrmFaxDisplay.setStatus('mandatory')
if mibBuilder.loadTexts: vcmAlrmFaxDisplay.setDescription('')
vcmAlrmTftpTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 1, 10, 8), )
if mibBuilder.loadTexts: vcmAlrmTftpTable.setStatus('mandatory')
if mibBuilder.loadTexts: vcmAlrmTftpTable.setDescription('')
vcmAlrmTftpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 1, 10, 8, 1), ).setIndexNames((0, "PCE-MIB", "vcmAlrmTftpFamilyId"), (0, "PCE-MIB", "vcmAlrmTftpTyp"))
if mibBuilder.loadTexts: vcmAlrmTftpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vcmAlrmTftpEntry.setDescription('An entry of vcmAlrmTftpTable.')
vcmAlrmTftpFamilyId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 10, 8, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("f00System", 1), ("f01Tftp", 2), ("f02Junction", 3), ("f03Lmi", 4), ("f04Svc", 5), ("f05Compression", 6), ("f06ServiceCanal", 7), ("f07Fax", 8), ("f08Switching", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcmAlrmTftpFamilyId.setStatus('mandatory')
if mibBuilder.loadTexts: vcmAlrmTftpFamilyId.setDescription('')
vcmAlrmTftpTyp = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 10, 8, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("dwnStart243", 1), ("dwnEnd244", 2), ("dwnError245", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcmAlrmTftpTyp.setStatus('mandatory')
if mibBuilder.loadTexts: vcmAlrmTftpTyp.setDescription('')
vcmAlrmTftpTrapSend = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 10, 8, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcmAlrmTftpTrapSend.setStatus('mandatory')
if mibBuilder.loadTexts: vcmAlrmTftpTrapSend.setDescription('')
vcmAlrmTftpDisplay = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 10, 8, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcmAlrmTftpDisplay.setStatus('mandatory')
if mibBuilder.loadTexts: vcmAlrmTftpDisplay.setDescription('')
vcmAlrmSvcTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 1, 10, 9), )
if mibBuilder.loadTexts: vcmAlrmSvcTable.setStatus('mandatory')
if mibBuilder.loadTexts: vcmAlrmSvcTable.setDescription('')
vcmAlrmSvcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 1, 10, 9, 1), ).setIndexNames((0, "PCE-MIB", "vcmAlrmSvcFamilyId"), (0, "PCE-MIB", "vcmAlrmSvcTyp"))
if mibBuilder.loadTexts: vcmAlrmSvcEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vcmAlrmSvcEntry.setDescription('An entry of vcmAlrmSvcTable.')
vcmAlrmSvcFamilyId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 10, 9, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("f00System", 1), ("f01Tftp", 2), ("f02Junction", 3), ("f03Lmi", 4), ("f04Svc", 5), ("f05Compression", 6), ("f06ServiceCanal", 7), ("f07Fax", 8), ("f08Switching", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcmAlrmSvcFamilyId.setStatus('mandatory')
if mibBuilder.loadTexts: vcmAlrmSvcFamilyId.setDescription('')
vcmAlrmSvcTyp = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 10, 9, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("svcOutCall246", 1), ("svcInCall247", 2), ("svcLocalConnect248", 3), ("svcLocalDisc249", 4), ("svcRemoteDisc250", 5), ("svcOutFailCall251", 6), ("svcInFailCall252", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcmAlrmSvcTyp.setStatus('mandatory')
if mibBuilder.loadTexts: vcmAlrmSvcTyp.setDescription('')
vcmAlrmSvcTrapSend = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 10, 9, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcmAlrmSvcTrapSend.setStatus('mandatory')
if mibBuilder.loadTexts: vcmAlrmSvcTrapSend.setDescription('')
vcmAlrmSvcDisplay = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 10, 9, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcmAlrmSvcDisplay.setStatus('mandatory')
if mibBuilder.loadTexts: vcmAlrmSvcDisplay.setDescription('')
vcInterfaces = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 30, 1, 15))
vcfPhysicalPortTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 1, 15, 1), )
if mibBuilder.loadTexts: vcfPhysicalPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: vcfPhysicalPortTable.setDescription('')
vcfPhysicalPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 1, 15, 1, 1), ).setIndexNames((0, "PCE-MIB", "vcfPhysPortId"))
if mibBuilder.loadTexts: vcfPhysicalPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vcfPhysicalPortEntry.setDescription('An entry of vcfPhysicalPortTable.')
vcfPhysPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 15, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("l0", 1), ("l1", 2), ("frontPannel", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcfPhysPortId.setStatus('mandatory')
if mibBuilder.loadTexts: vcfPhysPortId.setDescription('')
vcfPhysPortConnector = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 15, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("db15V11", 1), ("db15V28", 2), ("din", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcfPhysPortConnector.setStatus('mandatory')
if mibBuilder.loadTexts: vcfPhysPortConnector.setDescription('')
vcfNumericLines = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 30, 1, 15, 5))
vcfNumericLineTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 1, 15, 5, 1), )
if mibBuilder.loadTexts: vcfNumericLineTable.setStatus('mandatory')
if mibBuilder.loadTexts: vcfNumericLineTable.setDescription('')
vcfNumericLineEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 1, 15, 5, 1, 1), ).setIndexNames((0, "PCE-MIB", "vcfNumericLineInterfaceId"))
if mibBuilder.loadTexts: vcfNumericLineEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vcfNumericLineEntry.setDescription('An entry of vcfNumericLineTable.')
vcfNumericLineInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 15, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("l0", 1), ("l1", 2), ("frontPannel", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcfNumericLineInterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: vcfNumericLineInterfaceId.setDescription('')
vcfNumericLineType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 15, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("dataLine", 1), ("configurationLine", 2), ("debug", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcfNumericLineType.setStatus('mandatory')
if mibBuilder.loadTexts: vcfNumericLineType.setDescription('')
vcfDataLineTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 1, 15, 5, 2), )
if mibBuilder.loadTexts: vcfDataLineTable.setStatus('mandatory')
if mibBuilder.loadTexts: vcfDataLineTable.setDescription('')
vcfDataLineEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 1, 15, 5, 2, 1), ).setIndexNames((0, "PCE-MIB", "vcfDataLineInterfaceId"))
if mibBuilder.loadTexts: vcfDataLineEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vcfDataLineEntry.setDescription('An entry of vcfDataLineTable.')
vcfDataLineInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 15, 5, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("l0", 1), ("l1", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcfDataLineInterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: vcfDataLineInterfaceId.setDescription('')
vcfDataLineRate = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 15, 5, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("s4800", 1), ("s9600", 2), ("s19200", 3), ("s38400", 4), ("s48000", 5), ("s56000", 6), ("s64000", 7), ("s72000", 8), ("s128000", 9), ("s144000", 10), ("s256000", 11), ("s512000", 12)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcfDataLineRate.setStatus('mandatory')
if mibBuilder.loadTexts: vcfDataLineRate.setDescription('')
vcfDataLineRts105 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 15, 5, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unused", 1), ("used", 2), ("standard", 3), ("off", 4), ("on", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcfDataLineRts105.setStatus('mandatory')
if mibBuilder.loadTexts: vcfDataLineRts105.setDescription('')
vcfDataLineDtr108 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 15, 5, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unused", 1), ("used", 2), ("standard", 3), ("off", 4), ("on", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcfDataLineDtr108.setStatus('mandatory')
if mibBuilder.loadTexts: vcfDataLineDtr108.setDescription('')
vcfDataLineCts106 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 15, 5, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unused", 1), ("used", 2), ("standard", 3), ("off", 4), ("on", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcfDataLineCts106.setStatus('mandatory')
if mibBuilder.loadTexts: vcfDataLineCts106.setDescription('')
vcfDataLineDsr107 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 15, 5, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unused", 1), ("used", 2), ("standard", 3), ("off", 4), ("on", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcfDataLineDsr107.setStatus('mandatory')
if mibBuilder.loadTexts: vcfDataLineDsr107.setDescription('')
vcfDataLineDcd109 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 15, 5, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unused", 1), ("used", 2), ("standard", 3), ("off", 4), ("on", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcfDataLineDcd109.setStatus('mandatory')
if mibBuilder.loadTexts: vcfDataLineDcd109.setDescription('')
vcfConfLineTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 1, 15, 5, 3), )
if mibBuilder.loadTexts: vcfConfLineTable.setStatus('mandatory')
if mibBuilder.loadTexts: vcfConfLineTable.setDescription('')
vcfConfLineEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 1, 15, 5, 3, 1), ).setIndexNames((0, "PCE-MIB", "vcfConfLineInterfaceId"))
if mibBuilder.loadTexts: vcfConfLineEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vcfConfLineEntry.setDescription('An entry of vcfConfLineTable.')
vcfConfLineInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 15, 5, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("l0", 1), ("l1", 2), ("frontPannel", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcfConfLineInterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: vcfConfLineInterfaceId.setDescription('')
vcfConfLineRate = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 15, 5, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("s4800", 1), ("s9600", 2), ("s19200", 3), ("s38400", 4), ("s48000", 5), ("s56000", 6), ("s64000", 7), ("s72000", 8), ("s128000", 9), ("s144000", 10), ("s256000", 11), ("s512000", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcfConfLineRate.setStatus('mandatory')
if mibBuilder.loadTexts: vcfConfLineRate.setDescription('')
vcFrameRelaySw = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 30, 1, 20))
vcFrSwitchingTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 1, 20, 1), )
if mibBuilder.loadTexts: vcFrSwitchingTable.setStatus('mandatory')
if mibBuilder.loadTexts: vcFrSwitchingTable.setDescription('')
vcFrSwitchingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 1, 20, 1, 1), ).setIndexNames((0, "PCE-MIB", "vcFrSwL0Dlci"), (0, "PCE-MIB", "vcFrSwL1Dlci"))
if mibBuilder.loadTexts: vcFrSwitchingEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vcFrSwitchingEntry.setDescription('An entry of vcFrSwitchingTable.')
vcFrSwL0Dlci = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 20, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1022))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcFrSwL0Dlci.setStatus('mandatory')
if mibBuilder.loadTexts: vcFrSwL0Dlci.setDescription('')
vcFrSwL1Dlci = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 20, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1022))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcFrSwL1Dlci.setStatus('mandatory')
if mibBuilder.loadTexts: vcFrSwL1Dlci.setDescription('')
vcFrSwStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 20, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcFrSwStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vcFrSwStatus.setDescription('')
vcFrSwL0DlciPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 20, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("highPriority", 1), ("lowPriority", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcFrSwL0DlciPriority.setStatus('mandatory')
if mibBuilder.loadTexts: vcFrSwL0DlciPriority.setDescription('')
vcFrSwL0MuxEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 20, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcFrSwL0MuxEnable.setStatus('mandatory')
if mibBuilder.loadTexts: vcFrSwL0MuxEnable.setDescription('')
vcFrSwL0ChanelIdentifierCID = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 20, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcFrSwL0ChanelIdentifierCID.setStatus('mandatory')
if mibBuilder.loadTexts: vcFrSwL0ChanelIdentifierCID.setDescription('')
vcFrSwL1DlciPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 20, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("highPriority", 1), ("lowPriority", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcFrSwL1DlciPriority.setStatus('mandatory')
if mibBuilder.loadTexts: vcFrSwL1DlciPriority.setDescription('')
vcFrSwL1MuxEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 20, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcFrSwL1MuxEnable.setStatus('mandatory')
if mibBuilder.loadTexts: vcFrSwL1MuxEnable.setDescription('')
vcFrSwL1ChanelIdentifierCID = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 20, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcFrSwL1ChanelIdentifierCID.setStatus('mandatory')
if mibBuilder.loadTexts: vcFrSwL1ChanelIdentifierCID.setDescription('')
vcLogicalPorts = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 30, 1, 25))
vclLogicalPortTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 1, 25, 1), )
if mibBuilder.loadTexts: vclLogicalPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: vclLogicalPortTable.setDescription('')
vclLogicalPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 1, 25, 1, 1), ).setIndexNames((0, "PCE-MIB", "vclLogPortId"))
if mibBuilder.loadTexts: vclLogicalPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vclLogicalPortEntry.setDescription('An entry of vclLogicalPortTable.')
vclLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 25, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vclLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: vclLogPortId.setDescription('')
vclLogPortStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 25, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vclLogPortStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vclLogPortStatus.setDescription('')
vclLogPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 25, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("hdlc", 1), ("frCe", 2), ("frTe", 3), ("frSe", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vclLogPortType.setStatus('mandatory')
if mibBuilder.loadTexts: vclLogPortType.setDescription('')
vclHdlcAccessLogPort = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 30, 1, 25, 5))
vclHdlcLogPortTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 1, 25, 5, 1), )
if mibBuilder.loadTexts: vclHdlcLogPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: vclHdlcLogPortTable.setDescription('')
vclHdlcLogPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 1, 25, 5, 1, 1), ).setIndexNames((0, "PCE-MIB", "vclHdlcLpLogPortId"))
if mibBuilder.loadTexts: vclHdlcLogPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vclHdlcLogPortEntry.setDescription('An entry of vclHdlcLogPortTable.')
vclHdlcLpLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 25, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vclHdlcLpLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: vclHdlcLpLogPortId.setDescription('')
vclHdlcLpFragmentationLength = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 25, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(60, 390))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vclHdlcLpFragmentationLength.setStatus('mandatory')
if mibBuilder.loadTexts: vclHdlcLpFragmentationLength.setDescription('')
vclHdlcLpRemoteAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 25, 5, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vclHdlcLpRemoteAddress.setStatus('mandatory')
if mibBuilder.loadTexts: vclHdlcLpRemoteAddress.setDescription('')
vclFrameRelay = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 30, 1, 25, 10))
vclFrCommunicationEquipment = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 30, 1, 25, 10, 1))
vclFrCeLogPortTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 1, 25, 10, 1, 1), )
if mibBuilder.loadTexts: vclFrCeLogPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: vclFrCeLogPortTable.setDescription('')
vclFrCeLogPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 1, 25, 10, 1, 1, 1), ).setIndexNames((0, "PCE-MIB", "vclFrCeLpLogPortId"))
if mibBuilder.loadTexts: vclFrCeLogPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vclFrCeLogPortEntry.setDescription('An entry of vclFrCeLogPortTable.')
vclFrCeLpLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 25, 10, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vclFrCeLpLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: vclFrCeLpLogPortId.setDescription('')
vclFrCeLpInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 25, 10, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("l0", 1), ("l1", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vclFrCeLpInterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: vclFrCeLpInterfaceId.setDescription('')
vclFrTerminalEquipment = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 30, 1, 25, 10, 2))
vclFrTeLogPortTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 1, 25, 10, 2, 1), )
if mibBuilder.loadTexts: vclFrTeLogPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: vclFrTeLogPortTable.setDescription('')
vclFrTeLogPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 1, 25, 10, 2, 1, 1), ).setIndexNames((0, "PCE-MIB", "vclFrTeLpLogPortId"))
if mibBuilder.loadTexts: vclFrTeLogPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vclFrTeLogPortEntry.setDescription('An entry of vclFrTeLogPortTable.')
vclFrTeLpLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 25, 10, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vclFrTeLpLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: vclFrTeLpLogPortId.setDescription('')
vclFrTeLpInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 25, 10, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("l0", 1), ("l1", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vclFrTeLpInterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: vclFrTeLpInterfaceId.setDescription('')
vclFrTeLpConfigId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 25, 10, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vclFrTeLpConfigId.setStatus('mandatory')
if mibBuilder.loadTexts: vclFrTeLpConfigId.setDescription('')
vclFrTeLpLmi = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 25, 10, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("lmiUni", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vclFrTeLpLmi.setStatus('mandatory')
if mibBuilder.loadTexts: vclFrTeLpLmi.setDescription('')
vclFrSwitchEquipment = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 30, 1, 25, 10, 3))
vclFrSeLogPortTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 1, 25, 10, 3, 1), )
if mibBuilder.loadTexts: vclFrSeLogPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: vclFrSeLogPortTable.setDescription('')
vclFrSeLogPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 1, 25, 10, 3, 1, 1), ).setIndexNames((0, "PCE-MIB", "vclFrSeLpLogPortId"))
if mibBuilder.loadTexts: vclFrSeLogPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vclFrSeLogPortEntry.setDescription('An entry of vclFrSeLogPortTable.')
vclFrSeLpLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 25, 10, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vclFrSeLpLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: vclFrSeLpLogPortId.setDescription('')
vclFrSeLpInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 25, 10, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("l0", 1), ("l1", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vclFrSeLpInterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: vclFrSeLpInterfaceId.setDescription('')
vclFrSeLpConfigId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 25, 10, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vclFrSeLpConfigId.setStatus('mandatory')
if mibBuilder.loadTexts: vclFrSeLpConfigId.setDescription('')
vclFrConfigurationTe = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 30, 1, 25, 10, 4))
vclFrLmiParameterTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 1, 25, 10, 4, 1), )
if mibBuilder.loadTexts: vclFrLmiParameterTable.setStatus('mandatory')
if mibBuilder.loadTexts: vclFrLmiParameterTable.setDescription('')
vclFrLmiParameterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 1, 25, 10, 4, 1, 1), ).setIndexNames((0, "PCE-MIB", "vclFrLmiParaConfigId"))
if mibBuilder.loadTexts: vclFrLmiParameterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vclFrLmiParameterEntry.setDescription('An entry of vclFrLmiParameterTable.')
vclFrLmiParaConfigId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 25, 10, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vclFrLmiParaConfigId.setStatus('mandatory')
if mibBuilder.loadTexts: vclFrLmiParaConfigId.setDescription('')
vclFrLmiParaDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 25, 10, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vclFrLmiParaDlci.setStatus('mandatory')
if mibBuilder.loadTexts: vclFrLmiParaDlci.setDescription('')
vclFrLmiParaStandard = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 25, 10, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ansiT1-617d", 1), ("itutQ933a", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vclFrLmiParaStandard.setStatus('mandatory')
if mibBuilder.loadTexts: vclFrLmiParaStandard.setDescription('')
vclFrLmiParaAccessibilityCondition = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 25, 10, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vclFrLmiParaAccessibilityCondition.setStatus('mandatory')
if mibBuilder.loadTexts: vclFrLmiParaAccessibilityCondition.setDescription('')
vclFrLmiParaN391FullStatusPollCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 25, 10, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vclFrLmiParaN391FullStatusPollCount.setStatus('mandatory')
if mibBuilder.loadTexts: vclFrLmiParaN391FullStatusPollCount.setDescription('')
vclFrLmiParaN392ErrorThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 25, 10, 4, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vclFrLmiParaN392ErrorThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: vclFrLmiParaN392ErrorThreshold.setDescription('')
vclFrLmiParaN393MonitoredEventCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 25, 10, 4, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vclFrLmiParaN393MonitoredEventCount.setStatus('mandatory')
if mibBuilder.loadTexts: vclFrLmiParaN393MonitoredEventCount.setDescription('')
vclFrLmiParaT391LinkIntegPollTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 25, 10, 4, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vclFrLmiParaT391LinkIntegPollTimer.setStatus('mandatory')
if mibBuilder.loadTexts: vclFrLmiParaT391LinkIntegPollTimer.setDescription('')
vclFrConfigurationSe = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 30, 1, 25, 10, 5))
vclFrSeSignallingTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 1, 25, 10, 5, 1), )
if mibBuilder.loadTexts: vclFrSeSignallingTable.setStatus('mandatory')
if mibBuilder.loadTexts: vclFrSeSignallingTable.setDescription('')
vclFrSeSignallingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 1, 25, 10, 5, 1, 1), ).setIndexNames((0, "PCE-MIB", "vclFrSeSigConfigId"))
if mibBuilder.loadTexts: vclFrSeSignallingEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vclFrSeSignallingEntry.setDescription('An entry of vclFrSeSignallingTable.')
vclFrSeSigConfigId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 25, 10, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vclFrSeSigConfigId.setStatus('mandatory')
if mibBuilder.loadTexts: vclFrSeSigConfigId.setDescription('')
vclFrSeSigOuputTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 25, 10, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 51000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vclFrSeSigOuputTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: vclFrSeSigOuputTimeout.setDescription('')
vclFrSeSigSignalOutputWinSize = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 25, 10, 5, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vclFrSeSigSignalOutputWinSize.setStatus('mandatory')
if mibBuilder.loadTexts: vclFrSeSigSignalOutputWinSize.setDescription('')
vclFrSeSigN200RetransMaxCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 25, 10, 5, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vclFrSeSigN200RetransMaxCount.setStatus('mandatory')
if mibBuilder.loadTexts: vclFrSeSigN200RetransMaxCount.setDescription('')
vclFrSeSigT200RetransTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 25, 10, 5, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 25500))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vclFrSeSigT200RetransTimer.setStatus('mandatory')
if mibBuilder.loadTexts: vclFrSeSigT200RetransTimer.setDescription('')
vclFrSeSigT203InactivityTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 25, 10, 5, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vclFrSeSigT203InactivityTimer.setStatus('mandatory')
if mibBuilder.loadTexts: vclFrSeSigT203InactivityTimer.setDescription('')
vclFrSeSigT303SetupResponseTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 25, 10, 5, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vclFrSeSigT303SetupResponseTimer.setStatus('mandatory')
if mibBuilder.loadTexts: vclFrSeSigT303SetupResponseTimer.setDescription('')
vclFrSeSigT305DisconnectResponseTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 25, 10, 5, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vclFrSeSigT305DisconnectResponseTimer.setStatus('mandatory')
if mibBuilder.loadTexts: vclFrSeSigT305DisconnectResponseTimer.setDescription('')
vclFrSeSigT308ReleaseResponseTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 25, 10, 5, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vclFrSeSigT308ReleaseResponseTimer.setStatus('mandatory')
if mibBuilder.loadTexts: vclFrSeSigT308ReleaseResponseTimer.setDescription('')
vclFrSeSigT310CallProceedingTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 25, 10, 5, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vclFrSeSigT310CallProceedingTimer.setStatus('mandatory')
if mibBuilder.loadTexts: vclFrSeSigT310CallProceedingTimer.setDescription('')
vclFrSeSigT316RestartAcknowledgeTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 25, 10, 5, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vclFrSeSigT316RestartAcknowledgeTimer.setStatus('mandatory')
if mibBuilder.loadTexts: vclFrSeSigT316RestartAcknowledgeTimer.setDescription('')
vcWanSwitch = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 30, 1, 30))
vcwEquipParams = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 30, 1, 30, 1))
vcwEquipDnicZoAddr = MibScalar((1, 3, 6, 1, 4, 1, 866, 30, 1, 30, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(3, 3)).setFixedLength(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcwEquipDnicZoAddr.setStatus('mandatory')
if mibBuilder.loadTexts: vcwEquipDnicZoAddr.setDescription('')
vcwEquipVoiceRoutingServicePortAddr = MibScalar((1, 3, 6, 1, 4, 1, 866, 30, 1, 30, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcwEquipVoiceRoutingServicePortAddr.setStatus('mandatory')
if mibBuilder.loadTexts: vcwEquipVoiceRoutingServicePortAddr.setDescription('')
vcwEquipIpVirtualPortAddr = MibScalar((1, 3, 6, 1, 4, 1, 866, 30, 1, 30, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcwEquipIpVirtualPortAddr.setStatus('mandatory')
if mibBuilder.loadTexts: vcwEquipIpVirtualPortAddr.setDescription('')
vcwEquipRemoteConfPortAddr = MibScalar((1, 3, 6, 1, 4, 1, 866, 30, 1, 30, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcwEquipRemoteConfPortAddr.setStatus('mandatory')
if mibBuilder.loadTexts: vcwEquipRemoteConfPortAddr.setDescription('')
vcwEquipVoiceVirtualPortAddr = MibScalar((1, 3, 6, 1, 4, 1, 866, 30, 1, 30, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcwEquipVoiceVirtualPortAddr.setStatus('mandatory')
if mibBuilder.loadTexts: vcwEquipVoiceVirtualPortAddr.setDescription('')
vcwEquipSVCDisconnectOnCongestion = MibScalar((1, 3, 6, 1, 4, 1, 866, 30, 1, 30, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcwEquipSVCDisconnectOnCongestion.setStatus('mandatory')
if mibBuilder.loadTexts: vcwEquipSVCDisconnectOnCongestion.setDescription('')
vcwEquipOutLogPort = MibScalar((1, 3, 6, 1, 4, 1, 866, 30, 1, 30, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcwEquipOutLogPort.setStatus('mandatory')
if mibBuilder.loadTexts: vcwEquipOutLogPort.setDescription('')
vcwABPvcLpTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 1, 30, 2), )
if mibBuilder.loadTexts: vcwABPvcLpTable.setStatus('mandatory')
if mibBuilder.loadTexts: vcwABPvcLpTable.setDescription('')
vcwABPvcLpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 1, 30, 2, 1), ).setIndexNames((0, "PCE-MIB", "vcwABPvcLpId"))
if mibBuilder.loadTexts: vcwABPvcLpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vcwABPvcLpEntry.setDescription('An entry of vcwABPvcLpTable.')
vcwABPvcLpId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 30, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcwABPvcLpId.setStatus('mandatory')
if mibBuilder.loadTexts: vcwABPvcLpId.setDescription('')
vcwABPvcLpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 30, 2, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcwABPvcLpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: vcwABPvcLpAddress.setDescription('')
vcwWanRouteTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 1, 30, 3), )
if mibBuilder.loadTexts: vcwWanRouteTable.setStatus('mandatory')
if mibBuilder.loadTexts: vcwWanRouteTable.setDescription('')
vcwWanRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 1, 30, 3, 1), ).setIndexNames((0, "PCE-MIB", "vcwWanRouteDnicZoAddress"))
if mibBuilder.loadTexts: vcwWanRouteEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vcwWanRouteEntry.setDescription('An entry of vcwWanRouteTable.')
vcwWanRouteDnicZoAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 30, 3, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(3, 3)).setFixedLength(3)).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcwWanRouteDnicZoAddress.setStatus('mandatory')
if mibBuilder.loadTexts: vcwWanRouteDnicZoAddress.setDescription('')
vcwWanRouteStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 30, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcwWanRouteStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vcwWanRouteStatus.setDescription('')
vcwWanRouteLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 30, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcwWanRouteLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: vcwWanRouteLogPortId.setDescription('')
vcVirtualPorts = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 30, 1, 35))
vcvVirtualPortTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 1), )
if mibBuilder.loadTexts: vcvVirtualPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: vcvVirtualPortTable.setDescription('')
vcvVirtualPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 1, 1), ).setIndexNames((0, "PCE-MIB", "vcvVirtualPortId"))
if mibBuilder.loadTexts: vcvVirtualPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vcvVirtualPortEntry.setDescription('An entry of vcvVirtualPortTable.')
vcvVirtualPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("vpVoix", 1), ("vpIp", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcvVirtualPortId.setStatus('mandatory')
if mibBuilder.loadTexts: vcvVirtualPortId.setDescription('')
vcvIpVirtualPort = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 5))
vcvIpLocalTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 5, 1), )
if mibBuilder.loadTexts: vcvIpLocalTable.setStatus('mandatory')
if mibBuilder.loadTexts: vcvIpLocalTable.setDescription('')
vcvIpLocalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 5, 1, 1), ).setIndexNames((0, "PCE-MIB", "vcvIpLocVirtualPortId"))
if mibBuilder.loadTexts: vcvIpLocalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vcvIpLocalEntry.setDescription('An entry of vcvIpLocalTable.')
vcvIpLocVirtualPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("vpVoix", 1), ("vpIp", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcvIpLocVirtualPortId.setStatus('mandatory')
if mibBuilder.loadTexts: vcvIpLocVirtualPortId.setDescription('')
vcvIpLocAddressHost = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 5, 1, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvIpLocAddressHost.setStatus('mandatory')
if mibBuilder.loadTexts: vcvIpLocAddressHost.setDescription('')
vcvIpLocSubNetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 5, 1, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvIpLocSubNetMask.setStatus('mandatory')
if mibBuilder.loadTexts: vcvIpLocSubNetMask.setDescription('')
vcvIpLocMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 5, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(576, 9180))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcvIpLocMtu.setStatus('mandatory')
if mibBuilder.loadTexts: vcvIpLocMtu.setDescription('')
vcvIpLocRouteNextHop = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 5, 1, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvIpLocRouteNextHop.setStatus('mandatory')
if mibBuilder.loadTexts: vcvIpLocRouteNextHop.setDescription('')
vcvIpLocMinimumRecallTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 5, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvIpLocMinimumRecallTimer.setStatus('mandatory')
if mibBuilder.loadTexts: vcvIpLocMinimumRecallTimer.setDescription('')
vcvIpLocSvcClearCallTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 5, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvIpLocSvcClearCallTimer.setStatus('mandatory')
if mibBuilder.loadTexts: vcvIpLocSvcClearCallTimer.setDescription('')
vcvIpLocSvcCallRetryCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 5, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvIpLocSvcCallRetryCount.setStatus('mandatory')
if mibBuilder.loadTexts: vcvIpLocSvcCallRetryCount.setDescription('')
vcvSnmp = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 5, 5))
vcvSnmpGen = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 5, 5, 1))
vcvSnmpGenVirtualPortId = MibScalar((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 5, 5, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("vpVoix", 1), ("vpIp", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvSnmpGenVirtualPortId.setStatus('mandatory')
if mibBuilder.loadTexts: vcvSnmpGenVirtualPortId.setDescription('')
vcvSnmpGenCommunityStringReadOnly = MibScalar((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 5, 5, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 14))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvSnmpGenCommunityStringReadOnly.setStatus('mandatory')
if mibBuilder.loadTexts: vcvSnmpGenCommunityStringReadOnly.setDescription('')
vcvSnmpGenCommunityStringReadWrite = MibScalar((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 5, 5, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 14))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvSnmpGenCommunityStringReadWrite.setStatus('mandatory')
if mibBuilder.loadTexts: vcvSnmpGenCommunityStringReadWrite.setDescription('')
vcvSnmpGenCommunityStringTrap = MibScalar((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 5, 5, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 14))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvSnmpGenCommunityStringTrap.setStatus('mandatory')
if mibBuilder.loadTexts: vcvSnmpGenCommunityStringTrap.setDescription('')
vcvSnmpGenAuthenticationFailureTrap = MibScalar((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 5, 5, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvSnmpGenAuthenticationFailureTrap.setStatus('mandatory')
if mibBuilder.loadTexts: vcvSnmpGenAuthenticationFailureTrap.setDescription('')
vcvSnmpManagerTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 5, 5, 2), )
if mibBuilder.loadTexts: vcvSnmpManagerTable.setStatus('mandatory')
if mibBuilder.loadTexts: vcvSnmpManagerTable.setDescription('')
vcvSnmpManagerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 5, 5, 2, 1), ).setIndexNames((0, "PCE-MIB", "vcvSnmpManagerIpAddress"))
if mibBuilder.loadTexts: vcvSnmpManagerEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vcvSnmpManagerEntry.setDescription('An entry of vcvSnmpManagerTable.')
vcvSnmpManagerIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 5, 5, 2, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcvSnmpManagerIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: vcvSnmpManagerIpAddress.setDescription('')
vcvSnmpManagerStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 5, 5, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvSnmpManagerStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vcvSnmpManagerStatus.setDescription('')
vcvSnmpManagerName = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 5, 5, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 12))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvSnmpManagerName.setStatus('mandatory')
if mibBuilder.loadTexts: vcvSnmpManagerName.setDescription('')
vcvSnmpManagerSendTraps = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 5, 5, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvSnmpManagerSendTraps.setStatus('mandatory')
if mibBuilder.loadTexts: vcvSnmpManagerSendTraps.setDescription('')
vcvSnmpManagerTrapsUdpPort = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 5, 5, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvSnmpManagerTrapsUdpPort.setStatus('mandatory')
if mibBuilder.loadTexts: vcvSnmpManagerTrapsUdpPort.setDescription('')
vcvRemoteConfTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 5, 5, 3), )
if mibBuilder.loadTexts: vcvRemoteConfTable.setStatus('mandatory')
if mibBuilder.loadTexts: vcvRemoteConfTable.setDescription('')
vcvRemoteConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 5, 5, 3, 1), ).setIndexNames((0, "PCE-MIB", "vcvRemoteConfName"))
if mibBuilder.loadTexts: vcvRemoteConfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vcvRemoteConfEntry.setDescription('An entry of vcvRemoteConfTable.')
vcvRemoteConfName = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 5, 5, 3, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcvRemoteConfName.setStatus('mandatory')
if mibBuilder.loadTexts: vcvRemoteConfName.setDescription('')
vcvRemoteConfStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 5, 5, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvRemoteConfStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vcvRemoteConfStatus.setDescription('')
vcvRemoteConfWanAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 5, 5, 3, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvRemoteConfWanAddress.setStatus('mandatory')
if mibBuilder.loadTexts: vcvRemoteConfWanAddress.setDescription('')
vcvTftpTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 5, 10), )
if mibBuilder.loadTexts: vcvTftpTable.setStatus('mandatory')
if mibBuilder.loadTexts: vcvTftpTable.setDescription('')
vcvTftpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 5, 10, 1), ).setIndexNames((0, "PCE-MIB", "vcvTftpIpAddress"))
if mibBuilder.loadTexts: vcvTftpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vcvTftpEntry.setDescription('An entry of vcvTftpTable.')
vcvTftpIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 5, 10, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcvTftpIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: vcvTftpIpAddress.setDescription('')
vcvTftpStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 5, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvTftpStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vcvTftpStatus.setDescription('')
vcvTftpName = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 5, 10, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvTftpName.setStatus('mandatory')
if mibBuilder.loadTexts: vcvTftpName.setDescription('')
vcvTftpRetryTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 5, 10, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 600))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvTftpRetryTimer.setStatus('mandatory')
if mibBuilder.loadTexts: vcvTftpRetryTimer.setDescription('')
vcvTftpInactTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 5, 10, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 3600))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvTftpInactTimer.setStatus('mandatory')
if mibBuilder.loadTexts: vcvTftpInactTimer.setDescription('')
vcvRemoteNetToMediaTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 5, 15), )
if mibBuilder.loadTexts: vcvRemoteNetToMediaTable.setStatus('mandatory')
if mibBuilder.loadTexts: vcvRemoteNetToMediaTable.setDescription('')
vcvRemoteNetToMediaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 5, 15, 1), ).setIndexNames((0, "PCE-MIB", "vcvRemNetIpAddress"))
if mibBuilder.loadTexts: vcvRemoteNetToMediaEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vcvRemoteNetToMediaEntry.setDescription('An entry of vcvRemoteNetToMediaTable.')
vcvRemNetIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 5, 15, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcvRemNetIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: vcvRemNetIpAddress.setDescription('')
vcvRemNetStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 5, 15, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvRemNetStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vcvRemNetStatus.setDescription('')
vcvRemNetWanAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 5, 15, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvRemNetWanAddress.setStatus('mandatory')
if mibBuilder.loadTexts: vcvRemNetWanAddress.setDescription('')
vcvRemNetEncapsulation = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 5, 15, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("fripSimple", 1), ("fripRFC", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvRemNetEncapsulation.setStatus('mandatory')
if mibBuilder.loadTexts: vcvRemNetEncapsulation.setDescription('')
vcvVoiceVirtualPort = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10))
vcvVoiceGen = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 1))
vcvVoiceVirtualPortId = MibScalar((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("vpVoix", 1), ("vpIp", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvVoiceVirtualPortId.setStatus('mandatory')
if mibBuilder.loadTexts: vcvVoiceVirtualPortId.setDescription('')
vcvVoiceTransportTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 2), )
if mibBuilder.loadTexts: vcvVoiceTransportTable.setStatus('mandatory')
if mibBuilder.loadTexts: vcvVoiceTransportTable.setDescription('')
vcvVoiceTransportEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 2, 1), ).setIndexNames((0, "PCE-MIB", "vcvVoiceTransProfileId"))
if mibBuilder.loadTexts: vcvVoiceTransportEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vcvVoiceTransportEntry.setDescription('An entry of vcvVoiceTransportTable.')
vcvVoiceTransProfileId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvVoiceTransProfileId.setStatus('mandatory')
if mibBuilder.loadTexts: vcvVoiceTransProfileId.setDescription('')
vcvVoiceTransEncapsulationMode = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("frf", 1), ("private", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvVoiceTransEncapsulationMode.setStatus('mandatory')
if mibBuilder.loadTexts: vcvVoiceTransEncapsulationMode.setDescription('')
vcvVoiceTransMaxPayLoadNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvVoiceTransMaxPayLoadNumber.setStatus('mandatory')
if mibBuilder.loadTexts: vcvVoiceTransMaxPayLoadNumber.setDescription('')
vcvVoiceTransCompressionAlgorithm = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("g728", 1), ("celp", 2), ("g729", 3), ("g729A", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvVoiceTransCompressionAlgorithm.setStatus('mandatory')
if mibBuilder.loadTexts: vcvVoiceTransCompressionAlgorithm.setDescription('')
vcvVoiceTransJitterCompensation = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 9))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvVoiceTransJitterCompensation.setStatus('mandatory')
if mibBuilder.loadTexts: vcvVoiceTransJitterCompensation.setDescription('')
vcvVoiceTransVoicePacketsCombination = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvVoiceTransVoicePacketsCombination.setStatus('mandatory')
if mibBuilder.loadTexts: vcvVoiceTransVoicePacketsCombination.setDescription('')
vcvVoiceTransQosBc = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("s9600", 1), ("s14400", 2), ("s19200", 3), ("s32000", 4), ("s38400", 5), ("s48000", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvVoiceTransQosBc.setStatus('mandatory')
if mibBuilder.loadTexts: vcvVoiceTransQosBc.setDescription('')
vcvVoiceTransQosBe = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("s9600", 1), ("s14400", 2), ("s19200", 3), ("s32000", 4), ("s38400", 5), ("s48000", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvVoiceTransQosBe.setStatus('mandatory')
if mibBuilder.loadTexts: vcvVoiceTransQosBe.setDescription('')
vcvVoiceTransQosCir = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("s9600", 1), ("s14400", 2), ("s19200", 3), ("s32000", 4), ("s38400", 5), ("s48000", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvVoiceTransQosCir.setStatus('mandatory')
if mibBuilder.loadTexts: vcvVoiceTransQosCir.setDescription('')
vcvVoiceSuscriberTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 3), )
if mibBuilder.loadTexts: vcvVoiceSuscriberTable.setStatus('mandatory')
if mibBuilder.loadTexts: vcvVoiceSuscriberTable.setDescription('')
vcvVoiceSuscriberEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 3, 1), ).setIndexNames((0, "PCE-MIB", "vcvVoiceSuscrOrderNumber"), (0, "PCE-MIB", "vcvVoiceSuscrNumber"))
if mibBuilder.loadTexts: vcvVoiceSuscriberEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vcvVoiceSuscriberEntry.setDescription('An entry of vcvVoiceSuscriberTable.')
vcvVoiceSuscrOrderNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcvVoiceSuscrOrderNumber.setStatus('mandatory')
if mibBuilder.loadTexts: vcvVoiceSuscrOrderNumber.setDescription('')
vcvVoiceSuscrNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 3, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 21))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcvVoiceSuscrNumber.setStatus('mandatory')
if mibBuilder.loadTexts: vcvVoiceSuscrNumber.setDescription('')
vcvVoiceSuscrStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvVoiceSuscrStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vcvVoiceSuscrStatus.setDescription('')
vcvVoiceSuscrTransportNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("fr", 1), ("other", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcvVoiceSuscrTransportNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: vcvVoiceSuscrTransportNetwork.setDescription('')
vcvVoiceSuscrTransportNetworkAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 3, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvVoiceSuscrTransportNetworkAddress.setStatus('mandatory')
if mibBuilder.loadTexts: vcvVoiceSuscrTransportNetworkAddress.setDescription('')
vcvVoiceSuscrTransportProfileId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 3, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvVoiceSuscrTransportProfileId.setStatus('mandatory')
if mibBuilder.loadTexts: vcvVoiceSuscrTransportProfileId.setDescription('')
vcvVoiceSuscrRemovedDigitNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 3, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 21))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvVoiceSuscrRemovedDigitNumber.setStatus('mandatory')
if mibBuilder.loadTexts: vcvVoiceSuscrRemovedDigitNumber.setDescription('')
vcvVoiceSuscrInsPrefix = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 3, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 21))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvVoiceSuscrInsPrefix.setStatus('mandatory')
if mibBuilder.loadTexts: vcvVoiceSuscrInsPrefix.setDescription('')
vcvVoiceSuscrInsSuffix = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 3, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 21))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvVoiceSuscrInsSuffix.setStatus('mandatory')
if mibBuilder.loadTexts: vcvVoiceSuscrInsSuffix.setDescription('')
vcvVoiceSwTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 4), )
if mibBuilder.loadTexts: vcvVoiceSwTable.setStatus('mandatory')
if mibBuilder.loadTexts: vcvVoiceSwTable.setDescription('')
vcvVoiceSwEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 4, 1), ).setIndexNames((0, "PCE-MIB", "vcvVoiceSwOrderNumber"), (0, "PCE-MIB", "vcvVoiceSwSuscriberNumber"))
if mibBuilder.loadTexts: vcvVoiceSwEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vcvVoiceSwEntry.setDescription('An entry of vcvVoiceSwTable.')
vcvVoiceSwOrderNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcvVoiceSwOrderNumber.setStatus('mandatory')
if mibBuilder.loadTexts: vcvVoiceSwOrderNumber.setDescription('')
vcvVoiceSwSuscriberNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 4, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 21))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcvVoiceSwSuscriberNumber.setStatus('mandatory')
if mibBuilder.loadTexts: vcvVoiceSwSuscriberNumber.setDescription('')
vcvVoiceSwStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvVoiceSwStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vcvVoiceSwStatus.setDescription('')
vcvVoiceSwLogPortSetId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvVoiceSwLogPortSetId.setStatus('mandatory')
if mibBuilder.loadTexts: vcvVoiceSwLogPortSetId.setDescription('')
vcvVoiceSwRemovedDigitNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 4, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 21))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvVoiceSwRemovedDigitNumber.setStatus('mandatory')
if mibBuilder.loadTexts: vcvVoiceSwRemovedDigitNumber.setDescription('')
vcvVoiceSwInsPrefix = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 4, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 21))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvVoiceSwInsPrefix.setStatus('mandatory')
if mibBuilder.loadTexts: vcvVoiceSwInsPrefix.setDescription('')
vcvVoiceSwInsSuffix = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 4, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 21))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvVoiceSwInsSuffix.setStatus('mandatory')
if mibBuilder.loadTexts: vcvVoiceSwInsSuffix.setDescription('')
vcvDialingReceptTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 5), )
if mibBuilder.loadTexts: vcvDialingReceptTable.setStatus('mandatory')
if mibBuilder.loadTexts: vcvDialingReceptTable.setDescription('')
vcvDialingReceptEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 5, 1), ).setIndexNames((0, "PCE-MIB", "vcvDialRxSuscriberNumber"))
if mibBuilder.loadTexts: vcvDialingReceptEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vcvDialingReceptEntry.setDescription('An entry of vcvDialingReceptTable.')
vcvDialRxSuscriberNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 5, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 21))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcvDialRxSuscriberNumber.setStatus('mandatory')
if mibBuilder.loadTexts: vcvDialRxSuscriberNumber.setDescription('')
vcvDialRxStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvDialRxStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vcvDialRxStatus.setDescription('')
vcvDialRxNumberLength = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 5, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 21))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvDialRxNumberLength.setStatus('mandatory')
if mibBuilder.loadTexts: vcvDialRxNumberLength.setDescription('')
vcvDialRxEndOfDialingTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 5, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvDialRxEndOfDialingTimer.setStatus('mandatory')
if mibBuilder.loadTexts: vcvDialRxEndOfDialingTimer.setDescription('')
vcvVoiceLogPort = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10))
vcvVoiceLogicalPortTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 1), )
if mibBuilder.loadTexts: vcvVoiceLogicalPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: vcvVoiceLogicalPortTable.setDescription('')
vcvVoiceLogicalPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 1, 1), ).setIndexNames((0, "PCE-MIB", "vcvVoiceLogPortId"))
if mibBuilder.loadTexts: vcvVoiceLogicalPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vcvVoiceLogicalPortEntry.setDescription('An entry of vcvVoiceLogicalPortTable.')
vcvVoiceLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcvVoiceLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: vcvVoiceLogPortId.setDescription('')
vcvVoiceLogPortStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvVoiceLogPortStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vcvVoiceLogPortStatus.setDescription('')
vcvVoiceLogPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("emPermanent", 1), ("emSwitched", 2), ("fxx", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvVoiceLogPortType.setStatus('mandatory')
if mibBuilder.loadTexts: vcvVoiceLogPortType.setDescription('')
vcvProfileTone = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 5))
vcvToneGenTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 5, 1), )
if mibBuilder.loadTexts: vcvToneGenTable.setStatus('mandatory')
if mibBuilder.loadTexts: vcvToneGenTable.setDescription('')
vcvToneGenEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 5, 1, 1), ).setIndexNames((0, "PCE-MIB", "vcvToneGenProfileId"))
if mibBuilder.loadTexts: vcvToneGenEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vcvToneGenEntry.setDescription('An entry of vcvToneGenTable.')
vcvToneGenProfileId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcvToneGenProfileId.setStatus('mandatory')
if mibBuilder.loadTexts: vcvToneGenProfileId.setDescription('')
vcvToneGenLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvToneGenLevel.setStatus('mandatory')
if mibBuilder.loadTexts: vcvToneGenLevel.setDescription('')
vcvToneTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 5, 2), )
if mibBuilder.loadTexts: vcvToneTable.setStatus('mandatory')
if mibBuilder.loadTexts: vcvToneTable.setDescription('')
vcvToneEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 5, 2, 1), ).setIndexNames((0, "PCE-MIB", "vcvToneProfileId"), (0, "PCE-MIB", "vcvToneType"))
if mibBuilder.loadTexts: vcvToneEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vcvToneEntry.setDescription('An entry of vcvToneTable.')
vcvToneProfileId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 5, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcvToneProfileId.setStatus('mandatory')
if mibBuilder.loadTexts: vcvToneProfileId.setDescription('')
vcvToneType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 5, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("dialTone", 1), ("trouble", 2), ("congestion", 3), ("busy", 4), ("callBack", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcvToneType.setStatus('mandatory')
if mibBuilder.loadTexts: vcvToneType.setDescription('')
vcvToneEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 5, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvToneEnable.setStatus('mandatory')
if mibBuilder.loadTexts: vcvToneEnable.setDescription('')
vcvToneFreq1 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 5, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvToneFreq1.setStatus('mandatory')
if mibBuilder.loadTexts: vcvToneFreq1.setDescription('')
vcvToneDuration1 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 5, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 500))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvToneDuration1.setStatus('mandatory')
if mibBuilder.loadTexts: vcvToneDuration1.setDescription('')
vcvToneFreq2 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 5, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvToneFreq2.setStatus('mandatory')
if mibBuilder.loadTexts: vcvToneFreq2.setDescription('')
vcvToneDuration2 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 5, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 500))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvToneDuration2.setStatus('mandatory')
if mibBuilder.loadTexts: vcvToneDuration2.setDescription('')
vcvVoiceLogicalPortEM = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 10))
vcvEMPerm = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 10, 1))
vcvEMPermTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 10, 1, 1), )
if mibBuilder.loadTexts: vcvEMPermTable.setStatus('mandatory')
if mibBuilder.loadTexts: vcvEMPermTable.setDescription('')
vcvEMPermEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 10, 1, 1, 1), ).setIndexNames((0, "PCE-MIB", "vcvEMPermLpId"))
if mibBuilder.loadTexts: vcvEMPermEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vcvEMPermEntry.setDescription('An entry of vcvEMPermTable.')
vcvEMPermLpId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 10, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcvEMPermLpId.setStatus('mandatory')
if mibBuilder.loadTexts: vcvEMPermLpId.setDescription('')
vcvEMPermCommunicationMode = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 10, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dte", 1), ("dce", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvEMPermCommunicationMode.setStatus('mandatory')
if mibBuilder.loadTexts: vcvEMPermCommunicationMode.setDescription('')
vcvEMPermRemoteNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 10, 1, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 21))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvEMPermRemoteNumber.setStatus('mandatory')
if mibBuilder.loadTexts: vcvEMPermRemoteNumber.setDescription('')
vcvEMPermInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 10, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("v0", 1), ("v1", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvEMPermInterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: vcvEMPermInterfaceId.setDescription('')
vcvEMSw = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 10, 2))
vcvEMSwTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 10, 2, 1), )
if mibBuilder.loadTexts: vcvEMSwTable.setStatus('mandatory')
if mibBuilder.loadTexts: vcvEMSwTable.setDescription('')
vcvEMSwEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 10, 2, 1, 1), ).setIndexNames((0, "PCE-MIB", "vcvEMSwLpId"))
if mibBuilder.loadTexts: vcvEMSwEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vcvEMSwEntry.setDescription('An entry of vcvEMSwTable.')
vcvEMSwLpId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 10, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcvEMSwLpId.setStatus('mandatory')
if mibBuilder.loadTexts: vcvEMSwLpId.setDescription('')
vcvEMSwLogPortSetId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 10, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvEMSwLogPortSetId.setStatus('mandatory')
if mibBuilder.loadTexts: vcvEMSwLogPortSetId.setDescription('')
vcvEMSwCallType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 10, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("incoming", 1), ("outgoing", 2), ("mixed", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvEMSwCallType.setStatus('mandatory')
if mibBuilder.loadTexts: vcvEMSwCallType.setDescription('')
vcvEMSwRemoteNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 10, 2, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 21))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvEMSwRemoteNumber.setStatus('mandatory')
if mibBuilder.loadTexts: vcvEMSwRemoteNumber.setDescription('')
vcvEMSwConfigId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 10, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcvEMSwConfigId.setStatus('mandatory')
if mibBuilder.loadTexts: vcvEMSwConfigId.setDescription('')
vcvEMSwInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 10, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("v0", 1), ("v1", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvEMSwInterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: vcvEMSwInterfaceId.setDescription('')
vcvEMConfigTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 10, 2, 2), )
if mibBuilder.loadTexts: vcvEMConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: vcvEMConfigTable.setDescription('')
vcvEMConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 10, 2, 2, 1), ).setIndexNames((0, "PCE-MIB", "vcvEMConfId"))
if mibBuilder.loadTexts: vcvEMConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vcvEMConfigEntry.setDescription('An entry of vcvEMConfigTable.')
vcvEMConfId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 10, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcvEMConfId.setStatus('mandatory')
if mibBuilder.loadTexts: vcvEMConfId.setDescription('')
vcvEMConfCallSignalling = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 10, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("nColisee", 1), ("uColisee", 2), ("simm", 3), ("sDelay", 4), ("swink", 5), ("noResp", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvEMConfCallSignalling.setStatus('mandatory')
if mibBuilder.loadTexts: vcvEMConfCallSignalling.setDescription('')
vcvEMConfDialingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 10, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dec", 1), ("dtmf", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvEMConfDialingMode.setStatus('mandatory')
if mibBuilder.loadTexts: vcvEMConfDialingMode.setDescription('')
vcvEMConfDialingTimeOut = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 10, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvEMConfDialingTimeOut.setStatus('mandatory')
if mibBuilder.loadTexts: vcvEMConfDialingTimeOut.setDescription('')
vcvEMConfSigChannelDiscTimeOut = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 10, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvEMConfSigChannelDiscTimeOut.setStatus('mandatory')
if mibBuilder.loadTexts: vcvEMConfSigChannelDiscTimeOut.setDescription('')
vcvEMConfTimeBetweenSuccOutCall = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 10, 2, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvEMConfTimeBetweenSuccOutCall.setStatus('mandatory')
if mibBuilder.loadTexts: vcvEMConfTimeBetweenSuccOutCall.setDescription('')
vcvEMConfLineInterfacePolarity = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 10, 2, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("inverted", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvEMConfLineInterfacePolarity.setStatus('mandatory')
if mibBuilder.loadTexts: vcvEMConfLineInterfacePolarity.setDescription('')
vcvEMConfMinLineSeizureAckTime = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 10, 2, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 50))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvEMConfMinLineSeizureAckTime.setStatus('mandatory')
if mibBuilder.loadTexts: vcvEMConfMinLineSeizureAckTime.setDescription('')
vcvEMConfMaxLineSeizureAckTime = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 10, 2, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 50))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvEMConfMaxLineSeizureAckTime.setStatus('mandatory')
if mibBuilder.loadTexts: vcvEMConfMaxLineSeizureAckTime.setDescription('')
vcvEMConfLineSeizureAckTime = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 10, 2, 2, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 50))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvEMConfLineSeizureAckTime.setStatus('mandatory')
if mibBuilder.loadTexts: vcvEMConfLineSeizureAckTime.setDescription('')
vcvEMConfClearToIncCallTime = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 10, 2, 2, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(3, 50))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvEMConfClearToIncCallTime.setStatus('mandatory')
if mibBuilder.loadTexts: vcvEMConfClearToIncCallTime.setDescription('')
vcvEMConfSeizureAckPulseDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 10, 2, 2, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvEMConfSeizureAckPulseDuration.setStatus('mandatory')
if mibBuilder.loadTexts: vcvEMConfSeizureAckPulseDuration.setDescription('')
vcvEMConfMinSeizureAckPulseDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 10, 2, 2, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvEMConfMinSeizureAckPulseDuration.setStatus('mandatory')
if mibBuilder.loadTexts: vcvEMConfMinSeizureAckPulseDuration.setDescription('')
vcvEMConfDialingFormat = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 10, 2, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ds1", 1), ("ds2", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvEMConfDialingFormat.setStatus('mandatory')
if mibBuilder.loadTexts: vcvEMConfDialingFormat.setDescription('')
vcvEMConfInterdigitTime = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 10, 2, 2, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvEMConfInterdigitTime.setStatus('mandatory')
if mibBuilder.loadTexts: vcvEMConfInterdigitTime.setDescription('')
vcvEMConfPauseTime = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 10, 2, 2, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvEMConfPauseTime.setStatus('mandatory')
if mibBuilder.loadTexts: vcvEMConfPauseTime.setDescription('')
vcvEMConfDtmfDigitTime = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 10, 2, 2, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvEMConfDtmfDigitTime.setStatus('mandatory')
if mibBuilder.loadTexts: vcvEMConfDtmfDigitTime.setDescription('')
vcvEMConfDtmfDigitLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 10, 2, 2, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvEMConfDtmfDigitLevel.setStatus('mandatory')
if mibBuilder.loadTexts: vcvEMConfDtmfDigitLevel.setDescription('')
vcvEMConfDelayBeforeDialing = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 10, 2, 2, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvEMConfDelayBeforeDialing.setStatus('mandatory')
if mibBuilder.loadTexts: vcvEMConfDelayBeforeDialing.setDescription('')
vcvEMConfDigitReceptionTimeOut = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 10, 2, 2, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvEMConfDigitReceptionTimeOut.setStatus('mandatory')
if mibBuilder.loadTexts: vcvEMConfDigitReceptionTimeOut.setDescription('')
vcvEMConfEndOfDialingTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 10, 2, 2, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvEMConfEndOfDialingTimer.setStatus('mandatory')
if mibBuilder.loadTexts: vcvEMConfEndOfDialingTimer.setDescription('')
vcvEMConfToneProfile = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 10, 2, 2, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcvEMConfToneProfile.setStatus('mandatory')
if mibBuilder.loadTexts: vcvEMConfToneProfile.setDescription('')
vcvVoiceLogicalPortFxx = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 15))
vcvFxxLpTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 15, 1), )
if mibBuilder.loadTexts: vcvFxxLpTable.setStatus('mandatory')
if mibBuilder.loadTexts: vcvFxxLpTable.setDescription('')
vcvFxxLpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 15, 1, 1), ).setIndexNames((0, "PCE-MIB", "vcvFxxLpLogPortId"))
if mibBuilder.loadTexts: vcvFxxLpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vcvFxxLpEntry.setDescription('An entry of vcvFxxLpTable.')
vcvFxxLpLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 15, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcvFxxLpLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: vcvFxxLpLogPortId.setDescription('')
vcvFxxLpSetId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 15, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvFxxLpSetId.setStatus('mandatory')
if mibBuilder.loadTexts: vcvFxxLpSetId.setDescription('')
vcvFxxLpCallType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 15, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("incoming", 1), ("outgoing", 2), ("mixed", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvFxxLpCallType.setStatus('mandatory')
if mibBuilder.loadTexts: vcvFxxLpCallType.setDescription('')
vcvFxxLpRemoteNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 15, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 21))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvFxxLpRemoteNumber.setStatus('mandatory')
if mibBuilder.loadTexts: vcvFxxLpRemoteNumber.setDescription('')
vcvFxxLpConfigId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 15, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcvFxxLpConfigId.setStatus('mandatory')
if mibBuilder.loadTexts: vcvFxxLpConfigId.setDescription('')
vcvFxxLpInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 15, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("v0", 1), ("v1", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvFxxLpInterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: vcvFxxLpInterfaceId.setDescription('')
vcvFxxConfigTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 15, 2), )
if mibBuilder.loadTexts: vcvFxxConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: vcvFxxConfigTable.setDescription('')
vcvFxxConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 15, 2, 1), ).setIndexNames((0, "PCE-MIB", "vcvFxxConfId"))
if mibBuilder.loadTexts: vcvFxxConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vcvFxxConfigEntry.setDescription('An entry of vcvFxxConfigTable.')
vcvFxxConfId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 15, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcvFxxConfId.setStatus('mandatory')
if mibBuilder.loadTexts: vcvFxxConfId.setDescription('')
vcvFxxConfCallSignalling = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 15, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("fxx", 1), ("other", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcvFxxConfCallSignalling.setStatus('mandatory')
if mibBuilder.loadTexts: vcvFxxConfCallSignalling.setDescription('')
vcvFxxConfDialingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 15, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dec", 1), ("dtmf", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvFxxConfDialingMode.setStatus('mandatory')
if mibBuilder.loadTexts: vcvFxxConfDialingMode.setDescription('')
vcvFxxConfSigChannelDiscTimeOut = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 15, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvFxxConfSigChannelDiscTimeOut.setStatus('mandatory')
if mibBuilder.loadTexts: vcvFxxConfSigChannelDiscTimeOut.setDescription('')
vcvFxxConfTimeBetweenSuccOutCall = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 15, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvFxxConfTimeBetweenSuccOutCall.setStatus('mandatory')
if mibBuilder.loadTexts: vcvFxxConfTimeBetweenSuccOutCall.setDescription('')
vcvFxxConfDialingFormat = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 15, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ds1", 1), ("ds2", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvFxxConfDialingFormat.setStatus('mandatory')
if mibBuilder.loadTexts: vcvFxxConfDialingFormat.setDescription('')
vcvFxxConfInterdigitTime = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 15, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvFxxConfInterdigitTime.setStatus('mandatory')
if mibBuilder.loadTexts: vcvFxxConfInterdigitTime.setDescription('')
vcvFxxConfPauseTime = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 15, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvFxxConfPauseTime.setStatus('mandatory')
if mibBuilder.loadTexts: vcvFxxConfPauseTime.setDescription('')
vcvFxxConfDtmfDigitTime = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 15, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvFxxConfDtmfDigitTime.setStatus('mandatory')
if mibBuilder.loadTexts: vcvFxxConfDtmfDigitTime.setDescription('')
vcvFxxConfDtmfDigitLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 15, 2, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvFxxConfDtmfDigitLevel.setStatus('mandatory')
if mibBuilder.loadTexts: vcvFxxConfDtmfDigitLevel.setDescription('')
vcvFxxConfTxRecallSignalDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 15, 2, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 50))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvFxxConfTxRecallSignalDuration.setStatus('mandatory')
if mibBuilder.loadTexts: vcvFxxConfTxRecallSignalDuration.setDescription('')
vcvFxxConfDelayBeforeDialing = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 15, 2, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 50))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvFxxConfDelayBeforeDialing.setStatus('mandatory')
if mibBuilder.loadTexts: vcvFxxConfDelayBeforeDialing.setDescription('')
vcvFxxConfDialingTimeOut = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 15, 2, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvFxxConfDialingTimeOut.setStatus('mandatory')
if mibBuilder.loadTexts: vcvFxxConfDialingTimeOut.setDescription('')
vcvFxxConfDigitReceptionTimeOut = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 15, 2, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvFxxConfDigitReceptionTimeOut.setStatus('mandatory')
if mibBuilder.loadTexts: vcvFxxConfDigitReceptionTimeOut.setDescription('')
vcvFxxConfEndOfDialingTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 15, 2, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvFxxConfEndOfDialingTimer.setStatus('mandatory')
if mibBuilder.loadTexts: vcvFxxConfEndOfDialingTimer.setDescription('')
vcvFxxConfMinRxRecallSignalDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 15, 2, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 25))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvFxxConfMinRxRecallSignalDuration.setStatus('mandatory')
if mibBuilder.loadTexts: vcvFxxConfMinRxRecallSignalDuration.setDescription('')
vcvFxxConfToneProfile = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 15, 2, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcvFxxConfToneProfile.setStatus('mandatory')
if mibBuilder.loadTexts: vcvFxxConfToneProfile.setDescription('')
vcvFxxConfRingingProfile = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 15, 2, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcvFxxConfRingingProfile.setStatus('mandatory')
if mibBuilder.loadTexts: vcvFxxConfRingingProfile.setDescription('')
vcvFxxRingTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 15, 3), )
if mibBuilder.loadTexts: vcvFxxRingTable.setStatus('mandatory')
if mibBuilder.loadTexts: vcvFxxRingTable.setDescription('')
vcvFxxRingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 15, 3, 1), ).setIndexNames((0, "PCE-MIB", "vcvFxxRingProfile"))
if mibBuilder.loadTexts: vcvFxxRingEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vcvFxxRingEntry.setDescription('An entry of vcvFxxRingTable.')
vcvFxxRingProfile = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 15, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcvFxxRingProfile.setStatus('mandatory')
if mibBuilder.loadTexts: vcvFxxRingProfile.setDescription('')
vcvFxxRingFrequency = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 15, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 80))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvFxxRingFrequency.setStatus('mandatory')
if mibBuilder.loadTexts: vcvFxxRingFrequency.setDescription('')
vcvFxxRingTopDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 15, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 50))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvFxxRingTopDuration.setStatus('mandatory')
if mibBuilder.loadTexts: vcvFxxRingTopDuration.setDescription('')
vcvFxxRingSilenceDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 15, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 50))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvFxxRingSilenceDuration.setStatus('mandatory')
if mibBuilder.loadTexts: vcvFxxRingSilenceDuration.setDescription('')
vcvFxxRingMaxRingingTime = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 10, 15, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 600))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvFxxRingMaxRingingTime.setStatus('mandatory')
if mibBuilder.loadTexts: vcvFxxRingMaxRingingTime.setDescription('')
vcvAnalogLines = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 15))
vcvAnalogLineTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 15, 1), )
if mibBuilder.loadTexts: vcvAnalogLineTable.setStatus('mandatory')
if mibBuilder.loadTexts: vcvAnalogLineTable.setDescription('')
vcvAnalogLineEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 15, 1, 1), ).setIndexNames((0, "PCE-MIB", "vcvAnalogLineInterfaceId"))
if mibBuilder.loadTexts: vcvAnalogLineEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vcvAnalogLineEntry.setDescription('An entry of vcvAnalogLineTable.')
vcvAnalogLineInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 15, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("v0", 1), ("v1", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcvAnalogLineInterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: vcvAnalogLineInterfaceId.setDescription('')
vcvAnalogLineTypeInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 15, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("em", 1), ("fxo", 2), ("fxs", 3), ("ibx", 4), ("ia50Hz", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvAnalogLineTypeInterface.setStatus('mandatory')
if mibBuilder.loadTexts: vcvAnalogLineTypeInterface.setDescription('')
vcvAnalogLineVoiceProfile = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 15, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvAnalogLineVoiceProfile.setStatus('mandatory')
if mibBuilder.loadTexts: vcvAnalogLineVoiceProfile.setDescription('')
vcvVoiceProfileTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 15, 5), )
if mibBuilder.loadTexts: vcvVoiceProfileTable.setStatus('mandatory')
if mibBuilder.loadTexts: vcvVoiceProfileTable.setDescription('')
vcvVoiceProfileEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 15, 5, 1), ).setIndexNames((0, "PCE-MIB", "vcvVoiceProfId"))
if mibBuilder.loadTexts: vcvVoiceProfileEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vcvVoiceProfileEntry.setDescription('An entry of vcvVoiceProfileTable.')
vcvVoiceProfId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 15, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcvVoiceProfId.setStatus('mandatory')
if mibBuilder.loadTexts: vcvVoiceProfId.setDescription('')
vcvVoiceProfTransmitLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 15, 5, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 24))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvVoiceProfTransmitLevel.setStatus('mandatory')
if mibBuilder.loadTexts: vcvVoiceProfTransmitLevel.setDescription('')
vcvVoiceProfReceiveLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 15, 5, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvVoiceProfReceiveLevel.setStatus('mandatory')
if mibBuilder.loadTexts: vcvVoiceProfReceiveLevel.setDescription('')
vcvVoiceProfSilenceDetection = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 15, 5, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("no", 1), ("yes", 2), ("cng", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvVoiceProfSilenceDetection.setStatus('mandatory')
if mibBuilder.loadTexts: vcvVoiceProfSilenceDetection.setDescription('')
vcvVoiceProfSilenceDetectionLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 15, 5, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("low", 1), ("medium", 2), ("high", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvVoiceProfSilenceDetectionLevel.setStatus('mandatory')
if mibBuilder.loadTexts: vcvVoiceProfSilenceDetectionLevel.setDescription('')
vcvVoiceProfEchoCancellation = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 15, 5, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvVoiceProfEchoCancellation.setStatus('mandatory')
if mibBuilder.loadTexts: vcvVoiceProfEchoCancellation.setDescription('')
vcvVoiceProfEchoCancellationLength = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 15, 5, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("low", 1), ("medium", 2), ("high", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvVoiceProfEchoCancellationLength.setStatus('mandatory')
if mibBuilder.loadTexts: vcvVoiceProfEchoCancellationLength.setDescription('')
vcvVoiceProfNoiseFramesPeriodicity = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 15, 5, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(4, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvVoiceProfNoiseFramesPeriodicity.setStatus('mandatory')
if mibBuilder.loadTexts: vcvVoiceProfNoiseFramesPeriodicity.setDescription('')
vcvVoiceProfLoopActivation = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 15, 5, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("no", 1), ("local", 2), ("remote", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvVoiceProfLoopActivation.setStatus('mandatory')
if mibBuilder.loadTexts: vcvVoiceProfLoopActivation.setDescription('')
vcvVoiceProfFaxActivation = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 15, 5, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvVoiceProfFaxActivation.setStatus('mandatory')
if mibBuilder.loadTexts: vcvVoiceProfFaxActivation.setDescription('')
vcvVoiceProfMaximumFaxSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 15, 5, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("s9600", 1), ("s4800", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcvVoiceProfMaximumFaxSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: vcvVoiceProfMaximumFaxSpeed.setDescription('')
vcvVoicePhysicalPortTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 15, 10), )
if mibBuilder.loadTexts: vcvVoicePhysicalPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: vcvVoicePhysicalPortTable.setDescription('')
vcvVoicePhysicalPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 15, 10, 1), ).setIndexNames((0, "PCE-MIB", "vcvVoicePhysPortId"))
if mibBuilder.loadTexts: vcvVoicePhysicalPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vcvVoicePhysicalPortEntry.setDescription('An entry of vcvVoicePhysicalPortTable.')
vcvVoicePhysPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 15, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("v0", 1), ("v1", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcvVoicePhysPortId.setStatus('mandatory')
if mibBuilder.loadTexts: vcvVoicePhysPortId.setDescription('')
vcvVoicePhysPortConnector = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 1, 35, 10, 15, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("em", 1), ("fxofxs", 2), ("fxo", 3), ("fxs", 4), ("ia50", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcvVoicePhysPortConnector.setStatus('mandatory')
if mibBuilder.loadTexts: vcvVoicePhysPortConnector.setDescription('')
dcControl = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 30, 20, 1))
dcCtlDate = MibScalar((1, 3, 6, 1, 4, 1, 866, 30, 20, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(3, 3)).setFixedLength(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcCtlDate.setStatus('mandatory')
if mibBuilder.loadTexts: dcCtlDate.setDescription('')
dcCtlHour = MibScalar((1, 3, 6, 1, 4, 1, 866, 30, 20, 1, 2), TimeTicks()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcCtlHour.setStatus('mandatory')
if mibBuilder.loadTexts: dcCtlHour.setDescription('')
dcCtlConfigCom = MibScalar((1, 3, 6, 1, 4, 1, 866, 30, 20, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 5, 6, 10))).clone(namedValues=NamedValues(("ready", 1), ("check", 2), ("load", 5), ("save", 6), ("hotReset", 10)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcCtlConfigCom.setStatus('mandatory')
if mibBuilder.loadTexts: dcCtlConfigCom.setDescription('')
dcCtlConfigLoad = MibScalar((1, 3, 6, 1, 4, 1, 866, 30, 20, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 9))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcCtlConfigLoad.setStatus('mandatory')
if mibBuilder.loadTexts: dcCtlConfigLoad.setDescription('')
dcCtlErrorTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 20, 1, 10), )
if mibBuilder.loadTexts: dcCtlErrorTable.setStatus('mandatory')
if mibBuilder.loadTexts: dcCtlErrorTable.setDescription('')
dcCtlErrorEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 20, 1, 10, 1), ).setIndexNames((0, "PCE-MIB", "dcCtlErrorIndex"))
if mibBuilder.loadTexts: dcCtlErrorEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dcCtlErrorEntry.setDescription('An entry of dcCtlErrorTable.')
dcCtlErrorIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 1, 10, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcCtlErrorIndex.setStatus('mandatory')
if mibBuilder.loadTexts: dcCtlErrorIndex.setDescription('')
dcCtlErrorCode = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 1, 10, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcCtlErrorCode.setStatus('mandatory')
if mibBuilder.loadTexts: dcCtlErrorCode.setDescription('')
dcCtlErrorMessage = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 1, 10, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcCtlErrorMessage.setStatus('mandatory')
if mibBuilder.loadTexts: dcCtlErrorMessage.setDescription('')
dcCtlErrorTime = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 1, 10, 1, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcCtlErrorTime.setStatus('mandatory')
if mibBuilder.loadTexts: dcCtlErrorTime.setDescription('')
dcSystem = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 30, 20, 5))
dcSysConfActive = MibScalar((1, 3, 6, 1, 4, 1, 866, 30, 20, 5, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28))).clone(namedValues=NamedValues(("s1", 1), ("s2", 2), ("s3", 3), ("s4", 4), ("s5", 5), ("s6", 6), ("s7", 7), ("s8", 8), ("s9", 9), ("w0", 10), ("w1", 11), ("w2", 12), ("w3", 13), ("w4", 14), ("w5", 15), ("w6", 16), ("w7", 17), ("w8", 18), ("w9", 19), ("w0-1", 20), ("w0-2", 21), ("w0-3", 22), ("w0-4", 23), ("w0-5", 24), ("w0-6", 25), ("w0-7", 26), ("w0-8", 27), ("w0-9", 28)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcSysConfActive.setStatus('mandatory')
if mibBuilder.loadTexts: dcSysConfActive.setDescription('')
dcSysConfDate = MibScalar((1, 3, 6, 1, 4, 1, 866, 30, 20, 5, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(3, 3)).setFixedLength(3)).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcSysConfDate.setStatus('mandatory')
if mibBuilder.loadTexts: dcSysConfDate.setDescription('')
dcSysConfHour = MibScalar((1, 3, 6, 1, 4, 1, 866, 30, 20, 5, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcSysConfHour.setStatus('mandatory')
if mibBuilder.loadTexts: dcSysConfHour.setDescription('')
dcManagement = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 30, 20, 10))
dcmAlrmGenTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 20, 10, 1), )
if mibBuilder.loadTexts: dcmAlrmGenTable.setStatus('mandatory')
if mibBuilder.loadTexts: dcmAlrmGenTable.setDescription('')
dcmAlrmGenEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 20, 10, 1, 1), ).setIndexNames((0, "PCE-MIB", "dcmAlrmGenFamilyId"), (0, "PCE-MIB", "dcmAlrmGenTyp"))
if mibBuilder.loadTexts: dcmAlrmGenEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dcmAlrmGenEntry.setDescription('An entry of dcmAlrmGenTable.')
dcmAlrmGenFamilyId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 10, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("f00System", 1), ("f01Tftp", 2), ("f02Junction", 3), ("f03Lmi", 4), ("f04Svc", 5), ("f05Compression", 6), ("f06ServiceCanal", 7), ("f07Fax", 8), ("f08Switching", 9), ("f09Synchronization", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcmAlrmGenFamilyId.setStatus('mandatory')
if mibBuilder.loadTexts: dcmAlrmGenFamilyId.setDescription('')
dcmAlrmGenTyp = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 10, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("lnkReady208", 1), ("lnkNotReady209", 2), ("fatalError222", 3), ("reboot233", 4), ("dspOutofOrder257", 5), ("dspNoResourcesLeft258", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcmAlrmGenTyp.setStatus('mandatory')
if mibBuilder.loadTexts: dcmAlrmGenTyp.setDescription('')
dcmAlrmGenTrapSend = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 10, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcmAlrmGenTrapSend.setStatus('mandatory')
if mibBuilder.loadTexts: dcmAlrmGenTrapSend.setDescription('')
dcmAlrmGenDisplay = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 10, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcmAlrmGenDisplay.setStatus('mandatory')
if mibBuilder.loadTexts: dcmAlrmGenDisplay.setDescription('')
dcmAlrmSCTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 20, 10, 2), )
if mibBuilder.loadTexts: dcmAlrmSCTable.setStatus('mandatory')
if mibBuilder.loadTexts: dcmAlrmSCTable.setDescription('')
dcmAlrmSCEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 20, 10, 2, 1), ).setIndexNames((0, "PCE-MIB", "dcmAlrmSCFamilyId"), (0, "PCE-MIB", "dcmAlrmSCTyp"))
if mibBuilder.loadTexts: dcmAlrmSCEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dcmAlrmSCEntry.setDescription('An entry of dcmAlrmSCTable.')
dcmAlrmSCFamilyId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 10, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("f00System", 1), ("f01Tftp", 2), ("f02Junction", 3), ("f03Lmi", 4), ("f04Svc", 5), ("f05Compression", 6), ("f06ServiceCanal", 7), ("f07Fax", 8), ("f08Switching", 9), ("f09Synchronization", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcmAlrmSCFamilyId.setStatus('mandatory')
if mibBuilder.loadTexts: dcmAlrmSCFamilyId.setDescription('')
dcmAlrmSCTyp = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 10, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("scReady210", 1), ("scNotReady211", 2), ("frAddrError223", 3), ("dlciError224", 4), ("scNotFree225", 5), ("scDynamic226", 6), ("scReinit227", 7), ("unexpectedFrame230", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcmAlrmSCTyp.setStatus('mandatory')
if mibBuilder.loadTexts: dcmAlrmSCTyp.setDescription('')
dcmAlrmSCTrapSend = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 10, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcmAlrmSCTrapSend.setStatus('mandatory')
if mibBuilder.loadTexts: dcmAlrmSCTrapSend.setDescription('')
dcmAlrmSCDisplay = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 10, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcmAlrmSCDisplay.setStatus('mandatory')
if mibBuilder.loadTexts: dcmAlrmSCDisplay.setDescription('')
dcmAlrmVCTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 20, 10, 3), )
if mibBuilder.loadTexts: dcmAlrmVCTable.setStatus('mandatory')
if mibBuilder.loadTexts: dcmAlrmVCTable.setDescription('')
dcmAlrmVCEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 20, 10, 3, 1), ).setIndexNames((0, "PCE-MIB", "dcmAlrmVCFamilyId"), (0, "PCE-MIB", "dcmAlrmVCTyp"))
if mibBuilder.loadTexts: dcmAlrmVCEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dcmAlrmVCEntry.setDescription('An entry of dcmAlrmVCTable.')
dcmAlrmVCFamilyId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 10, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("f00System", 1), ("f01Tftp", 2), ("f02Junction", 3), ("f03Lmi", 4), ("f04Svc", 5), ("f05Compression", 6), ("f06ServiceCanal", 7), ("f07Fax", 8), ("f08Switching", 9), ("f09Synchronization", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcmAlrmVCFamilyId.setStatus('mandatory')
if mibBuilder.loadTexts: dcmAlrmVCFamilyId.setDescription('')
dcmAlrmVCTyp = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 10, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("vcReady212", 1), ("vcNotReady213", 2), ("lossOfSync220", 3), ("syncBack221", 4), ("vcRejected231", 5), ("endOfReject232", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcmAlrmVCTyp.setStatus('mandatory')
if mibBuilder.loadTexts: dcmAlrmVCTyp.setDescription('')
dcmAlrmVCTrapSend = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 10, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcmAlrmVCTrapSend.setStatus('mandatory')
if mibBuilder.loadTexts: dcmAlrmVCTrapSend.setDescription('')
dcmAlrmVCDisplay = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 10, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcmAlrmVCDisplay.setStatus('mandatory')
if mibBuilder.loadTexts: dcmAlrmVCDisplay.setDescription('')
dcmAlrmLMITable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 20, 10, 4), )
if mibBuilder.loadTexts: dcmAlrmLMITable.setStatus('mandatory')
if mibBuilder.loadTexts: dcmAlrmLMITable.setDescription('')
dcmAlrmLMIEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 20, 10, 4, 1), ).setIndexNames((0, "PCE-MIB", "dcmAlrmLMIFamilyId"), (0, "PCE-MIB", "dcmAlrmLMITyp"))
if mibBuilder.loadTexts: dcmAlrmLMIEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dcmAlrmLMIEntry.setDescription('An entry of dcmAlrmLMITable.')
dcmAlrmLMIFamilyId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 10, 4, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("f00System", 1), ("f01Tftp", 2), ("f02Junction", 3), ("f03Lmi", 4), ("f04Svc", 5), ("f05Compression", 6), ("f06ServiceCanal", 7), ("f07Fax", 8), ("f08Switching", 9), ("f09Synchronization", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcmAlrmLMIFamilyId.setStatus('mandatory')
if mibBuilder.loadTexts: dcmAlrmLMIFamilyId.setDescription('')
dcmAlrmLMITyp = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 10, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("dcnxLmi234", 1), ("cnxLmi235", 2), ("lmiDlciNotConf236", 3), ("lmiIntError237", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcmAlrmLMITyp.setStatus('mandatory')
if mibBuilder.loadTexts: dcmAlrmLMITyp.setDescription('')
dcmAlrmLMITrapSend = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 10, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcmAlrmLMITrapSend.setStatus('mandatory')
if mibBuilder.loadTexts: dcmAlrmLMITrapSend.setDescription('')
dcmAlrmLMIDisplay = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 10, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcmAlrmLMIDisplay.setStatus('mandatory')
if mibBuilder.loadTexts: dcmAlrmLMIDisplay.setDescription('')
dcmAlrmSwTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 20, 10, 5), )
if mibBuilder.loadTexts: dcmAlrmSwTable.setStatus('mandatory')
if mibBuilder.loadTexts: dcmAlrmSwTable.setDescription('')
dcmAlrmSwEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 20, 10, 5, 1), ).setIndexNames((0, "PCE-MIB", "dcmAlrmSwFamilyId"), (0, "PCE-MIB", "dcmAlrmSwTyp"))
if mibBuilder.loadTexts: dcmAlrmSwEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dcmAlrmSwEntry.setDescription('An entry of dcmAlrmSwTable.')
dcmAlrmSwFamilyId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 10, 5, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("f00System", 1), ("f01Tftp", 2), ("f02Junction", 3), ("f03Lmi", 4), ("f04Svc", 5), ("f05Compression", 6), ("f06ServiceCanal", 7), ("f07Fax", 8), ("f08Switching", 9), ("f09Synchronization", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcmAlrmSwFamilyId.setStatus('mandatory')
if mibBuilder.loadTexts: dcmAlrmSwFamilyId.setDescription('')
dcmAlrmSwTyp = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 10, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("outgoingCall238", 1), ("incomingCall239", 2), ("localDisc240", 3), ("remoteDisc241", 4), ("backup242", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcmAlrmSwTyp.setStatus('mandatory')
if mibBuilder.loadTexts: dcmAlrmSwTyp.setDescription('')
dcmAlrmSwTrapSend = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 10, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcmAlrmSwTrapSend.setStatus('mandatory')
if mibBuilder.loadTexts: dcmAlrmSwTrapSend.setDescription('')
dcmAlrmSwDisplay = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 10, 5, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcmAlrmSwDisplay.setStatus('mandatory')
if mibBuilder.loadTexts: dcmAlrmSwDisplay.setDescription('')
dcmAlrmCmpTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 20, 10, 6), )
if mibBuilder.loadTexts: dcmAlrmCmpTable.setStatus('mandatory')
if mibBuilder.loadTexts: dcmAlrmCmpTable.setDescription('')
dcmAlrmCmpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 20, 10, 6, 1), ).setIndexNames((0, "PCE-MIB", "dcmAlrmCmpFamilyId"), (0, "PCE-MIB", "dcmAlrmCmpTyp"))
if mibBuilder.loadTexts: dcmAlrmCmpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dcmAlrmCmpEntry.setDescription('An entry of dcmAlrmCmpTable.')
dcmAlrmCmpFamilyId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 10, 6, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("f00System", 1), ("f01Tftp", 2), ("f02Junction", 3), ("f03Lmi", 4), ("f04Svc", 5), ("f05Compression", 6), ("f06ServiceCanal", 7), ("f07Fax", 8), ("f08Switching", 9), ("f09Synchronization", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcmAlrmCmpFamilyId.setStatus('mandatory')
if mibBuilder.loadTexts: dcmAlrmCmpFamilyId.setDescription('')
dcmAlrmCmpTyp = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 10, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("compOn214", 1), ("compOff215", 2), ("algoCompNotOk228", 3), ("algoCompOk229", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcmAlrmCmpTyp.setStatus('mandatory')
if mibBuilder.loadTexts: dcmAlrmCmpTyp.setDescription('')
dcmAlrmCmpTrapSend = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 10, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcmAlrmCmpTrapSend.setStatus('mandatory')
if mibBuilder.loadTexts: dcmAlrmCmpTrapSend.setDescription('')
dcmAlrmCmpDisplay = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 10, 6, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcmAlrmCmpDisplay.setStatus('mandatory')
if mibBuilder.loadTexts: dcmAlrmCmpDisplay.setDescription('')
dcmAlrmFaxTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 20, 10, 7), )
if mibBuilder.loadTexts: dcmAlrmFaxTable.setStatus('mandatory')
if mibBuilder.loadTexts: dcmAlrmFaxTable.setDescription('')
dcmAlrmFaxEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 20, 10, 7, 1), ).setIndexNames((0, "PCE-MIB", "dcmAlrmFaxFamilyId"), (0, "PCE-MIB", "dcmAlrmFaxTyp"))
if mibBuilder.loadTexts: dcmAlrmFaxEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dcmAlrmFaxEntry.setDescription('An entry of dcmAlrmFaxTable.')
dcmAlrmFaxFamilyId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 10, 7, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("f00System", 1), ("f01Tftp", 2), ("f02Junction", 3), ("f03Lmi", 4), ("f04Svc", 5), ("f05Compression", 6), ("f06ServiceCanal", 7), ("f07Fax", 8), ("f08Switching", 9), ("f09Synchronization", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcmAlrmFaxFamilyId.setStatus('mandatory')
if mibBuilder.loadTexts: dcmAlrmFaxFamilyId.setDescription('')
dcmAlrmFaxTyp = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 10, 7, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("faxStart218", 1), ("faxEnd219", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcmAlrmFaxTyp.setStatus('mandatory')
if mibBuilder.loadTexts: dcmAlrmFaxTyp.setDescription('')
dcmAlrmFaxTrapSend = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 10, 7, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcmAlrmFaxTrapSend.setStatus('mandatory')
if mibBuilder.loadTexts: dcmAlrmFaxTrapSend.setDescription('')
dcmAlrmFaxDisplay = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 10, 7, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcmAlrmFaxDisplay.setStatus('mandatory')
if mibBuilder.loadTexts: dcmAlrmFaxDisplay.setDescription('')
dcmAlrmTftpTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 20, 10, 8), )
if mibBuilder.loadTexts: dcmAlrmTftpTable.setStatus('mandatory')
if mibBuilder.loadTexts: dcmAlrmTftpTable.setDescription('')
dcmAlrmTftpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 20, 10, 8, 1), ).setIndexNames((0, "PCE-MIB", "dcmAlrmTftpFamilyId"), (0, "PCE-MIB", "dcmAlrmTftpTyp"))
if mibBuilder.loadTexts: dcmAlrmTftpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dcmAlrmTftpEntry.setDescription('An entry of dcmAlrmTftpTable.')
dcmAlrmTftpFamilyId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 10, 8, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("f00System", 1), ("f01Tftp", 2), ("f02Junction", 3), ("f03Lmi", 4), ("f04Svc", 5), ("f05Compression", 6), ("f06ServiceCanal", 7), ("f07Fax", 8), ("f08Switching", 9), ("f09Synchronization", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcmAlrmTftpFamilyId.setStatus('mandatory')
if mibBuilder.loadTexts: dcmAlrmTftpFamilyId.setDescription('')
dcmAlrmTftpTyp = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 10, 8, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("dwnStart243", 1), ("dwnEnd244", 2), ("dwnError245", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcmAlrmTftpTyp.setStatus('mandatory')
if mibBuilder.loadTexts: dcmAlrmTftpTyp.setDescription('')
dcmAlrmTftpTrapSend = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 10, 8, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcmAlrmTftpTrapSend.setStatus('mandatory')
if mibBuilder.loadTexts: dcmAlrmTftpTrapSend.setDescription('')
dcmAlrmTftpDisplay = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 10, 8, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcmAlrmTftpDisplay.setStatus('mandatory')
if mibBuilder.loadTexts: dcmAlrmTftpDisplay.setDescription('')
dcmAlrmSvcTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 20, 10, 9), )
if mibBuilder.loadTexts: dcmAlrmSvcTable.setStatus('mandatory')
if mibBuilder.loadTexts: dcmAlrmSvcTable.setDescription('')
dcmAlrmSvcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 20, 10, 9, 1), ).setIndexNames((0, "PCE-MIB", "dcmAlrmSvcFamilyId"), (0, "PCE-MIB", "dcmAlrmSvcTyp"))
if mibBuilder.loadTexts: dcmAlrmSvcEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dcmAlrmSvcEntry.setDescription('An entry of dcmAlrmSvcTable.')
dcmAlrmSvcFamilyId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 10, 9, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("f00System", 1), ("f01Tftp", 2), ("f02Junction", 3), ("f03Lmi", 4), ("f04Svc", 5), ("f05Compression", 6), ("f06ServiceCanal", 7), ("f07Fax", 8), ("f08Switching", 9), ("f09Synchronization", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcmAlrmSvcFamilyId.setStatus('mandatory')
if mibBuilder.loadTexts: dcmAlrmSvcFamilyId.setDescription('')
dcmAlrmSvcTyp = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 10, 9, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("svcOutCall246", 1), ("svcInCall247", 2), ("svcLocalConnect248", 3), ("svcLocalDisc249", 4), ("svcRemoteDisc250", 5), ("svcOutFailCall251", 6), ("svcInFailCall252", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcmAlrmSvcTyp.setStatus('mandatory')
if mibBuilder.loadTexts: dcmAlrmSvcTyp.setDescription('')
dcmAlrmSvcTrapSend = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 10, 9, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcmAlrmSvcTrapSend.setStatus('mandatory')
if mibBuilder.loadTexts: dcmAlrmSvcTrapSend.setDescription('')
dcmAlrmSvcDisplay = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 10, 9, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcmAlrmSvcDisplay.setStatus('mandatory')
if mibBuilder.loadTexts: dcmAlrmSvcDisplay.setDescription('')
dcmAlrmSyncTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 20, 10, 10), )
if mibBuilder.loadTexts: dcmAlrmSyncTable.setStatus('mandatory')
if mibBuilder.loadTexts: dcmAlrmSyncTable.setDescription('')
dcmAlrmSyncEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 20, 10, 10, 1), ).setIndexNames((0, "PCE-MIB", "dcmAlrmSyncFamilyId"), (0, "PCE-MIB", "dcmAlrmSyncTyp"))
if mibBuilder.loadTexts: dcmAlrmSyncEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dcmAlrmSyncEntry.setDescription('An entry of dcmAlrmSyncTable.')
dcmAlrmSyncFamilyId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 10, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("f00System", 1), ("f01Tftp", 2), ("f02Junction", 3), ("f03Lmi", 4), ("f04Svc", 5), ("f05Compression", 6), ("f06ServiceCanal", 7), ("f07Fax", 8), ("f08Switching", 9), ("f09Synchronization", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcmAlrmSyncFamilyId.setStatus('mandatory')
if mibBuilder.loadTexts: dcmAlrmSyncFamilyId.setDescription('')
dcmAlrmSyncTyp = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 10, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("tdmUp253", 1), ("tdmDown254", 2), ("vpbSync255", 3), ("vpbOutofSync256", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcmAlrmSyncTyp.setStatus('mandatory')
if mibBuilder.loadTexts: dcmAlrmSyncTyp.setDescription('')
dcmAlrmSyncTrapSend = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 10, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcmAlrmSyncTrapSend.setStatus('mandatory')
if mibBuilder.loadTexts: dcmAlrmSyncTrapSend.setDescription('')
dcmAlrmSyncDisplay = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 10, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcmAlrmSyncDisplay.setStatus('mandatory')
if mibBuilder.loadTexts: dcmAlrmSyncDisplay.setDescription('')
dcInterfaces = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 30, 20, 15))
dcfPhysicalPortTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 20, 15, 1), )
if mibBuilder.loadTexts: dcfPhysicalPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: dcfPhysicalPortTable.setDescription('')
dcfPhysicalPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 20, 15, 1, 1), ).setIndexNames((0, "PCE-MIB", "dcfPhysPortId"))
if mibBuilder.loadTexts: dcfPhysicalPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dcfPhysicalPortEntry.setDescription('An entry of dcfPhysicalPortTable.')
dcfPhysPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 15, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("l0", 1), ("l1", 2), ("frontPannel", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcfPhysPortId.setStatus('mandatory')
if mibBuilder.loadTexts: dcfPhysPortId.setDescription('')
dcfPhysPortConnector = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 15, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("db25", 1), ("din", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcfPhysPortConnector.setStatus('mandatory')
if mibBuilder.loadTexts: dcfPhysPortConnector.setDescription('')
dcfNumericLines = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 30, 20, 15, 5))
dcfNumericLineTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 20, 15, 5, 1), )
if mibBuilder.loadTexts: dcfNumericLineTable.setStatus('mandatory')
if mibBuilder.loadTexts: dcfNumericLineTable.setDescription('')
dcfNumericLineEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 20, 15, 5, 1, 1), ).setIndexNames((0, "PCE-MIB", "dcfNumericLineInterfaceId"))
if mibBuilder.loadTexts: dcfNumericLineEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dcfNumericLineEntry.setDescription('An entry of dcfNumericLineTable.')
dcfNumericLineInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 15, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("l0", 1), ("l1", 2), ("frontPannel", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcfNumericLineInterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: dcfNumericLineInterfaceId.setDescription('')
dcfNumericLineType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 15, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("dataLine", 1), ("configurationLine", 2), ("debug", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcfNumericLineType.setStatus('mandatory')
if mibBuilder.loadTexts: dcfNumericLineType.setDescription('')
dcfDataLineTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 20, 15, 5, 2), )
if mibBuilder.loadTexts: dcfDataLineTable.setStatus('mandatory')
if mibBuilder.loadTexts: dcfDataLineTable.setDescription('')
dcfDataLineEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 20, 15, 5, 2, 1), ).setIndexNames((0, "PCE-MIB", "dcfDataLineInterfaceId"))
if mibBuilder.loadTexts: dcfDataLineEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dcfDataLineEntry.setDescription('An entry of dcfDataLineTable.')
dcfDataLineInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 15, 5, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("l0", 1), ("l1", 2), ("other", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcfDataLineInterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: dcfDataLineInterfaceId.setDescription('')
dcfDataLineRate = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 15, 5, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14))).clone(namedValues=NamedValues(("s4800", 1), ("s9600", 2), ("s19200", 3), ("s38400", 4), ("s48000", 5), ("s56000", 6), ("s64000", 7), ("s72000", 8), ("s128000", 9), ("s144000", 10), ("s256000", 11), ("s512000", 12), ("s1024000", 13), ("s2048000", 14)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcfDataLineRate.setStatus('mandatory')
if mibBuilder.loadTexts: dcfDataLineRate.setDescription('')
dcfDataLineRts105 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 15, 5, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unused", 1), ("used", 2), ("standard", 3), ("off", 4), ("on", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcfDataLineRts105.setStatus('mandatory')
if mibBuilder.loadTexts: dcfDataLineRts105.setDescription('')
dcfDataLineDtr108 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 15, 5, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unused", 1), ("used", 2), ("standard", 3), ("off", 4), ("on", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcfDataLineDtr108.setStatus('mandatory')
if mibBuilder.loadTexts: dcfDataLineDtr108.setDescription('')
dcfDataLineCts106 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 15, 5, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unused", 1), ("used", 2), ("standard", 3), ("off", 4), ("on", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcfDataLineCts106.setStatus('mandatory')
if mibBuilder.loadTexts: dcfDataLineCts106.setDescription('')
dcfDataLineDsr107 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 15, 5, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unused", 1), ("used", 2), ("standard", 3), ("off", 4), ("on", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcfDataLineDsr107.setStatus('mandatory')
if mibBuilder.loadTexts: dcfDataLineDsr107.setDescription('')
dcfDataLineDcd109 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 15, 5, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unused", 1), ("used", 2), ("standard", 3), ("off", 4), ("on", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcfDataLineDcd109.setStatus('mandatory')
if mibBuilder.loadTexts: dcfDataLineDcd109.setDescription('')
dcfConfLineTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 20, 15, 5, 3), )
if mibBuilder.loadTexts: dcfConfLineTable.setStatus('mandatory')
if mibBuilder.loadTexts: dcfConfLineTable.setDescription('')
dcfConfLineEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 20, 15, 5, 3, 1), ).setIndexNames((0, "PCE-MIB", "dcfConfLineInterfaceId"))
if mibBuilder.loadTexts: dcfConfLineEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dcfConfLineEntry.setDescription('An entry of dcfConfLineTable.')
dcfConfLineInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 15, 5, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("l0", 1), ("l1", 2), ("frontPannel", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcfConfLineInterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: dcfConfLineInterfaceId.setDescription('')
dcfConfLineRate = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 15, 5, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14))).clone(namedValues=NamedValues(("s4800", 1), ("s9600", 2), ("s19200", 3), ("s38400", 4), ("s48000", 5), ("s56000", 6), ("s64000", 7), ("s72000", 8), ("s128000", 9), ("s144000", 10), ("s256000", 11), ("s512000", 12), ("s1024000", 13), ("s2048000", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcfConfLineRate.setStatus('mandatory')
if mibBuilder.loadTexts: dcfConfLineRate.setDescription('')
dcLogicalPorts = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 30, 20, 20))
dclLogicalPortTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 20, 20, 1), )
if mibBuilder.loadTexts: dclLogicalPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: dclLogicalPortTable.setDescription('')
dclLogicalPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 20, 20, 1, 1), ).setIndexNames((0, "PCE-MIB", "dclLogPortId"))
if mibBuilder.loadTexts: dclLogicalPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dclLogicalPortEntry.setDescription('An entry of dclLogicalPortTable.')
dclLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 20, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: dclLogPortId.setDescription('')
dclLogPortStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 20, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dclLogPortStatus.setStatus('mandatory')
if mibBuilder.loadTexts: dclLogPortStatus.setDescription('')
dclLogPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 20, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("frTe", 1), ("frSe", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dclLogPortType.setStatus('mandatory')
if mibBuilder.loadTexts: dclLogPortType.setDescription('')
dclFrameRelay = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 30, 20, 20, 5))
dclFrTerminalEquipment = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 30, 20, 20, 5, 1))
dclFrTeLogPortTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 20, 20, 5, 1, 1), )
if mibBuilder.loadTexts: dclFrTeLogPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: dclFrTeLogPortTable.setDescription('')
dclFrTeLogPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 20, 20, 5, 1, 1, 1), ).setIndexNames((0, "PCE-MIB", "dclFrTeLpLogPortId"))
if mibBuilder.loadTexts: dclFrTeLogPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dclFrTeLogPortEntry.setDescription('An entry of dclFrTeLogPortTable.')
dclFrTeLpLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 20, 5, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclFrTeLpLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: dclFrTeLpLogPortId.setDescription('')
dclFrTeLpInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 20, 5, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("l0", 1), ("l1", 2), ("other", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclFrTeLpInterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: dclFrTeLpInterfaceId.setDescription('')
dclFrTeLpConfigId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 20, 5, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclFrTeLpConfigId.setStatus('mandatory')
if mibBuilder.loadTexts: dclFrTeLpConfigId.setDescription('')
dclFrTeLpLmi = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 20, 5, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("lmiUni", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dclFrTeLpLmi.setStatus('mandatory')
if mibBuilder.loadTexts: dclFrTeLpLmi.setDescription('')
dclFrSwitchEquipment = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 30, 20, 20, 5, 2))
dclFrSeLogPortTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 20, 20, 5, 2, 1), )
if mibBuilder.loadTexts: dclFrSeLogPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: dclFrSeLogPortTable.setDescription('')
dclFrSeLogPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 20, 20, 5, 2, 1, 1), ).setIndexNames((0, "PCE-MIB", "dclFrSeLpLogPortId"))
if mibBuilder.loadTexts: dclFrSeLogPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dclFrSeLogPortEntry.setDescription('An entry of dclFrSeLogPortTable.')
dclFrSeLpLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 20, 5, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclFrSeLpLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: dclFrSeLpLogPortId.setDescription('')
dclFrSeLpInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 20, 5, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("l0", 1), ("l1", 2), ("other", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclFrSeLpInterfaceId.setStatus('mandatory')
if mibBuilder.loadTexts: dclFrSeLpInterfaceId.setDescription('')
dclFrSeLpConfigId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 20, 5, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclFrSeLpConfigId.setStatus('mandatory')
if mibBuilder.loadTexts: dclFrSeLpConfigId.setDescription('')
dclFrConfigurationTe = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 30, 20, 20, 5, 3))
dclFrLmiParameterTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 20, 20, 5, 3, 1), )
if mibBuilder.loadTexts: dclFrLmiParameterTable.setStatus('mandatory')
if mibBuilder.loadTexts: dclFrLmiParameterTable.setDescription('')
dclFrLmiParameterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 20, 20, 5, 3, 1, 1), ).setIndexNames((0, "PCE-MIB", "dclFrLmiParaConfigId"))
if mibBuilder.loadTexts: dclFrLmiParameterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dclFrLmiParameterEntry.setDescription('An entry of dclFrLmiParameterTable.')
dclFrLmiParaConfigId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 20, 5, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclFrLmiParaConfigId.setStatus('mandatory')
if mibBuilder.loadTexts: dclFrLmiParaConfigId.setDescription('')
dclFrLmiParaDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 20, 5, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dclFrLmiParaDlci.setStatus('mandatory')
if mibBuilder.loadTexts: dclFrLmiParaDlci.setDescription('')
dclFrLmiParaStandard = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 20, 5, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ansiT1-617d", 1), ("itutQ933a", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dclFrLmiParaStandard.setStatus('mandatory')
if mibBuilder.loadTexts: dclFrLmiParaStandard.setDescription('')
dclFrLmiParaAccessibilityCondition = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 20, 5, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dclFrLmiParaAccessibilityCondition.setStatus('mandatory')
if mibBuilder.loadTexts: dclFrLmiParaAccessibilityCondition.setDescription('')
dclFrLmiParaN391FullStatusPollCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 20, 5, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dclFrLmiParaN391FullStatusPollCount.setStatus('mandatory')
if mibBuilder.loadTexts: dclFrLmiParaN391FullStatusPollCount.setDescription('')
dclFrLmiParaN392ErrorThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 20, 5, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dclFrLmiParaN392ErrorThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: dclFrLmiParaN392ErrorThreshold.setDescription('')
dclFrLmiParaN393MonitoredEventCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 20, 5, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dclFrLmiParaN393MonitoredEventCount.setStatus('mandatory')
if mibBuilder.loadTexts: dclFrLmiParaN393MonitoredEventCount.setDescription('')
dclFrLmiParaT391LinkIntegPollTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 20, 5, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dclFrLmiParaT391LinkIntegPollTimer.setStatus('mandatory')
if mibBuilder.loadTexts: dclFrLmiParaT391LinkIntegPollTimer.setDescription('')
dclFrConfigurationSe = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 30, 20, 20, 5, 4))
dclFrSeSignallingTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 20, 20, 5, 4, 1), )
if mibBuilder.loadTexts: dclFrSeSignallingTable.setStatus('mandatory')
if mibBuilder.loadTexts: dclFrSeSignallingTable.setDescription('')
dclFrSeSignallingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 20, 20, 5, 4, 1, 1), ).setIndexNames((0, "PCE-MIB", "dclFrSeSigConfigId"))
if mibBuilder.loadTexts: dclFrSeSignallingEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dclFrSeSignallingEntry.setDescription('An entry of dclFrSeSignallingTable.')
dclFrSeSigConfigId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 20, 5, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dclFrSeSigConfigId.setStatus('mandatory')
if mibBuilder.loadTexts: dclFrSeSigConfigId.setDescription('')
dclFrSeSigOuputTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 20, 5, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 51000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dclFrSeSigOuputTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: dclFrSeSigOuputTimeout.setDescription('')
dclFrSeSigSignalOutputWinSize = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 20, 5, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dclFrSeSigSignalOutputWinSize.setStatus('mandatory')
if mibBuilder.loadTexts: dclFrSeSigSignalOutputWinSize.setDescription('')
dclFrSeSigN200RetransMaxCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 20, 5, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dclFrSeSigN200RetransMaxCount.setStatus('mandatory')
if mibBuilder.loadTexts: dclFrSeSigN200RetransMaxCount.setDescription('')
dclFrSeSigT200RetransTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 20, 5, 4, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 25500))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dclFrSeSigT200RetransTimer.setStatus('mandatory')
if mibBuilder.loadTexts: dclFrSeSigT200RetransTimer.setDescription('')
dclFrSeSigT203InactivityTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 20, 5, 4, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dclFrSeSigT203InactivityTimer.setStatus('mandatory')
if mibBuilder.loadTexts: dclFrSeSigT203InactivityTimer.setDescription('')
dclFrSeSigT303SetupResponseTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 20, 5, 4, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dclFrSeSigT303SetupResponseTimer.setStatus('mandatory')
if mibBuilder.loadTexts: dclFrSeSigT303SetupResponseTimer.setDescription('')
dclFrSeSigT305DisconnectResponseTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 20, 5, 4, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dclFrSeSigT305DisconnectResponseTimer.setStatus('mandatory')
if mibBuilder.loadTexts: dclFrSeSigT305DisconnectResponseTimer.setDescription('')
dclFrSeSigT308ReleaseResponseTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 20, 5, 4, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dclFrSeSigT308ReleaseResponseTimer.setStatus('mandatory')
if mibBuilder.loadTexts: dclFrSeSigT308ReleaseResponseTimer.setDescription('')
dclFrSeSigT310CallProceedingTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 20, 5, 4, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dclFrSeSigT310CallProceedingTimer.setStatus('mandatory')
if mibBuilder.loadTexts: dclFrSeSigT310CallProceedingTimer.setDescription('')
dclFrSeSigT316RestartAcknowledgeTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 20, 5, 4, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dclFrSeSigT316RestartAcknowledgeTimer.setStatus('mandatory')
if mibBuilder.loadTexts: dclFrSeSigT316RestartAcknowledgeTimer.setDescription('')
dcWanSwitch = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 30, 20, 25))
dcwEquipParams = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 30, 20, 25, 1))
dcwEquipDnicZoAddr = MibScalar((1, 3, 6, 1, 4, 1, 866, 30, 20, 25, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(3, 3)).setFixedLength(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcwEquipDnicZoAddr.setStatus('mandatory')
if mibBuilder.loadTexts: dcwEquipDnicZoAddr.setDescription('')
dcwEquipVoiceRoutingServicePortAddr = MibScalar((1, 3, 6, 1, 4, 1, 866, 30, 20, 25, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcwEquipVoiceRoutingServicePortAddr.setStatus('mandatory')
if mibBuilder.loadTexts: dcwEquipVoiceRoutingServicePortAddr.setDescription('')
dcwEquipIpVirtualPortAddr = MibScalar((1, 3, 6, 1, 4, 1, 866, 30, 20, 25, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcwEquipIpVirtualPortAddr.setStatus('mandatory')
if mibBuilder.loadTexts: dcwEquipIpVirtualPortAddr.setDescription('')
dcwEquipRemoteConfPortAddr = MibScalar((1, 3, 6, 1, 4, 1, 866, 30, 20, 25, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcwEquipRemoteConfPortAddr.setStatus('mandatory')
if mibBuilder.loadTexts: dcwEquipRemoteConfPortAddr.setDescription('')
dcwEquipVoiceVirtualPortAddr = MibScalar((1, 3, 6, 1, 4, 1, 866, 30, 20, 25, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcwEquipVoiceVirtualPortAddr.setStatus('mandatory')
if mibBuilder.loadTexts: dcwEquipVoiceVirtualPortAddr.setDescription('')
dcwEquipSVCDisconnectOnCongestion = MibScalar((1, 3, 6, 1, 4, 1, 866, 30, 20, 25, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcwEquipSVCDisconnectOnCongestion.setStatus('mandatory')
if mibBuilder.loadTexts: dcwEquipSVCDisconnectOnCongestion.setDescription('')
dcwABPvcLpTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 20, 25, 2), )
if mibBuilder.loadTexts: dcwABPvcLpTable.setStatus('mandatory')
if mibBuilder.loadTexts: dcwABPvcLpTable.setDescription('')
dcwABPvcLpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 20, 25, 2, 1), ).setIndexNames((0, "PCE-MIB", "dcwABPvcLpId"))
if mibBuilder.loadTexts: dcwABPvcLpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dcwABPvcLpEntry.setDescription('An entry of dcwABPvcLpTable.')
dcwABPvcLpId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 25, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcwABPvcLpId.setStatus('mandatory')
if mibBuilder.loadTexts: dcwABPvcLpId.setDescription('')
dcwABPvcLpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 25, 2, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcwABPvcLpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: dcwABPvcLpAddress.setDescription('')
dcVirtualPorts = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 30, 20, 30))
dcvVirtualPortTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 1), )
if mibBuilder.loadTexts: dcvVirtualPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: dcvVirtualPortTable.setDescription('')
dcvVirtualPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 1, 1), ).setIndexNames((0, "PCE-MIB", "dcvVirtualPortId"))
if mibBuilder.loadTexts: dcvVirtualPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dcvVirtualPortEntry.setDescription('An entry of dcvVirtualPortTable.')
dcvVirtualPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("vpVoix", 1), ("vpIp", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcvVirtualPortId.setStatus('mandatory')
if mibBuilder.loadTexts: dcvVirtualPortId.setDescription('')
dcvIpVirtualPort = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 5))
dcvIpLocalTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 5, 1), )
if mibBuilder.loadTexts: dcvIpLocalTable.setStatus('mandatory')
if mibBuilder.loadTexts: dcvIpLocalTable.setDescription('')
dcvIpLocalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 5, 1, 1), ).setIndexNames((0, "PCE-MIB", "dcvIpLocVirtualPortId"))
if mibBuilder.loadTexts: dcvIpLocalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dcvIpLocalEntry.setDescription('An entry of dcvIpLocalTable.')
dcvIpLocVirtualPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("vpVoix", 1), ("vpIp", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcvIpLocVirtualPortId.setStatus('mandatory')
if mibBuilder.loadTexts: dcvIpLocVirtualPortId.setDescription('')
dcvIpLocAddressHost = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 5, 1, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvIpLocAddressHost.setStatus('mandatory')
if mibBuilder.loadTexts: dcvIpLocAddressHost.setDescription('')
dcvIpLocSubNetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 5, 1, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvIpLocSubNetMask.setStatus('mandatory')
if mibBuilder.loadTexts: dcvIpLocSubNetMask.setDescription('')
dcvIpLocMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 5, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(576, 9180))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcvIpLocMtu.setStatus('mandatory')
if mibBuilder.loadTexts: dcvIpLocMtu.setDescription('')
dcvIpLocRouteNextHop = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 5, 1, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvIpLocRouteNextHop.setStatus('mandatory')
if mibBuilder.loadTexts: dcvIpLocRouteNextHop.setDescription('')
dcvIpLocMinimumRecallTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 5, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvIpLocMinimumRecallTimer.setStatus('mandatory')
if mibBuilder.loadTexts: dcvIpLocMinimumRecallTimer.setDescription('')
dcvIpLocSvcClearCallTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 5, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvIpLocSvcClearCallTimer.setStatus('mandatory')
if mibBuilder.loadTexts: dcvIpLocSvcClearCallTimer.setDescription('')
dcvIpLocSvcCallRetryCount = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 5, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvIpLocSvcCallRetryCount.setStatus('mandatory')
if mibBuilder.loadTexts: dcvIpLocSvcCallRetryCount.setDescription('')
dcvSnmp = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 5, 5))
dcvSnmpGen = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 5, 5, 1))
dcvSnmpGenVirtualPortId = MibScalar((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 5, 5, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("vpVoix", 1), ("vpIp", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvSnmpGenVirtualPortId.setStatus('mandatory')
if mibBuilder.loadTexts: dcvSnmpGenVirtualPortId.setDescription('')
dcvSnmpGenCommunityStringReadOnly = MibScalar((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 5, 5, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 14))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvSnmpGenCommunityStringReadOnly.setStatus('mandatory')
if mibBuilder.loadTexts: dcvSnmpGenCommunityStringReadOnly.setDescription('')
dcvSnmpGenCommunityStringReadWrite = MibScalar((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 5, 5, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 14))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvSnmpGenCommunityStringReadWrite.setStatus('mandatory')
if mibBuilder.loadTexts: dcvSnmpGenCommunityStringReadWrite.setDescription('')
dcvSnmpGenCommunityStringTrap = MibScalar((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 5, 5, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 14))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvSnmpGenCommunityStringTrap.setStatus('mandatory')
if mibBuilder.loadTexts: dcvSnmpGenCommunityStringTrap.setDescription('')
dcvSnmpGenAuthenticationFailureTrap = MibScalar((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 5, 5, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvSnmpGenAuthenticationFailureTrap.setStatus('mandatory')
if mibBuilder.loadTexts: dcvSnmpGenAuthenticationFailureTrap.setDescription('')
dcvSnmpManagerTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 5, 5, 2), )
if mibBuilder.loadTexts: dcvSnmpManagerTable.setStatus('mandatory')
if mibBuilder.loadTexts: dcvSnmpManagerTable.setDescription('')
dcvSnmpManagerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 5, 5, 2, 1), ).setIndexNames((0, "PCE-MIB", "dcvSnmpManagerIpAddress"))
if mibBuilder.loadTexts: dcvSnmpManagerEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dcvSnmpManagerEntry.setDescription('An entry of dcvSnmpManagerTable.')
dcvSnmpManagerIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 5, 5, 2, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcvSnmpManagerIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: dcvSnmpManagerIpAddress.setDescription('')
dcvSnmpManagerStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 5, 5, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvSnmpManagerStatus.setStatus('mandatory')
if mibBuilder.loadTexts: dcvSnmpManagerStatus.setDescription('')
dcvSnmpManagerName = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 5, 5, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 12))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvSnmpManagerName.setStatus('mandatory')
if mibBuilder.loadTexts: dcvSnmpManagerName.setDescription('')
dcvSnmpManagerSendTraps = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 5, 5, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvSnmpManagerSendTraps.setStatus('mandatory')
if mibBuilder.loadTexts: dcvSnmpManagerSendTraps.setDescription('')
dcvSnmpManagerTrapsUdpPort = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 5, 5, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvSnmpManagerTrapsUdpPort.setStatus('mandatory')
if mibBuilder.loadTexts: dcvSnmpManagerTrapsUdpPort.setDescription('')
dcvRemoteConfTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 5, 5, 3), )
if mibBuilder.loadTexts: dcvRemoteConfTable.setStatus('mandatory')
if mibBuilder.loadTexts: dcvRemoteConfTable.setDescription('')
dcvRemoteConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 5, 5, 3, 1), ).setIndexNames((0, "PCE-MIB", "dcvRemoteConfName"))
if mibBuilder.loadTexts: dcvRemoteConfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dcvRemoteConfEntry.setDescription('An entry of dcvRemoteConfTable.')
dcvRemoteConfName = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 5, 5, 3, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcvRemoteConfName.setStatus('mandatory')
if mibBuilder.loadTexts: dcvRemoteConfName.setDescription('')
dcvRemoteConfStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 5, 5, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvRemoteConfStatus.setStatus('mandatory')
if mibBuilder.loadTexts: dcvRemoteConfStatus.setDescription('')
dcvRemoteConfWanAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 5, 5, 3, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvRemoteConfWanAddress.setStatus('mandatory')
if mibBuilder.loadTexts: dcvRemoteConfWanAddress.setDescription('')
dcvTftpTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 5, 10), )
if mibBuilder.loadTexts: dcvTftpTable.setStatus('mandatory')
if mibBuilder.loadTexts: dcvTftpTable.setDescription('')
dcvTftpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 5, 10, 1), ).setIndexNames((0, "PCE-MIB", "dcvTftpIpAddress"))
if mibBuilder.loadTexts: dcvTftpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dcvTftpEntry.setDescription('An entry of dcvTftpTable.')
dcvTftpIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 5, 10, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcvTftpIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: dcvTftpIpAddress.setDescription('')
dcvTftpStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 5, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvTftpStatus.setStatus('mandatory')
if mibBuilder.loadTexts: dcvTftpStatus.setDescription('')
dcvTftpName = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 5, 10, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvTftpName.setStatus('mandatory')
if mibBuilder.loadTexts: dcvTftpName.setDescription('')
dcvTftpRetryTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 5, 10, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 600))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvTftpRetryTimer.setStatus('mandatory')
if mibBuilder.loadTexts: dcvTftpRetryTimer.setDescription('')
dcvTftpInactTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 5, 10, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 3600))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvTftpInactTimer.setStatus('mandatory')
if mibBuilder.loadTexts: dcvTftpInactTimer.setDescription('')
dcvRemoteNetToMediaTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 5, 15), )
if mibBuilder.loadTexts: dcvRemoteNetToMediaTable.setStatus('mandatory')
if mibBuilder.loadTexts: dcvRemoteNetToMediaTable.setDescription('')
dcvRemoteNetToMediaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 5, 15, 1), ).setIndexNames((0, "PCE-MIB", "dcvRemNetIpAddress"))
if mibBuilder.loadTexts: dcvRemoteNetToMediaEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dcvRemoteNetToMediaEntry.setDescription('An entry of dcvRemoteNetToMediaTable.')
dcvRemNetIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 5, 15, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcvRemNetIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: dcvRemNetIpAddress.setDescription('')
dcvRemNetStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 5, 15, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvRemNetStatus.setStatus('mandatory')
if mibBuilder.loadTexts: dcvRemNetStatus.setDescription('')
dcvRemNetWanAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 5, 15, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvRemNetWanAddress.setStatus('mandatory')
if mibBuilder.loadTexts: dcvRemNetWanAddress.setDescription('')
dcvRemNetEncapsulation = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 5, 15, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("fripSimple", 1), ("fripRFC", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvRemNetEncapsulation.setStatus('mandatory')
if mibBuilder.loadTexts: dcvRemNetEncapsulation.setDescription('')
dcvVoiceVirtualPort = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10))
dcvVoiceGen = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 1))
dcvVoiceVirtualPortId = MibScalar((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("vpVoix", 1), ("vpIp", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvVoiceVirtualPortId.setStatus('mandatory')
if mibBuilder.loadTexts: dcvVoiceVirtualPortId.setDescription('')
dcvVoiceTransportTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 2), )
if mibBuilder.loadTexts: dcvVoiceTransportTable.setStatus('mandatory')
if mibBuilder.loadTexts: dcvVoiceTransportTable.setDescription('')
dcvVoiceTransportEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 2, 1), ).setIndexNames((0, "PCE-MIB", "dcvVoiceTransProfileId"))
if mibBuilder.loadTexts: dcvVoiceTransportEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dcvVoiceTransportEntry.setDescription('An entry of dcvVoiceTransportTable.')
dcvVoiceTransProfileId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvVoiceTransProfileId.setStatus('mandatory')
if mibBuilder.loadTexts: dcvVoiceTransProfileId.setDescription('')
dcvVoiceTransEncapsulationMode = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("frf", 1), ("private", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvVoiceTransEncapsulationMode.setStatus('mandatory')
if mibBuilder.loadTexts: dcvVoiceTransEncapsulationMode.setDescription('')
dcvVoiceTransMaxPayLoadNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvVoiceTransMaxPayLoadNumber.setStatus('mandatory')
if mibBuilder.loadTexts: dcvVoiceTransMaxPayLoadNumber.setDescription('')
dcvVoiceTransCompressionAlgorithm = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("g729", 1), ("g729A", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvVoiceTransCompressionAlgorithm.setStatus('mandatory')
if mibBuilder.loadTexts: dcvVoiceTransCompressionAlgorithm.setDescription('')
dcvVoiceTransJitterCompensation = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 9))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvVoiceTransJitterCompensation.setStatus('mandatory')
if mibBuilder.loadTexts: dcvVoiceTransJitterCompensation.setDescription('')
dcvVoiceTransVoicePacketsCombination = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvVoiceTransVoicePacketsCombination.setStatus('mandatory')
if mibBuilder.loadTexts: dcvVoiceTransVoicePacketsCombination.setDescription('')
dcvVoiceTransQosBc = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("s9600", 1), ("s14400", 2), ("s19200", 3), ("s32000", 4), ("s38400", 5), ("s48000", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvVoiceTransQosBc.setStatus('mandatory')
if mibBuilder.loadTexts: dcvVoiceTransQosBc.setDescription('')
dcvVoiceTransQosBe = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("s9600", 1), ("s14400", 2), ("s19200", 3), ("s32000", 4), ("s38400", 5), ("s48000", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvVoiceTransQosBe.setStatus('mandatory')
if mibBuilder.loadTexts: dcvVoiceTransQosBe.setDescription('')
dcvVoiceTransQosCir = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("s9600", 1), ("s14400", 2), ("s19200", 3), ("s32000", 4), ("s38400", 5), ("s48000", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvVoiceTransQosCir.setStatus('mandatory')
if mibBuilder.loadTexts: dcvVoiceTransQosCir.setDescription('')
dcvVoiceSuscriberTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 3), )
if mibBuilder.loadTexts: dcvVoiceSuscriberTable.setStatus('mandatory')
if mibBuilder.loadTexts: dcvVoiceSuscriberTable.setDescription('')
dcvVoiceSuscriberEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 3, 1), ).setIndexNames((0, "PCE-MIB", "dcvVoiceSuscrOrderNumber"), (0, "PCE-MIB", "dcvVoiceSuscrNumber"))
if mibBuilder.loadTexts: dcvVoiceSuscriberEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dcvVoiceSuscriberEntry.setDescription('An entry of dcvVoiceSuscriberTable.')
dcvVoiceSuscrOrderNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcvVoiceSuscrOrderNumber.setStatus('mandatory')
if mibBuilder.loadTexts: dcvVoiceSuscrOrderNumber.setDescription('')
dcvVoiceSuscrNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 3, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 21))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcvVoiceSuscrNumber.setStatus('mandatory')
if mibBuilder.loadTexts: dcvVoiceSuscrNumber.setDescription('')
dcvVoiceSuscrStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvVoiceSuscrStatus.setStatus('mandatory')
if mibBuilder.loadTexts: dcvVoiceSuscrStatus.setDescription('')
dcvVoiceSuscrTransportNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("fr", 1), ("other", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcvVoiceSuscrTransportNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: dcvVoiceSuscrTransportNetwork.setDescription('')
dcvVoiceSuscrTransportNetworkAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 3, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvVoiceSuscrTransportNetworkAddress.setStatus('mandatory')
if mibBuilder.loadTexts: dcvVoiceSuscrTransportNetworkAddress.setDescription('')
dcvVoiceSuscrTransportProfileId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 3, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvVoiceSuscrTransportProfileId.setStatus('mandatory')
if mibBuilder.loadTexts: dcvVoiceSuscrTransportProfileId.setDescription('')
dcvVoiceSuscrRemovedDigitNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 3, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 21))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvVoiceSuscrRemovedDigitNumber.setStatus('mandatory')
if mibBuilder.loadTexts: dcvVoiceSuscrRemovedDigitNumber.setDescription('')
dcvVoiceSuscrInsPrefix = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 3, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 21))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvVoiceSuscrInsPrefix.setStatus('mandatory')
if mibBuilder.loadTexts: dcvVoiceSuscrInsPrefix.setDescription('')
dcvVoiceSuscrInsSuffix = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 3, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 21))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvVoiceSuscrInsSuffix.setStatus('mandatory')
if mibBuilder.loadTexts: dcvVoiceSuscrInsSuffix.setDescription('')
dcvVoiceSwTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 4), )
if mibBuilder.loadTexts: dcvVoiceSwTable.setStatus('mandatory')
if mibBuilder.loadTexts: dcvVoiceSwTable.setDescription('')
dcvVoiceSwEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 4, 1), ).setIndexNames((0, "PCE-MIB", "dcvVoiceSwOrderNumber"), (0, "PCE-MIB", "dcvVoiceSwSuscriberNumber"))
if mibBuilder.loadTexts: dcvVoiceSwEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dcvVoiceSwEntry.setDescription('An entry of dcvVoiceSwTable.')
dcvVoiceSwOrderNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcvVoiceSwOrderNumber.setStatus('mandatory')
if mibBuilder.loadTexts: dcvVoiceSwOrderNumber.setDescription('')
dcvVoiceSwSuscriberNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 4, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 21))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcvVoiceSwSuscriberNumber.setStatus('mandatory')
if mibBuilder.loadTexts: dcvVoiceSwSuscriberNumber.setDescription('')
dcvVoiceSwStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvVoiceSwStatus.setStatus('mandatory')
if mibBuilder.loadTexts: dcvVoiceSwStatus.setDescription('')
dcvVoiceSwLogPortSetId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvVoiceSwLogPortSetId.setStatus('mandatory')
if mibBuilder.loadTexts: dcvVoiceSwLogPortSetId.setDescription('')
dcvVoiceSwRemovedDigitNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 4, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 21))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvVoiceSwRemovedDigitNumber.setStatus('mandatory')
if mibBuilder.loadTexts: dcvVoiceSwRemovedDigitNumber.setDescription('')
dcvVoiceSwInsPrefix = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 4, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 21))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvVoiceSwInsPrefix.setStatus('mandatory')
if mibBuilder.loadTexts: dcvVoiceSwInsPrefix.setDescription('')
dcvVoiceSwInsSuffix = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 4, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 21))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvVoiceSwInsSuffix.setStatus('mandatory')
if mibBuilder.loadTexts: dcvVoiceSwInsSuffix.setDescription('')
dcvDialingReceptTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 5), )
if mibBuilder.loadTexts: dcvDialingReceptTable.setStatus('mandatory')
if mibBuilder.loadTexts: dcvDialingReceptTable.setDescription('')
dcvDialingReceptEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 5, 1), ).setIndexNames((0, "PCE-MIB", "dcvDialRxSuscriberNumber"))
if mibBuilder.loadTexts: dcvDialingReceptEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dcvDialingReceptEntry.setDescription('An entry of dcvDialingReceptTable.')
dcvDialRxSuscriberNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 5, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 21))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcvDialRxSuscriberNumber.setStatus('mandatory')
if mibBuilder.loadTexts: dcvDialRxSuscriberNumber.setDescription('')
dcvDialRxStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvDialRxStatus.setStatus('mandatory')
if mibBuilder.loadTexts: dcvDialRxStatus.setDescription('')
dcvDialRxNumberLength = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 5, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 21))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvDialRxNumberLength.setStatus('mandatory')
if mibBuilder.loadTexts: dcvDialRxNumberLength.setDescription('')
dcvDialRxEndOfDialingTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 5, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvDialRxEndOfDialingTimer.setStatus('mandatory')
if mibBuilder.loadTexts: dcvDialRxEndOfDialingTimer.setDescription('')
dcvVoiceLogPort = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 10))
dcvVoiceLogicalPortTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 10, 1), )
if mibBuilder.loadTexts: dcvVoiceLogicalPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: dcvVoiceLogicalPortTable.setDescription('')
dcvVoiceLogicalPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 10, 1, 1), ).setIndexNames((0, "PCE-MIB", "dcvVoiceLogPortId"))
if mibBuilder.loadTexts: dcvVoiceLogicalPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dcvVoiceLogicalPortEntry.setDescription('An entry of dcvVoiceLogicalPortTable.')
dcvVoiceLogPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 10, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcvVoiceLogPortId.setStatus('mandatory')
if mibBuilder.loadTexts: dcvVoiceLogPortId.setDescription('')
dcvVoiceLogPortStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 10, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvVoiceLogPortStatus.setStatus('mandatory')
if mibBuilder.loadTexts: dcvVoiceLogPortStatus.setDescription('')
dcvVoiceLogPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 10, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("tsPCMPermanent", 1), ("tsPCMSwitched", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvVoiceLogPortType.setStatus('mandatory')
if mibBuilder.loadTexts: dcvVoiceLogPortType.setDescription('')
dcvProfileTone = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 10, 5))
dcvToneGenTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 10, 5, 1), )
if mibBuilder.loadTexts: dcvToneGenTable.setStatus('mandatory')
if mibBuilder.loadTexts: dcvToneGenTable.setDescription('')
dcvToneGenEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 10, 5, 1, 1), ).setIndexNames((0, "PCE-MIB", "dcvToneGenProfileId"))
if mibBuilder.loadTexts: dcvToneGenEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dcvToneGenEntry.setDescription('An entry of dcvToneGenTable.')
dcvToneGenProfileId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 10, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcvToneGenProfileId.setStatus('mandatory')
if mibBuilder.loadTexts: dcvToneGenProfileId.setDescription('')
dcvToneGenLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 10, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvToneGenLevel.setStatus('mandatory')
if mibBuilder.loadTexts: dcvToneGenLevel.setDescription('')
dcvToneTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 10, 5, 2), )
if mibBuilder.loadTexts: dcvToneTable.setStatus('mandatory')
if mibBuilder.loadTexts: dcvToneTable.setDescription('')
dcvToneEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 10, 5, 2, 1), ).setIndexNames((0, "PCE-MIB", "dcvToneProfileId"), (0, "PCE-MIB", "dcvToneType"))
if mibBuilder.loadTexts: dcvToneEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dcvToneEntry.setDescription('An entry of dcvToneTable.')
dcvToneProfileId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 10, 5, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcvToneProfileId.setStatus('mandatory')
if mibBuilder.loadTexts: dcvToneProfileId.setDescription('')
dcvToneType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 10, 5, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("dialTone", 1), ("trouble", 2), ("congestion", 3), ("busy", 4), ("callBack", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcvToneType.setStatus('mandatory')
if mibBuilder.loadTexts: dcvToneType.setDescription('')
dcvToneEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 10, 5, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvToneEnable.setStatus('mandatory')
if mibBuilder.loadTexts: dcvToneEnable.setDescription('')
dcvToneFreq1 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 10, 5, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvToneFreq1.setStatus('mandatory')
if mibBuilder.loadTexts: dcvToneFreq1.setDescription('')
dcvToneDuration1 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 10, 5, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 500))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvToneDuration1.setStatus('mandatory')
if mibBuilder.loadTexts: dcvToneDuration1.setDescription('')
dcvToneFreq2 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 10, 5, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvToneFreq2.setStatus('mandatory')
if mibBuilder.loadTexts: dcvToneFreq2.setDescription('')
dcvToneDuration2 = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 10, 5, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 500))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvToneDuration2.setStatus('mandatory')
if mibBuilder.loadTexts: dcvToneDuration2.setDescription('')
dcvVoiceLogicalPortTSPCM = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 10, 10))
dcvTSPCMPerm = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 10, 10, 1))
dcvTSPCMPermTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 10, 10, 1, 1), )
if mibBuilder.loadTexts: dcvTSPCMPermTable.setStatus('mandatory')
if mibBuilder.loadTexts: dcvTSPCMPermTable.setDescription('')
dcvTSPCMPermEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 10, 10, 1, 1, 1), ).setIndexNames((0, "PCE-MIB", "dcvTSPCMPermLpId"))
if mibBuilder.loadTexts: dcvTSPCMPermEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dcvTSPCMPermEntry.setDescription('An entry of dcvTSPCMPermTable.')
dcvTSPCMPermLpId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 10, 10, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcvTSPCMPermLpId.setStatus('mandatory')
if mibBuilder.loadTexts: dcvTSPCMPermLpId.setDescription('')
dcvTSPCMPermCommunicationMode = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 10, 10, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dte", 1), ("dce", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvTSPCMPermCommunicationMode.setStatus('mandatory')
if mibBuilder.loadTexts: dcvTSPCMPermCommunicationMode.setDescription('')
dcvTSPCMPermRemoteNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 10, 10, 1, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 21))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvTSPCMPermRemoteNumber.setStatus('mandatory')
if mibBuilder.loadTexts: dcvTSPCMPermRemoteNumber.setDescription('')
dcvTSPCMPermConfigId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 10, 10, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcvTSPCMPermConfigId.setStatus('mandatory')
if mibBuilder.loadTexts: dcvTSPCMPermConfigId.setDescription('')
dcvTSPCMPermChannIfId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 10, 10, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvTSPCMPermChannIfId.setStatus('mandatory')
if mibBuilder.loadTexts: dcvTSPCMPermChannIfId.setDescription('')
dcvTSPCMSw = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 10, 10, 2))
dcvTSPCMSwTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 10, 10, 2, 1), )
if mibBuilder.loadTexts: dcvTSPCMSwTable.setStatus('mandatory')
if mibBuilder.loadTexts: dcvTSPCMSwTable.setDescription('')
dcvTSPCMSwEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 10, 10, 2, 1, 1), ).setIndexNames((0, "PCE-MIB", "dcvTSPCMSwLpId"))
if mibBuilder.loadTexts: dcvTSPCMSwEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dcvTSPCMSwEntry.setDescription('An entry of dcvTSPCMSwTable.')
dcvTSPCMSwLpId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 10, 10, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcvTSPCMSwLpId.setStatus('mandatory')
if mibBuilder.loadTexts: dcvTSPCMSwLpId.setDescription('')
dcvTSPCMSwLogPortSetId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 10, 10, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvTSPCMSwLogPortSetId.setStatus('mandatory')
if mibBuilder.loadTexts: dcvTSPCMSwLogPortSetId.setDescription('')
dcvTSPCMSwCallType = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 10, 10, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("incoming", 1), ("outgoing", 2), ("mixed", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvTSPCMSwCallType.setStatus('mandatory')
if mibBuilder.loadTexts: dcvTSPCMSwCallType.setDescription('')
dcvTSPCMSwRemoteNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 10, 10, 2, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 21))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvTSPCMSwRemoteNumber.setStatus('mandatory')
if mibBuilder.loadTexts: dcvTSPCMSwRemoteNumber.setDescription('')
dcvTSPCMSwConfigId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 10, 10, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcvTSPCMSwConfigId.setStatus('mandatory')
if mibBuilder.loadTexts: dcvTSPCMSwConfigId.setDescription('')
dcvTSPCMSwChannIfId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 10, 10, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvTSPCMSwChannIfId.setStatus('mandatory')
if mibBuilder.loadTexts: dcvTSPCMSwChannIfId.setDescription('')
dcvCASConfigTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 10, 10, 5), )
if mibBuilder.loadTexts: dcvCASConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: dcvCASConfigTable.setDescription('')
dcvCASConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 10, 10, 5, 1), ).setIndexNames((0, "PCE-MIB", "dcvCASConfId"))
if mibBuilder.loadTexts: dcvCASConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dcvCASConfigEntry.setDescription('An entry of dcvCASConfigTable.')
dcvCASConfId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 10, 10, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcvCASConfId.setStatus('mandatory')
if mibBuilder.loadTexts: dcvCASConfId.setDescription('')
dcvCASConfSignallingTransport = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 10, 10, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("a", 2), ("ab", 3), ("abcd", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvCASConfSignallingTransport.setStatus('mandatory')
if mibBuilder.loadTexts: dcvCASConfSignallingTransport.setDescription('')
dcvCASConfCallSignalling = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 10, 10, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("nColisee", 1), ("uColisee", 2), ("simm", 3), ("sDelay", 4), ("swink", 5), ("noResp", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvCASConfCallSignalling.setStatus('mandatory')
if mibBuilder.loadTexts: dcvCASConfCallSignalling.setDescription('')
dcvCASConfDialingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 10, 10, 5, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dec", 1), ("dtmf", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvCASConfDialingMode.setStatus('mandatory')
if mibBuilder.loadTexts: dcvCASConfDialingMode.setDescription('')
dcvCASConfDialingTimeOut = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 10, 10, 5, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvCASConfDialingTimeOut.setStatus('mandatory')
if mibBuilder.loadTexts: dcvCASConfDialingTimeOut.setDescription('')
dcvCASConfSigChannelDiscTimeOut = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 10, 10, 5, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvCASConfSigChannelDiscTimeOut.setStatus('mandatory')
if mibBuilder.loadTexts: dcvCASConfSigChannelDiscTimeOut.setDescription('')
dcvCASConfTimeBetweenSuccOutCall = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 10, 10, 5, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvCASConfTimeBetweenSuccOutCall.setStatus('mandatory')
if mibBuilder.loadTexts: dcvCASConfTimeBetweenSuccOutCall.setDescription('')
dcvCASConfLineInterfacePolarity = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 10, 10, 5, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("inverted", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvCASConfLineInterfacePolarity.setStatus('mandatory')
if mibBuilder.loadTexts: dcvCASConfLineInterfacePolarity.setDescription('')
dcvCASConfMinLineSeizureAckTime = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 10, 10, 5, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 50))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvCASConfMinLineSeizureAckTime.setStatus('mandatory')
if mibBuilder.loadTexts: dcvCASConfMinLineSeizureAckTime.setDescription('')
dcvCASConfMaxLineSeizureAckTime = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 10, 10, 5, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 50))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvCASConfMaxLineSeizureAckTime.setStatus('mandatory')
if mibBuilder.loadTexts: dcvCASConfMaxLineSeizureAckTime.setDescription('')
dcvCASConfLineSeizureAckTime = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 10, 10, 5, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 50))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvCASConfLineSeizureAckTime.setStatus('mandatory')
if mibBuilder.loadTexts: dcvCASConfLineSeizureAckTime.setDescription('')
dcvCASConfClearToIncCallTime = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 10, 10, 5, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(3, 50))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvCASConfClearToIncCallTime.setStatus('mandatory')
if mibBuilder.loadTexts: dcvCASConfClearToIncCallTime.setDescription('')
dcvCASConfSeizureAckPulseDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 10, 10, 5, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvCASConfSeizureAckPulseDuration.setStatus('mandatory')
if mibBuilder.loadTexts: dcvCASConfSeizureAckPulseDuration.setDescription('')
dcvCASConfMinSeizureAckPulseDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 10, 10, 5, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvCASConfMinSeizureAckPulseDuration.setStatus('mandatory')
if mibBuilder.loadTexts: dcvCASConfMinSeizureAckPulseDuration.setDescription('')
dcvCASConfDialingFormat = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 10, 10, 5, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ds1", 1), ("ds2", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvCASConfDialingFormat.setStatus('mandatory')
if mibBuilder.loadTexts: dcvCASConfDialingFormat.setDescription('')
dcvCASConfInterdigitTime = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 10, 10, 5, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvCASConfInterdigitTime.setStatus('mandatory')
if mibBuilder.loadTexts: dcvCASConfInterdigitTime.setDescription('')
dcvCASConfPauseTime = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 10, 10, 5, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvCASConfPauseTime.setStatus('mandatory')
if mibBuilder.loadTexts: dcvCASConfPauseTime.setDescription('')
dcvCASConfDtmfDigitTime = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 10, 10, 5, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvCASConfDtmfDigitTime.setStatus('mandatory')
if mibBuilder.loadTexts: dcvCASConfDtmfDigitTime.setDescription('')
dcvCASConfDtmfDigitLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 10, 10, 5, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvCASConfDtmfDigitLevel.setStatus('mandatory')
if mibBuilder.loadTexts: dcvCASConfDtmfDigitLevel.setDescription('')
dcvCASConfDelayBeforeDialing = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 10, 10, 5, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvCASConfDelayBeforeDialing.setStatus('mandatory')
if mibBuilder.loadTexts: dcvCASConfDelayBeforeDialing.setDescription('')
dcvCASConfDigitReceptionTimeOut = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 10, 10, 5, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvCASConfDigitReceptionTimeOut.setStatus('mandatory')
if mibBuilder.loadTexts: dcvCASConfDigitReceptionTimeOut.setDescription('')
dcvCASConfEndOfDialingTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 10, 10, 5, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvCASConfEndOfDialingTimer.setStatus('mandatory')
if mibBuilder.loadTexts: dcvCASConfEndOfDialingTimer.setDescription('')
dcvCASConfToneProfile = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 10, 10, 5, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcvCASConfToneProfile.setStatus('mandatory')
if mibBuilder.loadTexts: dcvCASConfToneProfile.setDescription('')
dcvCASConfIdleState = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 10, 10, 5, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvCASConfIdleState.setStatus('mandatory')
if mibBuilder.loadTexts: dcvCASConfIdleState.setDescription('')
dcvCASConfAlarmState = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 10, 10, 5, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvCASConfAlarmState.setStatus('mandatory')
if mibBuilder.loadTexts: dcvCASConfAlarmState.setDescription('')
dcvDigitalLines = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 15))
dcvIfPCM = MibIdentifier((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 15, 1))
dcvIfPCMPhysTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 15, 1, 1), )
if mibBuilder.loadTexts: dcvIfPCMPhysTable.setStatus('mandatory')
if mibBuilder.loadTexts: dcvIfPCMPhysTable.setDescription('')
dcvIfPCMPhysEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 15, 1, 1, 1), ).setIndexNames((0, "PCE-MIB", "dcvIfPCMPhysIfId"))
if mibBuilder.loadTexts: dcvIfPCMPhysEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dcvIfPCMPhysEntry.setDescription('An entry of dcvIfPCMPhysTable.')
dcvIfPCMPhysIfId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 15, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("pcm1", 1), ("other", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcvIfPCMPhysIfId.setStatus('mandatory')
if mibBuilder.loadTexts: dcvIfPCMPhysIfId.setDescription('')
dcvIfPCMPhysTypeId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 15, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("e1", 1), ("t1-12", 2), ("t1-24", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvIfPCMPhysTypeId.setStatus('mandatory')
if mibBuilder.loadTexts: dcvIfPCMPhysTypeId.setDescription('')
dcvIfPCMPhysPhysicalPort = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 15, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("v1", 1), ("v2", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvIfPCMPhysPhysicalPort.setStatus('mandatory')
if mibBuilder.loadTexts: dcvIfPCMPhysPhysicalPort.setDescription('')
dcvIfPCMChannelTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 15, 1, 2), )
if mibBuilder.loadTexts: dcvIfPCMChannelTable.setStatus('mandatory')
if mibBuilder.loadTexts: dcvIfPCMChannelTable.setDescription('')
dcvIfPCMChannelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 15, 1, 2, 1), ).setIndexNames((0, "PCE-MIB", "dcvIfPCMChannelIfId"))
if mibBuilder.loadTexts: dcvIfPCMChannelEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dcvIfPCMChannelEntry.setDescription('An entry of dcvIfPCMChannelTable.')
dcvIfPCMChannelIfId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 15, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcvIfPCMChannelIfId.setStatus('mandatory')
if mibBuilder.loadTexts: dcvIfPCMChannelIfId.setDescription('')
dcvIfPCMChannelStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 15, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvIfPCMChannelStatus.setStatus('mandatory')
if mibBuilder.loadTexts: dcvIfPCMChannelStatus.setDescription('')
dcvIfPCMChannelVoiceProfId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 15, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvIfPCMChannelVoiceProfId.setStatus('mandatory')
if mibBuilder.loadTexts: dcvIfPCMChannelVoiceProfId.setDescription('')
dcvIfPCMChannelPhysIf = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 15, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("pcm1", 1), ("other", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcvIfPCMChannelPhysIf.setStatus('mandatory')
if mibBuilder.loadTexts: dcvIfPCMChannelPhysIf.setDescription('')
dcvVoiceProfileTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 15, 5), )
if mibBuilder.loadTexts: dcvVoiceProfileTable.setStatus('mandatory')
if mibBuilder.loadTexts: dcvVoiceProfileTable.setDescription('')
dcvVoiceProfileEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 15, 5, 1), ).setIndexNames((0, "PCE-MIB", "dcvVoiceProfId"))
if mibBuilder.loadTexts: dcvVoiceProfileEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dcvVoiceProfileEntry.setDescription('An entry of dcvVoiceProfileTable.')
dcvVoiceProfId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 15, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcvVoiceProfId.setStatus('mandatory')
if mibBuilder.loadTexts: dcvVoiceProfId.setDescription('')
dcvVoiceProfTransmitLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 15, 5, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 24))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvVoiceProfTransmitLevel.setStatus('mandatory')
if mibBuilder.loadTexts: dcvVoiceProfTransmitLevel.setDescription('')
dcvVoiceProfReceiveLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 15, 5, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvVoiceProfReceiveLevel.setStatus('mandatory')
if mibBuilder.loadTexts: dcvVoiceProfReceiveLevel.setDescription('')
dcvVoiceProfSilenceDetection = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 15, 5, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("no", 1), ("yes", 2), ("cng", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvVoiceProfSilenceDetection.setStatus('mandatory')
if mibBuilder.loadTexts: dcvVoiceProfSilenceDetection.setDescription('')
dcvVoiceProfSilenceDetectionLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 15, 5, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("low", 1), ("medium", 2), ("high", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvVoiceProfSilenceDetectionLevel.setStatus('mandatory')
if mibBuilder.loadTexts: dcvVoiceProfSilenceDetectionLevel.setDescription('')
dcvVoiceProfEchoCancellation = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 15, 5, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvVoiceProfEchoCancellation.setStatus('mandatory')
if mibBuilder.loadTexts: dcvVoiceProfEchoCancellation.setDescription('')
dcvVoiceProfEchoCancellationLength = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 15, 5, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("low", 1), ("medium", 2), ("high", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvVoiceProfEchoCancellationLength.setStatus('mandatory')
if mibBuilder.loadTexts: dcvVoiceProfEchoCancellationLength.setDescription('')
dcvVoiceProfNoiseFramesPeriodicity = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 15, 5, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(4, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvVoiceProfNoiseFramesPeriodicity.setStatus('mandatory')
if mibBuilder.loadTexts: dcvVoiceProfNoiseFramesPeriodicity.setDescription('')
dcvVoiceProfLoopActivation = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 15, 5, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("no", 1), ("local", 2), ("remote", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvVoiceProfLoopActivation.setStatus('mandatory')
if mibBuilder.loadTexts: dcvVoiceProfLoopActivation.setDescription('')
dcvVoiceProfFaxActivation = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 15, 5, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvVoiceProfFaxActivation.setStatus('mandatory')
if mibBuilder.loadTexts: dcvVoiceProfFaxActivation.setDescription('')
dcvVoiceProfMaximumFaxSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 15, 5, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("s9600", 1), ("s4800", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvVoiceProfMaximumFaxSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: dcvVoiceProfMaximumFaxSpeed.setDescription('')
dcvVoiceProfCESMode = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 15, 5, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvVoiceProfCESMode.setStatus('mandatory')
if mibBuilder.loadTexts: dcvVoiceProfCESMode.setDescription('')
dcvVoiceProfCESModeAverageDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 15, 5, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(4, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcvVoiceProfCESModeAverageDelay.setStatus('mandatory')
if mibBuilder.loadTexts: dcvVoiceProfCESModeAverageDelay.setDescription('')
dcvVoicePhysicalPortTable = MibTable((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 15, 10), )
if mibBuilder.loadTexts: dcvVoicePhysicalPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: dcvVoicePhysicalPortTable.setDescription('')
dcvVoicePhysicalPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 15, 10, 1), ).setIndexNames((0, "PCE-MIB", "dcvVoicePhysPortId"))
if mibBuilder.loadTexts: dcvVoicePhysicalPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dcvVoicePhysicalPortEntry.setDescription('An entry of dcvVoicePhysicalPortTable.')
dcvVoicePhysPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 15, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("v1", 1), ("v2", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcvVoicePhysPortId.setStatus('mandatory')
if mibBuilder.loadTexts: dcvVoicePhysPortId.setDescription('')
dcvVoicePhysPortConnector = MibTableColumn((1, 3, 6, 1, 4, 1, 866, 30, 20, 30, 10, 15, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("tdm", 1), ("other", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dcvVoicePhysPortConnector.setStatus('mandatory')
if mibBuilder.loadTexts: dcvVoicePhysPortConnector.setDescription('')
mibBuilder.exportSymbols("PCE-MIB", fclB3270LpEmulationType=fclB3270LpEmulationType, fciFlowRouteEntry=fciFlowRouteEntry, cfFactoryReturnDate3=cfFactoryReturnDate3, fmeEvtFamilyId=fmeEvtFamilyId, fclX25MlpOvMeasureCount=fclX25MlpOvMeasureCount, dcvIfPCMChannelStatus=dcvIfPCMChannelStatus, fclIulConversionIncomingCall=fclIulConversionIncomingCall, fclX25Mlp=fclX25Mlp, fmsInArpVpInRequests=fmsInArpVpInRequests, fclAsynCfgSerReliableVc=fclAsynCfgSerReliableVc, dcCtlHour=dcCtlHour, fmsEthLineId=fmsEthLineId, fcCtlStorageDevice=fcCtlStorageDevice, fclFrPvcQosLinkType=fclFrPvcQosLinkType, fclB3270CluClusterLogPortId=fclB3270CluClusterLogPortId, fclSdlcLpCompressNegotiation=fclSdlcLpCompressNegotiation, fclPppBIsdnLocalBriEntry=fclPppBIsdnLocalBriEntry, fclFrTeLogPortEntry=fclFrTeLogPortEntry, fclFrBackupStatus=fclFrBackupStatus, fclX25CfnNegWindowSize=fclX25CfnNegWindowSize, fclFrPvcTunBackupEnabling=fclFrPvcTunBackupEnabling, fcxServStaticNetNum=fcxServStaticNetNum, fclLogicalPortTable=fclLogicalPortTable, fcsnaLvpParamN3=fcsnaLvpParamN3, fmsEthOutErrDmaUnderrunCounter=fmsEthOutErrDmaUnderrunCounter, fmsPppPhysRemoteMru=fmsPppPhysRemoteMru, fmsPppAuthSlaveSuccessCounter=fmsPppAuthSlaveSuccessCounter, fclVipCluLpPollingTypeAfterSelect=fclVipCluLpPollingTypeAfterSelect, fcfIsdnRemIsdnNumber=fcfIsdnRemIsdnNumber, dcvTSPCMSwLpId=dcvTSPCMSwLpId, fclSdlcSecLpPollingTimer=fclSdlcSecLpPollingTimer, fcfLineV28AsynOutDteInterfaceId=fcfLineV28AsynOutDteInterfaceId, fclFrCfsSigT200RetransTimer=fclFrCfsSigT200RetransTimer, fcsHardDescReplicatedMode=fcsHardDescReplicatedMode, fclX25CfaNegMaxOutWindowSize=fclX25CfaNegMaxOutWindowSize, fclPppCfaRemIdentifier=fclPppCfaRemIdentifier, fmsIpTrafInReceivesCounter=fmsIpTrafInReceivesCounter, fmsFrDlcLogPortId=fmsFrDlcLogPortId, vcmAlrmSvcTyp=vcmAlrmSvcTyp, vcvTftpName=vcvTftpName, dcmAlrmSwFamilyId=dcmAlrmSwFamilyId, fcmAlrmPpPhysPort7=fcmAlrmPpPhysPort7, fclEthernetTable=fclEthernetTable, vcvFxxConfTimeBetweenSuccOutCall=vcvFxxConfTimeBetweenSuccOutCall, fmuLineAccess=fmuLineAccess, fclX25CfaSigConfigId=fclX25CfaSigConfigId, fclX25MlpMt4DownLinkDetectionTimer=fclX25MlpMt4DownLinkDetectionTimer, fmOspfStandardStubAreaID=fmOspfStandardStubAreaID, fcwSerReliableVirtualCircuits=fcwSerReliableVirtualCircuits, fmsEthOutSQETestErrorsCounter=fmsEthOutSQETestErrorsCounter, vcVirtualPorts=vcVirtualPorts, fclBSctProtocolDefinition1Entry=fclBSctProtocolDefinition1Entry, fclAsynCfgX3UserP21Parity=fclAsynCfgX3UserP21Parity, fcwConvMultiOutExternalAddr=fcwConvMultiOutExternalAddr, fclBX780IdentEntry=fclBX780IdentEntry, fclFrPvcSnaBanN2RetryCount=fclFrPvcSnaBanN2RetryCount, fciIpRouteTable=fciIpRouteTable, fcwSRvcReliableVcCount=fcwSRvcReliableVcCount, fclAsynchronousAccessLogPort=fclAsynchronousAccessLogPort, cfFlashSize=cfFlashSize, fccClnpRouting=fccClnpRouting, fclPppBIsdnLpIsdnInterfaceId=fclPppBIsdnLpIsdnInterfaceId, fmsIpCluVirtualIpAddress=fmsIpCluVirtualIpAddress, fclFrTeIsdnBackStatus=fclFrTeIsdnBackStatus, fclX25InDBackupEnabling=fclX25InDBackupEnabling, fmsFrDlcState=fmsFrDlcState, fmsFrDlcOutDiscards=fmsFrDlcOutDiscards, fclVipHosElementId=fclVipHosElementId, fclX25CfaDlnT1AcknowledgeTimer=fclX25CfaDlnT1AcknowledgeTimer, dclFrSeSigT203InactivityTimer=dclFrSeSigT203InactivityTimer, cfZoneToIdentify=cfZoneToIdentify, dcmAlrmSvcDisplay=dcmAlrmSvcDisplay, fclX25AccPdnLinkAddress=fclX25AccPdnLinkAddress, fmOspfStandardAreaRangeStatus=fmOspfStandardAreaRangeStatus, fcmMgfStatLogChannelSamplingPeriod=fcmMgfStatLogChannelSamplingPeriod, fclX25CfaNegInputFastSelect=fclX25CfaNegInputFastSelect, fmhEqIdSerialNb=fmhEqIdSerialNb, dcmAlrmGenDisplay=dcmAlrmGenDisplay, fclX25CfaDescription=fclX25CfaDescription, fmRip2PeerVersion=fmRip2PeerVersion, fcfLineV35DteD106=fcfLineV35DteD106, fmsFrcStorageBe=fmsFrcStorageBe, fcsnaLvpTrParamBc=fcsnaLvpTrParamBc, fmuFunctionOverflowResc=fmuFunctionOverflowResc, fclFrTeIsdnRemotePeerTable=fclFrTeIsdnRemotePeerTable, fcwSRvcConversionAimedPoint=fcwSRvcConversionAimedPoint, vclFrCeLogPortTable=vclFrCeLogPortTable, fclX25CfaProfileId=fclX25CfaProfileId, fcvLvpFltFilterTable=fcvLvpFltFilterTable, fclEthernet=fclEthernet, fclAsynCfgLinkConfigId=fclAsynCfgLinkConfigId, fclX25SlpSwSwitchBackThreshold=fclX25SlpSwSwitchBackThreshold, fmsBootPRelayDroppedPkts=fmsBootPRelayDroppedPkts, dcvVoicePhysicalPortTable=dcvVoicePhysicalPortTable, fclAsynAutoLogPortId=fclAsynAutoLogPortId, fmhTechnicTransputerPresence=fmhTechnicTransputerPresence, fcwSCUDProfilesId=fcwSCUDProfilesId, dcvToneEntry=dcvToneEntry, fcvRvpConnCos=fcvRvpConnCos, fmsFrDlcOutBecnFrames=fmsFrDlcOutBecnFrames, mcx112=mcx112, fclSdlcPrimaryPuLogPort=fclSdlcPrimaryPuLogPort, fcfLineV35DteSyn=fcfLineV35DteSyn, fcsnaLvpParamCir=fcsnaLvpParamCir, vcvVoiceSuscriberTable=vcvVoiceSuscriberTable, fmsFrcStorageSubDlci=fmsFrcStorageSubDlci, fclAsynCfgX3ProfileId=fclAsynCfgX3ProfileId, fclX25AccPvcRemoteLogChannel=fclX25AccPvcRemoteLogChannel, fclFrTeIsdnRemProtocol=fclFrTeIsdnRemProtocol, fciOspfVlTransitAreaId=fciOspfVlTransitAreaId, fmPingCompletedFlag=fmPingCompletedFlag, fclPointToPointProtocol=fclPointToPointProtocol, vcCtlErrorTable=vcCtlErrorTable, vcvTftpInactTimer=vcvTftpInactTimer, fcwSQOSX25Cos=fcwSQOSX25Cos, fclFrTeLogPortTable=fclFrTeLogPortTable, fcfE1Ds1DropInsertStatus=fcfE1Ds1DropInsertStatus, avb1002_FXS_FXO=avb1002_FXS_FXO, fciTelnetUserId=fciTelnetUserId, fciTelnetPwdP9=fciTelnetPwdP9, fdpCtrlDiagCode=fdpCtrlDiagCode, vcmAlrmSvcDisplay=vcmAlrmSvcDisplay, fcfIsdnRemStatus=fcfIsdnRemStatus, vclFrTeLpLogPortId=vclFrTeLpLogPortId, fclX25SlpIsdnRemCallRetryCount=fclX25SlpIsdnRemCallRetryCount, fclAsynX28PlusRemCfgX3P09CrPadding=fclAsynX28PlusRemCfgX3P09CrPadding, fmsGlobCongCpuLostBlocks=fmsGlobCongCpuLostBlocks, fmsBrdgTrafInServCounter=fmsBrdgTrafInServCounter, fclBscX780LogPort=fclBscX780LogPort, vcvTftpIpAddress=vcvTftpIpAddress, vcvVoiceProfSilenceDetectionLevel=vcvVoiceProfSilenceDetectionLevel, vcvIpLocSvcCallRetryCount=vcvIpLocSvcCallRetryCount, dclFrSeLogPortTable=dclFrSeLogPortTable, fcwRouteTable=fcwRouteTable, fciFlowTable=fciFlowTable, fclFrPvcNetworkTransport=fclFrPvcNetworkTransport, fcsnaLvpParamFrameFormat=fcsnaLvpParamFrameFormat, fmsRvpConnId=fmsRvpConnId, fciRipVirtualPortTable=fciRipVirtualPortTable, fccLvpEsIsHoldingTimer=fccLvpEsIsHoldingTimer, fmOsiISISISAdjacencyAreaAddressEntry=fmOsiISISISAdjacencyAreaAddressEntry, dcmAlrmSCTyp=dcmAlrmSCTyp, fcFrSwInputInterfaceId=fcFrSwInputInterfaceId, fcfLineModType=fcfLineModType, fclVipHosLpWaitTimeOutForPrinter=fclVipHosLpWaitTimeOutForPrinter, cf12NcNumber75=cf12NcNumber75, fmsEthOutErrCtsLossCounter=fmsEthOutErrCtsLossCounter, fclX25InBRemLinkCheckPeriod=fclX25InBRemLinkCheckPeriod, dcfPhysPortConnector=dcfPhysPortConnector, fcfE1Ds1DropInsertEntry=fcfE1Ds1DropInsertEntry, fcfIsdnDSigMulDialsTotalDuration=fcfIsdnDSigMulDialsTotalDuration, fcfIsdnDSigUnuseTimer=fcfIsdnDSigUnuseTimer, dcmAlrmVCDisplay=dcmAlrmVCDisplay, fcfIsdnBriSignalling=fcfIsdnBriSignalling, fcfIsdnDTimIsdnInterfaceId=fcfIsdnDTimIsdnInterfaceId, fclX25SlpIsdnBackupEntry=fclX25SlpIsdnBackupEntry, fdpModRespEltNum=fdpModRespEltNum, fclX25SlpSwitchOverEntry=fclX25SlpSwitchOverEntry, fcmMgfConversionIncomingCall=fcmMgfConversionIncomingCall, fclAsynCfgConfigId=fclAsynCfgConfigId, fclX25InBLogPortId=fclX25InBLogPortId, fclX25CfaPackingAddresses=fclX25CfaPackingAddresses, fcfLineModInputXidString=fcfLineModInputXidString, fcsnaLvpParamCompression=fcsnaLvpParamCompression, sc1200=sc1200, fclPppCfgAuthentication=fclPppCfgAuthentication, fcfIsdnRemCallDirection=fcfIsdnRemCallDirection, fmeFamilyEntry=fmeFamilyEntry, fciLocalClusterEntry=fciLocalClusterEntry, fmsMlpLineId=fmsMlpLineId, fclVipHosElemLogPortId=fclVipHosElemLogPortId, fciLclVirtualIpAddress=fciLclVirtualIpAddress, fcwZoRoutingTable=fcwZoRoutingTable, fcvLvpFltCondStatus=fcvLvpFltCondStatus, fclX25CfaNegDefOutPacketSize=fclX25CfaNegDefOutPacketSize, vcvEMSwTable=vcvEMSwTable, fcwSClearAnalysId=fcwSClearAnalysId, fclFrPvcEndPoint=fclFrPvcEndPoint, fcfLineModemManagement=fcfLineModemManagement, fcwSDynLspAgingTimer=fcwSDynLspAgingTimer, fclVipLpResponseSurveyPollingTimer=fclVipLpResponseSurveyPollingTimer, dcvToneType=dcvToneType, fmStatFrLineEntry=fmStatFrLineEntry, fclB3270HosClusterLogPortId=fclB3270HosClusterLogPortId, fclFrTeLpBackupTimer=fclFrTeLpBackupTimer, fclX25AccPvcFacThroughputClass=fclX25AccPvcFacThroughputClass, fcwRoutType=fcwRoutType, fdpTestInErrPktsCounter=fdpTestInErrPktsCounter, fclFrTeParGenLogPortId=fclFrTeParGenLogPortId, fclAsynAutoMinimumRecallTimer=fclAsynAutoMinimumRecallTimer, fclAsynVdxHomePageEntry=fclAsynVdxHomePageEntry, fmStatPppPhysLineEntry=fmStatPppPhysLineEntry, fmOspfStandardLsdbLSID=fmOspfStandardLsdbLSID, fcfIsdnPrimaryRateInterfaceTable=fcfIsdnPrimaryRateInterfaceTable, fcwSQOSProfilesBe=fcwSQOSProfilesBe, fcfLineDVBConnection=fcfLineDVBConnection, dcvSnmpManagerStatus=dcvSnmpManagerStatus, fcsnaLvpTrParamT2=fcsnaLvpTrParamT2, fmOsiISISAreaTable=fmOsiISISAreaTable, fcvRvpConnCir=fcvRvpConnCir, fcxServCircSapUpdate=fcxServCircSapUpdate, fmsIpLanInHdrErrorsCounter=fmsIpLanInHdrErrorsCounter, fcfLineV35DteF109=fcfLineV35DteF109, fclX25InBRemStatus=fclX25InBRemStatus, fclFrCeLogPortEntry=fclFrCeLogPortEntry, fcmMgfStatBufferThreshold=fcmMgfStatBufferThreshold, fcvRvpConnStatus=fcvRvpConnStatus, fcCtlHRCheckMsgIndex=fcCtlHRCheckMsgIndex, fcfIsdnDTimT303SetupResponseTimer=fcfIsdnDTimT303SetupResponseTimer, fmsBrdgTrafOutPktsCounter=fmsBrdgTrafOutPktsCounter, vcmAlrmTftpDisplay=vcmAlrmTftpDisplay, fclX25SlpAccess=fclX25SlpAccess, fciFlowLengthMax=fciFlowLengthMax, fmsFrSwOverBookingThrouhput=fmsFrSwOverBookingThrouhput, fclSdlcSecClusterXidStringResponse=fclSdlcSecClusterXidStringResponse, vcwWanRouteLogPortId=vcwWanRouteLogPortId, fmOspfStandardNbrPriority=fmOspfStandardNbrPriority, fclX25CfaNegMaxOutPacketSize=fclX25CfaNegMaxOutPacketSize, fmRip2IfStatStatus=fmRip2IfStatStatus, dclFrSeSigSignalOutputWinSize=dclFrSeSigSignalOutputWinSize, dcvVoiceSwLogPortSetId=dcvVoiceSwLogPortSetId, fclFrTeIsdnRemRemotePeerId=fclFrTeIsdnRemRemotePeerId, dcvVoiceTransportTable=dcvVoiceTransportTable, fmsFrLpLogPortEntry=fmsFrLpLogPortEntry, cfField3=cfField3, vcfNumericLineTable=vcfNumericLineTable, fmOsiISISISAdjState=fmOsiISISISAdjState, fcvLvpFltCondValue=fcvLvpFltCondValue, fcfIsdnPriINbBChannel=fcfIsdnPriINbBChannel, fmStatEthInputTrafficEntry=fmStatEthInputTrafficEntry, fmuAccessRnisChannelDNbMax=fmuAccessRnisChannelDNbMax, fcxCircuitEntry=fcxCircuitEntry, cf12NcNumber35=cf12NcNumber35, fclFrCfsGenNetworkBandwidth=fclFrCfsGenNetworkBandwidth, fclFrSeIsdnBackupEntry=fclFrSeIsdnBackupEntry, vcwWanRouteTable=vcwWanRouteTable, fclAsynPadLpNui=fclAsynPadLpNui, fclSdlcPriClusterTable=fclSdlcPriClusterTable, fciRipEgpRoutesDistributionTable=fciRipEgpRoutesDistributionTable, fclAsynCfgFacReverseCharging=fclAsynCfgFacReverseCharging, fmOspfStandardLsdbChecksum=fmOspfStandardLsdbChecksum, fclSdlcLpPacketSize=fclSdlcLpPacketSize, fclBSctConnLogPortId=fclBSctConnLogPortId, fcwSQOSProfilesId=fcwSQOSProfilesId, fclX25InDIsdnRemConnectionType=fclX25InDIsdnRemConnectionType, fciBootPInterfaceVpId=fciBootPInterfaceVpId, fmeFamilyTable=fmeFamilyTable, fclBSctProtDef2WACK=fclBSctProtDef2WACK, fclX25CfaPackOutSubAddressSize=fclX25CfaPackOutSubAddressSize, cfVersion=cfVersion, fcfLineType=fcfLineType, dcvVoiceVirtualPortId=dcvVoiceVirtualPortId, fcfLineV35DteE107=fcfLineV35DteE107, fclSdlcLpLogPortId=fclSdlcLpLogPortId)
mibBuilder.exportSymbols("PCE-MIB", fclSdlcSecClusterFacility=fclSdlcSecClusterFacility, fcxCircuitTable=fcxCircuitTable, fcfLineLinkCheckPeriod=fcfLineLinkCheckPeriod, fclAsynX28PlusConfRemoteEntry=fclAsynX28PlusConfRemoteEntry, fclX25CfnNegMaxOutPacketSize=fclX25CfnNegMaxOutPacketSize, fclX25CfnSigT11CallResponseTimer=fclX25CfnSigT11CallResponseTimer, vcvVoiceGen=vcvVoiceGen, fclX25InBIsdnEntry=fclX25InBIsdnEntry, fciSnmpCommunityStringReadWrite=fciSnmpCommunityStringReadWrite, fmStatS0BChannelEntry=fmStatS0BChannelEntry, fclAsynCfgX3P03ForwardingChar=fclAsynCfgX3P03ForwardingChar, fmOsiISISCircInCrtlPdu=fmOsiISISCircInCrtlPdu, fmuAccessLineNbMax=fmuAccessLineNbMax, fcxRoutCircCircuitId=fcxRoutCircCircuitId, atLan=atLan, fmsS2BChIfLastChange=fmsS2BChIfLastChange, fcwConvInExternalAddr=fcwConvInExternalAddr, fcxRoutStaticRouteCircuitId=fcxRoutStaticRouteCircuitId, dcvVoiceProfileTable=dcvVoiceProfileTable, fmsFrLpSvcBookingVbrThroughput=fmsFrLpSvcBookingVbrThroughput, fclSdlcPriLogPortEntry=fclSdlcPriLogPortEntry, fcsnaLvpTrParamCallDirection=fcsnaLvpTrParamCallDirection, fciRipVirtualPortEntry=fciRipVirtualPortEntry, fcxServCircuitTable=fcxServCircuitTable, fclX25CfnConfigId=fclX25CfnConfigId, vcvTftpStatus=vcvTftpStatus, fmStatRvpConnectionsTable=fmStatRvpConnectionsTable, fmsWanConnEncapsulation=fmsWanConnEncapsulation, fcfPhysPortId=fcfPhysPortId, fcInterfaces=fcInterfaces, fclFrCfsGeneralParameterTable=fclFrCfsGeneralParameterTable, fclAsynVdxPageAttributes=fclAsynVdxPageAttributes, portLabel=portLabel, fmRip2PeerRcvBadPackets=fmRip2PeerRcvBadPackets, fmPingDelay=fmPingDelay, fmOspfStandardIfAuthKey=fmOspfStandardIfAuthKey, fcfIsdnDTimT310CallProceedingTimer=fcfIsdnDTimT310CallProceedingTimer, fccRemoteNeighborTable=fccRemoteNeighborTable, fmsFrLpIncomingTable=fmsFrLpIncomingTable, dclFrLmiParaDlci=dclFrLmiParaDlci, fclVipCluStatStationAddress=fclVipCluStatStationAddress, fclX25CfaPackingEntry=fclX25CfaPackingEntry, fclAsynPadHomePageTable=fclAsynPadHomePageTable, dcfPhysicalPortEntry=dcfPhysicalPortEntry, fmsFrLpOutLogPortId=fmsFrLpOutLogPortId, fmOsiISISESAdjType=fmOsiISISESAdjType, fpb2025=fpb2025, fmsFrcFilterAction=fmsFrcFilterAction, fmsFrCommFilter=fmsFrCommFilter, fclX25CfaSerCharging=fclX25CfaSerCharging, fmOspfStandardIfAdminStat=fmOspfStandardIfAdminStat, fclBSctProtocolDefinition2Table=fclBSctProtocolDefinition2Table, compacV9toV11=compacV9toV11, fmOspfStandardNbrIpAddress=fmOspfStandardNbrIpAddress, fclFrTeLpLocalAddress=fclFrTeLpLocalAddress, fmhEquipmentId=fmhEquipmentId, fciEgpNeighborEntry=fciEgpNeighborEntry, fcfIsdnBasicRateInterfaceEntry=fcfIsdnBasicRateInterfaceEntry, fclVipHosLpRepAEot=fclVipHosLpRepAEot, fclB3270HosLogPortEntry=fclB3270HosLogPortEntry, fcbBrdgRemoteAddressMappingEntry=fcbBrdgRemoteAddressMappingEntry, fcsnaLvpTrParamBe=fcsnaLvpTrParamBe, fclAsynCfgX3P12InputFlowCtrl=fclAsynCfgX3P12InputFlowCtrl, fmsPppIpAddrReceived=fmsPppIpAddrReceived, fmStatPppProtocolStatusTable=fmStatPppProtocolStatusTable, vclFrSwitchEquipment=vclFrSwitchEquipment, vcvVoiceProfId=vcvVoiceProfId, fclBSctProtDef1NbCharInhibited=fclBSctProtDef1NbCharInhibited, fcmMgfAlarmsSubscriber1=fcmMgfAlarmsSubscriber1, fmOspfStandardLsdbAdvertisement=fmOspfStandardLsdbAdvertisement, fmsFrLpNumPlan=fmsFrLpNumPlan, fcvRvpConnectionTable=fcvRvpConnectionTable, fclAsynCfgX3UserP22PageWait=fclAsynCfgX3UserP22PageWait, fclPppCftTerminateMaxCount=fclPppCftTerminateMaxCount, cfMtbBoardReference255=cfMtbBoardReference255, fmsEthManFilterDenyCounter=fmsEthManFilterDenyCounter, fclBSctProtDef1PermanentDelimiter3=fclBSctProtDef1PermanentDelimiter3, fcsModuleIpxRouterInit=fcsModuleIpxRouterInit, fcxServStaticStatus=fcxServStaticStatus, vcvSnmpManagerEntry=vcvSnmpManagerEntry, fmsFrcStorageCos=fmsFrcStorageCos, vclHdlcLogPortEntry=vclHdlcLogPortEntry, fcfIsdnDSigDirectInwardDialingCheck=fcfIsdnDSigDirectInwardDialingCheck, fclX25AccPvcLocalLogChannel=fclX25AccPvcLocalLogChannel, fclFrCfcLmiDlci=fclFrCfcLmiDlci, fmOspfStandardIfMetricTOS=fmOspfStandardIfMetricTOS, vcControl=vcControl, fclFraLpGroupingThreshold=fclFraLpGroupingThreshold, fmsRvpConnOutPktsCounter=fmsRvpConnOutPktsCounter, fciLclPriority=fciLclPriority, fmsEthOutExcessiveCollisionsCounter=fmsEthOutExcessiveCollisionsCounter, fdpIdentPhysPortState=fdpIdentPhysPortState, fcvRvpCallAcceptwithReverseCharging=fcvRvpCallAcceptwithReverseCharging, fmsLineOutputOctetsCounter=fmsLineOutputOctetsCounter, vcvVoiceProfReceiveLevel=vcvVoiceProfReceiveLevel, fmStatBridge=fmStatBridge, fclAsynCfgX3UserProfilePart1=fclAsynCfgX3UserProfilePart1, fmuAccessBsc2780LineNbMax=fmuAccessBsc2780LineNbMax, fcmMgtFctActivationTable=fcmMgtFctActivationTable, fcxRipInstance=fcxRipInstance, fciFlowSegmented=fciFlowSegmented, fmsIpCluClusterNumber=fmsIpCluClusterNumber, fmRip2=fmRip2, fclAsynCfgSerCos=fclAsynCfgSerCos, fclX25AccPvcCalledAddr=fclX25AccPvcCalledAddr, dcvVoiceProfNoiseFramesPeriodicity=dcvVoiceProfNoiseFramesPeriodicity, fcwSResConversionAimedPoint=fcwSResConversionAimedPoint, fmOspfStandardVirtIfTable=fmOspfStandardVirtIfTable, fciOspfAreaStatus=fciOspfAreaStatus, fciRouteNextHop=fciRouteNextHop, fcsnaGpX25PuId=fcsnaGpX25PuId, fmsFrCommStorageTable=fmsFrCommStorageTable, fmsFrLpVcSigProtocol=fmsFrLpVcSigProtocol, fclFrPvcCalledAddress=fclFrPvcCalledAddress, fciFlowSubstDestIpAddress=fciFlowSubstDestIpAddress, fcwAddrConvOutgoingCallEntry=fcwAddrConvOutgoingCallEntry, fclAsynPadLpTable=fclAsynPadLpTable, fcxCircStatus=fcxCircStatus, fmOsiISISCircLANL2DesISChanges=fmOsiISISCircLANL2DesISChanges, fclX25SlpIsdnRemLogPortId=fclX25SlpIsdnRemLogPortId, fclFrPvcTunEndPointEntry=fclFrPvcTunEndPointEntry, fcfLineV11DteInterfaceId=fcfLineV11DteInterfaceId, fclAsynX28PlusLpEscapeDigit=fclAsynX28PlusLpEscapeDigit, fclAsynX28PlusRemLpIdleTimerDelay=fclAsynX28PlusRemLpIdleTimerDelay, fclX25CfaDlnLowestOutgoingChannel=fclX25CfaDlnLowestOutgoingChannel, fmsS2BChChannelId=fmsS2BChChannelId, fclAsynCfgX3P13LfInsertion=fclAsynCfgX3P13LfInsertion, fmsEthInNoErrCounter=fmsEthInNoErrCounter, dclFrSeLogPortEntry=dclFrSeLogPortEntry, dcmAlrmTftpFamilyId=dcmAlrmTftpFamilyId, vcmAlrmFaxTable=vcmAlrmFaxTable, fclPppBIsdnLocalBriTable=fclPppBIsdnLocalBriTable, dclFrSeSigT305DisconnectResponseTimer=dclFrSeSigT305DisconnectResponseTimer, fclX25CfaConfigId=fclX25CfaConfigId, fciOspfAreaStubStatus=fciOspfAreaStubStatus, fmOsiCLNPCircuitTable=fmOsiCLNPCircuitTable, vcvVoiceProfEchoCancellation=vcvVoiceProfEchoCancellation, vcCtlConfigCom=vcCtlConfigCom, fciOspfVirtualLinksEntry=fciOspfVirtualLinksEntry, fcbBrdgVpVirtualPortId=fcbBrdgVpVirtualPortId, fciNetToMediaStatus=fciNetToMediaStatus, fciFlowType=fciFlowType, dcvVoiceTransQosCir=dcvVoiceTransQosCir, fclAsynAutoTransProfile=fclAsynAutoTransProfile, fclX25AccIsdnRemPriority=fclX25AccIsdnRemPriority, fciNetToMediaTable=fciNetToMediaTable, fcmMgfGeneratorsDelay=fcmMgfGeneratorsDelay, fclAsynAutoTransAutoTermMode=fclAsynAutoTransAutoTermMode, fmsWanConnOutPktsCounter=fmsWanConnOutPktsCounter, fmOspfStandardIfTable=fmOspfStandardIfTable, fcsnaLocalVirtualPort=fcsnaLocalVirtualPort, fclBSctConnSubscriberNumber=fclBSctConnSubscriberNumber, mmx10000=mmx10000, fcfLineV11DteSignalTable=fcfLineV11DteSignalTable, dcvRemoteNetToMediaEntry=dcvRemoteNetToMediaEntry, fcwRoutRouteId=fcwRoutRouteId, fciOspfGeneralParameters=fciOspfGeneralParameters, fmsInArpVpLocalIpAddr=fmsInArpVpLocalIpAddr, fccLneighNeighborId=fccLneighNeighborId, dcvRemoteConfWanAddress=dcvRemoteConfWanAddress, fclAsynPadLpSpeedDetection=fclAsynPadLpSpeedDetection, fcsModuleId=fcsModuleId, dcmAlrmSCTable=dcmAlrmSCTable, fcbStpVpVirtualPortId=fcbStpVpVirtualPortId, fclFrameRelayBackup=fclFrameRelayBackup, cmeClearTimeStamp=cmeClearTimeStamp, fclFraPvcMinRecallTimer=fclFraPvcMinRecallTimer, fclX25CfmFlowCtrlMaxWindowSize=fclX25CfmFlowCtrlMaxWindowSize, cfFactoryReturnDate1=cfFactoryReturnDate1, fclAsynCfgSerConversionAddressCheck=fclAsynCfgSerConversionAddressCheck, fclFrPvcTunBackupDlci=fclFrPvcTunBackupDlci, fclFrPvcQosOutCir=fclFrPvcQosOutCir, fcwRoutStatus=fcwRoutStatus, fcVirtualPorts=fcVirtualPorts, vcCtlDate=vcCtlDate, vcvEMPerm=vcvEMPerm, fciOspfExportingGroup=fciOspfExportingGroup, fclAsynVdxLpLink=fclAsynVdxLpLink, fccRemoteNeighborEntry=fccRemoteNeighborEntry, fmuAccessX25MlpLineNbMax=fmuAccessX25MlpLineNbMax, dcvSnmpManagerSendTraps=dcvSnmpManagerSendTraps, vclFrLmiParaN393MonitoredEventCount=vclFrLmiParaN393MonitoredEventCount, fclFrTeLpLogPortId=fclFrTeLpLogPortId, fclVipLogPortEntry=fclVipLogPortEntry, fclX25AccIsdnRemX25AccessConfigId=fclX25AccIsdnRemX25AccessConfigId, fclAsynCfgSerConfigId=fclAsynCfgSerConfigId, fclB3270HosLpAnswerToPolling=fclB3270HosLpAnswerToPolling, fcxServSapInFltCheckedField=fcxServSapInFltCheckedField, fmOspfStandardNbrRtrId=fmOspfStandardNbrRtrId, vcvFxxConfDtmfDigitTime=vcvFxxConfDtmfDigitTime, vcFrSwL1Dlci=vcFrSwL1Dlci, fclFrPvcSnaLinkId=fclFrPvcSnaLinkId, fcvLvpFiltering=fcvLvpFiltering, vcvToneFreq1=vcvToneFreq1, fclX25CfnDlnT1AcknowledgeTimer=fclX25CfnDlnT1AcknowledgeTimer, fclX25MlpMwMultilinkWindowSize=fclX25MlpMwMultilinkWindowSize, cpcClearVirtualCircuitEvent=cpcClearVirtualCircuitEvent, fclAsynCfgLinkStopBitCount=fclAsynCfgLinkStopBitCount, vcmAlrmGenEntry=vcmAlrmGenEntry, fmsGlobCpuA=fmsGlobCpuA, vcvSnmpGenCommunityStringReadOnly=vcvSnmpGenCommunityStringReadOnly, fclAsynCfgX3UserP15Editing=fclAsynCfgX3UserP15Editing, fclAsynCfgX3P10LineFolding=fclAsynCfgX3P10LineFolding, fcxCircRvpLocalNode=fcxCircRvpLocalNode, fclX25MlpPstnOvInterfaceId=fclX25MlpPstnOvInterfaceId, fclB3270LpNoAnswerWatchDog=fclB3270LpNoAnswerWatchDog, fclBSctLpNumberOfSYN=fclBSctLpNumberOfSYN, dcvCASConfMinSeizureAckPulseDuration=dcvCASConfMinSeizureAckPulseDuration, fcfE1PhysPortId=fcfE1PhysPortId, fcmAlrmEvtEvent3=fcmAlrmEvtEvent3, rpb2025=rpb2025, fcmMgfStatLogChannelThreshold=fcmMgfStatLogChannelThreshold, fcfLineV35DceC105=fcfLineV35DceC105, fcwRouteEntry=fcwRouteEntry, vcvToneGenLevel=vcvToneGenLevel, fcsnaLvpParamReliableVc=fcsnaLvpParamReliableVc, fmRip2PeerRcvBadRoutes=fmRip2PeerRcvBadRoutes, fcfIsdnPriCrc4=fcfIsdnPriCrc4, fclAsynMneTransProfile=fclAsynMneTransProfile, fcwSCompModule2CompressedVcCount=fcwSCompModule2CompressedVcCount, fclX25CfnNegPacketSize=fclX25CfnNegPacketSize, fclPppBIsdnLocalPriTable=fclPppBIsdnLocalPriTable, fciOspfVpType=fciOspfVpType, vcfNumericLineType=vcfNumericLineType, fclFrPvcSnaBanLink=fclFrPvcSnaBanLink, fmsIpTrafIcmpInMsgsCounter=fmsIpTrafIcmpInMsgsCounter, fmOspf=fmOspf, fcfIsdnBriFilterRepeatCount=fcfIsdnBriFilterRepeatCount, fclAsynX28PlusRemCfgX3P14LfPadding=fclAsynX28PlusRemCfgX3P14LfPadding, fclX25AccPvcCallDirection=fclX25AccPvcCallDirection, fclPppCfgDescription=fclPppCfgDescription, fclPppBIsdnRemotePeerEntry=fclPppBIsdnRemotePeerEntry, vcvVoicePhysPortId=vcvVoicePhysPortId, fciBootPClientBootTime=fciBootPClientBootTime, fclLogPortStatus=fclLogPortStatus, dcwABPvcLpAddress=dcwABPvcLpAddress, fclAsynCfgConfigEntry=fclAsynCfgConfigEntry, dclLogPortId=dclLogPortId, cpcManagement=cpcManagement, fciVirtualPortEntry=fciVirtualPortEntry, fcfLineV28DteDsr107=fcfLineV28DteDsr107, fmOspfStandardNbrLSRetransQLen=fmOspfStandardNbrLSRetransQLen, fclFraLmiAccessibilityCondition=fclFraLmiAccessibilityCondition, fmsFrLpSvcDlcUbr=fmsFrLpSvcDlcUbr, fclFrCeLpLmi=fclFrCeLpLmi, fciOspfVirtualPortsEntry=fciOspfVirtualPortsEntry, fcwSerReselectionX29=fcwSerReselectionX29, fmsBootPClient=fmsBootPClient, fciFlowProtocol=fciFlowProtocol, nodeName=nodeName, fmsFrLpLmiNetT392=fmsFrLpLmiNetT392, fclFrSeInBRemConfigId=fclFrSeInBRemConfigId, fcFrSwOutputInterfaceId=fcFrSwOutputInterfaceId, fclFrTeLpLmi=fclFrTeLpLmi)
mibBuilder.exportSymbols("PCE-MIB", fclFrPvcSnaBanT2ReceiverAckTimer=fclFrPvcSnaBanT2ReceiverAckTimer, fcfLineV28DteSignalTable=fcfLineV28DteSignalTable, vcmAlrmFaxTyp=vcmAlrmFaxTyp, dcvVoiceTransEncapsulationMode=dcvVoiceTransEncapsulationMode, fclFraLpInactivityCheckDelay=fclFraLpInactivityCheckDelay, fclX25InDTei=fclX25InDTei, fclPppSerAutoReliableVc=fclPppSerAutoReliableVc, fclFrameRelay=fclFrameRelay, fdpTestCommand=fdpTestCommand, fcsnaLvpLlpVirtualPortId=fcsnaLvpLlpVirtualPortId, fcwFrFrameAcceptMemoryThreshold=fcwFrFrameAcceptMemoryThreshold, fclAsynAutoCallUserDataAscii=fclAsynAutoCallUserDataAscii, fcfLineV35DteSignalTable=fcfLineV35DteSignalTable, vcvVoiceTransJitterCompensation=vcvVoiceTransJitterCompensation, fclVipCluLpScreenKeepTimer=fclVipCluLpScreenKeepTimer, fclX25AccPstnBackStatus=fclX25AccPstnBackStatus, fclX25InDInactivityTimer=fclX25InDInactivityTimer, fclX25CfnDlnConfigId=fclX25CfnDlnConfigId, fmsFrLpSvcDlcInitialized=fmsFrLpSvcDlcInitialized, vcmAlrmTftpTyp=vcmAlrmTftpTyp, dcmAlrmSyncTrapSend=dcmAlrmSyncTrapSend, fccRoutDestClnpAddress=fccRoutDestClnpAddress, fclAsynPstnRemX121Addr=fclAsynPstnRemX121Addr, fmsIpCluVpId=fmsIpCluVpId, fcvRvpConvMultiCallingAddrOutCall=fcvRvpConvMultiCallingAddrOutCall, fmsE1Ds1ChIfMtu=fmsE1Ds1ChIfMtu, fmuAccessFrPublicNetworkLineNbMax=fmuAccessFrPublicNetworkLineNbMax, vcvVoiceTransEncapsulationMode=vcvVoiceTransEncapsulationMode, fclX25AccPstnBackX25AccessConfigId=fclX25AccPstnBackX25AccessConfigId, fclX25CfaNegotiatedFacilityTable=fclX25CfaNegotiatedFacilityTable, fciOspfVirtualLinksTable=fciOspfVirtualLinksTable, fccRneighNeighborId=fccRneighNeighborId, fciLvpVirtualPortId=fciLvpVirtualPortId, fmsRvpConnStatus=fmsRvpConnStatus, fmOsiESISCircIndex=fmOsiESISCircIndex, fcmAlrmPpPhysPort4=fcmAlrmPpPhysPort4, fclX25InDSubscriberNumber=fclX25InDSubscriberNumber, fclAsynX28PlusRemCfgX3P16CharDelete=fclAsynX28PlusRemCfgX3P16CharDelete, fclX25CfaSerCompressScrambling=fclX25CfaSerCompressScrambling, vclFrameRelay=vclFrameRelay, vcvVoiceSuscrInsPrefix=vcvVoiceSuscrInsPrefix, fcfLineV28DceDrs111=fcfLineV28DceDrs111, fccVirtualPortTable=fccVirtualPortTable, fmsIpCluAdminStatus=fmsIpCluAdminStatus, fclVipLpScreenRetryTimer=fclVipLpScreenRetryTimer, vcvIpLocalEntry=vcvIpLocalEntry, fmsE1Ds1ChIfNumber=fmsE1Ds1ChIfNumber, fmStatStateEntry=fmStatStateEntry, fcCtlAlteredIfTable=fcCtlAlteredIfTable, fclX25AccIsdnRemotePeerEntry=fclX25AccIsdnRemotePeerEntry, fclInterUnitLinkTable=fclInterUnitLinkTable, fclX25AccPermanentVcEntry=fclX25AccPermanentVcEntry, fclFrPvcSnaN3AcknowledgedCount=fclFrPvcSnaN3AcknowledgedCount, fcsnaLvpTrParamCirMin=fcsnaLvpTrParamCirMin, fcfTokenRingInterfaceId=fcfTokenRingInterfaceId, vcvAnalogLineTable=vcvAnalogLineTable, fclFrCfcLmiN391FullStatusPollCount=fclFrCfcLmiN391FullStatusPollCount, fmsEthInErrDmaOverrunCounter=fmsEthInErrDmaOverrunCounter, cfTransputerPresence=cfTransputerPresence, fclX25InBRemX25ConfigId=fclX25InBRemX25ConfigId, fcwConvInConvertedAddr=fcwConvInConvertedAddr, dcvVoiceTransCompressionAlgorithm=dcvVoiceTransCompressionAlgorithm, fclFrBackupLPId=fclFrBackupLPId, fciVpProxyArp=fciVpProxyArp, vcfNumericLineEntry=vcfNumericLineEntry, fclAsynMneFacility=fclAsynMneFacility, vcmAlrmSwTable=vcmAlrmSwTable, vcmAlrmCmpDisplay=vcmAlrmCmpDisplay, fclAsynX28PlusRemCfgX3Part2ConfigId=fclAsynX28PlusRemCfgX3Part2ConfigId, fclAsynCfgFacConfigId=fclAsynCfgFacConfigId, fciSnmpModule1TrapSourceAddrVpId=fciSnmpModule1TrapSourceAddrVpId, fclHdlcLpCompressScrambling=fclHdlcLpCompressScrambling, fclB3270LogPortEntry=fclB3270LogPortEntry, fclPppSerialAutoCallEntry=fclPppSerialAutoCallEntry, fciOspfVlRetransmitInterval=fciOspfVlRetransmitInterval, fclAsynCfgX3UserP16CharDelete=fclAsynCfgX3UserP16CharDelete, fcvRvpCompressScrambling=fcvRvpCompressScrambling, fclX25CfnSerReliableVc=fclX25CfnSerReliableVc, fclFrPvcSnaDestinationSap=fclFrPvcSnaDestinationSap, fclAsynCfgFacDefOutPacketSize=fclAsynCfgFacDefOutPacketSize, fmsPppProtoIpxNcpStatus=fmsPppProtoIpxNcpStatus, vcwEquipOutLogPort=vcwEquipOutLogPort, fclX25MlpLogPortId=fclX25MlpLogPortId, vcvDialRxSuscriberNumber=vcvDialRxSuscriberNumber, dcfConfLineInterfaceId=dcfConfLineInterfaceId, fmsFrLpLmiNetChanInactive=fmsFrLpLmiNetChanInactive, fcmMgfConvMultiCalledAddrOutCall=fcmMgfConvMultiCalledAddrOutCall, fmsEthOperStatus=fmsEthOperStatus, dcvTSPCMPerm=dcvTSPCMPerm, frx800=frx800, fclAsynX28PlusRemLpX3Mode=fclAsynX28PlusRemLpX3Mode, fclB3270CluCallStatus=fclB3270CluCallStatus, fcwFrameRelay=fcwFrameRelay, fclVipCluElemLogPortId=fclVipCluElemLogPortId, fcwFrDlcStatusChangeTrapEnabling=fcwFrDlcStatusChangeTrapEnabling, fclX25InDIsdnBackIsdnInterfaceId=fclX25InDIsdnBackIsdnInterfaceId, fcvVpType=fcvVpType, fclAsynX28PlusConfTELENETEntry=fclAsynX28PlusConfTELENETEntry, fclX25SlpPstnBackupTable=fclX25SlpPstnBackupTable, fclX25CfaSigPdnIndicator=fclX25CfaSigPdnIndicator, vcvVoiceSwRemovedDigitNumber=vcvVoiceSwRemovedDigitNumber, fclX25CfaFacOutputMarkers=fclX25CfaFacOutputMarkers, fclB3270HosClusterStaAdd=fclB3270HosClusterStaAdd, vclFrTeLpLmi=vclFrTeLpLmi, cfSoftwareFileToDownload=cfSoftwareFileToDownload, fclBSctProtDef2ControlFrameTerminator2=fclBSctProtDef2ControlFrameTerminator2, fclBSctProtDef2ControlFrameTerminator1=fclBSctProtDef2ControlFrameTerminator1, fmOsiISISSysL1DbaseOloads=fmOsiISISSysL1DbaseOloads, fcxServSapInputFiltering=fcxServSapInputFiltering, vcvIpLocalTable=vcvIpLocalTable, fmsGlobCongRamLostBlocks=fmsGlobCongRamLostBlocks, fclAsynCfgConnectionProfileId=fclAsynCfgConnectionProfileId, fcfLineV35DceInterfaceId=fcfLineV35DceInterfaceId, fclAsynX28PlusLpSpeedDetection=fclAsynX28PlusLpSpeedDetection, fmsPppAuthSlaveFailureCounter=fmsPppAuthSlaveFailureCounter, dcfNumericLineType=dcfNumericLineType, fclPppSerLpConfigId=fclPppSerLpConfigId, dcvVoiceSwSuscriberNumber=dcvVoiceSwSuscriberNumber, fclAsynX28PlusParTelLpFullDuplex=fclAsynX28PlusParTelLpFullDuplex, dclFrLmiParameterEntry=dclFrLmiParameterEntry, fclX25CfmAddress14DigitsTruncation=fclX25CfmAddress14DigitsTruncation, mcx512=mcx512, cfFactoryReturnDate2=cfFactoryReturnDate2, fmsFrLpLmiProced=fmsFrLpLmiProced, dclFrSeSignallingTable=dclFrSeSignallingTable, fcvRvpConnGrouping=fcvRvpConnGrouping, fmsBootP=fmsBootP, dcmAlrmLMIDisplay=dcmAlrmLMIDisplay, cdpIdentPhysPortType=cdpIdentPhysPortType, lineStatusChanged=lineStatusChanged, fcCtlErrorMessage=fcCtlErrorMessage, fcsConfigDescDate=fcsConfigDescDate, fcfLineV28AsynOutDteRil140=fcfLineV28AsynOutDteRil140, fcfLineV11DceSignalEntry=fcfLineV11DceSignalEntry, fmsEthInErrOutOfResourcesCounter=fmsEthInErrOutOfResourcesCounter, fmsPppAuthMasterFailureCounter=fmsPppAuthMasterFailureCounter, fmsFrLpInDiscards=fmsFrLpInDiscards, fmOsiISISSysSeqNumSkips=fmOsiISISSysSeqNumSkips, fclAsynCfgX3UserP14LfPadding=fclAsynCfgX3UserP14LfPadding, fmuVersionRight=fmuVersionRight, fclX25CfaSerCompression=fclX25CfaSerCompression, fmsWanConnRemoteAddr=fmsWanConnRemoteAddr, fcxRoutCircNcpSpoofing=fcxRoutCircNcpSpoofing, vcvSnmpManagerStatus=vcvSnmpManagerStatus, fciRipVpMetricOut=fciRipVpMetricOut, fmuAccessSdlcLineNbMax=fmuAccessSdlcLineNbMax, fciEgpRipRoutesDistribution=fciEgpRipRoutesDistribution, fcfLineV35DceSignalTable=fcfLineV35DceSignalTable, sc512Y=sc512Y, fclFrCfsSigOuputTimeout=fclFrCfsSigOuputTimeout, dcwEquipParams=dcwEquipParams, fcxCircType=fcxCircType, dclFrSwitchEquipment=dclFrSwitchEquipment, fclFrSeInBRemRemoteAddress=fclFrSeInBRemRemoteAddress, vclFrSeSigT308ReleaseResponseTimer=vclFrSeSigT308ReleaseResponseTimer, fclX25CfaSerCompressNegotiation=fclX25CfaSerCompressNegotiation, fmStatMlpTable=fmStatMlpTable, fclAsynX28PlusRemCfgX3P02Echo=fclAsynX28PlusRemCfgX3P02Echo, fcwMaxActiveCommunications=fcwMaxActiveCommunications, fcxServSapOutFltStatus=fcxServSapOutFltStatus, fmOsiISISISAdjSNPAAddress=fmOsiISISISAdjSNPAAddress, fmuFunctionSecurCard=fmuFunctionSecurCard, fclFrMainDlci=fclFrMainDlci, fdpIdentification=fdpIdentification, dcvVoiceVirtualPort=dcvVoiceVirtualPort, fclBX780LpNoAnswerWatchDog=fclBX780LpNoAnswerWatchDog, fclX25MlpIsdnOverLogPortId=fclX25MlpIsdnOverLogPortId, fciRipOspfRoutesDistribution=fciRipOspfRoutesDistribution, fmeTroubleReportInfoEntry=fmeTroubleReportInfoEntry, fclAsynMneVdxKeyTranslationEntry=fclAsynMneVdxKeyTranslationEntry, fcfLineV11DceSignalTable=fcfLineV11DceSignalTable, fcvLvpFltFilteringTable=fcvLvpFltFilteringTable, fmeTroubleReportInfoTable=fmeTroubleReportInfoTable, fciOspfVpAuthenticationKey=fciOspfVpAuthenticationKey, fccLneighStatus=fccLneighStatus, vcvEMPermCommunicationMode=vcvEMPermCommunicationMode, dcvDialRxNumberLength=dcvDialRxNumberLength, fcCtlAlteredIfEntry=fcCtlAlteredIfEntry, fcxCircuitRemoteVpEntry=fcxCircuitRemoteVpEntry, fclX25MlpOverflowEntry=fclX25MlpOverflowEntry, fciOspfVlRouterDeadInterval=fciOspfVlRouterDeadInterval, fclPppSerialAutoCallTable=fclPppSerialAutoCallTable, fclX25CfaNegMinOutPacketSize=fclX25CfaNegMinOutPacketSize, fmOspfStandardImportASExtern=fmOspfStandardImportASExtern, fclFrSeLpInterfaceId=fclFrSeLpInterfaceId, fmsGlobCompressBillGain=fmsGlobCompressBillGain, fmsFrLpInterfaceType=fmsFrLpInterfaceType, fclAsynX28PlusRemLpFullDuplex=fclAsynX28PlusRemLpFullDuplex, fclFrCfcConfigId=fclFrCfcConfigId, fclBX780LpCallDirection=fclBX780LpCallDirection, fcwZoStatus=fcwZoStatus, fclAsynCfgX3Part2Table=fclAsynCfgX3Part2Table, vcvEMSwLpId=vcvEMSwLpId, fclX25CfaDlnLowestIncomingChannel=fclX25CfaDlnLowestIncomingChannel, fciRipStaticRoutesDistributionMetric=fciRipStaticRoutesDistributionMetric, dcwEquipRemoteConfPortAddr=dcwEquipRemoteConfPortAddr, fclX25AccPrivX25FieldsSave=fclX25AccPrivX25FieldsSave, dclFrSeSigT200RetransTimer=dclFrSeSigT200RetransTimer, fciTelnetUserEntry=fciTelnetUserEntry, fmsSigState=fmsSigState, fcfLineSpeed=fcfLineSpeed, fmOspfStandardIfIpAddress=fmOspfStandardIfIpAddress, fdpTestOutputPacketsCount=fdpTestOutputPacketsCount, vcvEMConfDelayBeforeDialing=vcvEMConfDelayBeforeDialing, fclX25AccPermanentVcTable=fclX25AccPermanentVcTable, fcwConvMultiInConvertedAddr=fcwConvMultiInConvertedAddr, fclAsynX28PlusRemCfgX3P19EditingSignal=fclAsynX28PlusRemCfgX3P19EditingSignal, fcvVpVirtualPortId=fcvVpVirtualPortId, vclHdlcAccessLogPort=vclHdlcAccessLogPort, dcvIfPCMChannelPhysIf=dcvIfPCMChannelPhysIf, fclAsynCfgX3UserP09CrPadding=fclAsynCfgX3UserP09CrPadding, fclX25CfaDlnNetworkType=fclX25CfaDlnNetworkType, fciBootPClientServer=fciBootPClientServer, fcfLineV28AsynInDceEnablingSig2=fcfLineV28AsynInDceEnablingSig2, fcxCircuitLocalVpEntry=fcxCircuitLocalVpEntry, vcfPhysicalPortEntry=vcfPhysicalPortEntry, fcxServSapOutFltServiceNameType=fcxServSapOutFltServiceNameType, vclFrSeLpInterfaceId=vclFrSeLpInterfaceId, fciOspfVlHelloInterval=fciOspfVlHelloInterval, fmuFunctionLlcOnEthernet=fmuFunctionLlcOnEthernet, fciRipNeighborInput=fciRipNeighborInput, fclFrCfsSigN200RetransMaxCount=fclFrCfsSigN200RetransMaxCount, fmsFrcFilterPhysIfId=fmsFrcFilterPhysIfId, vcvFxxConfDialingTimeOut=vcvFxxConfDialingTimeOut, fclX25CfnSerCallReturnTransmission=fclX25CfnSerCallReturnTransmission, fciTelnetPwdP2=fciTelnetPwdP2, fmuFunctionMemTypeForMCXType4=fmuFunctionMemTypeForMCXType4, fmsFrCommIdentification=fmsFrCommIdentification, fcsnaGpRoutCir=fcsnaGpRoutCir, fmsSig108=fmsSig108, fcfLineV28AsynOutDceSi117=fcfLineV28AsynOutDceSi117, fclX25MlpIsdnOverflowEntry=fclX25MlpIsdnOverflowEntry, fclIulConversionAddressCheck=fclIulConversionAddressCheck, fclLogicalPortEntry=fclLogicalPortEntry, fclB3270LpLogPortId=fclB3270LpLogPortId, fcsnaLvpTrParamCos=fcsnaLvpTrParamCos, fmOspfStandardIfMetricEntry=fmOspfStandardIfMetricEntry, mcx212=mcx212, fclPppSerLpCir=fclPppSerLpCir, fclPppBIsdnPriStatus=fclPppBIsdnPriStatus, fmeTrblInfoData=fmeTrblInfoData, cmeClearX121Address=cmeClearX121Address, fclBSctProtDef2LogPortId=fclBSctProtDef2LogPortId, fclFrTeIsdnRemLogPortId=fclFrTeIsdnRemLogPortId, dcvSnmpGenCommunityStringReadWrite=dcvSnmpGenCommunityStringReadWrite, fcfLineV28AsynOutDceSignalTable=fcfLineV28AsynOutDceSignalTable, fclFraLmiT392PollingVerifTimer=fclFraLmiT392PollingVerifTimer, fmPingCountRequest=fmPingCountRequest, sc103_3W=sc103_3W, fmhE1S2ModDescSoftwareVersion=fmhE1S2ModDescSoftwareVersion, fclSdlcSecClusterStatus=fclSdlcSecClusterStatus, fcfTokenRingEntry=fcfTokenRingEntry, fclVipHosStatElementId=fclVipHosStatElementId, fcsnaLvpTrParameters=fcsnaLvpTrParameters)
mibBuilder.exportSymbols("PCE-MIB", fmsE1Ds1ChIfInDiscards=fmsE1Ds1ChIfInDiscards, dcvVoiceProfileEntry=dcvVoiceProfileEntry, vclFrLmiParameterTable=vclFrLmiParameterTable, fclFrSeIsdnBackIsdnInterfaceId=fclFrSeIsdnBackIsdnInterfaceId, cfConfigurationFileToDownload=cfConfigurationFileToDownload, fcsnaLvpParamCirMin=fcsnaLvpParamCirMin, fclX25CfnSignallingTable=fclX25CfnSignallingTable, vclFrTeLpInterfaceId=vclFrTeLpInterfaceId, fmsSig109=fmsSig109, spb1033=spb1033, fcwSRvcFastSelectUse=fcwSRvcFastSelectUse, fmsFrcStorageDlci=fmsFrcStorageDlci, fmOsiISISESAdjAdjIndex=fmOsiISISESAdjAdjIndex, fclFrCfsSigT308ReleaseResponseTimer=fclFrCfsSigT308ReleaseResponseTimer, fmuFunctionLz78Compression=fmuFunctionLz78Compression, fmeFamFamilyId=fmeFamFamilyId, fclSdlcSecClusterCir=fclSdlcSecClusterCir, fciSnmp=fciSnmp, fcsModuleBridgeInit=fcsModuleBridgeInit, fcfLineEntry=fcfLineEntry, fclVipLpEmulationType=fclVipLpEmulationType, fclFrTeIsdnBackupTable=fclFrTeIsdnBackupTable, fcsnaLvpTrParamMinRecallTimer=fcsnaLvpTrParamMinRecallTimer, dcvIfPCMPhysTypeId=dcvIfPCMPhysTypeId, vcmAlrmVCTyp=vcmAlrmVCTyp, fclFraLmiLogPortId=fclFraLmiLogPortId, fclX25CfaDlnT2AcknwledgeDelayTimer=fclX25CfaDlnT2AcknwledgeDelayTimer, fmOspfStandardStubAreaEntry=fmOspfStandardStubAreaEntry, fclX25CfnSigConversionAimedPoint=fclX25CfnSigConversionAimedPoint, fclAsynCfgLinkBitCount=fclAsynCfgLinkBitCount, fclFrPvcSnaBanN3AcknowledgedCount=fclFrPvcSnaBanN3AcknowledgedCount, vcvEMPermRemoteNumber=vcvEMPermRemoteNumber, fcCtlHRCheckMessage=fcCtlHRCheckMessage, fclSdlcLpReliableVc=fclSdlcLpReliableVc, fclVipHosLpLogPortId=fclVipHosLpLogPortId, fclFrTeParGenDlcSetupAlarmThreshold=fclFrTeParGenDlcSetupAlarmThreshold, dcvSnmpManagerIpAddress=dcvSnmpManagerIpAddress, fmOspfStandardHostTable=fmOspfStandardHostTable, fclX25AccIsdnRemIsdnInterfaceId=fclX25AccIsdnRemIsdnInterfaceId, fclX25CfaSignallingTable=fclX25CfaSignallingTable, fcwSQOSX25QOSProfileId=fcwSQOSX25QOSProfileId, fclAsynMultiLpAuthStep2=fclAsynMultiLpAuthStep2, cpcFileTransfer=cpcFileTransfer, vcmAlrmVCEntry=vcmAlrmVCEntry, fmsBootPRelayRecReplies=fmsBootPRelayRecReplies, fmsEthInErrOverFlowCounter=fmsEthInErrOverFlowCounter, vcvEMSwEntry=vcvEMSwEntry, vcvTftpTable=vcvTftpTable, fmsFrDlcInFrames=fmsFrDlcInFrames, fclAsynCfgSerCompressScrambling=fclAsynCfgSerCompressScrambling, fclX25ConfigAccess=fclX25ConfigAccess, fcwSCUDProfilesCUD=fcwSCUDProfilesCUD, fmOsi=fmOsi, fclBX780LogPortTable=fclBX780LogPortTable, fmOspfStandardIfMetricAddressLessIf=fmOspfStandardIfMetricAddressLessIf, fcxServSapOutFltFilterId=fcxServSapOutFltFilterId, fclAsynX28PlusLpX3Mode=fclAsynX28PlusLpX3Mode, dcmAlrmSwEntry=dcmAlrmSwEntry, fclX25CfaDlnLowestTwoWayChannel=fclX25CfaDlnLowestTwoWayChannel, vpx20=vpx20, fclBscSctLogPort=fclBscSctLogPort, fcfInterfaceType=fcfInterfaceType, fmOspfStandardRxNewLSAs=fmOspfStandardRxNewLSAs, fcwSerClearAnalysisTable=fcwSerClearAnalysisTable, vclFrSeSigT316RestartAcknowledgeTimer=vclFrSeSigT316RestartAcknowledgeTimer, fclX25AccPrivX25FieldsChanges=fclX25AccPrivX25FieldsChanges, fclFraLpCompressNegotiation=fclFraLpCompressNegotiation, fclFrPvcQosInBe=fclFrPvcQosInBe, fmuAccessVipLineNbMax=fmuAccessVipLineNbMax, fcxRipInFltNetAddress=fcxRipInFltNetAddress, fclFrCfsGenUnuseTimer=fclFrCfsGenUnuseTimer, fclPppSerLpMinCir=fclPppSerLpMinCir, fclPppBIsdnRemCallRetryCount=fclPppBIsdnRemCallRetryCount, fclFrCeLpLogPortId=fclFrCeLpLogPortId, fmOspfStandardAddressLessIf=fmOspfStandardAddressLessIf, fciOspfVpTransitDelay=fciOspfVpTransitDelay, fcsnaLvpParameters=fcsnaLvpParameters, dcmAlrmSCFamilyId=dcmAlrmSCFamilyId, fclHdlcLpMinCir=fclHdlcLpMinCir, vcmAlrmSCDisplay=vcmAlrmSCDisplay, fcsModuleTable=fcsModuleTable, fclFrCfcSignallingParameterEntry=fclFrCfcSignallingParameterEntry, fmsFrDlcOutExcessFrames=fmsFrDlcOutExcessFrames, fmsS2BChIfOutOctets=fmsS2BChIfOutOctets, fcfE1Ds1ChannelStatus=fcfE1Ds1ChannelStatus, cfEdition=cfEdition, fclX25InBRemPeerId=fclX25InBRemPeerId, fclAsynX28PlusRemCfgX3P04IdleTimerDelay=fclAsynX28PlusRemCfgX3P04IdleTimerDelay, dcvCASConfCallSignalling=dcvCASConfCallSignalling, fclPppPstnLpInterfaceId=fclPppPstnLpInterfaceId, fcvLvpFltFilterId=fcvLvpFltFilterId, fmsFrLpOutgoingEntry=fmsFrLpOutgoingEntry, vcCtlErrorCode=vcCtlErrorCode, fclAsynCfgX3P07BreakHandling=fclAsynCfgX3P07BreakHandling, vcwABPvcLpAddress=vcwABPvcLpAddress, fcxServSapInFltFiltering=fcxServSapInFltFiltering, fciTelnetTimer=fciTelnetTimer, fmsFrLpOutgoingTable=fmsFrLpOutgoingTable, fcwLoadAndTrafficSummingPeriod=fcwLoadAndTrafficSummingPeriod, fmsFrLpLmiUserN392=fmsFrLpLmiUserN392, fmOspfStandardExternLSACount=fmOspfStandardExternLSACount, fmsS0BChIfInOctets=fmsS0BChIfInOctets, fclX25CfnSigConvMultiCallingAddrOutCall=fclX25CfnSigConvMultiCallingAddrOutCall, fciEgpNeighborStatus=fciEgpNeighborStatus, fcsnaLvpParamMinRecallTimer=fcsnaLvpParamMinRecallTimer, fclFrCeLogPortTable=fclFrCeLogPortTable, fmOspfStandardVirtIfStatus=fmOspfStandardVirtIfStatus, fclAsynAutoCallTable=fclAsynAutoCallTable, fcsnaLvpTrParamBroadcastType=fcsnaLvpTrParamBroadcastType, dcvIfPCMPhysPhysicalPort=dcvIfPCMPhysPhysicalPort, dcvVoiceProfId=dcvVoiceProfId, fclFrPvcTunOutCir=fclFrPvcTunOutCir, fclX25CfaFacInputUnknownFacility=fclX25CfaFacInputUnknownFacility, fcxRipInputFilteringEntry=fcxRipInputFilteringEntry, fcxRipCircPacketSize=fcxRipCircPacketSize, fcbBrdgMapRemoteAddress=fcbBrdgMapRemoteAddress, fmsPppPhysLineId=fmsPppPhysLineId, fciEgpTargetAsNumber=fciEgpTargetAsNumber, fcwSbRouteId=fcwSbRouteId, dcvIpVirtualPort=dcvIpVirtualPort, dcvTftpStatus=dcvTftpStatus, fmsFrcStorageTypeOfDlci=fmsFrcStorageTypeOfDlci, fclAsynX28PlusRemCfgX3P13LfInsertion=fclAsynX28PlusRemCfgX3P13LfInsertion, fmsWanConnInErrPktsCounter=fmsWanConnInErrPktsCounter, fmsS2BChPhysIfId=fmsS2BChPhysIfId, fclX25MlpLink1InterfaceId=fclX25MlpLink1InterfaceId, fclFrCfcProfileId=fclFrCfcProfileId, fclAsynVdxLpEntry=fclAsynVdxLpEntry, fmsFrLpInFrHeaderErrors=fmsFrLpInFrHeaderErrors, dcmAlrmGenTable=dcmAlrmGenTable, fmOsiCLNPCircIndex=fmOsiCLNPCircIndex, fcsConfigDescName=fcsConfigDescName, dcvVoiceSwStatus=dcvVoiceSwStatus, fcfLineV28DteTi142=fcfLineV28DteTi142, fmsE1Ds1ChIfOutErrors=fmsE1Ds1ChIfOutErrors, dcvTSPCMPermEntry=dcvTSPCMPermEntry, fclAsynPstnRemStatus=fclAsynPstnRemStatus, fcfLineV28AsynOutDceDsr107=fcfLineV28AsynOutDceDsr107, fciOspfAseExportStaticsTag=fciOspfAseExportStaticsTag, hpb1025_8W=hpb1025_8W, fcwFrEndPointMaxCount=fcwFrEndPointMaxCount, vcmAlrmLMITrapSend=vcmAlrmLMITrapSend, fclPppSerLpBe=fclPppSerLpBe, fclAsynCfgX3UserP12InputFlowCtrl=fclAsynCfgX3UserP12InputFlowCtrl, dcvSnmpGen=dcvSnmpGen, fclVipCluLogPortTable=fclVipCluLogPortTable, fclAsynMnemonic=fclAsynMnemonic, fclFrSeIsdnRemStatus=fclFrSeIsdnRemStatus, fclAsynMneFacThroughputClass=fclAsynMneFacThroughputClass, fmsLineReinitsCounter=fmsLineReinitsCounter, cmeClearCause=cmeClearCause, fclB3270HosClusterTable=fclB3270HosClusterTable, fmsBrdgTrafInPktsCounter=fmsBrdgTrafInPktsCounter, vcvVoiceSuscrNumber=vcvVoiceSuscrNumber, fcfLineV28AsynOutDteSignalTable=fcfLineV28AsynOutDteSignalTable, fclSdlcLpCir=fclSdlcLpCir, fclVipHosStationTable=fclVipHosStationTable, dclFrLmiParaConfigId=dclFrLmiParaConfigId, fmOsiISISISAdjacencyAreaAddressTable=fmOsiISISISAdjacencyAreaAddressTable, vcfNumericLines=vcfNumericLines, fclBSctProtDef1PermanentDelimiter1=fclBSctProtDef1PermanentDelimiter1, dcvCASConfLineInterfacePolarity=dcvCASConfLineInterfacePolarity, fclB3270CluClusterCluAdd=fclB3270CluClusterCluAdd, fclX25InDPdnLinkAddress=fclX25InDPdnLinkAddress, fclX25CfaDlnIncomingChannelCount=fclX25CfaDlnIncomingChannelCount, fmsFrDlcCos=fmsFrDlcCos, fcwSDynRouteCalculationTimer=fcwSDynRouteCalculationTimer, vcvEMPermTable=vcvEMPermTable, fclAsynCfgLinkServSignalParity=fclAsynCfgLinkServSignalParity, fcmMgtFctCugFunctionId=fcmMgtFctCugFunctionId, fclAsynX28PlusParTelLpIdleTimerDelay=fclAsynX28PlusParTelLpIdleTimerDelay, fmsFrLpLmiNetProtErrors=fmsFrLpLmiNetProtErrors, fclX25SlpDARApplicable=fclX25SlpDARApplicable, vclHdlcLogPortTable=vclHdlcLogPortTable, fclX25CfaNegMaxInThroughputClass=fclX25CfaNegMaxInThroughputClass, fclAsynCfgFacClosedUserGroup=fclAsynCfgFacClosedUserGroup, fmsEthInAlignmentErrorsCounter=fmsEthInAlignmentErrorsCounter, fmOsiISISSysCorrLSP=fmOsiISISSysCorrLSP, vcmAlrmSCFamilyId=vcmAlrmSCFamilyId, vcmAlrmSCTyp=vcmAlrmSCTyp, fcwFrAllFramesDiscardThreshold=fcwFrAllFramesDiscardThreshold, fclPppCfaRemotePeerTable=fclPppCfaRemotePeerTable, fclFrTeParGenDynamicEir=fclFrTeParGenDynamicEir, fmuAccessPppsLineNbMax=fmuAccessPppsLineNbMax, dcCtlErrorTime=dcCtlErrorTime, fclX25ConfigInterNodeEntry=fclX25ConfigInterNodeEntry, fcfLineV28DceSignalEntry=fcfLineV28DceSignalEntry, fclAsynMneTransCFKeyHandling=fclAsynMneTransCFKeyHandling, dcvIfPCM=dcvIfPCM, fcCtlErrorTime=fcCtlErrorTime, fclPppBIsdnPriId=fclPppBIsdnPriId, fmsInArpVirtualPortEntry=fmsInArpVirtualPortEntry, fclX25CfaFacilityTable=fclX25CfaFacilityTable, vcmAlrmSCTrapSend=vcmAlrmSCTrapSend, fmsBootPRelayRecRequests=fmsBootPRelayRecRequests, dcvSnmpGenCommunityStringTrap=dcvSnmpGenCommunityStringTrap, fmOsiISISRAPathIdentifier=fmOsiISISRAPathIdentifier, fciLclClusterNumber=fciLclClusterNumber, fmOsiESISCircuitTable=fmOsiESISCircuitTable, fclAsynCfgX3P17LineDelete=fclAsynCfgX3P17LineDelete, npx90=npx90, fclAsynCfgX3P21Parity=fclAsynCfgX3P21Parity, vcvFxxConfDialingFormat=vcvFxxConfDialingFormat, fclFrTerminalEquipment=fclFrTerminalEquipment, fclFrSeInBRemotePeerEntry=fclFrSeInBRemotePeerEntry, fmuFunctionClnpRouter=fmuFunctionClnpRouter, portStatus=portStatus, fciRemStatus=fciRemStatus, fcmAlrmPpPhysPortSelection=fcmAlrmPpPhysPortSelection, fclBX780LpProtocolType=fclBX780LpProtocolType, fclHdlcLpCir=fclHdlcLpCir, fcmManagementFunctions=fcmManagementFunctions, fciFlowAddrSubstituteEntry=fciFlowAddrSubstituteEntry, fclBSctConnCalledAddr=fclBSctConnCalledAddr, fcsnaLvpTrParamCir=fcsnaLvpTrParamCir, fclPppPstnLpConfigId=fclPppPstnLpConfigId, projects=projects, nodeStatus=nodeStatus, fclSdlcLpCompressMultiPacketsTimer=fclSdlcLpCompressMultiPacketsTimer, fcxRipOutFltFiltering=fcxRipOutFltFiltering, dclFrLmiParaT391LinkIntegPollTimer=dclFrLmiParaT391LinkIntegPollTimer, fcwSQOSX25CUDProfileId=fcwSQOSX25CUDProfileId, fclB3270CluLpMaxNumberOfUnwPolls=fclB3270CluLpMaxNumberOfUnwPolls, fmsRvpConnInErrPktsCounter=fmsRvpConnInErrPktsCounter, fclBSctLpInterfaceId=fclBSctLpInterfaceId, fcwSClearAnalysCause=fcwSClearAnalysCause, fcwSQOSX25CalledAddress=fcwSQOSX25CalledAddress, fclFrCfsSigT316RestartAcknowledgeTimer=fclFrCfsSigT316RestartAcknowledgeTimer, dvb1008=dvb1008, fclSdlcSecClusterEntry=fclSdlcSecClusterEntry, fmOspfStandardIfMetricStatus=fmOspfStandardIfMetricStatus, fclFrTeParGenTable=fclFrTeParGenTable, fclX25InDIsdnRemotePeerTable=fclX25InDIsdnRemotePeerTable, fmOspfStandardVersionNumber=fmOspfStandardVersionNumber, fcbBrdgRemoteAddressMappingTable=fcbBrdgRemoteAddressMappingTable, fmhEqIdSerialNbEncodingType=fmhEqIdSerialNbEncodingType, fdpModRespElement=fdpModRespElement, fmOsiISISCircIDFieldLenMismatches=fmOsiISISCircIDFieldLenMismatches, fclX25SlpPstnBackupEntry=fclX25SlpPstnBackupEntry, fmsFrLpSvcLogPortId=fmsFrLpSvcLogPortId, fmsEthManInputResetCounter=fmsEthManInputResetCounter, fclAsynCfgX3P02Echo=fclAsynCfgX3P02Echo, dcvVoiceTransQosBc=dcvVoiceTransQosBc, fmStatFrLineTable=fmStatFrLineTable, fcvRvpConnModule1VpId=fcvRvpConnModule1VpId, dcvIpLocSubNetMask=dcvIpLocSubNetMask, fclSdlcPriLpPollingGroupResponse=fclSdlcPriLpPollingGroupResponse, fcvVirtualPortEntry=fcvVirtualPortEntry, fcxRipOutFltCircuitId=fcxRipOutFltCircuitId, fclAsynX28PlusRemoteCfgDescription=fclAsynX28PlusRemoteCfgDescription, fmOsiISISESAdjNeighSNPAAdress=fmOsiISISESAdjNeighSNPAAdress, fciOspfNeighborIpAddress=fciOspfNeighborIpAddress, fciRipEgpRoutesAsNumber=fciRipEgpRoutesAsNumber, vcvVoiceLogPort=vcvVoiceLogPort)
mibBuilder.exportSymbols("PCE-MIB", fclX25MlpOvOverflowThreshold=fclX25MlpOvOverflowThreshold, fcxServCircSapState=fcxServCircSapState, fclAsynMultiStandardPadLogPort=fclAsynMultiStandardPadLogPort, fclSdlcPriClusterEntry=fclSdlcPriClusterEntry, fciFlowRouteNextHop=fciFlowRouteNextHop, fclFrSeInBRemPeerId=fclFrSeInBRemPeerId, fmOspfStandardSpfRuns=fmOspfStandardSpfRuns, dcvTSPCMSwConfigId=dcvTSPCMSwConfigId, fmsS0BChIfCalledAddress=fmsS0BChIfCalledAddress, fmOspfStandardVirtNbrEvents=fmOspfStandardVirtNbrEvents, fcvLvpFltFilteringType=fcvLvpFltFilteringType, fmsFrSwBookingInputThrouhput=fmsFrSwBookingInputThrouhput, fmhTechnicEepromSize=fmhTechnicEepromSize, fclX25SlpIsdnRemotePeerTable=fclX25SlpIsdnRemotePeerTable, dcvVoiceSwInsPrefix=dcvVoiceSwInsPrefix, vcfDataLineRate=vcfDataLineRate, fclX25CfnNegDefOutWindowSize=fclX25CfnNegDefOutWindowSize, fmOsiISISRASNPAAddress=fmOsiISISRASNPAAddress, dcvSnmpManagerTable=dcvSnmpManagerTable, fclBSctProtDef1PermanentDelimiter5=fclBSctProtDef1PermanentDelimiter5, fclFrCfsSignallingTable=fclFrCfsSignallingTable, fclFrSeLpConfigId=fclFrSeLpConfigId, fcsnaGpRoutClusterPuId=fcsnaGpRoutClusterPuId, sc310_12W=sc310_12W, fclX25SlpIsdnBackStatus=fclX25SlpIsdnBackStatus, fclBSctProtDef1StartFrameDelimiter2=fclBSctProtDef1StartFrameDelimiter2, fclFrSnaBan=fclFrSnaBan, fclPppSerAutoRemoteAddress=fclPppSerAutoRemoteAddress, fclFrCfcSigSignalOutputWinSize=fclFrCfcSigSignalOutputWinSize, fclX25CfaNegMinInPacketSize=fclX25CfaNegMinInPacketSize, fclX25CfaNegWindowSize=fclX25CfaNegWindowSize, dcvVoiceSuscriberEntry=dcvVoiceSuscriberEntry, dcvToneDuration2=dcvToneDuration2, fclX25CfnStatus=fclX25CfnStatus, dvbConfig=dvbConfig, fclFrCfcGenMinimumRecallTimer=fclFrCfcGenMinimumRecallTimer, fclFrPvcSnaDlci=fclFrPvcSnaDlci, fcfLineV28AsynOutDteLl141=fcfLineV28AsynOutDteLl141, fclX25PstnLogPortId=fclX25PstnLogPortId, fcvRvpCos=fcvRvpCos, fmsFrCircuitInOctetsCounter=fmsFrCircuitInOctetsCounter, fclAsynCfgX3UserProfileDesc=fclAsynCfgX3UserProfileDesc, fclBsc3270LogPort=fclBsc3270LogPort, fclBX780LpLogPortId=fclBX780LpLogPortId, vcmAlrmCmpTyp=vcmAlrmCmpTyp, fclSdlcLpCompressScrambling=fclSdlcLpCompressScrambling, fclX25CfaNegConfigId=fclX25CfaNegConfigId, dcSysConfActive=dcSysConfActive, fmRip2IfStatRcvBadPackets=fmRip2IfStatRcvBadPackets, fcwDataPacketsAcceptThreshold=fcwDataPacketsAcceptThreshold, vcwEquipParams=vcwEquipParams, fclX25MlpOvLogPortId=fclX25MlpOvLogPortId, fcwFrFrameAcceptCpuThreshold=fcwFrFrameAcceptCpuThreshold, fclX25CfaFacClosedUserGroup=fclX25CfaFacClosedUserGroup, dcCtlConfigCom=dcCtlConfigCom, fmsEthOutSingleCollisionFramesCounter=fmsEthOutSingleCollisionFramesCounter, fciNetToMediaMacAddress=fciNetToMediaMacAddress, dcvTSPCMPermLpId=dcvTSPCMPermLpId, fmsIpLanIpAddr=fmsIpLanIpAddr, fclFrCfcGenUnuseTimer=fclFrCfcGenUnuseTimer, fciTelnetPwdP0=fciTelnetPwdP0, dcvVirtualPortTable=dcvVirtualPortTable, fmhTechnicPromFlashSize=fmhTechnicPromFlashSize, fclX25InBRemConnectionType=fclX25InBRemConnectionType, vcfDataLineDcd109=vcfDataLineDcd109, fclAsynPadLogPort=fclAsynPadLogPort, vcvEMConfDigitReceptionTimeOut=vcvEMConfDigitReceptionTimeOut, fclAsynCfgX3P22PageWait=fclAsynCfgX3P22PageWait, fcsnaGpLanFrPuId=fcsnaGpLanFrPuId, fcwSResLogChannelCount=fcwSResLogChannelCount, fcwSDynPassword=fcwSDynPassword, fclVipCluLpLogPortId=fclVipCluLpLogPortId, fcfLineV28DteSignalEntry=fcfLineV28DteSignalEntry, dcmAlrmVCTable=dcmAlrmVCTable, fclAsynPadLpCombinedFlowCtrl=fclAsynPadLpCombinedFlowCtrl, fcfE1PhysPortEntry=fcfE1PhysPortEntry, fclX25AccPvcStatus=fclX25AccPvcStatus, vcfPhysPortConnector=vcfPhysPortConnector, fclFrCfsSigT303SetupResponseTimer=fclFrCfsSigT303SetupResponseTimer, fmsCtrlResetTime=fmsCtrlResetTime, fcfTokenRingTable=fcfTokenRingTable, fmStatPppAuthenticationEntry=fmStatPppAuthenticationEntry, fcwAddrConvMultiCriterionOutCallEntry=fcwAddrConvMultiCriterionOutCallEntry, fclAsynX28PlusConfTELENETTable=fclAsynX28PlusConfTELENETTable, fclAsynCfgFacDefOutThroughputClass=fclAsynCfgFacDefOutThroughputClass, vcwABPvcLpEntry=vcwABPvcLpEntry, fmsBootPRelayEntry=fmsBootPRelayEntry, fmOspfStandardIfDesignatedRouter=fmOspfStandardIfDesignatedRouter, fmsE1Ds1ChIfInErrors=fmsE1Ds1ChIfInErrors, fcsnaLvpTrParamCompressScrambling=fcsnaLvpTrParamCompressScrambling, fclX25AccSwSwitchBackThreshold=fclX25AccSwSwitchBackThreshold, fmPingMinRoundTrip=fmPingMinRoundTrip, fclSdlcSecLpN2RetryCount=fclSdlcSecLpN2RetryCount, fmsFrDlcInExcessFrames=fmsFrDlcInExcessFrames, fmhEqIdReference=fmhEqIdReference, fmsPppIpAddrLineId=fmsPppIpAddrLineId, fcmMgfClosedUserGroup=fcmMgfClosedUserGroup, fcfLineV28AsynOutDteDrs111=fcfLineV28AsynOutDteDrs111, fclB3270HosClusterStatus=fclB3270HosClusterStatus, fcsnaGpSdlcEntry=fcsnaGpSdlcEntry, fclFrCfcSignallingParameterTable=fclFrCfcSignallingParameterTable, fcfLineModXidStringTable=fcfLineModXidStringTable, vcxConfig=vcxConfig, dcvIpLocMinimumRecallTimer=dcvIpLocMinimumRecallTimer, vcmAlrmTftpFamilyId=vcmAlrmTftpFamilyId, fcfLineV28AsynInDceSignalEntry=fcfLineV28AsynInDceSignalEntry, fcxRipCircuitTable=fcxRipCircuitTable, fccClnpRouteTable=fccClnpRouteTable, dcvVoiceSuscrInsSuffix=dcvVoiceSuscrInsSuffix, fcfE1PhysPortFlowType=fcfE1PhysPortFlowType, fclFraLmiT391LinkIntegPollTimer=fclFraLmiT391LinkIntegPollTimer, fclX25InBRemotePeerTable=fclX25InBRemotePeerTable, fdpTest=fdpTest, fclAsynCfgX3Part1ConfigId=fclAsynCfgX3Part1ConfigId, vcmAlrmGenTrapSend=vcmAlrmGenTrapSend, dcvIfPCMPhysTable=dcvIfPCMPhysTable, vcvFxxConfDialingMode=vcvFxxConfDialingMode, fcxRipCircuitEntry=fcxRipCircuitEntry, fcwAddrConvIncomingCallTable=fcwAddrConvIncomingCallTable, fclX25MlpPstnOvStatus=fclX25MlpPstnOvStatus, fclBSctProtDef1StartFrameDelimiter3=fclBSctProtDef1StartFrameDelimiter3, cfConfigurationRelease=cfConfigurationRelease, fciVpMtu=fciVpMtu, fcCtlHRCheckMessagesTable=fcCtlHRCheckMessagesTable, fcfLineV28AsynInDceSigMonitored1=fcfLineV28AsynInDceSigMonitored1, fclFrTeParGenBookingVbrRtThreshold=fclFrTeParGenBookingVbrRtThreshold, fmsEthJabber=fmsEthJabber, fcsnaLvpTrParamN2=fcsnaLvpTrParamN2, vcmAlrmSvcFamilyId=vcmAlrmSvcFamilyId, fclX25CfaNegDefOutWindowSize=fclX25CfaNegDefOutWindowSize, fclBSctLpOnePadSuppressed=fclBSctLpOnePadSuppressed, fclFrSeLogPortEntry=fclFrSeLogPortEntry, vcmAlrmSvcEntry=vcmAlrmSvcEntry, fmStatPppIpAddrAssignmentEntry=fmStatPppIpAddrAssignmentEntry, fmsE1Ds1ChIfSpeed=fmsE1Ds1ChIfSpeed, vcvFxxRingMaxRingingTime=vcvFxxRingMaxRingingTime, fcvRvpConnMinimumRecallTimer=fcvRvpConnMinimumRecallTimer, cfField1=cfField1, fclAsynCfgFacDefInPacketSize=fclAsynCfgFacDefInPacketSize, fmsIpTrafInHdrErrorsCounter=fmsIpTrafInHdrErrorsCounter, fclFrPvcSnaEncapsulationEntry=fclFrPvcSnaEncapsulationEntry, fclAsynCfgX3Part1ProfileId=fclAsynCfgX3Part1ProfileId, fclHdlcLogPortTable=fclHdlcLogPortTable, fmsSig142=fmsSig142, fmOspfStandardHostMetric=fmOspfStandardHostMetric, dcvDialRxEndOfDialingTimer=dcvDialRxEndOfDialingTimer, dcvVoiceProfTransmitLevel=dcvVoiceProfTransmitLevel, fclAsynX28PlusRemCfgX3P05OutputFlowCtrl=fclAsynX28PlusRemCfgX3P05OutputFlowCtrl, fclSdlcSecLpRemPuIdentification=fclSdlcSecLpRemPuIdentification, fclFrCfcSigT203InactivityTimer=fclFrCfcSigT203InactivityTimer, fclPppBIsdnPriLocalSubs=fclPppBIsdnPriLocalSubs, fcfLineTable=fcfLineTable, fciBootPInterfaceIpAddress=fciBootPInterfaceIpAddress, fcbBrdgVpBroadcasting=fcbBrdgVpBroadcasting, vcvFxxLpTable=vcvFxxLpTable, fclX25MlpTable=fclX25MlpTable, fciFlowPortMin=fciFlowPortMin, fmPingTimeout=fmPingTimeout, fclX25CfnSerConfigId=fclX25CfnSerConfigId, fcmAlarms=fcmAlarms, dcvVoiceProfCESModeAverageDelay=dcvVoiceProfCESModeAverageDelay, fclEthInterfaceId=fclEthInterfaceId, vclFrSeLpConfigId=vclFrSeLpConfigId, fmuAccessHdlcTranspLineNbMax=fmuAccessHdlcTranspLineNbMax, dcvCASConfMinLineSeizureAckTime=dcvCASConfMinLineSeizureAckTime, fclFrCfcEiCodCallingTypNum=fclFrCfcEiCodCallingTypNum, vcFrameRelaySw=vcFrameRelaySw, fcmAlrmEvtEvent7=fcmAlrmEvtEvent7, fcwSQOSX25Entry=fcwSQOSX25Entry, fclAsynVdxPageBlocId=fclAsynVdxPageBlocId, fmhEqIdSecondFactoryReturnDate=fmhEqIdSecondFactoryReturnDate, fclPppBIsdnRemStatus=fclPppBIsdnRemStatus, fcsnaGpRemotePuTable=fcsnaGpRemotePuTable, fclX25CfaCugChecking=fclX25CfaCugChecking, cfConfigurationFileToUpload=cfConfigurationFileToUpload, fclPppCfaRemPeerId=fclPppCfaRemPeerId, fclX25InDSwLogPortId=fclX25InDSwLogPortId, vcvFxxConfDtmfDigitLevel=vcvFxxConfDtmfDigitLevel, fclFrSeIsdnRemCallRetryCount=fclFrSeIsdnRemCallRetryCount, fclX25SlpPstnBackPstnNumber=fclX25SlpPstnBackPstnNumber, fclX25CfnDlnN2RetryCount=fclX25CfnDlnN2RetryCount, dcmAlrmLMIEntry=dcmAlrmLMIEntry, fmStatEthManagementTable=fmStatEthManagementTable, fmsE1Ds1ChIfChannelId=fmsE1Ds1ChIfChannelId, fcxServCircSapGetNearestServerReply=fcxServCircSapGetNearestServerReply, fcxRoutAddrFltFiltering=fcxRoutAddrFltFiltering, fclAsynX28PlusParTelConfigId=fclAsynX28PlusParTelConfigId, dclFrTeLpConfigId=dclFrTeLpConfigId, fmsFrDlcTable=fmsFrDlcTable, vclFrTeLpConfigId=vclFrTeLpConfigId, dcmAlrmCmpTyp=dcmAlrmCmpTyp, fmRip2IfConfAuthKey=fmRip2IfConfAuthKey, fccNeighborTable=fccNeighborTable, dclFrSeSigT316RestartAcknowledgeTimer=dclFrSeSigT316RestartAcknowledgeTimer, fclX25MlpMt3ResetConfirmationTimer=fclX25MlpMt3ResetConfirmationTimer, fmRip2PeerEntry=fmRip2PeerEntry, fmOspfStandardNbrTable=fmOspfStandardNbrTable, fclAsynPadLpLink=fclAsynPadLpLink, fcfIsdnBriInterfaceCheckPeriod=fcfIsdnBriInterfaceCheckPeriod, fcbBrdgMapMacAddress=fcbBrdgMapMacAddress, fclAsynCfgFacMaxOutThroughputClass=fclAsynCfgFacMaxOutThroughputClass, fclX25AccIsdnRemCallRetryCount=fclX25AccIsdnRemCallRetryCount, fclAsynCfgFacMinInPacketSize=fclAsynCfgFacMinInPacketSize, fcsnaLvpParamN2=fcsnaLvpParamN2, fcbSpanningTreeProtocol=fcbSpanningTreeProtocol, vclFrLmiParaN391FullStatusPollCount=vclFrLmiParaN391FullStatusPollCount, fclBSctConnMinimumRecallTimer=fclBSctConnMinimumRecallTimer, fclFrCfcLmiAccessibilityCondition=fclFrCfcLmiAccessibilityCondition, fclFrConfigSeEntry=fclFrConfigSeEntry, fcfE1Ds1DropInsertTable=fcfE1Ds1DropInsertTable, fcFrSwInputDlci=fcFrSwInputDlci, fcmMgfBISDNChannelOpening=fcmMgfBISDNChannelOpening, fmsE1Ds1ChIfOutDiscards=fmsE1Ds1ChIfOutDiscards, fclX25CfaPackOutSubAddressCheck=fclX25CfaPackOutSubAddressCheck, fcmMgfStatThroughputSamplingPeriod=fcmMgfStatThroughputSamplingPeriod, fmsStateLine=fmsStateLine, fclBSctProtDef1LogPortId=fclBSctProtDef1LogPortId, fclBSctLpSignalEnvelope=fclBSctLpSignalEnvelope, dcvTftpIpAddress=dcvTftpIpAddress, fcsnaLvpTrParamRW=fcsnaLvpTrParamRW, fcxRipInFltMask=fcxRipInFltMask, fcfTokenRingSpeed=fcfTokenRingSpeed, fclX25CfnSignallingEntry=fclX25CfnSignallingEntry, fcxServSapInFltFilterId=fcxServSapInFltFilterId, fmeTrapEventData=fmeTrapEventData, fmsLineLcInUseCount=fmsLineLcInUseCount, fclSdlcLpCompression=fclSdlcLpCompression, fclAsynX28PlusLpConIdTelenet=fclAsynX28PlusLpConIdTelenet, fclFrPvcSnaSourceSap=fclFrPvcSnaSourceSap, fciSnmpManagerStatus=fciSnmpManagerStatus, fmOsiISISCircAdjChanges=fmOsiISISCircAdjChanges, fclFrCfcEiCodingEntry=fclFrCfcEiCodingEntry, fmOsiISISSystem=fmOsiISISSystem, fclX25CfnDlnLowestOutgoingChannel=fclX25CfnDlnLowestOutgoingChannel, fclFrPvcLinkId=fclFrPvcLinkId, fmsLineIncidentsCounter=fmsLineIncidentsCounter, dcmAlrmCmpTrapSend=dcmAlrmCmpTrapSend, fmOsiISISCircMaxAreaAddrMismatches=fmOsiISISCircMaxAreaAddrMismatches, fmsRvpConnInPktsCounter=fmsRvpConnInPktsCounter, fclFrCfsSignallingEntry=fclFrCfsSignallingEntry, dcvVoiceSwInsSuffix=dcvVoiceSwInsSuffix, dcvTSPCMPermChannIfId=dcvTSPCMPermChannIfId, fcwAddrConvCondOutgoingCallEntry=fcwAddrConvCondOutgoingCallEntry, fclX25MlpMt1LostFrameTimer=fclX25MlpMt1LostFrameTimer, fclAsynX28PlusRemCfgTELENETConfigId=fclAsynX28PlusRemCfgTELENETConfigId, vcInterfaces=vcInterfaces, fmsEthOutPktsCounter=fmsEthOutPktsCounter, fmsFrLpLogPortTable=fmsFrLpLogPortTable, fcsnaLvpParamTW=fcsnaLvpParamTW, fclFrSeInBLpLogPortId=fclFrSeInBLpLogPortId, fcbTransparentBridge=fcbTransparentBridge, fmsFrcFilterDlci=fmsFrcFilterDlci, vcmAlrmSwFamilyId=vcmAlrmSwFamilyId, dcvVoiceSuscrOrderNumber=dcvVoiceSuscrOrderNumber)
mibBuilder.exportSymbols("PCE-MIB", fclX25CfnNegMinInPacketSize=fclX25CfnNegMinInPacketSize, fclAsynMneCallUserDataHexa=fclAsynMneCallUserDataHexa, fclFrCfcLmiParameterTable=fclFrCfcLmiParameterTable, fclFraPvcDlci=fclFraPvcDlci, fmOsiISISCircLANL1DesISChanges=fmOsiISISCircLANL1DesISChanges, fclPppSerLpCos=fclPppSerLpCos, fclAsynCfgX3P05OutputFlowCtrl=fclAsynCfgX3P05OutputFlowCtrl, vclFrSeLpLogPortId=vclFrSeLpLogPortId, fclX25CfnDlnDBitModification=fclX25CfnDlnDBitModification, fclSdlcSecLogPortEntry=fclSdlcSecLogPortEntry, fclPppCfgNcpBridge=fclPppCfgNcpBridge, sc5000=sc5000, fmOspfStandardASBdrRtrStatus=fmOspfStandardASBdrRtrStatus, fclFrCfsGenCallReturnTransmission=fclFrCfsGenCallReturnTransmission, fclFrCfcSigT308ReleaseResponseTimer=fclFrCfcSigT308ReleaseResponseTimer, fclFrSeLpLogPortId=fclFrSeLpLogPortId, fmStatEthernetTable=fmStatEthernetTable, fmStatIpTraffic=fmStatIpTraffic, vcvFxxLpCallType=vcvFxxLpCallType, fmRip2IfConfDefaultMetric=fmRip2IfConfDefaultMetric, fcwConvOutOrderNum=fcwConvOutOrderNum, fclB3270CluCallEntry=fclB3270CluCallEntry, dcvVoiceLogicalPortEntry=dcvVoiceLogicalPortEntry, fmPingAdminState=fmPingAdminState, fclAsynCfgX3P09CrPadding=fclAsynCfgX3P09CrPadding, vclFrSeSigConfigId=vclFrSeSigConfigId, fclFrCfsGeneralParameterEntry=fclFrCfsGeneralParameterEntry, fmOspfStandardVirtIfHelloInterval=fmOspfStandardVirtIfHelloInterval, fmsCtrlCountersCommand=fmsCtrlCountersCommand, fmOspfStandardVirtNbrTable=fmOspfStandardVirtNbrTable, fciRipNeighborTable=fciRipNeighborTable, fclX25CfnSerStatCompression=fclX25CfnSerStatCompression, vcfPhysicalPortTable=vcfPhysicalPortTable, vcvFxxRingFrequency=vcvFxxRingFrequency, fmsE1Ds1ChIfPhysAddress=fmsE1Ds1ChIfPhysAddress, dclFrSeLpInterfaceId=dclFrSeLpInterfaceId, fcfIsdnDSigMulDialsCycleTimer=fcfIsdnDSigMulDialsCycleTimer, dcvCASConfIdleState=dcvCASConfIdleState, fclFraLpDeDiscardThreshold=fclFraLpDeDiscardThreshold, dcvVoiceSuscrNumber=dcvVoiceSuscrNumber, fmsFrcStoragePvcStatus=fmsFrcStoragePvcStatus, fmOspfStandardVirtNbrLSRetransQLen=fmOspfStandardVirtNbrLSRetransQLen, fclX25CfnNegDefInWindowSize=fclX25CfnNegDefInWindowSize, dclLogicalPortEntry=dclLogicalPortEntry, fcmMgfConversionOutgoingCall=fcmMgfConversionOutgoingCall, fmOspfStandardHostEntry=fmOspfStandardHostEntry, fclVipCluStationEntry=fclVipCluStationEntry, fclFraPvcEncapsulation=fclFraPvcEncapsulation, fclAsynMneCalledAddr=fclAsynMneCalledAddr, cdpIdentification=cdpIdentification, fmsFrDlcInDlci=fmsFrDlcInDlci, fclFrPvcLinkType=fclFrPvcLinkType, fcwDnicRouteId=fcwDnicRouteId, fmsFrDlcInDeFrames=fmsFrDlcInDeFrames, fmOsiISISSysLSPL2DbaseOloads=fmOsiISISSysLSPL2DbaseOloads, fcwConvOutExternalAddr=fcwConvOutExternalAddr, fclAsynCfgX3P04IdleTimerDelay=fclAsynCfgX3P04IdleTimerDelay, dcvRemoteConfStatus=dcvRemoteConfStatus, fclAsynPadHomePageEntry=fclAsynPadHomePageEntry, fciVirtualPortTable=fciVirtualPortTable, fmOsiISISISAdjacencyEntry=fmOsiISISISAdjacencyEntry, fclB3270HostPadLogPort=fclB3270HostPadLogPort, fclAsynX28PlusRemConfigId=fclAsynX28PlusRemConfigId, fclPppCfaRemStatus=fclPppCfaRemStatus, fclPppBIsdnBriId=fclPppBIsdnBriId, fclFrPvcX25LinkType=fclFrPvcX25LinkType, cmeClearDiag=cmeClearDiag, fcwSCUDProfilesStatus=fcwSCUDProfilesStatus, cfMpbBoardReference255=cfMpbBoardReference255, fclSdlcLpPhysicalUnitType=fclSdlcLpPhysicalUnitType, fcsnaGpSdlcPuId=fcsnaGpSdlcPuId, fmsFrcStorageChannelId=fmsFrcStorageChannelId, vcvVoiceSuscrTransportNetwork=vcvVoiceSuscrTransportNetwork, fclAsynX28PlusRemCfgX3P21Parity=fclAsynX28PlusRemCfgX3P21Parity, fciRemoteNetToMediaTable=fciRemoteNetToMediaTable, fcmMgfConvMultiCallingAddrInCall=fcmMgfConvMultiCallingAddrInCall, fclX25CfnSigSubAddressTransmission=fclX25CfnSigSubAddressTransmission, fciFlowFlowId=fciFlowFlowId, fclVipHosElemAddress=fclVipHosElemAddress, vcvRemoteConfEntry=vcvRemoteConfEntry, fmOspfStandardAreaLSACount=fmOspfStandardAreaLSACount, fciRipVpMetricIn=fciRipVpMetricIn, fmOspfStandardHostStatus=fmOspfStandardHostStatus, fclFrTeLpConfigId=fclFrTeLpConfigId, vcvEMConfToneProfile=vcvEMConfToneProfile, fcmAlrmEventTable=fcmAlrmEventTable, fclAsynMneVdxKeyTranslationTable=fclAsynMneVdxKeyTranslationTable, fclFraLpReliableVc=fclFraLpReliableVc, fmsEthTdrState=fmsEthTdrState, fccLvpEsIsConfigTimer=fccLvpEsIsConfigTimer, fclAsynX28PlusLpLink=fclAsynX28PlusLpLink, frxStateChange=frxStateChange, vcvRemoteConfStatus=vcvRemoteConfStatus, vcvDialRxNumberLength=vcvDialRxNumberLength, fciOspfAreaRangeIpMask=fciOspfAreaRangeIpMask, fclAsynPadPageAttributes=fclAsynPadPageAttributes, fclVipHosStatStationAddress=fclVipHosStatStationAddress, fclVipCluLogPortEntry=fclVipCluLogPortEntry, fclIulCallReturnTransmission=fclIulCallReturnTransmission, dcvRemoteConfTable=dcvRemoteConfTable, vcx100=vcx100, fclFrCfsSigSignalOutputWinSize=fclFrCfsSigSignalOutputWinSize, fclFrBackupTable=fclFrBackupTable, sc103_6W=sc103_6W, vcvVoiceTransMaxPayLoadNumber=vcvVoiceTransMaxPayLoadNumber, fmRip2IfConfSend=fmRip2IfConfSend, fclFrTeIsdnRemPriority=fclFrTeIsdnRemPriority, cfRevision=cfRevision, fclFrPvcSnaEncapsulationTable=fclFrPvcSnaEncapsulationTable, fcwConvMultiInExternalAddr=fcwConvMultiInExternalAddr, fclBX780LpEquipementType=fclBX780LpEquipementType, vcwABPvcLpId=vcwABPvcLpId, fcsHardwareDescription=fcsHardwareDescription, dcSysConfHour=dcSysConfHour, fclX25CfnDataLinkNetworkEntry=fclX25CfnDataLinkNetworkEntry, fclHdlcLpCrcTransport=fclHdlcLpCrcTransport, fcsnaGpRoutingTable=fcsnaGpRoutingTable, vcvEMConfSeizureAckPulseDuration=vcvEMConfSeizureAckPulseDuration, fclX25CfaNegMaxInWindowSize=fclX25CfaNegMaxInWindowSize, fclX25CfaSigConvMultiCallingAddrOutCall=fclX25CfaSigConvMultiCallingAddrOutCall, fclX25MlpIsdnOverflowTable=fclX25MlpIsdnOverflowTable, fmsFrLpInFecnFrames=fmsFrLpInFecnFrames, fmOsiISISISAdjHoldTimer=fmOsiISISISAdjHoldTimer, fcfLineV28AsynOutDceDcd109=fcfLineV28AsynOutDceDcd109, fciFlowSrcMask=fciFlowSrcMask, dcvVoiceSwOrderNumber=dcvVoiceSwOrderNumber, fclX25CfnDlnLowestIncomingChannel=fclX25CfnDlnLowestIncomingChannel, fclFrSeInBLpIsdnInterfaceId=fclFrSeInBLpIsdnInterfaceId, vcfDataLineRts105=vcfDataLineRts105, fclX25CfnSerRemoteExclusiveLink=fclX25CfnSerRemoteExclusiveLink, fcfIsdnPrimaryRateInterfaceEntry=fcfIsdnPrimaryRateInterfaceEntry, dcvVoiceProfSilenceDetection=dcvVoiceProfSilenceDetection, fclPppConfigTimersEntry=fclPppConfigTimersEntry, fclFrTeIsdnRemotePeerEntry=fclFrTeIsdnRemotePeerEntry, mcx103=mcx103, fclSdlcLpUnknownPackets=fclSdlcLpUnknownPackets, fcxServSapOutputFilteringTable=fcxServSapOutputFilteringTable, fciFlowRouteFlowId=fciFlowRouteFlowId, vclFrSeSigT203InactivityTimer=vclFrSeSigT203InactivityTimer, fcxRoutAddrFltField=fcxRoutAddrFltField, vcvIpLocAddressHost=vcvIpLocAddressHost, fcxRoutStaticRouteNetNum=fcxRoutStaticRouteNetNum, fdpIdentPhysPortId=fdpIdentPhysPortId, fcsnaLvpLlpStatus=fcsnaLvpLlpStatus, vcvVoicePhysicalPortEntry=vcvVoicePhysicalPortEntry, dcmAlrmFaxFamilyId=dcmAlrmFaxFamilyId, dcfDataLineEntry=dcfDataLineEntry, fclPppPstnRemX121Addr=fclPppPstnRemX121Addr, fcxCircuitRemoteVpTable=fcxCircuitRemoteVpTable, fmOspfStandardAreaId=fmOspfStandardAreaId, fmOspfStandardIfMetricTable=fmOspfStandardIfMetricTable, fclPppBIsdnBriLocalSubsNb2=fclPppBIsdnBriLocalSubsNb2, dcmAlrmSwDisplay=dcmAlrmSwDisplay, fmOspfStandard=fmOspfStandard, fclAsynCfgConnServiceEntry=fclAsynCfgConnServiceEntry, fclSdlcSecClusterBc=fclSdlcSecClusterBc, fmeEvtEventIndex=fmeEvtEventIndex, fclX25SlpSwLogPortId=fclX25SlpSwLogPortId, fmRip2PeerTable=fmRip2PeerTable, fmOsiISISRAType=fmOsiISISRAType, vclFrCeLogPortEntry=vclFrCeLogPortEntry, fclX25PstnInterfaceId=fclX25PstnInterfaceId, fclX25ConfigAccessEntry=fclX25ConfigAccessEntry, fcwConvOutConvertedAddr=fcwConvOutConvertedAddr, fclFrCeParGenTable=fclFrCeParGenTable, dcvCASConfDelayBeforeDialing=dcvCASConfDelayBeforeDialing, fcfLineModem=fcfLineModem, fclFrBackupDlci=fclFrBackupDlci, fcxServices=fcxServices, dcvSnmpManagerEntry=dcvSnmpManagerEntry, fmsFrLpSvcDlcVbrRt=fmsFrLpSvcDlcVbrRt, fcxCircName=fcxCircName, cfFactoryReturnDate4=cfFactoryReturnDate4, fciLocalVirtualPortEntry=fciLocalVirtualPortEntry, fcfLineCheckPeriodCount=fcfLineCheckPeriodCount, fciBootPClientBootFile=fciBootPClientBootFile, fclFrSeIsdnRemRemotePeerId=fclFrSeIsdnRemRemotePeerId, fmRip2GlobalRouteChanges=fmRip2GlobalRouteChanges, dcCtlErrorTable=dcCtlErrorTable, fclSdlcPriClusterAddress=fclSdlcPriClusterAddress, fclVipHosStationEntry=fclVipHosStationEntry, fcvRvpCompressNegotiation=fcvRvpCompressNegotiation, fcfLineV11DceSyn=fcfLineV11DceSyn, fcbStpVpBpduEncapsulation=fcbStpVpBpduEncapsulation, fmsIpCluOperStatus=fmsIpCluOperStatus, fclAsynX28PlusRemCfgX3P20EchoMask=fclAsynX28PlusRemCfgX3P20EchoMask, fmeEventEntry=fmeEventEntry, fclAsynAutoCallUserDataHexa=fclAsynAutoCallUserDataHexa, fcsnaGeneralParameters=fcsnaGeneralParameters, fclAsynCfgX3P14LfPadding=fclAsynCfgX3P14LfPadding, fclX25CfaFacConfigId=fclX25CfaFacConfigId, fmStatFrCircuitEntry=fmStatFrCircuitEntry, cmeEventSynchronize=cmeEventSynchronize, fclPppCfaLocalIdentifier=fclPppCfaLocalIdentifier, fclAsynX28PlusRemCfgX3P18LineDisplay=fclAsynX28PlusRemCfgX3P18LineDisplay, fclX25MlpIsdnRemPriority=fclX25MlpIsdnRemPriority, fclPppBIsdnAccess=fclPppBIsdnAccess, fclB3270CluCallMinRecallTimer=fclB3270CluCallMinRecallTimer, fmsFrLpSvcSignallingEntry=fmsFrLpSvcSignallingEntry, vcvAnalogLineEntry=vcvAnalogLineEntry, fmOsiISISCircOutPdu=fmOsiISISCircOutPdu, vcmAlrmCmpTrapSend=vcmAlrmCmpTrapSend, fclVipHosLpFtbcc=fclVipHosLpFtbcc, fclB3270CluClusterTable=fclB3270CluClusterTable, fclVipCluElementEntry=fclVipCluElementEntry, fclX25CfaPackSubAddress=fclX25CfaPackSubAddress, fclFraLmiEntry=fclFraLmiEntry, dcvVoiceSwEntry=dcvVoiceSwEntry, fmeEvtTime=fmeEvtTime, cfReleaseDate=cfReleaseDate, cfSoftwareList=cfSoftwareList, fmOsiISISESAdjState=fmOsiISISESAdjState, fclX25SlpLogPortId=fclX25SlpLogPortId, fcIpx=fcIpx, dcvCASConfClearToIncCallTime=dcvCASConfClearToIncCallTime, fmsFrDlcDlci=fmsFrDlcDlci, fmsEthInPktsCounter=fmsEthInPktsCounter, fclSdlcLpLogicalLinkProtocol=fclSdlcLpLogicalLinkProtocol, fclPppSerAutoCompressMultiPktTimer=fclPppSerAutoCompressMultiPktTimer, fclFrPvcSnaBanMinRecallTimer=fclFrPvcSnaBanMinRecallTimer, fclX25SlpIsdnRemX25InterNodeConfigId=fclX25SlpIsdnRemX25InterNodeConfigId, fclX25SlpInterNodeTable=fclX25SlpInterNodeTable, fmsFrLpOutOctets=fmsFrLpOutOctets, fclX25CfaSerStatCompression=fclX25CfaSerStatCompression, fmOsiISISSysISFieldLenMismatches=fmOsiISISSysISFieldLenMismatches, dclFrSeSigN200RetransMaxCount=dclFrSeSigN200RetransMaxCount, fmsRvpConnRemoteAddr=fmsRvpConnRemoteAddr, fclAsynCfgX3Part1Table=fclAsynCfgX3Part1Table, fclX25AccX25AccessConfigId=fclX25AccX25AccessConfigId, fclAsynCfgX3P06ServiceSignals=fclAsynCfgX3P06ServiceSignals, fciOspfVpId=fciOspfVpId, vcvVoiceSuscrTransportProfileId=vcvVoiceSuscrTransportProfileId, fmOspfStandardIfEvents=fmOspfStandardIfEvents, fclFrCfsSigConfigId=fclFrCfsSigConfigId, dcwEquipIpVirtualPortAddr=dcwEquipIpVirtualPortAddr, fcSna=fcSna, fmOspfStandardNBMANbrStatus=fmOspfStandardNBMANbrStatus, fclBSctLpUnderrunManagement=fclBSctLpUnderrunManagement, fmOsiISISISAdjUsage=fmOsiISISISAdjUsage, dcvTSPCMSwEntry=dcvTSPCMSwEntry, vcfDataLineCts106=vcfDataLineCts106, fciRipAdminStatus=fciRipAdminStatus, dcvCASConfToneProfile=dcvCASConfToneProfile, fclFrCfsGenDlcSetupDiscardThreshold=fclFrCfsGenDlcSetupDiscardThreshold, fclFrCfsGenBehavior=fclFrCfsGenBehavior, fcsnaGpRoutCos=fcsnaGpRoutCos, fmOsiISISRASystemType=fmOsiISISRASystemType, fclX25AccIsdnBackupTable=fclX25AccIsdnBackupTable, fciOspfNeighborStatus=fciOspfNeighborStatus, fcfLineModOutputXidString=fcfLineModOutputXidString, fclB3270HosLpWackTransmission=fclB3270HosLpWackTransmission, fmOsiISISAreaAddress=fmOsiISISAreaAddress, fclFraPvcEndPointTable=fclFraPvcEndPointTable, fclHdlcLpCompressNegotiation=fclHdlcLpCompressNegotiation)
mibBuilder.exportSymbols("PCE-MIB", fmsEthInOctetsCounter=fmsEthInOctetsCounter, fclX25MlpTns3Level3CheckTimer=fclX25MlpTns3Level3CheckTimer, vcmAlrmSvcTrapSend=vcmAlrmSvcTrapSend, fclX25CfaSerStatSignalling=fclX25CfaSerStatSignalling, fmOspfStandardAreaRangeMask=fmOspfStandardAreaRangeMask, fmeTrapInfo=fmeTrapInfo, dcvCASConfDialingTimeOut=dcvCASConfDialingTimeOut, fclFraPvcInactivityTimer=fclFraPvcInactivityTimer, fcsnaLvpTrMacAddressTrans=fcsnaLvpTrMacAddressTrans, fclFrCfcLmiN392ErrorThreshold=fclFrCfcLmiN392ErrorThreshold, fcFrSwStatus=fcFrSwStatus, fcxRipOutFltNetAddress=fcxRipOutFltNetAddress, fclAsynCfgX3UserP05OutputFlowCtrl=fclAsynCfgX3UserP05OutputFlowCtrl, fclSdlcSecondaryPuLogPort=fclSdlcSecondaryPuLogPort, fcxRipInputFilteringTable=fcxRipInputFilteringTable, dcwABPvcLpId=dcwABPvcLpId, fcfIsdnDChannelSignallingEntry=fcfIsdnDChannelSignallingEntry, fcsnaGpRoutingEntry=fcsnaGpRoutingEntry, fcwFrVoiceFrameSize=fcwFrVoiceFrameSize, fclX25InDIsdnRemPdnLinkAddress=fclX25InDIsdnRemPdnLinkAddress, fcxServSapOutFltCircuitId=fcxServSapOutFltCircuitId, fcsnaLvpLocalLanPuEntry=fcsnaLvpLocalLanPuEntry, fclAsynCfgX3UserP10LineFolding=fclAsynCfgX3UserP10LineFolding, fclFrPvcEncapsulation=fclFrPvcEncapsulation, fmsPppIpAddrSent=fmsPppIpAddrSent, fclFrTeIsdnRemConfigId=fclFrTeIsdnRemConfigId, fmOsiISISCircL2DesIS=fmOsiISISCircL2DesIS, fclVipHosElementEntry=fclVipHosElementEntry, dcvVirtualPortEntry=dcvVirtualPortEntry, fclAsynX28PlusLpRemPrSentOnCalls=fclAsynX28PlusLpRemPrSentOnCalls, dcvToneFreq1=dcvToneFreq1, fmOspfStandardTOSSupport=fmOspfStandardTOSSupport, fccErrorFramesSending=fccErrorFramesSending, fmuAccessPadLineNbMax=fmuAccessPadLineNbMax, vcvVoiceSuscrTransportNetworkAddress=vcvVoiceSuscrTransportNetworkAddress, fciOspfVpPollInterval=fciOspfVpPollInterval, vclFrSeLogPortTable=vclFrSeLogPortTable, fmOsiISISCircIndex=fmOsiISISCircIndex, fcfLineV35DceLl141=fcfLineV35DceLl141, vcFrSwL0ChanelIdentifierCID=vcFrSwL0ChanelIdentifierCID, fcfLineV28AsynInDteEnablingSig2=fcfLineV28AsynInDteEnablingSig2, dcvDigitalLines=dcvDigitalLines, fclPppCfgAuthenticationMode=fclPppCfgAuthenticationMode, fmStatRvpConnectionsEntry=fmStatRvpConnectionsEntry, fcsnaLvpLlpPuId=fcsnaLvpLlpPuId, fclX25CfnSigConversionAddressCheck=fclX25CfnSigConversionAddressCheck, fclX25CfaServiceEntry=fclX25CfaServiceEntry, fclX25CfaDlnN2RetryCount=fclX25CfaDlnN2RetryCount, vcCtlErrorTime=vcCtlErrorTime, fclVipCluElemMinRecallTimer=fclVipCluElemMinRecallTimer, fmsSig140=fmsSig140, vcFrSwStatus=vcFrSwStatus, fccLvpStatus=fccLvpStatus, dcmAlrmGenTyp=dcmAlrmGenTyp, dcfPhysicalPortTable=dcfPhysicalPortTable, dcvVoiceLogicalPortTable=dcvVoiceLogicalPortTable, fcfE1Ds1PhysIfId=fcfE1Ds1PhysIfId, fclHdlcLpCos=fclHdlcLpCos, dcvTSPCMSw=dcvTSPCMSw, fmOspfStandardAreaRangeEntry=fmOspfStandardAreaRangeEntry, fciOspfAreaStubMetric=fciOspfAreaStubMetric, fcCtlErrorCode=fcCtlErrorCode, fmPingReceivedPackets=fmPingReceivedPackets, fclFrCfsSigT310CallProceedingTimer=fclFrCfsSigT310CallProceedingTimer, fclFrCfcSigT200RetransTimer=fclFrCfcSigT200RetransTimer, vcFrSwL0MuxEnable=vcFrSwL0MuxEnable, fmsBootPRelayTable=fmsBootPRelayTable, dclFrConfigurationSe=dclFrConfigurationSe, fmOspfStandardLsdbEntry=fmOspfStandardLsdbEntry, fclFrPvcQosLinkId=fclFrPvcQosLinkId, fciLvpEncapsulation=fciLvpEncapsulation, fciTelnetPwdP8=fciTelnetPwdP8, fcxServInstance=fcxServInstance, fcsnaLvpTrParamCompressMultiPacketsTimer=fcsnaLvpTrParamCompressMultiPacketsTimer, fmsRvpConnInOctetsCounter=fmsRvpConnInOctetsCounter, fcwDnicStatus=fcwDnicStatus, fcxServStaticServiceId=fcxServStaticServiceId, vcManagement=vcManagement, fmOspfStandardVirtNbrOptions=fmOspfStandardVirtNbrOptions, fclX25MlpPstnOvPstnNumber=fclX25MlpPstnOvPstnNumber, fclVipHosElementTable=fclVipHosElementTable, dcvCASConfDialingMode=dcvCASConfDialingMode, systemDescription=systemDescription, vcvSnmpGen=vcvSnmpGen, fclX25CfnDescription=fclX25CfnDescription, fciNetToMediaEntry=fciNetToMediaEntry, fcmMgfActAdminStatus=fcmMgfActAdminStatus, fclAsynLscpLpLink=fclAsynLscpLpLink, fclX25CfaFacOutputUnknownFacility=fclX25CfaFacOutputUnknownFacility, fclX25CfaCugClosedUserGroupExt=fclX25CfaCugClosedUserGroupExt, fclX25InDSwitchOverEntry=fclX25InDSwitchOverEntry, fciFastIpRouting=fciFastIpRouting, fmOsiISISESAdjESID=fmOsiISISESAdjESID, fcwFrSlowingDownThreshold=fcwFrSlowingDownThreshold, fmOspfStandardIfEntry=fmOspfStandardIfEntry, fmOspfStandardVirtNbrArea=fmOspfStandardVirtNbrArea, vcvVoiceSwLogPortSetId=vcvVoiceSwLogPortSetId, fclX25AccIsdnRemLogPortId=fclX25AccIsdnRemLogPortId, fclX25InBIsdnTable=fclX25InBIsdnTable, fciOspfVpAdminStatus=fciOspfVpAdminStatus, fmsPppProtoIpxNcpDiag=fmsPppProtoIpxNcpDiag, vcvToneType=vcvToneType, fciOspfAseExportStaticsType=fciOspfAseExportStaticsType, vcvVoiceTransVoicePacketsCombination=vcvVoiceTransVoicePacketsCombination, fcfE1Ds1ChannelTable=fcfE1Ds1ChannelTable, fmuFunctionBridgeAndStp=fmuFunctionBridgeAndStp, fcmAlrmPpPhysPort5=fcmAlrmPpPhysPort5, fcwSQOSX25Table=fcwSQOSX25Table, dclFrConfigurationTe=dclFrConfigurationTe, fclX25SlpIsdnRemStatus=fclX25SlpIsdnRemStatus, fclX25MlpIsdnRemPeerId=fclX25MlpIsdnRemPeerId, fclVipLogPort=fclVipLogPort, fmsE1Ds1ChIfDescr=fmsE1Ds1ChIfDescr, fcwSRvcFirstDataPacketTimer=fcwSRvcFirstDataPacketTimer, fclX25CfnSerStatTotalizer=fclX25CfnSerStatTotalizer, fcxServSapInFltServiceNameType=fcxServSapInFltServiceNameType, fcxServCircSapOutputFiltering=fcxServCircSapOutputFiltering, fcsnaLvpParamT1=fcsnaLvpParamT1, fcfLineV28DceRil140=fcfLineV28DceRil140, fclPppSerAutoCompression=fclPppSerAutoCompression, fcmAlrmEvtEvent2=fcmAlrmEvtEvent2, fclX25MlpIsdnOverflow=fclX25MlpIsdnOverflow, fclX25InDIsdnEntry=fclX25InDIsdnEntry, fmsGlobCompressOctetGain=fmsGlobCompressOctetGain, fclFrSeInBRemCallRetryCount=fclFrSeInBRemCallRetryCount, fmsFrcStorageDestAddr=fmsFrcStorageDestAddr, fcfLineDVBInterfaceId=fcfLineDVBInterfaceId, fclX25InBRemPdnLinkAddress=fclX25InBRemPdnLinkAddress, vcvVirtualPortTable=vcvVirtualPortTable, fclAsynCfgX3P19EditingSignal=fclAsynCfgX3P19EditingSignal, fclX25MlpLink4InterfaceId=fclX25MlpLink4InterfaceId, fclPppSerAutoCompressNegotiation=fclPppSerAutoCompressNegotiation, fmsStateTestState=fmsStateTestState, fmsS0BChProto=fmsS0BChProto, fmsFrcFilterChannelId=fmsFrcFilterChannelId, fcxRipCircState=fcxRipCircState, fclX25CfnNegThroughputClass=fclX25CfnNegThroughputClass, fcwSQOSProfilesStatus=fcwSQOSProfilesStatus, vcmAlrmLMITable=vcmAlrmLMITable, fcwSerDynamicRouting=fcwSerDynamicRouting, fcmAlrmEvtFamilyId=fcmAlrmEvtFamilyId, fmsMlpLineType=fmsMlpLineType, fcbBridging=fcbBridging, fcbBrdgVpAgingTime=fcbBrdgVpAgingTime, fclX25PstnRemX121Addr=fclX25PstnRemX121Addr, fmOspfStandardExternLSACksumSum=fmOspfStandardExternLSACksumSum, fclX25InDSwitchOverTable=fclX25InDSwitchOverTable, fclHdlcLpCompression=fclHdlcLpCompression, fcxRipCircOutputFiltering=fcxRipCircOutputFiltering, fmOspfStandardAreaRangeTable=fmOspfStandardAreaRangeTable, dcwEquipVoiceRoutingServicePortAddr=dcwEquipVoiceRoutingServicePortAddr, fclX25CfaSigOutPacketCauseField=fclX25CfaSigOutPacketCauseField, fmOspfStandardAreaRangeNet=fmOspfStandardAreaRangeNet, fclFrPvcTunLinkId=fclFrPvcTunLinkId, vcvSnmpManagerTrapsUdpPort=vcvSnmpManagerTrapsUdpPort, dcfDataLineCts106=dcfDataLineCts106, fmsRvpConnGrouping=fmsRvpConnGrouping, fcfIsdnBasicRateInterfaceTable=fcfIsdnBasicRateInterfaceTable, fmOsiCLNPSystem=fmOsiCLNPSystem, fcwSQOSProfilesCIRmin=fcwSQOSProfilesCIRmin, fclAsynX28PlusLpFullDuplex=fclAsynX28PlusLpFullDuplex, fmsE1Ds1ChIfType=fmsE1Ds1ChIfType, dcfPhysPortId=dcfPhysPortId, fmsInputDataPktsCounter=fmsInputDataPktsCounter, fclFrSeLpLogPortBackupEnabling=fclFrSeLpLogPortBackupEnabling, dcmAlrmFaxDisplay=dcmAlrmFaxDisplay, fclX25CfaCugStatus=fclX25CfaCugStatus, fciOspfAseExportStaticsMetric=fciOspfAseExportStaticsMetric, fmsPppProtoClnpNcpDiag=fmsPppProtoClnpNcpDiag, fciTelnet=fciTelnet, fmsFrDlcOutFecnFrames=fmsFrDlcOutFecnFrames, fmOsiISISCircInitFails=fmOsiISISCircInitFails, fmOspfStandardVirtIfRtrDeadInterval=fmOspfStandardVirtIfRtrDeadInterval, fmsFrLpLmiNetN392=fmsFrLpLmiNetN392, fmOspfStandardIfTransitDelay=fmOspfStandardIfTransitDelay, fcxRoutAddrFltMask=fcxRoutAddrFltMask, dcvDialRxStatus=dcvDialRxStatus, fclSdlcSecClusterLogPortId=fclSdlcSecClusterLogPortId, vclFrConfigurationTe=vclFrConfigurationTe, fclAsynAutoTransClearHangUp=fclAsynAutoTransClearHangUp, vcvSnmpGenCommunityStringReadWrite=vcvSnmpGenCommunityStringReadWrite, dclFrSeSigT308ReleaseResponseTimer=dclFrSeSigT308ReleaseResponseTimer, fdpTestOutPktsCounter=fdpTestOutPktsCounter, fcwSbRoutingEntry=fcwSbRoutingEntry, frxManagement=frxManagement, vcvEMConfDialingMode=vcvEMConfDialingMode, fmsEthPolarityCorrection=fmsEthPolarityCorrection, fclPppPstnRemStatus=fclPppPstnRemStatus, fciOspfVpAreaId=fciOspfVpAreaId, fclFrCfcLmiAsynchronousStatusReport=fclFrCfcLmiAsynchronousStatusReport, fmsIpCluLastChange=fmsIpCluLastChange, vcvEMConfigEntry=vcvEMConfigEntry, fclX25ConfigInterNode=fclX25ConfigInterNode, fclFrCfcLmiConfigId=fclFrCfcLmiConfigId, fclX25MlpRestartTxAfterResetRx=fclX25MlpRestartTxAfterResetRx, vcvFxxConfSigChannelDiscTimeOut=vcvFxxConfSigChannelDiscTimeOut, vcvVoiceProfSilenceDetection=vcvVoiceProfSilenceDetection, fclFrTeParGenVoiceMaxTransitDelay=fclFrTeParGenVoiceMaxTransitDelay, dcmAlrmSyncFamilyId=dcmAlrmSyncFamilyId, fcwLocalCommunications=fcwLocalCommunications, fciRemoteNetToMediaEntry=fciRemoteNetToMediaEntry, vclFrTeLogPortTable=vclFrTeLogPortTable, dcvDialingReceptEntry=dcvDialingReceptEntry, fclBSctLpLogPortId=fclBSctLpLogPortId, fclFraLpFecnBecnThreshold=fclFraLpFecnBecnThreshold, fclFrameRelayAccessLogPort=fclFrameRelayAccessLogPort, fmOsiISISReachableAddressEntry=fmOsiISISReachableAddressEntry, cmeClearCallUserData=cmeClearCallUserData, fcwZoRouteId=fcwZoRouteId, fclAsynX28PlusRemLpIdleTimerSelection=fclAsynX28PlusRemLpIdleTimerSelection, fciTelnetPwdP6=fciTelnetPwdP6, fclBSctProtDef2WABT=fclBSctProtDef2WABT, fcxRoutAddrFltValue=fcxRoutAddrFltValue, fcmAlrmEvtEvent6=fcmAlrmEvtEvent6, fcwSRvcConversionAddressCheck=fcwSRvcConversionAddressCheck, fclVipHosStatStatus=fclVipHosStatStatus, fcCtlAlteredIfId=fcCtlAlteredIfId, vcvFxxConfPauseTime=vcvFxxConfPauseTime, fcmMgfConversionAddressCheck=fcmMgfConversionAddressCheck, dclFrSeSigConfigId=dclFrSeSigConfigId, fciOspfAseExportLimit=fciOspfAseExportLimit, fmsInArpVpInResponses=fmsInArpVpInResponses, fcvLvpFltConditionTable=fcvLvpFltConditionTable, fcwConvInOrderNum=fcwConvInOrderNum, fciBootPClient=fciBootPClient, fcwSbStatus=fcwSbStatus, fclFrTeParGenPredictionRoundTripDelay=fclFrTeParGenPredictionRoundTripDelay, fcvRvpBe=fcvRvpBe, fclFrPvcSnaT1ReplyTimer=fclFrPvcSnaT1ReplyTimer, fmsWanConnOutOctetsCounter=fmsWanConnOutOctetsCounter, vcFrSwL1DlciPriority=vcFrSwL1DlciPriority, fcsnaLvpParamCompressMultiPacketsTimer=fcsnaLvpParamCompressMultiPacketsTimer, fmStatEthernet=fmStatEthernet, fmOspfStandardIfRtrPriority=fmOspfStandardIfRtrPriority, fmStatS0=fmStatS0, fmsFrcStorageBc=fmsFrcStorageBc, fcfLineInterfaceId=fcfLineInterfaceId, fciSnmpModule0TrapSourceAddrVpId=fciSnmpModule0TrapSourceAddrVpId, fcwConvCondOutTryOn=fcwConvCondOutTryOn, fmsFrLpLmiUserLinkRelErrors=fmsFrLpLmiUserLinkRelErrors, dcmAlrmFaxEntry=dcmAlrmFaxEntry, vcfDataLineInterfaceId=vcfDataLineInterfaceId, dclFrSeSigT310CallProceedingTimer=dclFrSeSigT310CallProceedingTimer, fmStatLinesSummary=fmStatLinesSummary, dcmAlrmVCTyp=dcmAlrmVCTyp, fclFraLpCompressMultiPacketsTimer=fclFraLpCompressMultiPacketsTimer, fclPppBIsdnLpLogPortId=fclPppBIsdnLpLogPortId, fclAsynMneName=fclAsynMneName, fclX25CfaStatus=fclX25CfaStatus, fcxRipCircAgeMultiplier=fcxRipCircAgeMultiplier, fcmMgfConvMultiCalledAddrInCall=fcmMgfConvMultiCalledAddrInCall, fclAsynLscpLpEquipment=fclAsynLscpLpEquipment, fclAsynCfgConnServiceTable=fclAsynCfgConnServiceTable, fclX25AccLogPortId=fclX25AccLogPortId)
mibBuilder.exportSymbols("PCE-MIB", vcvEMConfSigChannelDiscTimeOut=vcvEMConfSigChannelDiscTimeOut, dcvVoiceTransMaxPayLoadNumber=dcvVoiceTransMaxPayLoadNumber, vclHdlcLpRemoteAddress=vclHdlcLpRemoteAddress, fclAsynAutoTransTranscoding=fclAsynAutoTransTranscoding, dcvTftpEntry=dcvTftpEntry, fmPingTable=fmPingTable, fclX25InDIsdnRemIsdnInterfaceId=fclX25InDIsdnRemIsdnInterfaceId, fclFrCfcModificationCount=fclFrCfcModificationCount, fclFrPvcDlci=fclFrPvcDlci, fmsSigDceOrDte=fmsSigDceOrDte, fclAsynVdxLpNui=fclAsynVdxLpNui, fciVpVirtualPortId=fciVpVirtualPortId, fcsnaLvpTrParamLinkType=fcsnaLvpTrParamLinkType, fmuAccessX75LineNbMax=fmuAccessX75LineNbMax, fclAsynX28PlusLpMonSignalCTS=fclAsynX28PlusLpMonSignalCTS, fclPppSerAutoInactivityTimer=fclPppSerAutoInactivityTimer, vcvAnalogLines=vcvAnalogLines, fclFrSeInBRemotePeerTable=fclFrSeInBRemotePeerTable, fclFraPvcSubscriberNumber=fclFraPvcSubscriberNumber, fcwFrDlcSetupDiscardThreshold=fcwFrDlcSetupDiscardThreshold, fciOspfAreaAuthType=fciOspfAreaAuthType, fclPppBIsdnLocalPriEntry=fclPppBIsdnLocalPriEntry, fclBX780LpAuthorAnswerTimer=fclBX780LpAuthorAnswerTimer, dcvCASConfDtmfDigitTime=dcvCASConfDtmfDigitTime, fcwAddrConvOutgoingCallTable=fcwAddrConvOutgoingCallTable, fcfLineV28DteCts106=fcfLineV28DteCts106, fclB3270CluLpLogPortId=fclB3270CluLpLogPortId, fciRipNeighborIpAddress=fciRipNeighborIpAddress, fmsFrCircuitStatus=fmsFrCircuitStatus, fmsS0BChIfLastChange=fmsS0BChIfLastChange, fclAsynAutoVdxKeyTranslationTable=fclAsynAutoVdxKeyTranslationTable, fcxCircRvpCircuitId=fcxCircRvpCircuitId, vcvToneEntry=vcvToneEntry, dcvVoiceProfEchoCancellation=dcvVoiceProfEchoCancellation, fmsS0BChIfOutOctets=fmsS0BChIfOutOctets, fcbBrdgMapStatus=fcbBrdgMapStatus, fcmMgfAlarmsSubscriber2=fcmMgfAlarmsSubscriber2, fmOsiISISCircuitEntry=fmOsiISISCircuitEntry, fccLocalNeighborEntry=fccLocalNeighborEntry, fciTelnetPwdP5=fciTelnetPwdP5, dcmAlrmFaxTrapSend=dcmAlrmFaxTrapSend, fclX25MlpPstnOverflowTable=fclX25MlpPstnOverflowTable, fclX25CfaSignallingEntry=fclX25CfaSignallingEntry, fmsFrLineId=fmsFrLineId, fmOsiISISRAPathCost=fmOsiISISRAPathCost, dcvToneGenProfileId=dcvToneGenProfileId, frxNodeStateChange=frxNodeStateChange, fmOspfStandardAreaRangeAreaID=fmOspfStandardAreaRangeAreaID, fclX25CfnDlnOutgoingChannelNumbering=fclX25CfnDlnOutgoingChannelNumbering, fclSdlcSecLpCallRetryCount=fclSdlcSecLpCallRetryCount, fcCtlErrorIndex=fcCtlErrorIndex, fclFrCfsGenDlcSetupAlarmThreshold=fclFrCfsGenDlcSetupAlarmThreshold, fclFraLogPortEntry=fclFraLogPortEntry, fmsFrLpLogPortId=fmsFrLpLogPortId, fmsFrLpSvcBookingRate=fmsFrLpSvcBookingRate, vcmAlrmSwEntry=vcmAlrmSwEntry, fclFrPvcSnaBanT1ReplyTimer=fclFrPvcSnaBanT1ReplyTimer, mcx104=mcx104, fcfLineModXidStringElement=fcfLineModXidStringElement, cfConfigurationDate=cfConfigurationDate, fcxServStaticName=fcxServStaticName, fcfLineModUnuseTimer=fcfLineModUnuseTimer, vcvFxxConfDelayBeforeDialing=vcvFxxConfDelayBeforeDialing, fmsFrDlcInOctets=fmsFrDlcInOctets, fmOspfStandardHostIpAddress=fmOspfStandardHostIpAddress, fdpTestDiagCode=fdpTestDiagCode, fclX25SlpPstnBackStatus=fclX25SlpPstnBackStatus, fclX25AccPvcLogPortId=fclX25AccPvcLogPortId, fmOsiISISSysL2State=fmOsiISISSysL2State, fclAsynCfgSerCallReturnTransmission=fclAsynCfgSerCallReturnTransmission, dclFrLmiParaN392ErrorThreshold=dclFrLmiParaN392ErrorThreshold, fclAsynCfgX3ModifCount=fclAsynCfgX3ModifCount, fcbBrdgVirtualPortTable=fcbBrdgVirtualPortTable, fmuFunctionLz77Compression=fmuFunctionLz77Compression, fcsnaLvpTrParamNW=fcsnaLvpTrParamNW, fciTelnetUserLogin=fciTelnetUserLogin, fcfLineV35DteTi142=fcfLineV35DteTi142, fcxServStaticCircuitId=fcxServStaticCircuitId, fclAsynAutoCalledAddr=fclAsynAutoCalledAddr, fclAsynVdxLpPceSubThreshold=fclAsynVdxLpPceSubThreshold, fclX25InPstn=fclX25InPstn, frxSoftware=frxSoftware, fmeTrapFamilyId=fmeTrapFamilyId, fclFraLmiN391FullStatusPollCount=fclFraLmiN391FullStatusPollCount, fclX25CfnSigConversionOutgoingCall=fclX25CfnSigConversionOutgoingCall, fmHardwareId=fmHardwareId, dcvRemoteConfName=dcvRemoteConfName, fciBootPInterfaceTable=fciBootPInterfaceTable, vcvRemNetIpAddress=vcvRemNetIpAddress, fmsLineId=fmsLineId, fclAsynGenParLanguageType=fclAsynGenParLanguageType, fcwFrAnnexeGInternalStacksMaxCount=fcwFrAnnexeGInternalStacksMaxCount, fclBSctConnectionEntry=fclBSctConnectionEntry, fcvRvpConvMultiCallingAddrInCall=fcvRvpConvMultiCallingAddrInCall, fmsS0BChIfCallingAddress=fmsS0BChIfCallingAddress, fmsFrLpLmiUserT391=fmsFrLpLmiUserT391, fclX25SlpIsdnBackLogPortId=fclX25SlpIsdnBackLogPortId, fmOspfStandardVirtNbrRtrId=fmOspfStandardVirtNbrRtrId, dcmAlrmSCTrapSend=dcmAlrmSCTrapSend, dcvVoiceProfMaximumFaxSpeed=dcvVoiceProfMaximumFaxSpeed, fcfLineModInitString=fcfLineModInitString, fmStatS2=fmStatS2, dcfConfLineTable=dcfConfLineTable, fclAsynX28PlusRemCfgX3P03ForwardingChar=fclAsynX28PlusRemCfgX3P03ForwardingChar, fmsIpLanOutRequestsCounter=fmsIpLanOutRequestsCounter, fciOspfAreaRangesEntry=fciOspfAreaRangesEntry, dcvVoiceLogPortId=dcvVoiceLogPortId, fclX25CfnNegMaxOutWindowSize=fclX25CfnNegMaxOutWindowSize, fclFrConfigCeTeEntry=fclFrConfigCeTeEntry, fcxServStaticServiceEntry=fcxServStaticServiceEntry, fmsFrDlcEntry=fmsFrDlcEntry, fciTelnetPwdP1=fciTelnetPwdP1, dcvVoiceSuscrStatus=dcvVoiceSuscrStatus, fciFlowSubstFlowId=fciFlowSubstFlowId, fclX25CfaModificationCount=fclX25CfaModificationCount, fclX25CfaPackPdnCallingSubAddress=fclX25CfaPackPdnCallingSubAddress, fmsSig125=fmsSig125, fclAsynNetUserEntry=fclAsynNetUserEntry, fclFrMainLPId=fclFrMainLPId, fciFlowDestIpAddress=fciFlowDestIpAddress, fcwRoutLogPortId=fcwRoutLogPortId, fclFrTeParGenNetworkBandwidth=fclFrTeParGenNetworkBandwidth, fcwConvCondOutExternalAddr=fcwConvCondOutExternalAddr, fcxCircLvpStatus=fcxCircLvpStatus, fclAsynCfgConnFacilityEntry=fclAsynCfgConnFacilityEntry, fmOspfStandardVirtIfState=fmOspfStandardVirtIfState, fmsInArpVpOutRequests=fmsInArpVpOutRequests, fmsFrDataLinkConnection=fmsFrDataLinkConnection, fclX25AccPrivateNetTable=fclX25AccPrivateNetTable, fmsGlobGeneratorsInUseCount=fmsGlobGeneratorsInUseCount, cfConfigurationEdition=cfConfigurationEdition, fcvLvpFltFilterStatus=fcvLvpFltFilterStatus, fclAsynMneTransAutoTermMode=fclAsynMneTransAutoTermMode, fcmMgtFctCugClosedUserGroupExt=fcmMgtFctCugClosedUserGroupExt, fcSystem=fcSystem, fclX25InDIsdnRemotePeerEntry=fclX25InDIsdnRemotePeerEntry, fciEgp=fciEgp, fcfLineV35DteInterfaceId=fcfLineV35DteInterfaceId, cfNumberOfLines=cfNumberOfLines, fcmAlrmPpPhysPort6=fcmAlrmPpPhysPort6, fcvRemoteVirtualPorts=fcvRemoteVirtualPorts, fmsEthInUcastPktsCounter=fmsEthInUcastPktsCounter, mcx212Y=mcx212Y, vcvEMConfigTable=vcvEMConfigTable, vcvAnalogLineInterfaceId=vcvAnalogLineInterfaceId, fccNeighType=fccNeighType, fcwSResConversionIncomingCall=fcwSResConversionIncomingCall, fclAsynCfgFacMinOutPacketSize=fclAsynCfgFacMinOutPacketSize, fciNetToMediaIpAddress=fciNetToMediaIpAddress, fmeEvtData=fmeEvtData, fmPingProtocol=fmPingProtocol, vcvToneDuration1=vcvToneDuration1, fcxRoutCircuitEntry=fcxRoutCircuitEntry, fclAsynCfgFacDefInWindowSize=fclAsynCfgFacDefInWindowSize, fcvRvpConversionOutgoingCall=fcvRvpConversionOutgoingCall, fclAsynPadLpLogPortId=fclAsynPadLpLogPortId, dcvRemNetEncapsulation=dcvRemNetEncapsulation, fclX25CfnServiceTable=fclX25CfnServiceTable, fcwConvMultiInOrderNum=fcwConvMultiInOrderNum, fmStatIpRouter=fmStatIpRouter, fmOsiISISSysL1State=fmOsiISISSysL1State, fcwSResConversionOutgoingCall=fcwSResConversionOutgoingCall, hpb1025_12W=hpb1025_12W, fciOspfRouterId=fciOspfRouterId, fmOspfStandardRouterId=fmOspfStandardRouterId, fciOspfAreaRangesTable=fciOspfAreaRangesTable, fcfLineV28AsynOutDteRts105=fcfLineV28AsynOutDteRts105, fclFraPvcStatus=fclFraPvcStatus, fmsEthOutOctetsCounter=fmsEthOutOctetsCounter, fmsFrLineLmiStatus=fmsFrLineLmiStatus, fclAsynVdxLpPceNackTimer=fclAsynVdxLpPceNackTimer, fclAsynVdxLpTable=fclAsynVdxLpTable, fclFrCfcDescription=fclFrCfcDescription, fcvRvpConnRemoteAddress=fcvRvpConnRemoteAddress, fcvRvpConversionAimedPoint=fcvRvpConversionAimedPoint, fcsnaLvpMacAddressTrans=fcsnaLvpMacAddressTrans, fclBSctProtDef2DataFrameTerminator3=fclBSctProtDef2DataFrameTerminator3, fmOspfStandardIfBackupDesignatedRouter=fmOspfStandardIfBackupDesignatedRouter, vcvEMConfMinLineSeizureAckTime=vcvEMConfMinLineSeizureAckTime, fclFrSeInBIsdnLogPortTable=fclFrSeInBIsdnLogPortTable, fciRipEgpRoutesDistributionEntry=fciRipEgpRoutesDistributionEntry, vcwWanRouteEntry=vcwWanRouteEntry, dcmAlrmFaxTable=dcmAlrmFaxTable, vclLogicalPortTable=vclLogicalPortTable, fcsnaGpSdlcLp=fcsnaGpSdlcLp, fccRneighRemoteAddress=fccRneighRemoteAddress, fciOspfAseExportStaticsStatus=fciOspfAseExportStaticsStatus, fmOspfStandardOriginateNewLSAs=fmOspfStandardOriginateNewLSAs, dcmAlrmSwTrapSend=dcmAlrmSwTrapSend, fmStatStateTable=fmStatStateTable, fclX25CfaCugClosedUserGroupId=fclX25CfaCugClosedUserGroupId, fmPingAddress=fmPingAddress, fmStatIpLanTraffic=fmStatIpLanTraffic, fmhTechnicLineNb=fmhTechnicLineNb, fcfLineV28DceLl141=fcfLineV28DceLl141, fmsIpLanOutOctetsIpCounter=fmsIpLanOutOctetsIpCounter, fcfIsdnBasicRateInterfaceId=fcfIsdnBasicRateInterfaceId, fclVipCluElemCalledAddr=fclVipCluElemCalledAddr, cfField4=cfField4, fclAsynMneTransTranscoding=fclAsynMneTransTranscoding, vcCtlErrorIndex=vcCtlErrorIndex, fclX25CfaSigClearFormat=fclX25CfaSigClearFormat, frxManagementEvent=frxManagementEvent, fclBX780LpSurveyTimer=fclBX780LpSurveyTimer, fmPingOwner=fmPingOwner, fclPppCftConfigId=fclPppCftConfigId, fclX25CfaCugLogPortId=fclX25CfaCugLogPortId, fcwCallPacketsAcceptThreshold=fcwCallPacketsAcceptThreshold, fcwConvMultiOutConvID=fcwConvMultiOutConvID, fclIulInterfaceId=fclIulInterfaceId, fcxCircNetNumber=fcxCircNetNumber, fcfLineModXidStringEltStatus=fcfLineModXidStringEltStatus, fmsFrcStorageCir=fmsFrcStorageCir, cfUserField=cfUserField, fclAsynLpLogPortId=fclAsynLpLogPortId, fclAsynX28PlusLpConIdRemote=fclAsynX28PlusLpConIdRemote, dcWanSwitch=dcWanSwitch, sc300_4W=sc300_4W, fmsGlobCpuB=fmsGlobCpuB, fmOspfStandardNbrEntry=fmOspfStandardNbrEntry, fclX25MlpParameterEntry=fclX25MlpParameterEntry, fcwSCUDProfilesEntry=fcwSCUDProfilesEntry, fcmAlrmPpFamilyId=fcmAlrmPpFamilyId, fclX25CfaSerBe=fclX25CfaSerBe, fmRip2IfStatRcvBadRoutes=fmRip2IfStatRcvBadRoutes, fclX25CfnNegMaxInThroughputClass=fclX25CfnNegMaxInThroughputClass, fccVpMtu=fccVpMtu, fcfLineV28DceDtr108=fcfLineV28DceDtr108, fcfIsdnDSigIsdnNumber=fcfIsdnDSigIsdnNumber, fmStatLineTable=fmStatLineTable, fmStatWanConnectionsTable=fmStatWanConnectionsTable, fclFrCfsGenPredictionRoundTripDelay=fclFrCfsGenPredictionRoundTripDelay, fmsS0BChPhysIfId=fmsS0BChPhysIfId, fclPppCfgIpAddrAssignment=fclPppCfgIpAddrAssignment, fclFrPvcQosCos=fclFrPvcQosCos, dcvCASConfAlarmState=dcvCASConfAlarmState, fclBSctProtDef2RVI=fclBSctProtDef2RVI, fmPing=fmPing, fciOspfAseExportRipMetric=fciOspfAseExportRipMetric, fclAsynAutoFacThroughputClass=fclAsynAutoFacThroughputClass, fmeTrblInfoIndex=fmeTrblInfoIndex, fmPingEntry=fmPingEntry, fcfIsdnPriCountry=fcfIsdnPriCountry, dcvIpLocSvcCallRetryCount=dcvIpLocSvcCallRetryCount, fclAsynX28PlusCfgTELENETConfigId=fclAsynX28PlusCfgTELENETConfigId, fcFrSwitchingTable=fcFrSwitchingTable, fmOspfStandardIfState=fmOspfStandardIfState, vcvVoiceLogicalPortTable=vcvVoiceLogicalPortTable, fciOspfVpDRPriority=fciOspfVpDRPriority, fcbStpVirtualPortTable=fcbStpVirtualPortTable, fcsnaGpRoutBc=fcsnaGpRoutBc, vcvRemoteConfWanAddress=vcvRemoteConfWanAddress, fmsS2BChIfCalledAddress=fmsS2BChIfCalledAddress, fclSdlcSecClusterMinRecallTimer=fclSdlcSecClusterMinRecallTimer)
mibBuilder.exportSymbols("PCE-MIB", dcmAlrmSvcEntry=dcmAlrmSvcEntry, vcvVoiceSwOrderNumber=vcvVoiceSwOrderNumber, fclX25AccSwitchOverTable=fclX25AccSwitchOverTable, fclX25CfnDataLinkNetworkTable=fclX25CfnDataLinkNetworkTable, fciRipVpVersion=fciRipVpVersion, fmsInputReinitPktsCounter=fmsInputReinitPktsCounter, fmOspfStandardAreaLSACksumSum=fmOspfStandardAreaLSACksumSum, fmStatEthManagementEntry=fmStatEthManagementEntry, fclAsynAutoTransLpId=fclAsynAutoTransLpId, fcfLineV11DceControl105=fcfLineV11DceControl105, fcmMgfActPassword=fcmMgfActPassword, fclPppPstnAccess=fclPppPstnAccess, fclX25CfnNegMaxInWindowSize=fclX25CfnNegMaxInWindowSize, fmsFrLpLmiUserChanInactive=fmsFrLpLmiUserChanInactive, fcfLineModXidStringId=fcfLineModXidStringId, fmOsiISISCircRejAdjs=fmOsiISISCircRejAdjs, vcmAlrmFaxFamilyId=vcmAlrmFaxFamilyId, fcmMgfCallAcceptwithReverseCharging=fcmMgfCallAcceptwithReverseCharging, fclX25MlpIsdnRemotePeerTable=fclX25MlpIsdnRemotePeerTable, dcmAlrmSvcFamilyId=dcmAlrmSvcFamilyId, fmsPppAuthSlaveAuthentication=fmsPppAuthSlaveAuthentication, vclFrSeSigT200RetransTimer=vclFrSeSigT200RetransTimer, fclX25InBRemCheckPeriodCount=fclX25InBRemCheckPeriodCount, fmsEthOutErrExcdDelayCounter=fmsEthOutErrExcdDelayCounter, fmsS2BChOperStatus=fmsS2BChOperStatus, fclVipCluElementTable=fclVipCluElementTable, fcsnaLvpTrParamT1=fcsnaLvpTrParamT1, dcmAlrmVCEntry=dcmAlrmVCEntry, fmsPppProtoIpNcpDiag=fmsPppProtoIpNcpDiag, fciSnmpCommunityStringTrap=fciSnmpCommunityStringTrap, fclFrCfsModificationCount=fclFrCfsModificationCount, fcwAddrConvMultiCriterionOutCallTable=fcwAddrConvMultiCriterionOutCallTable, fmOspfStandardNbrState=fmOspfStandardNbrState, fciOspfAseExportRipType=fciOspfAseExportRipType, fmsBootPClientServerIpAddr=fmsBootPClientServerIpAddr, fclAsynX28PlusRemoteCfgX3Part1Table=fclAsynX28PlusRemoteCfgX3Part1Table, fclAsynNetStatus=fclAsynNetStatus, fclX25InDIsdnTable=fclX25InDIsdnTable, fclSdlcSecClusterAddress=fclSdlcSecClusterAddress, fclFrTeLpLogPortBackupEnabling=fclFrTeLpLogPortBackupEnabling, fciRipEgpRoutesStatus=fciRipEgpRoutesStatus, fcxServSapOutFltFiltering=fcxServSapOutFltFiltering, fclBSctProtDef1PermanentDelimiter2=fclBSctProtDef1PermanentDelimiter2, fclPppCfgNcpClnp=fclPppCfgNcpClnp, fccLvpEsIsRedirection=fccLvpEsIsRedirection, fmOsiCLNPCircuitEntry=fmOsiCLNPCircuitEntry, fcfPhysPortConnector=fcfPhysPortConnector, fclSdlcSecClusterCirmin=fclSdlcSecClusterCirmin, fmPingPacketSize=fmPingPacketSize, fcfIsdnRemotePeerEntry=fcfIsdnRemotePeerEntry, fcxInstance=fcxInstance, fccLvpVirtualPortId=fccLvpVirtualPortId, fcmMgfStatOutputThreshold=fcmMgfStatOutputThreshold, fclFrCfcStatus=fclFrCfcStatus, fmsFrLpAddrDlciLen=fmsFrLpAddrDlciLen, fclPppBIsdnRemotePeerTable=fclPppBIsdnRemotePeerTable, fmOspfStandardLsdbAge=fmOspfStandardLsdbAge, fcbBrdgVirtualPortEntry=fcbBrdgVirtualPortEntry, dclFrLmiParaStandard=dclFrLmiParaStandard, fmsBridgeState=fmsBridgeState, fclAsynCfgX3P20EchoMask=fclAsynCfgX3P20EchoMask, fclFrPvcStatus=fclFrPvcStatus, fcwSRvcConversionIncomingCall=fcwSRvcConversionIncomingCall, fclFrCfcSigT305DisconnectResponseTimer=fclFrCfcSigT305DisconnectResponseTimer, fmOsiISISRAAdjacencyId=fmOsiISISRAAdjacencyId, fciOspfVpRouterDeadInterval=fciOspfVpRouterDeadInterval, fmsInArpVpInverseArpStatus=fmsInArpVpInverseArpStatus, vcvVoiceSwEntry=vcvVoiceSwEntry, fcwSClearAnalysStatus=fcwSClearAnalysStatus, fclX25PstnRemStatus=fclX25PstnRemStatus, dcmAlrmLMITrapSend=dcmAlrmLMITrapSend, fclX25CfaClosedUserGroupEntry=fclX25CfaClosedUserGroupEntry, fmOsiISISISAdjCircIndex=fmOsiISISISAdjCircIndex, dcvCASConfSignallingTransport=dcvCASConfSignallingTransport, fmsS2BChAdminStatus=fmsS2BChAdminStatus, fcvRvpConnectionEntry=fcvRvpConnectionEntry, fcxRoutCircAddressFiltering=fcxRoutCircAddressFiltering, fmsInArpVpRemoteIpAddr=fmsInArpVpRemoteIpAddr, fclX25CfaDataLinkNetworkEntry=fclX25CfaDataLinkNetworkEntry, fmsS0BChAdminStatus=fmsS0BChAdminStatus, fmsEthTestMode=fmsEthTestMode, fcfLineModInterfaceId=fcfLineModInterfaceId, fclX25CfmFlowCtrlPacketSize=fclX25CfmFlowCtrlPacketSize, fmsFrLpOutLocalCongBecnFrames=fmsFrLpOutLocalCongBecnFrames, fcfIsdnDSigMulDialsCycleCount=fcfIsdnDSigMulDialsCycleCount, fcfIsdnDSigLowLayerCompatibility=fcfIsdnDSigLowLayerCompatibility, fmOspfStandardStubAreaTable=fmOspfStandardStubAreaTable, fmhEqIdThirdFactoryReturnDate=fmhEqIdThirdFactoryReturnDate, fclSdlcPriClusterRemPu2CalledAddr=fclSdlcPriClusterRemPu2CalledAddr, fciEgpAutonomousSystemNumber=fciEgpAutonomousSystemNumber, fmsPppAuthLineId=fmsPppAuthLineId, dcfDataLineTable=dcfDataLineTable, fclSdlcSecClusterTable=fclSdlcSecClusterTable, fciIpRouting=fciIpRouting, vcvRemoteConfTable=vcvRemoteConfTable, fclBX780IdentLogPortId=fclBX780IdentLogPortId, fclFrPvcTunDlci=fclFrPvcTunDlci, fclPppBIsdnBriLocalSubsNb1=fclPppBIsdnBriLocalSubsNb1, fcsnaGpSdlcCluster=fcsnaGpSdlcCluster, vcmAlrmTftpTrapSend=vcmAlrmTftpTrapSend, fcsnaLvpTrParamCompressNegotiation=fcsnaLvpTrParamCompressNegotiation, fcmMgtFctCugClosedUserGroupInt=fcmMgtFctCugClosedUserGroupInt, fciOspfAreasEntry=fciOspfAreasEntry, fclX25CfaSigConversionAddressCheck=fclX25CfaSigConversionAddressCheck, mcx300=mcx300, fclB3270CluCallCluAdd=fclB3270CluCallCluAdd, fcwSRvcOutputMarkers=fcwSRvcOutputMarkers, cfProductType=cfProductType, fclX25CfaSerX29Reselection=fclX25CfaSerX29Reselection, dcmAlrmTftpTable=dcmAlrmTftpTable, fclB3270CluCallLogPortId=fclB3270CluCallLogPortId, fcxCircuits=fcxCircuits, transProduct=transProduct, fclAsynMultiLpAuthStep4=fclAsynMultiLpAuthStep4, fclFrCfcLmiT391LinkIntegPollTimer=fclFrCfcLmiT391LinkIntegPollTimer, vcvRemNetStatus=vcvRemNetStatus, fclX25CfaSerConfigId=fclX25CfaSerConfigId, fclPppConfigTimersTable=fclPppConfigTimersTable, cfField2=cfField2, fclX25MlpIsdnRemLogPortId=fclX25MlpIsdnRemLogPortId, vcvProfileTone=vcvProfileTone, fclAsynCfgSerConversionOutgoingCall=fclAsynCfgSerConversionOutgoingCall, fmOsiISISISAdjType=fmOsiISISISAdjType, vcvVoiceProfTransmitLevel=vcvVoiceProfTransmitLevel, fmOspfStandardIfMetricMetric=fmOspfStandardIfMetricMetric, fmsRvpConnLocalSbNumber=fmsRvpConnLocalSbNumber, fclX25CfaDlnTwoWayChannelCount=fclX25CfaDlnTwoWayChannelCount, dcfNumericLineTable=dcfNumericLineTable, dclFrLmiParaN393MonitoredEventCount=dclFrLmiParaN393MonitoredEventCount, fclPppSerLpLogPortId=fclPppSerLpLogPortId, fmsPppProtoLcpStatus=fmsPppProtoLcpStatus, fclX25InBIsdnInterfaceId=fclX25InBIsdnInterfaceId, fdPhysicalPorts=fdPhysicalPorts, fcfLines=fcfLines, fclSdlcSecClusterFacThroughputClass=fclSdlcSecClusterFacThroughputClass, fclX25CfaSigSubAddressTransmission=fclX25CfaSigSubAddressTransmission, fcmAlrmPpPhysPort2=fcmAlrmPpPhysPort2, fmsEthAutoPortSelection=fmsEthAutoPortSelection, fclFrSeIsdnBackupTable=fclFrSeIsdnBackupTable, fclBSctProtDef2DataFrameTerminator2=fclBSctProtDef2DataFrameTerminator2, vcvEMConfClearToIncCallTime=vcvEMConfClearToIncCallTime, vcvVoiceTransportTable=vcvVoiceTransportTable, fclFraLpAllDiscardThreshold=fclFraLpAllDiscardThreshold, vcvVoiceVirtualPortId=vcvVoiceVirtualPortId, fmOsiISISSysInPdu=fmOsiISISSysInPdu, fclFrConfigurationCeTe=fclFrConfigurationCeTe, fclX25CfaDlnStationType=fclX25CfaDlnStationType, vclFrSeSigT310CallProceedingTimer=vclFrSeSigT310CallProceedingTimer, frx2000Y=frx2000Y, fcxCircOperState=fcxCircOperState, fccLocalVirtualPortEntry=fccLocalVirtualPortEntry, fcbStpPriority=fcbStpPriority, fclAsynX28PlusRemCfgX3P08OutputDiscard=fclAsynX28PlusRemCfgX3P08OutputDiscard, fmsE1Ds1ChIfOutUcastPkts=fmsE1Ds1ChIfOutUcastPkts, dcwABPvcLpTable=dcwABPvcLpTable, fcwFrFecnBecnOfAllFramesThreshold=fcwFrFecnBecnOfAllFramesThreshold, fcxServSapInFltServiceName=fcxServSapInFltServiceName, fclB3270CluLogPortEntry=fclB3270CluLogPortEntry, fmhTechnicTokenRingPresence=fmhTechnicTokenRingPresence, fmOspfStandardVirtNbrState=fmOspfStandardVirtNbrState, vcvVoiceSuscriberEntry=vcvVoiceSuscriberEntry, vcfConfLineInterfaceId=vcfConfLineInterfaceId, fmsFrCircuitOutOctetsCounter=fmsFrCircuitOutOctetsCounter, fclFrPvcSnaNwIncrementAckCount=fclFrPvcSnaNwIncrementAckCount, fcxRipCircUpdate=fcxRipCircUpdate, fcvVpStatus=fcvVpStatus, fmuFunctionIpxRouter=fmuFunctionIpxRouter, cmeClearEvent=cmeClearEvent, fclX25CfaSigCallAcceptedFormat=fclX25CfaSigCallAcceptedFormat, fmsSig107=fmsSig107, vcmAlrmSCTable=vcmAlrmSCTable, fclAsynX28PlusRemoteTELENETEntry=fclAsynX28PlusRemoteTELENETEntry, fcfLineV28AsynOutDteSignalEntry=fcfLineV28AsynOutDteSignalEntry, fclAsynNetUserId=fclAsynNetUserId, dcvCASConfigTable=dcvCASConfigTable, fclBX780ConnLogPortId=fclBX780ConnLogPortId, fcsnaLvpTrParamCompression=fcsnaLvpTrParamCompression, fclX25InBIsdn=fclX25InBIsdn, fclFrPvcCallDirection=fclFrPvcCallDirection, fclX25CfnDlnT2AcknowledgeDelayTimer=fclX25CfnDlnT2AcknowledgeDelayTimer, fclAsynCfgX3UserP02Echo=fclAsynCfgX3UserP02Echo, fcbStpForwardDelay=fcbStpForwardDelay, fciSnmpManagerIpAddress=fciSnmpManagerIpAddress, fmOspfStandardNbrAddressLessIndex=fmOspfStandardNbrAddressLessIndex, dcvTSPCMSwTable=dcvTSPCMSwTable, fclPppBIsdnRemLinkCheckPeriod=fclPppBIsdnRemLinkCheckPeriod, fclX25SlpBackupTimer=fclX25SlpBackupTimer, dcmAlrmVCFamilyId=dcmAlrmVCFamilyId, fclX25CfnNegConfigId=fclX25CfnNegConfigId, fclSdlcSecLpT1AcknowledgeTimer=fclSdlcSecLpT1AcknowledgeTimer, fmStatEthOutputTrafficTable=fmStatEthOutputTrafficTable, fclPppCfgNcpIp=fclPppCfgNcpIp, fcCtlAlteredLpEntry=fcCtlAlteredLpEntry, fcfIsdnDChannelSigTimerTable=fcfIsdnDChannelSigTimerTable, fclAsynX28PlusRemoteCfgX3Part2Table=fclAsynX28PlusRemoteCfgX3Part2Table, fclFrCeParGenVoiceMaxTransitDelay=fclFrCeParGenVoiceMaxTransitDelay, dcmAlrmTftpTrapSend=dcmAlrmTftpTrapSend, fclFrCfcGenInactivityTimer=fclFrCfcGenInactivityTimer, fciRipVpRipIn=fciRipVpRipIn, vcvSnmpGenCommunityStringTrap=vcvSnmpGenCommunityStringTrap, fclBX780LpInterfaceId=fclBX780LpInterfaceId, fclPppPstnLpLocalSubscriberNb=fclPppPstnLpLocalSubscriberNb, dcmAlrmSyncTyp=dcmAlrmSyncTyp, fclFraPvcCalledAddr=fclFraPvcCalledAddr, fccVpStatus=fccVpStatus, fmsIpTrafInOctetsCounter=fmsIpTrafInOctetsCounter, fcfE1PhysPortTable=fcfE1PhysPortTable, fclFrConfigCeTeTable=fclFrConfigCeTeTable, fclX25MlpX25InterNodeConfigId=fclX25MlpX25InterNodeConfigId, fcsnaGpLanFrEntry=fcsnaGpLanFrEntry, fcfLineModCallDirection=fcfLineModCallDirection, fmsSig105=fmsSig105, dcvTSPCMSwLogPortSetId=dcvTSPCMSwLogPortSetId, fciTelnetConfiguration=fciTelnetConfiguration, fclFrTeIsdnRemStatus=fclFrTeIsdnRemStatus, fmOsiISISSysOutPdu=fmOsiISISSysOutPdu, fcwSbRoutingTable=fcwSbRoutingTable, fccLocalNetworkEntityTitle=fccLocalNetworkEntityTitle, fclFrCfsSigT305DisconnectResponseTimer=fclFrCfsSigT305DisconnectResponseTimer, dcvVoiceTransVoicePacketsCombination=dcvVoiceTransVoicePacketsCombination, dcvTSPCMSwRemoteNumber=dcvTSPCMSwRemoteNumber, fclFrCfsConfigId=fclFrCfsConfigId, fclX25CfaSigConvMultiCallingAddrInCall=fclX25CfaSigConvMultiCallingAddrInCall, fclBSctLogPortTable=fclBSctLogPortTable, vcvVoiceTransportEntry=vcvVoiceTransportEntry, fclX25PstnX25InterNodeConfigId=fclX25PstnX25InterNodeConfigId, fcwFrDeFramesDiscardThreshold=fcwFrDeFramesDiscardThreshold, fciOspfAreaId=fciOspfAreaId, fmRip2IfConfDomain=fmRip2IfConfDomain, fclX25InDIsdn=fclX25InDIsdn, fclFrCommunicationEquipment=fclFrCommunicationEquipment, fclIulLogPortId=fclIulLogPortId, dcfDataLineRate=dcfDataLineRate, vcfConfLineRate=vcfConfLineRate, fcwRoutChannelId=fcwRoutChannelId, fmsFrLpInBecnFrames=fmsFrLpInBecnFrames, dcvRemNetWanAddress=dcvRemNetWanAddress, fcCtlBootDevice=fcCtlBootDevice, fcsnaLvpParamCallDirection=fcsnaLvpParamCallDirection, fclAsynCfgX3Part1Entry=fclAsynCfgX3Part1Entry, fclAsynCfgX3UserP20EchoMask=fclAsynCfgX3UserP20EchoMask, fclX25InDSwSwitchThreshold=fclX25InDSwSwitchThreshold, fclFrCfsDescription=fclFrCfsDescription, fclAsynCfgSerCompressNegociation=fclAsynCfgSerCompressNegociation, fcwConvInStatus=fcwConvInStatus, fclB3270CluCallTable=fclB3270CluCallTable, fciOspfVlNeighborId=fciOspfVlNeighborId, fmOspfStandardAreaBdrRtrStatus=fmOspfStandardAreaBdrRtrStatus, vcvIpLocSvcClearCallTimer=vcvIpLocSvcClearCallTimer, fmeEventTable=fmeEventTable, fclPppSerAutoMinimumRecallTimer=fclPppSerAutoMinimumRecallTimer, vcvVoiceProfNoiseFramesPeriodicity=vcvVoiceProfNoiseFramesPeriodicity, fcfIsdnDTimT308ReleaseResponseTimer=fcfIsdnDTimT308ReleaseResponseTimer, fclVipCluStationTable=fclVipCluStationTable)
mibBuilder.exportSymbols("PCE-MIB", fcxRipInFltStatus=fcxRipInFltStatus, fmsStateOsiState=fmsStateOsiState, fmsIpTrafOutForwDefRouteCounter=fmsIpTrafOutForwDefRouteCounter, fclX25MlpDARApplicable=fclX25MlpDARApplicable, dcmAlrmSwTyp=dcmAlrmSwTyp, fcfIsdnDChannelSignallingTable=fcfIsdnDChannelSignallingTable, fmsInputCallPktsCounter=fmsInputCallPktsCounter, fmuAccessFrseLineNbMax=fmuAccessFrseLineNbMax, vcmAlrmFaxTrapSend=vcmAlrmFaxTrapSend, fclFraLmiN392ErrorThreshold=fclFraLmiN392ErrorThreshold, fclX25InDIsdnBackupEntry=fclX25InDIsdnBackupEntry, fclPppSerialLinkAccess=fclPppSerialLinkAccess, vcmAlrmTftpEntry=vcmAlrmTftpEntry, fclInterUnitLinkEntry=fclInterUnitLinkEntry, vcvVoiceSwStatus=vcvVoiceSwStatus, dcwEquipSVCDisconnectOnCongestion=dcwEquipSVCDisconnectOnCongestion, frxLoadAndTrafficEvent=frxLoadAndTrafficEvent, fcxServSapInFltStatus=fcxServSapInFltStatus, fclHdlcAutoLogPortId=fclHdlcAutoLogPortId, fmuAccessCvfLineNbMax=fmuAccessCvfLineNbMax, fclSdlcLpCos=fclSdlcLpCos, fciFlowSrcIpAddress=fciFlowSrcIpAddress, fmStatEthernetEntry=fmStatEthernetEntry, fcfLineV28DceSyn=fcfLineV28DceSyn, dcvTftpInactTimer=dcvTftpInactTimer, dcvCASConfTimeBetweenSuccOutCall=dcvCASConfTimeBetweenSuccOutCall, fcBridge=fcBridge, fciOspfAreaRangeAreaId=fciOspfAreaRangeAreaId, fclPppBIsdnLogPortTable=fclPppBIsdnLogPortTable, fcsnaGpRoutBe=fcsnaGpRoutBe, fmsStateMlpTrunkState=fmsStateMlpTrunkState, fclX25SlpX25InterNodeConfigId=fclX25SlpX25InterNodeConfigId, fciBootPClientRetransNb=fciBootPClientRetransNb, fmhTechnicRamSize=fmhTechnicRamSize, fcwConvCondOutStatus=fcwConvCondOutStatus, fclAsynX28PlusRemCfgX3P22PageWait=fclAsynX28PlusRemCfgX3P22PageWait, dcvVoiceProfReceiveLevel=dcvVoiceProfReceiveLevel, fcwSerCompression=fcwSerCompression, vcwEquipDnicZoAddr=vcwEquipDnicZoAddr, vcvVoiceTransCompressionAlgorithm=vcvVoiceTransCompressionAlgorithm, fclSdlcLpInterfaceId=fclSdlcLpInterfaceId, fclFrPvcSnaBanEncapsulationTable=fclFrPvcSnaBanEncapsulationTable, fcsnaGpLanFrMacAddress=fcsnaGpLanFrMacAddress, fclAsynCfgConnModifCount=fclAsynCfgConnModifCount, fcxServCircSapCircuitId=fcxServCircSapCircuitId, fmsBootPRelayVirtualPortId=fmsBootPRelayVirtualPortId, fmPingIdentifier=fmPingIdentifier, fmuFunctionRouterAndBridge=fmuFunctionRouterAndBridge, fclSdlcSecClusterCalledAddr=fclSdlcSecClusterCalledAddr, fcxRoutStaticRouteStatus=fcxRoutStaticRouteStatus, fciEgpStaticRoutesDistribution=fciEgpStaticRoutesDistribution, dcvVoicePhysPortConnector=dcvVoicePhysPortConnector, vcmAlrmVCFamilyId=vcmAlrmVCFamilyId, fcwFrVoiceMaxTransitDelay=fcwFrVoiceMaxTransitDelay, fclAsynX28PlusConfRemoteTable=fclAsynX28PlusConfRemoteTable, fciOspfAreasTable=fciOspfAreasTable, fclX25AccPstnBackupTable=fclX25AccPstnBackupTable, fciRouteDest=fciRouteDest, fclX25SlpSwMeasureCount=fclX25SlpSwMeasureCount, fclAsynLpTerminalType=fclAsynLpTerminalType, fmsEthInErrCollCounter=fmsEthInErrCollCounter, cfStartUpChoiceAfterReset=cfStartUpChoiceAfterReset, products=products, fcbBridgingBetweenRemoteVp=fcbBridgingBetweenRemoteVp, fcbStpVirtualPortEntry=fcbStpVirtualPortEntry, fclBSctLpCodingParityType=fclBSctLpCodingParityType, fcxRipSysState=fcxRipSysState, fcfLineModemEntry=fcfLineModemEntry, dclLogPortStatus=dclLogPortStatus, fcwSCompModule1CompressedVcCount=fcwSCompModule1CompressedVcCount, fcfLineModInputXidStringCount=fcfLineModInputXidStringCount, vcvRemoteNetToMediaEntry=vcvRemoteNetToMediaEntry, fcfIsdnRemRemotePeerId=fcfIsdnRemRemotePeerId, fclAsynNetNui=fclAsynNetNui, fcCtlAlteredDlciState=fcCtlAlteredDlciState, fclX25CfnNegDefInPacketSize=fclX25CfnNegDefInPacketSize, fclFrCfcEiCodCalledTypNum=fclFrCfcEiCodCalledTypNum, fclFrSeIsdnRemotePeerEntry=fclFrSeIsdnRemotePeerEntry, fclFrCfcSigT310CallProceedingTimer=fclFrCfcSigT310CallProceedingTimer, dcCtlErrorMessage=dcCtlErrorMessage, dcvToneTable=dcvToneTable, fcvVirtualPortTable=fcvVirtualPortTable, fclFrPvcSnaBanPuId=fclFrPvcSnaBanPuId, fclFrTeIsdnBackLogPortId=fclFrTeIsdnBackLogPortId, fcFrSwOutputDlci=fcFrSwOutputDlci, fmPingSentPackets=fmPingSentPackets, fcmMgtFctCugEntry=fcmMgtFctCugEntry, vclLogicalPortEntry=vclLogicalPortEntry, fmsBrdgTrafOutServCounter=fmsBrdgTrafOutServCounter, fmuAccessRnisChannelBNbMax=fmuAccessRnisChannelBNbMax, vcwEquipVoiceRoutingServicePortAddr=vcwEquipVoiceRoutingServicePortAddr, fcbStpHelloTime=fcbStpHelloTime, vcvFxxRingTopDuration=vcvFxxRingTopDuration, fmhTechnicEthernetPresence=fmhTechnicEthernetPresence, dcmAlrmCmpTable=dcmAlrmCmpTable, fclHdlcAutoInactivityTimer=fclHdlcAutoInactivityTimer, dcLogicalPorts=dcLogicalPorts, fclAsynMultiLpTable=fclAsynMultiLpTable, fclAsynVdxPageStatus=fclAsynVdxPageStatus, fclAsynCfgSerMinCir=fclAsynCfgSerMinCir, fclFrCfcSigConfigId=fclFrCfcSigConfigId, fmOsiISISRACircuitId=fmOsiISISRACircuitId, vcvEMConfLineInterfacePolarity=vcvEMConfLineInterfacePolarity, fclVipLpPrinterMessagesManagement=fclVipLpPrinterMessagesManagement, fclFrCfcEiCodCalledNumPlanId=fclFrCfcEiCodCalledNumPlanId, fcxServSapOutFltServiceName=fcxServSapOutFltServiceName, fclSdlcPriClusterStatus=fclSdlcPriClusterStatus, fclPppConfigurationsEntry=fclPppConfigurationsEntry, fclFrCfsProfileId=fclFrCfsProfileId, fcsnaGpRoutCirmin=fcsnaGpRoutCirmin, fclBSctLpLinkType=fclBSctLpLinkType, fciOspfAdminStatus=fciOspfAdminStatus, fmOspfStandardVirtIfAuthKey=fmOspfStandardVirtIfAuthKey, fclHdlcAccessLogPort=fclHdlcAccessLogPort, pce=pce, fcvRvpConnCallDirection=fcvRvpConnCallDirection, fmsIpTrafInUnknownProtosCounter=fmsIpTrafInUnknownProtosCounter, fmhEqIdFirstFactoryReturnDate=fmhEqIdFirstFactoryReturnDate, vcCtlErrorEntry=vcCtlErrorEntry, fciFlowStatus=fciFlowStatus, vcvToneTable=vcvToneTable, dcmAlrmGenFamilyId=dcmAlrmGenFamilyId, vcvFxxRingEntry=vcvFxxRingEntry, dcvVoiceTransJitterCompensation=dcvVoiceTransJitterCompensation, fmsFrLpInLogPortId=fmsFrLpInLogPortId, fclAsynCfgFacThroughputClass=fclAsynCfgFacThroughputClass, fmsFrDlcIncomingTable=fmsFrDlcIncomingTable, fciOspfNeighborsTable=fciOspfNeighborsTable, vcvIpLocRouteNextHop=vcvIpLocRouteNextHop, fclX25ConfigAccessTable=fclX25ConfigAccessTable, fcfLineV28DteSyn=fcfLineV28DteSyn, fclFrCfcSigN200RetransMaxCount=fclFrCfcSigN200RetransMaxCount, fmuFunctionDPacket=fmuFunctionDPacket, fclFrCfcGeneralParameterEntry=fclFrCfcGeneralParameterEntry, fclPppCftLcpEchoRequestPeriod=fclPppCftLcpEchoRequestPeriod, fclFrPvcSnaConnTestEnabling=fclFrPvcSnaConnTestEnabling, fclFrPvcSnaBanLinkId=fclFrPvcSnaBanLinkId, fcxRoutAddressFilteringTable=fcxRoutAddressFilteringTable, fclAsynMneTransMnemonicId=fclAsynMneTransMnemonicId, fmOspfStandardIfType=fmOspfStandardIfType, vcfNumericLineInterfaceId=vcfNumericLineInterfaceId, fcfTokenRingCheckPeriodCount=fcfTokenRingCheckPeriodCount, fclAsynX28PlusParTelLpX3Mode=fclAsynX28PlusParTelLpX3Mode, dcvIpLocalTable=dcvIpLocalTable, fcfLineV28AsynInDteSigMonitored1=fcfLineV28AsynInDteSigMonitored1, fmsFrLpInOctets=fmsFrLpInOctets, fcxRoutAddrFltStatus=fcxRoutAddrFltStatus, frxConfig=frxConfig, fcfLineModXidStringEltNum=fcfLineModXidStringEltNum, fclAsynCfgX3P11BinarySpeed=fclAsynCfgX3P11BinarySpeed, fclX25MlpParamLogPortId=fclX25MlpParamLogPortId, dcmAlrmSwTable=dcmAlrmSwTable, vcmAlrmVCTable=vcmAlrmVCTable, dclFrTeLpLogPortId=dclFrTeLpLogPortId, fmsPppProtoBrdgNcpDiag=fmsPppProtoBrdgNcpDiag, dcvToneProfileId=dcvToneProfileId, fcwSRvcConversionOutgoingCall=fcwSRvcConversionOutgoingCall, dclLogPortType=dclLogPortType, fcvRvpConversionAddressCheck=fcvRvpConversionAddressCheck, fclAsynCfgSerDBitModification=fclAsynCfgSerDBitModification, fmsEthInPktsTooLongsCounter=fmsEthInPktsTooLongsCounter, fmsS2BChIfSpeed=fmsS2BChIfSpeed, vclFrLmiParaT391LinkIntegPollTimer=vclFrLmiParaT391LinkIntegPollTimer, fcvRvpConnInactivityTimer=fcvRvpConnInactivityTimer, fcsConfigDescAuthor=fcsConfigDescAuthor, fmsStateMlpTrunkNumber=fmsStateMlpTrunkNumber, fclAsynCfgLinkInactivityTimer=fclAsynCfgLinkInactivityTimer, fclX25CfaNegThroughputClass=fclX25CfaNegThroughputClass, mmx5000=mmx5000, fcsnaGpX25Status=fcsnaGpX25Status, fclX25CfnModificationCount=fclX25CfnModificationCount, fclAsynAutoVdxKeyTranslationEntry=fclAsynAutoVdxKeyTranslationEntry, fclX25CfaSigConvMultiCalledAddrInCall=fclX25CfaSigConvMultiCalledAddrInCall, fclAsynCfgX3P18LineDisplay=fclAsynCfgX3P18LineDisplay, fclBX780LpDeconnectTimer=fclBX780LpDeconnectTimer, fmsS2BChProto=fmsS2BChProto, fclX25CfnNegMaxOutThroughputClass=fclX25CfnNegMaxOutThroughputClass, fccNeighClnpAddress=fccNeighClnpAddress, fclVipCluLpFailedPollingMaxNumber=fclVipCluLpFailedPollingMaxNumber, fclX25SlpSwSwitchThreshold=fclX25SlpSwSwitchThreshold, fmuAccessBscTranspLineNbMax=fmuAccessBscTranspLineNbMax, fclX25AccPvcFacility=fclX25AccPvcFacility, vcFrSwL1MuxEnable=vcFrSwL1MuxEnable, fclAsynCfgX3UserP03ForwardingChar=fclAsynCfgX3UserP03ForwardingChar, fmRip2IfStatTable=fmRip2IfStatTable, dcvIpLocMtu=dcvIpLocMtu, fmsFrLpLmiLogPortId=fmsFrLpLmiLogPortId, fmuFunctionExploitMibUse=fmuFunctionExploitMibUse, fcfLineV11DteIndication109=fcfLineV11DteIndication109, fciRipVpDistribution=fciRipVpDistribution, fclPppCftConfigureMaxCount=fclPppCftConfigureMaxCount, fclX25CfaPackingTable=fclX25CfaPackingTable, vcwEquipSVCDisconnectOnCongestion=vcwEquipSVCDisconnectOnCongestion, dcvIfPCMPhysIfId=dcvIfPCMPhysIfId, vcvRemNetWanAddress=vcvRemNetWanAddress, fclAsynCfgX3P01EscapeChar=fclAsynCfgX3P01EscapeChar, fclFrPvcTrafficManagementStrategy=fclFrPvcTrafficManagementStrategy, fmOspfStandardNbrOptions=fmOspfStandardNbrOptions, dclFrSeSigT303SetupResponseTimer=dclFrSeSigT303SetupResponseTimer, fcvLocalVirtualPortTable=fcvLocalVirtualPortTable, fcfE1Ds1PhysEntry=fcfE1Ds1PhysEntry, fciFlowRouteStatus=fciFlowRouteStatus, fmOsiISISSysAuthFails=fmOsiISISSysAuthFails, fmsIpTrafOutForwDatagramsCounter=fmsIpTrafOutForwDatagramsCounter, vcvVoiceProfEchoCancellationLength=vcvVoiceProfEchoCancellationLength, fclAsynVdxLpMnemonicType=fclAsynVdxLpMnemonicType, fcxRipOutFltFilterId=fcxRipOutFltFilterId, vcmAlrmSwTrapSend=vcmAlrmSwTrapSend, fmOspfStandardLsdbAreaId=fmOspfStandardLsdbAreaId, fmsS2BChIfInOctets=fmsS2BChIfInOctets, fclBX780LpENQRetransTimer=fclBX780LpENQRetransTimer, fcxServStaticHopCount=fcxServStaticHopCount, vcmAlrmLMIDisplay=vcmAlrmLMIDisplay, fclX25CfaSigInPacketCauseField=fclX25CfaSigInPacketCauseField, fciOspfAsePreference=fciOspfAsePreference, fcfIsdnDSigMulDialsRetryTimer=fcfIsdnDSigMulDialsRetryTimer, fmsIpLanInOctetsIpCounter=fmsIpLanInOctetsIpCounter, fclAsynX28PlusLpMonSignalDCD=fclAsynX28PlusLpMonSignalDCD, vcvEMConfMaxLineSeizureAckTime=vcvEMConfMaxLineSeizureAckTime, fclAsynAutoStatus=fclAsynAutoStatus, fclFraLpLogPortId=fclFraLpLogPortId, fciVpIpAddress=fciVpIpAddress, fclSdlcSecClusterCos=fclSdlcSecClusterCos, dcvVoiceGen=dcvVoiceGen, fclX25CfaSerCos=fclX25CfaSerCos, fclEthLogPortId=fclEthLogPortId, fclAsynCfgX3UserP18LineDisplay=fclAsynCfgX3UserP18LineDisplay, fclX25CfmTransmitFlowControl=fclX25CfmTransmitFlowControl, vcvFxxLpEntry=vcvFxxLpEntry, fclX25SlpIsdnRemIsdnInterfaceId=fclX25SlpIsdnRemIsdnInterfaceId, fclFrPvcSnaRwReceiveWinSize=fclFrPvcSnaRwReceiveWinSize, fclX25SlpPstnBackLogPortId=fclX25SlpPstnBackLogPortId, fclAsynCfgFacMaxOutPacketSize=fclAsynCfgFacMaxOutPacketSize, fclFrPvcQosInCir=fclFrPvcQosInCir, vcCtlHour=vcCtlHour, dcvVoiceProfLoopActivation=dcvVoiceProfLoopActivation, fclFraPvcCallDirection=fclFraPvcCallDirection, fclX25PstnRemotePeerEntry=fclX25PstnRemotePeerEntry, fccNeighborEntry=fccNeighborEntry, fciOspfAreaRangeRestrict=fciOspfAreaRangeRestrict, fclSdlcPriClusterLogPortId=fclSdlcPriClusterLogPortId, fclFrCfcSigConversionAimedPoint=fclFrCfcSigConversionAimedPoint, fclAsynPadLpMnemonicType=fclAsynPadLpMnemonicType, fclX25MlpLink3InterfaceId=fclX25MlpLink3InterfaceId, fciLclStatus=fciLclStatus, fmsEthOutMultipleCollisionFramesCounter=fmsEthOutMultipleCollisionFramesCounter, dcControl=dcControl, fmhEqIdFourthFactoryReturnDate=fmhEqIdFourthFactoryReturnDate, fcfPhysicalPortEntry=fcfPhysicalPortEntry, fclX25CfaDlnOutgoingChannelNumbering=fclX25CfaDlnOutgoingChannelNumbering, fcxRipOutputFilteringTable=fcxRipOutputFilteringTable, fmsFrcStorageDirection=fmsFrcStorageDirection, vcvFxxLpSetId=vcvFxxLpSetId, dclFrTeLogPortTable=dclFrTeLogPortTable)
mibBuilder.exportSymbols("PCE-MIB", vclFrSeSigT303SetupResponseTimer=vclFrSeSigT303SetupResponseTimer, fcfLineV11DceInterfaceId=fcfLineV11DceInterfaceId, spb2033=spb2033, fcfLineV28DceSignalTable=fcfLineV28DceSignalTable, fclAsynPadPageBlocId=fclAsynPadPageBlocId, fclFrPvcX25InterNodeConfigId=fclFrPvcX25InterNodeConfigId, fciSnmpManagerEntry=fciSnmpManagerEntry, fcxRipCircPace=fcxRipCircPace, fclX25AccSwMeasureCount=fclX25AccSwMeasureCount, dcmAlrmSyncTable=dcmAlrmSyncTable, vcvFxxRingSilenceDuration=vcvFxxRingSilenceDuration, fcCtlAlteredLpTable=fcCtlAlteredLpTable, fclAsynAutoCallEntry=fclAsynAutoCallEntry, fcwDnicZoAddress=fcwDnicZoAddress, vclFrLmiParaDlci=vclFrLmiParaDlci, vcvToneDuration2=vcvToneDuration2, dcfNumericLines=dcfNumericLines, fcfLineModXidStringEntry=fcfLineModXidStringEntry, fmPingPermanent=fmPingPermanent, fclAsynMultiLpAuthStep3=fclAsynMultiLpAuthStep3, fclVipHosLogPortEntry=fclVipHosLogPortEntry, fclB3270HosClusterCluAdd=fclB3270HosClusterCluAdd, dcvTSPCMSwCallType=dcvTSPCMSwCallType, fclVipHostPadLogPort=fclVipHostPadLogPort, dcvCASConfLineSeizureAckTime=dcvCASConfLineSeizureAckTime, fclX25AccPstnBackupEnabling=fclX25AccPstnBackupEnabling, fciOspfVlTransitDelay=fciOspfVlTransitDelay, fmRip2IfConfAddress=fmRip2IfConfAddress, fclFrCeParGenBookingUbrThreshold=fclFrCeParGenBookingUbrThreshold, vcmAlrmSwDisplay=vcmAlrmSwDisplay, fclX25MlpIsdnOverBChannelCount=fclX25MlpIsdnOverBChannelCount, dcvVoiceSuscrRemovedDigitNumber=dcvVoiceSuscrRemovedDigitNumber, fmsEthInPktsTooShortsCounter=fmsEthInPktsTooShortsCounter, fclHdlcAutoCallTable=fclHdlcAutoCallTable, fmsGlobInitBuffCount=fmsGlobInitBuffCount, fclX25MlpIsdnOverStatus=fclX25MlpIsdnOverStatus, fclX25InDX25AccessConfigId=fclX25InDX25AccessConfigId, fclAsynMneMnemonicId=fclAsynMneMnemonicId, fcfE1Ds1=fcfE1Ds1, fmsCtrlSumming=fmsCtrlSumming, fclFrSeLpBackupTimer=fclFrSeLpBackupTimer, dcvProfileTone=dcvProfileTone, fclX25InBRemPriority=fclX25InBRemPriority, fcvLvpFltCondOffset=fcvLvpFltCondOffset, fmsFrLpOutFrames=fmsFrLpOutFrames, fclFrPvcSnaBanConnTestEnabling=fclFrPvcSnaBanConnTestEnabling, fclAsynCfgFacMaxOutWindowSize=fclAsynCfgFacMaxOutWindowSize, fmsInputDataBytesCounter=fmsInputDataBytesCounter, fclX25AccIsdnBackLogPortId=fclX25AccIsdnBackLogPortId, fclFrTeLpFragFrameSize=fclFrTeLpFragFrameSize, fcfLineDVBEntry=fcfLineDVBEntry, fcwSDynDynamicRouting=fcwSDynDynamicRouting, fcIpRouter=fcIpRouter, fclAsynMultiLpLogPortId=fclAsynMultiLpLogPortId, fcmMgfGeneratorCount=fcmMgfGeneratorCount, vcvEMConfId=vcvEMConfId, fdpControl=fdpControl, fcfE1Ds1PhysPhysicalPort=fcfE1Ds1PhysPhysicalPort, vcvVoicePhysicalPortTable=vcvVoicePhysicalPortTable, vcvSnmpManagerIpAddress=vcvSnmpManagerIpAddress, fciTelnetMaxSession=fciTelnetMaxSession, fclPppBIsdnBriStatus=fclPppBIsdnBriStatus, fclX25CfaDlnEachPacketAcknowledgement=fclX25CfaDlnEachPacketAcknowledgement, fcsnaGpSdlcTable=fcsnaGpSdlcTable, fcfLineV28AsynInDteEnablingSig1=fcfLineV28AsynInDteEnablingSig1, fciBootPClientStart=fciBootPClientStart, fmOsiISISESAdjacencyTable=fmOsiISISESAdjacencyTable, vcfPhysPortId=vcfPhysPortId, fcfLineV28DteSi117=fcfLineV28DteSi117, fcmMgtFctCugTable=fcmMgtFctCugTable, fcwSRvcRestoreOutgoingCallRetryCount=fcwSRvcRestoreOutgoingCallRetryCount, fdpTestLoopBackType=fdpTestLoopBackType, fclHdlcAutoMinRecallTimer=fclHdlcAutoMinRecallTimer, fclLogPortId=fclLogPortId, fclAsynPstnRemPstnNumber=fclAsynPstnRemPstnNumber, fclX25InDConnectionType=fclX25InDConnectionType, fclFrCfcSigT303SetupResponseTimer=fclFrCfcSigT303SetupResponseTimer, fmStatPppAuthenticationTable=fmStatPppAuthenticationTable, fcxCircLvpEncapsulation=fcxCircLvpEncapsulation, fcxServSapOutputFilteringEntry=fcxServSapOutputFilteringEntry, fclX25CfnNegotiatedFacilityEntry=fclX25CfnNegotiatedFacilityEntry, fmRip2IfConfTable=fmRip2IfConfTable, fcmAlrmPpPhysPort1=fcmAlrmPpPhysPort1, vcvVoiceSwTable=vcvVoiceSwTable, fcmMgtFctParameters=fcmMgtFctParameters, fcwSQOSProfilesEntry=fcwSQOSProfilesEntry, fclPppSerLpLocalSubscriberNb=fclPppSerLpLocalSubscriberNb, fclX25MlpOvOverflowBackThreshold=fclX25MlpOvOverflowBackThreshold, fclFrPvcX25AssociatedAddress=fclFrPvcX25AssociatedAddress, fcwSCompModule0CompressedVcCount=fcwSCompModule0CompressedVcCount, fcwSRvcKWindowSize=fcwSRvcKWindowSize, fclX25InBRemX121Addr=fclX25InBRemX121Addr, vcvToneGenTable=vcvToneGenTable, fmsEthInterface=fmsEthInterface, fclX25CfaDlnOutgoingChannelCount=fclX25CfaDlnOutgoingChannelCount, fclSdlcSecLogPortTable=fclSdlcSecLogPortTable, fclX25CfaFacilityEntry=fclX25CfaFacilityEntry, vcvIpVirtualPort=vcvIpVirtualPort, fclX25MlpPstnOvLogPortId=fclX25MlpPstnOvLogPortId, fclX25CfaSerRemoteExclusiveLink=fclX25CfaSerRemoteExclusiveLink, fcsModuleClnpRouterInit=fcsModuleClnpRouterInit, vcvVoiceSwSuscriberNumber=vcvVoiceSwSuscriberNumber, vcvAnalogLineVoiceProfile=vcvAnalogLineVoiceProfile, dclFrTerminalEquipment=dclFrTerminalEquipment, vclFrLmiParaN392ErrorThreshold=vclFrLmiParaN392ErrorThreshold, vcfDataLineEntry=vcfDataLineEntry, fclHdlcLpLogPortId=fclHdlcLpLogPortId, fciFlowRouteTable=fciFlowRouteTable, fciRipVpMulticast=fciRipVpMulticast, fcfLineV28AsynInDteSignalEntry=fcfLineV28AsynInDteSignalEntry, dcwABPvcLpEntry=dcwABPvcLpEntry, fclAsynCfgDescription=fclAsynCfgDescription, fclX25CfnNegOutputFastSelect=fclX25CfnNegOutputFastSelect, fclAsynCfgSerCir=fclAsynCfgSerCir, fclAsynCfgConnLinkEntry=fclAsynCfgConnLinkEntry, vcvSnmp=vcvSnmp, fcxServStaticNode=fcxServStaticNode, fcfLineV28DceRts105=fcfLineV28DceRts105, fcsnaGpSdlcStatus=fcsnaGpSdlcStatus, fclFrCeParGenLogPortId=fclFrCeParGenLogPortId, vclFrSeSigT305DisconnectResponseTimer=vclFrSeSigT305DisconnectResponseTimer, fclFrCfsSigT203InactivityTimer=fclFrCfsSigT203InactivityTimer, vcvIpLocSubNetMask=vcvIpLocSubNetMask, vcvVoiceProfFaxActivation=vcvVoiceProfFaxActivation, npx09=npx09, fdpModControlData=fdpModControlData, fclAsynX28PlusRemoteCfgX3Part2Entry=fclAsynX28PlusRemoteCfgX3Part2Entry, fcsModuleSubscriberNumber=fcsModuleSubscriberNumber, fclFrSeIsdnRemLogPortId=fclFrSeIsdnRemLogPortId, fclSdlcLogPort=fclSdlcLogPort, fclAsynCfgFacMaxInPacketSize=fclAsynCfgFacMaxInPacketSize, fclX25CfaPackPrivateZoSb=fclX25CfaPackPrivateZoSb, fcvLocalVirtualPortEntry=fcvLocalVirtualPortEntry, fcsnaLvpParamNW=fcsnaLvpParamNW, fmeTrblEventType=fmeTrblEventType, fcfE1Ds1PhysStatus=fcfE1Ds1PhysStatus, fmsPppProtoClnpNcpStatus=fmsPppProtoClnpNcpStatus, fmStatMlpEntry=fmStatMlpEntry, cfModuleToIdentify=cfModuleToIdentify, fcvRvpConnFlowTypeMask=fcvRvpConnFlowTypeMask, fmsWanConnId=fmsWanConnId, fclX25CfnSigConvMultiCalledAddrOutCall=fclX25CfnSigConvMultiCalledAddrOutCall, fclAsynCfgX3UserP11BinarySpeed=fclAsynCfgX3UserP11BinarySpeed, vcvVoiceProfileTable=vcvVoiceProfileTable, fclAsynNetUserTable=fclAsynNetUserTable, fmsLineType=fmsLineType, fmsIpLanNetMask=fmsIpLanNetMask, fclPppBIsdnRemPriority=fclPppBIsdnRemPriority, fciIcmpRedirection=fciIcmpRedirection, fcwSDynNeighborMaxCount=fcwSDynNeighborMaxCount, fclFrCfsGenDynamicEir=fclFrCfsGenDynamicEir, fcvLvpFltFilteringVirtualPortId=fcvLvpFltFilteringVirtualPortId, fclAsynCfgConnLinkTable=fclAsynCfgConnLinkTable, dcInterfaces=dcInterfaces, fciRipOspfRoutesDistributionMetric=fciRipOspfRoutesDistributionMetric, fclX25AccIsdnBackStatus=fclX25AccIsdnBackStatus, fmsEthManFilterPermitCounter=fmsEthManFilterPermitCounter, fclVipLpMessageRetryNumber=fclVipLpMessageRetryNumber, fclVipLogPortTable=fclVipLogPortTable, vcvEMSwInterfaceId=vcvEMSwInterfaceId, fclPppPstnLpLogPortId=fclPppPstnLpLogPortId, fcsnaLvpLocalLanPuTable=fcsnaLvpLocalLanPuTable, fclFrCfcGeneralParameterTable=fclFrCfcGeneralParameterTable, fclFrSeInBIsdnLogPortEntry=fclFrSeInBIsdnLogPortEntry, fcfLineV28AsynInDteSignalTable=fcfLineV28AsynInDteSignalTable, fmStatE1Ds1ChannelEntry=fmStatE1Ds1ChannelEntry, vclFrLmiParaAccessibilityCondition=vclFrLmiParaAccessibilityCondition, fclAsynMneCallUserDataAscii=fclAsynMneCallUserDataAscii, fcwSCUDProfilesTable=fcwSCUDProfilesTable, fmsFrcStoragePhysIfId=fmsFrcStoragePhysIfId, fclAsynCfgX3P16CharDelete=fclAsynCfgX3P16CharDelete, fclAsynCfgSerX29Reselection=fclAsynCfgSerX29Reselection, fclBSctProtDef1PermanentDelimiter4=fclBSctProtDef1PermanentDelimiter4, fcCtlAlteredDlciTable=fcCtlAlteredDlciTable, fciBootPInterfaceEntry=fciBootPInterfaceEntry, fcfE1Ds1PhysTable=fcfE1Ds1PhysTable, vcvFxxConfInterdigitTime=vcvFxxConfInterdigitTime, cdPhysicalPorts=cdPhysicalPorts, fciSnmpAuthenticationFailureTrap=fciSnmpAuthenticationFailureTrap, fciOspfNeighborEligibleStatus=fciOspfNeighborEligibleStatus, fmStatPppIpAddrAssignmentTable=fmStatPppIpAddrAssignmentTable, fcwAddrConvIncomingCallEntry=fcwAddrConvIncomingCallEntry, fcxServCircSapPace=fcxServCircSapPace, fmEvents=fmEvents, fclPppPstnLogPortEntry=fclPppPstnLogPortEntry, fclX25CfaNegDefInThroughputClass=fclX25CfaNegDefInThroughputClass, fdpModResponseTable=fdpModResponseTable, vcvEMPermEntry=vcvEMPermEntry, fcsnaLvpTrParamN3=fcsnaLvpTrParamN3, fmsFrDlcOutLogPortId=fmsFrDlcOutLogPortId, fclAsynPadLpEntry=fclAsynPadLpEntry, fcxRipInFltFiltering=fcxRipInFltFiltering, fmsE1Ds1ChIfOutQLen=fmsE1Ds1ChIfOutQLen, dcmAlrmSCDisplay=dcmAlrmSCDisplay, fclFrCfsGenConfigId=fclFrCfsGenConfigId, fclFrCfcLmiParameterEntry=fclFrCfcLmiParameterEntry, fmsE1Ds1ChIfOutOctets=fmsE1Ds1ChIfOutOctets, fclX25MlpLink2InterfaceId=fclX25MlpLink2InterfaceId, fclPppConfig=fclPppConfig, fciLocalClusterTable=fciLocalClusterTable, cmEvents=cmEvents, fdpTestMaxDuration=fdpTestMaxDuration, vcvVoiceSuscrInsSuffix=vcvVoiceSuscrInsSuffix, fmsIpLanArpFailedCounter=fmsIpLanArpFailedCounter, fclFrPvcQosOutBc=fclFrPvcQosOutBc, dcvTSPCMPermCommunicationMode=dcvTSPCMPermCommunicationMode, fclAsynNetNua=fclAsynNetNua, fmOsiISISISAdjIndex=fmOsiISISISAdjIndex, fclFrPvcSnaT2ReceiverAckTimer=fclFrPvcSnaT2ReceiverAckTimer, fclX25CfnDlnStationType=fclX25CfnDlnStationType, mcx512Y=mcx512Y, fclX25AccIsdnBackupEntry=fclX25AccIsdnBackupEntry, fclX25MlpEntry=fclX25MlpEntry, fclX25CfaFacReverseCharging=fclX25CfaFacReverseCharging, dcvIfPCMChannelTable=dcvIfPCMChannelTable, vcvVirtualPortEntry=vcvVirtualPortEntry, vcmAlrmSvcTable=vcmAlrmSvcTable, fclFrTeIsdnBackIsdnInterfaceId=fclFrTeIsdnBackIsdnInterfaceId, fcxServCircuitEntry=fcxServCircuitEntry, fcxCircLvpCircuitId=fcxCircLvpCircuitId, fclSdlcLpBitEncoding=fclSdlcLpBitEncoding, fclB3270HosLpLineWatchDog=fclB3270HosLpLineWatchDog, fciOspfVpHelloInterval=fciOspfVpHelloInterval, fccLneighMacAddress=fccLneighMacAddress, fmsEthOutCarrierSenseErrorsCounter=fmsEthOutCarrierSenseErrorsCounter, dcfNumericLineInterfaceId=dcfNumericLineInterfaceId, fclFrPvcSnaLinkType=fclFrPvcSnaLinkType, fcfIsdnPrimaryRateInterfaceId=fcfIsdnPrimaryRateInterfaceId, fclIulConversionAimedPoint=fclIulConversionAimedPoint, vcvEMConfEndOfDialingTimer=vcvEMConfEndOfDialingTimer, fclLogPortType=fclLogPortType, fclAsynPadPageStatus=fclAsynPadPageStatus, fclFrTeLpLinkLayerConsolidation=fclFrTeLpLinkLayerConsolidation, fccVirtualPortEntry=fccVirtualPortEntry, fmPingMaxRoundTrip=fmPingMaxRoundTrip, fcvLvpFltFilteringEntry=fcvLvpFltFilteringEntry, fclPppPstnLogPortTable=fclPppPstnLogPortTable, fmRip2GlobalGroup=fmRip2GlobalGroup, dcfConfLineEntry=dcfConfLineEntry, fmOspfStandardVirtNbrEntry=fmOspfStandardVirtNbrEntry, fcfLineV28AsynInDceEnablingSig1=fcfLineV28AsynInDceEnablingSig1, fclSdlcPriLpLogPortId=fclSdlcPriLpLogPortId, fclFraLmiN393MonitoredEventCount=fclFraLmiN393MonitoredEventCount, fmsCtrlStatus=fmsCtrlStatus, fmsPppProtoBrdgNcpStatus=fmsPppProtoBrdgNcpStatus, fmsSigPhysPortId=fmsSigPhysPortId, dclFrSeSigOuputTimeout=dclFrSeSigOuputTimeout, fclFrCfsStatus=fclFrCfsStatus, vcvEMConfCallSignalling=vcvEMConfCallSignalling, vcfConfLineTable=vcfConfLineTable, vclFrConfigurationSe=vclFrConfigurationSe, fclFrSeIsdnRemotePeerTable=fclFrSeIsdnRemotePeerTable, fclFrCfcEiCodingTable=fclFrCfcEiCodingTable, fclHdlcAutoSubscriberNumber=fclHdlcAutoSubscriberNumber)
mibBuilder.exportSymbols("PCE-MIB", fmOsiESISSysOutPDUs=fmOsiESISSysOutPDUs, fcwConvMultiInStatus=fcwConvMultiInStatus, fcxRipInFltFilterId=fcxRipInFltFilterId, fmStatLineEntry=fmStatLineEntry, fmOspfStandardStubStatus=fmOspfStandardStubStatus, fclFrPvcEndPointEntry=fclFrPvcEndPointEntry, fmuAccessAsynLineNbMax=fmuAccessAsynLineNbMax, fmOsiISISCircuitTable=fmOsiISISCircuitTable, fclX25InPstnTable=fclX25InPstnTable, fclAsynCfgFacDefInThroughputClass=fclAsynCfgFacDefInThroughputClass, fclVipCluStatElementId=fclVipCluStatElementId, fciEgpTargetAsDistributionTable=fciEgpTargetAsDistributionTable, fmsFrLpOutLocalCongFecnFrames=fmsFrLpOutLocalCongFecnFrames, dcvVoiceSuscrInsPrefix=dcvVoiceSuscrInsPrefix, fmOsiISISLogAdjcencyStateChanges=fmOsiISISLogAdjcencyStateChanges, vcvVoiceSuscrOrderNumber=vcvVoiceSuscrOrderNumber, fcxRipOutputFilteringEntry=fcxRipOutputFilteringEntry, vclFrSeSignallingEntry=vclFrSeSignallingEntry, vcvVoiceLogPortType=vcvVoiceLogPortType, fclB3270LpCodingParityType=fclB3270LpCodingParityType, fclFrTeIsdnRemCallRetryCount=fclFrTeIsdnRemCallRetryCount, fmOsiISISSysOwnLSPPurges=fmOsiISISSysOwnLSPPurges, fciOspfVpMetric=fciOspfVpMetric, fmsWanConnLocalSbNumber=fmsWanConnLocalSbNumber, cfEepromSize=cfEepromSize, dcfDataLineDcd109=dcfDataLineDcd109, fmStatFrCircuitTable=fmStatFrCircuitTable, fclBSctConnCallDirection=fclBSctConnCallDirection, dcfDataLineRts105=dcfDataLineRts105, fmOsiISISISAdjSysID=fmOsiISISISAdjSysID, fclX25InDIsdnRemCallRetryCount=fclX25InDIsdnRemCallRetryCount, fclX25CfaPackStatus=fclX25CfaPackStatus, fmStatE1Ds1ChannelTable=fmStatE1Ds1ChannelTable, fmuFunctionOnlineFileTransfer=fmuFunctionOnlineFileTransfer, fciRouteMask=fciRouteMask, fclAsynMneTransName=fclAsynMneTransName, fmsWanConnInPktsCounter=fmsWanConnInPktsCounter, fmsE1Ds1ChIfOutNUcastPkts=fmsE1Ds1ChIfOutNUcastPkts, fmsInArpVpOutResponses=fmsInArpVpOutResponses, fcxRoutingInformationProtocol=fcxRoutingInformationProtocol, fmsRvpConnEncapsulation=fmsRvpConnEncapsulation, fmOsiISISCircOutCtrlPdu=fmOsiISISCircOutCtrlPdu, fcsConfigDescription=fcsConfigDescription, fclFrCeLpConfigId=fclFrCeLpConfigId, vcWanSwitch=vcWanSwitch, vcvVoiceTransQosBc=vcvVoiceTransQosBc, fclAsynMnemonicTable=fclAsynMnemonicTable, fclAsynCfgFacWindowSize=fclAsynCfgFacWindowSize, fclHdlcAutoCallEntry=fclHdlcAutoCallEntry, fcsModuleEntry=fcsModuleEntry, fclX25SlpInterNode=fclX25SlpInterNode, fclX25CfnNegDefInThroughputClass=fclX25CfnNegDefInThroughputClass, fmsSig111=fmsSig111, fclFrPvcSpecific=fclFrPvcSpecific, fclX25Configurations=fclX25Configurations, fmsFrLpOutLocalCongDiscards=fmsFrLpOutLocalCongDiscards, fmsFrLpSvcBookingVbrRtThroughput=fmsFrLpSvcBookingVbrRtThroughput, fmStatS0BChannelTable=fmStatS0BChannelTable, fclX25AccSwSwitchThreshold=fclX25AccSwSwitchThreshold, fmRip2IfConfEntry=fmRip2IfConfEntry, fcfE1Ds1DropInsertIf2=fcfE1Ds1DropInsertIf2, vcvFxxLpRemoteNumber=vcvFxxLpRemoteNumber, fclAsynCfgX3P08OutputDiscard=fclAsynCfgX3P08OutputDiscard, dcvVoiceSwTable=dcvVoiceSwTable, vcvEMConfDtmfDigitLevel=vcvEMConfDtmfDigitLevel, vcvFxxConfCallSignalling=vcvFxxConfCallSignalling, fmOspfStandardGeneralGroup=fmOspfStandardGeneralGroup, fclBX780IdentTable=fclBX780IdentTable, fcfIsdnDTimT301AlertConnectTimer=fcfIsdnDTimT301AlertConnectTimer, fclAsynAutoCalls=fclAsynAutoCalls, fclX25MlpIsdnOverIsdnInterfaceId=fclX25MlpIsdnOverIsdnInterfaceId, fclFrTeParGenEntry=fclFrTeParGenEntry, fmsFrLpLmiUserN393=fmsFrLpLmiUserN393, fclAsynCfgLinkDataParity=fclAsynCfgLinkDataParity, fcfLineV35DceH108=fcfLineV35DceH108, fmsBrdgTrafOutBroadcastServCounter=fmsBrdgTrafOutBroadcastServCounter, fclX25CfnSigConversionIncomingCall=fclX25CfnSigConversionIncomingCall, fmOspfStandardAreaTable=fmOspfStandardAreaTable, vcvRemNetEncapsulation=vcvRemNetEncapsulation, fmsIpTrafIcmpOutMsgsCounter=fmsIpTrafIcmpOutMsgsCounter, dcvSnmpGenAuthenticationFailureTrap=dcvSnmpGenAuthenticationFailureTrap, fciTelnetPwdP4=fciTelnetPwdP4, fclX25MlpPstnOverflowEntry=fclX25MlpPstnOverflowEntry, fcfTokenRingLinkCheckPeriod=fcfTokenRingLinkCheckPeriod, fmeTrapLineId=fmeTrapLineId, fclPppCfgStatus=fclPppCfgStatus, fmsBootPClientStatus=fmsBootPClientStatus, fcfE1Ds1ChannelSlots=fcfE1Ds1ChannelSlots, sc310_8W=sc310_8W, fcFrSwitchingEntry=fcFrSwitchingEntry, cfFileTransferService=cfFileTransferService, fcxServSapOutFltServiceType=fcxServSapOutFltServiceType, fcxCircRvpRemoteAddress=fcxCircRvpRemoteAddress, fmOsiESISCircuitEntry=fmOsiESISCircuitEntry, fmsInArpVpVirtualPortId=fmsInArpVpVirtualPortId, dcvIpLocSvcClearCallTimer=dcvIpLocSvcClearCallTimer, fcfLineV28AsynOutDceCts106=fcfLineV28AsynOutDceCts106, fmsFrcStorageSrcAddr=fmsFrcStorageSrcAddr, fclX25InDIsdnRemStatus=fclX25InDIsdnRemStatus, vcmAlrmLMITyp=vcmAlrmLMITyp, fcsnaGpLanFrTable=fcsnaGpLanFrTable, fcvLvpFltConditionEntry=fcvLvpFltConditionEntry, fmsFrDlcInLostSegments=fmsFrDlcInLostSegments, fciRipVpAuthKey=fciRipVpAuthKey, fclFraLpX25InterframeFlagCount=fclFraLpX25InterframeFlagCount, fclX25MlpOverflowTable=fclX25MlpOverflowTable, fmsE1Ds1ChIfInUnknownProtos=fmsE1Ds1ChIfInUnknownProtos, fmRip2IfConfReceive=fmRip2IfConfReceive, fcxCircLocalMaxPacketSize=fcxCircLocalMaxPacketSize, fclFrSeIsdnBackLogPortId=fclFrSeIsdnBackLogPortId, fmRip2IfConfAuthType=fmRip2IfConfAuthType, fciTelnetPwdP3=fciTelnetPwdP3, fclX25AccIsdnRemStatus=fclX25AccIsdnRemStatus, fclB3270CluLpPollingTimer=fclB3270CluLpPollingTimer, fcsnaLvpParamRW=fcsnaLvpParamRW, fclFrTeIsdnBackupEntry=fclFrTeIsdnBackupEntry, fmsFrSwitch=fmsFrSwitch, portNumber=portNumber, fclFrSeLogPortTable=fclFrSeLogPortTable, fclX25CfnSigConfigId=fclX25CfnSigConfigId, fcfIsdnDTimT305DisconnectResponseTimer=fcfIsdnDTimT305DisconnectResponseTimer, fciRipNeighborStatus=fciRipNeighborStatus, fclX25InDIsdnBackLogPortId=fclX25InDIsdnBackLogPortId, fmsInArpVirtualPortTable=fmsInArpVirtualPortTable, fmuAccessX28PlusLineNbMax=fmuAccessX28PlusLineNbMax, fcxIpxRouting=fcxIpxRouting, fciOspfVlStatus=fciOspfVlStatus, fclFrSeInBRemStatus=fclFrSeInBRemStatus, fclB3270LpInterfaceId=fclB3270LpInterfaceId, fcwSQOSProfilesCIR=fcwSQOSProfilesCIR, fcxServSapOutFltCheckedField=fcxServSapOutFltCheckedField, fclAsynMneStatus=fclAsynMneStatus, fmPingAvgRoundTrip=fmPingAvgRoundTrip, cfRamSize=cfRamSize, fmsFrLpInExcessFrames=fmsFrLpInExcessFrames, fmOsiCLNPSysOutPDUs=fmOsiCLNPSysOutPDUs, fcCtlHRCheckMessagesEntry=fcCtlHRCheckMessagesEntry, fcLogicalPorts=fcLogicalPorts, fclAsynCfgFacPacketSize=fclAsynCfgFacPacketSize, fcfLineModemTable=fcfLineModemTable, fclBX780IdentStatus=fclBX780IdentStatus, fmsFrDlcInDiscards=fmsFrDlcInDiscards, vcwEquipRemoteConfPortAddr=vcwEquipRemoteConfPortAddr, fclX25CfaNegMaxOutThroughputClass=fclX25CfaNegMaxOutThroughputClass, fclAsynVdxHomePageTable=fclAsynVdxHomePageTable, fcwSbSubscriberNumber=fcwSbSubscriberNumber, fclFraPvcLogPortId=fclFraPvcLogPortId, vclHdlcLpFragmentationLength=vclHdlcLpFragmentationLength, fcxServCircSapPacketSize=fcxServCircSapPacketSize, fclX25CfaNegotiatedFacilityEntry=fclX25CfaNegotiatedFacilityEntry, fcxBasicSysName=fcxBasicSysName, fmRip2IfStatAddress=fmRip2IfStatAddress, fclX25CfnNegInputFastSelect=fclX25CfnNegInputFastSelect, dcvTftpTable=dcvTftpTable, fclAsynPadPageMessage=fclAsynPadPageMessage, fclVipHosElemType=fclVipHosElemType, vcmAlrmGenFamilyId=vcmAlrmGenFamilyId, fclFrPvcX25EncapsulationTable=fclFrPvcX25EncapsulationTable, fmsE1Ds1ChIfAdminStatus=fmsE1Ds1ChIfAdminStatus, fclVipCluLpPollingTimer=fclVipCluLpPollingTimer, fmOsiISISCircAuthFails=fmOsiISISCircAuthFails, vcmAlrmCmpTable=vcmAlrmCmpTable, fclBX780ConnCalledAddr=fclBX780ConnCalledAddr, fmeFamStoredEventsCount=fmeFamStoredEventsCount, fcbStpVpPortPathCost=fcbStpVpPortPathCost, fciRipPreference=fciRipPreference, vcvDialingReceptEntry=vcvDialingReceptEntry, dcfConfLineRate=dcfConfLineRate, fmsIpRouterState=fmsIpRouterState, fmsIpTrafOutRequestsCounter=fmsIpTrafOutRequestsCounter, dcvIpLocVirtualPortId=dcvIpLocVirtualPortId, vcvFxxLpConfigId=vcvFxxLpConfigId, fclX25PstnRemotePeerTable=fclX25PstnRemotePeerTable, fclPppCfgNcpIpx=fclPppCfgNcpIpx, fmuFunctionRight=fmuFunctionRight, fclAsynCfgSerConversionAimedPoint=fclAsynCfgSerConversionAimedPoint, fmsFrLpSvcOverBookingThroughput=fmsFrLpSvcOverBookingThroughput, fcwConvMultiOutOrderNum=fcwConvMultiOutOrderNum, fmOspfStandardNbrEvents=fmOspfStandardNbrEvents, fcfIsdnDTimT313ConnectAcknowledgeTimer=fcfIsdnDTimT313ConnectAcknowledgeTimer, fcwSDynRouteCalculLockingTimer=fcwSDynRouteCalculLockingTimer, fcwSerClearAnalysisEntry=fcwSerClearAnalysisEntry, fclAsynLscpLpTable=fclAsynLscpLpTable, fmOsiESISSysInPDUs=fmOsiESISSysInPDUs, cfHardwareIdentificationPassword=cfHardwareIdentificationPassword, fmStatS2BChannelTable=fmStatS2BChannelTable, vcvVoiceSuscrStatus=vcvVoiceSuscrStatus, sc106=sc106, fmsFrLpLmiEntry=fmsFrLpLmiEntry, fclX25SlpPstnBackInterfaceId=fclX25SlpPstnBackInterfaceId, fmsStateLineType=fmsStateLineType, fcvRvpMinCir=fcvRvpMinCir, fciOspfAseExportInterval=fciOspfAseExportInterval, fcfIsdnDTimBChannelUpTimer=fcfIsdnDTimBChannelUpTimer, fcfIsdnDTimT309DataLinkFailureTimer=fcfIsdnDTimT309DataLinkFailureTimer, fmsSig141=fmsSig141, vcvVoiceLogPortId=vcvVoiceLogPortId, dcmAlrmFaxTyp=dcmAlrmFaxTyp, fclX25CfnSigConvMultiCallingAddrInCall=fclX25CfnSigConvMultiCallingAddrInCall, fciFlowManagement=fciFlowManagement, fmsFrDlcOutgoingEntry=fmsFrDlcOutgoingEntry, fmuVersMax=fmuVersMax, fcwSQOSProfilesBc=fcwSQOSProfilesBc, fclX25CfnSerStatLoadAndTraffic=fclX25CfnSerStatLoadAndTraffic, fcsnaGpMiscellaneousParameters=fcsnaGpMiscellaneousParameters, fmOsiForwarding=fmOsiForwarding, vcmAlrmFaxEntry=vcmAlrmFaxEntry, fclB3270CluLpReconnectionType=fclB3270CluLpReconnectionType, vcvVoiceProfMaximumFaxSpeed=vcvVoiceProfMaximumFaxSpeed, fclFrCfcSigOuputTimeout=fclFrCfcSigOuputTimeout, sc300_1W_1E=sc300_1W_1E, fclAsynCfgX3UserP01EscapeChar=fclAsynCfgX3UserP01EscapeChar, fmsGlobFreeBuffCount=fmsGlobFreeBuffCount, fmhE1S2ModDescHardwareVersion=fmhE1S2ModDescHardwareVersion, fclX25SlpIsdnBackIsdnInterfaceId=fclX25SlpIsdnBackIsdnInterfaceId, fmOspfStandardAdminStat=fmOspfStandardAdminStat, vcvDialRxStatus=vcvDialRxStatus, fcsnaLvpParamBc=fcsnaLvpParamBc, fclFrConfigurationSe=fclFrConfigurationSe, fcsnaGpRemPuStatus=fcsnaGpRemPuStatus, fciSnmpManagerTrapsUdpPort=fciSnmpManagerTrapsUdpPort, vcvVoiceLogicalPortEM=vcvVoiceLogicalPortEM, dcvSnmpGenCommunityStringReadOnly=dcvSnmpGenCommunityStringReadOnly, fcvLvpFltCondConditionId=fcvLvpFltCondConditionId, fcfIsdnRemotePeerTable=fcfIsdnRemotePeerTable, fcmAlrmPhysPortEntry=fcmAlrmPhysPortEntry, fclX25CfaNegDefInPacketSize=fclX25CfaNegDefInPacketSize, fmOsiISISISAdjAreaAddrCircIndex=fmOsiISISISAdjAreaAddrCircIndex, fmOspfStandardIfHelloInterval=fmOspfStandardIfHelloInterval, dcCtlErrorIndex=dcCtlErrorIndex, fclPppBIsdnLogPortEntry=fclPppBIsdnLogPortEntry, cfConfigurationVersion=cfConfigurationVersion, fciVpInverseArp=fciVpInverseArp, fclFrCfsGenBookingUbrThreshold=fclFrCfsGenBookingUbrThreshold, fccVpVirtualPortId=fccVpVirtualPortId, fclFraLpLmi=fclFraLpLmi, fclX25InDLogPortId=fclX25InDLogPortId, fcvLvpVirtualPortId=fcvLvpVirtualPortId, fcfE1Ds1ChannelPhysIf=fcfE1Ds1ChannelPhysIf, fclX25AccSubscriberNumber=fclX25AccSubscriberNumber, vcvEMConfDialingFormat=vcvEMConfDialingFormat, dvb2030=dvb2030, fmOspfStandardAuthType=fmOspfStandardAuthType, fclB3270HosClusterEntry=fclB3270HosClusterEntry, fclFrPvcQosOutMinCir=fclFrPvcQosOutMinCir, fclPppCftFailureMaxCount=fclPppCftFailureMaxCount, fmsFrLogicalPort=fmsFrLogicalPort, fclX25CfnSerX29Reselection=fclX25CfnSerX29Reselection, dcmAlrmVCTrapSend=dcmAlrmVCTrapSend, fclAsynPstnRemotePeerTable=fclAsynPstnRemotePeerTable, vcmAlrmVCDisplay=vcmAlrmVCDisplay, vcvFxxConfigEntry=vcvFxxConfigEntry, fclFrPvcTunEndPointTable=fclFrPvcTunEndPointTable, fcfIsdnDSigCalledSubAddressCheck=fcfIsdnDSigCalledSubAddressCheck)
mibBuilder.exportSymbols("PCE-MIB", fclAsynMultiLpEntry=fclAsynMultiLpEntry, netAccessProduct=netAccessProduct, dcvVoiceSuscrTransportProfileId=dcvVoiceSuscrTransportProfileId, fclHdlcLpGroupingThreshold=fclHdlcLpGroupingThreshold, dcSystem=dcSystem, fclX25SlpInterNodeEntry=fclX25SlpInterNodeEntry, fciFlowAddrSubstituteTable=fciFlowAddrSubstituteTable, vcvFxxConfToneProfile=vcvFxxConfToneProfile, fcwFrEventOutput=fcwFrEventOutput, fclBSctProtocolDefinition2Entry=fclBSctProtocolDefinition2Entry, fclAsynX28PlusParTELENETEntry=fclAsynX28PlusParTELENETEntry, fclFrPvcX25LinkId=fclFrPvcX25LinkId, fclX25CfaNegMaxInPacketSize=fclX25CfaNegMaxInPacketSize, fciOspfAseExportRipTag=fciOspfAseExportRipTag, dcvVoiceTransQosBe=dcvVoiceTransQosBe, fclBSctProtDef1StFrDelimiterInhib1=fclBSctProtDef1StFrDelimiterInhib1, fcCtlAlteredDlciNum=fcCtlAlteredDlciNum, fclFrCfcEiCodConfigId=fclFrCfcEiCodConfigId, fcvRvpConnEncapsulation=fcvRvpConnEncapsulation, fclVipCluStatStatus=fclVipCluStatStatus, fcwAddrConvCondOutgoingCallTable=fcwAddrConvCondOutgoingCallTable, fmsEthOutDeferredTransmissionsCounter=fmsEthOutDeferredTransmissionsCounter, fcwSDynLspRetransmissionTimer=fcwSDynLspRetransmissionTimer, dclFrLmiParaAccessibilityCondition=dclFrLmiParaAccessibilityCondition, fciRipDistributionTimer=fciRipDistributionTimer, cmeClearVirtualCircuitInfo=cmeClearVirtualCircuitInfo, fclSdlcSecClusterBe=fclSdlcSecClusterBe, fcmMgtFctActivationEntry=fcmMgtFctActivationEntry, fcxRipInputFiltering=fcxRipInputFiltering, fciTelnetUserStatus=fciTelnetUserStatus, fclAsynCfgX3Part2ProfileId=fclAsynCfgX3Part2ProfileId, vcmAlrmVCTrapSend=vcmAlrmVCTrapSend, sc320_8W_1TR=sc320_8W_1TR, fclFraLmiDlci=fclFraLmiDlci, fcsnaGpX25Table=fcsnaGpX25Table, fcfLineV28AsynOutDteDtr108=fcfLineV28AsynOutDteDtr108, fclX25InDIsdnRemSubscriberNumber=fclX25InDIsdnRemSubscriberNumber, fclX25CfaNegDefOutThroughputClass=fclX25CfaNegDefOutThroughputClass, fclX25CfmTransmitFlowControlTable=fclX25CfmTransmitFlowControlTable, fmStatIpClusterStateTable=fmStatIpClusterStateTable, fcwZoZone=fcwZoZone, fcxRoutType20PacketBroadcasting=fcxRoutType20PacketBroadcasting, fclAsynX28PlusRemCfgX3P12InputFlowCtrl=fclAsynX28PlusRemCfgX3P12InputFlowCtrl, sc112=sc112, fclFraLpCompression=fclFraLpCompression, fclB3270CluClusterStaAdd=fclB3270CluClusterStaAdd, fcfLineV11DteSignalEntry=fcfLineV11DteSignalEntry, fclBX780LogPortEntry=fclBX780LogPortEntry, fcvRvpCompression=fcvRvpCompression, fcvRvpConnModule2VpId=fcvRvpConnModule2VpId, fmeEvtLineId=fmeEvtLineId, vcvToneProfileId=vcvToneProfileId, fclAsynMnemonicEntry=fclAsynMnemonicEntry, dcmAlrmCmpFamilyId=dcmAlrmCmpFamilyId, fmsFrLpLmiUserProtErrors=fmsFrLpLmiUserProtErrors, fmsInverseArp=fmsInverseArp, fmsFrLpSvcDlcVbr=fmsFrLpSvcDlcVbr, frx2000=frx2000, fmsEthPhysAddr=fmsEthPhysAddr, fcfE1Ds1DropInsertIf1=fcfE1Ds1DropInsertIf1, fclSdlcLogPortTable=fclSdlcLogPortTable, fmsFrSwDataLinkConnEstablished=fmsFrSwDataLinkConnEstablished, changeDescription=changeDescription, fclFrPvcQualityOfServiceEntry=fclFrPvcQualityOfServiceEntry, dcManagement=dcManagement, vcvAnalogLineTypeInterface=vcvAnalogLineTypeInterface, fciRouteMetric=fciRouteMetric, fclAsynCfgFacMaxInWindowSize=fclAsynCfgFacMaxInWindowSize, fmOsiISISAreaEntry=fmOsiISISAreaEntry, dcmAlrmCmpEntry=dcmAlrmCmpEntry, lmx506=lmx506, vclLogPortId=vclLogPortId, fccNeighVirtualPortId=fccNeighVirtualPortId, fclX25SlpIsdnBackupEnabling=fclX25SlpIsdnBackupEnabling, fclX25AccIsdnBackupEnabling=fclX25AccIsdnBackupEnabling, vcvDialingReceptTable=vcvDialingReceptTable, fciEgpNeighborAsNumber=fciEgpNeighborAsNumber, fclHdlcAutoEncapsulation=fclHdlcAutoEncapsulation, fcwLocalIncomingCallsRouteId=fcwLocalIncomingCallsRouteId, fclX25InDActiveLinkAtBootTime=fclX25InDActiveLinkAtBootTime, vcvEMSwCallType=vcvEMSwCallType, fclPppCfgLcpMagicNumber=fclPppCfgLcpMagicNumber, fclFrCfcGenInactivityCheckDelay=fclFrCfcGenInactivityCheckDelay, fclHdlcLpAllDiscardThreshold=fclHdlcLpAllDiscardThreshold, fciOspfNeighborsEntry=fciOspfNeighborsEntry, fclB3270CluClusterStatus=fclB3270CluClusterStatus, fmsLineInputOctetsCounter=fmsLineInputOctetsCounter, fmsFrLpLmiUserN391=fmsFrLpLmiUserN391, fclAsynLowSpeedCpLogPort=fclAsynLowSpeedCpLogPort, vcvVoiceLogicalPortFxx=vcvVoiceLogicalPortFxx, dcvCASConfMaxLineSeizureAckTime=dcvCASConfMaxLineSeizureAckTime, dcvVoiceProfCESMode=dcvVoiceProfCESMode, fclX25InDIsdnInterfaceId=fclX25InDIsdnInterfaceId, fciRipEgpRoutesDistribution=fciRipEgpRoutesDistribution, fclAsynX28PlusLpTable=fclAsynX28PlusLpTable, vcvIpLocMinimumRecallTimer=vcvIpLocMinimumRecallTimer, fclAsynVdxPageMessage=fclAsynVdxPageMessage, fclPppCftConnectionTimer=fclPppCftConnectionTimer, fmOspfStandardStubTOS=fmOspfStandardStubTOS, fcfE1PhysPortSynchSrc=fcfE1PhysPortSynchSrc, fmsEthInLineId=fmsEthInLineId, vcvVoiceVirtualPort=vcvVoiceVirtualPort, fmsFrLpInFrames=fmsFrLpInFrames, fmOspfStandardAreaEntry=fmOspfStandardAreaEntry, dcvDialingReceptTable=dcvDialingReceptTable, fciRipEgpRoutesMetric=fciRipEgpRoutesMetric, fmsEthManSupervisionNokCounter=fmsEthManSupervisionNokCounter, vcfDataLineDsr107=vcfDataLineDsr107, fcwConvCondOutConvertedAddr=fcwConvCondOutConvertedAddr, fclFrTeParGenDlcSetupDiscardThreshold=fclFrTeParGenDlcSetupDiscardThreshold, fcsnaGpRoutSsap=fcsnaGpRoutSsap, fdpTestInPktsCounter=fdpTestInPktsCounter, fclPppSerLpInterfaceId=fclPppSerLpInterfaceId, fmuAccessPppaLineNbMax=fmuAccessPppaLineNbMax, dcvVoiceTransProfileId=dcvVoiceTransProfileId, fcwSResConversionAddressCheck=fcwSResConversionAddressCheck, fcvRvpConnBe=fcvRvpConnBe, fmRip2PeerLastUpdate=fmRip2PeerLastUpdate, fclX25CfaSigConvMultiCalledAddrOutCall=fclX25CfaSigConvMultiCalledAddrOutCall, fcfLineV28AsynInDteInterfaceId=fcfLineV28AsynInDteInterfaceId, fcsnaGpMiscMacAddrLearningMode=fcsnaGpMiscMacAddrLearningMode, fmOspfStandardIfRtrDeadInterval=fmOspfStandardIfRtrDeadInterval, fmOspfStandardVirtIfNeighbor=fmOspfStandardVirtIfNeighbor, dcvSnmpManagerTrapsUdpPort=dcvSnmpManagerTrapsUdpPort, fmsFrCircuitAge=fmsFrCircuitAge, fclX25CfaClosedUserGroupTable=fclX25CfaClosedUserGroupTable, fcwZoRoutingEntry=fcwZoRoutingEntry, vcvEMSwRemoteNumber=vcvEMSwRemoteNumber, fcFrSwPriority=fcFrSwPriority, fclX25AccSwLogPortId=fclX25AccSwLogPortId, fclVipCluElemAddress=fclVipCluElemAddress, vcmAlrmCmpFamilyId=vcmAlrmCmpFamilyId, fclX25AccIsdnRemotePeerTable=fclX25AccIsdnRemotePeerTable, fclX25SlpSwitchOverTable=fclX25SlpSwitchOverTable, fclX25SlpPstnBackX25InterNodeConfigId=fclX25SlpPstnBackX25InterNodeConfigId, fcwSClearAnalysDiag=fcwSClearAnalysDiag, fclX25CfaDlnKWindowSize=fclX25CfaDlnKWindowSize, fcsnaGpX25Address=fcsnaGpX25Address, fclAsynMultiLpAuthStep1=fclAsynMultiLpAuthStep1, fmsFrcStorageTypeOfTransport=fmsFrcStorageTypeOfTransport, fclAsynX28PlusLpIdleTimerSelection=fclAsynX28PlusLpIdleTimerSelection, vcmAlrmSwTyp=vcmAlrmSwTyp, fclAsynCfgX3UserP07BreakHandling=fclAsynCfgX3UserP07BreakHandling, fcwConvOutStatus=fcwConvOutStatus, fcmMgtFctCugGroupId=fcmMgtFctCugGroupId, fclAsynLpInterfaceId=fclAsynLpInterfaceId, fclFrTeLpFragmentation=fclFrTeLpFragmentation, vcvFxxConfId=vcvFxxConfId, fciFlowPortMax=fciFlowPortMax, fclFrSeIsdnBackStatus=fclFrSeIsdnBackStatus, fcvLvpFltFilterEntry=fcvLvpFltFilterEntry, fciFlowDestMask=fciFlowDestMask, fclX25MlpIsdnRemotePeerEntry=fclX25MlpIsdnRemotePeerEntry, dcvVoiceSwRemovedDigitNumber=dcvVoiceSwRemovedDigitNumber, fclFrCeParGenEntry=fclFrCeParGenEntry, dcSysConfDate=dcSysConfDate, netConcentratorProduct=netConcentratorProduct, fmsWanConnStatus=fmsWanConnStatus, fcvLvpFltFilterCondition1Id=fcvLvpFltFilterCondition1Id, fclFrCfcSigT316RestartAcknowledgeTimer=fclFrCfcSigT316RestartAcknowledgeTimer, vcvEMConfPauseTime=vcvEMConfPauseTime, dcmAlrmLMITyp=dcmAlrmLMITyp, fclAsynLscpLpEntry=fclAsynLscpLpEntry, fcCtlConfigurationCommand=fcCtlConfigurationCommand, fclFraLogPortTable=fclFraLogPortTable, fcwDnicRoutingEntry=fcwDnicRoutingEntry, fcfLineModSpeed=fcfLineModSpeed, fclBSctProtDef2ACK0=fclBSctProtDef2ACK0, fclAsynCfgX3P15Editing=fclAsynCfgX3P15Editing, fcxServSapInputFilteringTable=fcxServSapInputFilteringTable, fmsFrLpLmiNetN393=fmsFrLpLmiNetN393, fcsnaGpRemPuPuId=fcsnaGpRemPuPuId, fmsLineState=fmsLineState, fcxRoutIpxStaticRouteTable=fcxRoutIpxStaticRouteTable, fmOsiISISISAdjPriority=fmOsiISISISAdjPriority, vcSysConfDate=vcSysConfDate, vcvFxxRingProfile=vcvFxxRingProfile, netBackboneProduct=netBackboneProduct, nodeStatusChanged=nodeStatusChanged, fciOspfAseExportRipStatus=fciOspfAseExportRipStatus, fclFrPvcX25Dlci=fclFrPvcX25Dlci, fclFrPvcQosInMinCir=fclFrPvcQosInMinCir, fclHdlcLogPortEntry=fclHdlcLogPortEntry, fciRipVpAuthType=fciRipVpAuthType, fcmMgfGeneratorsAction=fcmMgfGeneratorsAction, fciOspfVirtualPortsTable=fciOspfVirtualPortsTable, fmsInputCallConfPktsCounter=fmsInputCallConfPktsCounter, fmOsiCLNPSysInPDUs=fmOsiCLNPSysInPDUs, fmOsiCLNPCircOutPDUs=fmOsiCLNPCircOutPDUs, dcvIfPCMChannelIfId=dcvIfPCMChannelIfId, fciRipNeighborEntry=fciRipNeighborEntry, fclFrPvcTunInCir=fclFrPvcTunInCir, fclBX780ConnectionEntry=fclBX780ConnectionEntry, fcsnaLvpTrParamLocalTest=fcsnaLvpTrParamLocalTest, fclX25CfaSigConversionOutgoingCall=fclX25CfaSigConversionOutgoingCall, fmStatIpClusterStateEntry=fmStatIpClusterStateEntry, fmsStateMlpTrunkMainLine=fmsStateMlpTrunkMainLine, fclVipHosElemStatus=fclVipHosElemStatus, fclFrCeParGenDlcSetupAlarmThreshold=fclFrCeParGenDlcSetupAlarmThreshold, fmsFrLpLmiNetLinkRelErrors=fmsFrLpLmiNetLinkRelErrors, cfServiceReport=cfServiceReport, fcfIsdnPriSignalling=fcfIsdnPriSignalling, vcvVoiceLogicalPortEntry=vcvVoiceLogicalPortEntry, fmsE1Ds1ChIfInOctets=fmsE1Ds1ChIfInOctets, dcmAlrmSvcTrapSend=dcmAlrmSvcTrapSend, fcvRvpConvMultiCalledAddrOutCall=fcvRvpConvMultiCalledAddrOutCall, fcxRipCircCircuitId=fcxRipCircCircuitId, fclAsynX28PlusRemoteConfigId=fclAsynX28PlusRemoteConfigId, fclFrPvcBackupEnabling=fclFrPvcBackupEnabling, fclAsynX28PlusGeneralParameters=fclAsynX28PlusGeneralParameters, fclX25CfnNegDefOutThroughputClass=fclX25CfnNegDefOutThroughputClass, fmuAccessPaviLineNbMax=fmuAccessPaviLineNbMax, dcvToneEnable=dcvToneEnable, fclAsynCfgLinkXonXoffSignal=fclAsynCfgLinkXonXoffSignal, vcLogicalPorts=vcLogicalPorts, fclHdlcLpInterfaceId=fclHdlcLpInterfaceId, fcCtlErrorEntry=fcCtlErrorEntry, fclX25CfnDlnLowestTwoWayChannel=fclX25CfnDlnLowestTwoWayChannel, fcwSQOSX25Status=fcwSQOSX25Status, fcsnaLvpParamCos=fcsnaLvpParamCos, fmOsiESISCircInPDUs=fmOsiESISCircInPDUs, fcsnaGpRemPuProtocol=fcsnaGpRemPuProtocol, fciRemIpAddress=fciRemIpAddress, fclSdlcPriLogPortTable=fclSdlcPriLogPortTable, fmsFrLpIncomingEntry=fmsFrLpIncomingEntry, fmsPppPhysLocalMru=fmsPppPhysLocalMru, fmOsiISISCircL1DesIS=fmOsiISISCircL1DesIS, vcmAlrmLMIFamilyId=vcmAlrmLMIFamilyId, fclBX780LpCodingParityType=fclBX780LpCodingParityType, fcvVpModuleId=fcvVpModuleId, fclFrCeLpInterfaceId=fclFrCeLpInterfaceId, fclFrTeLpInterfaceId=fclFrTeLpInterfaceId, fclSdlcPriLpLinkType=fclSdlcPriLpLinkType, fmStatEthOutputTrafficEntry=fmStatEthOutputTrafficEntry, fmeTroubleReport=fmeTroubleReport, dcvIfPCMChannelVoiceProfId=dcvIfPCMChannelVoiceProfId, fmsE1Ds1ChIfSpecific=fmsE1Ds1ChIfSpecific, vcvSnmpGenAuthenticationFailureTrap=vcvSnmpGenAuthenticationFailureTrap, vcvVoiceSwInsSuffix=vcvVoiceSwInsSuffix, fcsnaGpRoutHostPuId=fcsnaGpRoutHostPuId, fmsS0BChOperStatus=fmsS0BChOperStatus, fclX25SlpPstnBackupEnabling=fclX25SlpPstnBackupEnabling, fmOspfStandardAreaBdrRtrCount=fmOspfStandardAreaBdrRtrCount, vcvEMSw=vcvEMSw, fciLclVirtualPortId=fciLclVirtualPortId, dcmAlrmSvcTable=dcmAlrmSvcTable, fcvRvpConvMultiCalledAddrInCall=fcvRvpConvMultiCalledAddrInCall, dcvToneGenLevel=dcvToneGenLevel, fmsFrcStorageMinCir=fmsFrcStorageMinCir, fclX25AccPstnBackupEntry=fclX25AccPstnBackupEntry, fciBootPInterfaceType=fciBootPInterfaceType, dclLogicalPortTable=dclLogicalPortTable, vclFrSeLogPortEntry=vclFrSeLogPortEntry, fdpModDiagCode=fdpModDiagCode)
mibBuilder.exportSymbols("PCE-MIB", dclFrameRelay=dclFrameRelay, fclAsynVdxLpLogPortId=fclAsynVdxLpLogPortId, fmsFrLpLmiTable=fmsFrLpLmiTable, fcxServSapInFltServiceType=fcxServSapInFltServiceType, fclX25ConfigInterNodeTable=fclX25ConfigInterNodeTable, fclAsynVdxLpParityBit=fclAsynVdxLpParityBit, fclAsynX28PlusLpEquipment=fclAsynX28PlusLpEquipment, vcvVoiceProfileEntry=vcvVoiceProfileEntry, dcvCASConfId=dcvCASConfId, fclAsynCfgConfigTable=fclAsynCfgConfigTable, fmStatInputTraffic=fmStatInputTraffic, fmeEvtEventType=fmeEvtEventType, fclX25CfnNegMinOutPacketSize=fclX25CfnNegMinOutPacketSize, vcwWanRouteStatus=vcwWanRouteStatus, fclFrPvcSnaTwTransmitWinSize=fclFrPvcSnaTwTransmitWinSize, dcvRemoteConfEntry=dcvRemoteConfEntry, fcxServCircSapAgeMultiplier=fcxServCircSapAgeMultiplier, fccNeighNeighborId=fccNeighNeighborId, dcmAlrmCmpDisplay=dcmAlrmCmpDisplay, dcvIpLocalEntry=dcvIpLocalEntry, fcbStpVpPortPriority=fcbStpVpPortPriority, fmsGlobVcInUseCount=fmsGlobVcInUseCount, fciSnmpManagerFiltering=fciSnmpManagerFiltering, fmhTechnicMacAdress=fmhTechnicMacAdress, fclPppCfaRemotePeerEntry=fclPppCfaRemotePeerEntry, fciFlowVpId=fciFlowVpId, mcx106=mcx106, fclFrPvcQosDlci=fclFrPvcQosDlci, fcvLocalVirtualPorts=fcvLocalVirtualPorts, fcxCircRvpStatus=fcxCircRvpStatus, dcvRemNetIpAddress=dcvRemNetIpAddress, fmsFrLineStatus=fmsFrLineStatus, fciOspfVlAuthenticationKey=fciOspfVlAuthenticationKey, fcfLineModOutputXidStringId=fcfLineModOutputXidStringId, fmsFrLpSvcSignallingTable=fmsFrLpSvcSignallingTable, fcxRoutInstance=fcxRoutInstance, fclX25InDIsdnRemPriority=fclX25InDIsdnRemPriority, fcmAlrmPpPhysPort3=fcmAlrmPpPhysPort3, vcmAlrmCmpEntry=vcmAlrmCmpEntry, vcvTftpRetryTimer=vcvTftpRetryTimer, fcvRvpConversionIncomingCall=fcvRvpConversionIncomingCall, fclX25CfnServiceEntry=fclX25CfnServiceEntry, fmOsiESISSystem=fmOsiESISSystem, vcvToneGenProfileId=vcvToneGenProfileId, fcfLineV35DteSignalEntry=fcfLineV35DteSignalEntry, fclAsynX28PlusRemCfgX3P01EscapeChar=fclAsynX28PlusRemCfgX3P01EscapeChar, fclX25AccPstnBackLogPortId=fclX25AccPstnBackLogPortId, fclX25CfaSerCompressMultiPacketsTimer=fclX25CfaSerCompressMultiPacketsTimer, vcvEMConfDialingTimeOut=vcvEMConfDialingTimeOut, dcmAlrmTftpDisplay=dcmAlrmTftpDisplay, fclFraLpInterfaceId=fclFraLpInterfaceId, fclSdlcSecLpPollingMaxCount=fclSdlcSecLpPollingMaxCount, fclBSctProtocolDefinition1Table=fclBSctProtocolDefinition1Table, fclX25CfaDlnDBitModification=fclX25CfaDlnDBitModification, fcfLineModLinkUpTimer=fcfLineModLinkUpTimer, fcwDnicRoutingTable=fcwDnicRoutingTable, vcwEquipVoiceVirtualPortAddr=vcwEquipVoiceVirtualPortAddr, fclPppPstnRemPstnNumber=fclPppPstnRemPstnNumber, fciSourceRouting=fciSourceRouting, fcwSerQOSX25=fcwSerQOSX25, fcxServStaticServiceTable=fcxServStaticServiceTable, dcvCASConfigEntry=dcvCASConfigEntry, fcmAlrmEvtEvent1=fcmAlrmEvtEvent1, sc104=sc104, fmsFrDlcInLogPortId=fmsFrDlcInLogPortId, fclFrPvcSnaBanRwReceiveWinSize=fclFrPvcSnaBanRwReceiveWinSize, fclPppSerAutoCompressScrambling=fclPppSerAutoCompressScrambling, fclFrBackupEntry=fclFrBackupEntry, fclInterUnitLink=fclInterUnitLink, fcwSRvcRestoreOutgoingCallDelay=fcwSRvcRestoreOutgoingCallDelay, fmsIpTrafNoRoutesCounter=fmsIpTrafNoRoutesCounter, vclFrSeSigOuputTimeout=vclFrSeSigOuputTimeout, dcwEquipVoiceVirtualPortAddr=dcwEquipVoiceVirtualPortAddr, fcfLineV28DteInterfaceId=fcfLineV28DteInterfaceId, fclAsynCfgFacMaxInThroughputClass=fclAsynCfgFacMaxInThroughputClass, fclX25SlpIsdnRemPriority=fclX25SlpIsdnRemPriority, fccClnpRouteEntry=fccClnpRouteEntry, fclFrPvcSnaBanEncapsulationEntry=fclFrPvcSnaBanEncapsulationEntry, vcFrSwitchingEntry=vcFrSwitchingEntry, fcsnaLvpParamCompressNegotiation=fcsnaLvpParamCompressNegotiation, fclX25AccIsdnBackIsdnInterfaceId=fclX25AccIsdnBackIsdnInterfaceId, fclX25CfmDiagnosticCodeField=fclX25CfmDiagnosticCodeField, fclAsynX28PlusRemCfgX3P07BreakHandling=fclAsynX28PlusRemCfgX3P07BreakHandling, fclAsynLogPortTable=fclAsynLogPortTable, fcwSQOSProfilesTable=fcwSQOSProfilesTable, fmOsiESISCircOutPDUs=fmOsiESISCircOutPDUs, vclFrLmiParameterEntry=vclFrLmiParameterEntry, vcvSnmpManagerSendTraps=vcvSnmpManagerSendTraps, sc300_3W_1E=sc300_3W_1E, fclAsynAutoDiscardCharDuringTimer=fclAsynAutoDiscardCharDuringTimer, fclX25SlpIsdnRemotePeerEntry=fclX25SlpIsdnRemotePeerEntry, fclFrSeIsdnRemPriority=fclFrSeIsdnRemPriority, fclX25CfaSigT11CallResponseTimer=fclX25CfaSigT11CallResponseTimer, fcsnaLvpParamLinkType=fcsnaLvpParamLinkType, fclPppBIsdnRemCheckPeriodCount=fclPppBIsdnRemCheckPeriodCount, fmhEqIdFifthFactoryReturnDate=fmhEqIdFifthFactoryReturnDate, fclPppSerialLogPortEntry=fclPppSerialLogPortEntry, fcvLvpFltFilteringStatus=fcvLvpFltFilteringStatus, adaptis=adaptis, fclX25CfmTransmitFlowControlEntry=fclX25CfmTransmitFlowControlEntry, fmsE1Ds1ChIfLastChange=fmsE1Ds1ChIfLastChange, fdpCtrlCommand=fdpCtrlCommand, fmsFrCircuitDlci=fmsFrCircuitDlci, fclAsynCfgSerConversionIncomingCall=fclAsynCfgSerConversionIncomingCall, vcfDataLineTable=vcfDataLineTable, fmsIpTrafOutOctetsCounter=fmsIpTrafOutOctetsCounter, fclFrSeInBIsdn=fclFrSeInBIsdn, fcmAlrmEvtEvent5=fcmAlrmEvtEvent5, fmOsiISISISAdjAreaAddrAdjIndex=fmOsiISISISAdjAreaAddrAdjIndex, fclX25CfnDlnKWindowSize=fclX25CfnDlnKWindowSize, dcfDataLineDtr108=dcfDataLineDtr108, fmRip2PeerAddress=fmRip2PeerAddress, fcxServStaticType=fcxServStaticType, dcvVoicePhysPortId=dcvVoicePhysPortId, fclAsynCfgX3UserProfilePart2=fclAsynCfgX3UserProfilePart2, fclAsynX28PlusLpIdleTimerDelay=fclAsynX28PlusLpIdleTimerDelay, fcfTokenRing=fcfTokenRing, fcxRoutAddressFilteringEntry=fcxRoutAddressFilteringEntry, fcmMgtFctCugChecking=fcmMgtFctCugChecking, fcsnaGpRoutDsap=fcsnaGpRoutDsap, fmsPppAuthMasterAuthentication=fmsPppAuthMasterAuthentication, fmsE1Ds1ChIfInUcastPkts=fmsE1Ds1ChIfInUcastPkts, vcmAlrmTftpTable=vcmAlrmTftpTable, vcvFxxConfRingingProfile=vcvFxxConfRingingProfile, fmsEthInFCSErrorsCounter=fmsEthInFCSErrorsCounter, fmOspfStandardVirtNbrIpAddr=fmOspfStandardVirtNbrIpAddr, fclAsynX28PlusLpLogPortId=fclAsynX28PlusLpLogPortId, fmsFrDlcRcvdSigStatus=fmsFrDlcRcvdSigStatus, fmuFunctionLoadStat=fmuFunctionLoadStat, dclFrTeLpInterfaceId=dclFrTeLpInterfaceId, fclFrCfcLmiT392PollingVerifTimer=fclFrCfcLmiT392PollingVerifTimer, fclFrPvcQosInBc=fclFrPvcQosInBc, fclAsynCfgX3Part2ConfigId=fclAsynCfgX3Part2ConfigId, vclFrLmiParaStandard=vclFrLmiParaStandard, fcxCircVirtualPortId=fcxCircVirtualPortId, fclFrTeParGenBookingUbrThreshold=fclFrTeParGenBookingUbrThreshold, fcfIsdnDSigInactivityTimer=fcfIsdnDSigInactivityTimer, fcwConvMultiOutConvertedAddr=fcwConvMultiOutConvertedAddr, fcfLineV35DceSignalEntry=fcfLineV35DceSignalEntry, fclFrPvcQualityOfServiceTable=fclFrPvcQualityOfServiceTable, fdpModemManagement=fdpModemManagement, vclFrCeLpInterfaceId=vclFrCeLpInterfaceId, fcxRoutStaticRouteTicks=fcxRoutStaticRouteTicks, dcvRemNetStatus=dcvRemNetStatus, fmsRvpConnOutOctetsCounter=fmsRvpConnOutOctetsCounter, fclHdlcLpInactivityCheckDelay=fclHdlcLpInactivityCheckDelay, fmsEthPolarityInversion=fmsEthPolarityInversion, fcsnaGpX25Entry=fcsnaGpX25Entry, dcvTftpRetryTimer=dcvTftpRetryTimer, fclX25CfnSigConvMultiCalledAddrInCall=fclX25CfnSigConvMultiCalledAddrInCall, fciEgpNeighborTable=fciEgpNeighborTable, fclX25CfnNegotiatedFacilityTable=fclX25CfnNegotiatedFacilityTable, dclFrTeLogPortEntry=dclFrTeLogPortEntry, fclBX780IdentTermId=fclBX780IdentTermId, sc103_6W_M=sc103_6W_M, fmsFrLpOutFecnFrames=fmsFrLpOutFecnFrames, fclX25AccConnectionType=fclX25AccConnectionType, fmOsiISIS=fmOsiISIS, fmeFamStoredEventsCommand=fmeFamStoredEventsCommand, dcvCASConfSeizureAckPulseDuration=dcvCASConfSeizureAckPulseDuration, fciRipVpVirtualPortId=fciRipVpVirtualPortId, fmsInputIntrPktsCounter=fmsInputIntrPktsCounter, vclFrCommunicationEquipment=vclFrCommunicationEquipment, fmOsiCLNPCircInPDUs=fmOsiCLNPCircInPDUs, fmsFrDlcOutOctets=fmsFrDlcOutOctets, fcmMgfActName=fcmMgfActName, fclAsynCfgX3UserP19EditingSignal=fclAsynCfgX3UserP19EditingSignal, fcfLineV28AsynOutDceSignalEntry=fcfLineV28AsynOutDceSignalEntry, fccLocalNeighborTable=fccLocalNeighborTable, fclB3270LpMessageRetryNumber=fclB3270LpMessageRetryNumber, fcxRoutAddrFltCircuitId=fcxRoutAddrFltCircuitId, fcvRvpReliableVirtualCircuit=fcvRvpReliableVirtualCircuit, dcmAlrmSyncEntry=dcmAlrmSyncEntry, vcvToneGenEntry=vcvToneGenEntry, dcvVoiceProfSilenceDetectionLevel=dcvVoiceProfSilenceDetectionLevel, fclX25PstnRemPstnNumber=fclX25PstnRemPstnNumber, fciRipNeighborBackupGroup=fciRipNeighborBackupGroup, fclFrPvcTunFrseConfiguration=fclFrPvcTunFrseConfiguration, fclX25CfnSerStatSignalling=fclX25CfnSerStatSignalling, fcwLoadAndTrafficEventsTimer=fcwLoadAndTrafficEventsTimer, fdpModResponseEntry=fdpModResponseEntry, fmRip2IfStatEntry=fmRip2IfStatEntry, vcSystem=vcSystem, vcvVoiceSwInsPrefix=vcvVoiceSwInsPrefix, fciTelnetPwd=fciTelnetPwd, fcwServices=fcwServices, fcsnaLvpParamBe=fcsnaLvpParamBe, fciEgpNeighborIpAddress=fciEgpNeighborIpAddress, vcvFxxConfTxRecallSignalDuration=vcvFxxConfTxRecallSignalDuration, fclAsynCfgStatus=fclAsynCfgStatus, fcCtlAlteredLpId=fcCtlAlteredLpId, fclB3270HosLpLogPortId=fclB3270HosLpLogPortId, sc512=sc512, fclAsynPstnRemotePeerEntry=fclAsynPstnRemotePeerEntry, dcvSnmpGenVirtualPortId=dcvSnmpGenVirtualPortId, fmsEthTdrLoc=fmsEthTdrLoc, fmsPppAuthMasterSuccessCounter=fmsPppAuthMasterSuccessCounter, fclFrCfsGenBookingVbrRtThreshold=fclFrCfsGenBookingVbrRtThreshold, fmsS2BChIfCallingAddress=fmsS2BChIfCallingAddress, fciLvpStatus=fciLvpStatus, fcxRipOutFltStatus=fcxRipOutFltStatus, fmOsiCLNPSysErrMemFails=fmOsiCLNPSysErrMemFails, dclFrSeLpLogPortId=dclFrSeLpLogPortId, vclFrLmiParaConfigId=vclFrLmiParaConfigId, fmOsiISISRAAddress=fmOsiISISRAAddress, vcwEquipIpVirtualPortAddr=vcwEquipIpVirtualPortAddr, fclX25CfnDlnOutgoingChannelCount=fclX25CfnDlnOutgoingChannelCount, fclX25CfaNegPacketSize=fclX25CfaNegPacketSize, fccRneighStatus=fccRneighStatus, vcSysConfActive=vcSysConfActive, dcvVoicePhysicalPortEntry=dcvVoicePhysicalPortEntry, fmOsiISISReachableAddressTable=fmOsiISISReachableAddressTable, dcvCASConfDtmfDigitLevel=dcvCASConfDtmfDigitLevel, dcmAlrmGenTrapSend=dcmAlrmGenTrapSend, fclAsynX28PlusRemCfgX3P06ServiceSignals=fclAsynX28PlusRemCfgX3P06ServiceSignals, fmsS0BChChannelId=fmsS0BChChannelId, fcsnaLvpTrParamTW=fcsnaLvpTrParamTW, vcvEMSwLogPortSetId=vcvEMSwLogPortSetId, fclBSctLogPortEntry=fclBSctLogPortEntry, fclX25AccPrivLogPortId=fclX25AccPrivLogPortId, fclX25AccPvcMinimumRecallTimer=fclX25AccPvcMinimumRecallTimer, fcvLvpFltCondMask=fcvLvpFltCondMask, fciVpStatus=fciVpStatus, fcfLineV11DteSyn=fcfLineV11DteSyn, fclPppCfaLocalPassword=fclPppCfaLocalPassword, fciEgpTargetAsStatus=fciEgpTargetAsStatus, vclFrSeSigN200RetransMaxCount=vclFrSeSigN200RetransMaxCount, fmsPppProtoLcpDiag=fmsPppProtoLcpDiag, fciFlowEntry=fciFlowEntry, fclHdlcAutoCallDirection=fclHdlcAutoCallDirection, fmsFrDlcInLostFrames=fmsFrDlcInLostFrames, vcwABPvcLpTable=vcwABPvcLpTable, fcfE1Ds1ChannelIfId=fcfE1Ds1ChannelIfId, fclBSctLpMaxFrameNumberIn=fclBSctLpMaxFrameNumberIn, fclBSctProtDef1StartFrameDelimiter1=fclBSctProtDef1StartFrameDelimiter1, fmhTechnicEquipmType=fmhTechnicEquipmType, fclPppCfaRemPassword=fclPppCfaRemPassword, fcwSResProtocolIdentifierTransmission=fcwSResProtocolIdentifierTransmission, vcmAlrmGenTyp=vcmAlrmGenTyp, fmuFunctionPae=fmuFunctionPae, fclFraPvcEndPointEntry=fclFraPvcEndPointEntry, fcfIsdnBriCountry=fcfIsdnBriCountry, fclPppCfgLcpLocalMtu=fclPppCfgLcpLocalMtu, fmStatS2BChannelEntry=fmStatS2BChannelEntry, fclX25MlpIsdnRemCallRetryCount=fclX25MlpIsdnRemCallRetryCount, fmOsiISISCircInPdu=fmOsiISISCircInPdu, fclSdlcLpWindowSize=fclSdlcLpWindowSize, vcvSnmpManagerTable=vcvSnmpManagerTable, fciOspfVlDRPriority=fciOspfVlDRPriority, fclX25InDIsdnRemLogPortId=fclX25InDIsdnRemLogPortId, fmOspfStandardLsdbType=fmOspfStandardLsdbType, fcfIsdnDSigIsdnInterfaceId=fcfIsdnDSigIsdnInterfaceId, fclAsynX28PlusRemCfgX3P15Editing=fclAsynX28PlusRemCfgX3P15Editing, fclX25CfnSerCharging=fclX25CfnSerCharging)
mibBuilder.exportSymbols("PCE-MIB", fciEgpTargetAsDistributionEntry=fciEgpTargetAsDistributionEntry, fmOspfStandardHostTOS=fmOspfStandardHostTOS, fcsnaGpRemotePuEntry=fcsnaGpRemotePuEntry, fciLocalVirtualPortTable=fciLocalVirtualPortTable, fclFrConfigSeTable=fclFrConfigSeTable, fclHdlcLpCompressMultiPacketsTimer=fclHdlcLpCompressMultiPacketsTimer, fclX25CfaNegOutputFastSelect=fclX25CfaNegOutputFastSelect, fclFrCfcEiCodCallingNumPlanId=fclFrCfcEiCodCallingNumPlanId, vcvEMConfDtmfDigitTime=vcvEMConfDtmfDigitTime, fmStatE1Ds1ChannelNumber=fmStatE1Ds1ChannelNumber, dcvCASConfDialingFormat=dcvCASConfDialingFormat, fmUsersRights=fmUsersRights, fclAsynX28PlusCfgTELENETDescription=fclAsynX28PlusCfgTELENETDescription, fmStatBrdgTraffic=fmStatBrdgTraffic, fmsFrDlcOutFrames=fmsFrDlcOutFrames, fcfIsdnDSigHighLayerCompatibility=fcfIsdnDSigHighLayerCompatibility, fcCtlAlteredDlciEntry=fcCtlAlteredDlciEntry, fclSdlcLpMinCir=fclSdlcLpMinCir, fclX25AccPstnBackPstnNumber=fclX25AccPstnBackPstnNumber, fmsFrDlcInFecnFrames=fmsFrDlcInFecnFrames, dcfNumericLineEntry=dcfNumericLineEntry, vcvFxxConfDigitReceptionTimeOut=vcvFxxConfDigitReceptionTimeOut, dcvVoiceLogicalPortTSPCM=dcvVoiceLogicalPortTSPCM, vcvEMSwConfigId=vcvEMSwConfigId, fclBSctProtDef2DataFrameTerminator1=fclBSctProtDef2DataFrameTerminator1, fmuAccessFrSuscribLineNbMax=fmuAccessFrSuscribLineNbMax, vcvEMConfMinSeizureAckPulseDuration=vcvEMConfMinSeizureAckPulseDuration, fmsBootPRelayRelayedPkts=fmsBootPRelayRelayedPkts, dcvVoiceSuscriberTable=dcvVoiceSuscriberTable, fmStatPointToPointProtocol=fmStatPointToPointProtocol, vcmAlrmLMIEntry=vcmAlrmLMIEntry, fmStatRemoteVirtualPorts=fmStatRemoteVirtualPorts, fmhE1S2ModuleDescription=fmhE1S2ModuleDescription, fcCtlConfigurationState=fcCtlConfigurationState, fcmAlrmEvtEventSelection=fcmAlrmEvtEventSelection, sc330=sc330, fcsnaLvpParamSubscriberNumber=fcsnaLvpParamSubscriberNumber, fclX25MlpRxMlpMxWinGuardRegion=fclX25MlpRxMlpMxWinGuardRegion, fmsPppProtoLineId=fmsPppProtoLineId, vcvFxxRingTable=vcvFxxRingTable, fcxRoutAddrFltFilterId=fcxRoutAddrFltFilterId, fmsFrDlcIncomingEntry=fmsFrDlcIncomingEntry, fmOspfStandardIfRetransInterval=fmOspfStandardIfRetransInterval, fclVipCluElemType=fclVipCluElemType, fdpTestState=fdpTestState, fclPppCfgConfigId=fclPppCfgConfigId, fcwSQOSX25PriorityLevel=fcwSQOSX25PriorityLevel, fclVipHosLogPortTable=fclVipHosLogPortTable, fciRip=fciRip, fcwAddrConvMultiCriterionInCallTable=fcwAddrConvMultiCriterionInCallTable, fclX25SlpAccessEntry=fclX25SlpAccessEntry, vcFrSwL0DlciPriority=vcFrSwL0DlciPriority, fclBX780LpMessageRetryNumber=fclBX780LpMessageRetryNumber, vcvVoiceProfLoopActivation=vcvVoiceProfLoopActivation, frxServicesStateChange=frxServicesStateChange, vcvVoiceTransQosBe=vcvVoiceTransQosBe, fmStatSignalEntry=fmStatSignalEntry, vcCtlConfigLoad=vcCtlConfigLoad, fcfE1PhysPortFraming=fcfE1PhysPortFraming, fclX25CfnDlnEachPacketAcknowledgement=fclX25CfnDlnEachPacketAcknowledgement, fmOspfStandardLsdbSequence=fmOspfStandardLsdbSequence, fclAsynCfgX3UserP04IdleTimerDelay=fclAsynCfgX3UserP04IdleTimerDelay, fmuFunctionAccessFrProtoco=fmuFunctionAccessFrProtoco, fcfE1Ds1ChannelEntry=fcfE1Ds1ChannelEntry, fcxServSapSysState=fcxServSapSysState, fcCtlStateCheckingResults=fcCtlStateCheckingResults, fmsS0BChIfSpeed=fmsS0BChIfSpeed, vcvIpLocMtu=vcvIpLocMtu, fmuAccessBsc3270LineNbMax=fmuAccessBsc3270LineNbMax, fcfLineV28AsynInDteSigMonitored2=fcfLineV28AsynInDteSigMonitored2, fcfLineDVBTable=fcfLineDVBTable, vcvVoicePhysPortConnector=vcvVoicePhysPortConnector, fciOspfRoutesPreference=fciOspfRoutesPreference, fcvRvpConnConnectionId=fcvRvpConnConnectionId, fclSdlcPriLpPollingGroupAddress=fclSdlcPriLpPollingGroupAddress, fclFrPvcTunAssociatedAddress=fclFrPvcTunAssociatedAddress, fciSnmpCommunityStringReadOnly=fciSnmpCommunityStringReadOnly, fmsLinesSummState=fmsLinesSummState, vclFrCeLpLogPortId=vclFrCeLpLogPortId, fclX25CfaDataLinkNetworkTable=fclX25CfaDataLinkNetworkTable, fmOspfStandardIfPollInterval=fmOspfStandardIfPollInterval, fmStatFrameRelay=fmStatFrameRelay, vcCtlErrorMessage=vcCtlErrorMessage, fclAsynPadLpEquipment=fclAsynPadLpEquipment, fclAsynX28PlusParTelLpIdleTimerSelection=fclAsynX28PlusParTelLpIdleTimerSelection, fcCtlHRCheckMsgCode=fcCtlHRCheckMsgCode, fclAsynCfgX3UserP13LfInsertion=fclAsynCfgX3UserP13LfInsertion, fcwCallPacketsDiscardThreshold=fcwCallPacketsDiscardThreshold, vcvVirtualPortId=vcvVirtualPortId, fclVipLpLogPortId=fclVipLpLogPortId, fmsInArpVpConnX121=fmsInArpVpConnX121, dcCtlConfigLoad=dcCtlConfigLoad, fmStat=fmStat, fclX25InDIsdnBackupTable=fclX25InDIsdnBackupTable, fciOspf=fciOspf, fcwSQOSX25CallingAddress=fcwSQOSX25CallingAddress, fccRoutStatus=fccRoutStatus, fclFrPvcSnaLevel3Pid=fclFrPvcSnaLevel3Pid, fclFraLmiLmiStandard=fclFraLmiLmiStandard, fcwConvMultiOutStatus=fcwConvMultiOutStatus, fcClnp=fcClnp, fclAsynCfgLinkCallResponseTimer=fclAsynCfgLinkCallResponseTimer, fclX25AccPrivateNetEntry=fclX25AccPrivateNetEntry, fclAsynX28PlusLpMnemonicType=fclAsynX28PlusLpMnemonicType, fcvLvpFltFilterCondition3Id=fcvLvpFltFilterCondition3Id, fcvRvpCir=fcvRvpCir, fclX25CfaSerStatTotalizer=fclX25CfaSerStatTotalizer, fciEgpMetricDistribution=fciEgpMetricDistribution, dcvSnmpManagerName=dcvSnmpManagerName, fcsnaLvpTrRingNo=fcsnaLvpTrRingNo, fmsBootPClientGatewayIpAddr=fmsBootPClientGatewayIpAddr, fclPppSerAutoStatus=fclPppSerAutoStatus, dcCtlErrorEntry=dcCtlErrorEntry, fmsMlpTrunkNumber=fmsMlpTrunkNumber, fmOspfStandardIfMetricIpAddress=fmOspfStandardIfMetricIpAddress, dcvCASConfDigitReceptionTimeOut=dcvCASConfDigitReceptionTimeOut, fcwSRvcRestoreIncomingCallTimer=fcwSRvcRestoreIncomingCallTimer, fclHdlcAutoCalledAddr=fclHdlcAutoCalledAddr, fcsConfigDescVersion=fcsConfigDescVersion, fcwDnicDataNetworkIdentifierCode=fcwDnicDataNetworkIdentifierCode, fciEgpAdminStatus=fciEgpAdminStatus, fclAsynCfgFacDefOutWindowSize=fclAsynCfgFacDefOutWindowSize, fmsEthManSupervisionOkCounter=fmsEthManSupervisionOkCounter, fmsEthManLineId=fmsEthManLineId, fdpModCommand=fdpModCommand, dcvSnmp=dcvSnmp, vclLogPortStatus=vclLogPortStatus, fclSdlcPriLpRemPuIdentification=fclSdlcPriLpRemPuIdentification, fciFlowSubstStatus=fciFlowSubstStatus, fclAsynX28PlusLpEntry=fclAsynX28PlusLpEntry, fcmMgfStatInputThreshold=fcmMgfStatInputThreshold, fclX25CfaNegDefInWindowSize=fclX25CfaNegDefInWindowSize, vcFrSwL1ChanelIdentifierCID=vcFrSwL1ChanelIdentifierCID, fciSnmpManagerSendTraps=fciSnmpManagerSendTraps, fmsGlobLanCpu=fmsGlobLanCpu, vcvEMConfLineSeizureAckTime=vcvEMConfLineSeizureAckTime, dclFrLmiParaN391FullStatusPollCount=dclFrLmiParaN391FullStatusPollCount, dcvToneFreq2=dcvToneFreq2, fmsFrLineActiveCircuitCount=fmsFrLineActiveCircuitCount, dcvIfPCMPhysEntry=dcvIfPCMPhysEntry, fclAsynLogPortEntry=fclAsynLogPortEntry, fclBSctProtDef2ACK1=fclBSctProtDef2ACK1, fclB3270CluClusterEntry=fclB3270CluClusterEntry, fclX25InDSwMeasureCount=fclX25InDSwMeasureCount, fclAsynCfgSerCompression=fclAsynCfgSerCompression, fclX25AccPstnBackInterfaceId=fclX25AccPstnBackInterfaceId, fmsSigSyn=fmsSigSyn, fclBX780ConnectionTable=fclBX780ConnectionTable, fcsnaLvpTrBridgeNo=fcsnaLvpTrBridgeNo, fclBSctProtDef1StFrDelimiterInhib2=fclBSctProtDef1StFrDelimiterInhib2, fclAsynCfgX3UserP06ServiceSignals=fclAsynCfgX3UserP06ServiceSignals, fclFrSeInBRemPriority=fclFrSeInBRemPriority, fclFrPvcSnaBanLinkType=fclFrPvcSnaBanLinkType, fclFrPvcTunLinkType=fclFrPvcTunLinkType, fclAsynAutoFacility=fclAsynAutoFacility, fclFrCfcLmiStandard=fclFrCfcLmiStandard, fciSnmpManagerTable=fciSnmpManagerTable, fmsIpLanNoRoutesCounter=fmsIpLanNoRoutesCounter, vcmAlrmGenDisplay=vcmAlrmGenDisplay, dcmAlrmSCEntry=dcmAlrmSCEntry, fmStatPppPhysLineTable=fmStatPppPhysLineTable, fclX25CfaDlnConfigId=fclX25CfaDlnConfigId, fccRoutRouteId=fccRoutRouteId, fclAsynCfgX3UserP08OutputDiscard=fclAsynCfgX3UserP08OutputDiscard, dcmAlrmSvcTyp=dcmAlrmSvcTyp, dcvVoiceSuscrTransportNetworkAddress=dcvVoiceSuscrTransportNetworkAddress, fmRip2IfStatSentUpdates=fmRip2IfStatSentUpdates, fciRemRemoteAddress=fciRemRemoteAddress, fclX25InBRemotePeerEntry=fclX25InBRemotePeerEntry, fciRouteStatus=fciRouteStatus, fmhTechnicalsFeatures=fmhTechnicalsFeatures, fclPppPstnRemotePeerTable=fclPppPstnRemotePeerTable, fclAsynCfgLinkBlockSize=fclAsynCfgLinkBlockSize, fclX25CfaSerMinCir=fclX25CfaSerMinCir, fclFrSeIsdnRemConfigId=fclFrSeIsdnRemConfigId, dcvIpLocAddressHost=dcvIpLocAddressHost, vcvEMPermLpId=vcvEMPermLpId, fclFrCeParGenBookingVbrRtThreshold=fclFrCeParGenBookingVbrRtThreshold, dclFrSeLpConfigId=dclFrSeLpConfigId, fclX25CfnNegMaxInPacketSize=fclX25CfnNegMaxInPacketSize, fclVipCluElementId=fclVipCluElementId, fclAsynAutoTransCFKeyHandling=fclAsynAutoTransCFKeyHandling, fcmMgfStatSummingPeriod=fcmMgfStatSummingPeriod, fclAsynX28PlusGenParDNIC=fclAsynX28PlusGenParDNIC, fcfPhysicalPortTable=fcfPhysicalPortTable, mcx09=mcx09, fclB3270HosLogPortTable=fclB3270HosLogPortTable, fcwFrDlcSetupAlarmThreshold=fcwFrDlcSetupAlarmThreshold, fmOsiISISISAdjAreaAddress=fmOsiISISISAdjAreaAddress, vcFrSwitchingTable=vcFrSwitchingTable, fclAsynLpConfigId=fclAsynLpConfigId, fciOspfAreaRangeIpAddress=fciOspfAreaRangeIpAddress, fclX25InBRemSubscriberNumber=fclX25InBRemSubscriberNumber, fcwSCompAlgorithmSelection=fcwSCompAlgorithmSelection, vcfConfLineEntry=vcfConfLineEntry, vcvSnmpManagerName=vcvSnmpManagerName, fclX25CfnDlnTwoWayChannelCount=fclX25CfnDlnTwoWayChannelCount, fclFrPvcEndPointTable=fclFrPvcEndPointTable, dcvVoiceTransportEntry=dcvVoiceTransportEntry, vcvRemoteConfName=vcvRemoteConfName, fmStatWanConnectionsEntry=fmStatWanConnectionsEntry, fclX25MlpParameterTable=fclX25MlpParameterTable, fclFrPvcSnaBanDlci=fclFrPvcSnaBanDlci, fmOsiISISRAMetric=fmOsiISISRAMetric, fmsE1Ds1ChIfOperStatus=fmsE1Ds1ChIfOperStatus, fclFrPvcTunStatus=fclFrPvcTunStatus, fclAsynGeneralParameters=fclAsynGeneralParameters, fcManagement=fcManagement, sc320_4W_1TR=sc320_4W_1TR, fclX25CfaSigConversionAimedPoint=fclX25CfaSigConversionAimedPoint, fclX25CfnProfileId=fclX25CfnProfileId, vcvEMConfTimeBetweenSuccOutCall=vcvEMConfTimeBetweenSuccOutCall, dcmAlrmGenEntry=dcmAlrmGenEntry, fclX25SlpInterfaceId=fclX25SlpInterfaceId, fmOsiISISSysttmpToExMaxSaqNums=fmOsiISISSysttmpToExMaxSaqNums, fclX25InPstnEntry=fclX25InPstnEntry, fcxAdvSysMaxPathSplits=fcxAdvSysMaxPathSplits, dcmAlrmTftpTyp=dcmAlrmTftpTyp, fciSnmpModule2TrapSourceAddrVpId=fciSnmpModule2TrapSourceAddrVpId, fclB3270CluLogPortTable=fclB3270CluLogPortTable, fcsnaLvpTrParamReliableVc=fcsnaLvpTrParamReliableVc, manager=manager, fclX25CfnDlnIncomingChannelCount=fclX25CfnDlnIncomingChannelCount, fmsFrCircuitLineId=fmsFrCircuitLineId, vcmAlrmFaxDisplay=vcmAlrmFaxDisplay, fclX25CfaSerStatLoadAndTraffic=fclX25CfaSerStatLoadAndTraffic, dcvVoiceLogPortStatus=dcvVoiceLogPortStatus, fcmAlrmEventEntry=fcmAlrmEventEntry, dcvVoiceProfEchoCancellationLength=dcvVoiceProfEchoCancellationLength, dcvIfPCMChannelEntry=dcvIfPCMChannelEntry, dcCtlErrorCode=dcCtlErrorCode, fcfLineV28DteDcd109=fcfLineV28DteDcd109, fclAsynCfgX3Part2Entry=fclAsynCfgX3Part2Entry, vcwWanRouteDnicZoAddress=vcwWanRouteDnicZoAddress, fmsBrdgTrafOutBroadcastPktsCounter=fmsBrdgTrafOutBroadcastPktsCounter, fmsLineTestState=fmsLineTestState, fcsnaGpRoutStatus=fcsnaGpRoutStatus, fclFraLmiTable=fclFraLmiTable, fmuAccessX29ReroutLineNbMax=fmuAccessX29ReroutLineNbMax, fclAsynX28PlusRemoteTELENETTable=fclAsynX28PlusRemoteTELENETTable, vcFrSwL0Dlci=vcFrSwL0Dlci, dcvTSPCMPermConfigId=dcvTSPCMPermConfigId, fclVipClusterLogPort=fclVipClusterLogPort, fmOsiISISESAdjacencyEntry=fmOsiISISESAdjacencyEntry, avb1002_EM=avb1002_EM, fclAsynLscpLpLogPortId=fclAsynLscpLpLogPortId, fmOspfStandardVirtIfEvents=fmOspfStandardVirtIfEvents, fcwSQOSX25TrafficManagementStrategy=fcwSQOSX25TrafficManagementStrategy, fclX25CfaFacInputMarkers=fclX25CfaFacInputMarkers, vcvFxxConfMinRxRecallSignalDuration=vcvFxxConfMinRxRecallSignalDuration, dclFrTeLpLmi=dclFrTeLpLmi, fccNeighStatus=fccNeighStatus, fcxAdvSysMaxHops=fcxAdvSysMaxHops, dcmAlrmLMITable=dcmAlrmLMITable)
mibBuilder.exportSymbols("PCE-MIB", fmRip2GlobalQueries=fmRip2GlobalQueries, fmsEthOutNoErrCounter=fmsEthOutNoErrCounter, fclAsynCfgSerCompressMultiPacketsTimer=fclAsynCfgSerCompressMultiPacketsTimer, fclX25AccSwitchOverEntry=fclX25AccSwitchOverEntry, fmsFrLineCircuitCount=fmsFrLineCircuitCount, fcmAlrmPhysPortTable=fcmAlrmPhysPortTable, fciOspfAreaRangeStatus=fciOspfAreaRangeStatus, fclPppPstnRemotePeerEntry=fclPppPstnRemotePeerEntry, fclX25MlpIsdnRemStatus=fclX25MlpIsdnRemStatus, fclAsynMneTransClearHangUp=fclAsynMneTransClearHangUp, fclX25InBRemCallRetryCount=fclX25InBRemCallRetryCount, fcCtlErrorTable=fcCtlErrorTable, dcfDataLineInterfaceId=dcfDataLineInterfaceId, fcfLineV28AsynInDceSigMonitored2=fcfLineV28AsynInDceSigMonitored2, fcFrameRelaySwitch=fcFrameRelaySwitch, fclX25InDIsdnRemX25AccConfigId=fclX25InDIsdnRemX25AccConfigId, fcfLineV28DceInterfaceId=fcfLineV28DceInterfaceId, fccRoutNextHopNeighborId=fccRoutNextHopNeighborId, dcvIpLocRouteNextHop=dcvIpLocRouteNextHop, dcvCASConfSigChannelDiscTimeOut=dcvCASConfSigChannelDiscTimeOut, fclVipCluElemStatus=fclVipCluElemStatus, fclB3270LogPortTable=fclB3270LogPortTable, fciOspfVpRetransmitInterval=fciOspfVpRetransmitInterval, vclFrTerminalEquipment=vclFrTerminalEquipment, fclFrPvcSnaN2RetryCount=fclFrPvcSnaN2RetryCount, fciRipStaticRoutesDistribution=fciRipStaticRoutesDistribution, fclAsynX28PlusLpEasyMnemo=fclAsynX28PlusLpEasyMnemo, fmStatE1=fmStatE1, fclAsynCfgConnFacilityTable=fclAsynCfgConnFacilityTable, fclSdlcLogPortEntry=fclSdlcLogPortEntry, fclX25MlpPstnOverflow=fclX25MlpPstnOverflow, fclAsynX28PlusRemoteCfgX3Part1Entry=fclAsynX28PlusRemoteCfgX3Part1Entry, fmsPppPhysMagicNumber=fmsPppPhysMagicNumber, fcwSRvcRestoreMinimumRecallTimer=fcwSRvcRestoreMinimumRecallTimer, fclFrCfcGenConfigId=fclFrCfcGenConfigId, dcfDataLineDsr107=dcfDataLineDsr107, dcvTSPCMPermTable=dcvTSPCMPermTable, fcbBrdgVpStatus=fcbBrdgVpStatus, fmsE1Ds1ChIfInNUcastPkts=fmsE1Ds1ChIfInNUcastPkts, fclB3270CluCallCallAddr=fclB3270CluCallCallAddr, vcvVoiceSuscrRemovedDigitNumber=vcvVoiceSuscrRemovedDigitNumber, fclVipLpPrinterRetryTimer=fclVipLpPrinterRetryTimer, cfSoftwareListPassword=cfSoftwareListPassword, fclAsynCfgX3UserP17LineDelete=fclAsynCfgX3UserP17LineDelete, fclX25InDIsdnBackStatus=fclX25InDIsdnBackStatus, fmStatGlobal=fmStatGlobal, fmRip2PeerDomain=fmRip2PeerDomain, fclX25CfaSerReliableVc=fclX25CfaSerReliableVc, dcvToneDuration1=dcvToneDuration1, fcfIsdnDChannelSigTimerEntry=fcfIsdnDChannelSigTimerEntry, fclHdlcLpX25InterframeFlagCount=fclHdlcLpX25InterframeFlagCount, fclAsynX28PlusRemCfgX3P10LineFolding=fclAsynX28PlusRemCfgX3P10LineFolding, fclFrSwitchEquipment=fclFrSwitchEquipment, compacProxySoftware=compacProxySoftware, fclX25ConfigMiscellaneous=fclX25ConfigMiscellaneous, fccLocalVirtualPortTable=fccLocalVirtualPortTable, frxDiagnostic=frxDiagnostic, dclFrSeSignallingEntry=dclFrSeSignallingEntry, fmOsiISISSysMaxAreaAddrMismatches=fmOsiISISSysMaxAreaAddrMismatches, fcfLineModDiallingCount=fcfLineModDiallingCount, fclAsynX28PlusParTELENETTable=fclAsynX28PlusParTELENETTable, vcmAlrmSCEntry=vcmAlrmSCEntry, vcvVoiceLogPortStatus=vcvVoiceLogPortStatus, dcvCASConfPauseTime=dcvCASConfPauseTime, fclFrPvcBackupDlci=fclFrPvcBackupDlci, frx1000=frx1000, fclX25AccInterfaceId=fclX25AccInterfaceId, fcfIsdn=fcfIsdn, dcmAlrmTftpEntry=dcmAlrmTftpEntry, dcvVoiceSuscrTransportNetwork=dcvVoiceSuscrTransportNetwork, fclX25SlpAccessTable=fclX25SlpAccessTable, vcvFxxLpInterfaceId=vcvFxxLpInterfaceId, fmsWanConnInOctetsCounter=fmsWanConnInOctetsCounter, fmRip2IfConfStatus=fmRip2IfConfStatus, vclFrSeSigSignalOutputWinSize=vclFrSeSigSignalOutputWinSize, fclB3270ClusterLogPort=fclB3270ClusterLogPort, fmOsiISISISAdjacencyTable=fmOsiISISISAdjacencyTable, vcvFxxConfEndOfDialingTimer=vcvFxxConfEndOfDialingTimer, vcvVoiceTransProfileId=vcvVoiceTransProfileId, fcxRouting=fcxRouting, fcsnaLvpParamT2=fcsnaLvpParamT2, fcwConvMultiInConvID=fcwConvMultiInConvID, frx300=frx300, fcvLvpLogicalPortId=fcvLvpLogicalPortId, fclSdlcSecLpLogPortId=fclSdlcSecLpLogPortId, fciTelnetUserTable=fciTelnetUserTable, fcsnaGpLanFrStatus=fcsnaGpLanFrStatus, vcvFxxLpLogPortId=vcvFxxLpLogPortId, cfFactoryReturnDate5=cfFactoryReturnDate5, fcfLineV35DceRil140=fcfLineV35DceRil140, fcmAlrmEvtEvent4=fcmAlrmEvtEvent4, fclAsynCfgX3UserProfileId=fclAsynCfgX3UserProfileId, fcfLineV35DceSyn=fcfLineV35DceSyn, dcvTftpName=dcvTftpName, fmsFrLpOutBecnFrames=fmsFrLpOutBecnFrames, mmxSoftware=mmxSoftware, fclAsynX28PlusLpMonSignalDSR=fclAsynX28PlusLpMonSignalDSR, fclAsynVdxLogPort=fclAsynVdxLogPort, fclAsynX28PlusRemCfgX3P17LineDelete=fclAsynX28PlusRemCfgX3P17LineDelete, fcsnaLvpParamLocalTest=fcsnaLvpParamLocalTest, vcmAlrmGenTable=vcmAlrmGenTable, fmOspfStandardVirtIfEntry=fmOspfStandardVirtIfEntry, fmsE1Ds1ChIfPhysId=fmsE1Ds1ChIfPhysId, fcxRoutCircType20PacketBroadcasting=fcxRoutCircType20PacketBroadcasting, vcvVoiceTransQosCir=vcvVoiceTransQosCir, cfMtbBoardSerialNumber=cfMtbBoardSerialNumber, fcwFrCongestionCount=fcwFrCongestionCount, fclX25InDSwSwitchBackThreshold=fclX25InDSwSwitchBackThreshold, fclIulConversionOutgoingCall=fclIulConversionOutgoingCall, fmOspfStandardASBdrRtrCount=fmOspfStandardASBdrRtrCount, fmhEqIdFactoryReleaseDate=fmhEqIdFactoryReleaseDate, fcxRoutCircuitTable=fcxRoutCircuitTable, fclPppBIsdnRemConfigId=fclPppBIsdnRemConfigId, vcxSoftware=vcxSoftware, fcfLineV28AsynOutDceInterfaceId=fcfLineV28AsynOutDceInterfaceId, fclSdlcSecLpLinkType=fclSdlcSecLpLinkType, fclEthernetEntry=fclEthernetEntry, vcvFxxConfigTable=vcvFxxConfigTable, fclPppConfigAuthentication=fclPppConfigAuthentication, cfCpuBoardType=cfCpuBoardType, fclPppBIsdnRemX121Addr=fclPppBIsdnRemX121Addr, fclAsynX28PlusLogPort=fclAsynX28PlusLogPort, fmsBootPClientFileName=fmsBootPClientFileName, fmsFrDlcOutDlci=fmsFrDlcOutDlci, fmStatSignalTable=fmStatSignalTable, fclFrNbStationByDlci=fclFrNbStationByDlci, dcvVoiceLogPortType=dcvVoiceLogPortType, fmsSig106=fmsSig106, vcvTftpEntry=vcvTftpEntry, fmStatEthInputTrafficTable=fmStatEthInputTrafficTable, fcmMgfConvMultiCallingAddrOutCall=fcmMgfConvMultiCallingAddrOutCall, fmOsiESIS=fmOsiESIS, fcfLineV28AsynInDceInterfaceId=fcfLineV28AsynInDceInterfaceId, fclAsynConfiguration=fclAsynConfiguration, fclX25CfaFacTransitDelay=fclX25CfaFacTransitDelay, fcsnaLvpParamCompressScrambling=fcsnaLvpParamCompressScrambling, fmOspfStandardLsdbRouterId=fmOspfStandardLsdbRouterId, vcvEMPermInterfaceId=vcvEMPermInterfaceId, fclPppCfgLcpLocalMru=fclPppCfgLcpLocalMru, fmOsiISISESAdjCircIndex=fmOsiISISESAdjCircIndex, vcfDataLineDtr108=vcfDataLineDtr108, vcvSnmpGenVirtualPortId=vcvSnmpGenVirtualPortId, fciRipNeighborOutput=fciRipNeighborOutput, fclPppBIsdnRemPeerId=fclPppBIsdnRemPeerId, fcfIsdnDSigHighLayerCharactIdent=fcfIsdnDSigHighLayerCharactIdent, fmOspfStandardVirtIfAreaID=fmOspfStandardVirtIfAreaID, fciTelnetPwdP7=fciTelnetPwdP7, fcvLvpFltFilterCondition2Id=fcvLvpFltFilterCondition2Id, fclHdlcLpReliableVc=fclHdlcLpReliableVc, fmOsiCLNP=fmOsiCLNP, fcwFrFecnBecnOfDeFramesThreshold=fcwFrFecnBecnOfDeFramesThreshold, fmOspfStandardVirtIfRetransInterval=fmOspfStandardVirtIfRetransInterval, fmsEthUpTime=fmsEthUpTime, fmsFrDlcOutgoingTable=fmsFrDlcOutgoingTable, fclPppConfigurationsTable=fclPppConfigurationsTable, fclX25CfaSigType=fclX25CfaSigType, dcwEquipDnicZoAddr=dcwEquipDnicZoAddr, fcbStpMaxAge=fcbStpMaxAge, vcSysConfHour=vcSysConfHour, dcvCASConfInterdigitTime=dcvCASConfInterdigitTime, fcwSDynLspRetransRequestTimer=fcwSDynLspRetransRequestTimer, vcvToneFreq2=vcvToneFreq2, fclX25CfaSerCir=fclX25CfaSerCir, fclX25CfaSigPacketAddressCount=fclX25CfaSigPacketAddressCount, vcvDialRxEndOfDialingTimer=vcvDialRxEndOfDialingTimer, fclX25CfaSigConversionIncomingCall=fclX25CfaSigConversionIncomingCall, fmsWanConnGrouping=fmsWanConnGrouping, fcwDataPacketsDiscardThreshold=fcwDataPacketsDiscardThreshold, fcfLineDVBStatus=fcfLineDVBStatus, fclSdlcLpSubscriberNumber=fclSdlcLpSubscriberNumber, fmOspfStandardStubMetric=fmOspfStandardStubMetric, fmsEthLinkIntegrity=fmsEthLinkIntegrity, fcxCircChecksumEnabling=fcxCircChecksumEnabling, cpcDiagnostic=cpcDiagnostic, fmStatControl=fmStatControl, dcvVirtualPortId=dcvVirtualPortId, vclLogPortType=vclLogPortType, dcvDialRxSuscriberNumber=dcvDialRxSuscriberNumber, fciBootPInterfaceStatus=fciBootPInterfaceStatus, vcvToneEnable=vcvToneEnable, fmeTrapEventType=fmeTrapEventType, fclFrCeLpLocalAddress=fclFrCeLpLocalAddress, fcxServStaticSocket=fcxServStaticSocket, fmsPppProtoIpNcpStatus=fmsPppProtoIpNcpStatus, dcmAlrmSyncDisplay=dcmAlrmSyncDisplay, fclFraLpCompressScrambling=fclFraLpCompressScrambling, dcmAlrmLMIFamilyId=dcmAlrmLMIFamilyId, fmOspfStandardVirtIfTransitDelay=fmOspfStandardVirtIfTransitDelay, mcx109=mcx109, fclBX780ConnMinimumRecallTimer=fclBX780ConnMinimumRecallTimer, fciIpRouteEntry=fciIpRouteEntry, fcxServSapInputFilteringEntry=fcxServSapInputFilteringEntry, fcvRvpConnModule0VpId=fcvRvpConnModule0VpId, fmsFrDlcInBecnFrames=fmsFrDlcInBecnFrames, fcxRoutIpxStaticRouteEntry=fcxRoutIpxStaticRouteEntry, fmsFrLpInErrors=fmsFrLpInErrors, frxLineStateChange=frxLineStateChange, fclFrCeParGenDlcSetupDiscardThreshold=fclFrCeParGenDlcSetupDiscardThreshold, fcfLineV28AsynInDceSignalTable=fcfLineV28AsynInDceSignalTable, fclAsynX28PlusRemCfgX3P11BinarySpeed=fclAsynX28PlusRemCfgX3P11BinarySpeed, fcControl=fcControl, fclVipLpInterfaceId=fclVipLpInterfaceId, fcwAddrConvMultiCriterionInCallEntry=fcwAddrConvMultiCriterionInCallEntry, dcvRemoteNetToMediaTable=dcvRemoteNetToMediaTable, fclFrPvcSnaBanTwTransmitWinSize=fclFrPvcSnaBanTwTransmitWinSize, fmuAccessX25PlsLineNbMax=fmuAccessX25PlsLineNbMax, fclX25SlpIsdnBackupTable=fclX25SlpIsdnBackupTable, fclSdlcLpBe=fclSdlcLpBe, fmsEthTestLoopback=fmsEthTestLoopback, fmStatPppProtocolStatusEntry=fmStatPppProtocolStatusEntry, fcfLineV28AsynOutDceTi142=fcfLineV28AsynOutDceTi142, fcfIsdnBriEnablingTimer=fcfIsdnBriEnablingTimer, fciBootP=fciBootP, fmOspfStandardIfAreaId=fmOspfStandardIfAreaId, cfMpbBoardSerialNumber=cfMpbBoardSerialNumber, fclFrPvcX25EncapsulationEntry=fclFrPvcX25EncapsulationEntry, fcmMgfConversionAimedPoint=fcmMgfConversionAimedPoint, vcvIpLocVirtualPortId=vcvIpLocVirtualPortId, fclFrNbStationDlci=fclFrNbStationDlci, fcbBrdgVpFcsPreservation=fcbBrdgVpFcsPreservation, fclPppSerAutoLogPortId=fclPppSerAutoLogPortId, fcxRoutStaticRouteHopCount=fcxRoutStaticRouteHopCount, fcvLvpFltFilteringFilterId=fcvLvpFltFilteringFilterId, fmuFunctionIpRouter=fmuFunctionIpRouter, fciVpNetMask=fciVpNetMask, fcwFrCirTimer=fcwFrCirTimer, fdpTestInErrOctetsCounter=fdpTestInErrOctetsCounter, vclFrSeSignallingTable=vclFrSeSignallingTable, fclBSctConnectionTable=fclBSctConnectionTable, dcvCASConfEndOfDialingTimer=dcvCASConfEndOfDialingTimer, netCentralSiteProduct=netCentralSiteProduct, fclX25CfnNegDefOutPacketSize=fclX25CfnNegDefOutPacketSize, dcCtlDate=dcCtlDate, vclHdlcLpLogPortId=vclHdlcLpLogPortId, vclFrTeLogPortEntry=vclFrTeLogPortEntry, vcvEMConfInterdigitTime=vcvEMConfInterdigitTime, dcvVoiceLogPort=dcvVoiceLogPort, fclFrCfcLmiN393MonitoredEventCount=fclFrCfcLmiN393MonitoredEventCount, fmOspfStandardLsdbTable=fmOspfStandardLsdbTable, fcxCircuitLocalVpTable=fcxCircuitLocalVpTable, fclAsynCfgLinkXonXoffParity=fclAsynCfgLinkXonXoffParity, fclFrPvcQosOutBe=fclFrPvcQosOutBe, fclX25CfaServiceTable=fclX25CfaServiceTable, vcvRemoteNetToMediaTable=vcvRemoteNetToMediaTable, dcVirtualPorts=dcVirtualPorts, dcvTSPCMSwChannIfId=dcvTSPCMSwChannIfId, fclSdlcSecClusterRemPvcLogChannel=fclSdlcSecClusterRemPvcLogChannel, fclX25MlpFramesMaxCountByLink=fclX25MlpFramesMaxCountByLink, fcxRipOutFltMask=fcxRipOutFltMask, fclFrPvcSnaBanNwIncrementAckCount=fclFrPvcSnaBanNwIncrementAckCount, fcxCircCircuitId=fcxCircCircuitId, fmsEthOutLateCollisionsCounter=fmsEthOutLateCollisionsCounter, fcwFrCongestionCheckTimer=fcwFrCongestionCheckTimer, dcvToneGenEntry=dcvToneGenEntry)
mibBuilder.exportSymbols("PCE-MIB", fcCtlAlteredDlciPpId=fcCtlAlteredDlciPpId, fclPppSerialLogPortTable=fclPppSerialLogPortTable, fcvRvpCompressMultiPacketsTimer=fcvRvpCompressMultiPacketsTimer, fcfLineModNewDiallingTimer=fcfLineModNewDiallingTimer, fcwAddressConversion=fcwAddressConversion, vpx10=vpx10, fcfIsdnBriDisablingTimer=fcfIsdnBriDisablingTimer, fcsnaLvpTrParamSubscriberNumber=fcsnaLvpTrParamSubscriberNumber, fmsEthOutLineId=fmsEthOutLineId, fmsIpLanInReceivesCounter=fmsIpLanInReceivesCounter, dclFrLmiParameterTable=dclFrLmiParameterTable, fciTelnetUserPriority=fciTelnetUserPriority, fcWanSwitch=fcWanSwitch, fclFrCfcGenSVC=fclFrCfcGenSVC, fclAsynLpSubscriberNumber=fclAsynLpSubscriberNumber, fmsFrCommStorageEntry=fmsFrCommStorageEntry, dcvToneGenTable=dcvToneGenTable, dcvVoiceProfFaxActivation=dcvVoiceProfFaxActivation, fclX25CfnSigCallAcceptedFormat=fclX25CfnSigCallAcceptedFormat, dcvTSPCMPermRemoteNumber=dcvTSPCMPermRemoteNumber, fclPppCftRestartTimer=fclPppCftRestartTimer)

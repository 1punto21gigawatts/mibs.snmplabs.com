#
# PySNMP MIB module DOT12-IF-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/DOT12-IF-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:53:56 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ValueRangeConstraint, SingleValueConstraint, ConstraintsUnion, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsUnion", "ConstraintsIntersection")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Gauge32, Counter64, iso, TimeTicks, Bits, ObjectIdentity, Unsigned32, Integer32, MibScalar, MibTable, MibTableRow, MibTableColumn, NotificationType, Counter32, ModuleIdentity, IpAddress, experimental, MibIdentifier = mibBuilder.importSymbols("SNMPv2-SMI", "Gauge32", "Counter64", "iso", "TimeTicks", "Bits", "ObjectIdentity", "Unsigned32", "Integer32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "NotificationType", "Counter32", "ModuleIdentity", "IpAddress", "experimental", "MibIdentifier")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
dot12MIB = MibIdentifier((1, 3, 6, 1, 3, 63))
dot12MIBObjects = MibIdentifier((1, 3, 6, 1, 3, 63, 1))
dot12ConfigTable = MibTable((1, 3, 6, 1, 3, 63, 1, 1), )
if mibBuilder.loadTexts: dot12ConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: dot12ConfigTable.setDescription('Configuration information for a collection of 802.12 interfaces attached to a particular system.')
dot12ConfigEntry = MibTableRow((1, 3, 6, 1, 3, 63, 1, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: dot12ConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dot12ConfigEntry.setDescription('Configuration for a particular interface to an 802.12 medium.')
dot12DesiredFramingType = MibTableColumn((1, 3, 6, 1, 3, 63, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("frameType88023", 1), ("frameType88025", 2), ("frameTypeEither", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot12DesiredFramingType.setReference("The type of framing which will be requested by the interface during the next interface MAC initialization or open action. In master mode, this is the framing mode which will be granted by the interface. Note that for a master mode interface, this object must be equal to 'frameType88023' or 'frameType88025', since a master mode interface cannot grant 'frameTypeEither'.")
if mibBuilder.loadTexts: dot12DesiredFramingType.setStatus('mandatory')
if mibBuilder.loadTexts: dot12DesiredFramingType.setDescription("The type of framing which will be requested by the interface during the next interface MAC initialization or open action. In master mode, this is the framing mode which will be granted by the interface. Note that for a master mode interface, this object must be equal to 'frameType88023' or 'frameType88025', since a master mode interface cannot grant 'frameTypeEither'.")
dot12FramingCapability = MibTableColumn((1, 3, 6, 1, 3, 63, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("frameType88023", 1), ("frameType88025", 2), ("frameTypeEither", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot12FramingCapability.setReference('The type of framing this interface is capable of supporting.')
if mibBuilder.loadTexts: dot12FramingCapability.setStatus('mandatory')
if mibBuilder.loadTexts: dot12FramingCapability.setDescription('The type of framing this interface is capable of supporting.')
dot12DesiredPromiscStatus = MibTableColumn((1, 3, 6, 1, 3, 63, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("singleAddressMode", 1), ("promiscuousMode", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot12DesiredPromiscStatus.setReference('This object is used to select the promiscuous mode that this interface will request in the next training packet issued on this interface. Whether the repeater grants the requested mode must be verified by examining the state of the PP bits in the corresponding instance of dot12LastTrainingConfig. In master mode, this object controls whether or not promiscuous mode will be granted by the interface when requested by the lower level device. Note that this object indicates the desired mode for the next time the interface trains. The currently active mode will be reflected in dot12LastTrainingConfig and in ifPromiscuousMode.')
if mibBuilder.loadTexts: dot12DesiredPromiscStatus.setStatus('mandatory')
if mibBuilder.loadTexts: dot12DesiredPromiscStatus.setDescription('This object is used to select the promiscuous mode that this interface will request in the next training packet issued on this interface. Whether the repeater grants the requested mode must be verified by examining the state of the PP bits in the corresponding instance of dot12LastTrainingConfig. In master mode, this object controls whether or not promiscuous mode will be granted by the interface when requested by the lower level device. Note that this object indicates the desired mode for the next time the interface trains. The currently active mode will be reflected in dot12LastTrainingConfig and in ifPromiscuousMode.')
dot12TrainingVersion = MibTableColumn((1, 3, 6, 1, 3, 63, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot12TrainingVersion.setReference('The value that will be used in the version bits (vvv bits) in training frames on this interface. This is the highest version number supported by this MAC.')
if mibBuilder.loadTexts: dot12TrainingVersion.setStatus('mandatory')
if mibBuilder.loadTexts: dot12TrainingVersion.setDescription('The value that will be used in the version bits (vvv bits) in training frames on this interface. This is the highest version number supported by this MAC.')
dot12LastTrainingConfig = MibTableColumn((1, 3, 6, 1, 3, 63, 1, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot12LastTrainingConfig.setReference('This 16 bit field contains the configuration bits from the most recent error-free training frame received during training on this interface. Training request frames are received when in master mode, while training response frames are received in slave mode. On master mode interfaces, this object contains the contents of the requested configuration field of the most recent traing request frame. On slave mode interfaces, this object contains the contents of the allowed configuration field of the most recent training response frame. The format of the current version of this field is described in section 3.7. Please refer to the most recent version of the IEEE 802.12 standard for the most up-to-date definition of the format of this object.')
if mibBuilder.loadTexts: dot12LastTrainingConfig.setStatus('mandatory')
if mibBuilder.loadTexts: dot12LastTrainingConfig.setDescription('This 16 bit field contains the configuration bits from the most recent error-free training frame received during training on this interface. Training request frames are received when in master mode, while training response frames are received in slave mode. On master mode interfaces, this object contains the contents of the requested configuration field of the most recent traing request frame. On slave mode interfaces, this object contains the contents of the allowed configuration field of the most recent training response frame. The format of the current version of this field is described in section 3.7. Please refer to the most recent version of the IEEE 802.12 standard for the most up-to-date definition of the format of this object.')
dot12Commands = MibTableColumn((1, 3, 6, 1, 3, 63, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("noOp", 1), ("open", 2), ("reset", 3), ("close", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot12Commands.setReference("If the current value of dot12Status is 'closed', setting the value of this object to 'open' will change the corresponding instance of MIB-II's ifAdminStatus to 'up', cause this interface to enter the 'opening' state, and will cause training to be initiated on this interface. The progress and success of the open is given by the values of the dot12Status object. Setting this object to 'open' when dot12Status has a value other than 'closed' has no effect. Setting the corresponding instance of ifAdminStatus to 'up' when the current value of dot12Status is 'closed' will have the same effect as setting this object to 'open'. Setting ifAdminStatus to 'up' when dot12Status has a value other than 'closed' has no effect. Setting the value of this object to 'close' will move this interface into the 'closed' state and cause all transmit and receive actions to stop. This object will then have to be set to 'open' in order to reinitiate training. Setting the corresponding instance of ifAdminStatus to 'down' will have the same effect as setting this object to 'close'. Setting the value of this object to 'reset' when the current value of dot12Status has a value other than 'closed' will reset the interface. On a reset, all MIB counters should retain their values. This will cause the MAC to initiate an acInitializeMAC action as specified in IEEE 802.12. This will cause training to be reinitiated on this interface. Setting this object to 'reset' when dot12Status has a value of 'closed' has no effect. Setting this object to 'reset' has no effect on the corresponding instance of ifAdminStatus. Setting the value of this object to 'noOp' has no effect. When read, this object will always have a value of 'noOp'.")
if mibBuilder.loadTexts: dot12Commands.setStatus('mandatory')
if mibBuilder.loadTexts: dot12Commands.setDescription("If the current value of dot12Status is 'closed', setting the value of this object to 'open' will change the corresponding instance of MIB-II's ifAdminStatus to 'up', cause this interface to enter the 'opening' state, and will cause training to be initiated on this interface. The progress and success of the open is given by the values of the dot12Status object. Setting this object to 'open' when dot12Status has a value other than 'closed' has no effect. Setting the corresponding instance of ifAdminStatus to 'up' when the current value of dot12Status is 'closed' will have the same effect as setting this object to 'open'. Setting ifAdminStatus to 'up' when dot12Status has a value other than 'closed' has no effect. Setting the value of this object to 'close' will move this interface into the 'closed' state and cause all transmit and receive actions to stop. This object will then have to be set to 'open' in order to reinitiate training. Setting the corresponding instance of ifAdminStatus to 'down' will have the same effect as setting this object to 'close'. Setting the value of this object to 'reset' when the current value of dot12Status has a value other than 'closed' will reset the interface. On a reset, all MIB counters should retain their values. This will cause the MAC to initiate an acInitializeMAC action as specified in IEEE 802.12. This will cause training to be reinitiated on this interface. Setting this object to 'reset' when dot12Status has a value of 'closed' has no effect. Setting this object to 'reset' has no effect on the corresponding instance of ifAdminStatus. Setting the value of this object to 'noOp' has no effect. When read, this object will always have a value of 'noOp'.")
dot12Status = MibTableColumn((1, 3, 6, 1, 3, 63, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 5, 6))).clone(namedValues=NamedValues(("opened", 1), ("closed", 2), ("opening", 3), ("openFailure", 5), ("linkFailure", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot12Status.setReference("The current interface status with respect to training. One of the following values: opened - Training has completed successfully. closed - MAC has been disabled by setting dot12Commands to 'close'. opening - MAC is in training. Training signals have been received. openFailure - Passed 24 error-free packets, but there is a problem, noted in the training configuration bits (dot12LastTrainingConfig). linkFailure - Training signals not received, or could not pass 24 error-free packets. Whenever the dot12Commands object is set to 'close' or ifAdminStatus is set to 'down', the MAC will go silent, dot12Status will be 'closed', and ifOperStatus will be 'down'. When the value of this object is equal to 'closed' and the dot12Commands object is set to 'open' or the ifAdminStatus object is set to 'up', training will be initiated on this interface. When the value of this object is not equal to 'closed' and the dot12Commands object is set to 'reset', training will be reinitiated on this interface. Note that sets of some other objects (e.g. dot12ControlMode) or external events (e.g. MAC protocol violations) may also cause training to be reinitiated on this interface. When training is initiated or reinitiated on an interface, the end node will send Training_Up to the master and initially go to the 'linkFailure' state and ifOperStatus will go to 'down'. When the master sends back Training_Down, dot12Status will change to the 'opening' state, and training packets will be transferred. After all of the training packets have been passed, dot12Status will change to 'linkFailure' if 24 consecutive error-free packets were not passed, 'opened' if 24 consecutive error-free packets were passed and the training configuration bits were OK, or 'openFailure' if there were 24 consecutive error-free packets, but there was a problem with the training configuration bits. When in the 'openFailure' state, the dot12LastTrainingConfig object will contain the configuration bits from the last training packet which can be examined to determine the exact reason for the training configuration failure. If training did not succeed (dot12Status is 'linkFailure' or 'openFailure), the entire process will be restarted after MAC_Retraining_Delay_Timer seconds. If training does succeed (dot12Status changes to 'opened'), ifOperStatus will change to 'up'. If training does not succeed (dot12Status changes to 'linkFailure' or 'openFailure'), ifOperStatus will remain 'down'.")
if mibBuilder.loadTexts: dot12Status.setStatus('mandatory')
if mibBuilder.loadTexts: dot12Status.setDescription("The current interface status with respect to training. One of the following values: opened - Training has completed successfully. closed - MAC has been disabled by setting dot12Commands to 'close'. opening - MAC is in training. Training signals have been received. openFailure - Passed 24 error-free packets, but there is a problem, noted in the training configuration bits (dot12LastTrainingConfig). linkFailure - Training signals not received, or could not pass 24 error-free packets. Whenever the dot12Commands object is set to 'close' or ifAdminStatus is set to 'down', the MAC will go silent, dot12Status will be 'closed', and ifOperStatus will be 'down'. When the value of this object is equal to 'closed' and the dot12Commands object is set to 'open' or the ifAdminStatus object is set to 'up', training will be initiated on this interface. When the value of this object is not equal to 'closed' and the dot12Commands object is set to 'reset', training will be reinitiated on this interface. Note that sets of some other objects (e.g. dot12ControlMode) or external events (e.g. MAC protocol violations) may also cause training to be reinitiated on this interface. When training is initiated or reinitiated on an interface, the end node will send Training_Up to the master and initially go to the 'linkFailure' state and ifOperStatus will go to 'down'. When the master sends back Training_Down, dot12Status will change to the 'opening' state, and training packets will be transferred. After all of the training packets have been passed, dot12Status will change to 'linkFailure' if 24 consecutive error-free packets were not passed, 'opened' if 24 consecutive error-free packets were passed and the training configuration bits were OK, or 'openFailure' if there were 24 consecutive error-free packets, but there was a problem with the training configuration bits. When in the 'openFailure' state, the dot12LastTrainingConfig object will contain the configuration bits from the last training packet which can be examined to determine the exact reason for the training configuration failure. If training did not succeed (dot12Status is 'linkFailure' or 'openFailure), the entire process will be restarted after MAC_Retraining_Delay_Timer seconds. If training does succeed (dot12Status changes to 'opened'), ifOperStatus will change to 'up'. If training does not succeed (dot12Status changes to 'linkFailure' or 'openFailure'), ifOperStatus will remain 'down'.")
dot12CurrentFramingType = MibTableColumn((1, 3, 6, 1, 3, 63, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("frameType88023", 1), ("frameType88025", 2), ("frameTypeUnknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot12CurrentFramingType.setStatus('mandatory')
if mibBuilder.loadTexts: dot12CurrentFramingType.setDescription("When dot12DesiredFramingType is one of 'frameType88023' or 'frameType88025', this is the type of framing asserted by the interface. When dot12DesiredFramingType is 'frameTypeEither', dot12CurrentFramingType shall be one of 'frameType88023' or 'frameType88025' when the dot12Status is 'opened'. When the dot12Status is anything other than 'opened', dot12CurrentFramingType shall take the value of 'frameTypeUnknown'.")
dot12ControlMode = MibTableColumn((1, 3, 6, 1, 3, 63, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("masterMode", 1), ("slaveMode", 2), ("learn", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot12ControlMode.setStatus('mandatory')
if mibBuilder.loadTexts: dot12ControlMode.setDescription("This object is used to configure and report whether or not this interface is operating in master mode. In a Demand Priority network, end node interfaces typically operate in slave mode, while switch interfaces may control the Demand Priority protocol and operate in master mode. This object may be implemented as a read-only object by those agents and interfaces that do not implement software control of master mode. In particular, interfaces that cannot operate in master mode, and interfaces on which master mode is controlled by a pushbutton on the device, should implement this object read-only. Some interfaces do not require network management configuration of this feature and can autosense whether to use master mode or slave mode. The value 'learn' is used for that purpose. While autosense is taking place, the value 'learn' is returned. A network management operation which modifies the value of dot12ControlMode causes the interface to retrain.")
dot12StatTable = MibTable((1, 3, 6, 1, 3, 63, 1, 2), )
if mibBuilder.loadTexts: dot12StatTable.setStatus('mandatory')
if mibBuilder.loadTexts: dot12StatTable.setDescription('Statistics for a collection of 802.12 interfaces attached to a particular system.')
dot12StatEntry = MibTableRow((1, 3, 6, 1, 3, 63, 1, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: dot12StatEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dot12StatEntry.setDescription('Statistics for a particular interface to an 802.12 medium. The receive statistics in this table apply only to packets received by this station (i.e., packets whose destination address is either the local station address, the broadcast address, or a multicast address that this station is receiving, unless the station is in promiscuous mode).')
dot12InHighPriorityFrames = MibTableColumn((1, 3, 6, 1, 3, 63, 1, 2, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot12InHighPriorityFrames.setReference('This object is a count of high priority frames that have been received on this interface. Includes both good and bad high priority frames, as well as high priority training frames. Does not include normal priority frames which were priority promoted.')
if mibBuilder.loadTexts: dot12InHighPriorityFrames.setStatus('mandatory')
if mibBuilder.loadTexts: dot12InHighPriorityFrames.setDescription('This object is a count of high priority frames that have been received on this interface. Includes both good and bad high priority frames, as well as high priority training frames. Does not include normal priority frames which were priority promoted.')
dot12InHighPriorityOctets = MibTableColumn((1, 3, 6, 1, 3, 63, 1, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot12InHighPriorityOctets.setReference('This object is a count of the number of octets contained in high priority frames that have been received on this interface. This counter is incremented by OctetCount for each frame received on this interface which is counted by dot12InHighPriorityFrames. Note that this counter will roll over very quickly. It is provided for backward compatibility for Network Management protocols that do not support 64 bit counters (e.g. SNMP version 1).')
if mibBuilder.loadTexts: dot12InHighPriorityOctets.setStatus('mandatory')
if mibBuilder.loadTexts: dot12InHighPriorityOctets.setDescription('This object is a count of the number of octets contained in high priority frames that have been received on this interface. This counter is incremented by OctetCount for each frame received on this interface which is counted by dot12InHighPriorityFrames. Note that this counter will roll over very quickly. It is provided for backward compatibility for Network Management protocols that do not support 64 bit counters (e.g. SNMP version 1).')
dot12InNormPriorityFrames = MibTableColumn((1, 3, 6, 1, 3, 63, 1, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot12InNormPriorityFrames.setReference('This object is a count of normal priority frames that have been received on this interface. Includes both good and bad normal priority frames, as well as normal priority training frames and normal priority frames which were priority promoted.')
if mibBuilder.loadTexts: dot12InNormPriorityFrames.setStatus('mandatory')
if mibBuilder.loadTexts: dot12InNormPriorityFrames.setDescription('This object is a count of normal priority frames that have been received on this interface. Includes both good and bad normal priority frames, as well as normal priority training frames and normal priority frames which were priority promoted.')
dot12InNormPriorityOctets = MibTableColumn((1, 3, 6, 1, 3, 63, 1, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot12InNormPriorityOctets.setReference('This object is a count of the number of octets contained in normal priority frames that have been received on this interface. This counter is incremented by OctetCount for each frame received on this interface which is counted by dot12InNormPriorityFrames. Note that this counter will roll over very quickly. It is provided for backward compatibility for Network Management protocols that do not support 64 bit counters (e.g. SNMP version 1).')
if mibBuilder.loadTexts: dot12InNormPriorityOctets.setStatus('mandatory')
if mibBuilder.loadTexts: dot12InNormPriorityOctets.setDescription('This object is a count of the number of octets contained in normal priority frames that have been received on this interface. This counter is incremented by OctetCount for each frame received on this interface which is counted by dot12InNormPriorityFrames. Note that this counter will roll over very quickly. It is provided for backward compatibility for Network Management protocols that do not support 64 bit counters (e.g. SNMP version 1).')
dot12InIPMErrors = MibTableColumn((1, 3, 6, 1, 3, 63, 1, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot12InIPMErrors.setReference('This object is a count of the number of frames that have been received on this interface with an invalid packet marker and no PMI errors. A repeater will write an invalid packet marker to the end of a frame containing errors as it is forwarded through the repeater to the other ports. This counter is incremented by one for each frame received on this interface which has had an invalid packet marker added to the end of the frame.')
if mibBuilder.loadTexts: dot12InIPMErrors.setStatus('mandatory')
if mibBuilder.loadTexts: dot12InIPMErrors.setDescription('This object is a count of the number of frames that have been received on this interface with an invalid packet marker and no PMI errors. A repeater will write an invalid packet marker to the end of a frame containing errors as it is forwarded through the repeater to the other ports. This counter is incremented by one for each frame received on this interface which has had an invalid packet marker added to the end of the frame.')
dot12InOversizeFrameErrors = MibTableColumn((1, 3, 6, 1, 3, 63, 1, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot12InOversizeFrameErrors.setReference('This object is a count of oversize frames received on this interface. This counter is incremented by one for each frame received on this interface whose OctetCount is larger than the maximum legal frame size. The frame size which causes this counter to increment is dependent on the current framing type.')
if mibBuilder.loadTexts: dot12InOversizeFrameErrors.setStatus('mandatory')
if mibBuilder.loadTexts: dot12InOversizeFrameErrors.setDescription('This object is a count of oversize frames received on this interface. This counter is incremented by one for each frame received on this interface whose OctetCount is larger than the maximum legal frame size. The frame size which causes this counter to increment is dependent on the current framing type.')
dot12InDataErrors = MibTableColumn((1, 3, 6, 1, 3, 63, 1, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot12InDataErrors.setReference('This object is a count of errored frames received on this interface. This counter is incremented by one for each frame received on this interface with any of the following errors: bad FCS (with no IPM), PMI errors (excluding frames with an IPM as the only PMI error), undersize, bad start of frame delimiter, or bad end of packet marker. Does not include frames counted by dot12InIPMErrors, dot12InNullAddressedFrames, or dot12InOversizeFrameErrors. This counter indicates problems with the cable directly attached to this interface, while dot12InIPMErrors indicates problems with remote cables.')
if mibBuilder.loadTexts: dot12InDataErrors.setStatus('mandatory')
if mibBuilder.loadTexts: dot12InDataErrors.setDescription('This object is a count of errored frames received on this interface. This counter is incremented by one for each frame received on this interface with any of the following errors: bad FCS (with no IPM), PMI errors (excluding frames with an IPM as the only PMI error), undersize, bad start of frame delimiter, or bad end of packet marker. Does not include frames counted by dot12InIPMErrors, dot12InNullAddressedFrames, or dot12InOversizeFrameErrors. This counter indicates problems with the cable directly attached to this interface, while dot12InIPMErrors indicates problems with remote cables.')
dot12InNullAddressedFrames = MibTableColumn((1, 3, 6, 1, 3, 63, 1, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot12InNullAddressedFrames.setReference('This object is a count of null addressed frames received on this interface. This counter is incremented by one for each frame received on this interface with a destination MAC address consisting of all zero bits. Both void and training frames are included in this counter. Note that since this station would normally not receive null addressed frames, this counter is only incremented when this station is operating in promiscuous mode or in training.')
if mibBuilder.loadTexts: dot12InNullAddressedFrames.setStatus('mandatory')
if mibBuilder.loadTexts: dot12InNullAddressedFrames.setDescription('This object is a count of null addressed frames received on this interface. This counter is incremented by one for each frame received on this interface with a destination MAC address consisting of all zero bits. Both void and training frames are included in this counter. Note that since this station would normally not receive null addressed frames, this counter is only incremented when this station is operating in promiscuous mode or in training.')
dot12OutHighPriorityFrames = MibTableColumn((1, 3, 6, 1, 3, 63, 1, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot12OutHighPriorityFrames.setReference('This counter is incremented by one for each high priority frame successfully transmitted out this interface.')
if mibBuilder.loadTexts: dot12OutHighPriorityFrames.setStatus('mandatory')
if mibBuilder.loadTexts: dot12OutHighPriorityFrames.setDescription('This counter is incremented by one for each high priority frame successfully transmitted out this interface.')
dot12OutHighPriorityOctets = MibTableColumn((1, 3, 6, 1, 3, 63, 1, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot12OutHighPriorityOctets.setReference('This counter is incremented by OctetCount for each frame counted by dot12OutHighPriorityFrames. Note that this counter will roll over very quickly. It is provided for backward compatibility for Network Management protocols that do not support 64 bit counters (e.g. SNMP version 1).')
if mibBuilder.loadTexts: dot12OutHighPriorityOctets.setStatus('mandatory')
if mibBuilder.loadTexts: dot12OutHighPriorityOctets.setDescription('This counter is incremented by OctetCount for each frame counted by dot12OutHighPriorityFrames. Note that this counter will roll over very quickly. It is provided for backward compatibility for Network Management protocols that do not support 64 bit counters (e.g. SNMP version 1).')
dot12TransitionIntoTrainings = MibTableColumn((1, 3, 6, 1, 3, 63, 1, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot12TransitionIntoTrainings.setReference("This object is a count of the number of times this interface has entered the training state. This counter is incremented by one each time dot12Status transitions to 'linkFailure' from any state other than 'opening' or 'openFailure'.")
if mibBuilder.loadTexts: dot12TransitionIntoTrainings.setStatus('mandatory')
if mibBuilder.loadTexts: dot12TransitionIntoTrainings.setDescription("This object is a count of the number of times this interface has entered the training state. This counter is incremented by one each time dot12Status transitions to 'linkFailure' from any state other than 'opening' or 'openFailure'.")
dot12Conformance = MibIdentifier((1, 3, 6, 1, 3, 63, 2))
dot12Compliances = MibIdentifier((1, 3, 6, 1, 3, 63, 2, 1))
dot12Groups = MibIdentifier((1, 3, 6, 1, 3, 63, 2, 2))
dot12Compliance = MibIdentifier((1, 3, 6, 1, 3, 63, 2, 1, 1))
dot12ConfigGroup = MibIdentifier((1, 3, 6, 1, 3, 63, 2, 2, 1))
dot12StatsGroup = MibIdentifier((1, 3, 6, 1, 3, 63, 2, 2, 2))
mibBuilder.exportSymbols("DOT12-IF-MIB", dot12StatTable=dot12StatTable, dot12LastTrainingConfig=dot12LastTrainingConfig, dot12Compliances=dot12Compliances, dot12MIBObjects=dot12MIBObjects, dot12Conformance=dot12Conformance, dot12StatsGroup=dot12StatsGroup, dot12InNormPriorityOctets=dot12InNormPriorityOctets, dot12Status=dot12Status, dot12DesiredPromiscStatus=dot12DesiredPromiscStatus, dot12OutHighPriorityOctets=dot12OutHighPriorityOctets, dot12ConfigTable=dot12ConfigTable, dot12MIB=dot12MIB, dot12DesiredFramingType=dot12DesiredFramingType, dot12Groups=dot12Groups, dot12InHighPriorityFrames=dot12InHighPriorityFrames, dot12InOversizeFrameErrors=dot12InOversizeFrameErrors, dot12FramingCapability=dot12FramingCapability, dot12CurrentFramingType=dot12CurrentFramingType, dot12InNormPriorityFrames=dot12InNormPriorityFrames, dot12OutHighPriorityFrames=dot12OutHighPriorityFrames, dot12Commands=dot12Commands, dot12Compliance=dot12Compliance, dot12InIPMErrors=dot12InIPMErrors, dot12ControlMode=dot12ControlMode, dot12InHighPriorityOctets=dot12InHighPriorityOctets, dot12InNullAddressedFrames=dot12InNullAddressedFrames, dot12ConfigEntry=dot12ConfigEntry, dot12InDataErrors=dot12InDataErrors, dot12TransitionIntoTrainings=dot12TransitionIntoTrainings, dot12TrainingVersion=dot12TrainingVersion, dot12ConfigGroup=dot12ConfigGroup, dot12StatEntry=dot12StatEntry)

#
# PySNMP MIB module EXTREME-MPLS-TE-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/EXTREME-MPLS-TE-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:08:28 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, SingleValueConstraint, ValueSizeConstraint, ConstraintsUnion, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsUnion", "ConstraintsIntersection")
extremeMplsMIB, = mibBuilder.importSymbols("EXTREME-MPLS-MIB", "extremeMplsMIB")
mplsTunnelEgressLSRId, mplsTunnelInstance, mplsTunnelIndex, mplsTunnelIngressLSRId = mibBuilder.importSymbols("MPLS-TE-STD-MIB", "mplsTunnelEgressLSRId", "mplsTunnelInstance", "mplsTunnelIndex", "mplsTunnelIngressLSRId")
ObjectGroup, NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "NotificationGroup", "ModuleCompliance")
NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, Bits, Gauge32, Unsigned32, TimeTicks, ObjectIdentity, MibIdentifier, Counter64, Integer32, Counter32, ModuleIdentity, iso, IpAddress = mibBuilder.importSymbols("SNMPv2-SMI", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Bits", "Gauge32", "Unsigned32", "TimeTicks", "ObjectIdentity", "MibIdentifier", "Counter64", "Integer32", "Counter32", "ModuleIdentity", "iso", "IpAddress")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
extremeMplsTeMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 1916, 1, 37, 2))
if mibBuilder.loadTexts: extremeMplsTeMIB.setLastUpdated('200907040000Z')
if mibBuilder.loadTexts: extremeMplsTeMIB.setOrganization('Extreme Networks, Inc.')
if mibBuilder.loadTexts: extremeMplsTeMIB.setContactInfo('www.extremenetworks.com')
if mibBuilder.loadTexts: extremeMplsTeMIB.setDescription('Extreme extensions to mplsTeStdMIB')
extremeMplsTeScalars = MibIdentifier((1, 3, 6, 1, 4, 1, 1916, 1, 37, 2, 1))
extremeMplsTeObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 1916, 1, 37, 2, 2))
extremeMplsTeConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 1916, 1, 37, 2, 3))
extremeMplsTunnelTable = MibTable((1, 3, 6, 1, 4, 1, 1916, 1, 37, 2, 2, 1), )
if mibBuilder.loadTexts: extremeMplsTunnelTable.setStatus('current')
if mibBuilder.loadTexts: extremeMplsTunnelTable.setDescription('The mplsTunnelTable (see RFC 3812) allows new MPLS tunnels to be created between an LSR and a remote endpoint, and existing tunnels to be reconfigured or removed. Note that only point-to-point tunnel segments are supported, although multipoint-to-point and point- to-multipoint connections are supported by an LSR acting as a cross-connect. Each MPLS tunnel can thus have one out-segment originating at this LSR and/or one in-segment terminating at this LSR. Extreme Networks MPLS implementation allows tunnel instances with a common endpoint to be grouped at the ingress LSR to provide redundancy. The role of each tunnel in the group must be configured and is indicated by extremeMplsTunnelRedundancyType. The failover to a redundant tunnel is implementation dependent.')
extremeMplsTunnelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1916, 1, 37, 2, 2, 1, 1), ).setIndexNames((0, "MPLS-TE-STD-MIB", "mplsTunnelIndex"), (0, "MPLS-TE-STD-MIB", "mplsTunnelInstance"), (0, "MPLS-TE-STD-MIB", "mplsTunnelIngressLSRId"), (0, "MPLS-TE-STD-MIB", "mplsTunnelEgressLSRId"))
if mibBuilder.loadTexts: extremeMplsTunnelEntry.setStatus('current')
if mibBuilder.loadTexts: extremeMplsTunnelEntry.setDescription('An entry in this table represents an extension to an MPLS tunnel reported in the mplsTunnelTable (see RFC 3812). An entry can be created by a network administrator or by an SNMP agent as instructed by an MPLS signalling protocol. An entry in this table displays an ingress tunnel only since the tunnel type is a configured value at the local node and is not exchanged by the signalling protocol.')
mplsTunnelRedundancyType = MibTableColumn((1, 3, 6, 1, 4, 1, 1916, 1, 37, 2, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("primary", 1), ("secondary", 2))).clone('primary')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mplsTunnelRedundancyType.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelRedundancyType.setDescription('Identifies the tunnel redundancy type associated with this tunnel instance. A value of primary(1) or secondary(2) MAY be assigned by the network administrator or by an SNMP manager at the time of setting up the tunnel.')
mplsTunnelRedundancyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1916, 1, 37, 2, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("standby", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTunnelRedundancyStatus.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelRedundancyStatus.setDescription('Indicates the actual redundancy status of this tunnel. When the status is active, the tunnel is the preferred tunnel in the group.')
mplsTunnelTransportStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1916, 1, 37, 2, 2, 1, 1, 3), Bits().clone(namedValues=NamedValues(("allowAllIp", 0), ("allowAssignedIpOnly", 1), ("allowAllLayer2Vpn", 2), ("allowAsignedLayer2VpnOnly", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mplsTunnelTransportStatus.setStatus('current')
if mibBuilder.loadTexts: mplsTunnelTransportStatus.setDescription('Indicates the type of traffic the tunnel group can be used for sending. When the allowAllIp(0) bit is set, IP traffic destined for all IPv4 routes will be allowed over any tunnel in the group marked active. When the allowAssignedIpOnly(1) bit is set, IP traffic destined only for IPv4 static routes that have been explicitly configured to use this tunnel group will be allowed. When the allowAllLayer2Vpn(2) bit is set, layer 2 VPN traffic for all layer 2 VPNs will be allowed over any tunnel in the group marked active. When the allowAssignedLayer2VpnOnly(3) bit is set, layer 2 VPN traffic destined only for pseudo-wires that have been explicitly configured to use this tunnel group will be allowed.')
mibBuilder.exportSymbols("EXTREME-MPLS-TE-MIB", extremeMplsTunnelTable=extremeMplsTunnelTable, mplsTunnelTransportStatus=mplsTunnelTransportStatus, extremeMplsTeScalars=extremeMplsTeScalars, PYSNMP_MODULE_ID=extremeMplsTeMIB, mplsTunnelRedundancyType=mplsTunnelRedundancyType, extremeMplsTeObjects=extremeMplsTeObjects, extremeMplsTeConformance=extremeMplsTeConformance, extremeMplsTunnelEntry=extremeMplsTunnelEntry, mplsTunnelRedundancyStatus=mplsTunnelRedundancyStatus, extremeMplsTeMIB=extremeMplsTeMIB)

#
# PySNMP MIB module ATKKACTN-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/ATKKACTN-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:30:57 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueSizeConstraint, ValueRangeConstraint, SingleValueConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueSizeConstraint", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsUnion")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Bits, IpAddress, iso, Integer32, MibIdentifier, Unsigned32, Counter32, ModuleIdentity, ObjectIdentity, TimeTicks, enterprises, Counter64, MibScalar, MibTable, MibTableRow, MibTableColumn, Gauge32, NotificationType = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "IpAddress", "iso", "Integer32", "MibIdentifier", "Unsigned32", "Counter32", "ModuleIdentity", "ObjectIdentity", "TimeTicks", "enterprises", "Counter64", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Gauge32", "NotificationType")
TextualConvention, DisplayString, PhysAddress = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString", "PhysAddress")
alliedTelesyn = MibIdentifier((1, 3, 6, 1, 4, 1, 207))
products = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1))
mibObject = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8))
repeaterMib = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 1))
newRepeaterMib = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 1, 20))
acctonHubMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3))
acctonCommon = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 1))
accsystem = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 1, 1))
majorVer = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: majorVer.setStatus('mandatory')
if mibBuilder.loadTexts: majorVer.setDescription('Software major version')
minorVer = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: minorVer.setStatus('mandatory')
if mibBuilder.loadTexts: minorVer.setDescription('Software minor version')
hardwareVer = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hardwareVer.setStatus('mandatory')
if mibBuilder.loadTexts: hardwareVer.setDescription('Hardware version of system board')
communityMgt = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 1, 2))
communityStringSize = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 1, 2, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: communityStringSize.setStatus('mandatory')
if mibBuilder.loadTexts: communityStringSize.setDescription('The length of the community string')
communityTableSize = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 1, 2, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: communityTableSize.setStatus('mandatory')
if mibBuilder.loadTexts: communityTableSize.setDescription('The size of the community table')
communityTable = MibTable((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 1, 2, 3), )
if mibBuilder.loadTexts: communityTable.setStatus('mandatory')
if mibBuilder.loadTexts: communityTable.setDescription('Community table')
communityEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 1, 2, 3, 1), ).setIndexNames((0, "ATKKACTN-MIB", "communityIndex"))
if mibBuilder.loadTexts: communityEntry.setStatus('mandatory')
if mibBuilder.loadTexts: communityEntry.setDescription('')
communityIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 1, 2, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: communityIndex.setStatus('mandatory')
if mibBuilder.loadTexts: communityIndex.setDescription('Index in community table')
communityString = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 1, 2, 3, 1, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: communityString.setStatus('mandatory')
if mibBuilder.loadTexts: communityString.setDescription('Community string; the length is limited by communityStringSize')
communityAccessMode = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 1, 2, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("readOnly", 1), ("readWrite", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: communityAccessMode.setStatus('mandatory')
if mibBuilder.loadTexts: communityAccessMode.setDescription('Access mode of the community')
communityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 1, 2, 3, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: communityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: communityStatus.setDescription('Entries marked valid or invalid can not be changed. When a manager wants to define a new community, he sets an entry from valid or invalid to underChange, then begins to define values in the table. After the entry is completed, change it to valid, then the community is enabled. To delete a community, just change the status to invalid. Currentlty, only three values are accepted: invalid -- 0, underChange -- 1, valid -- 2. ')
trapManagerMgt = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 1, 3))
trapManagerTableSize = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 1, 3, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trapManagerTableSize.setStatus('mandatory')
if mibBuilder.loadTexts: trapManagerTableSize.setDescription('Size of trap manager table')
trapManagerTable = MibTable((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 1, 3, 2), )
if mibBuilder.loadTexts: trapManagerTable.setStatus('mandatory')
if mibBuilder.loadTexts: trapManagerTable.setDescription('The trap manager table')
trapManagerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 1, 3, 2, 1), ).setIndexNames((0, "ATKKACTN-MIB", "trapMgrIndex"))
if mibBuilder.loadTexts: trapManagerEntry.setStatus('mandatory')
if mibBuilder.loadTexts: trapManagerEntry.setDescription('')
trapMgrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 1, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trapMgrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: trapMgrIndex.setDescription('Index to the trap manager table')
trapMgrCommunityIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 1, 3, 2, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trapMgrCommunityIndex.setStatus('mandatory')
if mibBuilder.loadTexts: trapMgrCommunityIndex.setDescription('Community string specified by the index in the community table')
trapMgrIpaddress = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 1, 3, 2, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trapMgrIpaddress.setStatus('mandatory')
if mibBuilder.loadTexts: trapMgrIpaddress.setDescription('IP address of the network manager')
trapMgrEntryStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 1, 3, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("invalid", 0), ("underChange", 1), ("valid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trapMgrEntryStatus.setStatus('mandatory')
if mibBuilder.loadTexts: trapMgrEntryStatus.setDescription('Entries marked valid or invalid can not be changed. To define a new manager, set an entry from valid or invalid to underChange. Then fill in the required information. Setting the status to valid enables the entry. Setting the status to invalid deletes the entry. Currentlty, only three value are accepted: invalid -- 0, underChange -- 1, valid -- 2. ')
downloadMgt = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 1, 4))
downloadServerIP = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 1, 4, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: downloadServerIP.setStatus('mandatory')
if mibBuilder.loadTexts: downloadServerIP.setDescription('The file server with the download file')
downloadFilename = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 1, 4, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: downloadFilename.setStatus('mandatory')
if mibBuilder.loadTexts: downloadFilename.setDescription('Name of file to download')
downloadMode = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 1, 4, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("permanant", 1), ("temporary", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: downloadMode.setStatus('mandatory')
if mibBuilder.loadTexts: downloadMode.setDescription('Permanent upgrade stores download software into permanent storage of the agent device. Temporary upgrade just puts download software in RAM, often for a test only.')
downloadAction = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 1, 4, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("run", 1), ("noRun", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: downloadAction.setStatus('mandatory')
if mibBuilder.loadTexts: downloadAction.setDescription('DownloadAction triggers the download operation. The run option starts the new software after downloading is complete. The noRun option does not execute the new software. The new software will be effective after the next restart. Note that the noRun option is useful only when the download is permanent.')
restart = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: restart.setStatus('mandatory')
if mibBuilder.loadTexts: restart.setDescription('A write to restart the machine Currentlty, only three value are accepted: normal -- 0, coldstart -- 1, warmstart -- 2. ')
acctest = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 1, 6))
testTrap = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 1, 6, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("test", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: testTrap.setStatus('mandatory')
if mibBuilder.loadTexts: testTrap.setDescription('A write to testTrap triggers a warm-start trap for testing trap capability')
ipxtrapManagerMgt = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 1, 7))
ipxtrapManagerTableSize = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 1, 7, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxtrapManagerTableSize.setStatus('mandatory')
if mibBuilder.loadTexts: ipxtrapManagerTableSize.setDescription('Size of ipx trap manager table')
ipxtrapManagerTable = MibTable((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 1, 7, 2), )
if mibBuilder.loadTexts: ipxtrapManagerTable.setStatus('mandatory')
if mibBuilder.loadTexts: ipxtrapManagerTable.setDescription('The ipx trap manager table')
ipxtrapManagerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 1, 7, 2, 1), ).setIndexNames((0, "ATKKACTN-MIB", "ipxtrapMgrIndex"))
if mibBuilder.loadTexts: ipxtrapManagerEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ipxtrapManagerEntry.setDescription('')
ipxtrapMgrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 1, 7, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxtrapMgrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ipxtrapMgrIndex.setDescription('Index to the ipx trap manager table')
ipxtrapMgrCommunityIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 1, 7, 2, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxtrapMgrCommunityIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ipxtrapMgrCommunityIndex.setDescription('Community string specified by the index in the community table')
ipxtrapMgrNetNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 1, 7, 2, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxtrapMgrNetNumber.setStatus('mandatory')
if mibBuilder.loadTexts: ipxtrapMgrNetNumber.setDescription('The network number portion of the IPX address of this network manager')
ipxtrapMgrNode = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 1, 7, 2, 1, 4), PhysAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxtrapMgrNode.setStatus('mandatory')
if mibBuilder.loadTexts: ipxtrapMgrNode.setDescription('The node number portion of the IPX address of this network manager')
ipxtrapMgrEntryStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 1, 20, 3, 1, 7, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("invalid", 1), ("valid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxtrapMgrEntryStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ipxtrapMgrEntryStatus.setDescription('Entries marked valid or invalid can not be changed. To define a new manager, set an entry from valid or invalid to underChange. Then fill in the required information. Setting the status to valid enables the entry. Setting the status to invalid deletes the entry.')
mibBuilder.exportSymbols("ATKKACTN-MIB", communityAccessMode=communityAccessMode, ipxtrapMgrEntryStatus=ipxtrapMgrEntryStatus, trapMgrIpaddress=trapMgrIpaddress, communityIndex=communityIndex, ipxtrapMgrIndex=ipxtrapMgrIndex, trapMgrCommunityIndex=trapMgrCommunityIndex, ipxtrapManagerMgt=ipxtrapManagerMgt, alliedTelesyn=alliedTelesyn, downloadMode=downloadMode, ipxtrapMgrNode=ipxtrapMgrNode, trapManagerMgt=trapManagerMgt, majorVer=majorVer, communityTable=communityTable, trapMgrIndex=trapMgrIndex, acctonCommon=acctonCommon, downloadFilename=downloadFilename, downloadAction=downloadAction, hardwareVer=hardwareVer, trapMgrEntryStatus=trapMgrEntryStatus, communityEntry=communityEntry, acctonHubMIB=acctonHubMIB, mibObject=mibObject, trapManagerTable=trapManagerTable, newRepeaterMib=newRepeaterMib, ipxtrapMgrCommunityIndex=ipxtrapMgrCommunityIndex, restart=restart, communityString=communityString, communityStatus=communityStatus, repeaterMib=repeaterMib, minorVer=minorVer, ipxtrapManagerTable=ipxtrapManagerTable, acctest=acctest, testTrap=testTrap, ipxtrapManagerEntry=ipxtrapManagerEntry, ipxtrapManagerTableSize=ipxtrapManagerTableSize, trapManagerEntry=trapManagerEntry, communityStringSize=communityStringSize, downloadMgt=downloadMgt, communityTableSize=communityTableSize, trapManagerTableSize=trapManagerTableSize, downloadServerIP=downloadServerIP, ipxtrapMgrNetNumber=ipxtrapMgrNetNumber, products=products, communityMgt=communityMgt, accsystem=accsystem)

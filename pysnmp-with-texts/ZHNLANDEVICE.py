#
# PySNMP MIB module ZHNLANDEVICE (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/ZHNLANDEVICE
# Produced by pysmi-0.3.4 at Wed May  1 15:46:38 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueSizeConstraint, SingleValueConstraint, ValueRangeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueSizeConstraint", "SingleValueConstraint", "ValueRangeConstraint", "ConstraintsUnion")
ObjectGroup, NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "NotificationGroup", "ModuleCompliance")
Integer32, Unsigned32, MibScalar, MibTable, MibTableRow, MibTableColumn, iso, enterprises, IpAddress, Bits, Gauge32, Counter32, Counter64, NotificationType, ObjectIdentity, MibIdentifier, ModuleIdentity, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "Integer32", "Unsigned32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "iso", "enterprises", "IpAddress", "Bits", "Gauge32", "Counter32", "Counter64", "NotificationType", "ObjectIdentity", "MibIdentifier", "ModuleIdentity", "TimeTicks")
TruthValue, RowStatus, DisplayString, MacAddress, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "TruthValue", "RowStatus", "DisplayString", "MacAddress", "TextualConvention")
VlanTypeValues, = mibBuilder.importSymbols("ZHNLAYER2BRIDGING", "VlanTypeValues")
zhoneWtn, = mibBuilder.importSymbols("Zhone", "zhoneWtn")
ZhoneRowStatus, = mibBuilder.importSymbols("Zhone-TC", "ZhoneRowStatus")
zhnLANDevice = ModuleIdentity((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41))
zhnLANDevice.setRevisions(('2012-06-13 12:00', '2012-05-10 12:00', '2012-04-11 02:11', '2012-01-27 12:00', '2011-01-11 00:00', '2010-07-21 00:00', '2010-04-01 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: zhnLANDevice.setRevisionsDescriptions(('Added new lanEthernetInterfaceConfigTable objects: zhnDhcpConditionalServingPoolObjects Added new zhnIpInterfaceTableobject naptEnabled ', 'Added new lanEthernetInterfaceConfigTable objects: lanEthernetLanFollowsWan lanEthernetIgmpPriorityMark lanEthernetIgmpPvid Added new zhnIpInterfaceTable object: alternateWanIfName Added new lanHostConfigManagementTable objects: zhnUseWanVlan zhnEnableStaticLease ', 'Modified the following objects: lanEthAclRulesTable ', 'Added the following objects: lanEthAclRulesTable lanDefaultIfName lanDefaultIfIpAddress lanEthernetAcl lanEthernetAclRulesNumberofEntries igmpGroupQuerier ', 'Fixed MIB tree and table indices. Also added lanEthIntfStatisticsTable.', 'Added pppoeConfigTable for configuring PPPoE LAN Host configuration parameters and lanEthernetRateLimitTable for configuring rate limits for LAN Ethernet Devices.', 'First Draft',))
if mibBuilder.loadTexts: zhnLANDevice.setLastUpdated('201206131200Z')
if mibBuilder.loadTexts: zhnLANDevice.setOrganization('Zhone Technologies, Inc.')
if mibBuilder.loadTexts: zhnLANDevice.setContactInfo('Zhone Technologies, Inc. Florida Design Center 8545 126th Avenue North Largo, FL 33773 Toll-Free: +1 877-ZHONE20 (+1 877-946-6320) Tel: +1-510-777-7000 Fax: +1-510-777-7001 E-mail: support@zhone.com')
if mibBuilder.loadTexts: zhnLANDevice.setDescription('This file defines the private Enterprise MIB extensions that define LAN ethernet interface related objects supported by the Zhone CPEs.')
zhnLANDeviceObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1))
class LANEthernetStatusValues(TextualConvention, OctetString):
    description = 'Ethernet LAN interface status. An enumeration of: Up NoLink Error Disabled '
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 32)

class LANEthernetMaxBitRateValues(TextualConvention, OctetString):
    description = 'The maximum upstream and downstream bit rate available to this connection. Enumeration of: 10 100 1000 Auto '
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 32)

class LANEthernetDuplexModeValues(TextualConvention, OctetString):
    description = 'The duplex mode available to this connection. Enumeration of: Half Full Auto '
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 32)

class LANEthernetPauseModeValues(TextualConvention, OctetString):
    description = 'The pause mode available to this connection. Enumeration of: Auto Enable Disable '
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 32)

class IPInterfaceAddressingTypeValues(TextualConvention, OctetString):
    description = 'The addressing method used to assign the LAN-side IP Address. Enumeration of: Unknown Unconfigured Default DHCP Static PPPoE '
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 32)

class IGMPSnoopingModeValues(TextualConvention, OctetString):
    description = 'Enumeration of: Standard Blocking '
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 32)

class DNSTypeValues(TextualConvention, OctetString):
    description = 'Enumeration of: Default - Get the DNS information from the uplink interface Static - The DNS information is manually provisioned DHCP - The DNS information is obtained via DHCP '
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 32)

class IpPppoeConnectionTypeValues(TextualConvention, OctetString):
    description = 'Enumeration of: IP_Routed IP_Bridged PPPoE_IP_Routed PPPoE_IP_Bridged Unconfigured '
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 32)

class PPPUserConnectionRequestValues(TextualConvention, OctetString):
    description = 'Enumeration of: None Down Up Connect Disconnect '
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 32)

class PPPAuthenticationProtocolValues(TextualConvention, OctetString):
    description = 'Enumeration of: AUTO_AUTH PAP CHAP MS-CHAP '
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 32)

class PPPEncryptionProtocolValues(TextualConvention, OctetString):
    description = 'Enumeration of: None MPPE '
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 32)

class PPPCompressionProtocolValues(TextualConvention, OctetString):
    description = 'Enumeration of: None VanJacobsen STAC-LZS '
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 32)

class WANPppConnectionStatusValues(TextualConvention, OctetString):
    description = 'Enumeration of: Unconfigured Connecting Authenticating Connected PendingDisconnect Disconnecting Disconnected '
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 32)

class WANPppLastConnectionErrorValues(TextualConvention, OctetString):
    description = 'Enumeration of: ERROR_NONE ERROR_ISP_TIME_OUT ERROR_COMMAND_ABORTED ERROR_NOT_ENABLED_FOR_INTERNET ERROR_BAD_PHONE_NUMBER ERROR_USER_DISCONNECT ERROR_ISP_DISCONNECT ERROR_IDLE_DISCONNECT ERROR_FORCED_DISCONNECT ERROR_SERVER_OUT_OF_RESOURCES ERROR_RESTRICTED_LOGON_HOURS ERROR_ACCOUNT_DISABLED ERROR_ACCOUNT_EXPIRED ERROR_PASSWORD_EXPIRED ERROR_AUTHENTICATION_FAILURE ERROR_NO_DIALTONE ERROR_NO_CARRIER ERROR_NO_ANSWER ERROR_LINE_BUSY ERROR_UNSUPPORTED_BITSPERSECOND ERROR_TOO_MANY_LINE_ERRORS ERROR_IP_CONFIGURATION ERROR_UNKNOWN '
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 32)

class LANRateLimitBurstSizeValues(TextualConvention, OctetString):
    description = 'Enumeration of: 16KB 20KB 28KB 40KB 76KB 140KB 268KB 500KB '
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 32)

class LANRateLimitDirectionValues(TextualConvention, OctetString):
    description = 'Enumeration of: Inbound Outbound Both-Directions '
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 32)

class LANEthernetAclValues(TextualConvention, OctetString):
    description = 'The access list values available to an ethernet interface. Enumeration of: Disable BlackList WhiteList Unsupported '
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 32)

class LANEthernetIpProtocolValues(TextualConvention, Integer32):
    description = 'The access list IP protocol values with which to filter. Enumeration of: tcp(1) udp(2) icmp(3) igmp(4) any(5) '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))
    namedValues = NamedValues(("tcp", 1), ("udp", 2), ("icmp", 3), ("igmp", 4), ("any", 5))

lanDeviceTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 1), )
if mibBuilder.loadTexts: lanDeviceTable.setStatus('current')
if mibBuilder.loadTexts: lanDeviceTable.setDescription('Table of LAN devices, including Ethernet, WLAN, and USB physical interfaces')
lanDeviceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 1, 1), ).setIndexNames((0, "ZHNLANDEVICE", "lanDeviceIndex"))
if mibBuilder.loadTexts: lanDeviceEntry.setStatus('current')
if mibBuilder.loadTexts: lanDeviceEntry.setDescription('Table of LAN devices, including Ethernet, WLAN, and USB physical interfaces. Each instance contains all LAN-related objects for a given bridged subnet.')
lanDeviceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 1, 1, 1), Unsigned32())
if mibBuilder.loadTexts: lanDeviceIndex.setStatus('current')
if mibBuilder.loadTexts: lanDeviceIndex.setDescription('LAN Device ifIndex')
lanEthernetInterfaceNumberOfEntries = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 1, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lanEthernetInterfaceNumberOfEntries.setStatus('current')
if mibBuilder.loadTexts: lanEthernetInterfaceNumberOfEntries.setDescription('Number of instances of lanEthernetInterfaceConfig entries for this LAN device.')
lanUSBInterfaceNumberOfEntries = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 1, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lanUSBInterfaceNumberOfEntries.setStatus('current')
if mibBuilder.loadTexts: lanUSBInterfaceNumberOfEntries.setDescription('Number of instances of lanUSBInterfaceConfig entries for this LAN device.')
lanWLANConfigurationNumberOfEntries = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 1, 1, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lanWLANConfigurationNumberOfEntries.setStatus('current')
if mibBuilder.loadTexts: lanWLANConfigurationNumberOfEntries.setDescription('Number of instances of lanWLANInterfaceConfig entries for this LAN device.')
lanMocaInterfaceNumberOfEntries = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 1, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lanMocaInterfaceNumberOfEntries.setStatus('current')
if mibBuilder.loadTexts: lanMocaInterfaceNumberOfEntries.setDescription('Number of instances of lanMocaInterfaceConfig entries for this LAN device.')
igmpSnoopingCfgTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 2), )
if mibBuilder.loadTexts: igmpSnoopingCfgTable.setStatus('current')
if mibBuilder.loadTexts: igmpSnoopingCfgTable.setDescription('Table of IGMP configuration information for LAN devices, including Ethernet, WLAN, and USB physical interfaces')
igmpSnoopingCfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 2, 1), ).setIndexNames((0, "ZHNLANDEVICE", "lanDeviceIndex"))
if mibBuilder.loadTexts: igmpSnoopingCfgEntry.setStatus('current')
if mibBuilder.loadTexts: igmpSnoopingCfgEntry.setDescription('Table of IGMP configuration information for LAN devices, including Ethernet, WLAN, and USB physical interfaces.')
igmpEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 2, 1, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igmpEnable.setStatus('current')
if mibBuilder.loadTexts: igmpEnable.setDescription('Enables or disables IGMP snooping for the LAN device. ')
igmpMode = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 2, 1, 2), IGMPSnoopingModeValues()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igmpMode.setStatus('current')
if mibBuilder.loadTexts: igmpMode.setDescription('IGMP Snooping mode. Enumeration of: Standard Blocking ')
igmpIfName = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 2, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpIfName.setStatus('current')
if mibBuilder.loadTexts: igmpIfName.setDescription('The interface name for this LAN device. This object has the same value as the ipInterfaceifName object in the ipInterfaceTable and is included within the IGMP table for convenience purposes.')
lanHostConfigManagementObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3))
lanHostConfigManagementTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 1), )
if mibBuilder.loadTexts: lanHostConfigManagementTable.setStatus('current')
if mibBuilder.loadTexts: lanHostConfigManagementTable.setDescription('Table of LAN Host Configuration Management information for LAN devices, including Ethernet, WLAN, and USB physical interfaces')
lanHostConfigManagementEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 1, 1), ).setIndexNames((0, "ZHNLANDEVICE", "lanDeviceIndex"))
if mibBuilder.loadTexts: lanHostConfigManagementEntry.setStatus('current')
if mibBuilder.loadTexts: lanHostConfigManagementEntry.setDescription('Table of LAN Host Configuration Management information for LAN devices, including Ethernet, WLAN, and USB physical interfaces')
dhcpServerConfigurable = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 1, 1, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpServerConfigurable.setStatus('current')
if mibBuilder.loadTexts: dhcpServerConfigurable.setDescription('Enables the configuration of the DHCP server on the LAN interface If this variable is set to false, the CPE should restore its default DHCP server settings. ')
zhnDhcpServerEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 1, 1, 2), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: zhnDhcpServerEnable.setStatus('current')
if mibBuilder.loadTexts: zhnDhcpServerEnable.setDescription('Enables or disables the DHCP server on the LAN interface.')
dhcpRelay = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 1, 1, 3), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpRelay.setStatus('current')
if mibBuilder.loadTexts: dhcpRelay.setDescription('Indicates if the DHCP server performs the role of a server or a relay on the LAN interface. ')
dhcpRelayServer = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 1, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpRelayServer.setStatus('current')
if mibBuilder.loadTexts: dhcpRelayServer.setDescription('DHCP Relay Server IP Address.')
minAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 1, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: minAddress.setStatus('current')
if mibBuilder.loadTexts: minAddress.setDescription('Specifies first address in the pool to be assigned by the DHCP server on the LAN interface. ')
maxAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 1, 1, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: maxAddress.setStatus('current')
if mibBuilder.loadTexts: maxAddress.setDescription('Specifies last address in the pool to be assigned by the DHCP server on the LAN interface. ')
reservedAddresses = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 1, 1, 7), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: reservedAddresses.setStatus('current')
if mibBuilder.loadTexts: reservedAddresses.setDescription('Comma separated list of addresses marked reserved from the address allocation pool. ')
subnetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 1, 1, 8), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: subnetMask.setStatus('current')
if mibBuilder.loadTexts: subnetMask.setDescription('DHCP client subnet mask')
dnsServers = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 1, 1, 9), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dnsServers.setStatus('current')
if mibBuilder.loadTexts: dnsServers.setDescription('Comma separated list of DNS servers offered to DHCP clients. Support for more than three DNS Servers is Optional. ')
domainName = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 1, 1, 10), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: domainName.setStatus('current')
if mibBuilder.loadTexts: domainName.setDescription('Sets the domain name to provide to clients on the LAN interface.')
ipRouters = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 1, 1, 11), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipRouters.setStatus('current')
if mibBuilder.loadTexts: ipRouters.setDescription('Comma separated list of IP addresses of routers on this subnet. Also known as default gateway. Support for more than one Router address is Optional. ')
dhcpLeaseTime = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpLeaseTime.setStatus('current')
if mibBuilder.loadTexts: dhcpLeaseTime.setDescription('Specifies the lease time in seconds of client assigned addresses. A value of -1 indicates an infinite lease. ')
ipInterfaceNumberOfEntries = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 1, 1, 13), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipInterfaceNumberOfEntries.setStatus('current')
if mibBuilder.loadTexts: ipInterfaceNumberOfEntries.setDescription('Number of IP interface at LAN side of the CPE. 1 is a typical value for CPE not supporting Multihomed interfaces. Support for more than one interface instance is Optional. ')
ipInterfaceObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 2))
zhnIpInterfaceTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 2, 1), )
if mibBuilder.loadTexts: zhnIpInterfaceTable.setStatus('current')
if mibBuilder.loadTexts: zhnIpInterfaceTable.setDescription('IP interface table.')
zhnIpInterfaceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 2, 1, 1), ).setIndexNames((0, "ZHNLANDEVICE", "lanDeviceIndex"), (0, "ZHNLANDEVICE", "ipInterfaceIndex"))
if mibBuilder.loadTexts: zhnIpInterfaceEntry.setStatus('current')
if mibBuilder.loadTexts: zhnIpInterfaceEntry.setDescription('IP interface table.')
ipInterfaceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 2, 1, 1, 1), Unsigned32())
if mibBuilder.loadTexts: ipInterfaceIndex.setStatus('current')
if mibBuilder.loadTexts: ipInterfaceIndex.setDescription('LAN IP Address Index')
ipInterfaceEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 2, 1, 1, 2), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipInterfaceEnable.setStatus('current')
if mibBuilder.loadTexts: ipInterfaceEnable.setDescription('Enables or disables this entry.')
ipInterfaceIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 2, 1, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipInterfaceIPAddress.setStatus('current')
if mibBuilder.loadTexts: ipInterfaceIPAddress.setDescription('IP address of the LAN-side interface of the CPE.')
ipInterfaceSubnetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 2, 1, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipInterfaceSubnetMask.setStatus('current')
if mibBuilder.loadTexts: ipInterfaceSubnetMask.setDescription('Subnet mask of the LAN-side interface of the CPE.')
ipInterfaceAddressingType = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 2, 1, 1, 5), IPInterfaceAddressingTypeValues()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipInterfaceAddressingType.setStatus('current')
if mibBuilder.loadTexts: ipInterfaceAddressingType.setDescription('Represents the addressing method used to assign the LAN-side IP address of the CPE on this interface of the CPE. Enumeration of: DHCP Static Auto-IP ')
ipInterfaceifName = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 2, 1, 1, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipInterfaceifName.setStatus('current')
if mibBuilder.loadTexts: ipInterfaceifName.setDescription('The interface name for this LAN device.')
firewallEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 2, 1, 1, 7), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: firewallEnabled.setStatus('current')
if mibBuilder.loadTexts: firewallEnabled.setDescription('Indicates if a stateful firewall is enabled for all traffic from this IP interface to the modem. If TRUE, all inbound local traffic (from LAN to modem) that is not responding to an outbound packet or listed in the firewall exception table will be blocked. ')
defaultGateway = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 2, 1, 1, 8), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: defaultGateway.setStatus('current')
if mibBuilder.loadTexts: defaultGateway.setDescription('The IP address of the default gateway for this IP interface. This parameter is configurable only if the AddressingType is Static. ')
natEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 2, 1, 1, 9), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: natEnabled.setStatus('current')
if mibBuilder.loadTexts: natEnabled.setDescription('This parameter enables or disables NAT for this IP interface. This parameter is configurable only if this interface is on an uplink port. ')
dhcpcPid = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 2, 1, 1, 10), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpcPid.setStatus('current')
if mibBuilder.loadTexts: dhcpcPid.setDescription('If the address type is DHCP, then we will start a DHCP client to get the IP address for this IP interface. The process ID (pid) is stored in this field. A pid of 0 indicates that no dhcpc is running. ')
dnsType = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 2, 1, 1, 11), DNSTypeValues()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dnsType.setStatus('current')
if mibBuilder.loadTexts: dnsType.setDescription('This object specifies the DNS mode for this IP interface. The DNS associates hostname-to-IP address, and so domain names and IP addresses can be used interchangeably. Enumeration of: Default - Get the DNS information from the uplink interface Static - The DNSinformation is manually provisioned DHCP - The DNS information is obtained via DHCP ')
primaryDnsIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 2, 1, 1, 12), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: primaryDnsIPAddress.setStatus('current')
if mibBuilder.loadTexts: primaryDnsIPAddress.setDescription('The DNS server primary IP address. ')
secondaryDnsIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 2, 1, 1, 13), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: secondaryDnsIPAddress.setStatus('current')
if mibBuilder.loadTexts: secondaryDnsIPAddress.setDescription('The DNS server secondary IP address. ')
zhnVlanType = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 2, 1, 1, 14), VlanTypeValues()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: zhnVlanType.setStatus('current')
if mibBuilder.loadTexts: zhnVlanType.setDescription('This object specifies the VLAN connection type of the interface.')
connectionType = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 2, 1, 1, 15), IpPppoeConnectionTypeValues()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: connectionType.setStatus('current')
if mibBuilder.loadTexts: connectionType.setDescription('This object specifies the connection type of the interface.')
maxMTUSize = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 2, 1, 1, 16), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 1540))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: maxMTUSize.setStatus('current')
if mibBuilder.loadTexts: maxMTUSize.setDescription('The maximum size of IP packet that can be transmitted without fragmentation - including IP headers but excluding headers from lower levels in the protocol stack. The default MTU size is 1500 bytes.')
alternateWanIfName = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 2, 1, 1, 17), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: alternateWanIfName.setStatus('current')
if mibBuilder.loadTexts: alternateWanIfName.setDescription('Name of a different VLAN WAN interface to run on if the current VLAN WAN interface is set to unconfigured.')
naptEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 2, 1, 1, 18), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: naptEnabled.setStatus('current')
if mibBuilder.loadTexts: naptEnabled.setDescription('This parameter enables or disables NAPT for this IP interface. This parameter is configurable only if this interface is on an uplink port. ')
pppoeConfigObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 2, 2))
pppoeConfigTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 2, 2, 1), )
if mibBuilder.loadTexts: pppoeConfigTable.setStatus('current')
if mibBuilder.loadTexts: pppoeConfigTable.setDescription('PPPoE configuration interface table for LAN interfaces.')
pppoeConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 2, 2, 1, 1), ).setIndexNames((0, "ZHNLANDEVICE", "lanDeviceIndex"), (0, "ZHNLANDEVICE", "ipInterfaceIndex"))
if mibBuilder.loadTexts: pppoeConfigEntry.setStatus('current')
if mibBuilder.loadTexts: pppoeConfigEntry.setDescription('PPPoE configuration table entry.')
pppoeIfName = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 2, 2, 1, 1, 1), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppoeIfName.setStatus('current')
if mibBuilder.loadTexts: pppoeIfName.setDescription('The interface name for this LAN device.')
pid = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 2, 2, 1, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pid.setStatus('current')
if mibBuilder.loadTexts: pid.setDescription('This object holds the process id (pid) of the pppd associated with this connection. A pid of 0 indicates that there is no pppd running.')
connectionRequest = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 2, 2, 1, 1, 3), PPPUserConnectionRequestValues()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: connectionRequest.setStatus('current')
if mibBuilder.loadTexts: connectionRequest.setDescription('This object is used to bring up or down a PPPoE connection. Enumeration of: None Down Up Connect Disconnect ')
username = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 2, 2, 1, 1, 4), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: username.setStatus('current')
if mibBuilder.loadTexts: username.setDescription('PPP requires that you have a user name and password to establish your connection. This object is the login user name to be used for PPP authentication.')
password = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 2, 2, 1, 1, 5), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: password.setStatus('current')
if mibBuilder.loadTexts: password.setDescription('PPP requires that you have a user name and password to establish your connection. This object is the login password to be used for PPP authentication. When read, this parameter returns an empty string, regardless of the actual value.')
authentication = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 2, 2, 1, 1, 6), PPPAuthenticationProtocolValues()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: authentication.setStatus('current')
if mibBuilder.loadTexts: authentication.setDescription('This object is the PPP authentication protocol to be used for PPP authentication. Enumeration of: AUTO_AUTH PAP CHAP MS-CHAP ')
serviceName = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 2, 2, 1, 1, 7), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: serviceName.setStatus('current')
if mibBuilder.loadTexts: serviceName.setDescription('This object is the PPP Service Name. It should be filled only if specified by the provider.')
encryptionProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 2, 2, 1, 1, 8), PPPEncryptionProtocolValues()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: encryptionProtocol.setStatus('current')
if mibBuilder.loadTexts: encryptionProtocol.setDescription('This object describes the PPP encryption protocol. Enumeration of: None MPPE ')
compressionProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 2, 2, 1, 1, 9), PPPCompressionProtocolValues()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: compressionProtocol.setStatus('current')
if mibBuilder.loadTexts: compressionProtocol.setDescription('This object describes the PPP compression protocol used between the WAN device and the ISP POP. Enumeration of: None VanJacobsen STAC-LZS ')
idleDisconnectTime = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 2, 2, 1, 1, 10), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: idleDisconnectTime.setStatus('current')
if mibBuilder.loadTexts: idleDisconnectTime.setDescription('The time in seconds that if the connection remains idle, the CPE automatically terminates the connection. A value of 0 (zero) indicates that the connection is not to be shutdown automatically.')
holdOffTime = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 2, 2, 1, 1, 11), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: holdOffTime.setStatus('current')
if mibBuilder.loadTexts: holdOffTime.setDescription('Set time in seconds before retrying connection.')
useStaticIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 2, 2, 1, 1, 12), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: useStaticIpAddress.setStatus('current')
if mibBuilder.loadTexts: useStaticIpAddress.setDescription('If TRUE, PPPoE connection will use a static IP address.')
staticIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 2, 2, 1, 1, 13), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: staticIpAddress.setStatus('current')
if mibBuilder.loadTexts: staticIpAddress.setDescription('PPPoE static IP address.')
enableDebug = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 2, 2, 1, 1, 14), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: enableDebug.setStatus('current')
if mibBuilder.loadTexts: enableDebug.setDescription('Enable PPPoE debug.')
pppoeStatusObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 2, 3))
pppoeStatusTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 2, 3, 1), )
if mibBuilder.loadTexts: pppoeStatusTable.setStatus('current')
if mibBuilder.loadTexts: pppoeStatusTable.setDescription('PPPoE configuration interface table for LAN interfaces.')
pppoeStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 2, 3, 1, 1), ).setIndexNames((0, "ZHNLANDEVICE", "lanDeviceIndex"), (0, "ZHNLANDEVICE", "ipInterfaceIndex"))
if mibBuilder.loadTexts: pppoeStatusEntry.setStatus('current')
if mibBuilder.loadTexts: pppoeStatusEntry.setDescription('PPPoE status table entry.')
connectionStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 2, 3, 1, 1, 1), WANPppConnectionStatusValues()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connectionStatus.setStatus('current')
if mibBuilder.loadTexts: connectionStatus.setDescription('Current status of the PPP connection.')
lastConnectionError = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 2, 3, 1, 1, 2), WANPppLastConnectionErrorValues()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lastConnectionError.setStatus('current')
if mibBuilder.loadTexts: lastConnectionError.setDescription('The failure reason of the last PPP connection setup.')
connectionEstablishedTime = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 2, 3, 1, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connectionEstablishedTime.setStatus('current')
if mibBuilder.loadTexts: connectionEstablishedTime.setDescription('The last time the PPP connection was established.')
currentMTUSize = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 2, 3, 1, 1, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: currentMTUSize.setStatus('current')
if mibBuilder.loadTexts: currentMTUSize.setDescription('The current MTU in use over this connection.')
uptime = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 2, 3, 1, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: uptime.setStatus('current')
if mibBuilder.loadTexts: uptime.setDescription('The time in seconds this connection has been up.')
zhnDhcpConditionalServingPoolObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 3))
zhnDhcpConditionalServingPoolTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 3, 1), )
if mibBuilder.loadTexts: zhnDhcpConditionalServingPoolTable.setStatus('current')
if mibBuilder.loadTexts: zhnDhcpConditionalServingPoolTable.setDescription('A collection of configuration parameters for DHCP conditional serving.')
zhnDhcpConditionalServingPoolEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 3, 1, 1), ).setIndexNames((0, "ZHNLANDEVICE", "lanDeviceIndex"), (0, "ZHNLANDEVICE", "dhcpPoolIndex"))
if mibBuilder.loadTexts: zhnDhcpConditionalServingPoolEntry.setStatus('current')
if mibBuilder.loadTexts: zhnDhcpConditionalServingPoolEntry.setDescription('DHCP Conditional Serving Pool table.')
dhcpPoolIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 3, 1, 1, 1), Unsigned32())
if mibBuilder.loadTexts: dhcpPoolIndex.setStatus('current')
if mibBuilder.loadTexts: dhcpPoolIndex.setDescription('DHCP pool index')
dhcpPoolEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 3, 1, 1, 2), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpPoolEnable.setStatus('current')
if mibBuilder.loadTexts: dhcpPoolEnable.setDescription('Enables or disables this entry.')
dhcpPoolChaddr = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 3, 1, 1, 3), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpPoolChaddr.setStatus('current')
if mibBuilder.loadTexts: dhcpPoolChaddr.setDescription('MAC address of the physical interface of the DHCP client. A perfect match is needed. An empty value indicates this criterion is not used for conditional serving. ')
dhcpPoolChaddrMask = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 3, 1, 1, 4), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpPoolChaddrMask.setStatus('current')
if mibBuilder.loadTexts: dhcpPoolChaddrMask.setDescription('Chaddr is only to be done for bit positions set to one in the mask. A mask of FF:FF:FF:FF:FF:FF indicates all bits of the Chaddr are to be used for classification. A perfect match is needed. An empty value indicates this criterion is not used for conditional serving. ')
dhcpPoolMinAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 3, 1, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpPoolMinAddress.setStatus('current')
if mibBuilder.loadTexts: dhcpPoolMinAddress.setDescription('Specifies first address in the pool to be assigned by the DHCP server on the LAN interface. ')
dhcpPoolMaxAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 3, 1, 1, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpPoolMaxAddress.setStatus('current')
if mibBuilder.loadTexts: dhcpPoolMaxAddress.setDescription('Specifies last address in the pool to be assigned by the DHCP server on the LAN interface. ')
dhcpPoolReservedAddresses = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 3, 1, 1, 7), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpPoolReservedAddresses.setStatus('current')
if mibBuilder.loadTexts: dhcpPoolReservedAddresses.setDescription('Comma separated list of addresses marked reserved from the address allocation pool. ')
dhcpPoolSubnetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 3, 1, 1, 8), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpPoolSubnetMask.setStatus('current')
if mibBuilder.loadTexts: dhcpPoolSubnetMask.setDescription('Specifies the clients network subnet mask.')
dhcpPoolDnsServers = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 3, 1, 1, 9), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpPoolDnsServers.setStatus('current')
if mibBuilder.loadTexts: dhcpPoolDnsServers.setDescription('Comma separated list of DNS servers offered to DHCP clients. Support for more than three DNS Servers is Optional. ')
dhcpPoolDomainName = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 3, 1, 1, 10), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpPoolDomainName.setStatus('current')
if mibBuilder.loadTexts: dhcpPoolDomainName.setDescription('Sets the domain name to provide to clients on the LAN interface.')
dhcpPoolIPRouters = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 3, 1, 1, 11), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpPoolIPRouters.setStatus('current')
if mibBuilder.loadTexts: dhcpPoolIPRouters.setDescription('Comma separated list of IP addresses of routers on this subnet. Also known as default gateway. Support for more than one Router address is Optional. ')
dhcpPoolLeaseTime = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 3, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpPoolLeaseTime.setStatus('current')
if mibBuilder.loadTexts: dhcpPoolLeaseTime.setDescription('Specifies the lease time in seconds of client assigned addresses. A value of -1 indicates an infinite lease. ')
dhcpPoolUseWanVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 3, 1, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpPoolUseWanVlan.setStatus('current')
if mibBuilder.loadTexts: dhcpPoolUseWanVlan.setDescription('The WAN VLAN is used to determine the default gateway router for upstream packets that have a source IP address in this subnet. A zero value indicates that the WAN VLAN is not used. ')
dhcpPoolEnableStaticLease = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 3, 1, 1, 14), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpPoolEnableStaticLease.setStatus('current')
if mibBuilder.loadTexts: dhcpPoolEnableStaticLease.setDescription('Enable this option to permanently bind the IP address to the client MAC. ')
dhcpPoolRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 3, 3, 1, 1, 15), ZhoneRowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpPoolRowStatus.setStatus('current')
if mibBuilder.loadTexts: dhcpPoolRowStatus.setDescription('The SNMP RowStatus of the current row. The following object must be specified upon row creation: dhcpPoolChaddr ')
zhnLANEthernetInterfaceObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 4))
lanEthernetInterfaceConfigTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 4, 1), )
if mibBuilder.loadTexts: lanEthernetInterfaceConfigTable.setStatus('current')
if mibBuilder.loadTexts: lanEthernetInterfaceConfigTable.setDescription('Table of LAN ethernet interface configuration objects. This object models an Ethernet LAN connection on a CPE device. This object must be implemented for all CPEs that contain an Ethernet interface on the LAN side.')
lanEthernetInterfaceConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 4, 1, 1), ).setIndexNames((0, "ZHNLANDEVICE", "lanDeviceIndex"), (0, "ZHNLANDEVICE", "lanEthernetIndex"))
if mibBuilder.loadTexts: lanEthernetInterfaceConfigEntry.setStatus('current')
if mibBuilder.loadTexts: lanEthernetInterfaceConfigEntry.setDescription('Table entry for LAN ethernet interface configuration objects.')
lanEthernetIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 4, 1, 1, 1), Unsigned32())
if mibBuilder.loadTexts: lanEthernetIndex.setStatus('current')
if mibBuilder.loadTexts: lanEthernetIndex.setDescription('LAN Ethernet Interface Index')
lanEthernetEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 4, 1, 1, 2), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lanEthernetEnable.setStatus('current')
if mibBuilder.loadTexts: lanEthernetEnable.setDescription('Enables or disables this interface.')
lanEthernetStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 4, 1, 1, 3), LANEthernetStatusValues()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lanEthernetStatus.setStatus('current')
if mibBuilder.loadTexts: lanEthernetStatus.setDescription('Indicates the status of this interface. Enumeration of: Up NoLink Error Disabled ')
macAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 4, 1, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: macAddress.setStatus('current')
if mibBuilder.loadTexts: macAddress.setDescription('ASCII representation of the physical address of the interface')
macAddressControlEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 4, 1, 1, 5), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: macAddressControlEnabled.setStatus('current')
if mibBuilder.loadTexts: macAddressControlEnabled.setDescription('Indicates whether MAC Address Control is enabled or not on this interface. MAC Address Control limits the clients that connect to those that match a list of allowed MAC addresses specified in InternetGatewayDevice.LANDevice.{i}.LANHostConfigManagement.AllowedMACAddresses.')
maxBitRate = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 4, 1, 1, 6), LANEthernetMaxBitRateValues()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: maxBitRate.setStatus('current')
if mibBuilder.loadTexts: maxBitRate.setDescription('The maximum upstream and downstream bit rate available to this connection. Enumeration of: 10 100 1000 Auto ')
duplexMode = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 4, 1, 1, 7), LANEthernetDuplexModeValues()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: duplexMode.setStatus('current')
if mibBuilder.loadTexts: duplexMode.setDescription('The duplex mode available to this connection. Enumeration of: Half Full Auto ')
zhnIfName = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 4, 1, 1, 8), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: zhnIfName.setStatus('current')
if mibBuilder.loadTexts: zhnIfName.setDescription('Ethernet interface name such as eth0, eth1.')
zhnEthernetPriorityMark = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 4, 1, 1, 9), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: zhnEthernetPriorityMark.setStatus('current')
if mibBuilder.loadTexts: zhnEthernetPriorityMark.setDescription('802.1P priority value for this ethernet interface. Assigment of priority values is done via the Layer 2 Bridge Marking Table. Therefore, this object is read-only.')
dot1qPvid = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 4, 1, 1, 10), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1qPvid.setStatus('current')
if mibBuilder.loadTexts: dot1qPvid.setDescription('Default 802.1Q VLAN ID for this ethernet interface.')
lanEthernetAlias = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 4, 1, 1, 11), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lanEthernetAlias.setStatus('current')
if mibBuilder.loadTexts: lanEthernetAlias.setDescription('A descriptive name for this ethernet interface.')
pauseMode = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 4, 1, 1, 12), LANEthernetPauseModeValues()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pauseMode.setStatus('current')
if mibBuilder.loadTexts: pauseMode.setDescription('The pause mode available to this connection. Enumeration of: Auto Enable Disable ')
lanEthernetAcl = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 4, 1, 1, 13), LANEthernetAclValues()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lanEthernetAcl.setStatus('current')
if mibBuilder.loadTexts: lanEthernetAcl.setDescription('The access list values available to an ethernet interface. Enumeration of: Disable BlackList WhiteList Unsupported ')
lanEthernetAclRulesNumberofEntries = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 4, 1, 1, 14), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lanEthernetAclRulesNumberofEntries.setStatus('current')
if mibBuilder.loadTexts: lanEthernetAclRulesNumberofEntries.setDescription('The number of entries in the access list table for this ethernet interface.')
lanEthernetLanFollowsWan = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 4, 1, 1, 15), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lanEthernetLanFollowsWan.setStatus('current')
if mibBuilder.loadTexts: lanEthernetLanFollowsWan.setDescription('Enable or disable this LAN interface based upon the WAN status.')
lanEthernetIgmpPriorityMark = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 4, 1, 1, 16), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lanEthernetIgmpPriorityMark.setStatus('current')
if mibBuilder.loadTexts: lanEthernetIgmpPriorityMark.setDescription('The 802.1P priority value that this LAN interface will assign to ingress untagged IGMP frames.')
lanEthernetIgmpPvid = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 4, 1, 1, 17), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lanEthernetIgmpPvid.setStatus('current')
if mibBuilder.loadTexts: lanEthernetIgmpPvid.setDescription('The VLAN ID that this LAN interface will assign to ingress untagged IGMP frames.')
lanEthIntfStatisticsTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 4, 2), )
if mibBuilder.loadTexts: lanEthIntfStatisticsTable.setStatus('current')
if mibBuilder.loadTexts: lanEthIntfStatisticsTable.setDescription('Table of LAN ethernet interface statistics objects. This object contains statistics for an Ethernet LAN connection on a CPE device.')
lanEthIntfStatisticsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 4, 2, 1), ).setIndexNames((0, "ZHNLANDEVICE", "lanDeviceIndex"), (0, "ZHNLANDEVICE", "lanEthernetIndex"))
if mibBuilder.loadTexts: lanEthIntfStatisticsEntry.setStatus('current')
if mibBuilder.loadTexts: lanEthIntfStatisticsEntry.setDescription('Table entry for LAN ethernet interface statistics objects.')
bytesSent = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 4, 2, 1, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bytesSent.setStatus('current')
if mibBuilder.loadTexts: bytesSent.setDescription('Total number of bytes sent over the interface since the CPE was last reset.')
bytesReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 4, 2, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bytesReceived.setStatus('current')
if mibBuilder.loadTexts: bytesReceived.setDescription('Total number of bytes received over the interface since the CPE was last reset.')
packetsSent = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 4, 2, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: packetsSent.setStatus('current')
if mibBuilder.loadTexts: packetsSent.setDescription('Total number of packets sent over the interface since the CPE was last reset.')
packetsReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 4, 2, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: packetsReceived.setStatus('current')
if mibBuilder.loadTexts: packetsReceived.setDescription('Total number of packets received over the interface since the CPE was last reset.')
txErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 4, 2, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txErrors.setStatus('current')
if mibBuilder.loadTexts: txErrors.setDescription('Total number of transmit errors on the interface since the CPE was last reset.')
rxErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 4, 2, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxErrors.setStatus('current')
if mibBuilder.loadTexts: rxErrors.setDescription('Total number of receive errors on the interface since the CPE was last reset.')
txDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 4, 2, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txDrops.setStatus('current')
if mibBuilder.loadTexts: txDrops.setDescription('Total number of packets dropped on the transmit side of the interface since the CPE was last reset.')
rxDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 4, 2, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxDrops.setStatus('current')
if mibBuilder.loadTexts: rxDrops.setDescription('Total number of packets dropped on the receive side of the interface since the CPE was last reset.')
lanEthIntfStatusTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 4, 3), )
if mibBuilder.loadTexts: lanEthIntfStatusTable.setStatus('current')
if mibBuilder.loadTexts: lanEthIntfStatusTable.setDescription('Table of LAN ethernet interface status objects. This object models an Ethernet LAN connection on a CPE device. This object must be implemented for all CPEs that contain an Ethernet interface on the LAN side.')
lanEthIntfStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 4, 3, 1), ).setIndexNames((0, "ZHNLANDEVICE", "lanDeviceIndex"), (0, "ZHNLANDEVICE", "lanEthernetIndex"))
if mibBuilder.loadTexts: lanEthIntfStatusEntry.setStatus('current')
if mibBuilder.loadTexts: lanEthIntfStatusEntry.setDescription('Table entry for LAN ethernet interface status objects.')
linkStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 4, 3, 1, 1), LANEthernetStatusValues()).setMaxAccess("readonly")
if mibBuilder.loadTexts: linkStatus.setStatus('current')
if mibBuilder.loadTexts: linkStatus.setDescription("The port's current link status.")
rateStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 4, 3, 1, 2), LANEthernetMaxBitRateValues()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rateStatus.setStatus('current')
if mibBuilder.loadTexts: rateStatus.setDescription("The port's current maximum bit rate. ")
duplexStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 4, 3, 1, 3), LANEthernetDuplexModeValues()).setMaxAccess("readonly")
if mibBuilder.loadTexts: duplexStatus.setStatus('current')
if mibBuilder.loadTexts: duplexStatus.setDescription("The port's current duplex mode. ")
pauseStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 4, 3, 1, 4), LANEthernetPauseModeValues()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pauseStatus.setStatus('current')
if mibBuilder.loadTexts: pauseStatus.setDescription("The port's current pause mode. ")
lanEthIntfRateLimitTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 4, 4), )
if mibBuilder.loadTexts: lanEthIntfRateLimitTable.setStatus('current')
if mibBuilder.loadTexts: lanEthIntfRateLimitTable.setDescription('Table of LAN ethernet interface configuration objects. This object models an Ethernet LAN connection on a CPE device. This object must be implemented for all CPEs that contain an Ethernet interface on the LAN side.')
lanEthIntfRateLimitEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 4, 4, 1), ).setIndexNames((0, "ZHNLANDEVICE", "lanDeviceIndex"), (0, "ZHNLANDEVICE", "lanEthernetIndex"))
if mibBuilder.loadTexts: lanEthIntfRateLimitEntry.setStatus('current')
if mibBuilder.loadTexts: lanEthIntfRateLimitEntry.setDescription('Rate limit table entry for LAN ethernet interface configuration objects.')
rateLimitEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 4, 4, 1, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rateLimitEnable.setStatus('current')
if mibBuilder.loadTexts: rateLimitEnable.setDescription('This object is used to enable or disable rate limit on a port. Setting it to True will rate limit traffic on the port to a specified peak rate.')
peakRate = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 4, 4, 1, 2), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: peakRate.setStatus('current')
if mibBuilder.loadTexts: peakRate.setDescription('This object identifies the maximum rate (0-1000) in Mbps on a port. If Rate Limit is disabled, this object has no effect.')
burstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 4, 4, 1, 3), LANRateLimitBurstSizeValues()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: burstSize.setStatus('current')
if mibBuilder.loadTexts: burstSize.setDescription('This object burst size. If Rate Limit is disabled, this object has no effect.')
rateDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 4, 4, 1, 4), LANRateLimitDirectionValues()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rateDirection.setStatus('current')
if mibBuilder.loadTexts: rateDirection.setDescription('This object specifies the traffic direction to which the rate limit applies. The supported values are inbound, outbound or both. If the Rate Limit is disabled, this object has no effect.')
inboundPeakRate = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 4, 4, 1, 5), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: inboundPeakRate.setStatus('current')
if mibBuilder.loadTexts: inboundPeakRate.setDescription('This object identifies the maximum rate (0-1000) in Mbps on a port for inbound data. If Rate Limit is disabled, this object has no effect.')
igmpGroupsTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 5), )
if mibBuilder.loadTexts: igmpGroupsTable.setStatus('current')
if mibBuilder.loadTexts: igmpGroupsTable.setDescription('Table of IGMP Multicast Groups currently detected by IGMP snooping.')
igmpGroupsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 5, 1), ).setIndexNames((0, "ZHNLANDEVICE", "igmpGroupIndex"))
if mibBuilder.loadTexts: igmpGroupsEntry.setStatus('current')
if mibBuilder.loadTexts: igmpGroupsEntry.setDescription('IGMP Multicast Groups table.')
igmpGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 5, 1, 1), Unsigned32())
if mibBuilder.loadTexts: igmpGroupIndex.setStatus('current')
if mibBuilder.loadTexts: igmpGroupIndex.setDescription('IGMP Multicast Groups Table Index')
igmpGroupAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 5, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpGroupAddress.setStatus('current')
if mibBuilder.loadTexts: igmpGroupAddress.setDescription('This object identifies the IP address of the multicast group.')
igmpGroupReporterIP = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 5, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpGroupReporterIP.setStatus('current')
if mibBuilder.loadTexts: igmpGroupReporterIP.setDescription('This object identifies the IP address of the host in the multicast group.')
igmpGroupReporterMAC = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 5, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpGroupReporterMAC.setStatus('current')
if mibBuilder.loadTexts: igmpGroupReporterMAC.setDescription('This object identifies the MAC address of the host in the multicast group.')
igmpGroupInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 5, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpGroupInterface.setStatus('current')
if mibBuilder.loadTexts: igmpGroupInterface.setDescription('This object identifies the interface that discovered the multicast group.')
igmpGroupVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 5, 1, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpGroupVlan.setStatus('current')
if mibBuilder.loadTexts: igmpGroupVlan.setDescription('This object identifies the VLAN that discovered the multicast group.')
igmpGroupExpiration = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 5, 1, 7), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpGroupExpiration.setStatus('current')
if mibBuilder.loadTexts: igmpGroupExpiration.setDescription('This object identifies the time (in seconds) before the multicast group times out.')
igmpGroupQuerier = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 5, 1, 8), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpGroupQuerier.setStatus('current')
if mibBuilder.loadTexts: igmpGroupQuerier.setDescription('This object identifies the IP address to be used by a proxy querier.')
zhnLANDeviceSystemObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 6))
lanDefaultIfName = MibScalar((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 6, 1), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lanDefaultIfName.setStatus('current')
if mibBuilder.loadTexts: lanDefaultIfName.setDescription('Configure the default interface name.')
lanDefaultIfIpAddress = MibScalar((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 6, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lanDefaultIfIpAddress.setStatus('current')
if mibBuilder.loadTexts: lanDefaultIfIpAddress.setDescription('The IP address of the default interface, as configured by IPInterfaceIPAddress.')
lanEthAclRulesTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 7), )
if mibBuilder.loadTexts: lanEthAclRulesTable.setStatus('current')
if mibBuilder.loadTexts: lanEthAclRulesTable.setDescription('Table of LAN ethernet access list rules. This table contains a list of all access rules used to filter incoming traffic for a single physical ethernet interface.')
lanEthAclRulesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 7, 1), ).setIndexNames((0, "ZHNLANDEVICE", "lanDeviceIndex"), (0, "ZHNLANDEVICE", "lanEthernetIndex"), (0, "ZHNLANDEVICE", "lanAclRuleKey"))
if mibBuilder.loadTexts: lanEthAclRulesEntry.setStatus('current')
if mibBuilder.loadTexts: lanEthAclRulesEntry.setDescription('Table entry for LAN ethernet access list objects.')
lanAclRuleKey = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 7, 1, 1), Unsigned32())
if mibBuilder.loadTexts: lanAclRuleKey.setStatus('current')
if mibBuilder.loadTexts: lanAclRuleKey.setDescription('Index for the Ethernet Access List table.')
lanAclRuleIfName = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 7, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lanAclRuleIfName.setStatus('current')
if mibBuilder.loadTexts: lanAclRuleIfName.setDescription('Identify the interface name.')
lanAclRuleName = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 7, 1, 3), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lanAclRuleName.setStatus('current')
if mibBuilder.loadTexts: lanAclRuleName.setDescription('The user defined identifier for the rule. When creating a new rule, this field must be provided and must be unique per interface rule.')
lanAclRuleSourceIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 7, 1, 4), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lanAclRuleSourceIPAddress.setStatus('current')
if mibBuilder.loadTexts: lanAclRuleSourceIPAddress.setDescription('The Source IP address to filter. The address may include a subnet prefix length in CIDR notation. Therefore the format would be 192.168.2.0/24. This is a ASCII representation of the IP address')
lanAclRuleIPProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 7, 1, 5), LANEthernetIpProtocolValues()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lanAclRuleIPProtocol.setStatus('current')
if mibBuilder.loadTexts: lanAclRuleIPProtocol.setDescription('The IPv4 Protocol to filter.')
lanAclRuleSourceMACAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 7, 1, 6), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lanAclRuleSourceMACAddress.setStatus('current')
if mibBuilder.loadTexts: lanAclRuleSourceMACAddress.setDescription('The Source MAC Address to filter. ASCII representation of the physical address of the interface')
lanAclRuleSourceMACMask = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 7, 1, 7), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lanAclRuleSourceMACMask.setStatus('current')
if mibBuilder.loadTexts: lanAclRuleSourceMACMask.setDescription('Mask by which to filter MAC address. For example a MAC Mask of ff:ff:ff:00:00:00 would filter against the first six digits of the MAC address. ASCII representation of the MAC Mask')
lanAclRuleRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 1, 7, 1, 8), ZhoneRowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lanAclRuleRowStatus.setStatus('current')
if mibBuilder.loadTexts: lanAclRuleRowStatus.setDescription('The SNMP RowStatus of the current row. The following object must be specified upon row creation: lanAclRuleName ')
zhnLANDeviceConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 2))
zhnLANDeviceGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 2, 1))
zhnLANDeviceCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 2, 2))
zhnLANDeviceCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 2, 2, 1)).setObjects(("ZHNLANDEVICE", "zhnLANDeviceGroup"), ("ZHNLANDEVICE", "zhnLANHostConfigManagementGroup"), ("ZHNLANDEVICE", "zhnIpInterfaceGroup"), ("ZHNLANDEVICE", "zhnLANEthernetInterfaceConfigGroup"), ("ZHNLANDEVICE", "zhnLANEthIntfStatusGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    zhnLANDeviceCompliance = zhnLANDeviceCompliance.setStatus('current')
if mibBuilder.loadTexts: zhnLANDeviceCompliance.setDescription('The Compliance statement for SNMP entities which manage the Zhone CPE LAN Device Information')
zhnLANDeviceGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 2, 1, 1)).setObjects(("ZHNLANDEVICE", "lanEthernetInterfaceNumberOfEntries"), ("ZHNLANDEVICE", "lanUSBInterfaceNumberOfEntries"), ("ZHNLANDEVICE", "lanWLANConfigurationNumberOfEntries"), ("ZHNLANDEVICE", "lanMocaInterfaceNumberOfEntries"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    zhnLANDeviceGroup = zhnLANDeviceGroup.setStatus('current')
if mibBuilder.loadTexts: zhnLANDeviceGroup.setDescription('A collection of Zhone LAN Device objects that describe the LAN interfaces of the device.')
zhnLANIgmpSnoopingGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 2, 1, 2)).setObjects(("ZHNLANDEVICE", "igmpEnable"), ("ZHNLANDEVICE", "igmpMode"), ("ZHNLANDEVICE", "igmpIfName"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    zhnLANIgmpSnoopingGroup = zhnLANIgmpSnoopingGroup.setStatus('current')
if mibBuilder.loadTexts: zhnLANIgmpSnoopingGroup.setDescription('A collection of Zhone LAN Device objects that describe the IGMP snooping capabilities of the device.')
zhnLANHostConfigManagementGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 2, 1, 3)).setObjects(("ZHNLANDEVICE", "dhcpServerConfigurable"), ("ZHNLANDEVICE", "zhnDhcpServerEnable"), ("ZHNLANDEVICE", "dhcpRelay"), ("ZHNLANDEVICE", "dhcpRelayServer"), ("ZHNLANDEVICE", "minAddress"), ("ZHNLANDEVICE", "maxAddress"), ("ZHNLANDEVICE", "reservedAddresses"), ("ZHNLANDEVICE", "subnetMask"), ("ZHNLANDEVICE", "dnsServers"), ("ZHNLANDEVICE", "domainName"), ("ZHNLANDEVICE", "ipRouters"), ("ZHNLANDEVICE", "dhcpLeaseTime"), ("ZHNLANDEVICE", "ipInterfaceNumberOfEntries"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    zhnLANHostConfigManagementGroup = zhnLANHostConfigManagementGroup.setStatus('current')
if mibBuilder.loadTexts: zhnLANHostConfigManagementGroup.setDescription('A collection of Zhone LAN Host Configuration Management objects that describe the LAN IP addressing of the device.')
zhnIpInterfaceGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 2, 1, 4)).setObjects(("ZHNLANDEVICE", "ipInterfaceEnable"), ("ZHNLANDEVICE", "ipInterfaceIPAddress"), ("ZHNLANDEVICE", "ipInterfaceSubnetMask"), ("ZHNLANDEVICE", "ipInterfaceAddressingType"), ("ZHNLANDEVICE", "ipInterfaceifName"), ("ZHNLANDEVICE", "firewallEnabled"), ("ZHNLANDEVICE", "defaultGateway"), ("ZHNLANDEVICE", "natEnabled"), ("ZHNLANDEVICE", "dhcpcPid"), ("ZHNLANDEVICE", "dnsType"), ("ZHNLANDEVICE", "primaryDnsIPAddress"), ("ZHNLANDEVICE", "secondaryDnsIPAddress"), ("ZHNLANDEVICE", "zhnVlanType"), ("ZHNLANDEVICE", "connectionType"), ("ZHNLANDEVICE", "maxMTUSize"), ("ZHNLANDEVICE", "alternateWanIfName"), ("ZHNLANDEVICE", "natEnabled"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    zhnIpInterfaceGroup = zhnIpInterfaceGroup.setStatus('current')
if mibBuilder.loadTexts: zhnIpInterfaceGroup.setDescription('A collection of Zhone LAN IP Address objects that describe the IP connectivity of interfaces of the device.')
zhnPPPoEConfigGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 2, 1, 5)).setObjects(("ZHNLANDEVICE", "pppoeIfName"), ("ZHNLANDEVICE", "pid"), ("ZHNLANDEVICE", "connectionRequest"), ("ZHNLANDEVICE", "username"), ("ZHNLANDEVICE", "password"), ("ZHNLANDEVICE", "authentication"), ("ZHNLANDEVICE", "serviceName"), ("ZHNLANDEVICE", "encryptionProtocol"), ("ZHNLANDEVICE", "compressionProtocol"), ("ZHNLANDEVICE", "idleDisconnectTime"), ("ZHNLANDEVICE", "holdOffTime"), ("ZHNLANDEVICE", "useStaticIpAddress"), ("ZHNLANDEVICE", "staticIpAddress"), ("ZHNLANDEVICE", "enableDebug"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    zhnPPPoEConfigGroup = zhnPPPoEConfigGroup.setStatus('current')
if mibBuilder.loadTexts: zhnPPPoEConfigGroup.setDescription('A collection of Zhone LAN PPPoE objects that describe the configuration of PPPoE connections for interfaces of the device.')
zhnPPPoEStatusGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 2, 1, 6)).setObjects(("ZHNLANDEVICE", "connectionStatus"), ("ZHNLANDEVICE", "lastConnectionError"), ("ZHNLANDEVICE", "connectionEstablishedTime"), ("ZHNLANDEVICE", "currentMTUSize"), ("ZHNLANDEVICE", "uptime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    zhnPPPoEStatusGroup = zhnPPPoEStatusGroup.setStatus('current')
if mibBuilder.loadTexts: zhnPPPoEStatusGroup.setDescription('A collection of Zhone LAN PPPoE objects that describe the status of PPPoE connections for interfaces of the device.')
zhnLANEthernetInterfaceConfigGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 2, 1, 7)).setObjects(("ZHNLANDEVICE", "lanEthernetEnable"), ("ZHNLANDEVICE", "lanEthernetStatus"), ("ZHNLANDEVICE", "macAddress"), ("ZHNLANDEVICE", "macAddressControlEnabled"), ("ZHNLANDEVICE", "maxBitRate"), ("ZHNLANDEVICE", "duplexMode"), ("ZHNLANDEVICE", "zhnIfName"), ("ZHNLANDEVICE", "zhnEthernetPriorityMark"), ("ZHNLANDEVICE", "dot1qPvid"), ("ZHNLANDEVICE", "lanEthernetAlias"), ("ZHNLANDEVICE", "pauseMode"), ("ZHNLANDEVICE", "lanEthernetAcl"), ("ZHNLANDEVICE", "lanEthernetAclRulesNumberofEntries"), ("ZHNLANDEVICE", "lanEthernetLanFollowsWan"), ("ZHNLANDEVICE", "lanEthernetIgmpPriorityMark"), ("ZHNLANDEVICE", "lanEthernetIgmpPvid"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    zhnLANEthernetInterfaceConfigGroup = zhnLANEthernetInterfaceConfigGroup.setStatus('current')
if mibBuilder.loadTexts: zhnLANEthernetInterfaceConfigGroup.setDescription('A collection of Zhone LAN Ethernet objects that describe the ethernet-like interfaces of the device.')
zhnLANEthIntfStatisticsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 2, 1, 8)).setObjects(("ZHNLANDEVICE", "bytesSent"), ("ZHNLANDEVICE", "bytesReceived"), ("ZHNLANDEVICE", "packetsSent"), ("ZHNLANDEVICE", "packetsReceived"), ("ZHNLANDEVICE", "txErrors"), ("ZHNLANDEVICE", "rxErrors"), ("ZHNLANDEVICE", "txDrops"), ("ZHNLANDEVICE", "rxDrops"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    zhnLANEthIntfStatisticsGroup = zhnLANEthIntfStatisticsGroup.setStatus('current')
if mibBuilder.loadTexts: zhnLANEthIntfStatisticsGroup.setDescription('A collection of Zhone LAN Ethernet objects that convey statistical information for the ethernet-like interfaces of the device.')
zhnLANEthIntfStatusGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 2, 1, 9)).setObjects(("ZHNLANDEVICE", "linkStatus"), ("ZHNLANDEVICE", "rateStatus"), ("ZHNLANDEVICE", "duplexStatus"), ("ZHNLANDEVICE", "pauseStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    zhnLANEthIntfStatusGroup = zhnLANEthIntfStatusGroup.setStatus('current')
if mibBuilder.loadTexts: zhnLANEthIntfStatusGroup.setDescription('A collection of Zhone LAN Ethernet objects that convey the status of the ethernet-like interfaces of the device.')
zhnLANEthIntfRateLimitGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 2, 1, 10)).setObjects(("ZHNLANDEVICE", "rateLimitEnable"), ("ZHNLANDEVICE", "peakRate"), ("ZHNLANDEVICE", "burstSize"), ("ZHNLANDEVICE", "rateDirection"), ("ZHNLANDEVICE", "inboundPeakRate"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    zhnLANEthIntfRateLimitGroup = zhnLANEthIntfRateLimitGroup.setStatus('current')
if mibBuilder.loadTexts: zhnLANEthIntfRateLimitGroup.setDescription('A collection of Zhone LAN Ethernet objects that convey the rate-limit information of the ethernet-like interfaces of the device.')
zhnLANIGMPMulticastGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 2, 1, 11)).setObjects(("ZHNLANDEVICE", "igmpGroupAddress"), ("ZHNLANDEVICE", "igmpGroupReporterIP"), ("ZHNLANDEVICE", "igmpGroupReporterMAC"), ("ZHNLANDEVICE", "igmpGroupInterface"), ("ZHNLANDEVICE", "igmpGroupVlan"), ("ZHNLANDEVICE", "igmpGroupExpiration"), ("ZHNLANDEVICE", "igmpGroupQuerier"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    zhnLANIGMPMulticastGroup = zhnLANIGMPMulticastGroup.setStatus('current')
if mibBuilder.loadTexts: zhnLANIGMPMulticastGroup.setDescription('A collection of Zhone LAN IGMP objects that identify the multicast groups currently detected by IGMP snooping within the device.')
zhnLANSystemGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 2, 1, 12)).setObjects(("ZHNLANDEVICE", "lanDefaultIfName"), ("ZHNLANDEVICE", "lanDefaultIfIpAddress"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    zhnLANSystemGroup = zhnLANSystemGroup.setStatus('current')
if mibBuilder.loadTexts: zhnLANSystemGroup.setDescription('A collection of Zhone LAN System-wide scalar objects that identify the system default interface.')
zhnLANAclRulesGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 2, 1, 13)).setObjects(("ZHNLANDEVICE", "lanAclRuleIfName"), ("ZHNLANDEVICE", "lanAclRuleName"), ("ZHNLANDEVICE", "lanAclRuleSourceIPAddress"), ("ZHNLANDEVICE", "lanAclRuleIPProtocol"), ("ZHNLANDEVICE", "lanAclRuleSourceMACAddress"), ("ZHNLANDEVICE", "lanAclRuleSourceMACMask"), ("ZHNLANDEVICE", "lanAclRuleRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    zhnLANAclRulesGroup = zhnLANAclRulesGroup.setStatus('current')
if mibBuilder.loadTexts: zhnLANAclRulesGroup.setDescription('A collection of Zhone LAN Ethernet interface access-list rules with which to filter incoming traffic.')
zhnDhcpConditionalServingPoolGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 5504, 2, 5, 41, 2, 1, 14)).setObjects(("ZHNLANDEVICE", "dhcpPoolIndex"), ("ZHNLANDEVICE", "dhcpPoolEnable"), ("ZHNLANDEVICE", "dhcpPoolChaddr"), ("ZHNLANDEVICE", "dhcpPoolChaddrMask"), ("ZHNLANDEVICE", "dhcpPoolMinAddress"), ("ZHNLANDEVICE", "dhcpPoolMaxAddress"), ("ZHNLANDEVICE", "dhcpPoolReservedAddresses"), ("ZHNLANDEVICE", "dhcpPoolSubnetMask"), ("ZHNLANDEVICE", "dhcpPoolDnsServers"), ("ZHNLANDEVICE", "dhcpPoolDomainName"), ("ZHNLANDEVICE", "dhcpPoolIPRouters"), ("ZHNLANDEVICE", "dhcpPoolLeaseTime"), ("ZHNLANDEVICE", "dhcpPoolUseWanVlan"), ("ZHNLANDEVICE", "dhcpPoolEnableStaticLease"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    zhnDhcpConditionalServingPoolGroup = zhnDhcpConditionalServingPoolGroup.setStatus('current')
if mibBuilder.loadTexts: zhnDhcpConditionalServingPoolGroup.setDescription('A collection of configuration parameters for DHCP conditional serving.')
mibBuilder.exportSymbols("ZHNLANDEVICE", secondaryDnsIPAddress=secondaryDnsIPAddress, lanMocaInterfaceNumberOfEntries=lanMocaInterfaceNumberOfEntries, zhnIpInterfaceTable=zhnIpInterfaceTable, idleDisconnectTime=idleDisconnectTime, rxErrors=rxErrors, reservedAddresses=reservedAddresses, dhcpcPid=dhcpcPid, pppoeStatusObjects=pppoeStatusObjects, igmpMode=igmpMode, lanDefaultIfIpAddress=lanDefaultIfIpAddress, zhnLANEthernetInterfaceConfigGroup=zhnLANEthernetInterfaceConfigGroup, connectionType=connectionType, dhcpPoolIndex=dhcpPoolIndex, dhcpRelayServer=dhcpRelayServer, lanAclRuleRowStatus=lanAclRuleRowStatus, LANRateLimitDirectionValues=LANRateLimitDirectionValues, igmpSnoopingCfgEntry=igmpSnoopingCfgEntry, staticIpAddress=staticIpAddress, zhnDhcpConditionalServingPoolObjects=zhnDhcpConditionalServingPoolObjects, dot1qPvid=dot1qPvid, holdOffTime=holdOffTime, igmpGroupIndex=igmpGroupIndex, bytesSent=bytesSent, inboundPeakRate=inboundPeakRate, lanDeviceIndex=lanDeviceIndex, uptime=uptime, ipInterfaceIPAddress=ipInterfaceIPAddress, connectionRequest=connectionRequest, password=password, lanHostConfigManagementTable=lanHostConfigManagementTable, IPInterfaceAddressingTypeValues=IPInterfaceAddressingTypeValues, lanEthernetAlias=lanEthernetAlias, connectionStatus=connectionStatus, linkStatus=linkStatus, pppoeConfigEntry=pppoeConfigEntry, lanEthernetIndex=lanEthernetIndex, igmpEnable=igmpEnable, compressionProtocol=compressionProtocol, lanHostConfigManagementEntry=lanHostConfigManagementEntry, currentMTUSize=currentMTUSize, zhnLANEthIntfRateLimitGroup=zhnLANEthIntfRateLimitGroup, lanEthIntfRateLimitEntry=lanEthIntfRateLimitEntry, zhnLANDevice=zhnLANDevice, zhnDhcpConditionalServingPoolTable=zhnDhcpConditionalServingPoolTable, serviceName=serviceName, igmpGroupInterface=igmpGroupInterface, packetsSent=packetsSent, dhcpPoolReservedAddresses=dhcpPoolReservedAddresses, lanEthernetAclRulesNumberofEntries=lanEthernetAclRulesNumberofEntries, igmpGroupsEntry=igmpGroupsEntry, lanUSBInterfaceNumberOfEntries=lanUSBInterfaceNumberOfEntries, dhcpPoolLeaseTime=dhcpPoolLeaseTime, zhnLANDeviceGroups=zhnLANDeviceGroups, lanAclRuleIPProtocol=lanAclRuleIPProtocol, igmpIfName=igmpIfName, ipInterfaceifName=ipInterfaceifName, firewallEnabled=firewallEnabled, dhcpServerConfigurable=dhcpServerConfigurable, dhcpPoolMinAddress=dhcpPoolMinAddress, igmpGroupAddress=igmpGroupAddress, lanEthernetInterfaceConfigEntry=lanEthernetInterfaceConfigEntry, LANEthernetPauseModeValues=LANEthernetPauseModeValues, maxAddress=maxAddress, ipInterfaceIndex=ipInterfaceIndex, lanEthernetIgmpPvid=lanEthernetIgmpPvid, dhcpLeaseTime=dhcpLeaseTime, pauseStatus=pauseStatus, zhnLANIgmpSnoopingGroup=zhnLANIgmpSnoopingGroup, dhcpPoolDomainName=dhcpPoolDomainName, burstSize=burstSize, zhnLANDeviceCompliance=zhnLANDeviceCompliance, zhnDhcpServerEnable=zhnDhcpServerEnable, zhnLANHostConfigManagementGroup=zhnLANHostConfigManagementGroup, lastConnectionError=lastConnectionError, peakRate=peakRate, lanEthernetEnable=lanEthernetEnable, lanEthernetInterfaceNumberOfEntries=lanEthernetInterfaceNumberOfEntries, zhnPPPoEConfigGroup=zhnPPPoEConfigGroup, zhnEthernetPriorityMark=zhnEthernetPriorityMark, LANEthernetMaxBitRateValues=LANEthernetMaxBitRateValues, txErrors=txErrors, domainName=domainName, zhnIfName=zhnIfName, PPPAuthenticationProtocolValues=PPPAuthenticationProtocolValues, dhcpPoolEnableStaticLease=dhcpPoolEnableStaticLease, lanEthIntfStatusEntry=lanEthIntfStatusEntry, lanEthIntfRateLimitTable=lanEthIntfRateLimitTable, defaultGateway=defaultGateway, dhcpPoolEnable=dhcpPoolEnable, igmpGroupReporterMAC=igmpGroupReporterMAC, pppoeIfName=pppoeIfName, dhcpPoolRowStatus=dhcpPoolRowStatus, dhcpPoolChaddr=dhcpPoolChaddr, pppoeConfigObjects=pppoeConfigObjects, zhnIpInterfaceGroup=zhnIpInterfaceGroup, lanAclRuleKey=lanAclRuleKey, lanAclRuleSourceIPAddress=lanAclRuleSourceIPAddress, WANPppLastConnectionErrorValues=WANPppLastConnectionErrorValues, zhnLANIGMPMulticastGroup=zhnLANIGMPMulticastGroup, lanAclRuleSourceMACAddress=lanAclRuleSourceMACAddress, zhnLANSystemGroup=zhnLANSystemGroup, lanEthIntfStatisticsEntry=lanEthIntfStatisticsEntry, igmpGroupVlan=igmpGroupVlan, zhnLANEthernetInterfaceObjects=zhnLANEthernetInterfaceObjects, ipInterfaceSubnetMask=ipInterfaceSubnetMask, natEnabled=natEnabled, igmpGroupQuerier=igmpGroupQuerier, bytesReceived=bytesReceived, rateDirection=rateDirection, dnsServers=dnsServers, PPPEncryptionProtocolValues=PPPEncryptionProtocolValues, PYSNMP_MODULE_ID=zhnLANDevice, lanAclRuleName=lanAclRuleName, ipRouters=ipRouters, ipInterfaceObjects=ipInterfaceObjects, lanDefaultIfName=lanDefaultIfName, zhnDhcpConditionalServingPoolGroup=zhnDhcpConditionalServingPoolGroup, pppoeConfigTable=pppoeConfigTable, zhnLANDeviceGroup=zhnLANDeviceGroup, zhnLANDeviceObjects=zhnLANDeviceObjects, dnsType=dnsType, username=username, igmpGroupsTable=igmpGroupsTable, ipInterfaceEnable=ipInterfaceEnable, ipInterfaceNumberOfEntries=ipInterfaceNumberOfEntries, lanAclRuleSourceMACMask=lanAclRuleSourceMACMask, IGMPSnoopingModeValues=IGMPSnoopingModeValues, dhcpPoolSubnetMask=dhcpPoolSubnetMask, pppoeStatusTable=pppoeStatusTable, zhnVlanType=zhnVlanType, pauseMode=pauseMode, lanEthAclRulesEntry=lanEthAclRulesEntry, lanDeviceTable=lanDeviceTable, minAddress=minAddress, lanEthernetAcl=lanEthernetAcl, LANEthernetStatusValues=LANEthernetStatusValues, dhcpPoolMaxAddress=dhcpPoolMaxAddress, duplexMode=duplexMode, lanEthIntfStatisticsTable=lanEthIntfStatisticsTable, lanDeviceEntry=lanDeviceEntry, encryptionProtocol=encryptionProtocol, igmpGroupReporterIP=igmpGroupReporterIP, alternateWanIfName=alternateWanIfName, zhnLANEthIntfStatisticsGroup=zhnLANEthIntfStatisticsGroup, LANEthernetIpProtocolValues=LANEthernetIpProtocolValues, rxDrops=rxDrops, subnetMask=subnetMask, useStaticIpAddress=useStaticIpAddress, lanEthernetLanFollowsWan=lanEthernetLanFollowsWan, zhnLANAclRulesGroup=zhnLANAclRulesGroup, enableDebug=enableDebug, lanEthernetIgmpPriorityMark=lanEthernetIgmpPriorityMark, rateStatus=rateStatus, dhcpPoolIPRouters=dhcpPoolIPRouters, LANEthernetDuplexModeValues=LANEthernetDuplexModeValues, macAddress=macAddress, zhnIpInterfaceEntry=zhnIpInterfaceEntry, duplexStatus=duplexStatus, rateLimitEnable=rateLimitEnable, lanEthAclRulesTable=lanEthAclRulesTable, zhnLANDeviceCompliances=zhnLANDeviceCompliances, WANPppConnectionStatusValues=WANPppConnectionStatusValues, IpPppoeConnectionTypeValues=IpPppoeConnectionTypeValues, lanEthIntfStatusTable=lanEthIntfStatusTable, lanAclRuleIfName=lanAclRuleIfName, dhcpPoolUseWanVlan=dhcpPoolUseWanVlan, lanEthernetStatus=lanEthernetStatus, dhcpPoolDnsServers=dhcpPoolDnsServers, igmpGroupExpiration=igmpGroupExpiration, zhnLANEthIntfStatusGroup=zhnLANEthIntfStatusGroup, connectionEstablishedTime=connectionEstablishedTime, zhnLANDeviceSystemObjects=zhnLANDeviceSystemObjects, PPPCompressionProtocolValues=PPPCompressionProtocolValues, LANEthernetAclValues=LANEthernetAclValues, naptEnabled=naptEnabled, lanEthernetInterfaceConfigTable=lanEthernetInterfaceConfigTable, igmpSnoopingCfgTable=igmpSnoopingCfgTable, lanHostConfigManagementObjects=lanHostConfigManagementObjects, pid=pid, PPPUserConnectionRequestValues=PPPUserConnectionRequestValues, macAddressControlEnabled=macAddressControlEnabled, pppoeStatusEntry=pppoeStatusEntry, zhnLANDeviceConformance=zhnLANDeviceConformance, zhnDhcpConditionalServingPoolEntry=zhnDhcpConditionalServingPoolEntry, maxMTUSize=maxMTUSize, zhnPPPoEStatusGroup=zhnPPPoEStatusGroup, maxBitRate=maxBitRate, dhcpRelay=dhcpRelay, dhcpPoolChaddrMask=dhcpPoolChaddrMask, packetsReceived=packetsReceived, LANRateLimitBurstSizeValues=LANRateLimitBurstSizeValues, txDrops=txDrops, authentication=authentication, ipInterfaceAddressingType=ipInterfaceAddressingType, DNSTypeValues=DNSTypeValues, primaryDnsIPAddress=primaryDnsIPAddress, lanWLANConfigurationNumberOfEntries=lanWLANConfigurationNumberOfEntries)

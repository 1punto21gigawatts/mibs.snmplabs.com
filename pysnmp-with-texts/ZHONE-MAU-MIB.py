#
# PySNMP MIB module ZHONE-MAU-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/ZHONE-MAU-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:47:45 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueRangeConstraint, ConstraintsUnion, SingleValueConstraint, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueRangeConstraint", "ConstraintsUnion", "SingleValueConstraint", "ValueSizeConstraint")
ifName, ifOperStatus, InterfaceIndexOrZero, ifAdminStatus, ifIndex = mibBuilder.importSymbols("IF-MIB", "ifName", "ifOperStatus", "InterfaceIndexOrZero", "ifAdminStatus", "ifIndex")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Integer32, iso, Counter64, Unsigned32, NotificationType, Counter32, MibScalar, MibTable, MibTableRow, MibTableColumn, ModuleIdentity, TimeTicks, IpAddress, Gauge32, ObjectIdentity, MibIdentifier, Bits = mibBuilder.importSymbols("SNMPv2-SMI", "Integer32", "iso", "Counter64", "Unsigned32", "NotificationType", "Counter32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ModuleIdentity", "TimeTicks", "IpAddress", "Gauge32", "ObjectIdentity", "MibIdentifier", "Bits")
TextualConvention, DisplayString, TruthValue = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString", "TruthValue")
zhoneModules, zhoneEnet = mibBuilder.importSymbols("Zhone", "zhoneModules", "zhoneEnet")
phyEnetMauMib = ModuleIdentity((1, 3, 6, 1, 4, 1, 5504, 6, 8))
phyEnetMauMib.setRevisions(('2013-10-13 17:08', '2012-05-25 14:55', '2009-02-03 01:39', '2009-01-19 21:44', '2008-08-14 07:17', '2008-03-10 12:03', '2007-11-01 14:37', '2007-06-24 23:11', '2007-05-22 16:05', '2005-10-13 16:55', '2000-09-12 18:01',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: phyEnetMauMib.setRevisionsDescriptions(('Add mazFrameSize', 'Added a value to the pauseControl enum', 'Added new 10gBase Mau Types in MauTypeListBits.', 'Added new mauTypes for 10 Gig ports.', 'Added zhoneIfMauEntry.zhoneMauLinkStateMirror field.', 'Added profile link-agg', 'Add aggregation mode', 'V01.00.03 - Add zhoneMauPauseFlowControl and zhoneMauSetPauseTime.', 'V01.00.02 - Added linkAggLink1Trap, linkAggLink2Trap, LinkAggLinkGroup', 'V01.00.01 - Add RPR Traps.', 'V01.00.00 - Initial Release',))
if mibBuilder.loadTexts: phyEnetMauMib.setLastUpdated('201310131500Z')
if mibBuilder.loadTexts: phyEnetMauMib.setOrganization('Zhone Technologies, Inc.')
if mibBuilder.loadTexts: phyEnetMauMib.setContactInfo(' Zhone Technologies. Inc. Postal: 900 Chelmsford Street Lowell, MA 01851 Phone: +1 877-ZHONE20 (877 946-6320) +1 978 848-3766 Fax: +1 978 848-3796 Email: support@zhone.com')
if mibBuilder.loadTexts: phyEnetMauMib.setDescription('MIB to manage the physical interface on Ethernet ports. The MAU referred to by the MIB refers to both integarted physical interfaces as well as the now rarely used external MAUs. Adapted from RFC 2668 - Definitions of Managed Objects for 802.3 Media Attachment Units (MAU). ')
zhoneIfMauTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 5, 1, 1), )
if mibBuilder.loadTexts: zhoneIfMauTable.setStatus('current')
if mibBuilder.loadTexts: zhoneIfMauTable.setDescription('Table of descriptive and status information about the phsyical Enet interface.')
zhoneIfMauEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 5, 1, 1, 1), ).setIndexNames((0, "ZHONE-MAU-MIB", "zhoneMauIfIndex"))
if mibBuilder.loadTexts: zhoneIfMauEntry.setStatus('current')
if mibBuilder.loadTexts: zhoneIfMauEntry.setDescription('An entry in the table, containing information about a single physical Enet interface.')
zhoneMauIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 5, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: zhoneMauIfIndex.setReference('RFC 1213, ifIndex')
if mibBuilder.loadTexts: zhoneMauIfIndex.setStatus('current')
if mibBuilder.loadTexts: zhoneMauIfIndex.setDescription('This variable uniquely identifies the interface to which the Ethernet/MAU described by this entry is connected.')
zhoneMauType = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 5, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 5, 10, 11, 15, 16, 22, 23, 25, 26, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40))).clone(namedValues=NamedValues(("mauOther", 1), ("mau10BaseT", 5), ("mau10BaseTHD", 10), ("mau10BaseTFD", 11), ("mau100BaseTXHD", 15), ("mau100BaseTXFD", 16), ("mau1000BaseLXHD", 22), ("mau1000BaseLXFD", 23), ("mau1000BaseSXHD", 25), ("mau1000BaseSXFD", 26), ("mau1000BaseTHD", 29), ("mau1000BaseTFD", 30), ("mau10gBaseX", 31), ("mau10gBaseR", 32), ("mau10gBaseW", 33), ("mau10gBaseLX4", 34), ("mau10gBaseSR", 35), ("mau10gBaseSW", 36), ("mau10gBaseLR", 37), ("mau10gBaseLW", 38), ("mau10gBaseER", 39), ("mau10gBaseEW", 40)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: zhoneMauType.setStatus('current')
if mibBuilder.loadTexts: zhoneMauType.setDescription('Physical Interface Type')
zhoneMauOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 5, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("unknown", 2), ("operational", 3), ("standby", 4), ("shutdown", 5), ("reset", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: zhoneMauOperStatus.setReference('[IEEE 802.3 Std], 30.5.1.1.7, aMAUAdminState, 30.5.1.2.2, acMAUAdminControl, and 30.5.1.2.1, acResetMAU.')
if mibBuilder.loadTexts: zhoneMauOperStatus.setStatus('current')
if mibBuilder.loadTexts: zhoneMauOperStatus.setDescription('The current operational state of the MAU. other(1) is returned if the MAU or interface is in a state other than one of the states 2 through 6. unknown(2) is returned when the true state of the MAU is unknown; for example, when it is being initialized. operational(3) state is fully functional, operates, and passes signals to its attached DTE. standby(4) state forces DI and CI to idle and the media transmitter or interface to idle or fault, if supported. Standby(4) mode only applies to link type MAUs. The state of zhoneMauMediaAvailable is unaffected. A MAU in shutdown(5) state assumes the same condition on DI, CI, and the media transmitter as though it were powered down or not connected. The MAU MAY return other(1) value for the zhoneMauJabberState and zhoneMauMediaAvailable objects when it is in this state. For an AUI, this state will remove power from the AUI. Setting this variable to the value reset(6) resets the MAU in the same manner as a power-off, power-on cycle of at least one-half second would. The agent is not required to return the value reset (6).')
zhoneMauMediaAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 5, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("other", 1), ("unknown", 2), ("available", 3), ("notAvailable", 4), ("remoteFault", 5), ("invalidSignal", 6), ("remoteJabber", 7), ("remoteLinkLoss", 8), ("remoteTest", 9), ("offline", 10), ("autoNegError", 11)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: zhoneMauMediaAvailable.setReference('[IEEE 802.3 Std], 30.5.1.1.4, aMediaAvailable.')
if mibBuilder.loadTexts: zhoneMauMediaAvailable.setStatus('current')
if mibBuilder.loadTexts: zhoneMauMediaAvailable.setDescription("If the MAU or interface is a link or fiber type (FOIRL, 10BASE-T, 10BASE-F) then this is equivalent to the link test fail state/low light function. For an AUI MAU this indicates whether or not loopback is detected on the DI circuit. other(1) is returned if the mediaAvailable state is not one of 2 through 11. unknown(2) is returned when the MAU's true state is unknown; for example, when it is being initialized. At power-up or following a reset, the value of this attribute will be unknown for AUI and 10BASE-FP MAUs. For these MAUs loopback will be tested on each transmission during which no collision is detected. If DI is receiving input when DO returns to IDL after a transmission and there has been no collision during the transmission then loopback will be detected. The value of this attribute will only change during non-collided transmissions for AUI and 10BASE-FP MAUs. For 100Mbps and 1000Mbps MAUs, the enumerations match the states within the respective link integrity states. Any MAU which implements management of auto-negotiation will map remote fault indication to remote fault. available(3) indicates that the link, light, or loopback is normal. The value notAvailable(4) indicates link loss, low light, or no loopback. remoteFault(5) indicates that a fault has been detected at the remote end of the link. This value applies to 10BASE-FB, 100BASE-T4 Far End Fault Indication and non-specified remote faults from a system running auto-negotiation. remoteJabber(7), remoteLinkLoss(8), and remoteTest(9) SHOULD be used instead of remoteFault(5) where the reason for remote fault is identified in the remote signaling protocol. invalidSignal(6) indicates that an invalid signal has been received from the other end of the link. InvalidSignal(6) applies only to MAUs of type 10BASE-FB. Where an IEEE Std 802.3u-1995 clause 22 MII is present, a logic one in the remote fault bit (reference section 22.2.4.2.8 of that document) maps to the value remoteFault(5), and a logic zero in the link status bit (reference section 22.2.4.2.10 of that document) maps to the value notAvailable(4). The value notAvailable(4) takes precedence over the value remoteFault(5). Any MAU that implements management of clause 37 Auto-Negotiation will map the received RF1 and RF2 bit values for Offline to offline(10), Link Failure to remoteFault(5) and Auto-Negotiation Error to autoNegError(11).")
zhoneMauMediaAvailStateExits = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 5, 1, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: zhoneMauMediaAvailStateExits.setReference('[IEEE 802.3 Std], 30.5.1.1.5, aLoseMediaCounter. RFC 2233, ifCounterDiscontinuityTime.')
if mibBuilder.loadTexts: zhoneMauMediaAvailStateExits.setStatus('current')
if mibBuilder.loadTexts: zhoneMauMediaAvailStateExits.setDescription('A count of the number of times that zhoneMauMediaAvailable for this MAU or interface instance leaves the state available(3). Discontinuities in the value of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of ifCounterDiscontinuityTime.')
zhoneMauJabberState = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 5, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("unknown", 2), ("noJabber", 3), ("jabbering", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: zhoneMauJabberState.setReference('[IEEE 802.3 Std], 30.5.1.1.6, aJabber.jabberFlag.')
if mibBuilder.loadTexts: zhoneMauJabberState.setStatus('current')
if mibBuilder.loadTexts: zhoneMauJabberState.setDescription("The value other(1) is returned if the jabber state is not 2, 3, or 4. unknown(2) is returned when the MAU's true state is unknown; e.g. when it is being initialized. If the MAU is not jabbering the agent returns noJabber(3). This is the 'normal' state. If the MAU is in jabber state the agent returns the jabbering(4) value.")
zhoneMauJabberingStateEnters = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 5, 1, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: zhoneMauJabberingStateEnters.setReference('[IEEE 802.3 Std], 30.5.1.1.6, aJabber.jabberCounter. RFC 2233, ifCounterDiscontinuityTime.')
if mibBuilder.loadTexts: zhoneMauJabberingStateEnters.setStatus('current')
if mibBuilder.loadTexts: zhoneMauJabberingStateEnters.setDescription('A count of the number of times that zhoneMauJabberState for this MAU or interface instance enters the state jabbering(4). This counter will always indicate zero for MAUs of ype dot1MauTypeAUI and those of speeds above 10Mbps. Discontinuities in the value of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of ifCounterDiscontinuityTime.')
zhoneMauFalseCarriers = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 5, 1, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: zhoneMauFalseCarriers.setReference('[IEEE 802.3 Std], 30.5.1.1.10, aFalseCarriers. RFC 2233, ifCounterDiscontinuityTime.')
if mibBuilder.loadTexts: zhoneMauFalseCarriers.setStatus('current')
if mibBuilder.loadTexts: zhoneMauFalseCarriers.setDescription('A count of the number of false carrier events during IDLE in 100BASE-X and 1000BASE-X links. For all other MAU or inetrafce types, this counter will always indicate zero. This counter does not increment at the symbol rate. It can increment after a valid carrier completion at a maximum rate of once per 100 ms for 100BASE-X and once per 10us for 1000BASE-X until the next CarrierEvent. Discontinuities in the value of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of ifCounterDiscontinuityTime.')
zhoneMauDefaultType = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 5, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 5, 10, 11, 15, 16, 22, 23, 25, 26, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40))).clone(namedValues=NamedValues(("mauOther", 1), ("mau10BaseT", 5), ("mau10BaseTHD", 10), ("mau10BaseTFD", 11), ("mau100BaseTXHD", 15), ("mau100BaseTXFD", 16), ("mau1000BaseLXHD", 22), ("mau1000BaseLXFD", 23), ("mau1000BaseSXHD", 25), ("mau1000BaseSXFD", 26), ("mau1000BaseTHD", 29), ("mau1000BaseTFD", 30), ("mau10gBaseX", 31), ("mau10gBaseR", 32), ("mau10gBaseW", 33), ("mau10gBaseLX4", 34), ("mau10gBaseSR", 35), ("mau10gBaseSW", 36), ("mau10gBaseLR", 37), ("mau10gBaseLW", 38), ("mau10gBaseER", 39), ("mau10gBaseEW", 40)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: zhoneMauDefaultType.setStatus('current')
if mibBuilder.loadTexts: zhoneMauDefaultType.setDescription('Physical interface type.')
zhoneMauAutoNegSupported = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 5, 1, 1, 1, 10), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: zhoneMauAutoNegSupported.setStatus('current')
if mibBuilder.loadTexts: zhoneMauAutoNegSupported.setDescription('This object indicates whether or not auto-negotiation is supported.')
zhoneMauTypeListBits = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 5, 1, 1, 1, 11), Bits().clone(namedValues=NamedValues(("bOther", 0), ("bAUI", 1), ("b10base5", 2), ("bFoirl", 3), ("b10base2", 4), ("b10baseT", 5), ("b10baseFP", 6), ("b10baseFB", 7), ("b10baseFL", 8), ("b10broad36", 9), ("b10baseTHD", 10), ("b10baseTFD", 11), ("b10baseFLHD", 12), ("b10baseFLFD", 13), ("b100baseT4", 14), ("b100baseTXHD", 15), ("b100baseTXFD", 16), ("b100baseFXHD", 17), ("b100baseFXFD", 18), ("b100baseT2HD", 19), ("b100baseT2FD", 20), ("b1000baseXHD", 21), ("b1000baseXFD", 22), ("b1000baseLXHD", 23), ("b1000baseLXFD", 24), ("b1000baseSXHD", 25), ("b1000baseSXFD", 26), ("b1000baseCXHD", 27), ("b1000baseCXFD", 28), ("b1000baseTHD", 29), ("b1000baseTFD", 30), ("b10gbaseX", 31), ("b10gbaseR", 32), ("b10gbaseW", 33), ("b10gbaseLX4", 34), ("b10gbaseSR", 35), ("b10gbaseSW", 36), ("b10gbaseLR", 37), ("b10gbaseLW", 38), ("b10gbaseER", 39), ("b10gbaseEW", 40)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: zhoneMauTypeListBits.setStatus('current')
if mibBuilder.loadTexts: zhoneMauTypeListBits.setDescription('A value that uniquely identifies the set of possible IEEE 802.3 types that the MAU could be. If auto-negotiation is present on this MAU, this object will map to ifMauAutoNegCapability. Note that this MAU may be capable of operating as a MAU type that is beyond the scope of this MIB. This is indicated by returning the bit value bOther in addition to any bit values for capabilities that are listed above.')
zhoneMauClkSrc = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 5, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unused", 1), ("automatic", 2), ("master", 3), ("slave", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: zhoneMauClkSrc.setStatus('current')
if mibBuilder.loadTexts: zhoneMauClkSrc.setDescription('Clock source for timing. Unused - unused Automatic - Master/Slave is decided during autonegotiation Master - Clocked from local source Slave - Loop timing from the received data stream')
zhoneMauPauseFlowControl = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 5, 1, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("disabled", 1), ("asymmetricTx", 2), ("asymmetricRx", 3), ("symmetric", 4), ("passthrough", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: zhoneMauPauseFlowControl.setStatus('current')
if mibBuilder.loadTexts: zhoneMauPauseFlowControl.setDescription('When autonegotiation is enabled (zhoneMauAutoNegSupported is true), this Pause Flow Control field is used to program the advertised pause capabilities. When autonegotiation is disabled (manual negotiation), this Pause Flow Control field is used to program the local Mac as instructed. If passthrough is selected the pause frames are sent to the host for forwarding or discard as the packet rules dictate.')
zhoneMauAggregationMode = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 5, 1, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("passive", 3), ("active", 4))).clone('on')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: zhoneMauAggregationMode.setStatus('current')
if mibBuilder.loadTexts: zhoneMauAggregationMode.setDescription('On: The link aggregation is forced to be formed without any LACP negotiation .In other words, the switch will neither send the LACP packet nor process any incoming LACP packet. This is similar to the on state for PAgP. Off: The link aggregation will not be formed. We do not send or understand the LACP packet. This is similar to the off state for PAgP. Passive: The switch does not initiate the channel, but does understand incoming LACP packets. The peer (in active state) initiates negotiation (by sending out an LACP packet) which we receive and reply to, eventually forming the aggregation channel with the peer. This is similar to the auto mode in PAgP. Active: We are willing to form an aggregate link, and initiate the negotiation. The link aggregate will be formed if the other end is running in LACP active or passive mode. This is similar to the desirable mode of PAgP. ')
zhoneMauLinkStateMirror = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 5, 1, 1, 1, 15), InterfaceIndexOrZero()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: zhoneMauLinkStateMirror.setStatus('current')
if mibBuilder.loadTexts: zhoneMauLinkStateMirror.setDescription('ifIndex of another physical interface whose link state will be mirrored on this MAU. This is used to propagate a link fault observed on one physical interface onto another interface.')
zhoneMauSetPauseTime = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 5, 1, 1, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: zhoneMauSetPauseTime.setStatus('current')
if mibBuilder.loadTexts: zhoneMauSetPauseTime.setDescription('Used to set the pause interval. Units are in pause_quanta. Currently not supported.')
zhoneMauMaxFrameSize = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 5, 1, 1, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15360))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: zhoneMauMaxFrameSize.setStatus('current')
if mibBuilder.loadTexts: zhoneMauMaxFrameSize.setDescription('Used to set the max frame size for ethernet ports. Units are bytes. Range is 0 15360. 0 is default implying 2048 bytes.')
zhoneMauIngressRate = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 5, 1, 1, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10240000))).setUnits('Kbps').setMaxAccess("readwrite")
if mibBuilder.loadTexts: zhoneMauIngressRate.setStatus('current')
if mibBuilder.loadTexts: zhoneMauIngressRate.setDescription('Used to set the ingress rate for ethernet ports. Units are Kbps. Range is 0 10Gbps. 0 is default implying no limit.')
zhoneMauIngressBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 5, 1, 1, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 512000))).setUnits('Kbits').setMaxAccess("readwrite")
if mibBuilder.loadTexts: zhoneMauIngressBurstSize.setStatus('current')
if mibBuilder.loadTexts: zhoneMauIngressBurstSize.setDescription('Used to set the ingress burst size for ethernet ports. Units are Kbits. Range is 0 512000. 0 is default implying no restriction.')
zhoneMauEgressRate = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 5, 1, 1, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10240000))).setUnits('Kbps').setMaxAccess("readwrite")
if mibBuilder.loadTexts: zhoneMauEgressRate.setStatus('current')
if mibBuilder.loadTexts: zhoneMauEgressRate.setDescription('Used to set the egress rate for ethernet ports. Units are Kbps. Range is 0 10Gbps. 0 is default implying no limit.')
zhoneMauEgressBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 5, 1, 1, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 512000))).setUnits('Kbits').setMaxAccess("readwrite")
if mibBuilder.loadTexts: zhoneMauEgressBurstSize.setStatus('current')
if mibBuilder.loadTexts: zhoneMauEgressBurstSize.setDescription('Used to set the egress burst size for ethernet ports. Units are Kbits. Range is 0 512000. 0 is default implying no restriction.')
zhoneMauAutoNegTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 5, 1, 2), )
if mibBuilder.loadTexts: zhoneMauAutoNegTable.setStatus('current')
if mibBuilder.loadTexts: zhoneMauAutoNegTable.setDescription('Configuration and status objects for the auto-negotiation function of MAUs attached to interfaces.')
zhoneMauAutoNegEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 5, 1, 2, 1), ).setIndexNames((0, "ZHONE-MAU-MIB", "zhoneMauIfIndex"))
if mibBuilder.loadTexts: zhoneMauAutoNegEntry.setStatus('current')
if mibBuilder.loadTexts: zhoneMauAutoNegEntry.setDescription('An entry in the table, containing configuration and status information for the auto-negotiation function of a particular MAU.')
zhoneMauAutoNegAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 5, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: zhoneMauAutoNegAdminStatus.setReference('[IEEE 802.3 Std], 30.6.1.1.2, aAutoNegAdminState and 30.6.1.2.2, acAutoNegAdminControl.')
if mibBuilder.loadTexts: zhoneMauAutoNegAdminStatus.setStatus('current')
if mibBuilder.loadTexts: zhoneMauAutoNegAdminStatus.setDescription('Setting this object to enabled(1) will cause the interface which has the auto-negotiation signaling ability to be enabled. If the value of this object is disabled(2) then the interface will act as it would if it had no auto-negotiation signaling. Under these conditions, an IEEE 802.3 MAU will immediately be forced to the state indicated by the value of the object zhoneMauDefaultType. NOTE TO IMPLEMENTORS: When ifMauAutoNegAdminStatus transitions from enabled to disabled, the agent implementation MUST ensure that the operational type of the MAU (as reported by zhoneMauType) correctly transitions to the value specified by the zhoneMauDefaultType object, rather than continuing to operate at the value earlier determined by the auto-negotiation function.')
zhoneMauAutoNegRemoteSignaling = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 5, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("detected", 1), ("notdetected", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: zhoneMauAutoNegRemoteSignaling.setReference('[IEEE 802.3 Std], 30.6.1.1.3, aAutoNegRemoteSignaling.')
if mibBuilder.loadTexts: zhoneMauAutoNegRemoteSignaling.setStatus('current')
if mibBuilder.loadTexts: zhoneMauAutoNegRemoteSignaling.setDescription('A value indicating whether the remote end of the link is using auto-negotiation signaling. It takes the value detected(1) if and only if, during the previous link negotiation, FLP Bursts were received.')
zhoneMauAutoNegConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 5, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("configuring", 2), ("complete", 3), ("disabled", 4), ("parallelDetectFail", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: zhoneMauAutoNegConfig.setReference('[IEEE 802.3 Std], 30.6.1.1.4, aAutoNegAutoConfig.')
if mibBuilder.loadTexts: zhoneMauAutoNegConfig.setStatus('current')
if mibBuilder.loadTexts: zhoneMauAutoNegConfig.setDescription('A value indicating the current status of the auto-negotiation process. The enumeration parallelDetectFail(5) maps to a failure in parallel detection as defined in 28.2.3.1 of [IEEE 802.3 Std].')
zhoneMauAutoNegRestart = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 5, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("restart", 1), ("norestart", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: zhoneMauAutoNegRestart.setReference('[IEEE 802.3 Std], 30.6.1.2.1, acAutoNegRestartAutoConfig.')
if mibBuilder.loadTexts: zhoneMauAutoNegRestart.setStatus('current')
if mibBuilder.loadTexts: zhoneMauAutoNegRestart.setDescription('If the value of this object is set to restart(1) then this will force auto-negotiation to begin link renegotiation. If auto-negotiation signaling is disabled, a write to this object has no effect. Setting the value of this object to norestart(2) has no effect.')
zhoneMauAutoNegCapabilityBits = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 5, 1, 2, 1, 5), Bits().clone(namedValues=NamedValues(("bOther", 0), ("b10baseT", 1), ("b10baseTFD", 2), ("b100baseT4", 3), ("b100baseTX", 4), ("b100baseTXFD", 5), ("b100baseT2", 6), ("b100baseT2FD", 7), ("bfdxPause", 8), ("bfdxAPause", 9), ("bfdxSPause", 10), ("bfdxBPause", 11), ("b1000baseX", 12), ("b1000baseXFD", 13), ("b1000baseT", 14), ("b1000baseTFD", 15), ("b10gbaseX", 16), ("b10gbaseR", 17), ("b10gbaseW", 18), ("b10gbaseLX4", 19), ("b10gbaseSR", 20), ("b10gbaseSW", 21), ("b10gbaseLR", 22), ("b10gbaseLW", 23), ("b10gbaseER", 24), ("b10gbaseEW", 25)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: zhoneMauAutoNegCapabilityBits.setReference('[IEEE 802.3 Std], 30.6.1.1.5, aAutoNegLocalTechnologyAbility.')
if mibBuilder.loadTexts: zhoneMauAutoNegCapabilityBits.setStatus('current')
if mibBuilder.loadTexts: zhoneMauAutoNegCapabilityBits.setDescription('A value that uniquely identifies the set of capabilities of the local auto-negotiation entity. Note that interfaces that support this MIB may have capabilities that extend beyond the scope of this MIB. Note that the local auto-negotiation entity may support some capabilities beyond the scope of this MIB. This is indicated by returning the bit value bOther in addition to any bit values for capabilities that are listed above.')
zhoneMauAutoNegCapAdvertBits = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 5, 1, 2, 1, 6), Bits().clone(namedValues=NamedValues(("bOther", 0), ("b10baseT", 1), ("b10baseTFD", 2), ("b100baseT4", 3), ("b100baseTX", 4), ("b100baseTXFD", 5), ("b100baseT2", 6), ("b100baseT2FD", 7), ("bFdxPause", 8), ("bFdxAPause", 9), ("bFdxSPause", 10), ("bFdxBPause", 11), ("b1000baseX", 12), ("b1000baseXFD", 13), ("b1000baseT", 14), ("b1000baseTFD", 15), ("b10gbaseX", 16), ("b10gbaseR", 17), ("b10gbaseW", 18), ("b10gbaseLX4", 19), ("b10gbaseSR", 20), ("b10gbaseSW", 21), ("b10gbaseLR", 22), ("b10gbaseLW", 23), ("b10gbaseER", 24), ("b10gbaseEW", 25)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: zhoneMauAutoNegCapAdvertBits.setReference('[IEEE 802.3 Std], 30.6.1.1.6, aAutoNegAdvertisedTechnologyAbility.')
if mibBuilder.loadTexts: zhoneMauAutoNegCapAdvertBits.setStatus('current')
if mibBuilder.loadTexts: zhoneMauAutoNegCapAdvertBits.setDescription('A value that uniquely identifies the set of capabilities advertised by the local auto-negotiation entity. Capabilities in this object that are not available in ifMauAutoNegCapabilityBits cannot be enabled. Note that the local auto-negotiation entity may advertise some capabilities beyond the scope of this MIB. This is indicated by returning the bit value bOther in addition to any bit values for capabilities that are listed above.')
zhoneMauAutoNegCapRecvBits = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 5, 1, 2, 1, 7), Bits().clone(namedValues=NamedValues(("bOther", 0), ("b10baseT", 1), ("b10baseTFD", 2), ("b100baseT4", 3), ("b100baseTX", 4), ("b100baseTXFD", 5), ("b100baseT2", 6), ("b100baseT2FD", 7), ("bFdxPause", 8), ("bFdxAPause", 9), ("bFdxSPause", 10), ("bFdxBPause", 11), ("b1000baseX", 12), ("b1000baseXFD", 13), ("b1000baseT", 14), ("b1000baseTFD", 15), ("b10gbaseX", 16), ("b10gbaseR", 17), ("b10gbaseW", 18), ("b10gbaseLX4", 19), ("b10gbaseSR", 20), ("b10gbaseSW", 21), ("b10gbaseLR", 22), ("b10gbaseLW", 23), ("b10gbaseER", 24), ("b10gbaseEW", 25)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: zhoneMauAutoNegCapRecvBits.setReference('[IEEE 802.3 Std], 30.6.1.1.7, aAutoNegReceivedTechnologyAbility.')
if mibBuilder.loadTexts: zhoneMauAutoNegCapRecvBits.setStatus('current')
if mibBuilder.loadTexts: zhoneMauAutoNegCapRecvBits.setDescription('A value that uniquely identifies the set of capabilities received from the remote auto-negotiation entity. Note that interfaces that support this MIB may be attached to remote auto-negotiation entities which have capabilities beyond the scope of this MIB. This is indicated by returning the bit value bOther(0) in addition to any bit values for capabilities that are listed above.')
zhoneMauAutoNegRemoteFaultAdvert = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 5, 1, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("noError", 1), ("offline", 2), ("linkFailure", 3), ("autoNegError", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: zhoneMauAutoNegRemoteFaultAdvert.setReference('[IEEE 802.3 Std], 30.6.1.1.6, aAutoNegAdvertisedTechnologyAbility.')
if mibBuilder.loadTexts: zhoneMauAutoNegRemoteFaultAdvert.setStatus('current')
if mibBuilder.loadTexts: zhoneMauAutoNegRemoteFaultAdvert.setDescription('A value that identifies any local fault indications that this MAU has detected and will advertise at the next auto-negotiation interaction for 1000Mbps MAUs.')
zhoneMauAutoNegRemoteFaultRecv = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 5, 1, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("noError", 1), ("offline", 2), ("linkFailure", 3), ("autoNegError", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: zhoneMauAutoNegRemoteFaultRecv.setReference('[IEEE 802.3 Std], 30.6.1.1.7, aAutoNegReceivedTechnologyAbility.')
if mibBuilder.loadTexts: zhoneMauAutoNegRemoteFaultRecv.setStatus('current')
if mibBuilder.loadTexts: zhoneMauAutoNegRemoteFaultRecv.setDescription('A value that identifies any fault indications received from the far end of a link by the local auto-negotiation entity for 1000Mbps MAUs.')
zhoneEnetTraps = ObjectIdentity((1, 3, 6, 1, 4, 1, 5504, 5, 1, 3))
if mibBuilder.loadTexts: zhoneEnetTraps.setStatus('current')
if mibBuilder.loadTexts: zhoneEnetTraps.setDescription('Description.')
enetV2Traps = ObjectIdentity((1, 3, 6, 1, 4, 1, 5504, 5, 1, 3, 0))
if mibBuilder.loadTexts: enetV2Traps.setStatus('current')
if mibBuilder.loadTexts: enetV2Traps.setDescription('Description.')
rprEastSpanTrap = NotificationType((1, 3, 6, 1, 4, 1, 5504, 5, 1, 3, 0, 1)).setObjects(("IF-MIB", "ifIndex"), ("IF-MIB", "ifAdminStatus"), ("IF-MIB", "ifOperStatus"), ("IF-MIB", "ifName"))
if mibBuilder.loadTexts: rprEastSpanTrap.setStatus('current')
if mibBuilder.loadTexts: rprEastSpanTrap.setDescription('Resilient Packet Ring (RPR) East Span Trap - indicates East span went Up or Down. RPR runs over Gigabit Ethernet.')
rprWestSpanTrap = NotificationType((1, 3, 6, 1, 4, 1, 5504, 5, 1, 3, 0, 2)).setObjects(("IF-MIB", "ifIndex"), ("IF-MIB", "ifAdminStatus"), ("IF-MIB", "ifOperStatus"), ("IF-MIB", "ifName"))
if mibBuilder.loadTexts: rprWestSpanTrap.setStatus('current')
if mibBuilder.loadTexts: rprWestSpanTrap.setDescription('Resilient Packet Ring (RPR) West Span Trap - indicates West span went Up or Down. RPR runs over Gigabit Ethernet.')
linkAggLink1Trap = NotificationType((1, 3, 6, 1, 4, 1, 5504, 5, 1, 3, 0, 3))
if mibBuilder.loadTexts: linkAggLink1Trap.setStatus('current')
if mibBuilder.loadTexts: linkAggLink1Trap.setDescription('Link Aggregation Link1 Trap - indicates Link 1 went Up or Down. ')
linkAggLink2Trap = NotificationType((1, 3, 6, 1, 4, 1, 5504, 5, 1, 3, 0, 4))
if mibBuilder.loadTexts: linkAggLink2Trap.setStatus('current')
if mibBuilder.loadTexts: linkAggLink2Trap.setDescription('Link Aggregation Link2 Trap - indicates Link 2 went Up or Down. ')
rprSpanGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 5504, 5, 1, 3, 2)).setObjects(("ZHONE-MAU-MIB", "rprEastSpanTrap"), ("ZHONE-MAU-MIB", "rprWestSpanTrap"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rprSpanGroup = rprSpanGroup.setStatus('current')
if mibBuilder.loadTexts: rprSpanGroup.setDescription('Grouping of RPR Span Notifications.')
linkAggLinkGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 5504, 5, 1, 3, 3)).setObjects(("ZHONE-MAU-MIB", "linkAggLink1Trap"), ("ZHONE-MAU-MIB", "linkAggLink2Trap"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    linkAggLinkGroup = linkAggLinkGroup.setStatus('current')
if mibBuilder.loadTexts: linkAggLinkGroup.setDescription('Grouping of Link Aggregation Link Notifications.')
zhoneLinkAggTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 5, 1, 4), )
if mibBuilder.loadTexts: zhoneLinkAggTable.setStatus('current')
if mibBuilder.loadTexts: zhoneLinkAggTable.setDescription('Table of Identifiers specifying the partner system to which an aggregation is connected.')
zhoneLinkAggEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 5, 1, 4, 1), ).setIndexNames((0, "ZHONE-MAU-MIB", "zhoneLinkAggIfIndex"))
if mibBuilder.loadTexts: zhoneLinkAggEntry.setStatus('current')
if mibBuilder.loadTexts: zhoneLinkAggEntry.setDescription('An entry in the table, containing information about a single partner system aggregation.')
zhoneLinkAggIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 5, 1, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: zhoneLinkAggIfIndex.setStatus('current')
if mibBuilder.loadTexts: zhoneLinkAggIfIndex.setDescription('This variable uniquely identifies the link aggregation by which the profile described in this entry is identified.')
zhoneLinkAggPartnerSystem = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 5, 1, 4, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 18))).setMaxAccess("readonly")
if mibBuilder.loadTexts: zhoneLinkAggPartnerSystem.setStatus('current')
if mibBuilder.loadTexts: zhoneLinkAggPartnerSystem.setDescription("A six-byte identifier, similar to a MAC address, specifying the partner system, but stored as a string, and specified in the pattern 'nn:nn:nn:nn:nn:nn', where 'nn' is a hex number specifying a byte of the pattern.")
zhoneLinkAggPartnerSystemPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 5, 1, 4, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: zhoneLinkAggPartnerSystemPriority.setStatus('current')
if mibBuilder.loadTexts: zhoneLinkAggPartnerSystemPriority.setDescription('An integer further specifying the partner system.')
zhoneLinkAggPartnerGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 5, 1, 4, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: zhoneLinkAggPartnerGroupId.setStatus('current')
if mibBuilder.loadTexts: zhoneLinkAggPartnerGroupId.setDescription('An integer identifier specifying the link group.')
mibBuilder.exportSymbols("ZHONE-MAU-MIB", zhoneMauAutoNegCapabilityBits=zhoneMauAutoNegCapabilityBits, zhoneMauOperStatus=zhoneMauOperStatus, zhoneMauAutoNegRestart=zhoneMauAutoNegRestart, zhoneMauEgressRate=zhoneMauEgressRate, zhoneMauAggregationMode=zhoneMauAggregationMode, zhoneIfMauEntry=zhoneIfMauEntry, zhoneLinkAggPartnerGroupId=zhoneLinkAggPartnerGroupId, zhoneMauAutoNegRemoteSignaling=zhoneMauAutoNegRemoteSignaling, linkAggLink2Trap=linkAggLink2Trap, zhoneMauAutoNegConfig=zhoneMauAutoNegConfig, rprSpanGroup=rprSpanGroup, zhoneMauJabberState=zhoneMauJabberState, zhoneMauClkSrc=zhoneMauClkSrc, zhoneMauTypeListBits=zhoneMauTypeListBits, zhoneLinkAggTable=zhoneLinkAggTable, zhoneLinkAggPartnerSystemPriority=zhoneLinkAggPartnerSystemPriority, zhoneMauAutoNegCapAdvertBits=zhoneMauAutoNegCapAdvertBits, zhoneMauFalseCarriers=zhoneMauFalseCarriers, zhoneMauAutoNegAdminStatus=zhoneMauAutoNegAdminStatus, zhoneMauJabberingStateEnters=zhoneMauJabberingStateEnters, zhoneEnetTraps=zhoneEnetTraps, zhoneMauIngressBurstSize=zhoneMauIngressBurstSize, phyEnetMauMib=phyEnetMauMib, zhoneMauAutoNegSupported=zhoneMauAutoNegSupported, zhoneIfMauTable=zhoneIfMauTable, zhoneMauLinkStateMirror=zhoneMauLinkStateMirror, zhoneMauAutoNegTable=zhoneMauAutoNegTable, zhoneMauAutoNegRemoteFaultRecv=zhoneMauAutoNegRemoteFaultRecv, zhoneLinkAggPartnerSystem=zhoneLinkAggPartnerSystem, linkAggLink1Trap=linkAggLink1Trap, zhoneMauType=zhoneMauType, zhoneLinkAggEntry=zhoneLinkAggEntry, zhoneLinkAggIfIndex=zhoneLinkAggIfIndex, zhoneMauMediaAvailStateExits=zhoneMauMediaAvailStateExits, zhoneMauMediaAvailable=zhoneMauMediaAvailable, zhoneMauIfIndex=zhoneMauIfIndex, zhoneMauAutoNegRemoteFaultAdvert=zhoneMauAutoNegRemoteFaultAdvert, zhoneMauDefaultType=zhoneMauDefaultType, zhoneMauIngressRate=zhoneMauIngressRate, rprWestSpanTrap=rprWestSpanTrap, zhoneMauEgressBurstSize=zhoneMauEgressBurstSize, zhoneMauSetPauseTime=zhoneMauSetPauseTime, PYSNMP_MODULE_ID=phyEnetMauMib, zhoneMauAutoNegEntry=zhoneMauAutoNegEntry, rprEastSpanTrap=rprEastSpanTrap, linkAggLinkGroup=linkAggLinkGroup, enetV2Traps=enetV2Traps, zhoneMauAutoNegCapRecvBits=zhoneMauAutoNegCapRecvBits, zhoneMauMaxFrameSize=zhoneMauMaxFrameSize, zhoneMauPauseFlowControl=zhoneMauPauseFlowControl)

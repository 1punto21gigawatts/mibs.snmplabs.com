#
# PySNMP MIB module CPQIDE-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CPQIDE-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:27:38 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ValueSizeConstraint, SingleValueConstraint, ConstraintsIntersection, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsIntersection", "ConstraintsUnion")
compaq, cpqHoTrapFlags = mibBuilder.importSymbols("CPQHOST-MIB", "compaq", "cpqHoTrapFlags")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
sysName, = mibBuilder.importSymbols("SNMPv2-MIB", "sysName")
ModuleIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter32, Gauge32, iso, IpAddress, NotificationType, Bits, ObjectIdentity, NotificationType, Counter64, Unsigned32, MibIdentifier, TimeTicks, Integer32, enterprises = mibBuilder.importSymbols("SNMPv2-SMI", "ModuleIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter32", "Gauge32", "iso", "IpAddress", "NotificationType", "Bits", "ObjectIdentity", "NotificationType", "Counter64", "Unsigned32", "MibIdentifier", "TimeTicks", "Integer32", "enterprises")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
cpqIde = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 14))
cpqIdeMibRev = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 14, 1))
cpqIdeComponent = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 14, 2))
cpqIdeInterface = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 14, 2, 1))
cpqIdeIdent = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 14, 2, 2))
cpqIdeController = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 14, 2, 3))
cpqIdeAtaDisk = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 14, 2, 4))
cpqIdeAtapiDevice = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 14, 2, 5))
cpqIdeLogicalDrive = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 14, 2, 6))
cpqIdeOsCommon = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 14, 2, 1, 4))
cpqIdeMibRevMajor = MibScalar((1, 3, 6, 1, 4, 1, 232, 14, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqIdeMibRevMajor.setStatus('mandatory')
if mibBuilder.loadTexts: cpqIdeMibRevMajor.setDescription('The Major Revision level. A change in the major revision level represents a major change in the architecture of the MIB. A change in the major revision level may indicate a significant change in the information supported and/or the meaning of the supported information, correct interpretation of data may require a MIB document with the same major revision level.')
cpqIdeMibRevMinor = MibScalar((1, 3, 6, 1, 4, 1, 232, 14, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqIdeMibRevMinor.setStatus('mandatory')
if mibBuilder.loadTexts: cpqIdeMibRevMinor.setDescription('The Minor Revision level. A change in the minor revision level may represent some minor additional support; no changes to any pre-existing information has occurred.')
cpqIdeMibCondition = MibScalar((1, 3, 6, 1, 4, 1, 232, 14, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("degraded", 3), ("failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqIdeMibCondition.setStatus('mandatory')
if mibBuilder.loadTexts: cpqIdeMibCondition.setDescription('The overall condition. This object represents the overall status of the Ide system represented by this MIB.')
cpqIdeOsCommonPollFreq = MibScalar((1, 3, 6, 1, 4, 1, 232, 14, 2, 1, 4, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpqIdeOsCommonPollFreq.setStatus('mandatory')
if mibBuilder.loadTexts: cpqIdeOsCommonPollFreq.setDescription("The Insight Agent's polling frequency. The frequency, in seconds, at which the Insight Agent requests information from the device driver. A frequency of zero indicates that the Insight Agent retrieves the information upon request of a management station, it does not poll the device driver at a specific interval. If the poll frequency is zero (0) all attempts to write to this object will fail. If the poll frequency is non-zero, setting this value will change the polling frequency of the Insight Agent. Setting the poll frequency to zero will always fail, an agent may also choose to fail any request to change the poll frequency to a value that would severely impact system performance.")
cpqIdeOsCommonModuleTable = MibTable((1, 3, 6, 1, 4, 1, 232, 14, 2, 1, 4, 2), )
if mibBuilder.loadTexts: cpqIdeOsCommonModuleTable.setStatus('deprecated')
if mibBuilder.loadTexts: cpqIdeOsCommonModuleTable.setDescription('A table of software modules that provide an interface to the device this MIB describes.')
cpqIdeOsCommonModuleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 14, 2, 1, 4, 2, 1), ).setIndexNames((0, "CPQIDE-MIB", "cpqIdeOsCommonModuleIndex"))
if mibBuilder.loadTexts: cpqIdeOsCommonModuleEntry.setStatus('deprecated')
if mibBuilder.loadTexts: cpqIdeOsCommonModuleEntry.setDescription('A description of a software modules that provide an interface to the device this MIB describes.')
cpqIdeOsCommonModuleIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 14, 2, 1, 4, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqIdeOsCommonModuleIndex.setStatus('deprecated')
if mibBuilder.loadTexts: cpqIdeOsCommonModuleIndex.setDescription('A unique index for this module description.')
cpqIdeOsCommonModuleName = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 14, 2, 1, 4, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqIdeOsCommonModuleName.setStatus('deprecated')
if mibBuilder.loadTexts: cpqIdeOsCommonModuleName.setDescription('The module name.')
cpqIdeOsCommonModuleVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 14, 2, 1, 4, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 5))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqIdeOsCommonModuleVersion.setStatus('deprecated')
if mibBuilder.loadTexts: cpqIdeOsCommonModuleVersion.setDescription('The module version in XX.YY format. Where XX is the major version number and YY is the minor version number. This field will be a null (size 0) string if the agent cannot provide the module version.')
cpqIdeOsCommonModuleDate = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 14, 2, 1, 4, 2, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(7, 7)).setFixedLength(7)).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqIdeOsCommonModuleDate.setStatus('deprecated')
if mibBuilder.loadTexts: cpqIdeOsCommonModuleDate.setDescription('The module date. field octets contents range ===== ====== ======= ===== 1 1-2 year 0..65536 2 3 month 1..12 3 4 day 1..31 4 5 hour 0..23 5 6 minute 0..59 6 7 second 0..60 (use 60 for leap-second) This field will be set to year = 0 if the agent cannot provide the module date. The hour, minute, and second field will be set to zero (0) if they are not relevant.')
cpqIdeOsCommonModulePurpose = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 14, 2, 1, 4, 2, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqIdeOsCommonModulePurpose.setStatus('deprecated')
if mibBuilder.loadTexts: cpqIdeOsCommonModulePurpose.setDescription('The purpose of the module described in this entry.')
cpqIdeIdentTable = MibTable((1, 3, 6, 1, 4, 1, 232, 14, 2, 2, 1), )
if mibBuilder.loadTexts: cpqIdeIdentTable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqIdeIdentTable.setDescription('IDE Drive Identification Table.')
cpqIdeIdentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 14, 2, 2, 1, 1), ).setIndexNames((0, "CPQIDE-MIB", "cpqIdeIdentIndex"))
if mibBuilder.loadTexts: cpqIdeIdentEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cpqIdeIdentEntry.setDescription('IDE Identification Table Entry.')
cpqIdeIdentIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 14, 2, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqIdeIdentIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqIdeIdentIndex.setDescription('An index that uniquely specifies each device. For disks, this index value will match the value of the cpqSeFixedDiskIndex in the Standard Equipment MIB (CPQSTDEQ.MIB) when the same disk is being described. Each possible index value indicates a specific drive as shown in the table below: Drive Index IDE Controller Drive Unit =========== ============== ========== 0 Primary 1 1 Primary 2 2 Secondary 1 3 Secondary 2 Any other index value would be implementation specific.')
cpqIdeIdentModel = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 14, 2, 2, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 41))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqIdeIdentModel.setStatus('mandatory')
if mibBuilder.loadTexts: cpqIdeIdentModel.setDescription('IDE Drive Model. The is the drive model name and can be used for identification purposes.')
cpqIdeIdentSerNum = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 14, 2, 2, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 21))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqIdeIdentSerNum.setStatus('mandatory')
if mibBuilder.loadTexts: cpqIdeIdentSerNum.setDescription('IDE Drive Serial Number. The is the drive serial number and can be used for identification purposes.')
cpqIdeIdentFWVers = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 14, 2, 2, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 9))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqIdeIdentFWVers.setStatus('mandatory')
if mibBuilder.loadTexts: cpqIdeIdentFWVers.setDescription('IDE Firmware Version. This is the version of the firmware on the IDE drive. If the IDE drive firmware version is unavailable, then this string will be of length zero (0).')
cpqIdeIdentCondition = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 14, 2, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("degraded", 3), ("failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqIdeIdentCondition.setStatus('deprecated')
if mibBuilder.loadTexts: cpqIdeIdentCondition.setDescription('IDE Drive Condition. This is the overall condition of the IDE drive. The following values are defined: other(1) The drive does not support drive condition monitoring. ok(2) The drive is operating normally. No user action is required. degraded(3) The drive is degraded. The drive may need to be replaced. failed(4) The drive has failed. The drive should be replaced.')
cpqIdeIdentErrorNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 14, 2, 2, 1, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqIdeIdentErrorNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cpqIdeIdentErrorNumber.setDescription('IDE Error Number. This value represents the error code associated with a failing IDE drive.')
cpqIdeIdentType = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 14, 2, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("other", 1), ("disk", 2), ("tape", 3), ("printer", 4), ("processor", 5), ("wormDrive", 6), ("cd-rom", 7), ("scanner", 8), ("optical", 9), ("jukeBox", 10), ("commDev", 11)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqIdeIdentType.setStatus('mandatory')
if mibBuilder.loadTexts: cpqIdeIdentType.setDescription('IDE Device Type. This is the type of ATAPI device. The following types are defined: other(1) The Insight agent does not recognize this type. You may need to upgrade your software. disk(2) This is a direct-access device like a disk drive. tape(3) This is a sequential-access device like a tape drive. printer(4) This is a printer device. processor(5) This is a processor device. worm(6) This is a write-once, read-many times device. cd-rom(7) This is a CD or DVD device. scanner(8) This is a scanner device. optical(9) This is an optical memory device. jukeBox(10) This is a media changer device like a jukebox. commDev(11) This is a communications device like a LAN bridge.')
cpqIdeIdentTypeExtended = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 14, 2, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("pdcd", 2), ("removableDisk", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqIdeIdentTypeExtended.setStatus('mandatory')
if mibBuilder.loadTexts: cpqIdeIdentTypeExtended.setDescription('IDE Extended Device Type. This is additional information about the type of IDE device. The following types are defined: other(1) This target does not have any extended type information. pdcd(2) This is a power-drive CD-ROM. removableDisk(3) This is a removable media disk device like a floppy drive.')
cpqIdeIdentCondition2 = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 14, 2, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("degraded", 3), ("failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqIdeIdentCondition2.setStatus('mandatory')
if mibBuilder.loadTexts: cpqIdeIdentCondition2.setDescription('IDE Drive Condition. This is the overall condition of the IDE drive. The following values are defined: other(1) The drive does not support drive condition monitoring. ok(2) The drive is operating normally. No user action is required. degraded(3) The drive is degraded. See cpqIdeIdentStatus for the appropriate action. failed(4) The drive has failed. See cpqIdeIdentStatus for the appropriate action.')
cpqIdeIdentStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 14, 2, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("preFailureDegraded", 3), ("ultraAtaDegraded", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqIdeIdentStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cpqIdeIdentStatus.setDescription('IDE Drive Satus. This indicates the status of the IDE drive. The following values are defined: other(1) The drive does not support drive status monitoring. ok(2) The drive is operating normally. No user action is required. preFailureDegraded(3) The drive has detected that at least one pre-failure SMART attribute has gone out of range. The drive may need to be replaced. ultraAtaDegraded(4) The Ultra ATA Integrity Monitor has detected data transmission errors between the hard drive and processor. For best performance, move Ultra ATA devices to the primary controller and non Ultra ATA devices to the secondary controller. If errors still persist, consider replacing the standard 40-conductor cable with and 80-conductor cable.')
cpqIdeIdentUltraAtaAvailability = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 14, 2, 2, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("noNotSupportedByDeviceAndController", 2), ("noNotSupportedByDevice", 3), ("noNotSupportedByController", 4), ("noDisabledInSetup", 5), ("yesEnabledInSetup", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqIdeIdentUltraAtaAvailability.setStatus('mandatory')
if mibBuilder.loadTexts: cpqIdeIdentUltraAtaAvailability.setDescription('This describes the availability of Ultra ATA transfers between this device and the controller. The following values are defined: other(1) The agents do not support reporting this variable or the agent need to be upgraded. noNotSupportedByDeviceAndController(2), The device and the controller do not support Ultra ATA. noNotSupportedByDevice(3), The device does not support Ultra ATA but the controller does support Ultra ATA. noNotSupportedByController(4), The controller does not support Ultra ATA but the device does support Ultra ATA. NoDisabledInSetup(5), The device and the controller do support Ultra ATA but it has been disabled in F10 Setup. yesEnabledInSetup(6), The device and the controller do support Ultra ATA and it is enabled in F10 Setup.')
cpqIdeControllerTable = MibTable((1, 3, 6, 1, 4, 1, 232, 14, 2, 3, 1), )
if mibBuilder.loadTexts: cpqIdeControllerTable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqIdeControllerTable.setDescription('IDE Controller Table.')
cpqIdeControllerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 14, 2, 3, 1, 1), ).setIndexNames((0, "CPQIDE-MIB", "cpqIdeControllerIndex"))
if mibBuilder.loadTexts: cpqIdeControllerEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cpqIdeControllerEntry.setDescription('IDE Controller Table Entry.')
cpqIdeControllerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 14, 2, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqIdeControllerIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqIdeControllerIndex.setDescription('An index that uniquely identifies each controller.')
cpqIdeControllerOverallCondition = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 14, 2, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("degraded", 3), ("failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqIdeControllerOverallCondition.setStatus('mandatory')
if mibBuilder.loadTexts: cpqIdeControllerOverallCondition.setDescription('IDE Controller Overall Condition. This is the overall condition of the IDE controller and any associated devices.')
cpqIdeControllerModel = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 14, 2, 3, 1, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqIdeControllerModel.setStatus('mandatory')
if mibBuilder.loadTexts: cpqIdeControllerModel.setDescription('IDE Controller Model. The is the IDE controller model name.')
cpqIdeControllerFwRev = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 14, 2, 3, 1, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqIdeControllerFwRev.setStatus('mandatory')
if mibBuilder.loadTexts: cpqIdeControllerFwRev.setDescription('IDE Controller Firmware Revision. The is the IDE controller firmware revision.')
cpqIdeControllerSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 14, 2, 3, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqIdeControllerSlot.setStatus('mandatory')
if mibBuilder.loadTexts: cpqIdeControllerSlot.setDescription('IDE Controller Slot. This identifies the physical slot where the IDE controller resides in the system. For example, if this value is three, the controller is located in slot three of your computer. If the value cannot be determined or is not applicable, the value is set to -1.')
cpqIdeControllerStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 14, 2, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("failed", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqIdeControllerStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cpqIdeControllerStatus.setDescription('IDE Channel Host Controller Status. The host controller can be in one of the following states: Other (1) The agent is unable to determine the status of the controller. OK (2) Indicates that the controller is in normal operation mode. Failed (3) Indicates that the host controller has failed and should be replaced.')
cpqIdeControllerCondition = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 14, 2, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("degraded", 3), ("failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqIdeControllerCondition.setStatus('mandatory')
if mibBuilder.loadTexts: cpqIdeControllerCondition.setDescription('IDE Controller Condition. This is the condition of the IDE controller.')
cpqIdeControllerSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 14, 2, 3, 1, 1, 8), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqIdeControllerSerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cpqIdeControllerSerialNumber.setDescription('IDE Controller Serial Number. The is the IDE controller serial number. A NULL string indicates that the serial number could not be determined or is irrelevant.')
cpqIdeAtaDiskTable = MibTable((1, 3, 6, 1, 4, 1, 232, 14, 2, 4, 1), )
if mibBuilder.loadTexts: cpqIdeAtaDiskTable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqIdeAtaDiskTable.setDescription('IDE ATA Disk Table.')
cpqIdeAtaDiskEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 14, 2, 4, 1, 1), ).setIndexNames((0, "CPQIDE-MIB", "cpqIdeAtaDiskControllerIndex"), (0, "CPQIDE-MIB", "cpqIdeAtaDiskIndex"))
if mibBuilder.loadTexts: cpqIdeAtaDiskEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cpqIdeAtaDiskEntry.setDescription('IDE ATA Disk Table Entry.')
cpqIdeAtaDiskControllerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 14, 2, 4, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqIdeAtaDiskControllerIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqIdeAtaDiskControllerIndex.setDescription('An index that uniquely identifies each controller.')
cpqIdeAtaDiskIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 14, 2, 4, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqIdeAtaDiskIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqIdeAtaDiskIndex.setDescription('An index that uniquely identifies each disk.')
cpqIdeAtaDiskModel = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 14, 2, 4, 1, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqIdeAtaDiskModel.setStatus('mandatory')
if mibBuilder.loadTexts: cpqIdeAtaDiskModel.setDescription('ATA Disk Model. The is the model name of the ATA disk.')
cpqIdeAtaDiskFwRev = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 14, 2, 4, 1, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqIdeAtaDiskFwRev.setStatus('mandatory')
if mibBuilder.loadTexts: cpqIdeAtaDiskFwRev.setDescription('ATA Disk Firmware Revision. The is the firmware revision of the ATA disk.')
cpqIdeAtaDiskSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 14, 2, 4, 1, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqIdeAtaDiskSerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cpqIdeAtaDiskSerialNumber.setDescription('ATA Disk Serial Number. The is the serial number of the ATA disk.')
cpqIdeAtaDiskStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 14, 2, 4, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("smartError", 3), ("failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqIdeAtaDiskStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cpqIdeAtaDiskStatus.setDescription('ATA Disk Status. This is the status of the ATA disk.')
cpqIdeAtaDiskCondition = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 14, 2, 4, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("degraded", 3), ("failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqIdeAtaDiskCondition.setStatus('mandatory')
if mibBuilder.loadTexts: cpqIdeAtaDiskCondition.setDescription('ATA Disk Condition. This is the condition of the ATA disk.')
cpqIdeAtaDiskCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 14, 2, 4, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqIdeAtaDiskCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: cpqIdeAtaDiskCapacity.setDescription('ATA Disk Capacity. This is the capacity of the ATA disk in megabytes.')
cpqIdeAtaDiskSmartEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 14, 2, 4, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("true", 2), ("false", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqIdeAtaDiskSmartEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: cpqIdeAtaDiskSmartEnabled.setDescription('ATA Disk S.M.A.R.T Enabled? other(1) The agent cannot determine the state of S.M.A.R.T. monitoring on this ATA disk. true(2) The ATA disk has S.M.A.R.T motitoring enabled. false(3) The ATA disk does not have S.M.A.R.T motitoring enabled.')
cpqIdeAtaDiskTransferMode = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 14, 2, 4, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("other", 1), ("pioMode0", 2), ("pioMode1", 3), ("pioMode2", 4), ("pioMode3", 5), ("pioMode4", 6), ("dmaMode0", 7), ("dmaMode1", 8), ("dmaMode2", 9), ("ultraDmaMode0", 10), ("ultraDmaMode1", 11), ("ultraDmaMode2", 12), ("ultraDmaMode3", 13), ("ultraDmaMode4", 14), ("ultraDmaMode5", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqIdeAtaDiskTransferMode.setStatus('mandatory')
if mibBuilder.loadTexts: cpqIdeAtaDiskTransferMode.setDescription('ATA Disk Transfer Mode. other(1) The agent cannot determine the transfer mode on this ATA disk. pioMode0(2) The ATA disk is using PIO mode 0. pioMode1(3) The ATA disk is using PIO mode 1. pioMode2(4) The ATA disk is using PIO mode 2. pioMode3(5) The ATA disk is using PIO mode 3. pioMode4(6) The ATA disk is using PIO mode 4. dmaMode0(7) The ATA disk is using DMA mode 0. dmaMode1(8) The ATA disk is using DMA mode 1. dmaMode2(9) The ATA disk is using DMA mode 2. ultraDmaMode0(10) The ATA disk is using Ultra DMA mode 0. ultraDmaMode1(11) The ATA disk is using Ultra DMA mode 1. ultraDmaMode2(12) The ATA disk is using Ultra DMA mode 2. ultraDmaMode3(13) The ATA disk is using Ultra DMA mode 3. ultraDmaMode4(14) The ATA disk is using Ultra DMA mode 4. ultraDmaMode5(15) The ATA disk is using Ultra DMA mode 5.')
cpqIdeAtaDiskChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 14, 2, 4, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("channel0", 2), ("channel1", 3), ("serial", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqIdeAtaDiskChannel.setStatus('mandatory')
if mibBuilder.loadTexts: cpqIdeAtaDiskChannel.setDescription('ATA Disk Channel. other(1) The agent cannot determine the channel to which the ATA disk is attached. channel0(2) The ATA disk is attached to the primary channel. channel1(3) The ATA disk is attached to the secondary channel. serial(4) The disk is attached to the serial interface and channel no longer applies.')
cpqIdeAtaDiskNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 14, 2, 4, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 21, 22, 23, 24, 25, 26, 27, 28))).clone(namedValues=NamedValues(("other", 1), ("device0", 2), ("device1", 3), ("sataDevice0", 4), ("sataDevice1", 5), ("sataDevice2", 6), ("sataDevice3", 7), ("sataDevice4", 8), ("sataDevice5", 9), ("sataDevice6", 10), ("sataDevice7", 11), ("bay1", 21), ("bay2", 22), ("bay3", 23), ("bay4", 24), ("bay5", 25), ("bay6", 26), ("bay7", 27), ("bay8", 28)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqIdeAtaDiskNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cpqIdeAtaDiskNumber.setDescription('ATA Disk Number. other(1) The agent cannot determine the number of the ATA disk. device0(2) The ATA disk is device 0 (master). device1(3) The ATA disk is device 1 (slave). sataDevice0(4) The SATA disk is device 0. sataDevice1(5) The SATA disk is device 1. sataDevice2(6) The SATA disk is device 2. sataDevice3(7) The SATA disk is device 3. sataDevice4(8) The SATA disk is device 4. sataDevice5(9) The SATA disk is device 5. sataDevice6(10) The SATA disk is device 6. sataDevice7(11) The SATA disk is device 7. bay1(21) The disk is in bay 1. bay2(22) The disk is in bay 2. bay3(23) The disk is in bay 3. bay4(24) The disk is in bay 4. bay5(25) The disk is in bay 5. bay6(26) The disk is in bay 6. bay7(27) The disk is in bay 7. bay8(28) The disk is in bay 8.')
cpqIdeAtaDiskLogicalDriveMember = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 14, 2, 4, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("true", 2), ("false", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqIdeAtaDiskLogicalDriveMember.setStatus('mandatory')
if mibBuilder.loadTexts: cpqIdeAtaDiskLogicalDriveMember.setDescription('Logical Drive Membership? other(1) The agent cannot determine if the ATA disk is part of a logical drive. true(2) The ATA disk is part of a logical drive. false(3) The ATA disk is not part of a logical drive.')
cpqIdeAtaDiskIsSpare = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 14, 2, 4, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("true", 2), ("false", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqIdeAtaDiskIsSpare.setStatus('mandatory')
if mibBuilder.loadTexts: cpqIdeAtaDiskIsSpare.setDescription('ATA Disk Spare? other(1) The agent cannot determine if the ATA disk is a spare. true(2) The ATA disk is a spare disk. false(3) The ATA disk is not a spare disk.')
cpqIdeAtaDiskOsName = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 14, 2, 4, 1, 1, 15), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqIdeAtaDiskOsName.setStatus('mandatory')
if mibBuilder.loadTexts: cpqIdeAtaDiskOsName.setDescription('ATA Disk OS Name. The OS name for this ATA disk. This field will be a null (size 0) string if the agent does not support OS name or if the ATA disk is part of a logical drive.')
cpqIdeAtaDiskType = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 14, 2, 4, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("ata", 2), ("sata", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqIdeAtaDiskType.setStatus('mandatory')
if mibBuilder.loadTexts: cpqIdeAtaDiskType.setDescription('ATA Disk Type other(1) The agent cannot determine the disk type. ata(2) The disk type is parallel ATA. sata(3) The disk type is Serial ATA.')
cpqIdeAtaDiskSataVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 14, 2, 4, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("sataOne", 2), ("sataTwo", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqIdeAtaDiskSataVersion.setStatus('mandatory')
if mibBuilder.loadTexts: cpqIdeAtaDiskSataVersion.setDescription('Physical Drive SATA Version. The following values are defined: other(1) The agent is unable to determine the SATA version for this disk or it is not a SATA disk. sataOne(2) The disk is SATA version one. sataTwo(3) The disk is SATA version two.')
cpqIdeAtapiDeviceTable = MibTable((1, 3, 6, 1, 4, 1, 232, 14, 2, 5, 1), )
if mibBuilder.loadTexts: cpqIdeAtapiDeviceTable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqIdeAtapiDeviceTable.setDescription('IDE ATAPI Device Table.')
cpqIdeAtapiDeviceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 14, 2, 5, 1, 1), ).setIndexNames((0, "CPQIDE-MIB", "cpqIdeAtapiDeviceControllerIndex"), (0, "CPQIDE-MIB", "cpqIdeAtapiDeviceIndex"))
if mibBuilder.loadTexts: cpqIdeAtapiDeviceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cpqIdeAtapiDeviceEntry.setDescription('IDE ATAPI Device Table Entry.')
cpqIdeAtapiDeviceControllerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 14, 2, 5, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqIdeAtapiDeviceControllerIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqIdeAtapiDeviceControllerIndex.setDescription('An index that uniquely identifies each controller.')
cpqIdeAtapiDeviceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 14, 2, 5, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqIdeAtapiDeviceIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqIdeAtapiDeviceIndex.setDescription('An index that uniquely identifies each ATAPI device.')
cpqIdeAtapiDeviceModel = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 14, 2, 5, 1, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqIdeAtapiDeviceModel.setStatus('mandatory')
if mibBuilder.loadTexts: cpqIdeAtapiDeviceModel.setDescription('ATAPI Device Model. The is the model name of the ATAPI device.')
cpqIdeAtapiDeviceFwRev = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 14, 2, 5, 1, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqIdeAtapiDeviceFwRev.setStatus('mandatory')
if mibBuilder.loadTexts: cpqIdeAtapiDeviceFwRev.setDescription('ATAPI Device Firmware Revision. The is the firmware revision of the ATAPI device.')
cpqIdeAtapiDeviceType = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 14, 2, 5, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("other", 1), ("disk", 2), ("tape", 3), ("printer", 4), ("processor", 5), ("wormDrive", 6), ("cd-rom", 7), ("scanner", 8), ("optical", 9), ("jukeBox", 10), ("commDev", 11)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqIdeAtapiDeviceType.setStatus('mandatory')
if mibBuilder.loadTexts: cpqIdeAtapiDeviceType.setDescription('ATAPI Device Type. This is the type of ATAPI device. The following types are defined: other(1) The agent does not recognize this type. You may need to upgrade your software. disk(2) This is a direct-access device like a disk drive. tape(3) This is a sequential-access device like a tape drive. printer(4) This is a printer device. processor(5) This is a processor device. worm(6) This is a write-once, read-many times device. cd-rom(7) This is a CD or DVD device. scanner(8) This is a scanner device. optical(9) This is an optical memory device. jukeBox(10) This is a media changer device like a jukebox. commDev(11) This is a communications device like a LAN bridge.')
cpqIdeAtapiDeviceTypeExtended = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 14, 2, 5, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("pdcd", 2), ("removableDisk", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqIdeAtapiDeviceTypeExtended.setStatus('mandatory')
if mibBuilder.loadTexts: cpqIdeAtapiDeviceTypeExtended.setDescription('ATAPI Extended Device Type. This is additional information about the type of ATAPI device. The following types are defined: other(1) This target does not have any extended type information. pdcd(2) This is a power-drive CD-ROM. removableDisk(3) This is a removable media disk device like a floppy drive.')
cpqIdeAtapiDeviceChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 14, 2, 5, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("channel0", 2), ("channel1", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqIdeAtapiDeviceChannel.setStatus('mandatory')
if mibBuilder.loadTexts: cpqIdeAtapiDeviceChannel.setDescription('ATAPI Device Channel. other(1) The agent cannot determine the channel to which the ATAPI device is attached. channel0(2) The ATAPI device is attached to the primary channel. channel1(3) The ATAPI device is attached to the secondary channel.')
cpqIdeAtapiDeviceNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 14, 2, 5, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("device0", 2), ("device1", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqIdeAtapiDeviceNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cpqIdeAtapiDeviceNumber.setDescription('ATAPI Device Number. other(1) The agent cannot determine the number of the ATAPI device. device0(2) The ATAPI device is device 0 (master). device1(3) The ATAPI device is device 1 (slave).')
cpqIdeLogicalDriveTable = MibTable((1, 3, 6, 1, 4, 1, 232, 14, 2, 6, 1), )
if mibBuilder.loadTexts: cpqIdeLogicalDriveTable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqIdeLogicalDriveTable.setDescription('IDE Logical Drive Table.')
cpqIdeLogicalDriveEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 14, 2, 6, 1, 1), ).setIndexNames((0, "CPQIDE-MIB", "cpqIdeLogicalDriveControllerIndex"), (0, "CPQIDE-MIB", "cpqIdeLogicalDriveIndex"))
if mibBuilder.loadTexts: cpqIdeLogicalDriveEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cpqIdeLogicalDriveEntry.setDescription('IDE Logical Drive Table Entry.')
cpqIdeLogicalDriveControllerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 14, 2, 6, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqIdeLogicalDriveControllerIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqIdeLogicalDriveControllerIndex.setDescription('An index that uniquely identifies each controller.')
cpqIdeLogicalDriveIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 14, 2, 6, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqIdeLogicalDriveIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqIdeLogicalDriveIndex.setDescription('An index that uniquely identifies each logical drive.')
cpqIdeLogicalDriveRaidLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 14, 2, 6, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("other", 1), ("raid0", 2), ("raid1", 3), ("raid0plus1", 4), ("raid5", 5), ("raid15", 6), ("volume", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqIdeLogicalDriveRaidLevel.setStatus('mandatory')
if mibBuilder.loadTexts: cpqIdeLogicalDriveRaidLevel.setDescription('IDE Logical Drive RAID Level. The following RAID levels are defined: other(1) The agent cannot determine the RAID level of this logical drive. raid0(2) The logical drive is configured with RAID level 0. raid1(3) The logical drive is configured with RAID level 1. raid0plus1(4) The logical drive is configured with RAID level 0 plus 1. raid5(5) The logical drive is configured with RAID level 5. raid15(6) The logical drive is configured with RAID level 1 plus 5. volume(7) The logical drive is configured as a volume set.')
cpqIdeLogicalDriveCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 14, 2, 6, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqIdeLogicalDriveCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: cpqIdeLogicalDriveCapacity.setDescription('IDE Logical Drive Capacity. This is the capacity of the logical drive in megabytes.')
cpqIdeLogicalDriveStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 14, 2, 6, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("degraded", 3), ("rebuilding", 4), ("failed", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqIdeLogicalDriveStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cpqIdeLogicalDriveStatus.setDescription("IDE Logical Drive Status. This is the status of the logical drive. other(1) The agent cannot determine the logical drive status. ok(2) Indicates that the logical drive is in normal operation mode. degraded(3) Indicates that at least one physical drive has failed, but the logical drive's RAID level lets the drive continue to operate with no data loss. rebuilding(4) Indicates that the logical drive is rebuilding a physical drive. When complete, the logical drive will return to normal operation. failed(5) Indicates that more physical drives have failed than the RAID level of the logical drive can handle without data loss.")
cpqIdeLogicalDriveCondition = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 14, 2, 6, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("degraded", 3), ("failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqIdeLogicalDriveCondition.setStatus('mandatory')
if mibBuilder.loadTexts: cpqIdeLogicalDriveCondition.setDescription('IDE Logical Drive Condition. This is the condition of the logical drive.')
cpqIdeLogicalDriveDiskIds = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 14, 2, 6, 1, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqIdeLogicalDriveDiskIds.setStatus('mandatory')
if mibBuilder.loadTexts: cpqIdeLogicalDriveDiskIds.setDescription('IDE Logical Drive Disk ID list. This lists the ATA disks drive IDs which are associated with this logical drive. These are the same IDs which can be used as indices into the ATA disk table (cpqIdeAtaDiskIndex). Each byte of the string is an index.')
cpqIdeLogicalDriveStripeSize = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 14, 2, 6, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqIdeLogicalDriveStripeSize.setStatus('mandatory')
if mibBuilder.loadTexts: cpqIdeLogicalDriveStripeSize.setDescription('IDE Logical Drive Stripe Size. This is the stripe size in kilobytes.')
cpqIdeLogicalDriveSpareIds = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 14, 2, 6, 1, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqIdeLogicalDriveSpareIds.setStatus('mandatory')
if mibBuilder.loadTexts: cpqIdeLogicalDriveSpareIds.setDescription('IDE Logical Drive Spare ID list. This lists the ATA disks drive IDs which are possible spares for this logical drive. These are the same IDs which can be used as indices into the ATA disk table (cpqIdeAtaDiskIndex). Each byte of the string is an index.')
cpqIdeLogicalDriveRebuildingDisk = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 14, 2, 6, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqIdeLogicalDriveRebuildingDisk.setStatus('mandatory')
if mibBuilder.loadTexts: cpqIdeLogicalDriveRebuildingDisk.setDescription('IDE Logical Drive Rebuilding Disk. This is the ATA disk that is in the process of rebuilding. If no drive is currently rebuilding, a value of -1 will be returned.')
cpqIdeLogicalDriveOsName = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 14, 2, 6, 1, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqIdeLogicalDriveOsName.setStatus('mandatory')
if mibBuilder.loadTexts: cpqIdeLogicalDriveOsName.setDescription('IDE Logical Drive OS Name. The OS name for this logical drive. This field will be a null (size 0) string if the agent does not support OS name.')
cpqIdeDriveDegraded = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,14001)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQIDE-MIB", "cpqIdeIdentIndex"))
if mibBuilder.loadTexts: cpqIdeDriveDegraded.setDescription('An IDE drive status has been set to degraded. User Action: The drive should be scheduled for replacement. Refer to the appropriate Maintenance and Service Guide for detailed information on a component replacement.')
cpqIdeDriveOk = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,14002)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQIDE-MIB", "cpqIdeIdentIndex"))
if mibBuilder.loadTexts: cpqIdeDriveOk.setDescription('An IDE drive status has been set to ok. User Action: None.')
cpqIdeDriveUltraAtaDegraded = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,14003)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQIDE-MIB", "cpqIdeIdentIndex"))
if mibBuilder.loadTexts: cpqIdeDriveUltraAtaDegraded.setDescription('An IDE drive detects an excessive number of Ultra ATA data transmission errors between the hard drive and the processor. User Action: For best performance move Ultra ATA devices to the primary controller and non Ultra ATA devices to the secondary controller. If errors still persist, consider replacing the standard 40-conductor IDE cable with an 80-conductor Ultra ATA cable.')
cpqIdeAtaDiskStatusChange = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,14004)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQIDE-MIB", "cpqIdeAtaDiskControllerIndex"), ("CPQIDE-MIB", "cpqIdeAtaDiskIndex"), ("CPQIDE-MIB", "cpqIdeAtaDiskModel"), ("CPQIDE-MIB", "cpqIdeAtaDiskFwRev"), ("CPQIDE-MIB", "cpqIdeAtaDiskSerialNumber"), ("CPQIDE-MIB", "cpqIdeAtaDiskStatus"), ("CPQIDE-MIB", "cpqIdeAtaDiskChannel"), ("CPQIDE-MIB", "cpqIdeAtaDiskNumber"))
if mibBuilder.loadTexts: cpqIdeAtaDiskStatusChange.setDescription('ATA Disk Status Change. This trap signifies that the agent has detected a change in the status of an ATA disk drive. The variable cpqIdeAtaDiskStatus indicates the current disk drive status. User Action: If the physical drive status is smartError(3) or failed(4), replace the drive.')
cpqIdeLogicalDriveStatusChange = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,14005)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQIDE-MIB", "cpqIdeControllerModel"), ("CPQIDE-MIB", "cpqIdeControllerSlot"), ("CPQIDE-MIB", "cpqIdeLogicalDriveControllerIndex"), ("CPQIDE-MIB", "cpqIdeLogicalDriveIndex"), ("CPQIDE-MIB", "cpqIdeLogicalDriveStatus"))
if mibBuilder.loadTexts: cpqIdeLogicalDriveStatusChange.setDescription('IDE Logical Drive Status Change. This trap signifies that the agent has detected a change in the status of an IDE logical drive. The variable cpqIdeLogicalDriveStatus indicates the current logical drive status. User Action: If the logical drive status is failed(5), examine the array for failed drives that need replacement.')
mibBuilder.exportSymbols("CPQIDE-MIB", cpqIdeIdentIndex=cpqIdeIdentIndex, cpqIdeOsCommon=cpqIdeOsCommon, cpqIdeAtaDiskModel=cpqIdeAtaDiskModel, cpqIdeOsCommonModuleEntry=cpqIdeOsCommonModuleEntry, cpqIdeIdentCondition2=cpqIdeIdentCondition2, cpqIdeIdentSerNum=cpqIdeIdentSerNum, cpqIdeControllerTable=cpqIdeControllerTable, cpqIdeIdentStatus=cpqIdeIdentStatus, cpqIdeLogicalDriveEntry=cpqIdeLogicalDriveEntry, cpqIdeLogicalDrive=cpqIdeLogicalDrive, cpqIdeOsCommonModulePurpose=cpqIdeOsCommonModulePurpose, cpqIdeMibRevMinor=cpqIdeMibRevMinor, cpqIdeLogicalDriveCapacity=cpqIdeLogicalDriveCapacity, cpqIdeAtaDiskType=cpqIdeAtaDiskType, cpqIdeIdentErrorNumber=cpqIdeIdentErrorNumber, cpqIdeComponent=cpqIdeComponent, cpqIdeControllerModel=cpqIdeControllerModel, cpqIdeLogicalDriveRebuildingDisk=cpqIdeLogicalDriveRebuildingDisk, cpqIdeOsCommonModuleVersion=cpqIdeOsCommonModuleVersion, cpqIdeAtaDiskTransferMode=cpqIdeAtaDiskTransferMode, cpqIdeAtaDiskSataVersion=cpqIdeAtaDiskSataVersion, cpqIdeControllerFwRev=cpqIdeControllerFwRev, cpqIdeAtaDisk=cpqIdeAtaDisk, cpqIdeAtapiDeviceTable=cpqIdeAtapiDeviceTable, cpqIdeControllerSerialNumber=cpqIdeControllerSerialNumber, cpqIdeLogicalDriveStatusChange=cpqIdeLogicalDriveStatusChange, cpqIdeLogicalDriveCondition=cpqIdeLogicalDriveCondition, cpqIdeOsCommonModuleDate=cpqIdeOsCommonModuleDate, cpqIdeLogicalDriveOsName=cpqIdeLogicalDriveOsName, cpqIdeLogicalDriveRaidLevel=cpqIdeLogicalDriveRaidLevel, cpqIdeControllerStatus=cpqIdeControllerStatus, cpqIdeAtaDiskTable=cpqIdeAtaDiskTable, cpqIdeControllerSlot=cpqIdeControllerSlot, cpqIdeDriveOk=cpqIdeDriveOk, cpqIdeLogicalDriveIndex=cpqIdeLogicalDriveIndex, cpqIdeControllerEntry=cpqIdeControllerEntry, cpqIdeAtapiDeviceModel=cpqIdeAtapiDeviceModel, cpqIdeAtaDiskLogicalDriveMember=cpqIdeAtaDiskLogicalDriveMember, cpqIdeAtapiDeviceTypeExtended=cpqIdeAtapiDeviceTypeExtended, cpqIdeAtapiDeviceIndex=cpqIdeAtapiDeviceIndex, cpqIdeController=cpqIdeController, cpqIdeLogicalDriveSpareIds=cpqIdeLogicalDriveSpareIds, cpqIdeLogicalDriveDiskIds=cpqIdeLogicalDriveDiskIds, cpqIdeIdentEntry=cpqIdeIdentEntry, cpqIdeAtapiDevice=cpqIdeAtapiDevice, cpqIdeOsCommonModuleIndex=cpqIdeOsCommonModuleIndex, cpqIdeIdentTypeExtended=cpqIdeIdentTypeExtended, cpqIdeDriveUltraAtaDegraded=cpqIdeDriveUltraAtaDegraded, cpqIdeAtapiDeviceControllerIndex=cpqIdeAtapiDeviceControllerIndex, cpqIdeAtaDiskSerialNumber=cpqIdeAtaDiskSerialNumber, cpqIdeIdentCondition=cpqIdeIdentCondition, cpqIdeAtaDiskCondition=cpqIdeAtaDiskCondition, cpqIdeAtaDiskStatusChange=cpqIdeAtaDiskStatusChange, cpqIdeControllerCondition=cpqIdeControllerCondition, cpqIdeAtaDiskOsName=cpqIdeAtaDiskOsName, cpqIdeAtaDiskSmartEnabled=cpqIdeAtaDiskSmartEnabled, cpqIdeMibRevMajor=cpqIdeMibRevMajor, cpqIdeControllerOverallCondition=cpqIdeControllerOverallCondition, cpqIdeLogicalDriveStatus=cpqIdeLogicalDriveStatus, cpqIdeAtaDiskFwRev=cpqIdeAtaDiskFwRev, cpqIdeAtaDiskControllerIndex=cpqIdeAtaDiskControllerIndex, cpqIdeAtapiDeviceType=cpqIdeAtapiDeviceType, cpqIdeMibCondition=cpqIdeMibCondition, cpqIdeLogicalDriveStripeSize=cpqIdeLogicalDriveStripeSize, cpqIdeOsCommonModuleTable=cpqIdeOsCommonModuleTable, cpqIdeAtapiDeviceFwRev=cpqIdeAtapiDeviceFwRev, cpqIdeAtapiDeviceEntry=cpqIdeAtapiDeviceEntry, cpqIde=cpqIde, cpqIdeIdentModel=cpqIdeIdentModel, cpqIdeControllerIndex=cpqIdeControllerIndex, cpqIdeInterface=cpqIdeInterface, cpqIdeAtapiDeviceNumber=cpqIdeAtapiDeviceNumber, cpqIdeAtaDiskCapacity=cpqIdeAtaDiskCapacity, cpqIdeAtaDiskChannel=cpqIdeAtaDiskChannel, cpqIdeOsCommonModuleName=cpqIdeOsCommonModuleName, cpqIdeAtaDiskStatus=cpqIdeAtaDiskStatus, cpqIdeIdent=cpqIdeIdent, cpqIdeIdentUltraAtaAvailability=cpqIdeIdentUltraAtaAvailability, cpqIdeAtaDiskIsSpare=cpqIdeAtaDiskIsSpare, cpqIdeDriveDegraded=cpqIdeDriveDegraded, cpqIdeAtaDiskEntry=cpqIdeAtaDiskEntry, cpqIdeIdentFWVers=cpqIdeIdentFWVers, cpqIdeLogicalDriveControllerIndex=cpqIdeLogicalDriveControllerIndex, cpqIdeMibRev=cpqIdeMibRev, cpqIdeAtaDiskIndex=cpqIdeAtaDiskIndex, cpqIdeOsCommonPollFreq=cpqIdeOsCommonPollFreq, cpqIdeLogicalDriveTable=cpqIdeLogicalDriveTable, cpqIdeAtapiDeviceChannel=cpqIdeAtapiDeviceChannel, cpqIdeIdentType=cpqIdeIdentType, cpqIdeAtaDiskNumber=cpqIdeAtaDiskNumber, cpqIdeIdentTable=cpqIdeIdentTable)

#
# PySNMP MIB module CISCO-PFR-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-PFR-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:09:24 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ValueSizeConstraint, ConstraintsIntersection, SingleValueConstraint, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ValueSizeConstraint", "ConstraintsIntersection", "SingleValueConstraint", "ValueRangeConstraint")
CiscoPdProtocolIndex, = mibBuilder.importSymbols("CISCO-NBAR-PROTOCOL-DISCOVERY-MIB", "CiscoPdProtocolIndex")
ciscoMgmt, = mibBuilder.importSymbols("CISCO-SMI", "ciscoMgmt")
CiscoPort, InterfaceIndexOrZero = mibBuilder.importSymbols("CISCO-TC", "CiscoPort", "InterfaceIndexOrZero")
DscpOrAny, = mibBuilder.importSymbols("DIFFSERV-DSCP-TC", "DscpOrAny")
CounterBasedGauge64, = mibBuilder.importSymbols("HCNUM-TC", "CounterBasedGauge64")
InetPortNumber, InetAddress, InetAddressType = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetPortNumber", "InetAddress", "InetAddressType")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ModuleCompliance, NotificationGroup, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup", "ObjectGroup")
MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, NotificationType, Gauge32, Counter32, TimeTicks, iso, Bits, Counter64, ObjectIdentity, Integer32, ModuleIdentity, IpAddress, Unsigned32 = mibBuilder.importSymbols("SNMPv2-SMI", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "NotificationType", "Gauge32", "Counter32", "TimeTicks", "iso", "Bits", "Counter64", "ObjectIdentity", "Integer32", "ModuleIdentity", "IpAddress", "Unsigned32")
DateAndTime, TimeStamp, RowStatus, TextualConvention, TruthValue, StorageType, DisplayString, TimeInterval = mibBuilder.importSymbols("SNMPv2-TC", "DateAndTime", "TimeStamp", "RowStatus", "TextualConvention", "TruthValue", "StorageType", "DisplayString", "TimeInterval")
ciscoPfrMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 9, 772))
ciscoPfrMIB.setRevisions(('2012-11-13 00:00', '2011-04-04 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ciscoPfrMIB.setRevisionsDescriptions(('Add the following mib groups: cpfrMasterControllerGroupRev1, cpfrBorderRouterGroupRev1 cpfrMCNotificationGroup; Add ciscoPfrMIBComplianceRev1; Modify cpfrTCSLastOOPReason object to add rsvpOOPRecomputeExclude enum value; Modify cpfrBRConnFailureReason object to add authFailure(3), socketError(4), timerExpired(5) enum values; Modify cpfrTCSLastOOPReason object to add rsvpOOPRecomputeExclude;', 'The first version of PfR MIB module.',))
if mibBuilder.loadTexts: ciscoPfrMIB.setLastUpdated('201211130000Z')
if mibBuilder.loadTexts: ciscoPfrMIB.setOrganization('Cisco Systems, Inc.')
if mibBuilder.loadTexts: ciscoPfrMIB.setContactInfo('Cisco Systems Customer Service Postal: 170 W Tasman Drive San Jose, CA 95134 USA Tel: +1 800 553-NETS E-mail: cs-pfr@cisco.com')
if mibBuilder.loadTexts: ciscoPfrMIB.setDescription("This MIB module defines objects that describe Performance Routing (PfR). Standard routing protocols base routing decisions on reachability and the number of hops between the source and destination networks. PfR collects and analyzes other performance data, such as delay, loss, jitter, MOS, and link utilization, which allows it to make routing decisions based on policies defined by the network administrator. Glossary ======== PfR Performance Routing. MC PfR Master Controller. BR PfR Border Router. DRIP Dynamic Router Interaction Protocol. TC PfR Traffic Class. IPSLA IP Service Level Agreement (active probing). Exit PfR external interface. Link Group PfR logical grouping of exits to narrow down potential exits for a TC to use. Cost Minimization PfR feature that assigns costs to exits and minimizes the overall monetary cost for a TC Rollup Data collection for monetary cost calculation for all available exits. DSCP Diff-Serv Control Point. PfR Policy Global PfR policy defined under PfR master. TC policy defined under PfR map. PfR Map Container for a PfR policy. MOS Mean opinion score PBR Policy based routing. PBR uses route map to enforce the routing decision made by PfR. PfR Elements ============ A PfR system consists of a Master Controller (MC) and one or more Border Routers (BRs). The MC is a hardware or software entity that is not in the data path. A BR is a software entity in the data path, typically running on an edge router. The MC and BRs communicate with each other over a socket interface using the Dynamic Router Interaction Protocol (DRIP). The MC sends commands to the BRs related to PfR Policies and the monitoring of PfR traffic classes (TCs). The BRs send performance data gathered using either 'passive data' provided by NetFlow, 'active data' provided by sending artificial probes that are created using IPSLA APIs, or both, depending on the PfR policies configured on the MC. This MIB module describes a MC object as a single row in the cpfrMCTable and the BR object as a single row in the cpfrBRTable. PfR Exits ========= A PfR system must have at least two interfaces (i.e., exits) configured as 'external interfaces' over which a TC's destination network is reachable in order for PfR to function. These two exits can be on the same BR or on different BRs. +------+ +------+ |----> Exit 1 | MC | ---- | BR | ---- | +------+ +------+ |----> Exit 2 **** OR **** +------+ | ---- | BR | ----> Exit 1 +------+ | +------+ | MC | ---- | +------+ | +------+ | ---- | BR | ----> Exit 2 +------+ PfR can assign these exits to different PfR Link Groups. A PfR exit can be in at most three Link Groups at one time. (See 'PfR Policies' below). This MIB module describes a PfR exit as a single row in the cpfrExitTable and a cost minimization policy of an exit as a single row of the cpfrExitCostTierTable. PfR Traffic Classes =================== A traffic class is a generic term for a set of traffic flows coming into or going out of a network that have a common characteristic, such as destination address, source address, application, or DSCP value. The simplest form of a TC is 'all traffic going to the same destination prefix'. Additional parameters defines more specific TCs. PfR monitors the TCs that are specified either by enabling PfR learn mode or by direct configuration in a PfR map. PfR can learn TCs with the highest throughput, with the highest delay, with a destination address inside the PfR network, or TCs that matches a configured PfR Learn List. The BRs use iBGP to obtain information about 'inside TCs'. A PfR map specifies TCs to which the policy applies by configuring match clause. This MIB module describes a PfR TC as a single row in the cpfrTrafficClassTable and current status of a TC as a single row of the cpfrTrafficClassStatusTable, and performance metrics gathered for a specific TC as a single row of the cpfrTrafficClassMetricsTable. PfR Policies ============ A PfR policy describes the performance metrics the router is to gather, how to gather these metrics, how frequently it should gather these metrics, and how these metrics influence routing decisions. Once enabled, PfR provides a global default PfR policy. A PfR policy can be configured to use one link group as a 'primary' and one as a 'fallback' link group. If PfR determines that a TC has gone 'Out of Policy' based on the current PfR policy, it attempts to move the TC to an exit in the same primary link group, and only moves it to an exit in the fallback link group, if configured, if no exit in the primary link group is 'In Policy'. This MIB module describes a PfR map policy in a single row of the cpfrMapTable and a match clause configured for a specific PfR map as a single row of the cpfrMatchTable.")
class PfrMetricPolicyType(TextualConvention, Integer32):
    description = "'relative' Relative percentage is used. 'threshold' Maximum threshold is used."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("relative", 1), ("threshold", 2))

class PfrLastUncontrolReason(TextualConvention, Integer32):
    description = "This textual convention denotes all types of uncontrol reasons that causes PfR to uncontrol a TC. 'none' TC is uncontrolled due to unknown reasons. 'activatingUnsedFcdTgt' TC is uncontrolled due to activating an unused forced target. 'ifaceDown' TC is uncontrolled due to an interface down. 'newProbeTargetAssigned' TC is uncontrolled due to newly assigned probe targets. 'newTargetAssigned' TC is uncontrolled due to newly assigned targets. 'borderDown' TC is uncontrolled due to BR down. 'uncontrolNonOptimizedPfx' TC is uncontrolled due to uncontrolled non optimized prefixes. 'recontrolNull0Pfx' TC is uncontrolled due to recontrolling a null0 prefix. 'recontrolSinkHolePfx' TC is uncontrolled due to recontrolling a sink hole prefix. 'modeRouteChange' TC is uncontrolled due to route mode change. 'pfxEnabled' TC is uncontrolled due to prefix enabled. 'uncontrolModeMonitorChange' TC is uncontrolled due to monitor mode change. 'insideEnabled' TC is uncontrolled due to inside prefix learn enabled. 'forcedNextHop' TC is uncontrolled due to forced next hop configured. 'forwardToNull0' TC is uncontrolled since TCs are forwarded to null0 interfaces. 'clearOnePfx' TC is uncontrolled due to clearing one prefix. 'clearOneTc' TC is uncontrolled due to clearing one TC. 'grantUpdated' TC is uncontrolled due to granted update. 'tcInFastMode' TC is uncontrolled due to TC in fast mode. 'pbrBRTopologyChange' TC is uncontrolled due to BR topology change when PBR is met. 'pfrReqNotMet' TC is uncontrolled since PfR requests are not met. 'probeFrequencyChange' TC is uncontrolled due to probe frequency change. 'fcdTgtAssRemMod' TC is uncontrolled due to assigned force target removed. 'policyChangedAddedNewFcdProbeTgt' TC is uncontrolled due to newly added forced probe target. 'usingFcdTgtNow' TC is uncontrolled due to starting using forced target. 'firstTargetWithDscpAdded' TC is uncontrolled due to newly added target with DSCP. 'lastTargetWithDscpRemoved' TC is uncontrolled due to last target with DSCP removed. 'couldntMonitor' TC is uncontrolled since PfR could not monitor it. 'couldntControl' TC is uncontrolled since PfR could not control it. 'applControlOnBrFailed' TC is uncontrolled since PfR could not control an application. 'allProtoCouldNtControl' TC is uncontrolled since control attempts by all protocols fail. 'excludePfxFailed' TC is uncontrolled due to failing excluding a prefix. 'ipflowRestFailed' TC is uncontrolled due to ip flow reset failure. 'couldntExclude' TC is uncontrolled due to failing excluding prefixes. 'dontDowngradeAllEntrances' TC is uncontrolled due to no downgrade all entrance. 'maxDownGrade' TC is uncontrolled due to maximizing downgrade. 'cantSelectEntrances' TC is uncontrolled since PfR cannot select entrances. 'unhandledOopReasonInChooseExit' TC is uncontrolled due to unhandled out of policy reason when choosing exit. 'oopModeSelectExitGood' TC is uncontrolled due to out of policy when selecting good exit. 'couldntFindBestExitInAllLinkGrps' TC is uncontrolled since PfR could not find best exit in all linkgroups. 'couldntFindBestExit' TC is uncontrolled since PfR could not find best exit. 'failedToControlRoute' TC is uncontrolled due to route control failure. 'endOfProbing' TC is uncontrolled due to the end of active probing. 'retryForcedNextHop' TC is uncontrolled due to retrying forced next hop. 'noStatusInPfxTimeout' TC is uncontrolled due to missing status before the time is out for controlling a prefix. 'couldntChooseExitInPfxTimeout' TC is uncontrolled since PfR could not choose exit before the time is out for controlling a prefix. 'unableToSendControlMsg' TC is uncontrolled since control messages could not be sent out. 'nbarIdStateUpdated' TC is uncontrolled due to nbar state update failure. 'exitMisMatch' TC is uncontrolled due to exit mismatch. 'unknownExit' TC is uncontrolled due to unknown exits. 'newExitWhileInpolicy' TC is uncontrolled due to new exit appearance. 'couldntControlPasPfxInSpecMode' TC is uncontrolled since PfR could not control passive prefixes in specific mode. 'remoteStatsNotFound' TC is uncontrolled due to unclear remote statistic data. 'nbarInternalIfAddedRemoved' TC is uncontrolled since NBAR internal interface is added or removed. 'noPassiveData' TC is uncontrolled due to lack of passive data. 'probeNumPktsChanged' TC is uncontrolled due to the number of probing packets changed."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61))
    namedValues = NamedValues(("none", 1), ("activatingUnsedFcdTgt", 2), ("ifaceDown", 3), ("newProbeTargetAssigned", 4), ("newTargetAssigned", 5), ("borderDown", 6), ("uncontrolNonOptimizedPfx", 7), ("recontrolNull0Pfx", 8), ("recontrolSinkHolePfx", 9), ("modeRouteChange", 10), ("pfxEnabled", 11), ("uncontrolModeMonitorChange", 12), ("insideEnabled", 13), ("forcedNextHop", 14), ("forwardToNull0", 15), ("clearOnePfx", 16), ("clearOneTc", 17), ("grantUpdated", 18), ("tcInFastMode", 19), ("pbrBRTopologyChange", 20), ("pfrReqNotMet", 21), ("probeFrequencyChange", 22), ("fcdTgtAssRemMod", 23), ("policyChangedAddedNewFcdProbeTgt", 24), ("usingFcdTgtNow", 25), ("firstTargetWithDscpAdded", 26), ("usingLmNow", 27), ("lastTargetWithDscpRemoved", 28), ("couldntMonitor", 29), ("couldntControl", 30), ("applControlOnBrFailed", 31), ("allProtoCouldNtControl", 32), ("excludePfxFailed", 33), ("ipflowRestFailed", 34), ("couldntExclude", 35), ("dontDowngradeAllEntrances", 36), ("maxDownGrade", 37), ("cantSelectEntrances", 38), ("unhandledOopReasonInChooseExit", 39), ("oopModeSelectExitGood", 40), ("couldntFindBestExitInAllLinkGrps", 41), ("couldntFindBestExit", 42), ("failedToControlRoute", 43), ("endOfProbing", 44), ("retryForcedNextHop", 45), ("noStatusInPfxTimeout", 46), ("couldntChooseExitInPfxTimeout", 47), ("inconsistentView", 48), ("unableToSendControlMsg", 49), ("nbarIdStateUpdated", 50), ("controledExitIsNotCurrent", 51), ("exitMisMatch", 52), ("newExitWhileInpolicy", 53), ("unknownExit", 54), ("controlledExitIsNotCurrForUpd", 55), ("couldntControlPasPfxInSpecMode", 56), ("remoteStatsNotFound", 57), ("nbarInternalIfAddedRemoved", 58), ("noPassiveData", 59), ("probeNumPktsChanged", 60), ("last", 61))

class PfRMasterControllerIndex(TextualConvention, Unsigned32):
    description = 'This textual convention denotes an arbitrary integer-value that uniquely identifies a MC instance.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(1, 4294967295)

class PfrBorderRouterIndex(TextualConvention, Unsigned32):
    description = 'This textual convention denotes an arbitrary integer-value that uniquely identifies a BR instance.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(1, 4294967295)

class PfrExitIndex(TextualConvention, Unsigned32):
    description = 'This textual convention denotes an arbitrary integer-value that uniquely identifies an Exit instance.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(1, 4294967295)

class PfrMapIndex(TextualConvention, Unsigned32):
    description = 'This textual convention denotes an arbitrary integer-value that uniquely identifies a PfR map instance.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(1, 4294967295)

class PfrMapPolicyIndex(TextualConvention, Unsigned32):
    description = 'This textual convention denotes an arbitrary integer-value that uniquely identifies a PfR policy instance of a PfR map.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(1, 4294967295)

class PfrMapIndexOrZero(TextualConvention, Unsigned32):
    description = 'This textual convention is an extension of the PfrMapIndex convention. This extension permits the additional value of zero. The value zero is object-specific and must therefore be defined as part of the description of any object which uses this syntax.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(0, 4294967295)

class PfrLearnListIndex(TextualConvention, Unsigned32):
    description = 'This textual convention denotes an arbitrary integer-value that uniquely identifies a learn list instance.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(1, 4294967295)

class PfrLearnListIndexOrZero(TextualConvention, Unsigned32):
    description = 'This textual convention is an extension of the PfrLearnListIndex convention. This extension permits the additional value of zero. The value zero is object-specific and must therefore be defined as part of the description of any object which uses this syntax.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(0, 4294967295)

class PfrResolvePolicyType(TextualConvention, Integer32):
    description = "This textual convention denotes the type of resolver policies supported by PfR. 'cost' The resolver policy is based on routing cost. 'delay' The resolver policy is based on routing delay. 'jitter' The resolver policy is based on jitter. 'loss' The resolver policy is based on packet loss. 'mos' The resolver policy is based on MOS."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))
    namedValues = NamedValues(("none", 0), ("cost", 1), ("delay", 2), ("jitter", 3), ("loss", 4), ("mos", 5), ("range", 6), ("utilization", 7))

ciscoPfrMIBNotifs = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 772, 0))
ciscoPfrMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 772, 1))
ciscoPfrMIBConform = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 772, 2))
cpfrMCTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 1), )
if mibBuilder.loadTexts: cpfrMCTable.setStatus('current')
if mibBuilder.loadTexts: cpfrMCTable.setDescription('This table lists the MC instances created by the system.')
cpfrMCEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 1, 1), ).setIndexNames((0, "CISCO-PFR-MIB", "cpfrMCIndex"))
if mibBuilder.loadTexts: cpfrMCEntry.setStatus('current')
if mibBuilder.loadTexts: cpfrMCEntry.setDescription("An entry describing the configuration and status of one PfR MC. A simple device may only support a single MC, where a more sophisticate device may support more than one MC. A peer SNMP entity may create a MC by setting an instance of cpfrMCRowStatus to 'createAndWait' or 'createAndGo'. Observe that an implementation that does not support these option must specify these limitations in an agent capability statement. Other management entities (e.g., the local console) may create a MC. In these cases, the system must automatically create a row in the cpfrMCTable. A peer SNMP entity may destroy a MC by setting the corresponding instance of cpfrMCRowStatus to 'destroy'. Observe that an implementation that does not support this option must specify this limitation in an agent capability statement. Other management entities may destroy a MC. In these cases, the system must automatically destroy the corresponding row in the cpfrMCTable.")
cpfrMCIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 1, 1, 1), PfRMasterControllerIndex())
if mibBuilder.loadTexts: cpfrMCIndex.setStatus('current')
if mibBuilder.loadTexts: cpfrMCIndex.setDescription('This object indicates an arbitrary integer-value that uniquely identifies a PfR MC.')
cpfrMCStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 1, 1, 2), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrMCStorageType.setStatus('current')
if mibBuilder.loadTexts: cpfrMCStorageType.setDescription('This object specifies the memory realization of the row. The following columnar objects are allowed to be writable when the storageType of this entry is permanent(4): cpfrMCMapIndex, cpfrMCKeepAliveTimer, cpfrMCMaxPrefixTotal, cpfrMCMaxPrefixLearn, cpfrMCMaxRangeReceivePercent, cpfrMCMaxRangeUtilPercentMax, cpfrMCPortNumber, cpfrMCTracerouteProbeDelay, cpfrMCRsvpPostDialDelay, cpfrMCRsvpSignalingRetries, cpfrMCNetflowExporter, cpfrMCAdminStatus.')
cpfrMCRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 1, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrMCRowStatus.setStatus('current')
if mibBuilder.loadTexts: cpfrMCRowStatus.setDescription('This object specifies the status of a row in the MC table. The following columnar objects must be valid in order to transition the row to the active state: None. The following columnar objects can be modified when the row is in the active state: None')
cpfrMCMapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 1, 1, 4), PfrMapIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrMCMapIndex.setStatus('current')
if mibBuilder.loadTexts: cpfrMCMapIndex.setDescription('This object indicates a set of PfR policy map entries in cpfrMapTable associated with the MC. A value of zero indicates that there is no policy map associated with the MC and that the values in the default policy should be used for all TCs. The peer SNMP entity can retrieve this value and retrieve the cpfrMapEntry rows indexed by this value to understand the PfR policies. Alternatively the peer SNMP entity can assign the value of pfrMapIndex to this object to associate a set of policies to MC.')
cpfrMCKeepAliveTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 1, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(5)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrMCKeepAliveTimer.setStatus('current')
if mibBuilder.loadTexts: cpfrMCKeepAliveTimer.setDescription('This object specifies the value of the PfR keepalive timer. The MC sends keepalive packets to BRs to maintain connectivity between the MC and the BR. If the MC does not receive keepalive packets from a BR before the keepalive timer expires and this situation happens three times in a row, then the MC will not maintain the connection.')
cpfrMCMaxPrefixTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 1, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(5000)).setUnits('prefixes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrMCMaxPrefixTotal.setStatus('current')
if mibBuilder.loadTexts: cpfrMCMaxPrefixTotal.setDescription('This object specifies the maximum number of prefixes that a PfR MC will monitor. Limiting the number of prefixes a MC will monitor and learn reduces memory and system resource consumption.')
cpfrMCMaxPrefixLearn = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 1, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(2500)).setUnits('prefixes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrMCMaxPrefixLearn.setStatus('current')
if mibBuilder.loadTexts: cpfrMCMaxPrefixLearn.setDescription('This object specifies the maximum number of prefixes that a PfR MC will learn.')
cpfrMCEntranceLinksMaxUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 1, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 100)).clone(20)).setUnits('percent').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrMCEntranceLinksMaxUtil.setStatus('current')
if mibBuilder.loadTexts: cpfrMCEntranceLinksMaxUtil.setDescription('This object specifies the maximum utilization threshold of incoming traffic that can be transmitted over a PfR-managed entrance link interface.')
cpfrMCExitLinksMaxUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 1, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 100)).clone(20)).setUnits('percent').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrMCExitLinksMaxUtil.setStatus('current')
if mibBuilder.loadTexts: cpfrMCExitLinksMaxUtil.setDescription('This object specifies the maximum utilization of outbound traffic that can be transmitted over a PfR-managed exit interface.')
cpfrMCPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 1, 1, 10), InetPortNumber().clone(3949)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrMCPortNumber.setStatus('current')
if mibBuilder.loadTexts: cpfrMCPortNumber.setDescription('This object specifies a dynamic port number for communication between a PfR MC and a PfR BR.')
cpfrMCTracerouteProbeDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 1, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(10000)).setUnits('milliseconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrMCTracerouteProbeDelay.setStatus('current')
if mibBuilder.loadTexts: cpfrMCTracerouteProbeDelay.setDescription('This object specifies the time interval between traceroute probe cycles.')
cpfrMCRsvpPostDialDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 1, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setUnits('milliseconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrMCRsvpPostDialDelay.setStatus('current')
if mibBuilder.loadTexts: cpfrMCRsvpPostDialDelay.setDescription('This object specifies the delay before PfR returns the default routing path to RSVP.')
cpfrMCRsvpSignalingRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 1, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(1)).setUnits('retries').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrMCRsvpSignalingRetries.setStatus('current')
if mibBuilder.loadTexts: cpfrMCRsvpSignalingRetries.setDescription('This object specifies the number of retries that RSVP will query PfR for the alternate path.')
cpfrMCNetflowExporter = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 1, 1, 14), SnmpAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrMCNetflowExporter.setStatus('current')
if mibBuilder.loadTexts: cpfrMCNetflowExporter.setDescription('This object specifies the name of PfR Netflow exporter.')
cpfrMCAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrMCAdminStatus.setStatus('current')
if mibBuilder.loadTexts: cpfrMCAdminStatus.setDescription("This object can be used to enable or disable PfR operation in the system. 'enable' Enable MC on the router. 'disable' Disable MC on the router.")
cpfrMCOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrMCOperStatus.setStatus('current')
if mibBuilder.loadTexts: cpfrMCOperStatus.setDescription("This object indicates the operational status of PfR MC. 'active' MC is active. 'inactive' MC is not active.")
cpfrMCConnStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("success", 1), ("closed", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrMCConnStatus.setStatus('current')
if mibBuilder.loadTexts: cpfrMCConnStatus.setDescription("This object indicates the state of the connection between MC and BRs. 'success' MC is successfully connected to at least one BR. 'closed' MC is not connected to any BR.")
cpfrMCNumofBorderRouters = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 1, 1, 18), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setUnits('border routers').setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrMCNumofBorderRouters.setStatus('current')
if mibBuilder.loadTexts: cpfrMCNumofBorderRouters.setDescription('This object indicates the number of BRs that peer with the MC.')
cpfrMCNumofExits = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 1, 1, 19), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setUnits('exits').setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrMCNumofExits.setStatus('current')
if mibBuilder.loadTexts: cpfrMCNumofExits.setDescription('This object indicates the total number of PfR external interfaces configured on a MC.')
cpfrMCLearnState = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("disabled", 1), ("started", 2), ("writing", 3), ("sleep", 4), ("retry", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrMCLearnState.setStatus('current')
if mibBuilder.loadTexts: cpfrMCLearnState.setDescription("This object indicates the status of PfR learning operation. 'disable' PfR learning mode is not enabled. 'started' PfR is learning TCs. 'writing' PfR is storing the learned data of TCs. 'sleep' PfR is waiting for entering into another learning period. 'retry' PfR is retrying to learn the TCs.")
cpfrMCLearnStateTimeRemain = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 1, 1, 21), Unsigned32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrMCLearnStateTimeRemain.setStatus('current')
if mibBuilder.loadTexts: cpfrMCLearnStateTimeRemain.setDescription('This object indicates time remaining in the current prefix learning period measured in seconds.')
cpfrMCPrefixCount = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 1, 1, 22), Counter32()).setUnits('prefixes').setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrMCPrefixCount.setStatus('current')
if mibBuilder.loadTexts: cpfrMCPrefixCount.setDescription('This object indicates the total number of prefixes PfR is monitoring.')
cpfrMCPrefixLearned = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 1, 1, 23), Counter32()).setUnits('prefixes').setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrMCPrefixLearned.setStatus('current')
if mibBuilder.loadTexts: cpfrMCPrefixLearned.setDescription('This object indicates the number of prefixes PfR has learned.')
cpfrMCPrefixConfigured = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 1, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrMCPrefixConfigured.setStatus('current')
if mibBuilder.loadTexts: cpfrMCPrefixConfigured.setDescription('This object indicates the number of configured prefixes PfR is monitoring.')
cpfrMCPbrMet = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 1, 1, 25), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrMCPbrMet.setStatus('current')
if mibBuilder.loadTexts: cpfrMCPbrMet.setDescription('This object indicates whether the PBR requirements have been met. If PBR requirements are not met, the BRs cannot communicate with each other over the internal interfaces and cannot redirect traffic to each other using PBR route maps.')
cpfrMCLoggingAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 1, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrMCLoggingAdminStatus.setStatus('current')
if mibBuilder.loadTexts: cpfrMCLoggingAdminStatus.setDescription("This object specifies whether logging is enabled or not on PfR MC. 'enable' logging is enabled. 'disable' logging is disabled.")
cpfrMCControlMode = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 1, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("observe", 1), ("control", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrMCControlMode.setStatus('current')
if mibBuilder.loadTexts: cpfrMCControlMode.setDescription("This object specifies PfR MC control-mode. 'observe' PfR doesn't control traffic classes, but observes them. 'control' PfR controls traffic classes.")
cpfrMCClear = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 1, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("clearAll", 2), ("clearAllPrefixes", 3), ("clearAllBorders", 4)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrMCClear.setStatus('current')
if mibBuilder.loadTexts: cpfrMCClear.setDescription("This object specifies the clear operation that an MC should perform. A read on this object will return the last successful clear operation performed by the master controller. 'none' No clear operation was executed by MC since the time it became operational. This is read-only. 'clearAll' Specifies the MC to clear all prefixes in PfR master database, connections to all border routers, and restart the PfR master process. 'clearAllPrefixes' Specifies the MC to clear all prefixes in PfR master database. 'clearAllBorders' Specifies the MC to clear connections to all border routers.")
cpfrMCLastClearTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 1, 1, 29), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrMCLastClearTime.setStatus('current')
if mibBuilder.loadTexts: cpfrMCLastClearTime.setDescription('This object indicates the value of sysUpTime the last time the MC successfully performed a clear operation.')
cpfrMCNotifisControl = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 1, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrMCNotifisControl.setStatus('current')
if mibBuilder.loadTexts: cpfrMCNotifisControl.setDescription("This object specifies whether PfR notifications is enabled or not from PfR MC. 'enable' notification is enabled. 'disable' notification is disabled.")
cpfrMCChangeConfigType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 1, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("cpfrMCLoggingAdminStatus", 1), ("cpfrMCAdminStatus", 2), ("cpfrMCControlMode", 3), ("cpfrMCClear", 4)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: cpfrMCChangeConfigType.setStatus('current')
if mibBuilder.loadTexts: cpfrMCChangeConfigType.setDescription("This object indicates which of the following configuration is changed. 'cpfrMCLoggingAdminStatus' cpfrMCLoggingAdminStatus is changed. 'cpfrMCAdminStatus' cpfrMCAdminStatus is changed. 'cpfrMCControlMode' cpfrMCControlMode is changed. 'cpfrMCClear' cpfrMCClear is changed.")
cpfrMCChangeConfigValue = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 1, 1, 32), Integer32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: cpfrMCChangeConfigValue.setStatus('current')
if mibBuilder.loadTexts: cpfrMCChangeConfigValue.setDescription('This object indicates the value to which the type of configuration specified in cpfrMCChangeConfigType, is changed.')
cpfrMapTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 2), )
if mibBuilder.loadTexts: cpfrMapTable.setStatus('current')
if mibBuilder.loadTexts: cpfrMapTable.setDescription('This table lists the PfR map instances created by the system. This table has a sparse expansion dependent relationship on cpfrMCTable, containing one or more rows for each cpfrMCEntry.')
cpfrMapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 2, 1), ).setIndexNames((0, "CISCO-PFR-MIB", "cpfrMapIndex"), (0, "CISCO-PFR-MIB", "cpfrMapPolicyIndex"))
if mibBuilder.loadTexts: cpfrMapEntry.setStatus('current')
if mibBuilder.loadTexts: cpfrMapEntry.setDescription("An entry describing the configuration of one PfR map. A device creates a row in a cpfrMapTable when it specifies a PfR map. Likewise, such a device destroys a row in the cpfrBRTable when removing a PfR map. A peer SNMP entity may create a PfR map by setting an instance of cpfrMapRowStatus to 'createAndWait' or 'createAndGo'. Observe that an implementation that does not support these option must specify these limitations in an agent capability statement. Other management entities (e.g., the local console) may create a PfR Map. In these cases, the system must automatically create a row in the cpfrMapTable. A peer SNMP entity may destroy a PfR map by setting the corresponding instance of cpfrMapRowStatus to 'destroy'. Observe that an implementation that does not support this option must specify this limitation in an agent capability statement. Other management entities may destroy a Map. In these cases, the system must automatically destroy the corresponding row in the cpfrMapTable. The system automatically destroys rows when the system or EMS/NMS destroys the corresponding entry in cpfrMCEntry.")
cpfrMapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 2, 1, 1), PfrMapIndex())
if mibBuilder.loadTexts: cpfrMapIndex.setStatus('current')
if mibBuilder.loadTexts: cpfrMapIndex.setDescription('This object indicates an arbitrary integer-value that uniquely identifies a set of PfR policy maps.')
cpfrMapPolicyIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 2, 1, 2), PfrMapPolicyIndex())
if mibBuilder.loadTexts: cpfrMapPolicyIndex.setStatus('current')
if mibBuilder.loadTexts: cpfrMapPolicyIndex.setDescription('This object indicates an arbitrary integer-value that, in combination with cpfrMapIndex, uniquely identifies a PfR policy map.')
cpfrMapStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 2, 1, 3), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrMapStorageType.setStatus('current')
if mibBuilder.loadTexts: cpfrMapStorageType.setDescription('This object specifies the memory realization of the row. The following columnar objects are allowed to be writable when the storageType of this entry is permanent(4): cpfrMapIndex, cpfrMapPolicyIndex, cpfrMapStorageType, cpfrMapRowStatus, cpfrMapName, cpfrMapBackoffMinTimer, cpfrMapBackoffMaxTimer, cpfrMapBackoffStepTimer, cpfrMapDelayType, cpfrMapDelayRelativePercent, cpfrMapDelayThresholdMax, cpfrMapHolddownTimer, cpfrMapPrefixForwardInterface, cpfrMapJitterThresholdMax, cpfrMapLinkGroupName, cpfrMapFallbackLinkGroupName, cpfrMapLossType, cpfrMapLossRelativeAvg, cpfrMapLossThresholdMax, cpfrMapModeMonitor, cpfrMapModeRouteOpts,cpfrMapRouteMetricBgpLocalPref, cpfrMapRouteMetricEigrpTagCommunity, cpfrMapRouteMetricStaticTag, cpfrMapModeSelectExitType, cpfrMapMossThresholdMin, cpfrMapMossPercentage, cpfrMapNextHopAddressType, cpfrMapNextHopAddress, cpfrMapPeriodicTimer, cpfrMapActiveProbeFrequency, cpfrMapActiveProbePackets, cpfrMapTracerouteReporting, cpfrMapUnreachableType, cpfrMapUnreachableRelativeAvg, cpfrMapUnreachableThresholdMax, cpfrMapRoundRobinResolver.')
cpfrMapRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 2, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrMapRowStatus.setStatus('current')
if mibBuilder.loadTexts: cpfrMapRowStatus.setDescription('This object specifies the status of a row in the PfR map table. The following columnar objects must be valid in order to transition the row to the active state: cpfrMapName. The following columnar objects can be modified when the row is in the active state: None')
cpfrMapName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 2, 1, 5), SnmpAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrMapName.setStatus('current')
if mibBuilder.loadTexts: cpfrMapName.setDescription('This object specifies the name of a PfR map.')
cpfrMapBackoffMinTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 2, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(300)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrMapBackoffMinTimer.setStatus('current')
if mibBuilder.loadTexts: cpfrMapBackoffMinTimer.setDescription('This object specifies the minimum value for the backoff timer. The backoff timer is used to configure a PfR map to set the transition period for which the MC holds an out-of-policy prefix.')
cpfrMapBackoffMaxTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 2, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(3000)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrMapBackoffMaxTimer.setStatus('current')
if mibBuilder.loadTexts: cpfrMapBackoffMaxTimer.setDescription('This object specifies the maximum value for the backoff timer. If the maximum timer expires and all PfR-managed exits are out-of-policy, PfR will install the best available exit and reset the minimum timer.')
cpfrMapBackoffStepTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 2, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(300)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrMapBackoffStepTimer.setStatus('current')
if mibBuilder.loadTexts: cpfrMapBackoffStepTimer.setDescription('This object specifies the time period value for the step timer. PfR users the step timer to add time to the out-of-policy waiting period each time the backoff timer expires and PfR is unable to find an in-policy exit. The backoff timer is initialized to the minimum timer and incremented by the step timer until it reaches the maximum timer.')
cpfrMapDelayType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 2, 1, 9), PfrMetricPolicyType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrMapDelayType.setStatus('current')
if mibBuilder.loadTexts: cpfrMapDelayType.setDescription('This object specifies the delay type of a PfR map. It is used to set the delay threshold as a relative percentage or as an absolute value for match criteria.')
cpfrMapDelayRelativePercent = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 2, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000)).clone(500)).setUnits('tenths of percent').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrMapDelayRelativePercent.setStatus('current')
if mibBuilder.loadTexts: cpfrMapDelayRelativePercent.setDescription("This object specifies a relative delay threshold based on a comparison of short-term and long-term delay percentages. The value of this object is valid if the corresponding value of cpfrMapDelayType is set to 'relative'.")
cpfrMapDelayThresholdMax = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 2, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(5000)).setUnits('milliseconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrMapDelayThresholdMax.setStatus('current')
if mibBuilder.loadTexts: cpfrMapDelayThresholdMax.setDescription("This object specifies the absolute maximum delay time. The value of this object is valid if the corresponding value of cpfrMapDelayType is set to 'threshold'.")
cpfrMapHolddownTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 2, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(300)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrMapHolddownTimer.setStatus('current')
if mibBuilder.loadTexts: cpfrMapHolddownTimer.setDescription('This object specifies the route dampening time period. It is used to configure the prefix route dampening timer for the minimum period of time in which a new exit must be used before an alternate exit can be selected.')
cpfrMapPrefixForwardInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 2, 1, 13), InterfaceIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrMapPrefixForwardInterface.setStatus('current')
if mibBuilder.loadTexts: cpfrMapPrefixForwardInterface.setDescription('This object specifies whether or not a null forwarding interface has been configured. This interface is always up and can never forward or receive traffic; encapsulation always fails. Null interfaces are used as a low-overhead method of discarding unnecessary network traffic.')
cpfrMapJitterThresholdMax = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 2, 1, 14), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(30)).setUnits('milliseconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrMapJitterThresholdMax.setStatus('current')
if mibBuilder.loadTexts: cpfrMapJitterThresholdMax.setDescription('This object specifies the maximum tolerable jitter value permitted on an exit link.')
cpfrMapLinkGroupName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 2, 1, 15), SnmpAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrMapLinkGroupName.setStatus('current')
if mibBuilder.loadTexts: cpfrMapLinkGroupName.setDescription('This object specifies the primary link group to be used by PfR to select an exit. It allows a group of exit links to be defined as a preferred set of links for PfR to use when optimizing TCs specified in a PfR policy.')
cpfrMapFallbackLinkGroupName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 2, 1, 16), SnmpAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrMapFallbackLinkGroupName.setStatus('current')
if mibBuilder.loadTexts: cpfrMapFallbackLinkGroupName.setDescription('This object specifies a fallback link group to be used if all the exits in the primary link group are out-of-policy (OOP).')
cpfrMapLossType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 2, 1, 17), PfrMetricPolicyType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrMapLossType.setStatus('current')
if mibBuilder.loadTexts: cpfrMapLossType.setDescription('This object specifies the loss type configuration used by PfR. It specifies the relative percentage or maximum number of packets that PfR will permit to be lost during transmission on an exit link.')
cpfrMapLossRelativeAvg = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 2, 1, 18), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(100)).setUnits('tenths of percent').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrMapLossRelativeAvg.setStatus('current')
if mibBuilder.loadTexts: cpfrMapLossRelativeAvg.setDescription("This object specifies a relative percentage of packet loss based on a comparison of short-term and long-term packet loss percentages. The value of this object is valid if the corresponding value of cpfrMapLossType is set to 'relative'.")
cpfrMapLossThresholdMax = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 2, 1, 19), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setUnits('packets-per-million').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrMapLossThresholdMax.setStatus('current')
if mibBuilder.loadTexts: cpfrMapLossThresholdMax.setDescription("This object specifies absolute packet loss based on packets per million (PPM). The value of this object is valid if the corresponding value of cpfrMapLossType is set to 'threshold'.")
cpfrMapModeMonitor = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 2, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("active", 1), ("activeThroughput", 2), ("both", 3), ("fast", 4), ("passive", 5))).clone('both')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrMapModeMonitor.setStatus('current')
if mibBuilder.loadTexts: cpfrMapModeMonitor.setDescription("This object specifies how a PfR MC using this PfR map should monitor the TCs. 'active' Enable active monitoring. 'activethrougput' Enable active monitoring with throughput data from passive monitoring. 'both' Enable both active and passive monitoring. 'fast' Enable continuous active and passive monitoring. 'passive' Enable passive monitoring.")
cpfrMapModeRouteOpts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 2, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("control", 1), ("observe", 2), ("metric", 3))).clone('observe')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrMapModeRouteOpts.setStatus('current')
if mibBuilder.loadTexts: cpfrMapModeRouteOpts.setDescription("This object specifies how a PfR MC using this PfR map should control the TCs. 'control' Monitor and report performance data and use the data to make route changes that will optimize performance. 'observe' Monitor and report performance data without making any route changes. 'metric' Enable route control based on BGP Local preference, EIGRP community tag, or a specific static route tag.")
cpfrMapRouteMetricBgpLocalPref = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 2, 1, 22), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrMapRouteMetricBgpLocalPref.setStatus('current')
if mibBuilder.loadTexts: cpfrMapRouteMetricBgpLocalPref.setDescription("This object specifies the BGP local preference for PfR controlled routes. The value of this object is valid if the corresponding value of cpfrMapModeRouteOpts is set to 'metric'. The value 0 is not a valid BGP local preference. Configuring 0 disables route control based on BGP local preference.")
cpfrMapRouteMetricEigrpTagCommunity = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 2, 1, 23), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrMapRouteMetricEigrpTagCommunity.setStatus('current')
if mibBuilder.loadTexts: cpfrMapRouteMetricEigrpTagCommunity.setDescription("This object specifies the community value to an EIGRP route under PfR control. The value of this object is valid if the corresponding value of cpfrMapModeRouteOpts is set to 'metric'. The value 0 is not a valid EIGRP Community tag. Configuring 0 disables route control based on EIGRP.")
cpfrMapRouteMetricStaticTag = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 2, 1, 24), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrMapRouteMetricStaticTag.setStatus('current')
if mibBuilder.loadTexts: cpfrMapRouteMetricStaticTag.setDescription("This object specifies the tag to a static route under PfR control. The value of this object is valid if the corresponding value of cpfrMapModeRouteOpts is set to 'metric'. The value 0 is not a valid Static tag. Configuring 0 disables route control based on static tag.")
cpfrMapModeSelectExitType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 2, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("best", 1), ("good", 2))).clone('good')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrMapModeSelectExitType.setStatus('current')
if mibBuilder.loadTexts: cpfrMapModeSelectExitType.setDescription("This object specifies how a PfR MC using this PfR map should select an exit based on performance or policy. 'best' Select the best exit based on performance or policy. 'good' Select the first exit that is in policy.")
cpfrMapMOSThresholdMin = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 2, 1, 26), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(360)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrMapMOSThresholdMin.setStatus('current')
if mibBuilder.loadTexts: cpfrMapMOSThresholdMin.setDescription('This object specifies a threshold MOS value that represents a minimum voice quality for exit link utilization.')
cpfrMapMOSPercentage = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 2, 1, 27), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setUnits('percent').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrMapMOSPercentage.setStatus('current')
if mibBuilder.loadTexts: cpfrMapMOSPercentage.setDescription('This object specifies a percentage value that is compared with the percentage of MOS samples that are below the MOS threshold. The number of MOS samples over a period of time that are below the threshold MOS value are calculated. If the percentage of MOS samples below the threshold is greater than the configured percentage, PfR determines that the exit link is out-of-policy and searches for an alternate exit link.')
cpfrMapNextHopAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 2, 1, 28), InetAddressType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrMapNextHopAddressType.setStatus('current')
if mibBuilder.loadTexts: cpfrMapNextHopAddressType.setDescription('This object specifies the address type of the address specified as the next hop when PfR is used for sinkhole filtering.')
cpfrMapNextHopAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 2, 1, 29), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrMapNextHopAddress.setStatus('current')
if mibBuilder.loadTexts: cpfrMapNextHopAddress.setDescription('This object specifies the next hop address to which PfR forwards packets for matching prefixes. The prefixes that are forwarded to the next hop address are specified by an access list configured in a match clause on the PfR map')
cpfrMapPeriodicTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 2, 1, 30), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrMapPeriodicTimer.setStatus('current')
if mibBuilder.loadTexts: cpfrMapPeriodicTimer.setDescription('This object specifies the periodic timer that PfR uses to select the best exit for the matched TCs. When this timer expires, PfR automatically selects the best exit, irrespective of whether the current exit is in-policy or out-of-policy. The periodic timer is reset when the new exit is selected.')
cpfrMapActiveProbeFrequency = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 2, 1, 31), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(60)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrMapActiveProbeFrequency.setStatus('current')
if mibBuilder.loadTexts: cpfrMapActiveProbeFrequency.setDescription('This object specifies the frequency of active probes configured under a PfR map.')
cpfrMapActiveProbePackets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 2, 1, 32), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(100)).setUnits('packets').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrMapActiveProbePackets.setStatus('current')
if mibBuilder.loadTexts: cpfrMapActiveProbePackets.setDescription('This object specifies the number of probe packets generated for each active probe cycle.')
cpfrMapTracerouteReporting = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 2, 1, 33), Bits().clone(namedValues=NamedValues(("none", 0), ("delay", 1), ("loss", 2), ("unreachable", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrMapTracerouteReporting.setStatus('current')
if mibBuilder.loadTexts: cpfrMapTracerouteReporting.setDescription("This object enables continuous and policy-based traceroute probing. Traceroute probing allows prefix performance to be measured on a hop-by-hop basis. Delay, loss, and reachability measurements are gathered for each hop from the probe source to the target prefix. 'none' Traceroute probing is disabled. 'delay' Delay policy based traceroute probing is enabled. 'loss' Loss policy based traceroute probing is enabled. 'reachability' Reachability policy based traceroute probing is enabled.")
cpfrMapUnreachableType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 2, 1, 34), PfrMetricPolicyType().clone('relative')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrMapUnreachableType.setStatus('current')
if mibBuilder.loadTexts: cpfrMapUnreachableType.setDescription('This object specifies the unreachable type configuration used by PfR. It is used to set the relative percentage or the absolute maximum number of unreachable hosts, based on flows per million (fpm), that PfR will permit from a PfR-managed exit link.')
cpfrMapUnreachableRelativeAvg = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 2, 1, 35), Unsigned32().clone(50)).setUnits('tenths of percent').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrMapUnreachableRelativeAvg.setStatus('current')
if mibBuilder.loadTexts: cpfrMapUnreachableRelativeAvg.setDescription("This object specifies a relative percentage of unreachable hosts. The relative unreachable host percentage is based on a comparison of short-term and long-term measurements. The short-term measurement reflects the percentage of hosts that are unreachable within a 5-minute period. The long-term measurement reflects the percentage of unreachable hosts within a 60-minute period. The following formula is used to calculate this value: Relative percentage of unreachable hosts equals to the difference between short-term percentage and long-term percentage divided by long-term percentage. The master controller measures the difference between these two values as a percentage. If the percentage exceeds the user-defined or default value, the exit link is determined to be out-of-policy. The value of this object is valid if the corresponding value of cpfrMapUnreachableType is set to 'relative'.")
cpfrMapUnreachableThresholdMax = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 2, 1, 36), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setUnits('flows per million').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrMapUnreachableThresholdMax.setStatus('current')
if mibBuilder.loadTexts: cpfrMapUnreachableThresholdMax.setDescription("This object specifies the absolute maximum number of unreachable hosts based on flows per million. The value of this object is valid if the corresponding value of cpfrMapUnreachableType is set to 'threshold'.")
cpfrMapRoundRobinResolver = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 2, 1, 37), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrMapRoundRobinResolver.setStatus('current')
if mibBuilder.loadTexts: cpfrMapRoundRobinResolver.setDescription("This object specifies whether the round robin resolver is enabled or disabled. 'enable' Round robin resolver is enabled. 'disable' Round robin resolver is disabled.")
cpfrMapEventNotifCtrlType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 2, 1, 38), PfrMetricPolicyType().clone('relative')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrMapEventNotifCtrlType.setStatus('current')
if mibBuilder.loadTexts: cpfrMapEventNotifCtrlType.setDescription('This object specifies the event notification control type configuration used by PfR. It is used to set the relative percentage or the absolute threshold value for cpfrMapEventNotifCtrlThreshold object.')
cpfrMapEventNotifCtrlThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 2, 1, 39), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrMapEventNotifCtrlThreshold.setStatus('current')
if mibBuilder.loadTexts: cpfrMapEventNotifCtrlThreshold.setDescription('This object specifies the absolute event counter threshold or relative percentage threshold used by PfR to throttle the generation of cpfrTCInpolicyThresholdBelowNotify and cpfrTCPrimaryThresholdBelowNotify. If the value is relative percentage threshold, then the notification is generated if cpfrMapEventTCCount over total TC count is more than the value of this percentage. - If the value is absolute event counter threshold, then the notification is generated if cpfrEventTrapTCCount is more than this value.')
cpfrMapEventTCCount = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 2, 1, 40), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrMapEventTCCount.setStatus('current')
if mibBuilder.loadTexts: cpfrMapEventTCCount.setDescription("This object specifies the current absolute number of traffic classes, whose state are 'default' or 'oopolicy' specified by cpfrTCStatus.")
cpfrMatchTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 3), )
if mibBuilder.loadTexts: cpfrMatchTable.setStatus('current')
if mibBuilder.loadTexts: cpfrMatchTable.setDescription('This table lists the match clause instances created by the system. This table has an expansion dependent relationship on cpfrMapTable, containing zero or more rows for each cpfrMapEntry.')
cpfrMatchEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 3, 1), ).setIndexNames((0, "CISCO-PFR-MIB", "cpfrMapIndex"), (0, "CISCO-PFR-MIB", "cpfrMapPolicyIndex"))
if mibBuilder.loadTexts: cpfrMatchEntry.setStatus('current')
if mibBuilder.loadTexts: cpfrMatchEntry.setDescription("An entry describing a match clause PfR uses. A peer SNMP entity may create a match criterion by setting an instance of cpfrMatchStatus to 'createAndWait' or 'createAndGo'. Observe that an implementation that does not support these option must specify these limitations in an agent capability statement. Other management entities (e.g., the local console) may create a match criterion. In these cases, the system must automatically create a row in the cpfrMatchTable. A peer SNMP entity may destroy a match criterion by setting the corresponding instance of cpfrMatchStatus to 'destroy'. Observe that an implementation that does not support this option must specify this limitation in an agent capability statement. Other management entities may destroy a match criterion. In these cases, the system must automatically destroy the corresponding row in the cpfrMatchTable. The system automatically destroys a row when the system or EMS/NMS destroys the corresponding entries in the cpfrMapTable.")
cpfrMatchValid = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 3, 1, 1), Bits().clone(namedValues=NamedValues(("accessList", 0), ("prefixList", 1), ("learn", 2), ("trafficClassACL", 3), ("nbarApplicationList", 4), ("trafficClassPfx", 5)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrMatchValid.setStatus('current')
if mibBuilder.loadTexts: cpfrMatchValid.setDescription("This object specifies which of those objects are valid. When a user is configuring a match clause, the corresponding bit should also be set to true in this object. The following list shows different types of match clauses, the bit to be set and the corresponding objects. 'access-list' If this bit is set to '1' then corresponding instance of cpfrMatchAccessList is valid. 'prefix-list' If this bit is set to '1' then corresponding instance of cpfrMatchPrefixList is valid. 'inside' If this bit is set to '1' then corresponding instance of cpfrMatchInside is valid. 'learn' If this bit is set to '1' then corresponding instances of cpfrMatchLearnMode and cpfrMatchLearnListName are valid. 'nbarApplicationList' If this bit is set to '1' then corresponding instance of cpfrMatchTCNbarListName is valid.")
cpfrMatchAddrAccessList = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 3, 1, 2), SnmpAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrMatchAddrAccessList.setStatus('current')
if mibBuilder.loadTexts: cpfrMatchAddrAccessList.setDescription('This object specifies the access list used to manually configure a traffic class that matches destination prefixes in an access list used in a PfR map.')
cpfrMatchAddrPrefixList = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 3, 1, 3), SnmpAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrMatchAddrPrefixList.setStatus('current')
if mibBuilder.loadTexts: cpfrMatchAddrPrefixList.setDescription('This object specifies the prefix list used to manually configure a traffic class that matches destination prefixes in a prefix list.')
cpfrMatchAddrPrefixInside = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 3, 1, 4), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrMatchAddrPrefixInside.setStatus('current')
if mibBuilder.loadTexts: cpfrMatchAddrPrefixInside.setDescription('This object specifies whether or not the prefixes learned by PfR are within the internal network.')
cpfrMatchLearnMode = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("delay", 1), ("inside", 2), ("throughput", 3), ("list", 4))).clone('throughput')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrMatchLearnMode.setStatus('current')
if mibBuilder.loadTexts: cpfrMatchLearnMode.setDescription("This object specifies the mode by which PfR should learn prefixes. 'Delay' PfR learns prefixes based on the highest delay. 'Inside' PfR learns the prefixes inside the network. 'Throughput' PfR learns prefixes based on the highest throughput. 'list' PfR learns prefixes based on a learn list.")
cpfrMatchLearnListName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 3, 1, 6), SnmpAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrMatchLearnListName.setStatus('current')
if mibBuilder.loadTexts: cpfrMatchLearnListName.setDescription("This object specifies the learn list name used by PfR for learning prefixes. This object is valid when the corresponding cpfrMatchLearnMode object is set to 'list'.")
cpfrMatchTCNbarListName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 3, 1, 7), SnmpAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrMatchTCNbarListName.setStatus('current')
if mibBuilder.loadTexts: cpfrMatchTCNbarListName.setDescription('This object specifies that PfR is to profile traffic destined for prefixes defined in an IP prefix list that match one or more NBAR applications. The applications are predefined with a protocol identifier. This object identifies a set of protocols in cpfrNbarApplListTable.')
cpfrMatchTCNbarApplPfxList = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 3, 1, 8), SnmpAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrMatchTCNbarApplPfxList.setStatus('current')
if mibBuilder.loadTexts: cpfrMatchTCNbarApplPfxList.setDescription('This object specifies the prefix list to be used by PfR to filter traffic that is learned based on NBAR applications.')
cpfrMatchTCPfxInside = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 3, 1, 9), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrMatchTCPfxInside.setStatus('current')
if mibBuilder.loadTexts: cpfrMatchTCPfxInside.setDescription('This object specifies whether or not the prefixes filtered by the prefix list is inside the internal network.')
cpfrResolveTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 4), )
if mibBuilder.loadTexts: cpfrResolveTable.setStatus('current')
if mibBuilder.loadTexts: cpfrResolveTable.setDescription('This table lists the resolver instances created by the system. This table has an expansion dependent relationship on cpfrMapTable, containing zero or more rows for each cpfrMapEntry.')
cpfrResolveEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 4, 1), ).setIndexNames((0, "CISCO-PFR-MIB", "cpfrResolveIndex"))
if mibBuilder.loadTexts: cpfrResolveEntry.setStatus('current')
if mibBuilder.loadTexts: cpfrResolveEntry.setDescription("An entry in the cpfrResolveTable describes a policy metric and its priority relative to other metrics if multiple metrics are configured for the default policy or under a PfR map. A peer SNMP entity may create a resolver by setting an instance of cpfrResolveRowStatus to 'createAndWait' or 'createAndGo'. Observe that an implementation that does not support these option must specify these limitations in an agent capability statement. Other management entities (e.g., the local console) may create a resolver. In these cases, the system must automatically create a row in the cpfrResolveTable. A peer SNMP entity may destroy a resolver by setting the corresponding instance of cpfrResolveRowStatus to 'destroy'. Observe that an mplementation that does not support this option must specify this limitation in an agent capability statement. Other management entities may destroy a resolver. In these cases, the system must automatically destroy the corresponding row in the cpfrResolveTable. The system automatically destroys rows when the system or EMS/NMS destroys the corresponding entry in cpfrMapTable.")
cpfrResolveIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 4, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: cpfrResolveIndex.setStatus('current')
if mibBuilder.loadTexts: cpfrResolveIndex.setDescription('This object indicates an arbitrary integer-value that uniquely identifies a PfR resolver.')
cpfrResolveStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 4, 1, 2), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrResolveStorageType.setStatus('current')
if mibBuilder.loadTexts: cpfrResolveStorageType.setDescription('This object specifies the memory realization of the row. The following columnar objects are allowed to be writable when the storageType of this entry is permanent(4): cpfrResolvePolicyType, cpfrResolveVariance, cpfrResolveMapIndex, cpfrResolveMapIndex.')
cpfrResolveRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 4, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrResolveRowStatus.setStatus('current')
if mibBuilder.loadTexts: cpfrResolveRowStatus.setDescription('This object specifies the status of a row in the resolver table. The following columnar objects must be valid in order to transition the row to the active state: cpfrMCResolvePriority, cpfrResolvePolicyType, cpfrResolveMapIndex, cpfrResolveMapPolicyIndex The following columnar objects can be modified when the row is in the active state: None')
cpfrResolvePriority = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 4, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrResolvePriority.setStatus('current')
if mibBuilder.loadTexts: cpfrResolvePriority.setDescription('This object indicates the priority of the resolver.')
cpfrResolvePolicyType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 4, 1, 5), PfrResolvePolicyType().clone('none')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrResolvePolicyType.setStatus('current')
if mibBuilder.loadTexts: cpfrResolvePolicyType.setDescription('This object indicates the type of this resolver policy.')
cpfrResolveVariance = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 4, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrResolveVariance.setStatus('current')
if mibBuilder.loadTexts: cpfrResolveVariance.setDescription('This object specifies the allowable variance for the policy, as a percentage.')
cpfrResolveMapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 4, 1, 7), PfrMapIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrResolveMapIndex.setStatus('current')
if mibBuilder.loadTexts: cpfrResolveMapIndex.setDescription('This object refers to the map Index of PfR map under which this resolver was configured.')
cpfrResolveMapPolicyIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 4, 1, 8), PfrMapPolicyIndex()).setUnits('0').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrResolveMapPolicyIndex.setStatus('current')
if mibBuilder.loadTexts: cpfrResolveMapPolicyIndex.setDescription('This object refers to PfR map policy index of PfR map under which this resolver was configured.')
cpfrLearnTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 5), )
if mibBuilder.loadTexts: cpfrLearnTable.setStatus('current')
if mibBuilder.loadTexts: cpfrLearnTable.setDescription('This table lists the PfR learn instances created by the system. This table has a one-to-one relationship with cpfrMCTable, containing zero or more rows for each cpfrMCEntry.')
cpfrLearnEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 5, 1), ).setIndexNames((0, "CISCO-PFR-MIB", "cpfrMCIndex"))
if mibBuilder.loadTexts: cpfrLearnEntry.setStatus('current')
if mibBuilder.loadTexts: cpfrLearnEntry.setDescription('An entry in the cpfrLearnTable describes the configuration and status of a PfR learning policy. A device creates a row in a cpfrLearnTable when PfR learn is enabled. Likewise, such a device destroys a row in the cpfrLearnTable when PfR learn is disabled.')
cpfrLearnAggregationType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 5, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("bgp", 1), ("nonBgp", 2), ("prefixLength", 3))).clone('prefixLength')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrLearnAggregationType.setStatus('current')
if mibBuilder.loadTexts: cpfrLearnAggregationType.setDescription("This object specifies how a MC aggregates learned prefixes based on traffic type. 'bgp' The bgp keyword configures aggregation based on entries in the BGP routing table. 'nonBgp' The non-bgp keyword configures aggregation based on static routes. 'prefixLength' The prefix-length keyword configures aggregation based on the specified prefix length. The range of values that can be configured for this argument is a prefix mask from 1 to 32. If this command is not specified, the default aggregation is performed based on a /24 prefix length")
cpfrLearnAggregationPrefixLen = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 5, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(24)).setUnits('bits').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrLearnAggregationPrefixLen.setStatus('current')
if mibBuilder.loadTexts: cpfrLearnAggregationPrefixLen.setDescription('This object configures aggregation based on the specified prefix length.')
cpfrLearnMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 5, 1, 3), Bits().clone(namedValues=NamedValues(("delay", 0), ("throughput", 1), ("insideBgp", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrLearnMethod.setStatus('current')
if mibBuilder.loadTexts: cpfrLearnMethod.setDescription("This object specifies the method by which PfR learns prefixes. 'delay' Learn prefixes with the highest round trip delay. 'throughput' Learn prefixes with the highest throughput. 'insideBgp' Learn prefixes inside the network.")
cpfrLearnExpireType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 5, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("session", 1), ("time", 2))).clone('time')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrLearnExpireType.setStatus('current')
if mibBuilder.loadTexts: cpfrLearnExpireType.setDescription("This object specifies the length of time that the learned prefixes are kept in the central policy database. 'session' Configures a session-based expiration timer. 'time' Configures a time-based expiration timer.")
cpfrLearnExpireSessionNum = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 5, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setUnits('monitoring periods').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrLearnExpireSessionNum.setStatus('current')
if mibBuilder.loadTexts: cpfrLearnExpireSessionNum.setDescription('This object configures a session-based expiration timer. A number from 1 to 65535 can be entered. Each increment represents one monitoring period. The object is valid when cpfrLearnExpireType is configured with session.')
cpfrLearnExpireTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 5, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(720)).setUnits('minutes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrLearnExpireTime.setStatus('current')
if mibBuilder.loadTexts: cpfrLearnExpireTime.setDescription('This object configures a time-based expiration timer.')
cpfrLearnMonitorPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 5, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(5)).setUnits('minutes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrLearnMonitorPeriod.setStatus('current')
if mibBuilder.loadTexts: cpfrLearnMonitorPeriod.setDescription('This object specifies the time period over which a PfR MC learns traffic flows.')
cpfrLearnPeriodInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 5, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(120)).setUnits('minutes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrLearnPeriodInterval.setStatus('current')
if mibBuilder.loadTexts: cpfrLearnPeriodInterval.setDescription('This object specifies the time interval between prefix monitoring periods.')
cpfrLearnPrefixesNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 5, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(1000)).setUnits('prefixes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrLearnPrefixesNumber.setStatus('current')
if mibBuilder.loadTexts: cpfrLearnPrefixesNumber.setDescription('This object specifies the maximum number of prefixes PfR can learn.')
cpfrLearnAggAccesslistName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 5, 1, 10), SnmpAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrLearnAggAccesslistName.setStatus('current')
if mibBuilder.loadTexts: cpfrLearnAggAccesslistName.setDescription('This object specifies a PfR access list to define criteria which PfR uses to aggregate TCs.')
cpfrLearnFilterAccessListName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 5, 1, 11), SnmpAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrLearnFilterAccessListName.setStatus('current')
if mibBuilder.loadTexts: cpfrLearnFilterAccessListName.setDescription('This object specifies an access list used to filter TCs learned by PfR.')
cpfrLearnListTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 6), )
if mibBuilder.loadTexts: cpfrLearnListTable.setStatus('current')
if mibBuilder.loadTexts: cpfrLearnListTable.setDescription('This table lists the learn lists created by the system. This table has an expansion dependent relationship on cpfrLearnTable, containing zero or more rows for each cpfrLearnEntry.')
cpfrLearnListEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 6, 1), ).setIndexNames((0, "CISCO-PFR-MIB", "cpfrMCIndex"), (0, "CISCO-PFR-MIB", "cpfrLearnListIndex"))
if mibBuilder.loadTexts: cpfrLearnListEntry.setStatus('current')
if mibBuilder.loadTexts: cpfrLearnListEntry.setDescription("An entry in the cpfrLearnListTable describes the configuration and status of a PfR learn list. A peer SNMP entity may create a learn list by setting an instance of cpfrLearnListRowStatus to 'createAndWait' or 'createAndGo'. Observe that an implementation that does not support these option must specify these limitations in an agent capability statement. Other management entities (e.g., the local console) may create a learn list. In these cases, the system must automatically create a row in the cpfrLearnListTable. A peer SNMP entity may destroy a learn list by setting the corresponding instance of cpfrLearnListRowStatus to 'destroy'. Observe that an mplementation that does not support this option must specify this limitation in an agent capability statement. Other management entities may destroy a learn list. In these cases, the system must automatically destroy the corresponding row in the cpfrLearnListTable. The system automatically destroys rows when the system or EMS/NMS destroys the corresponding entry in cpfrLearnTable.")
cpfrLearnListIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 6, 1, 1), PfrLearnListIndex())
if mibBuilder.loadTexts: cpfrLearnListIndex.setStatus('current')
if mibBuilder.loadTexts: cpfrLearnListIndex.setDescription('This object indicates an arbitrary integer-value that uniquely identifies a PfR learn list.')
cpfrLearnListStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 6, 1, 2), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrLearnListStorageType.setStatus('current')
if mibBuilder.loadTexts: cpfrLearnListStorageType.setDescription('This object specifies the memory realization of the row. The following columnar objects are allowed to be writable when the storageType of this entry is permanent(4): cpfrLearnListReferenceName, cpfrLearnListSequenceNum, cpfrLearnListMethod, cpfrLearnListDelayType, cpfrLearnListDelayRelativePercentage, cpfrLearnListDelayThresholdMax, cpfrLearnListAclName, cpfrLearnListFilterPfxName, cpfrLearnListPfxName, cpfrLearnListPfxInside, cpfrLearnListNbarAppl.')
cpfrLearnListRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 6, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrLearnListRowStatus.setStatus('current')
if mibBuilder.loadTexts: cpfrLearnListRowStatus.setDescription('This object specifies the status of a row in the learn list table. The following columnar objects must be valid in order to transition the row to the active state: cpfrLearnListReferenceName, cpfrLearnListSequenceNum. The following columnar objects can be modified when the row is in the active state: None')
cpfrLearnListReferenceName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 6, 1, 4), SnmpAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrLearnListReferenceName.setStatus('current')
if mibBuilder.loadTexts: cpfrLearnListReferenceName.setDescription('This object specifies the reference name of a learn list.')
cpfrLearnListSequenceNum = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 6, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrLearnListSequenceNum.setStatus('current')
if mibBuilder.loadTexts: cpfrLearnListSequenceNum.setDescription('This object specifies the sequence number representing a sequence that is used to determine the order in which PfR applies learn list criteria.')
cpfrLearnListMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 6, 1, 6), Bits().clone(namedValues=NamedValues(("delay", 0), ("throughput", 1), ("rsvp", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrLearnListMethod.setStatus('current')
if mibBuilder.loadTexts: cpfrLearnListMethod.setDescription("This object specifies how PfR learns prefixes. 'delay' Learn prefixes with the highest round trip delay. 'througput' Learn prefixes with the highest throughput. 'rsvp' Learn prefixes on the basis of RSVP.")
cpfrLearnListAclName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 6, 1, 7), SnmpAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrLearnListAclName.setStatus('current')
if mibBuilder.loadTexts: cpfrLearnListAclName.setDescription('This object specifies the name of the access list to be used by the PfR learn list.')
cpfrLearnListPfxName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 6, 1, 8), SnmpAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrLearnListPfxName.setStatus('current')
if mibBuilder.loadTexts: cpfrLearnListPfxName.setDescription('This object specifies the name of the prefix list to be used by the PfR learn list.')
cpfrLearnListPfxInside = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 6, 1, 9), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrLearnListPfxInside.setStatus('current')
if mibBuilder.loadTexts: cpfrLearnListPfxInside.setDescription('This object specifies whether PfR should learn prefixes that are inside the network.')
cpfrLearnListNbarAppl = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 6, 1, 10), SnmpAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrLearnListNbarAppl.setStatus('current')
if mibBuilder.loadTexts: cpfrLearnListNbarAppl.setDescription('This object specifies a set of protocols in the cpfrNbarApplListTable that will be used by PfR to learn TCs.')
cpfrLearnListFilterPfxName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 6, 1, 11), SnmpAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrLearnListFilterPfxName.setStatus('current')
if mibBuilder.loadTexts: cpfrLearnListFilterPfxName.setDescription('This object specifies the name of the prefix list to be used as a filter for traffic classes to be learned by this learn list.')
cpfrActiveProbeTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 7), )
if mibBuilder.loadTexts: cpfrActiveProbeTable.setStatus('current')
if mibBuilder.loadTexts: cpfrActiveProbeTable.setDescription('This table lists the active probe instances created by the system. This table has an expansion dependent relationship on cpfrMapTable, containing zero or more rows for each cpfrMapEntry.')
cpfrActiveProbeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 7, 1), ).setIndexNames((0, "CISCO-PFR-MIB", "cpfrActiveProbeIndex"))
if mibBuilder.loadTexts: cpfrActiveProbeEntry.setStatus('current')
if mibBuilder.loadTexts: cpfrActiveProbeEntry.setDescription("An entry in the cpfrActiveProbeTable describes the configuration and status that directs how PfR active-probes targets. A peer SNMP entity may create an active probe by setting an instance of cpfrActiveProbeRowStatus to 'createAndWait' or 'createAndGo'. Observe that an implementation that does not support these option must specify these limitations in an agent capability statement. Other management entities (e.g., the local console) may create an active probe. In these cases, the system must automatically create a row in the cpfrActiveProbeTable. A peer SNMP entity may destroy an active probe by setting the corresponding instance of cpfrActiveProbeRowStatus to 'destroy'. Observe that an mplementation that does not support this option must specify this limitation in an agent capability statement. Other management entities may destroy an active probe. In these cases, the system must automatically destroy the corresponding row in the cpfrActiveProbeTable. The system automatically destroys rows when the system or EMS/NMS destroys the corresponding entry in cpfrMapTable.")
cpfrActiveProbeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 7, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: cpfrActiveProbeIndex.setStatus('current')
if mibBuilder.loadTexts: cpfrActiveProbeIndex.setDescription('This object indicates an arbitrary integer-value that uniquely identifies an active probe entity in a PfR policy map.')
cpfrActiveProbeStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 7, 1, 2), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrActiveProbeStorageType.setStatus('current')
if mibBuilder.loadTexts: cpfrActiveProbeStorageType.setDescription('This object specifies the memory realization of the row. The following columnar objects are allowed to be writable when the storageType of this entry is permanent(4): pfrActiveProbeType, cpfrActiveProbeTargetAddressType, cpfrActiveProbeTargetAddress, cpfrActiveProbeTargetPortNumber, cpfrActiveProbePfrMapIndex, cpfrActiveProbeDscpValue, cpfrActiveProbeCodecName, cpfrActiveProbeMapIndex, cpfrActiveProbeMapPolicyIndex, cpfrActiveProbeAdminStatus.')
cpfrActiveProbeRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 7, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrActiveProbeRowStatus.setStatus('current')
if mibBuilder.loadTexts: cpfrActiveProbeRowStatus.setDescription('This object specifies the status of row in the active probe table. The following columnar objects must be valid in order to transition the row to the active state: cpfrActiveProbeType, cpfrActiveProbeTargetAddressType, cpfrActiveProbeTargetAddress, cpfrActiveProbeTargetPortNumber, cpfrActiveProbeMapIndex, cpfrActiveProbeMapPolicyIndex. The following columnar objects can be modified when the row is in the active state: None')
cpfrActiveProbeType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 7, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("echo", 1), ("jitter", 2), ("tcpConn", 3), ("udpEcho", 4)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrActiveProbeType.setStatus('current')
if mibBuilder.loadTexts: cpfrActiveProbeType.setDescription("This object specifies the Type of probe. 'echo' Use Internet Control Message Protocol (ICMP) echo messages (ping) for active probe. 'jitter' Use jitter messages for active probe. 'tcp-conn' Use TCP connection messages for active probe. 'udp-echo' Use User Datagram Protocol (UDP) echo messages for active probe.")
cpfrActiveProbeTargetAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 7, 1, 5), InetAddressType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrActiveProbeTargetAddressType.setStatus('current')
if mibBuilder.loadTexts: cpfrActiveProbeTargetAddressType.setDescription('This object specifies the type of a target IP address of a prefix to be monitored using the specified type of probe.')
cpfrActiveProbeTargetAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 7, 1, 6), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrActiveProbeTargetAddress.setStatus('current')
if mibBuilder.loadTexts: cpfrActiveProbeTargetAddress.setDescription('This object specifies target IP address of a prefix to be monitored using the specified type of probe.')
cpfrActiveProbeTargetPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 7, 1, 7), CiscoPort()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrActiveProbeTargetPortNumber.setStatus('current')
if mibBuilder.loadTexts: cpfrActiveProbeTargetPortNumber.setDescription('This object specifies the destination port number for the active probe.')
cpfrActiveProbePfrMapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 7, 1, 8), PfrMapIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrActiveProbePfrMapIndex.setStatus('current')
if mibBuilder.loadTexts: cpfrActiveProbePfrMapIndex.setDescription('This object specifies the index of the PfR policy map on which the active probe clause is configured.')
cpfrActiveProbeDscpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 7, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrActiveProbeDscpValue.setStatus('current')
if mibBuilder.loadTexts: cpfrActiveProbeDscpValue.setDescription('This object indicates the Differentiated Services Code Point (DSCP) value.')
cpfrActiveProbeCodecName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 7, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("g711alaw", 1), ("g711ulaw", 2), ("g729a", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrActiveProbeCodecName.setStatus('current')
if mibBuilder.loadTexts: cpfrActiveProbeCodecName.setDescription("This object specifies the codec value used for Mean Opinion Score (MOS) calculation and only used with the jitter probe type. The codec values must be one of the following, 'g711alaw' G.711 A Law 64000 bps. 'g711ulaw' G.711 U Law 64000 bps. 'g729a' G.729 8000 bps.")
cpfrActiveProbeMapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 7, 1, 11), PfrMapIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrActiveProbeMapIndex.setStatus('current')
if mibBuilder.loadTexts: cpfrActiveProbeMapIndex.setDescription('This object specifies the index of a PfR map under which this active probe was configured.')
cpfrActiveProbeMapPolicyIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 7, 1, 12), PfrMapIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrActiveProbeMapPolicyIndex.setStatus('current')
if mibBuilder.loadTexts: cpfrActiveProbeMapPolicyIndex.setDescription('This object specifies the index of a PfR map policy under which this active probe was configured.')
cpfrActiveProbeAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 7, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("assigned", 1), ("unassigned", 2), ("forced", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrActiveProbeAdminStatus.setStatus('current')
if mibBuilder.loadTexts: cpfrActiveProbeAdminStatus.setDescription("This object specifies whether the probe is assigned to a prefix or not, or is a forced probe configured on a PfR map. 'assigned' Active probe is assigned. 'unassigned' Active probe is unassigned. 'forced' Active probe is sent to forced targets configured in PfR map.")
cpfrActiveProbeOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 7, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("running", 1), ("notRunning", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrActiveProbeOperStatus.setStatus('current')
if mibBuilder.loadTexts: cpfrActiveProbeOperStatus.setDescription("This object indicates the current status of an active probe. 'running' Active probe is running. 'notrunning' Active probe is not running.")
cpfrActiveProbeAssignedPfxAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 7, 1, 15), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrActiveProbeAssignedPfxAddressType.setStatus('current')
if mibBuilder.loadTexts: cpfrActiveProbeAssignedPfxAddressType.setDescription('This object indicates the type of assigned prefix address.')
cpfrActiveProbeAssignedPfxAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 7, 1, 16), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrActiveProbeAssignedPfxAddress.setStatus('current')
if mibBuilder.loadTexts: cpfrActiveProbeAssignedPfxAddress.setDescription('This object indicates the assigned prefix address.')
cpfrActiveProbeAssignedPfxLen = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 7, 1, 17), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrActiveProbeAssignedPfxLen.setStatus('current')
if mibBuilder.loadTexts: cpfrActiveProbeAssignedPfxLen.setDescription('This object indicates the length of the assigned prefix address.')
cpfrActiveProbeMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 7, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("learned", 1), ("configured", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrActiveProbeMethod.setStatus('current')
if mibBuilder.loadTexts: cpfrActiveProbeMethod.setDescription("This object indicates how an active probe is entered into the PfR system. 'learned' Active probe is triggered when PfR learns TCs. 'configured' Active probe is forced by CLI command.")
cpfrBRTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 8), )
if mibBuilder.loadTexts: cpfrBRTable.setStatus('current')
if mibBuilder.loadTexts: cpfrBRTable.setDescription('This table lists the border router (BR) instances created by the system. This table has an expansion dependent relationship on the cpfrMCTable, containing zero or more rows for each cpfrMCEntry.')
cpfrBREntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 8, 1), ).setIndexNames((0, "CISCO-PFR-MIB", "cpfrMCIndex"), (0, "CISCO-PFR-MIB", "cpfrBRIndex"))
if mibBuilder.loadTexts: cpfrBREntry.setStatus('current')
if mibBuilder.loadTexts: cpfrBREntry.setDescription("An entry in the cpfrBRTable describes the configuration and status of one PfR BR. A peer SNMP entity may create a BR by setting an instance of cpfrBRRowStatus to 'createAndWait' or 'createAndGo'. Observe that an implementation that does not support these option must specify these limitations in an agent capability statement. Other management entities (e.g., the local console) may create an exit. In these cases, the system must automatically create a row in the cpfrBRTable. A peer SNMP entity may destroy a BR by setting the corresponding instance of cpfrBRRowStatus to 'destroy'. Observe that an implementation that does not support this option must specify this limitation in an agent capability statement. Other management entities may destroy a BR. In these cases, the system must automatically destroy the corresponding row in the cpfrBRTable. The system automatically destroys rows when the system or EMS/NMS destroys the corresponding entry in cpfrMCEntry.")
cpfrBRIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 8, 1, 1), PfrBorderRouterIndex())
if mibBuilder.loadTexts: cpfrBRIndex.setStatus('current')
if mibBuilder.loadTexts: cpfrBRIndex.setDescription('This object indicates an arbitrary integer-value that uniquely identifies a PfR BR.')
cpfrBRStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 8, 1, 2), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrBRStorageType.setStatus('current')
if mibBuilder.loadTexts: cpfrBRStorageType.setDescription('This object specifies the memory realization of the row. The following columnar objects are allowed to be writable when the storageType of this entry is permanent(4): cpfrBRAddressType, cpfrBRAddress, cpfrBRKeyName.')
cpfrBRRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 8, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrBRRowStatus.setStatus('current')
if mibBuilder.loadTexts: cpfrBRRowStatus.setDescription('This object specifies the status of a row in the BR table. The following columnar objects must be valid in order to transition the row to the active state: None. The following columnar objects can be modified when the row is in the active state: None')
cpfrBRAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 8, 1, 4), InetAddressType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrBRAddressType.setStatus('current')
if mibBuilder.loadTexts: cpfrBRAddressType.setDescription('This object specifies the IP address type of a PfR BR.')
cpfrBRAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 8, 1, 5), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrBRAddress.setStatus('current')
if mibBuilder.loadTexts: cpfrBRAddress.setDescription('This object specifies the IP address of a PfR BR')
cpfrBRKeyName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 8, 1, 6), SnmpAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrBRKeyName.setStatus('current')
if mibBuilder.loadTexts: cpfrBRKeyName.setDescription('This object specifies the key used to authenticate communication between the BR and the MC. The authentication key must be specified during the initial configuration to establish communication, but is not required to enter PfR managed BR configuration mode.')
cpfrBROperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 8, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrBROperStatus.setStatus('current')
if mibBuilder.loadTexts: cpfrBROperStatus.setDescription("This object indicates the operational status of PfR BR. 'active' BR is active. 'inactive' BR is inactive.")
cpfrBRConnStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 8, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrBRConnStatus.setStatus('current')
if mibBuilder.loadTexts: cpfrBRConnStatus.setDescription("This object indicates the connection status between BR and MC. 'up' BR is successfully connected to the MC. 'down' BR is not connected to the MC.")
cpfrBRUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 8, 1, 9), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrBRUpTime.setStatus('current')
if mibBuilder.loadTexts: cpfrBRUpTime.setDescription('This object indicates the length of time that the connection with the MC has been up.')
cpfrBRConnFailureReason = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 8, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("versionMismatch", 1), ("none", 2), ("authFailure", 3), ("socketError", 4), ("timerExpired", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrBRConnFailureReason.setStatus('current')
if mibBuilder.loadTexts: cpfrBRConnFailureReason.setDescription("This object indicates the reason why the connection status between the BR and MC fails. 'versionmismatch' The software version between MC and BR does not match. 'none' No failure reason. 'authFailure' authentication failed. 'socketError' socket was closed with an error. 'timerExpired' connection was closed with keepalive timer expiration.")
cpfrBRAuthFailCount = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 8, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrBRAuthFailCount.setStatus('current')
if mibBuilder.loadTexts: cpfrBRAuthFailCount.setDescription('This object indicates the number of authentication failures between the MC and the BR.')
cpfrExitTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 9), )
if mibBuilder.loadTexts: cpfrExitTable.setStatus('current')
if mibBuilder.loadTexts: cpfrExitTable.setDescription('This table lists the PfR exit instances created by the system. This table has an expansion dependent relationship on the cpfrBRTable, containing zero or more rows for each cpfrBREntry.')
cpfrExitEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 9, 1), ).setIndexNames((0, "CISCO-PFR-MIB", "cpfrMCIndex"), (0, "CISCO-PFR-MIB", "cpfrBRIndex"), (0, "CISCO-PFR-MIB", "cpfrExitIndex"))
if mibBuilder.loadTexts: cpfrExitEntry.setStatus('current')
if mibBuilder.loadTexts: cpfrExitEntry.setDescription("An entry in the cpfrExitTable describes the configuration and status of one PfR monitored/controlled exit. A peer SNMP entity may create an exit for PfR BR by setting an instance of cpfrLinkGroupRowStatus to 'createAndWait' or 'createAndGo'. Observe that an implementation that does not support these option must specify these limitations in an agent capability statement. Other management entities (e.g., the local console) may create an exit for a PfR BR. In these cases, the system must automatically create a row in the cpfrExitTable. A peer SNMP entity may destroy an exit from a PfR BR by setting the corresponding instance of cpfrExitRowStatus to 'destroy'. Observe that an implementation that does not support this option must specify this limitation in an agent capability statement. Other management entities may destroy an exit from a PfR BR. In these cases, the system must automatically destroy the corresponding row in the cpfrExitTable. The system automatically destroys rows when the system or EMS/NMS destroys the corresponding entry in cpfrBREntry.")
cpfrExitIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 9, 1, 1), PfrExitIndex())
if mibBuilder.loadTexts: cpfrExitIndex.setStatus('current')
if mibBuilder.loadTexts: cpfrExitIndex.setDescription('This object indicates an arbitrary integer-value that uniquely identifies a PfR monitored/controlled exit.')
cpfrExitStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 9, 1, 2), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrExitStorageType.setStatus('current')
if mibBuilder.loadTexts: cpfrExitStorageType.setDescription('This object specifies the memory realization of the row. The following columnar objects are allowed to be writable when the storageType of this entry is permanent(4): cpfrExitName, cpfrExitType, cpfrDowngradeBgpCommunity, cpfrExitMaxUtilRxType, cpfrExitMURxAbsolute, cpfrExitMURxPercentage , cpfrExitMaxUtilTxType, cpfrExitMUTxAbsolute, cpfrExitMUTxPercentage, cpfrExitCostCalcMethod, cpfrExitCostDiscard, cpfrExitCostDiscardType, cpfrExitCostDiscardAbsolute, cpfrExitCostDiscardPercent, cpfrExitCostEndDayOfMonth, cpfrExitCostEndOffset, cpfrExitCostFixedFeeCost, cpfrExitCostNickName, cpfrExitCostSamplingPeriod, cpfrExitCostRollupPeriod, cpfrExitCostSummerTimeStart, cpfrExitCostSummerTimeOffset, cpfrExitCostSummerTimeEnd.')
cpfrExitRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 9, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrExitRowStatus.setStatus('current')
if mibBuilder.loadTexts: cpfrExitRowStatus.setDescription('This object specifies the status of a row in the exit table. The following columnar objects must be valid in order to transition the row to the active state: cpfrExitName, cpfrExitType. The following columnar objects can be modified when the row is in the active state: None')
cpfrExitName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 9, 1, 4), SnmpAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrExitName.setStatus('current')
if mibBuilder.loadTexts: cpfrExitName.setDescription('This object specifies the name of a PfR controlled interface on a BR.')
cpfrExitType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 9, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("internal", 1), ("external", 2))).clone('external')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrExitType.setStatus('current')
if mibBuilder.loadTexts: cpfrExitType.setDescription("This object specifies the exit type. 'internal' The interface is an internal interface. Internal interfaces are used for communication between BRs. 'external' The interface is an external interface. External interfaces are used for active and passive monitoring and traffic forwarding.")
cpfrDowngradeBgpCommunity = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 9, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrDowngradeBgpCommunity.setStatus('current')
if mibBuilder.loadTexts: cpfrDowngradeBgpCommunity.setDescription('This object specifies a BGP prepend community number attached to an inside prefix BGP advertisement from the network to another autonomous system. The BGP prepend community will increase the number of autonomous system hops in the advertisement of the inside prefix to other autonomous systems.')
cpfrExitMaxUtilRxType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 9, 1, 7), PfrMetricPolicyType().clone('relative')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrExitMaxUtilRxType.setStatus('current')
if mibBuilder.loadTexts: cpfrExitMaxUtilRxType.setDescription('This object specifies the maximum utilization configuration type for incoming traffic over a single PfR exit.')
cpfrExitMaxUtilRxAbsolute = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 9, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setUnits('Kbps').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrExitMaxUtilRxAbsolute.setStatus('current')
if mibBuilder.loadTexts: cpfrExitMaxUtilRxAbsolute.setDescription('This object specifies the maximum utilization on a PfR managed entrance link to an absolute value.')
cpfrExitMaxUtilRxPercentage = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 9, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 100)).clone(75)).setUnits('percent').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrExitMaxUtilRxPercentage.setStatus('current')
if mibBuilder.loadTexts: cpfrExitMaxUtilRxPercentage.setDescription('This object specifies the maximum utilization on a PfR managed entrance link to a bandwidth percentage.')
cpfrExitMaxUtilTxType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 9, 1, 10), PfrMetricPolicyType().clone('relative')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrExitMaxUtilTxType.setStatus('current')
if mibBuilder.loadTexts: cpfrExitMaxUtilTxType.setDescription('This object specifies the maximum utilization configuration type for traffic over a single PfR managed exit.')
cpfrExitMaxUtilTxAbsolute = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 9, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setUnits('Kbps').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrExitMaxUtilTxAbsolute.setStatus('current')
if mibBuilder.loadTexts: cpfrExitMaxUtilTxAbsolute.setDescription('This object indicates the maximum utilization on a PfR managed exit link to an absolute value.')
cpfrExitMaxUtilTxPercentage = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 9, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 100)).clone(75)).setUnits('percent').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrExitMaxUtilTxPercentage.setStatus('current')
if mibBuilder.loadTexts: cpfrExitMaxUtilTxPercentage.setDescription('This object specifies the maximum utilization on a PfR managed exit link to a bandwidth percentage.')
cpfrExitCostCalcMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 9, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("combined", 1), ("separate", 2), ("sum", 3))).clone('combined')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrExitCostCalcMethod.setStatus('current')
if mibBuilder.loadTexts: cpfrExitCostCalcMethod.setDescription("This object indicates how the fee for a particular exit is calculated. 'combined' Specifies billing based on combined egress and ingress rollup samples. 'separate' Specifies billing based on separate egress and ingress rollup samples. 'sum' Specifies billing based on egress and ingress rollup samples that are added and then combined.")
cpfrExitCostDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 9, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("daily", 1), ("monthly", 2))).clone('monthly')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrExitCostDiscard.setStatus('current')
if mibBuilder.loadTexts: cpfrExitCostDiscard.setDescription("This object specifies how often rollup samples are discarded. 'daily' Rollup samples are discarded every day. 'monthly' Rollup samples are discarded every month.")
cpfrExitCostDiscardType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 9, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("absolute", 1), ("percent", 2))).clone('absolute')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrExitCostDiscardType.setStatus('current')
if mibBuilder.loadTexts: cpfrExitCostDiscardType.setDescription("This object specifies the threshold value types for cost discard. 'absolute' Absolute value configured in cpfrExitCostDiscardAbsolute object will be used. 'percent' Percent value configured in cpfrExitCostDiscardPercent object will be used.")
cpfrExitCostDiscardAbsolute = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 9, 1, 16), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setUnits('samples').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrExitCostDiscardAbsolute.setStatus('current')
if mibBuilder.loadTexts: cpfrExitCostDiscardAbsolute.setDescription('This object specifies an absolute number of rollup samples to be discarded.')
cpfrExitCostDiscardPercent = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 9, 1, 17), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 99))).setUnits('percent').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrExitCostDiscardPercent.setStatus('current')
if mibBuilder.loadTexts: cpfrExitCostDiscardPercent.setDescription('This object specifies what percentage of the rollup samples should be discarded when calculating the exit cost.')
cpfrExitCostEndDayOfMonth = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 9, 1, 18), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 31)).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrExitCostEndDayOfMonth.setStatus('current')
if mibBuilder.loadTexts: cpfrExitCostEndDayOfMonth.setDescription('This object specifies the end billing date.')
cpfrExitCostEndOffsetType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 9, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("positive", 1), ("negative", 2))).clone('positive')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrExitCostEndOffsetType.setStatus('current')
if mibBuilder.loadTexts: cpfrExitCostEndOffsetType.setDescription("This object indicates the cpfrExitCostEndOffset is before or after cpfrExitCostEndDayOfMonth. 'positive' time After cpfrExitCostEndDayOfMonth. 'negative' time before cpfrExitCostEndDayOfMonth.")
cpfrExitCostEndOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 9, 1, 20), TimeInterval()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrExitCostEndOffset.setStatus('current')
if mibBuilder.loadTexts: cpfrExitCostEndOffset.setDescription('This object indicates an offset in hours and minutes, allowing you to compensate for time zone differences.')
cpfrExitCostFixedFeeCost = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 9, 1, 21), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setUnits('dollars').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrExitCostFixedFeeCost.setStatus('current')
if mibBuilder.loadTexts: cpfrExitCostFixedFeeCost.setDescription('This object specifies a non-usage based fixed fee.')
cpfrExitCostNickName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 9, 1, 22), SnmpAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrExitCostNickName.setStatus('current')
if mibBuilder.loadTexts: cpfrExitCostNickName.setDescription('This object specifies a nickname for the cost structure.')
cpfrExitCostSamplingPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 9, 1, 23), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setUnits('minutes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrExitCostSamplingPeriod.setStatus('current')
if mibBuilder.loadTexts: cpfrExitCostSamplingPeriod.setDescription('This object specifies the sampling period.')
cpfrExitCostRollupPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 9, 1, 24), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setUnits('minutes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrExitCostRollupPeriod.setStatus('current')
if mibBuilder.loadTexts: cpfrExitCostRollupPeriod.setDescription('This object specifies that samples are rolled up at the interval specified for the minutes argument. This value must be greater than or equal to the corresponding instance of cpfrExitCostSamplingPeriod.')
cpfrExitCostSummerTimeStart = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 9, 1, 25), DateAndTime()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrExitCostSummerTimeStart.setStatus('current')
if mibBuilder.loadTexts: cpfrExitCostSummerTimeStart.setDescription('This object indicates the date and time when the daylight savings time starts.')
cpfrExitCostSummerTimeOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 9, 1, 26), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 120))).setUnits('minutes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrExitCostSummerTimeOffset.setStatus('current')
if mibBuilder.loadTexts: cpfrExitCostSummerTimeOffset.setDescription('This object specifies the offset added in the spring and subtracted in the fall.')
cpfrExitCostSummerTimeEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 9, 1, 27), DateAndTime()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrExitCostSummerTimeEnd.setStatus('current')
if mibBuilder.loadTexts: cpfrExitCostSummerTimeEnd.setDescription('This object indicates the date and time when daylight saving time comes to an end.')
cpfrExitCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 9, 1, 28), CounterBasedGauge64()).setUnits('Kbps').setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrExitCapacity.setStatus('current')
if mibBuilder.loadTexts: cpfrExitCapacity.setDescription('This object indicates the capacity of the interface.')
cpfrExitRxBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 9, 1, 29), CounterBasedGauge64()).setUnits('Kbps').setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrExitRxBandwidth.setStatus('current')
if mibBuilder.loadTexts: cpfrExitRxBandwidth.setDescription('This object indicates the receive bandwidth as configured on the interface.')
cpfrExitTxBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 9, 1, 30), CounterBasedGauge64()).setUnits('Kbps').setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrExitTxBandwidth.setStatus('current')
if mibBuilder.loadTexts: cpfrExitTxBandwidth.setDescription('This object indicates the transmit bandwidth as configured on the interface.')
cpfrExitTxLoad = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 9, 1, 31), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setUnits('percent').setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrExitTxLoad.setStatus('current')
if mibBuilder.loadTexts: cpfrExitTxLoad.setDescription('This object indicates the transmit load of the exit.')
cpfrExitRxLoad = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 9, 1, 32), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrExitRxLoad.setStatus('current')
if mibBuilder.loadTexts: cpfrExitRxLoad.setDescription('This object indicates the receive traffic load of the exit.')
cpfrExitNickName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 9, 1, 33), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrExitNickName.setStatus('current')
if mibBuilder.loadTexts: cpfrExitNickName.setDescription('The object indicates the exit nickname assigned to an external PfR interface.')
cpfrExitCost1 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 9, 1, 34), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setUnits('dollars').setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrExitCost1.setStatus('current')
if mibBuilder.loadTexts: cpfrExitCost1.setDescription('This object indicates the exit link cost for the current month.')
cpfrExitSustainedUtil1 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 9, 1, 35), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setUnits('Kbps').setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrExitSustainedUtil1.setStatus('current')
if mibBuilder.loadTexts: cpfrExitSustainedUtil1.setDescription('This object indicates the sustained utilization of the exit link in the current month.')
cpfrExitCost2 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 9, 1, 36), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setUnits('dollars').setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrExitCost2.setStatus('current')
if mibBuilder.loadTexts: cpfrExitCost2.setDescription('This object indicates the exit link cost of the previous month.')
cpfrExitSustainedUtil2 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 9, 1, 37), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setUnits('Kbps').setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrExitSustainedUtil2.setStatus('current')
if mibBuilder.loadTexts: cpfrExitSustainedUtil2.setDescription('This object indicates the sustained utilization of the exit link for the month prior to the previous month.')
cpfrExitCost3 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 9, 1, 38), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setUnits('dollars').setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrExitCost3.setStatus('current')
if mibBuilder.loadTexts: cpfrExitCost3.setDescription('This object indicates the exit link cost for the month prior to the previous month.')
cpfrExitSustainedUtil3 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 9, 1, 39), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setUnits('Kbps').setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrExitSustainedUtil3.setStatus('current')
if mibBuilder.loadTexts: cpfrExitSustainedUtil3.setDescription('This object indicates the sustained utilization of the exit link the month prior to the previous month.')
cpfrExitRollupTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 9, 1, 40), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setUnits('minutes').setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrExitRollupTotal.setStatus('current')
if mibBuilder.loadTexts: cpfrExitRollupTotal.setDescription('This object indicates the total rollups.')
cpfrExitRollupDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 9, 1, 41), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrExitRollupDiscard.setStatus('current')
if mibBuilder.loadTexts: cpfrExitRollupDiscard.setDescription('This object indicates the total discarded rollups.')
cpfrExitRollupLeft = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 9, 1, 42), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrExitRollupLeft.setStatus('current')
if mibBuilder.loadTexts: cpfrExitRollupLeft.setDescription('This object indicates the left over rollups.')
cpfrExitRollupCollected = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 9, 1, 43), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrExitRollupCollected.setStatus('current')
if mibBuilder.loadTexts: cpfrExitRollupCollected.setDescription('This object indicates the rollups that are being collected.')
cpfrExitRollupMomTgtUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 9, 1, 44), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setUnits('Kbps').setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrExitRollupMomTgtUtil.setStatus('current')
if mibBuilder.loadTexts: cpfrExitRollupMomTgtUtil.setDescription('This object indicates the momentary utilization of the targets.')
cpfrExitRollupStartingTgtUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 9, 1, 45), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setUnits('Kbps').setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrExitRollupStartingTgtUtil.setStatus('current')
if mibBuilder.loadTexts: cpfrExitRollupStartingTgtUtil.setDescription('This object indicates the target when the rollup starts.')
cpfrExitRollupCurrentTgtUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 9, 1, 46), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setUnits('kbps').setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrExitRollupCurrentTgtUtil.setStatus('current')
if mibBuilder.loadTexts: cpfrExitRollupCurrentTgtUtil.setDescription('This object indicates current rollup target.')
cpfrExitRollupCumRxBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 9, 1, 47), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrExitRollupCumRxBytes.setStatus('current')
if mibBuilder.loadTexts: cpfrExitRollupCumRxBytes.setDescription('This object indicates the cumulative receive bytes in a rollup.')
cpfrExitRollupCumTxBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 9, 1, 48), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrExitRollupCumTxBytes.setStatus('current')
if mibBuilder.loadTexts: cpfrExitRollupCumTxBytes.setDescription('This object indicates the cumulative transmit bytes in a rollup.')
cpfrExitRollupTimeRemain = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 9, 1, 49), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrExitRollupTimeRemain.setStatus('current')
if mibBuilder.loadTexts: cpfrExitRollupTimeRemain.setDescription('This object indicates the remaining time before a new rollup is started.')
cpfrExitOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 9, 1, 50), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrExitOperStatus.setStatus('current')
if mibBuilder.loadTexts: cpfrExitOperStatus.setDescription("This object indicates the current status of an exit. 'up' The exit is up. 'down' The exit is down.")
cpfrExitRsvpBandwidthPool = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 9, 1, 51), CounterBasedGauge64()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrExitRsvpBandwidthPool.setStatus('current')
if mibBuilder.loadTexts: cpfrExitRsvpBandwidthPool.setDescription('This object indicates the bandwidth pool for RSVP in PfR.')
cpfrExitCostTierTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 10), )
if mibBuilder.loadTexts: cpfrExitCostTierTable.setStatus('current')
if mibBuilder.loadTexts: cpfrExitCostTierTable.setDescription('This table lists the cost tier instances created by the system. This table has an expansion dependent relationship on the cpfrExitTable, containing zero or more rows for each cpfrExitEntry.')
cpfrExitCostTierEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 10, 1), ).setIndexNames((0, "CISCO-PFR-MIB", "cpfrMCIndex"), (0, "CISCO-PFR-MIB", "cpfrBRIndex"), (0, "CISCO-PFR-MIB", "cpfrExitIndex"), (0, "CISCO-PFR-MIB", "cpfrExitCostTierIndex"))
if mibBuilder.loadTexts: cpfrExitCostTierEntry.setStatus('current')
if mibBuilder.loadTexts: cpfrExitCostTierEntry.setDescription("An entry describing the configuration of a cost tier of a PfR monitored or Controlled exit. A peer SNMP entity may create a cost tier for a PfR monitored or controlled exit by setting an instance of cpfrExitCostTierRowStatus to 'createAndWait' or 'createAndGo'. Observe that an implementation that does not support these option must specify these limitations in an agent capability statement. Other management entities (e.g., the local console) may create a cost tier for a PfR monitored or controlled external exit. In these cases, the system must automatically create a row in the cpfrExitCostTierTable. A peer SNMP entity may destroy a cost tier from a PfR monitored or controlled external exit by setting the corresponding instance of cpfrLinkGroupRowStatus to 'destroy'. Observe that an implementation that does not support this option must specify this limitation in an agent capability statement. Other management entities may destroy a cost tier from a PfR monitored or controlled external exit. In these cases, the system must automatically destroy the corresponding row in the cpfrExitCostTierTable. The system automatically destroys rows when the system or EMS/NMS destroys the corresponding entry in cpfrExitEntry.")
cpfrExitCostTierIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)))
if mibBuilder.loadTexts: cpfrExitCostTierIndex.setStatus('current')
if mibBuilder.loadTexts: cpfrExitCostTierIndex.setDescription('This object indicates an arbitrary integer-value that uniquely identifies the cost tier of a PfR monitored/controlled exit.')
cpfrExitCostTierStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 10, 1, 2), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrExitCostTierStorageType.setStatus('current')
if mibBuilder.loadTexts: cpfrExitCostTierStorageType.setDescription('This object specifies the memory realization of the row. The following columnar objects are allowed to be writable when the storageType of this entry is permanent(4): cpfrExitCostTierFee.')
cpfrExitCostTierRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 10, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrExitCostTierRowStatus.setStatus('current')
if mibBuilder.loadTexts: cpfrExitCostTierRowStatus.setDescription('This object specifies the status of a row in the exit cost tier table. The following columnar objects must be valid in order to transition the row to the active state: cpfrExitCostTierFee. The following columnar objects can be modified when the row is in the active state: None')
cpfrExitCostTierFee = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrExitCostTierFee.setStatus('current')
if mibBuilder.loadTexts: cpfrExitCostTierFee.setDescription('This object specifies the cost value of a cost tier.')
cpfrTrafficClassTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 11), )
if mibBuilder.loadTexts: cpfrTrafficClassTable.setStatus('current')
if mibBuilder.loadTexts: cpfrTrafficClassTable.setDescription('This table lists the TC instances created by the system.')
cpfrTrafficClassEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 11, 1), ).setIndexNames((0, "CISCO-PFR-MIB", "cpfrMCIndex"), (0, "CISCO-PFR-MIB", "cpfrTrafficClassIndex"))
if mibBuilder.loadTexts: cpfrTrafficClassEntry.setStatus('current')
if mibBuilder.loadTexts: cpfrTrafficClassEntry.setDescription('An entry describing the metrics that identify a PfR monitored or controlled TC. A device supporting PfR creates a row in a cpfrTrafficClassTable when it recognizes the addition of a new TC monitored by PfR. Likewise, such a device destroys a row in the cpfrTrafficClassTable when a TC has been purged from the system.')
cpfrTrafficClassIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 11, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: cpfrTrafficClassIndex.setStatus('current')
if mibBuilder.loadTexts: cpfrTrafficClassIndex.setDescription('This object indicates an arbitrary integer-value that uniquely identifies a TC monitored/controlled by PfR.')
cpfrTCBRIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 11, 1, 2), PfrBorderRouterIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrTCBRIndex.setStatus('current')
if mibBuilder.loadTexts: cpfrTCBRIndex.setDescription('This object indicates the index of the BR on which PfR is controlling the TC.')
cpfrTCBRExitIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 11, 1, 3), PfrExitIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrTCBRExitIndex.setStatus('current')
if mibBuilder.loadTexts: cpfrTCBRExitIndex.setDescription('This object indicates the index of the exit on which PfR is controlling the TC.')
cpfrTCMapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 11, 1, 4), PfrMapIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrTCMapIndex.setStatus('current')
if mibBuilder.loadTexts: cpfrTCMapIndex.setDescription('This object indicates the map index of the PfR map defining the policy for the TC.')
cpfrTCMapPolicyIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 11, 1, 5), PfrMapPolicyIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrTCMapPolicyIndex.setStatus('current')
if mibBuilder.loadTexts: cpfrTCMapPolicyIndex.setDescription('This object indicates the map policy index of the PfR map defining the policy for the TC.')
cpfrTrafficClassValid = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 11, 1, 6), Bits().clone(namedValues=NamedValues(("source", 0), ("destination", 1), ("sourcePort", 2), ("destinationPort", 3), ("dscp", 4), ("protocol", 5), ("nbar", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrTrafficClassValid.setStatus('current')
if mibBuilder.loadTexts: cpfrTrafficClassValid.setDescription("This object indicates which objects in the traffic class table are valid. If an attribute of a TC is configured, the corresponding bit in this object should be set. 'source' Source address is valid. 'destination' Destination address is valid. 'sourcePort' Source port object in the entry is valid. 'destinationPort' Destination port object in the entry is valid. 'dscp' DSCP object in the entry is valid. 'protocol' Protocol object in the entry is valid. 'nbar' NBAR object in the entry is valid.")
cpfrTCSrcPrefixType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 11, 1, 7), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrTCSrcPrefixType.setStatus('current')
if mibBuilder.loadTexts: cpfrTCSrcPrefixType.setDescription('This object indicates the type of IP address indicated by the corresponding instance of cpfrTCSrcPrefix.')
cpfrTCSrcPrefix = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 11, 1, 8), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrTCSrcPrefix.setStatus('current')
if mibBuilder.loadTexts: cpfrTCSrcPrefix.setDescription('This object indicates the source IP prefix of the corresponding TC.')
cpfrTCSrcPrefixLen = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 11, 1, 9), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrTCSrcPrefixLen.setStatus('current')
if mibBuilder.loadTexts: cpfrTCSrcPrefixLen.setDescription('This object indicates the prefix length of source IP address for the TC.')
cpfrTCSrcMinPort = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 11, 1, 10), CiscoPort()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrTCSrcMinPort.setStatus('current')
if mibBuilder.loadTexts: cpfrTCSrcMinPort.setDescription('This object indicates the minimum source port number for a TC.')
cpfrTCSrcMaxPort = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 11, 1, 11), CiscoPort()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrTCSrcMaxPort.setStatus('current')
if mibBuilder.loadTexts: cpfrTCSrcMaxPort.setDescription('This object indicates the maximum source port number for a TC')
cpfrTCDstPrefixType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 11, 1, 12), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrTCDstPrefixType.setStatus('current')
if mibBuilder.loadTexts: cpfrTCDstPrefixType.setDescription('This object indicates the type of IP address indicated by the corresponding instances of cpfrTCDstPrefix.')
cpfrTCDstPrefix = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 11, 1, 13), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrTCDstPrefix.setStatus('current')
if mibBuilder.loadTexts: cpfrTCDstPrefix.setDescription('This object indicates the destination IP prefix of the corresponding TC.')
cpfrTCDstPrefixLen = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 11, 1, 14), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrTCDstPrefixLen.setStatus('current')
if mibBuilder.loadTexts: cpfrTCDstPrefixLen.setDescription('This object indicates the prefix length of destination IP address for the TC.')
cpfrTCDstMinPort = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 11, 1, 15), CiscoPort()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrTCDstMinPort.setStatus('current')
if mibBuilder.loadTexts: cpfrTCDstMinPort.setDescription('This object indicates the minimum destination port of a TC.')
cpfrTCDstMaxPort = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 11, 1, 16), CiscoPort()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrTCDstMaxPort.setStatus('current')
if mibBuilder.loadTexts: cpfrTCDstMaxPort.setDescription('This object indicates the maximum destination port of a TC')
cpfrTCDscpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 11, 1, 17), DscpOrAny().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-1, -1), ValueRangeConstraint(0, 63), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrTCDscpValue.setStatus('current')
if mibBuilder.loadTexts: cpfrTCDscpValue.setDescription('This object indicates the Differentiated Services Code Point (DSCP) value of a TC.')
cpfrTCProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 11, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("static", 1), ("eigrp", 2), ("ribpbr", 3), ("bgp", 4), ("pbr", 5), ("cce", 6), ("unknown", 7)))).setUnits('bgp').setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrTCProtocol.setStatus('current')
if mibBuilder.loadTexts: cpfrTCProtocol.setDescription('This object indicates the routing protocol by a TC.')
cpfrTCNbarApplication = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 11, 1, 19), CiscoPdProtocolIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrTCNbarApplication.setStatus('current')
if mibBuilder.loadTexts: cpfrTCNbarApplication.setDescription('This object indicates the application or protocol recognized by NBAR. The value of this object points to an entry in cnpdSupportedProtocolsTable, which describes the recognized protocol, and is defined in CISCO-NBAR-PROTOCOL-DISCOVERY-MIB.')
cpfrTrafficClassStatusTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 12), )
if mibBuilder.loadTexts: cpfrTrafficClassStatusTable.setStatus('current')
if mibBuilder.loadTexts: cpfrTrafficClassStatusTable.setDescription('This table lists the TC status instances created by the system. This table has an one-to-one relationship with cpfrTrafficClassTable, containing a row for each entry in cpfrTrafficClassTable.')
cpfrTrafficClassStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 12, 1), ).setIndexNames((0, "CISCO-PFR-MIB", "cpfrMCIndex"), (0, "CISCO-PFR-MIB", "cpfrTrafficClassIndex"))
if mibBuilder.loadTexts: cpfrTrafficClassStatusEntry.setStatus('current')
if mibBuilder.loadTexts: cpfrTrafficClassStatusEntry.setDescription('An entry describing the status of a PfR monitored or controlled TC. A device supporting PfR creates a row in a cpfrTrafficClassStatusTable when it recognizes the addition of a new TC. Likewise, such a device destroys a row in the cpfrTrafficClassStatusTable when a TC has been purged from the system.')
cpfrTCStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("default", 1), ("choose", 2), ("holddown", 3), ("inpolicy", 4), ("oopolicy", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrTCStatus.setStatus('current')
if mibBuilder.loadTexts: cpfrTCStatus.setDescription("This object indicates the current state of a TC. 'default' The state means that the parent IP routes control the exit for this destination prefix. This would be the same behavior as if PfR were not configured or was shutdown. 'choose' The state indicates PfR is choosing the exit for the prefix. 'holddown' The state is seen when a TC is initially controlled by PfR. This holddown concept is applied to prevent churning or erratic behavior of PfR managed routes from being injected and withdrawn from the IP routing table (and subsequently being redistributed by some IGP) or BGP tables. 'inpolicy' This state means that the prefix meets the policy associated with this prefix or application. 'oopolicy' The prefix or application has been identified as failing to meet its respective policy.")
cpfrTCSType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("learned", 1), ("configured", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrTCSType.setStatus('current')
if mibBuilder.loadTexts: cpfrTCSType.setDescription("This object indicates whether a TC was learned or configured. 'learned' The TC is learned by PfR. 'configured' The TC is configured via CLI command.")
cpfrTCSLearnListIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 12, 1, 3), PfrLearnListIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrTCSLearnListIndex.setStatus('current')
if mibBuilder.loadTexts: cpfrTCSLearnListIndex.setDescription('This object indicates the index of the learn list responsible for PfR learning this TC.')
cpfrTCSTimeOnCurrExit = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 12, 1, 4), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrTCSTimeOnCurrExit.setStatus('current')
if mibBuilder.loadTexts: cpfrTCSTimeOnCurrExit.setDescription('This object indicates the length of time the TC has been controlled on the current exit.')
cpfrTCSControlState = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 12, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("controlled", 1), ("uncontrolled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrTCSControlState.setStatus('current')
if mibBuilder.loadTexts: cpfrTCSControlState.setDescription("The object indicates the control state of a TC. 'controlled' PfR is controlling this TC. 'uncontrolled' PfR is not controlling this TC.")
cpfrTCSControlBy = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 12, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("static", 1), ("eigrp", 2), ("ribpbr", 3), ("bgp", 4), ("pbr", 5), ("cce", 6), ("unknown", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrTCSControlBy.setStatus('current')
if mibBuilder.loadTexts: cpfrTCSControlBy.setDescription("This object indicates which routing protocol a TC is being controlled by. 'static' TC is controlled by static routing protocol. 'eigrp' TC is controlled by EIGRP. 'ribpbr' TC is controlled by RIB. 'bgp' TC is controlled by BGP 'pbr' TC is controlled by PBR. 'cce' TC is controlled by CCE. 'unknown' TC os controlled by unknown protocols")
cpfrTCSTimeRemainCurrState = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 12, 1, 7), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrTCSTimeRemainCurrState.setStatus('current')
if mibBuilder.loadTexts: cpfrTCSTimeRemainCurrState.setDescription('This object indicates the time remaining before the prefix timer expires.')
cpfrTCSLastOOPEventTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 12, 1, 8), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrTCSLastOOPEventTime.setStatus('current')
if mibBuilder.loadTexts: cpfrTCSLastOOPEventTime.setDescription('This object indicates the time when the last out-of-policy event was observed.')
cpfrTCSLastOOPReason = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 12, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("delayOOPPassiveMode", 1), ("lossOOPPassiveMode", 2), ("unreachableOOPPassiveMode", 3), ("delayOOPActiveMode", 4), ("lossOOPActiveMode", 5), ("unreachableOOPActiveMode", 6), ("jitterOOPActiveMode", 7), ("mosOOPActiveMode", 8), ("none", 9), ("rsvpOOPRecomputeExclude", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrTCSLastOOPReason.setStatus('current')
if mibBuilder.loadTexts: cpfrTCSLastOOPReason.setDescription("This object indicates the last out-of-policy reason. This object indicates the reason that causes an out-of-policy event. 'delayOOPassiveMode' The Delay is out of policy in passive mode. 'lossOOPassiveMode' The loss is out of policy in passive mode. 'unreachableOOPassiveMode' The unreachability rate is out of policy in passive mode. 'delayOOPActiveMode' The Delay is out of policy in active mode. 'lossOOPActiveMode' The loss is out of policy in active mode. 'unreachableOOPActiveMode' The unreachability rate is out of policy in active mode. 'jitterOOPActiveMode' The jitter is out of policy in active mode. 'mosOOPActiveMode' The mos is out of policy in active mode. 'none' no reason. 'rsvpRecomputeExclude' The TC was excluded by recomputing RSVP bandwidth.")
cpfrTCSLastRouteChangeEvent = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 12, 1, 10), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrTCSLastRouteChangeEvent.setStatus('current')
if mibBuilder.loadTexts: cpfrTCSLastRouteChangeEvent.setDescription('This object indicates the value of sysUpTime when the last route change occurred for this TC.')
cpfrTCSLastRouteChangeReason = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 12, 1, 11), PfrLastUncontrolReason()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrTCSLastRouteChangeReason.setStatus('current')
if mibBuilder.loadTexts: cpfrTCSLastRouteChangeReason.setDescription('This object indicates the reason the last route change occurred.')
cpfrTrafficClassMetricTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 13), )
if mibBuilder.loadTexts: cpfrTrafficClassMetricTable.setStatus('current')
if mibBuilder.loadTexts: cpfrTrafficClassMetricTable.setDescription("This table lists the TC's metrics instances created by the system. This table has an one-to-one relationship with cpfrTrafficClassTable, containing a row for each entry in cpfrTrafficClassTable.")
cpfrTrafficClassMetricEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 13, 1), ).setIndexNames((0, "CISCO-PFR-MIB", "cpfrMCIndex"), (0, "CISCO-PFR-MIB", "cpfrTrafficClassIndex"))
if mibBuilder.loadTexts: cpfrTrafficClassMetricEntry.setStatus('current')
if mibBuilder.loadTexts: cpfrTrafficClassMetricEntry.setDescription('An entry describing the metric for a PfR monitored or controlled TC. A device supporting PfR creates a row in a cpfrTrafficClassMetricTable when it recognizes the addition of a new TC. Likewise, such a device destroys a row in the cpfrTrafficClassMetricTable when a TC has been purged from the system.')
cpfrTCMLastUpdateTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 13, 1, 1), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrTCMLastUpdateTime.setStatus('current')
if mibBuilder.loadTexts: cpfrTCMLastUpdateTime.setDescription('This object indicates the value of sysUpTime when the metrics were last updated.')
cpfrTCMAge = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 13, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrTCMAge.setStatus('current')
if mibBuilder.loadTexts: cpfrTCMAge.setDescription('This object indicates the age of a metric.')
cpfrTCMetricsValid = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 13, 1, 3), Bits().clone(namedValues=NamedValues(("activeSTJitterAvg", 0), ("mosPercentage", 1), ("attempts", 2), ("packets", 3), ("passiveSTUnreachableAvg", 4), ("passiveSTdelayAvg", 5), ("passiveSTLossAvg", 6), ("activeSTUnreachableAvg", 7), ("activeSTDelayAvg", 8), ("passiveLTUnreachableAvg", 9), ("passiveLTDelayAvg", 10), ("passiveLTLossAvg", 11), ("activeLTUnreachableAvg", 12), ("activeLTDelayAvg", 13)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrTCMetricsValid.setStatus('current')
if mibBuilder.loadTexts: cpfrTCMetricsValid.setDescription("This object indicates if an object in the entry is valid. 'relativeDelay' Relative delay is a valid value. 'relativeJitter' Relative jitter is a valid value. 'relativeDelayLoss' Relative loss is a valid value. 'relativeDelayUnreachable' Relative unreachability rate is a valid value. 'activeDelay' Absolute delay is a valid value. 'activeJitter' Absolute jitter is a valid value. 'activeLoss' Absolute loss is a valid value. 'activeUnreachable' Absolute unreachable rate is a valid value. 'mosPercentage' Most percentage is a valid value. 'attempts' The number of attempts is a valid value. 'packets' Probe packet is a valid value. 'passiveSTUnreachableAvg' Short time unreachability rate in passive mode is a valid value. 'passiveSTDelayAvg' Short time delay in passive mode is a valid value. 'passiveSTLossAvg' Short time loss in passive mode is a valid value. 'activeSTUnreachableAvg' Short time unreachability rate in active mode is a valid value. 'activeSTDelayAvg' Short time delay in active mode is a valid value. 'passiveLTUnreachableAvg' Long time unreachability rate in passive mode is a valid value. 'passiveLTDelayAvg' Long time delay in passive mode is a valid value. 'passiveLTLossAvg' Long time loss in passive mode is a valid value. 'activeLTUnreachableAvg' Long time unreachability rate in active mode is a valid value. 'activeLTDelayAvg' Long time delay in active mode is a valid value.")
cpfrTCMActiveSTJitterAvg = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 13, 1, 4), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setUnits('percent').setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrTCMActiveSTJitterAvg.setStatus('current')
if mibBuilder.loadTexts: cpfrTCMActiveSTJitterAvg.setDescription('This object indicates average jitter of a TC in active mode.')
cpfrTCMMOSPercentage = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 13, 1, 5), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setUnits('percent').setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrTCMMOSPercentage.setStatus('current')
if mibBuilder.loadTexts: cpfrTCMMOSPercentage.setDescription('This object indicates the number of Mean Opinion Score (MOS) packets with a percentage below threshold in active mode.')
cpfrTCMAttempts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 13, 1, 6), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setUnits('attempts').setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrTCMAttempts.setStatus('current')
if mibBuilder.loadTexts: cpfrTCMAttempts.setDescription('This object indicates the number of attempts to send an active probe to a target for this TC.')
cpfrTCMPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 13, 1, 7), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setUnits('Packets/probe').setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrTCMPackets.setStatus('current')
if mibBuilder.loadTexts: cpfrTCMPackets.setDescription('This object indicates the number packets per jitter probe.')
cpfrTCMPassiveSTUnreachableAvg = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 13, 1, 8), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setUnits('flows-per-million').setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrTCMPassiveSTUnreachableAvg.setStatus('current')
if mibBuilder.loadTexts: cpfrTCMPassiveSTUnreachableAvg.setDescription('This object indicates the number of the average short term unreachable targets in passive mode.')
cpfrTCMPassiveSTDelayAvg = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 13, 1, 9), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrTCMPassiveSTDelayAvg.setStatus('current')
if mibBuilder.loadTexts: cpfrTCMPassiveSTDelayAvg.setDescription('This object indicates the short term delay as measured by Netflow. The short term interval is 5 minutes.')
cpfrTCMPassiveSTLossAvg = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 13, 1, 10), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrTCMPassiveSTLossAvg.setStatus('current')
if mibBuilder.loadTexts: cpfrTCMPassiveSTLossAvg.setDescription('This object indicates the number of short term packets lost in passive mode.')
cpfrTCMActiveSTUnreachableAvg = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 13, 1, 11), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setUnits('flows-per-million').setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrTCMActiveSTUnreachableAvg.setStatus('current')
if mibBuilder.loadTexts: cpfrTCMActiveSTUnreachableAvg.setDescription('This object indicates the number of short term unreachable packets in active mode.')
cpfrTCMActiveSTDelayAvg = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 13, 1, 12), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrTCMActiveSTDelayAvg.setStatus('current')
if mibBuilder.loadTexts: cpfrTCMActiveSTDelayAvg.setDescription('This object indicates the short term delay in milliseconds in active mode.')
cpfrTCMPassiveLTUnreachableAvg = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 13, 1, 13), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrTCMPassiveLTUnreachableAvg.setStatus('current')
if mibBuilder.loadTexts: cpfrTCMPassiveLTUnreachableAvg.setDescription('This object indicates the number of long term unreachable packets in flows-per-million in passive mode.')
cpfrTCMPassiveLTDelayAvg = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 13, 1, 14), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrTCMPassiveLTDelayAvg.setStatus('current')
if mibBuilder.loadTexts: cpfrTCMPassiveLTDelayAvg.setDescription('This object indicates the long term delay in milliseconds in passive mode.')
cpfrTCMPassiveLTLossAvg = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 13, 1, 15), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrTCMPassiveLTLossAvg.setStatus('current')
if mibBuilder.loadTexts: cpfrTCMPassiveLTLossAvg.setDescription('This object indicates the number of packets lost over the long term in packets-per-million in passive mode.')
cpfrTCMActiveLTUnreachableAvg = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 13, 1, 16), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrTCMActiveLTUnreachableAvg.setStatus('current')
if mibBuilder.loadTexts: cpfrTCMActiveLTUnreachableAvg.setDescription('This object indicates the number of long term unreachable packets in flows-per-million in active mode.')
cpfrTCMActiveLTDelayAvg = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 13, 1, 17), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrTCMActiveLTDelayAvg.setStatus('current')
if mibBuilder.loadTexts: cpfrTCMActiveLTDelayAvg.setDescription('This object indicates the long term delay in milliseconds in active mode.')
cpfrLinkGroupExitTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 14), )
if mibBuilder.loadTexts: cpfrLinkGroupExitTable.setStatus('current')
if mibBuilder.loadTexts: cpfrLinkGroupExitTable.setDescription('This table lists the link group instances created by the system. It has an expansion dependent relationship on cpfrExitTable, containing zero or more rows for each cpfrExitEntry.')
cpfrLinkGroupExitEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 14, 1), ).setIndexNames((0, "CISCO-PFR-MIB", "cpfrMCIndex"), (0, "CISCO-PFR-MIB", "cpfrLinkGroupName"), (0, "CISCO-PFR-MIB", "cpfrLinkGroupIndex"))
if mibBuilder.loadTexts: cpfrLinkGroupExitEntry.setStatus('current')
if mibBuilder.loadTexts: cpfrLinkGroupExitEntry.setDescription("An entry describing a link group configured for a PfR monitored or controlled external exit. A peer SNMP entity may create a link group for a PfR monitored or controlled exit by setting an instance of cpfrLinkGroupRowStatus to 'createAndWait' or 'createAndGo'. Observe that an implementation that does not support these option must specify these limitations in an agent capability statement. Other management entities (e.g., the local console) may create a link group for a PfR monitored or controlled external exit. In these cases, the system must automatically create a row in the cpfrLinkGroupExitTable. A peer SNMP entity may destroy a link group from a PfR monitored or controlled external exit by setting the corresponding instance of cpfrLinkGroupRowStatus to 'destroy'. Observe that an implementation that does not support this option must specify this limitation in an agent capability statement. Other management entities may destroy a link group from a PfR monitored or controlled external exit. In these cases, the system must automatically destroy the corresponding row in the cpfrLinkGroupExitTable. The system automatically destroys rows when the system or EMS/NMS destroys the corresponding entry in cpfrExitEntry.")
cpfrLinkGroupName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 14, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 64)))
if mibBuilder.loadTexts: cpfrLinkGroupName.setStatus('current')
if mibBuilder.loadTexts: cpfrLinkGroupName.setDescription('This object indicates the name of a link-group.')
cpfrLinkGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 14, 1, 2), Unsigned32())
if mibBuilder.loadTexts: cpfrLinkGroupIndex.setStatus('current')
if mibBuilder.loadTexts: cpfrLinkGroupIndex.setDescription('This object indicates a unique arbitrary number identifying a specific instance in a link-group with the identical name.')
cpfrLinkGroupStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 14, 1, 3), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrLinkGroupStorageType.setStatus('current')
if mibBuilder.loadTexts: cpfrLinkGroupStorageType.setDescription('This object specifies the memory realization of the row. The following columnar objects are allowed to be writable when the storageType of this entry is permanent(4): cpfrLinkGroupBRIndex, cpfrLinkGroupExitIndex.')
cpfrLinkGroupRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 14, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrLinkGroupRowStatus.setStatus('current')
if mibBuilder.loadTexts: cpfrLinkGroupRowStatus.setDescription('This object specifies the status of a NBAR application list. The following columnar objects must be valid in order to transition the row to the active state: None. The following columnar objects can be modified when the row is in the active state: None')
cpfrLinkGroupBRIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 14, 1, 5), PfrBorderRouterIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrLinkGroupBRIndex.setStatus('current')
if mibBuilder.loadTexts: cpfrLinkGroupBRIndex.setDescription('This object specifies the PfR BR on which the exit related to this link group is configured.')
cpfrLinkGroupExitIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 14, 1, 6), PfrExitIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrLinkGroupExitIndex.setStatus('current')
if mibBuilder.loadTexts: cpfrLinkGroupExitIndex.setDescription('This object specifies the exit, identified by this index, in combination with cpfrLinkGroupBRIndex, in cpfrExitTable.')
cpfrLinkGroupType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 14, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("primaryLinkGroup", 1), ("fallbackLinkGroup", 2), ("none", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpfrLinkGroupType.setStatus('current')
if mibBuilder.loadTexts: cpfrLinkGroupType.setDescription("This object indicates PfR Link-Group type. 'primaryLinkGroup' primary link-group 'fallbackLinkGroup' fallback link-group 'none' There is no link-group.")
cpfrNbarApplListTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 15), )
if mibBuilder.loadTexts: cpfrNbarApplListTable.setStatus('current')
if mibBuilder.loadTexts: cpfrNbarApplListTable.setDescription('This table lists the NBAR list instances created by the system. This table has an expansion dependent relationship on cpfrMatchTable and cpfrLearnListTable, containing zero or more rows for each cpfrMatchEntry and cpfrLearnListEntry.')
cpfrNbarApplListEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 15, 1), ).setIndexNames((0, "CISCO-PFR-MIB", "cpfrNbarApplListName"), (0, "CISCO-PFR-MIB", "cpfrNbarApplIndex"))
if mibBuilder.loadTexts: cpfrNbarApplListEntry.setStatus('current')
if mibBuilder.loadTexts: cpfrNbarApplListEntry.setDescription("An entry describing a NBAR application configured in PfR. A peer SNMP entity may create an NBAR application entry by setting an instance of cpfrNbarApplListRowStatus to 'createAndWait' or 'createAndGo'. Observe that an implementation that does not support these option must specify these limitations in an agent capability statement. Other management entities (e.g., the local console) may create a NBAR application. In these cases, the system must automatically create a row in the cpfrNbarApplListTable. A peer SNMP entity may destroy a NBAR application by setting the corresponding instance of cpfrNbarApplListRow Status to 'destroy'. Observe that an implementation that does not support this option must specify this limitation in an agent capability statement. Other management entities may destroy an NBAR application. In these cases, the system must automatically destroy the corresponding row in the cpfrNbarApplListTable. The system automatically destroys rows when the system or EMS/NMS destroys the corresponding entry in cpfrMatchEntry and cpfrLearnListEntry.")
cpfrNbarApplListName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 15, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 64)))
if mibBuilder.loadTexts: cpfrNbarApplListName.setStatus('current')
if mibBuilder.loadTexts: cpfrNbarApplListName.setDescription('This object indicates the name of a NBAR application list.')
cpfrNbarApplIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 15, 1, 2), Unsigned32())
if mibBuilder.loadTexts: cpfrNbarApplIndex.setStatus('current')
if mibBuilder.loadTexts: cpfrNbarApplIndex.setDescription('This object indicates a unique arbitrary number identifying a specific protocol in a PfR NBAR Application List.')
cpfrNbarApplListStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 15, 1, 3), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrNbarApplListStorageType.setStatus('current')
if mibBuilder.loadTexts: cpfrNbarApplListStorageType.setDescription('This object specifies the memory realization of the row. The following columnar objects are allowed to be writable when the storageType of this conceptual row is permanent(4): cpfrNbarApplPdIndex.')
cpfrNbarApplListRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 15, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrNbarApplListRowStatus.setStatus('current')
if mibBuilder.loadTexts: cpfrNbarApplListRowStatus.setDescription('This object specifies the status of a NBAR application list. The following columnar objects must be valid in order to transition the row to the active state: None. The following columnar objects can be modified when the row is in the active state: None')
cpfrNbarApplPdIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 772, 1, 15, 1, 5), CiscoPdProtocolIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpfrNbarApplPdIndex.setStatus('current')
if mibBuilder.loadTexts: cpfrNbarApplPdIndex.setDescription('This object indicates the application or protocol recognized by NBAR. The value of this object points to an entry in cnpdSupportedProtocolsTable, which describes the recognized protocol and is defined in CISCO-NBAR-PROTOCOL-DISCOVERY-MIB.')
ciscoPfrMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 772, 2, 1))
cpfrMCStatusChangeNotify = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 772, 0, 1)).setObjects(("CISCO-PFR-MIB", "cpfrMCChangeConfigType"), ("CISCO-PFR-MIB", "cpfrMCChangeConfigValue"))
if mibBuilder.loadTexts: cpfrMCStatusChangeNotify.setStatus('current')
if mibBuilder.loadTexts: cpfrMCStatusChangeNotify.setDescription('The device generates this notification when one of cpfrMCLoggingAdminStatus, cpfrMCAdminStatus, cpfrMCControlMode, cpfrMCClear, on PfR master controller is changed.')
cpfrBRStatusChangeNotify = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 772, 0, 2)).setObjects(("CISCO-PFR-MIB", "cpfrBRAddressType"), ("CISCO-PFR-MIB", "cpfrBRAddress"), ("CISCO-PFR-MIB", "cpfrBROperStatus"), ("CISCO-PFR-MIB", "cpfrBRConnStatus"), ("CISCO-PFR-MIB", "cpfrBRConnFailureReason"))
if mibBuilder.loadTexts: cpfrBRStatusChangeNotify.setStatus('current')
if mibBuilder.loadTexts: cpfrBRStatusChangeNotify.setDescription('The device generates this notification when the master controller detects a status change with a border router.')
cpfrExitStatusChangeNotify = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 772, 0, 3)).setObjects(("CISCO-PFR-MIB", "cpfrExitName"), ("CISCO-PFR-MIB", "cpfrExitType"), ("CISCO-PFR-MIB", "cpfrExitOperStatus"), ("CISCO-PFR-MIB", "cpfrBRAddressType"), ("CISCO-PFR-MIB", "cpfrBRAddress"))
if mibBuilder.loadTexts: cpfrExitStatusChangeNotify.setStatus('current')
if mibBuilder.loadTexts: cpfrExitStatusChangeNotify.setDescription('The device generates this notification when the master controller detects a status change with an exit link.')
cpfrTrafficClassEventNotify = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 772, 0, 4)).setObjects(("CISCO-PFR-MIB", "cpfrTCStatus"), ("CISCO-PFR-MIB", "cpfrTCSLastOOPReason"), ("CISCO-PFR-MIB", "cpfrBRAddressType"), ("CISCO-PFR-MIB", "cpfrBRAddress"), ("CISCO-PFR-MIB", "cpfrExitName"), ("CISCO-PFR-MIB", "cpfrLinkGroupType"))
if mibBuilder.loadTexts: cpfrTrafficClassEventNotify.setStatus('current')
if mibBuilder.loadTexts: cpfrTrafficClassEventNotify.setDescription('The device generates this notification when the master controller detects a traffic class status event.')
cpfrTCInpolicyThresholdBelowNotify = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 772, 0, 5)).setObjects(("CISCO-PFR-MIB", "cpfrMapEventNotifCtrlType"), ("CISCO-PFR-MIB", "cpfrMapEventNotifCtrlThreshold"), ("CISCO-PFR-MIB", "cpfrMapEventTCCount"))
if mibBuilder.loadTexts: cpfrTCInpolicyThresholdBelowNotify.setStatus('current')
if mibBuilder.loadTexts: cpfrTCInpolicyThresholdBelowNotify.setDescription('The device generates this notification, when the master controller detects number of in-policy traffic class falls below the configured threshold.')
cpfrTCPrimaryThresholdBelowNotify = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 772, 0, 6)).setObjects(("CISCO-PFR-MIB", "cpfrMapEventNotifCtrlType"), ("CISCO-PFR-MIB", "cpfrMapEventNotifCtrlThreshold"), ("CISCO-PFR-MIB", "cpfrMapEventTCCount"))
if mibBuilder.loadTexts: cpfrTCPrimaryThresholdBelowNotify.setStatus('current')
if mibBuilder.loadTexts: cpfrTCPrimaryThresholdBelowNotify.setDescription('The device generates this notification, when the master controller detects number of in-policy traffic classes at primary link group falls below the configured threshold.')
ciscoPfrMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 772, 2, 2))
ciscoPfrMIBCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 772, 2, 1, 1)).setObjects(("CISCO-PFR-MIB", "cpfrMasterControllerGroup"), ("CISCO-PFR-MIB", "cpfrBorderRouterGroup"), ("CISCO-PFR-MIB", "cpfrTrafficClassGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoPfrMIBCompliance = ciscoPfrMIBCompliance.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoPfrMIBCompliance.setDescription('This compliance statement specifies the minimal requirements an implementation must meet in order to claim full compliance with the definition of the CISCO-PFR-MIB.')
ciscoPfrMIBComplianceRev1 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 772, 2, 1, 2)).setObjects(("CISCO-PFR-MIB", "cpfrMasterControllerGroup"), ("CISCO-PFR-MIB", "cpfrBorderRouterGroup"), ("CISCO-PFR-MIB", "cpfrTrafficClassGroup"), ("CISCO-PFR-MIB", "cpfrMasterControllerGroupRev1"), ("CISCO-PFR-MIB", "cpfrBorderRouterGroupRev1"), ("CISCO-PFR-MIB", "cpfrMCNotificationGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoPfrMIBComplianceRev1 = ciscoPfrMIBComplianceRev1.setStatus('current')
if mibBuilder.loadTexts: ciscoPfrMIBComplianceRev1.setDescription('This compliance statement specifies the new minimal requirements an implementation must meet in order to claim full compliance with the definition of the CISCO-PFR-MIB.')
cpfrMasterControllerGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 772, 2, 2, 1)).setObjects(("CISCO-PFR-MIB", "cpfrMCStorageType"), ("CISCO-PFR-MIB", "cpfrMCRowStatus"), ("CISCO-PFR-MIB", "cpfrMCKeepAliveTimer"), ("CISCO-PFR-MIB", "cpfrMCMaxPrefixTotal"), ("CISCO-PFR-MIB", "cpfrMCMaxPrefixLearn"), ("CISCO-PFR-MIB", "cpfrMCEntranceLinksMaxUtil"), ("CISCO-PFR-MIB", "cpfrMCExitLinksMaxUtil"), ("CISCO-PFR-MIB", "cpfrMCPortNumber"), ("CISCO-PFR-MIB", "cpfrMCTracerouteProbeDelay"), ("CISCO-PFR-MIB", "cpfrMCRsvpPostDialDelay"), ("CISCO-PFR-MIB", "cpfrMCRsvpSignalingRetries"), ("CISCO-PFR-MIB", "cpfrMCNetflowExporter"), ("CISCO-PFR-MIB", "cpfrMCAdminStatus"), ("CISCO-PFR-MIB", "cpfrMCOperStatus"), ("CISCO-PFR-MIB", "cpfrMCConnStatus"), ("CISCO-PFR-MIB", "cpfrMCNumofBorderRouters"), ("CISCO-PFR-MIB", "cpfrMCNumofExits"), ("CISCO-PFR-MIB", "cpfrMCLearnState"), ("CISCO-PFR-MIB", "cpfrMCLearnStateTimeRemain"), ("CISCO-PFR-MIB", "cpfrMCPrefixCount"), ("CISCO-PFR-MIB", "cpfrMCPrefixLearned"), ("CISCO-PFR-MIB", "cpfrMCPrefixConfigured"), ("CISCO-PFR-MIB", "cpfrMCPbrMet"), ("CISCO-PFR-MIB", "cpfrMapStorageType"), ("CISCO-PFR-MIB", "cpfrMapRowStatus"), ("CISCO-PFR-MIB", "cpfrMapName"), ("CISCO-PFR-MIB", "cpfrMapBackoffMinTimer"), ("CISCO-PFR-MIB", "cpfrMapBackoffMaxTimer"), ("CISCO-PFR-MIB", "cpfrMapBackoffStepTimer"), ("CISCO-PFR-MIB", "cpfrMapDelayType"), ("CISCO-PFR-MIB", "cpfrMapDelayRelativePercent"), ("CISCO-PFR-MIB", "cpfrMapDelayThresholdMax"), ("CISCO-PFR-MIB", "cpfrMapHolddownTimer"), ("CISCO-PFR-MIB", "cpfrMapPrefixForwardInterface"), ("CISCO-PFR-MIB", "cpfrMapJitterThresholdMax"), ("CISCO-PFR-MIB", "cpfrMapLinkGroupName"), ("CISCO-PFR-MIB", "cpfrMapFallbackLinkGroupName"), ("CISCO-PFR-MIB", "cpfrMapLossType"), ("CISCO-PFR-MIB", "cpfrMapLossRelativeAvg"), ("CISCO-PFR-MIB", "cpfrMapLossThresholdMax"), ("CISCO-PFR-MIB", "cpfrMapModeMonitor"), ("CISCO-PFR-MIB", "cpfrMapModeRouteOpts"), ("CISCO-PFR-MIB", "cpfrMapRouteMetricBgpLocalPref"), ("CISCO-PFR-MIB", "cpfrMapRouteMetricEigrpTagCommunity"), ("CISCO-PFR-MIB", "cpfrMapRouteMetricStaticTag"), ("CISCO-PFR-MIB", "cpfrMapModeSelectExitType"), ("CISCO-PFR-MIB", "cpfrMapMOSThresholdMin"), ("CISCO-PFR-MIB", "cpfrMapMOSPercentage"), ("CISCO-PFR-MIB", "cpfrMapNextHopAddressType"), ("CISCO-PFR-MIB", "cpfrMapNextHopAddress"), ("CISCO-PFR-MIB", "cpfrMapPeriodicTimer"), ("CISCO-PFR-MIB", "cpfrMapActiveProbeFrequency"), ("CISCO-PFR-MIB", "cpfrMapActiveProbePackets"), ("CISCO-PFR-MIB", "cpfrMapTracerouteReporting"), ("CISCO-PFR-MIB", "cpfrMapUnreachableType"), ("CISCO-PFR-MIB", "cpfrMapUnreachableRelativeAvg"), ("CISCO-PFR-MIB", "cpfrMapUnreachableThresholdMax"), ("CISCO-PFR-MIB", "cpfrMapRoundRobinResolver"), ("CISCO-PFR-MIB", "cpfrMatchValid"), ("CISCO-PFR-MIB", "cpfrMatchAddrAccessList"), ("CISCO-PFR-MIB", "cpfrMatchAddrPrefixList"), ("CISCO-PFR-MIB", "cpfrMatchAddrPrefixInside"), ("CISCO-PFR-MIB", "cpfrMatchLearnMode"), ("CISCO-PFR-MIB", "cpfrMatchLearnListName"), ("CISCO-PFR-MIB", "cpfrMatchTCNbarListName"), ("CISCO-PFR-MIB", "cpfrMatchTCNbarApplPfxList"), ("CISCO-PFR-MIB", "cpfrMatchTCPfxInside"), ("CISCO-PFR-MIB", "cpfrLearnListStorageType"), ("CISCO-PFR-MIB", "cpfrLearnListRowStatus"), ("CISCO-PFR-MIB", "cpfrLearnListReferenceName"), ("CISCO-PFR-MIB", "cpfrLearnListSequenceNum"), ("CISCO-PFR-MIB", "cpfrLearnListMethod"), ("CISCO-PFR-MIB", "cpfrLearnListAclName"), ("CISCO-PFR-MIB", "cpfrLearnListPfxName"), ("CISCO-PFR-MIB", "cpfrLearnListPfxInside"), ("CISCO-PFR-MIB", "cpfrLearnListNbarAppl"), ("CISCO-PFR-MIB", "cpfrLearnListFilterPfxName"), ("CISCO-PFR-MIB", "cpfrActiveProbeStorageType"), ("CISCO-PFR-MIB", "cpfrActiveProbeRowStatus"), ("CISCO-PFR-MIB", "cpfrActiveProbeType"), ("CISCO-PFR-MIB", "cpfrActiveProbeTargetAddressType"), ("CISCO-PFR-MIB", "cpfrActiveProbeTargetAddress"), ("CISCO-PFR-MIB", "cpfrActiveProbeTargetPortNumber"), ("CISCO-PFR-MIB", "cpfrActiveProbePfrMapIndex"), ("CISCO-PFR-MIB", "cpfrActiveProbeDscpValue"), ("CISCO-PFR-MIB", "cpfrActiveProbeCodecName"), ("CISCO-PFR-MIB", "cpfrActiveProbeMapIndex"), ("CISCO-PFR-MIB", "cpfrActiveProbeMapPolicyIndex"), ("CISCO-PFR-MIB", "cpfrActiveProbeAdminStatus"), ("CISCO-PFR-MIB", "cpfrActiveProbeOperStatus"), ("CISCO-PFR-MIB", "cpfrActiveProbeAssignedPfxAddressType"), ("CISCO-PFR-MIB", "cpfrActiveProbeAssignedPfxAddress"), ("CISCO-PFR-MIB", "cpfrActiveProbeAssignedPfxLen"), ("CISCO-PFR-MIB", "cpfrActiveProbeMethod"), ("CISCO-PFR-MIB", "cpfrResolveStorageType"), ("CISCO-PFR-MIB", "cpfrResolveRowStatus"), ("CISCO-PFR-MIB", "cpfrResolvePolicyType"), ("CISCO-PFR-MIB", "cpfrResolveVariance"), ("CISCO-PFR-MIB", "cpfrResolveMapIndex"), ("CISCO-PFR-MIB", "cpfrResolveMapPolicyIndex"), ("CISCO-PFR-MIB", "cpfrLearnAggregationType"), ("CISCO-PFR-MIB", "cpfrLearnAggregationPrefixLen"), ("CISCO-PFR-MIB", "cpfrLearnMethod"), ("CISCO-PFR-MIB", "cpfrLearnExpireType"), ("CISCO-PFR-MIB", "cpfrLearnExpireSessionNum"), ("CISCO-PFR-MIB", "cpfrLearnExpireTime"), ("CISCO-PFR-MIB", "cpfrLearnMonitorPeriod"), ("CISCO-PFR-MIB", "cpfrLearnPeriodInterval"), ("CISCO-PFR-MIB", "cpfrLearnPrefixesNumber"), ("CISCO-PFR-MIB", "cpfrLearnAggAccesslistName"), ("CISCO-PFR-MIB", "cpfrLearnFilterAccessListName"), ("CISCO-PFR-MIB", "cpfrNbarApplListStorageType"), ("CISCO-PFR-MIB", "cpfrNbarApplListRowStatus"), ("CISCO-PFR-MIB", "cpfrNbarApplPdIndex"), ("CISCO-PFR-MIB", "cpfrResolvePriority"), ("CISCO-PFR-MIB", "cpfrMCMapIndex"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cpfrMasterControllerGroup = cpfrMasterControllerGroup.setStatus('current')
if mibBuilder.loadTexts: cpfrMasterControllerGroup.setDescription('This group contains objects describing PfR MCs and policy maps.')
cpfrBorderRouterGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 772, 2, 2, 2)).setObjects(("CISCO-PFR-MIB", "cpfrBRStorageType"), ("CISCO-PFR-MIB", "cpfrBRRowStatus"), ("CISCO-PFR-MIB", "cpfrBRAddressType"), ("CISCO-PFR-MIB", "cpfrBRAddress"), ("CISCO-PFR-MIB", "cpfrBRKeyName"), ("CISCO-PFR-MIB", "cpfrBROperStatus"), ("CISCO-PFR-MIB", "cpfrBRConnStatus"), ("CISCO-PFR-MIB", "cpfrBRUpTime"), ("CISCO-PFR-MIB", "cpfrBRConnFailureReason"), ("CISCO-PFR-MIB", "cpfrBRAuthFailCount"), ("CISCO-PFR-MIB", "cpfrExitStorageType"), ("CISCO-PFR-MIB", "cpfrExitRowStatus"), ("CISCO-PFR-MIB", "cpfrExitName"), ("CISCO-PFR-MIB", "cpfrExitType"), ("CISCO-PFR-MIB", "cpfrDowngradeBgpCommunity"), ("CISCO-PFR-MIB", "cpfrExitMaxUtilRxType"), ("CISCO-PFR-MIB", "cpfrExitMaxUtilRxAbsolute"), ("CISCO-PFR-MIB", "cpfrExitMaxUtilRxPercentage"), ("CISCO-PFR-MIB", "cpfrExitMaxUtilTxType"), ("CISCO-PFR-MIB", "cpfrExitMaxUtilTxAbsolute"), ("CISCO-PFR-MIB", "cpfrExitMaxUtilTxPercentage"), ("CISCO-PFR-MIB", "cpfrExitCostCalcMethod"), ("CISCO-PFR-MIB", "cpfrExitCostDiscard"), ("CISCO-PFR-MIB", "cpfrExitCostDiscardType"), ("CISCO-PFR-MIB", "cpfrExitCostDiscardAbsolute"), ("CISCO-PFR-MIB", "cpfrExitCostDiscardPercent"), ("CISCO-PFR-MIB", "cpfrExitCostEndDayOfMonth"), ("CISCO-PFR-MIB", "cpfrExitCostEndOffsetType"), ("CISCO-PFR-MIB", "cpfrExitCostEndOffset"), ("CISCO-PFR-MIB", "cpfrExitCostFixedFeeCost"), ("CISCO-PFR-MIB", "cpfrExitCostNickName"), ("CISCO-PFR-MIB", "cpfrExitCostSamplingPeriod"), ("CISCO-PFR-MIB", "cpfrExitCostRollupPeriod"), ("CISCO-PFR-MIB", "cpfrExitCostSummerTimeStart"), ("CISCO-PFR-MIB", "cpfrExitCostSummerTimeOffset"), ("CISCO-PFR-MIB", "cpfrExitCostSummerTimeEnd"), ("CISCO-PFR-MIB", "cpfrExitCapacity"), ("CISCO-PFR-MIB", "cpfrExitRxBandwidth"), ("CISCO-PFR-MIB", "cpfrExitTxBandwidth"), ("CISCO-PFR-MIB", "cpfrExitTxLoad"), ("CISCO-PFR-MIB", "cpfrExitNickName"), ("CISCO-PFR-MIB", "cpfrExitCost1"), ("CISCO-PFR-MIB", "cpfrExitSustainedUtil1"), ("CISCO-PFR-MIB", "cpfrExitCost2"), ("CISCO-PFR-MIB", "cpfrExitSustainedUtil2"), ("CISCO-PFR-MIB", "cpfrExitCost3"), ("CISCO-PFR-MIB", "cpfrExitSustainedUtil3"), ("CISCO-PFR-MIB", "cpfrExitRollupTotal"), ("CISCO-PFR-MIB", "cpfrExitRollupDiscard"), ("CISCO-PFR-MIB", "cpfrExitRollupLeft"), ("CISCO-PFR-MIB", "cpfrExitRollupCollected"), ("CISCO-PFR-MIB", "cpfrExitRollupMomTgtUtil"), ("CISCO-PFR-MIB", "cpfrExitRollupStartingTgtUtil"), ("CISCO-PFR-MIB", "cpfrExitRollupCurrentTgtUtil"), ("CISCO-PFR-MIB", "cpfrExitRollupCumRxBytes"), ("CISCO-PFR-MIB", "cpfrExitRollupCumTxBytes"), ("CISCO-PFR-MIB", "cpfrExitRollupTimeRemain"), ("CISCO-PFR-MIB", "cpfrExitOperStatus"), ("CISCO-PFR-MIB", "cpfrExitRsvpBandwidthPool"), ("CISCO-PFR-MIB", "cpfrExitCostTierStorageType"), ("CISCO-PFR-MIB", "cpfrExitCostTierRowStatus"), ("CISCO-PFR-MIB", "cpfrExitCostTierFee"), ("CISCO-PFR-MIB", "cpfrLinkGroupStorageType"), ("CISCO-PFR-MIB", "cpfrLinkGroupRowStatus"), ("CISCO-PFR-MIB", "cpfrLinkGroupBRIndex"), ("CISCO-PFR-MIB", "cpfrLinkGroupExitIndex"), ("CISCO-PFR-MIB", "cpfrExitRxLoad"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cpfrBorderRouterGroup = cpfrBorderRouterGroup.setStatus('current')
if mibBuilder.loadTexts: cpfrBorderRouterGroup.setDescription('This group contains objects describing PfR Border Router and Exits.')
cpfrTrafficClassGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 772, 2, 2, 3)).setObjects(("CISCO-PFR-MIB", "cpfrTrafficClassValid"), ("CISCO-PFR-MIB", "cpfrTCSrcPrefixType"), ("CISCO-PFR-MIB", "cpfrTCSrcPrefix"), ("CISCO-PFR-MIB", "cpfrTCSrcPrefixLen"), ("CISCO-PFR-MIB", "cpfrTCSrcMinPort"), ("CISCO-PFR-MIB", "cpfrTCDstPrefixType"), ("CISCO-PFR-MIB", "cpfrTCDstPrefix"), ("CISCO-PFR-MIB", "cpfrTCDstPrefixLen"), ("CISCO-PFR-MIB", "cpfrTCDstMinPort"), ("CISCO-PFR-MIB", "cpfrTCDscpValue"), ("CISCO-PFR-MIB", "cpfrTCProtocol"), ("CISCO-PFR-MIB", "cpfrTCNbarApplication"), ("CISCO-PFR-MIB", "cpfrTCBRIndex"), ("CISCO-PFR-MIB", "cpfrTCBRExitIndex"), ("CISCO-PFR-MIB", "cpfrTCMapIndex"), ("CISCO-PFR-MIB", "cpfrTCMapPolicyIndex"), ("CISCO-PFR-MIB", "cpfrTCStatus"), ("CISCO-PFR-MIB", "cpfrTCSType"), ("CISCO-PFR-MIB", "cpfrTCSLearnListIndex"), ("CISCO-PFR-MIB", "cpfrTCSTimeOnCurrExit"), ("CISCO-PFR-MIB", "cpfrTCSControlState"), ("CISCO-PFR-MIB", "cpfrTCSControlBy"), ("CISCO-PFR-MIB", "cpfrTCSTimeRemainCurrState"), ("CISCO-PFR-MIB", "cpfrTCSLastOOPEventTime"), ("CISCO-PFR-MIB", "cpfrTCSLastOOPReason"), ("CISCO-PFR-MIB", "cpfrTCSLastRouteChangeEvent"), ("CISCO-PFR-MIB", "cpfrTCSLastRouteChangeReason"), ("CISCO-PFR-MIB", "cpfrTCMLastUpdateTime"), ("CISCO-PFR-MIB", "cpfrTCMAge"), ("CISCO-PFR-MIB", "cpfrTCMetricsValid"), ("CISCO-PFR-MIB", "cpfrTCMActiveSTJitterAvg"), ("CISCO-PFR-MIB", "cpfrTCMMOSPercentage"), ("CISCO-PFR-MIB", "cpfrTCMAttempts"), ("CISCO-PFR-MIB", "cpfrTCMPackets"), ("CISCO-PFR-MIB", "cpfrTCMPassiveSTUnreachableAvg"), ("CISCO-PFR-MIB", "cpfrTCMPassiveSTDelayAvg"), ("CISCO-PFR-MIB", "cpfrTCMPassiveSTLossAvg"), ("CISCO-PFR-MIB", "cpfrTCMActiveSTUnreachableAvg"), ("CISCO-PFR-MIB", "cpfrTCMActiveSTDelayAvg"), ("CISCO-PFR-MIB", "cpfrTCMPassiveLTUnreachableAvg"), ("CISCO-PFR-MIB", "cpfrTCMPassiveLTDelayAvg"), ("CISCO-PFR-MIB", "cpfrTCMPassiveLTLossAvg"), ("CISCO-PFR-MIB", "cpfrTCMActiveLTUnreachableAvg"), ("CISCO-PFR-MIB", "cpfrTCMActiveLTDelayAvg"), ("CISCO-PFR-MIB", "cpfrTCSrcMaxPort"), ("CISCO-PFR-MIB", "cpfrTCDstMaxPort"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cpfrTrafficClassGroup = cpfrTrafficClassGroup.setStatus('current')
if mibBuilder.loadTexts: cpfrTrafficClassGroup.setDescription('This group contains objects describing PfR TCs.')
cpfrMasterControllerGroupRev1 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 772, 2, 2, 4)).setObjects(("CISCO-PFR-MIB", "cpfrMCLoggingAdminStatus"), ("CISCO-PFR-MIB", "cpfrMCControlMode"), ("CISCO-PFR-MIB", "cpfrMCClear"), ("CISCO-PFR-MIB", "cpfrMapEventNotifCtrlType"), ("CISCO-PFR-MIB", "cpfrMapEventNotifCtrlThreshold"), ("CISCO-PFR-MIB", "cpfrMapEventTCCount"), ("CISCO-PFR-MIB", "cpfrMCLastClearTime"), ("CISCO-PFR-MIB", "cpfrMCNotifisControl"), ("CISCO-PFR-MIB", "cpfrMCChangeConfigType"), ("CISCO-PFR-MIB", "cpfrMCChangeConfigValue"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cpfrMasterControllerGroupRev1 = cpfrMasterControllerGroupRev1.setStatus('current')
if mibBuilder.loadTexts: cpfrMasterControllerGroupRev1.setDescription('This group contains new objects describing PfR MCs and policy maps.')
cpfrBorderRouterGroupRev1 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 772, 2, 2, 5)).setObjects(("CISCO-PFR-MIB", "cpfrLinkGroupType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cpfrBorderRouterGroupRev1 = cpfrBorderRouterGroupRev1.setStatus('current')
if mibBuilder.loadTexts: cpfrBorderRouterGroupRev1.setDescription('This group contains objects describing PfR Border Router and Exits.')
cpfrMCNotificationGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 9, 9, 772, 2, 2, 6)).setObjects(("CISCO-PFR-MIB", "cpfrBRStatusChangeNotify"), ("CISCO-PFR-MIB", "cpfrExitStatusChangeNotify"), ("CISCO-PFR-MIB", "cpfrTrafficClassEventNotify"), ("CISCO-PFR-MIB", "cpfrTCInpolicyThresholdBelowNotify"), ("CISCO-PFR-MIB", "cpfrTCPrimaryThresholdBelowNotify"), ("CISCO-PFR-MIB", "cpfrMCStatusChangeNotify"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cpfrMCNotificationGroup = cpfrMCNotificationGroup.setStatus('current')
if mibBuilder.loadTexts: cpfrMCNotificationGroup.setDescription('A collection of PfR MC notifications.')
mibBuilder.exportSymbols("CISCO-PFR-MIB", cpfrExitRollupTotal=cpfrExitRollupTotal, cpfrExitSustainedUtil3=cpfrExitSustainedUtil3, cpfrExitStorageType=cpfrExitStorageType, cpfrExitTxBandwidth=cpfrExitTxBandwidth, cpfrLearnTable=cpfrLearnTable, cpfrMapNextHopAddress=cpfrMapNextHopAddress, cpfrResolvePolicyType=cpfrResolvePolicyType, cpfrBRRowStatus=cpfrBRRowStatus, ciscoPfrMIBGroups=ciscoPfrMIBGroups, ciscoPfrMIBNotifs=ciscoPfrMIBNotifs, cpfrBRAuthFailCount=cpfrBRAuthFailCount, cpfrExitNickName=cpfrExitNickName, cpfrExitSustainedUtil1=cpfrExitSustainedUtil1, cpfrMapEventNotifCtrlThreshold=cpfrMapEventNotifCtrlThreshold, PfrLearnListIndex=PfrLearnListIndex, PfrMapPolicyIndex=PfrMapPolicyIndex, cpfrMasterControllerGroupRev1=cpfrMasterControllerGroupRev1, cpfrMCPrefixLearned=cpfrMCPrefixLearned, cpfrMapDelayRelativePercent=cpfrMapDelayRelativePercent, cpfrMCLearnStateTimeRemain=cpfrMCLearnStateTimeRemain, PfrResolvePolicyType=PfrResolvePolicyType, cpfrExitMaxUtilTxPercentage=cpfrExitMaxUtilTxPercentage, cpfrLinkGroupRowStatus=cpfrLinkGroupRowStatus, cpfrBorderRouterGroup=cpfrBorderRouterGroup, cpfrExitCostDiscardAbsolute=cpfrExitCostDiscardAbsolute, cpfrMapName=cpfrMapName, cpfrTCDstMinPort=cpfrTCDstMinPort, cpfrLinkGroupExitIndex=cpfrLinkGroupExitIndex, cpfrActiveProbeTable=cpfrActiveProbeTable, cpfrMCPbrMet=cpfrMCPbrMet, cpfrNbarApplListRowStatus=cpfrNbarApplListRowStatus, cpfrMCStorageType=cpfrMCStorageType, cpfrTCMActiveLTDelayAvg=cpfrTCMActiveLTDelayAvg, cpfrMCEntranceLinksMaxUtil=cpfrMCEntranceLinksMaxUtil, cpfrActiveProbePfrMapIndex=cpfrActiveProbePfrMapIndex, cpfrLearnAggAccesslistName=cpfrLearnAggAccesslistName, cpfrMapDelayType=cpfrMapDelayType, cpfrMCExitLinksMaxUtil=cpfrMCExitLinksMaxUtil, cpfrResolveMapPolicyIndex=cpfrResolveMapPolicyIndex, ciscoPfrMIBCompliances=ciscoPfrMIBCompliances, cpfrTCDstMaxPort=cpfrTCDstMaxPort, cpfrMapPrefixForwardInterface=cpfrMapPrefixForwardInterface, cpfrTCSrcPrefixType=cpfrTCSrcPrefixType, cpfrNbarApplListStorageType=cpfrNbarApplListStorageType, cpfrLearnListMethod=cpfrLearnListMethod, PfrBorderRouterIndex=PfrBorderRouterIndex, cpfrTCMapPolicyIndex=cpfrTCMapPolicyIndex, cpfrLinkGroupType=cpfrLinkGroupType, cpfrMCLastClearTime=cpfrMCLastClearTime, cpfrActiveProbeTargetAddressType=cpfrActiveProbeTargetAddressType, cpfrExitRollupCollected=cpfrExitRollupCollected, cpfrMapFallbackLinkGroupName=cpfrMapFallbackLinkGroupName, cpfrMatchTCNbarListName=cpfrMatchTCNbarListName, cpfrMapEventTCCount=cpfrMapEventTCCount, cpfrMCRowStatus=cpfrMCRowStatus, cpfrTCMActiveSTJitterAvg=cpfrTCMActiveSTJitterAvg, cpfrExitStatusChangeNotify=cpfrExitStatusChangeNotify, cpfrMCKeepAliveTimer=cpfrMCKeepAliveTimer, cpfrMCNetflowExporter=cpfrMCNetflowExporter, cpfrExitCostFixedFeeCost=cpfrExitCostFixedFeeCost, cpfrTCDstPrefixType=cpfrTCDstPrefixType, cpfrExitRollupCurrentTgtUtil=cpfrExitRollupCurrentTgtUtil, cpfrResolveIndex=cpfrResolveIndex, cpfrExitCostRollupPeriod=cpfrExitCostRollupPeriod, cpfrMCNotifisControl=cpfrMCNotifisControl, cpfrTCMAttempts=cpfrTCMAttempts, cpfrMCClear=cpfrMCClear, cpfrExitCostDiscard=cpfrExitCostDiscard, cpfrTCMActiveSTDelayAvg=cpfrTCMActiveSTDelayAvg, cpfrExitCostCalcMethod=cpfrExitCostCalcMethod, cpfrMapBackoffStepTimer=cpfrMapBackoffStepTimer, cpfrMapDelayThresholdMax=cpfrMapDelayThresholdMax, cpfrExitCostNickName=cpfrExitCostNickName, cpfrNbarApplPdIndex=cpfrNbarApplPdIndex, cpfrExitCost1=cpfrExitCost1, cpfrMCAdminStatus=cpfrMCAdminStatus, cpfrMapActiveProbeFrequency=cpfrMapActiveProbeFrequency, cpfrMapNextHopAddressType=cpfrMapNextHopAddressType, cpfrExitCostEndOffset=cpfrExitCostEndOffset, cpfrMCLearnState=cpfrMCLearnState, cpfrTCSrcMinPort=cpfrTCSrcMinPort, cpfrTCSLearnListIndex=cpfrTCSLearnListIndex, cpfrTCSType=cpfrTCSType, cpfrMapModeMonitor=cpfrMapModeMonitor, cpfrActiveProbeAssignedPfxAddressType=cpfrActiveProbeAssignedPfxAddressType, cpfrTCNbarApplication=cpfrTCNbarApplication, cpfrMCStatusChangeNotify=cpfrMCStatusChangeNotify, ciscoPfrMIBObjects=ciscoPfrMIBObjects, cpfrMatchTCPfxInside=cpfrMatchTCPfxInside, cpfrExitCost2=cpfrExitCost2, cpfrBRKeyName=cpfrBRKeyName, cpfrMCNotificationGroup=cpfrMCNotificationGroup, cpfrTCMLastUpdateTime=cpfrTCMLastUpdateTime, cpfrMatchLearnListName=cpfrMatchLearnListName, cpfrMCPrefixCount=cpfrMCPrefixCount, cpfrLearnListNbarAppl=cpfrLearnListNbarAppl, cpfrLearnListTable=cpfrLearnListTable, cpfrExitCostEndDayOfMonth=cpfrExitCostEndDayOfMonth, cpfrLearnEntry=cpfrLearnEntry, cpfrExitMaxUtilTxType=cpfrExitMaxUtilTxType, cpfrLinkGroupExitEntry=cpfrLinkGroupExitEntry, cpfrActiveProbeType=cpfrActiveProbeType, cpfrResolvePriority=cpfrResolvePriority, cpfrNbarApplIndex=cpfrNbarApplIndex, cpfrMatchEntry=cpfrMatchEntry, cpfrLearnPrefixesNumber=cpfrLearnPrefixesNumber, cpfrResolveVariance=cpfrResolveVariance, cpfrTCMPassiveLTLossAvg=cpfrTCMPassiveLTLossAvg, cpfrResolveRowStatus=cpfrResolveRowStatus, cpfrExitCost3=cpfrExitCost3, cpfrLearnMonitorPeriod=cpfrLearnMonitorPeriod, cpfrBRUpTime=cpfrBRUpTime, cpfrBRConnStatus=cpfrBRConnStatus, cpfrTrafficClassStatusTable=cpfrTrafficClassStatusTable, cpfrTCMAge=cpfrTCMAge, cpfrMatchValid=cpfrMatchValid, cpfrExitEntry=cpfrExitEntry, cpfrTCBRExitIndex=cpfrTCBRExitIndex, cpfrMapModeRouteOpts=cpfrMapModeRouteOpts, cpfrBRConnFailureReason=cpfrBRConnFailureReason, cpfrActiveProbeMapIndex=cpfrActiveProbeMapIndex, cpfrActiveProbeMethod=cpfrActiveProbeMethod, cpfrTCSrcMaxPort=cpfrTCSrcMaxPort, cpfrExitRollupTimeRemain=cpfrExitRollupTimeRemain, cpfrLinkGroupExitTable=cpfrLinkGroupExitTable, cpfrActiveProbeEntry=cpfrActiveProbeEntry, cpfrExitIndex=cpfrExitIndex, cpfrResolveEntry=cpfrResolveEntry, cpfrMCTable=cpfrMCTable, cpfrMapTable=cpfrMapTable, PfrMapIndex=PfrMapIndex, cpfrMCNumofExits=cpfrMCNumofExits, cpfrLearnListIndex=cpfrLearnListIndex, cpfrMCNumofBorderRouters=cpfrMCNumofBorderRouters, cpfrTCSTimeOnCurrExit=cpfrTCSTimeOnCurrExit, cpfrTCSControlState=cpfrTCSControlState, cpfrActiveProbeMapPolicyIndex=cpfrActiveProbeMapPolicyIndex, cpfrExitCostSummerTimeOffset=cpfrExitCostSummerTimeOffset, cpfrMapRouteMetricBgpLocalPref=cpfrMapRouteMetricBgpLocalPref, cpfrLearnListAclName=cpfrLearnListAclName, cpfrMCRsvpPostDialDelay=cpfrMCRsvpPostDialDelay, cpfrExitCostEndOffsetType=cpfrExitCostEndOffsetType, cpfrMapTracerouteReporting=cpfrMapTracerouteReporting, cpfrTCMPassiveLTDelayAvg=cpfrTCMPassiveLTDelayAvg, cpfrLearnAggregationType=cpfrLearnAggregationType, cpfrExitCostSummerTimeStart=cpfrExitCostSummerTimeStart, cpfrMCIndex=cpfrMCIndex, cpfrTCDscpValue=cpfrTCDscpValue, cpfrMCRsvpSignalingRetries=cpfrMCRsvpSignalingRetries, cpfrMCPortNumber=cpfrMCPortNumber, cpfrExitCostTierRowStatus=cpfrExitCostTierRowStatus, cpfrMapEventNotifCtrlType=cpfrMapEventNotifCtrlType, cpfrTCSLastRouteChangeEvent=cpfrTCSLastRouteChangeEvent, cpfrBROperStatus=cpfrBROperStatus, cpfrLearnExpireSessionNum=cpfrLearnExpireSessionNum, cpfrTCPrimaryThresholdBelowNotify=cpfrTCPrimaryThresholdBelowNotify, cpfrTCStatus=cpfrTCStatus, cpfrExitCostTierEntry=cpfrExitCostTierEntry, cpfrLearnExpireType=cpfrLearnExpireType, cpfrMapModeSelectExitType=cpfrMapModeSelectExitType, cpfrTCMPassiveSTDelayAvg=cpfrTCMPassiveSTDelayAvg, cpfrBRStatusChangeNotify=cpfrBRStatusChangeNotify, cpfrMapHolddownTimer=cpfrMapHolddownTimer, cpfrExitMaxUtilRxAbsolute=cpfrExitMaxUtilRxAbsolute, cpfrExitTxLoad=cpfrExitTxLoad, cpfrMCChangeConfigType=cpfrMCChangeConfigType, cpfrTrafficClassStatusEntry=cpfrTrafficClassStatusEntry, cpfrMasterControllerGroup=cpfrMasterControllerGroup, cpfrTCMPassiveLTUnreachableAvg=cpfrTCMPassiveLTUnreachableAvg, cpfrExitRxLoad=cpfrExitRxLoad, cpfrActiveProbeTargetPortNumber=cpfrActiveProbeTargetPortNumber, cpfrMapRoundRobinResolver=cpfrMapRoundRobinResolver, cpfrActiveProbeAssignedPfxAddress=cpfrActiveProbeAssignedPfxAddress, cpfrExitName=cpfrExitName, cpfrActiveProbeAdminStatus=cpfrActiveProbeAdminStatus, cpfrMapLossRelativeAvg=cpfrMapLossRelativeAvg, cpfrLinkGroupIndex=cpfrLinkGroupIndex, cpfrNbarApplListTable=cpfrNbarApplListTable, cpfrMCChangeConfigValue=cpfrMCChangeConfigValue, cpfrMCEntry=cpfrMCEntry, cpfrMatchTable=cpfrMatchTable, cpfrLearnFilterAccessListName=cpfrLearnFilterAccessListName, cpfrTrafficClassMetricTable=cpfrTrafficClassMetricTable, cpfrTCSControlBy=cpfrTCSControlBy, cpfrTrafficClassValid=cpfrTrafficClassValid, cpfrMatchLearnMode=cpfrMatchLearnMode, cpfrTCMPackets=cpfrTCMPackets, cpfrTCSTimeRemainCurrState=cpfrTCSTimeRemainCurrState, cpfrExitRollupCumRxBytes=cpfrExitRollupCumRxBytes, cpfrBRStorageType=cpfrBRStorageType, cpfrTCSLastOOPReason=cpfrTCSLastOOPReason, cpfrMCControlMode=cpfrMCControlMode, cpfrExitCostTierTable=cpfrExitCostTierTable, cpfrLearnListSequenceNum=cpfrLearnListSequenceNum, cpfrTCMActiveSTUnreachableAvg=cpfrTCMActiveSTUnreachableAvg, cpfrBRTable=cpfrBRTable, cpfrMapLossThresholdMax=cpfrMapLossThresholdMax, cpfrTCSrcPrefix=cpfrTCSrcPrefix, cpfrTCMMOSPercentage=cpfrTCMMOSPercentage, cpfrActiveProbeRowStatus=cpfrActiveProbeRowStatus, cpfrLinkGroupName=cpfrLinkGroupName, cpfrLearnListEntry=cpfrLearnListEntry, ciscoPfrMIBCompliance=ciscoPfrMIBCompliance, cpfrExitCostTierFee=cpfrExitCostTierFee, cpfrTCDstPrefixLen=cpfrTCDstPrefixLen, cpfrLearnMethod=cpfrLearnMethod, cpfrTCBRIndex=cpfrTCBRIndex, ciscoPfrMIBConform=ciscoPfrMIBConform, cpfrLearnListPfxName=cpfrLearnListPfxName, cpfrExitRollupDiscard=cpfrExitRollupDiscard, cpfrMapMOSPercentage=cpfrMapMOSPercentage, cpfrMapLossType=cpfrMapLossType, cpfrMapUnreachableRelativeAvg=cpfrMapUnreachableRelativeAvg, cpfrMCMaxPrefixTotal=cpfrMCMaxPrefixTotal, cpfrExitRxBandwidth=cpfrExitRxBandwidth, cpfrExitCapacity=cpfrExitCapacity, cpfrTrafficClassEventNotify=cpfrTrafficClassEventNotify, cpfrMapPeriodicTimer=cpfrMapPeriodicTimer, cpfrResolveMapIndex=cpfrResolveMapIndex, cpfrLearnExpireTime=cpfrLearnExpireTime, cpfrTCMetricsValid=cpfrTCMetricsValid, cpfrExitCostTierStorageType=cpfrExitCostTierStorageType, cpfrNbarApplListEntry=cpfrNbarApplListEntry, cpfrExitMaxUtilRxType=cpfrExitMaxUtilRxType, cpfrMatchTCNbarApplPfxList=cpfrMatchTCNbarApplPfxList, cpfrMCLoggingAdminStatus=cpfrMCLoggingAdminStatus, cpfrExitRollupStartingTgtUtil=cpfrExitRollupStartingTgtUtil, cpfrBRAddressType=cpfrBRAddressType, cpfrLinkGroupBRIndex=cpfrLinkGroupBRIndex, cpfrExitMaxUtilRxPercentage=cpfrExitMaxUtilRxPercentage, cpfrResolveStorageType=cpfrResolveStorageType, cpfrMapUnreachableThresholdMax=cpfrMapUnreachableThresholdMax, cpfrExitRowStatus=cpfrExitRowStatus, cpfrExitRollupMomTgtUtil=cpfrExitRollupMomTgtUtil, cpfrMapRouteMetricStaticTag=cpfrMapRouteMetricStaticTag, cpfrTCProtocol=cpfrTCProtocol, cpfrLearnListFilterPfxName=cpfrLearnListFilterPfxName, ciscoPfrMIBComplianceRev1=ciscoPfrMIBComplianceRev1, cpfrActiveProbeTargetAddress=cpfrActiveProbeTargetAddress, cpfrActiveProbeOperStatus=cpfrActiveProbeOperStatus, cpfrExitRsvpBandwidthPool=cpfrExitRsvpBandwidthPool, PfRMasterControllerIndex=PfRMasterControllerIndex, cpfrExitCostTierIndex=cpfrExitCostTierIndex, cpfrMapBackoffMaxTimer=cpfrMapBackoffMaxTimer, cpfrDowngradeBgpCommunity=cpfrDowngradeBgpCommunity, cpfrExitRollupCumTxBytes=cpfrExitRollupCumTxBytes, cpfrMapLinkGroupName=cpfrMapLinkGroupName, cpfrBREntry=cpfrBREntry, cpfrActiveProbeStorageType=cpfrActiveProbeStorageType, PfrLastUncontrolReason=PfrLastUncontrolReason, cpfrMapJitterThresholdMax=cpfrMapJitterThresholdMax, cpfrMatchAddrPrefixInside=cpfrMatchAddrPrefixInside, cpfrBorderRouterGroupRev1=cpfrBorderRouterGroupRev1, cpfrMCConnStatus=cpfrMCConnStatus)
mibBuilder.exportSymbols("CISCO-PFR-MIB", cpfrTCSLastOOPEventTime=cpfrTCSLastOOPEventTime, ciscoPfrMIB=ciscoPfrMIB, cpfrActiveProbeDscpValue=cpfrActiveProbeDscpValue, cpfrTCMPassiveSTUnreachableAvg=cpfrTCMPassiveSTUnreachableAvg, cpfrTCMapIndex=cpfrTCMapIndex, cpfrLearnListPfxInside=cpfrLearnListPfxInside, cpfrExitCostDiscardType=cpfrExitCostDiscardType, cpfrMapMOSThresholdMin=cpfrMapMOSThresholdMin, cpfrMCMaxPrefixLearn=cpfrMCMaxPrefixLearn, cpfrExitCostSamplingPeriod=cpfrExitCostSamplingPeriod, cpfrTrafficClassEntry=cpfrTrafficClassEntry, PfrMapIndexOrZero=PfrMapIndexOrZero, cpfrTCSLastRouteChangeReason=cpfrTCSLastRouteChangeReason, cpfrMapActiveProbePackets=cpfrMapActiveProbePackets, cpfrMCPrefixConfigured=cpfrMCPrefixConfigured, cpfrTrafficClassTable=cpfrTrafficClassTable, cpfrBRAddress=cpfrBRAddress, cpfrMapEntry=cpfrMapEntry, cpfrExitCostSummerTimeEnd=cpfrExitCostSummerTimeEnd, cpfrLearnAggregationPrefixLen=cpfrLearnAggregationPrefixLen, cpfrResolveTable=cpfrResolveTable, cpfrExitType=cpfrExitType, cpfrLearnListRowStatus=cpfrLearnListRowStatus, cpfrTCMActiveLTUnreachableAvg=cpfrTCMActiveLTUnreachableAvg, cpfrTrafficClassGroup=cpfrTrafficClassGroup, cpfrMatchAddrAccessList=cpfrMatchAddrAccessList, cpfrTCDstPrefix=cpfrTCDstPrefix, cpfrLearnListReferenceName=cpfrLearnListReferenceName, cpfrExitRollupLeft=cpfrExitRollupLeft, cpfrExitCostDiscardPercent=cpfrExitCostDiscardPercent, cpfrMapStorageType=cpfrMapStorageType, cpfrActiveProbeIndex=cpfrActiveProbeIndex, cpfrActiveProbeAssignedPfxLen=cpfrActiveProbeAssignedPfxLen, cpfrExitSustainedUtil2=cpfrExitSustainedUtil2, cpfrExitOperStatus=cpfrExitOperStatus, cpfrTCInpolicyThresholdBelowNotify=cpfrTCInpolicyThresholdBelowNotify, cpfrNbarApplListName=cpfrNbarApplListName, cpfrActiveProbeCodecName=cpfrActiveProbeCodecName, cpfrTCSrcPrefixLen=cpfrTCSrcPrefixLen, cpfrMapUnreachableType=cpfrMapUnreachableType, cpfrBRIndex=cpfrBRIndex, PYSNMP_MODULE_ID=ciscoPfrMIB, PfrLearnListIndexOrZero=PfrLearnListIndexOrZero, cpfrTrafficClassMetricEntry=cpfrTrafficClassMetricEntry, cpfrMapBackoffMinTimer=cpfrMapBackoffMinTimer, cpfrMCOperStatus=cpfrMCOperStatus, PfrMetricPolicyType=PfrMetricPolicyType, cpfrMatchAddrPrefixList=cpfrMatchAddrPrefixList, cpfrMCTracerouteProbeDelay=cpfrMCTracerouteProbeDelay, cpfrMapPolicyIndex=cpfrMapPolicyIndex, cpfrTCMPassiveSTLossAvg=cpfrTCMPassiveSTLossAvg, cpfrLearnPeriodInterval=cpfrLearnPeriodInterval, cpfrMapRowStatus=cpfrMapRowStatus, cpfrExitMaxUtilTxAbsolute=cpfrExitMaxUtilTxAbsolute, cpfrMapIndex=cpfrMapIndex, PfrExitIndex=PfrExitIndex, cpfrMCMapIndex=cpfrMCMapIndex, cpfrLearnListStorageType=cpfrLearnListStorageType, cpfrMapRouteMetricEigrpTagCommunity=cpfrMapRouteMetricEigrpTagCommunity, cpfrExitTable=cpfrExitTable, cpfrTrafficClassIndex=cpfrTrafficClassIndex, cpfrLinkGroupStorageType=cpfrLinkGroupStorageType)

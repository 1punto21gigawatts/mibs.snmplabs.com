#
# PySNMP MIB module CISCO-SMART-INSTALL-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-SMART-INSTALL-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:12:16 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, SingleValueConstraint, ValueSizeConstraint, ConstraintsUnion, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsUnion", "ConstraintsIntersection")
ciscoMgmt, = mibBuilder.importSymbols("CISCO-SMI", "ciscoMgmt")
CiscoURLStringOrEmpty, TimeIntervalMin, Cisco2KVlanList = mibBuilder.importSymbols("CISCO-TC", "CiscoURLStringOrEmpty", "TimeIntervalMin", "Cisco2KVlanList")
InetAddress, InetAddressType = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddress", "InetAddressType")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ObjectGroup, NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "NotificationGroup", "ModuleCompliance")
NotificationType, Counter64, ObjectIdentity, Counter32, Gauge32, Integer32, ModuleIdentity, iso, Bits, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, IpAddress, Unsigned32, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "NotificationType", "Counter64", "ObjectIdentity", "Counter32", "Gauge32", "Integer32", "ModuleIdentity", "iso", "Bits", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "IpAddress", "Unsigned32", "TimeTicks")
RowStatus, DateAndTime, StorageType, MacAddress, TextualConvention, TruthValue, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "RowStatus", "DateAndTime", "StorageType", "MacAddress", "TextualConvention", "TruthValue", "DisplayString")
ciscoSmartInstallMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 9, 725))
ciscoSmartInstallMIB.setRevisions(('2010-04-30 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ciscoSmartInstallMIB.setRevisionsDescriptions(('Initial version of this MIB module.',))
if mibBuilder.loadTexts: ciscoSmartInstallMIB.setLastUpdated('201004300000Z')
if mibBuilder.loadTexts: ciscoSmartInstallMIB.setOrganization('Cisco Systems, Inc.')
if mibBuilder.loadTexts: ciscoSmartInstallMIB.setContactInfo('Cisco Systems Customer Service Postal: 170 W Tasman Drive San Jose, CA 95134 USA Tel: +1 800 553-NETS E-mail: interest-comp-smartinstall@cisco.com')
if mibBuilder.loadTexts: ciscoSmartInstallMIB.setDescription("This MIB module defines managed objects that facilitate the management of Smart Install feature. Smart Install is a plug-and-play image and configuration management feature which enables zero-touch deployment of Cisco network devices in an enterprise branch network. Following is the terminology associated with Smart Install feature: Director A router or switch selected as the single management point for images and configuration of network devices in a Smart Install network. When a device is first installed into the network, the director detects the new device and facilitates the correct Cisco IOS image and configuration file for the device based on user defined profiles. With the automated process, a single or a group of devices are deployed without user intervention. The managed device includes, but not limited to, Cisco 2K/3K switches and EtherSwitch service modules. Director learns about them through CDP or Smart Install protocol. Smart Install Capable Client A client device running Smart Install capable image. Group Devices are placed into Groups where they can be manipulated together rather than individually. Profile Profile is the configuration file, image, etc. that a user programs for each group. Backup The feature to archive/backup client device's configuration file upon 'write memory' on client. Join-Window A join window is a time window during which the device is allowed to upgrade image or configuration files. Only during this window can the director provide information about the image and configuration to the device. A device attempting to join the network outside of the join window will not be allowed to do so, and cannot upgrade their image and configuration files. This MIB module is supported on the director but not on the client devices. It is designed to: - Allow operators to make configurations for client devices before and after they connect to the director's network. - Support monitoring of client devices discovered by the director. - Provide status of the deployed client image and configuration as a result of operator defined profiles. - Provide notifications for notable events such as new device joined or upgrade failure if there is any. Please note that, in most cases a working DHCP pool is configured for the subnet(s) on which the client devices are located. The DHCP server could be the director, another Cisco device running Cisco IOS, or a non-Cisco third-party server. CISCO-SMART-INSTALL-MIB Module usage: 1) Create profile for a group of devices Profile is used to pre-configure image and configuration files for a group of devices. In csiProfileTable { csiProfileIndex = 8, csiProfileGroupName = '3750E_24', csiProfileImageUrl = 'tftp://10.0.0.1/3750e.tar', csiProfileImageTwoUrl = '', csiProfileConfigUrl = 'flash:/default_config.txt', <snip> } 2) Define a group of devices For example, to define a group matching on Catalyst 2960 24 8 Poe switches: In csiMatchTable { csiMatchIndex = 1, csiMatchGroupType = 'product', csiMatchProductId = 'WS-C2960-24LT-L', csiProfileIndex = 6, <snip> } 3) Enable Smart Install feature on the director The operator enables the Smart Install feature by setting csiOperationMode = basic(2) 4) Display device information Director is aware of Smart Install capable devices and others connected to a Smart Install capable device. This MIB table displays information about the devices, such as the running image, the MAC address, etc. csiDeviceTable 5) Further refine the running environment Objects in csiGlobalConfig enable the Operator to tailor the director operation, such as: . Backup client device's configuration file. . Set up Join Window to monitor newly installed devices.")
ciscoSmartInstallMIBNotifs = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 725, 0))
ciscoSmartInstallMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 725, 1))
ciscoSmartInstallMIBConform = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 725, 2))
csiGlobalConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 725, 1, 1))
csiProfile = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 725, 1, 2))
csiDeviceInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 725, 1, 3))
csiNotifObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 725, 1, 4))
csiOperationMode = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 725, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("basic", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: csiOperationMode.setStatus('current')
if mibBuilder.loadTexts: csiOperationMode.setDescription('This object specifies the Smart Install director operation mode. The following enumerated values are supported: disabled(1) - Smart Install feature disabled. basic(2) - Enabled with Smart Install basic features.')
csiDirectorIpAddressType = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 725, 1, 1, 2), InetAddressType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: csiDirectorIpAddressType.setStatus('current')
if mibBuilder.loadTexts: csiDirectorIpAddressType.setDescription('This object specifies the type of Internet address in csiDirectorIpAddress object.')
csiDirectorIpAddress = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 725, 1, 1, 3), InetAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: csiDirectorIpAddress.setStatus('current')
if mibBuilder.loadTexts: csiDirectorIpAddress.setDescription('This object specifies the Internet address assigned for the director. The type of this address is determined by the value of csiDirectorIpAddressType object. Setting this object is not mandatory if the director IP address is configured by DHCP. For DHCP to assign the director IP address, the operator needs to configure the DHCP server.')
csiManagementVlan = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 725, 1, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csiManagementVlan.setStatus('current')
if mibBuilder.loadTexts: csiManagementVlan.setDescription('This object indicates if management VLAN is in use or not.')
csiManagementVlansFirst2K = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 725, 1, 1, 5), Cisco2KVlanList()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: csiManagementVlansFirst2K.setStatus('current')
if mibBuilder.loadTexts: csiManagementVlansFirst2K.setDescription('This object specifies the management VLANs in a string of octets containing one bit per VLAN for VLANs 0 to 2047. The director snoops all DHCP packets that pass through on the management VLANs in addition to the default VLAN 1. The value of this object is irrelevent if csiManagementVlan is false(2).')
csiManagementVlansSecond2K = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 725, 1, 1, 6), Cisco2KVlanList()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: csiManagementVlansSecond2K.setStatus('current')
if mibBuilder.loadTexts: csiManagementVlansSecond2K.setDescription('This object specifies the management VLANs in a string of octets containing one bit per VLAN for VLANs 2048 to 4095. The director snoops all DHCP packets that pass through on the management VLANs in addition to the default VLAN 1. The value of this object is irrelevent if csiManagementVlan is false(2).')
csiBackup = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 725, 1, 1, 7))
csiJoinWindow = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 725, 1, 1, 8))
csiBackupHostUrl = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 725, 1, 1, 7, 1), CiscoURLStringOrEmpty()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: csiBackupHostUrl.setStatus('current')
if mibBuilder.loadTexts: csiBackupHostUrl.setDescription("A Uniform Resource Locator specifying the host where the client configuration files are stored, 'tftp://101.122.33.10/vstack' for example. When a client configuration is committed (i.e. write memory), a backup of the configuration is saved in the backup host if csiBackupEnable is 'true'. The backup file name is consisted of the client host name, MAC address and file extension 'REV2', for example 'SwitchA-0021.d7ae.fc00.REV2'. For subsequent backups, .REV2 file is copied to .REV1, and .REV2 is over-written with the latest client configuration.")
csiBackupEnable = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 725, 1, 1, 7, 2), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: csiBackupEnable.setStatus('current')
if mibBuilder.loadTexts: csiBackupEnable.setDescription("This object specifies whether client configuration file is backed up in the backup host. Director is informed when a Smart Install client configuration is committed (i.e. write memory). If this object value is 'true', director orchestrates the backup of the client configuration file to the designated backup host.")
csiJoinWindowConfigOperationMode = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 725, 1, 1, 8, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("closed", 1), ("auto", 2), ("manual", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: csiJoinWindowConfigOperationMode.setStatus('current')
if mibBuilder.loadTexts: csiJoinWindowConfigOperationMode.setDescription("A join window is a time window during which a network device is allowed to upgrade image or configuration files. Only during this window can the director provide information about the image and configuration to the device. A device attempting to join the network outside of the join window will not be allowed to do so, and cannot upgrade their image and configuration files. This object specifies the configuration of the Join Window operation mode. closed - All devices attempting to join are denied to upgrade as indicated in the csiDeviceStatus object. Director does not provide information about the image and configuration to the device. auto - Director provides image and configuration information to devices joining during 'Join Window' period. manual - Devices attempting to join during Join Window are put on hold as indicated in the csiDeviceStatus object. Director does not give image and configuration information to these on hold devices unless the operator manually instructs the director to upgrade them.")
csiJoinWindowPeriodNextFreeIndex = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 725, 1, 1, 8, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: csiJoinWindowPeriodNextFreeIndex.setStatus('current')
if mibBuilder.loadTexts: csiJoinWindowPeriodNextFreeIndex.setDescription('An integer which may be used as a new index in csiJoinWindowPeriodTable. The special value of 0 indicates that no more new entries can be created in csiJoinWindowPeriodTable. This object is a legal value (if non-zero) for an index that is not currently used in the relevant table. The Network Management Application reads this variable and uses the (non-zero) value read when creating a new row with an SNMP SET. When the SET is performed, the agent must determine whether the value is indeed still unused; two Network Management Applications may attempt to create a row (configuration entry) simultaneously and use the same value. If it is currently unused, the SET succeeds and the agent monotonically increases the value of this object. However if the value is in use, the SET fails. The Network Management Application must then re-read this variable to obtain a new usable value.')
csiJoinWindowPeriodTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 725, 1, 1, 8, 3), )
if mibBuilder.loadTexts: csiJoinWindowPeriodTable.setStatus('current')
if mibBuilder.loadTexts: csiJoinWindowPeriodTable.setDescription("A table of Join Window time periods. Management Application creates an entry in the table to add a Join Window period and its recurrence pattern. If csiJoinWindowConfigOperationMode is 'auto', all devices joined during Join Window are automatically upgraded. If csiJoinWindowConfigOperationMode is 'manual', new devices joined during Join Window are put on hold as indicated in csiDeviceStatus. They are not offered upgrade information unless the operator manually instructs the director to do so. In rare occasions, when entries overlap in time, the devices joining during any of the Join Window period are allowed to be upgraded or put on hold.")
csiJoinWindowPeriodEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 725, 1, 1, 8, 3, 1), ).setIndexNames((0, "CISCO-SMART-INSTALL-MIB", "csiJoinWindowPeriodIndex"))
if mibBuilder.loadTexts: csiJoinWindowPeriodEntry.setStatus('current')
if mibBuilder.loadTexts: csiJoinWindowPeriodEntry.setDescription('An entry specifying a time period during which director offers image and configuration information to the newly installed devices. A configured row instance can be created or removed by setting the appropriate value of its RowStatus object.')
csiJoinWindowPeriodIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 725, 1, 1, 8, 3, 1, 1), Unsigned32())
if mibBuilder.loadTexts: csiJoinWindowPeriodIndex.setStatus('current')
if mibBuilder.loadTexts: csiJoinWindowPeriodIndex.setDescription('This object uniquely identifies a row in csiJoinWindowPeriodTable. The Management Application chooses this value by reading csiJoinWindowPeriodNextFreeIndex while creating an entry in this table. If an entry already exists with this index, the creation of the entry will not continue and error will be returned. The Management Application should read the value of csiJoinWindowPeriodNextFreeIndex again and retry with the new value for this object.')
csiJoinWindowPeriodStartTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 725, 1, 1, 8, 3, 1, 2), DateAndTime()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csiJoinWindowPeriodStartTime.setStatus('current')
if mibBuilder.loadTexts: csiJoinWindowPeriodStartTime.setDescription('This object specifies the start time of a Join Window period.')
csiJoinWindowPeriodInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 725, 1, 1, 8, 3, 1, 3), TimeIntervalMin()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csiJoinWindowPeriodInterval.setStatus('current')
if mibBuilder.loadTexts: csiJoinWindowPeriodInterval.setDescription('This object specifies the length of Join Window period in minutes starting from csiJoinWindowPeriodStartTime.')
csiJoinWindowPeriodRecurrencePattern = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 725, 1, 1, 8, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("none", 1), ("daily", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csiJoinWindowPeriodRecurrencePattern.setStatus('current')
if mibBuilder.loadTexts: csiJoinWindowPeriodRecurrencePattern.setDescription('This object specifies the Join Window recurrence pattern. none(1) - The join window period does not recur. daily(2) - The join window period recurs daily.')
csiJoinWindowPeriodExpirationDate = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 725, 1, 1, 8, 3, 1, 5), DateAndTime()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csiJoinWindowPeriodExpirationDate.setStatus('current')
if mibBuilder.loadTexts: csiJoinWindowPeriodExpirationDate.setDescription('This object specifies the day (in year, month and date) the Join Window period stops. An empty string indicates that no expiration date is applied. The Join Window period can be stopped by either this object or csiJoinWindowPeriodInterval object, whichever expires first.')
csiJoinWindowPeriodStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 725, 1, 1, 8, 3, 1, 6), StorageType().clone('volatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csiJoinWindowPeriodStorageType.setStatus('current')
if mibBuilder.loadTexts: csiJoinWindowPeriodStorageType.setDescription('This object specifies the storage type of this conceptual row.')
csiJoinWindowPeriodRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 725, 1, 1, 8, 3, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csiJoinWindowPeriodRowStatus.setStatus('current')
if mibBuilder.loadTexts: csiJoinWindowPeriodRowStatus.setDescription("This object is used to manage the creation and deletion of rows in this table. If this object value is 'active', user cannot modify any writable object in this row.")
csiImageFileUrl = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 725, 1, 2, 1), CiscoURLStringOrEmpty()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: csiImageFileUrl.setStatus('current')
if mibBuilder.loadTexts: csiImageFileUrl.setDescription('This object specifies the location of the default boot .tar image file. An empty string indicates that no such file is applied. If all clients in a Smart Install network have the same product ID and can run the same image file, user can assign a default image file for all clients.')
csiConfigFileUrl = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 725, 1, 2, 2), CiscoURLStringOrEmpty()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: csiConfigFileUrl.setStatus('current')
if mibBuilder.loadTexts: csiConfigFileUrl.setDescription('This object specifies the location of the default configuration file. An empty string indicates that no such file is applied. If all clients in a Smart Install network have the same product ID and can run the same configuration file, user can assign a default configuration file for all clients.')
csiHostnamePrefix = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 725, 1, 2, 3), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: csiHostnamePrefix.setStatus('current')
if mibBuilder.loadTexts: csiHostnamePrefix.setDescription('This object specifies the default hostname prefix. The director provides hostname (with prefix followed by an implementation-dependent string) to clients.')
csiProfileNextFreeIndex = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 725, 1, 2, 4), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(2, 4294967295), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: csiProfileNextFreeIndex.setStatus('current')
if mibBuilder.loadTexts: csiProfileNextFreeIndex.setDescription('An integer value which may be used as a new index in csiProfileTable. The special value of 0 indicates that no more new entries can be created in csiProfileTable, and value 1 is not a valid csiProfileTable index. Thus the value of this object starts at 2 and monotonically increases after a profile is created. The Network Management Application reads this variable and uses the non-zero value when creating a new row with an SNMP SET. When the SET is performed, the agent must determine whether the value is indeed still unused, for two Network Management Applications may attempt to create a row (profile entry) simultaneously and use the same value. If it is currently unused, the SET succeeds and the agent increases the value of this object. If the value is in use, however, the SET fails. The Network Management Application must then re-read this variable to obtain a new usable value.')
csiProfileTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 725, 1, 2, 5), )
if mibBuilder.loadTexts: csiProfileTable.setStatus('current')
if mibBuilder.loadTexts: csiProfileTable.setDescription("A table of Smart Install profile entries. In Smart Install, any number of client devices can be placed together to form a 'group' for easy management. A profile is used to associate image and configuration files for a group of devices, before and after they join the network. An entry in this table reflects the profile of one Smart Install group.")
csiProfileEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 725, 1, 2, 5, 1), ).setIndexNames((0, "CISCO-SMART-INSTALL-MIB", "csiProfileIndex"))
if mibBuilder.loadTexts: csiProfileEntry.setStatus('current')
if mibBuilder.loadTexts: csiProfileEntry.setDescription('An entry in the csiProfileTable, describing the image and configuration files that represent the profile.')
csiProfileIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 725, 1, 2, 5, 1, 1), Unsigned32())
if mibBuilder.loadTexts: csiProfileIndex.setStatus('current')
if mibBuilder.loadTexts: csiProfileIndex.setDescription('This object uniquely identifies the entry in csiProfileTable. The value of the object is 2 or greater.')
csiProfileGroupName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 725, 1, 2, 5, 1, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csiProfileGroupName.setStatus('current')
if mibBuilder.loadTexts: csiProfileGroupName.setDescription('This object specifies the name of a group for which this profile associates.')
csiProfileImageUrl = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 725, 1, 2, 5, 1, 3), CiscoURLStringOrEmpty()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csiProfileImageUrl.setStatus('current')
if mibBuilder.loadTexts: csiProfileImageUrl.setDescription('This object specifies the location of the boot .tar image file. An empty string indicates that no such file is applied.')
csiProfileImageTwoUrl = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 725, 1, 2, 5, 1, 4), CiscoURLStringOrEmpty()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csiProfileImageTwoUrl.setStatus('current')
if mibBuilder.loadTexts: csiProfileImageTwoUrl.setDescription('For mixed switch stack, this object specifies the location of the second .tar image file. An empty string indicates that no such file is applied.')
csiProfileConfigUrl = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 725, 1, 2, 5, 1, 5), CiscoURLStringOrEmpty()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csiProfileConfigUrl.setStatus('current')
if mibBuilder.loadTexts: csiProfileConfigUrl.setDescription('This object specifies the location of the configuration file. An empty string indicates that no such file is applied.')
csiProfileStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 725, 1, 2, 5, 1, 6), StorageType().clone('volatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csiProfileStorageType.setStatus('current')
if mibBuilder.loadTexts: csiProfileStorageType.setDescription('This object specifies the storage type for this conceptual row.')
csiProfileRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 725, 1, 2, 5, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csiProfileRowStatus.setStatus('current')
if mibBuilder.loadTexts: csiProfileRowStatus.setDescription("This object specifies the status of this conceptual row. If this object value is 'active', user cannot modify any writable object in this row.")
csiMatchTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 725, 1, 2, 6), )
if mibBuilder.loadTexts: csiMatchTable.setStatus('current')
if mibBuilder.loadTexts: csiMatchTable.setDescription("A table of group matching criteria entries. In Smart Install, 'group' represents a collection of network devices and a profile is configured for the group. The matching criteria entries are used to identify the devices belonging to a profile group, and the matching entries cannot exist without a profile. This is implied by the reference to csiProfileIndex object in the index clause of this table.")
csiMatchEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 725, 1, 2, 6, 1), ).setIndexNames((0, "CISCO-SMART-INSTALL-MIB", "csiProfileIndex"), (0, "CISCO-SMART-INSTALL-MIB", "csiMatchIndex"))
if mibBuilder.loadTexts: csiMatchEntry.setStatus('current')
if mibBuilder.loadTexts: csiMatchEntry.setDescription('An entry in csiMatchTable, defining one matching criterion for a profile group. When its profile entry is deleted, the match entry is deleted too. The objects needed in an entry depend on the value of csiMatchGroupType. Multiple match entries can be entered for stack, connectivity or mac type of groups.')
csiMatchIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 725, 1, 2, 6, 1, 1), Unsigned32())
if mibBuilder.loadTexts: csiMatchIndex.setStatus('current')
if mibBuilder.loadTexts: csiMatchIndex.setDescription('This object uniquely identifies a matching criterion within a group.')
csiMatchGroupType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 725, 1, 2, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unknown", 1), ("mac", 2), ("connectivity", 3), ("product", 4), ("stack", 5)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csiMatchGroupType.setStatus('current')
if mibBuilder.loadTexts: csiMatchGroupType.setDescription('This object indicates the general category of a Smart Install group. A profile group can be formed based on, unknown(1) - unknown match group type mac(2) - MAC addresses of devices connectivity(3) - connectivity or topology of devices product(4) - product type of devices stack(5) - a switch stack')
csiMatchMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 725, 1, 2, 6, 1, 3), MacAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csiMatchMacAddress.setStatus('current')
if mibBuilder.loadTexts: csiMatchMacAddress.setDescription("This object specifies the MAC address of the client. It is required when csiMatchGroupType is 'mac'. A MAC address match takes priority over other match criteria.")
csiMatchHostAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 725, 1, 2, 6, 1, 4), InetAddressType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csiMatchHostAddressType.setStatus('current')
if mibBuilder.loadTexts: csiMatchHostAddressType.setDescription("This object specifies the type of Internet address stored in csiMatchHostAddress. It is required when csiMatchGroupType is 'connectivity'.")
csiMatchHostAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 725, 1, 2, 6, 1, 5), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csiMatchHostAddress.setStatus('current')
if mibBuilder.loadTexts: csiMatchHostAddress.setDescription("User can configure a profile group based on the connectivity or topology of clients in a Smart Install network, that is, a group of clients that are connected to the director through a single interface or clients that are connected to the director through a common intermediate device. This object specifies the Internet address of the upstream device, which could be the director or an intermediate device. Together with csiMatchHostInterface, it specifies the path through which clients are connected to the director. This object is required when csiMatchGroupType is 'connectivity'. The type of this address is determined by the value of csiMatchHostAddressType object. A connectivity match takes priority over product ID match.")
csiMatchHostInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 725, 1, 2, 6, 1, 6), SnmpAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csiMatchHostInterface.setStatus('current')
if mibBuilder.loadTexts: csiMatchHostInterface.setDescription("For connectivity group, this object specifies the interface, together with csiMatchHostAddress, representing the path through which clients are connected to the director. It is typically the value of the ifName object (e.g., 'Ethernet0'). It is required when csiMatchGroupType is 'connectivity'.")
csiMatchProductId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 725, 1, 2, 6, 1, 7), SnmpAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csiMatchProductId.setStatus('current')
if mibBuilder.loadTexts: csiMatchProductId.setDescription("This object specifies the device product type for profile groups formed based on 'product'. For pre-defined profile group, it is the group name such as '2960 24-8POE'. For user defined group, it specifies a product ID reported in ENTITY-MIB, such as 'WS-C2960-24LT-L'. It is required when csiMatchGroupType is 'product'.")
csiMatchSwitchNum = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 725, 1, 2, 6, 1, 8), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csiMatchSwitchNum.setStatus('current')
if mibBuilder.loadTexts: csiMatchSwitchNum.setDescription("This object specifies the switch number in a stackable switch. Together with csiMatchSwitchProductId, it describes a stack member. It is required when csiMatchGroupType is 'stack'.")
csiMatchSwitchProductId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 725, 1, 2, 6, 1, 9), SnmpAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csiMatchSwitchProductId.setStatus('current')
if mibBuilder.loadTexts: csiMatchSwitchProductId.setDescription("This object specifies the product ID of a switch member indicated in csiMatchSwitchNum. It is required when csiMatchGroupType is 'stack'.")
csiMatchStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 725, 1, 2, 6, 1, 10), StorageType().clone('volatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csiMatchStorageType.setStatus('current')
if mibBuilder.loadTexts: csiMatchStorageType.setDescription('This object specifies the storage type for this conceptual row.')
csiMatchRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 725, 1, 2, 6, 1, 11), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: csiMatchRowStatus.setStatus('current')
if mibBuilder.loadTexts: csiMatchRowStatus.setDescription("This object specifies the status of this conceptual row. If this object value is 'active', user cannot modify any writable object in this row.")
csiDeviceTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 725, 1, 3, 1), )
if mibBuilder.loadTexts: csiDeviceTable.setStatus('current')
if mibBuilder.loadTexts: csiDeviceTable.setDescription('A conceptual table listing the network devices with connectivity to the director, that is the device is either Smart Install capable or is connected to a Smart Install capable client.')
csiDeviceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 725, 1, 3, 1, 1), ).setIndexNames((0, "CISCO-SMART-INSTALL-MIB", "csiDeviceNum"))
if mibBuilder.loadTexts: csiDeviceEntry.setStatus('current')
if mibBuilder.loadTexts: csiDeviceEntry.setDescription('An entry for each device that has joined the Smart Install network.')
csiDeviceNum = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 725, 1, 3, 1, 1, 1), Unsigned32())
if mibBuilder.loadTexts: csiDeviceNum.setStatus('current')
if mibBuilder.loadTexts: csiDeviceNum.setDescription('A value assigned by the director to uniquely identify each entry in csiDeviceTable.')
csiDeviceMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 725, 1, 3, 1, 1, 2), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csiDeviceMacAddress.setStatus('current')
if mibBuilder.loadTexts: csiDeviceMacAddress.setDescription('This object indicates the MAC address of the network device.')
csiDeviceAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 725, 1, 3, 1, 1, 3), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csiDeviceAddressType.setStatus('current')
if mibBuilder.loadTexts: csiDeviceAddressType.setDescription('This object indicates the type of Internet address in csiDeviceAddress.')
csiDeviceAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 725, 1, 3, 1, 1, 4), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csiDeviceAddress.setStatus('current')
if mibBuilder.loadTexts: csiDeviceAddress.setDescription('This object indicates the Internet address of the device that sends Smart Install communication messages. The type of this address is determined by the value of csiDeviceAddressType object.')
csiDeviceName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 725, 1, 3, 1, 1, 5), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csiDeviceName.setStatus('current')
if mibBuilder.loadTexts: csiDeviceName.setDescription('This object indicates the host name of the device to easily identify it in a network.')
csiDeviceBackupConfigFileName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 725, 1, 3, 1, 1, 6), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csiDeviceBackupConfigFileName.setStatus('current')
if mibBuilder.loadTexts: csiDeviceBackupConfigFileName.setDescription("This object indicates the name of the latest saved configuration file of the device. The file name is consisted of the device host name, MAC address and file extension 'REV2', for example 'SwitchA-0021.d7ae.fc00.REV2'. The file is stored in the host indicated by the csiBackupHostUrl object. If the device configuration file is saved again, .REV2 file is copied to .REV1, and .REV2 is over-written with the latest device configuration.")
csiDeviceImageVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 725, 1, 3, 1, 1, 7), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csiDeviceImageVersion.setStatus('current')
if mibBuilder.loadTexts: csiDeviceImageVersion.setDescription('This object indicates the software release version that the device is running. The zero-length string indicates that no Version field (TLV) was reported in the most recent CDP message.')
csiDevicePlatform = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 725, 1, 3, 1, 1, 8), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csiDevicePlatform.setStatus('current')
if mibBuilder.loadTexts: csiDevicePlatform.setDescription("The device's hardware platform as reported in the most recent CDP message. The zero-length string indicates that no Platform field (TLV) was reported in the most recent CDP message.")
csiDeviceSerialNum = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 725, 1, 3, 1, 1, 9), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csiDeviceSerialNum.setStatus('current')
if mibBuilder.loadTexts: csiDeviceSerialNum.setDescription('A recorded serial number for this device that indexes some type device catalog or inventory, if applicable.')
csiDeviceStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 725, 1, 3, 1, 1, 10), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csiDeviceStatus.setStatus('current')
if mibBuilder.loadTexts: csiDeviceStatus.setDescription('A text string describes the network device status. The agent implementation may use this object to report upgrading progress.')
csiNotifEnable = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 725, 1, 4, 1), Bits().clone(namedValues=NamedValues(("operationModeChange", 0), ("deviceAdded", 1), ("deviceLost", 2), ("fileLoadFailed", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: csiNotifEnable.setStatus('current')
if mibBuilder.loadTexts: csiNotifEnable.setDescription("This object controls the generation of Smart Install notifications. For example, a value of '1' for 'deviceAdded' enables csiDeviceAdded notification, whereas a value of '0' disables csiDeviceAdded notification.")
csiNotifOperationType = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 725, 1, 4, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("downloadConfig", 2), ("downloadImage", 3), ("uploadConfig", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: csiNotifOperationType.setStatus('current')
if mibBuilder.loadTexts: csiNotifOperationType.setDescription('This object indicates the type of operation of csiFileLoadFailed notification. other(1) - none of the following downloadConfig(2) - configuration file download downloadImage(3) - image file download uploadConfig(4) - client config file upload to storage')
csiNotifOperationResult = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 725, 1, 4, 3), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: csiNotifOperationResult.setStatus('current')
if mibBuilder.loadTexts: csiNotifOperationResult.setDescription('This object indicates the file operation result of csiFileLoadFailed notification.')
csiOperationModeChange = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 725, 0, 1)).setObjects(("CISCO-SMART-INSTALL-MIB", "csiOperationMode"))
if mibBuilder.loadTexts: csiOperationModeChange.setStatus('current')
if mibBuilder.loadTexts: csiOperationModeChange.setDescription('This notification is generated when the director operation mode changes. csiOperationMode indicates the director operation mode.')
csiDeviceAdded = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 725, 0, 2)).setObjects(("CISCO-SMART-INSTALL-MIB", "csiDeviceName"), ("CISCO-SMART-INSTALL-MIB", "csiDeviceAddressType"), ("CISCO-SMART-INSTALL-MIB", "csiDeviceAddress"), ("CISCO-SMART-INSTALL-MIB", "csiDeviceMacAddress"))
if mibBuilder.loadTexts: csiDeviceAdded.setStatus('current')
if mibBuilder.loadTexts: csiDeviceAdded.setDescription('This notification is generated when a network device joins the Smart Install network. csiDeviceName indicates the device host name. csiDeviceAddressType indicates the device Internet address type. csiDeviceAddress indicates the device Internet address. csiDeviceMacAddress indicates the device MAC address.')
csiDeviceLost = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 725, 0, 3)).setObjects(("CISCO-SMART-INSTALL-MIB", "csiDeviceName"), ("CISCO-SMART-INSTALL-MIB", "csiDeviceAddressType"), ("CISCO-SMART-INSTALL-MIB", "csiDeviceAddress"), ("CISCO-SMART-INSTALL-MIB", "csiDeviceMacAddress"))
if mibBuilder.loadTexts: csiDeviceLost.setStatus('current')
if mibBuilder.loadTexts: csiDeviceLost.setDescription('This notification is generated when director loses connectivity to a device. csiDeviceName indicates the device host name. csiDeviceAddressType indicates the device Internet address type. csiDeviceAddress indicates the device Internet address. csiDeviceMacAddress indicates the device MAC address.')
csiFileLoadFailed = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 725, 0, 4)).setObjects(("CISCO-SMART-INSTALL-MIB", "csiDeviceName"), ("CISCO-SMART-INSTALL-MIB", "csiDeviceAddressType"), ("CISCO-SMART-INSTALL-MIB", "csiDeviceAddress"), ("CISCO-SMART-INSTALL-MIB", "csiDeviceMacAddress"), ("CISCO-SMART-INSTALL-MIB", "csiNotifOperationType"), ("CISCO-SMART-INSTALL-MIB", "csiNotifOperationResult"))
if mibBuilder.loadTexts: csiFileLoadFailed.setStatus('current')
if mibBuilder.loadTexts: csiFileLoadFailed.setDescription('This notification is generated when a file upload or download operation has failed. csiDeviceName indicates the device host name. csiDeviceAddressType indicates the device Internet address type. csiDeviceAddress indicates the device Internet address. csiDeviceMacAddress indicates the device MAC address. csiNotifOperationType indicates the file operation type. csiNotifOperationResult indicates the file operation result.')
ciscoSmartInstallCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 725, 2, 1))
ciscoSmartInstallGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 725, 2, 2))
ciscoSmartInstallCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 725, 2, 1, 1)).setObjects(("CISCO-SMART-INSTALL-MIB", "ciscoSmartInstallGlobalConfigGroup"), ("CISCO-SMART-INSTALL-MIB", "ciscoSmartInstallDeviceInformationGroup"), ("CISCO-SMART-INSTALL-MIB", "ciscoSmartInstallConfigBackupGroup"), ("CISCO-SMART-INSTALL-MIB", "ciscoSmartInstallJoinWindowGroup"), ("CISCO-SMART-INSTALL-MIB", "ciscoSmartInstallProfileGroup"), ("CISCO-SMART-INSTALL-MIB", "ciscoSmartInstallNotificationEnableGroup"), ("CISCO-SMART-INSTALL-MIB", "ciscoSmartInstallNotificationsGroup"), ("CISCO-SMART-INSTALL-MIB", "ciscoSmartInstallNotifyVarsGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoSmartInstallCompliance = ciscoSmartInstallCompliance.setStatus('current')
if mibBuilder.loadTexts: ciscoSmartInstallCompliance.setDescription('Describes the requirements for conformance to the CISCO-SMART-INSTALL-MIB module.')
ciscoSmartInstallGlobalConfigGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 725, 2, 2, 1)).setObjects(("CISCO-SMART-INSTALL-MIB", "csiOperationMode"), ("CISCO-SMART-INSTALL-MIB", "csiDirectorIpAddressType"), ("CISCO-SMART-INSTALL-MIB", "csiDirectorIpAddress"), ("CISCO-SMART-INSTALL-MIB", "csiManagementVlan"), ("CISCO-SMART-INSTALL-MIB", "csiManagementVlansFirst2K"), ("CISCO-SMART-INSTALL-MIB", "csiManagementVlansSecond2K"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoSmartInstallGlobalConfigGroup = ciscoSmartInstallGlobalConfigGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoSmartInstallGlobalConfigGroup.setDescription('A collection of objects used for director configurations.')
ciscoSmartInstallConfigBackupGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 725, 2, 2, 2)).setObjects(("CISCO-SMART-INSTALL-MIB", "csiBackupEnable"), ("CISCO-SMART-INSTALL-MIB", "csiBackupHostUrl"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoSmartInstallConfigBackupGroup = ciscoSmartInstallConfigBackupGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoSmartInstallConfigBackupGroup.setDescription('A collection of objects related to configuration file backup feature.')
ciscoSmartInstallJoinWindowGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 725, 2, 2, 3)).setObjects(("CISCO-SMART-INSTALL-MIB", "csiJoinWindowConfigOperationMode"), ("CISCO-SMART-INSTALL-MIB", "csiJoinWindowPeriodNextFreeIndex"), ("CISCO-SMART-INSTALL-MIB", "csiJoinWindowPeriodStartTime"), ("CISCO-SMART-INSTALL-MIB", "csiJoinWindowPeriodInterval"), ("CISCO-SMART-INSTALL-MIB", "csiJoinWindowPeriodRecurrencePattern"), ("CISCO-SMART-INSTALL-MIB", "csiJoinWindowPeriodExpirationDate"), ("CISCO-SMART-INSTALL-MIB", "csiJoinWindowPeriodRowStatus"), ("CISCO-SMART-INSTALL-MIB", "csiJoinWindowPeriodStorageType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoSmartInstallJoinWindowGroup = ciscoSmartInstallJoinWindowGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoSmartInstallJoinWindowGroup.setDescription('A collection of objects related to the Join Window.')
ciscoSmartInstallProfileGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 725, 2, 2, 4)).setObjects(("CISCO-SMART-INSTALL-MIB", "csiImageFileUrl"), ("CISCO-SMART-INSTALL-MIB", "csiConfigFileUrl"), ("CISCO-SMART-INSTALL-MIB", "csiHostnamePrefix"), ("CISCO-SMART-INSTALL-MIB", "csiProfileNextFreeIndex"), ("CISCO-SMART-INSTALL-MIB", "csiProfileGroupName"), ("CISCO-SMART-INSTALL-MIB", "csiProfileImageUrl"), ("CISCO-SMART-INSTALL-MIB", "csiProfileImageTwoUrl"), ("CISCO-SMART-INSTALL-MIB", "csiProfileConfigUrl"), ("CISCO-SMART-INSTALL-MIB", "csiProfileStorageType"), ("CISCO-SMART-INSTALL-MIB", "csiProfileRowStatus"), ("CISCO-SMART-INSTALL-MIB", "csiMatchGroupType"), ("CISCO-SMART-INSTALL-MIB", "csiMatchProductId"), ("CISCO-SMART-INSTALL-MIB", "csiMatchSwitchNum"), ("CISCO-SMART-INSTALL-MIB", "csiMatchSwitchProductId"), ("CISCO-SMART-INSTALL-MIB", "csiMatchHostAddressType"), ("CISCO-SMART-INSTALL-MIB", "csiMatchHostAddress"), ("CISCO-SMART-INSTALL-MIB", "csiMatchHostInterface"), ("CISCO-SMART-INSTALL-MIB", "csiMatchMacAddress"), ("CISCO-SMART-INSTALL-MIB", "csiMatchStorageType"), ("CISCO-SMART-INSTALL-MIB", "csiMatchRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoSmartInstallProfileGroup = ciscoSmartInstallProfileGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoSmartInstallProfileGroup.setDescription('A collection of objects which are used to configure the profile for clients.')
ciscoSmartInstallDeviceInformationGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 725, 2, 2, 5)).setObjects(("CISCO-SMART-INSTALL-MIB", "csiDeviceMacAddress"), ("CISCO-SMART-INSTALL-MIB", "csiDeviceAddressType"), ("CISCO-SMART-INSTALL-MIB", "csiDeviceAddress"), ("CISCO-SMART-INSTALL-MIB", "csiDeviceName"), ("CISCO-SMART-INSTALL-MIB", "csiDeviceBackupConfigFileName"), ("CISCO-SMART-INSTALL-MIB", "csiDeviceImageVersion"), ("CISCO-SMART-INSTALL-MIB", "csiDevicePlatform"), ("CISCO-SMART-INSTALL-MIB", "csiDeviceSerialNum"), ("CISCO-SMART-INSTALL-MIB", "csiDeviceStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoSmartInstallDeviceInformationGroup = ciscoSmartInstallDeviceInformationGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoSmartInstallDeviceInformationGroup.setDescription('A collection of objects that provide information about devices in a Smart Install network.')
ciscoSmartInstallNotificationEnableGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 725, 2, 2, 6)).setObjects(("CISCO-SMART-INSTALL-MIB", "csiNotifEnable"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoSmartInstallNotificationEnableGroup = ciscoSmartInstallNotificationEnableGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoSmartInstallNotificationEnableGroup.setDescription('A collection of objects for controlling (enabling/disabling) notifications to a management application.')
ciscoSmartInstallNotificationsGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 9, 9, 725, 2, 2, 7)).setObjects(("CISCO-SMART-INSTALL-MIB", "csiOperationModeChange"), ("CISCO-SMART-INSTALL-MIB", "csiDeviceAdded"), ("CISCO-SMART-INSTALL-MIB", "csiDeviceLost"), ("CISCO-SMART-INSTALL-MIB", "csiFileLoadFailed"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoSmartInstallNotificationsGroup = ciscoSmartInstallNotificationsGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoSmartInstallNotificationsGroup.setDescription('A collection of notifications in this MIB module.')
ciscoSmartInstallNotifyVarsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 725, 2, 2, 8)).setObjects(("CISCO-SMART-INSTALL-MIB", "csiNotifOperationType"), ("CISCO-SMART-INSTALL-MIB", "csiNotifOperationResult"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoSmartInstallNotifyVarsGroup = ciscoSmartInstallNotifyVarsGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoSmartInstallNotifyVarsGroup.setDescription('A collection of objects used for notifications.')
mibBuilder.exportSymbols("CISCO-SMART-INSTALL-MIB", csiJoinWindowPeriodStorageType=csiJoinWindowPeriodStorageType, csiJoinWindowPeriodRowStatus=csiJoinWindowPeriodRowStatus, csiMatchSwitchProductId=csiMatchSwitchProductId, csiNotifOperationType=csiNotifOperationType, csiBackupHostUrl=csiBackupHostUrl, csiDeviceStatus=csiDeviceStatus, csiMatchProductId=csiMatchProductId, csiMatchMacAddress=csiMatchMacAddress, csiDirectorIpAddressType=csiDirectorIpAddressType, csiManagementVlansFirst2K=csiManagementVlansFirst2K, csiNotifObjects=csiNotifObjects, csiImageFileUrl=csiImageFileUrl, csiMatchHostAddress=csiMatchHostAddress, csiJoinWindowPeriodIndex=csiJoinWindowPeriodIndex, csiNotifEnable=csiNotifEnable, ciscoSmartInstallNotificationEnableGroup=ciscoSmartInstallNotificationEnableGroup, csiDeviceEntry=csiDeviceEntry, ciscoSmartInstallMIBConform=ciscoSmartInstallMIBConform, csiDeviceInfo=csiDeviceInfo, ciscoSmartInstallDeviceInformationGroup=ciscoSmartInstallDeviceInformationGroup, csiJoinWindow=csiJoinWindow, csiDeviceAddress=csiDeviceAddress, csiProfile=csiProfile, csiProfileStorageType=csiProfileStorageType, csiJoinWindowPeriodTable=csiJoinWindowPeriodTable, ciscoSmartInstallCompliance=ciscoSmartInstallCompliance, ciscoSmartInstallGlobalConfigGroup=ciscoSmartInstallGlobalConfigGroup, csiDirectorIpAddress=csiDirectorIpAddress, csiDeviceImageVersion=csiDeviceImageVersion, csiConfigFileUrl=csiConfigFileUrl, csiMatchHostInterface=csiMatchHostInterface, csiDevicePlatform=csiDevicePlatform, csiJoinWindowPeriodStartTime=csiJoinWindowPeriodStartTime, ciscoSmartInstallJoinWindowGroup=ciscoSmartInstallJoinWindowGroup, csiFileLoadFailed=csiFileLoadFailed, csiMatchEntry=csiMatchEntry, ciscoSmartInstallConfigBackupGroup=ciscoSmartInstallConfigBackupGroup, ciscoSmartInstallMIBNotifs=ciscoSmartInstallMIBNotifs, csiMatchStorageType=csiMatchStorageType, csiJoinWindowPeriodNextFreeIndex=csiJoinWindowPeriodNextFreeIndex, ciscoSmartInstallGroups=ciscoSmartInstallGroups, csiJoinWindowPeriodRecurrencePattern=csiJoinWindowPeriodRecurrencePattern, csiBackupEnable=csiBackupEnable, csiNotifOperationResult=csiNotifOperationResult, ciscoSmartInstallNotificationsGroup=ciscoSmartInstallNotificationsGroup, csiManagementVlan=csiManagementVlan, ciscoSmartInstallCompliances=ciscoSmartInstallCompliances, csiJoinWindowConfigOperationMode=csiJoinWindowConfigOperationMode, csiProfileConfigUrl=csiProfileConfigUrl, ciscoSmartInstallMIB=ciscoSmartInstallMIB, csiDeviceAddressType=csiDeviceAddressType, csiJoinWindowPeriodExpirationDate=csiJoinWindowPeriodExpirationDate, PYSNMP_MODULE_ID=ciscoSmartInstallMIB, csiMatchIndex=csiMatchIndex, csiProfileImageTwoUrl=csiProfileImageTwoUrl, csiProfileRowStatus=csiProfileRowStatus, csiOperationModeChange=csiOperationModeChange, csiGlobalConfig=csiGlobalConfig, csiMatchSwitchNum=csiMatchSwitchNum, csiDeviceLost=csiDeviceLost, csiMatchTable=csiMatchTable, csiProfileEntry=csiProfileEntry, csiHostnamePrefix=csiHostnamePrefix, csiProfileIndex=csiProfileIndex, csiBackup=csiBackup, csiDeviceName=csiDeviceName, csiMatchGroupType=csiMatchGroupType, csiOperationMode=csiOperationMode, csiDeviceTable=csiDeviceTable, csiProfileTable=csiProfileTable, csiProfileImageUrl=csiProfileImageUrl, csiMatchHostAddressType=csiMatchHostAddressType, csiProfileGroupName=csiProfileGroupName, csiDeviceMacAddress=csiDeviceMacAddress, ciscoSmartInstallProfileGroup=ciscoSmartInstallProfileGroup, csiDeviceSerialNum=csiDeviceSerialNum, csiDeviceAdded=csiDeviceAdded, csiManagementVlansSecond2K=csiManagementVlansSecond2K, ciscoSmartInstallNotifyVarsGroup=ciscoSmartInstallNotifyVarsGroup, csiProfileNextFreeIndex=csiProfileNextFreeIndex, csiJoinWindowPeriodInterval=csiJoinWindowPeriodInterval, csiJoinWindowPeriodEntry=csiJoinWindowPeriodEntry, csiMatchRowStatus=csiMatchRowStatus, csiDeviceNum=csiDeviceNum, csiDeviceBackupConfigFileName=csiDeviceBackupConfigFileName, ciscoSmartInstallMIBObjects=ciscoSmartInstallMIBObjects)

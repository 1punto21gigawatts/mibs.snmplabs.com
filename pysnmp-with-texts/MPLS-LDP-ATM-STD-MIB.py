#
# PySNMP MIB module MPLS-LDP-ATM-STD-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/MPLS-LDP-ATM-STD-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:14:26 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ValueRangeConstraint, ConstraintsIntersection, ValueSizeConstraint, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ValueRangeConstraint", "ConstraintsIntersection", "ValueSizeConstraint", "SingleValueConstraint")
AtmVpIdentifier, = mibBuilder.importSymbols("ATM-TC-MIB", "AtmVpIdentifier")
InterfaceIndexOrZero, = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero")
mplsLdpEntityIndex, mplsLdpEntityLdpId, mplsLdpPeerLdpId = mibBuilder.importSymbols("MPLS-LDP-STD-MIB", "mplsLdpEntityIndex", "mplsLdpEntityLdpId", "mplsLdpPeerLdpId")
mplsStdMIB, MplsAtmVcIdentifier = mibBuilder.importSymbols("MPLS-TC-STD-MIB", "mplsStdMIB", "MplsAtmVcIdentifier")
NotificationGroup, ObjectGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ObjectGroup", "ModuleCompliance")
Bits, MibIdentifier, ModuleIdentity, Gauge32, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter64, IpAddress, Integer32, iso, Counter32, Unsigned32, TimeTicks, NotificationType, ObjectIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "MibIdentifier", "ModuleIdentity", "Gauge32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter64", "IpAddress", "Integer32", "iso", "Counter32", "Unsigned32", "TimeTicks", "NotificationType", "ObjectIdentity")
RowStatus, StorageType, TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "RowStatus", "StorageType", "TextualConvention", "DisplayString")
mplsLdpAtmStdMIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 10, 166, 5))
mplsLdpAtmStdMIB.setRevisions(('2004-06-03 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: mplsLdpAtmStdMIB.setRevisionsDescriptions(('Initial version published as part of RFC 3815.',))
if mibBuilder.loadTexts: mplsLdpAtmStdMIB.setLastUpdated('200406030000Z')
if mibBuilder.loadTexts: mplsLdpAtmStdMIB.setOrganization('Multiprotocol Label Switching (mpls) Working Group')
if mibBuilder.loadTexts: mplsLdpAtmStdMIB.setContactInfo('Joan Cucchiara (jcucchiara@mindspring.com) Marconi Communications, Inc. Hans Sjostrand (hans@ipunplugged.com) ipUnplugged James V. Luciani (james_luciani@mindspring.com) Marconi Communications, Inc. Working Group Chairs: George Swallow, email: swallow@cisco.com Loa Andersson, email: loa@pi.se MPLS Working Group, email: mpls@uu.net ')
if mibBuilder.loadTexts: mplsLdpAtmStdMIB.setDescription('Copyright (C) The Internet Society (2004). The initial version of this MIB module was published in RFC 3815. For full legal notices see the RFC itself or see: http://www.ietf.org/copyrights/ianamib.html This MIB contains managed object definitions for configuring and monitoring the Multiprotocol Label Switching (MPLS), Label Distribution Protocol (LDP), utilizing Asynchronous Transfer Mode (ATM) as the Layer 2 media.')
mplsLdpAtmObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 166, 5, 1))
mplsLdpAtmConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 166, 5, 2))
mplsLdpEntityAtmObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 1))
mplsLdpEntityAtmTable = MibTable((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 1, 1), )
if mibBuilder.loadTexts: mplsLdpEntityAtmTable.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityAtmTable.setDescription("This table contains ATM specific information which could be used in the 'Optional Parameters' and other ATM specific information. This table 'sparse augments' the mplsLdpEntityTable when ATM is the Layer 2 medium.")
mplsLdpEntityAtmEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 1, 1, 1), ).setIndexNames((0, "MPLS-LDP-STD-MIB", "mplsLdpEntityLdpId"), (0, "MPLS-LDP-STD-MIB", "mplsLdpEntityIndex"))
if mibBuilder.loadTexts: mplsLdpEntityAtmEntry.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityAtmEntry.setDescription('An entry in this table represents the ATM parameters and ATM information for this LDP entity.')
mplsLdpEntityAtmIfIndexOrZero = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 1, 1, 1, 1), InterfaceIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityAtmIfIndexOrZero.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityAtmIfIndexOrZero.setDescription('This value represents either the InterfaceIndex or 0 (zero). The value of zero means that the InterfaceIndex is not known. However, if the InterfaceIndex is known, then it must be represented by this value. If an InterfaceIndex becomes known, then the network management entity (e.g., SNMP agent) responsible for this object MUST change the value from 0 (zero) to the value of the InterfaceIndex. If an ATM Label is being used in forwarding data, then the value of this object MUST be the InterfaceIndex.')
mplsLdpEntityAtmMergeCap = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("notSupported", 0), ("vpMerge", 1), ("vcMerge", 2), ("vpAndVcMerge", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityAtmMergeCap.setReference('RFC3036, LDP Specification, Section 3.5.3 Initialization Message.')
if mibBuilder.loadTexts: mplsLdpEntityAtmMergeCap.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityAtmMergeCap.setDescription("Denotes the Merge Capability of this Entity. This is the EXACT value for the ATM Session Parameter, field M (for ATM Merge Capabilities). The ATM Session Parameter is an optional parameter in the Initialization Message. The description from rfc3036.txt is: 'M, ATM Merge Capabilities Specifies the merge capabilities of an ATM switch. The following values are supported in this version of the specification: Value Meaning 0 Merge not supported 1 VP Merge supported 2 VC Merge supported 3 VP & VC Merge supported If the merge capabilities of the LSRs differ, then: - Non-merge and VC-merge LSRs may freely interoperate. - The interoperability of VP-merge-capable switches with non-VP-merge-capable switches is a subject for future study. When the LSRs differ on the use of VP-merge, the session is established, but VP merge is not used.' Please refer to the following reference for a complete description of this feature.")
mplsLdpEntityAtmLRComponents = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 1, 1, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpEntityAtmLRComponents.setReference('RFC3036, LDP Specification, Section 3.5.3 Initialization Message.')
if mibBuilder.loadTexts: mplsLdpEntityAtmLRComponents.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityAtmLRComponents.setDescription("Number of Label Range Components in the Initialization message. This also represents the number of entries in the mplsLdpEntityAtmLRTable which correspond to this entry. This is the EXACT value for the ATM Session Parameter, field N (for Number of label range components). The ATM Session Parameter is an optional parameter in the Initialization Message. The description from rfc3036.txt is: 'N, Number of label range components Specifies the number of ATM Label Range Components included in the TLV.' Please refer to the following reference for a complete description of this feature.")
mplsLdpEntityAtmVcDirectionality = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("bidirectional", 0), ("unidirectional", 1)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityAtmVcDirectionality.setReference('RFC3036, LDP Specification, Section 3.5.3 Initialization Message.')
if mibBuilder.loadTexts: mplsLdpEntityAtmVcDirectionality.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityAtmVcDirectionality.setDescription("If the value of this object is 'bidirectional(0)', a given VCI, within a given VPI, is used as a label for both directions independently. If the value of this object is 'unidirectional(1)', a given VCI within a VPI designates one direction. This is the EXACT value for the ATM Session Parameter, field D (for VC Directionality). The ATM Session Parameter is an optional parameter in the Initialization Message. The description from rfc3036.txt is: 'D, VC Directionality A value of 0 specifies bidirectional VC capability, meaning the LSR can (within a given VPI) support the use of a given VCI as a label for both link directions independently. A value of 1 specifies unidirectional VC capability, meaning (within a given VPI) a given VCI may appear in a label mapping for one direction on the link only. When either or both of the peers specifies unidirectional VC capability, both LSRs use unidirectional VC label assignment for the link as follows. The LSRs compare their LDP Identifiers as unsigned integers. The LSR with the larger LDP Identifier may assign only odd-numbered VCIs in the VPI/VCI range as labels. The system with the smaller LDP Identifier may assign only even-numbered VCIs in the VPI/VCI range as labels.' Please refer to the following reference for a complete description of this feature.")
mplsLdpEntityAtmLsrConnectivity = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("direct", 1), ("indirect", 2))).clone('direct')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityAtmLsrConnectivity.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityAtmLsrConnectivity.setDescription('The peer LSR may be connected indirectly by means of an ATM VP so that the VPI values may be different on either endpoint so the label MUST be encoded entirely within the VCI field.')
mplsLdpEntityAtmDefaultControlVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 1, 1, 1, 6), AtmVpIdentifier()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityAtmDefaultControlVpi.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityAtmDefaultControlVpi.setDescription('The default VPI value for the non-MPLS connection. The default value of this is 0 (zero) but other values may be configured. This object allows a different value to be configured.')
mplsLdpEntityAtmDefaultControlVci = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 1, 1, 1, 7), MplsAtmVcIdentifier().clone(32)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityAtmDefaultControlVci.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityAtmDefaultControlVci.setDescription('The Default VCI value for a non-MPLS connection. The default value of this is 32 but other values may be configured. This object allows a different value to be configured.')
mplsLdpEntityAtmUnlabTrafVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 1, 1, 1, 8), AtmVpIdentifier()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityAtmUnlabTrafVpi.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityAtmUnlabTrafVpi.setDescription("VPI value of the VCC supporting unlabeled traffic. This non-MPLS connection is used to carry unlabeled (IP) packets. The default value is the same as the default value of the 'mplsLdpEntityAtmDefaultControlVpi', however another value may be configured.")
mplsLdpEntityAtmUnlabTrafVci = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 1, 1, 1, 9), MplsAtmVcIdentifier().clone(32)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityAtmUnlabTrafVci.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityAtmUnlabTrafVci.setDescription("VCI value of the VCC supporting unlabeled traffic. This non-MPLS connection is used to carry unlabeled (IP) packets. The default value is the same as the default value of the 'mplsLdpEntityAtmDefaultControlVci', however another value may be configured.")
mplsLdpEntityAtmStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 1, 1, 1, 10), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityAtmStorageType.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityAtmStorageType.setDescription("The storage type for this conceptual row. Conceptual rows having the value 'permanent(4)' need not allow write-access to any columnar objects in the row.")
mplsLdpEntityAtmRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 1, 1, 1, 11), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityAtmRowStatus.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityAtmRowStatus.setDescription("The status of this conceptual row. All writable objects in this row may be modified at any time, however, as described in detail in the section entitled, 'Changing Values After Session Establishment', and again described in the DESCRIPTION clause of the mplsLdpEntityAdminStatus object, if a session has been initiated with a Peer, changing objects in this table will wreak havoc with the session and interrupt traffic. To repeat again: the recommended procedure is to set the mplsLdpEntityAdminStatus to down, thereby explicitly causing a session to be torn down. Then, change objects in this entry, then set the mplsLdpEntityAdminStatus to enable which enables a new session to be initiated.")
mplsLdpEntityAtmLRTable = MibTable((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 1, 2), )
if mibBuilder.loadTexts: mplsLdpEntityAtmLRTable.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityAtmLRTable.setDescription("The MPLS LDP Entity ATM Label Range (LR) Table. The purpose of this table is to provide a mechanism for configuring a contiguous range of vpi's with a contiguous range of vci's, or a 'label range' for LDP Entities. LDP Entities which use ATM must have at least one entry in this table. There must exist at least one entry in this table for every LDP Entity that has 'mplsLdpEntityOptionalParameters' object with a value of 'atmSessionParameters'.")
mplsLdpEntityAtmLREntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 1, 2, 1), ).setIndexNames((0, "MPLS-LDP-STD-MIB", "mplsLdpEntityLdpId"), (0, "MPLS-LDP-STD-MIB", "mplsLdpEntityIndex"), (0, "MPLS-LDP-ATM-STD-MIB", "mplsLdpEntityAtmLRMinVpi"), (0, "MPLS-LDP-ATM-STD-MIB", "mplsLdpEntityAtmLRMinVci"))
if mibBuilder.loadTexts: mplsLdpEntityAtmLREntry.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityAtmLREntry.setDescription('A row in the LDP Entity ATM Label Range Table. One entry in this table contains information on a single range of labels represented by the configured Upper and Lower Bounds VPI/VCI pairs. These are the same data used in the Initialization Message. NOTE: The ranges for a specific LDP Entity are UNIQUE and non-overlapping. For example, for a specific LDP Entity index, there could be one entry having LowerBound vpi/vci == 0/32, and UpperBound vpi/vci == 0/100, and a second entry for this same interface with LowerBound vpi/vci == 0/101 and UpperBound vpi/vci == 0/200. However, there could not be a third entry with LowerBound vpi/vci == 0/200 and UpperBound vpi/vci == 0/300 because this label range overlaps with the second entry (i.e., both entries now have 0/200). A row will not become active unless a unique and non-overlapping range is specified. At least one label range entry for a specific LDP Entity MUST include the default VPI/VCI values denoted in the LDP Entity Table. A request to create a row with an overlapping range should result in an inconsistentValue error.')
mplsLdpEntityAtmLRMinVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 1, 2, 1, 1), AtmVpIdentifier())
if mibBuilder.loadTexts: mplsLdpEntityAtmLRMinVpi.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityAtmLRMinVpi.setDescription('The minimum VPI number configured for this range. The value of zero is a valid value for the VPI portion of the label.')
mplsLdpEntityAtmLRMinVci = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 1, 2, 1, 2), MplsAtmVcIdentifier())
if mibBuilder.loadTexts: mplsLdpEntityAtmLRMinVci.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityAtmLRMinVci.setDescription('The minimum VCI number configured for this range.')
mplsLdpEntityAtmLRMaxVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 1, 2, 1, 3), AtmVpIdentifier()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityAtmLRMaxVpi.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityAtmLRMaxVpi.setDescription('The maximum VPI number configured for this range.')
mplsLdpEntityAtmLRMaxVci = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 1, 2, 1, 4), MplsAtmVcIdentifier()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityAtmLRMaxVci.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityAtmLRMaxVci.setDescription('The maximum VCI number configured for this range.')
mplsLdpEntityAtmLRStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 1, 2, 1, 5), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityAtmLRStorageType.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityAtmLRStorageType.setDescription("The storage type for this conceptual row. Conceptual rows having the value 'permanent(4)' need not allow write-access to any columnar objects in the row.")
mplsLdpEntityAtmLRRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 1, 2, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityAtmLRRowStatus.setStatus('current')
if mibBuilder.loadTexts: mplsLdpEntityAtmLRRowStatus.setDescription("The status of this conceptual row. All writable objects in this row may be modified at any time, however, as described in detail in the section entitled, 'Changing Values After Session Establishment', and again described in the DESCRIPTION clause of the mplsLdpEntityAdminStatus object, if a session has been initiated with a Peer, changing objects in this table will wreak havoc with the session and interrupt traffic. To repeat again: the recommended procedure is to set the mplsLdpEntityAdminStatus to down, thereby explicitly causing a session to be torn down. Then, change objects in this entry, then set the mplsLdpEntityAdminStatus to enable which enables a new session to be initiated.")
mplsLdpAtmSessionObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 2))
mplsLdpAtmSessionTable = MibTable((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 2, 1), )
if mibBuilder.loadTexts: mplsLdpAtmSessionTable.setStatus('current')
if mibBuilder.loadTexts: mplsLdpAtmSessionTable.setDescription("A table which relates sessions in the 'mplsLdpSessionTable' and their label range intersections. There could be one or more label range intersections between an LDP Entity and LDP Peer using ATM as the underlying media. Each row represents a single label range intersection. This table cannot use the 'AUGMENTS' clause because there is not necessarily a one-to-one mapping between this table and the mplsLdpSessionTable.")
mplsLdpAtmSessionEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 2, 1, 1), ).setIndexNames((0, "MPLS-LDP-STD-MIB", "mplsLdpEntityLdpId"), (0, "MPLS-LDP-STD-MIB", "mplsLdpEntityIndex"), (0, "MPLS-LDP-STD-MIB", "mplsLdpPeerLdpId"), (0, "MPLS-LDP-ATM-STD-MIB", "mplsLdpSessionAtmLRLowerBoundVpi"), (0, "MPLS-LDP-ATM-STD-MIB", "mplsLdpSessionAtmLRLowerBoundVci"))
if mibBuilder.loadTexts: mplsLdpAtmSessionEntry.setStatus('current')
if mibBuilder.loadTexts: mplsLdpAtmSessionEntry.setDescription('An entry in this table represents information on a single label range intersection between an LDP Entity and LDP Peer. The information contained in a row is read-only.')
mplsLdpSessionAtmLRLowerBoundVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 2, 1, 1, 1), AtmVpIdentifier())
if mibBuilder.loadTexts: mplsLdpSessionAtmLRLowerBoundVpi.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionAtmLRLowerBoundVpi.setDescription('The minimum VPI number for this range.')
mplsLdpSessionAtmLRLowerBoundVci = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 2, 1, 1, 2), MplsAtmVcIdentifier())
if mibBuilder.loadTexts: mplsLdpSessionAtmLRLowerBoundVci.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionAtmLRLowerBoundVci.setDescription('The minimum VCI number for this range.')
mplsLdpSessionAtmLRUpperBoundVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 2, 1, 1, 3), AtmVpIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpSessionAtmLRUpperBoundVpi.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionAtmLRUpperBoundVpi.setDescription('The maximum VPI number for this range.')
mplsLdpSessionAtmLRUpperBoundVci = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 2, 1, 1, 4), MplsAtmVcIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpSessionAtmLRUpperBoundVci.setStatus('current')
if mibBuilder.loadTexts: mplsLdpSessionAtmLRUpperBoundVci.setDescription('The maximum VCI number for this range.')
mplsLdpAtmGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 166, 5, 2, 1))
mplsLdpAtmCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 166, 5, 2, 2))
mplsLdpAtmModuleFullCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 10, 166, 5, 2, 2, 1)).setObjects(("MPLS-LDP-ATM-STD-MIB", "mplsLdpAtmGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsLdpAtmModuleFullCompliance = mplsLdpAtmModuleFullCompliance.setStatus('current')
if mibBuilder.loadTexts: mplsLdpAtmModuleFullCompliance.setDescription('The Module is implemented with support for read-create and read-write. In other words, both monitoring and configuration are available when using this MODULE-COMPLIANCE.')
mplsLdpAtmModuleReadOnlyCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 10, 166, 5, 2, 2, 2)).setObjects(("MPLS-LDP-ATM-STD-MIB", "mplsLdpAtmGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsLdpAtmModuleReadOnlyCompliance = mplsLdpAtmModuleReadOnlyCompliance.setStatus('current')
if mibBuilder.loadTexts: mplsLdpAtmModuleReadOnlyCompliance.setDescription('The Module is implemented with support for read-only. In other words, only monitoring is available by implementing this MODULE-COMPLIANCE.')
mplsLdpAtmGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 166, 5, 2, 1, 1)).setObjects(("MPLS-LDP-ATM-STD-MIB", "mplsLdpEntityAtmIfIndexOrZero"), ("MPLS-LDP-ATM-STD-MIB", "mplsLdpEntityAtmMergeCap"), ("MPLS-LDP-ATM-STD-MIB", "mplsLdpEntityAtmLRComponents"), ("MPLS-LDP-ATM-STD-MIB", "mplsLdpEntityAtmVcDirectionality"), ("MPLS-LDP-ATM-STD-MIB", "mplsLdpEntityAtmLsrConnectivity"), ("MPLS-LDP-ATM-STD-MIB", "mplsLdpEntityAtmDefaultControlVpi"), ("MPLS-LDP-ATM-STD-MIB", "mplsLdpEntityAtmDefaultControlVci"), ("MPLS-LDP-ATM-STD-MIB", "mplsLdpEntityAtmUnlabTrafVpi"), ("MPLS-LDP-ATM-STD-MIB", "mplsLdpEntityAtmUnlabTrafVci"), ("MPLS-LDP-ATM-STD-MIB", "mplsLdpEntityAtmStorageType"), ("MPLS-LDP-ATM-STD-MIB", "mplsLdpEntityAtmRowStatus"), ("MPLS-LDP-ATM-STD-MIB", "mplsLdpEntityAtmLRMaxVpi"), ("MPLS-LDP-ATM-STD-MIB", "mplsLdpEntityAtmLRMaxVci"), ("MPLS-LDP-ATM-STD-MIB", "mplsLdpEntityAtmLRStorageType"), ("MPLS-LDP-ATM-STD-MIB", "mplsLdpEntityAtmLRRowStatus"), ("MPLS-LDP-ATM-STD-MIB", "mplsLdpSessionAtmLRUpperBoundVpi"), ("MPLS-LDP-ATM-STD-MIB", "mplsLdpSessionAtmLRUpperBoundVci"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsLdpAtmGroup = mplsLdpAtmGroup.setStatus('current')
if mibBuilder.loadTexts: mplsLdpAtmGroup.setDescription('Objects that apply to all MPLS LDP implementations using ATM as the Layer 2.')
mibBuilder.exportSymbols("MPLS-LDP-ATM-STD-MIB", mplsLdpAtmSessionTable=mplsLdpAtmSessionTable, mplsLdpAtmSessionEntry=mplsLdpAtmSessionEntry, mplsLdpEntityAtmLRMinVpi=mplsLdpEntityAtmLRMinVpi, mplsLdpEntityAtmStorageType=mplsLdpEntityAtmStorageType, mplsLdpAtmModuleReadOnlyCompliance=mplsLdpAtmModuleReadOnlyCompliance, mplsLdpEntityAtmObjects=mplsLdpEntityAtmObjects, mplsLdpSessionAtmLRUpperBoundVpi=mplsLdpSessionAtmLRUpperBoundVpi, mplsLdpEntityAtmLRMaxVci=mplsLdpEntityAtmLRMaxVci, mplsLdpAtmSessionObjects=mplsLdpAtmSessionObjects, mplsLdpEntityAtmVcDirectionality=mplsLdpEntityAtmVcDirectionality, mplsLdpSessionAtmLRUpperBoundVci=mplsLdpSessionAtmLRUpperBoundVci, mplsLdpEntityAtmLRMaxVpi=mplsLdpEntityAtmLRMaxVpi, mplsLdpEntityAtmLRComponents=mplsLdpEntityAtmLRComponents, mplsLdpEntityAtmIfIndexOrZero=mplsLdpEntityAtmIfIndexOrZero, mplsLdpEntityAtmDefaultControlVci=mplsLdpEntityAtmDefaultControlVci, mplsLdpEntityAtmRowStatus=mplsLdpEntityAtmRowStatus, mplsLdpEntityAtmUnlabTrafVci=mplsLdpEntityAtmUnlabTrafVci, mplsLdpEntityAtmLRMinVci=mplsLdpEntityAtmLRMinVci, PYSNMP_MODULE_ID=mplsLdpAtmStdMIB, mplsLdpAtmCompliances=mplsLdpAtmCompliances, mplsLdpEntityAtmUnlabTrafVpi=mplsLdpEntityAtmUnlabTrafVpi, mplsLdpSessionAtmLRLowerBoundVci=mplsLdpSessionAtmLRLowerBoundVci, mplsLdpEntityAtmDefaultControlVpi=mplsLdpEntityAtmDefaultControlVpi, mplsLdpEntityAtmTable=mplsLdpEntityAtmTable, mplsLdpAtmGroups=mplsLdpAtmGroups, mplsLdpAtmObjects=mplsLdpAtmObjects, mplsLdpEntityAtmLRTable=mplsLdpEntityAtmLRTable, mplsLdpEntityAtmEntry=mplsLdpEntityAtmEntry, mplsLdpAtmStdMIB=mplsLdpAtmStdMIB, mplsLdpEntityAtmMergeCap=mplsLdpEntityAtmMergeCap, mplsLdpEntityAtmLRRowStatus=mplsLdpEntityAtmLRRowStatus, mplsLdpAtmModuleFullCompliance=mplsLdpAtmModuleFullCompliance, mplsLdpEntityAtmLsrConnectivity=mplsLdpEntityAtmLsrConnectivity, mplsLdpEntityAtmLRStorageType=mplsLdpEntityAtmLRStorageType, mplsLdpSessionAtmLRLowerBoundVpi=mplsLdpSessionAtmLRLowerBoundVpi, mplsLdpEntityAtmLREntry=mplsLdpEntityAtmLREntry, mplsLdpAtmGroup=mplsLdpAtmGroup, mplsLdpAtmConformance=mplsLdpAtmConformance)

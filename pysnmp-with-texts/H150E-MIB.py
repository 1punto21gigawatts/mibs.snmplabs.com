#
# PySNMP MIB module H150E-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/H150E-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:20:58 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsIntersection, SingleValueConstraint, ValueSizeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsIntersection", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsUnion")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Bits, ObjectIdentity, Unsigned32, IpAddress, ModuleIdentity, Counter32, NotificationType, iso, MibIdentifier, Counter64, enterprises, TimeTicks, MibScalar, MibTable, MibTableRow, MibTableColumn, Gauge32, Integer32 = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "ObjectIdentity", "Unsigned32", "IpAddress", "ModuleIdentity", "Counter32", "NotificationType", "iso", "MibIdentifier", "Counter64", "enterprises", "TimeTicks", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Gauge32", "Integer32")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
sni = MibIdentifier((1, 3, 6, 1, 4, 1, 231))
siemensUnits = MibIdentifier((1, 3, 6, 1, 4, 1, 231, 7))
pn = MibIdentifier((1, 3, 6, 1, 4, 1, 231, 7, 2))
h150eOffice = ModuleIdentity((1, 3, 6, 1, 4, 1, 231, 7, 2, 9))
if mibBuilder.loadTexts: h150eOffice.setLastUpdated('0606080000Z')
if mibBuilder.loadTexts: h150eOffice.setOrganization('Siemens Communications')
if mibBuilder.loadTexts: h150eOffice.setContactInfo(' Technical Support ')
if mibBuilder.loadTexts: h150eOffice.setDescription('HiPath 3000 and Hicom 150E/H MIB.')
h150eControlGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 1))
h150eErrorHistoryGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 2))
h150eSystemInfoGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3))
h150eStatisticsGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 4))
h150eCdrConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 5))
h150eTrapSpecifications = MibIdentifier((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 6))
umProxyGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 8))
class DisplayString(OctetString):
    pass

class DateAndTime(TextualConvention, OctetString):
    description = 'A date-time specification identical to rfc 1443 definition. field octets contents range ----- ------ -------- ----- 1 1-2 year 0..65536 2 3 month 1..12 3 4 day 1..31 4 5 hour 0..23 5 6 minutes 0..59 6 7 seconds 0..60 (use 60 for leap-second) 7 8 deci-seconds 0..9 For example, Tuesday May 26, 2003 at 1:30:15 PM EDT would be displayed as: 2003-5-26,13:30:15.0'
    status = 'current'
    displayHint = '2d-1d-1d,1d:1d:1d.1d'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(8, 8)
    fixedLength = 8

class ReadWrite(TextualConvention, Integer32):
    description = 'A textual convention for describing objects that enable or disable some sort of write access.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("readWrite", 1), ("readOnly", 2))

h150eSysState = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("normal", 1), ("warning", 2), ("minor", 3), ("major", 4), ("critical", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: h150eSysState.setStatus('current')
if mibBuilder.loadTexts: h150eSysState.setDescription('The actual error state of the device. Contains the highest severity level of the recent error events. This object is updated automatically, but it can also be modified manually.')
tftpSwitchoverDateTime = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 1, 2), DateAndTime()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tftpSwitchoverDateTime.setStatus('current')
if mibBuilder.loadTexts: tftpSwitchoverDateTime.setDescription('Date and time for the switchover to the new system software. The configured time will be ignored, if the upgrade is started with the downloadAndImmediateSwitchover define of the tftpDownloadAction object. octet format: field octets contents range hex (range dez) ----- ------ -------- --------- ---------- 1 1-2 year 00 00 - FF FF (0 - 65536) 2 3 month 01 - 0C (1 - 12) 3 4 day 01 - 1F (1 - 31) 4 5 hour 00 - 17 (0 - 23) 5 6 minutes 00 - 3B (0 - 59) 6 7 seconds 00 - 3B (0 - 60) 7 8 deci-seconds 00 - 09 (0 - 9) For example, to configure Wednesday June 16, 1999 at 8:30:15 AM would be configured as 07 cf 06 10 08 1E 0F 00')
tftpDownloadAction = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notDownloading", 1), ("downloadAndImmediateSwitchover", 2), ("downloadAndDelayedSwitchover", 3), ("downloadWithoutSwitchover", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tftpDownloadAction.setStatus('current')
if mibBuilder.loadTexts: tftpDownloadAction.setDescription('When this object is set to downloadAndImmediateSwitchover (2), the device will download the new software from the configured host. After the download is finished, the device will automatically restart with the new software. If downloadAndDelayedSwitchover (3) is specified, the new image is copied to the device. When the tftpDateTime value is matched, the device discontinues its normal operation and does the software switchover. After an automatic reset, it starts with the new system software. Setting downloadWithoutSwitchover (4) initiates a download without switching over to the new software. When the device is not downloading, this object will have a value of notDownloading(1).')
h150eResetControl = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("running", 1), ("warmBoot", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: h150eResetControl.setStatus('current')
if mibBuilder.loadTexts: h150eResetControl.setDescription('Setting this object to warmBoot(2) causes the device to restart the application software with current configuration parameters saved in non-volatile memory. When the device is running normally, this variable has a value of running(1). The effect of configuring this object is identical to the configuration of the probeResetControl object of RFC 2021, except for the coldBoot option which is not supported.')
h150eSwitchoverState = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("readyForSwitchover", 1), ("notReadyForSwitchover", 2), ("initSwitchoverNow", 3), ("initSwitchoverDelayed", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: h150eSwitchoverState.setStatus('current')
if mibBuilder.loadTexts: h150eSwitchoverState.setDescription('The values readyForSwitchover (1) and notReadyForSwitchover (2) indicate whether the system is ready to be switched over to the new software that was downloaded to the shadow flash area, or not. If it is not passible, h150eShadowFlashState gives details on the reason. Setting this object to switchoverNow (3) causes the device to switchover immediately to the new software which was downloaded to the shadow flash area before and restart the system. initSwitchoverDelayed(4) causes a delayed switchover.')
h150eShadowFlashState = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("flashDeleted", 1), ("flashNotDeleted", 2), ("flashWriteProtected", 3), ("flashTooSmall", 4), ("deleteFlashNow", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: h150eShadowFlashState.setStatus('current')
if mibBuilder.loadTexts: h150eShadowFlashState.setDescription("This object informs about the state of the shadow flash memory area which is used to buffer a new software image that is being downloaded to the system. A download is only possible when the state is flashDeleted (1). It is not possible to download if the state is flashNotDeleted(2), nor if it's flashWriteProtected(3) (this means it is internally locked by software because the system is not in the state of accepting new flash data). If the flash memory is smaller than 8 MB ( flashTooSmall(4) ), no transfer is possible, too. It is possible to delete an inactive software image from the shadow flash area by setting deleteFlashNow (5).")
h150eLoadLevel = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: h150eLoadLevel.setStatus('current')
if mibBuilder.loadTexts: h150eLoadLevel.setDescription('The actual CPU load level (per cent).')
h150eTrapRepetitions = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: h150eTrapRepetitions.setStatus('current')
if mibBuilder.loadTexts: h150eTrapRepetitions.setDescription('The number of trap repetitions for error events marked as very important (log-and-multiple-trap).')
h150eCdrBufferState = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("accounting", 1), ("deleteBufferNow", 2), ("notAccounting", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: h150eCdrBufferState.setStatus('current')
if mibBuilder.loadTexts: h150eCdrBufferState.setDescription('Use this object to delete the CDR buffer.')
h150eLogBufferState = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("logging", 1), ("deleteBufferNow", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: h150eLogBufferState.setStatus('current')
if mibBuilder.loadTexts: h150eLogBufferState.setDescription('Use this object to delete the log data.')
numberOfErrorHistoryEntries = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 2, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483187))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: numberOfErrorHistoryEntries.setStatus('current')
if mibBuilder.loadTexts: numberOfErrorHistoryEntries.setDescription('Contains the number of errors to be found in the error history table. This value can be used to delete the last x entries (reduce value by x) or to delete all entries (value = 0).')
h150eErrorHistoryTable = MibTable((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 2, 2), )
if mibBuilder.loadTexts: h150eErrorHistoryTable.setStatus('current')
if mibBuilder.loadTexts: h150eErrorHistoryTable.setDescription('This table contains information about the errors that occured.')
h150eErrorHistoryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 2, 2, 1), ).setIndexNames((0, "H150E-MIB", "h150eErrorIndex"))
if mibBuilder.loadTexts: h150eErrorHistoryEntry.setStatus('current')
if mibBuilder.loadTexts: h150eErrorHistoryEntry.setDescription('The trap history table entries.')
h150eErrorIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483187))).setMaxAccess("readonly")
if mibBuilder.loadTexts: h150eErrorIndex.setStatus('current')
if mibBuilder.loadTexts: h150eErrorIndex.setDescription('Identification of an table entry enabled by this index.')
h150eErrorDateTime = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 2, 2, 1, 2), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: h150eErrorDateTime.setStatus('current')
if mibBuilder.loadTexts: h150eErrorDateTime.setDescription('Time, when the error occurred.')
h150eErrorClass = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483187))).setMaxAccess("readonly")
if mibBuilder.loadTexts: h150eErrorClass.setStatus('current')
if mibBuilder.loadTexts: h150eErrorClass.setDescription('Contains the error class number (type of trap).')
h150eErrorCode = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483187))).setMaxAccess("readonly")
if mibBuilder.loadTexts: h150eErrorCode.setStatus('current')
if mibBuilder.loadTexts: h150eErrorCode.setDescription('Contains the error code.')
h150eAccessSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483187))).setMaxAccess("readonly")
if mibBuilder.loadTexts: h150eAccessSlot.setStatus('current')
if mibBuilder.loadTexts: h150eAccessSlot.setDescription('Contains the access slot for the error.')
h150eAccessPort = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 2, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483187))).setMaxAccess("readonly")
if mibBuilder.loadTexts: h150eAccessPort.setStatus('current')
if mibBuilder.loadTexts: h150eAccessPort.setDescription('Contains the local access port of the error. Local means that port numbering starts with 0 for each card.')
h150eErrorDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 2, 2, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: h150eErrorDescription.setStatus('current')
if mibBuilder.loadTexts: h150eErrorDescription.setDescription('Detailed information about errors.')
h150eErrorSeverity = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 2, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("normal", 1), ("warning", 2), ("minor", 3), ("major", 4), ("critical", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: h150eErrorSeverity.setStatus('current')
if mibBuilder.loadTexts: h150eErrorSeverity.setDescription('Contains the severity of the specific error.')
sysHardwareVersion = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 25))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysHardwareVersion.setStatus('current')
if mibBuilder.loadTexts: sysHardwareVersion.setDescription('Contains the version string of the system hardware.')
sysSoftwareVersion = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 25))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSoftwareVersion.setStatus('current')
if mibBuilder.loadTexts: sysSoftwareVersion.setDescription('Contains the version string of the system software.')
sysCodeNumber = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 25))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysCodeNumber.setStatus('current')
if mibBuilder.loadTexts: sysCodeNumber.setDescription('Contains the code number of the system software.')
sysSoftwareLocation = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("lower", 1), ("upper", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSoftwareLocation.setStatus('current')
if mibBuilder.loadTexts: sysSoftwareLocation.setDescription('Contains location (address space) where the system software is currently running.')
numberOfSlotTableEntries = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483187))).setMaxAccess("readonly")
if mibBuilder.loadTexts: numberOfSlotTableEntries.setStatus('current')
if mibBuilder.loadTexts: numberOfSlotTableEntries.setDescription('Contains the number of entries in the slot table.')
h150eSlotTable = MibTable((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 6), )
if mibBuilder.loadTexts: h150eSlotTable.setStatus('current')
if mibBuilder.loadTexts: h150eSlotTable.setDescription('This table contains information about the system slots.')
h150eSlotTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 6, 1), ).setIndexNames((0, "H150E-MIB", "cardIndex"))
if mibBuilder.loadTexts: h150eSlotTableEntry.setStatus('current')
if mibBuilder.loadTexts: h150eSlotTableEntry.setDescription('The slot table entries.')
cardIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483187))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cardIndex.setStatus('current')
if mibBuilder.loadTexts: cardIndex.setDescription('Identification of an table entry enabled by this index.')
cardBoxNum = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 6, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483187))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cardBoxNum.setStatus('current')
if mibBuilder.loadTexts: cardBoxNum.setDescription('Index of the box where the card is placed.')
cardSlotNum = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 6, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483187))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cardSlotNum.setStatus('current')
if mibBuilder.loadTexts: cardSlotNum.setDescription('Index of the slot where the card is placed.')
cardType = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 6, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cardType.setStatus('current')
if mibBuilder.loadTexts: cardType.setDescription('Code for the type of the card.')
cardDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 6, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cardDescription.setStatus('current')
if mibBuilder.loadTexts: cardDescription.setDescription('Textual card description.')
cardCodeNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 6, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 25))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cardCodeNumber.setStatus('current')
if mibBuilder.loadTexts: cardCodeNumber.setDescription('Contains the code number of the card software.')
cardState = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 6, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("normal", 1), ("warning", 2), ("minor", 3), ("major", 4), ("critical", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cardState.setStatus('current')
if mibBuilder.loadTexts: cardState.setDescription('Contains the state of the card.')
numberOfPortTableEntries = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483187))).setMaxAccess("readonly")
if mibBuilder.loadTexts: numberOfPortTableEntries.setStatus('current')
if mibBuilder.loadTexts: numberOfPortTableEntries.setDescription('Contains the number of entries in the port table.')
h150ePortTable = MibTable((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 8), )
if mibBuilder.loadTexts: h150ePortTable.setStatus('current')
if mibBuilder.loadTexts: h150ePortTable.setDescription('This table contains information about the system ports.')
h150ePortTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 8, 1), ).setIndexNames((0, "H150E-MIB", "portIndex"))
if mibBuilder.loadTexts: h150ePortTableEntry.setStatus('current')
if mibBuilder.loadTexts: h150ePortTableEntry.setDescription('The port table entries.')
portIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 8, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483187))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portIndex.setStatus('current')
if mibBuilder.loadTexts: portIndex.setDescription('Identification of an table entry enabled by this index.')
portCardIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 8, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483187))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portCardIndex.setStatus('current')
if mibBuilder.loadTexts: portCardIndex.setDescription('Reference to the card the port is assigned to.')
portType = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 8, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portType.setStatus('current')
if mibBuilder.loadTexts: portType.setDescription('Contains the type of the port.')
portState = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 8, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("inactive", 1), ("active", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portState.setStatus('current')
if mibBuilder.loadTexts: portState.setDescription('Contains the general state of the port.')
portLock = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 8, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unlocked", 1), ("lockedBySoftware", 2), ("lockedByHardware", 3), ("lockedBySoftAndHardware", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portLock.setStatus('current')
if mibBuilder.loadTexts: portLock.setDescription('This object contains the lock state of the port. A software lock can be enabled / disabled. Possible state transitions: unlocked -> lockedBySoftware lockedByHardware -> lockedBySoftAndHardware lockedBySoftware -> unlocked lockedBySoftAndHardware -> lockedByHardware')
portLogicalPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 8, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483187))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portLogicalPortNumber.setStatus('current')
if mibBuilder.loadTexts: portLogicalPortNumber.setDescription('The logical port number.')
numberOfExtensionTableEntries = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483187))).setMaxAccess("readonly")
if mibBuilder.loadTexts: numberOfExtensionTableEntries.setStatus('current')
if mibBuilder.loadTexts: numberOfExtensionTableEntries.setDescription('Contains the number of entries in the hardware extension table.')
h150eExtensionTable = MibTable((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 10), )
if mibBuilder.loadTexts: h150eExtensionTable.setStatus('current')
if mibBuilder.loadTexts: h150eExtensionTable.setDescription('This table contains information about the hardware extensions.')
h150eExtensionTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 10, 1), ).setIndexNames((0, "H150E-MIB", "extensionIndex"))
if mibBuilder.loadTexts: h150eExtensionTableEntry.setStatus('current')
if mibBuilder.loadTexts: h150eExtensionTableEntry.setDescription('The extension table entries.')
extensionIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 10, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483187))).setMaxAccess("readonly")
if mibBuilder.loadTexts: extensionIndex.setStatus('current')
if mibBuilder.loadTexts: extensionIndex.setDescription('Identification of an table entry enabled by this index.')
extensionDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 10, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: extensionDescription.setStatus('current')
if mibBuilder.loadTexts: extensionDescription.setDescription('Contains a textual desription of the hardware extension.')
extensionCodeNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 10, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: extensionCodeNumber.setStatus('current')
if mibBuilder.loadTexts: extensionCodeNumber.setDescription('Contains the code number of the hardware extension.')
numberOfLanConnTableEntries = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483187))).setMaxAccess("readonly")
if mibBuilder.loadTexts: numberOfLanConnTableEntries.setStatus('current')
if mibBuilder.loadTexts: numberOfLanConnTableEntries.setDescription('Contains the number of entries in the LAN connection table.')
h150eLanConnTable = MibTable((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 12), )
if mibBuilder.loadTexts: h150eLanConnTable.setStatus('current')
if mibBuilder.loadTexts: h150eLanConnTable.setDescription('This table contains information about the interfaces available for LAN access of the device or its cards.')
h150eLanConnTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 12, 1), ).setIndexNames((0, "H150E-MIB", "lanConnIndex"))
if mibBuilder.loadTexts: h150eLanConnTableEntry.setStatus('current')
if mibBuilder.loadTexts: h150eLanConnTableEntry.setDescription('The LAN connection table entries.')
lanConnIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 12, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483187))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lanConnIndex.setStatus('current')
if mibBuilder.loadTexts: lanConnIndex.setDescription('Identification of an table entry enabled by this index.')
lanConnDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 12, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lanConnDescription.setStatus('current')
if mibBuilder.loadTexts: lanConnDescription.setDescription('Textual desription on the LAN connection.')
lanConnIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 12, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lanConnIpAddress.setStatus('current')
if mibBuilder.loadTexts: lanConnIpAddress.setDescription('IP address of the LAN connection.')
lanConnSubnetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 12, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lanConnSubnetMask.setStatus('current')
if mibBuilder.loadTexts: lanConnSubnetMask.setDescription('Subnet mask of the LAN connection.')
lanConnStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 12, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lanConnStatus.setStatus('current')
if mibBuilder.loadTexts: lanConnStatus.setDescription('Status of the LAN Connection.')
hiPathAllServeServerIpAddress = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 13), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hiPathAllServeServerIpAddress.setStatus('current')
if mibBuilder.loadTexts: hiPathAllServeServerIpAddress.setDescription('IP address of the HiPath AllServe (Venus) server.')
indexOfLastPortStatusNotificationTrap = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483187))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: indexOfLastPortStatusNotificationTrap.setStatus('current')
if mibBuilder.loadTexts: indexOfLastPortStatusNotificationTrap.setDescription("Index of last 'port status change' notification trap sent by the device. Note: only reset possible (0)")
sysSnmpAgentVersion = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 15), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSnmpAgentVersion.setStatus('current')
if mibBuilder.loadTexts: sysSnmpAgentVersion.setDescription('Version number of the systems SNMP agent (formatting: x.y.z.)')
sysShadowSoftwareVersion = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 16), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 25))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysShadowSoftwareVersion.setStatus('current')
if mibBuilder.loadTexts: sysShadowSoftwareVersion.setDescription('Contains the version string of the inactive (shadow) system software. This is the software image that has been transferred to the system without triggering the software switchover afterwards.')
sysHiPathSymbolSubInfo = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 17), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysHiPathSymbolSubInfo.setStatus('current')
if mibBuilder.loadTexts: sysHiPathSymbolSubInfo.setDescription('Contains an URL to detailed symbol information in addition to the symbol information contained in the common mib object deviceSymbolInfo.')
sysHiPathBranding = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 18), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysHiPathBranding.setStatus('current')
if mibBuilder.loadTexts: sysHiPathBranding.setDescription('Contains the branding string of the device.')
sysTimezoneOffset = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1440, 1440))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysTimezoneOffset.setStatus('current')
if mibBuilder.loadTexts: sysTimezoneOffset.setDescription('Timezone offset in minutes.')
numberOfFeatureStatTableEntries = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 4, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483187))).setMaxAccess("readonly")
if mibBuilder.loadTexts: numberOfFeatureStatTableEntries.setStatus('current')
if mibBuilder.loadTexts: numberOfFeatureStatTableEntries.setDescription('Contains the number of feature counters to be found in the table.')
h150eFeatureStatTable = MibTable((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 4, 2), )
if mibBuilder.loadTexts: h150eFeatureStatTable.setStatus('current')
if mibBuilder.loadTexts: h150eFeatureStatTable.setDescription('This table contains information about the usage of specific system features. It is designed to monitor the use of these features for a limited time only, because each counter is limited to one byte.')
h150eFeatureStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 4, 2, 1), ).setIndexNames((0, "H150E-MIB", "featureIndex"))
if mibBuilder.loadTexts: h150eFeatureStatEntry.setStatus('current')
if mibBuilder.loadTexts: h150eFeatureStatEntry.setDescription('The feature statistics table entries.')
featureIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 4, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483187))).setMaxAccess("readonly")
if mibBuilder.loadTexts: featureIndex.setStatus('current')
if mibBuilder.loadTexts: featureIndex.setDescription('Identification of an table entry enabled by this index.')
featureDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 4, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: featureDescription.setStatus('current')
if mibBuilder.loadTexts: featureDescription.setDescription('Description of the feature.')
featureCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 4, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483187))).setMaxAccess("readonly")
if mibBuilder.loadTexts: featureCounter.setStatus('current')
if mibBuilder.loadTexts: featureCounter.setDescription('This Counter indicates how often the feature was used since last system reload')
featureStatTableReset = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 4, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("counting", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: featureStatTableReset.setStatus('current')
if mibBuilder.loadTexts: featureStatTableReset.setDescription('Enables reset (2) of all counters of the featureStatTable.')
h150eCdrSeparator = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 5, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dosMode", 1), ("unixMode", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: h150eCdrSeparator.setStatus('current')
if mibBuilder.loadTexts: h150eCdrSeparator.setDescription('Separator between following CDRs: DOS mode (1): CRLF UNIX mode (2): LF')
h150eCdrElementSeparator = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 5, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(124, 59, 32))).clone(namedValues=NamedValues(("pipe", 124), ("semicolon", 59), ("blank", 32)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: h150eCdrElementSeparator.setStatus('current')
if mibBuilder.loadTexts: h150eCdrElementSeparator.setDescription("Separator between the different elements of one CDR: pipe (0x7c): '|' semicolon (0x3b): ';' blank (0x20): ' ' NOTE: no write access for blank")
h150eCdrThresholdValue = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 5, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483187))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: h150eCdrThresholdValue.setStatus('current')
if mibBuilder.loadTexts: h150eCdrThresholdValue.setDescription('CDR buffer limit (only relevant for TFTP server mode): threshold value (in percent) for sending a CDR data notification trap recommended values: 0 to 80')
h150eCdrTftpFileCounter = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 5, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483187))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: h150eCdrTftpFileCounter.setStatus('current')
if mibBuilder.loadTexts: h150eCdrTftpFileCounter.setDescription(" CDR <FileCounter> (only relevant for TFTP client mode): For each transferred CDR-file a new filename is necassary filename: 'GDS<IPAdr>.c<FileCounter>'")
h150eCdrTftpServerDestAddress = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 5, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: h150eCdrTftpServerDestAddress.setStatus('current')
if mibBuilder.loadTexts: h150eCdrTftpServerDestAddress.setDescription('Destination IP addresse of CDR TFTP server (only relevant for TFTP client mode)')
h150eCdrTftpServerAlternateDestAddress = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 5, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: h150eCdrTftpServerAlternateDestAddress.setStatus('current')
if mibBuilder.loadTexts: h150eCdrTftpServerAlternateDestAddress.setDescription('Alternate destination IP addresse of CDR TFTP server (only relevant for TFTP client mode): is the CDR TFTP Server not reachable the switch transfers CDR data to this alternative server')
h150eCdrTftpClientTimer = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 5, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483187))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: h150eCdrTftpClientTimer.setStatus('current')
if mibBuilder.loadTexts: h150eCdrTftpClientTimer.setDescription('cycle time in minutes for initiating CDR output, max value 1439 minutes (23hours,59minutes) (only relevant for TFTP client mode)')
h150eCdrTcpServerDestAddress = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 5, 8), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: h150eCdrTcpServerDestAddress.setStatus('current')
if mibBuilder.loadTexts: h150eCdrTcpServerDestAddress.setDescription('Destination IP addresse of CDR TCP server (only relevant for TCP client mode)')
h150eCdrTcpServerDestPort = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 5, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483187))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: h150eCdrTcpServerDestPort.setStatus('current')
if mibBuilder.loadTexts: h150eCdrTcpServerDestPort.setDescription('Destination TCP port of CDR TCP server (only relevant for TCP client mode)')
h150eCdrOutputMode = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 5, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("v24port", 1), ("uPNport", 2), ("pCVPLport", 3), ("tftpClient", 4), ("tftpServer", 5), ("tcpClient", 6), ("noOutput", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: h150eCdrOutputMode.setStatus('current')
if mibBuilder.loadTexts: h150eCdrOutputMode.setDescription('CDR (Call Detailed Record) output mode: V24-Port (1): the PABX is permanently connected over a V.24 connection to an extern application and sends each CDR immidiatly NOTE: no write access UPN-Port (2): the PABX is permanently connected over terminal adapter (PPM) connection to an extern application and sends each CDR immidiatly NOTE: no write access PCVPL-Port (3): the PEBX is permanently connected over a CorNet TS connection to an extern application (PCVPL) and sends each CDR immidiatly NOTE: no write access TFTP-Client (4): the PABX sends the collected CDRs to the administrated TFTP-Server TFTP-Server (5): an extern TFTP client can request the collected CDRs TCP-Client (6): the PABX is permanently connected to an extern TCP server and sends each CDR immidiatly NoOutput (7): no output for CDR')
h150eIndexOfLastCdrNotificationTrap = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 5, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483187))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: h150eIndexOfLastCdrNotificationTrap.setStatus('current')
if mibBuilder.loadTexts: h150eIndexOfLastCdrNotificationTrap.setDescription('Index of last CDR notification trap sent by device Note: only reset possible (0)')
h150etypeOfLastCdrNotificationTrap = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 5, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483187))).setMaxAccess("readonly")
if mibBuilder.loadTexts: h150etypeOfLastCdrNotificationTrap.setStatus('current')
if mibBuilder.loadTexts: h150etypeOfLastCdrNotificationTrap.setDescription("Type of last CDR notification trap sent by the the device: (1) : error - CDR buffer overflow (2) : warning - CDR buffer is filled up over 80% (3) : notification - administrateable CDR buffer threshold is reached -> extern TFTP client has to get the collected CDRs (4) : warning - TCP Client couldn't reach administrated server (5) : warning - TFTP Client couldn't reach administrated server (6) : warning - TFTP Client couldn't reach administrated alternative server")
h150eDescriptionOfLastCdrNotificationTrap = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 5, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: h150eDescriptionOfLastCdrNotificationTrap.setStatus('current')
if mibBuilder.loadTexts: h150eDescriptionOfLastCdrNotificationTrap.setDescription('Textual description of last CDR notification trap sent by the device')
sendAlarm = NotificationType((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 6, 1)).setObjects(("H150E-MIB", "h150eErrorIndex"), ("H150E-MIB", "h150eErrorDateTime"), ("H150E-MIB", "h150eErrorClass"), ("H150E-MIB", "h150eErrorCode"), ("H150E-MIB", "h150eAccessSlot"), ("H150E-MIB", "h150eAccessPort"), ("H150E-MIB", "h150eErrorDescription"), ("H150E-MIB", "h150eSysState"), ("H150E-MIB", "h150eErrorSeverity"))
if mibBuilder.loadTexts: sendAlarm.setStatus('current')
if mibBuilder.loadTexts: sendAlarm.setDescription('If an error occurs, there will be checked if the errorClass is configured to trigger an immediate signalling. If so, a trap will be send to the management station containing the information shown above.')
sendCdrNotification = NotificationType((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 6, 2)).setObjects(("H150E-MIB", "h150eIndexOfLastCdrNotificationTrap"), ("H150E-MIB", "h150etypeOfLastCdrNotificationTrap"), ("H150E-MIB", "h150eDescriptionOfLastCdrNotificationTrap"))
if mibBuilder.loadTexts: sendCdrNotification.setStatus('current')
if mibBuilder.loadTexts: sendCdrNotification.setDescription('The CDR notification trap is sent to trigger further actions by the management station, for instance download of CDR data.')
sendPortStatusNotification = NotificationType((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 6, 3)).setObjects(("H150E-MIB", "indexOfLastPortStatusNotificationTrap"))
if mibBuilder.loadTexts: sendPortStatusNotification.setStatus('current')
if mibBuilder.loadTexts: sendPortStatusNotification.setDescription("The 'port status change' notification trap is sent to trigger a polling of the port table by a management station. It indicates one or more changes in port states.")
sendUmRelatedChangeNotification = NotificationType((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 6, 4)).setObjects(("H150E-MIB", "umTrapIdentifier"), ("H150E-MIB", "umTrapType"), ("H150E-MIB", "umTrapLogicalPortNumber"), ("H150E-MIB", "umNetworkElementKey"))
if mibBuilder.loadTexts: sendUmRelatedChangeNotification.setStatus('current')
if mibBuilder.loadTexts: sendUmRelatedChangeNotification.setDescription('This trap is sent (to UM proxy), as the system detects changes.')
umNodeNumber = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 8, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: umNodeNumber.setStatus('current')
if mibBuilder.loadTexts: umNodeNumber.setDescription('The node number of the system. Unique number identifying the PBX.')
umSrsEnabled = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 8, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: umSrsEnabled.setStatus('current')
if mibBuilder.loadTexts: umSrsEnabled.setDescription('Indicates whether the SRS feature flag of the machine is enabled or not. The small remote site flag is an overall flag of the system.')
umDefaultLanguage = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 8, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("german", 1), ("english", 2), ("french", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: umDefaultLanguage.setStatus('current')
if mibBuilder.loadTexts: umDefaultLanguage.setDescription('Default language')
umNumberOfSubscriberEntries = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 8, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483187))).setMaxAccess("readonly")
if mibBuilder.loadTexts: umNumberOfSubscriberEntries.setStatus('current')
if mibBuilder.loadTexts: umNumberOfSubscriberEntries.setDescription('Number of entries in subscriber table.')
umSubscriberTable = MibTable((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 8, 5), )
if mibBuilder.loadTexts: umSubscriberTable.setStatus('current')
if mibBuilder.loadTexts: umSubscriberTable.setDescription('This table contains information about all HFA-Clients available for UM-configuration.')
umSubscriberTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 8, 5, 1), ).setIndexNames((0, "H150E-MIB", "umLogicalPortNumber"))
if mibBuilder.loadTexts: umSubscriberTableEntry.setStatus('current')
if mibBuilder.loadTexts: umSubscriberTableEntry.setDescription('The UM-subscriber table entries.')
umLogicalPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 8, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9999))).setMaxAccess("readonly")
if mibBuilder.loadTexts: umLogicalPortNumber.setStatus('current')
if mibBuilder.loadTexts: umLogicalPortNumber.setDescription('The logical port number of the subscriber.')
umInternalCallNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 8, 5, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: umInternalCallNumber.setStatus('current')
if mibBuilder.loadTexts: umInternalCallNumber.setDescription('The internal call number of the subscriber.')
umDIDNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 8, 5, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: umDIDNumber.setStatus('current')
if mibBuilder.loadTexts: umDIDNumber.setDescription('The DID number of the subscriber.')
umE164Number = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 8, 5, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: umE164Number.setStatus('current')
if mibBuilder.loadTexts: umE164Number.setDescription('The E.164 call number of the subscriber.')
umDisplayName = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 8, 5, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: umDisplayName.setStatus('current')
if mibBuilder.loadTexts: umDisplayName.setDescription('The display name of the subscriber.')
umStationType = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 8, 5, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("s0", 0), ("up0", 1), ("hfa", 2), ("analog", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: umStationType.setStatus('current')
if mibBuilder.loadTexts: umStationType.setDescription('The type of the station. e.g. UP0, S0, HFA, ...')
umPortStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 8, 5, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("inactive", 0), ("active", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: umPortStatus.setStatus('current')
if mibBuilder.loadTexts: umPortStatus.setDescription('The status of the logical port.')
umClassOfService = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 8, 5, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: umClassOfService.setStatus('current')
if mibBuilder.loadTexts: umClassOfService.setDescription('Classes of service can be used to restrict external calls. The types of calls that can be made from each station are defined for this purpose.')
umDisplayLanguage = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 8, 5, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("german", 1), ("english", 2), ("french", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: umDisplayLanguage.setStatus('current')
if mibBuilder.loadTexts: umDisplayLanguage.setDescription('Display language')
umCfssTarget = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 8, 5, 1, 10), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: umCfssTarget.setStatus('current')
if mibBuilder.loadTexts: umCfssTarget.setDescription('The target for Call Forwarding for Station out of Service.')
umNumberOfUnconfirmedTraps = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 8, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483187))).setMaxAccess("readonly")
if mibBuilder.loadTexts: umNumberOfUnconfirmedTraps.setStatus('current')
if mibBuilder.loadTexts: umNumberOfUnconfirmedTraps.setDescription('Number of entries in the umUnconfirmedTrapTable. A trap is confirmed and as result removed from the table, when its entry in the table is requested in a GetRequest for the 1st time. Traps presented in the table are retried as long as a GetRequest arrives.')
umUnconfirmedTrapTable = MibTable((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 8, 7), )
if mibBuilder.loadTexts: umUnconfirmedTrapTable.setStatus('current')
if mibBuilder.loadTexts: umUnconfirmedTrapTable.setDescription('This table contains information about traps sent to UM-Proxy. The contained traps have not yet been confirmed.')
umUnconfirmedTrapTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 8, 7, 1), ).setIndexNames((0, "H150E-MIB", "umTrapIdentifier"))
if mibBuilder.loadTexts: umUnconfirmedTrapTableEntry.setStatus('current')
if mibBuilder.loadTexts: umUnconfirmedTrapTableEntry.setDescription('The unconfirmed traps table entries.')
umTrapIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 8, 7, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483187))).setMaxAccess("readonly")
if mibBuilder.loadTexts: umTrapIdentifier.setStatus('current')
if mibBuilder.loadTexts: umTrapIdentifier.setDescription('Unique identifier of the trap. A SetRequest with value 0 removes the entry from the table. A value unequal to 0 is erroneous.')
umTrapType = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 8, 7, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("startup", 0), ("modifyGeneral", 1), ("modifySubscriber", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: umTrapType.setStatus('current')
if mibBuilder.loadTexts: umTrapType.setDescription('The type of trap sent. Startup traps are sent as the system resets. The 2 types of modify traps aim on distinguishing between modification that are subscriber- related and those that are global.')
umTrapLogicalPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 8, 7, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483187))).setMaxAccess("readonly")
if mibBuilder.loadTexts: umTrapLogicalPortNumber.setStatus('current')
if mibBuilder.loadTexts: umTrapLogicalPortNumber.setDescription('In case of a modifySubscriber-type trap, the logical port number that was the reason for the traps is presented here. For the other umTrapTypes, the content is undefined!')
umNetworkElementKey = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 8, 8), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: umNetworkElementKey.setStatus('current')
if mibBuilder.loadTexts: umNetworkElementKey.setDescription('A key that uniquely identifies the node towards UM. For a HiPath 3000/5000 this would be the IP-address, A simulator should additionally provide the port.')
mibBuilder.exportSymbols("H150E-MIB", h150eCdrOutputMode=h150eCdrOutputMode, cardSlotNum=cardSlotNum, portType=portType, sysTimezoneOffset=sysTimezoneOffset, h150eFeatureStatTable=h150eFeatureStatTable, umClassOfService=umClassOfService, sysSnmpAgentVersion=sysSnmpAgentVersion, h150eErrorDescription=h150eErrorDescription, umUnconfirmedTrapTableEntry=umUnconfirmedTrapTableEntry, h150eLanConnTable=h150eLanConnTable, h150eErrorHistoryEntry=h150eErrorHistoryEntry, numberOfLanConnTableEntries=numberOfLanConnTableEntries, indexOfLastPortStatusNotificationTrap=indexOfLastPortStatusNotificationTrap, h150eLanConnTableEntry=h150eLanConnTableEntry, sysSoftwareLocation=sysSoftwareLocation, h150eSlotTableEntry=h150eSlotTableEntry, umCfssTarget=umCfssTarget, sysHardwareVersion=sysHardwareVersion, sendPortStatusNotification=sendPortStatusNotification, cardType=cardType, extensionCodeNumber=extensionCodeNumber, numberOfExtensionTableEntries=numberOfExtensionTableEntries, umTrapType=umTrapType, portLock=portLock, lanConnDescription=lanConnDescription, h150eCdrThresholdValue=h150eCdrThresholdValue, umSrsEnabled=umSrsEnabled, h150eCdrTftpFileCounter=h150eCdrTftpFileCounter, umSubscriberTableEntry=umSubscriberTableEntry, extensionDescription=extensionDescription, sysCodeNumber=sysCodeNumber, siemensUnits=siemensUnits, DisplayString=DisplayString, h150eErrorCode=h150eErrorCode, tftpSwitchoverDateTime=tftpSwitchoverDateTime, umNumberOfSubscriberEntries=umNumberOfSubscriberEntries, umLogicalPortNumber=umLogicalPortNumber, sendUmRelatedChangeNotification=sendUmRelatedChangeNotification, umSubscriberTable=umSubscriberTable, featureStatTableReset=featureStatTableReset, h150eSystemInfoGroup=h150eSystemInfoGroup, cardCodeNumber=cardCodeNumber, sendCdrNotification=sendCdrNotification, umNumberOfUnconfirmedTraps=umNumberOfUnconfirmedTraps, numberOfSlotTableEntries=numberOfSlotTableEntries, portIndex=portIndex, h150etypeOfLastCdrNotificationTrap=h150etypeOfLastCdrNotificationTrap, h150eErrorSeverity=h150eErrorSeverity, h150eErrorHistoryGroup=h150eErrorHistoryGroup, umNodeNumber=umNodeNumber, h150eCdrElementSeparator=h150eCdrElementSeparator, h150eErrorIndex=h150eErrorIndex, portCardIndex=portCardIndex, h150eOffice=h150eOffice, h150eSysState=h150eSysState, umDIDNumber=umDIDNumber, cardIndex=cardIndex, featureDescription=featureDescription, umProxyGroup=umProxyGroup, h150eAccessPort=h150eAccessPort, h150eExtensionTable=h150eExtensionTable, h150eAccessSlot=h150eAccessSlot, h150eSlotTable=h150eSlotTable, h150eCdrBufferState=h150eCdrBufferState, h150eCdrTftpClientTimer=h150eCdrTftpClientTimer, h150eCdrConfigGroup=h150eCdrConfigGroup, sni=sni, lanConnIpAddress=lanConnIpAddress, h150eErrorDateTime=h150eErrorDateTime, h150eCdrSeparator=h150eCdrSeparator, umPortStatus=umPortStatus, h150eControlGroup=h150eControlGroup, umTrapIdentifier=umTrapIdentifier, umE164Number=umE164Number, h150eShadowFlashState=h150eShadowFlashState, lanConnIndex=lanConnIndex, sysHiPathSymbolSubInfo=sysHiPathSymbolSubInfo, h150eLoadLevel=h150eLoadLevel, portState=portState, lanConnSubnetMask=lanConnSubnetMask, h150ePortTableEntry=h150ePortTableEntry, h150eFeatureStatEntry=h150eFeatureStatEntry, h150ePortTable=h150ePortTable, numberOfPortTableEntries=numberOfPortTableEntries, extensionIndex=extensionIndex, h150eLogBufferState=h150eLogBufferState, sysShadowSoftwareVersion=sysShadowSoftwareVersion, h150eErrorClass=h150eErrorClass, numberOfErrorHistoryEntries=numberOfErrorHistoryEntries, DateAndTime=DateAndTime, numberOfFeatureStatTableEntries=numberOfFeatureStatTableEntries, h150eTrapRepetitions=h150eTrapRepetitions, h150eCdrTftpServerAlternateDestAddress=h150eCdrTftpServerAlternateDestAddress, umDefaultLanguage=umDefaultLanguage, sysHiPathBranding=sysHiPathBranding, h150eErrorHistoryTable=h150eErrorHistoryTable, sendAlarm=sendAlarm, h150eCdrTcpServerDestPort=h150eCdrTcpServerDestPort, h150eIndexOfLastCdrNotificationTrap=h150eIndexOfLastCdrNotificationTrap, umStationType=umStationType, cardDescription=cardDescription, h150eCdrTcpServerDestAddress=h150eCdrTcpServerDestAddress, hiPathAllServeServerIpAddress=hiPathAllServeServerIpAddress, ReadWrite=ReadWrite, umInternalCallNumber=umInternalCallNumber, lanConnStatus=lanConnStatus, featureCounter=featureCounter, cardBoxNum=cardBoxNum, umTrapLogicalPortNumber=umTrapLogicalPortNumber, tftpDownloadAction=tftpDownloadAction, h150eSwitchoverState=h150eSwitchoverState, umDisplayLanguage=umDisplayLanguage, PYSNMP_MODULE_ID=h150eOffice, cardState=cardState, h150eCdrTftpServerDestAddress=h150eCdrTftpServerDestAddress, h150eExtensionTableEntry=h150eExtensionTableEntry, umNetworkElementKey=umNetworkElementKey, umUnconfirmedTrapTable=umUnconfirmedTrapTable, h150eTrapSpecifications=h150eTrapSpecifications, pn=pn, featureIndex=featureIndex, umDisplayName=umDisplayName, h150eStatisticsGroup=h150eStatisticsGroup, sysSoftwareVersion=sysSoftwareVersion, portLogicalPortNumber=portLogicalPortNumber, h150eDescriptionOfLastCdrNotificationTrap=h150eDescriptionOfLastCdrNotificationTrap, h150eResetControl=h150eResetControl)

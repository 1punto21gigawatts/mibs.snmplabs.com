#
# PySNMP MIB module LIGHTSTREAM-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/LIGHTSTREAM-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:07:04 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueRangeConstraint, ConstraintsUnion, ValueSizeConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueRangeConstraint", "ConstraintsUnion", "ValueSizeConstraint", "ConstraintsIntersection")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Unsigned32, Gauge32, Counter32, IpAddress, iso, mib_2, ModuleIdentity, TimeTicks, Integer32, Counter64, ObjectIdentity, enterprises, Bits, NotificationType, MibIdentifier, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn = mibBuilder.importSymbols("SNMPv2-SMI", "Unsigned32", "Gauge32", "Counter32", "IpAddress", "iso", "mib-2", "ModuleIdentity", "TimeTicks", "Integer32", "Counter64", "ObjectIdentity", "enterprises", "Bits", "NotificationType", "MibIdentifier", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
class LightStreamStatus(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("enabled", 1), ("disabled", 2))

class LightStreamValidation(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("valid", 1), ("invalid", 2))

class LightStreamFilterAction(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("forward", 1), ("block", 2))

lightStream = MibIdentifier((1, 3, 6, 1, 4, 1, 711))
lightStreamOIDs = MibIdentifier((1, 3, 6, 1, 4, 1, 711, 1))
lightStreamProducts = MibIdentifier((1, 3, 6, 1, 4, 1, 711, 2))
lightStreamInternet = MibIdentifier((1, 3, 6, 1, 4, 1, 711, 3))
lightStreamVli = MibIdentifier((1, 3, 6, 1, 4, 1, 711, 4))
lightStreamEOM = MibIdentifier((1, 3, 6, 1, 4, 1, 711, 1000))
lightStreamATM = MibIdentifier((1, 3, 6, 1, 4, 1, 711, 1, 1))
lsOther = MibIdentifier((1, 3, 6, 1, 4, 1, 711, 1, 2))
lsTrapNumber = MibIdentifier((1, 3, 6, 1, 4, 1, 711, 1, 2, 1))
lsTrapText = MibIdentifier((1, 3, 6, 1, 4, 1, 711, 1, 2, 2))
lsTrapName = MibIdentifier((1, 3, 6, 1, 4, 1, 711, 1, 2, 3))
lsConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 711, 1, 3))
class LightStreamUpToMaxAge(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 3600)

class LightStreamDLCI(Integer32):
    pass

class VCI(Integer32):
    pass

atmSwitch = MibIdentifier((1, 3, 6, 1, 4, 1, 711, 2, 1))
chassisInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 711, 2, 1, 1))
chassisId = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassisId.setStatus('mandatory')
if mibBuilder.loadTexts: chassisId.setDescription('Chassis ID (24 bits)')
chassisActiveIpAddr = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chassisActiveIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: chassisActiveIpAddr.setDescription('Active IP Address for Management of this chassis. This is the IP address used for network mangement and will point to the active of the 2 NPs in a given chassis.')
chassisSecondaryIpAddr = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chassisSecondaryIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: chassisSecondaryIpAddr.setDescription('Secondary IP Address for Management of this chassis. This is the IP address used for network mangement and will point to the backup NP in a given chassis.')
chassisNetworkMask = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chassisNetworkMask.setStatus('mandatory')
if mibBuilder.loadTexts: chassisNetworkMask.setDescription('Subnet mask used for the IP addresses associated with switch ports')
chassisEthernetIpAddr = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 1, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chassisEthernetIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: chassisEthernetIpAddr.setDescription('This is the IP Address associated with the ethernet port on the primary NP in the chassis. The Ethernet port on the backup NP is unused,should that NP become primary it will take over the chassisEthernetIpAddr.')
chassisEthernetIpMask = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 1, 7), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chassisEthernetIpMask.setStatus('mandatory')
if mibBuilder.loadTexts: chassisEthernetIpMask.setDescription('This is the IP network mask associated with the Ethernet to which the network processors in the chassis are connected.')
chassisDefaultIpRouter = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 1, 8), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chassisDefaultIpRouter.setStatus('mandatory')
if mibBuilder.loadTexts: chassisDefaultIpRouter.setDescription("This is a machine, connected to the same ethernet as the chassis' NPs, which is capable of routing IP datagrams to other portions of the Internet.")
chassisStatusWord = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassisStatusWord.setStatus('mandatory')
if mibBuilder.loadTexts: chassisStatusWord.setDescription('Bit map of certain chassis wide status information for use with UB Net/Director.')
chassisConsoleTrapLevel = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("operational", 1), ("informational", 2), ("trace", 3), ("debug", 4), ("off", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassisConsoleTrapLevel.setStatus('mandatory')
if mibBuilder.loadTexts: chassisConsoleTrapLevel.setDescription('Trap level to use with console trap display')
cardInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 711, 2, 1, 2))
cardTable = MibTable((1, 3, 6, 1, 4, 1, 711, 2, 1, 2, 1), )
if mibBuilder.loadTexts: cardTable.setStatus('mandatory')
if mibBuilder.loadTexts: cardTable.setDescription('Card specific information')
cardEntry = MibTableRow((1, 3, 6, 1, 4, 1, 711, 2, 1, 2, 1, 1), ).setIndexNames((0, "LIGHTSTREAM-MIB", "cardIndex"))
if mibBuilder.loadTexts: cardEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cardEntry.setDescription('An entry in the chassis card table. (1-n)')
cardIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cardIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cardIndex.setDescription('Unique Index consisting of card number.')
cardName = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 2, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cardName.setStatus('mandatory')
if mibBuilder.loadTexts: cardName.setDescription('Name of Card')
cardBoardType = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 2, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cardBoardType.setStatus('mandatory')
if mibBuilder.loadTexts: cardBoardType.setDescription('Board type of this card.')
cardLcSoftwareVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 2, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cardLcSoftwareVersion.setStatus('mandatory')
if mibBuilder.loadTexts: cardLcSoftwareVersion.setDescription('Software revision of process running in the line card')
cardLccSoftwareVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 2, 1, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cardLccSoftwareVersion.setStatus('mandatory')
if mibBuilder.loadTexts: cardLccSoftwareVersion.setDescription('Software revision of process controlling card')
cardPID = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 2, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cardPID.setStatus('mandatory')
if mibBuilder.loadTexts: cardPID.setDescription('Unique Process ID for LCC process (from OS).')
cardMaxVCs = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 2, 1, 1, 7), Integer32().clone(800)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cardMaxVCs.setStatus('mandatory')
if mibBuilder.loadTexts: cardMaxVCs.setDescription('Maximum Virtual Circuits Supported by this card')
cardOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3), ("empty", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cardOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cardOperStatus.setDescription('Card Operational status')
cardAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cardAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cardAdminStatus.setDescription('Administratively Desired Status of this card')
cardStatusWord = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 2, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cardStatusWord.setStatus('mandatory')
if mibBuilder.loadTexts: cardStatusWord.setDescription('Card status word, for use with the UB Net/Director product')
cardConfigRegister = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 2, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3), ("empty", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cardConfigRegister.setStatus('mandatory')
if mibBuilder.loadTexts: cardConfigRegister.setDescription('Actual Card Enable Status as read from status register')
portInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 711, 2, 1, 3))
portInfoTable = MibTable((1, 3, 6, 1, 4, 1, 711, 2, 1, 3, 1), )
if mibBuilder.loadTexts: portInfoTable.setStatus('mandatory')
if mibBuilder.loadTexts: portInfoTable.setDescription('Port specific information')
portInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 711, 2, 1, 3, 1, 1), ).setIndexNames((0, "LIGHTSTREAM-MIB", "portInfoIndex"))
if mibBuilder.loadTexts: portInfoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: portInfoEntry.setDescription('An entry in the Edge Port table.')
portInfoIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portInfoIndex.setStatus('mandatory')
if mibBuilder.loadTexts: portInfoIndex.setDescription('This is the ifIndex value of the corresponding ifEntry. See comments above.')
portInfoType = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 12, 13, 14, 15, 30, 31, 32, 33, 34, 35, 36, 37))).clone(namedValues=NamedValues(("empty", 1), ("error", 2), ("unknown", 3), ("switch", 4), ("np", 5), ("lsEdge", 6), ("lsTrunk", 7), ("msTrunk", 8), ("msEdge", 10), ("plc12fac1", 11), ("plc18eac1", 12), ("plc1Lstoken", 13), ("plc18sac1Edge", 14), ("plc18sac1Trunk", 15), ("clc1Gen", 30), ("clc12oc3ac1Edge", 31), ("clc12oc3ac1Trunk", 32), ("clc18t3ac1Edge", 33), ("clc18t3ac1Trunk", 34), ("clc12taxiac1Edge", 35), ("clc12taxiac1Trunk", 36), ("clc18t1e1cbrac1", 37)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portInfoType.setStatus('mandatory')
if mibBuilder.loadTexts: portInfoType.setDescription('Object id of the port information table used with this port. (e.g. ls1InfoTable for the low speed line card version 1')
portInfoSpecific = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 3, 1, 1, 3), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portInfoSpecific.setStatus('mandatory')
if mibBuilder.loadTexts: portInfoSpecific.setDescription('Object id of the port information table used with this port. (e.g. ls1InfoTable for the low speed line card version 1')
portInfoName = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 3, 1, 1, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portInfoName.setStatus('mandatory')
if mibBuilder.loadTexts: portInfoName.setDescription('The name of this port. This is primary used as a help aid to identification. There is no absolute need for it to be set.')
portInfoErrorLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 3, 1, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portInfoErrorLimit.setStatus('mandatory')
if mibBuilder.loadTexts: portInfoErrorLimit.setDescription('The maximum error for this port, expressed as an inverse power of ten. I.E. 3 sets an acceptable error rate of 10**-3 receive+transmit errors. When this object is set to the value 0, the error limit trap is disabled. This value is always 0, i.e. disabled for Ethernet and FDDI ports.')
portTransmission = MibIdentifier((1, 3, 6, 1, 4, 1, 711, 2, 1, 4))
ls1InfoTable = MibTable((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 1), )
if mibBuilder.loadTexts: ls1InfoTable.setStatus('mandatory')
if mibBuilder.loadTexts: ls1InfoTable.setDescription('Edge Port Address table specific Information')
ls1InfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 1, 1), ).setIndexNames((0, "LIGHTSTREAM-MIB", "ls1InfoIfIndex"))
if mibBuilder.loadTexts: ls1InfoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ls1InfoEntry.setDescription('An entry in the Edge Port Address table.')
ls1InfoIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ls1InfoIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ls1InfoIfIndex.setDescription('This is the ifIndex value of the corresponding ifEntry. See comments above.')
ls1InfoType = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 99))).clone(namedValues=NamedValues(("v35", 1), ("rs422", 2), ("rs530", 3), ("t1", 4), ("unknown", 99)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ls1InfoType.setStatus('mandatory')
if mibBuilder.loadTexts: ls1InfoType.setDescription('Level 1 interface type used for this port')
ls1InfoOperCsuType = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("none", 1), ("larse", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ls1InfoOperCsuType.setStatus('mandatory')
if mibBuilder.loadTexts: ls1InfoOperCsuType.setDescription('Identifier of operational CSU Interface')
ls1InfoAdminCsuType = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("none", 1), ("larse", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ls1InfoAdminCsuType.setStatus('mandatory')
if mibBuilder.loadTexts: ls1InfoAdminCsuType.setDescription('Identifier of administartively specified CSU Interface')
ls1InfoOperRcvBaudRate = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ls1InfoOperRcvBaudRate.setStatus('mandatory')
if mibBuilder.loadTexts: ls1InfoOperRcvBaudRate.setDescription('Operation receive baud rate')
ls1InfoAdminRcvBaudRate = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 1, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ls1InfoAdminRcvBaudRate.setStatus('mandatory')
if mibBuilder.loadTexts: ls1InfoAdminRcvBaudRate.setDescription('Adminsitratively desired receive baud rate')
ls1InfoOperXmitBaudRate = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ls1InfoOperXmitBaudRate.setStatus('mandatory')
if mibBuilder.loadTexts: ls1InfoOperXmitBaudRate.setDescription('Operation transmit baud rate.')
ls1InfoAdminXmitBaudRate = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 1, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ls1InfoAdminXmitBaudRate.setStatus('mandatory')
if mibBuilder.loadTexts: ls1InfoAdminXmitBaudRate.setDescription('Admistratively desired transmission baud rate')
ls1InfoOperNetIntType = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("dce", 1), ("dte", 2), ("dceTTloop", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ls1InfoOperNetIntType.setStatus('mandatory')
if mibBuilder.loadTexts: ls1InfoOperNetIntType.setDescription('Operational network Interface Type for this port: DCE, DTE, or DCE with local tt loopback. This last option provides the ability to interface to DTE devices which are unable to return the tt signal as required for full V.35 standard compliance.')
ls1InfoAdminNetIntType = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("dce", 1), ("dte", 2), ("dceTTloop", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ls1InfoAdminNetIntType.setStatus('mandatory')
if mibBuilder.loadTexts: ls1InfoAdminNetIntType.setDescription('Administrative or desired Network Interface Type for DCE, DTE, or DCE with local tt loopback. This last option provides the ability to interface to DTE devices which are unable to return the tt signal as required for full V.35 standard compliance.')
ls1InfoOperModemState = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 1, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ls1InfoOperModemState.setStatus('mandatory')
if mibBuilder.loadTexts: ls1InfoOperModemState.setDescription('Operational Status of certain modem signals. A bitmask which gives the current state of certain modmem signals is returned. If the Port is configured as a DTE, bit 0 will be DCD and bit 1 DSR. If the Port is configured as a DCE, bit 0 will be RTS and bit 1 DTR.')
ls1InfoOperProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("trunk", 1), ("frameRelay", 2), ("frameForwarding", 3), ("ppp", 4), ("unknown", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ls1InfoOperProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: ls1InfoOperProtocol.setDescription('Operational higher level protocol stack to support on this port.')
ls1InfoAdminProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("trunk", 1), ("frameRelay", 2), ("frameForwarding", 3), ("ppp", 4), ("unknown", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ls1InfoAdminProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: ls1InfoAdminProtocol.setDescription('Administratively desired higher level protocol stack to support on this port.')
ls1InfoOperControlBandwidthSize = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 1, 1, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ls1InfoOperControlBandwidthSize.setStatus('mandatory')
if mibBuilder.loadTexts: ls1InfoOperControlBandwidthSize.setDescription('The current operation value of the control bandwidth size for this port. This is a scaling factor. This value is multiplied by ls1InfoOperRcvBaudRate and the result divided by 1000 to derive the actual bandwidth.')
ls1InfoAdminControlBandwidthSize = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 1, 1, 22), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ls1InfoAdminControlBandwidthSize.setStatus('mandatory')
if mibBuilder.loadTexts: ls1InfoAdminControlBandwidthSize.setDescription('The current administratively desired value of the control bandwidth size for this port. Setting the trigger variable ls1InfoAdimOperTrigger will cause this value to become the operation value. This is a scaling factor. This value is multiplied by ls1InfoAdminRcvBaudRate and the result divided by 1000 to derive the actual bandwidth.')
ls1InfoOperDataBandwidthSize = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 1, 1, 23), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ls1InfoOperDataBandwidthSize.setStatus('mandatory')
if mibBuilder.loadTexts: ls1InfoOperDataBandwidthSize.setDescription('The current operation value of the data bandwidth size for this port. This is a scaling factor. This value is multiplied by ls1InfoOperRcvBaudRate and the result divided by 1000 to derive the actual bandwidth.')
ls1InfoAdminDataBandwidthSize = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 1, 1, 24), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ls1InfoAdminDataBandwidthSize.setStatus('mandatory')
if mibBuilder.loadTexts: ls1InfoAdminDataBandwidthSize.setDescription('The current administratively desired value of the data bandwidth size for this port. Setting the trigger variable ls1InfoAdimOperTrigger will cause this value to become the operation value. This is a scaling factor. This value is multiplied by ls1InfoAdminRcvBaudRate and the result divided by 1000 to derive the actual bandwidth.')
ls1InfoOperLoopMode = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 1, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("internal", 2), ("external", 3), ("remote", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ls1InfoOperLoopMode.setStatus('mandatory')
if mibBuilder.loadTexts: ls1InfoOperLoopMode.setDescription('Operational loop mode for this port: none, internal, external, or remote')
ls1InfoAdminLoopMode = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 1, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("internal", 2), ("external", 3), ("remote", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ls1InfoAdminLoopMode.setStatus('mandatory')
if mibBuilder.loadTexts: ls1InfoAdminLoopMode.setDescription('Administrative or desired loop mode for this port: none, internal, external, or remote')
ls1InfoLcAutoEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 1, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ls1InfoLcAutoEnable.setStatus('mandatory')
if mibBuilder.loadTexts: ls1InfoLcAutoEnable.setDescription('State of the LC auto-enable flag for this port. If enabled the port will be enable at LC boot time. If disabled the port will remain disabled until configured and started by the LCC software on the NP. This parameter is set in the LC EEPROM by portctl.')
ls1InfoLcDebugLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 1, 1, 28), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ls1InfoLcDebugLevel.setStatus('mandatory')
if mibBuilder.loadTexts: ls1InfoLcDebugLevel.setDescription('Value of the LC debug level variable for this port. This parameter is set in the LC EEPROM by portctl.')
ls1InfoDataCellCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 1, 1, 29), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ls1InfoDataCellCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: ls1InfoDataCellCapacity.setDescription("The portion of this port's capacity in cells that is allocated for data traffic.")
ls1InfoDataCellAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 1, 1, 30), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ls1InfoDataCellAvailable.setStatus('mandatory')
if mibBuilder.loadTexts: ls1InfoDataCellAvailable.setDescription("The portion of this port's capacity in cells that is available for data traffic. This variable is adjusted for the bandwidth consumed by VCs created using this port. It does not count VCs which have been configured but not yet established.")
ls1InfoMeasuredBaudRate = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 1, 1, 31), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ls1InfoMeasuredBaudRate.setStatus('mandatory')
if mibBuilder.loadTexts: ls1InfoMeasuredBaudRate.setDescription('This is the line rate as measured from the line card.')
ls1InfoLinkUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 1, 1, 32), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ls1InfoLinkUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: ls1InfoLinkUtilization.setDescription('This is an estimated utilization on the link.')
ls1InfoAdminOperTrigger = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 1, 1, 99), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 99))).clone(namedValues=NamedValues(("trigger", 1), ("other", 99)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ls1InfoAdminOperTrigger.setStatus('mandatory')
if mibBuilder.loadTexts: ls1InfoAdminOperTrigger.setDescription('When proper commands written to this variable the LCC attempts to change the state of the port such that the oper status reflects the desired admin status.')
ms1InfoTable = MibTable((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 2), )
if mibBuilder.loadTexts: ms1InfoTable.setStatus('mandatory')
if mibBuilder.loadTexts: ms1InfoTable.setDescription('Edge Port Address table specific Information')
ms1InfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 2, 1), ).setIndexNames((0, "LIGHTSTREAM-MIB", "ms1InfoIfIndex"))
if mibBuilder.loadTexts: ms1InfoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ms1InfoEntry.setDescription('An entry in the Edge Port Address table.')
ms1InfoIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ms1InfoIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ms1InfoIfIndex.setDescription('This is the ifIndex value of the corresponding ifEntry. See comments above.')
ms1InfoOperCableLength = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("t3CableLength1", 1), ("t3CableLength2", 2), ("e3CableLength1", 3), ("e3CableLength2", 4), ("e3CableLength3", 5), ("e3CableLength4", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ms1InfoOperCableLength.setStatus('mandatory')
if mibBuilder.loadTexts: ms1InfoOperCableLength.setDescription('Operational value for Cable Length used for this port.')
ms1InfoAdminCableLength = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("t3CableLength1", 1), ("t3CableLength2", 2), ("e3CableLength1", 3), ("e3CableLength2", 4), ("e3CableLength3", 5), ("e3CableLength4", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ms1InfoAdminCableLength.setStatus('mandatory')
if mibBuilder.loadTexts: ms1InfoAdminCableLength.setDescription('Administrative value for Cable Length used for this port. Setting the trigger variable ms1InfoAdimOperTrigger will cause this value to become the operation value. ')
ms1InfoOperProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("trunk", 1), ("atmUni", 2), ("unknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ms1InfoOperProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: ms1InfoOperProtocol.setDescription('Operational higher level protocol stack to support on this port.')
ms1InfoAdminProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("trunk", 1), ("atmUni", 2), ("unknown", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ms1InfoAdminProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: ms1InfoAdminProtocol.setDescription('Administratively desired higher level protocol stack to support on this port.')
ms1InfoOperControlBandwidthSize = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 2, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ms1InfoOperControlBandwidthSize.setStatus('mandatory')
if mibBuilder.loadTexts: ms1InfoOperControlBandwidthSize.setDescription('The current operation value of the control bandwidth size for this port. This is a scaling factor. This value is multiplied by ms1InfoOperRcvBaudRate and the result divided by 1000 to derive the actual bandwidth.')
ms1InfoAdminControlBandwidthSize = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 2, 1, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ms1InfoAdminControlBandwidthSize.setStatus('mandatory')
if mibBuilder.loadTexts: ms1InfoAdminControlBandwidthSize.setDescription('The current administratively desired value of the control bandwidth size for this port. Setting the trigger variable ms1InfoAdimOperTrigger will cause this value to become the operation value. This is a scaling factor. This value is multiplied by ms1InfoAdminRcvBaudRate and the result divided by 1000 to derive the actual bandwidth.')
ms1InfoOperDataBandwidthSize = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 2, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ms1InfoOperDataBandwidthSize.setStatus('mandatory')
if mibBuilder.loadTexts: ms1InfoOperDataBandwidthSize.setDescription('The current operation value of the data bandwidth size for this port. This is a scaling factor. This value is multiplied by ms1InfoOperRcvBaudRate and the result divided by 1000 to derive the actual bandwidth.')
ms1InfoAdminDataBandwidthSize = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 2, 1, 13), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ms1InfoAdminDataBandwidthSize.setStatus('mandatory')
if mibBuilder.loadTexts: ms1InfoAdminDataBandwidthSize.setDescription('The current administratively desired value of the data bandwidth size for this port. Setting the trigger variable ms1InfoAdimOperTrigger will cause this value to become the operation value. This is a scaling factor. This value is multiplied by ms1InfoAdminRcvBaudRate and the result divided by 1000 to derive the actual bandwidth.')
ms1InfoLcAutoEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ms1InfoLcAutoEnable.setStatus('mandatory')
if mibBuilder.loadTexts: ms1InfoLcAutoEnable.setDescription('State of the LC auto-enable flag for this port. If enabled the port will be enable at LC boot time. If disabled the port will remain disabled until configured and started by the LCC software on the NP. This parameter is set in the LC EEPROM by portctl.')
ms1InfoLcDebugLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 2, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ms1InfoLcDebugLevel.setStatus('mandatory')
if mibBuilder.loadTexts: ms1InfoLcDebugLevel.setDescription('Value of the LC debug level variable for this port. This parameter is set in the LC EEPROM by portctl.')
ms1InfoOperScramble = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("t3ScrambleEnable", 1), ("t3ScrambleDisable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ms1InfoOperScramble.setStatus('mandatory')
if mibBuilder.loadTexts: ms1InfoOperScramble.setDescription('Operational value for Cell Payload scrambling used for this port.')
ms1InfoAdminScramble = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 2, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("t3ScrambleEnable", 1), ("t3ScrambleDisable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ms1InfoAdminScramble.setStatus('mandatory')
if mibBuilder.loadTexts: ms1InfoAdminScramble.setDescription('Administrative value for Cell Payload scrambling used for this port. Setting the trigger variable ms1InfoAdimOperTrigger will cause this value to become the operation value. ')
ms1InfoDataCellCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 2, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ms1InfoDataCellCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: ms1InfoDataCellCapacity.setDescription("The portion of this port's capacity in cells that is allocated for data traffic.")
ms1InfoDataCellAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 2, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ms1InfoDataCellAvailable.setStatus('mandatory')
if mibBuilder.loadTexts: ms1InfoDataCellAvailable.setDescription("The portion of this port's capacity in cells that is available for data traffic. This variable is adjusted for the bandwidth consumed by VCs created using this port. It does not count VCs which have been configured but not yet established.")
ms1InfoLinkUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 2, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ms1InfoLinkUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: ms1InfoLinkUtilization.setDescription('This is an estimated utilization on the link.')
ms1InfoOperFraming = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 2, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("plcp", 1), ("t3-Hec", 2), ("g-804", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ms1InfoOperFraming.setStatus('mandatory')
if mibBuilder.loadTexts: ms1InfoOperFraming.setDescription('Operational ATM framing typein use on this port.')
ms1InfoAdminOperTrigger = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 2, 1, 99), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 99))).clone(namedValues=NamedValues(("trigger", 1), ("other", 99)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ms1InfoAdminOperTrigger.setStatus('mandatory')
if mibBuilder.loadTexts: ms1InfoAdminOperTrigger.setDescription('When proper commands written to this variable the LCC attempts to change the state of the port such that the oper status reflects the desired admin status.')
npInfoTable = MibTable((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 3), )
if mibBuilder.loadTexts: npInfoTable.setStatus('mandatory')
if mibBuilder.loadTexts: npInfoTable.setDescription('Edge Port Address table specific Information')
npInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 3, 1), ).setIndexNames((0, "LIGHTSTREAM-MIB", "npInfoIfIndex"))
if mibBuilder.loadTexts: npInfoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: npInfoEntry.setDescription('An entry in the NP configuration table.')
npInfoIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: npInfoIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: npInfoIfIndex.setDescription('This is the ifIndex value of the corresponding ifEntry. See comments above.')
npInfoIPCommittedRate = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 3, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: npInfoIPCommittedRate.setStatus('mandatory')
if mibBuilder.loadTexts: npInfoIPCommittedRate.setDescription('Default committed rate for IP circuits')
npInfoIPCommittedBurst = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 3, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: npInfoIPCommittedBurst.setStatus('mandatory')
if mibBuilder.loadTexts: npInfoIPCommittedBurst.setDescription('Default committed burst rate for IP circuits')
npInfoIPExcessRate = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 3, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: npInfoIPExcessRate.setStatus('mandatory')
if mibBuilder.loadTexts: npInfoIPExcessRate.setDescription('Default excess rate for IP circuits')
npInfoIPExcessBurst = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 3, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: npInfoIPExcessBurst.setStatus('mandatory')
if mibBuilder.loadTexts: npInfoIPExcessBurst.setDescription('Default excess burst rate for IP circuits')
npInfoIPNCircuits = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 3, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: npInfoIPNCircuits.setStatus('mandatory')
if mibBuilder.loadTexts: npInfoIPNCircuits.setDescription('Number of IP circuits supported')
npInfoAdminOperTrigger = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 3, 1, 99), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 99))).clone(namedValues=NamedValues(("trigger", 1), ("other", 99)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: npInfoAdminOperTrigger.setStatus('mandatory')
if mibBuilder.loadTexts: npInfoAdminOperTrigger.setDescription('When proper commands written to this variable the LCC attempts to change the state of the port such that the oper status reflects the desired admin status.')
clc1InfoTable = MibTable((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 4), )
if mibBuilder.loadTexts: clc1InfoTable.setStatus('mandatory')
if mibBuilder.loadTexts: clc1InfoTable.setDescription('Edge Port Address table specific Information')
clc1InfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 4, 1), ).setIndexNames((0, "LIGHTSTREAM-MIB", "clc1InfoIfIndex"))
if mibBuilder.loadTexts: clc1InfoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: clc1InfoEntry.setDescription('An entry in the Edge Port Address table.')
clc1InfoIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: clc1InfoIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: clc1InfoIfIndex.setDescription('This is the ifIndex value of the corresponding ifEntry. See comments above.')
clc1InfoOperProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("trunk", 1), ("atmUni", 2), ("unknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: clc1InfoOperProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: clc1InfoOperProtocol.setDescription('Operational higher level protocol stack to support on this port.')
clc1InfoAdminProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("trunk", 1), ("atmUni", 2), ("unknown", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: clc1InfoAdminProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: clc1InfoAdminProtocol.setDescription('Administratively desired higher level protocol stack to support on this port.')
clc1InfoOperLoopMode = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("internal", 2), ("external", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: clc1InfoOperLoopMode.setStatus('mandatory')
if mibBuilder.loadTexts: clc1InfoOperLoopMode.setDescription('Operational loop mode for this port: none, internal, or external.')
clc1InfoAdminLoopMode = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 4, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("internal", 2), ("external", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: clc1InfoAdminLoopMode.setStatus('mandatory')
if mibBuilder.loadTexts: clc1InfoAdminLoopMode.setDescription('Administrative or desired loop mode for this port: none, internal, or external.')
clc1InfoOperControlBandwidthSize = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 4, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: clc1InfoOperControlBandwidthSize.setStatus('mandatory')
if mibBuilder.loadTexts: clc1InfoOperControlBandwidthSize.setDescription('The current operation value of the control bandwidth size for this port. This is a scaling factor. This value is multiplied by the port bit rate and the result divided by 1000 to derive the actual bandwidth.')
clc1InfoAdminControlBandwidthSize = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 4, 1, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: clc1InfoAdminControlBandwidthSize.setStatus('mandatory')
if mibBuilder.loadTexts: clc1InfoAdminControlBandwidthSize.setDescription('The current administratively desired value of the control bandwidth size for this port. Setting the trigger variable clc1InfoAdimOperTrigger will cause this value to become the operation value. This is a scaling factor. This value is multiplied by the port bit rate and the result divided by 1000 to derive the actual bandwidth.')
clc1InfoOperDataBandwidthSize = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 4, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: clc1InfoOperDataBandwidthSize.setStatus('mandatory')
if mibBuilder.loadTexts: clc1InfoOperDataBandwidthSize.setDescription('The current operation value of the data bandwidth size for this port. This is a scaling factor. This value is multiplied by the port bit rate and the result divided by 1000 to derive the actual bandwidth.')
clc1InfoAdminDataBandwidthSize = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 4, 1, 13), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: clc1InfoAdminDataBandwidthSize.setStatus('mandatory')
if mibBuilder.loadTexts: clc1InfoAdminDataBandwidthSize.setDescription('The current administratively desired value of the data bandwidth size for this port. Setting the trigger variable clc1InfoAdimOperTrigger will cause this value to become the operation value. This is a scaling factor. This value is multiplied by the port bit rate and the result divided by 1000 to derive the actual bandwidth.')
clc1InfoLcAutoEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 4, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: clc1InfoLcAutoEnable.setStatus('mandatory')
if mibBuilder.loadTexts: clc1InfoLcAutoEnable.setDescription('State of the LC auto-enable flag for this port. If enabled the port will be enable at LC boot time. If disabled the port will remain disabled until configured and started by the LCC software on the NP. This parameter is set in the LC EEPROM by portctl.')
clc1InfoLcDebugLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 4, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: clc1InfoLcDebugLevel.setStatus('mandatory')
if mibBuilder.loadTexts: clc1InfoLcDebugLevel.setDescription('Value of the LC debug level variable for this port. This parameter is set in the LC EEPROM by portctl.')
clc1InfoOperScramble = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 4, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("scrambleEnable", 1), ("scrambleDisable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: clc1InfoOperScramble.setStatus('mandatory')
if mibBuilder.loadTexts: clc1InfoOperScramble.setDescription('Operational value for Cell Payload scrambling used for this port.')
clc1InfoAdminScramble = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 4, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("scrambleEnable", 1), ("scrambleDisable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: clc1InfoAdminScramble.setStatus('mandatory')
if mibBuilder.loadTexts: clc1InfoAdminScramble.setDescription('Administrative value for Cell Payload scrambling used for this port. Setting the trigger variable clc1InfoAdimOperTrigger will cause this value to become the operation value. ')
clc1InfoDataCellCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 4, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: clc1InfoDataCellCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: clc1InfoDataCellCapacity.setDescription("The portion of this port's capacity in cells that is allocated for data traffic.")
clc1InfoDataCellAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 4, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: clc1InfoDataCellAvailable.setStatus('mandatory')
if mibBuilder.loadTexts: clc1InfoDataCellAvailable.setDescription("The portion of this port's capacity in cells that is available for data traffic. This variable is adjusted for the bandwidth consumed by VCs created using this port. It does not count VCs which have been configured but not yet established.")
clc1InfoLinkUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 4, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: clc1InfoLinkUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: clc1InfoLinkUtilization.setDescription('This is an estimated utilization on the link.')
clc1InfoOperClock = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 4, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("internalClock", 1), ("externalClock", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: clc1InfoOperClock.setStatus('mandatory')
if mibBuilder.loadTexts: clc1InfoOperClock.setDescription('Operational value for the source of transmit clock for this port.')
clc1InfoAdminClock = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 4, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("internalClock", 1), ("externalClock", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: clc1InfoAdminClock.setStatus('mandatory')
if mibBuilder.loadTexts: clc1InfoAdminClock.setDescription('Administrative value for the source of transmit clock used for this port. Setting the trigger variable clc1InfoAdimOperTrigger will cause this value to become the operation value. ')
clc1InfoAdminOperTrigger = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 4, 1, 99), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 99))).clone(namedValues=NamedValues(("trigger", 1), ("other", 99)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: clc1InfoAdminOperTrigger.setStatus('mandatory')
if mibBuilder.loadTexts: clc1InfoAdminOperTrigger.setDescription('When proper commands written to this variable the LCC attempts to change the state of the port such that the oper status reflects the desired admin status.')
oc3InfoTable = MibTable((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 5), )
if mibBuilder.loadTexts: oc3InfoTable.setStatus('mandatory')
if mibBuilder.loadTexts: oc3InfoTable.setDescription('Edge Port Address table specific Information')
oc3InfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 5, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: oc3InfoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: oc3InfoEntry.setDescription('An entry in the Edge Port Address table.')
oc3InfoReceiveSignalDetect = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 5, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: oc3InfoReceiveSignalDetect.setStatus('mandatory')
if mibBuilder.loadTexts: oc3InfoReceiveSignalDetect.setDescription('This value indicates that a receive signal has been detected on thei port')
oc3InfoTransmitSafetySwitch = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: oc3InfoTransmitSafetySwitch.setStatus('mandatory')
if mibBuilder.loadTexts: oc3InfoTransmitSafetySwitch.setDescription('State of the Safety Switch with the single mode interface. When the saftey switch is enabled, the laser is disabled. This variable is undefined for multimode interfaces.')
oc3InfoMediumType = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 4, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("sonet", 1), ("sdh", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: oc3InfoMediumType.setStatus('mandatory')
if mibBuilder.loadTexts: oc3InfoMediumType.setDescription('This variable identifies whether a SONET or a SDH signal is used across this interface.')
congestionAvoidance = MibIdentifier((1, 3, 6, 1, 4, 1, 711, 2, 1, 5))
caMaxIntervalPermitLimit = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 5, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: caMaxIntervalPermitLimit.setStatus('mandatory')
if mibBuilder.loadTexts: caMaxIntervalPermitLimit.setDescription('The maximum interval at which permit limits are to be reported by trunk and outgoing edge cards.')
caMinIntervalPermitLimit = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 5, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: caMinIntervalPermitLimit.setStatus('mandatory')
if mibBuilder.loadTexts: caMinIntervalPermitLimit.setDescription('The minimum interval at which permit limits are to be reported by trunk and outgoing edge cards.')
caMinIntervalCaInfo = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 5, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: caMinIntervalCaInfo.setStatus('mandatory')
if mibBuilder.loadTexts: caMinIntervalCaInfo.setDescription('The minimum interval at which CA information processes are to distribute aggregated CA updates to input edge cards.')
mmaInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 711, 2, 1, 6))
mmaDbActive = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 6, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("inactive", 1), ("newDBactive", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mmaDbActive.setStatus('mandatory')
if mibBuilder.loadTexts: mmaDbActive.setDescription('Controls and displays state of persistent database used by MMA. Primary use of this variable was to allow release 1 configuration systems to shut off the database before it was replaced with a new one and then re-activated. The release 2 configuration mechanism depends on mmaSetLock to backup and coordinate configuration updates.')
mmaTrapFilter = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 6, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("operational", 1), ("informational", 2), ("trace", 3), ("debug", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mmaTrapFilter.setStatus('mandatory')
if mibBuilder.loadTexts: mmaTrapFilter.setDescription('Value of highest priority trap that will be be forwarded to any NMS sites. For example if set to mediumPriority then mediumPrioriy and highPriority messages will be forwarded')
mmaTrapLanguage = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 6, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("english", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mmaTrapLanguage.setStatus('mandatory')
if mibBuilder.loadTexts: mmaTrapLanguage.setDescription('Langauage to be used for the text of traps.')
mmaCollectionSpace = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 6, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mmaCollectionSpace.setStatus('mandatory')
if mibBuilder.loadTexts: mmaCollectionSpace.setDescription('Max size of disk space available for collecting autonomous traps. Actual size is mmaCollectionSpace * 1024')
mmaConfigHost = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 6, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mmaConfigHost.setStatus('mandatory')
if mibBuilder.loadTexts: mmaConfigHost.setDescription('Host supplying configuration file')
mmaConfigAuthor = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 6, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mmaConfigAuthor.setStatus('mandatory')
if mibBuilder.loadTexts: mmaConfigAuthor.setDescription('Person who last changed configuration file')
mmaConfigID = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 6, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mmaConfigID.setStatus('mandatory')
if mibBuilder.loadTexts: mmaConfigID.setDescription('Configuration ID set by configuration program')
mmaSetLock = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 6, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unlock", 1), ("lockVolatile", 2), ("lockPermanent", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mmaSetLock.setStatus('mandatory')
if mibBuilder.loadTexts: mmaSetLock.setDescription('If a user locks this field (2 or 3), set commands are accepted only from that IP address. The lock times out if the session is idle for two minutes. There are two configuration files: mma.db.pag and mma.db.dir. If set to lockPermanent(3), these files are copied to mma.db.BAK.pag and mma.db.BAK.dir, and sets are written to the configuration files. Otherwise sets are written to run-time memory only. To recover backup configuration files, the user must log in to the LightStream node and rename the files.')
mmaPID = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 6, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mmaPID.setStatus('mandatory')
if mibBuilder.loadTexts: mmaPID.setDescription('PID of the MMA process')
mmaTrapLog = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 6, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mmaTrapLog.setStatus('mandatory')
if mibBuilder.loadTexts: mmaTrapLog.setDescription("Trap log control field. If enabled the MMA will log traps received from LWMA clients to disk. It saves traps into a 'circular file' such that only the last number of traps are on disk.")
mmaTrapNumber = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 6, 13), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mmaTrapNumber.setStatus('mandatory')
if mibBuilder.loadTexts: mmaTrapNumber.setDescription('Trap Number used by the state and action variables')
mmaTrapOnOffState = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 6, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("trapOn", 1), ("trapOff", 2), ("trapEnable", 3), ("trapDisable", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mmaTrapOnOffState.setStatus('mandatory')
if mibBuilder.loadTexts: mmaTrapOnOffState.setDescription('On/Off State of Trap specified in mmaTrapNumber and mmaTrapPidSelector')
mmaNumNameTable = MibTable((1, 3, 6, 1, 4, 1, 711, 2, 1, 6, 16), )
if mibBuilder.loadTexts: mmaNumNameTable.setStatus('mandatory')
if mibBuilder.loadTexts: mmaNumNameTable.setDescription('Table of current file transfers')
mmaNumNameEntry = MibTableRow((1, 3, 6, 1, 4, 1, 711, 2, 1, 6, 16, 1), ).setIndexNames((0, "LIGHTSTREAM-MIB", "mmaNumNameNumber"))
if mibBuilder.loadTexts: mmaNumNameEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mmaNumNameEntry.setDescription('An entry in the file transfer table.')
mmaNumNameNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 6, 16, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mmaNumNameNumber.setStatus('mandatory')
if mibBuilder.loadTexts: mmaNumNameNumber.setDescription('Unique Index consisting of chassis ID.')
mmaNumName = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 6, 16, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mmaNumName.setStatus('mandatory')
if mibBuilder.loadTexts: mmaNumName.setDescription('Name of chassis corresponding to value of mmaNumNameNumber.')
mmaLwmpTimeouts = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 6, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mmaLwmpTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: mmaLwmpTimeouts.setDescription('The number of times the MMA did a read on a socket to a chassis-resident process and timed out before the process responded. This object is being added here for debug purposes and may be changed in future releases of the MIB.')
collectInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 711, 2, 1, 7))
collectTable = MibTable((1, 3, 6, 1, 4, 1, 711, 2, 1, 7, 1), )
if mibBuilder.loadTexts: collectTable.setStatus('mandatory')
if mibBuilder.loadTexts: collectTable.setDescription('Collector table of current collections')
collectEntry = MibTableRow((1, 3, 6, 1, 4, 1, 711, 2, 1, 7, 1, 1), ).setIndexNames((0, "LIGHTSTREAM-MIB", "collectIndex"))
if mibBuilder.loadTexts: collectEntry.setStatus('mandatory')
if mibBuilder.loadTexts: collectEntry.setDescription('An entry in the Collector collection table. (1-n)')
collectIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 7, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: collectIndex.setStatus('mandatory')
if mibBuilder.loadTexts: collectIndex.setDescription('Unique Index consisting of collection number.')
collectStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 7, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("valid", 1), ("createRequest", 2), ("underCreation", 3), ("invalid", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: collectStatus.setStatus('mandatory')
if mibBuilder.loadTexts: collectStatus.setDescription('Collection status of this collection row entry.')
collectStart = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 7, 1, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: collectStart.setStatus('mandatory')
if mibBuilder.loadTexts: collectStart.setDescription('Collection start time. If specified and status is valid means a collection will start at time. Time is the UNIX real time in seconds.')
collectFinish = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 7, 1, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: collectFinish.setStatus('mandatory')
if mibBuilder.loadTexts: collectFinish.setDescription('Collection finish time in TOD seconds.')
collectInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 7, 1, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: collectInterval.setStatus('mandatory')
if mibBuilder.loadTexts: collectInterval.setDescription('Collection Interval, in seconds.')
collectFileName = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 7, 1, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: collectFileName.setStatus('mandatory')
if mibBuilder.loadTexts: collectFileName.setDescription("Automatically generated filename for this collection. The file name is 'Collect.n' where 'n' is the collectIndex.")
collectFileSize = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 7, 1, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: collectFileSize.setStatus('mandatory')
if mibBuilder.loadTexts: collectFileSize.setDescription('Max Size of the circular file named in collectFileName. Actual maximum size of file is value of collectFileSize * 1024.')
collectOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 7, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("waiting", 1), ("running", 2), ("underCreation", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: collectOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: collectOperStatus.setDescription('Collection status of this collection row entry.')
collectDataBase = MibTable((1, 3, 6, 1, 4, 1, 711, 2, 1, 7, 2), )
if mibBuilder.loadTexts: collectDataBase.setStatus('mandatory')
if mibBuilder.loadTexts: collectDataBase.setDescription('Collector table of current collections')
collectDbEntry = MibTableRow((1, 3, 6, 1, 4, 1, 711, 2, 1, 7, 2, 1), ).setIndexNames((0, "LIGHTSTREAM-MIB", "collectDBIndex"), (0, "LIGHTSTREAM-MIB", "collectDBInstance"))
if mibBuilder.loadTexts: collectDbEntry.setStatus('mandatory')
if mibBuilder.loadTexts: collectDbEntry.setDescription('An entry in the Collector group database. (1-n)')
collectDBIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 7, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: collectDBIndex.setStatus('mandatory')
if mibBuilder.loadTexts: collectDBIndex.setDescription('Unique Index equal to collectIndex')
collectDBInstance = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 7, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: collectDBInstance.setStatus('mandatory')
if mibBuilder.loadTexts: collectDBInstance.setDescription('Record instance within a group ID')
collectDBObjectID = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 7, 2, 1, 3), ObjectIdentifier()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: collectDBObjectID.setStatus('mandatory')
if mibBuilder.loadTexts: collectDBObjectID.setDescription('Object identifier of a member of a group specified by the group ID and instance.')
collectDBStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 7, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("valid", 1), ("createRequest", 2), ("underCreation", 3), ("invalid", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: collectDBStatus.setStatus('mandatory')
if mibBuilder.loadTexts: collectDBStatus.setDescription('Collection status of this collection database row entry.')
collectCommunityName = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 7, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: collectCommunityName.setStatus('mandatory')
if mibBuilder.loadTexts: collectCommunityName.setDescription('Used by Collector with its SNMP requests to the MMA.')
rmonCommunityName = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 7, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmonCommunityName.setStatus('mandatory')
if mibBuilder.loadTexts: rmonCommunityName.setDescription('Used by RMON/Collector with its SNMP requests to the MMA.')
lsPortProtocols = MibIdentifier((1, 3, 6, 1, 4, 1, 711, 2, 1, 8))
edgePort = MibIdentifier((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 1))
edgePortTable = MibTable((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 1, 1), )
if mibBuilder.loadTexts: edgePortTable.setStatus('mandatory')
if mibBuilder.loadTexts: edgePortTable.setDescription('EdgePort Port Address table specific information')
edgePortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 1, 1, 1), ).setIndexNames((0, "LIGHTSTREAM-MIB", "edgeIfIndex"))
if mibBuilder.loadTexts: edgePortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: edgePortEntry.setDescription('An entry in the EdgePort Port Address table.')
edgeIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: edgeIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: edgeIfIndex.setDescription('This is the ifIndex value of the corresponding ifEntry. See comments above.')
edgeUpcType = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("ansiCompliant", 1))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: edgeUpcType.setStatus('mandatory')
if mibBuilder.loadTexts: edgeUpcType.setDescription('Usage Parameter Control model type. This parameter selects the UPC model, which regulates the flow of data into the network.')
edgeUserDataPerCell = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 384)).clone(341)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: edgeUserDataPerCell.setStatus('mandatory')
if mibBuilder.loadTexts: edgeUserDataPerCell.setDescription('User data bits per cell. This specifies the expected packing efficiency when frames are converted to cells. It does not affect the actual packing of data into cells but serves as an estimate on which bandwidth allocation and other connection related functions will be based.')
edgeCellDelayVariance = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 1, 1, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: edgeCellDelayVariance.setStatus('mandatory')
if mibBuilder.loadTexts: edgeCellDelayVariance.setDescription('Cell Delay Variance in microseconds. This is the typical variance in the delay added as a cell is processed by an switch')
edgePrincipalScale = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 1, 1, 1, 5), Integer32().clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: edgePrincipalScale.setStatus('mandatory')
if mibBuilder.loadTexts: edgePrincipalScale.setDescription(" Principal bandwidth scaling factor. This is used to scale down the actual amount of bandwidth to allocate for the principal portion of a VC's bandwidth. This is specified as a codepoint as follows: Codepoints Meaning Comment - ---------- ------- ------- 0 - 100 x / 100 e.g., 1 => .01 101 - 109 x - 100 / 1000 e.g., 101 => .001")
edgeSecondaryScale = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 1, 1, 1, 6), Integer32().clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: edgeSecondaryScale.setStatus('mandatory')
if mibBuilder.loadTexts: edgeSecondaryScale.setDescription(" Secondary bandwidth scaling factor. This is used to scale down the actual amount of bandwidth to allocate for the Secondary portion of a VC's bandwidth. This is specified as a codepoint as follows: Codepoints Meaning Comment - ---------- ------- ------- 0 - 100 x / 100 e.g., 1 => .01 101 - 109 x - 100 / 1000 e.g., 101 => .001")
edgeMeteringFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 1, 1, 1, 7), Integer32().clone(64)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: edgeMeteringFactor.setStatus('mandatory')
if mibBuilder.loadTexts: edgeMeteringFactor.setDescription('Scale factor for the metering time charge, a value (divided by 256) by which to increase the time or slow down metering of traffic into the network. A value of 256 would typically keep the metering rate close to the minimum allowable rate for the aggregate information rate for the group of circuits being metered.')
edgeMeteringBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 1, 1, 1, 8), Integer32().clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: edgeMeteringBurstSize.setStatus('mandatory')
if mibBuilder.loadTexts: edgeMeteringBurstSize.setDescription('This is the minimum number of cells to burst at a time')
edgeCallSetupRetry = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: edgeCallSetupRetry.setStatus('mandatory')
if mibBuilder.loadTexts: edgeCallSetupRetry.setDescription('This specifies the initial time to wait between successive failed attempts to establish a connection. This interval is in seconds. An incremental backoff algorithm may applied to this value. See Parameter edgeCallSetupBackoff.')
edgeCallSetupBackoff = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: edgeCallSetupBackoff.setStatus('mandatory')
if mibBuilder.loadTexts: edgeCallSetupBackoff.setDescription('This specifies the maximum power of 2 to backoff in call setup retry attempts. For each retry up to this maxumim the retry timer will be adjusted by multipliing by 2**(n). The first retry will be multiplied by 2**0 or 1, the second by 2**1 or 2, and so on. The variable can range from 1 to 10.')
edgeMaxFrameSize = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(48, 8152)).clone(1516)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: edgeMaxFrameSize.setStatus('mandatory')
if mibBuilder.loadTexts: edgeMaxFrameSize.setDescription('This specifies the maximum frame size that can be transmitted on this edge port. The size is specified in bytes. ')
frDceInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 2))
frProvMiTable = MibTable((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 2, 1), )
if mibBuilder.loadTexts: frProvMiTable.setReference('Draft American National Standard T1.617-1991, Annex D')
if mibBuilder.loadTexts: frProvMiTable.setStatus('mandatory')
if mibBuilder.loadTexts: frProvMiTable.setDescription('The Parameters for the Data Link Connection Management Interface for the frame relay service on this interface.')
frProvMiEntry = MibTableRow((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 2, 1, 1), ).setIndexNames((0, "LIGHTSTREAM-MIB", "frProvMiIfIndex"))
if mibBuilder.loadTexts: frProvMiEntry.setStatus('mandatory')
if mibBuilder.loadTexts: frProvMiEntry.setDescription('The Parameters for a particular Data Link Con- nection Management Interface.')
frProvMiIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frProvMiIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: frProvMiIfIndex.setDescription('This is the ifIndex value of the corresponding ifEntry. See comments above.')
frProvMiState = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("noLmiConfigured", 1), ("lmiFRIF", 2), ("ansiT1-617-D", 3), ("ccittQ-933-A", 4))).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frProvMiState.setReference('Draft American National Standard T1.617-1991')
if mibBuilder.loadTexts: frProvMiState.setStatus('mandatory')
if mibBuilder.loadTexts: frProvMiState.setDescription('This variable states which Data Link Connec- tion Management scheme is active (and by impli- cation, what DLCI it uses) on the Frame Relay interface.')
frProvMiAddressLen = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2))).clone(namedValues=NamedValues(("two-octets", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frProvMiAddressLen.setStatus('mandatory')
if mibBuilder.loadTexts: frProvMiAddressLen.setDescription('This variable states which address length in octets. In the case of Q922 format, the length indicates the entire length of the address in- cluding the control portion.')
frProvMiNetRequestInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 30)).clone(15)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frProvMiNetRequestInterval.setReference('Draft American National Standard T1.617-1991, Section D.7 Timer T392.')
if mibBuilder.loadTexts: frProvMiNetRequestInterval.setStatus('mandatory')
if mibBuilder.loadTexts: frProvMiNetRequestInterval.setDescription('This is the maximum number of seconds between successive status enquiry messages. If a status enquiry message does not arrive within this time an error event occurs. This is also refered to as T392 and nT2. Must be 5 in second intervals as defined in the ANSI and ITU specifications.')
frProvMiNetErrorThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frProvMiNetErrorThreshold.setReference('Draft American National Standard T1.617-1991, Section D.5.1 Counter N392.')
if mibBuilder.loadTexts: frProvMiNetErrorThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: frProvMiNetErrorThreshold.setDescription('This is the maximum number of unanswered Status Enquiries the equipment shall accept be- fore declaring the interface down by the network side of the interface. This is also refered to as N392 and nN2.')
frProvMiNetMonitoredEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frProvMiNetMonitoredEvents.setReference('Draft American National Standard T1.617-1991, Section D.5.2 Counter N393.')
if mibBuilder.loadTexts: frProvMiNetMonitoredEvents.setStatus('mandatory')
if mibBuilder.loadTexts: frProvMiNetMonitoredEvents.setDescription("This is the number of status polling intervals over which the error threshold is counted. For example, if within 'MonitoredEvents' number of events the station receives 'ErrorThreshold' number of errors, the interface is marked as down. This is also refered to as N393 and nN3.")
frProvMiMaxSupportedVCs = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 2, 1, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frProvMiMaxSupportedVCs.setStatus('mandatory')
if mibBuilder.loadTexts: frProvMiMaxSupportedVCs.setDescription("The maximum number of Virtual Circuits allowed for this interface. Usually dictated by the Frame Relay network. This variable will limit the creation of more than this number of VCs. It will not delete VCs which have already been configured at the time this parameter is set. In response to a SET, if a value less than zero or higher than the agent's maximal capability is configured, the agent should respond bad- Value")
frProvMiMulticast = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("nonBroadcast", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frProvMiMulticast.setStatus('mandatory')
if mibBuilder.loadTexts: frProvMiMulticast.setDescription('This indicates whether the Frame Relay inter- face is using a multicast service.')
frProvMiUserPollingInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 30)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frProvMiUserPollingInterval.setReference('Draft American National Standard T1.617-1991, Section D.7 Timer T391.')
if mibBuilder.loadTexts: frProvMiUserPollingInterval.setStatus('mandatory')
if mibBuilder.loadTexts: frProvMiUserPollingInterval.setDescription('This is the number of seconds between succes- sive status enquiry messages sent by the user portion of a NNI interface. This is also refered to as T391 and nT1.')
frProvMiUserFullEnquiryInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frProvMiUserFullEnquiryInterval.setReference('Draft American National Standard T1.617-1991, Section D.7 Counter N391.')
if mibBuilder.loadTexts: frProvMiUserFullEnquiryInterval.setStatus('mandatory')
if mibBuilder.loadTexts: frProvMiUserFullEnquiryInterval.setDescription('Number of status enquiry intervals that pass before issuance of a full status enquiry mes- sage by the user portion of a NNI interface. This is also refered to as N391 and nN1.')
frProvMiUserErrorThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 2, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frProvMiUserErrorThreshold.setReference('Draft American National Standard T1.617-1991, Section D.5.1 Counter N392.')
if mibBuilder.loadTexts: frProvMiUserErrorThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: frProvMiUserErrorThreshold.setDescription('This is the maximum number of unanswered Status Enquiries the equipment shall accept be- fore declaring the interface down by the user side of the NNI interface. This is also refered to as N392 and nT2.')
frProvMiUserMonitoredEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 2, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frProvMiUserMonitoredEvents.setReference('Draft American National Standard T1.617-1991, Section D.5.2 Counter N393.')
if mibBuilder.loadTexts: frProvMiUserMonitoredEvents.setStatus('mandatory')
if mibBuilder.loadTexts: frProvMiUserMonitoredEvents.setDescription("This is the number of status polling intervals over which the error threshold is counted on a NNI interface. For example, if within 'MonitoredEvents' number of events the station receives 'ErrorThreshold' number of errors, the interface is marked as down.")
frProvMiNetInterfaceType = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 2, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("niUNI", 1), ("niNNI", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frProvMiNetInterfaceType.setReference('Draft American National Standard T1.617-1991')
if mibBuilder.loadTexts: frProvMiNetInterfaceType.setStatus('mandatory')
if mibBuilder.loadTexts: frProvMiNetInterfaceType.setDescription('This variable states which type of Network Interface should be used. UNI provides for a User Network Interface, while NNI provides for a Network to Network Interface.')
frCktInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 3))
frCktCfgTable = MibTable((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 3, 1), )
if mibBuilder.loadTexts: frCktCfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: frCktCfgTable.setDescription('A table containing information about specific DLCIs and corresponding circuits.')
frCktEntry = MibTableRow((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 3, 1, 1), ).setIndexNames((0, "LIGHTSTREAM-MIB", "frCktSrcIfIndex"), (0, "LIGHTSTREAM-MIB", "frCktSrcDlci"))
if mibBuilder.loadTexts: frCktEntry.setStatus('mandatory')
if mibBuilder.loadTexts: frCktEntry.setDescription('The information regarding a single Data Link Connection Identifier.')
frCktSrcNode = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frCktSrcNode.setStatus('mandatory')
if mibBuilder.loadTexts: frCktSrcNode.setDescription('The Node Identifier for the source end of this virtual circuit.')
frCktSrcIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 3, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frCktSrcIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: frCktSrcIfIndex.setDescription('The ifIndex Value of the ifEntry this virtual circuit is layered onto. See comments above to calculate ifIndex value.')
frCktSrcDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 3, 1, 1, 3), LightStreamDLCI()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frCktSrcDlci.setReference('Draft American National Standard T1.618-1991, Section 3.3.6')
if mibBuilder.loadTexts: frCktSrcDlci.setStatus('mandatory')
if mibBuilder.loadTexts: frCktSrcDlci.setDescription('The Data Link Connection Identifier for this virtual circuit.')
frCktAdminDestNode = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 3, 1, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frCktAdminDestNode.setStatus('mandatory')
if mibBuilder.loadTexts: frCktAdminDestNode.setDescription('The Node Identifier for the Destination end of this virtual circuit. This variable takes effect when frCktStatus is set.')
frCktOperDestNode = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 3, 1, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frCktOperDestNode.setStatus('mandatory')
if mibBuilder.loadTexts: frCktOperDestNode.setDescription('The Node Identifier for the Destination end of this virtual circuit.')
frCktAdminDestIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 3, 1, 1, 12), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frCktAdminDestIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: frCktAdminDestIfIndex.setDescription('The ifIndex Value of the ifEntry this virtual circuit is layered onto. See comments above to calculate ifIndex. This variable takes effect when frCktStatus is set.')
frCktOperDestIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 3, 1, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frCktOperDestIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: frCktOperDestIfIndex.setDescription('The ifIndex Value of the ifEntry this virtual circuit is layered onto. See comments above to calculate ifIndex.')
frCktAdminDestDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 3, 1, 1, 14), LightStreamDLCI()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frCktAdminDestDlci.setReference('Draft American National Standard T1.618-1991, Section 3.3.6')
if mibBuilder.loadTexts: frCktAdminDestDlci.setStatus('mandatory')
if mibBuilder.loadTexts: frCktAdminDestDlci.setDescription('The Data Link Connection Identifier for this virtual circuit. This variable takes effect when frCktStatus is set.')
frCktOperDestDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 3, 1, 1, 15), LightStreamDLCI()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frCktOperDestDlci.setReference('Draft American National Standard T1.618-1991, Section 3.3.6')
if mibBuilder.loadTexts: frCktOperDestDlci.setStatus('mandatory')
if mibBuilder.loadTexts: frCktOperDestDlci.setDescription('The Data Link Connection Identifier for this virtual circuit.')
frCktAdminSrcInsuredRate = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 3, 1, 1, 25), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frCktAdminSrcInsuredRate.setReference('Draft American National Standard T1.617-1991, Section 6.5.19 Throughput parameter')
if mibBuilder.loadTexts: frCktAdminSrcInsuredRate.setStatus('mandatory')
if mibBuilder.loadTexts: frCktAdminSrcInsuredRate.setDescription('This variable, the Insured Rate is the rate of insured data that the network commits to supporting under normal network conditions from Source to Destination. It is specified in bits per second. This variable takes effect when frCktStatus is set.')
frCktOperSrcInsuredRate = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 3, 1, 1, 26), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frCktOperSrcInsuredRate.setReference('Draft American National Standard T1.617-1991, Section 6.5.19 Throughput parameter')
if mibBuilder.loadTexts: frCktOperSrcInsuredRate.setStatus('mandatory')
if mibBuilder.loadTexts: frCktOperSrcInsuredRate.setDescription('This variable, the Insured Rate is the rate of insured data that the network commits to supporting under normal network conditions from source to destination. It is specified in bits per second.')
frCktAdminSrcInsuredBurst = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 3, 1, 1, 27), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frCktAdminSrcInsuredBurst.setReference('Draft American National Standard T1.617-1991, Section 6.5.19')
if mibBuilder.loadTexts: frCktAdminSrcInsuredBurst.setStatus('mandatory')
if mibBuilder.loadTexts: frCktAdminSrcInsuredBurst.setDescription('This variable indicates the Insured Burst Size, which is the amount of insured data, in bytes, that the network agrees to transfer under normal conditions, during the measurement interval from source to destination. This variable takes effect when frCktStatus is set.')
frCktOperSrcInsuredBurst = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 3, 1, 1, 28), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frCktOperSrcInsuredBurst.setReference('Draft American National Standard T1.617-1991, Section 6.5.19')
if mibBuilder.loadTexts: frCktOperSrcInsuredBurst.setStatus('mandatory')
if mibBuilder.loadTexts: frCktOperSrcInsuredBurst.setDescription('This variable indicates the Insured Burst Size, which is the amount of insured data, in bytes, that the network agrees to transfer under normal conditions, during the measurement interval from source to destination.')
frCktAdminSrcMaxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 3, 1, 1, 29), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frCktAdminSrcMaxRate.setReference('Draft American National Standard T1.617-1991, Section 6.5.19 Throughput parameter')
if mibBuilder.loadTexts: frCktAdminSrcMaxRate.setStatus('mandatory')
if mibBuilder.loadTexts: frCktAdminSrcMaxRate.setDescription('This variable, the Maximum Rate is the the maximum amount of insured plus uninsured data throughput that the network agrees to support from source to destination. It is specified in bits per second. This variable takes effect when frCktStatus is set.')
frCktOperSrcMaxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 3, 1, 1, 30), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frCktOperSrcMaxRate.setReference('Draft American National Standard T1.617-1991, Section 6.5.19 Throughput parameter')
if mibBuilder.loadTexts: frCktOperSrcMaxRate.setStatus('mandatory')
if mibBuilder.loadTexts: frCktOperSrcMaxRate.setDescription('This variable, the Maximum Rate is the the maximum amount of insured plus uninsured data throughput that the network agrees to support from source to destination. It is specified in bits per second.')
frCktAdminSrcMaxBurst = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 3, 1, 1, 31), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frCktAdminSrcMaxBurst.setReference('Draft American National Standard T1.617-1991, Section 6.5.19')
if mibBuilder.loadTexts: frCktAdminSrcMaxBurst.setStatus('mandatory')
if mibBuilder.loadTexts: frCktAdminSrcMaxBurst.setDescription('This variable indicates the Total Burst Size, which is the maximum amount of insured plus uninsured data bytes that the network will at- tempt to deliver over the measurement interval from the Source to the Destination. This variable takes effect when frCktStatus is set.')
frCktOperSrcMaxBurst = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 3, 1, 1, 32), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frCktOperSrcMaxBurst.setReference('Draft American National Standard T1.617-1991, Section 6.5.19')
if mibBuilder.loadTexts: frCktOperSrcMaxBurst.setStatus('mandatory')
if mibBuilder.loadTexts: frCktOperSrcMaxBurst.setDescription('This variable indicates the Total Burst Size, which is the maximum amount of insured plus uninsured data bytes that the network will at- tempt to deliver over the measurement interval from the Source to the Destination.')
frCktAdminDestInsuredRate = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 3, 1, 1, 33), Integer32())
if mibBuilder.loadTexts: frCktAdminDestInsuredRate.setReference('Draft American National Standard T1.617-1991, Section 6.5.19 Throughput parameter')
if mibBuilder.loadTexts: frCktAdminDestInsuredRate.setStatus('mandatory')
if mibBuilder.loadTexts: frCktAdminDestInsuredRate.setDescription('This variable, the Insured Rate is the rate of insured data that the network commits to supporting under normal network conditions from destination to source. It is specified in bits per second. This variable takes effect when frCktStatus is set.')
frCktOperDestInsuredRate = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 3, 1, 1, 34), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frCktOperDestInsuredRate.setReference('Draft American National Standard T1.617-1991, Section 6.5.19 Throughput parameter')
if mibBuilder.loadTexts: frCktOperDestInsuredRate.setStatus('mandatory')
if mibBuilder.loadTexts: frCktOperDestInsuredRate.setDescription('This variable, the Insured Rate is the rate of insured data that the network commits to supporting under normal network conditions from destination to source. It is specified in bits per second.')
frCktAdminDestInsuredBurst = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 3, 1, 1, 35), Integer32())
if mibBuilder.loadTexts: frCktAdminDestInsuredBurst.setReference('Draft American National Standard T1.617-1991, Section 6.5.19')
if mibBuilder.loadTexts: frCktAdminDestInsuredBurst.setStatus('mandatory')
if mibBuilder.loadTexts: frCktAdminDestInsuredBurst.setDescription('This variable indicates the Insured Burst Size, which is the amount of insured data, in bytes, that the network agrees to transfer under normal conditions, during the measurement interval from destination to source. This variable takes effect when frCktStatus is set.')
frCktOperDestInsuredBurst = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 3, 1, 1, 36), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frCktOperDestInsuredBurst.setReference('Draft American National Standard T1.617-1991, Section 6.5.19')
if mibBuilder.loadTexts: frCktOperDestInsuredBurst.setStatus('mandatory')
if mibBuilder.loadTexts: frCktOperDestInsuredBurst.setDescription('This variable indicates the Insured Burst Size, which is the amount of insured data, in bytes, that the network agrees to transfer under normal conditions, during the measurement interval from destination to source.')
frCktAdminDestMaxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 3, 1, 1, 37), Integer32())
if mibBuilder.loadTexts: frCktAdminDestMaxRate.setReference('Draft American National Standard T1.617-1991, Section 6.5.19 Throughput parameter')
if mibBuilder.loadTexts: frCktAdminDestMaxRate.setStatus('mandatory')
if mibBuilder.loadTexts: frCktAdminDestMaxRate.setDescription('This variable, the Maximum Rate is the the maximum amount of insured plus uninsured data throughput that the network agrees to transfer from destination to source. It is specified in bits per second. This variable takes effect when frCktStatus is set.')
frCktOperDestMaxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 3, 1, 1, 38), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frCktOperDestMaxRate.setReference('Draft American National Standard T1.617-1991, Section 6.5.19 Throughput parameter')
if mibBuilder.loadTexts: frCktOperDestMaxRate.setStatus('mandatory')
if mibBuilder.loadTexts: frCktOperDestMaxRate.setDescription('This variable, the maximum rate is the total data throughput that the network will allow to pass on this VC under optimal network conditions from destination to source. It is specified in bits per second.')
frCktAdminDestMaxBurst = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 3, 1, 1, 39), Integer32())
if mibBuilder.loadTexts: frCktAdminDestMaxBurst.setReference('Draft American National Standard T1.617-1991, Section 6.5.19')
if mibBuilder.loadTexts: frCktAdminDestMaxBurst.setStatus('mandatory')
if mibBuilder.loadTexts: frCktAdminDestMaxBurst.setDescription('This variable indicates the Total Burst Size, which is the maximum amount of insured plus uninsured data bytes that the network will at- tempt to deliver over the measurement interval from the Destination to the Source. This variable takes effect when frCktStatus is set.')
frCktOperDestMaxBurst = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 3, 1, 1, 40), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frCktOperDestMaxBurst.setReference('Draft American National Standard T1.617-1991, Section 6.5.19')
if mibBuilder.loadTexts: frCktOperDestMaxBurst.setStatus('mandatory')
if mibBuilder.loadTexts: frCktOperDestMaxBurst.setDescription('This variable indicates the Total Burst Size, which is the maximum amount of insured plus uninsured data bytes that the network will at- tempt to deliver over the measurement interval from the Destination to the Source.')
frCktOperSecondaryScale = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 3, 1, 1, 41), Integer32().clone(255)).setMaxAccess("readonly")
if mibBuilder.loadTexts: frCktOperSecondaryScale.setStatus('mandatory')
if mibBuilder.loadTexts: frCktOperSecondaryScale.setDescription("Operational version of the Secondary bandwidth scaling factor. This is used to scale down the actual amount of bandwidth to allocate for the Secondary portion of a VC's bandwidth. This is specified as a codepoint as follows: Codepoints Meaning Comment - ---------- ------- ------- 0 - 100 x / 100 e.g., 1 => .01 101 - 109 x - 100 / 1000 e.g., 101 => .001 254 (reserved) 255 (per-port dflt)")
frCktAdminSecondaryScale = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 3, 1, 1, 42), Integer32().clone(255)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frCktAdminSecondaryScale.setStatus('mandatory')
if mibBuilder.loadTexts: frCktAdminSecondaryScale.setDescription("Secondary bandwidth scaling factor. This is used to scale down the actual amount of bandwidth to allocate for the Secondary portion of a VC's bandwidth. This is specified as a codepoint as follows: Codepoints Meaning Comment - ---------- ------- ------- 0 - 100 x / 100 e.g., 1 => .01 101 - 109 x - 100 / 1000 e.g., 101 => .001 254 (reserved) 255 (per-port dflt)")
frCktOperPrinBwType = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 3, 1, 1, 43), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("guaranteed", 1), ("insured", 2))).clone(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: frCktOperPrinBwType.setStatus('mandatory')
if mibBuilder.loadTexts: frCktOperPrinBwType.setDescription('This variable indicates the type of service supported on primary portion of this Virtual Circuit.')
frCktAdminPrinBwType = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 3, 1, 1, 44), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("guaranteed", 1), ("insured", 2))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frCktAdminPrinBwType.setStatus('mandatory')
if mibBuilder.loadTexts: frCktAdminPrinBwType.setDescription('This variable indicates the type of service supported on primary portion of this Virtual Circuit. This variable takes effect when frCktStatus is set.')
frCktOperTransPri = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 3, 1, 1, 45), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frCktOperTransPri.setStatus('mandatory')
if mibBuilder.loadTexts: frCktOperTransPri.setDescription('This variable indicates the transfer priority supported on this Virtual Circuit.')
frCktAdminTransPri = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 3, 1, 1, 46), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frCktAdminTransPri.setStatus('mandatory')
if mibBuilder.loadTexts: frCktAdminTransPri.setDescription('This variable indicates the transfer priority supported on this Virtual Circuit. This variable takes effect when frCktStatus is set.')
frCktOperUserDataPerCell = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 3, 1, 1, 47), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 384))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frCktOperUserDataPerCell.setStatus('mandatory')
if mibBuilder.loadTexts: frCktOperUserDataPerCell.setDescription('Operational User data bits per cell, specifies the expected packing efficiency when frames are converted to cells. It does not affect the actual packing of data into cells but serves as an estimate on which bandwidth allocation and other connection related functions will be based.')
frCktAdminUserDataPerCell = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 3, 1, 1, 48), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 384))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frCktAdminUserDataPerCell.setStatus('mandatory')
if mibBuilder.loadTexts: frCktAdminUserDataPerCell.setDescription('Administrative User data bits per cell, specifies the expected packing efficiency when frames are converted to cells. It does not affect the actual packing of data into cells but serves as an estimate on which bandwidth allocation and other connection related functions will be based. This variable takes effect when frCktStatus is set.')
frCktStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 3, 1, 1, 99), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("delete", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frCktStatus.setStatus('mandatory')
if mibBuilder.loadTexts: frCktStatus.setDescription('This variable indicates the Status of this Virtual Circuit. It may be enabled or disabled. In order to modify a Virtual Circuit, the new desired variables should be modified and then this variable should be set (or set again) to enabled. At that time desired variables will become the actual variables. To remove a PVC, set its status to delete. By default, if not configured when creating the entry, the status is disabled.')
frCktInfoTable = MibTable((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 3, 2), )
if mibBuilder.loadTexts: frCktInfoTable.setStatus('mandatory')
if mibBuilder.loadTexts: frCktInfoTable.setDescription('A table containing information about specific DLCIs and corresponding circuits.')
frCktInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 3, 2, 1), ).setIndexNames((0, "LIGHTSTREAM-MIB", "frCktInfoIfIndex"), (0, "LIGHTSTREAM-MIB", "frCktInfoDlci"))
if mibBuilder.loadTexts: frCktInfoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: frCktInfoEntry.setDescription('The information regarding a single Data Link Connection Identifier.')
frCktInfoIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frCktInfoIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: frCktInfoIfIndex.setDescription('The ifIndex Value of the ifEntry this virtual circuit is layered onto. See comments above to calculate ifIndex.')
frCktInfoDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 3, 2, 1, 2), LightStreamDLCI()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frCktInfoDlci.setReference('Draft American National Standard T1.618-1991, Section 3.3.6')
if mibBuilder.loadTexts: frCktInfoDlci.setStatus('mandatory')
if mibBuilder.loadTexts: frCktInfoDlci.setDescription('The Data Link Connection Identifier for this virtual circuit.')
frCktInfoLclLMI = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frCktInfoLclLMI.setStatus('mandatory')
if mibBuilder.loadTexts: frCktInfoLclLMI.setDescription('This variable indicates the local LMI state of the circuit.')
frCktInfoRmtLMI = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 3, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frCktInfoRmtLMI.setStatus('mandatory')
if mibBuilder.loadTexts: frCktInfoRmtLMI.setDescription('This variable indicates the remote LMI state of the circuit.')
frCktInfoCallIDIncoming = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 3, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frCktInfoCallIDIncoming.setStatus('mandatory')
if mibBuilder.loadTexts: frCktInfoCallIDIncoming.setDescription('This variable indicates the Call Identifier assigned to the incomming half of this circuit.')
frCktInfoCallIDOutgoing = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 3, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frCktInfoCallIDOutgoing.setStatus('mandatory')
if mibBuilder.loadTexts: frCktInfoCallIDOutgoing.setDescription('This variable indicates the Call Identifier assigned to the outgoing half of this circuit.')
frCktInfoDownstreamState = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 3, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frCktInfoDownstreamState.setStatus('mandatory')
if mibBuilder.loadTexts: frCktInfoDownstreamState.setDescription('This variable indicates the state of the downstream half of the circuit. (passing data from the local port to the remote end of the network)')
frCktInfoUpstreamState = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 3, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frCktInfoUpstreamState.setStatus('mandatory')
if mibBuilder.loadTexts: frCktInfoUpstreamState.setDescription('This variable indicates the state of the upstream half of the circuit. (passing data from the port at the remote end of the network to the local port)')
frCktInfoLastAtmErr = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 3, 2, 1, 9), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frCktInfoLastAtmErr.setStatus('mandatory')
if mibBuilder.loadTexts: frCktInfoLastAtmErr.setDescription('This variable indicates the last error, if any, returned by the Atm Connection Management layer when an attempt was made to create a connection or flow.')
frCktInfoDataCellsRequired = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 3, 2, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frCktInfoDataCellsRequired.setStatus('mandatory')
if mibBuilder.loadTexts: frCktInfoDataCellsRequired.setDescription('This variable indicates the bandwidth in cells needed to establish this VC. The value returned combines the committed and the Secondary bandwidth needs.')
frCktInfoLastAtmLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 3, 2, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frCktInfoLastAtmLocation.setStatus('mandatory')
if mibBuilder.loadTexts: frCktInfoLastAtmLocation.setDescription('This variable indicates the last error, if any, returned by the Atm Connection Management layer when an attempt was made to create a connection or flow. The format of the string is: nodenum:ifIndex where all numbers are specified in decimal. For example 5142:6000 refers to the remote endpoint with node 5142, ifIndex 6000 (slot 6 port 0 fr type 0).')
ffCktInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 4))
ffCktCfgTable = MibTable((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 4, 1), )
if mibBuilder.loadTexts: ffCktCfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: ffCktCfgTable.setDescription('A table containing information about Frame Forwarding circuits for every port.')
ffCktEntry = MibTableRow((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 4, 1, 1), ).setIndexNames((0, "LIGHTSTREAM-MIB", "ffCktSrcIfIndex"))
if mibBuilder.loadTexts: ffCktEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ffCktEntry.setDescription('The information regarding a single Data Link Connection Identifier.')
ffCktSrcNode = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 4, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ffCktSrcNode.setStatus('mandatory')
if mibBuilder.loadTexts: ffCktSrcNode.setDescription('The Node Identifier for the source end of this virtual circuit.')
ffCktSrcIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 4, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ffCktSrcIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ffCktSrcIfIndex.setDescription('The ifIndex Value of the ifEntry this virtual circuit is layered onto. See above comments to calculate ifIndex.')
ffCktAdminDestNode = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 4, 1, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ffCktAdminDestNode.setStatus('mandatory')
if mibBuilder.loadTexts: ffCktAdminDestNode.setDescription('The Node Identifier for the Destination end of this virtual circuit. This variable takes effect when ffCktStatus is set.')
ffCktOperDestNode = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 4, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ffCktOperDestNode.setStatus('mandatory')
if mibBuilder.loadTexts: ffCktOperDestNode.setDescription('The Node Identifier for the Destination end of this virtual circuit.')
ffCktAdminDestIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 4, 1, 1, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ffCktAdminDestIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ffCktAdminDestIfIndex.setDescription('The ifIndex Value of the ifEntry this virtual circuit is layered onto. See above comments to calculate ifIndex. This variable takes effect when ffCktStatus is set.')
ffCktOperDestIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 4, 1, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ffCktOperDestIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ffCktOperDestIfIndex.setDescription('The ifIndex Value of the ifEntry this virtual circuit is layered onto. See above comments to calculate ifIndex.')
ffCktAdminSrcInsuredRate = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 4, 1, 1, 21), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ffCktAdminSrcInsuredRate.setStatus('mandatory')
if mibBuilder.loadTexts: ffCktAdminSrcInsuredRate.setDescription('This variable, the Insured Rate is the rate of insured data that the network commits to supporting under normal network conditions from source to destination. This is specified in bits per second. This variable takes effect when ffCktStatus is set.')
ffCktOperSrcInsuredRate = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 4, 1, 1, 22), Integer32().clone(-11)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ffCktOperSrcInsuredRate.setStatus('mandatory')
if mibBuilder.loadTexts: ffCktOperSrcInsuredRate.setDescription('This variable, the Insured Rate is the rate of insured data that the network commits to supporting under normal network conditions from source to destination. This is specified in bits per second.')
ffCktAdminSrcInsuredBurst = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 4, 1, 1, 23), Integer32().clone(-1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ffCktAdminSrcInsuredBurst.setStatus('mandatory')
if mibBuilder.loadTexts: ffCktAdminSrcInsuredBurst.setDescription('This variable indicates the Insured Burst Size, which is the amount of insured data, in bytes, that the network agrees to transfer under normal conditions, during the measurement interval from source to destination. This variable takes effect when ffCktStatus is set.')
ffCktOperSrcInsuredBurst = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 4, 1, 1, 24), Integer32().clone(-1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ffCktOperSrcInsuredBurst.setStatus('mandatory')
if mibBuilder.loadTexts: ffCktOperSrcInsuredBurst.setDescription('This variable indicates the Insured Burst Size, which is the amount of insured data, in bytes, that the network agrees to transfer under normal conditions, during the measurement interval from source to destination.')
ffCktAdminSrcMaxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 4, 1, 1, 25), Integer32().clone(-1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ffCktAdminSrcMaxRate.setStatus('mandatory')
if mibBuilder.loadTexts: ffCktAdminSrcMaxRate.setDescription('This variable, the Maximum Rate is the the maximum amount of insured plus uninsured data throughput that the network agrees to transfer from source to destination. This is specified in bits per second. This variable takes effect when ffCktStatus is set.')
ffCktOperSrcMaxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 4, 1, 1, 26), Integer32().clone(-1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ffCktOperSrcMaxRate.setStatus('mandatory')
if mibBuilder.loadTexts: ffCktOperSrcMaxRate.setDescription('This variable, the Maximum Rate is the the maximum amount of insured plus uninsured data throughput that the network agrees to support from source to destination. This is specified in bits per second.')
ffCktAdminSrcMaxBurst = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 4, 1, 1, 27), Integer32().clone(-1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ffCktAdminSrcMaxBurst.setStatus('mandatory')
if mibBuilder.loadTexts: ffCktAdminSrcMaxBurst.setDescription('This variable indicates the Total Burst Size, the maximum amount of insured plus uninsured data, in bytes, that the network agrees to transfer under normal conditions, during the measurement interval from source to destination. This variable takes effect when ffCktStatus is set.')
ffCktOperSrcMaxBurst = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 4, 1, 1, 28), Integer32().clone(-1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ffCktOperSrcMaxBurst.setStatus('mandatory')
if mibBuilder.loadTexts: ffCktOperSrcMaxBurst.setDescription('This variable indicates the Total Burst Size, the maximum amount of insured plus uninsured data, in bytes, that the network agrees to transfer under normal conditions, during the measurement interval from source to destination.')
ffCktAdminDestInsuredRate = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 4, 1, 1, 29), Integer32().clone(-1))
if mibBuilder.loadTexts: ffCktAdminDestInsuredRate.setStatus('mandatory')
if mibBuilder.loadTexts: ffCktAdminDestInsuredRate.setDescription('This variable, the Insured Rate is the rate of insured data that the network commits to supporting under normal network conditions from destination to source. This is specified in bits per second. This variable takes effect when ffCktStatus is set.')
ffCktOperDestInsuredRate = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 4, 1, 1, 30), Integer32().clone(-1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ffCktOperDestInsuredRate.setStatus('mandatory')
if mibBuilder.loadTexts: ffCktOperDestInsuredRate.setDescription('This variable, the Insured Rate is the rate of insured data that the network commits to supporting under normal network conditions from destination to source. This is specified in bits per second.')
ffCktAdminDestInsuredBurst = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 4, 1, 1, 31), Integer32().clone(-1))
if mibBuilder.loadTexts: ffCktAdminDestInsuredBurst.setStatus('mandatory')
if mibBuilder.loadTexts: ffCktAdminDestInsuredBurst.setDescription('This variable indicates the Insured Burst Size, which is the amount of insured data, in bytes, that the network agrees to transfer under normal conditions, during the measurement interval from destination to source. This variable takes effect when ffCktStatus is set.')
ffCktOperDestInsuredBurst = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 4, 1, 1, 32), Integer32().clone(-1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ffCktOperDestInsuredBurst.setStatus('mandatory')
if mibBuilder.loadTexts: ffCktOperDestInsuredBurst.setDescription('This variable indicates the Insured Burst Size, which is the amount of insured data, in bytes, that the network agrees to transfer under normal conditions, during the measurement interval from destination to source.')
ffCktAdminDestMaxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 4, 1, 1, 33), Integer32().clone(-1))
if mibBuilder.loadTexts: ffCktAdminDestMaxRate.setStatus('mandatory')
if mibBuilder.loadTexts: ffCktAdminDestMaxRate.setDescription('This variable, the Maximum Rate is the the maximum amount of insured plus uninsured data throughput that the network agrees to transfer from destination to source. This is specified in bits per second. This variable takes effect when ffCktStatus is set.')
ffCktOperDestMaxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 4, 1, 1, 34), Integer32().clone(-1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ffCktOperDestMaxRate.setStatus('mandatory')
if mibBuilder.loadTexts: ffCktOperDestMaxRate.setDescription('This variable, the Maximum Rate is the the maximum amount of insured plus uninsured data throughput that the network agrees to support from destination to source. This is specified in bits per second.')
ffCktAdminDestMaxBurst = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 4, 1, 1, 35), Integer32().clone(-1))
if mibBuilder.loadTexts: ffCktAdminDestMaxBurst.setStatus('mandatory')
if mibBuilder.loadTexts: ffCktAdminDestMaxBurst.setDescription('This variable indicates the Total Burst Size, the maximum amount of insured plus uninsured data, in bytes, that the network agrees to transfer during the measurement interval from destination to source. This variable takes effect when ffCktStatus is set.')
ffCktOperDestMaxBurst = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 4, 1, 1, 36), Integer32().clone(-1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ffCktOperDestMaxBurst.setStatus('mandatory')
if mibBuilder.loadTexts: ffCktOperDestMaxBurst.setDescription('This variable indicates the Total Burst Size, the maximum amount of insured plus uninsured data, in bytes, that the network agrees to transfer, during the measurement interval from destination to source.')
ffCktOperPrinBwType = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 4, 1, 1, 37), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("guaranteed", 1), ("insured", 2))).clone(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ffCktOperPrinBwType.setStatus('mandatory')
if mibBuilder.loadTexts: ffCktOperPrinBwType.setDescription('This variable indicates the type of service supported on primary portion of this Virtual Circuit.')
ffCktAdminPrinBwType = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 4, 1, 1, 38), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("guaranteed", 1), ("insured", 2))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ffCktAdminPrinBwType.setStatus('mandatory')
if mibBuilder.loadTexts: ffCktAdminPrinBwType.setDescription('This variable indicates the type of service supported on primary portion of this Virtual Circuit. This variable takes effect when ffCktStatus is set.')
ffCktOperTransPri = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 4, 1, 1, 39), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1)).clone(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ffCktOperTransPri.setStatus('mandatory')
if mibBuilder.loadTexts: ffCktOperTransPri.setDescription('This variable indicates the transfer priority supported on this Virtual Circuit.')
ffCktAdminTransPri = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 4, 1, 1, 40), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ffCktAdminTransPri.setStatus('mandatory')
if mibBuilder.loadTexts: ffCktAdminTransPri.setDescription('This variable indicates the transfer priority supported on this Virtual Circuit. This variable takes effect when ffCktStatus is set.')
ffCktStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 4, 1, 1, 99), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("delete", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ffCktStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ffCktStatus.setDescription('This variable indicates the Status of this Virtual Circuit. It may be enabled or disabled. In order to modify a Virtual Circuit, the new desired variables should be modified and then this variable should be set (or set again) to enabled. At that time desired variables will become the actual variables. To remove a PVC, set its status to delete. By default, if not configured when creating the entry, the status is disabled.')
ffCktInfoTable = MibTable((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 4, 2), )
if mibBuilder.loadTexts: ffCktInfoTable.setStatus('mandatory')
if mibBuilder.loadTexts: ffCktInfoTable.setDescription('A table containing information about specific Frame Forwarding virtual circuits.')
ffCktInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 4, 2, 1), ).setIndexNames((0, "LIGHTSTREAM-MIB", "ffCktInfoIfIndex"))
if mibBuilder.loadTexts: ffCktInfoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ffCktInfoEntry.setDescription('The information regarding a single Data Link Connection Identifier.')
ffCktInfoIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 4, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ffCktInfoIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ffCktInfoIfIndex.setDescription('The ifIndex Value of the ifEntry this virtual circuit is layered onto. See above comments to calculate ifIndex.')
ffCktInfoDownstreamState = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 4, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ffCktInfoDownstreamState.setStatus('mandatory')
if mibBuilder.loadTexts: ffCktInfoDownstreamState.setDescription('This variable indicates the state of the downstream half of the circuit. (passing data from the local port to the remote end of the network)')
ffCktInfoUpstreamState = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 4, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ffCktInfoUpstreamState.setStatus('mandatory')
if mibBuilder.loadTexts: ffCktInfoUpstreamState.setDescription('This variable indicates the state of the upstream half of the circuit. (passing data from the port at the remote end of the network to the local port)')
ffCktInfoCallIDIncoming = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 4, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ffCktInfoCallIDIncoming.setStatus('mandatory')
if mibBuilder.loadTexts: ffCktInfoCallIDIncoming.setDescription('This variable indicates the Call Identifier assigned to the incomming half of this circuit.')
ffCktInfoCallIDOutgoing = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 4, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ffCktInfoCallIDOutgoing.setStatus('mandatory')
if mibBuilder.loadTexts: ffCktInfoCallIDOutgoing.setDescription('This variable indicates the Call Identifier assigned to the outgoing half of this circuit.')
ffCktInfoLastAtmErr = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 4, 2, 1, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ffCktInfoLastAtmErr.setStatus('mandatory')
if mibBuilder.loadTexts: ffCktInfoLastAtmErr.setDescription('This variable indicates the last error, if any, returned by the Atm Connection Management layer when an attempt was made to create a connection or flow.')
ffCktInfoDataCellsRequired = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 4, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ffCktInfoDataCellsRequired.setStatus('mandatory')
if mibBuilder.loadTexts: ffCktInfoDataCellsRequired.setDescription('This variable indicates the bandwidth in cells needed to establish this VC. The value returned combines the committed and the Secondary bandwidth needs.')
ffCktInfoLastAtmLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 4, 2, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ffCktInfoLastAtmLocation.setStatus('mandatory')
if mibBuilder.loadTexts: ffCktInfoLastAtmLocation.setDescription('This variable indicates the last error, if any, returned by the Atm Connection Management layer when an attempt was made to create a connection or flow. The format of the string is: nodenum:ifIndex where all numbers are specified in decimal. For example 5142:6000 refers to the remote endpoint with node 5142, ifIndex 6000 (slot 6 port 0 frType 0).')
sUniCktInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 5))
sUniCktCfgTable = MibTable((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 5, 1), )
if mibBuilder.loadTexts: sUniCktCfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: sUniCktCfgTable.setDescription('A table containing information about specific VCIs and corresponding circuits.')
sUniCktEntry = MibTableRow((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 5, 1, 1), ).setIndexNames((0, "LIGHTSTREAM-MIB", "sUniCktSrcIfIndex"), (0, "LIGHTSTREAM-MIB", "sUniCktSrcVCI"))
if mibBuilder.loadTexts: sUniCktEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sUniCktEntry.setDescription('The information regarding a single Data Link Connection Identifier.')
sUniCktSrcNode = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 5, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sUniCktSrcNode.setStatus('mandatory')
if mibBuilder.loadTexts: sUniCktSrcNode.setDescription('The Node Identifier for the source end of this virtual circuit.')
sUniCktSrcIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 5, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sUniCktSrcIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sUniCktSrcIfIndex.setDescription('The ifIndex Value of the ifEntry this virtual circuit is layered onto. See above comments to calculate ifIndex.')
sUniCktSrcVCI = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 5, 1, 1, 3), VCI()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sUniCktSrcVCI.setStatus('mandatory')
if mibBuilder.loadTexts: sUniCktSrcVCI.setDescription('The Data Link Connection Identifier for this virtual circuit.')
sUniCktAdminDestNode = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 5, 1, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sUniCktAdminDestNode.setStatus('mandatory')
if mibBuilder.loadTexts: sUniCktAdminDestNode.setDescription('The Node Identifier for the Destination end of this virtual circuit. This variable takes effect when sUniCktSts is set.')
sUniCktOperDestNode = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 5, 1, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sUniCktOperDestNode.setStatus('mandatory')
if mibBuilder.loadTexts: sUniCktOperDestNode.setDescription('The Node Identifier for the Destination end of this virtual circuit.')
sUniCktAdminDestIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 5, 1, 1, 12), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sUniCktAdminDestIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sUniCktAdminDestIfIndex.setDescription('The ifIndex Value of the ifEntry this virtual circuit is layered onto. See above comments to calculate ifIndex. This variable takes effect when sUniCktSts is set.')
sUniCktOperDestIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 5, 1, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sUniCktOperDestIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sUniCktOperDestIfIndex.setDescription('The ifIndex Value of the ifEntry this virtual circuit is layered onto. See above comments to calculate ifIndex.')
sUniCktAdminDestVCI = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 5, 1, 1, 14), VCI()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sUniCktAdminDestVCI.setStatus('mandatory')
if mibBuilder.loadTexts: sUniCktAdminDestVCI.setDescription('The Data Link Connection Identifier for this virtual circuit. This variable takes effect when sUniCktSts is set.')
sUniCktOperDestVCI = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 5, 1, 1, 15), VCI()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sUniCktOperDestVCI.setStatus('mandatory')
if mibBuilder.loadTexts: sUniCktOperDestVCI.setDescription('The Data Link Connection Identifier for this virtual circuit.')
sUniCktOperPrinBwType = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 5, 1, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("guaranteed", 1), ("insured", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sUniCktOperPrinBwType.setStatus('mandatory')
if mibBuilder.loadTexts: sUniCktOperPrinBwType.setDescription('This variable indicates the type of service supported on primary portion of this Virtual Circuit.')
sUniCktAdminPrinBwType = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 5, 1, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("guaranteed", 1), ("insured", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sUniCktAdminPrinBwType.setStatus('mandatory')
if mibBuilder.loadTexts: sUniCktAdminPrinBwType.setDescription('This variable indicates the type of service supported on primary portion of this Virtual Circuit. This variable takes effect when sUniCktSts is set.')
sUniCktOperTransPri = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 5, 1, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sUniCktOperTransPri.setStatus('mandatory')
if mibBuilder.loadTexts: sUniCktOperTransPri.setDescription('This variable indicates the transfer priority supported on this Virtual Circuit.')
sUniCktAdminTransPri = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 5, 1, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sUniCktAdminTransPri.setStatus('mandatory')
if mibBuilder.loadTexts: sUniCktAdminTransPri.setDescription('This variable indicates the transfer priority supported on this Virtual Circuit. This variable takes effect when sUniCktSts is set.')
sUniCktAdminSrcInsuredRate = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 5, 1, 1, 26), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sUniCktAdminSrcInsuredRate.setStatus('mandatory')
if mibBuilder.loadTexts: sUniCktAdminSrcInsuredRate.setDescription('This variable, the Insured Rate is the rate of insured data that the network commits to supporting under normal network conditions from source to destination. This is specified in cells per second. This variable takes effect when sUniCktSts is set.')
sUniCktOperSrcInsuredRate = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 5, 1, 1, 27), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sUniCktOperSrcInsuredRate.setStatus('mandatory')
if mibBuilder.loadTexts: sUniCktOperSrcInsuredRate.setDescription('This variable, the Insured Rate is the rate of insured data that the network commits to supporting under normal network conditions from source to destination. This is specified in cells per second.')
sUniCktAdminSrcInsuredBurst = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 5, 1, 1, 28), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sUniCktAdminSrcInsuredBurst.setStatus('mandatory')
if mibBuilder.loadTexts: sUniCktAdminSrcInsuredBurst.setDescription('This variable indicates the Insured Burst Size, which is the amount of insured data, in cells, that the network agrees to transfer under normal conditions, during the measurement interval from source to destination. This variable takes effect when sUniCktSts is set.')
sUniCktOperSrcInsuredBurst = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 5, 1, 1, 29), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sUniCktOperSrcInsuredBurst.setStatus('mandatory')
if mibBuilder.loadTexts: sUniCktOperSrcInsuredBurst.setDescription('This variable indicates the Insured Burst Size, which is the amount of insured data, in cells, that the network agrees to transfer under normal conditions, during the measurement interval from source to destination.')
sUniCktAdminSrcMaxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 5, 1, 1, 30), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sUniCktAdminSrcMaxRate.setStatus('mandatory')
if mibBuilder.loadTexts: sUniCktAdminSrcMaxRate.setDescription('This variable, the maximum rate is the the total amount of insured plus uninsured data throughput that the network attempts to support under normal network conditions from destination to source. This is specified in cells per second. This variable takes effect when sUniCktSts is set.')
sUniCktOperSrcMaxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 5, 1, 1, 31), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sUniCktOperSrcMaxRate.setStatus('mandatory')
if mibBuilder.loadTexts: sUniCktOperSrcMaxRate.setDescription('This variable, the maximum rate is the the total amount of insured plus uninsured data throughput that the network attempts to support under normal network conditions from destination to source. This is specified in cells per second.')
sUniCktAdminSrcMaxBurst = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 5, 1, 1, 32), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sUniCktAdminSrcMaxBurst.setStatus('mandatory')
if mibBuilder.loadTexts: sUniCktAdminSrcMaxBurst.setDescription('This variable is the maximum Burst Size, the maximum amount of insured plus uninsured data, in cells, that the network will attempt to deliver over the measurement interval from the Source to the Destination. This variable takes effect when sUniCktSts is set.')
sUniCktOperSrcMaxBurst = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 5, 1, 1, 33), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sUniCktOperSrcMaxBurst.setStatus('mandatory')
if mibBuilder.loadTexts: sUniCktOperSrcMaxBurst.setDescription('This variable indicates the maximum Burst Size, the maximum amount of insured plus uninsured cells, that the network will attempt to deliver over the measurement interval from the Source to the Destination.')
sUniCktAdminDestInsuredRate = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 5, 1, 1, 34), Integer32())
if mibBuilder.loadTexts: sUniCktAdminDestInsuredRate.setStatus('mandatory')
if mibBuilder.loadTexts: sUniCktAdminDestInsuredRate.setDescription('This variable, the Insured Rate is the rate of insured data that the network commits to supporting under normal network conditions from destination to source. This is specified in cells per second. This variable takes effect when sUniCktSts is set.')
sUniCktOperDestInsuredRate = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 5, 1, 1, 35), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sUniCktOperDestInsuredRate.setStatus('mandatory')
if mibBuilder.loadTexts: sUniCktOperDestInsuredRate.setDescription('This variable, the Insured Rate, is the rate of insured data that the network commits to supporting under normal network conditions from destination to source. This is specified in cells per second.')
sUniCktAdminDestInsuredBurst = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 5, 1, 1, 36), Integer32())
if mibBuilder.loadTexts: sUniCktAdminDestInsuredBurst.setStatus('mandatory')
if mibBuilder.loadTexts: sUniCktAdminDestInsuredBurst.setDescription('This variable indicates the Insured Burst Size, which is the amount of insured data, in cells, that the network agrees to transfer under normal conditions, during the measurement interval from destination to source. This variable takes effect when sUniCktSts is set.')
sUniCktOperDestInsuredBurst = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 5, 1, 1, 37), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sUniCktOperDestInsuredBurst.setStatus('mandatory')
if mibBuilder.loadTexts: sUniCktOperDestInsuredBurst.setDescription('This variable indicates the Insured Burst Size, which is the amount of insured data, in cells, that the network agrees to transfer under normal conditions, during the measurement interval from destination to source.')
sUniCktAdminDestMaxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 5, 1, 1, 38), Integer32())
if mibBuilder.loadTexts: sUniCktAdminDestMaxRate.setStatus('mandatory')
if mibBuilder.loadTexts: sUniCktAdminDestMaxRate.setDescription('This variable, the maximum rate is the the total amount of insured plus uninsured data throughput that the network attempts to support under normal network conditions from destination to source. This is specified in cells per second. This variable takes effect when sUniCktSts is set.')
sUniCktOperDestMaxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 5, 1, 1, 39), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sUniCktOperDestMaxRate.setStatus('mandatory')
if mibBuilder.loadTexts: sUniCktOperDestMaxRate.setDescription('This variable, the maximum rate is the the total amount of insured plus uninsured data throughput that the network attempts to support under normal network conditions from destination to source. This is specified in cells per second.')
sUniCktAdminDestMaxBurst = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 5, 1, 1, 40), Integer32())
if mibBuilder.loadTexts: sUniCktAdminDestMaxBurst.setStatus('mandatory')
if mibBuilder.loadTexts: sUniCktAdminDestMaxBurst.setDescription('This variable is the maximum Burst Size, the maximum amount of insured plus uninsured cells that the network will attempt to deliver over the measurement interval from the Destination to the Source. This variable takes effect when sUniCktSts is set.')
sUniCktOperDestMaxBurst = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 5, 1, 1, 41), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sUniCktOperDestMaxBurst.setStatus('mandatory')
if mibBuilder.loadTexts: sUniCktOperDestMaxBurst.setDescription('This variable indicates the maximum Burst Size, the maximum amount of insured plus uninsured cells that the network will attempt to deliver over the measurement interval from the Destination to the Source.')
sUniCktAdminSecondaryScale = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 5, 1, 1, 42), Integer32().clone(255)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sUniCktAdminSecondaryScale.setStatus('mandatory')
if mibBuilder.loadTexts: sUniCktAdminSecondaryScale.setDescription("Secondary bandwidth scaling factor. This is used to scale down the actual amount of bandwidth to allocate for the Secondary portion of a VC's bandwidth. This is specified as a codepoint as follows: Codepoints Meaning Comment - ---------- ------- ------- 0 - 100 x / 100 e.g., 1 => .01 101 - 109 x - 100 / 1000 e.g., 101 => .001 254 (reserved) 255 (per-port dflt)")
sUniCktOperSecondaryScale = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 5, 1, 1, 43), Integer32().clone(255)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sUniCktOperSecondaryScale.setStatus('mandatory')
if mibBuilder.loadTexts: sUniCktOperSecondaryScale.setDescription("Operational version of the Secondary bandwidth scaling factor. This is used to scale down the actual amount of bandwidth to allocate for the Secondary portion of a VC's bandwidth. This is specified as a codepoint as follows: Codepoints Meaning Comment - ---------- ------- ------- 0 - 100 x / 100 e.g., 1 => .01 101 - 109 x - 100 / 1000 e.g., 101 => .001 254 (reserved) 255 (per-port dflt)")
sUniCktSts = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 5, 1, 1, 99), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("delete", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sUniCktSts.setStatus('mandatory')
if mibBuilder.loadTexts: sUniCktSts.setDescription('This variable indicates the Status of this Virtual Circuit. It may be enabled or disabled. In order to modify a Virtual Circuit, the new desired variables should be modified and then this variable should be set (or set again) to enabled. At that time desired variables will become the actual variables. To remove a PVC, set its status to delete. By default, if not configured when creating the entry, the status is disabled.')
sUniCktInfoTable = MibTable((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 5, 2), )
if mibBuilder.loadTexts: sUniCktInfoTable.setStatus('mandatory')
if mibBuilder.loadTexts: sUniCktInfoTable.setDescription('A table containing information about specific VCIs and corresponding circuits.')
sUniCktInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 5, 2, 1), ).setIndexNames((0, "LIGHTSTREAM-MIB", "sUniCktInfoIfIndex"), (0, "LIGHTSTREAM-MIB", "sUniCktInfoVCI"))
if mibBuilder.loadTexts: sUniCktInfoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sUniCktInfoEntry.setDescription('The information regarding a single Data Link Connection Identifier.')
sUniCktInfoIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 5, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sUniCktInfoIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sUniCktInfoIfIndex.setDescription('The ifIndex Value of the ifEntry this virtual circuit is layered onto. See above comments to calculate ifIndex.')
sUniCktInfoVCI = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 5, 2, 1, 2), VCI()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sUniCktInfoVCI.setStatus('mandatory')
if mibBuilder.loadTexts: sUniCktInfoVCI.setDescription('The Data Link Connection Identifier for this virtual circuit.')
sUniCktInfoUniToNetCallID = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 5, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sUniCktInfoUniToNetCallID.setStatus('mandatory')
if mibBuilder.loadTexts: sUniCktInfoUniToNetCallID.setDescription('This variable indicates the Call Identifier assigned to the incomming half of this circuit.')
sUniCktInfoNetToUniCallID = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 5, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sUniCktInfoNetToUniCallID.setStatus('mandatory')
if mibBuilder.loadTexts: sUniCktInfoNetToUniCallID.setDescription('This variable indicates the Call Identifier assigned to the outgoing half of this circuit.')
sUniCktInfoUniToNetState = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 5, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sUniCktInfoUniToNetState.setStatus('mandatory')
if mibBuilder.loadTexts: sUniCktInfoUniToNetState.setDescription('This variable indicates the state of the UniToNet half of the circuit. (passing data from the local port to the remote end of the network)')
sUniCktInfoNetToUniState = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 5, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sUniCktInfoNetToUniState.setStatus('mandatory')
if mibBuilder.loadTexts: sUniCktInfoNetToUniState.setDescription('This variable indicates the state of the NetToUni half of the circuit. (passing data from the port at the remote end of the network to the local port)')
sUniCktInfoLastAtmErr = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 5, 2, 1, 7), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sUniCktInfoLastAtmErr.setStatus('mandatory')
if mibBuilder.loadTexts: sUniCktInfoLastAtmErr.setDescription('This variable indicates the last error, if any, returned by the Atm Connection Management layer when an attempt was made to create a connection or flow.')
sUniCktInfoDataCellsRequired = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 5, 2, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sUniCktInfoDataCellsRequired.setStatus('mandatory')
if mibBuilder.loadTexts: sUniCktInfoDataCellsRequired.setDescription('This variable indicates the bandwidth in cells needed to establish this VC. The value returned combines the committed and the Secondary bandwidth needs.')
sUniCktInfoLastAtmLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 5, 2, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sUniCktInfoLastAtmLocation.setStatus('mandatory')
if mibBuilder.loadTexts: sUniCktInfoLastAtmLocation.setDescription('This variable indicates the last error, if any, returned by the Atm Connection Management layer when an attempt was made to create a connection or flow. The format of the string is: nodenum:ifIndex where all numbers are specified in decimal. For example 5142:6000 refers to the remote endpoint with node 5142, ifIndex 6000 (slot 6 port 0 frType 0).')
pvcInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 6))
pvcCfgTable = MibTable((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 6, 1), )
if mibBuilder.loadTexts: pvcCfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: pvcCfgTable.setDescription('A table containing information about specific PVCs.')
pvcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 6, 1, 1), ).setIndexNames((0, "LIGHTSTREAM-MIB", "pvcSrcIfIndex"), (0, "LIGHTSTREAM-MIB", "pvcSrcPvcId"))
if mibBuilder.loadTexts: pvcEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pvcEntry.setDescription('The information regarding a single PVC.')
pvcSrcIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 6, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvcSrcIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pvcSrcIfIndex.setDescription('The ifIndex Value of the ifEntry this virtual circuit is layered onto. See above comments to calculate ifIndex.')
pvcSrcPvcId = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 6, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvcSrcPvcId.setReference('Draft American National Standard T1.618-1991, Section 3.3.6')
if mibBuilder.loadTexts: pvcSrcPvcId.setStatus('mandatory')
if mibBuilder.loadTexts: pvcSrcPvcId.setDescription('The local PVC Connection Identifier for this virtual circuit.')
pvcSrcNode = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 6, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pvcSrcNode.setStatus('mandatory')
if mibBuilder.loadTexts: pvcSrcNode.setDescription('The Node Identifier for the source end of this virtual circuit.')
pvcSrcInsuredRate = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 6, 1, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcSrcInsuredRate.setReference('Draft American National Standard T1.617-1991, Section 6.5.19 Throughput parameter')
if mibBuilder.loadTexts: pvcSrcInsuredRate.setStatus('mandatory')
if mibBuilder.loadTexts: pvcSrcInsuredRate.setDescription('This variable, the Insured Rate is the rate of insured data that the network commits to supporting under normal network conditions from Source to Destination. It is specified in bits per second. This variable takes effect when pvcStatus is set. This variable may not be modified unless pvcStatus is set to disabled.')
pvcSrcInsuredBurst = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 6, 1, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcSrcInsuredBurst.setReference('Draft American National Standard T1.617-1991, Section 6.5.19')
if mibBuilder.loadTexts: pvcSrcInsuredBurst.setStatus('mandatory')
if mibBuilder.loadTexts: pvcSrcInsuredBurst.setDescription('This variable indicates the Insured Burst Size, which is the amount of insured data, in bytes, that the network agrees to transfer under normal conditions, during the measurement interval from source to destination. This variable takes effect when pvcStatus is set. This variable may not be modified unless pvcStatus is set to disabled.')
pvcSrcMaxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 6, 1, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcSrcMaxRate.setReference('Draft American National Standard T1.617-1991, Section 6.5.19 Throughput parameter')
if mibBuilder.loadTexts: pvcSrcMaxRate.setStatus('mandatory')
if mibBuilder.loadTexts: pvcSrcMaxRate.setDescription('This variable, the Maximum Rate is the the maximum amount of insured plus uninsured data throughput that the network agrees to support from source to destination. It is specified in bits per second. This variable takes effect when pvcStatus is set. This variable may not be modified unless pvcStatus is set to disabled.')
pvcSrcMaxBurst = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 6, 1, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcSrcMaxBurst.setReference('Draft American National Standard T1.617-1991, Section 6.5.19')
if mibBuilder.loadTexts: pvcSrcMaxBurst.setStatus('mandatory')
if mibBuilder.loadTexts: pvcSrcMaxBurst.setDescription('This variable indicates the Total Burst Size, which is the maximum amount of insured plus uninsured data bytes that the network will at- tempt to deliver over the measurement interval from the Source to the Destination. This variable takes effect when pvcStatus is set. This variable may not be modified unless pvcStatus is set to disabled.')
pvcSecondaryScale = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 6, 1, 1, 8), Integer32().clone(255)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcSecondaryScale.setStatus('mandatory')
if mibBuilder.loadTexts: pvcSecondaryScale.setDescription("Secondary bandwidth scaling factor. This is used to scale down the actual amount of bandwidth to allocate for the Secondary portion of a VC's bandwidth. This is specified as a codepoint as follows: Codepoints Meaning Comment - ---------- ------- ------- 0 - 100 x / 100 e.g., 1 => .01 101 - 109 x - 100 / 1000 e.g., 101 => .001 254 (reserved) 255 (per-port dflt)")
pvcPrinBwType = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 6, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("guaranteed", 1), ("insured", 2))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcPrinBwType.setStatus('mandatory')
if mibBuilder.loadTexts: pvcPrinBwType.setDescription('This variable indicates the type of service supported on primary portion of this Virtual Circuit. This variable takes effect when pvcStatus is set. This variable may not be modified unless pvcStatus is set to disabled.')
pvcTransPri = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 6, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcTransPri.setStatus('mandatory')
if mibBuilder.loadTexts: pvcTransPri.setDescription('This variable indicates the transfer priority supported on this Virtual Circuit. This variable takes effect when pvcStatus is set. This variable may not be modified unless pvcStatus is set to disabled.')
pvcUserDataPerCell = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 6, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 384))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcUserDataPerCell.setStatus('mandatory')
if mibBuilder.loadTexts: pvcUserDataPerCell.setDescription('User data bits per cell, specifies the expected packing efficiency when frames are converted to cells. It does not affect the actual packing of data into cells but serves as an estimate on which bandwidth allocation and other connection related functions will be based. This variable takes effect when pvcStatus is set. This variable may not be modified unless pvcStatus is set to disabled.')
pvcStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 6, 1, 1, 99), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("delete", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pvcStatus.setStatus('mandatory')
if mibBuilder.loadTexts: pvcStatus.setDescription('This variable indicates the Status of this Virtual Circuit. It may be enabled or disabled. In order to modify a Virtual Circuit, the new desired variables should be modified and then this variable should be set (or set again) to enabled. At that time desired variables will become the actual variables. To remove a PVC, set its status to delete. By default, if not configured when creating the entry, the status is disabled.')
mcEndptInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 7))
mcEndptCfgTable = MibTable((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 7, 1), )
if mibBuilder.loadTexts: mcEndptCfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: mcEndptCfgTable.setDescription('A table containing information about specific endpoints and corresponding circuits.')
mcEndptEntry = MibTableRow((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 7, 1, 1), ).setIndexNames((0, "LIGHTSTREAM-MIB", "mcEndptLclIfIndex"), (0, "LIGHTSTREAM-MIB", "mcEndptLclCktid"), (0, "LIGHTSTREAM-MIB", "mcEndptLclInstance"))
if mibBuilder.loadTexts: mcEndptEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mcEndptEntry.setDescription('The information regarding a single endpoint.')
mcEndptLclIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 7, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcEndptLclIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mcEndptLclIfIndex.setDescription('The ifIndex Value of the ifEntry this virtual circuit is layered onto. See above comments to calculate ifIndex.')
mcEndptLclCktid = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 7, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcEndptLclCktid.setStatus('mandatory')
if mibBuilder.loadTexts: mcEndptLclCktid.setDescription('The Local Circuit Identifier for this virtual circuit.')
mcEndptLclInstance = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 7, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcEndptLclInstance.setStatus('mandatory')
if mibBuilder.loadTexts: mcEndptLclInstance.setDescription('A Locally significant index used to separate the different remote endpoints for this multicast virtual circuit.')
mcEndptDest = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 7, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mcEndptDest.setStatus('mandatory')
if mibBuilder.loadTexts: mcEndptDest.setDescription('The Destination for this segment of the multicast virtual circuit. The format of the string is: nodenum:ifIndex:cktID where all numbers are specified in decimal. For example 5142:6000:16 refers to the remote endpoint with node 5142, ifIndex 6000 (slot 6 port 0 frType 0), and circuit identifier 16. This variable cannot be modified while mcEndptStatus is set to active.')
mcEndptServiceType = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 7, 1, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mcEndptServiceType.setStatus('mandatory')
if mibBuilder.loadTexts: mcEndptServiceType.setDescription('This variable is provided for future expansion, to allow creation of VCs between dissimilar protocols. This variable cannot be modified while mcEndptStatus is set to active.')
mcEndptRmtVCstatus = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 7, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcEndptRmtVCstatus.setStatus('mandatory')
if mibBuilder.loadTexts: mcEndptRmtVCstatus.setDescription('This variable indicates the remote state of the circuit. For FR this would be the LMI status.')
mcEndptCallIDIncoming = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 7, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcEndptCallIDIncoming.setStatus('mandatory')
if mibBuilder.loadTexts: mcEndptCallIDIncoming.setDescription('This variable indicates the Call Identifier assigned to the incomming (from the net) direction of this circuit.')
mcEndptDownstreamState = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 7, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcEndptDownstreamState.setStatus('mandatory')
if mibBuilder.loadTexts: mcEndptDownstreamState.setDescription('This variable indicates the state of the downstream direction of the circuit. (passing data from the local port to the remote end of the network)')
mcEndptUpstreamState = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 7, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcEndptUpstreamState.setStatus('mandatory')
if mibBuilder.loadTexts: mcEndptUpstreamState.setDescription('This variable indicates the state of the upstream direction of the circuit. (passing data from the port at the remote end of the network to the local port)')
mcEndptLastAtmErr = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 7, 1, 1, 10), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcEndptLastAtmErr.setStatus('mandatory')
if mibBuilder.loadTexts: mcEndptLastAtmErr.setDescription('This variable indicates the last error, if any, returned by the Atm Connection Management layer when an attempt was made to create a connection or flow.')
mcEndptLastAtmLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 7, 1, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcEndptLastAtmLocation.setStatus('mandatory')
if mibBuilder.loadTexts: mcEndptLastAtmLocation.setDescription('This variable indicates the last error, if any, returned by the Atm Connection Management layer when an attempt was made to create a connection or flow. The format of the string is: nodenum:ifIndex where all numbers are specified in decimal. For example 5142:6000 refers to the remote endpoint with node 5142, ifIndex 6000 (slot 6 port 0 frType 0).')
mcEndptStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 8, 7, 1, 1, 99), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("delete", 3), ("createRequest", 4), ("underCreation", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mcEndptStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mcEndptStatus.setDescription('This variable indicates the Status of this Virtual Circuit. It may be enabled or disabled. In order to modify a Virtual Circuit, the new desired variables should be modified and then this variable should be set (or set again) to enabled. At that time desired variables will become the operational (or in-use) variables. To remove a PVC, set its status to delete. By default, if not configured when creating the entry, the status is disabled. An existing instance of this object cannot be set to createRequest(4). This object may only be set to createRequest(4) when this instance is created. When this object is created, the agent may wish to create supplemental object instances to complete a conceptual row in this table. Immediately after completing the create operation, the agent must set this object to underCreation(5). Entries shall exist in the underCreation(5) state until the management station is finished configuring the entry and sets this object to active(1), inactive(2), or aborts, setting this object to delete(4). If the agent determines that an entry has been in the underCreation(5) state for an abnormally long time, it may decide that the management station has become unavailable. If the agent makes this decision, it may set this object to delete(3) to reclaim the entry. A prudent agent will understand that the management station may need to wait for human input and will allow for that possibility in its determination of this abnormally long period.')
lsPrivate = MibIdentifier((1, 3, 6, 1, 4, 1, 711, 2, 1, 10))
lsExperimental = MibIdentifier((1, 3, 6, 1, 4, 1, 711, 2, 1, 11))
lsExperimentalStatistics = MibIdentifier((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1))
lsEdgeStatistics = MibIdentifier((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1))
lsEdgeStatTable = MibTable((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 1), )
if mibBuilder.loadTexts: lsEdgeStatTable.setStatus('mandatory')
if mibBuilder.loadTexts: lsEdgeStatTable.setDescription('Edge Card specific statistics subset information')
lsEdgeStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 1, 1), ).setIndexNames((0, "LIGHTSTREAM-MIB", "edgeStatIndex"))
if mibBuilder.loadTexts: lsEdgeStatEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lsEdgeStatEntry.setDescription('An entry in Edge Card Statistics Table.')
edgeStatIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: edgeStatIndex.setStatus('mandatory')
if mibBuilder.loadTexts: edgeStatIndex.setDescription('This is the ifIndex value of the corresponding ifEntry. See comments above.')
edgeStatFsuRATOs = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: edgeStatFsuRATOs.setStatus('mandatory')
if mibBuilder.loadTexts: edgeStatFsuRATOs.setDescription('The total number of Reassembly TimeOuts detected by the FSU')
edgeStatFsuRATOLastInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: edgeStatFsuRATOLastInfo.setStatus('mandatory')
if mibBuilder.loadTexts: edgeStatFsuRATOLastInfo.setDescription('Header Information related to the last RATO (Port/VCI minimum)')
edgeStatTsuHoldQCells = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 1, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: edgeStatTsuHoldQCells.setStatus('mandatory')
if mibBuilder.loadTexts: edgeStatTsuHoldQCells.setDescription('The total number of cells in hold queues')
edgeStatTsuHoldQs = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 1, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: edgeStatTsuHoldQs.setStatus('mandatory')
if mibBuilder.loadTexts: edgeStatTsuHoldQs.setDescription('The total number of active hold queues')
tluAAL5XsumErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tluAAL5XsumErrs.setStatus('mandatory')
if mibBuilder.loadTexts: tluAAL5XsumErrs.setDescription('Number of AAL5 Xsum errors detected by the TLU. Availability may depend on HW type, such as ASIC HW.')
tluAAL5AbortErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tluAAL5AbortErrs.setStatus('mandatory')
if mibBuilder.loadTexts: tluAAL5AbortErrs.setDescription('Number of AAL5 Abort errors (zero length) detected by the TLU. Availability may depend on HW type, such as ASIC HW.')
tluAAL5ErrLastVci = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tluAAL5ErrLastVci.setStatus('mandatory')
if mibBuilder.loadTexts: tluAAL5ErrLastVci.setDescription('Contains the 16-bit VCI index corresponding to the last AAL5 Xsum or Abort error, along with the port number. Format TBD. Availability may depend on HW type, such as ASIC HW.')
lsEdgePortStatTable = MibTable((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 2), )
if mibBuilder.loadTexts: lsEdgePortStatTable.setStatus('mandatory')
if mibBuilder.loadTexts: lsEdgePortStatTable.setDescription('Edge Card specific statistics subset information')
lsEdgePortStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 2, 1), ).setIndexNames((0, "LIGHTSTREAM-MIB", "edgePortStatIndex"))
if mibBuilder.loadTexts: lsEdgePortStatEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lsEdgePortStatEntry.setDescription('An entry in Edge Port Statistics Table.')
edgePortStatIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: edgePortStatIndex.setStatus('mandatory')
if mibBuilder.loadTexts: edgePortStatIndex.setDescription('This is the ifIndex value of the corresponding ifEntry. See comments above.')
edgePortRcvOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: edgePortRcvOctets.setStatus('mandatory')
if mibBuilder.loadTexts: edgePortRcvOctets.setDescription('Number of octets received regardless of error status')
edgePortXmtOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: edgePortXmtOctets.setStatus('mandatory')
if mibBuilder.loadTexts: edgePortXmtOctets.setDescription('Number of octets transmitted regardless of error status')
edgePortFsuCksmErrMsgs = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: edgePortFsuCksmErrMsgs.setStatus('mandatory')
if mibBuilder.loadTexts: edgePortFsuCksmErrMsgs.setDescription('The number of messages with AAL5 checksum errors detected by FSU. May not be provided on a per-port basis in all HW.')
edgePortCksmErrLastVci = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: edgePortCksmErrLastVci.setStatus('mandatory')
if mibBuilder.loadTexts: edgePortCksmErrLastVci.setDescription('The last Vci index associated with a AAL5 checksum error. May not be provided on a per-port basis in all HW.')
edgePortDownXmtFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: edgePortDownXmtFrames.setStatus('mandatory')
if mibBuilder.loadTexts: edgePortDownXmtFrames.setDescription('The number of messages received by the TSU for which the the VCI was not configured.')
edgePortRcvUcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: edgePortRcvUcastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: edgePortRcvUcastPkts.setDescription('Number of Unicast packets received. Availability may depend on HW type, such as ASIC HW.')
edgePortRcvNUcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: edgePortRcvNUcastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: edgePortRcvNUcastPkts.setDescription('Number of Non-Unicast packets received. Availability may depend on HW type, such as ASIC HW.')
edgePortXmtUcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: edgePortXmtUcastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: edgePortXmtUcastPkts.setDescription('Number of Unicast packets transmitted. Availability may depend on HW type, such as ASIC HW.')
edgePortXmtNUcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: edgePortXmtNUcastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: edgePortXmtNUcastPkts.setDescription('Number of Non-Unicast packets transmitted. Availability may depend on HW type, such as ASIC HW.')
edgePortRcvSmplPktSize = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 2, 1, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: edgePortRcvSmplPktSize.setStatus('mandatory')
if mibBuilder.loadTexts: edgePortRcvSmplPktSize.setDescription('Number of octets for the last sampled from-port packet, including overhead octets. Used as a substitute for the frame size histogram when the histogram is not available. Availability may depend on HW type, such as ASIC HW. Sampling algorithm to be determined.')
edgePortXmtSmplPktSize = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 2, 1, 12), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: edgePortXmtSmplPktSize.setStatus('mandatory')
if mibBuilder.loadTexts: edgePortXmtSmplPktSize.setDescription('Number of octets for the last sampled to-port packet, including overhead octets. Used as a substitute for the frame size histogram when the histogram is not available. Availability may depend on HW type, such as ASIC HW. Sampling algorithm to be determined.')
edgePortRcvL3XsumErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: edgePortRcvL3XsumErrs.setStatus('mandatory')
if mibBuilder.loadTexts: edgePortRcvL3XsumErrs.setDescription('Number of L3 packets processed with a Level 3 checksum error. Availability may depend on HW type, such as ASIC HW.')
edgePortRcvL3XsumErrLastVci = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 2, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: edgePortRcvL3XsumErrLastVci.setStatus('mandatory')
if mibBuilder.loadTexts: edgePortRcvL3XsumErrLastVci.setDescription('Last 15-bit VCI index associated with a Level 3 checksum error. Availability may depend on HW type, such as ASIC HW.')
edgePortRcvCRCErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: edgePortRcvCRCErrors.setStatus('mandatory')
if mibBuilder.loadTexts: edgePortRcvCRCErrors.setDescription('The number of messages received by the port with CRC errors.')
edgePortRcvAborts = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 2, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: edgePortRcvAborts.setStatus('mandatory')
if mibBuilder.loadTexts: edgePortRcvAborts.setDescription('The number of aborts detected by the HW.')
edgePortXmtUnderflows = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 2, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: edgePortXmtUnderflows.setStatus('mandatory')
if mibBuilder.loadTexts: edgePortXmtUnderflows.setDescription('The number of underflow events detected by I/O hardware.')
edgePortRcvShortFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 2, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: edgePortRcvShortFrames.setStatus('mandatory')
if mibBuilder.loadTexts: edgePortRcvShortFrames.setDescription('The number of short incoming frames detected by L2')
lsFrameRelayDlciStatTable = MibTable((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 3), )
if mibBuilder.loadTexts: lsFrameRelayDlciStatTable.setStatus('mandatory')
if mibBuilder.loadTexts: lsFrameRelayDlciStatTable.setDescription('FrameRelay Port/DLCI specific statistics subset information')
lsFrameRelayDlciStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 3, 1), ).setIndexNames((0, "LIGHTSTREAM-MIB", "frameRelayDlciStatPortIndex"), (0, "LIGHTSTREAM-MIB", "frameRelayDlciStatDlciIndex"))
if mibBuilder.loadTexts: lsFrameRelayDlciStatEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lsFrameRelayDlciStatEntry.setDescription('An entry in the FrameRelay Port/Dlci Statistics Table.')
frameRelayDlciStatPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameRelayDlciStatPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelayDlciStatPortIndex.setDescription('This is the ifIndex value of the corresponding ifEntry. See comments above.')
frameRelayDlciStatDlciIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameRelayDlciStatDlciIndex.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelayDlciStatDlciIndex.setDescription('Unique Dlci identifier for indicated port')
frameRelayDlciToSwCLP0Frames = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 3, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameRelayDlciToSwCLP0Frames.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelayDlciToSwCLP0Frames.setDescription('Number of Frames forwarded to TSU with CLP=0')
frameRelayDlciToSwCLP0Cells = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameRelayDlciToSwCLP0Cells.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelayDlciToSwCLP0Cells.setDescription('Number of Cells forwarded to TSU with CLP=0')
frameRelayDlciToSwCLP1Frames = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameRelayDlciToSwCLP1Frames.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelayDlciToSwCLP1Frames.setDescription('Number of Frames forwarded to TSU with CLP=1')
frameRelayDlciToSwCLP1Cells = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameRelayDlciToSwCLP1Cells.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelayDlciToSwCLP1Cells.setDescription('Number of Cells forwarded to TSU with CLP=1')
frameRelayDlciToSwDiscardFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameRelayDlciToSwDiscardFrames.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelayDlciToSwDiscardFrames.setDescription('Number of to-switch Frames discarded due to excessive traffic according to the Usage Parameter Descriptor for this Dlci')
frameRelayDlciToSwDiscardCells = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 3, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameRelayDlciToSwDiscardCells.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelayDlciToSwDiscardCells.setDescription('Number of to-switch Cells discarded due to excessive traffic according to the Usage Parameter Descriptor for this Dlci')
frameRelayDlciFrSwCLP0Frames = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 3, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameRelayDlciFrSwCLP0Frames.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelayDlciFrSwCLP0Frames.setDescription('Number of frames received from the switch with CLP=0')
frameRelayDlciFrSwCLP0Cells = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 3, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameRelayDlciFrSwCLP0Cells.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelayDlciFrSwCLP0Cells.setDescription('Number of cells received from the switch with CLP=0')
frameRelayDlciFrSwCLP1Frames = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 3, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameRelayDlciFrSwCLP1Frames.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelayDlciFrSwCLP1Frames.setDescription('Number of frames received from the switch with CLP=1')
frameRelayDlciFrSwCLP1Cells = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 3, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameRelayDlciFrSwCLP1Cells.setStatus('mandatory')
if mibBuilder.loadTexts: frameRelayDlciFrSwCLP1Cells.setDescription('Number of cells received from the switch with CLP=1')
lsEdgePortToSwMsgLenTable = MibTable((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 4), )
if mibBuilder.loadTexts: lsEdgePortToSwMsgLenTable.setStatus('mandatory')
if mibBuilder.loadTexts: lsEdgePortToSwMsgLenTable.setDescription('Histogram of incoming message lengths (in cells) by Edge port')
lsEdgePortToSwMsgLenEntry = MibTableRow((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 4, 1), ).setIndexNames((0, "LIGHTSTREAM-MIB", "edgeToSwMsgLenPortIndex"), (0, "LIGHTSTREAM-MIB", "edgeToSwMsgLenBinIndex"))
if mibBuilder.loadTexts: lsEdgePortToSwMsgLenEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lsEdgePortToSwMsgLenEntry.setDescription('An entry in the Edge Port/Incoming-Message-Cell-Length histogram table.')
edgeToSwMsgLenPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: edgeToSwMsgLenPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: edgeToSwMsgLenPortIndex.setDescription('This is the ifIndex value of the corresponding ifEntry. See comments above.')
edgeToSwMsgLenBinIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: edgeToSwMsgLenBinIndex.setStatus('mandatory')
if mibBuilder.loadTexts: edgeToSwMsgLenBinIndex.setDescription('Histogram index for the incoming message size in units of network cells')
edgeToSwMsgLenMsgs = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 4, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: edgeToSwMsgLenMsgs.setStatus('mandatory')
if mibBuilder.loadTexts: edgeToSwMsgLenMsgs.setDescription('Count of the number of incoming messages of the given length in units of network cells.')
lsEdgeSwToPortMsgLenTable = MibTable((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 5), )
if mibBuilder.loadTexts: lsEdgeSwToPortMsgLenTable.setStatus('mandatory')
if mibBuilder.loadTexts: lsEdgeSwToPortMsgLenTable.setDescription('Histogram of incoming message lengths (in cells) by Edge port')
lsEdgeSwToPortMsgLenEntry = MibTableRow((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 5, 1), ).setIndexNames((0, "LIGHTSTREAM-MIB", "edgeToPortMsgLenPortIndex"), (0, "LIGHTSTREAM-MIB", "edgeToPortMsgLenBinIndex"))
if mibBuilder.loadTexts: lsEdgeSwToPortMsgLenEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lsEdgeSwToPortMsgLenEntry.setDescription('An entry in the Edge Port/Outgoing-Message-Cell-Length histogram table.')
edgeToPortMsgLenPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: edgeToPortMsgLenPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: edgeToPortMsgLenPortIndex.setDescription('This is the ifIndex value of the corresponding ifEntry. See comments above.')
edgeToPortMsgLenBinIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 5, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: edgeToPortMsgLenBinIndex.setStatus('mandatory')
if mibBuilder.loadTexts: edgeToPortMsgLenBinIndex.setDescription('Histogram index for the outgoing message length in units of network cells.')
edgeToPortMsgLenMsgs = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 5, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: edgeToPortMsgLenMsgs.setStatus('mandatory')
if mibBuilder.loadTexts: edgeToPortMsgLenMsgs.setDescription('Count of the number of outgoing messages of the given length in terms of network cells.')
lsEdgeCpuWorkloadTable = MibTable((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 6), )
if mibBuilder.loadTexts: lsEdgeCpuWorkloadTable.setStatus('mandatory')
if mibBuilder.loadTexts: lsEdgeCpuWorkloadTable.setDescription('Edge Card Workload Statistics Counter Table')
lsEdgeCpuWorkloadEntry = MibTableRow((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 6, 1), ).setIndexNames((0, "LIGHTSTREAM-MIB", "lsEdgeWorkloadCardIndex"), (0, "LIGHTSTREAM-MIB", "lsEdgeWorkloadTypeIndex"))
if mibBuilder.loadTexts: lsEdgeCpuWorkloadEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lsEdgeCpuWorkloadEntry.setDescription('An entry in the Edge Cpu Workload Table')
lsEdgeWorkloadCardIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsEdgeWorkloadCardIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lsEdgeWorkloadCardIndex.setDescription('Unique Edge card Index consisting of slot number.')
lsEdgeWorkloadTypeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 6, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsEdgeWorkloadTypeIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lsEdgeWorkloadTypeIndex.setDescription('Index which identifies the Edge CPU Workload Variable')
lsEdgeWorkloadEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 6, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsEdgeWorkloadEvents.setStatus('mandatory')
if mibBuilder.loadTexts: lsEdgeWorkloadEvents.setDescription('Edge Cpu Workload Counter for the specified Workload Variable')
lsFrameForwardStatTable = MibTable((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 7), )
if mibBuilder.loadTexts: lsFrameForwardStatTable.setStatus('mandatory')
if mibBuilder.loadTexts: lsFrameForwardStatTable.setDescription('FrameForward Port/ specific statistics subset information')
lsFrameForwardStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 7, 1), ).setIndexNames((0, "LIGHTSTREAM-MIB", "frameForwardStatPortIndex"))
if mibBuilder.loadTexts: lsFrameForwardStatEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lsFrameForwardStatEntry.setDescription('An entry in the FrameForward Port/ Statistics Table.')
frameForwardStatPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 7, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameForwardStatPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: frameForwardStatPortIndex.setDescription('This is the ifIndex value of the corresponding ifEntry. See comments above.')
frameForwardToSwCLP0Frames = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 7, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameForwardToSwCLP0Frames.setStatus('mandatory')
if mibBuilder.loadTexts: frameForwardToSwCLP0Frames.setDescription('Number of Frames forwarded to TSU with CLP=0')
frameForwardToSwCLP0Cells = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 7, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameForwardToSwCLP0Cells.setStatus('mandatory')
if mibBuilder.loadTexts: frameForwardToSwCLP0Cells.setDescription('Number of Cells forwarded to TSU with CLP=0')
frameForwardToSwCLP1Frames = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 7, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameForwardToSwCLP1Frames.setStatus('mandatory')
if mibBuilder.loadTexts: frameForwardToSwCLP1Frames.setDescription('Number of Frames forwarded to TSU with CLP=1')
frameForwardToSwCLP1Cells = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 7, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameForwardToSwCLP1Cells.setStatus('mandatory')
if mibBuilder.loadTexts: frameForwardToSwCLP1Cells.setDescription('Number of Cells forwarded to TSU with CLP=1')
frameForwardToSwDiscardFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 7, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameForwardToSwDiscardFrames.setStatus('mandatory')
if mibBuilder.loadTexts: frameForwardToSwDiscardFrames.setDescription('Number of to-switch Frames discarded due to excessive traffic according to the Usage Parameter Descriptor for this ')
frameForwardToSwDiscardCells = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 7, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameForwardToSwDiscardCells.setStatus('mandatory')
if mibBuilder.loadTexts: frameForwardToSwDiscardCells.setDescription('Number of to-switch Cells discarded due to excessive traffic according to the Usage Parameter Descriptor for this ')
frameForwardFrSwCLP0Frames = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 7, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameForwardFrSwCLP0Frames.setStatus('mandatory')
if mibBuilder.loadTexts: frameForwardFrSwCLP0Frames.setDescription('Number of frames received from the switch with CLP=0')
frameForwardFrSwCLP0Cells = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 7, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameForwardFrSwCLP0Cells.setStatus('mandatory')
if mibBuilder.loadTexts: frameForwardFrSwCLP0Cells.setDescription('Number of cells received from the switch with CLP=0')
frameForwardFrSwCLP1Frames = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 7, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameForwardFrSwCLP1Frames.setStatus('mandatory')
if mibBuilder.loadTexts: frameForwardFrSwCLP1Frames.setDescription('Number of frames received from the switch with CLP=1')
frameForwardFrSwCLP1Cells = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 1, 7, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frameForwardFrSwCLP1Cells.setStatus('mandatory')
if mibBuilder.loadTexts: frameForwardFrSwCLP1Cells.setDescription('Number of cells received from the switch with CLP=1')
lsTrunkStatistics = MibIdentifier((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 2))
lsTrunkPortStatTable = MibTable((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 2, 1), )
if mibBuilder.loadTexts: lsTrunkPortStatTable.setStatus('mandatory')
if mibBuilder.loadTexts: lsTrunkPortStatTable.setDescription('Trunk Card specific statistics subset information')
lsTrunkPortStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 2, 1, 1), ).setIndexNames((0, "LIGHTSTREAM-MIB", "trunkPortStatIndex"))
if mibBuilder.loadTexts: lsTrunkPortStatEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lsTrunkPortStatEntry.setDescription('An entry in Trunk Port Statistics Table.')
trunkPortStatIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkPortStatIndex.setStatus('mandatory')
if mibBuilder.loadTexts: trunkPortStatIndex.setDescription('This is the ifIndex value of the corresponding ifEntry. See comments above.')
trunkPortRcvCells = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 2, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkPortRcvCells.setStatus('mandatory')
if mibBuilder.loadTexts: trunkPortRcvCells.setDescription('Number of cells received regardless of error status')
trunkPortXmtCells = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 2, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkPortXmtCells.setStatus('mandatory')
if mibBuilder.loadTexts: trunkPortXmtCells.setDescription('Number of cells transmitted regardless of error status')
trunkPortRcvRuns = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 2, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkPortRcvRuns.setStatus('mandatory')
if mibBuilder.loadTexts: trunkPortRcvRuns.setDescription('The number of runs of cells received. A Run is a sequence of Non-Null Cells bounded by Null Cells.')
trunkPortDownXmtCells = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 2, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkPortDownXmtCells.setStatus('mandatory')
if mibBuilder.loadTexts: trunkPortDownXmtCells.setDescription('The number of cells received by the TSU for which the the VCI was not configured.')
trunkPortRcvCRCErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 2, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkPortRcvCRCErrors.setStatus('mandatory')
if mibBuilder.loadTexts: trunkPortRcvCRCErrors.setDescription('The number of messages received by the port with CRC errors.')
trunkPortRcvAborts = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 2, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkPortRcvAborts.setStatus('mandatory')
if mibBuilder.loadTexts: trunkPortRcvAborts.setDescription('The number of aborts detected by the HW.')
trunkPortXmtUnderflows = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 2, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkPortXmtUnderflows.setStatus('mandatory')
if mibBuilder.loadTexts: trunkPortXmtUnderflows.setDescription('The number of underflow events detected by I/O hardware.')
trunkPortRcvShortFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 2, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkPortRcvShortFrames.setStatus('mandatory')
if mibBuilder.loadTexts: trunkPortRcvShortFrames.setDescription('The number of short incoming frames detected by L2')
lsTrunkCpuWorkloadTable = MibTable((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 2, 2), )
if mibBuilder.loadTexts: lsTrunkCpuWorkloadTable.setStatus('mandatory')
if mibBuilder.loadTexts: lsTrunkCpuWorkloadTable.setDescription('Trunk Card Workload Statistics Counter Table')
lsTrunkCpuWorkloadEntry = MibTableRow((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 2, 2, 1), ).setIndexNames((0, "LIGHTSTREAM-MIB", "lsTrunkWorkloadCardIndex"), (0, "LIGHTSTREAM-MIB", "lsTrunkWorkloadTypeIndex"))
if mibBuilder.loadTexts: lsTrunkCpuWorkloadEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lsTrunkCpuWorkloadEntry.setDescription('An entry in the Trunk Cpu Workload Table')
lsTrunkWorkloadCardIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsTrunkWorkloadCardIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lsTrunkWorkloadCardIndex.setDescription("Unique Trunk card Index consisting of card's slot number")
lsTrunkWorkloadTypeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("average", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsTrunkWorkloadTypeIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lsTrunkWorkloadTypeIndex.setDescription('Trunk CPU Workload Counter Variable: 1 - average workload')
lsTrunkWorkloadEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 2, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsTrunkWorkloadEvents.setStatus('mandatory')
if mibBuilder.loadTexts: lsTrunkWorkloadEvents.setDescription('Trunk Cpu Workload Counter for the specified Workload Variable')
lsLcStatistics = MibIdentifier((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 3))
lcStatTable = MibTable((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 3, 1), )
if mibBuilder.loadTexts: lcStatTable.setStatus('mandatory')
if mibBuilder.loadTexts: lcStatTable.setDescription('Table of objects, such as FSU and TSU objects, which exist across for either trunk or edge cards, indexed by the line card alone. Some of these objects may require ASIC HW.')
lcStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 3, 1, 1), ).setIndexNames((0, "LIGHTSTREAM-MIB", "lcStatCardIndex"))
if mibBuilder.loadTexts: lcStatEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lcStatEntry.setDescription('An entry in the LC common FSU Stat table.')
lcStatCardIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcStatCardIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lcStatCardIndex.setDescription('Unique Line Card index')
tsuFreeCells = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 3, 1, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsuFreeCells.setStatus('mandatory')
if mibBuilder.loadTexts: tsuFreeCells.setDescription('The total number of free cells available on the Tsu')
fsuSharedFreeCells = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 3, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fsuSharedFreeCells.setStatus('mandatory')
if mibBuilder.loadTexts: fsuSharedFreeCells.setDescription('Number of Cells on the shared free-list in the FSU.')
tsuCellDropLastVci = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 3, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsuCellDropLastVci.setStatus('mandatory')
if mibBuilder.loadTexts: tsuCellDropLastVci.setDescription('The last VCI index associated with a message dropped by the TSU due to buffer shortage. This index implicitly determines the port and connection.')
switchCellDgRejectEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 3, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: switchCellDgRejectEvents.setStatus('mandatory')
if mibBuilder.loadTexts: switchCellDgRejectEvents.setDescription('The number of switch rejects of datagram cells. These are not errors, but this does provide a measure of switch contention. May only be available on ASIC HW Line Cards.')
switchCellSchedRejectEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 3, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: switchCellSchedRejectEvents.setStatus('mandatory')
if mibBuilder.loadTexts: switchCellSchedRejectEvents.setDescription('The number of switch rejects of datagram cells. These are errors, since appropriate scheduling should not allow these. May only be available on ASIC HW Line Cards.')
tsuErrFutQCellDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 3, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsuErrFutQCellDrops.setStatus('mandatory')
if mibBuilder.loadTexts: tsuErrFutQCellDrops.setDescription('The number of cells dropped due to FutureQ Overruns')
tsuErrFutQMsgDropLastVci = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 3, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsuErrFutQMsgDropLastVci.setStatus('mandatory')
if mibBuilder.loadTexts: tsuErrFutQMsgDropLastVci.setDescription('The last Vci index associated with a cell dropped due to FutureQ overrun.')
fsuHdrLrcErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 3, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fsuHdrLrcErrs.setStatus('mandatory')
if mibBuilder.loadTexts: fsuHdrLrcErrs.setDescription('The total number of LRC errors detected by the FSU')
fsuPayloadLrcErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 3, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fsuPayloadLrcErrs.setStatus('mandatory')
if mibBuilder.loadTexts: fsuPayloadLrcErrs.setDescription('The total number of LRC errors detected by the FSU')
lcPortStatTable = MibTable((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 3, 2), )
if mibBuilder.loadTexts: lcPortStatTable.setStatus('mandatory')
if mibBuilder.loadTexts: lcPortStatTable.setDescription('Table of Line Card (Edge and Trunk) Statistics by port. There are a number of TSU and FSU statistics in common to edges and trunks. Some of the objects in this table may be limited in use to ASIC HW.')
lcPortStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 3, 2, 1), ).setIndexNames((0, "LIGHTSTREAM-MIB", "lcStatPortIndex"))
if mibBuilder.loadTexts: lcPortStatEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lcPortStatEntry.setDescription('An entry in the Line Card Stat Table, indexed by port.')
lcStatPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcStatPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lcStatPortIndex.setDescription('This is the ifIndex value of the corresponding ifEntry. See comments above.')
fsuPortFreeCells = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 3, 2, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fsuPortFreeCells.setStatus('mandatory')
if mibBuilder.loadTexts: fsuPortFreeCells.setDescription('Number of Cells on per-port FSU free lists.')
fsuCellDropLastCellHdr = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 3, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fsuCellDropLastCellHdr.setStatus('mandatory')
if mibBuilder.loadTexts: fsuCellDropLastCellHdr.setDescription('The last Cell Header associated with a FSU cell drop due to buffer shortage. Provides a clue as to which VCIs are being dropped. Since this is a full 32-bit header, the CLP bit state is available. The XCLP and Queue can be inferred from indirect lookup based on the header, if desired.')
tsuPortErrL1UnconfigVcis = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 3, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsuPortErrL1UnconfigVcis.setStatus('mandatory')
if mibBuilder.loadTexts: tsuPortErrL1UnconfigVcis.setDescription('The number of cells received by the TSU for which the the VCI was not configured within the Level 1 table. Cells for unconfigured VCIs are dropped.')
tsuPortErrL2UnconfigVcis = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 3, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsuPortErrL2UnconfigVcis.setStatus('mandatory')
if mibBuilder.loadTexts: tsuPortErrL2UnconfigVcis.setDescription('The number of cells received by the TSU for which the the VCI was not configured within the Level 2 table. Cells for unconfigured VCIs are dropped.')
tsuPortErrL1UnconfigLastVci = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 3, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsuPortErrL1UnconfigLastVci.setStatus('mandatory')
if mibBuilder.loadTexts: tsuPortErrL1UnconfigLastVci.setDescription('The last 4-byte cell header associated with a Level 1 unconfigured VCI.')
tsuPortErrL2UnconfigLastVci = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 3, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsuPortErrL2UnconfigLastVci.setStatus('mandatory')
if mibBuilder.loadTexts: tsuPortErrL2UnconfigLastVci.setDescription('The last 4-byte cell header associated with a Level 2 unconfigured VCI.')
tsuPortErrNonZeroGfc = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 3, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsuPortErrNonZeroGfc.setStatus('mandatory')
if mibBuilder.loadTexts: tsuPortErrNonZeroGfc.setDescription('For a UNI, the number of cells received with a non-zero GFC byte. No action taken aside from counting.')
fsuPortXmtCellsTable = MibTable((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 3, 3), )
if mibBuilder.loadTexts: fsuPortXmtCellsTable.setStatus('mandatory')
if mibBuilder.loadTexts: fsuPortXmtCellsTable.setDescription('Table of cells transmited by FSU to either a line-card chip or TLU, indexed by port and a drop priority subindex which represents the CLP and XCLP status of the cells. The priority index is tentatively defined as 2*CLP + XCLP + 1. Does not count cells dropped due to FSU buffer shortages or header LRC errors. Availability may depend on HW.')
fsuPortXmtCellsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 3, 3, 1), ).setIndexNames((0, "LIGHTSTREAM-MIB", "fsuXmtCellsPortIndex"), (0, "LIGHTSTREAM-MIB", "fsuXmtCellsPriorityIndex"))
if mibBuilder.loadTexts: fsuPortXmtCellsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fsuPortXmtCellsEntry.setDescription('An entry in the LC common FSU Port Xmt Cells Table.')
fsuXmtCellsPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 3, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fsuXmtCellsPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fsuXmtCellsPortIndex.setDescription('This is the ifIndex value of the corresponding ifEntry. See comments above.')
fsuXmtCellsPriorityIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 3, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fsuXmtCellsPriorityIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fsuXmtCellsPriorityIndex.setDescription('Index specifying the CLP and XCLP priority substream for the port. Index defined as 2*CLP + XCLP + 1.')
fsuXmtCellEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 3, 3, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fsuXmtCellEvents.setStatus('mandatory')
if mibBuilder.loadTexts: fsuXmtCellEvents.setDescription('Number of cells forwarded by the FSU towards the port indicated by the PortIndex, by the specified priority.')
fsuQueueCellLengthTable = MibTable((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 3, 4), )
if mibBuilder.loadTexts: fsuQueueCellLengthTable.setStatus('mandatory')
if mibBuilder.loadTexts: fsuQueueCellLengthTable.setDescription('Table of current queue lengths by port and subqueue as measured in cells.')
fsuQueueCellLenEntry = MibTableRow((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 3, 4, 1), ).setIndexNames((0, "LIGHTSTREAM-MIB", "fsuQueueCellLenPortIndex"), (0, "LIGHTSTREAM-MIB", "fsuQueueCellLenSubQIndex"))
if mibBuilder.loadTexts: fsuQueueCellLenEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fsuQueueCellLenEntry.setDescription('An entry in the FSU queue length table')
fsuQueueCellLenPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 3, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fsuQueueCellLenPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fsuQueueCellLenPortIndex.setDescription('This is the ifIndex value of the corresponding ifEntry. See comments above.')
fsuQueueCellLenSubQIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 3, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fsuQueueCellLenSubQIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fsuQueueCellLenSubQIndex.setDescription('Index specifying the subqueue for the port, where a lower queue number has a lower fsu priority.')
fsuQueueCellLength = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 3, 4, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fsuQueueCellLength.setStatus('mandatory')
if mibBuilder.loadTexts: fsuQueueCellLength.setDescription('Length of the specified queue in cell units. For ASIC Edge versions, this will include cells on the reassembly Queue for a port. For non-ASIC Edge versions, does not include reassembly Queue. Non-ASIC versions provide an estimate due to slow-side scanner logic, while ASIC versions provide direct counts.')
fsuDropEventTable = MibTable((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 3, 5), )
if mibBuilder.loadTexts: fsuDropEventTable.setStatus('mandatory')
if mibBuilder.loadTexts: fsuDropEventTable.setDescription('Table of drop events by FSU due to buffer shortage, by Port and drop watermark. This table may be limited in use to ASIC HW. For ASIC these are cell drops. For non-ASIC, might be messages instead of cells.')
fsuDropEventEntry = MibTableRow((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 3, 5, 1), ).setIndexNames((0, "LIGHTSTREAM-MIB", "fsuDropEventPortIndex"), (0, "LIGHTSTREAM-MIB", "fsuDropEventWatermarkIndex"))
if mibBuilder.loadTexts: fsuDropEventEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fsuDropEventEntry.setDescription('An entry in the FSU Port/Watermark drop event table')
fsuDropEventPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 3, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fsuDropEventPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fsuDropEventPortIndex.setDescription('This is the ifIndex value of the corresponding ifEntry. See comments above.')
fsuDropEventWatermarkIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 3, 5, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fsuDropEventWatermarkIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fsuDropEventWatermarkIndex.setDescription('Watermark associated with the drop count. The watermark selected is a function of the Fsu Priority, CLP and XCLP within port. We tentively define it to be (FSU-Priority)*4 + 2*CLP + XCLP+1. CLP and XCLP are 0/1 valued. At this time, there are eight Fsu priorities (treated as 0-7 in increasing priority), however these components cannot vary independently as currently used. Therefore, some entries will either not exist or will have a non-varying (default) count of zero.')
fsuDropEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 3, 5, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fsuDropEvents.setStatus('mandatory')
if mibBuilder.loadTexts: fsuDropEvents.setDescription('Count of the number drop events (cells or messages) dropped by the FSU due to low buffers, for the specified port and drop watermark.')
lsFsuFastDropTable = MibTable((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 3, 6), )
if mibBuilder.loadTexts: lsFsuFastDropTable.setStatus('mandatory')
if mibBuilder.loadTexts: lsFsuFastDropTable.setDescription('Table of cells dropped by FSU due to buffer shortage, by drop watermark, for cards using the fast-side drop mechanism. These statistics are not available for other cards.')
lsFsuFastDropEntry = MibTableRow((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 3, 6, 1), ).setIndexNames((0, "LIGHTSTREAM-MIB", "lsFsuFastDropWatermarkIndex"))
if mibBuilder.loadTexts: lsFsuFastDropEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lsFsuFastDropEntry.setDescription('An entry in the FSU fast-side per watermark drop table')
lsFsuFastDropWatermarkIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 3, 6, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("clp1", 1), ("clp0HiPriority", 2), ("clp0HiOther", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsFsuFastDropWatermarkIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lsFsuFastDropWatermarkIndex.setDescription('Watermark used for dropping with the fast-drop mechanism.')
lsFsuFastCellDropEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 3, 6, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsFsuFastCellDropEvents.setStatus('mandatory')
if mibBuilder.loadTexts: lsFsuFastCellDropEvents.setDescription('Count of the number cells dropped by FSU due to low buffers, for the specified watermark, using the fast-drop mechanism. These should be rare if the slow-side mechanism is functioning properly.')
tsuDropEventTable = MibTable((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 3, 7), )
if mibBuilder.loadTexts: tsuDropEventTable.setStatus('mandatory')
if mibBuilder.loadTexts: tsuDropEventTable.setDescription('Table of drop events by TSU due to buffer shortage, by Port and drop watermark. A drop event corresponds to a cell drop for ASIC cards. It may correspond to frame drops` on other cards.')
tsuDropEventEntry = MibTableRow((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 3, 7, 1), ).setIndexNames((0, "LIGHTSTREAM-MIB", "tsuDropEventPortIndex"), (0, "LIGHTSTREAM-MIB", "tsuDropEventWatermarkIndex"))
if mibBuilder.loadTexts: tsuDropEventEntry.setStatus('mandatory')
if mibBuilder.loadTexts: tsuDropEventEntry.setDescription('An entry in the Edge Port/Watermark TSU drop events table')
tsuDropEventPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 3, 7, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsuDropEventPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: tsuDropEventPortIndex.setDescription('This is the ifIndex value of the corresponding ifEntry. See comments above.')
tsuDropEventWatermarkIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 3, 7, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("user", 1), ("control", 2), ("scheduled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsuDropEventWatermarkIndex.setStatus('mandatory')
if mibBuilder.loadTexts: tsuDropEventWatermarkIndex.setDescription('Watermark associated with the drop count.')
tsuDropEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 3, 7, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsuDropEvents.setStatus('mandatory')
if mibBuilder.loadTexts: tsuDropEvents.setDescription('TSU drop events due to low buffers, for the specified port and drop watermark. For ASIC cards these are cell drops. For other cards the unit may be messages, depending on the card. These drops should be rare. They could be a byproduct of incorrect scheduled service setup.')
lsUtStatistics = MibIdentifier((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 4))
lsLcFsuIntervalTable = MibTable((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 4, 1), )
if mibBuilder.loadTexts: lsLcFsuIntervalTable.setStatus('mandatory')
if mibBuilder.loadTexts: lsLcFsuIntervalTable.setDescription('Table of sampled FSU queue depths and drop information, by outbound port (trunk and edge) where sampling occurs for queue depth is sampled once per second and data is aggregated into one minute buckets defined by the lsLcIntervalNumber.')
lsLcFsuIntervalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 4, 1, 1), ).setIndexNames((0, "LIGHTSTREAM-MIB", "lsLcIntervalPortIndex"), (0, "LIGHTSTREAM-MIB", "lsLcIntervalNumber"))
if mibBuilder.loadTexts: lsLcFsuIntervalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lsLcFsuIntervalEntry.setDescription('An entry in the LC FSU Interval table')
lsLcIntervalPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 4, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsLcIntervalPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lsLcIntervalPortIndex.setDescription('This is the ifIndex value of the corresponding ifEntry. See comments above. The port may be logical (e.g. terminated by a processor).')
lsLcIntervalNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsLcIntervalNumber.setStatus('mandatory')
if mibBuilder.loadTexts: lsLcIntervalNumber.setDescription('A number between 1 and 60, where 1 is the most recently completed 1 minute interval and 60 is the least recently completed one minute interval (assuming that all 60 intervals are valid). Currently only interval of 1 is supported')
lsLcIntervalPSDepth = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 4, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsLcIntervalPSDepth.setStatus('mandatory')
if mibBuilder.loadTexts: lsLcIntervalPSDepth.setDescription('Peak sampled queue depth for this outbound port, in cells, where queue depth is sampled once per second.')
lsLcIntervalASDepth = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 4, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsLcIntervalASDepth.setStatus('mandatory')
if mibBuilder.loadTexts: lsLcIntervalASDepth.setDescription('Average sampled queue depth for this outbound port, in cells, where queue depth is sampled once per second.')
lsLcIntervalDropEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 4, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsLcIntervalDropEvents.setStatus('mandatory')
if mibBuilder.loadTexts: lsLcIntervalDropEvents.setDescription('The Number of cell drop events encountered for this port during the specified interval. This provides the average cell loss ratio over the interval.')
lsLcIntervalAvgCells = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 4, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsLcIntervalAvgCells.setStatus('mandatory')
if mibBuilder.loadTexts: lsLcIntervalAvgCells.setDescription('The Number of cells transmitted for this port during the specified interval. This provides average utilization over the interval.')
lsLcIntervalPeakCells = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 4, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsLcIntervalPeakCells.setStatus('mandatory')
if mibBuilder.loadTexts: lsLcIntervalPeakCells.setDescription('The Peak Number of cells transmitted for this port during any one second measurement period within the specified interval. This provides peak one-second utilization information.')
lsLcIntervalMinPermits = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 4, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsLcIntervalMinPermits.setStatus('mandatory')
if mibBuilder.loadTexts: lsLcIntervalMinPermits.setDescription('The Minimum Permit value as sampled once per second during the specified interval.')
lsLcIntervalAvgPermits = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 4, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsLcIntervalAvgPermits.setStatus('mandatory')
if mibBuilder.loadTexts: lsLcIntervalAvgPermits.setDescription('The Average Permit value as sampled once per second during the specified interval.')
lsLcIntervalMaxPermits = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 4, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsLcIntervalMaxPermits.setStatus('mandatory')
if mibBuilder.loadTexts: lsLcIntervalMaxPermits.setDescription('The Maximum Permit value as sampled once per second during the specified interval.')
lsLcIntervalDecrPermits = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 4, 1, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsLcIntervalDecrPermits.setStatus('mandatory')
if mibBuilder.loadTexts: lsLcIntervalDecrPermits.setDescription('The Number of Permit decrease updates submitted during the current interval')
lsLcIntervalIncrPermits = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 4, 1, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsLcIntervalIncrPermits.setStatus('mandatory')
if mibBuilder.loadTexts: lsLcIntervalIncrPermits.setDescription('The Number of Permit increase updates submitted during the current interval')
lsLcIntervalMinBwAlloc = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 4, 1, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsLcIntervalMinBwAlloc.setStatus('mandatory')
if mibBuilder.loadTexts: lsLcIntervalMinBwAlloc.setDescription('The minimum BW allocation assessed during the current interval.')
lsLcIntervalAvgBwAlloc = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 4, 1, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsLcIntervalAvgBwAlloc.setStatus('mandatory')
if mibBuilder.loadTexts: lsLcIntervalAvgBwAlloc.setDescription('The minimum BW allocation assessed during the current interval.')
lsLcIntervalMaxBwAlloc = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 4, 1, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsLcIntervalMaxBwAlloc.setStatus('mandatory')
if mibBuilder.loadTexts: lsLcIntervalMaxBwAlloc.setDescription('The maximum BW allocation assessed during the current interval.')
lsNpStatistics = MibIdentifier((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 5))
lsNpCpuWorkloadTable = MibTable((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 5, 1), )
if mibBuilder.loadTexts: lsNpCpuWorkloadTable.setStatus('mandatory')
if mibBuilder.loadTexts: lsNpCpuWorkloadTable.setDescription('Network processor CPU specific workload statistics')
lsNpCpuWorkloadEntry = MibTableRow((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 5, 1, 1), ).setIndexNames((0, "LIGHTSTREAM-MIB", "lsNpCpuWorkloadIndex"))
if mibBuilder.loadTexts: lsNpCpuWorkloadEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lsNpCpuWorkloadEntry.setDescription('An entry in the Network Processor Statistics table.')
lsNpCpuWorkloadIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 5, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsNpCpuWorkloadIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lsNpCpuWorkloadIndex.setDescription('Np CPU Workload variable identifier')
lsNpCpuWorkloadEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 5, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsNpCpuWorkloadEvents.setStatus('mandatory')
if mibBuilder.loadTexts: lsNpCpuWorkloadEvents.setDescription('NP workload event count')
lsCellStatistics = MibIdentifier((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 6))
lsCellVciStatTable = MibTable((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 6, 1), )
if mibBuilder.loadTexts: lsCellVciStatTable.setStatus('mandatory')
if mibBuilder.loadTexts: lsCellVciStatTable.setDescription('Cell Port/VCI specific statistics subset information')
lsCellVciStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 6, 1, 1), ).setIndexNames((0, "LIGHTSTREAM-MIB", "cellVciStatPortIndex"), (0, "LIGHTSTREAM-MIB", "cellVciStatVciIndex"))
if mibBuilder.loadTexts: lsCellVciStatEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lsCellVciStatEntry.setDescription('An entry in the cell Port/Vci Statistics Table.')
cellVciStatPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 6, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cellVciStatPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cellVciStatPortIndex.setDescription('This is the ifIndex value of the corresponding ifEntry. See comments above.')
cellVciStatVciIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 6, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cellVciStatVciIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cellVciStatVciIndex.setDescription('Unique Vci identifier for indicated VC')
cellVciToSwCLP0Cells = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 6, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cellVciToSwCLP0Cells.setStatus('mandatory')
if mibBuilder.loadTexts: cellVciToSwCLP0Cells.setDescription('Number of Cells forwarded to TSU with CLP=0')
cellVciToSwCLP01Cells = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 6, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cellVciToSwCLP01Cells.setStatus('mandatory')
if mibBuilder.loadTexts: cellVciToSwCLP01Cells.setDescription('Number of Cells forwarded to TSU with CLP=1, which arrived at port as CLP=0.')
cellVciToSwCLP1Cells = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 6, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cellVciToSwCLP1Cells.setStatus('mandatory')
if mibBuilder.loadTexts: cellVciToSwCLP1Cells.setDescription('Number of Cells forwarded to TSU with CLP=1')
cellVciToSwDiscardCells = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 11, 1, 6, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cellVciToSwDiscardCells.setStatus('mandatory')
if mibBuilder.loadTexts: cellVciToSwDiscardCells.setDescription('Number of to-switch Cells discarded due to excessive traffic according to the Usage Parameter Descriptor for this Vci')
lsIR = MibIdentifier((1, 3, 6, 1, 4, 1, 711, 2, 1, 12))
irRoutingGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 711, 2, 1, 12, 1))
irRoutingPathsGenerated = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 12, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: irRoutingPathsGenerated.setStatus('mandatory')
if mibBuilder.loadTexts: irRoutingPathsGenerated.setDescription('The number of path generation operations performed since initialization.')
irRoutingPathGenSuccess = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 12, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: irRoutingPathGenSuccess.setStatus('mandatory')
if mibBuilder.loadTexts: irRoutingPathGenSuccess.setDescription('The number of path generation operations successfully performed since initialization.')
irRoutingPathGenFailedNoResources = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 12, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: irRoutingPathGenFailedNoResources.setStatus('mandatory')
if mibBuilder.loadTexts: irRoutingPathGenFailedNoResources.setDescription('The number of path generation operations which have failed due to lack of network resources.')
irRoutingPathGenFailedUnknown = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 12, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: irRoutingPathGenFailedUnknown.setStatus('mandatory')
if mibBuilder.loadTexts: irRoutingPathGenFailedUnknown.setDescription('The number of path generation operations which have failed because a specified port or chassis was unknown.')
irRoutingPathGenFailedOther = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 12, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: irRoutingPathGenFailedOther.setStatus('mandatory')
if mibBuilder.loadTexts: irRoutingPathGenFailedOther.setDescription('The number of path generation operations which have failed for reasons other than unknown chassis/port or lack of network resources.')
irRoutingAveragePathLength = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 12, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: irRoutingAveragePathLength.setStatus('mandatory')
if mibBuilder.loadTexts: irRoutingAveragePathLength.setDescription('The average length (in ports) of all paths generated since initialization.')
lsStatistics = MibIdentifier((1, 3, 6, 1, 4, 1, 711, 2, 1, 13))
tcsInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 711, 2, 1, 14))
tcsTable = MibTable((1, 3, 6, 1, 4, 1, 711, 2, 1, 14, 1), )
if mibBuilder.loadTexts: tcsTable.setStatus('mandatory')
if mibBuilder.loadTexts: tcsTable.setDescription('TCS Slave specific information')
tcsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 711, 2, 1, 14, 1, 1), ).setIndexNames((0, "LIGHTSTREAM-MIB", "tcsIndex"))
if mibBuilder.loadTexts: tcsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: tcsEntry.setDescription('An entry in the tcs table ordered by slot. (1-n)')
tcsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 14, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: tcsIndex.setDescription('Unique Index consisting of slot number.')
tcsTemp1 = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 14, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcsTemp1.setStatus('mandatory')
if mibBuilder.loadTexts: tcsTemp1.setDescription('Temperature 1 detected by TCS.')
tcsTemp2 = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 14, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcsTemp2.setStatus('mandatory')
if mibBuilder.loadTexts: tcsTemp2.setDescription('Temperature 2 detected by TCS.')
tcsTcsVoltage = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 14, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcsTcsVoltage.setStatus('mandatory')
if mibBuilder.loadTexts: tcsTcsVoltage.setDescription('Voltage detected by TCS.')
tcsVccVoltage = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 14, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcsVccVoltage.setStatus('mandatory')
if mibBuilder.loadTexts: tcsVccVoltage.setDescription('VCC Voltage detected by TCS.')
tcsScsiVoltage = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 14, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcsScsiVoltage.setStatus('mandatory')
if mibBuilder.loadTexts: tcsScsiVoltage.setDescription('SCSI Voltage (or Bulk for switches) detected by TCS.')
tcsPostResult = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 14, 1, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcsPostResult.setStatus('mandatory')
if mibBuilder.loadTexts: tcsPostResult.setDescription('POST result of card.')
tcsCardType = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 14, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 12, 13, 14, 15, 30, 31, 32, 33, 34, 35, 36, 37, 70))).clone(namedValues=NamedValues(("empty", 1), ("error", 2), ("unknown", 3), ("switch", 4), ("np", 5), ("lsEdge", 6), ("lsTrunk", 7), ("msTrunk", 8), ("msEdge", 10), ("plc12fac1", 11), ("plc18eac1", 12), ("plc1Lstoken", 13), ("plc18sac1Edge", 14), ("plc18sac1Trunk", 15), ("clc1Gen", 30), ("clc12oc3ac1Edge", 31), ("clc12oc3ac1Trunk", 32), ("clc18t3ac1Edge", 33), ("clc18t3ac1Trunk", 34), ("clc12taxiac1Edge", 35), ("clc12taxiac1Trunk", 36), ("clc18t1e1cbrac1", 37), ("switch2", 70)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcsCardType.setStatus('mandatory')
if mibBuilder.loadTexts: tcsCardType.setDescription('Card type.')
tcsPaddleTemp1 = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 14, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcsPaddleTemp1.setStatus('mandatory')
if mibBuilder.loadTexts: tcsPaddleTemp1.setDescription('Paddle card temperature 1 detected by TCS.')
tcsPaddleTemp2 = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 14, 1, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcsPaddleTemp2.setStatus('mandatory')
if mibBuilder.loadTexts: tcsPaddleTemp2.setDescription('Paddle card temperature 2 detected by TCS.')
tcsPaddleWarnTemp1 = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 14, 1, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcsPaddleWarnTemp1.setStatus('mandatory')
if mibBuilder.loadTexts: tcsPaddleWarnTemp1.setDescription('Paddle card warning temperature 1 maintained by TCS.')
tcsPaddleWarnTemp2 = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 14, 1, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcsPaddleWarnTemp2.setStatus('mandatory')
if mibBuilder.loadTexts: tcsPaddleWarnTemp2.setDescription('Paddle card warning temperature 2 maintained by TCS.')
tcsPaddleShutdownTemp1 = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 14, 1, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcsPaddleShutdownTemp1.setStatus('mandatory')
if mibBuilder.loadTexts: tcsPaddleShutdownTemp1.setDescription('Warning temperature 1 at which the paddle card will shut down.')
tcsPaddleShutdownTemp2 = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 14, 1, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcsPaddleShutdownTemp2.setStatus('mandatory')
if mibBuilder.loadTexts: tcsPaddleShutdownTemp2.setDescription('Warning temperature 2 at which the paddle card will shut down.')
tcsWarnTemp1 = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 14, 1, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcsWarnTemp1.setStatus('mandatory')
if mibBuilder.loadTexts: tcsWarnTemp1.setDescription('Warning temperature 1 maintained by TCS.')
tcsWarnTemp2 = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 14, 1, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcsWarnTemp2.setStatus('mandatory')
if mibBuilder.loadTexts: tcsWarnTemp2.setDescription('Warning temperature 2 maintained by TCS.')
tcsShutdownTemp1 = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 14, 1, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcsShutdownTemp1.setStatus('mandatory')
if mibBuilder.loadTexts: tcsShutdownTemp1.setDescription('Warning temperature 2 at which the card will shut down.')
tcsShutdownTemp2 = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 14, 1, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcsShutdownTemp2.setStatus('mandatory')
if mibBuilder.loadTexts: tcsShutdownTemp2.setDescription('Warning temperature 2 at which the card will shut down.')
tcsFaultLight = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 14, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcsFaultLight.setStatus('mandatory')
if mibBuilder.loadTexts: tcsFaultLight.setDescription('The state of the fault light.')
tcsReadyLight = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 14, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcsReadyLight.setStatus('mandatory')
if mibBuilder.loadTexts: tcsReadyLight.setDescription('The state of the ready light')
tcsSwitchConnectivityMask = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 14, 1, 1, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcsSwitchConnectivityMask.setStatus('mandatory')
if mibBuilder.loadTexts: tcsSwitchConnectivityMask.setDescription('Bitmask of cards with which this function card communicates via the switch. Bit 0 is the least-significant bit. Bit 1 represents slot 1, bit 2 represents slot 2 and so on.')
tcsPrimarySwitch = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 14, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("switchA", 1), ("switchB", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tcsPrimarySwitch.setStatus('mandatory')
if mibBuilder.loadTexts: tcsPrimarySwitch.setDescription("Primary Switch. When 'read' provides the current primary switch. When 'written' attempts to make the written value the new switch.")
tcsPowerSupplyA = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 14, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("empty", 1), ("failed", 2), ("good", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcsPowerSupplyA.setStatus('mandatory')
if mibBuilder.loadTexts: tcsPowerSupplyA.setDescription('Status of power supply A.')
tcsPowerSupplyB = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 14, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("empty", 1), ("failed", 2), ("good", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcsPowerSupplyB.setStatus('mandatory')
if mibBuilder.loadTexts: tcsPowerSupplyB.setDescription('Status of power supply B.')
tcsPowerSupplyTypeA = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 14, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("empty", 1), ("dcPowerTray", 2), ("toddPS", 3), ("unknown", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcsPowerSupplyTypeA.setStatus('mandatory')
if mibBuilder.loadTexts: tcsPowerSupplyTypeA.setDescription('Type of power supply A.')
tcsPowerSupplyTypeB = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 14, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("empty", 1), ("dcPowerTray", 2), ("toddPS", 3), ("unknown", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcsPowerSupplyTypeB.setStatus('mandatory')
if mibBuilder.loadTexts: tcsPowerSupplyTypeB.setDescription('Type of power supply A.')
tcsSwitchFaultMaskA = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 14, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcsSwitchFaultMaskA.setStatus('mandatory')
if mibBuilder.loadTexts: tcsSwitchFaultMaskA.setDescription("Bitmask of slots reporting unhealthy clocks. If the corresponding bit is set, switch card A's clock is viewed as unhealthy by the function card in that slot. In addition, it indicates whether or not the entire switch card has been marked as usable or unusable. Bit 1 represents clock health for slot 1, bit 2 represents slot 2 and so on. Bit 0 is the least-significant bit. Bit 0 represents the dont-use bit for switch A. If bit 0 is set, it indicates that TCS has marked switch A as dont-use.")
tcsSwitchFaultMaskB = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 14, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcsSwitchFaultMaskB.setStatus('mandatory')
if mibBuilder.loadTexts: tcsSwitchFaultMaskB.setDescription("Bitmask of slots reporting unhealthy clocks. If the corresponding bit is set, switch card B's clock is viewed as unhealthy by the function card in that slot. In addition, it indicates whether or not the entire switch card has been marked as usable or unusable. Bit 1 represents clock health for slot 1, bit 2 represents slot 2 and so on. Bit 0 is the least-significant bit. Bit 0 represents the dont-use bit for switch B. If bit 0 is set, it indicates that TCS has marked switch B as dont-use.")
tcsSwitchCutoverSupport = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 14, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("willDoLossLess", 1), ("wontDoLossLess", 2), ("cantDoLossLess", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcsSwitchCutoverSupport.setStatus('mandatory')
if mibBuilder.loadTexts: tcsSwitchCutoverSupport.setDescription("willDoLossLess indicates that there are two SC2's that are in synch. wontDoLossLess indicates that there are two SC2's that are NOT in sync. cantDoLossLess indicates any other situation (1-SC1/SC2, 2-SC1's).")
tcsFCPrimarySwitchA = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 14, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcsFCPrimarySwitchA.setStatus('mandatory')
if mibBuilder.loadTexts: tcsFCPrimarySwitchA.setDescription('The bit corresponding to that slot is a 1 if the card believes that Switch A is the primary switch and 0 otherwise. Bit 0 is the least-significant bit. Bit 1 represents slot 1, bit 2 represents slot 2 and so on.')
tcsFCPrimarySwitchB = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 14, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcsFCPrimarySwitchB.setStatus('mandatory')
if mibBuilder.loadTexts: tcsFCPrimarySwitchB.setDescription('The bit corresponding to that slot is a 1 if the card believes that Switch B is the primary switch and 0 otherwise. Bit 0 is the least-significant bit. Bit 1 represents slot 1, bit 2 represents slot 2 and so on.')
lsGID = MibIdentifier((1, 3, 6, 1, 4, 1, 711, 2, 1, 15))
gidGeneralGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 1))
gidSoftwareVersionNumber = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 1, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gidSoftwareVersionNumber.setStatus('mandatory')
if mibBuilder.loadTexts: gidSoftwareVersionNumber.setDescription('The global information distribution (GID) process software revision number')
gidProcessID = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gidProcessID.setStatus('mandatory')
if mibBuilder.loadTexts: gidProcessID.setDescription('The GID process ID.')
gidUpTime = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gidUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: gidUpTime.setDescription('The number of seconds the GID process has been running.')
gidMemoryUse = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gidMemoryUse.setStatus('mandatory')
if mibBuilder.loadTexts: gidMemoryUse.setDescription('The total amount of memory (in bytes) currently allocated by GID for all purposes.')
gidTimersProcessed = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gidTimersProcessed.setStatus('mandatory')
if mibBuilder.loadTexts: gidTimersProcessed.setDescription('The number of timers processed by the GID process since initialization.')
gidMallocFailures = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gidMallocFailures.setStatus('mandatory')
if mibBuilder.loadTexts: gidMallocFailures.setDescription('The number of times GID has failed to dynamically allocate memory since initialization.')
gidDebugFlag = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gidDebugFlag.setStatus('mandatory')
if mibBuilder.loadTexts: gidDebugFlag.setDescription('Bit mask for debug statements to AppLog. This is being used for debug purposes. It is not advised that the user change this. Future releases may move this to a debug subtree.')
gidDebugLevel = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gidDebugLevel.setStatus('mandatory')
if mibBuilder.loadTexts: gidDebugLevel.setDescription('The gidDebugLevel determines the amount of detail that the debug flags will cause to dump to the apps.log, where 0 means no detail and 3 is the maximum value Future releases may move this to a debug subtree.')
gidAcceptedBcastRateIn = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gidAcceptedBcastRateIn.setStatus('mandatory')
if mibBuilder.loadTexts: gidAcceptedBcastRateIn.setDescription('The LAN inbound broadcast traffic average inter-frame time specified in microseconds. The default rate is 20,000 microseconds. Defines the acceptable average inbound bcast rate. Future releases may move this to another subtree.')
gidNbrGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 2))
gidNbrCount = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 2, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gidNbrCount.setStatus('mandatory')
if mibBuilder.loadTexts: gidNbrCount.setDescription('The number of neighbor NPs known to the GID process.')
gidNbrTable = MibTable((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 2, 2), )
if mibBuilder.loadTexts: gidNbrTable.setStatus('mandatory')
if mibBuilder.loadTexts: gidNbrTable.setDescription('A table containing information about each GID neighbor.')
gidNbrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 2, 2, 1), ).setIndexNames((0, "LIGHTSTREAM-MIB", "gidNbrEIA"))
if mibBuilder.loadTexts: gidNbrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gidNbrEntry.setDescription('The information regarding a single GID neighbor.')
gidNbrEIA = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gidNbrEIA.setStatus('mandatory')
if mibBuilder.loadTexts: gidNbrEIA.setDescription('The internal address of the neighbor NP.')
gidNbrVCI = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 2, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gidNbrVCI.setStatus('mandatory')
if mibBuilder.loadTexts: gidNbrVCI.setDescription('The VCI of the reliable channel to the neighbor.')
gidNbrState = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("unknown", 1), ("existent", 2), ("exstart", 3), ("exchange", 4), ("loading", 5), ("full", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gidNbrState.setStatus('mandatory')
if mibBuilder.loadTexts: gidNbrState.setDescription("The neighbor's synchronization protocol state.")
gidNbrSyncEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 2, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gidNbrSyncEvents.setStatus('mandatory')
if mibBuilder.loadTexts: gidNbrSyncEvents.setDescription('The number of synchronization protocol events associated with this neighbor that have occurred since initialization.')
gidNbrDBReqListLength = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 2, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gidNbrDBReqListLength.setStatus('mandatory')
if mibBuilder.loadTexts: gidNbrDBReqListLength.setDescription('The number of database requests queued to the neighbor.')
gidNbrDBSumListLength = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 2, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gidNbrDBSumListLength.setStatus('mandatory')
if mibBuilder.loadTexts: gidNbrDBSumListLength.setDescription('The number of database summary list entries queued for transmission to the neighbor.')
gidNbrHellosRx = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 2, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gidNbrHellosRx.setStatus('mandatory')
if mibBuilder.loadTexts: gidNbrHellosRx.setDescription('The number of Hello packets received from the neighbor.')
gidNbrLinkAnnouncementsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 2, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gidNbrLinkAnnouncementsRx.setStatus('mandatory')
if mibBuilder.loadTexts: gidNbrLinkAnnouncementsRx.setDescription('The number of link state announcements received from the neighbor.')
gidNbrNewLinkAnnouncementsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 2, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gidNbrNewLinkAnnouncementsRx.setStatus('mandatory')
if mibBuilder.loadTexts: gidNbrNewLinkAnnouncementsRx.setDescription('The number of link state announcements received from the neighbor and accepted as new.')
gidNbrIPAnnouncementsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 2, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gidNbrIPAnnouncementsRx.setStatus('mandatory')
if mibBuilder.loadTexts: gidNbrIPAnnouncementsRx.setDescription('The number of internal IP address translation announcements received from the neighbor.')
gidNbrNewIPAnnouncementsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 2, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gidNbrNewIPAnnouncementsRx.setStatus('mandatory')
if mibBuilder.loadTexts: gidNbrNewIPAnnouncementsRx.setDescription('The number of internal IP address translation announcements received from the neighbor and accepted as new.')
gidNbrGenericAnnouncementsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 2, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gidNbrGenericAnnouncementsRx.setStatus('mandatory')
if mibBuilder.loadTexts: gidNbrGenericAnnouncementsRx.setDescription('The number of generic global information announcements received from the neighbor.')
gidNbrNewGenericAnnouncementsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 2, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gidNbrNewGenericAnnouncementsRx.setStatus('mandatory')
if mibBuilder.loadTexts: gidNbrNewGenericAnnouncementsRx.setDescription('The number of generic global information announcements received from the neighbor and accepted as new.')
gidClientGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 3))
gidClientCount = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 3, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gidClientCount.setStatus('mandatory')
if mibBuilder.loadTexts: gidClientCount.setDescription('The number of registered GID client processes.')
gidClientTable = MibTable((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 3, 2), )
if mibBuilder.loadTexts: gidClientTable.setStatus('mandatory')
if mibBuilder.loadTexts: gidClientTable.setDescription('A table containing information about each GID client process.')
gidClientEntry = MibTableRow((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 3, 2, 1), ).setIndexNames((0, "LIGHTSTREAM-MIB", "gidClientID"))
if mibBuilder.loadTexts: gidClientEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gidClientEntry.setDescription('The information regarding a single GID client process.')
gidClientID = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gidClientID.setStatus('mandatory')
if mibBuilder.loadTexts: gidClientID.setDescription('The GID client process identifier.')
gidClientEIA = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 3, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gidClientEIA.setStatus('mandatory')
if mibBuilder.loadTexts: gidClientEIA.setDescription('The internal card address associated with the GID client process. Edge and trunk card control processes are associated with a unique card address. The NP card control process and the Congestion Avoidance information distribution process share the internal card address of the local NP.')
gidClientAnnouncementsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 3, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gidClientAnnouncementsRx.setStatus('mandatory')
if mibBuilder.loadTexts: gidClientAnnouncementsRx.setDescription('The total number of global information announcements received from this GID client process since initialization.')
gidClientLinkAnnouncementsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 3, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gidClientLinkAnnouncementsRx.setStatus('mandatory')
if mibBuilder.loadTexts: gidClientLinkAnnouncementsRx.setDescription('The number of link state information announcements received from this GID client process since initialization.')
gidClientIPAnnouncementsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 3, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gidClientIPAnnouncementsRx.setStatus('mandatory')
if mibBuilder.loadTexts: gidClientIPAnnouncementsRx.setDescription('The number of internal IP address translation announcements received from this GID client process since initialization.')
gidClientGenericAnnouncementsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 3, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gidClientGenericAnnouncementsRx.setStatus('mandatory')
if mibBuilder.loadTexts: gidClientGenericAnnouncementsRx.setDescription('The number of generic global information announcements received from this GID client process since initialization.')
gidClientEventsTx = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 3, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gidClientEventsTx.setStatus('mandatory')
if mibBuilder.loadTexts: gidClientEventsTx.setDescription('The number of global information-related events sent by the GID process to the GID client process since initialization.')
gidClientPathsGenerated = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 3, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gidClientPathsGenerated.setStatus('mandatory')
if mibBuilder.loadTexts: gidClientPathsGenerated.setDescription('The number of path generation requests made by the GID client process since initialization.')
gidIOGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 4))
gidIONbrMsgBuffersFree = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 4, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gidIONbrMsgBuffersFree.setStatus('mandatory')
if mibBuilder.loadTexts: gidIONbrMsgBuffersFree.setDescription('The number of neighbor message buffers available on the neighbor message buffer free list.')
gidIONbrMsgBuffersActive = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 4, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gidIONbrMsgBuffersActive.setStatus('mandatory')
if mibBuilder.loadTexts: gidIONbrMsgBuffersActive.setDescription('The number of neighbor message buffers currently active, either in transmission or queued for output.')
gidIOClientMsgBuffersFree = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 4, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gidIOClientMsgBuffersFree.setStatus('mandatory')
if mibBuilder.loadTexts: gidIOClientMsgBuffersFree.setDescription('The number of client message buffers available on the client message buffer free list.')
gidIOClientMsgBuffersActive = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 4, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gidIOClientMsgBuffersActive.setStatus('mandatory')
if mibBuilder.loadTexts: gidIOClientMsgBuffersActive.setDescription('The number of client message buffers currently active, either in transmission or queued for output.')
gidSyncGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 6))
gidSyncNbrsExistent = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 6, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gidSyncNbrsExistent.setStatus('mandatory')
if mibBuilder.loadTexts: gidSyncNbrsExistent.setDescription('The number of neighbors in the Existent synchronization protocol state.')
gidSyncNbrsExStart = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 6, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gidSyncNbrsExStart.setStatus('mandatory')
if mibBuilder.loadTexts: gidSyncNbrsExStart.setDescription('The number of neighbors in the Exchange Start synchronization protocol state.')
gidSyncNbrsExchange = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 6, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gidSyncNbrsExchange.setStatus('mandatory')
if mibBuilder.loadTexts: gidSyncNbrsExchange.setDescription('The number of neighbors in the Exchange synchronization protocol state.')
gidSyncNbrsLoading = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 6, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gidSyncNbrsLoading.setStatus('mandatory')
if mibBuilder.loadTexts: gidSyncNbrsLoading.setDescription('The number of neighbors in the Loading synchronization protocol state.')
gidSyncNbrsFull = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 6, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gidSyncNbrsFull.setStatus('mandatory')
if mibBuilder.loadTexts: gidSyncNbrsFull.setDescription('The number of neighbors in the Full synchronization protocol state.')
gidLinkGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 7))
gidLinkDatabaseSize = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 7, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gidLinkDatabaseSize.setStatus('mandatory')
if mibBuilder.loadTexts: gidLinkDatabaseSize.setDescription('The current size of the link state database, in bytes.')
gidLineCardTable = MibTable((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 7, 2), )
if mibBuilder.loadTexts: gidLineCardTable.setStatus('mandatory')
if mibBuilder.loadTexts: gidLineCardTable.setDescription('A table containing information about each line card known to GID.')
gidLineCardEntry = MibTableRow((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 7, 2, 1), ).setIndexNames((0, "LIGHTSTREAM-MIB", "gidLineCardChassis"), (0, "LIGHTSTREAM-MIB", "gidLineCardSlot"))
if mibBuilder.loadTexts: gidLineCardEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gidLineCardEntry.setDescription('The information regarding a single line card.')
gidLineCardChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 7, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gidLineCardChassis.setStatus('mandatory')
if mibBuilder.loadTexts: gidLineCardChassis.setDescription('The internal chassis ID of the chassis which contains the line card described by the link state entry.')
gidLineCardSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 7, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gidLineCardSlot.setStatus('mandatory')
if mibBuilder.loadTexts: gidLineCardSlot.setDescription('The slot in the chassis which contains the line card described by the link state entry.')
gidLineCardEntryAge = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 7, 2, 1, 3), LightStreamUpToMaxAge()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gidLineCardEntryAge.setStatus('mandatory')
if mibBuilder.loadTexts: gidLineCardEntryAge.setDescription('The time, in seconds, that have elapsed since the link state advertisement was originated. The link state advertisement will be purged from the global database when the age reaches MaxAge (1 hour).')
gidLineCardEntrySeqno = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 7, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gidLineCardEntrySeqno.setStatus('mandatory')
if mibBuilder.loadTexts: gidLineCardEntrySeqno.setDescription('The flooding protocol sequence number currently associated with the link state advertisement. The sequence number is a signed 32-bit integer. It is used to detect old and duplicate database announcements. The sequence number space is linearly ordered; the larger the sequence number, the more recent the database announcement.')
gidLineCardEntryAdvNP = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 7, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gidLineCardEntryAdvNP.setStatus('mandatory')
if mibBuilder.loadTexts: gidLineCardEntryAdvNP.setDescription('The internal card ID of the Network Processor which originated the IP address translation.')
gidLineCardPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 7, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gidLineCardPorts.setStatus('mandatory')
if mibBuilder.loadTexts: gidLineCardPorts.setDescription('The number of edge and/or trunk ports attached to the line card. Network processor cards may be advertised as having 0 ports.')
gidPortTable = MibTable((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 7, 3), )
if mibBuilder.loadTexts: gidPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: gidPortTable.setDescription('A table containing information about each network link known to GID. A point-to-point link is represented by two entries in the GID link state database, one for each direction of data transmission.')
gidPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 7, 3, 1), ).setIndexNames((0, "LIGHTSTREAM-MIB", "gidPortChassis"), (0, "LIGHTSTREAM-MIB", "gidPortID"))
if mibBuilder.loadTexts: gidPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gidPortEntry.setDescription('The information regarding a single network link.')
gidPortChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 7, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gidPortChassis.setStatus('mandatory')
if mibBuilder.loadTexts: gidPortChassis.setDescription('The internal chassis ID of the chassis which contains the line card associated with the port.')
gidPortID = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 7, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gidPortID.setStatus('mandatory')
if mibBuilder.loadTexts: gidPortID.setDescription('This is the ifIndex value of the corresponding ifEntry. See comments above.')
gidPortService = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 7, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("trunk", 1), ("edge", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gidPortService.setStatus('mandatory')
if mibBuilder.loadTexts: gidPortService.setDescription('The operating mode (trunk or edge) of the port.')
gidPortUpDown = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 7, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("down", 1), ("up", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gidPortUpDown.setStatus('mandatory')
if mibBuilder.loadTexts: gidPortUpDown.setDescription('The up/down state of the port.')
gidPortBW0 = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 7, 3, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gidPortBW0.setStatus('mandatory')
if mibBuilder.loadTexts: gidPortBW0.setDescription('The amount of type 0 bandwidth available for reservation for data transmission through the port.')
gidPortBW1 = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 7, 3, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gidPortBW1.setStatus('mandatory')
if mibBuilder.loadTexts: gidPortBW1.setDescription('The amount of type 1 bandwidth available for reservation for data transmission through the port.')
gidPortBW2 = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 7, 3, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gidPortBW2.setStatus('mandatory')
if mibBuilder.loadTexts: gidPortBW2.setDescription('The amount of type 2 bandwidth available for reservation for data transmission through the port.')
gidPortRemoteChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 7, 3, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gidPortRemoteChassis.setStatus('mandatory')
if mibBuilder.loadTexts: gidPortRemoteChassis.setDescription('The internal chassis ID of the chassis which contains the line card and port at the remote end of the point-to-point link.')
gidPortRemotePort = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 7, 3, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gidPortRemotePort.setStatus('mandatory')
if mibBuilder.loadTexts: gidPortRemotePort.setDescription('This is the ifIndex value of the corresponding ifEntry. See comments above.')
gidIpAddressGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 8))
gidIpAddressDatabaseSize = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 8, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gidIpAddressDatabaseSize.setStatus('mandatory')
if mibBuilder.loadTexts: gidIpAddressDatabaseSize.setDescription('The current size of the address translation database, in bytes.')
gidIpAddressTable = MibTable((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 8, 2), )
if mibBuilder.loadTexts: gidIpAddressTable.setStatus('mandatory')
if mibBuilder.loadTexts: gidIpAddressTable.setDescription('A table containing information about each internal IP address translation known to GID.')
gidIpAddressEntry = MibTableRow((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 8, 2, 1), ).setIndexNames((0, "LIGHTSTREAM-MIB", "gidInternalIpAddress"))
if mibBuilder.loadTexts: gidIpAddressEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gidIpAddressEntry.setDescription('The information regarding a single internal IP address translation.')
gidInternalIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 8, 2, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gidInternalIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: gidInternalIpAddress.setDescription('The internal IP address associated with the IP address translation instance.')
gidIpEntryAge = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 8, 2, 1, 2), LightStreamUpToMaxAge()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gidIpEntryAge.setStatus('mandatory')
if mibBuilder.loadTexts: gidIpEntryAge.setDescription('The time, in seconds, that have elapsed since the IP address translation was originated. The address translation will be purged from the global database when the age reaches MaxAge (1 hour).')
gidIpEntrySeqno = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 8, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gidIpEntrySeqno.setStatus('mandatory')
if mibBuilder.loadTexts: gidIpEntrySeqno.setDescription('The flooding protocol sequence number currently associated with the IP address translation. The sequence number is a signed 32-bit integer. It is used to detect old and duplicate database announcements. The sequence number space is linearly ordered; the larger the sequence number, the more recent the database announcement.')
gidIpEntryAdvNP = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 8, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gidIpEntryAdvNP.setStatus('mandatory')
if mibBuilder.loadTexts: gidIpEntryAdvNP.setDescription('The internal card ID of the Network Processor which originated the IP address translation.')
gidIpEntryNetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 8, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gidIpEntryNetMask.setStatus('mandatory')
if mibBuilder.loadTexts: gidIpEntryNetMask.setDescription('The IP network mask associated with the IP address translation.')
gidIpEntryEIA = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 8, 2, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: gidIpEntryEIA.setStatus('mandatory')
if mibBuilder.loadTexts: gidIpEntryEIA.setDescription('The internal address of the network port associated with the IP address translation.')
gidEventGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 9))
gidEventLinkEventsDelivered = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 9, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gidEventLinkEventsDelivered.setStatus('mandatory')
if mibBuilder.loadTexts: gidEventLinkEventsDelivered.setDescription('The number of link events delivered by GID since initialization.')
gidEventIpEventsDelivered = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 9, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gidEventIpEventsDelivered.setStatus('mandatory')
if mibBuilder.loadTexts: gidEventIpEventsDelivered.setDescription('The number of internal IP events delivered by GID since initialization.')
gidEventGenericGinfoEventsDelivered = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 9, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gidEventGenericGinfoEventsDelivered.setStatus('mandatory')
if mibBuilder.loadTexts: gidEventGenericGinfoEventsDelivered.setDescription('The number of generic global information events delivered by GID since initialization.')
gidEventGenericGinfoEventTable = MibTable((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 9, 4), )
if mibBuilder.loadTexts: gidEventGenericGinfoEventTable.setStatus('mandatory')
if mibBuilder.loadTexts: gidEventGenericGinfoEventTable.setDescription('A table containing the number of generic global information events transmitted by GID since initialization. The table is indexed by distribution group.')
gidEventGenericGinfoEventCount = MibTableRow((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 9, 4, 1), ).setIndexNames((0, "LIGHTSTREAM-MIB", "gidEventDistributionGroup"))
if mibBuilder.loadTexts: gidEventGenericGinfoEventCount.setStatus('mandatory')
if mibBuilder.loadTexts: gidEventGenericGinfoEventCount.setDescription('The number of generic global information events delivered to clients in this distribution group.')
gidEventDistributionGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 9, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gidEventDistributionGroup.setStatus('mandatory')
if mibBuilder.loadTexts: gidEventDistributionGroup.setDescription('The flooding protocol distribution group to which the events were delivered.')
gidEventGenericGinfoEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 15, 9, 4, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gidEventGenericGinfoEvents.setStatus('mandatory')
if mibBuilder.loadTexts: gidEventGenericGinfoEvents.setDescription('The number of events delivered to clients in the distribution group.')
lsPID = MibIdentifier((1, 3, 6, 1, 4, 1, 711, 2, 1, 16))
pidTable = MibTable((1, 3, 6, 1, 4, 1, 711, 2, 1, 16, 1), )
if mibBuilder.loadTexts: pidTable.setStatus('mandatory')
if mibBuilder.loadTexts: pidTable.setDescription('PID table of current pids')
pidEntry = MibTableRow((1, 3, 6, 1, 4, 1, 711, 2, 1, 16, 1, 1), ).setIndexNames((0, "LIGHTSTREAM-MIB", "pidIndex"))
if mibBuilder.loadTexts: pidEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pidEntry.setDescription('An entry in the PPID table.')
pidIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 16, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pidIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pidIndex.setDescription('Unique Index consisting of PID number.')
pidName = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 16, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pidName.setStatus('mandatory')
if mibBuilder.loadTexts: pidName.setDescription('Process Name.')
pidCreationTime = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 16, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pidCreationTime.setStatus('mandatory')
if mibBuilder.loadTexts: pidCreationTime.setDescription('Time since process creation in seconds.')
pidOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 16, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pidOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: pidOperStatus.setDescription('Operation Status of process.')
pidAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 16, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pidAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: pidAdminStatus.setDescription('Administratively desired state of process.')
lsND = MibIdentifier((1, 3, 6, 1, 4, 1, 711, 2, 1, 17))
ndGeneralGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 711, 2, 1, 17, 1))
ndSoftwareVersionNumber = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 17, 1, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndSoftwareVersionNumber.setStatus('mandatory')
if mibBuilder.loadTexts: ndSoftwareVersionNumber.setDescription('The neighborhood discovery (ND) process software revision number')
ndProcessID = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 17, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndProcessID.setStatus('mandatory')
if mibBuilder.loadTexts: ndProcessID.setDescription('The ND process ID.')
ndMemoryUse = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 17, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndMemoryUse.setStatus('mandatory')
if mibBuilder.loadTexts: ndMemoryUse.setDescription('The total amount of dynamically allocated memory (in bytes) currently allocated by the ND process for all purposes.')
ndTimersProcessed = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 17, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndTimersProcessed.setStatus('mandatory')
if mibBuilder.loadTexts: ndTimersProcessed.setDescription('The number of timers processed by the ND process since initialization.')
ndLCGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 711, 2, 1, 17, 2))
ndLCCount = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 17, 2, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndLCCount.setStatus('mandatory')
if mibBuilder.loadTexts: ndLCCount.setDescription('The number of line cards managed by the NP.')
ndLCTable = MibTable((1, 3, 6, 1, 4, 1, 711, 2, 1, 17, 2, 2), )
if mibBuilder.loadTexts: ndLCTable.setStatus('mandatory')
if mibBuilder.loadTexts: ndLCTable.setDescription('A table containing information about each managed line card neighbor.')
ndLCEntry = MibTableRow((1, 3, 6, 1, 4, 1, 711, 2, 1, 17, 2, 2, 1), ).setIndexNames((0, "LIGHTSTREAM-MIB", "ndLCEIA"))
if mibBuilder.loadTexts: ndLCEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ndLCEntry.setDescription('The information regarding a single ND neighbor.')
ndLCEIA = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 17, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndLCEIA.setStatus('mandatory')
if mibBuilder.loadTexts: ndLCEIA.setDescription('The internal address of the managed line card.')
ndLCChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 17, 2, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndLCChannel.setStatus('mandatory')
if mibBuilder.loadTexts: ndLCChannel.setDescription('The reliable channel to the managed line card.')
ndLCState = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 17, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("existent", 2), ("up", 3), ("comingdown", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndLCState.setStatus('mandatory')
if mibBuilder.loadTexts: ndLCState.setDescription("The line card's state.")
ndNbrGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 711, 2, 1, 17, 3))
ndNbrCount = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 17, 3, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndNbrCount.setStatus('mandatory')
if mibBuilder.loadTexts: ndNbrCount.setDescription('The number of neighbor NPs known to the ND process.')
ndNbrTable = MibTable((1, 3, 6, 1, 4, 1, 711, 2, 1, 17, 3, 2), )
if mibBuilder.loadTexts: ndNbrTable.setStatus('mandatory')
if mibBuilder.loadTexts: ndNbrTable.setDescription('A table containing information about each ND neighbor.')
ndNbrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 711, 2, 1, 17, 3, 2, 1), ).setIndexNames((0, "LIGHTSTREAM-MIB", "ndNbrEIA"))
if mibBuilder.loadTexts: ndNbrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ndNbrEntry.setDescription('The information regarding a single ND neighbor.')
ndNbrEIA = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 17, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndNbrEIA.setStatus('mandatory')
if mibBuilder.loadTexts: ndNbrEIA.setDescription('The internal address of the neighbor NP.')
ndNbrChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 17, 3, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndNbrChannel.setStatus('mandatory')
if mibBuilder.loadTexts: ndNbrChannel.setDescription('The reliable channel to the neighbor.')
ndNbrState = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 17, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("existent", 2), ("up", 3), ("comingdown", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndNbrState.setStatus('mandatory')
if mibBuilder.loadTexts: ndNbrState.setDescription("The neighbor's state.")
ndSwudGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 711, 2, 1, 17, 4))
ndSwudTable = MibTable((1, 3, 6, 1, 4, 1, 711, 2, 1, 17, 4, 1), )
if mibBuilder.loadTexts: ndSwudTable.setStatus('mandatory')
if mibBuilder.loadTexts: ndSwudTable.setDescription('A table containing switch up/down protocol parameters for each switch slot.')
ndSwudEntry = MibTableRow((1, 3, 6, 1, 4, 1, 711, 2, 1, 17, 4, 1, 1), ).setIndexNames((0, "LIGHTSTREAM-MIB", "ndSwudIndex"))
if mibBuilder.loadTexts: ndSwudEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ndSwudEntry.setDescription('The switch up/down protocol parameters for a single switch slot.')
ndSwudIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 17, 4, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndSwudIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ndSwudIndex.setDescription('The switch slot to which the parameters correspond.')
ndOperIntvl = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 17, 4, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndOperIntvl.setStatus('mandatory')
if mibBuilder.loadTexts: ndOperIntvl.setDescription('The operational interval between switch up/down messages sent by ND to this slot, in units of 100 milliseconds.')
ndOperJ = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 17, 4, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndOperJ.setStatus('mandatory')
if mibBuilder.loadTexts: ndOperJ.setDescription('The operational J parameter for this slot.')
ndOperK = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 17, 4, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndOperK.setStatus('mandatory')
if mibBuilder.loadTexts: ndOperK.setDescription('The operational K parameter for this slot.')
ndOperM = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 17, 4, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndOperM.setStatus('mandatory')
if mibBuilder.loadTexts: ndOperM.setDescription('The operational M parameter for this slot.')
ndOperN = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 17, 4, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndOperN.setStatus('mandatory')
if mibBuilder.loadTexts: ndOperN.setDescription('The operational N parameter for this slot.')
ndAdminIntvl = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 17, 4, 1, 1, 7), Integer32().clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ndAdminIntvl.setStatus('mandatory')
if mibBuilder.loadTexts: ndAdminIntvl.setDescription('The administratively desired interval between switch up/down messages sent by ND to this slot, in units of 100 milliseconds.')
ndAdminJ = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 17, 4, 1, 1, 8), Integer32().clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ndAdminJ.setStatus('mandatory')
if mibBuilder.loadTexts: ndAdminJ.setDescription('The administratively desired J parameter for this slot.')
ndAdminK = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 17, 4, 1, 1, 9), Integer32().clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ndAdminK.setStatus('mandatory')
if mibBuilder.loadTexts: ndAdminK.setDescription('The administratively desired K parameter for this slot.')
ndAdminM = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 17, 4, 1, 1, 10), Integer32().clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ndAdminM.setStatus('mandatory')
if mibBuilder.loadTexts: ndAdminM.setDescription('The administratively desired M parameter for this slot.')
ndAdminN = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 17, 4, 1, 1, 11), Integer32().clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ndAdminN.setStatus('mandatory')
if mibBuilder.loadTexts: ndAdminN.setDescription('The administratively desired N parameter for this slot.')
ndTrigger = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 17, 4, 1, 1, 12), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ndTrigger.setStatus('mandatory')
if mibBuilder.loadTexts: ndTrigger.setDescription('Transfer administratively desired to operational parameters.')
ndSwudStatsInputErrors = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 17, 4, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndSwudStatsInputErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ndSwudStatsInputErrors.setDescription('The number of errors received on switch up/down input cells.')
ndSwudStatsTable = MibTable((1, 3, 6, 1, 4, 1, 711, 2, 1, 17, 4, 3), )
if mibBuilder.loadTexts: ndSwudStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: ndSwudStatsTable.setDescription('A table containing switch up/down protocol statistics for each switch slot.')
ndSwudStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 711, 2, 1, 17, 4, 3, 1), ).setIndexNames((0, "LIGHTSTREAM-MIB", "ndSwudStatsIndex"))
if mibBuilder.loadTexts: ndSwudStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ndSwudStatsEntry.setDescription('Switch up/down protocol statistics for a single switch slot.')
ndSwudStatsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 17, 4, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndSwudStatsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ndSwudStatsIndex.setDescription('The switch slot to which the statistics correspond.')
ndInputCells = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 17, 4, 3, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndInputCells.setStatus('mandatory')
if mibBuilder.loadTexts: ndInputCells.setDescription('The number of switch up/down cells received from this switch slot.')
ndInputErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 17, 4, 3, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndInputErrs.setStatus('mandatory')
if mibBuilder.loadTexts: ndInputErrs.setDescription('The number of errored switch up/down cells received from this switch slot.')
ndOutputCells = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 17, 4, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndOutputCells.setStatus('mandatory')
if mibBuilder.loadTexts: ndOutputCells.setDescription('The number of switch up/down cells sent to this switch slot.')
ndOutputErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 17, 4, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndOutputErrs.setStatus('mandatory')
if mibBuilder.loadTexts: ndOutputErrs.setDescription('The number of errors reported on switch up/down cells sent to this switch slot.')
ndClientGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 711, 2, 1, 17, 5))
ndClientCount = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 17, 5, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndClientCount.setStatus('mandatory')
if mibBuilder.loadTexts: ndClientCount.setDescription('The number of registered ND client processes.')
ndClientTable = MibTable((1, 3, 6, 1, 4, 1, 711, 2, 1, 17, 5, 2), )
if mibBuilder.loadTexts: ndClientTable.setStatus('mandatory')
if mibBuilder.loadTexts: ndClientTable.setDescription('A table containing information about each ND client process.')
ndClientEntry = MibTableRow((1, 3, 6, 1, 4, 1, 711, 2, 1, 17, 5, 2, 1), ).setIndexNames((0, "LIGHTSTREAM-MIB", "ndClientID"))
if mibBuilder.loadTexts: ndClientEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ndClientEntry.setDescription('The information regarding a single ND client process.')
ndClientID = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 17, 5, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndClientID.setStatus('mandatory')
if mibBuilder.loadTexts: ndClientID.setDescription('The ND client process identifier.')
ndClientType = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 17, 5, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("nd", 3), ("gid", 4), ("lcc", 5), ("ca", 6), ("sys", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndClientType.setStatus('mandatory')
if mibBuilder.loadTexts: ndClientType.setDescription('The ND client type.')
ndClientSubType = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 17, 5, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndClientSubType.setStatus('mandatory')
if mibBuilder.loadTexts: ndClientSubType.setDescription('The ND client subtype, if applicable. Certain processes with the same major type, e.g. sys, are distinguished by differing subtypes.')
ndClientEIA = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 17, 5, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndClientEIA.setStatus('mandatory')
if mibBuilder.loadTexts: ndClientEIA.setDescription('The internal card address associated with the ND client process, if applicable. Edge and trunk card control processes are associated with a unique card address. The NP card control process and the Congestion Avoidance information distribution process share the internal card address of the local NP.')
ndClientRegistration = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 17, 5, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndClientRegistration.setStatus('mandatory')
if mibBuilder.loadTexts: ndClientRegistration.setDescription('A mask of events for which the ND client is registered.')
ndInternalGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 711, 2, 1, 17, 6))
ndInternalDebugLevel = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 17, 6, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ndInternalDebugLevel.setStatus('mandatory')
if mibBuilder.loadTexts: ndInternalDebugLevel.setDescription('ND internal debugging variable.')
ndInternalDebugFlags = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 17, 6, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ndInternalDebugFlags.setStatus('mandatory')
if mibBuilder.loadTexts: ndInternalDebugFlags.setDescription('ND internal debugging variable.')
ndRedundancyGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 711, 2, 1, 17, 7))
ndPrimaryNP = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 17, 7, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndPrimaryNP.setStatus('mandatory')
if mibBuilder.loadTexts: ndPrimaryNP.setDescription('Slot number of primary NP.')
ndThisNP = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 17, 7, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndThisNP.setStatus('mandatory')
if mibBuilder.loadTexts: ndThisNP.setDescription('Slot number of currently connected NP.')
ndForceToBackup = MibScalar((1, 3, 6, 1, 4, 1, 711, 2, 1, 17, 7, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ndForceToBackup.setStatus('mandatory')
if mibBuilder.loadTexts: ndForceToBackup.setDescription('Force this NP to become backup.')
lwmaInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 711, 2, 1, 18))
lwmaTable = MibTable((1, 3, 6, 1, 4, 1, 711, 2, 1, 18, 1), )
if mibBuilder.loadTexts: lwmaTable.setStatus('mandatory')
if mibBuilder.loadTexts: lwmaTable.setDescription('Table of perprocess LWMA private info')
lwmaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 711, 2, 1, 18, 1, 1), ).setIndexNames((0, "LIGHTSTREAM-MIB", "lwmaIndex"))
if mibBuilder.loadTexts: lwmaEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lwmaEntry.setDescription('An entry in the LWMA table.')
lwmaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 18, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lwmaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lwmaIndex.setDescription('Unique Index consisting of LWMA number.')
lwmaCreationTime = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 18, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lwmaCreationTime.setStatus('mandatory')
if mibBuilder.loadTexts: lwmaCreationTime.setDescription('Unix time in seconds marking start of MMA.')
lwmaTableNotification = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 18, 1, 1, 3), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lwmaTableNotification.setStatus('mandatory')
if mibBuilder.loadTexts: lwmaTableNotification.setDescription('Object-ID of last table completing configuration')
lwmaTrapLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 18, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("operational", 1), ("informational", 2), ("trace", 3), ("debug", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lwmaTrapLevel.setStatus('mandatory')
if mibBuilder.loadTexts: lwmaTrapLevel.setDescription('Trap filter level for the lwma.')
lwmaTrapNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 18, 1, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lwmaTrapNumber.setStatus('mandatory')
if mibBuilder.loadTexts: lwmaTrapNumber.setDescription('Trap Number used by the state and action variables')
lwmaTrapOnOffState = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 18, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("trapOn", 1), ("trapOff", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lwmaTrapOnOffState.setStatus('mandatory')
if mibBuilder.loadTexts: lwmaTrapOnOffState.setDescription('On/Off State of Trap specified in lwmaTrapNumber')
lwmaTrapCliAlias = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 2, 1, 18, 1, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lwmaTrapCliAlias.setStatus('mandatory')
if mibBuilder.loadTexts: lwmaTrapCliAlias.setDescription('Name for this process that can be used in the CLI trap interface.')
lightStreamBridge = MibIdentifier((1, 3, 6, 1, 4, 1, 711, 3, 1))
lightStreamBridgePortTable = MibTable((1, 3, 6, 1, 4, 1, 711, 3, 1, 1), )
if mibBuilder.loadTexts: lightStreamBridgePortTable.setStatus('mandatory')
if mibBuilder.loadTexts: lightStreamBridgePortTable.setDescription('Proprietary port parameters needed for LightStream node configuration. This table contains one entry for each bridge port.')
lightStreamBridgePortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 711, 3, 1, 1, 1), ).setIndexNames((0, "LIGHTSTREAM-MIB", "lightStreamBrPortPort"))
if mibBuilder.loadTexts: lightStreamBridgePortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lightStreamBridgePortEntry.setDescription('Objects required for a given bridge port.')
lightStreamBrPortPort = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 3, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lightStreamBrPortPort.setStatus('mandatory')
if mibBuilder.loadTexts: lightStreamBrPortPort.setDescription('The value of the instance of the dot1dBasePort object, defined in the standard Bridge MIB (RFC1286), for the port this entry corresponds to.')
lightStreamBrPortDefaultAction = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 3, 1, 1, 1, 2), LightStreamFilterAction().clone('forward')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lightStreamBrPortDefaultAction.setStatus('mandatory')
if mibBuilder.loadTexts: lightStreamBrPortDefaultAction.setDescription('This is the action taken on frames received that do not match a defined filter.')
lightStreamBrPortBcastRateLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 3, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 127)).clone(-1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lightStreamBrPortBcastRateLimit.setStatus('mandatory')
if mibBuilder.loadTexts: lightStreamBrPortBcastRateLimit.setDescription('Number of broadcast packets that this node forwards per second. The node discards all additional packets per second. If the value is zero, all broadcast packets are discarded. If the value is -1 all broadcast packets are forwarded. That is, there is no limit on broadcasts.')
lightStreamBrPortDroppedBcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 3, 1, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lightStreamBrPortDroppedBcastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: lightStreamBrPortDroppedBcastPkts.setDescription('The number of broadcast packets dropped because the lightStreamBrPortBcastRateLimit was exceeded.')
lightStreamBridgeFilterTable = MibTable((1, 3, 6, 1, 4, 1, 711, 3, 1, 2), )
if mibBuilder.loadTexts: lightStreamBridgeFilterTable.setStatus('mandatory')
if mibBuilder.loadTexts: lightStreamBridgeFilterTable.setDescription("A list of filters. Reverse Polish Notation (RPN) is being used here to provide the most flexibility in defining more complex filters in the future. Each filter is represented by a list of entries. Each entry is a single RPN token. To create an entry, create the list of tokens as follows: More than one token can be contained in a single message. All fields of a single token must be in the same message. The lightStreamBrFilterStatus object of all intermediate tokens must contain the value 'intermediateToken'. The lightStreamBrFilterStatus object of the last token must contain the value 'complete'. When the last token is created with a status of 'complete' the status field of every prior token associated with that filter is set to 'complete'. When the filter is set to 'complete', it is available for use in a lightStreamBridgeFilterParameterEntry. The filter is not actually used until its ID is placed in a lightStreamBridgeFilterParameterEntry and the associated parameters are defined. A filter may be used more than once in the lightStreamBridgeFilterParameterTable. The agent does not permit the user to 'delete' the filter entry until it is removed from the lightStreamBridgeFilterParameterTable. When a filter is placed into or removed from the lightStreamBridgeFilterParameterTable, its new state becomes active immediately. The agent provides timeout service for partially constructed filters. If a manager doesn't complete a filter definition within the timeout period (currently 3 minutes), the agent removes all tokens associated with that filter.")
lightStreamBridgeFilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 711, 3, 1, 2, 1), ).setIndexNames((0, "LIGHTSTREAM-MIB", "lightStreamBrFilterId"), (0, "LIGHTSTREAM-MIB", "lightStreamBrFilterTokenIndex"))
if mibBuilder.loadTexts: lightStreamBridgeFilterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lightStreamBridgeFilterEntry.setDescription('A single filter consists of multiple lightStreamBridgeFilterEntries. Each entry represents a single token of a given filter.')
lightStreamBrFilterId = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 3, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lightStreamBrFilterId.setStatus('mandatory')
if mibBuilder.loadTexts: lightStreamBrFilterId.setDescription('The ID assigned to this filter.')
lightStreamBrFilterTokenIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 3, 1, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lightStreamBrFilterTokenIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lightStreamBrFilterTokenIndex.setDescription('The RPN index of this token within the filter. This value must be assigned sequentially starting with 1.')
lightStreamBrFilterTokenType = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 3, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("operation", 1), ("frameField", 2), ("macAddrType", 3), ("etherType", 4), ("llcSAPType", 5), ("reserved", 6), ("snapOuiType", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lightStreamBrFilterTokenType.setStatus('mandatory')
if mibBuilder.loadTexts: lightStreamBrFilterTokenType.setDescription('This defines the type of token contained in this entry. There is no default value for this object, its value must be contained in the creation message.')
lightStreamBrFilterTokenValue = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 3, 1, 2, 1, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lightStreamBrFilterTokenValue.setStatus('mandatory')
if mibBuilder.loadTexts: lightStreamBrFilterTokenValue.setDescription("The value for this token. The appropriate value depends on the lightStreamBrFilterTokenType. Because instances of this object can be of diverse types, they are exchanged as DisplayStrings and the agent parses it according to the type. If the type is 'operation', the agent expects one of the following character strings: maskAnd and or equal notEqual greater greaterOrEqual less lessOrEqual If the type is 'macAddrType' the agent expects a MAC address DisplayString in the format xx:xx:xx:xx:xx:xx. If the type is 'frameField' the agent will expect of one of the following character strings: macSrc macDst macProto llcSSAP llcDSAP snapOUI snapProto For all other types, the agent expects a hex digit displayString in the form 0x800. This object has no default value. It must be explicitly set in the creation message.")
lightStreamBrFilterStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 3, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4))).clone(namedValues=NamedValues(("complete", 1), ("delete", 2), ("intermediateToken", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lightStreamBrFilterStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lightStreamBrFilterStatus.setDescription("To define an interim token, set this field to 'intermediateToken'. To define the final token set this field to 'complete'. This has the side-effect of setting the lightStreamBrFilterStatus fields of all tokens for this filter to 'complete'. To delete an unassigned filter, set this value to 'delete' in any of the filter's token entries. This has the side-effect of setting the lightStreamBrFilterStatus fields of all tokens for this filter to 'delete'. This object does not have a default value. To create an entry this object must be explicitly contained in the set message.")
lightStreamBridgeFilterParameterTable = MibTable((1, 3, 6, 1, 4, 1, 711, 3, 1, 3), )
if mibBuilder.loadTexts: lightStreamBridgeFilterParameterTable.setStatus('mandatory')
if mibBuilder.loadTexts: lightStreamBridgeFilterParameterTable.setDescription('This table contains the list of assigned filters and the parameters associated with it. To add an entry to this table, all non-defaulted objects must be contained in a single message and the lightStreamBrFilterParmFilterId must already be created in the lightStreamBridgeFilterTable.')
lightStreamBridgeFilterParameterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 711, 3, 1, 3, 1), ).setIndexNames((0, "LIGHTSTREAM-MIB", "lightStreamBrFilterParmPort"), (0, "LIGHTSTREAM-MIB", "lightStreamBrFilterParmFilterId"))
if mibBuilder.loadTexts: lightStreamBridgeFilterParameterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lightStreamBridgeFilterParameterEntry.setDescription('The objects associated with a single assigned filter.')
lightStreamBrFilterParmPort = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 3, 1, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lightStreamBrFilterParmPort.setStatus('mandatory')
if mibBuilder.loadTexts: lightStreamBrFilterParmPort.setDescription('The dot1dBasePort, defined in the standard Bridge MIB (RFC1286), this entry is defined for.')
lightStreamBrFilterParmFilterId = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 3, 1, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lightStreamBrFilterParmFilterId.setStatus('mandatory')
if mibBuilder.loadTexts: lightStreamBrFilterParmFilterId.setDescription('The lightStreamBrFilterId being assigned here.')
lightStreamBrFilterParmFilterPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 3, 1, 3, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lightStreamBrFilterParmFilterPriority.setStatus('mandatory')
if mibBuilder.loadTexts: lightStreamBrFilterParmFilterPriority.setDescription('The precedence assigned to this filter. The value 1 gives the object the highest priority on this port. It is recommended that these not be assigned sequentially. Sequential numbering would make it difficult to re-prioritize the filters.')
lightStreamBrFilterParmAction = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 3, 1, 3, 1, 4), LightStreamFilterAction()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lightStreamBrFilterParmAction.setStatus('mandatory')
if mibBuilder.loadTexts: lightStreamBrFilterParmAction.setDescription('Definition of what action should be taken when a packet matching this filter is encountered.')
lightStreamBrFilterParmMatchCounts = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 3, 1, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lightStreamBrFilterParmMatchCounts.setStatus('mandatory')
if mibBuilder.loadTexts: lightStreamBrFilterParmMatchCounts.setDescription('The number of times this filter instance was matched.')
lightStreamBrFilterParmValidation = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 3, 1, 3, 1, 6), LightStreamValidation()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lightStreamBrFilterParmValidation.setStatus('mandatory')
if mibBuilder.loadTexts: lightStreamBrFilterParmValidation.setDescription('This object indicates whether the user has validated or invalidated this entry. This entry does not have a default value. To create an entry this object must be explicitly contained in the set message.')
lightStreamBrStaticGoToCardSize = MibScalar((1, 3, 6, 1, 4, 1, 711, 3, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lightStreamBrStaticGoToCardSize.setStatus('mandatory')
if mibBuilder.loadTexts: lightStreamBrStaticGoToCardSize.setDescription('This object indicates how many bytes of the bit string dot1dStaticGoTo represent a single card. There must be enough bytes to represent all the ports on a card, and this is release specific. The dot1dStaticGoTo object is a bit string that represents the bridging ports on the LightStream Node.')
lightStreamVliVersion = MibScalar((1, 3, 6, 1, 4, 1, 711, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("version-1", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lightStreamVliVersion.setStatus('mandatory')
if mibBuilder.loadTexts: lightStreamVliVersion.setDescription('The version of VLI implemented in this node.')
lightStreamVliPortCtlTable = MibTable((1, 3, 6, 1, 4, 1, 711, 4, 4), )
if mibBuilder.loadTexts: lightStreamVliPortCtlTable.setStatus('mandatory')
if mibBuilder.loadTexts: lightStreamVliPortCtlTable.setDescription('This table contains the control information for port based VLI.')
lightStreamVliPortCtlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 711, 4, 4, 1), ).setIndexNames((0, "LIGHTSTREAM-MIB", "lightStreamVliPortCtlPort"))
if mibBuilder.loadTexts: lightStreamVliPortCtlEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lightStreamVliPortCtlEntry.setDescription('Information needed to manage port based VLI on a given bridge port.')
lightStreamVliPortCtlPort = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 4, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lightStreamVliPortCtlPort.setStatus('mandatory')
if mibBuilder.loadTexts: lightStreamVliPortCtlPort.setDescription('The bridge port this entry corresponds to. This value is the same as dot1dBasePort which is defined in the IETF standard Bridge MIB.')
lightStreamVliPortCtlMode = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 4, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("include", 1), ("exclude", 2))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lightStreamVliPortCtlMode.setStatus('mandatory')
if mibBuilder.loadTexts: lightStreamVliPortCtlMode.setDescription('This defines the type of control to be instrumented on this port. include: When this object is set to include, port based VLI will process only the work groups defined in the corresponding work group table entries. All other work groups will be filtered out on this port. exclude: When this object is set to exclude, port based VLI will process all work groups except those listed in the corresponding work group table entries. Those listed in the lightStreamVliPortWorkGroupTable will be filtered. The default state of exclude with an empty work group table allows all work groups to be recognized as valid on this port.')
lightStreamVliPortWorkGroupTable = MibTable((1, 3, 6, 1, 4, 1, 711, 4, 5), )
if mibBuilder.loadTexts: lightStreamVliPortWorkGroupTable.setStatus('mandatory')
if mibBuilder.loadTexts: lightStreamVliPortWorkGroupTable.setDescription('The list of work groups defined for port based VLI management.')
lightStreamVliPortWorkGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 711, 4, 5, 1), ).setIndexNames((0, "LIGHTSTREAM-MIB", "lightStreamVliPortWorkGroupPort"), (0, "LIGHTSTREAM-MIB", "lightStreamVliPortWorkGroupID"))
if mibBuilder.loadTexts: lightStreamVliPortWorkGroupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lightStreamVliPortWorkGroupEntry.setDescription('A work group to port association.')
lightStreamVliPortWorkGroupPort = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 4, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lightStreamVliPortWorkGroupPort.setStatus('mandatory')
if mibBuilder.loadTexts: lightStreamVliPortWorkGroupPort.setDescription('The port this work group is being defined on. This value is the same as dot1dBasePort.')
lightStreamVliPortWorkGroupID = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 4, 5, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lightStreamVliPortWorkGroupID.setStatus('mandatory')
if mibBuilder.loadTexts: lightStreamVliPortWorkGroupID.setDescription('The identifier of the work group being assigned to this port. This must have a corresponding entry in the lightStreamVliWorkGroupTable.')
lightStreamVliPortWorkGroupValidation = MibTableColumn((1, 3, 6, 1, 4, 1, 711, 4, 5, 1, 3), LightStreamValidation()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lightStreamVliPortWorkGroupValidation.setStatus('mandatory')
if mibBuilder.loadTexts: lightStreamVliPortWorkGroupValidation.setDescription('For conceptual row addition, this table requires all non-defaulted objects for a given entry to be contained in a single SNMP message. This object will not default. To create a new entry, this object must be explicitly set to valid. To remove an entry, this object must be explicitly set to invalid.')
lightStreamEndOfMib = MibScalar((1, 3, 6, 1, 4, 1, 711, 1000, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lightStreamEndOfMib.setStatus('mandatory')
if mibBuilder.loadTexts: lightStreamEndOfMib.setDescription('Always returns 1.')
mibBuilder.exportSymbols("LIGHTSTREAM-MIB", ndLCEntry=ndLCEntry, fsuQueueCellLenSubQIndex=fsuQueueCellLenSubQIndex, LightStreamStatus=LightStreamStatus, edgeToSwMsgLenPortIndex=edgeToSwMsgLenPortIndex, trunkPortRcvAborts=trunkPortRcvAborts, ls1InfoDataCellCapacity=ls1InfoDataCellCapacity, clc1InfoOperClock=clc1InfoOperClock, lightStreamBridge=lightStreamBridge, gidLineCardTable=gidLineCardTable, ms1InfoLcAutoEnable=ms1InfoLcAutoEnable, lsTrapName=lsTrapName, ffCktAdminPrinBwType=ffCktAdminPrinBwType, sUniCktInfoUniToNetCallID=sUniCktInfoUniToNetCallID, portTransmission=portTransmission, lsFrameRelayDlciStatTable=lsFrameRelayDlciStatTable, oc3InfoReceiveSignalDetect=oc3InfoReceiveSignalDetect, gidIpEntryAdvNP=gidIpEntryAdvNP, cellVciStatVciIndex=cellVciStatVciIndex, chassisInfo=chassisInfo, ndLCChannel=ndLCChannel, tcsInfo=tcsInfo, ndLCEIA=ndLCEIA, lightStreamEndOfMib=lightStreamEndOfMib, edgeSecondaryScale=edgeSecondaryScale, lsEdgeSwToPortMsgLenEntry=lsEdgeSwToPortMsgLenEntry, fsuPortFreeCells=fsuPortFreeCells, gidDebugLevel=gidDebugLevel, sUniCktOperDestNode=sUniCktOperDestNode, ls1InfoAdminNetIntType=ls1InfoAdminNetIntType, fsuHdrLrcErrs=fsuHdrLrcErrs, cardAdminStatus=cardAdminStatus, frCktAdminSrcInsuredBurst=frCktAdminSrcInsuredBurst, mcEndptLastAtmLocation=mcEndptLastAtmLocation, edgePortDownXmtFrames=edgePortDownXmtFrames, frameForwardToSwCLP1Frames=frameForwardToSwCLP1Frames, gidEventGenericGinfoEventsDelivered=gidEventGenericGinfoEventsDelivered, lightStreamVliPortCtlEntry=lightStreamVliPortCtlEntry, mcEndptEntry=mcEndptEntry, gidSyncNbrsExchange=gidSyncNbrsExchange, ms1InfoAdminOperTrigger=ms1InfoAdminOperTrigger, tcsWarnTemp2=tcsWarnTemp2, ls1InfoOperDataBandwidthSize=ls1InfoOperDataBandwidthSize, frCktStatus=frCktStatus, ndPrimaryNP=ndPrimaryNP, fsuQueueCellLenPortIndex=fsuQueueCellLenPortIndex, pidTable=pidTable, switchCellSchedRejectEvents=switchCellSchedRejectEvents, ffCktSrcNode=ffCktSrcNode, lsFsuFastDropEntry=lsFsuFastDropEntry, ndOperK=ndOperK, ls1InfoOperXmitBaudRate=ls1InfoOperXmitBaudRate, portInfoSpecific=portInfoSpecific, edgeUpcType=edgeUpcType, tcsShutdownTemp2=tcsShutdownTemp2, lsLcFsuIntervalTable=lsLcFsuIntervalTable, collectCommunityName=collectCommunityName, ls1InfoMeasuredBaudRate=ls1InfoMeasuredBaudRate, gidMallocFailures=gidMallocFailures, cardOperStatus=cardOperStatus, frProvMiNetErrorThreshold=frProvMiNetErrorThreshold, cellVciToSwCLP0Cells=cellVciToSwCLP0Cells, gidNbrIPAnnouncementsRx=gidNbrIPAnnouncementsRx, gidNbrNewLinkAnnouncementsRx=gidNbrNewLinkAnnouncementsRx, tsuDropEvents=tsuDropEvents, tsuPortErrL1UnconfigLastVci=tsuPortErrL1UnconfigLastVci, edgeUserDataPerCell=edgeUserDataPerCell, gidEventGenericGinfoEventCount=gidEventGenericGinfoEventCount, lightStreamATM=lightStreamATM, gidUpTime=gidUpTime, gidEventLinkEventsDelivered=gidEventLinkEventsDelivered, irRoutingPathGenSuccess=irRoutingPathGenSuccess, lightStreamBrFilterId=lightStreamBrFilterId, ndSwudGroup=ndSwudGroup, lightStreamBrFilterStatus=lightStreamBrFilterStatus, sUniCktInfoIfIndex=sUniCktInfoIfIndex, gidEventGenericGinfoEventTable=gidEventGenericGinfoEventTable, ndOperIntvl=ndOperIntvl, sUniCktOperTransPri=sUniCktOperTransPri, lwmaIndex=lwmaIndex, portInfo=portInfo, ffCktInfoDataCellsRequired=ffCktInfoDataCellsRequired, ffCktAdminDestMaxBurst=ffCktAdminDestMaxBurst, ndMemoryUse=ndMemoryUse, frCktSrcNode=frCktSrcNode, frCktAdminDestInsuredBurst=frCktAdminDestInsuredBurst, ls1InfoAdminCsuType=ls1InfoAdminCsuType, collectDBObjectID=collectDBObjectID, ndSoftwareVersionNumber=ndSoftwareVersionNumber, gidNbrState=gidNbrState, gidInternalIpAddress=gidInternalIpAddress, frameForwardToSwCLP0Frames=frameForwardToSwCLP0Frames, cardLcSoftwareVersion=cardLcSoftwareVersion, frCktOperSrcMaxRate=frCktOperSrcMaxRate, lsUtStatistics=lsUtStatistics, ms1InfoIfIndex=ms1InfoIfIndex, tsuDropEventPortIndex=tsuDropEventPortIndex, gidPortID=gidPortID, lcPortStatTable=lcPortStatTable, ffCktAdminTransPri=ffCktAdminTransPri, lcStatCardIndex=lcStatCardIndex, mcEndptStatus=mcEndptStatus, frCktOperSecondaryScale=frCktOperSecondaryScale, tcsPaddleWarnTemp1=tcsPaddleWarnTemp1, edgeStatFsuRATOs=edgeStatFsuRATOs, irRoutingPathGenFailedUnknown=irRoutingPathGenFailedUnknown, pidOperStatus=pidOperStatus, gidLineCardPorts=gidLineCardPorts, lsLcIntervalNumber=lsLcIntervalNumber, lsLcIntervalMaxPermits=lsLcIntervalMaxPermits, ndNbrGroup=ndNbrGroup, gidClientGroup=gidClientGroup, oc3InfoTransmitSafetySwitch=oc3InfoTransmitSafetySwitch, tsuPortErrNonZeroGfc=tsuPortErrNonZeroGfc, frCktInfoTable=frCktInfoTable, gidEventIpEventsDelivered=gidEventIpEventsDelivered, frProvMiUserFullEnquiryInterval=frProvMiUserFullEnquiryInterval, sUniCktInfoNetToUniState=sUniCktInfoNetToUniState, clc1InfoEntry=clc1InfoEntry, frCktOperDestDlci=frCktOperDestDlci, frCktAdminSrcInsuredRate=frCktAdminSrcInsuredRate, lwmaTrapCliAlias=lwmaTrapCliAlias, gidPortChassis=gidPortChassis, edgePortXmtOctets=edgePortXmtOctets, sUniCktOperDestVCI=sUniCktOperDestVCI, edgePrincipalScale=edgePrincipalScale, clc1InfoOperLoopMode=clc1InfoOperLoopMode, mcEndptDownstreamState=mcEndptDownstreamState, ffCktOperSrcMaxBurst=ffCktOperSrcMaxBurst, frCktInfoDataCellsRequired=frCktInfoDataCellsRequired, ndInternalDebugFlags=ndInternalDebugFlags, mcEndptLastAtmErr=mcEndptLastAtmErr, trunkPortDownXmtCells=trunkPortDownXmtCells, ndSwudStatsEntry=ndSwudStatsEntry, mcEndptCallIDIncoming=mcEndptCallIDIncoming, frCktOperDestMaxBurst=frCktOperDestMaxBurst, lightStreamVli=lightStreamVli, ms1InfoOperProtocol=ms1InfoOperProtocol, gidNbrDBReqListLength=gidNbrDBReqListLength, lsPrivate=lsPrivate, gidIpAddressDatabaseSize=gidIpAddressDatabaseSize, frameRelayDlciStatPortIndex=frameRelayDlciStatPortIndex, sUniCktOperDestInsuredRate=sUniCktOperDestInsuredRate, pidCreationTime=pidCreationTime, lsTrunkCpuWorkloadEntry=lsTrunkCpuWorkloadEntry, sUniCktInfoLastAtmErr=sUniCktInfoLastAtmErr, cardMaxVCs=cardMaxVCs, ffCktOperSrcInsuredRate=ffCktOperSrcInsuredRate, ndInternalGroup=ndInternalGroup, frCktOperSrcInsuredRate=frCktOperSrcInsuredRate, sUniCktAdminDestMaxRate=sUniCktAdminDestMaxRate, gidPortBW1=gidPortBW1, edgePortCksmErrLastVci=edgePortCksmErrLastVci, frCktOperPrinBwType=frCktOperPrinBwType, lightStreamBrFilterParmAction=lightStreamBrFilterParmAction, lsCellVciStatEntry=lsCellVciStatEntry, lsLcIntervalDropEvents=lsLcIntervalDropEvents, VCI=VCI, edgeStatFsuRATOLastInfo=edgeStatFsuRATOLastInfo, gidEventGroup=gidEventGroup, lightStreamVliPortWorkGroupID=lightStreamVliPortWorkGroupID, frameForwardToSwDiscardFrames=frameForwardToSwDiscardFrames, frCktOperSrcMaxBurst=frCktOperSrcMaxBurst, sUniCktAdminDestVCI=sUniCktAdminDestVCI, tcsTable=tcsTable, gidClientCount=gidClientCount, npInfoAdminOperTrigger=npInfoAdminOperTrigger, pvcSrcMaxBurst=pvcSrcMaxBurst, lsLcIntervalIncrPermits=lsLcIntervalIncrPermits, lightStreamVliPortWorkGroupEntry=lightStreamVliPortWorkGroupEntry, ls1InfoEntry=ls1InfoEntry, ndClientGroup=ndClientGroup, frCktAdminSrcMaxRate=frCktAdminSrcMaxRate, mcEndptServiceType=mcEndptServiceType, clc1InfoAdminProtocol=clc1InfoAdminProtocol, gidClientLinkAnnouncementsRx=gidClientLinkAnnouncementsRx, sUniCktAdminSecondaryScale=sUniCktAdminSecondaryScale, sUniCktSrcVCI=sUniCktSrcVCI, ndClientEIA=ndClientEIA, ls1InfoAdminControlBandwidthSize=ls1InfoAdminControlBandwidthSize, gidSyncGroup=gidSyncGroup, ndLCState=ndLCState, fsuPayloadLrcErrs=fsuPayloadLrcErrs, edgePortXmtUnderflows=edgePortXmtUnderflows, frCktAdminPrinBwType=frCktAdminPrinBwType, gidIpAddressEntry=gidIpAddressEntry, portInfoEntry=portInfoEntry, ffCktOperPrinBwType=ffCktOperPrinBwType, ndAdminK=ndAdminK, tsuErrFutQCellDrops=tsuErrFutQCellDrops, frProvMiIfIndex=frProvMiIfIndex, frCktInfoDownstreamState=frCktInfoDownstreamState, collectFileSize=collectFileSize, ls1InfoOperLoopMode=ls1InfoOperLoopMode, mmaTrapOnOffState=mmaTrapOnOffState, collectFileName=collectFileName, frCktInfoIfIndex=frCktInfoIfIndex, ls1InfoOperCsuType=ls1InfoOperCsuType, lsLcIntervalMaxBwAlloc=lsLcIntervalMaxBwAlloc, tsuDropEventTable=tsuDropEventTable, ffCktOperSrcInsuredBurst=ffCktOperSrcInsuredBurst, tcsFaultLight=tcsFaultLight, clc1InfoOperDataBandwidthSize=clc1InfoOperDataBandwidthSize, lsNpCpuWorkloadIndex=lsNpCpuWorkloadIndex, lightStreamVliPortWorkGroupTable=lightStreamVliPortWorkGroupTable, ndSwudStatsInputErrors=ndSwudStatsInputErrors, collectDBInstance=collectDBInstance, pvcSecondaryScale=pvcSecondaryScale, frameRelayDlciToSwCLP1Cells=frameRelayDlciToSwCLP1Cells, mmaNumNameEntry=mmaNumNameEntry, frameRelayDlciToSwCLP0Cells=frameRelayDlciToSwCLP0Cells, irRoutingAveragePathLength=irRoutingAveragePathLength, edgeToSwMsgLenMsgs=edgeToSwMsgLenMsgs, frCktOperDestInsuredRate=frCktOperDestInsuredRate, tcsPowerSupplyTypeB=tcsPowerSupplyTypeB, mmaPID=mmaPID, ndOutputErrs=ndOutputErrs, ffCktAdminSrcMaxRate=ffCktAdminSrcMaxRate, ffCktAdminDestInsuredBurst=ffCktAdminDestInsuredBurst, pidIndex=pidIndex, tcsTemp1=tcsTemp1, ffCktInfoEntry=ffCktInfoEntry, fsuDropEventTable=fsuDropEventTable, lsEdgePortStatTable=lsEdgePortStatTable, tsuPortErrL1UnconfigVcis=tsuPortErrL1UnconfigVcis, gidNbrGenericAnnouncementsRx=gidNbrGenericAnnouncementsRx, chassisId=chassisId, lsLcIntervalPSDepth=lsLcIntervalPSDepth, gidClientTable=gidClientTable, ls1InfoDataCellAvailable=ls1InfoDataCellAvailable, collectStart=collectStart, lsFrameRelayDlciStatEntry=lsFrameRelayDlciStatEntry, lightStreamBrFilterParmValidation=lightStreamBrFilterParmValidation, portInfoIndex=portInfoIndex, fsuDropEventEntry=fsuDropEventEntry, lsFrameForwardStatTable=lsFrameForwardStatTable, lsTrunkWorkloadCardIndex=lsTrunkWorkloadCardIndex, fsuQueueCellLenEntry=fsuQueueCellLenEntry, ms1InfoLcDebugLevel=ms1InfoLcDebugLevel, gidGeneralGroup=gidGeneralGroup, edgePortTable=edgePortTable, tcsPowerSupplyA=tcsPowerSupplyA, ndNbrTable=ndNbrTable, clc1InfoLinkUtilization=clc1InfoLinkUtilization, chassisConsoleTrapLevel=chassisConsoleTrapLevel, clc1InfoAdminClock=clc1InfoAdminClock, sUniCktOperDestInsuredBurst=sUniCktOperDestInsuredBurst, ffCktOperDestInsuredRate=ffCktOperDestInsuredRate, ndAdminIntvl=ndAdminIntvl, lwmaTrapLevel=lwmaTrapLevel, ffCktInfoTable=ffCktInfoTable, lsTrunkCpuWorkloadTable=lsTrunkCpuWorkloadTable, ffCktStatus=ffCktStatus, frCktOperUserDataPerCell=frCktOperUserDataPerCell, cardStatusWord=cardStatusWord)
mibBuilder.exportSymbols("LIGHTSTREAM-MIB", mmaSetLock=mmaSetLock, lightStreamBridgeFilterParameterTable=lightStreamBridgeFilterParameterTable, sUniCktInfoUniToNetState=sUniCktInfoUniToNetState, mcEndptDest=mcEndptDest, lsCellStatistics=lsCellStatistics, pidEntry=pidEntry, tcsPowerSupplyTypeA=tcsPowerSupplyTypeA, edgePortEntry=edgePortEntry, portInfoTable=portInfoTable, sUniCktInfoDataCellsRequired=sUniCktInfoDataCellsRequired, gidIOClientMsgBuffersActive=gidIOClientMsgBuffersActive, gidNbrCount=gidNbrCount, frameRelayDlciToSwDiscardFrames=frameRelayDlciToSwDiscardFrames, edgeCellDelayVariance=edgeCellDelayVariance, gidSyncNbrsExistent=gidSyncNbrsExistent, frCktAdminTransPri=frCktAdminTransPri, edgePortStatIndex=edgePortStatIndex, lightStreamBridgePortEntry=lightStreamBridgePortEntry, frameRelayDlciFrSwCLP0Frames=frameRelayDlciFrSwCLP0Frames, gidLineCardSlot=gidLineCardSlot, gidLineCardEntryAdvNP=gidLineCardEntryAdvNP, ndClientCount=ndClientCount, lwmaInfo=lwmaInfo, ms1InfoEntry=ms1InfoEntry, LightStreamValidation=LightStreamValidation, chassisStatusWord=chassisStatusWord, ms1InfoOperScramble=ms1InfoOperScramble, gidNbrNewIPAnnouncementsRx=gidNbrNewIPAnnouncementsRx, ndAdminM=ndAdminM, ffCktInfoIfIndex=ffCktInfoIfIndex, fsuDropEventWatermarkIndex=fsuDropEventWatermarkIndex, frCktInfoLclLMI=frCktInfoLclLMI, cardEntry=cardEntry, oc3InfoMediumType=oc3InfoMediumType, ndInputCells=ndInputCells, gidPortService=gidPortService, chassisActiveIpAddr=chassisActiveIpAddr, frProvMiUserPollingInterval=frProvMiUserPollingInterval, lsEdgePortToSwMsgLenEntry=lsEdgePortToSwMsgLenEntry, lightStream=lightStream, ffCktAdminDestNode=ffCktAdminDestNode, ms1InfoAdminCableLength=ms1InfoAdminCableLength, sUniCktEntry=sUniCktEntry, pvcStatus=pvcStatus, lightStreamVliPortCtlPort=lightStreamVliPortCtlPort, gidPortRemotePort=gidPortRemotePort, ffCktInfoLastAtmErr=ffCktInfoLastAtmErr, lsOther=lsOther, sUniCktOperSrcInsuredRate=sUniCktOperSrcInsuredRate, gidSyncNbrsFull=gidSyncNbrsFull, pvcCfgTable=pvcCfgTable, pvcUserDataPerCell=pvcUserDataPerCell, edgePortXmtUcastPkts=edgePortXmtUcastPkts, ndForceToBackup=ndForceToBackup, cellVciToSwCLP01Cells=cellVciToSwCLP01Cells, ndSwudTable=ndSwudTable, mcEndptCfgTable=mcEndptCfgTable, trunkPortRcvCRCErrors=trunkPortRcvCRCErrors, tcsTcsVoltage=tcsTcsVoltage, pvcSrcInsuredBurst=pvcSrcInsuredBurst, ndTrigger=ndTrigger, frameForwardToSwCLP0Cells=frameForwardToSwCLP0Cells, collectDBStatus=collectDBStatus, sUniCktOperSrcMaxRate=sUniCktOperSrcMaxRate, gidAcceptedBcastRateIn=gidAcceptedBcastRateIn, atmSwitch=atmSwitch, lsEdgeCpuWorkloadEntry=lsEdgeCpuWorkloadEntry, lightStreamVliPortWorkGroupPort=lightStreamVliPortWorkGroupPort, oc3InfoEntry=oc3InfoEntry, gidClientID=gidClientID, trunkPortRcvRuns=trunkPortRcvRuns, ndLCTable=ndLCTable, tcsCardType=tcsCardType, ffCktInfoCallIDIncoming=ffCktInfoCallIDIncoming, frCktOperDestInsuredBurst=frCktOperDestInsuredBurst, lcStatTable=lcStatTable, clc1InfoIfIndex=clc1InfoIfIndex, sUniCktOperSrcInsuredBurst=sUniCktOperSrcInsuredBurst, clc1InfoAdminLoopMode=clc1InfoAdminLoopMode, ffCktOperSrcMaxRate=ffCktOperSrcMaxRate, frCktAdminDestMaxRate=frCktAdminDestMaxRate, gidLineCardEntrySeqno=gidLineCardEntrySeqno, mmaTrapLog=mmaTrapLog, gidLinkGroup=gidLinkGroup, npInfoTable=npInfoTable, mmaConfigID=mmaConfigID, tcsPostResult=tcsPostResult, pvcSrcPvcId=pvcSrcPvcId, gidIpEntryEIA=gidIpEntryEIA, sUniCktOperSrcMaxBurst=sUniCktOperSrcMaxBurst, npInfoIPNCircuits=npInfoIPNCircuits, edgePortFsuCksmErrMsgs=edgePortFsuCksmErrMsgs, tcsPaddleShutdownTemp1=tcsPaddleShutdownTemp1, gidNbrNewGenericAnnouncementsRx=gidNbrNewGenericAnnouncementsRx, lsFsuFastDropWatermarkIndex=lsFsuFastDropWatermarkIndex, sUniCktSrcNode=sUniCktSrcNode, clc1InfoTable=clc1InfoTable, ffCktAdminSrcInsuredRate=ffCktAdminSrcInsuredRate, gidMemoryUse=gidMemoryUse, ndLCCount=ndLCCount, gidNbrTable=gidNbrTable, ls1InfoOperControlBandwidthSize=ls1InfoOperControlBandwidthSize, gidNbrEntry=gidNbrEntry, edgePortXmtNUcastPkts=edgePortXmtNUcastPkts, pvcSrcIfIndex=pvcSrcIfIndex, frameForwardToSwCLP1Cells=frameForwardToSwCLP1Cells, lsTrunkPortStatTable=lsTrunkPortStatTable, sUniCktAdminSrcMaxBurst=sUniCktAdminSrcMaxBurst, tsuFreeCells=tsuFreeCells, frProvMiEntry=frProvMiEntry, ms1InfoOperCableLength=ms1InfoOperCableLength, sUniCktOperDestIfIndex=sUniCktOperDestIfIndex, fsuSharedFreeCells=fsuSharedFreeCells, cellVciToSwDiscardCells=cellVciToSwDiscardCells, tluAAL5AbortErrs=tluAAL5AbortErrs, tsuPortErrL2UnconfigVcis=tsuPortErrL2UnconfigVcis, fsuPortXmtCellsTable=fsuPortXmtCellsTable, ndOperM=ndOperM, ndAdminN=ndAdminN, ndClientType=ndClientType, gidClientEntry=gidClientEntry, gidSoftwareVersionNumber=gidSoftwareVersionNumber, sUniCktInfo=sUniCktInfo, caMinIntervalCaInfo=caMinIntervalCaInfo, pvcEntry=pvcEntry, mmaNumNameTable=mmaNumNameTable, trunkPortRcvCells=trunkPortRcvCells, tcsShutdownTemp1=tcsShutdownTemp1, edgeStatIndex=edgeStatIndex, lsConfig=lsConfig, edgePortRcvL3XsumErrs=edgePortRcvL3XsumErrs, gidIONbrMsgBuffersFree=gidIONbrMsgBuffersFree, gidIpEntryNetMask=gidIpEntryNetMask, trunkPortXmtUnderflows=trunkPortXmtUnderflows, lightStreamBrFilterTokenIndex=lightStreamBrFilterTokenIndex, lightStreamOIDs=lightStreamOIDs, gidPortTable=gidPortTable, lwmaTrapNumber=lwmaTrapNumber, sUniCktAdminTransPri=sUniCktAdminTransPri, gidPortUpDown=gidPortUpDown, frCktCfgTable=frCktCfgTable, ffCktInfoUpstreamState=ffCktInfoUpstreamState, gidNbrGroup=gidNbrGroup, cardIndex=cardIndex, lightStreamVliPortCtlTable=lightStreamVliPortCtlTable, ms1InfoOperFraming=ms1InfoOperFraming, lsLcIntervalAvgCells=lsLcIntervalAvgCells, ndClientEntry=ndClientEntry, ndInternalDebugLevel=ndInternalDebugLevel, sUniCktOperDestMaxRate=sUniCktOperDestMaxRate, edgeToPortMsgLenBinIndex=edgeToPortMsgLenBinIndex, mmaTrapFilter=mmaTrapFilter, gidLineCardChassis=gidLineCardChassis, edgePortRcvNUcastPkts=edgePortRcvNUcastPkts, tcsSwitchFaultMaskA=tcsSwitchFaultMaskA, lightStreamBrFilterParmMatchCounts=lightStreamBrFilterParmMatchCounts, ffCktOperDestMaxBurst=ffCktOperDestMaxBurst, clc1InfoLcAutoEnable=clc1InfoLcAutoEnable, edgePortRcvCRCErrors=edgePortRcvCRCErrors, lsNpCpuWorkloadEntry=lsNpCpuWorkloadEntry, ls1InfoAdminLoopMode=ls1InfoAdminLoopMode, edgeMeteringBurstSize=edgeMeteringBurstSize, fsuXmtCellsPortIndex=fsuXmtCellsPortIndex, lsPID=lsPID, ndInputErrs=ndInputErrs, sUniCktAdminSrcInsuredRate=sUniCktAdminSrcInsuredRate, ndAdminJ=ndAdminJ, gidEventDistributionGroup=gidEventDistributionGroup, lightStreamBridgeFilterEntry=lightStreamBridgeFilterEntry, edgePortRcvUcastPkts=edgePortRcvUcastPkts, gidIONbrMsgBuffersActive=gidIONbrMsgBuffersActive, tcsPowerSupplyB=tcsPowerSupplyB, lsStatistics=lsStatistics, mcEndptLclInstance=mcEndptLclInstance, LightStreamUpToMaxAge=LightStreamUpToMaxAge, edgeMaxFrameSize=edgeMaxFrameSize, frCktInfoCallIDOutgoing=frCktInfoCallIDOutgoing, tcsTemp2=tcsTemp2, edgePortRcvAborts=edgePortRcvAborts, sUniCktInfoNetToUniCallID=sUniCktInfoNetToUniCallID, sUniCktOperSecondaryScale=sUniCktOperSecondaryScale, lsTrunkWorkloadTypeIndex=lsTrunkWorkloadTypeIndex, ffCktAdminDestIfIndex=ffCktAdminDestIfIndex, ndNbrChannel=ndNbrChannel, portInfoName=portInfoName, edgeIfIndex=edgeIfIndex, lsLcIntervalPortIndex=lsLcIntervalPortIndex, collectDBIndex=collectDBIndex, lightStreamBrFilterParmFilterId=lightStreamBrFilterParmFilterId, frameForwardFrSwCLP1Frames=frameForwardFrSwCLP1Frames, ls1InfoIfIndex=ls1InfoIfIndex, lsEdgeWorkloadCardIndex=lsEdgeWorkloadCardIndex, collectEntry=collectEntry, frDceInfo=frDceInfo, tluAAL5ErrLastVci=tluAAL5ErrLastVci, tcsWarnTemp1=tcsWarnTemp1, collectStatus=collectStatus, tcsPaddleWarnTemp2=tcsPaddleWarnTemp2, mmaInfo=mmaInfo, frCktInfo=frCktInfo, lsND=lsND, ndSwudStatsTable=ndSwudStatsTable, tcsPaddleTemp2=tcsPaddleTemp2, clc1InfoOperControlBandwidthSize=clc1InfoOperControlBandwidthSize, ls1InfoOperRcvBaudRate=ls1InfoOperRcvBaudRate, pvcSrcNode=pvcSrcNode, frameForwardStatPortIndex=frameForwardStatPortIndex, ls1InfoOperNetIntType=ls1InfoOperNetIntType, fsuCellDropLastCellHdr=fsuCellDropLastCellHdr, lwmaCreationTime=lwmaCreationTime, cardTable=cardTable, tcsEntry=tcsEntry, mcEndptLclIfIndex=mcEndptLclIfIndex, fsuDropEvents=fsuDropEvents, lightStreamVliPortWorkGroupValidation=lightStreamVliPortWorkGroupValidation, lsTrunkStatistics=lsTrunkStatistics, gidClientIPAnnouncementsRx=gidClientIPAnnouncementsRx, lsLcFsuIntervalEntry=lsLcFsuIntervalEntry, sUniCktOperPrinBwType=sUniCktOperPrinBwType, lightStreamBridgeFilterParameterEntry=lightStreamBridgeFilterParameterEntry, gidIpAddressTable=gidIpAddressTable, lsEdgeWorkloadEvents=lsEdgeWorkloadEvents, ffCktOperDestNode=ffCktOperDestNode, ffCktOperDestMaxRate=ffCktOperDestMaxRate, ndNbrEntry=ndNbrEntry, lsExperimentalStatistics=lsExperimentalStatistics, frCktOperDestMaxRate=frCktOperDestMaxRate, lsTrapNumber=lsTrapNumber, lsCellVciStatTable=lsCellVciStatTable, ls1InfoTable=ls1InfoTable, cellVciStatPortIndex=cellVciStatPortIndex, clc1InfoAdminScramble=clc1InfoAdminScramble, gidLinkDatabaseSize=gidLinkDatabaseSize, gidLineCardEntryAge=gidLineCardEntryAge, lcPortStatEntry=lcPortStatEntry, lsLcIntervalMinBwAlloc=lsLcIntervalMinBwAlloc, ndOperN=ndOperN, rmonCommunityName=rmonCommunityName, ndNbrCount=ndNbrCount, ndThisNP=ndThisNP, mmaCollectionSpace=mmaCollectionSpace, frCktOperDestIfIndex=frCktOperDestIfIndex, sUniCktOperDestMaxBurst=sUniCktOperDestMaxBurst, ls1InfoType=ls1InfoType, ndLCGroup=ndLCGroup, ls1InfoAdminDataBandwidthSize=ls1InfoAdminDataBandwidthSize, fsuQueueCellLengthTable=fsuQueueCellLengthTable, lsIR=lsIR, ffCktSrcIfIndex=ffCktSrcIfIndex, lightStreamBrStaticGoToCardSize=lightStreamBrStaticGoToCardSize, frProvMiTable=frProvMiTable, frCktAdminSrcMaxBurst=frCktAdminSrcMaxBurst, gidClientEIA=gidClientEIA, lightStreamBridgePortTable=lightStreamBridgePortTable)
mibBuilder.exportSymbols("LIGHTSTREAM-MIB", ffCktOperDestInsuredBurst=ffCktOperDestInsuredBurst, sUniCktInfoLastAtmLocation=sUniCktInfoLastAtmLocation, collectDataBase=collectDataBase, frameForwardToSwDiscardCells=frameForwardToSwDiscardCells, edgePortRcvShortFrames=edgePortRcvShortFrames, sUniCktInfoVCI=sUniCktInfoVCI, irRoutingPathsGenerated=irRoutingPathsGenerated, gidPortBW2=gidPortBW2, edgeToSwMsgLenBinIndex=edgeToSwMsgLenBinIndex, collectInfo=collectInfo, frCktOperTransPri=frCktOperTransPri, ms1InfoAdminDataBandwidthSize=ms1InfoAdminDataBandwidthSize, pvcInfo=pvcInfo, clc1InfoLcDebugLevel=clc1InfoLcDebugLevel, pvcSrcMaxRate=pvcSrcMaxRate, tluAAL5XsumErrs=tluAAL5XsumErrs, lsGID=lsGID, lsTrapText=lsTrapText, lsEdgeWorkloadTypeIndex=lsEdgeWorkloadTypeIndex, lwmaTableNotification=lwmaTableNotification, lsTrunkWorkloadEvents=lsTrunkWorkloadEvents, ls1InfoOperModemState=ls1InfoOperModemState, npInfoEntry=npInfoEntry, frameForwardFrSwCLP0Cells=frameForwardFrSwCLP0Cells, lightStreamBrFilterParmPort=lightStreamBrFilterParmPort, gidDebugFlag=gidDebugFlag, clc1InfoDataCellAvailable=clc1InfoDataCellAvailable, sUniCktSts=sUniCktSts, clc1InfoOperProtocol=clc1InfoOperProtocol, frCktInfoRmtLMI=frCktInfoRmtLMI, frCktSrcDlci=frCktSrcDlci, clc1InfoOperScramble=clc1InfoOperScramble, irRoutingGroup=irRoutingGroup, ndRedundancyGroup=ndRedundancyGroup, ndSwudEntry=ndSwudEntry, collectOperStatus=collectOperStatus, tcsVccVoltage=tcsVccVoltage, ndSwudIndex=ndSwudIndex, ndNbrEIA=ndNbrEIA, ffCktInfoCallIDOutgoing=ffCktInfoCallIDOutgoing, lightStreamEOM=lightStreamEOM, gidLineCardEntry=gidLineCardEntry, chassisEthernetIpMask=chassisEthernetIpMask, sUniCktAdminPrinBwType=sUniCktAdminPrinBwType, irRoutingPathGenFailedNoResources=irRoutingPathGenFailedNoResources, frameRelayDlciStatDlciIndex=frameRelayDlciStatDlciIndex, portInfoType=portInfoType, pvcPrinBwType=pvcPrinBwType, ffCktEntry=ffCktEntry, mcEndptRmtVCstatus=mcEndptRmtVCstatus, ffCktAdminDestMaxRate=ffCktAdminDestMaxRate, lightStreamBrFilterTokenType=lightStreamBrFilterTokenType, edgeStatTsuHoldQCells=edgeStatTsuHoldQCells, lsLcIntervalMinPermits=lsLcIntervalMinPermits, gidEventGenericGinfoEvents=gidEventGenericGinfoEvents, ndClientTable=ndClientTable, tsuErrFutQMsgDropLastVci=tsuErrFutQMsgDropLastVci, sUniCktAdminSrcInsuredBurst=sUniCktAdminSrcInsuredBurst, ndOperJ=ndOperJ, gidNbrLinkAnnouncementsRx=gidNbrLinkAnnouncementsRx, lightStreamBrPortBcastRateLimit=lightStreamBrPortBcastRateLimit, frCktOperDestNode=frCktOperDestNode, frCktAdminSecondaryScale=frCktAdminSecondaryScale, caMaxIntervalPermitLimit=caMaxIntervalPermitLimit, chassisSecondaryIpAddr=chassisSecondaryIpAddr, chassisDefaultIpRouter=chassisDefaultIpRouter, cardLccSoftwareVersion=cardLccSoftwareVersion, frCktInfoLastAtmLocation=frCktInfoLastAtmLocation, ls1InfoLinkUtilization=ls1InfoLinkUtilization, lcStatEntry=lcStatEntry, lightStreamBridgeFilterTable=lightStreamBridgeFilterTable, frCktAdminDestIfIndex=frCktAdminDestIfIndex, mmaTrapLanguage=mmaTrapLanguage, gidClientGenericAnnouncementsRx=gidClientGenericAnnouncementsRx, chassisNetworkMask=chassisNetworkMask, ls1InfoLcDebugLevel=ls1InfoLcDebugLevel, gidIpAddressGroup=gidIpAddressGroup, lsEdgeSwToPortMsgLenTable=lsEdgeSwToPortMsgLenTable, lsLcIntervalDecrPermits=lsLcIntervalDecrPermits, mmaNumName=mmaNumName, fsuXmtCellEvents=fsuXmtCellEvents, collectTable=collectTable, pidName=pidName, pvcSrcInsuredRate=pvcSrcInsuredRate, frameForwardFrSwCLP1Cells=frameForwardFrSwCLP1Cells, lsFsuFastCellDropEvents=lsFsuFastCellDropEvents, tcsPrimarySwitch=tcsPrimarySwitch, frProvMiMaxSupportedVCs=frProvMiMaxSupportedVCs, ms1InfoOperDataBandwidthSize=ms1InfoOperDataBandwidthSize, gidTimersProcessed=gidTimersProcessed, mmaDbActive=mmaDbActive, frProvMiState=frProvMiState, portInfoErrorLimit=portInfoErrorLimit, npInfoIPCommittedRate=npInfoIPCommittedRate, clc1InfoAdminControlBandwidthSize=clc1InfoAdminControlBandwidthSize, mcEndptInfo=mcEndptInfo, switchCellDgRejectEvents=switchCellDgRejectEvents, frProvMiNetMonitoredEvents=frProvMiNetMonitoredEvents, mcEndptUpstreamState=mcEndptUpstreamState, tsuDropEventEntry=tsuDropEventEntry, ndClientRegistration=ndClientRegistration, gidPortBW0=gidPortBW0, sUniCktAdminDestNode=sUniCktAdminDestNode, ndOutputCells=ndOutputCells, lightStreamBrPortPort=lightStreamBrPortPort, congestionAvoidance=congestionAvoidance, trunkPortStatIndex=trunkPortStatIndex, tsuCellDropLastVci=tsuCellDropLastVci, ms1InfoTable=ms1InfoTable, npInfoIPExcessRate=npInfoIPExcessRate, frCktInfoCallIDIncoming=frCktInfoCallIDIncoming, ms1InfoAdminControlBandwidthSize=ms1InfoAdminControlBandwidthSize, sUniCktCfgTable=sUniCktCfgTable, gidNbrDBSumListLength=gidNbrDBSumListLength, lsExperimental=lsExperimental, lsLcStatistics=lsLcStatistics, chassisEthernetIpAddr=chassisEthernetIpAddr, frCktAdminDestInsuredRate=frCktAdminDestInsuredRate, collectDbEntry=collectDbEntry, gidIOGroup=gidIOGroup, lsEdgeStatTable=lsEdgeStatTable, lsLcIntervalPeakCells=lsLcIntervalPeakCells, ffCktCfgTable=ffCktCfgTable, collectFinish=collectFinish, oc3InfoTable=oc3InfoTable, ffCktAdminSrcMaxBurst=ffCktAdminSrcMaxBurst, fsuDropEventPortIndex=fsuDropEventPortIndex, lightStreamVliPortCtlMode=lightStreamVliPortCtlMode, cardBoardType=cardBoardType, caMinIntervalPermitLimit=caMinIntervalPermitLimit, frCktAdminUserDataPerCell=frCktAdminUserDataPerCell, frProvMiUserMonitoredEvents=frProvMiUserMonitoredEvents, ls1InfoAdminOperTrigger=ls1InfoAdminOperTrigger, frameRelayDlciToSwDiscardCells=frameRelayDlciToSwDiscardCells, frameForwardFrSwCLP0Frames=frameForwardFrSwCLP0Frames, lsTrunkPortStatEntry=lsTrunkPortStatEntry, ls1InfoAdminXmitBaudRate=ls1InfoAdminXmitBaudRate, clc1InfoDataCellCapacity=clc1InfoDataCellCapacity, frProvMiNetRequestInterval=frProvMiNetRequestInterval, LightStreamDLCI=LightStreamDLCI, mmaLwmpTimeouts=mmaLwmpTimeouts, frCktInfoUpstreamState=frCktInfoUpstreamState, lightStreamBrFilterTokenValue=lightStreamBrFilterTokenValue, npInfoIPExcessBurst=npInfoIPExcessBurst, sUniCktInfoEntry=sUniCktInfoEntry, ffCktInfoLastAtmLocation=ffCktInfoLastAtmLocation, edgePort=edgePort, frCktEntry=frCktEntry, edgePortRcvL3XsumErrLastVci=edgePortRcvL3XsumErrLastVci, lightStreamBrFilterParmFilterPriority=lightStreamBrFilterParmFilterPriority, mmaTrapNumber=mmaTrapNumber, ndNbrState=ndNbrState, lwmaTrapOnOffState=lwmaTrapOnOffState, ms1InfoDataCellAvailable=ms1InfoDataCellAvailable, tcsPaddleTemp1=tcsPaddleTemp1, ffCktInfo=ffCktInfo, ffCktAdminSrcInsuredBurst=ffCktAdminSrcInsuredBurst, ffCktInfoDownstreamState=ffCktInfoDownstreamState, frameRelayDlciFrSwCLP1Frames=frameRelayDlciFrSwCLP1Frames, lsEdgePortToSwMsgLenTable=lsEdgePortToSwMsgLenTable, trunkPortXmtCells=trunkPortXmtCells, sUniCktInfoTable=sUniCktInfoTable, frCktOperSrcInsuredBurst=frCktOperSrcInsuredBurst, edgeCallSetupRetry=edgeCallSetupRetry, lsEdgeCpuWorkloadTable=lsEdgeCpuWorkloadTable, edgeMeteringFactor=edgeMeteringFactor, mmaConfigAuthor=mmaConfigAuthor, tcsReadyLight=tcsReadyLight, ndProcessID=ndProcessID, frProvMiAddressLen=frProvMiAddressLen, frCktAdminDestNode=frCktAdminDestNode, edgeCallSetupBackoff=edgeCallSetupBackoff, gidPortEntry=gidPortEntry, frCktAdminDestDlci=frCktAdminDestDlci, cardInfo=cardInfo, cardPID=cardPID, tcsFCPrimarySwitchA=tcsFCPrimarySwitchA, gidClientEventsTx=gidClientEventsTx, ms1InfoAdminScramble=ms1InfoAdminScramble, gidSyncNbrsLoading=gidSyncNbrsLoading, ms1InfoDataCellCapacity=ms1InfoDataCellCapacity, ls1InfoOperProtocol=ls1InfoOperProtocol, fsuQueueCellLength=fsuQueueCellLength, lsLcIntervalASDepth=lsLcIntervalASDepth, irRoutingPathGenFailedOther=irRoutingPathGenFailedOther, gidProcessID=gidProcessID, gidIpEntryAge=gidIpEntryAge, tsuPortErrL2UnconfigLastVci=tsuPortErrL2UnconfigLastVci, npInfoIfIndex=npInfoIfIndex, ffCktAdminDestInsuredRate=ffCktAdminDestInsuredRate, sUniCktAdminDestInsuredBurst=sUniCktAdminDestInsuredBurst, tsuDropEventWatermarkIndex=tsuDropEventWatermarkIndex, mmaNumNameNumber=mmaNumNameNumber, ms1InfoAdminProtocol=ms1InfoAdminProtocol, lsNpCpuWorkloadEvents=lsNpCpuWorkloadEvents, frProvMiMulticast=frProvMiMulticast, edgePortRcvOctets=edgePortRcvOctets, cardConfigRegister=cardConfigRegister, lsEdgeStatistics=lsEdgeStatistics, trunkPortRcvShortFrames=trunkPortRcvShortFrames, gidNbrVCI=gidNbrVCI, ms1InfoOperControlBandwidthSize=ms1InfoOperControlBandwidthSize, cellVciToSwCLP1Cells=cellVciToSwCLP1Cells, lwmaTable=lwmaTable, tcsPaddleShutdownTemp2=tcsPaddleShutdownTemp2, clc1InfoAdminOperTrigger=clc1InfoAdminOperTrigger, frameRelayDlciFrSwCLP1Cells=frameRelayDlciFrSwCLP1Cells, sUniCktAdminDestInsuredRate=sUniCktAdminDestInsuredRate, ndClientSubType=ndClientSubType, frameRelayDlciToSwCLP1Frames=frameRelayDlciToSwCLP1Frames, gidNbrEIA=gidNbrEIA, ls1InfoLcAutoEnable=ls1InfoLcAutoEnable, tcsSwitchCutoverSupport=tcsSwitchCutoverSupport, sUniCktAdminDestIfIndex=sUniCktAdminDestIfIndex, edgePortXmtSmplPktSize=edgePortXmtSmplPktSize, lsFrameForwardStatEntry=lsFrameForwardStatEntry, edgeStatTsuHoldQs=edgeStatTsuHoldQs, sUniCktAdminSrcMaxRate=sUniCktAdminSrcMaxRate, gidPortRemoteChassis=gidPortRemoteChassis, lsEdgeStatEntry=lsEdgeStatEntry, npInfoIPCommittedBurst=npInfoIPCommittedBurst, edgeToPortMsgLenPortIndex=edgeToPortMsgLenPortIndex, ndGeneralGroup=ndGeneralGroup, lcStatPortIndex=lcStatPortIndex, mcEndptLclCktid=mcEndptLclCktid, clc1InfoAdminDataBandwidthSize=clc1InfoAdminDataBandwidthSize, sUniCktAdminDestMaxBurst=sUniCktAdminDestMaxBurst, pvcTransPri=pvcTransPri, lwmaEntry=lwmaEntry, lsFsuFastDropTable=lsFsuFastDropTable, mmaConfigHost=mmaConfigHost, tcsFCPrimarySwitchB=tcsFCPrimarySwitchB, tcsSwitchConnectivityMask=tcsSwitchConnectivityMask, gidIpEntrySeqno=gidIpEntrySeqno, lsLcIntervalAvgPermits=lsLcIntervalAvgPermits, ffCktOperDestIfIndex=ffCktOperDestIfIndex, gidSyncNbrsExStart=gidSyncNbrsExStart, pidAdminStatus=pidAdminStatus, edgeToPortMsgLenMsgs=edgeToPortMsgLenMsgs, frProvMiNetInterfaceType=frProvMiNetInterfaceType, lightStreamVliVersion=lightStreamVliVersion, gidClientPathsGenerated=gidClientPathsGenerated, edgePortRcvSmplPktSize=edgePortRcvSmplPktSize, lsPortProtocols=lsPortProtocols, lsNpStatistics=lsNpStatistics, tcsIndex=tcsIndex, gidClientAnnouncementsRx=gidClientAnnouncementsRx, fsuXmtCellsPriorityIndex=fsuXmtCellsPriorityIndex, frCktAdminDestMaxBurst=frCktAdminDestMaxBurst, tcsScsiVoltage=tcsScsiVoltage, frProvMiUserErrorThreshold=frProvMiUserErrorThreshold, LightStreamFilterAction=LightStreamFilterAction, lightStreamInternet=lightStreamInternet, ffCktOperTransPri=ffCktOperTransPri)
mibBuilder.exportSymbols("LIGHTSTREAM-MIB", lightStreamBrPortDroppedBcastPkts=lightStreamBrPortDroppedBcastPkts, gidIOClientMsgBuffersFree=gidIOClientMsgBuffersFree, gidNbrHellosRx=gidNbrHellosRx, ndClientID=ndClientID, sUniCktSrcIfIndex=sUniCktSrcIfIndex, ms1InfoLinkUtilization=ms1InfoLinkUtilization, ndSwudStatsIndex=ndSwudStatsIndex, ndTimersProcessed=ndTimersProcessed, fsuPortXmtCellsEntry=fsuPortXmtCellsEntry, frCktInfoEntry=frCktInfoEntry, ls1InfoAdminProtocol=ls1InfoAdminProtocol, frameRelayDlciToSwCLP0Frames=frameRelayDlciToSwCLP0Frames, collectIndex=collectIndex, frCktSrcIfIndex=frCktSrcIfIndex, gidNbrSyncEvents=gidNbrSyncEvents, frCktInfoLastAtmErr=frCktInfoLastAtmErr, lightStreamBrPortDefaultAction=lightStreamBrPortDefaultAction, frameRelayDlciFrSwCLP0Cells=frameRelayDlciFrSwCLP0Cells, lsEdgePortStatEntry=lsEdgePortStatEntry, lsLcIntervalAvgBwAlloc=lsLcIntervalAvgBwAlloc, lsNpCpuWorkloadTable=lsNpCpuWorkloadTable, tcsSwitchFaultMaskB=tcsSwitchFaultMaskB, collectInterval=collectInterval, cardName=cardName, ls1InfoAdminRcvBaudRate=ls1InfoAdminRcvBaudRate, lightStreamProducts=lightStreamProducts, frCktInfoDlci=frCktInfoDlci)

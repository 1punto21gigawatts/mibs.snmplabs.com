#
# PySNMP MIB module DECATM-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/DECATM-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:37:24 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsIntersection, ValueRangeConstraint, SingleValueConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsIntersection", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsUnion")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
TimeTicks, ObjectIdentity, ModuleIdentity, IpAddress, Bits, MibScalar, MibTable, MibTableRow, MibTableColumn, Unsigned32, Integer32, Counter32, Gauge32, iso, enterprises, NotificationType, MibIdentifier, Counter64 = mibBuilder.importSymbols("SNMPv2-SMI", "TimeTicks", "ObjectIdentity", "ModuleIdentity", "IpAddress", "Bits", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Unsigned32", "Integer32", "Counter32", "Gauge32", "iso", "enterprises", "NotificationType", "MibIdentifier", "Counter64")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
dec = MibIdentifier((1, 3, 6, 1, 4, 1, 36))
ema = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2))
sysobjid = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 15))
atmSwitch = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 15, 14))
atmSwitch1 = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 15, 14, 1))
atmversion1 = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 15, 14, 1, 1))
atmSwitch2 = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 15, 14, 2))
atmversion2 = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 15, 14, 2, 1))
decMIBextension = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18))
atmExpand = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 17))
ad = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 1))
dxatm = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 2))
adUID = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 1, 1), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: adUID.setStatus('mandatory')
if mibBuilder.loadTexts: adUID.setDescription('48 bit User Identification number assigned to the ATM device.')
adEscapeSupport = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("supported", 1), ("none", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: adEscapeSupport.setStatus('mandatory')
if mibBuilder.loadTexts: adEscapeSupport.setDescription('Indicates if the VCI 16 can be used to carry configuration management traffic with a escape sequence 0x55 (instead of SNMP ASN.1 header).')
adFlowMaster = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("supported", 1), ("none", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: adFlowMaster.setStatus('mandatory')
if mibBuilder.loadTexts: adFlowMaster.setDescription('Indicates if FLOWmaster flow control is supported on this device.')
adRVC = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("supported", 1), ("none", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: adRVC.setStatus('mandatory')
if mibBuilder.loadTexts: adRVC.setDescription('Indicates if Resilient Virtual Circuits (RVCs) are supported on this device.')
adObjectId = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: adObjectId.setStatus('mandatory')
if mibBuilder.loadTexts: adObjectId.setDescription(' Switch, none, unknown.')
adObjectSubId = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: adObjectSubId.setStatus('mandatory')
if mibBuilder.loadTexts: adObjectSubId.setDescription('an3, an2, none, unknown.')
adNumPorts = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: adNumPorts.setStatus('mandatory')
if mibBuilder.loadTexts: adNumPorts.setDescription('Indicates number of ATM ports on this device. adNumLinks is the number of rows in the adPortTable.')
adPortTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 1, 8), )
if mibBuilder.loadTexts: adPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: adPortTable.setDescription('A list of the link attributes on a per port basis. The number of entries is given in adNumPorts.')
adPortTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 1, 8, 1), ).setIndexNames((0, "DECATM-MIB", "adpPortIndex"))
if mibBuilder.loadTexts: adPortTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: adPortTableEntry.setDescription('Contains the characteristics of ATM ports.')
adpPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 1, 8, 1, 1), Integer32())
if mibBuilder.loadTexts: adpPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: adpPortIndex.setDescription('A unique value which identifies the ATM Port Number. The value 0 has a special meaning and identifies the local port')
adpType = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 1, 8, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: adpType.setStatus('mandatory')
if mibBuilder.loadTexts: adpType.setDescription('Type: qlv1, none, unknown.')
adpSubType = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 1, 8, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: adpSubType.setStatus('mandatory')
if mibBuilder.loadTexts: adpSubType.setDescription('Subtye: ver0, none, unknown.')
adpFlowMaster = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 1, 8, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("none", 1), ("supported", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: adpFlowMaster.setStatus('mandatory')
if mibBuilder.loadTexts: adpFlowMaster.setDescription('Indicates if FLOWmaster flow control is supported on this device.')
adpCreditResync = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 1, 8, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("none", 2), ("an2Style", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: adpCreditResync.setStatus('mandatory')
if mibBuilder.loadTexts: adpCreditResync.setDescription('The type of the credit resynchronization used by the flow control on this link.')
adpResyncVCI = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 1, 8, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: adpResyncVCI.setStatus('mandatory')
if mibBuilder.loadTexts: adpResyncVCI.setDescription('The VCI used to send credit resynchronization requests and response cells.')
adpReceiveBuffers = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 1, 8, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: adpReceiveBuffers.setStatus('mandatory')
if mibBuilder.loadTexts: adpReceiveBuffers.setDescription('The amount of buffering available on this port in cells.')
adpPVCMin = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 1, 8, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: adpPVCMin.setStatus('mandatory')
if mibBuilder.loadTexts: adpPVCMin.setDescription('The lowest VCI value which can be assigned for PVCs.')
adpPVCMax = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 1, 8, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: adpPVCMax.setStatus('mandatory')
if mibBuilder.loadTexts: adpPVCMax.setDescription('The highest VCI value which can be assigned for PVCs.')
adpSVCMin = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 1, 8, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: adpSVCMin.setStatus('mandatory')
if mibBuilder.loadTexts: adpSVCMin.setDescription('The lowest VCI value which can be assigned for SVCs.')
adpSVCMax = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 1, 8, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: adpSVCMax.setStatus('mandatory')
if mibBuilder.loadTexts: adpSVCMax.setDescription('The highest VCI value which can be assigned for SVCs.')
adpRVCMin = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 1, 8, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: adpRVCMin.setStatus('mandatory')
if mibBuilder.loadTexts: adpRVCMin.setDescription('The lowest VCI value which can be assigned for RVCs.')
adpRVCMax = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 1, 8, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: adpRVCMax.setStatus('mandatory')
if mibBuilder.loadTexts: adpRVCMax.setDescription('The highest VCI value which can be assigned for RVCs.')
adpBroadcastVCI = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 1, 8, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: adpBroadcastVCI.setStatus('mandatory')
if mibBuilder.loadTexts: adpBroadcastVCI.setDescription('The VCI used for broadcast on this port. The value of 2 will be used to be UNI compliant.')
adpArpVCI = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 1, 8, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: adpArpVCI.setStatus('mandatory')
if mibBuilder.loadTexts: adpArpVCI.setDescription('The VCI used to resolve addresses (ARP broadcasts). adpArpVCI will have a value of 2 in UNI compliant implementations.')
adpHomeVCI = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 1, 8, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: adpHomeVCI.setStatus('mandatory')
if mibBuilder.loadTexts: adpHomeVCI.setDescription('The Home VCI .')
adpMaxReceiveBufferCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 1, 8, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: adpMaxReceiveBufferCounter.setStatus('mandatory')
if mibBuilder.loadTexts: adpMaxReceiveBufferCounter.setDescription(' Although the transmitter can allocate the adpReciveBuffers however it wants to VCs, it will not allocate more than adpMaxReciveBufferCounter to any individual VC')
adpUsedReceiveBuffers = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 1, 8, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: adpUsedReceiveBuffers.setStatus('mandatory')
if mibBuilder.loadTexts: adpUsedReceiveBuffers.setDescription('The current number of of free buffers for the link')
adpRemoteFlowMaster = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 1, 8, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("supported", 1), ("none", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: adpRemoteFlowMaster.setStatus('mandatory')
if mibBuilder.loadTexts: adpRemoteFlowMaster.setDescription('Indicates if FLOWmaster flow control is supported on this device.')
adpOutputBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 1, 8, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: adpOutputBandwidth.setStatus('mandatory')
if mibBuilder.loadTexts: adpOutputBandwidth.setDescription('Total CBR output bandwidth in cells per second')
adpAvailableOutputBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 1, 8, 1, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: adpAvailableOutputBandwidth.setStatus('mandatory')
if mibBuilder.loadTexts: adpAvailableOutputBandwidth.setDescription('Available CBR output bandwidth in cells per second')
dxatmPvcTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 2, 1), )
if mibBuilder.loadTexts: dxatmPvcTable.setStatus('mandatory')
if mibBuilder.loadTexts: dxatmPvcTable.setDescription('The point-to-point ATM PVC Cross Connect table. A bi-directional PVC cross-connect which cross-connects two end points (i.e., VCLs) is modeled as one entry in this table.')
dxatmPvcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 2, 1, 1), ).setIndexNames((0, "DECATM-MIB", "dxatmPvcLowIfIndex"), (0, "DECATM-MIB", "dxatmPvcLowVpi"), (0, "DECATM-MIB", "dxatmPvcLowVci"), (0, "DECATM-MIB", "dxatmPvcHighIfIndex"), (0, "DECATM-MIB", "dxatmPvcHighVpi"), (0, "DECATM-MIB", "dxatmPvcHighVci"))
if mibBuilder.loadTexts: dxatmPvcEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dxatmPvcEntry.setDescription(' similar to atm mib description')
dxatmPvcLowIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 2, 1, 1, 1), Integer32())
if mibBuilder.loadTexts: dxatmPvcLowIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: dxatmPvcLowIfIndex.setDescription("The value of this object is equal to MIB II's ifIndex value of the ATM interface port for this cross-connect. The term low implies that this ATM interface has the numerically lower ifIndex value than the other ATM interface identified in the same dxatmPvcEntry.")
dxatmPvcLowVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095)))
if mibBuilder.loadTexts: dxatmPvcLowVpi.setStatus('mandatory')
if mibBuilder.loadTexts: dxatmPvcLowVpi.setDescription('The value of this object is equal to the VPI value at the ATM interface associated with the cross-connect that is identified by dxatmPvcLowIfIndex. The VPI value cannot exceed the number supported by the atmInterfaceMaxVpiBits at the low ATM interface port.')
dxatmPvcLowVci = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095)))
if mibBuilder.loadTexts: dxatmPvcLowVci.setStatus('mandatory')
if mibBuilder.loadTexts: dxatmPvcLowVci.setDescription('The value of this object is equal to the VCI value at the ATM interface associated with the cross-connect that is identified by dxatmPvcLowIfIndex. The VPI value cannot exceed the number supported by the atmInterfaceMaxVciBits at the low ATM interface port.')
dxatmPvcHighIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 2, 1, 1, 4), Integer32())
if mibBuilder.loadTexts: dxatmPvcHighIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: dxatmPvcHighIfIndex.setDescription("The value of this object is equal to MIB II's ifIndex value of the ATM interface port for this cross-connect. The term high implies that this ATM interface has the numerically higher ifIndex value than the other ATM interface identified in the same dxatmPvcEntry.")
dxatmPvcHighVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095)))
if mibBuilder.loadTexts: dxatmPvcHighVpi.setStatus('mandatory')
if mibBuilder.loadTexts: dxatmPvcHighVpi.setDescription('The value of this object is equal to the VPI value at the ATM interface associated with the cross-connect that is identified by dxatmPvcHighIfIndex. The VPI value cannot exceed the number supported by the atmInterfaceMaxVpiBits at the high ATM interface port.')
dxatmPvcHighVci = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095)))
if mibBuilder.loadTexts: dxatmPvcHighVci.setStatus('mandatory')
if mibBuilder.loadTexts: dxatmPvcHighVci.setDescription('The value of this object is equal to the VCI value at the ATM interface associated with the cross-connect that is identified by dxatmPvcHighIfIndex. The VPI value cannot exceed the number supported by the atmInterfaceMaxVciBits at the high ATM interface port.')
dxatmPvcAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dxatmPvcAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: dxatmPvcAdminStatus.setDescription('The value of this object identifies the desired administrative status of this bi-directional cross-connect. The up and down states indicate that the traffic flow is enabled and disabled respectively on this VP cross-connect.')
dxatmPvcL2HOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("unknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dxatmPvcL2HOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: dxatmPvcL2HOperStatus.setDescription('The value of this object identifies the current operational status of the cross-connect in one direction; (i.e., from the low to high direction). The up and down states indicate that this cross-connect from low to high direction is operational or not operational respectively. The unknown state indicates that the state of it cannot be determined.')
dxatmPvcH2LOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("unknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dxatmPvcH2LOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: dxatmPvcH2LOperStatus.setDescription('The value of this object identifies the current operational status of the cross-connect in one direction; (i.e., from the high to low direction). The up and down states indicate that this cross-connect from high to low direction is operational or not operational respectively. The unknown state indicates that the state of it cannot be determined.')
dxatmPvcL2HFCStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dxatmPvcL2HFCStatus.setStatus('mandatory')
if mibBuilder.loadTexts: dxatmPvcL2HFCStatus.setDescription('The value of this object identifies the current status of the flow control mecahnism across cross-connect in one direction; (i.e., from the low to high direction). The enabled and disabled states indicate that this flow control from low to high direction is operational or not operational respectively. The notApplicable state indicates that traffic in this direction is not subject to flow control.')
dxatmPvcH2LFCStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 2, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dxatmPvcH2LFCStatus.setStatus('mandatory')
if mibBuilder.loadTexts: dxatmPvcH2LFCStatus.setDescription('The value of this object identifies the current status of the flow control mecahnism across cross-connect in one direction; (i.e., from the high to low direction). The enabled and disabled states indicate that this flow control from high to low direction is operational or not operational respectively. The notApplicable state indicates that traffic in this direction is not subject to flow control.')
dxatmPvcL2HTrafficDescriptorType = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 2, 1, 1, 12), ObjectIdentifier()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dxatmPvcL2HTrafficDescriptorType.setStatus('mandatory')
if mibBuilder.loadTexts: dxatmPvcL2HTrafficDescriptorType.setDescription('The type of traffic management, aplicable to the L2H direction of this PVC. The type may indicate none, or a type with one or more parameters. These parameters are specified as a parameter vector, in the corresponding instances of the objects: dxatmPvcL2HTrafficDescriptorParam1, dxatmPvcL2HTrafficDescriptorParam2, dxatmPvcL2HTrafficDescriptorParam3, dxatmPvcL2HTrafficDescriptorParam4, and dxatmPvcL2HTrafficDescriptorParam5.')
dxatmPvcL2HTrafficDescriptorParam1 = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 2, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dxatmPvcL2HTrafficDescriptorParam1.setStatus('mandatory')
if mibBuilder.loadTexts: dxatmPvcL2HTrafficDescriptorParam1.setDescription('The first parameter of the L2H parameter vector for this PVC, used according to the value of dxatmPvcL2HTrafficDescriptorType.')
dxatmPvcL2HTrafficDescriptorParam2 = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 2, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dxatmPvcL2HTrafficDescriptorParam2.setStatus('mandatory')
if mibBuilder.loadTexts: dxatmPvcL2HTrafficDescriptorParam2.setDescription('The second parameter of the L2H parameter vector for this PVC, used according to the value of dxatmPvcL2HTrafficDescriptorType.')
dxatmPvcL2HTrafficDescriptorParam3 = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 2, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dxatmPvcL2HTrafficDescriptorParam3.setStatus('mandatory')
if mibBuilder.loadTexts: dxatmPvcL2HTrafficDescriptorParam3.setDescription('The third parameter of the L2H parameter vector for this PVC, used according to the value of dxatmPvcL2HTrafficDescriptorType.')
dxatmPvcL2HTrafficDescriptorParam4 = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 2, 1, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dxatmPvcL2HTrafficDescriptorParam4.setStatus('mandatory')
if mibBuilder.loadTexts: dxatmPvcL2HTrafficDescriptorParam4.setDescription('The fourth parameter of the L2H parameter vector for this PVC, used according to the value of dxatmPvcL2HTrafficDescriptorType.')
dxatmPvcL2HTrafficDescriptorParam5 = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 2, 1, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dxatmPvcL2HTrafficDescriptorParam5.setStatus('mandatory')
if mibBuilder.loadTexts: dxatmPvcL2HTrafficDescriptorParam5.setDescription('The fifth parameter of the L2H parameter vector for this PVC, used according to the value of dxatmPvcL2HTrafficDescriptorType.')
dxatmPvcH2LTrafficDescriptorType = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 2, 1, 1, 18), ObjectIdentifier()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dxatmPvcH2LTrafficDescriptorType.setStatus('mandatory')
if mibBuilder.loadTexts: dxatmPvcH2LTrafficDescriptorType.setDescription('The type of traffic management, aplicable to the H2L direction of this PVC. The type may indicate none, or a type with one or more parameters. These parameters are specified as a parameter vector, in the corresponding instances of the objects: dxatmPvcH2LTrafficDescriptorParam1, dxatmPvcH2LTrafficDescriptorParam2, dxatmPvcH2LTrafficDescriptorParam3, dxatmPvcH2LTrafficDescriptorParam4, and dxatmPvcH2LTrafficDescriptorParam5.')
dxatmPvcH2LTrafficDescriptorParam1 = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 2, 1, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dxatmPvcH2LTrafficDescriptorParam1.setStatus('mandatory')
if mibBuilder.loadTexts: dxatmPvcH2LTrafficDescriptorParam1.setDescription('The first parameter of the H2L parameter vector for this PVC, used according to the value of dxatmPvcH2LTrafficDescriptorType.')
dxatmPvcH2LTrafficDescriptorParam2 = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 2, 1, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dxatmPvcH2LTrafficDescriptorParam2.setStatus('mandatory')
if mibBuilder.loadTexts: dxatmPvcH2LTrafficDescriptorParam2.setDescription('The second parameter of the H2L parameter vector for this PVC, used according to the value of dxatmPvcH2LTrafficDescriptorType.')
dxatmPvcH2LTrafficDescriptorParam3 = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 2, 1, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dxatmPvcH2LTrafficDescriptorParam3.setStatus('mandatory')
if mibBuilder.loadTexts: dxatmPvcH2LTrafficDescriptorParam3.setDescription('The third parameter of the H2L parameter vector for this PVC, used according to the value of dxatmPvcH2LTrafficDescriptorType.')
dxatmPvcH2LTrafficDescriptorParam4 = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 2, 1, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dxatmPvcH2LTrafficDescriptorParam4.setStatus('mandatory')
if mibBuilder.loadTexts: dxatmPvcH2LTrafficDescriptorParam4.setDescription('The fourth parameter of the H2L parameter vector for this PVC, used according to the value of dxatmPvcH2LTrafficDescriptorType.')
dxatmPvcH2LTrafficDescriptorParam5 = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 2, 1, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dxatmPvcH2LTrafficDescriptorParam5.setStatus('mandatory')
if mibBuilder.loadTexts: dxatmPvcH2LTrafficDescriptorParam5.setDescription('The fifth parameter of the H2L parameter vector for this PVC, used according to the value of dxatmPvcH2LTrafficDescriptorType.')
dxatmPvcL2HQoSClass = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 2, 1, 1, 24), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dxatmPvcL2HQoSClass.setStatus('mandatory')
if mibBuilder.loadTexts: dxatmPvcL2HQoSClass.setDescription('The QoS Class, as defined in section 4 of Apendix A, for the L2H direction of this PVC connection at the local UNI.')
dxatmPvcH2LQoSClass = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 2, 1, 1, 25), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dxatmPvcH2LQoSClass.setStatus('mandatory')
if mibBuilder.loadTexts: dxatmPvcH2LQoSClass.setDescription('The QoS Class, as defined in section 4 of Apendix A, for the H2L direction of this PVC connection at the local UNI.')
dxatmPvcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 2, 1, 1, 26), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dxatmPvcRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: dxatmPvcRowStatus.setDescription('This object is used to create a new row or modify or delete an existing row in this table.')
dxatmPvcMpTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 2, 2), )
if mibBuilder.loadTexts: dxatmPvcMpTable.setStatus('mandatory')
if mibBuilder.loadTexts: dxatmPvcMpTable.setDescription('The ATM Multipoint PVC Cross Connect table. A point-to-multipoint PVC cross-connect is modeled as a set of entries in this table having a common root and multiple leaves.')
dxatmPvcMpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 2, 2, 1), ).setIndexNames((0, "DECATM-MIB", "dxatmPvcMpRootIfIndex"), (0, "DECATM-MIB", "dxatmPvcMpRootVpi"), (0, "DECATM-MIB", "dxatmPvcMpRootVci"), (0, "DECATM-MIB", "dxatmPvcMpLeafIfIndex"), (0, "DECATM-MIB", "dxatmPvcMpLeafVpi"), (0, "DECATM-MIB", "dxatmPvcMpLeafVci"))
if mibBuilder.loadTexts: dxatmPvcMpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dxatmPvcMpEntry.setDescription(' similar to atm mib description')
dxatmPvcMpRootIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 2, 2, 1, 1), Integer32())
if mibBuilder.loadTexts: dxatmPvcMpRootIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: dxatmPvcMpRootIfIndex.setDescription("The value of this object is equal to MIB II's ifIndex value of the ATM interface port for the root end of the multipoint cross-connect.")
dxatmPvcMpRootVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095)))
if mibBuilder.loadTexts: dxatmPvcMpRootVpi.setStatus('mandatory')
if mibBuilder.loadTexts: dxatmPvcMpRootVpi.setDescription('The value of this object is equal to the VPI value at the ATM interface associated with the cross-connect that is identified by dxatmPvcMpRootIfIndex. The VPI value cannot exceed the number supported by the atmInterfaceMaxVpiBits at the Root ATM interface port.')
dxatmPvcMpRootVci = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095)))
if mibBuilder.loadTexts: dxatmPvcMpRootVci.setStatus('mandatory')
if mibBuilder.loadTexts: dxatmPvcMpRootVci.setDescription('The value of this object is equal to the VCI value at the ATM interface associated with the cross-connect that is identified by dxatmPvcMpRootIfIndex. The VCI value cannot exceed the number supported by the atmInterfaceMaxVciBits at the Root ATM interface port.')
dxatmPvcMpLeafIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 2, 2, 1, 4), Integer32())
if mibBuilder.loadTexts: dxatmPvcMpLeafIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: dxatmPvcMpLeafIfIndex.setDescription("The value of this object is equal to MIB II's ifIndex value of the ATM interface port for the leaf end of the multipoint cross-connect.")
dxatmPvcMpLeafVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095)))
if mibBuilder.loadTexts: dxatmPvcMpLeafVpi.setStatus('mandatory')
if mibBuilder.loadTexts: dxatmPvcMpLeafVpi.setDescription('The value of this object is equal to the VPI value at the ATM interface associated with the cross-connect that is identified by dxatmPvcMpLeafIfIndex. The VPI value cannot exceed the number supported by the atmInterfaceMaxVpiBits at the Leaf ATM interface port.')
dxatmPvcMpLeafVci = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 2, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095)))
if mibBuilder.loadTexts: dxatmPvcMpLeafVci.setStatus('mandatory')
if mibBuilder.loadTexts: dxatmPvcMpLeafVci.setDescription('The value of this object is equal to the VCI value at the ATM interface associated with the cross-connect that is identified by dxatmPvcMpLeafIfIndex. The VPI value cannot exceed the number supported by the atmInterfaceMaxVciBits at the Leaf ATM interface port.')
dxatmPvcMpAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 2, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dxatmPvcMpAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: dxatmPvcMpAdminStatus.setDescription('The value of this object identifies the desired administrative status of this point-to-multipoint cross-connect branch. The up and down states indicate that the traffic is enabled and disabled respectively on this branch of the cross-connect.')
dxatmPvcMpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 2, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("unknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dxatmPvcMpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: dxatmPvcMpOperStatus.setDescription('The value of this object identifies the current operational status of this branch of the point-to- multipoint cross-connect. The up and down states indicate that this branch of cross-connect is operational or not operational respectively. The unknown state indicates that the state of it cannot be determined.')
dxatmPvcMpFCStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 2, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dxatmPvcMpFCStatus.setStatus('mandatory')
if mibBuilder.loadTexts: dxatmPvcMpFCStatus.setDescription('The value of this object identifies the current status of the flow control mecahnism across PM. The enabled and disabled states indicate that this flow control is operational or not operational respectively. The notApplicable state indicates that traffic is not subject to flow control.')
dxatmPvcMpTrafficDescriptorType = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 2, 2, 1, 10), ObjectIdentifier()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dxatmPvcMpTrafficDescriptorType.setStatus('mandatory')
if mibBuilder.loadTexts: dxatmPvcMpTrafficDescriptorType.setDescription('The type of traffic management, aplicable to the transmit from Root to Leaf. The type may indicate none, or a type with one or more parameters. These parameters are specified as a parameter vector, in the corresponding instances of the objects: dxatmPvcMpTrafficDescriptorParam1, dxatmPvcMpTrafficDescriptorParam2, dxatmPvcMpTrafficDescriptorParam3, dxatmPvcMpTrafficDescriptorParam4, and dxatmPvcMpTrafficDescriptorParam5.')
dxatmPvcMpTrafficDescriptorParam1 = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 2, 2, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dxatmPvcMpTrafficDescriptorParam1.setStatus('mandatory')
if mibBuilder.loadTexts: dxatmPvcMpTrafficDescriptorParam1.setDescription('The first parameter of the parameter vector for this PvcMp, used according to the value of dxatmPvcMpTrafficDescriptorType.')
dxatmPvcMpTrafficDescriptorParam2 = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 2, 2, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dxatmPvcMpTrafficDescriptorParam2.setStatus('mandatory')
if mibBuilder.loadTexts: dxatmPvcMpTrafficDescriptorParam2.setDescription('The second parameter of the parameter vector for this PvcMp, used according to the value of dxatmPvcMpTrafficDescriptorType.')
dxatmPvcMpTrafficDescriptorParam3 = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 2, 2, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dxatmPvcMpTrafficDescriptorParam3.setStatus('mandatory')
if mibBuilder.loadTexts: dxatmPvcMpTrafficDescriptorParam3.setDescription('The third parameter of the parameter vector for this PvcMp, used according to the value of dxatmPvcMpTrafficDescriptorType.')
dxatmPvcMpTrafficDescriptorParam4 = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 2, 2, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dxatmPvcMpTrafficDescriptorParam4.setStatus('mandatory')
if mibBuilder.loadTexts: dxatmPvcMpTrafficDescriptorParam4.setDescription('The fifth parameter of the parameter vector for this PvcMp, used according to the value of dxatmPvcMpTrafficDescriptorType.')
dxatmPvcMpTrafficDescriptorParam5 = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 2, 2, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dxatmPvcMpTrafficDescriptorParam5.setStatus('mandatory')
if mibBuilder.loadTexts: dxatmPvcMpTrafficDescriptorParam5.setDescription('The fifth parameter of the parameter vector for this PvcMp, used according to the value of dxatmPvcMpXmtTrafficDescriptorType.')
dxatmPvcMpQoSClass = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 2, 2, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dxatmPvcMpQoSClass.setStatus('mandatory')
if mibBuilder.loadTexts: dxatmPvcMpQoSClass.setDescription('The QoS Class, as defined in section 4 of Apendix A, of this PvcMp connection at the local UNI.')
dxatmPvcMpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 2, 2, 1, 17), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dxatmPvcMpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: dxatmPvcMpRowStatus.setDescription('This object is used to create a new row or modify or delete an existing row in this table.')
dxatmVirtualPathObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 2, 3))
dxatmVpModeTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 2, 3, 1), )
if mibBuilder.loadTexts: dxatmVpModeTable.setStatus('mandatory')
if mibBuilder.loadTexts: dxatmVpModeTable.setDescription('A table describing the desired and actual virtual path mode of each line card.')
dxatmVpModeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 2, 3, 1, 1), ).setIndexNames((0, "DECATM-MIB", "dxatmVpModeSlot"))
if mibBuilder.loadTexts: dxatmVpModeEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dxatmVpModeEntry.setDescription('Each entry describes one line card.')
dxatmVpModeSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 2, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dxatmVpModeSlot.setStatus('mandatory')
if mibBuilder.loadTexts: dxatmVpModeSlot.setDescription('The front-panel slot number for the line card whose virtual path mode is to be examined or modified.')
dxatmVpModeDesired = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 2, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dxatmVpModeDesired.setStatus('mandatory')
if mibBuilder.loadTexts: dxatmVpModeDesired.setDescription("The desired virtual path mode for the line card in this slot. On a Version 2.0 line card, on (1) lets you use virtual path terminations - but restricts you to the use of one port. off(2) lets you use all four mod-PHY ports - but only with VPI zero. Line cards which can't support VPs or which can support them without such tradeoffs will ignore this setting.")
dxatmVpModeActual = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 2, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unknown", 1), ("emptySlot", 2), ("noVpSupport", 3), ("vpModeOn", 4), ("vpModeOff", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dxatmVpModeActual.setStatus('mandatory')
if mibBuilder.loadTexts: dxatmVpModeActual.setDescription('The actual virtual path mode for this slot.')
dxatmVpTermTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 2, 3, 2), )
if mibBuilder.loadTexts: dxatmVpTermTable.setStatus('mandatory')
if mibBuilder.loadTexts: dxatmVpTermTable.setDescription('The ATM permanent virtual path termination table.')
dxatmVpTermEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 2, 3, 2, 1), ).setIndexNames((0, "DECATM-MIB", "dxatmVpTermIfIndex"), (0, "DECATM-MIB", "dxatmVpTermVpi"))
if mibBuilder.loadTexts: dxatmVpTermEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dxatmVpTermEntry.setDescription('Each entry describes one virtual path termination.')
dxatmVpTermIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 2, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dxatmVpTermIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: dxatmVpTermIfIndex.setDescription("The value of the MIB II ifIndex object for the 'atm' port on which the virtual path is located.")
dxatmVpTermVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 2, 3, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dxatmVpTermVpi.setStatus('mandatory')
if mibBuilder.loadTexts: dxatmVpTermVpi.setDescription('The virtual path index.')
dxatmVpTermAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 2, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dxatmVpTermAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: dxatmVpTermAdminStatus.setDescription('The desired state of this virtual path termination. The up and down states indicate respectively that the traffic flow is enabled and disabled.')
dxatmVpTermOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 2, 3, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("unknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dxatmVpTermOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: dxatmVpTermOperStatus.setDescription('The current operational state of the virtual path connection. The up and down states indicate respectively that this VP is operational or not operational. The unknown state indicates that the state of it cannot be determined.')
dxatmVpTermPcr = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 2, 3, 2, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dxatmVpTermPcr.setStatus('mandatory')
if mibBuilder.loadTexts: dxatmVpTermPcr.setDescription('The peak cell rate for the virtual path, in cells per second. If this is set to 0 (or left unset) when the VP is created, the peak cell rate will default to the link bandwidth.')
dxatmVpTermScr = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 2, 3, 2, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dxatmVpTermScr.setStatus('mandatory')
if mibBuilder.loadTexts: dxatmVpTermScr.setDescription('The sustained cell rate for the virtual path, in cells per second.')
dxatmVpTermMbs = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 2, 3, 2, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dxatmVpTermMbs.setStatus('mandatory')
if mibBuilder.loadTexts: dxatmVpTermMbs.setDescription('The maximum burst size.')
dxatmVpTermRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 17, 2, 3, 2, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dxatmVpTermRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: dxatmVpTermRowStatus.setDescription('This object is used to create a new row, or modify or delete an existing row in this table.')
mibBuilder.exportSymbols("DECATM-MIB", dxatmVpTermOperStatus=dxatmVpTermOperStatus, dxatmPvcEntry=dxatmPvcEntry, dxatmPvcH2LQoSClass=dxatmPvcH2LQoSClass, decMIBextension=decMIBextension, dxatm=dxatm, dxatmPvcMpTrafficDescriptorParam4=dxatmPvcMpTrafficDescriptorParam4, dxatmVpTermScr=dxatmVpTermScr, dxatmPvcL2HQoSClass=dxatmPvcL2HQoSClass, adpSVCMax=adpSVCMax, adpHomeVCI=adpHomeVCI, dxatmVpModeEntry=dxatmVpModeEntry, adEscapeSupport=adEscapeSupport, dxatmPvcH2LTrafficDescriptorType=dxatmPvcH2LTrafficDescriptorType, adObjectSubId=adObjectSubId, dxatmPvcMpTrafficDescriptorParam1=dxatmPvcMpTrafficDescriptorParam1, dxatmVpModeSlot=dxatmVpModeSlot, ema=ema, dxatmPvcH2LTrafficDescriptorParam5=dxatmPvcH2LTrafficDescriptorParam5, dxatmPvcMpRootVci=dxatmPvcMpRootVci, dxatmVpModeTable=dxatmVpModeTable, dxatmPvcHighVpi=dxatmPvcHighVpi, atmSwitch2=atmSwitch2, adPortTable=adPortTable, dxatmPvcL2HTrafficDescriptorParam2=dxatmPvcL2HTrafficDescriptorParam2, dxatmPvcLowVci=dxatmPvcLowVci, dxatmPvcH2LFCStatus=dxatmPvcH2LFCStatus, adpPVCMin=adpPVCMin, dxatmPvcL2HFCStatus=dxatmPvcL2HFCStatus, adPortTableEntry=adPortTableEntry, dxatmPvcMpLeafVci=dxatmPvcMpLeafVci, atmversion2=atmversion2, dxatmPvcMpAdminStatus=dxatmPvcMpAdminStatus, dxatmPvcL2HOperStatus=dxatmPvcL2HOperStatus, adpBroadcastVCI=adpBroadcastVCI, dxatmVpTermPcr=dxatmVpTermPcr, dxatmPvcH2LTrafficDescriptorParam3=dxatmPvcH2LTrafficDescriptorParam3, ad=ad, dxatmPvcRowStatus=dxatmPvcRowStatus, dxatmPvcMpOperStatus=dxatmPvcMpOperStatus, dxatmPvcLowVpi=dxatmPvcLowVpi, adUID=adUID, adpPortIndex=adpPortIndex, dxatmPvcMpTrafficDescriptorParam3=dxatmPvcMpTrafficDescriptorParam3, dxatmPvcH2LTrafficDescriptorParam1=dxatmPvcH2LTrafficDescriptorParam1, atmExpand=atmExpand, dxatmPvcMpEntry=dxatmPvcMpEntry, adpRVCMin=adpRVCMin, dxatmPvcMpRootVpi=dxatmPvcMpRootVpi, adpPVCMax=adpPVCMax, dxatmPvcL2HTrafficDescriptorType=dxatmPvcL2HTrafficDescriptorType, dxatmVpTermVpi=dxatmVpTermVpi, dxatmPvcTable=dxatmPvcTable, dxatmPvcH2LOperStatus=dxatmPvcH2LOperStatus, dxatmPvcMpTrafficDescriptorType=dxatmPvcMpTrafficDescriptorType, dxatmPvcL2HTrafficDescriptorParam4=dxatmPvcL2HTrafficDescriptorParam4, adpMaxReceiveBufferCounter=adpMaxReceiveBufferCounter, dxatmVpTermAdminStatus=dxatmVpTermAdminStatus, dxatmPvcHighIfIndex=dxatmPvcHighIfIndex, dxatmVirtualPathObjects=dxatmVirtualPathObjects, dec=dec, adpSubType=adpSubType, sysobjid=sysobjid, adpRemoteFlowMaster=adpRemoteFlowMaster, dxatmPvcLowIfIndex=dxatmPvcLowIfIndex, dxatmPvcH2LTrafficDescriptorParam2=dxatmPvcH2LTrafficDescriptorParam2, adpCreditResync=adpCreditResync, dxatmPvcMpTrafficDescriptorParam5=dxatmPvcMpTrafficDescriptorParam5, adpArpVCI=adpArpVCI, dxatmPvcH2LTrafficDescriptorParam4=dxatmPvcH2LTrafficDescriptorParam4, adObjectId=adObjectId, adpAvailableOutputBandwidth=adpAvailableOutputBandwidth, dxatmPvcHighVci=dxatmPvcHighVci, dxatmVpTermEntry=dxatmVpTermEntry, dxatmPvcAdminStatus=dxatmPvcAdminStatus, adNumPorts=adNumPorts, adpReceiveBuffers=adpReceiveBuffers, adRVC=adRVC, adpType=adpType, dxatmVpTermMbs=dxatmVpTermMbs, dxatmPvcMpFCStatus=dxatmPvcMpFCStatus, adpResyncVCI=adpResyncVCI, adpRVCMax=adpRVCMax, dxatmPvcL2HTrafficDescriptorParam1=dxatmPvcL2HTrafficDescriptorParam1, dxatmPvcMpRowStatus=dxatmPvcMpRowStatus, dxatmVpTermTable=dxatmVpTermTable, dxatmPvcMpTrafficDescriptorParam2=dxatmPvcMpTrafficDescriptorParam2, adpUsedReceiveBuffers=adpUsedReceiveBuffers, atmversion1=atmversion1, dxatmPvcMpTable=dxatmPvcMpTable, atmSwitch1=atmSwitch1, dxatmPvcL2HTrafficDescriptorParam3=dxatmPvcL2HTrafficDescriptorParam3, dxatmPvcMpRootIfIndex=dxatmPvcMpRootIfIndex, dxatmPvcMpLeafVpi=dxatmPvcMpLeafVpi, adpFlowMaster=adpFlowMaster, adpSVCMin=adpSVCMin, dxatmVpTermIfIndex=dxatmVpTermIfIndex, dxatmPvcMpQoSClass=dxatmPvcMpQoSClass, dxatmPvcMpLeafIfIndex=dxatmPvcMpLeafIfIndex, dxatmPvcL2HTrafficDescriptorParam5=dxatmPvcL2HTrafficDescriptorParam5, dxatmVpTermRowStatus=dxatmVpTermRowStatus, adFlowMaster=adFlowMaster, adpOutputBandwidth=adpOutputBandwidth, dxatmVpModeDesired=dxatmVpModeDesired, atmSwitch=atmSwitch, dxatmVpModeActual=dxatmVpModeActual)

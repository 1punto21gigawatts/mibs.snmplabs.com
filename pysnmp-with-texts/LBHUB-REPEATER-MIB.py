#
# PySNMP MIB module LBHUB-REPEATER-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/LBHUB-REPEATER-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:06:05 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, SingleValueConstraint, ValueSizeConstraint, ConstraintsIntersection, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsIntersection", "ValueRangeConstraint")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Gauge32, enterprises, Counter32, Unsigned32, MibIdentifier, iso, Bits, ModuleIdentity, mgmt, MibScalar, MibTable, MibTableRow, MibTableColumn, NotificationType, Integer32, TimeTicks, Counter64, IpAddress, NotificationType, ObjectIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "Gauge32", "enterprises", "Counter32", "Unsigned32", "MibIdentifier", "iso", "Bits", "ModuleIdentity", "mgmt", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "NotificationType", "Integer32", "TimeTicks", "Counter64", "IpAddress", "NotificationType", "ObjectIdentity")
PhysAddress, TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "PhysAddress", "TextualConvention", "DisplayString")
mib_2 = MibIdentifier((1, 3, 6, 1, 2, 1)).setLabel("mib-2")
class DisplayString(OctetString):
    pass

class PhysAddress(OctetString):
    pass

system = MibIdentifier((1, 3, 6, 1, 2, 1, 1))
interfaces = MibIdentifier((1, 3, 6, 1, 2, 1, 2))
at = MibIdentifier((1, 3, 6, 1, 2, 1, 3))
ip = MibIdentifier((1, 3, 6, 1, 2, 1, 4))
icmp = MibIdentifier((1, 3, 6, 1, 2, 1, 5))
tcp = MibIdentifier((1, 3, 6, 1, 2, 1, 6))
udp = MibIdentifier((1, 3, 6, 1, 2, 1, 7))
egp = MibIdentifier((1, 3, 6, 1, 2, 1, 8))
transmission = MibIdentifier((1, 3, 6, 1, 2, 1, 10))
snmp = MibIdentifier((1, 3, 6, 1, 2, 1, 11))
dot1dBridge = MibIdentifier((1, 3, 6, 1, 2, 1, 17))
a3Com = MibIdentifier((1, 3, 6, 1, 4, 1, 43))
products = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1))
terminalServer = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 1))
dedicatedBridgeServer = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 2))
dedicatedRouteServer = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 3))
brouter = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 4))
genericMSWorkstation = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 5))
genericMSServer = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 6))
genericUnixServer = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 7))
hub = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 8))
cards = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9))
chipsets = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 10))
linkBuilder3GH = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 8, 1))
linkBuilder10BTi = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 8, 2))
linkBuilderECS = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 8, 3))
linkBuilderMSH = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 8, 4))
linkBuilderFMS = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 8, 5))
linkBuilderFDDIwg = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 8, 6))
linkBuilderFMSII = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 8, 7))
linkSwitchFMS = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 8, 8))
linkSwitchMSH = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 8, 9))
linkBuilderFMSLBridge = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 8, 10))
linkBuilder3GH_cards = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 1)).setLabel("linkBuilder3GH-cards")
linkBuilder10BTi_cards = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 2)).setLabel("linkBuilder10BTi-cards")
linkBuilderECS_cards = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 3)).setLabel("linkBuilderECS-cards")
linkBuilderMSH_cards = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 4)).setLabel("linkBuilderMSH-cards")
linkBuilderFMS_cards = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 5)).setLabel("linkBuilderFMS-cards")
linkBuilderFMSII_cards = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 6)).setLabel("linkBuilderFMSII-cards")
linkBuilder10BTi_cards_utp = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 2, 1)).setLabel("linkBuilder10BTi-cards-utp")
linkBuilder10BT_cards_utp = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 2, 2)).setLabel("linkBuilder10BT-cards-utp")
linkBuilderFMS_cards_utp = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 5, 1)).setLabel("linkBuilderFMS-cards-utp")
linkBuilderFMS_cards_coax = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 5, 2)).setLabel("linkBuilderFMS-cards-coax")
linkBuilderFMS_cards_fiber = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 5, 3)).setLabel("linkBuilderFMS-cards-fiber")
linkBuilderFMS_cards_12fiber = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 5, 4)).setLabel("linkBuilderFMS-cards-12fiber")
linkBuilderFMS_cards_24utp = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 5, 5)).setLabel("linkBuilderFMS-cards-24utp")
linkBuilderFMSII_cards_12tp_rj45 = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 6, 1)).setLabel("linkBuilderFMSII-cards-12tp-rj45")
linkBuilderFMSII_cards_10coax_bnc = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 6, 2)).setLabel("linkBuilderFMSII-cards-10coax-bnc")
linkBuilderFMSII_cards_6fiber_st = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 6, 3)).setLabel("linkBuilderFMSII-cards-6fiber-st")
linkBuilderFMSII_cards_12fiber_st = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 6, 4)).setLabel("linkBuilderFMSII-cards-12fiber-st")
linkBuilderFMSII_cards_24tp_rj45 = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 6, 5)).setLabel("linkBuilderFMSII-cards-24tp-rj45")
linkBuilderFMSII_cards_24tp_telco = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 6, 6)).setLabel("linkBuilderFMSII-cards-24tp-telco")
amp_mib = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 3)).setLabel("amp-mib")
genericTrap = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 4))
viewBuilderApps = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 5))
specificTrap = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 6))
linkBuilder3GH_mib = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 7)).setLabel("linkBuilder3GH-mib")
linkBuilder10BTi_mib = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 8)).setLabel("linkBuilder10BTi-mib")
linkBuilderECS_mib = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 9)).setLabel("linkBuilderECS-mib")
generic = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10))
genExperimental = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 1))
setup = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 2))
sysLoader = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 3))
security = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 4))
gauges = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 5))
asciiAgent = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 6))
serialIf = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 7))
repeaterMgmt = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 8))
endStation = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 9))
localSnmp = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 10))
manager = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 11))
unusedGeneric12 = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 12))
chassis = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 14))
mrmResilience = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 15))
tokenRing = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 16))
multiRepeater = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 17))
bridgeMgmt = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 18))
fault = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 19))
poll = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 20))
powerSupply = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 21))
testData = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 1, 1))
ifExtensions = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 1, 2))
netBuilder_mib = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 11)).setLabel("netBuilder-mib")
lBridgeECS_mib = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 12)).setLabel("lBridgeECS-mib")
deskMan_mib = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 13)).setLabel("deskMan-mib")
linkBuilderMSH_mib = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 14)).setLabel("linkBuilderMSH-mib")
linkBuilderFMS_mib = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 15)).setLabel("linkBuilderFMS-mib")
linkBuilderFDDI_wghub_mib = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 16)).setLabel("linkBuilderFDDI-wghub-mib")
linkSwitch_mib = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 17)).setLabel("linkSwitch-mib")
snmpDot3RptrMgt = MibIdentifier((1, 3, 6, 1, 2, 1, 22))
class MacAddress(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(6, 6)
    fixedLength = 6

rptrBasicPackage = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 1))
rptrMonitorPackage = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 2))
rptrAddrTrackPackage = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 3))
rptrRptrInfo = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 1, 1))
rptrGroupInfo = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 1, 2))
rptrPortInfo = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 1, 3))
rptrMonitorRptrInfo = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 2, 1))
rptrMonitorGroupInfo = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 2, 2))
rptrMonitorPortInfo = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 2, 3))
rptrAddrTrackRptrInfo = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 3, 1))
rptrAddrTrackGroupInfo = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 3, 2))
rptrAddrTrackPortInfo = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 3, 3))
rptrGroupCapacity = MibScalar((1, 3, 6, 1, 2, 1, 22, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrGroupCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: rptrGroupCapacity.setDescription('The rptrGroupCapacity is the number of groups that can be contained within the repeater. Within each managed repeater, the groups are uniquely numbered in the range from 1 to rptrGroupCapacity. Some groups may not be present in the repeater, in which case the actual number of groups present will be less than rptrGroupCapacity. The number of groups present will never be greater than rptrGroupCapacity. Note: In practice, this will generally be the number of field-replaceable units (i.e., modules, cards, or boards) that can fit in the physical repeater enclosure, and the group numbers will correspond to numbers marked on the physical enclosure.')
rptrOperSTATUS = MibScalar((1, 3, 6, 1, 2, 1, 22, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("rptrFailure", 3), ("groupFailure", 4), ("portFailure", 5), ("generalFailure", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrOperSTATUS.setStatus('mandatory')
if mibBuilder.loadTexts: rptrOperSTATUS.setDescription("The rptrOperSTATUS object indicates the operational state of the repeater. The rptrHealthText object may be consulted for more specific information about the state of the repeater's health. In the case of multiple kinds of failures (e.g., repeater failure and port failure), the value of this attribute shall reflect the highest priority failure in the following order, listed highest priority first: rptrFailure(3) groupFailure(4) portFailure(5) generalFailure(6).")
rptrHealthText = MibScalar((1, 3, 6, 1, 2, 1, 22, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrHealthText.setStatus('mandatory')
if mibBuilder.loadTexts: rptrHealthText.setDescription('The health text object is a text string that provides information relevant to the operational state of the repeater. Agents may use this string to provide detailed information on current failures, including how they were detected, and/or instructions for problem resolution. The contents are agent-specific.')
rptrReset = MibScalar((1, 3, 6, 1, 2, 1, 22, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noReset", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rptrReset.setStatus('mandatory')
if mibBuilder.loadTexts: rptrReset.setDescription('Setting this object to reset(2) causes a transition to the START state of Fig 9-2 in section 9 [IEEE 802.3 Std]. Setting this object to noReset(1) has no effect. The agent will always return the value noReset(1) when this object is read. After receiving a request to set this variable to reset(2), the agent is allowed to delay the reset for a short period. For example, the implementor may choose to delay the reset long enough to allow the SNMP response to be transmitted. In any event, the SNMP response must be transmitted. This action does not reset the management counters defined in this document nor does it affect the portAdminSTATUS parameters. Included in this action is the execution of a disruptive Self-Test with the following characteristics: a) The nature of the tests is not specified. b) The test resets the repeater but without affecting management information about the repeater. c) The test does not inject packets onto any segment. d) Packets received during the test may or may not be transferred. e) The test does not interfere with management functions. After performing this self-test, the agent will update the repeater health information (including rptrOperSTATUS and rptrHealthText), and send a rptrHealth trap.')
rptrNonDisruptTest = MibScalar((1, 3, 6, 1, 2, 1, 22, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noSelfTest", 1), ("selfTest", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rptrNonDisruptTest.setStatus('mandatory')
if mibBuilder.loadTexts: rptrNonDisruptTest.setDescription("Setting this object to selfTest(2) causes the repeater to perform a agent-specific, non- disruptive self-test that has the following characteristics: a) The nature of the tests is not specified. b) The test does not change the state of the repeater or management information about the repeater. c) The test does not inject packets onto any segment. d) The test does not prevent the relay of any packets. e) The test does not interfere with management functions. After performing this test, the agent will update the repeater health information (including rptrOperSTATUS and rptrHealthText) and send a rptrHealth trap. Note that this definition allows returning an 'okay' result after doing a trivial test. Setting this object to noSelfTest(1) has no effect. The agent will always return the value noSelfTest(1) when this object is read.")
rptrTotalPartitionedPorts = MibScalar((1, 3, 6, 1, 2, 1, 22, 1, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrTotalPartitionedPorts.setStatus('mandatory')
if mibBuilder.loadTexts: rptrTotalPartitionedPorts.setDescription('This object returns the total number of ports in the repeater whose current state meets all three of the following criteria: rptrPortOperSTATUS does not have the value notPresent(3), rptrPortAdminSTATUS is enabled(1), and rptrPortAutoPartitionState is autoPartitioned(2).')
rptrGroupTable = MibTable((1, 3, 6, 1, 2, 1, 22, 1, 2, 1), )
if mibBuilder.loadTexts: rptrGroupTable.setStatus('mandatory')
if mibBuilder.loadTexts: rptrGroupTable.setDescription('Table of descriptive and STATUS information about the groups of ports.')
rptrGroupEntry = MibTableRow((1, 3, 6, 1, 2, 1, 22, 1, 2, 1, 1), ).setIndexNames((0, "LBHUB-REPEATER-MIB", "rptrGroupIndex"))
if mibBuilder.loadTexts: rptrGroupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rptrGroupEntry.setDescription('An entry in the table, containing information about a single group of ports.')
rptrGroupIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 1, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrGroupIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rptrGroupIndex.setDescription('This object identifies the group within the repeater for which this entry contains information. This value is never greater than rptrGroupCapacity.')
rptrGroupDescr = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 1, 2, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrGroupDescr.setStatus('mandatory')
if mibBuilder.loadTexts: rptrGroupDescr.setDescription("A textual description of the group. This value should include the full name and version identification of the group's hardware type and indicate how the group is differentiated from other types of groups in the repeater. Plug-in Module, Rev A' or 'Barney Rubble 10BASE-T 4-port SIMM socket Version 2.1' are examples of valid group descriptions. It is mandatory that this only contain printable ASCII characters.")
rptrGroupObjectID = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 1, 2, 1, 1, 3), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrGroupObjectID.setStatus('mandatory')
if mibBuilder.loadTexts: rptrGroupObjectID.setDescription("The vendor's authoritative identification of the group. This value may be allocated within the SMI enterprises subtree (1.3.6.1.4.1) and provides a straight-forward and unambiguous means for determining what kind of group is being managed. For example, this object could take the value 1.3.6.1.4.1.4242.1.2.14 if vendor 'Flintstones, Inc.' was assigned the subtree 1.3.6.1.4.1.4242, and had assigned the identifier 1.3.6.1.4.1.4242.1.2.14 to its 'Wilma Flintstone 6-Port FOIRL Plug-in Module.'")
rptrGroupOperSTATUS = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 1, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("operational", 2), ("malfunctioning", 3), ("notPresent", 4), ("underTest", 5), ("resetInProgress", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrGroupOperSTATUS.setStatus('mandatory')
if mibBuilder.loadTexts: rptrGroupOperSTATUS.setDescription('An object that indicates the operational STATUS of the group. A STATUS of notPresent(4) indicates that the group is temporarily or permanently physically and/or logically not a part of the repeater. It is an implementation-specific matter as to whether the agent effectively removes notPresent entries from the table. A STATUS of operational(2) indicates that the group is functioning, and a STATUS of malfunctioning(3) indicates that the group is malfunctioning in some way.')
rptrGroupLastOperSTATUSChange = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 1, 2, 1, 1, 5), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrGroupLastOperSTATUSChange.setStatus('mandatory')
if mibBuilder.loadTexts: rptrGroupLastOperSTATUSChange.setDescription("An object that contains the value of sysUpTime at the time that the value of the rptrGroupOperSTATUS object for this group last changed. A value of zero indicates that the group's operational STATUS has not changed since the agent last restarted.")
rptrGroupPortCapacity = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 1, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrGroupPortCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: rptrGroupPortCapacity.setDescription('The rptrGroupPortCapacity is the number of ports that can be contained within the group. Valid range is 1-1024. Within each group, the ports are uniquely numbered in the range from 1 to rptrGroupPortCapacity. Note: In practice, this will generally be the number of ports on a module, card, or board, and the port numbers will correspond to numbers marked on the physical embodiment.')
rptrPortTable = MibTable((1, 3, 6, 1, 2, 1, 22, 1, 3, 1), )
if mibBuilder.loadTexts: rptrPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: rptrPortTable.setDescription('Table of descriptive and STATUS information about the ports.')
rptrPortEntry = MibTableRow((1, 3, 6, 1, 2, 1, 22, 1, 3, 1, 1), ).setIndexNames((0, "LBHUB-REPEATER-MIB", "rptrPortGroupIndex"), (0, "LBHUB-REPEATER-MIB", "rptrPortIndex"))
if mibBuilder.loadTexts: rptrPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rptrPortEntry.setDescription('An entry in the table, containing information about a single port.')
rptrPortGroupIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 1, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrPortGroupIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rptrPortGroupIndex.setDescription('This object identifies the group containing the port for which this entry contains information.')
rptrPortIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 1, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rptrPortIndex.setDescription('This object identifies the port within the group for which this entry contains information. This value can never be greater than rptrGroupPortCapacity for the associated group.')
rptrPortAdminSTATUS = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 1, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rptrPortAdminSTATUS.setStatus('mandatory')
if mibBuilder.loadTexts: rptrPortAdminSTATUS.setDescription("Setting this object to disabled(2) disables the port. A disabled port neither transmits nor receives. Once disabled, a port must be explicitly enabled to restore operation. A port which is disabled when power is lost or when a reset is exerted shall remain disabled when normal operation resumes. The admin STATUS takes precedence over auto- partition and functionally operates between the auto-partition mechanism and the AUI/PMA. Setting this object to enabled(1) enables the port and exerts a BEGIN on the port's auto-partition state machine. (In effect, when a port is disabled, the value of rptrPortAutoPartitionState for that port is frozen until the port is next enabled. When the port becomes enabled, the rptrPortAutoPartitionState becomes notAutoPartitioned(1), regardless of its pre-disabling state.)")
rptrPortAutoPartitionState = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 1, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notAutoPartitioned", 1), ("autoPartitioned", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrPortAutoPartitionState.setStatus('mandatory')
if mibBuilder.loadTexts: rptrPortAutoPartitionState.setDescription("The autoPartitionState flag indicates whether the port is currently partitioned by the repeater's auto-partition protection. The conditions that cause port partitioning are specified in partition state machine in Section 9 [IEEE 802.3 Std]. They are not differentiated here.")
rptrPortOperSTATUS = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 1, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("operational", 1), ("notOperational", 2), ("notPresent", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrPortOperSTATUS.setStatus('mandatory')
if mibBuilder.loadTexts: rptrPortOperSTATUS.setDescription("This object indicates the port's operational STATUS. The notPresent(3) status indicates the port is physically removed (note this may or may not be possible depending on the type of port.) The operational(1) STATUS indicates that the port is enabled (see rptrPortAdminSTATUS) and working, even though it might be auto-partitioned (see rptrPortAutoPartitionState). If this object has the value operational(1) and rptrPortAdminSTATUS is set to disabled(2), it is expected that this object's value will soon change to notOperational(2).")
rptrMonitorTransmitCollisions = MibScalar((1, 3, 6, 1, 2, 1, 22, 2, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorTransmitCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorTransmitCollisions.setDescription('This counter is incremented every time the repeater state machine enters the TRANSMIT COLLISION state from any state other than ONE PORT LEFT (Ref: Fig 9-2, IEEE 802.3 Std). The approximate minimum time for rollover of this counter is 16 hours.')
rptrMonitorGroupTable = MibTable((1, 3, 6, 1, 2, 1, 22, 2, 2, 1), )
if mibBuilder.loadTexts: rptrMonitorGroupTable.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorGroupTable.setDescription('Table of performance and error statistics for the groups.')
rptrMonitorGroupEntry = MibTableRow((1, 3, 6, 1, 2, 1, 22, 2, 2, 1, 1), ).setIndexNames((0, "LBHUB-REPEATER-MIB", "rptrMonitorGroupIndex"))
if mibBuilder.loadTexts: rptrMonitorGroupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorGroupEntry.setDescription("An entry in the table, containing total performance and error statistics for a single group. Regular retrieval of the information in this table provides a means of tracking the performance and health of the networked devices attached to this group's ports. The counters in this table are redundant in the sense that they are the summations of information already available through other objects. However, these sums provide a considerable optimization of network management traffic over the otherwise necessary retrieval of the individual counters included in each sum.")
rptrMonitorGroupIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorGroupIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorGroupIndex.setDescription('This object identifies the group within the repeater for which this entry contains information.')
rptrMonitorGroupTotalFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 2, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorGroupTotalFrames.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorGroupTotalFrames.setDescription('The total number of frames of valid frame length that have been received on the ports in this group and for which the FCSError and CollisionEvent signals were not asserted. This counter is the summation of the values of the rptrMonitorPortReadableFrames counters for all of the ports in the group. This statistic provides one of the parameters necessary for obtaining the packet error rate. The approximate minimum time for rollover of this counter is 80 hours.')
rptrMonitorGroupTotalOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 2, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorGroupTotalOctets.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorGroupTotalOctets.setDescription('The total number of octets contained in the valid frames that have been received on the ports in this group. This counter is the summation of the values of the rptrMonitorPortReadableOctets counters for all of the ports in the group. This statistic provides an indicator of the total data transferred. The approximate minimum time for rollover of this counter is 58 minutes.')
rptrMonitorGroupTotalErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 2, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorGroupTotalErrors.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorGroupTotalErrors.setDescription('The total number of errors which have occurred on all of the ports in this group. This counter is the summation of the values of the rptrMonitorPortTotalErrors counters for all of the ports in the group.')
rptrMonitorPortTable = MibTable((1, 3, 6, 1, 2, 1, 22, 2, 3, 1), )
if mibBuilder.loadTexts: rptrMonitorPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorPortTable.setDescription('Table of performance and error statistics for the ports.')
rptrMonitorPortEntry = MibTableRow((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1), ).setIndexNames((0, "LBHUB-REPEATER-MIB", "rptrMonitorPortGroupIndex"), (0, "LBHUB-REPEATER-MIB", "rptrMonitorPortIndex"))
if mibBuilder.loadTexts: rptrMonitorPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorPortEntry.setDescription('An entry in the table, containing performance and error statistics for a single port.')
rptrMonitorPortGroupIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortGroupIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorPortGroupIndex.setDescription('This object identifies the group containing the port for which this entry contains information.')
rptrMonitorPortIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorPortIndex.setDescription('This object identifies the port within the group for which this entry contains information.')
rptrMonitorPortReadableFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortReadableFrames.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorPortReadableFrames.setDescription('This object is the number of frames of valid frame length that have been received on this port. This counter is incremented by one for each frame received on this port whose OctetCount is greater than or equal to minFrameSize and less than or equal to maxFrameSize (Ref: IEEE 802.3 Std, 4.4.2.1) and for which the FCSError and CollisionEvent signals are not asserted. This statistic provides one of the parameters necessary for obtaining the packet error rate. The approximate minimum time for rollover of this counter is 80 hours.')
rptrMonitorPortReadableOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortReadableOctets.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorPortReadableOctets.setDescription('This object is the number of octets contained in valid frames that have been received on this port. This counter is incremented by OctetCount for each frame received on this port which has been determined to be a readable frame (i.e., including FCS octets but excluding framing bits and dribble bits). This statistic provides an indicator of the total data transferred. The approximate minimum time for rollover of this counter is 58 minutes.')
rptrMonitorPortFCSErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortFCSErrors.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorPortFCSErrors.setDescription('This counter is incremented by one for each frame received on this port with the FCSError signal asserted and the FramingError and CollisionEvent signals deasserted and whose OctetCount is greater than or equal to minFrameSize and less than or equal to maxFrameSize (Ref: 4.4.2.1, IEEE 802.3 Std). The approximate minimum time for rollover of this counter is 80 hours.')
rptrMonitorPortAlignmentErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortAlignmentErrors.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorPortAlignmentErrors.setDescription('This counter is incremented by one for each frame received on this port with the FCSError and FramingError signals asserted and CollisionEvent signal deasserted and whose OctetCount is greater than or equal to minFrameSize and less than or equal to maxFrameSize (Ref: IEEE 802.3 Std, 4.4.2.1). If rptrMonitorPortAlignmentErrors is incremented then the rptrMonitorPortFCSErrors Counter shall not be incremented for the same frame. The approximate minimum time for rollover of this counter is 80 hours.')
rptrMonitorPortFrameTooLongs = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortFrameTooLongs.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorPortFrameTooLongs.setDescription('This counter is incremented by one for each frame received on this port whose OctetCount is greater than maxFrameSize (Ref: 4.4.2.1, IEEE 802.3 Std). If rptrMonitorPortFrameTooLongs is incremented then neither the rptrMonitorPortAlignmentErrors nor the rptrMonitorPortFCSErrors counter shall be incremented for the frame. The approximate minimum time for rollover of this counter is 61 days.')
rptrMonitorPortShortEvents = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortShortEvents.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorPortShortEvents.setDescription('This counter is incremented by one for each CarrierEvent on this port with ActivityDuration less than ShortEventMaxTime. ShortEventMaxTime is greater than 74 bit times and less than 82 bit times. ShortEventMaxTime has tolerances included to provide for circuit losses between a conformance test point at the AUI and the measurement point within the state machine. Note: shortEvents may indicate externally generated noise hits which will cause the repeater to transmit Runts to its other ports, or propagate a collision (which may be late) back to the transmitting DTE and damaged frames to the rest of the network. Implementors may wish to consider selecting the ShortEventMaxTime towards the lower end of the allowed tolerance range to accommodate bit losses suffered through physical channel devices not budgeted for within this standard. The approximate minimum time for rollover of this counter is 16 hours.')
rptrMonitorPortRunts = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortRunts.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorPortRunts.setDescription('This counter is incremented by one for each CarrierEvent on this port that meets one of the following two conditions. Only one test need be made. a) The ActivityDuration is greater than ShortEventMaxTime and less than ValidPacketMinTime and the CollisionEvent signal is deasserted. b) The OctetCount is less than 64, the ActivityDuration is greater than ShortEventMaxTime and the CollisionEvent signal is deasserted. ValidPacketMinTime is greater than or equal to 552 bit times and less than 565 bit times. An event whose length is greater than 74 bit times but less than 82 bit times shall increment either the shortEvents counter or the runts counter but not both. A CarrierEvent greater than or equal to 552 bit times but less than 565 bit times may or may not be counted as a runt. ValidPacketMinTime has tolerances included to provide for circuit losses between a conformance test point at the AUI and the measurement point within the state machine. Runts usually indicate collision fragments, a normal network event. In certain situations associated with large diameter networks a percentage of collision fragments may exceed ValidPacketMinTime. The approximate minimum time for rollover of this counter is 16 hours.')
rptrMonitorPortCollisions = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorPortCollisions.setDescription('This counter is incremented by one for any CarrierEvent signal on any port for which the CollisionEvent signal on this port is also asserted. The approximate minimum time for rollover of this counter is 16 hours.')
rptrMonitorPortLateEvents = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortLateEvents.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorPortLateEvents.setDescription('This counter is incremented by one for each CarrierEvent on this port in which the CollIn(X) variable transitions to the value SQE (Ref: 9.6.6.2, IEEE 802.3 Std) while the ActivityDuration is greater than the LateEventThreshold. Such a CarrierEvent is counted twice, as both a collision and as a lateEvent. The LateEventThreshold is greater than 480 bit times and less than 565 bit times. LateEventThreshold has tolerances included to permit an implementation to build a single threshold to serve as both the LateEventThreshold and ValidPacketMinTime threshold. The approximate minimum time for rollover of this counter is 81 hours.')
rptrMonitorPortVeryLongEvents = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortVeryLongEvents.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorPortVeryLongEvents.setDescription('This counter is incremented by one for each CarrierEvent on this port whose ActivityDuration is greater than the MAU Jabber Lockup Protection timer TW3 (Ref: 9.6.1 & 9.6.5, IEEE 802.3 Std). Other counters may be incremented as appropriate.')
rptrMonitorPortDataRateMismatches = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortDataRateMismatches.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorPortDataRateMismatches.setDescription("This counter is incremented by one for each frame received on this port that meets all of the following conditions: a) The CollisionEvent signal is not asserted. b) The ActivityDuration is greater than ValidPacketMinTime. c) The frequency (data rate) is detectably mismatched from the local transmit frequency. The exact degree of mismatch is vendor specific and is to be defined by the vendor for conformance testing. When this event occurs, other counters whose increment conditions were satisfied may or may not also be incremented, at the implementor's discretion. Whether or not the repeater was able to maintain data integrity is beyond the scope of this standard.")
rptrMonitorPortAutoPartitions = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortAutoPartitions.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorPortAutoPartitions.setDescription('This counter is incremented by one for each time the repeater has automatically partitioned this port. The conditions that cause port partitioning are specified in the partition state machine in Section 9 [IEEE 802.3 Std]. They are not differentiated here.')
rptrMonitorPortTotalErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortTotalErrors.setStatus('mandatory')
if mibBuilder.loadTexts: rptrMonitorPortTotalErrors.setDescription('The total number of errors which have occurred on this port. This counter is the summation of the values of other error counters (for the same port), namely: rptrMonitorPortFCSErrors, rptrMonitorPortAlignmentErrors, rptrMonitorPortFrameTooLongs, rptrMonitorPortShortEvents, rptrMonitorPortLateEvents, rptrMonitorPortVeryLongEvents, and rptrMonitorPortDataRateMismatches. This counter is redundant in the sense that it is the summation of information already available through other objects. However, it is included specifically because the regular retrieval of this object as a means of tracking the health of a port provides a considerable optimization of network management traffic over the otherwise necessary retrieval of the summed counters.')
rptrAddrTrackTable = MibTable((1, 3, 6, 1, 2, 1, 22, 3, 3, 1), )
if mibBuilder.loadTexts: rptrAddrTrackTable.setStatus('mandatory')
if mibBuilder.loadTexts: rptrAddrTrackTable.setDescription('Table of address mapping information about the ports.')
rptrAddrTrackEntry = MibTableRow((1, 3, 6, 1, 2, 1, 22, 3, 3, 1, 1), ).setIndexNames((0, "LBHUB-REPEATER-MIB", "rptrAddrTrackGroupIndex"), (0, "LBHUB-REPEATER-MIB", "rptrAddrTrackPortIndex"))
if mibBuilder.loadTexts: rptrAddrTrackEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rptrAddrTrackEntry.setDescription('An entry in the table, containing address mapping information about a single port.')
rptrAddrTrackGroupIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 3, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrAddrTrackGroupIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rptrAddrTrackGroupIndex.setDescription('This object identifies the group containing the port for which this entry contains information.')
rptrAddrTrackPortIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 3, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrAddrTrackPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rptrAddrTrackPortIndex.setDescription('This object identifies the port within the group for which this entry contains information.')
rptrAddrTrackLastSourceAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 3, 3, 1, 1, 3), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrAddrTrackLastSourceAddress.setStatus('deprecated')
if mibBuilder.loadTexts: rptrAddrTrackLastSourceAddress.setDescription('This object is the SourceAddress of the last readable frame (i.e., counted by rptrMonitorPortReadableFrames) received by this port. This object has been deprecated because its value is undefined when no frames have been observed on this port. The replacement object is rptrAddrTrackNewLastSrcAddress.')
rptrAddrTrackSourceAddrChanges = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 3, 3, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrAddrTrackSourceAddrChanges.setStatus('mandatory')
if mibBuilder.loadTexts: rptrAddrTrackSourceAddrChanges.setDescription('This counter is incremented by one for each time that the rptrAddrTrackLastSourceAddress attribute for this port has changed. This may indicate whether a link is connected to a single DTE or another multi-user segment. The approximate minimum time for rollover of this counter is 81 hours.')
rptrAddrTrackNewLastSrcAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 3, 3, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 6))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrAddrTrackNewLastSrcAddress.setStatus('mandatory')
if mibBuilder.loadTexts: rptrAddrTrackNewLastSrcAddress.setDescription('This object is the SourceAddress of the last readable frame (i.e., counted by rptrMonitorPortReadableFrames) received by this port. If no frames have been received by this port since the agent began monitoring the port activity, the agent shall return a string of length zero.')
snmpDot3MauMgt = MibIdentifier((1, 3, 6, 1, 2, 1, 26))
dot3RpMauBasicGroup = MibIdentifier((1, 3, 6, 1, 2, 1, 26, 1))
dot3IfMauBasicGroup = MibIdentifier((1, 3, 6, 1, 2, 1, 26, 2))
dot3BroadMauBasicGroup = MibIdentifier((1, 3, 6, 1, 2, 1, 26, 3))
dot3MauType = MibIdentifier((1, 3, 6, 1, 2, 1, 26, 4))
dot3MauTypeAUI = MibIdentifier((1, 3, 6, 1, 2, 1, 26, 4, 1))
dot3MauType10Base5 = MibIdentifier((1, 3, 6, 1, 2, 1, 26, 4, 2))
dot3MauTypeFoirl = MibIdentifier((1, 3, 6, 1, 2, 1, 26, 4, 3))
dot3MauType10Base2 = MibIdentifier((1, 3, 6, 1, 2, 1, 26, 4, 4))
dot3MauType10BaseT = MibIdentifier((1, 3, 6, 1, 2, 1, 26, 4, 5))
dot3MauType10BaseFP = MibIdentifier((1, 3, 6, 1, 2, 1, 26, 4, 6))
dot3MauType10BaseFB = MibIdentifier((1, 3, 6, 1, 2, 1, 26, 4, 7))
dot3MauType10BaseFL = MibIdentifier((1, 3, 6, 1, 2, 1, 26, 4, 8))
dot3MauType10Broad36 = MibIdentifier((1, 3, 6, 1, 2, 1, 26, 4, 9))
rpMauTable = MibTable((1, 3, 6, 1, 2, 1, 26, 1, 1), )
if mibBuilder.loadTexts: rpMauTable.setStatus('mandatory')
if mibBuilder.loadTexts: rpMauTable.setDescription('Table of descriptive and status information about the MAU(s) attached to the ports of a repeater.')
rpMauEntry = MibTableRow((1, 3, 6, 1, 2, 1, 26, 1, 1, 1), ).setIndexNames((0, "LBHUB-REPEATER-MIB", "rpMauGroupIndex"), (0, "LBHUB-REPEATER-MIB", "rpMauPortIndex"), (0, "LBHUB-REPEATER-MIB", "rpMauIndex"))
if mibBuilder.loadTexts: rpMauEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rpMauEntry.setDescription('An entry in the table, containing information about a single MAU.')
rpMauGroupIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 26, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpMauGroupIndex.setReference('Reference RFC1368, rptrGroupIndex.')
if mibBuilder.loadTexts: rpMauGroupIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rpMauGroupIndex.setDescription('This variable uniquely identifies the repeater group containing the port to which the MAU described by this entry is connected.')
rpMauPortIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 26, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpMauPortIndex.setReference('Reference RFC 1368, rptrPortIndex.')
if mibBuilder.loadTexts: rpMauPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rpMauPortIndex.setDescription('This variable uniquely identifies the repeater port within group rpMauGroupIndex to which the MAU described by this entry is connected.')
rpMauIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 26, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpMauIndex.setReference('Reference IEEE 802.3 MAU Mgt, 20.2.3.2, aMAUID.')
if mibBuilder.loadTexts: rpMauIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rpMauIndex.setDescription('This variable uniquely identifies the MAU connected to port rpMauPortIndex within group rpMauGroupIndex that is described by this entry.')
rpMauType = MibTableColumn((1, 3, 6, 1, 2, 1, 26, 1, 1, 1, 4), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpMauType.setReference('Reference IEEE 802.3 MAU Mgt, 20.2.3.2, aMAUType.')
if mibBuilder.loadTexts: rpMauType.setStatus('mandatory')
if mibBuilder.loadTexts: rpMauType.setDescription('This object identifies the 10 Mb/s baseband MAU type. An initial set of MAU types are defined above. The assignment of OBJECT IDENTIFIERs to new types of MAUs is managed by the IANA. If the MAU type is unknown, the object identifier unknownMauType OBJECT IDENTIFIER ::= { 0 0 } is returned. Note that unknownMauType is a syntactically valid object identifier, and any conformant implementation of ASN.1 and the BER must be able to generate and recognize this value.')
rpMauStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 26, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("unknown", 2), ("operational", 3), ("standby", 4), ("shutdown", 5), ("reset", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rpMauStatus.setReference('Reference IEEE 802.3 MAU Mgt, 20.2.3.2, aMAUAdminState, and 20.2.3.3, acMAUAdminControl and acResetMAUAction.')
if mibBuilder.loadTexts: rpMauStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rpMauStatus.setDescription("The current state of the MAU. This object may be implemented as a read-only object by those agents and MAUs that do not implement software control of the MAU state. Some agents may not support setting the value of this object to some of the enumerated values. The value other(1) is returned if the MAU is in a state other than one of the states 2 through 6. The value unknown(2) is returned when the MAU's true state is unknown; for example, when it is being initialized. A MAU in the operational(3) state is fully functional, operates, and passes signals to its attached DTE or repeater port in accordance to its specification. A MAU in standby(4) state forces DI and CI and the media transmitter to idle. Standby(4) mode only applies to link type MAUs. The state of rpMauMediaAvailable is unaffected. A MAU in shutdown(5) state assumes the same condition on DI, CI, and the media transmitter as though it were powered down. The MAU may return other(1) value for the mauJabber and rpMauMediaAvailable objects when it is in this state. For an AUI, this state will remove power from the AUI. Setting this variable to the value reset(6) resets the MAU in the same manner as a power-off, power- on cycle of at least one-half second would. The agent is not required to return the value reset (6). Setting this variable to the value operational(3), standby(4), or shutdown(5) causes the MAU to assume the respective state except that setting a mixing-type MAU or an AUI to standby(4) will cause the MAU to enter the shutdown state.")
rpMauMediaAvailable = MibTableColumn((1, 3, 6, 1, 2, 1, 26, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("unknown", 2), ("available", 3), ("notAvailable", 4), ("remoteFault", 5), ("invalidSignal", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpMauMediaAvailable.setReference('Reference IEEE 802.3 MAU Mgt, 20.2.3.2, aMediaAvailable.')
if mibBuilder.loadTexts: rpMauMediaAvailable.setStatus('mandatory')
if mibBuilder.loadTexts: rpMauMediaAvailable.setDescription("If the MAU is a link or fiber type (FOIRL, 10BASE-T, 10BASE-F) then this is equivalent to the link test fail state/low light function. For an AUI or a coax (including broadband) MAU this indicates whether or not loopback is detected on the DI circuit. The value of this attribute persists between packets for MAU types AUI, 10BASE5, 10BASE2, 10BROAD36, and 10BASE-FP. The value other(1) is returned if the mediaAvailable state is not one of 2 through 6. The value unknown(2) is returned when the MAU's true state is unknown; for example, when it is being initialized. At power-up or following a reset, the value of this attribute will be unknown for AUI, coax, and 10BASE-FP MAUs. For these MAUs loopback will be tested on each transmission during which no collision is detected. If DI is receiving input when DO returns to IDL after a transmission and there has been no collision during the transmission then loopback will be detected. The value of this attribute will only change during non-collided transmissions for AUI, coax, and 10BASE-FP MAUs. The value available(3) indicates that the link, light, or loopback is normal. The value notAvailable(4) indicates link loss, low light, or no loopback. The value remoteFault(5) indicates that a fault has been detected at the remote end of the link. The value invalidSignal(6) indicates that an invalid signal has been received from the other end of the link. Both remoteFault(5) and invalidSignal(6) apply only to MAUs of type 10BASE-FB.")
rpMauMediaAvailableStateExits = MibTableColumn((1, 3, 6, 1, 2, 1, 26, 1, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpMauMediaAvailableStateExits.setReference('Reference IEEE 802.3 MAU Mgt, 20.2.3.2, lostMediaCount.')
if mibBuilder.loadTexts: rpMauMediaAvailableStateExits.setStatus('mandatory')
if mibBuilder.loadTexts: rpMauMediaAvailableStateExits.setDescription('A count of the number of times that rpMauMediaAvailable for this MAU instance leaves the state available(3).')
rpMauJabberState = MibTableColumn((1, 3, 6, 1, 2, 1, 26, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("unknown", 2), ("noJabber", 3), ("jabbering", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpMauJabberState.setReference('Reference IEEE 802.3 MAU Mgt, 20.2.3.2, aJabber.jabberFlag.')
if mibBuilder.loadTexts: rpMauJabberState.setStatus('mandatory')
if mibBuilder.loadTexts: rpMauJabberState.setDescription("The value other(1) is returned if the jabber state is not 2, 3, or 4. The agent must always return other(1) for MAU type dot3MauTypeAUI. The value unknown(2) is returned when the MAU's true state is unknown; for example, when it is being initialized. If the MAU is not jabbering the agent returns noJabber(3). This is the 'normal' state. If the MAU is in jabber state the agent returns the jabbering(4) value.")
rpMauJabberingStateEnters = MibTableColumn((1, 3, 6, 1, 2, 1, 26, 1, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpMauJabberingStateEnters.setReference('Reference IEEE 802.3 MAU Mgt, 20.2.3.2, aJabber.jabberCounter.')
if mibBuilder.loadTexts: rpMauJabberingStateEnters.setStatus('mandatory')
if mibBuilder.loadTexts: rpMauJabberingStateEnters.setDescription('A count of the number of times that rpMauJabberState for this MAU instance enters the state jabbering(4). For a MAU of type dot3MauTypeAUI, this counter will always indicate zero.')
mibBuilder.exportSymbols("LBHUB-REPEATER-MIB", rptrMonitorPortEntry=rptrMonitorPortEntry, rptrAddrTrackEntry=rptrAddrTrackEntry, rpMauMediaAvailableStateExits=rpMauMediaAvailableStateExits, rptrPortEntry=rptrPortEntry, rptrPortOperSTATUS=rptrPortOperSTATUS, chassis=chassis, rptrNonDisruptTest=rptrNonDisruptTest, amp_mib=amp_mib, mib_2=mib_2, lBridgeECS_mib=lBridgeECS_mib, rptrRptrInfo=rptrRptrInfo, linkBuilder3GH=linkBuilder3GH, powerSupply=powerSupply, rptrMonitorGroupTotalErrors=rptrMonitorGroupTotalErrors, rptrMonitorGroupTotalFrames=rptrMonitorGroupTotalFrames, rptrGroupInfo=rptrGroupInfo, tcp=tcp, rptrMonitorPortRunts=rptrMonitorPortRunts, linkBuilderFMSII_cards_6fiber_st=linkBuilderFMSII_cards_6fiber_st, viewBuilderApps=viewBuilderApps, dedicatedRouteServer=dedicatedRouteServer, mrmResilience=mrmResilience, security=security, linkBuilder10BTi_mib=linkBuilder10BTi_mib, rptrGroupOperSTATUS=rptrGroupOperSTATUS, rptrMonitorGroupTotalOctets=rptrMonitorGroupTotalOctets, linkBuilderFDDIwg=linkBuilderFDDIwg, rptrReset=rptrReset, localSnmp=localSnmp, linkSwitch_mib=linkSwitch_mib, linkSwitchFMS=linkSwitchFMS, endStation=endStation, linkBuilder10BTi_cards_utp=linkBuilder10BTi_cards_utp, netBuilder_mib=netBuilder_mib, serialIf=serialIf, dot3MauType10Base2=dot3MauType10Base2, rpMauEntry=rpMauEntry, ip=ip, genericUnixServer=genericUnixServer, rptrAddrTrackGroupInfo=rptrAddrTrackGroupInfo, rptrMonitorPortReadableFrames=rptrMonitorPortReadableFrames, rptrMonitorPackage=rptrMonitorPackage, rptrMonitorPortTotalErrors=rptrMonitorPortTotalErrors, testData=testData, linkBuilderFMSII_cards_24tp_telco=linkBuilderFMSII_cards_24tp_telco, at=at, a3Com=a3Com, linkBuilderFMS_mib=linkBuilderFMS_mib, rptrAddrTrackGroupIndex=rptrAddrTrackGroupIndex, linkBuilderFMS_cards_fiber=linkBuilderFMS_cards_fiber, terminalServer=terminalServer, linkBuilderMSH_mib=linkBuilderMSH_mib, linkBuilderMSH=linkBuilderMSH, linkBuilderMSH_cards=linkBuilderMSH_cards, rptrGroupCapacity=rptrGroupCapacity, rptrMonitorPortCollisions=rptrMonitorPortCollisions, rptrMonitorPortDataRateMismatches=rptrMonitorPortDataRateMismatches, rptrPortAdminSTATUS=rptrPortAdminSTATUS, interfaces=interfaces, dot3MauType10BaseFP=dot3MauType10BaseFP, genericMSWorkstation=genericMSWorkstation, linkBuilderECS_mib=linkBuilderECS_mib, products=products, setup=setup, dot3RpMauBasicGroup=dot3RpMauBasicGroup, linkBuilderFMS_cards_24utp=linkBuilderFMS_cards_24utp, egp=egp, rptrMonitorPortVeryLongEvents=rptrMonitorPortVeryLongEvents, dot3MauType10BaseT=dot3MauType10BaseT, rptrGroupLastOperSTATUSChange=rptrGroupLastOperSTATUSChange, dot3MauType=dot3MauType, dot3MauType10Base5=dot3MauType10Base5, rptrGroupEntry=rptrGroupEntry, linkBuilderFMS_cards_12fiber=linkBuilderFMS_cards_12fiber, gauges=gauges, rptrTotalPartitionedPorts=rptrTotalPartitionedPorts, rptrHealthText=rptrHealthText, rptrMonitorPortAlignmentErrors=rptrMonitorPortAlignmentErrors, genericMSServer=genericMSServer, linkBuilderFMS_cards=linkBuilderFMS_cards, rptrAddrTrackPortIndex=rptrAddrTrackPortIndex, dot3MauType10Broad36=dot3MauType10Broad36, rpMauIndex=rpMauIndex, linkBuilder3GH_mib=linkBuilder3GH_mib, dot3IfMauBasicGroup=dot3IfMauBasicGroup, rpMauType=rpMauType, linkBuilderFMSLBridge=linkBuilderFMSLBridge, genExperimental=genExperimental, rptrMonitorGroupEntry=rptrMonitorGroupEntry, rptrAddrTrackPackage=rptrAddrTrackPackage, rptrGroupTable=rptrGroupTable, dedicatedBridgeServer=dedicatedBridgeServer, chipsets=chipsets, rptrMonitorPortLateEvents=rptrMonitorPortLateEvents, dot3MauTypeFoirl=dot3MauTypeFoirl, rptrOperSTATUS=rptrOperSTATUS, unusedGeneric12=unusedGeneric12, linkBuilderECS_cards=linkBuilderECS_cards, manager=manager, rptrAddrTrackNewLastSrcAddress=rptrAddrTrackNewLastSrcAddress, icmp=icmp, deskMan_mib=deskMan_mib, linkBuilderFMSII_cards=linkBuilderFMSII_cards, rptrPortAutoPartitionState=rptrPortAutoPartitionState, rpMauStatus=rpMauStatus, rpMauMediaAvailable=rpMauMediaAvailable, linkBuilderFMSII_cards_12fiber_st=linkBuilderFMSII_cards_12fiber_st, PhysAddress=PhysAddress, sysLoader=sysLoader, system=system, dot1dBridge=dot1dBridge, linkBuilderFMS_cards_utp=linkBuilderFMS_cards_utp, rptrAddrTrackPortInfo=rptrAddrTrackPortInfo, linkBuilder10BTi=linkBuilder10BTi, dot3MauType10BaseFL=dot3MauType10BaseFL, rpMauTable=rpMauTable, linkBuilderFMSII_cards_10coax_bnc=linkBuilderFMSII_cards_10coax_bnc, rptrMonitorPortGroupIndex=rptrMonitorPortGroupIndex, rptrGroupDescr=rptrGroupDescr, poll=poll, snmpDot3MauMgt=snmpDot3MauMgt, specificTrap=specificTrap, linkBuilderFMS=linkBuilderFMS, rptrAddrTrackLastSourceAddress=rptrAddrTrackLastSourceAddress, rpMauPortIndex=rpMauPortIndex, rpMauGroupIndex=rpMauGroupIndex, transmission=transmission, rptrPortIndex=rptrPortIndex, linkBuilder10BT_cards_utp=linkBuilder10BT_cards_utp, snmpDot3RptrMgt=snmpDot3RptrMgt, rptrPortTable=rptrPortTable, linkBuilderECS=linkBuilderECS, linkBuilder3GH_cards=linkBuilder3GH_cards, dot3BroadMauBasicGroup=dot3BroadMauBasicGroup, cards=cards, udp=udp, repeaterMgmt=repeaterMgmt, rptrMonitorPortAutoPartitions=rptrMonitorPortAutoPartitions, asciiAgent=asciiAgent, generic=generic, MacAddress=MacAddress, rptrMonitorGroupIndex=rptrMonitorGroupIndex, rptrMonitorRptrInfo=rptrMonitorRptrInfo, genericTrap=genericTrap, linkBuilderFDDI_wghub_mib=linkBuilderFDDI_wghub_mib, rptrMonitorTransmitCollisions=rptrMonitorTransmitCollisions, rpMauJabberState=rpMauJabberState, hub=hub, rptrMonitorPortIndex=rptrMonitorPortIndex, linkBuilderFMSII_cards_24tp_rj45=linkBuilderFMSII_cards_24tp_rj45, rptrAddrTrackTable=rptrAddrTrackTable, tokenRing=tokenRing, linkBuilder10BTi_cards=linkBuilder10BTi_cards, bridgeMgmt=bridgeMgmt, rptrPortInfo=rptrPortInfo, rptrGroupObjectID=rptrGroupObjectID, rptrMonitorPortFrameTooLongs=rptrMonitorPortFrameTooLongs, rptrMonitorPortReadableOctets=rptrMonitorPortReadableOctets, rptrBasicPackage=rptrBasicPackage, rptrGroupIndex=rptrGroupIndex, rpMauJabberingStateEnters=rpMauJabberingStateEnters, linkBuilderFMS_cards_coax=linkBuilderFMS_cards_coax, rptrMonitorPortTable=rptrMonitorPortTable, rptrGroupPortCapacity=rptrGroupPortCapacity, rptrMonitorPortFCSErrors=rptrMonitorPortFCSErrors, rptrMonitorGroupTable=rptrMonitorGroupTable, rptrAddrTrackRptrInfo=rptrAddrTrackRptrInfo, DisplayString=DisplayString, ifExtensions=ifExtensions, linkBuilderFMSII_cards_12tp_rj45=linkBuilderFMSII_cards_12tp_rj45, linkSwitchMSH=linkSwitchMSH, rptrMonitorPortInfo=rptrMonitorPortInfo, rptrMonitorPortShortEvents=rptrMonitorPortShortEvents, snmp=snmp, rptrAddrTrackSourceAddrChanges=rptrAddrTrackSourceAddrChanges, linkBuilderFMSII=linkBuilderFMSII, multiRepeater=multiRepeater, dot3MauTypeAUI=dot3MauTypeAUI, fault=fault, rptrMonitorGroupInfo=rptrMonitorGroupInfo, rptrPortGroupIndex=rptrPortGroupIndex, dot3MauType10BaseFB=dot3MauType10BaseFB, brouter=brouter)

#
# PySNMP MIB module CHANNEL-CHANGE-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CHANNEL-CHANGE-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:48:31 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ValueSizeConstraint, ConstraintsIntersection, SingleValueConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ValueSizeConstraint", "ConstraintsIntersection", "SingleValueConstraint", "ConstraintsUnion")
InterfaceIndex, InterfaceIndexOrZero = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex", "InterfaceIndexOrZero")
ModuleCompliance, ObjectGroup, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup", "NotificationGroup")
NotificationType, Counter32, Counter64, ObjectIdentity, iso, Integer32, MibIdentifier, Gauge32, Unsigned32, Bits, TimeTicks, ModuleIdentity, IpAddress, enterprises, MibScalar, MibTable, MibTableRow, MibTableColumn = mibBuilder.importSymbols("SNMPv2-SMI", "NotificationType", "Counter32", "Counter64", "ObjectIdentity", "iso", "Integer32", "MibIdentifier", "Gauge32", "Unsigned32", "Bits", "TimeTicks", "ModuleIdentity", "IpAddress", "enterprises", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn")
TextualConvention, DisplayString, RowStatus = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString", "RowStatus")
channelChangeMib = ModuleIdentity((1, 3, 6, 1, 4, 1, 1, 1, 1))
if mibBuilder.loadTexts: channelChangeMib.setLastUpdated('200205121638Z')
if mibBuilder.loadTexts: channelChangeMib.setOrganization('FS VDSL Architecture Experts Group')
if mibBuilder.loadTexts: channelChangeMib.setContactInfo("FS-VDSL Secretariat -- editor's note: enter correct address in here Email: teresa.marsico@fs-vdsl.net")
if mibBuilder.loadTexts: channelChangeMib.setDescription('This module defines a MIB for managing the Channel Change Control Function within an OLT/ONU.')
fsan = MibIdentifier((1, 3, 6, 1, 4, 1, 1))
fsVdsl = MibIdentifier((1, 3, 6, 1, 4, 1, 1, 1))
channelChangeMibObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 1, 1, 1, 1))
channelChangeMibNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 1, 1, 1, 2))
channelTable = MibTable((1, 3, 6, 1, 4, 1, 1, 1, 1, 1, 1), )
if mibBuilder.loadTexts: channelTable.setStatus('current')
if mibBuilder.loadTexts: channelTable.setDescription('This defines the channels and associated ATM replication points (ATM VCCs) within the OLT/ONU. Note that the channel table supports both IP multicast addresses and DSM-CC program IDs as a means of channel lookup.')
channelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1, 1, 1, 1, 1, 1), ).setIndexNames((0, "CHANNEL-CHANGE-MIB", "channelId"))
if mibBuilder.loadTexts: channelEntry.setStatus('current')
if mibBuilder.loadTexts: channelEntry.setDescription('An entry in the channelTable represents a single channel.')
channelId = MibTableColumn((1, 3, 6, 1, 4, 1, 1, 1, 1, 1, 1, 1, 1), IpAddress())
if mibBuilder.loadTexts: channelId.setStatus('current')
if mibBuilder.loadTexts: channelId.setDescription('The channelId shall be a Class D IP address allocated to the multicast channel regardless of whether the channel is delivering video over UDP/IP multicast or AAL5. Where DSM-CC is used as the channel change protocol, this is also the DSM-CC Broadcast Program ID (BPID). This facilitates transparent mapping between the IGMP and DSM-CC channel change protocols.')
entitlementIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1, 1, 1, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: entitlementIndex.setStatus('current')
if mibBuilder.loadTexts: entitlementIndex.setDescription('The value of this object is the key for performing conditional access. The value zero (0) is reserved and is allocated to a channel which is free and does not require conditional access to be performed. Note that a maximum of 4095 channels can be supported by this MIB.')
networkPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 1, 1, 1, 1, 1, 1, 3), InterfaceIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: networkPortId.setStatus('current')
if mibBuilder.loadTexts: networkPortId.setDescription("The value of this object shall be equal to the ifIndex of the network interface in the OLT/ONU carrying the multicast channels. This is so that this object along with the vpi and vci objects below can be used as an index into the OLT's/ONU's ifTable to gather more information about the replication point(ATM VCC) such as peak bandwidth.")
vpi = MibTableColumn((1, 3, 6, 1, 4, 1, 1, 1, 1, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vpi.setStatus('current')
if mibBuilder.loadTexts: vpi.setDescription('The value of this object is equal to the VPI allocated to the replication point (ATM VCC) in the OLT/ONU for this channel.')
vci = MibTableColumn((1, 3, 6, 1, 4, 1, 1, 1, 1, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(32, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vci.setStatus('current')
if mibBuilder.loadTexts: vci.setDescription('The value of this object is equal to the VCI allocated to the replication point (ATM VCC) in the OLT/ONU for this channel.')
channelAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1, 1, 1, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("locked", 1), ("unlocked", 2), ("shuttingDown", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: channelAdminStatus.setStatus('current')
if mibBuilder.loadTexts: channelAdminStatus.setDescription('This object is used to control the management state of this channel. When this object is set to locked(1) all existing customers connected to this channel shall be immediately disconnected and further join requests to this channel should be rejected. If this object is set to shuttingDown(3), no further join requests should be accepted for this channel; when all existing customers have disconnected from this channel the value of this object moves to locked(1).')
channelRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1, 1, 1, 1, 1, 1, 8), RowStatus().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("active", 1), ("notInService", 2), ("notReady", 3), ("createAndGo", 4), ("createAndWait", 5), ("destroy", 6)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: channelRowStatus.setStatus('current')
if mibBuilder.loadTexts: channelRowStatus.setDescription('This object is used to manage row creation and deletion. When the channelAdminStatus is locked(1) the value of this object should be notInService(2). When the channelAdminStatus is unlocked(2) the value of this objects should be active(1) or notReady (3). When the value of channelAdminStatus is shuttingDown(3), the value of this object should be active(1).')
customerTable = MibTable((1, 3, 6, 1, 4, 1, 1, 1, 1, 1, 2), )
if mibBuilder.loadTexts: customerTable.setStatus('current')
if mibBuilder.loadTexts: customerTable.setDescription('This defines the customers for broadcast entertainment services.')
customerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1, 1, 1, 1, 2, 1), ).setIndexNames((0, "CHANNEL-CHANGE-MIB", "onuId"), (0, "CHANNEL-CHANGE-MIB", "customerPortId"))
if mibBuilder.loadTexts: customerEntry.setStatus('current')
if mibBuilder.loadTexts: customerEntry.setDescription('An entry in the customerTable represents a single customer.')
onuId = MibTableColumn((1, 3, 6, 1, 4, 1, 1, 1, 1, 1, 2, 1, 1), InterfaceIndexOrZero())
if mibBuilder.loadTexts: onuId.setStatus('current')
if mibBuilder.loadTexts: onuId.setDescription('Describes uniquely the ONU to which the customer is attached. The value of this object shall be the ifIndex of the interface in the OLT that connects to the associated ONU. If the OLT/ONU are integrated then the value of this object shall be zero (0).')
customerPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 1, 1, 1, 1, 2, 1, 2), InterfaceIndex())
if mibBuilder.loadTexts: customerPortId.setStatus('current')
if mibBuilder.loadTexts: customerPortId.setDescription('Describes uniquely the port within the ONU/OLT to which the customer is attached. The value of this object shall be the ifIndex of the port to which the customer is attached.')
maxMulticastTraffic = MibTableColumn((1, 3, 6, 1, 4, 1, 1, 1, 1, 1, 2, 1, 3), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: maxMulticastTraffic.setStatus('current')
if mibBuilder.loadTexts: maxMulticastTraffic.setDescription('This object defines the maximum amount of bandwidth in kilobit/s allocated to broadcast entertainment services. The value shall be an integer multiple of 10kbps and shall not exceed the DSL line rate.')
maxMulticastStreams = MibTableColumn((1, 3, 6, 1, 4, 1, 1, 1, 1, 1, 2, 1, 4), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: maxMulticastStreams.setStatus('current')
if mibBuilder.loadTexts: maxMulticastStreams.setDescription('This object defines the maximum number of multicast streams that can be active simultaneously across a DSL UNI. A value of zero (0) is used to indicate that this object shall not be used as part of any decision making process for a channel change request.')
untimedEntitlements1 = MibTableColumn((1, 3, 6, 1, 4, 1, 1, 1, 1, 1, 2, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 256))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: untimedEntitlements1.setStatus('current')
if mibBuilder.loadTexts: untimedEntitlements1.setDescription('This object is used as a bitmap to store untimed entitlements to premium channels. Note that the first bit of the first octet is reserved. Bits 1 to 2047 correspond to entitlements for channels with entitlementIndex between 1 and 2047, respectively. In order to entitlement channel with entitlementIndex x, the value of bit x in this bitmap shall be 1. In order to revoke entitlement to channel with entitlementIndex y, the value of bit y in this bitmap shall be 0.')
untimedEntitlements2 = MibTableColumn((1, 3, 6, 1, 4, 1, 1, 1, 1, 1, 2, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 256))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: untimedEntitlements2.setStatus('current')
if mibBuilder.loadTexts: untimedEntitlements2.setDescription('In order to support a greater number of channels this object is used in the same way as untimedEntitlements1 but bits 0 to 2048 correspond to entitlements for channels with entitlementIndex between 2048 and 4095, respectively. The index into this bitmap is entitlementIndex - 2048.')
grantEntitlement = MibTableColumn((1, 3, 6, 1, 4, 1, 1, 1, 1, 1, 2, 1, 7), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: grantEntitlement.setStatus('current')
if mibBuilder.loadTexts: grantEntitlement.setDescription('When granting entitlements to a single channel for many customers SNMP Setting the untimedEntitlement1/2 object leads to lots of management traffic due to the size of the untimedEntitlement1/2 object. In this situation it is much more bandwidth efficient to use this object. To grant an entitlement, the value of this object is SET to the channelId of the Channel for which entitlement is being granted to this customer. When this object is SET, the OLT/ONU shall automatically update the associated bit in the untimedEntitlement1/2 object to 1.')
revokeEntitlement = MibTableColumn((1, 3, 6, 1, 4, 1, 1, 1, 1, 1, 2, 1, 8), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: revokeEntitlement.setStatus('current')
if mibBuilder.loadTexts: revokeEntitlement.setDescription('When revoking entitlements to a single channel for many customers SNMP Setting the untimedEntitlement1/2 object leads to lots of management traffic due to the size of the untimedEntitlement1/2 object. In this situation it is much more bandwidth efficient to use this object. To revoke an entitlement, the value of this object is SET to the channelId of the Channel for which entitlement is being revoked for this customer. When this object is SET, the OLT/ONU shall automatically update the associated bit in the untimedEntitlement1/2 object to zero (0).')
customerAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1, 1, 1, 1, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("locked", 1), ("unlocked", 2), ("shuttingDown", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: customerAdminStatus.setStatus('current')
if mibBuilder.loadTexts: customerAdminStatus.setDescription('This object is used to control the management state of this customer. When this object is set to locked(1) all existing channels being delivered to this customer shall be immediately disconnected and further join requests from this customer shall be rejected. If this object is set to shuttingDown(3), no further join requests should be accepted from this customer; when all existing channels have been disconnected from this customer the value of this object moves to locked(1).')
customerRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1, 1, 1, 1, 2, 1, 10), RowStatus().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("active", 1), ("notInService", 2), ("notReady", 3), ("createAndGo", 4), ("createAndWait", 5), ("destroy", 6)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: customerRowStatus.setStatus('current')
if mibBuilder.loadTexts: customerRowStatus.setDescription('This object is used to manage row creation and deletion. When the channelAdminStatus is locked(1) the value of this object should be notInService(2). When the channelAdminStatus is unlocked(2) the value of this objects should be active(1) or notReady (3). When the value of channelAdminStatus is shuttingDown(3), the value of this object should be active(1).')
timedEntitlementTable = MibTable((1, 3, 6, 1, 4, 1, 1, 1, 1, 1, 3), )
if mibBuilder.loadTexts: timedEntitlementTable.setStatus('current')
if mibBuilder.loadTexts: timedEntitlementTable.setDescription('This table is used to store entitlements to channels that have a relatively short duration, such as PPV channels.')
timedEntitlementEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1, 1, 1, 1, 3, 1), ).setIndexNames((0, "CHANNEL-CHANGE-MIB", "timedEntitlementId"))
if mibBuilder.loadTexts: timedEntitlementEntry.setStatus('current')
if mibBuilder.loadTexts: timedEntitlementEntry.setDescription('An entry corresponds to timed entitlement for a single channel identified by the channelId. The same entry may be applicable to one or more customers as defined by the customerTimeEntitlementTable.')
timedEntitlementId = MibTableColumn((1, 3, 6, 1, 4, 1, 1, 1, 1, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: timedEntitlementId.setStatus('current')
if mibBuilder.loadTexts: timedEntitlementId.setDescription('Describes uniquely a timed entitlement.')
timedEntitlementChannelId = MibTableColumn((1, 3, 6, 1, 4, 1, 1, 1, 1, 1, 3, 1, 2), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: timedEntitlementChannelId.setStatus('current')
if mibBuilder.loadTexts: timedEntitlementChannelId.setDescription('This has the value of the channelId of the channelEntry for which this timedEntitlementEntry is for.')
startTime = MibTableColumn((1, 3, 6, 1, 4, 1, 1, 1, 1, 1, 3, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: startTime.setStatus('current')
if mibBuilder.loadTexts: startTime.setDescription('This is the time, expressed in UTC, from which time the channel is allowed to be viewed. When this time is less than or equal to the current time, the bit in the untimedEntitlement1/2 object corresponding to the channel for which this timedEntitlementEntry relates is set to 1.')
stopTime = MibTableColumn((1, 3, 6, 1, 4, 1, 1, 1, 1, 1, 3, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: stopTime.setStatus('current')
if mibBuilder.loadTexts: stopTime.setDescription('This is the time, expressed in UTC, after which time the channel is not allowed to be viewed. When this time is less than the current time, the bit in the untimedEntitlement1/2 object corresponding to the channel for which this timedEntitlementEntry relates is set to zero (0). Once this is done this timedEntitlementEntry shall also be removed from this table in order to stop this table growing indefinitely. Note that the information may be archived by the management system for audit purposes.')
entitlementRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1, 1, 1, 1, 3, 1, 5), RowStatus().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("active", 1), ("notInService", 2), ("notReady", 3), ("createAndGo", 4), ("createAndWait", 5), ("destroy", 6)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: entitlementRowStatus.setStatus('current')
if mibBuilder.loadTexts: entitlementRowStatus.setDescription('This object is used to manage row creation and deletion.')
customerTimedEntitlementTable = MibTable((1, 3, 6, 1, 4, 1, 1, 1, 1, 1, 4), )
if mibBuilder.loadTexts: customerTimedEntitlementTable.setStatus('current')
if mibBuilder.loadTexts: customerTimedEntitlementTable.setDescription('This table defines the timed entitlements used by a customer as defined by the associated timedEntitlementEntry.')
customerTimedEntitlementEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1, 1, 1, 1, 4, 1), ).setIndexNames((0, "CHANNEL-CHANGE-MIB", "custOnuId"), (0, "CHANNEL-CHANGE-MIB", "custPortId"), (0, "CHANNEL-CHANGE-MIB", "custTimedEntitlementId"))
if mibBuilder.loadTexts: customerTimedEntitlementEntry.setStatus('current')
if mibBuilder.loadTexts: customerTimedEntitlementEntry.setDescription('An entry corresponds to a timed entitlement for a customer.')
custOnuId = MibTableColumn((1, 3, 6, 1, 4, 1, 1, 1, 1, 1, 4, 1, 1), InterfaceIndexOrZero())
if mibBuilder.loadTexts: custOnuId.setStatus('current')
if mibBuilder.loadTexts: custOnuId.setDescription('Describes uniquely the ONU to which the customer is attached. The value of this object shall be the ifIndex of the interface in the OLT that connects to the associated ONU. If the OLT/ONU are integrated then the value of this object shall be zero (0).')
custPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 1, 1, 1, 1, 4, 1, 2), InterfaceIndex())
if mibBuilder.loadTexts: custPortId.setStatus('current')
if mibBuilder.loadTexts: custPortId.setDescription('Describes uniquely the port within the ONU/OLT to which the customer is attached. The value of this object shall be the ifIndex of the port to which the customer is attached.')
custTimedEntitlementId = MibTableColumn((1, 3, 6, 1, 4, 1, 1, 1, 1, 1, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: custTimedEntitlementId.setStatus('current')
if mibBuilder.loadTexts: custTimedEntitlementId.setDescription('This has the value of the timedEntitlementId for the timedEntitlementEntry that defined the timed entitlement to a channel for this customer.')
custTimedEntitlementRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1, 1, 1, 1, 4, 1, 4), RowStatus().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("active", 1), ("notInService", 2), ("notReady", 3), ("createAndGo", 4), ("createAndWait", 5), ("destroy", 6)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: custTimedEntitlementRowStatus.setStatus('current')
if mibBuilder.loadTexts: custTimedEntitlementRowStatus.setDescription('This object is used to manage row creation and deletion.')
channelChangeMibNotificationPrefix = MibIdentifier((1, 3, 6, 1, 4, 1, 1, 1, 1, 2, 0))
channelChangeCAFailed = NotificationType((1, 3, 6, 1, 4, 1, 1, 1, 1, 2, 0, 1)).setObjects(("CHANNEL-CHANGE-MIB", "rejectedOnuId"), ("CHANNEL-CHANGE-MIB", "rejectedCustomerPortId"))
if mibBuilder.loadTexts: channelChangeCAFailed.setStatus('current')
if mibBuilder.loadTexts: channelChangeCAFailed.setDescription('This trap is generated when conditional access fails for a requested channel change. The trap identifies the customer that issued the request.')
rejectedOnuId = MibScalar((1, 3, 6, 1, 4, 1, 1, 1, 1, 1, 5), InterfaceIndexOrZero()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rejectedOnuId.setStatus('current')
if mibBuilder.loadTexts: rejectedOnuId.setDescription('Identifies the ONU from which the rejected channel change request originated.')
rejectedCustomerPortId = MibScalar((1, 3, 6, 1, 4, 1, 1, 1, 1, 1, 6), InterfaceIndex()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rejectedCustomerPortId.setStatus('current')
if mibBuilder.loadTexts: rejectedCustomerPortId.setDescription('Identifies the DSL portfrom which the rejected channel change request originated.')
caFailedNotificationStatus = MibScalar((1, 3, 6, 1, 4, 1, 1, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: caFailedNotificationStatus.setStatus('current')
if mibBuilder.loadTexts: caFailedNotificationStatus.setDescription('This object is used to enable and disable the sending of the channelChangeCAFailed trap.')
channelChangeMibConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 1, 1, 1, 3))
channelChangeMibCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 1, 1, 1, 3, 1))
channelChangeMibGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 1, 1, 1, 3, 2))
channelChangeMibCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 1, 1, 1, 3, 1, 1)).setObjects(("CHANNEL-CHANGE-MIB", "channelChangeBasicGroup"), ("CHANNEL-CHANGE-MIB", "channelChangeCACGroup"), ("CHANNEL-CHANGE-MIB", "channelChangeBasicCAGroup"), ("CHANNEL-CHANGE-MIB", "channelChangeCA4095ChannelsGroup"), ("CHANNEL-CHANGE-MIB", "channelChangeCATimedEntitlementsGroup"), ("CHANNEL-CHANGE-MIB", "channelChangeCANotificationsGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    channelChangeMibCompliance = channelChangeMibCompliance.setStatus('current')
if mibBuilder.loadTexts: channelChangeMibCompliance.setDescription('The compliance statement for SNMP entities that support the channel change function as specified in FS-VDSL SA specification. For a system to conform to this MIB it shall also implement: - ifTable from RFC 2863 to define the physical interfaces.')
channelChangeBasicGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 1, 1, 1, 3, 2, 1)).setObjects(("CHANNEL-CHANGE-MIB", "channelId"), ("CHANNEL-CHANGE-MIB", "networkPortId"), ("CHANNEL-CHANGE-MIB", "vpi"), ("CHANNEL-CHANGE-MIB", "vci"), ("CHANNEL-CHANGE-MIB", "channelAdminStatus"), ("CHANNEL-CHANGE-MIB", "channelRowStatus"), ("CHANNEL-CHANGE-MIB", "onuId"), ("CHANNEL-CHANGE-MIB", "customerPortId"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    channelChangeBasicGroup = channelChangeBasicGroup.setStatus('current')
if mibBuilder.loadTexts: channelChangeBasicGroup.setDescription('A collection of objects required as a minimum to manage the Channel Change Control function.')
channelChangeCACGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 1, 1, 1, 3, 2, 2)).setObjects(("CHANNEL-CHANGE-MIB", "maxMulticastTraffic"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    channelChangeCACGroup = channelChangeCACGroup.setStatus('current')
if mibBuilder.loadTexts: channelChangeCACGroup.setDescription('A collection of objects required to support CAC.')
channelChangeBasicCAGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 1, 1, 1, 3, 2, 3)).setObjects(("CHANNEL-CHANGE-MIB", "maxMulticastStreams"), ("CHANNEL-CHANGE-MIB", "entitlementIndex"), ("CHANNEL-CHANGE-MIB", "untimedEntitlements1"), ("CHANNEL-CHANGE-MIB", "grantEntitlement"), ("CHANNEL-CHANGE-MIB", "revokeEntitlement"), ("CHANNEL-CHANGE-MIB", "rejectedOnuId"), ("CHANNEL-CHANGE-MIB", "rejectedCustomerPortId"), ("CHANNEL-CHANGE-MIB", "caFailedNotificationStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    channelChangeBasicCAGroup = channelChangeBasicCAGroup.setStatus('current')
if mibBuilder.loadTexts: channelChangeBasicCAGroup.setDescription('A collection of objects required to support CA with only untimed entitlements. This group is sufficient to support conditional access for up to 2047 channels.')
channelChangeCA4095ChannelsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 1, 1, 1, 3, 2, 4)).setObjects(("CHANNEL-CHANGE-MIB", "untimedEntitlements2"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    channelChangeCA4095ChannelsGroup = channelChangeCA4095ChannelsGroup.setStatus('current')
if mibBuilder.loadTexts: channelChangeCA4095ChannelsGroup.setDescription('This group is required in addition to the channelChangeBasicCAGroup to support CA for up to 4095 channels.')
channelChangeCATimedEntitlementsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 1, 1, 1, 3, 2, 5)).setObjects(("CHANNEL-CHANGE-MIB", "timedEntitlementId"), ("CHANNEL-CHANGE-MIB", "timedEntitlementChannelId"), ("CHANNEL-CHANGE-MIB", "startTime"), ("CHANNEL-CHANGE-MIB", "stopTime"), ("CHANNEL-CHANGE-MIB", "entitlementRowStatus"), ("CHANNEL-CHANGE-MIB", "custTimedEntitlementId"), ("CHANNEL-CHANGE-MIB", "custTimedEntitlementRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    channelChangeCATimedEntitlementsGroup = channelChangeCATimedEntitlementsGroup.setStatus('current')
if mibBuilder.loadTexts: channelChangeCATimedEntitlementsGroup.setDescription('This group is required in addition to the channelChangeBasicCAGroup, and if applicable the channelChangeCA4095ChannelsGroup, to support timed entitlements.')
channelChangeCANotificationsGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 1, 1, 1, 3, 2, 6)).setObjects(("CHANNEL-CHANGE-MIB", "channelChangeCAFailed"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    channelChangeCANotificationsGroup = channelChangeCANotificationsGroup.setStatus('current')
if mibBuilder.loadTexts: channelChangeCANotificationsGroup.setDescription('This group contains the notification used to inform management that a conditional access request failed. This group is optional if CA is implemented by the Channel Change Function.')
mibBuilder.exportSymbols("CHANNEL-CHANGE-MIB", rejectedOnuId=rejectedOnuId, custTimedEntitlementRowStatus=custTimedEntitlementRowStatus, maxMulticastStreams=maxMulticastStreams, maxMulticastTraffic=maxMulticastTraffic, customerTimedEntitlementEntry=customerTimedEntitlementEntry, custPortId=custPortId, untimedEntitlements1=untimedEntitlements1, channelChangeCAFailed=channelChangeCAFailed, channelChangeMibNotifications=channelChangeMibNotifications, customerAdminStatus=customerAdminStatus, rejectedCustomerPortId=rejectedCustomerPortId, channelAdminStatus=channelAdminStatus, vpi=vpi, timedEntitlementId=timedEntitlementId, customerTable=customerTable, customerTimedEntitlementTable=customerTimedEntitlementTable, untimedEntitlements2=untimedEntitlements2, channelChangeMibCompliance=channelChangeMibCompliance, entitlementIndex=entitlementIndex, channelId=channelId, entitlementRowStatus=entitlementRowStatus, channelChangeBasicGroup=channelChangeBasicGroup, channelChangeMibCompliances=channelChangeMibCompliances, channelTable=channelTable, channelChangeBasicCAGroup=channelChangeBasicCAGroup, stopTime=stopTime, PYSNMP_MODULE_ID=channelChangeMib, startTime=startTime, fsVdsl=fsVdsl, revokeEntitlement=revokeEntitlement, vci=vci, channelChangeMibNotificationPrefix=channelChangeMibNotificationPrefix, channelEntry=channelEntry, channelChangeMibConformance=channelChangeMibConformance, customerRowStatus=customerRowStatus, customerPortId=customerPortId, timedEntitlementEntry=timedEntitlementEntry, channelChangeMibObjects=channelChangeMibObjects, channelRowStatus=channelRowStatus, channelChangeCACGroup=channelChangeCACGroup, customerEntry=customerEntry, onuId=onuId, channelChangeMibGroups=channelChangeMibGroups, timedEntitlementTable=timedEntitlementTable, custOnuId=custOnuId, channelChangeMib=channelChangeMib, networkPortId=networkPortId, custTimedEntitlementId=custTimedEntitlementId, channelChangeCATimedEntitlementsGroup=channelChangeCATimedEntitlementsGroup, channelChangeCANotificationsGroup=channelChangeCANotificationsGroup, grantEntitlement=grantEntitlement, channelChangeCA4095ChannelsGroup=channelChangeCA4095ChannelsGroup, timedEntitlementChannelId=timedEntitlementChannelId, fsan=fsan, caFailedNotificationStatus=caFailedNotificationStatus)

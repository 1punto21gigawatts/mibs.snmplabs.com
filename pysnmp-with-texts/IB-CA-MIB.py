#
# PySNMP MIB module IB-CA-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/IB-CA-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:50:34 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint", "ConstraintsUnion")
infinibandMIB, IbPhysPort = mibBuilder.importSymbols("IB-TC-MIB", "infinibandMIB", "IbPhysPort")
ModuleCompliance, NotificationGroup, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup", "ObjectGroup")
Counter64, Gauge32, ModuleIdentity, Unsigned32, Bits, Integer32, TimeTicks, IpAddress, iso, Counter32, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, MibIdentifier, ObjectIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "Counter64", "Gauge32", "ModuleIdentity", "Unsigned32", "Bits", "Integer32", "TimeTicks", "IpAddress", "iso", "Counter32", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "MibIdentifier", "ObjectIdentity")
DisplayString, TruthValue, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TruthValue", "TextualConvention")
ibCaMIB = ModuleIdentity((1, 3, 6, 1, 3, 117, 4))
ibCaMIB.setRevisions(('2006-10-10 12:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ibCaMIB.setRevisionsDescriptions(('Initial version published as part of RFC XXXX.',))
if mibBuilder.loadTexts: ibCaMIB.setLastUpdated('200610101200Z')
if mibBuilder.loadTexts: ibCaMIB.setOrganization('IETF IP Over IB (IPOIB) Working Group')
if mibBuilder.loadTexts: ibCaMIB.setContactInfo('Hal Rosenstock Postal: HNR Consulting 200 Old Harvard Road Boxboro MA 01719-1834 United States Email: hnrose@earthlink.net Email comments to the IPOIB WG Mailing List at ipoverib@ietf.org.')
if mibBuilder.loadTexts: ibCaMIB.setDescription('Copyright (C) The Internet Society (2006). The initial version of this MIB module was published in RFC XXXX; for full legal notices see the RFC itself. Supplementary information may be available on http://www.ietf.org/copyrights/ianamib.html. This module contains managed object definitions for the instrumentation for an InfiniBand Channel Adapter (CA).')
ibCaObjects = MibIdentifier((1, 3, 6, 1, 3, 117, 4, 1))
ibCaConformance = MibIdentifier((1, 3, 6, 1, 3, 117, 4, 2))
ibCaGeneralInfo = MibIdentifier((1, 3, 6, 1, 3, 117, 4, 1, 1))
ibCaGeneralInfoTable = MibTable((1, 3, 6, 1, 3, 117, 4, 1, 1, 1), )
if mibBuilder.loadTexts: ibCaGeneralInfoTable.setStatus('current')
if mibBuilder.loadTexts: ibCaGeneralInfoTable.setDescription('A table containing general information about the Channel Adapters on this network entity.')
ibCaGeneralInfoEntry = MibTableRow((1, 3, 6, 1, 3, 117, 4, 1, 1, 1, 1), ).setIndexNames((0, "IB-CA-MIB", "ibCaIndex"))
if mibBuilder.loadTexts: ibCaGeneralInfoEntry.setStatus('current')
if mibBuilder.loadTexts: ibCaGeneralInfoEntry.setDescription('A conceptual row of the ibCaGeneralInfoTable containing information about the general characteristics of each Channel Adapter on this network entity.')
ibCaIndex = MibTableColumn((1, 3, 6, 1, 3, 117, 4, 1, 1, 1, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 254)))
if mibBuilder.loadTexts: ibCaIndex.setStatus('current')
if mibBuilder.loadTexts: ibCaIndex.setDescription('Index that identifies the specific CA on this network entity. The index is defined for a range of CAs from 1 to N, where N can have a maximum value of 254.')
ibCaType = MibTableColumn((1, 3, 6, 1, 3, 117, 4, 1, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("hca", 2), ("tca", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibCaType.setReference('InfiniBand Architecture Release 1.2 Vol. 1. Section 17.1.')
if mibBuilder.loadTexts: ibCaType.setStatus('current')
if mibBuilder.loadTexts: ibCaType.setDescription('Type of Channel Adapter: either a Host Channel Adapter (HCA), or a Target Channel Adapter (TCA). The key difference between an HCA and a TCA is that the HCA supports the IBA Verbs layer, while the TCA uses an implementation dependent interface to the transport layer. If the type of CA cannot be determined, the unknown(1) value is returned.')
ibCaNodeGuid = MibTableColumn((1, 3, 6, 1, 3, 117, 4, 1, 1, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibCaNodeGuid.setReference('InfiniBand Architecture Release 1.2 Vol. 1. Section 17.2.5.')
if mibBuilder.loadTexts: ibCaNodeGuid.setStatus('current')
if mibBuilder.loadTexts: ibCaNodeGuid.setDescription('The GUID of this CA. All ports on the same node shall report the same CA node GUID value. This provides a means for uniquely identifying a CA node within a subnet and helps to determine the co-location of the ports.')
ibCaNumPorts = MibTableColumn((1, 3, 6, 1, 3, 117, 4, 1, 1, 1, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 254))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibCaNumPorts.setReference('InfiniBand Architecture Release 1.2 Vol. 1. Section 17.2.1.3; Table 313 Port Attributes & Functions.')
if mibBuilder.loadTexts: ibCaNumPorts.setStatus('current')
if mibBuilder.loadTexts: ibCaNumPorts.setDescription('Number of physical IB data ports on this Channel Adapter. Ports are numbered starting from 1. If there is more than one port, the ports are numbered sequentially.')
ibCaAttrInfo = MibIdentifier((1, 3, 6, 1, 3, 117, 4, 1, 2))
ibCaAttributeTable = MibTable((1, 3, 6, 1, 3, 117, 4, 1, 2, 1), )
if mibBuilder.loadTexts: ibCaAttributeTable.setStatus('current')
if mibBuilder.loadTexts: ibCaAttributeTable.setDescription('A table containing information about the Channel Adapter attributes on this network entity.')
ibCaAttributeEntry = MibTableRow((1, 3, 6, 1, 3, 117, 4, 1, 2, 1, 1), ).setIndexNames((0, "IB-CA-MIB", "ibCaIndex"))
if mibBuilder.loadTexts: ibCaAttributeEntry.setStatus('current')
if mibBuilder.loadTexts: ibCaAttributeEntry.setDescription('A conceptual row of the ibCaAttributeTable containing information about the general characteristics of each Channel Adapter on this network entity.')
ibCaHasReliableConnection = MibTableColumn((1, 3, 6, 1, 3, 117, 4, 1, 2, 1, 1, 1), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibCaHasReliableConnection.setReference('InfiniBand Architecture Release 1.2 Vol. 1. Section 17.2.2; Table 314 Channel Adapter Attributes.')
if mibBuilder.loadTexts: ibCaHasReliableConnection.setStatus('current')
if mibBuilder.loadTexts: ibCaHasReliableConnection.setDescription('Flag that indicates whether this CA supports Reliable Connection (RC) transport service.')
ibCaHasUnreliableConnection = MibTableColumn((1, 3, 6, 1, 3, 117, 4, 1, 2, 1, 1, 2), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibCaHasUnreliableConnection.setReference('InfiniBand Architecture Release 1.2 Vol. 1. Section 17.2.2; Table 314 Channel Adapter Attributes.')
if mibBuilder.loadTexts: ibCaHasUnreliableConnection.setStatus('current')
if mibBuilder.loadTexts: ibCaHasUnreliableConnection.setDescription('Flag that indicates whether this CA supports Unreliable Connection (UC) transport service.')
ibCaHasReliableDatagram = MibTableColumn((1, 3, 6, 1, 3, 117, 4, 1, 2, 1, 1, 3), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibCaHasReliableDatagram.setReference('InfiniBand Architecture Release 1.2 Vol. 1. Section 17.2.2; Table 314 Channel Adapter Attributes.')
if mibBuilder.loadTexts: ibCaHasReliableDatagram.setStatus('current')
if mibBuilder.loadTexts: ibCaHasReliableDatagram.setDescription('Flag that indicates whether this CA supports Reliable Datagram (RD) transport service.')
ibCaHasUnreliableDatagram = MibTableColumn((1, 3, 6, 1, 3, 117, 4, 1, 2, 1, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibCaHasUnreliableDatagram.setReference('InfiniBand Architecture Release 1.2 Vol. 1. Section 17.2.2; Table 314 Channel Adapter Attributes.')
if mibBuilder.loadTexts: ibCaHasUnreliableDatagram.setStatus('current')
if mibBuilder.loadTexts: ibCaHasUnreliableDatagram.setDescription('Flag that indicates whether this CA supports Unreliable Datagram (UD) transport service.')
ibCaSupportsAtomicOperations = MibTableColumn((1, 3, 6, 1, 3, 117, 4, 1, 2, 1, 1, 5), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibCaSupportsAtomicOperations.setReference('InfiniBand Architecture Release 1.2 Vol. 1. Section 17.2.2; Table 314 Channel Adapter Attributes.')
if mibBuilder.loadTexts: ibCaSupportsAtomicOperations.setStatus('current')
if mibBuilder.loadTexts: ibCaSupportsAtomicOperations.setDescription('Flag that indicates whether this CA supports atomic operations. An atomic operation is an operation that is guaranteed to finish without having another operation alter the results once the atomic operation has been initiated.')
ibCaSupportsOtherOperations = MibTableColumn((1, 3, 6, 1, 3, 117, 4, 1, 2, 1, 1, 6), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibCaSupportsOtherOperations.setReference('InfiniBand Architecture Release 1.2 Vol. 1. Section 17.2.2; Table 314 Channel Adapter Attributes.')
if mibBuilder.loadTexts: ibCaSupportsOtherOperations.setStatus('current')
if mibBuilder.loadTexts: ibCaSupportsOtherOperations.setDescription('Flag that indicates whether this CA supports all of the other operations (excluding atomic operations) defined for a particular supported transport service.')
ibCaSupportsSolicitedEvents = MibTableColumn((1, 3, 6, 1, 3, 117, 4, 1, 2, 1, 1, 7), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibCaSupportsSolicitedEvents.setReference('InfiniBand Architecture Release 1.2 Vol. 1. Section 17.2.2; Table 314 Channel Adapter Attributes. and Section 9.2.3 Solicited Event (SE) - 1 bit.')
if mibBuilder.loadTexts: ibCaSupportsSolicitedEvents.setStatus('current')
if mibBuilder.loadTexts: ibCaSupportsSolicitedEvents.setDescription('Flag that indicates whether this CA supports the generation and reception of solicited events. A solicited event is a feature by which a queue pair consumer on a CA can cause an event to be generated at the destination when its message is received.')
ibCaPathMtuSetSupport = MibTableColumn((1, 3, 6, 1, 3, 117, 4, 1, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("mtu256", 1), ("mtu256n512", 2), ("mtu256n512n1024", 3), ("mtu256n512n1024n2048", 4), ("mtu256n512n1024n2048n4096", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibCaPathMtuSetSupport.setReference('InfiniBand Architecture Release 1.2 Vol. 1. Section 17.2.2; Table 314 Channel Adapter Attributes.')
if mibBuilder.loadTexts: ibCaPathMtuSetSupport.setStatus('current')
if mibBuilder.loadTexts: ibCaPathMtuSetSupport.setDescription('Set of MTU values (in bytes) supported by this CA for all transport service classes. The Maximum Transfer Unit is the largest size allowable for the packet payload.')
ibCaGenEndToEndFlowControl = MibTableColumn((1, 3, 6, 1, 3, 117, 4, 1, 2, 1, 1, 9), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibCaGenEndToEndFlowControl.setReference('InfiniBand Architecture Release 1.2 Vol. 1. Section 17.2.2; Table 314 Channel Adapter Attributes.')
if mibBuilder.loadTexts: ibCaGenEndToEndFlowControl.setStatus('current')
if mibBuilder.loadTexts: ibCaGenEndToEndFlowControl.setDescription('Flag that indicates whether this CA supports the generation of end-to-end flow control. End-to-end flow control is a mechanism that prevents sending messages when the destination does not have adequate receive buffers to receive the message.')
ibCaSupportsMulticast = MibTableColumn((1, 3, 6, 1, 3, 117, 4, 1, 2, 1, 1, 10), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibCaSupportsMulticast.setReference('InfiniBand Architecture Release 1.2 Vol. 1. Section 17.2.2; Table 314 Channel Adapter Attributes.')
if mibBuilder.loadTexts: ibCaSupportsMulticast.setStatus('current')
if mibBuilder.loadTexts: ibCaSupportsMulticast.setDescription('Flag that indicates whether this CA supports multicast operations. Multicast is the ability to deliver a single packet to multiple ports.')
ibCaSupportsAutoPathMigration = MibTableColumn((1, 3, 6, 1, 3, 117, 4, 1, 2, 1, 1, 11), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibCaSupportsAutoPathMigration.setReference('InfiniBand Architecture Release 1.2 Vol. 1. Section 17.2.2; Table 314 Channel Adapter Attributes.')
if mibBuilder.loadTexts: ibCaSupportsAutoPathMigration.setStatus('current')
if mibBuilder.loadTexts: ibCaSupportsAutoPathMigration.setDescription('Flag that indicates whether this CA supports automatic path migration. Automatic path migration is the process by which a CA (on a per QP basis) signals another CA to cause path migration to a preset alternate path.')
ibCaSupportsMemoryProtection = MibTableColumn((1, 3, 6, 1, 3, 117, 4, 1, 2, 1, 1, 12), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibCaSupportsMemoryProtection.setReference('InfiniBand Architecture Release 1.2 Vol. 1. Section 17.2.2; Table 314 Channel Adapter Attributes. and Section 10.6 Memory Management.')
if mibBuilder.loadTexts: ibCaSupportsMemoryProtection.setStatus('current')
if mibBuilder.loadTexts: ibCaSupportsMemoryProtection.setDescription('Flag that indicates whether this CA supports InfiniBand memory management protection mechanisms.')
ibCaSupportsLoopback = MibTableColumn((1, 3, 6, 1, 3, 117, 4, 1, 2, 1, 1, 13), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibCaSupportsLoopback.setReference('InfiniBand Architecture Release 1.2 Vol. 1. Section 17.2.2; Table 314 Channel Adapter Attributes.')
if mibBuilder.loadTexts: ibCaSupportsLoopback.setStatus('current')
if mibBuilder.loadTexts: ibCaSupportsLoopback.setDescription('Flag that indicates whether this CA supports loopback operations. Loopback support allows for the sending and receiving of self-addressed packets that do not go out on the wire. If this feature is supported, self-addressed packets must work, even if no switch is present.')
ibCaSupportsSubnetManager = MibTableColumn((1, 3, 6, 1, 3, 117, 4, 1, 2, 1, 1, 14), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibCaSupportsSubnetManager.setReference('InfiniBand Architecture Release 1.2 Vol. 1. Section 17.2.2; Table 314 Channel Adapter Attributes.')
if mibBuilder.loadTexts: ibCaSupportsSubnetManager.setStatus('current')
if mibBuilder.loadTexts: ibCaSupportsSubnetManager.setDescription('Flag that indicates whether this CA supports a Subnet Manager (SM) instance.')
ibCaPortAttrInfo = MibIdentifier((1, 3, 6, 1, 3, 117, 4, 1, 3))
ibCaPortAttributeTable = MibTable((1, 3, 6, 1, 3, 117, 4, 1, 3, 1), )
if mibBuilder.loadTexts: ibCaPortAttributeTable.setStatus('current')
if mibBuilder.loadTexts: ibCaPortAttributeTable.setDescription('A table containing information about the Channel Adapter port attributes on this network entity.')
ibCaPortAttributeEntry = MibTableRow((1, 3, 6, 1, 3, 117, 4, 1, 3, 1, 1), ).setIndexNames((0, "IB-CA-MIB", "ibCaIndex"), (0, "IB-CA-MIB", "ibCaPortIndex"))
if mibBuilder.loadTexts: ibCaPortAttributeEntry.setStatus('current')
if mibBuilder.loadTexts: ibCaPortAttributeEntry.setDescription('A conceptual row of the ibCaPortAttributeTable containing information about the general characteristics of each Channel Adapter port on this network entity.')
ibCaPortIndex = MibTableColumn((1, 3, 6, 1, 3, 117, 4, 1, 3, 1, 1, 1), IbPhysPort())
if mibBuilder.loadTexts: ibCaPortIndex.setStatus('current')
if mibBuilder.loadTexts: ibCaPortIndex.setDescription('Index that identifies the InfiniBand data port. The IBA defines a range of valid data ports from 1 to N, where N can have a maximum value of 254 for an IBA switch.')
ibCaPortGuid = MibTableColumn((1, 3, 6, 1, 3, 117, 4, 1, 3, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibCaPortGuid.setReference('InfiniBand Architecture Release 1.2 Vol. 1. Section 17.2.5.')
if mibBuilder.loadTexts: ibCaPortGuid.setStatus('current')
if mibBuilder.loadTexts: ibCaPortGuid.setDescription('The GUID of this CA port. All ports on the same CA shall report a unique ibCaPortGuid value. This provides a means for uniquely identifying a CA port on a node within a subnet and helps to determine the co-location of the ports.')
ibCaPhysicalInterface = MibTableColumn((1, 3, 6, 1, 3, 117, 4, 1, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("cable", 1), ("fiber", 2), ("backplane", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibCaPhysicalInterface.setReference('InfiniBand Architecture Release 1.2 Vol. 1. Section 17.2.1.3 Port Attributes and Functions; Vol. 2. 3.1 Introduction (Physical Layer Overview).')
if mibBuilder.loadTexts: ibCaPhysicalInterface.setStatus('current')
if mibBuilder.loadTexts: ibCaPhysicalInterface.setDescription('The physical interface for this CA. When the value is cable(1), the CA supports a cable connector physical interface. This physical attach point is defined for use with copper cables. When the value is fiber(2), the CA supports a fiber connector physical interface. This physical attach point is defined for use with optical cables. When the value is backplane(3), the CA supports a backplane connector physical interface. This physical attach point is defined for accepting a specified form factor that houses the channel adapter.')
ibCaSupportsStaticRateControl = MibTableColumn((1, 3, 6, 1, 3, 117, 4, 1, 3, 1, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibCaSupportsStaticRateControl.setReference('InfiniBand Architecture Release 1.2 Vol. 1. Section 17.2.6 Static Rate Control.')
if mibBuilder.loadTexts: ibCaSupportsStaticRateControl.setStatus('current')
if mibBuilder.loadTexts: ibCaSupportsStaticRateControl.setDescription('Flag that indicates whether this CA supports static rate control. Static rate controls are required for all IB ports that support a data rate over 2.5 Gbps.')
ibCaInterpacketDelayValue = MibTableColumn((1, 3, 6, 1, 3, 117, 4, 1, 3, 1, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibCaInterpacketDelayValue.setReference('InfiniBand Architecture Release 1.2 Vol. 1. Section 17.2.6 Static Rate Control, and Table 315 Static Rate Control IPD Values. Section 9.11.1 Static Rate Control for Heterogeneous Links, and Table 63 Inter Packet Delay')
if mibBuilder.loadTexts: ibCaInterpacketDelayValue.setStatus('current')
if mibBuilder.loadTexts: ibCaInterpacketDelayValue.setDescription('Interpacket Delay Value (IPD) supported for CAs that have static rate control (i.e., the ibCaSupportsStaticRateControl object must have a value of true(1) for this object to contain a valid value; Otherwise, 0 is returned). The IPD allows for the slowing of the packet rate for all of the standard link rates.')
ibCaSupportsMultipathing = MibTableColumn((1, 3, 6, 1, 3, 117, 4, 1, 3, 1, 1, 6), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibCaSupportsMultipathing.setReference('InfiniBand Architecture Release 1.2 Vol. 1. Section 17.2.1.3 and Table 313 Port Attributes & Functions; Also, Section 7.11.1 Multipathing Requirements on End Node.')
if mibBuilder.loadTexts: ibCaSupportsMultipathing.setStatus('current')
if mibBuilder.loadTexts: ibCaSupportsMultipathing.setDescription('Flag that indicates whether this CA supports multipathing. The CA link layer port checks the unicast DLID in the received packet for validity by masking the number of low order bits indicated by the LID Mask Control field (LMC) before comparing the DLID to its assigned LID if this object is true(1).')
ibCaValidatesInPktDlid = MibTableColumn((1, 3, 6, 1, 3, 117, 4, 1, 3, 1, 1, 7), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibCaValidatesInPktDlid.setReference('InfiniBand Architecture Release 1.2 Vol. 1. Section 17.2.1.3. and Table 313 Port Attributes & Functions.')
if mibBuilder.loadTexts: ibCaValidatesInPktDlid.setStatus('current')
if mibBuilder.loadTexts: ibCaValidatesInPktDlid.setDescription('Flag that indicates whether this CA supports the validation of incoming packet DLIDs, and if the GRH is present, the DGID.')
ibCaMaxGidsPerPort = MibTableColumn((1, 3, 6, 1, 3, 117, 4, 1, 3, 1, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibCaMaxGidsPerPort.setReference('InfiniBand Architecture Release 1.2 Vol. 1. Section 17.2.1.3. and Table 313 Port Attributes & Functions.')
if mibBuilder.loadTexts: ibCaMaxGidsPerPort.setStatus('current')
if mibBuilder.loadTexts: ibCaMaxGidsPerPort.setDescription('Maximum number of GIDs per port. The maximum number of unicast GIDs supported per CA port is implementation specific. Each port will support at least one (1) GID.')
ibCaPortGidTable = MibTable((1, 3, 6, 1, 3, 117, 4, 1, 3, 2), )
if mibBuilder.loadTexts: ibCaPortGidTable.setStatus('current')
if mibBuilder.loadTexts: ibCaPortGidTable.setDescription('A table containing the port GIDs for each CA.')
ibCaPortGidEntry = MibTableRow((1, 3, 6, 1, 3, 117, 4, 1, 3, 2, 1), ).setIndexNames((0, "IB-CA-MIB", "ibCaIndex"), (0, "IB-CA-MIB", "ibCaPortIndex"), (0, "IB-CA-MIB", "ibCaPortGidIndex"))
if mibBuilder.loadTexts: ibCaPortGidEntry.setStatus('current')
if mibBuilder.loadTexts: ibCaPortGidEntry.setDescription('A conceptual row of the ibCaPortGidTable containing information about a particular GID on an IB port for a particular CA.')
ibCaPortGidIndex = MibTableColumn((1, 3, 6, 1, 3, 117, 4, 1, 3, 2, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: ibCaPortGidIndex.setStatus('current')
if mibBuilder.loadTexts: ibCaPortGidIndex.setDescription('Index that identifies the GID entry for this IB data port. Each port on a CA is assigned at least 1 unicast GID. Note, the value of ibCaPortGidIndex will never be greater than the value of ibCaMaxGidsPerPort that defines the upper value for this index.')
ibCaPortGidValue = MibTableColumn((1, 3, 6, 1, 3, 117, 4, 1, 3, 2, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibCaPortGidValue.setReference('InfiniBand Architecture Release 1.2 Vol. 1. Section 4.1.1 GID Usage and Properties.')
if mibBuilder.loadTexts: ibCaPortGidValue.setStatus('current')
if mibBuilder.loadTexts: ibCaPortGidValue.setDescription('The Global Identifier (GID) is a 128-bit (16-byte) unicast or multicast identifier used to identify a channel adapter port. A GID is a valid 128-bit IPv6 address (as defined in RFC 2373) with additional IBA modifications that facilitate node discovery, routing, and communications.')
ibCaCompliances = MibIdentifier((1, 3, 6, 1, 3, 117, 4, 2, 1))
ibCaGroups = MibIdentifier((1, 3, 6, 1, 3, 117, 4, 2, 2))
ibCaBasicCompliance = ModuleCompliance((1, 3, 6, 1, 3, 117, 4, 2, 1, 1)).setObjects(("IB-CA-MIB", "ibCaGeneralGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibCaBasicCompliance = ibCaBasicCompliance.setStatus('current')
if mibBuilder.loadTexts: ibCaBasicCompliance.setDescription('The basic CA implementation requirements for agents that support the IPOIB CA MIB.')
ibCaFullCompliance = ModuleCompliance((1, 3, 6, 1, 3, 117, 4, 2, 1, 2)).setObjects(("IB-CA-MIB", "ibCaGeneralGroup"), ("IB-CA-MIB", "ibCaAttrGroup"), ("IB-CA-MIB", "ibCaPortAttrGroup"), ("IB-CA-MIB", "ibCaPortGidGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibCaFullCompliance = ibCaFullCompliance.setStatus('current')
if mibBuilder.loadTexts: ibCaFullCompliance.setDescription('The complete node implementation requirements for agents that support the full IPOIB CA MIB.')
ibCaGeneralGroup = ObjectGroup((1, 3, 6, 1, 3, 117, 4, 2, 2, 1)).setObjects(("IB-CA-MIB", "ibCaType"), ("IB-CA-MIB", "ibCaNodeGuid"), ("IB-CA-MIB", "ibCaNumPorts"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibCaGeneralGroup = ibCaGeneralGroup.setStatus('current')
if mibBuilder.loadTexts: ibCaGeneralGroup.setDescription('The ibCaGeneralGroup defines the MIB objects that describe the general characteristics of this Channel Adapter.')
ibCaAttrGroup = ObjectGroup((1, 3, 6, 1, 3, 117, 4, 2, 2, 2)).setObjects(("IB-CA-MIB", "ibCaHasReliableConnection"), ("IB-CA-MIB", "ibCaHasUnreliableConnection"), ("IB-CA-MIB", "ibCaHasReliableDatagram"), ("IB-CA-MIB", "ibCaHasUnreliableDatagram"), ("IB-CA-MIB", "ibCaSupportsAtomicOperations"), ("IB-CA-MIB", "ibCaSupportsOtherOperations"), ("IB-CA-MIB", "ibCaSupportsSolicitedEvents"), ("IB-CA-MIB", "ibCaPathMtuSetSupport"), ("IB-CA-MIB", "ibCaGenEndToEndFlowControl"), ("IB-CA-MIB", "ibCaSupportsMulticast"), ("IB-CA-MIB", "ibCaSupportsAutoPathMigration"), ("IB-CA-MIB", "ibCaSupportsMemoryProtection"), ("IB-CA-MIB", "ibCaSupportsLoopback"), ("IB-CA-MIB", "ibCaSupportsSubnetManager"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibCaAttrGroup = ibCaAttrGroup.setStatus('current')
if mibBuilder.loadTexts: ibCaAttrGroup.setDescription('The ibCaAttrGroup defines the MIB objects that describe more specific attributes about the Channel Adapter.')
ibCaPortAttrGroup = ObjectGroup((1, 3, 6, 1, 3, 117, 4, 2, 2, 3)).setObjects(("IB-CA-MIB", "ibCaPortGuid"), ("IB-CA-MIB", "ibCaPhysicalInterface"), ("IB-CA-MIB", "ibCaSupportsStaticRateControl"), ("IB-CA-MIB", "ibCaInterpacketDelayValue"), ("IB-CA-MIB", "ibCaSupportsMultipathing"), ("IB-CA-MIB", "ibCaValidatesInPktDlid"), ("IB-CA-MIB", "ibCaMaxGidsPerPort"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibCaPortAttrGroup = ibCaPortAttrGroup.setStatus('current')
if mibBuilder.loadTexts: ibCaPortAttrGroup.setDescription('The ibCaPortAttrGroup defines the MIB objects that describe attributes about the Channel Adapter ports.')
ibCaPortGidGroup = ObjectGroup((1, 3, 6, 1, 3, 117, 4, 2, 2, 4)).setObjects(("IB-CA-MIB", "ibCaPortGidValue"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibCaPortGidGroup = ibCaPortGidGroup.setStatus('current')
if mibBuilder.loadTexts: ibCaPortGidGroup.setDescription('The ibCaPortGidGroup defines the MIB objects that describe attributes about the Channel Adapter port GIDs.')
mibBuilder.exportSymbols("IB-CA-MIB", ibCaFullCompliance=ibCaFullCompliance, ibCaSupportsAtomicOperations=ibCaSupportsAtomicOperations, PYSNMP_MODULE_ID=ibCaMIB, ibCaHasReliableConnection=ibCaHasReliableConnection, ibCaHasUnreliableConnection=ibCaHasUnreliableConnection, ibCaPortGidTable=ibCaPortGidTable, ibCaHasUnreliableDatagram=ibCaHasUnreliableDatagram, ibCaPortGidIndex=ibCaPortGidIndex, ibCaPortAttrGroup=ibCaPortAttrGroup, ibCaObjects=ibCaObjects, ibCaAttributeEntry=ibCaAttributeEntry, ibCaPortGidValue=ibCaPortGidValue, ibCaConformance=ibCaConformance, ibCaAttrInfo=ibCaAttrInfo, ibCaValidatesInPktDlid=ibCaValidatesInPktDlid, ibCaAttrGroup=ibCaAttrGroup, ibCaGeneralInfoTable=ibCaGeneralInfoTable, ibCaGeneralGroup=ibCaGeneralGroup, ibCaPortAttributeTable=ibCaPortAttributeTable, ibCaAttributeTable=ibCaAttributeTable, ibCaSupportsAutoPathMigration=ibCaSupportsAutoPathMigration, ibCaSupportsMultipathing=ibCaSupportsMultipathing, ibCaNodeGuid=ibCaNodeGuid, ibCaPathMtuSetSupport=ibCaPathMtuSetSupport, ibCaSupportsSubnetManager=ibCaSupportsSubnetManager, ibCaGeneralInfoEntry=ibCaGeneralInfoEntry, ibCaSupportsStaticRateControl=ibCaSupportsStaticRateControl, ibCaSupportsOtherOperations=ibCaSupportsOtherOperations, ibCaPortIndex=ibCaPortIndex, ibCaMaxGidsPerPort=ibCaMaxGidsPerPort, ibCaPortGidEntry=ibCaPortGidEntry, ibCaCompliances=ibCaCompliances, ibCaGroups=ibCaGroups, ibCaSupportsLoopback=ibCaSupportsLoopback, ibCaBasicCompliance=ibCaBasicCompliance, ibCaSupportsMemoryProtection=ibCaSupportsMemoryProtection, ibCaGenEndToEndFlowControl=ibCaGenEndToEndFlowControl, ibCaPortGuid=ibCaPortGuid, ibCaInterpacketDelayValue=ibCaInterpacketDelayValue, ibCaNumPorts=ibCaNumPorts, ibCaIndex=ibCaIndex, ibCaGeneralInfo=ibCaGeneralInfo, ibCaPhysicalInterface=ibCaPhysicalInterface, ibCaPortAttributeEntry=ibCaPortAttributeEntry, ibCaHasReliableDatagram=ibCaHasReliableDatagram, ibCaMIB=ibCaMIB, ibCaSupportsSolicitedEvents=ibCaSupportsSolicitedEvents, ibCaPortAttrInfo=ibCaPortAttrInfo, ibCaSupportsMulticast=ibCaSupportsMulticast, ibCaPortGidGroup=ibCaPortGidGroup, ibCaType=ibCaType)

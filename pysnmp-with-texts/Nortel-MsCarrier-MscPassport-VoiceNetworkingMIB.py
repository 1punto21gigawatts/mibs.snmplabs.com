#
# PySNMP MIB module Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB
# Produced by pysmi-0.3.4 at Wed May  1 14:31:40 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, SingleValueConstraint, ConstraintsUnion, ValueRangeConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsUnion", "ValueRangeConstraint", "ConstraintsIntersection")
DisplayString, RowPointer, InterfaceIndex, RowStatus, Unsigned32, Counter32, Gauge32, StorageType, Integer32 = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-StandardTextualConventionsMIB", "DisplayString", "RowPointer", "InterfaceIndex", "RowStatus", "Unsigned32", "Counter32", "Gauge32", "StorageType", "Integer32")
PassportCounter64, DigitString, AsciiString, EnterpriseDateAndTime, Link, NonReplicated, Hex = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-TextualConventionsMIB", "PassportCounter64", "DigitString", "AsciiString", "EnterpriseDateAndTime", "Link", "NonReplicated", "Hex")
mscComponents, mscPassportMIBs = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-UsefulDefinitionsMIB", "mscComponents", "mscPassportMIBs")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
ObjectIdentity, iso, Counter64, IpAddress, TimeTicks, NotificationType, ModuleIdentity, Unsigned32, Bits, Counter32, Gauge32, Integer32, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn = mibBuilder.importSymbols("SNMPv2-SMI", "ObjectIdentity", "iso", "Counter64", "IpAddress", "TimeTicks", "NotificationType", "ModuleIdentity", "Unsigned32", "Bits", "Counter32", "Gauge32", "Integer32", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
voiceNetworkingMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 109))
mscSigChan = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115))
mscSigChanRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 1), )
if mibBuilder.loadTexts: mscSigChanRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanRowStatusTable.setDescription('This entry controls the addition and deletion of mscSigChan components.')
mscSigChanRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscSigChanIndex"))
if mibBuilder.loadTexts: mscSigChanRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanRowStatusEntry.setDescription('A single entry in the table represents a single mscSigChan component.')
mscSigChanRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscSigChanRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscSigChan components. These components can be added and deleted.')
mscSigChanComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscSigChanStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanStorageType.setDescription('This variable represents the storage type value for the mscSigChan tables.')
mscSigChanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)))
if mibBuilder.loadTexts: mscSigChanIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanIndex.setDescription('This variable represents the index for the mscSigChan tables.')
mscSigChanCidDataTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 100), )
if mibBuilder.loadTexts: mscSigChanCidDataTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanCidDataTable.setDescription("This group contains the attribute for a component's Customer Identifier (CID). Refer to the attribute description for a detailed explanation of CIDs.")
mscSigChanCidDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 100, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscSigChanIndex"))
if mibBuilder.loadTexts: mscSigChanCidDataEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanCidDataEntry.setDescription('An entry in the mscSigChanCidDataTable.')
mscSigChanCustomerIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 100, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 8191), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscSigChanCustomerIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanCustomerIdentifier.setDescription("This attribute holds the Customer Identifier (CID). Every component has a CID. If a component has a cid attribute, the component's CID is the provisioned value of that attribute; otherwise the component inherits the CID of its parent. The top- level component has a CID of 0. Every operator session also has a CID, which is the CID provisioned for the operator's user ID. An operator will see only the stream data for components having a matching CID. Also, the operator will be allowed to issue commands for only those components which have a matching CID. An operator CID of 0 is used to identify the Network Manager (referred to as 'NetMan' in DPN). This CID matches the CID of any component. Values 1 to 8191 inclusive (equivalent to 'basic CIDs' in DPN) may be assigned to specific customers.")
mscSigChanIfEntryTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 101), )
if mibBuilder.loadTexts: mscSigChanIfEntryTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanIfEntryTable.setDescription('This group contains the provisionable attributes for the ifEntry.')
mscSigChanIfEntryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 101, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscSigChanIndex"))
if mibBuilder.loadTexts: mscSigChanIfEntryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanIfEntryEntry.setDescription('An entry in the mscSigChanIfEntryTable.')
mscSigChanIfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 101, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscSigChanIfAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanIfAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational. The down state indicates the interface is not operational. The testing state indicates that no operational packets can be passed.')
mscSigChanIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 101, 1, 2), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanIfIndex.setDescription('This is the index for the IfEntry. Its value is automatically initialized during the provisioning process.')
mscSigChanOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 102), )
if mibBuilder.loadTexts: mscSigChanOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
mscSigChanOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 102, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscSigChanIndex"))
if mibBuilder.loadTexts: mscSigChanOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanOperStatusEntry.setDescription('An entry in the mscSigChanOperStatusTable.')
mscSigChanSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 102, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
mscSigChanStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 103), )
if mibBuilder.loadTexts: mscSigChanStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscSigChanStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 103, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscSigChanIndex"))
if mibBuilder.loadTexts: mscSigChanStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanStateEntry.setDescription('An entry in the mscSigChanStateTable.')
mscSigChanAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 103, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscSigChanOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 103, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscSigChanUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 103, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscSigChanProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 104), )
if mibBuilder.loadTexts: mscSigChanProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanProvTable.setDescription('This group represents the provisionable attributes of a SigChan.')
mscSigChanProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 104, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscSigChanIndex"))
if mibBuilder.loadTexts: mscSigChanProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanProvEntry.setDescription('An entry in the mscSigChanProvTable.')
mscSigChanCommentText = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 104, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscSigChanCommentText.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanCommentText.setDescription('Use of this attribute is at the discretion of the system administrator. Typically, this attribute specifies the name of the customer that is using this SigChan.')
mscSigChanOctothorpeEod = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 104, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("yes", 0), ("no", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscSigChanOctothorpeEod.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanOctothorpeEod.setDescription('This attribute specifies whether the octothorpe should be used as an end of dialling indication. When this character is received, only the digits that have been received to that point will be used for address resolution. All subsequent digits will be forwarded to the far-end, but they will not be used. The octothorpe will not be sent to the far-end.')
mscSigChanForceNpiTon = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 104, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("yes", 0), ("no", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscSigChanForceNpiTon.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanForceNpiTon.setDescription('This attribute, together with the defaultNpiTon attribute, controls Numbering Plan Identifier (NPI) and Type Of Number (TON) values to be used by the SigChan component for egress calls (if applicable). If set to yes, NPI and TON values defined by the defaultNpiTon attribute unconditionally overwrite values received in the call setup message from the subnet.')
mscSigChanDefaultNpiTon = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 104, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("unknown", 0), ("international", 1), ("national", 2), ("subscriber", 3), ("p0", 4), ("p1", 5), ("p2", 6), ("p3", 7), ("p4", 8), ("p5", 9), ("p6", 10), ("p7", 11), ("casUnknown", 12))).clone('casUnknown')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscSigChanDefaultNpiTon.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanDefaultNpiTon.setDescription("This attribute, together with the forceNpiTon attribute, controls Numbering Plan Identifier (NPI) and Type Of Number (TON) values to be used by the SigChan component for egress calls (if applicable). The combination of NPI and TON values defined by the defaultNpiTon attribute is used for an egress call whenever: - the call setup message received from subnet indicates that NPI or TON information is not supplied or doesn't make sense, or - attribute forceNpiTon is set to yes Mapping between values of the defaultNpiTon attribute and associated combinations of NPI and TON values follows: casUnknown: NPI=unknown (0) TON=unknown (0) unknown: NPI=E.164 (1) TON=unknown (0) international: NPI=E.164 (1) TON=international (1) national: NPI=E.164 (1) TON=national (2) subscriber: NPI=E.164 (1) TON=subscriber (4) p0: NPI=private(9) TON=0 p1: NPI=private(9) TON=1 p2: NPI=private(9) TON=2 p3: NPI=private(9) TON=3 p4: NPI=private(9) TON=4 p5: NPI=private(9) TON=5 p6: NPI=private(9) TON=6 p7: NPI=private(9) TON=7")
mscSigChanSubroutesTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 307), )
if mibBuilder.loadTexts: mscSigChanSubroutesTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanSubroutesTable.setDescription('This attribute identifies all of the VoiceSubroutes which are associated with this signalling channel.')
mscSigChanSubroutesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 307, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscSigChanIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscSigChanSubroutesValue"))
if mibBuilder.loadTexts: mscSigChanSubroutesEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanSubroutesEntry.setDescription('An entry in the mscSigChanSubroutesTable.')
mscSigChanSubroutesValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 307, 1, 1), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscSigChanSubroutesValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanSubroutesValue.setDescription('This variable represents both the value and the index for the mscSigChanSubroutesTable.')
mscSigChanSubroutesRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 307, 1, 2), RowStatus()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mscSigChanSubroutesRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanSubroutesRowStatus.setDescription('This variable is used to control the addition and deletion of individual values of the mscSigChanSubroutesTable.')
mscSigChanDegradedSubroutesTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 308), )
if mibBuilder.loadTexts: mscSigChanDegradedSubroutesTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanDegradedSubroutesTable.setDescription('This attribute lists all of the VoiceSubroute components that do not have all of their SwitchedVoiceService subcomponents available for use.')
mscSigChanDegradedSubroutesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 308, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscSigChanIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscSigChanDegradedSubroutesValue"))
if mibBuilder.loadTexts: mscSigChanDegradedSubroutesEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanDegradedSubroutesEntry.setDescription('An entry in the mscSigChanDegradedSubroutesTable.')
mscSigChanDegradedSubroutesValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 308, 1, 1), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanDegradedSubroutesValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanDegradedSubroutesValue.setDescription('This variable represents both the value and the index for the mscSigChanDegradedSubroutesTable.')
mscSigChanBch = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 7))
mscSigChanBchRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 7, 1), )
if mibBuilder.loadTexts: mscSigChanBchRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanBchRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of mscSigChanBch components.')
mscSigChanBchRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 7, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscSigChanIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscSigChanBchIndex"))
if mibBuilder.loadTexts: mscSigChanBchRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanBchRowStatusEntry.setDescription('A single entry in the table represents a single mscSigChanBch component.')
mscSigChanBchRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 7, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanBchRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanBchRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscSigChanBch components. These components cannot be added nor deleted.')
mscSigChanBchComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 7, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanBchComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanBchComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscSigChanBchStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 7, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanBchStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanBchStorageType.setDescription('This variable represents the storage type value for the mscSigChanBch tables.')
mscSigChanBchIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 7, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 331)))
if mibBuilder.loadTexts: mscSigChanBchIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanBchIndex.setDescription('This variable represents the index for the mscSigChanBch tables.')
mscSigChanBchOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 7, 4), )
if mibBuilder.loadTexts: mscSigChanBchOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanBchOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains various operational attributes of a B-channel serviced by a Signalling Channel.')
mscSigChanBchOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 7, 4, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscSigChanIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscSigChanBchIndex"))
if mibBuilder.loadTexts: mscSigChanBchOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanBchOperEntry.setDescription('An entry in the mscSigChanBchOperTable.')
mscSigChanBchStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 7, 4, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("unknown", 0), ("maintB", 1), ("idle", 2), ("busy", 3), ("ingress", 4), ("egress", 5), ("idleMaintenance", 6), ("ingressMaintenance", 7), ("egressMaintenance", 8), ("outOfService", 9))).clone('unknown')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanBchStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanBchStatus.setDescription('This attribute indicates what is current internal B-channel state. The attribute may have the following values for any supported access signalling protocol on Passport: unknown, the B-channel has not registered yet for SigChan services maintB, the B-channel is undergoing a maintenance action idle, the B-channel is available for ingress/egress calls busy, the B-channel is currently being used for an ingress or egress call ingress, the B-channel is currently being used for an ingress call (from the external network to the subnet) egress, the B-channel is currently being used for an egress call (from the subnet to the external network) In addition, CCS protocols supporting SERVICE messaging may also use the following values: idleMaintenance, the B-channel received a SERVICE message placing the channel in maintenance, and no calls are active on the channel ingressMaintenance, the B-channel received a SERVICE message placing the channel in maintenance, and an incoming call is active on the channel egressMaintenance, the B-channel received a SERVICE message placing the channel in maintenance, and an outgoing call is active on the channel outOfService, a SERVICE message to or from the PBX has placed the channel out of service')
mscSigChanBchTimeSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 7, 4, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanBchTimeSlot.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanBchTimeSlot.setDescription('This attribute indicates which timeslot the B-channel uses.')
mscSigChanBchVsrInstance = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 7, 4, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanBchVsrInstance.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanBchVsrInstance.setDescription('This attribute indicates the component instance of the VoiceSubroute to which the B-channel belongs.')
mscSigChanBchCalledDirectoryNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 7, 4, 1, 4), DigitString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanBchCalledDirectoryNumber.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanBchCalledDirectoryNumber.setDescription('This attribute indicates the dialled number for the currently active call on this B-channel.')
mscSigChanGw = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 15))
mscSigChanGwRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 15, 1), )
if mibBuilder.loadTexts: mscSigChanGwRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanGwRowStatusTable.setDescription('This entry controls the addition and deletion of mscSigChanGw components.')
mscSigChanGwRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 15, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscSigChanIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscSigChanGwIndex"))
if mibBuilder.loadTexts: mscSigChanGwRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanGwRowStatusEntry.setDescription('A single entry in the table represents a single mscSigChanGw component.')
mscSigChanGwRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 15, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanGwRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanGwRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscSigChanGw components. These components cannot be added nor deleted.')
mscSigChanGwComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 15, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanGwComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanGwComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscSigChanGwStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 15, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanGwStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanGwStorageType.setDescription('This variable represents the storage type value for the mscSigChanGw tables.')
mscSigChanGwIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 15, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscSigChanGwIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanGwIndex.setDescription('This variable represents the index for the mscSigChanGw tables.')
mscSigChanGwStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 15, 101), )
if mibBuilder.loadTexts: mscSigChanGwStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanGwStatsTable.setDescription('This group provides signalling gateway related statistical attributes for the SigChan component.')
mscSigChanGwStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 15, 101, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscSigChanIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscSigChanGwIndex"))
if mibBuilder.loadTexts: mscSigChanGwStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanGwStatsEntry.setDescription('An entry in the mscSigChanGwStatsTable.')
mscSigChanGwRequiredConversions = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 15, 101, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanGwRequiredConversions.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanGwRequiredConversions.setDescription('This attribute counts the total number of calls that have been made from the subnet to the interface (that is external equipment, for example a PBX) which needed signalling protocol conversion. The value wraps to zero when it exceeds its maximum. The count includes both, supported and unsupported conversions.')
mscSigChanGwUnsupportedConversions = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 15, 101, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanGwUnsupportedConversions.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanGwUnsupportedConversions.setDescription('This attribute counts the total number of calls that have been made from the subnet to the interface (that is external equipment, for example a PBX) which needed signalling protocol conversion but were rejected since the requested conversion was not supported. The value wraps to zero when it exceeds its maximum.')
mscSigChanGwGwcTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 15, 301), )
if mibBuilder.loadTexts: mscSigChanGwGwcTable.setStatus('obsolete')
if mibBuilder.loadTexts: mscSigChanGwGwcTable.setDescription('This attribute has been migrated to gatewayCapability.')
mscSigChanGwGwcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 15, 301, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscSigChanIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscSigChanGwIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscSigChanGwGwcIndex"))
if mibBuilder.loadTexts: mscSigChanGwGwcEntry.setStatus('obsolete')
if mibBuilder.loadTexts: mscSigChanGwGwcEntry.setDescription('An entry in the mscSigChanGwGwcTable.')
mscSigChanGwGwcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 15, 301, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("etsiQsigPG", 0), ("nisPG", 1), ("analogAndCasPG", 2), ("euroIsdnPG", 3), ("mcdnPG", 4), ("mcdnUniPG", 5))))
if mibBuilder.loadTexts: mscSigChanGwGwcIndex.setStatus('obsolete')
if mibBuilder.loadTexts: mscSigChanGwGwcIndex.setDescription('This variable represents the mscSigChanGwGwcTable specific index for the mscSigChanGwGwcTable.')
mscSigChanGwGwcValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 15, 301, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("noGw", 0), ("singleEndedGw", 1), ("doubleEndedGw", 2), ("singleOrDoubleEndedGw", 3), ("nativePG", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanGwGwcValue.setStatus('obsolete')
if mibBuilder.loadTexts: mscSigChanGwGwcValue.setDescription('This variable represents an individual value for the mscSigChanGwGwcTable.')
mscSigChanGwGatewayCapTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 15, 302), )
if mibBuilder.loadTexts: mscSigChanGwGatewayCapTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanGwGatewayCapTable.setDescription("This attribute indicates the SigChan component's capability to convert from one access signalling type to another. Access signalling protocols (protocols between a Passport and external switching equipment, for example a PBX) are grouped into protocol groups. Protocols within the same protocol group are considered completely compatible. This means that no extra processing is needed when a call originates from an ingress link using protocol A and terminates on an egress link using protocol B if protocols A and B belong to the same protocol group. The following protocol groups are defined: etsiQsigPG - ETSI QSIG protocol group containing ETSI QSIG protocol, mcdnFamilyPG - MCDN Family protocol group containing NIS, Meridian Customer Defined Network (MCDN) peer to peer, and MCDN User to Network (UNI) protocols, analogAndCasPG - Analog and CAS protocol group containing most of the analog and channel associated signalling protocols with steady state line signalling and DTMF register signalling, euroIsdnPG - EURO ISDN protocol group containing most of the European national ISDN protocols based on ETSI ISDN (ETSI-T) standard. For every of the protocols group this attribute indicates what is the level of protocol conversion support available on the SigChan component: noGw - no protocol conversion available for the protocol group, singleEndedGw - only full protocol conversion available for the protocol group (that is the SigChan component on the other side of the subnet does not have to get involved in the gateway processing), doubleEndedGw - only partial protocol conversion available for the protocol group (that is both SigChan components, ingress and egress, have to get involved in signalling conversion), singleOrDoubleEndedGw - both, full and partial protocol conversions available for the protocol group, nativePG - the protocol group is the native protocol group for the SigChan component.")
mscSigChanGwGatewayCapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 15, 302, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscSigChanIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscSigChanGwIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscSigChanGwGatewayCapIndex"))
if mibBuilder.loadTexts: mscSigChanGwGatewayCapEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanGwGatewayCapEntry.setDescription('An entry in the mscSigChanGwGatewayCapTable.')
mscSigChanGwGatewayCapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 15, 302, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("etsiQsigPG", 0), ("mcdnPG", 1), ("analogAndCasPG", 2), ("euroIsdnPG", 3))))
if mibBuilder.loadTexts: mscSigChanGwGatewayCapIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanGwGatewayCapIndex.setDescription('This variable represents the mscSigChanGwGatewayCapTable specific index for the mscSigChanGwGatewayCapTable.')
mscSigChanGwGatewayCapValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 15, 302, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("noGw", 0), ("singleEndedGw", 1), ("doubleEndedGw", 2), ("singleOrDoubleEndedGw", 3), ("nativePG", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanGwGatewayCapValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanGwGatewayCapValue.setDescription('This variable represents an individual value for the mscSigChanGwGatewayCapTable.')
mscSigChanNcas = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 16))
mscSigChanNcasRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 16, 1), )
if mibBuilder.loadTexts: mscSigChanNcasRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanNcasRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of mscSigChanNcas components.')
mscSigChanNcasRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 16, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscSigChanIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscSigChanNcasIndex"))
if mibBuilder.loadTexts: mscSigChanNcasRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanNcasRowStatusEntry.setDescription('A single entry in the table represents a single mscSigChanNcas component.')
mscSigChanNcasRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 16, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanNcasRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanNcasRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscSigChanNcas components. These components cannot be added nor deleted.')
mscSigChanNcasComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 16, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanNcasComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanNcasComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscSigChanNcasStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 16, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanNcasStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanNcasStorageType.setDescription('This variable represents the storage type value for the mscSigChanNcas tables.')
mscSigChanNcasIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 16, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: mscSigChanNcasIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanNcasIndex.setDescription('This variable represents the index for the mscSigChanNcas tables.')
mscSigChanNcasOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 16, 100), )
if mibBuilder.loadTexts: mscSigChanNcasOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanNcasOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains various operational attributes of a non call-associated signalling session serviced by a SigChan component.')
mscSigChanNcasOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 16, 100, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscSigChanIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscSigChanNcasIndex"))
if mibBuilder.loadTexts: mscSigChanNcasOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanNcasOperEntry.setDescription('An entry in the mscSigChanNcasOperTable.')
mscSigChanNcasDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 16, 100, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ingress", 1), ("egress", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanNcasDirection.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanNcasDirection.setDescription('This attribute indicates what is the direction of the non call-associated signalling session. The attribute may have the following values: ingress, the NCAS session is originated by the external equipment into the subnet egress, the NCAS session is originated by the subnet into the external equipment')
mscSigChanNcasCallReference = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 16, 100, 1, 2), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanNcasCallReference.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanNcasCallReference.setDescription('This attribute indicates which call reference the NCAS session uses.')
mscSigChanNcasCalledDirectoryNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 16, 100, 1, 3), DigitString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanNcasCalledDirectoryNumber.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanNcasCalledDirectoryNumber.setDescription('This attribute indicates the dialled number for the NCAS session.')
mscSigChanNcasDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 16, 100, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanNcasDuration.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanNcasDuration.setDescription('This attribute indicates duration of the NCAS session since its establishment.')
mscSigChanICmap = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 18))
mscSigChanICmapRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 18, 1), )
if mibBuilder.loadTexts: mscSigChanICmapRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanICmapRowStatusTable.setDescription('This entry controls the addition and deletion of mscSigChanICmap components.')
mscSigChanICmapRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 18, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscSigChanIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscSigChanICmapIndex"))
if mibBuilder.loadTexts: mscSigChanICmapRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanICmapRowStatusEntry.setDescription('A single entry in the table represents a single mscSigChanICmap component.')
mscSigChanICmapRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 18, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscSigChanICmapRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanICmapRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscSigChanICmap components. These components can be added and deleted.')
mscSigChanICmapComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 18, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanICmapComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanICmapComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscSigChanICmapStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 18, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanICmapStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanICmapStorageType.setDescription('This variable represents the storage type value for the mscSigChanICmap tables.')
mscSigChanICmapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 18, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscSigChanICmapIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanICmapIndex.setDescription('This variable represents the index for the mscSigChanICmap tables.')
mscSigChanICmapIntCauseTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 18, 100), )
if mibBuilder.loadTexts: mscSigChanICmapIntCauseTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanICmapIntCauseTable.setDescription('This group contains the provisionable, Passport generated clearing reasons of an establishing call.')
mscSigChanICmapIntCauseEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 18, 100, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscSigChanIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscSigChanICmapIndex"))
if mibBuilder.loadTexts: mscSigChanICmapIntCauseEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanICmapIntCauseEntry.setDescription('An entry in the mscSigChanICmapIntCauseTable.')
mscSigChanICmapEgressLinkOutOfServCause = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 18, 100, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 127), ValueRangeConstraint(128, 128), )).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscSigChanICmapEgressLinkOutOfServCause.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanICmapEgressLinkOutOfServCause.setDescription('This attribute specifies the cause code sent to the originating PBX when the data link to the remote PBX is down or when remote channels are in maintenance. If the component is not added or if the default value autoConfigure is provisioned for the attribute the cause code sent to the originating PBX is not manipulated and the clearing process is not influenced. For this case, a typical cause code value sent back to the originating PBX is 27. VALUES ( 128 = autoConfigure )')
mscSigChanICmapChanOrCircNotAvailCause = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 18, 100, 1, 2), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 127), ValueRangeConstraint(128, 128), )).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscSigChanICmapChanOrCircNotAvailCause.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanICmapChanOrCircNotAvailCause.setDescription('This attribute specifies the cause code sent to the originating PBX if no timeslot is available for an incoming call. If the component is not added or if the default value autoConfigure is provisioned for the attribute the cause code sent to the originating PBX is not manipulated and the clearing process is not influenced. For this case, a typical cause code value sent back to the originating PBX is 34. VALUES ( 128 = autoConfigure )')
mscSigChanICmapTempFailureCause = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 18, 100, 1, 3), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 127), ValueRangeConstraint(128, 128), )).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscSigChanICmapTempFailureCause.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanICmapTempFailureCause.setDescription('This attribute specifies the cause code sent to the originating PBX when PORS fails to establish a call due to congestion or a disabled trunk. It is also generated when the calling side fails to decode payload capabilities sent by the called side. If the component is not added or if the default value autoConfigure is provisioned for the attribute the cause code sent to the originating PBX is not manipulated and the clearing process is not influenced. For this case, a typical cause code value sent back to the originating PBX is 41. VALUES ( 128 = autoConfigure )')
mscSigChanICmapSwitchCongestCause = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 18, 100, 1, 4), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 127), ValueRangeConstraint(128, 128), )).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscSigChanICmapSwitchCongestCause.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanICmapSwitchCongestCause.setDescription('This attribute specifies the cause code sent to the originating PBX when the allocation of internal resources for an incoming call fails. If the component is not added or if the default value autoConfigure is provisioned for the attribute the cause code sent to the originating PBX is not manipulated and the clearing process is not influenced. For this case, typical cause code values sent back to the originating PBX are 42 for NIS and 41 for ETSI. VALUES ( 128 = autoConfigure )')
mscSigChanICmapReqChanOrCircNotAvailCause = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 18, 100, 1, 5), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 127), ValueRangeConstraint(128, 128), )).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscSigChanICmapReqChanOrCircNotAvailCause.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanICmapReqChanOrCircNotAvailCause.setDescription('This attribute specifies the cause code sent to the originating PBX when an exclusively requested channel is not in service or a channel request is unsuccessful. If the component is not added or if the default value autoConfigure is provisioned for the attribute the cause code sent to the originating PBX is not manipulated and the clearing process is not influenced. For this case, a typical cause code value sent back to the originating PBX is 44. VALUES ( 128 = autoConfigure )')
mscSigChanICmapResourceUnavailCause = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 18, 100, 1, 6), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 127), ValueRangeConstraint(128, 128), )).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscSigChanICmapResourceUnavailCause.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanICmapResourceUnavailCause.setDescription('This attribute specifies the cause code sent to the originating PBX when the path establishing timer expires, when the switched voice service associated to a call is locked by CAS or when an H-channel is requested. If the component is not added or if the default value autoConfigure is provisioned for the attribute the cause code sent to the originating PBX is not manipulated and the clearing process is not influenced. For this case, typical cause code values sent back to the originating PBX are 47 for NIS and 44 for ETSI. VALUES ( 128 = autoConfigure )')
mscSigChanICmapServNotAllowedCause = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 18, 100, 1, 7), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 127), ValueRangeConstraint(128, 128), )).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscSigChanICmapServNotAllowedCause.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanICmapServNotAllowedCause.setDescription('This attribute specifies the cause code sent to the originating PBX when the requested call type (voice or data) is not compatible with Vroute typeOfRoute at the calling side. If the component is not added or if the default value autoConfigure is provisioned for the attribute the cause code sent to the originating PBX is not manipulated and the clearing process is not influenced. For this case, a typical cause code value sent back to the originating PBX is 63. VALUES ( 128 = autoConfigure )')
mscSigChanICmapNoSuchChannelCause = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 18, 100, 1, 8), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 127), ValueRangeConstraint(128, 128), )).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscSigChanICmapNoSuchChannelCause.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanICmapNoSuchChannelCause.setDescription('This attribute specifies the cause code sent to the originating PBX when a requested channel does not exist. If the component is not added or if the default value autoConfigure is provisioned for the attribute the cause code sent to the originating PBX is not manipulated and the clearing process is not influenced. For this case, a typical cause code value sent back to the originating PBX is 82. VALUES ( 128 = autoConfigure )')
mscSigChanICmapIncompatDestCause = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 18, 100, 1, 9), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 127), ValueRangeConstraint(128, 128), )).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscSigChanICmapIncompatDestCause.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanICmapIncompatDestCause.setDescription('This attribute specifies the cause code sent to the originating PBX when the calling and called side capabilities do not match. If the component is not added or if the default value autoConfigure is provisioned for the attribute the cause code sent to the originating PBX is not manipulated and the clearing process is not influenced. For this case, a typical cause code value sent back to the originating PBX is 88. VALUES ( 128 = autoConfigure )')
mscVRoute = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116))
mscVRouteRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 1), )
if mibBuilder.loadTexts: mscVRouteRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteRowStatusTable.setDescription('This entry controls the addition and deletion of mscVRoute components.')
mscVRouteRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVRouteIndex"))
if mibBuilder.loadTexts: mscVRouteRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteRowStatusEntry.setDescription('A single entry in the table represents a single mscVRoute component.')
mscVRouteRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVRouteRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVRoute components. These components can be added and deleted.')
mscVRouteComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVRouteComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVRouteStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVRouteStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteStorageType.setDescription('This variable represents the storage type value for the mscVRoute tables.')
mscVRouteIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)))
if mibBuilder.loadTexts: mscVRouteIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteIndex.setDescription('This variable represents the index for the mscVRoute tables.')
mscVRouteProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 10), )
if mibBuilder.loadTexts: mscVRouteProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteProvTable.setDescription('This group contains the provisionable attributes of a Voice Networking VoiceRoute component.')
mscVRouteProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVRouteIndex"))
if mibBuilder.loadTexts: mscVRouteProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteProvEntry.setDescription('An entry in the mscVRouteProvTable.')
mscVRouteCommentText = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 10, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVRouteCommentText.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteCommentText.setDescription('Use of this attribute is at the discretion of the system administrator. Typically, it specifies the name of the customer that is using this VoiceRoute.')
mscVRouteTypeOfRoute = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("voice", 0), ("data", 1), ("voiceData", 2))).clone('voiceData')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVRouteTypeOfRoute.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteTypeOfRoute.setDescription('This attribute specifies the type of calls (either voice, data, or both voice and data) that this VoiceRoute will accept from the Passport subnet and the local PBX. If typeOfRoute is set to voice, then all data calls from the subnet and the local PBX will be rejected. If typeOfRoute is set to data, then all voice calls from the subnet and the local PBX will be rejected. If typeOfRoute is set to voiceData, then all data and voice calls will be accepted from the subnet and the local PBX.')
mscVRouteDiallingPlan0 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 10, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2).clone(hexValue="fff8")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVRouteDiallingPlan0.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteDiallingPlan0.setDescription('This attribute specifies how to map the numbering plan indication and the type of number into the Vncs database diallingPlan0. For more information refer to NTP 241-7001-4xx Voice Networking Users Guide. There are three numbering plans that are allowed, unknown, E.164, and private. Within each of these, there are eight possible type of numbers. Since the name for the type of numbers for the private numbering plans varies from protocol to protocol, a generic scheme has been adopted. unknown means that the sending and receiving switches have no knowledge of the numbering plan. international means that the sending switch has identified the number format as matching the E.164 international dialling. national means that the sending switch has identified the number as conforming to the E.164 national dialling plan subscriber means that the number is the address of a customer conforming to the local public network. p0, p1, p2, p3, p4, p5, p6 and p7 are private numbering plans, with a type of number zero to seven. casUnknown means any number received from a Channel Associated Signalling (CAS) trunk. Description of bits: unknown(0) international(1) national(2) subscriber(3) p0(4) p1(5) p2(6) p3(7) p4(8) p5(9) p6(10) p7(11) casUnknown(12)')
mscVRouteDiallingPlan1 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 10, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVRouteDiallingPlan1.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteDiallingPlan1.setDescription('This attribute specifies how to map the numbering plan indication and the type of number into the Vncs database diallingPlan1. For more information refer to NTP 241-7001-4xx Voice Networking Users Guide. There are three numbering plans that are allowed, unknown, E.164, and private. Within each of these, there are eight possible type of numbers. Since the name for the type of numbers for the private numbering plans varies from protocol to protocol, a generic scheme has been adopted. unknown means that the sending and receiving switches have no knowledge of the numbering plan. international means that the sending switch has identified the number format as matching the E.164 international dialling plan. national means that the sending switch has identified the number as conforming to the E.164 national dialling plan subscriber means that the number is the address of a customer conforming to the local public network. p0, p1, p2, p3, p4, p5, p6 and p7 are private numbering plans, with a type of number zero to seven. casUnknown means any number received from a Channel Associated Signalling (CAS) trunk. Description of bits: unknown(0) international(1) national(2) subscriber(3) p0(4) p1(5) p2(6) p3(7) p4(8) p5(9) p6(10) p7(11) casUnknown(12)')
mscVRouteDiallingPlan2 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 10, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVRouteDiallingPlan2.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteDiallingPlan2.setDescription('This attribute specifies how to map the numbering plan indication and the type of number into the Vncs database diallingPlan2. For more information refer to NTP 241-7001-4xx Voice Networking Users Guide. There are three numbering plans that are allowed, unknown, E.164, and private. Within each of these, there are eight possible type of numbers. Since the name for the type of numbers for the private numbering plans varies from protocol to protocol, a generic scheme has been adopted. unknown means that the sending and receiving switches have no knowledge of the numbering plan. international means that the sending switch has identified the number format as matching the E.164 international dialling plan. national means that the sending switch has identified the number as conforming to the E.164 national dialling plan subscriber means that the number is the address of a customer conforming to the local public network. p0, p1, p2, p3, p4, p5, p6 and p7 are private numbering plans, with a type of number zero to seven. casUnknown means any number received from a Channel Associated Signalling (CAS) trunk. Description of bits: unknown(0) international(1) national(2) subscriber(3) p0(4) p1(5) p2(6) p3(7) p4(8) p5(9) p6(10) p7(11) casUnknown(12)')
mscVRouteHuntingAlgorithm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 10, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("bottomUpLinear", 0), ("topDownLinear", 1))).clone('bottomUpLinear')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVRouteHuntingAlgorithm.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteHuntingAlgorithm.setDescription('This attribute specifies the type of hunting algorithm that should be used by the VoiceRoute and VoiceSubroutes when selecting a channel to make an outgoing call. bottomUpLinear means that a call from the subnet will be passed to the lowest instance of the VoiceSubroutes, which in turn will pass the call to the lowest instance of SwitchedVoiceService. If there are no available SwitchedVoiceServices in that VoiceSubroute then the process will be repeated for the next lowest instance of VoiceSubroute. topDownLinear means that a call from the subnet will be passed to the highest instance of the VoiceSubroutes, which in turn will pass the call to the highest instance of SwitchedVoiceService. If there are no available SwitchedVoiceServices in that VoiceSubroute then the process will be repeated for the next highest instance of VoiceSubroute.')
mscVRouteMinimumDigitsToRoute = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 10, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVRouteMinimumDigitsToRoute.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteMinimumDigitsToRoute.setDescription('This attribute specifies the number of digits that must be received before an address resolution request will be sent to the VoiceNetworkingCallServer. Once this level has been exceeded an address resolution request will be sent for every digit received until the dialled number has been resolved in the database. This number should be set to a value which represents the average number of digits that will allow for a unique end-point to be identified. If the number is set too low, then the number of simultaneous calls that can be handled by the VoiceNetworkingCallServer will be reduced since the number of address resolution requests sent for each call will be increased. If it is set too high then address resolution request messages will not be sent to the VoiceNetworkingCallServer until the end-of-dial timer has expired (approximately 12 seconds after the last digit has been received). This can result in very long call setup times.')
mscVRouteVoiceNetworkingCallServer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 10, 1, 11), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVRouteVoiceNetworkingCallServer.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteVoiceNetworkingCallServer.setDescription('This attribute specifies which Vncs instance should be used by all calls into this VoiceRoute from the PBX.')
mscVRouteOverrideDirectoryNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 10, 1, 12), DigitString().subtype(subtypeSpec=ValueSizeConstraint(0, 24)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVRouteOverrideDirectoryNumber.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteOverrideDirectoryNumber.setDescription('The number specified here will be used in place of the dialled number to lookup the destination in the VoiceNetworkingCallServer. A null string means that the routing decision should be based on the dialled number. The numbering plan type that will be used will be noAccessCode.')
mscVRoutePrivateNetworkIdentifer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 10, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 32700))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVRoutePrivateNetworkIdentifer.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRoutePrivateNetworkIdentifer.setDescription('This attribute specifies the private network identifier (PNI) value. If the value is zero then connectionless supplementary service transport for TCAP formatted FACILITY messages is not supported.')
mscVRouteCidDataTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 11), )
if mibBuilder.loadTexts: mscVRouteCidDataTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteCidDataTable.setDescription("This group contains the attribute for a component's Customer Identifier (CID). Refer to the attribute description for a detailed explanation of CIDs.")
mscVRouteCidDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVRouteIndex"))
if mibBuilder.loadTexts: mscVRouteCidDataEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteCidDataEntry.setDescription('An entry in the mscVRouteCidDataTable.')
mscVRouteCustomerIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 11, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 8191), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVRouteCustomerIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteCustomerIdentifier.setDescription("This attribute holds the Customer Identifier (CID). Every component has a CID. If a component has a cid attribute, the component's CID is the provisioned value of that attribute; otherwise the component inherits the CID of its parent. The top- level component has a CID of 0. Every operator session also has a CID, which is the CID provisioned for the operator's user ID. An operator will see only the stream data for components having a matching CID. Also, the operator will be allowed to issue commands for only those components which have a matching CID. An operator CID of 0 is used to identify the Network Manager (referred to as 'NetMan' in DPN). This CID matches the CID of any component. Values 1 to 8191 inclusive (equivalent to 'basic CIDs' in DPN) may be assigned to specific customers.")
mscVRouteIfEntryTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 12), )
if mibBuilder.loadTexts: mscVRouteIfEntryTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteIfEntryTable.setDescription('This group contains the provisionable attributes for the ifEntry.')
mscVRouteIfEntryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVRouteIndex"))
if mibBuilder.loadTexts: mscVRouteIfEntryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteIfEntryEntry.setDescription('An entry in the mscVRouteIfEntryTable.')
mscVRouteIfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVRouteIfAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteIfAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational. The down state indicates the interface is not operational. The testing state indicates that no operational packets can be passed.')
mscVRouteIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 12, 1, 2), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVRouteIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteIfIndex.setDescription('This is the index for the IfEntry. Its value is automatically initialized during the provisioning process.')
mscVRouteStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 13), )
if mibBuilder.loadTexts: mscVRouteStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscVRouteStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVRouteIndex"))
if mibBuilder.loadTexts: mscVRouteStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteStateEntry.setDescription('An entry in the mscVRouteStateTable.')
mscVRouteAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVRouteAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscVRouteOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 13, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVRouteOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscVRouteUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 13, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVRouteUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscVRouteOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 14), )
if mibBuilder.loadTexts: mscVRouteOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
mscVRouteOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 14, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVRouteIndex"))
if mibBuilder.loadTexts: mscVRouteOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteOperStatusEntry.setDescription('An entry in the mscVRouteOperStatusTable.')
mscVRouteSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVRouteSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
mscVRouteStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 15), )
if mibBuilder.loadTexts: mscVRouteStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteStatsTable.setDescription('This group provides the operational attributes for the VoiceRoute component. It contains information relating to calls that originate from the network.')
mscVRouteStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 15, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVRouteIndex"))
if mibBuilder.loadTexts: mscVRouteStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteStatsEntry.setDescription('An entry in the mscVRouteStatsTable.')
mscVRouteTotalCallsFromSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 15, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVRouteTotalCallsFromSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteTotalCallsFromSubnet.setDescription('This attribute counts the total number of calls that have been received from the Passport subnet, including calls that fail. The value wraps to zero when it reaches its maximum.')
mscVRouteCallsClearedNoChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 15, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVRouteCallsClearedNoChannel.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteCallsClearedNoChannel.setDescription('This attribute counts the total number of calls from the subnet that were rejected when all of the in-service channels were busy. When a call is rejected for this reason, the cause code sent to the originator is 34, no circuit/channel available. The value wraps to zero when it reaches its maximum.')
mscVRouteCallsClearedOutOfService = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 15, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVRouteCallsClearedOutOfService.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteCallsClearedOutOfService.setDescription("This attribute counts the total number of calls from the subnet that were rejected because all of the channels were out-of-service. A channel is considered out-of-service if it is unavailable for any reason other than it is being engaged in handling a call. That is, an operator lock of any of the components required for the channel's operation, or problems which interfere with the connection to the PBX, will cause the channel to be considered out-of-service. When a call is rejected for this reason, the cause code sent back to the originator is 27, destination out-of-service. The value wraps to zero when it reaches its maximum.")
mscVRouteCallsRejected = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 15, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVRouteCallsRejected.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteCallsRejected.setDescription('This attribute counts the total number of calls from the subnet that were rejected because they were: 1) voice calls to a typeOfRoute which is set to data, 2) data calls to a typeOfRoute which is set to voice, 3) using a signalling protocol which is incompatible with this end. The value wraps to zero when it reaches its maximum.')
mscVRouteSubroutesTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 309), )
if mibBuilder.loadTexts: mscVRouteSubroutesTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteSubroutesTable.setDescription('This attribute specifies all of the VoiceSubroutes which are associated with this VoiceRoute. There are only 4 VoiceSubroutes allowed per VoiceRoute.')
mscVRouteSubroutesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 309, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVRouteIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVRouteSubroutesValue"))
if mibBuilder.loadTexts: mscVRouteSubroutesEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteSubroutesEntry.setDescription('An entry in the mscVRouteSubroutesTable.')
mscVRouteSubroutesValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 309, 1, 1), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVRouteSubroutesValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteSubroutesValue.setDescription('This variable represents both the value and the index for the mscVRouteSubroutesTable.')
mscVRouteSubroutesRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 309, 1, 2), RowStatus()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mscVRouteSubroutesRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteSubroutesRowStatus.setDescription('This variable is used to control the addition and deletion of individual values of the mscVRouteSubroutesTable.')
mscVRouteDegradedSubroutesTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 310), )
if mibBuilder.loadTexts: mscVRouteDegradedSubroutesTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteDegradedSubroutesTable.setDescription('This attribute indicates all of the VoiceSubroutes that have at least one SwitchedVoiceService whose operationalState is disabled.')
mscVRouteDegradedSubroutesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 310, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVRouteIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVRouteDegradedSubroutesValue"))
if mibBuilder.loadTexts: mscVRouteDegradedSubroutesEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteDegradedSubroutesEntry.setDescription('An entry in the mscVRouteDegradedSubroutesTable.')
mscVRouteDegradedSubroutesValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 310, 1, 1), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVRouteDegradedSubroutesValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteDegradedSubroutesValue.setDescription('This variable represents both the value and the index for the mscVRouteDegradedSubroutesTable.')
mscVRouteDebug = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 2))
mscVRouteDebugRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 2, 1), )
if mibBuilder.loadTexts: mscVRouteDebugRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteDebugRowStatusTable.setDescription('This entry controls the addition and deletion of mscVRouteDebug components.')
mscVRouteDebugRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVRouteIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVRouteDebugIndex"))
if mibBuilder.loadTexts: mscVRouteDebugRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteDebugRowStatusEntry.setDescription('A single entry in the table represents a single mscVRouteDebug component.')
mscVRouteDebugRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVRouteDebugRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteDebugRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVRouteDebug components. These components cannot be added nor deleted.')
mscVRouteDebugComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVRouteDebugComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteDebugComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVRouteDebugStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVRouteDebugStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteDebugStorageType.setDescription('This variable represents the storage type value for the mscVRouteDebug tables.')
mscVRouteDebugIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscVRouteDebugIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteDebugIndex.setDescription('This variable represents the index for the mscVRouteDebug tables.')
mscVRouteInterface = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 3))
mscVRouteInterfaceRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 3, 1), )
if mibBuilder.loadTexts: mscVRouteInterfaceRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteInterfaceRowStatusTable.setDescription('This entry controls the addition and deletion of mscVRouteInterface components.')
mscVRouteInterfaceRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 3, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVRouteIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVRouteInterfaceIndex"))
if mibBuilder.loadTexts: mscVRouteInterfaceRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteInterfaceRowStatusEntry.setDescription('A single entry in the table represents a single mscVRouteInterface component.')
mscVRouteInterfaceRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 3, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVRouteInterfaceRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteInterfaceRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVRouteInterface components. These components cannot be added nor deleted.')
mscVRouteInterfaceComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVRouteInterfaceComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteInterfaceComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVRouteInterfaceStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVRouteInterfaceStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteInterfaceStorageType.setDescription('This variable represents the storage type value for the mscVRouteInterface tables.')
mscVRouteInterfaceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscVRouteInterfaceIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteInterfaceIndex.setDescription('This variable represents the index for the mscVRouteInterface tables.')
mscVRouteInterfaceProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 3, 10), )
if mibBuilder.loadTexts: mscVRouteInterfaceProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteInterfaceProvTable.setDescription('This group contains attributes specifying the interface to a PBX.')
mscVRouteInterfaceProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 3, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVRouteIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVRouteInterfaceIndex"))
if mibBuilder.loadTexts: mscVRouteInterfaceProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteInterfaceProvEntry.setDescription('An entry in the mscVRouteInterfaceProvTable.')
mscVRouteInterfaceIngressAudioGain = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 3, 10, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-12, 12))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVRouteInterfaceIngressAudioGain.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteInterfaceIngressAudioGain.setDescription("This attribute specifies the gain in dB that is applied to data coming from outside the network before it is transferred across the network. It applies to voice, modem and fax traffic. For example, ingress gain is applied to audio data coming from a PBX. If ingressAudioGain is negative, a loss is applied. ingressAudioGain and egressAudioGain are used in loss planning, which is the configuration of the devices in a network to ensure that the signal level from any point in the network to any other point is correct. ingressAudioGain is ignored for calls on 1pDS1V and 1pE1V cards. For calls running on these cards, ingress audio gain is not under the user's control and egress audio gain is determined by the audioGain attribute in the appropriate Vncs/m VoiceProfile/n.")
mscVRouteInterfaceEgressAudioGain = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 3, 10, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-12, 12))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVRouteInterfaceEgressAudioGain.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteInterfaceEgressAudioGain.setDescription('This attribute specifies the gain in dB that is applied to data leaving the network. It applies to voice, modem and fax traffic. For example, egress gain is applied to audio data going to a PBX. If egressAudioGain is negative, a loss is applied. ingressAudioGain and egressAudioGain are used in loss planning, which is the configuration of the devices in the network to ensure that the signal level from any point in the network to any other point is correct. egressAudioGain is ignored for calls running on 1pDS1V and 1pE1V cards. For calls running on these cards, egress audio gain is determined by the audioGain attribute in the appropriate Vncs/m VoiceProfile/n.')
mscVRouteInterfaceTandemPassThrough = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 3, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVRouteInterfaceTandemPassThrough.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteInterfaceTandemPassThrough.setDescription('This attribute specifies whether tandem pass through is desired. If tandemPassThrough is enabled, tandem pass through is used if possible. If tandemPassThrough is disabled, tandem pass through is not used under any circumstances. The actual state of tandem pass through is indicated in Vsr Svs Framer tptStatus. The negotiated tandem pass through is available in Vsr Svs Framer negotiatedTandemPassThrough. Tandem pass through is not supported on 1pDS1V and 1pE1V cards, so tandemPassThrough is ignored on these cards.')
mscVRouteInterfaceEchoCancellation = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 3, 10, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('on')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVRouteInterfaceEchoCancellation.setStatus('obsolete')
if mibBuilder.loadTexts: mscVRouteInterfaceEchoCancellation.setDescription('This attribute has been migrated to echoCancellation.')
mscVRouteInterfaceComfortNoiseCap = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 3, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-78, -78), ValueRangeConstraint(-65, -65), ValueRangeConstraint(-60, -60), ValueRangeConstraint(-54, -54), ValueRangeConstraint(-52, -52), ValueRangeConstraint(-50, -50), ValueRangeConstraint(-48, -48), ValueRangeConstraint(-46, -46), ValueRangeConstraint(-44, -44), ValueRangeConstraint(-42, -42), ValueRangeConstraint(-40, -40), )).clone(-40)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVRouteInterfaceComfortNoiseCap.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteInterfaceComfortNoiseCap.setDescription('This attribute specifies the maximum level at which comfort noise is generated. The comfort noise is limited by comfortNoiseCap before egressAudioGain is applied. The default value of -40 dBm0 equates to the maximum level of comfort noise available and effectively disables the comfortNoiseCap.')
mscVRouteInterfaceSpeechHangoverTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 3, 10, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(10, 500)).clone(150)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVRouteInterfaceSpeechHangoverTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteInterfaceSpeechHangoverTime.setDescription('This attribute specifies the time after the end of speech before silence suppression starts. It applies only to voice traffic. It is not used unless Vsr Svs Framer negotiatedSilenceSuppression is on, congested or slowAndCongested. Higher values of speechHangoverTime reduce undesirable clipping but increase bandwidth usage. speechHangoverTime is not used on DS1V, E1V, 1pDS1V, 1pE1V and J2MV cards.')
mscVRouteInterfaceFaxHangoverTimeG711G726 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 3, 10, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(300, 20000)).clone(1000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVRouteInterfaceFaxHangoverTimeG711G726.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteInterfaceFaxHangoverTimeG711G726.setDescription('This attribute specifies the time after the end of fax traffic before G.711/G.726 fax idle suppression starts. It applies only if the negotiated fax encoding, available in Vsr Svs Framer negotiatedEncoding, is g711, g726 or g711G726 and Vsr Svs Framer negotiatedFisG711G726 is on. Higher values of faxHangoverTimeG711G726 reduce undesirable clipping but increase bandwidth usage. faxHangoverTimeG711G726 is not used on DS1V, E1V, 1pDS1V, 1pE1V and J2MV cards.')
mscVRouteInterfaceModemFaxSpeechDiscrim = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 3, 10, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('on')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVRouteInterfaceModemFaxSpeechDiscrim.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteInterfaceModemFaxSpeechDiscrim.setDescription('This attribute specifies whether this VoiceRoute differentiates between modemFax traffic and speech. If modemFaxSpeechDiscrim is on and a false 2100 Hz tone is detected, any Svs using this route reverts to speech mode when speech is detected. modemFaxSpeechDiscrim is not used on DS1V, E1V, 1pDS1V, 1pE1V and J2MV cards.')
mscVRouteInterfaceEchoTailDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 3, 10, 1, 10), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(32, 32), ValueRangeConstraint(64, 64), )).clone(64)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVRouteInterfaceEchoTailDelay.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteInterfaceEchoTailDelay.setDescription('This attribute specifies the maximum echo canceller tail delay coverage. It should be selected higher than the summation of the round trip delay of echo and hybrid response time. A 32 msec setting is good for a radius of 2700 km, assuming that the signal is going through 4 exchanges and the hybrid response time is 6 msec. A 64 msec setting offers even greater coverage (more distance or more switches), with comparable convergence time. The recommended setting is 64 msec. This attribute is not used on DS1V, E1V, 1pDS1V, 1pE1V, J2MV, 1pE1Mvp, 1pDS1Mvp, or 1pTTC2mMvp card.')
mscVRouteInterfaceEchoReturnLoss = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 3, 10, 1, 11), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(3, 3), ValueRangeConstraint(6, 6), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVRouteInterfaceEchoReturnLoss.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteInterfaceEchoReturnLoss.setDescription('This attribute specifies the echo return loss parameter of the echo canceller. 0 db is the normal value for most line conditions. If the line quality is poor, in terms of echo, selecting a higher value may allow the echo canceller to perform better. A side effect is that the voice level is attenuated by the same amount, which may not always be acceptable. This attribute is not used on DS1V, E1V, 1pDS1V, 1pE1V, J2MV, 1pE1Mvp, 1pDS1Mvp, or 1pTTC2mMvp card.')
mscVRouteInterfaceEcanBypassMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 3, 10, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("g164", 0), ("g165", 1), ("never", 2))).clone('g165')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVRouteInterfaceEcanBypassMode.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteInterfaceEcanBypassMode.setDescription('This attribute specifies when version 2 internal echo cancellers are placed in bypass mode on this VoiceRoute. This attribute only applies if v2 of echoCancellation is on. If ecanBypassMode is g165, the internal echo canceller is placed in bypass mode as per ITU-T G.165. If ecanBypassMode is g164, the internal echo canceller is placed in bypass mode as per ITU-T G.164. If ecanBypassMode is never, the internal echo canceller is never placed in bypass mode. This mode should only be used for debugging. This attribute does not apply to 1pE1V, 1pDS1V, J2MV, 1pE1Mvp, 1pDS1Mvp or 1pTTC2mMvp cards.')
mscVRouteInterfaceStructuredEchoCancellationTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 3, 474), )
if mibBuilder.loadTexts: mscVRouteInterfaceStructuredEchoCancellationTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteInterfaceStructuredEchoCancellationTable.setDescription('This attribute specifies whether echo cancellation is performed on this VoiceRoute. v1 specifies whether echo cancellation is performed by version 1 internal echo cancellers. v2 specifes whether echo cancellation is performed by version 2 echo cancellers. If echoCancellation is on, the internal echo canceller is enabled and echo cancellation is performed. If echoCancellation is off, the internal echo canceller is placed in transparent bypass mode and echo cancellation is never performed.')
mscVRouteInterfaceStructuredEchoCancellationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 3, 474, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVRouteIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVRouteInterfaceIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVRouteInterfaceStructuredEchoCancellationIndex"))
if mibBuilder.loadTexts: mscVRouteInterfaceStructuredEchoCancellationEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteInterfaceStructuredEchoCancellationEntry.setDescription('An entry in the mscVRouteInterfaceStructuredEchoCancellationTable.')
mscVRouteInterfaceStructuredEchoCancellationIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 3, 474, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("v1", 0), ("v2", 1))))
if mibBuilder.loadTexts: mscVRouteInterfaceStructuredEchoCancellationIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteInterfaceStructuredEchoCancellationIndex.setDescription('This variable represents the mscVRouteInterfaceStructuredEchoCancellationTable specific index for the mscVRouteInterfaceStructuredEchoCancellationTable.')
mscVRouteInterfaceStructuredEchoCancellationValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 3, 474, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVRouteInterfaceStructuredEchoCancellationValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteInterfaceStructuredEchoCancellationValue.setDescription('This variable represents an individual value for the mscVRouteInterfaceStructuredEchoCancellationTable.')
mscVRouteDna = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 4))
mscVRouteDnaRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 4, 1), )
if mibBuilder.loadTexts: mscVRouteDnaRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteDnaRowStatusTable.setDescription('This entry controls the addition and deletion of mscVRouteDna components.')
mscVRouteDnaRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 4, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVRouteIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVRouteDnaIndex"))
if mibBuilder.loadTexts: mscVRouteDnaRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteDnaRowStatusEntry.setDescription('A single entry in the table represents a single mscVRouteDna component.')
mscVRouteDnaRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 4, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVRouteDnaRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteDnaRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVRouteDna components. These components cannot be added nor deleted.')
mscVRouteDnaComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVRouteDnaComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteDnaComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVRouteDnaStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVRouteDnaStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteDnaStorageType.setDescription('This variable represents the storage type value for the mscVRouteDna tables.')
mscVRouteDnaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 4, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscVRouteDnaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteDnaIndex.setDescription('This variable represents the index for the mscVRouteDna tables.')
mscVRouteDnaAddressTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 4, 10), )
if mibBuilder.loadTexts: mscVRouteDnaAddressTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteDnaAddressTable.setDescription("Address group contains attributes common to all Dna's. Every Dna used in the network is defined with this group of 2 attributes. String of address digits is complemented by type of address and Npi. These attributes are used to interpret format of the address digits.")
mscVRouteDnaAddressEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 4, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVRouteIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVRouteDnaIndex"))
if mibBuilder.loadTexts: mscVRouteDnaAddressEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteDnaAddressEntry.setDescription('An entry in the mscVRouteDnaAddressTable.')
mscVRouteDnaNumberingPlanIndicator = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 4, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("x121", 0), ("e164", 1))).clone('e164')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVRouteDnaNumberingPlanIndicator.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteDnaNumberingPlanIndicator.setDescription('This attribute indicates the Numbering Plan Indicator (NPI) of the Dna that is entered. Address may belong to X.121 or E.164 plans. X.121 is used in packet svitched data networks.')
mscVRouteDnaDataNetworkAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 4, 10, 1, 2), DigitString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVRouteDnaDataNetworkAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteDnaDataNetworkAddress.setDescription('Dna attribute contains digits which form unique identifier of the customer interface. It can be compared (approximation only) to telephone number where phone number identifies unique telephone set. Dna digits are selected and assigned by network operators.')
mscVRouteAcct = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 5))
mscVRouteAcctRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 5, 1), )
if mibBuilder.loadTexts: mscVRouteAcctRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteAcctRowStatusTable.setDescription('This entry controls the addition and deletion of mscVRouteAcct components.')
mscVRouteAcctRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 5, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVRouteIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVRouteAcctIndex"))
if mibBuilder.loadTexts: mscVRouteAcctRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteAcctRowStatusEntry.setDescription('A single entry in the table represents a single mscVRouteAcct component.')
mscVRouteAcctRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 5, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVRouteAcctRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteAcctRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVRouteAcct components. These components cannot be added nor deleted.')
mscVRouteAcctComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVRouteAcctComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteAcctComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVRouteAcctStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVRouteAcctStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteAcctStorageType.setDescription('This variable represents the storage type value for the mscVRouteAcct tables.')
mscVRouteAcctIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 5, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscVRouteAcctIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteAcctIndex.setDescription('This variable represents the index for the mscVRouteAcct tables.')
mscVRouteAcctProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 5, 2), )
if mibBuilder.loadTexts: mscVRouteAcctProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteAcctProvTable.setDescription('This group contains the provisionable attributes of a VoiceAccounting component.')
mscVRouteAcctProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 5, 2, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVRouteIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVRouteAcctIndex"))
if mibBuilder.loadTexts: mscVRouteAcctProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteAcctProvEntry.setDescription('An entry in the mscVRouteAcctProvTable.')
mscVRouteAcctAccountCollection = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 5, 2, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVRouteAcctAccountCollection.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteAcctAccountCollection.setDescription('This attribute specifies that accounting records are to be collected for the various reasons: bill, test, study, audit. The last of the parameters, force, specifies that accounting records are to be collected irrespective of other collection reasons. If none of these reasons is set, then accounting will be suppressed. Description of bits: bill(0) test(1) study(2) audit(3) force(4)')
mscVRouteAcctAccountClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 5, 2, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVRouteAcctAccountClass.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteAcctAccountClass.setDescription('This attribute specifies the accounting class which is reserved for network operations usage. Its value is returned in the accounting record in the local and remote service type attributes. The use of this attribute is decided by the network operator.')
mscVRouteAcctServiceExchange = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 5, 2, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVRouteAcctServiceExchange.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteAcctServiceExchange.setDescription('This attribute specifies a user defined value, Data Service Exchange, as entered by the network operator and reported in the accounting record.')
mscVRouteAcctDigitsSuppressed = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 5, 2, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVRouteAcctDigitsSuppressed.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteAcctDigitsSuppressed.setDescription("This attribute specifies the number of trailing digits which will be suppressed in the calledNumber in the accounting records. Each of the specified number of trailing digits are replaced with an 'X'. This option exists to satisfy privacy requirements in a number of countries.")
mscVRouteAcctAccountingOptions = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 116, 5, 2, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVRouteAcctAccountingOptions.setStatus('mandatory')
if mibBuilder.loadTexts: mscVRouteAcctAccountingOptions.setDescription('This attribute specifies optional settings for the voice networking accounting system. The options are: suppressTerminatingEndRecords - setting this option suppresses the generation of accounting records at the destination node. This reduces the volume of accounting data. This option has local significance only. It only suppresses the generation of accounting records for calls received by this node. Description of bits: notused0(0) suppressTerminatingEndRecords(1)')
mscVsr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117))
mscVsrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 1), )
if mibBuilder.loadTexts: mscVsrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrRowStatusTable.setDescription('This entry controls the addition and deletion of mscVsr components.')
mscVsrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrIndex"))
if mibBuilder.loadTexts: mscVsrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrRowStatusEntry.setDescription('A single entry in the table represents a single mscVsr component.')
mscVsrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVsrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVsr components. These components can be added and deleted.')
mscVsrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVsrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrStorageType.setDescription('This variable represents the storage type value for the mscVsr tables.')
mscVsrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)))
if mibBuilder.loadTexts: mscVsrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrIndex.setDescription('This variable represents the index for the mscVsr tables.')
mscVsrCidDataTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 10), )
if mibBuilder.loadTexts: mscVsrCidDataTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrCidDataTable.setDescription("This group contains the attribute for a component's Customer Identifier (CID). Refer to the attribute description for a detailed explanation of CIDs.")
mscVsrCidDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrIndex"))
if mibBuilder.loadTexts: mscVsrCidDataEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrCidDataEntry.setDescription('An entry in the mscVsrCidDataTable.')
mscVsrCustomerIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 8191), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVsrCustomerIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrCustomerIdentifier.setDescription("This attribute holds the Customer Identifier (CID). Every component has a CID. If a component has a cid attribute, the component's CID is the provisioned value of that attribute; otherwise the component inherits the CID of its parent. The top- level component has a CID of 0. Every operator session also has a CID, which is the CID provisioned for the operator's user ID. An operator will see only the stream data for components having a matching CID. Also, the operator will be allowed to issue commands for only those components which have a matching CID. An operator CID of 0 is used to identify the Network Manager (referred to as 'NetMan' in DPN). This CID matches the CID of any component. Values 1 to 8191 inclusive (equivalent to 'basic CIDs' in DPN) may be assigned to specific customers.")
mscVsrIfEntryTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 11), )
if mibBuilder.loadTexts: mscVsrIfEntryTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrIfEntryTable.setDescription('This group contains the provisionable attributes for the ifEntry.')
mscVsrIfEntryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrIndex"))
if mibBuilder.loadTexts: mscVsrIfEntryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrIfEntryEntry.setDescription('An entry in the mscVsrIfEntryTable.')
mscVsrIfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVsrIfAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrIfAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational. The down state indicates the interface is not operational. The testing state indicates that no operational packets can be passed.')
mscVsrIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 11, 1, 2), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrIfIndex.setDescription('This is the index for the IfEntry. Its value is automatically initialized during the provisioning process.')
mscVsrProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 12), )
if mibBuilder.loadTexts: mscVsrProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrProvTable.setDescription('This group represents the provisionable attributes of a VoiceSubroute.')
mscVsrProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrIndex"))
if mibBuilder.loadTexts: mscVsrProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrProvEntry.setDescription('An entry in the mscVsrProvTable.')
mscVsrCommentText = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 12, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVsrCommentText.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrCommentText.setDescription('Use of this attribute is at the discretion of the system administrator. Typically, it specifies the name of the customer that is using this VoiceSubroute. Typical use of this attribute is to store customer name.')
mscVsrVoiceRoute = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 12, 1, 3), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVsrVoiceRoute.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrVoiceRoute.setDescription('This attribute specifies the VoiceRoute component that this VoiceSubroute belongs to.')
mscVsrSignallingChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 12, 1, 311), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVsrSignallingChannel.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSignallingChannel.setDescription('This attribute specifies the signalling channel to be used by the VoiceSubroute.')
mscVsrStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 13), )
if mibBuilder.loadTexts: mscVsrStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscVsrStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrIndex"))
if mibBuilder.loadTexts: mscVsrStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrStateEntry.setDescription('An entry in the mscVsrStateTable.')
mscVsrAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscVsrOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 13, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscVsrUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 13, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscVsrOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 14), )
if mibBuilder.loadTexts: mscVsrOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
mscVsrOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 14, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrIndex"))
if mibBuilder.loadTexts: mscVsrOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrOperStatusEntry.setDescription('An entry in the mscVsrOperStatusTable.')
mscVsrSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
mscVsrStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 15), )
if mibBuilder.loadTexts: mscVsrStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrStatsTable.setDescription('This group provides the operational statistics for the VoiceSubroute component.')
mscVsrStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 15, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrIndex"))
if mibBuilder.loadTexts: mscVsrStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrStatsEntry.setDescription('An entry in the mscVsrStatsTable.')
mscVsrTotalCallsFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 15, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrTotalCallsFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrTotalCallsFromIf.setDescription('This attribute indicates the total number of calls that have been received by this VoiceSubroute from the PBX. The value wraps to zero when it reaches its maximum.')
mscVsrTotalFailedCallsFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 15, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrTotalFailedCallsFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrTotalFailedCallsFromIf.setDescription('This attribute counts indicates the total number of calls that have been received by this VoiceSubroute from the PBX which failed to be successfully routed through the subnet for various reasons. The value wraps to zero when it reaches its maximum.')
mscVsrInvalidNumberingPlanCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 15, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrInvalidNumberingPlanCalls.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrInvalidNumberingPlanCalls.setDescription('This attribute counts the calls from the interface for which the type of number and the numbering plan identification was not associated to an access code. The numbering plan types noAccessCode, accessCode1 and accessCode2 are provisioned in the VoiceRoute. Refer to NTP-241-7001-xxx for more information. The value wraps to zero when it reaches its maximum.')
mscVsrAddressResolutionFailedCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 15, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrAddressResolutionFailedCalls.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrAddressResolutionFailedCalls.setDescription('This attribute counts the calls from the interface which had dialled numbers that had no entry in the VoiceNetworkingCallServer data base. The value wraps to zero when it reaches its maximum.')
mscVsrAddressIncompleteCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 15, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrAddressIncompleteCalls.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrAddressIncompleteCalls.setDescription('This attribute counts the calls from the interface which had dialled numbers with insufficient digits to resolve to a unique entry in the VoiceNetworkingCallServer data base. The value wraps to zero when it reaches its maximum.')
mscVsrPathAttributesNotMetCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 15, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrPathAttributesNotMetCalls.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrPathAttributesNotMetCalls.setDescription('This attribute counts the calls from the interface for which a path to the end point could not be established based on the attributes specified in the VoiceProfile. The value wraps to zero when it reaches its maximum.')
mscVsrPathSetupTimeOutCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 15, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrPathSetupTimeOutCalls.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrPathSetupTimeOutCalls.setDescription('This attribute counts the calls from the interface for which a path to the end point could not be established due to a subnet path setup time-out. The value wraps to zero when it reaches its maximum.')
mscVsrCallsRejectedLocally = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 15, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrCallsRejectedLocally.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrCallsRejectedLocally.setDescription('This attribute counts the calls from the interface which were rejected by the originating end because it was: 1) a data call on a voice only VoiceRoute, or 2) a voice call on a data only VoiceRoute, or 3) a data call to an end-point whose VoiceProfile prevents data calls from being made. The value wraps to zero when it reaches its maximum.')
mscVsrCallsRejectedByFarEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 15, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrCallsRejectedByFarEnd.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrCallsRejectedByFarEnd.setDescription('This attribute counts the calls from the interface which were rejected by the far-end. This rejection could be due to: 1) no free channels at the end-point, or 2) a voice call going to a data only VoiceRoute, or 3) a data call going to a voice only VoiceRoute, or 4) a signalling protocol incompatibility between end-points. The value wraps to zero when it reaches its maximum.')
mscVsrOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 16), )
if mibBuilder.loadTexts: mscVsrOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrOperTable.setDescription('This group provides the operational attributes for the VoiceSubroute component.')
mscVsrOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 16, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrIndex"))
if mibBuilder.loadTexts: mscVsrOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrOperEntry.setDescription('An entry in the mscVsrOperTable.')
mscVsrActiveChannels = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 16, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrActiveChannels.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrActiveChannels.setDescription('This attribute indicates the total number of B-channels that currently have active calls.')
mscVsrPeakActiveChannels = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 16, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrPeakActiveChannels.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrPeakActiveChannels.setDescription('This attribute indicates the peak number of B-channels that were active during the previous polling period.')
mscVsrActiveVoiceChannels = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 16, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrActiveVoiceChannels.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrActiveVoiceChannels.setDescription('This attribute indicates the number of B-channels that are currently carrying voice.')
mscVsrActiveModemChannels = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 16, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrActiveModemChannels.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrActiveModemChannels.setDescription('This attribute indicates the number of B-channels that are currently active, where a 2100Hz tone was detected.')
mscVsrActiveDataChannels = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 16, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrActiveDataChannels.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrActiveDataChannels.setDescription('This attribute indicates the number of B-channels that are currently active carrying data.')
mscVsrPeakActiveVoiceChannels = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 16, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrPeakActiveVoiceChannels.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrPeakActiveVoiceChannels.setDescription('This attribute indicates the peak number of B-channels that were active carrying voice during the previous polling period.')
mscVsrPeakActiveModemChannels = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 16, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrPeakActiveModemChannels.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrPeakActiveModemChannels.setDescription('This attribute indicates the peak number of active B-channels that a 2100Hz tone was detected during the previous polling period.')
mscVsrPeakActiveDataChannels = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 16, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrPeakActiveDataChannels.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrPeakActiveDataChannels.setDescription('This attribute indicates the maximum number of B-channels that were active carrying data during the previous polling period.')
mscVsrActiveFaxRelayChannels = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 16, 1, 10), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrActiveFaxRelayChannels.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrActiveFaxRelayChannels.setDescription('This attribute indicates the number of B-channels that are currently performing fax relay.')
mscVsrActiveTptChannels = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 16, 1, 11), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrActiveTptChannels.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrActiveTptChannels.setDescription('This attribute indicates the number of B-channels that are currently performing tandem pass through.')
mscVsrPeakActiveFaxRelayChannels = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 16, 1, 12), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrPeakActiveFaxRelayChannels.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrPeakActiveFaxRelayChannels.setDescription('This attribute indicates the peak number of B-channels that performed fax relay during the previous polling period.')
mscVsrPeakActiveTptChannels = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 16, 1, 13), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrPeakActiveTptChannels.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrPeakActiveTptChannels.setDescription('This attribute indicates the peak number of B-channels that performed tandem pass through during the previous polling period.')
mscVsrSvs = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2))
mscVsrSvsRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 1), )
if mibBuilder.loadTexts: mscVsrSvsRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsRowStatusTable.setDescription('This entry controls the addition and deletion of mscVsrSvs components.')
mscVsrSvsRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrSvsIndex"))
if mibBuilder.loadTexts: mscVsrSvsRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsRowStatusEntry.setDescription('A single entry in the table represents a single mscVsrSvs component.')
mscVsrSvsRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVsrSvsRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVsrSvs components. These components can be added and deleted.')
mscVsrSvsComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVsrSvsStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsStorageType.setDescription('This variable represents the storage type value for the mscVsrSvs tables.')
mscVsrSvsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32)))
if mibBuilder.loadTexts: mscVsrSvsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsIndex.setDescription('This variable represents the index for the mscVsrSvs tables.')
mscVsrSvsIfEntryTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 11), )
if mibBuilder.loadTexts: mscVsrSvsIfEntryTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsIfEntryTable.setDescription('This group contains the provisionable attributes for the ifEntry.')
mscVsrSvsIfEntryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrSvsIndex"))
if mibBuilder.loadTexts: mscVsrSvsIfEntryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsIfEntryEntry.setDescription('An entry in the mscVsrSvsIfEntryTable.')
mscVsrSvsIfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVsrSvsIfAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsIfAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational. The down state indicates the interface is not operational. The testing state indicates that no operational packets can be passed.')
mscVsrSvsIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 11, 1, 2), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsIfIndex.setDescription('This is the index for the IfEntry. Its value is automatically initialized during the provisioning process.')
mscVsrSvsOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 12), )
if mibBuilder.loadTexts: mscVsrSvsOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsOperTable.setDescription('This group provides the operational attributes for the SwitchedVoiceService component.')
mscVsrSvsOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrSvsIndex"))
if mibBuilder.loadTexts: mscVsrSvsOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsOperEntry.setDescription('An entry in the mscVsrSvsOperTable.')
mscVsrSvsStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("idle", 0), ("seized", 1), ("answered", 2), ("clearing", 3), ("lockout", 4), ("idleMaintenance", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsStatus.setDescription('This attribute indicates the current state of the channel. idle means that there is no call currently active on this channel. seized means that the channel is currently setting up a call, but a connect message has not been received. answered means that a connect message has been received. clearing means that the call is being taken down. lockout means that due to glare or channel rejection, the channel is available for ingress calls only. That is, either the PBX and the Passport tried to seize the channel for a call at the same time (glare), or the PBX rejected the Passport seizure. idleMaintenance means that due to explicit channel maintenance messages, the channel is not available for egress calls. This can only happen when the protocol control places the channel into a maintenance state, and only happens if the Passport receives a message causing the channel state change such as the SERVICE maintenance message.')
mscVsrSvsProfileNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 12, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsProfileNumber.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsProfileNumber.setDescription('This attribute indicates the VoiceProfile number that is being used for this call. If no call is active, then it displays the value of the last profile used.')
mscVsrSvsCallType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("voice", 0), ("data", 1), ("modem", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsCallType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsCallType.setDescription('This attribute indicates the type of call that this channel is currently carrying. If no call is active, then it displays the value for the last call.')
mscVsrSvsCalledNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 12, 1, 4), DigitString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsCalledNumber.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsCalledNumber.setDescription('This attribute indicates the dialled number that is active on this channel. If no call is active, then it displays the dialled number from the last call.')
mscVsrSvsCallingNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 12, 1, 5), DigitString().subtype(subtypeSpec=ValueSizeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsCallingNumber.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsCallingNumber.setDescription("This attribute indicates the originator's number for the currently active call. If no call is active, then it displays the originator's number from the last call.")
mscVsrSvsClearCauseCode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 12, 1, 6), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsClearCauseCode.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsClearCauseCode.setDescription('This attribute indicates the clear cause code of the call. This code is always the Q.931 code, regardless of the access protocol.')
mscVsrSvsStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 13), )
if mibBuilder.loadTexts: mscVsrSvsStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsStatsTable.setDescription('This group provides the operational attributes for the SwitchedVoiceService component.')
mscVsrSvsStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrSvsIndex"))
if mibBuilder.loadTexts: mscVsrSvsStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsStatsEntry.setDescription('An entry in the mscVsrSvsStatsTable.')
mscVsrSvsTotalCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 13, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsTotalCalls.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsTotalCalls.setDescription('This attribute counts the call attempts processed on this channel (in both directions). This counter includes the number of unsuccessful as well as successful call attempts. The value wraps when it reaches its maximum.')
mscVsrSvsTotalCallSeconds = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 13, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsTotalCallSeconds.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsTotalCallSeconds.setDescription('This attribute indicates the total number of seconds that this channel is handling a call. This is regardless of whether the call is successful or not. In other words, this is the amount of time that the channel is not in the idle state. The value wraps when it reaches its maximum.')
mscVsrSvsStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 14), )
if mibBuilder.loadTexts: mscVsrSvsStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscVsrSvsStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 14, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrSvsIndex"))
if mibBuilder.loadTexts: mscVsrSvsStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsStateEntry.setDescription('An entry in the mscVsrSvsStateTable.')
mscVsrSvsAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscVsrSvsOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 14, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscVsrSvsUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 14, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscVsrSvsOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 15), )
if mibBuilder.loadTexts: mscVsrSvsOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
mscVsrSvsOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 15, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrSvsIndex"))
if mibBuilder.loadTexts: mscVsrSvsOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsOperStatusEntry.setDescription('An entry in the mscVsrSvsOperStatusTable.')
mscVsrSvsSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 15, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
mscVsrSvsFramer = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2))
mscVsrSvsFramerRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 1), )
if mibBuilder.loadTexts: mscVsrSvsFramerRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerRowStatusTable.setDescription('This entry controls the addition and deletion of mscVsrSvsFramer components.')
mscVsrSvsFramerRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrSvsIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrSvsFramerIndex"))
if mibBuilder.loadTexts: mscVsrSvsFramerRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerRowStatusEntry.setDescription('A single entry in the table represents a single mscVsrSvsFramer component.')
mscVsrSvsFramerRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsFramerRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVsrSvsFramer components. These components cannot be added nor deleted.')
mscVsrSvsFramerComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsFramerComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVsrSvsFramerStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsFramerStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerStorageType.setDescription('This variable represents the storage type value for the mscVsrSvsFramer tables.')
mscVsrSvsFramerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscVsrSvsFramerIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerIndex.setDescription('This variable represents the index for the mscVsrSvsFramer tables.')
mscVsrSvsFramerProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 10), )
if mibBuilder.loadTexts: mscVsrSvsFramerProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerProvTable.setDescription('This group contains the base provisioning data for the Framer component. Application or hardware interface specific provisioning data is contained in other provisionable Framer groups.')
mscVsrSvsFramerProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrSvsIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrSvsFramerIndex"))
if mibBuilder.loadTexts: mscVsrSvsFramerProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerProvEntry.setDescription('An entry in the mscVsrSvsFramerProvTable.')
mscVsrSvsFramerInterfaceName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 10, 1, 1), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVsrSvsFramerInterfaceName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerInterfaceName.setDescription("This attribute contains a hardware component name. The attribute associates the application with a specific link. This defines the module processor on which Framer's parent component (as well as Framer itself) will run.")
mscVsrSvsFramerStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 14), )
if mibBuilder.loadTexts: mscVsrSvsFramerStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscVsrSvsFramerStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 14, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrSvsIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrSvsFramerIndex"))
if mibBuilder.loadTexts: mscVsrSvsFramerStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerStateEntry.setDescription('An entry in the mscVsrSvsFramerStateTable.')
mscVsrSvsFramerAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsFramerAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscVsrSvsFramerOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 14, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsFramerOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscVsrSvsFramerUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 14, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsFramerUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscVsrSvsFramerStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 15), )
if mibBuilder.loadTexts: mscVsrSvsFramerStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerStatsTable.setDescription('This group contains the operational statistics data for a Framer component.')
mscVsrSvsFramerStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 15, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrSvsIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrSvsFramerIndex"))
if mibBuilder.loadTexts: mscVsrSvsFramerStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerStatsEntry.setDescription('An entry in the mscVsrSvsFramerStatsTable.')
mscVsrSvsFramerTotalCells = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 15, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsFramerTotalCells.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerTotalCells.setDescription('This attribute counts the total number of cells received from the interface. Each cell contains 44 bytes of data from the DS0 channel. Since a DS0 provides data at 64 kbit/s, each cell contains 5.5 ms of audio data. This data flow is measured before compression is performed on the channel. This counter wraps to zero after reaching its maximum value.')
mscVsrSvsFramerAudioCells = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 15, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsFramerAudioCells.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerAudioCells.setDescription('This attribute counts the total number of cells containing audio data received from the interface while the channel was seized. A CCS channel is always considered to be seized. Audio data includes cells containing voice as well modem audio, but not silence. A cell contains 44 bytes of data from the DS0 channel(5.5 ms). This flow is measured before compression is performed on the channel. This counter wraps to zero after reaching its maximum value.')
mscVsrSvsFramerSilenceCells = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 15, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsFramerSilenceCells.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerSilenceCells.setDescription('This attribute counts the total number of cells containing silence data received from the interface which was not forwarded into the network, thus saving bandwidth. A channel may go into silence due to the operation of the silence suppression feature or for CAS channels when the ABCD signalling bits go idle. A cell contains 44 bytes of data from the DS0 channel(5.5 ms). This flow is measured before compression is performed on the channel. This counter wraps to zero after reaching its maximum value.')
mscVsrSvsFramerModemCells = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 15, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsFramerModemCells.setStatus('obsolete')
if mibBuilder.loadTexts: mscVsrSvsFramerModemCells.setDescription('This attribute is migrated into modemFaxCells.')
mscVsrSvsFramerCurrentEncodingRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 15, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("n640", 1), ("n320", 2), ("n240", 3), ("n160", 4), ("n80", 5), ("n144", 6), ("n120", 7), ("n96", 8), ("n72", 9), ("n63", 10), ("n53", 11), ("n48", 12), ("n24", 13), ("n12", 14), ("n03", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsFramerCurrentEncodingRate.setStatus('obsolete')
if mibBuilder.loadTexts: mscVsrSvsFramerCurrentEncodingRate.setDescription('This attribute has been migrated to currentRate in Operational group.')
mscVsrSvsFramerLrcErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 15, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsFramerLrcErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerLrcErrors.setDescription('This attribute counts the number of frames received from the network with LRC errors.')
mscVsrSvsFramerFrmLostInNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 15, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsFramerFrmLostInNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerFrmLostInNetwork.setDescription('This attribute counts the number of frames which the service knows it did not receive from the network although they were sent in to the network from the far end.')
mscVsrSvsFramerFrmUnderRuns = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 15, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsFramerFrmUnderRuns.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerFrmUnderRuns.setDescription('This attribute counts the number of times that a frame was needed but was not available because it had been delayed too long in the network. This error may occur repeatedly if the interface clocks at the two access points to the network are operating at different rates.')
mscVsrSvsFramerFrmDumped = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 15, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsFramerFrmDumped.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerFrmDumped.setDescription('This attribute counts the number of frames which have been dumped because the output queue grew too large. This can occur if the clock rate on the incoming interface is faster than the clock rate on the outgoing interface and there are no silence periods to absorb the difference, or when a compression rate change occurs. This count wraps to zero after reaching its maximum value.')
mscVsrSvsFramerModemSilenceCells = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 15, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsFramerModemSilenceCells.setStatus('obsolete')
if mibBuilder.loadTexts: mscVsrSvsFramerModemSilenceCells.setDescription('This attribute is migrated into faxIdleCells.')
mscVsrSvsFramerCurrentEncoding = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 15, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 32, 33, 64, 65, 66, 67, 255))).clone(namedValues=NamedValues(("g729", 1), ("g728", 2), ("g723", 3), ("g726", 4), ("g711", 5), ("v22", 32), ("v22bis", 33), ("faxRelay", 64), ("v27", 65), ("v29", 66), ("v17", 67), ("none", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsFramerCurrentEncoding.setStatus('obsolete')
if mibBuilder.loadTexts: mscVsrSvsFramerCurrentEncoding.setDescription('This attribute has been migrated to currentEncoding in Operational group.')
mscVsrSvsFramerTptStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 15, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("operating", 0), ("rejected", 1), ("monitoring", 2), ("disabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsFramerTptStatus.setStatus('obsolete')
if mibBuilder.loadTexts: mscVsrSvsFramerTptStatus.setDescription('This attribute has been migrated to tptStatus in Operational group.')
mscVsrSvsFramerFaxRelayCells = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 15, 1, 35), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsFramerFaxRelayCells.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerFaxRelayCells.setDescription('This attribute counts the total number of fax relay cells sent to the network. This counter wraps to zero after reaching its maximum value.')
mscVsrSvsFramerModemFaxCells = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 15, 1, 36), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsFramerModemFaxCells.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerModemFaxCells.setDescription('This attribute counts the total number of cells containing modem data received from the interface while the channel was seized. A CCS channel is always considered to be seized. Cells are considered to be modem data if a constant energy level above -25 dBmO is detected for more than 900 ms. An energy level below -36 dBmO for more than 650 ms is required to detect that the modem is no longer present. A cell contains 44 bytes of data from the DS0 channel (5.5 ms). This flow is measured before compression is performed on the channel. This counter wraps to zero after reaching its maximum value.')
mscVsrSvsFramerFaxIdleCells = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 15, 1, 37), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsFramerFaxIdleCells.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerFaxIdleCells.setDescription('This attribute counts the total number of cells containing silent fax data received from the interface which were not forwarded into the network, thus saving bandwidth. A channel may go into silence due to the silence Suppression feature or for CAS channels when the ABCD signalling bits go idle. A cell contains 44 bytes of data from the DS0 channel (5.5 ms). This flow is measured before compression is performed on the channel. This counter wraps to zero after reaching its maximum value.')
mscVsrSvsFramerOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 16), )
if mibBuilder.loadTexts: mscVsrSvsFramerOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerOperTable.setDescription('This group contains the operational data for a Svs Framer.')
mscVsrSvsFramerOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 16, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrSvsIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrSvsFramerIndex"))
if mibBuilder.loadTexts: mscVsrSvsFramerOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerOperEntry.setDescription('An entry in the mscVsrSvsFramerOperTable.')
mscVsrSvsFramerOpCurrentEncoding = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 16, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 32, 33, 64, 65, 66, 67, 255))).clone(namedValues=NamedValues(("g729", 1), ("g728", 2), ("g723", 3), ("g726", 4), ("g711", 5), ("v22", 32), ("v22bis", 33), ("faxRelay", 64), ("v27", 65), ("v29", 66), ("v17", 67), ("none", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsFramerOpCurrentEncoding.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerOpCurrentEncoding.setDescription('This attribute indicates the encoding currently being performed on this channel. g711 indicates that pulse code modulation (PCM) defined by ITU-T G.711 is being performed. g726 indicates that adaptive differential pulse code modulation (ADPCM) defined by ITU-T G.726 is being performed. g728 indicates that the Low Delay Coded Excited Linear Predictive Coder (LD-CELP) algorithm defined by ITU-T G.728 is being performed. g729 indicates that the Conjunctive Structure Algebraic Code Excited Linear Predictive Coder (CS-ACELP) algorithm defined by ITU-T G.729 is being performed. v27 indicates that the algorithm defined by ITU-T V.27 is being performed. v29 indicates that the algorithm defined by ITU-T V.29 is being performed.')
mscVsrSvsFramerCurrentRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 16, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("n0", 0), ("n640", 1), ("n320", 2), ("n240", 3), ("n160", 4), ("n80", 5), ("n144", 6), ("n120", 7), ("n96", 8), ("n72", 9), ("n63", 10), ("n53", 11), ("n48", 12), ("n24", 13), ("n12", 14), ("n03", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsFramerCurrentRate.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerCurrentRate.setDescription('This attribute indicates the current encoding rate for frames being sent to the network.')
mscVsrSvsFramerOpTptStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 16, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2, 3))).clone(namedValues=NamedValues(("operating", 0), ("monitoring", 2), ("disabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsFramerOpTptStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerOpTptStatus.setDescription('This attribute indicates the current status of the tandem pass through algorithm. If tptStatus is operating, the tandem pass through algorithm is cutting through a voice switch. If tptStatus is monitoring, negotiatedTandemPassThrough is enabled, but the tandem pass through algorithm is not cutting through a voice switch. If tptStatus is disabled, negotiatedTandemPassThrough is disabled.')
mscVsrSvsFramerNegTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 17), )
if mibBuilder.loadTexts: mscVsrSvsFramerNegTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerNegTable.setDescription('This group contains the attributes indicating the results of voice networking end to end negotiation.')
mscVsrSvsFramerNegEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 17, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrSvsIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrSvsFramerIndex"))
if mibBuilder.loadTexts: mscVsrSvsFramerNegEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerNegEntry.setDescription('An entry in the mscVsrSvsFramerNegTable.')
mscVsrSvsFramerNegotiatedSilenceSuppression = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 17, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("off", 0), ("on", 1), ("congested", 2), ("slow", 3), ("slowAndCongested", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVsrSvsFramerNegotiatedSilenceSuppression.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerNegotiatedSilenceSuppression.setDescription('This attribute indicates the result of negotiating silence suppression with the remote end across the subnet. The parameter used for negotiating with the remote end is provisioned in Vncs Vp silenceSuppression. If negotiatedSilenceSuppression is off, silence suppression is never performed. If negotiatedSilenceSuppression is on, silence suppression is always performed. If negotiatedSilenceSuppression is congested, silence suppression is performed only when the network is congested. If negotiatedSilenceSuppression is slow, silence suppression begins after 10 to 20 seconds without any speech or audio being detected. If negotiatedSilenceSuppression is slowAndCongested, both the slow and congested options are applied.')
mscVsrSvsFramerNegotiatedFisG711G726 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 17, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVsrSvsFramerNegotiatedFisG711G726.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerNegotiatedFisG711G726.setDescription('This attribute indicates the result of negotiating G.711/G.726 fax idle suppression with the remote end across the subnet. The parameter used for negotiating with the remote end is provisioned in Vncs Vp faxIdleSuppressionG711G726.')
mscVsrSvsFramerNegotiatedDtmfRegeneration = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 17, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVsrSvsFramerNegotiatedDtmfRegeneration.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerNegotiatedDtmfRegeneration.setDescription('This attribute indicates the result of negotiating DTMF regeneration with the remote end across the subnet. The parameter used for negotiating with the remote end is provisioned in Vncs Vp dtmfRegeneration. If negotiatedDtmfRegeneration is on, DTMF tones received from the link are first converted to digits before being sent to the subnet. When a digit is received from the subnet, its respective DTMF tone is generated before being sent to the link. If negotiatedDtmfRegeneration is off, DTMF tones are transported transparently.')
mscVsrSvsFramerNegotiatedV17AsG711G726 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 17, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsFramerNegotiatedV17AsG711G726.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerNegotiatedV17AsG711G726.setDescription('This attribute indicates how this SwitchedVoiceService negotiates with V.17 fax machines, as determined by negotiation with the remote end across the subnet. The parameter used for negotiating with the remote end is provisioned in Vncs Vp v17EncodedAsG711G726. If negotiatedV17AsG711G726 is no, V.17 fax machines are instructed to use V.29, and V.29 fax traffic sent by fax machines is demodulated and encoded using fax relay. If negotiatedV17AsG711G726 is yes, V.17 fax machines are permitted to use V.17 and V.17 fax traffic sent by fax machines is encoded using G.711 or G.726, at the rates given in negotiatedRates.')
mscVsrSvsFramerNegotiatedTandemPassThrough = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 17, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsFramerNegotiatedTandemPassThrough.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerNegotiatedTandemPassThrough.setDescription('This attribute indicates the result of negotiating tandem pass through with the remote end across the subnet. The parameter used for negotiating with the remote end is provisioned in Vncs Vp tandemPassThrough.')
mscVsrSvsFramerFrmToNetworkTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 315), )
if mibBuilder.loadTexts: mscVsrSvsFramerFrmToNetworkTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerFrmToNetworkTable.setDescription('This attribute counts the number of frames sent to the network at each encoding rate. Fax relay cells are not included.')
mscVsrSvsFramerFrmToNetworkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 315, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrSvsIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrSvsFramerIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrSvsFramerFrmToNetworkIndex"))
if mibBuilder.loadTexts: mscVsrSvsFramerFrmToNetworkEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerFrmToNetworkEntry.setDescription('An entry in the mscVsrSvsFramerFrmToNetworkTable.')
mscVsrSvsFramerFrmToNetworkIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 315, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n64KbitS", 0), ("n32KbitS", 1), ("n24KbitS", 2), ("n16KbitS", 3), ("n8KbitS", 4))))
if mibBuilder.loadTexts: mscVsrSvsFramerFrmToNetworkIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerFrmToNetworkIndex.setDescription('This variable represents the mscVsrSvsFramerFrmToNetworkTable specific index for the mscVsrSvsFramerFrmToNetworkTable.')
mscVsrSvsFramerFrmToNetworkValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 315, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsFramerFrmToNetworkValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerFrmToNetworkValue.setDescription('This variable represents an individual value for the mscVsrSvsFramerFrmToNetworkTable.')
mscVsrSvsFramerFrmFromNetworkTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 316), )
if mibBuilder.loadTexts: mscVsrSvsFramerFrmFromNetworkTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerFrmFromNetworkTable.setDescription('This attribute counts the number of frames received from the network at each encoding rate.')
mscVsrSvsFramerFrmFromNetworkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 316, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrSvsIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrSvsFramerIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrSvsFramerFrmFromNetworkIndex"))
if mibBuilder.loadTexts: mscVsrSvsFramerFrmFromNetworkEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerFrmFromNetworkEntry.setDescription('An entry in the mscVsrSvsFramerFrmFromNetworkTable.')
mscVsrSvsFramerFrmFromNetworkIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 316, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n64KbitS", 0), ("n32KbitS", 1), ("n24KbitS", 2), ("n16KbitS", 3), ("n8KbitS", 4))))
if mibBuilder.loadTexts: mscVsrSvsFramerFrmFromNetworkIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerFrmFromNetworkIndex.setDescription('This variable represents the mscVsrSvsFramerFrmFromNetworkTable specific index for the mscVsrSvsFramerFrmFromNetworkTable.')
mscVsrSvsFramerFrmFromNetworkValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 316, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsFramerFrmFromNetworkValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerFrmFromNetworkValue.setDescription('This variable represents an individual value for the mscVsrSvsFramerFrmFromNetworkTable.')
mscVsrSvsFramerNEncodingTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 467), )
if mibBuilder.loadTexts: mscVsrSvsFramerNEncodingTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerNEncodingTable.setDescription('This attribute indicates the results of negotiating audio call encodings for voice, modemFax and fax traffic with the remote end across the subnet. The parameters used for negotiating with the remote end are provisioned in Vncs Vp voiceEncodingChoice and Vncs Vp modemFaxEncodingChoice. voice traffic is all traffic from the start of a call or speech until a 2100 Hz tone or call release. modemFax traffic is all traffic after a 2100 Hz tone but before a fax preamble, speech or call release. fax traffic is all traffic after a fax preamble but before speech or call release. g711 indicates that pulse code modulation (PCM) defined by ITU-T G.711 is the negotiated encoding. g726 indicates that Adaptive Differential Pulse Code Modulation (ADPCM) defined by ITU-T G.726 is the negotiated encoding. g711G726 indicates that pulse code modulation (PCM) defined by ITU-T G.711 and Adaptive Differential Pulse Code Modulation (ADPCM) defined by ITU-T G.726 are both negotiated encodings. If negotiatedEncoding is g711G726, the actual encoding performed can be either G.711 or G.726, depending on network congestion. g728 indicates that Low Delay Coded Excited Linear Predictive Coder (CS-ACELP) defined by ITU-T G.728 is the negotiated encoding. g729 indicates that Conjunctive Structure Algebraic Code Excited Linear Predictive Coder (CS-ACELP) defined by ITU-T G.729 is the negotiated encoding. v29V27Relay indicates that fax relay using ITU-T V.29 or ITU-T V.27 is the negotiated encoding. v17V29V27Relay indicates that fax relay using ITU-T V.17, ITU-T V.29, or ITU-T V.27 is the negotiated encoding. If all negotiated encodings are none, the negotiation of audio call encodings is not complete.')
mscVsrSvsFramerNEncodingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 467, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrSvsIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrSvsFramerIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrSvsFramerNEncodingIndex"))
if mibBuilder.loadTexts: mscVsrSvsFramerNEncodingEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerNEncodingEntry.setDescription('An entry in the mscVsrSvsFramerNEncodingTable.')
mscVsrSvsFramerNEncodingIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 467, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("voice", 0), ("modemFax", 1), ("fax", 2))))
if mibBuilder.loadTexts: mscVsrSvsFramerNEncodingIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerNEncodingIndex.setDescription('This variable represents the mscVsrSvsFramerNEncodingTable specific index for the mscVsrSvsFramerNEncodingTable.')
mscVsrSvsFramerNEncodingValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 467, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 5, 31, 64, 68, 255))).clone(namedValues=NamedValues(("g729", 1), ("g728", 2), ("g726", 4), ("g711", 5), ("g711G726", 31), ("v29V27Relay", 64), ("v17V29V27Relay", 68), ("none", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVsrSvsFramerNEncodingValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerNEncodingValue.setDescription('This variable represents an individual value for the mscVsrSvsFramerNEncodingTable.')
mscVsrSvsFramerNRatesTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 479), )
if mibBuilder.loadTexts: mscVsrSvsFramerNRatesTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerNRatesTable.setDescription('This attribute indicates the results of negotiating minimum and maximum rates for voice, modemFax and fax traffic with the remote end across the subnet. The parameters used for negotiating with the remote end are provisioned in Vncs Vp voiceRates and Vncs Vp modemFaxRates.')
mscVsrSvsFramerNRatesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 479, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrSvsIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrSvsFramerIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrSvsFramerNRatesTrafficIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrSvsFramerNRatesRateIndex"))
if mibBuilder.loadTexts: mscVsrSvsFramerNRatesEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerNRatesEntry.setDescription('An entry in the mscVsrSvsFramerNRatesTable.')
mscVsrSvsFramerNRatesTrafficIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 479, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("voice", 0), ("modemFax", 1), ("fax", 2))))
if mibBuilder.loadTexts: mscVsrSvsFramerNRatesTrafficIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerNRatesTrafficIndex.setDescription('This variable represents the next to last index for the mscVsrSvsFramerNRatesTable.')
mscVsrSvsFramerNRatesRateIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 479, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("min", 0), ("max", 1))))
if mibBuilder.loadTexts: mscVsrSvsFramerNRatesRateIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerNRatesRateIndex.setDescription('This variable represents the final index for the mscVsrSvsFramerNRatesTable.')
mscVsrSvsFramerNRatesValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 479, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 66, 67, 68, 69, 70))).clone(namedValues=NamedValues(("n00", 0), ("n03", 1), ("n12", 2), ("n24", 3), ("n48", 4), ("n72", 5), ("n96", 6), ("n120", 7), ("n144", 8), ("n80", 66), ("n160", 67), ("n240", 68), ("n320", 69), ("n640", 70)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVsrSvsFramerNRatesValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerNRatesValue.setDescription('This variable represents an individual value for the mscVsrSvsFramerNRatesTable.')
mscVsrSvsFramerVfpDebug = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 5))
mscVsrSvsFramerVfpDebugRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 5, 1), )
if mibBuilder.loadTexts: mscVsrSvsFramerVfpDebugRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerVfpDebugRowStatusTable.setDescription('This entry controls the addition and deletion of mscVsrSvsFramerVfpDebug components.')
mscVsrSvsFramerVfpDebugRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 5, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrSvsIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrSvsFramerIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrSvsFramerVfpDebugIndex"))
if mibBuilder.loadTexts: mscVsrSvsFramerVfpDebugRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerVfpDebugRowStatusEntry.setDescription('A single entry in the table represents a single mscVsrSvsFramerVfpDebug component.')
mscVsrSvsFramerVfpDebugRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 5, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsFramerVfpDebugRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerVfpDebugRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVsrSvsFramerVfpDebug components. These components cannot be added nor deleted.')
mscVsrSvsFramerVfpDebugComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsFramerVfpDebugComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerVfpDebugComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVsrSvsFramerVfpDebugStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsFramerVfpDebugStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerVfpDebugStorageType.setDescription('This variable represents the storage type value for the mscVsrSvsFramerVfpDebug tables.')
mscVsrSvsFramerVfpDebugIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 5, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscVsrSvsFramerVfpDebugIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerVfpDebugIndex.setDescription('This variable represents the index for the mscVsrSvsFramerVfpDebug tables.')
mscVsrSvsFramerMvpDebug = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 6))
mscVsrSvsFramerMvpDebugRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 6, 1), )
if mibBuilder.loadTexts: mscVsrSvsFramerMvpDebugRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerMvpDebugRowStatusTable.setDescription('This entry controls the addition and deletion of mscVsrSvsFramerMvpDebug components.')
mscVsrSvsFramerMvpDebugRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 6, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrSvsIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrSvsFramerIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrSvsFramerMvpDebugIndex"))
if mibBuilder.loadTexts: mscVsrSvsFramerMvpDebugRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerMvpDebugRowStatusEntry.setDescription('A single entry in the table represents a single mscVsrSvsFramerMvpDebug component.')
mscVsrSvsFramerMvpDebugRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 6, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsFramerMvpDebugRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerMvpDebugRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVsrSvsFramerMvpDebug components. These components cannot be added nor deleted.')
mscVsrSvsFramerMvpDebugComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 6, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsFramerMvpDebugComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerMvpDebugComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVsrSvsFramerMvpDebugStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 6, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsFramerMvpDebugStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerMvpDebugStorageType.setDescription('This variable represents the storage type value for the mscVsrSvsFramerMvpDebug tables.')
mscVsrSvsFramerMvpDebugIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 6, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscVsrSvsFramerMvpDebugIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerMvpDebugIndex.setDescription('This variable represents the index for the mscVsrSvsFramerMvpDebug tables.')
mscVsrSvsFramerPcmCapture = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 7))
mscVsrSvsFramerPcmCaptureRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 7, 1), )
if mibBuilder.loadTexts: mscVsrSvsFramerPcmCaptureRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerPcmCaptureRowStatusTable.setDescription('This entry controls the addition and deletion of mscVsrSvsFramerPcmCapture components.')
mscVsrSvsFramerPcmCaptureRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 7, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrSvsIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrSvsFramerIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrSvsFramerPcmCaptureIndex"))
if mibBuilder.loadTexts: mscVsrSvsFramerPcmCaptureRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerPcmCaptureRowStatusEntry.setDescription('A single entry in the table represents a single mscVsrSvsFramerPcmCapture component.')
mscVsrSvsFramerPcmCaptureRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 7, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsFramerPcmCaptureRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerPcmCaptureRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVsrSvsFramerPcmCapture components. These components cannot be added nor deleted.')
mscVsrSvsFramerPcmCaptureComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 7, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsFramerPcmCaptureComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerPcmCaptureComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVsrSvsFramerPcmCaptureStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 7, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsFramerPcmCaptureStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerPcmCaptureStorageType.setDescription('This variable represents the storage type value for the mscVsrSvsFramerPcmCapture tables.')
mscVsrSvsFramerPcmCaptureIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 2, 7, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscVsrSvsFramerPcmCaptureIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsFramerPcmCaptureIndex.setDescription('This variable represents the index for the mscVsrSvsFramerPcmCapture tables.')
mscVsrSvsLCo = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 3))
mscVsrSvsLCoRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 3, 1), )
if mibBuilder.loadTexts: mscVsrSvsLCoRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsLCoRowStatusTable.setDescription('This entry controls the addition and deletion of mscVsrSvsLCo components.')
mscVsrSvsLCoRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 3, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrSvsIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrSvsLCoIndex"))
if mibBuilder.loadTexts: mscVsrSvsLCoRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsLCoRowStatusEntry.setDescription('A single entry in the table represents a single mscVsrSvsLCo component.')
mscVsrSvsLCoRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 3, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsLCoRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsLCoRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVsrSvsLCo components. These components cannot be added nor deleted.')
mscVsrSvsLCoComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsLCoComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsLCoComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVsrSvsLCoStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsLCoStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsLCoStorageType.setDescription('This variable represents the storage type value for the mscVsrSvsLCo tables.')
mscVsrSvsLCoIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscVsrSvsLCoIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsLCoIndex.setDescription('This variable represents the index for the mscVsrSvsLCo tables.')
mscVsrSvsLCoPathDataTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 3, 10), )
if mibBuilder.loadTexts: mscVsrSvsLCoPathDataTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsLCoPathDataTable.setDescription('This group contains all operational attributes for the path oriented LCo.')
mscVsrSvsLCoPathDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 3, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrSvsIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrSvsLCoIndex"))
if mibBuilder.loadTexts: mscVsrSvsLCoPathDataEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsLCoPathDataEntry.setDescription('An entry in the mscVsrSvsLCoPathDataTable.')
mscVsrSvsLCoState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 3, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("pathDown", 0), ("selectingRoute", 1), ("connecting", 2), ("pathUp", 3), ("pathDownRetrying", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsLCoState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsLCoState.setDescription('This attribute reflects the current state of the connection. The pathDown state indicates a connection that has no remote end provisioned or the application has not yet signalled for a path. The selectingRoute state occurs when a request has been sent to route selector and it has not yet responded. The connectingState occurs while a path is being established. The pathUp state is the normal operational state of a path. The pathDownRetrying state indicates a path that attempted route selection but received no route and is now waiting to retry route selection again.')
mscVsrSvsLCoOverrideRemoteName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 3, 10, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVsrSvsLCoOverrideRemoteName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsLCoOverrideRemoteName.setDescription("If set and the current PLC remoteName is blank this remoteName will override the blank PLC remoteName. Usually you would set this attribute and then lock/unlock the service component which will result in this new overrideRemoteName being used as if it had been provisioned into the PLC remoteName. The advantage of this attribute is that the connection's remoteName can be changed immediately without having to 'activate prov' but the disadvantage is that the overrideRemoteName is not permanent and if the card or switch is reset the override will be lost.")
mscVsrSvsLCoEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 3, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("calling", 0), ("called", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsLCoEnd.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsLCoEnd.setDescription('This attribute identifies whether this is the calling or called end of the path.')
mscVsrSvsLCoCostMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 3, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsLCoCostMetric.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsLCoCostMetric.setDescription("This attribute gives the route's total cost metric. It is calculated as the sum of the cost metric of all trunks in the path at the time the connection was established. The cost metric of a trunk is defined by the trunkCost attribute of the Trunk component. The costMetric for an LCo that is originated and terminated on the same module is 0.")
mscVsrSvsLCoDelayMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 3, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsLCoDelayMetric.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsLCoDelayMetric.setDescription('This attribute gives the total delay of the route as the one way delay for a 512 byte packet. It is calculated as the sum of the delays of all trunks in the path stored in topology at the time the connection was established. The delay for an LCo that is originated and terminated on the same module is 0.')
mscVsrSvsLCoRoundTripDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 3, 10, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 200000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsLCoRoundTripDelay.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsLCoRoundTripDelay.setDescription('This attribute contains the time taken for a packet (cell) of 44 bytes to be transmitted to the remote LCo and return to this LCo. The number reported is given in milliseconds to the nearest millisecond. A value of one millisecond is reported if the time is less than 1 millisecond even though the delay may be less than 1 Millisecond when the LCo is originated and terminated on the same module.')
mscVsrSvsLCoSetupPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 3, 10, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsLCoSetupPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsLCoSetupPriority.setDescription('This attribute gives the priority at which the current path is established. Zero is the highest priority and four is the lowest. The holdingPriority, a complementary attribute of this component, indicates the priority a path maintains once it is established.')
mscVsrSvsLCoHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 3, 10, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsLCoHoldingPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsLCoHoldingPriority.setDescription('This attribute gives the priority at which a path holds its current path once the path is established. Zero is the highest priority and four is the lowest. The setupPriority, a complementary attribute, indicates the priority of a path at establishment time.')
mscVsrSvsLCoRequiredTxBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 3, 10, 1, 9), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsLCoRequiredTxBandwidth.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsLCoRequiredTxBandwidth.setDescription('This attribute gives the actual bandwidth (in bits per second) reserved by this path on each of the trunks of its route. This attribute represents the bandwidth for traffic outgoing to the remote end point. The originating end of the connection determines this value.')
mscVsrSvsLCoRequiredRxBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 3, 10, 1, 10), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsLCoRequiredRxBandwidth.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsLCoRequiredRxBandwidth.setDescription('This attribute gives the actual bandwidth (in bits per second) reserved by this path on each of trunks of its route. This attribute represents the bandwidth for traffic incoming from the remote end point. The originating end of the connection determines this value')
mscVsrSvsLCoRequiredTrafficType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 3, 10, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("voice", 0), ("data", 1), ("video", 2), ("trafficType1", 3), ("trafficType2", 4), ("trafficType3", 5), ("trafficType4", 6), ("trafficType5", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsLCoRequiredTrafficType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsLCoRequiredTrafficType.setDescription('This operational attribute indicates the type of traffic transmitted over the path. There are eight possible traffic types, and the path can transmit only one of them. The originating end of the connection determines the type. These are arbitrary designations for traffic type. The voice, data and video traffic types are defined, and five other arbitrary traffic types can be defined by the network administration. This attribute is used in the route selection process to restrict the route to trunks that support this traffic type. The supportedTrafficType trunk attribute lists all the types of traffic allowed on the trunk. For example, if requiredTrafficType is specified as trafficType1 then only trunks that include trafficType1 in supportedTrafficType, will be candidates for this connection.')
mscVsrSvsLCoPermittedTrunkTypes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 3, 10, 1, 12), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsLCoPermittedTrunkTypes.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsLCoPermittedTrunkTypes.setDescription("This operational attribute lists up to eight types of trunk that can be used on the route. The originating end of the connection determines the types. The terrestrial and satellite trunk types have been defined, leaving six remaining arbitrary types that can be defined by the network administration. The trunk's type is indicated in the trunkType attribute of the Trunk component. When selecting a route, PORS only chooses trunks whose trunkType are in the permittedTrunkTypes for the path. Description of bits: terrestrial(0) satellite(1) trunkType1(2) trunkType2(3) trunkType3(4) trunkType4(5) trunkType5(6) trunkType6(7)")
mscVsrSvsLCoRequiredSecurity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 3, 10, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsLCoRequiredSecurity.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsLCoRequiredSecurity.setDescription("This attribute indicates the required minimum level of security of the trunks on the route. Zero represents the most secure and seven represents the least secure. The trunk's security is indicated by the trunkSecurity attribute of the Trunk component, and has values identical in range and meaning to the requiredSecurity attribute. PORS ensures that any route selected does not contain a trunk whose trunkSecurity attribute is numerically greater than the requiredSecurity.")
mscVsrSvsLCoRequiredCustomerParameter = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 3, 10, 1, 14), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsLCoRequiredCustomerParameter.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsLCoRequiredCustomerParameter.setDescription('This attribute indicates the allowed customer defined parameter of the trunks on the route.The originating end of the connection determines the customer defined parameter. Its value, a number from zero to seven, is chosen by a network administration to have a meaning specific to their network, thus allowing them to customize the use of their trunks. A complementary trunk attribute, customerParameter, also has a value from zero to seven. The route selection process does not consider trunks whose customerParameter is greater than the requiredCustomerParameter of the path.')
mscVsrSvsLCoEmissionPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 3, 10, 1, 15), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsLCoEmissionPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsLCoEmissionPriority.setDescription('This attribute indicates the urgency with which packets on the path are emitted by the trunks on the route. The originating end of the connection selects the emissionPriority. EmissionPriority of zero indicates the highest emission priority, while two indicates the lowest emission priority. Packets with a higher emissionPriority (or numerically less) are serviced and sent out before the packets of lower emissionPriority (or numerically higher).')
mscVsrSvsLCoDiscardPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 3, 10, 1, 16), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsLCoDiscardPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsLCoDiscardPriority.setDescription('This attribute indicates the importance of the packets on the path.The originating end of the connection sets discardPriority. One is used for paths carrying the most important traffic, and three is used for paths carrying the least important traffic. Packets with lower discardPriority(numerically lower) are discarded after packets with a higher discardPriority(numerically higher).')
mscVsrSvsLCoPathType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 3, 10, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("normal", 0), ("manual", 1), ("forced", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsLCoPathType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsLCoPathType.setDescription('This attribute indicates whether the path for this PLC was determined automatically or by static provisioning. Normal pathTypes are selected automatically by Route Selector.The other pathTypes are both manual pathTypes where the operator must specify, through provisioning, a static route termed the manualPath. A manual pathType connection is nearly identical to a normal path type connection with the exception that the route is pre-provisioned. For a manual pathType, bandwidth reservations are respected along the path exactly as in a normal path. The last type, the forced pathType, is also a manual path but regardless of the bandwidth available the route is granted provided the trunks are operational and there are sufficient Logical Channels (LChs). The forced pathType could result in over committing the reserved bandwidth allowed on a trunk. A better way to achieve the effects of a forced pathType is to use a manual pathType with setupPriority = 0 and holdingPriority = 0. In this manner the path will reserve correct bandwidth and it will bump other paths if required while not being bumped itself.')
mscVsrSvsLCoRetryCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 3, 10, 1, 18), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsLCoRetryCount.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsLCoRetryCount.setDescription('This attribute is the count of the number of times the path chosen during route selection could not be instantiated. This count should be three or below if the network is performing adequately. A high value indicates that the route selection is often performed using an out-of-date view of available network bandwidth and/or topology. This attribute will only increase at the calling end of the connection. This attribute is reset each time a path reconnects and stops counting when it reaches its maximum value.')
mscVsrSvsLCoPathFailureCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 3, 10, 1, 19), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsLCoPathFailureCount.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsLCoPathFailureCount.setDescription('This attribute is the count of the number of times the path has successfully connected. It is set to zero the first time the path is up. If a path fails anytime after connecting this count will be incremented when the path is up again. Failed route requests do not count in this statistic. See retryCount above. This attribute stops counting at its maximum value.')
mscVsrSvsLCoReasonForNoRoute = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 3, 10, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14))).clone(namedValues=NamedValues(("none", 0), ("destinationNameTooLong", 1), ("destinationNotSpecified", 2), ("unknownDestinationName", 3), ("incorrectDestination", 4), ("incorrectDestinationEndPoint", 5), ("unknownSource", 6), ("unknownDestination", 7), ("sameNode", 8), ("routeCostTooMuch", 9), ("routesDelayTooLong", 10), ("attributesNotMet", 11), ("anError", 12), ("attributeProfileProblem", 13), ("manualPathIndexProblem", 14))).clone('none')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsLCoReasonForNoRoute.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsLCoReasonForNoRoute.setDescription("This attribute is the route selection's reasonForNoRoute and provides a brief reason for which a route was not selected. The reasons are essentially self-explanatory. Perhaps two reasons for no route require some explanation. The reason unknownRemoteNodeName is issued when the remote node name is not in the topological database. The reason plcAttributesNotMet is issued when there is no network connectivity at a level specified by the PLC attributes. This reason is also issued when there is no physical connectivity between two end nodes.")
mscVsrSvsLCoLastTearDownReason = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 3, 10, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23))).clone(namedValues=NamedValues(("none", 0), ("normalShutDown", 1), ("insufficientTxLcOrBandwidth", 2), ("insufficientRxLcOrBandwidth", 3), ("trunkFailure", 4), ("trunkCardFailure", 5), ("operatorForced", 6), ("lostLcnClash", 7), ("networkCongestion", 8), ("trunkNotFound", 9), ("farEndNotFound", 10), ("wrongModuleReached", 11), ("farEndBusy", 12), ("callLoopedBack", 13), ("unknownReason", 14), ("farEndNotReady", 15), ("remoteNameMismatch", 16), ("serviceTypeMismatch", 17), ("reconnectFromFarEnd", 18), ("bumped", 19), ("accessCardFailure", 20), ("optimized", 21), ("overrideRemoteName", 22), ("trunkOrFarEndDidNotSupportMode", 23))).clone('none')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsLCoLastTearDownReason.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsLCoLastTearDownReason.setDescription("This attribute reflects the last tear down reason for a connection (LCo). In many cases this displays the reason for a momentary service interruption. This attribute applies to the last path failure only. If a path is no longer up, this may give an indication to the reason that the path has failed. In many cases an alarm will also be generated with more specific information. The following is a brief description of the reasons: none - This path has no information for the teardown this is typical of a path provisioned with no remoteName that has not been up. normalShutDown - This path has gone down due to normal call termination. insufficientTxLcOrBandwidth - At present there is either no available bandwidth or logical channel numbers available on one or more of the trunks for this path in the transmit direction. insufficientRxLcOrBandwidth - At present there is either no available bandwidth or logical channel numbers available on one or more of the trunks for this path in the receive direction. trunkFailure- A trunk on the path has failed or has gone down due to a provisioning change of a critical attribute. trunkCardFailure- A trunk FP card has failed along the path. accessCardFailure- The FP on which the peer access service was running has failed. operatorForced- The path has terminated due to the operator locking a trunk along the path. lostLcnClash- The path has terminated because the PA's at both ends of an intermediate trunk have allocated the same LC to different calls. When this happens both calls must go down and then try to come up again a fraction of a second later (effectively ensuring that they will now be assigned different LC's). It is normal to get the odd clash especially when the PA's usedLC is approaching the PA's maxLC. networkCongestion - The path has failed due to control information being lost and not recoverable. trunkNotFound - Occurs on a manual path usually. Check for trunks not up or names provisioned incorrectly. farEndNotFound - The far end is not provisioned or is not up. Check remote Name. wrongModuleReached - This may occur on a manual path. Check provisioning for correct trunk and service names. For a normal path, the network Topology may be changing check remoteName. farEndBusy - The far end has been reached but it is busy. Check remoteName and remote end provisioning. callLoopedBack - This LCo is provisioned to call itself. Re- provision since this is invalid. unknownReason - The failure was not resolved. farEndNotReady - The remote end was reached but the connection was refused due to the remote end not being enabled. remoteNameMismatch - The remote end has alarmed and rejected this setup due to remoteName provisioning. serviceTypeMismatch - The remote Service Type does not match this service type. Check provisioning. reconnectFromFarEnd - The remote end re-established this connection. Check the remote end lastTearDownReason to determine the real reason. bumped - Another call bumped this path from a trunk to get bandwidth (or an LC) which it required to come up. This other path had a higher setupPriority than this path's holdingPriority hence it was allowed to steal the bandwidth (or LC) from this path. optimized - This call has been rerouted due to the optimization feature. The call is still active this just indicates why the path changed. trunkOrFarEndDidNotSupportMode - This call was unable to complete because a mode required by the service was not supported by one of the trunks the route went through or by the far end service it connected to. Currently the only mode that this applies to is the map/mux mode on TRUNK PA ATM component. Map mode was required by the application (CES/FrAtm etc.) but was not available on the TRUNK PA ATM component through which the call was routed or the far end CES/FrAtm component did not specify the same mode.")
mscVsrSvsLCoPathFailureAction = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 3, 10, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disconnectConnection", 0), ("reRoutePath", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsLCoPathFailureAction.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsLCoPathFailureAction.setDescription('This attribute displays whether the application is set to tolerate momentary interruption of a path while a new path is selected. If disconnectConnection is displayed, the application is informed as soon as possible about a failure by disconnection. If the attribute displays reRoutePath, the path may attempt an immediate reroute, provided the failure is a recoverable failure. If rerouting fails the application is informed of the failure. With this option set to reRoutePath the LCo may wait up to 30 seconds before informing the service of complete disconnection in order to allow both ends to attempt to reconnect. Note that if PLC components are different at both ends only the calling end is allowed to reconnect. All pathTypes respect this attribute. Also on a manualPath with both ends provisioned with independent paths (at least with respect to the failure) this option will have the desired effect that the path is rerouted without complete disconnection at both ends')
mscVsrSvsLCoBumpPreference = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 3, 10, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("bumpWhenNecessary", 0), ("bumpToObtainBestRoute", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsLCoBumpPreference.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsLCoBumpPreference.setDescription("This attribute specifies when bumping will occur during route selection process. Bumping may occur when necessary or always. It will be necessary for a connection to bump if there is not enough resources for the connection to be established and these resources are occupied by a connection whose setupPriority is lower (numerically higher) than the connection's setupPriority. A connection may also always bump in order to obtain the best route.")
mscVsrSvsLCoOptimization = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 3, 10, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsLCoOptimization.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsLCoOptimization.setDescription('This attribute is used to specify whether this connection should attempt to optimize its path when requested by the routing PORS component. Every path is as optimal as it can be when it is established, but as network traffic patterns and configurations change this path may no longer be as optimal as it could be. The PORS connection manager on a module requests circuits to optimize at the optimization interval.')
mscVsrSvsLCoPathUpDateTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 3, 10, 1, 25), EnterpriseDateAndTime().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(19, 19), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsLCoPathUpDateTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsLCoPathUpDateTime.setDescription('This is the time stamp when the current path was established or reestablished.')
mscVsrSvsLCoStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 3, 11), )
if mibBuilder.loadTexts: mscVsrSvsLCoStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsLCoStatsTable.setDescription('This group contains the operational statistics attributes for the path oriented LCo.')
mscVsrSvsLCoStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 3, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrSvsIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrSvsLCoIndex"))
if mibBuilder.loadTexts: mscVsrSvsLCoStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsLCoStatsEntry.setDescription('An entry in the mscVsrSvsLCoStatsTable.')
mscVsrSvsLCoPktsToNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 3, 11, 1, 1), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsLCoPktsToNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsLCoPktsToNetwork.setDescription('This attribute counts the number of packets transmitted to the network over this Logical Connection.')
mscVsrSvsLCoBytesToNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 3, 11, 1, 2), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsLCoBytesToNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsLCoBytesToNetwork.setDescription('This attribute counts the number of bytes sent to the network over this Logical Connection.')
mscVsrSvsLCoPktsFromNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 3, 11, 1, 3), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsLCoPktsFromNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsLCoPktsFromNetwork.setDescription('This attribute counts the number of packets received from the remote LCo via the network.')
mscVsrSvsLCoBytesFromNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 3, 11, 1, 4), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsLCoBytesFromNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsLCoBytesFromNetwork.setDescription('This attribute counts the number of bytes received from the remote LCo via the network.')
mscVsrSvsLCoPathTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 3, 264), )
if mibBuilder.loadTexts: mscVsrSvsLCoPathTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsLCoPathTable.setDescription('This attribute contains the trunk component names over which the path has been instantiated and the remote end point name terminating the path.')
mscVsrSvsLCoPathEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 3, 264, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrSvsIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrSvsLCoIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrSvsLCoPathValue"))
if mibBuilder.loadTexts: mscVsrSvsLCoPathEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsLCoPathEntry.setDescription('An entry in the mscVsrSvsLCoPathTable.')
mscVsrSvsLCoPathValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 3, 264, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsLCoPathValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsLCoPathValue.setDescription('This variable represents both the value and the index for the mscVsrSvsLCoPathTable.')
mscVsrSvsDebug = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 4))
mscVsrSvsDebugRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 4, 1), )
if mibBuilder.loadTexts: mscVsrSvsDebugRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsDebugRowStatusTable.setDescription('This entry controls the addition and deletion of mscVsrSvsDebug components.')
mscVsrSvsDebugRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 4, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrSvsIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrSvsDebugIndex"))
if mibBuilder.loadTexts: mscVsrSvsDebugRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsDebugRowStatusEntry.setDescription('A single entry in the table represents a single mscVsrSvsDebug component.')
mscVsrSvsDebugRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 4, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsDebugRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsDebugRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVsrSvsDebug components. These components cannot be added nor deleted.')
mscVsrSvsDebugComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsDebugComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsDebugComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVsrSvsDebugStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrSvsDebugStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsDebugStorageType.setDescription('This variable represents the storage type value for the mscVsrSvsDebug tables.')
mscVsrSvsDebugIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 2, 4, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscVsrSvsDebugIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrSvsDebugIndex.setDescription('This variable represents the index for the mscVsrSvsDebug tables.')
mscVsrDebug = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 3))
mscVsrDebugRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 3, 1), )
if mibBuilder.loadTexts: mscVsrDebugRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrDebugRowStatusTable.setDescription('This entry controls the addition and deletion of mscVsrDebug components.')
mscVsrDebugRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 3, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrIndex"), (0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscVsrDebugIndex"))
if mibBuilder.loadTexts: mscVsrDebugRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrDebugRowStatusEntry.setDescription('A single entry in the table represents a single mscVsrDebug component.')
mscVsrDebugRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 3, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrDebugRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrDebugRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVsrDebug components. These components cannot be added nor deleted.')
mscVsrDebugComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrDebugComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrDebugComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVsrDebugStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVsrDebugStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrDebugStorageType.setDescription('This variable represents the storage type value for the mscVsrDebug tables.')
mscVsrDebugIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 117, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscVsrDebugIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVsrDebugIndex.setDescription('This variable represents the index for the mscVsrDebug tables.')
voiceNetworkingGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 109, 1))
voiceNetworkingGroupCA = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 109, 1, 1))
voiceNetworkingGroupCA02 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 109, 1, 1, 3))
voiceNetworkingGroupCA02A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 109, 1, 1, 3, 2))
voiceNetworkingCapabilities = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 109, 3))
voiceNetworkingCapabilitiesCA = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 109, 3, 1))
voiceNetworkingCapabilitiesCA02 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 109, 3, 1, 3))
voiceNetworkingCapabilitiesCA02A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 109, 3, 1, 3, 2))
mibBuilder.exportSymbols("Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", mscSigChanForceNpiTon=mscSigChanForceNpiTon, mscVsrIfEntryEntry=mscVsrIfEntryEntry, mscSigChanICmapChanOrCircNotAvailCause=mscSigChanICmapChanOrCircNotAvailCause, mscVRouteSubroutesValue=mscVRouteSubroutesValue, mscVsrCallsRejectedByFarEnd=mscVsrCallsRejectedByFarEnd, mscSigChanNcasOperTable=mscSigChanNcasOperTable, voiceNetworkingGroupCA02A=voiceNetworkingGroupCA02A, mscVRouteStatsTable=mscVRouteStatsTable, mscVsrSvsIfIndex=mscVsrSvsIfIndex, mscVsrSvsFramerVfpDebugIndex=mscVsrSvsFramerVfpDebugIndex, mscVRouteHuntingAlgorithm=mscVRouteHuntingAlgorithm, mscSigChanNcasOperEntry=mscSigChanNcasOperEntry, mscVsrSvsFramerNRatesTable=mscVsrSvsFramerNRatesTable, mscVsrSvsLCoPathEntry=mscVsrSvsLCoPathEntry, mscSigChanSnmpOperStatus=mscSigChanSnmpOperStatus, mscVsrSvsComponentName=mscVsrSvsComponentName, mscVsrSvsLCoLastTearDownReason=mscVsrSvsLCoLastTearDownReason, mscVsrOperStatusTable=mscVsrOperStatusTable, mscVsrSvsFramerNegotiatedSilenceSuppression=mscVsrSvsFramerNegotiatedSilenceSuppression, mscSigChanIfIndex=mscSigChanIfIndex, mscSigChanIfAdminStatus=mscSigChanIfAdminStatus, mscSigChanICmapReqChanOrCircNotAvailCause=mscSigChanICmapReqChanOrCircNotAvailCause, mscVsrSvsLCoPathFailureAction=mscVsrSvsLCoPathFailureAction, mscSigChanBchRowStatusTable=mscSigChanBchRowStatusTable, mscVRouteDebugRowStatusTable=mscVRouteDebugRowStatusTable, mscSigChanRowStatusEntry=mscSigChanRowStatusEntry, mscVRouteDiallingPlan2=mscVRouteDiallingPlan2, mscVsrComponentName=mscVsrComponentName, mscSigChanNcasRowStatus=mscSigChanNcasRowStatus, mscVsrSvsLCoRowStatus=mscVsrSvsLCoRowStatus, mscSigChanGwGatewayCapEntry=mscSigChanGwGatewayCapEntry, mscVsrSvsFramerPcmCaptureRowStatusEntry=mscVsrSvsFramerPcmCaptureRowStatusEntry, mscVsrSvsDebugStorageType=mscVsrSvsDebugStorageType, mscVRouteAcctServiceExchange=mscVRouteAcctServiceExchange, mscSigChanCommentText=mscSigChanCommentText, mscVRouteInterfaceProvTable=mscVRouteInterfaceProvTable, mscVsrCommentText=mscVsrCommentText, mscVRouteIfEntryEntry=mscVRouteIfEntryEntry, mscSigChanGwGatewayCapTable=mscSigChanGwGatewayCapTable, mscVsrSvsFramerMvpDebugRowStatus=mscVsrSvsFramerMvpDebugRowStatus, mscVsrSvsLCoRetryCount=mscVsrSvsLCoRetryCount, mscVsrSvsCallType=mscVsrSvsCallType, mscVsrSvsFramerStateTable=mscVsrSvsFramerStateTable, mscSigChanGwGwcTable=mscSigChanGwGwcTable, mscVRouteCustomerIdentifier=mscVRouteCustomerIdentifier, mscVRouteDnaRowStatusEntry=mscVRouteDnaRowStatusEntry, mscVsrOperTable=mscVsrOperTable, voiceNetworkingGroup=voiceNetworkingGroup, mscVsrSvsFramerAdminState=mscVsrSvsFramerAdminState, mscSigChanICmapTempFailureCause=mscSigChanICmapTempFailureCause, mscVsrSvsLCoState=mscVsrSvsLCoState, mscVsrSvsLCoPermittedTrunkTypes=mscVsrSvsLCoPermittedTrunkTypes, mscSigChanIfEntryTable=mscSigChanIfEntryTable, mscVsrSignallingChannel=mscVsrSignallingChannel, mscVRouteDnaComponentName=mscVRouteDnaComponentName, mscVRouteOperStatusTable=mscVRouteOperStatusTable, mscVsrSvsProfileNumber=mscVsrSvsProfileNumber, mscSigChanGwRequiredConversions=mscSigChanGwRequiredConversions, mscSigChanICmapRowStatus=mscSigChanICmapRowStatus, mscSigChanCidDataEntry=mscSigChanCidDataEntry, mscVsrSvsFramerMvpDebugRowStatusTable=mscVsrSvsFramerMvpDebugRowStatusTable, mscVsrSvsFramerCurrentEncoding=mscVsrSvsFramerCurrentEncoding, mscVsrSvsFramerInterfaceName=mscVsrSvsFramerInterfaceName, mscVsrAddressIncompleteCalls=mscVsrAddressIncompleteCalls, mscVsrSvsFramerRowStatus=mscVsrSvsFramerRowStatus, mscVsrSvsStatus=mscVsrSvsStatus, mscVsrStateTable=mscVsrStateTable, mscVRouteSubroutesTable=mscVRouteSubroutesTable, mscVsrDebugRowStatusTable=mscVsrDebugRowStatusTable, mscVsrSvsOperStatusEntry=mscVsrSvsOperStatusEntry, mscVsrSvsFramerNRatesEntry=mscVsrSvsFramerNRatesEntry, mscSigChanGwRowStatusEntry=mscSigChanGwRowStatusEntry, mscVsrSvsFramerIndex=mscVsrSvsFramerIndex, mscVRouteIndex=mscVRouteIndex, mscVsrSvsFramerVfpDebugRowStatusTable=mscVsrSvsFramerVfpDebugRowStatusTable, mscVsrTotalFailedCallsFromIf=mscVsrTotalFailedCallsFromIf, mscVRouteInterfaceStructuredEchoCancellationTable=mscVRouteInterfaceStructuredEchoCancellationTable, mscVRouteInterfaceEgressAudioGain=mscVRouteInterfaceEgressAudioGain, mscVRouteInterfaceTandemPassThrough=mscVRouteInterfaceTandemPassThrough, mscVsrSvsDebugIndex=mscVsrSvsDebugIndex, mscVsrSvsFramerVfpDebugRowStatus=mscVsrSvsFramerVfpDebugRowStatus, mscVsrSvsLCoOptimization=mscVsrSvsLCoOptimization, voiceNetworkingGroupCA02=voiceNetworkingGroupCA02, mscVsrSvsFramerFrmToNetworkIndex=mscVsrSvsFramerFrmToNetworkIndex, mscVsrSvsFramerPcmCaptureRowStatus=mscVsrSvsFramerPcmCaptureRowStatus, mscVsrSvsFramerVfpDebugRowStatusEntry=mscVsrSvsFramerVfpDebugRowStatusEntry, mscVsrSvsStateEntry=mscVsrSvsStateEntry, mscVsrSvsFramerFrmDumped=mscVsrSvsFramerFrmDumped, mscVsrDebugComponentName=mscVsrDebugComponentName, mscVsrSvsLCoPktsFromNetwork=mscVsrSvsLCoPktsFromNetwork, mscVsrSvsOperEntry=mscVsrSvsOperEntry, mscVRouteMinimumDigitsToRoute=mscVRouteMinimumDigitsToRoute, mscVsrSvsFramerPcmCapture=mscVsrSvsFramerPcmCapture, mscSigChanGwGwcValue=mscSigChanGwGwcValue, mscVsrSvsRowStatusEntry=mscVsrSvsRowStatusEntry, mscVsrSvsFramerMvpDebugIndex=mscVsrSvsFramerMvpDebugIndex, mscVsrSvsLCoPathDataEntry=mscVsrSvsLCoPathDataEntry, mscVRouteDiallingPlan1=mscVRouteDiallingPlan1, mscVsrUsageState=mscVsrUsageState, mscVsrStateEntry=mscVsrStateEntry, mscVRouteDebugRowStatusEntry=mscVRouteDebugRowStatusEntry, mscVsrSvsFramerNegTable=mscVsrSvsFramerNegTable, mscVsrSvsLCoPathUpDateTime=mscVsrSvsLCoPathUpDateTime, mscVsrSvsFramerUsageState=mscVsrSvsFramerUsageState, mscVRouteAcctAccountingOptions=mscVRouteAcctAccountingOptions, mscSigChanDegradedSubroutesTable=mscSigChanDegradedSubroutesTable, mscVsrPathAttributesNotMetCalls=mscVsrPathAttributesNotMetCalls, mscSigChanBchOperTable=mscSigChanBchOperTable, mscVRouteComponentName=mscVRouteComponentName, mscVRouteInterfaceComfortNoiseCap=mscVRouteInterfaceComfortNoiseCap, mscVRouteInterfaceModemFaxSpeechDiscrim=mscVRouteInterfaceModemFaxSpeechDiscrim, voiceNetworkingCapabilities=voiceNetworkingCapabilities, mscVsrSvsFramerOperationalState=mscVsrSvsFramerOperationalState, mscVsrSvsFramerProvTable=mscVsrSvsFramerProvTable, mscSigChanRowStatus=mscSigChanRowStatus, mscSigChanBchStorageType=mscSigChanBchStorageType, voiceNetworkingMIB=voiceNetworkingMIB, mscVRouteOperationalState=mscVRouteOperationalState, mscVRouteDnaRowStatus=mscVRouteDnaRowStatus, mscVsrSvsLCoEmissionPriority=mscVsrSvsLCoEmissionPriority, mscVsrSvsLCoEnd=mscVsrSvsLCoEnd, mscVsrSvsDebugRowStatus=mscVsrSvsDebugRowStatus, mscVRouteDnaNumberingPlanIndicator=mscVRouteDnaNumberingPlanIndicator, mscSigChanProvTable=mscSigChanProvTable, mscVsrSvsDebug=mscVsrSvsDebug, mscVsrSvsFramerVfpDebug=mscVsrSvsFramerVfpDebug, voiceNetworkingCapabilitiesCA02=voiceNetworkingCapabilitiesCA02, mscSigChanDegradedSubroutesValue=mscSigChanDegradedSubroutesValue, mscVsrSvsClearCauseCode=mscVsrSvsClearCauseCode, mscVRouteUsageState=mscVRouteUsageState, voiceNetworkingCapabilitiesCA=voiceNetworkingCapabilitiesCA, mscSigChanNcasIndex=mscSigChanNcasIndex, mscVRouteOverrideDirectoryNumber=mscVRouteOverrideDirectoryNumber, mscVRouteDiallingPlan0=mscVRouteDiallingPlan0, mscVRouteInterface=mscVRouteInterface, mscVsrSvsFramerPcmCaptureStorageType=mscVsrSvsFramerPcmCaptureStorageType, mscVsrSvsFramerNegEntry=mscVsrSvsFramerNegEntry, mscVRouteDnaIndex=mscVRouteDnaIndex, mscSigChanBchTimeSlot=mscSigChanBchTimeSlot, mscVsrSvsFramerOpCurrentEncoding=mscVsrSvsFramerOpCurrentEncoding, mscVsrSvsFramerVfpDebugComponentName=mscVsrSvsFramerVfpDebugComponentName, mscSigChanGwUnsupportedConversions=mscSigChanGwUnsupportedConversions, mscVRouteAcctRowStatusEntry=mscVRouteAcctRowStatusEntry, mscVsrSvsFramerNEncodingTable=mscVsrSvsFramerNEncodingTable, mscVRouteProvTable=mscVRouteProvTable, mscVRouteDnaDataNetworkAddress=mscVRouteDnaDataNetworkAddress, mscSigChanStorageType=mscSigChanStorageType, mscVRouteInterfaceFaxHangoverTimeG711G726=mscVRouteInterfaceFaxHangoverTimeG711G726, mscVsrSvsFramerCurrentEncodingRate=mscVsrSvsFramerCurrentEncodingRate, mscVRouteSubroutesEntry=mscVRouteSubroutesEntry, mscVRouteDebug=mscVRouteDebug, mscVRouteStatsEntry=mscVRouteStatsEntry, mscSigChanGwGwcIndex=mscSigChanGwGwcIndex, mscVRouteDnaAddressEntry=mscVRouteDnaAddressEntry, mscVsrIfIndex=mscVsrIfIndex, mscSigChanICmapIntCauseEntry=mscSigChanICmapIntCauseEntry, mscVsrSvsIfAdminStatus=mscVsrSvsIfAdminStatus, mscVRouteSubroutesRowStatus=mscVRouteSubroutesRowStatus, mscSigChanNcasDuration=mscSigChanNcasDuration, mscVRouteDna=mscVRouteDna, mscSigChanICmapServNotAllowedCause=mscSigChanICmapServNotAllowedCause, mscVsrProvEntry=mscVsrProvEntry, mscVsrActiveFaxRelayChannels=mscVsrActiveFaxRelayChannels, mscVsrSvsDebugRowStatusTable=mscVsrSvsDebugRowStatusTable, mscVRouteAcctRowStatusTable=mscVRouteAcctRowStatusTable, mscVRouteCidDataEntry=mscVRouteCidDataEntry, mscVRouteProvEntry=mscVRouteProvEntry, mscVsrSvsFramerFrmFromNetworkEntry=mscVsrSvsFramerFrmFromNetworkEntry, mscSigChan=mscSigChan, mscVsrSvsFramerFrmFromNetworkTable=mscVsrSvsFramerFrmFromNetworkTable, mscVsrDebugIndex=mscVsrDebugIndex, mscVsrSvsFramerFrmFromNetworkIndex=mscVsrSvsFramerFrmFromNetworkIndex, mscSigChanGwStorageType=mscSigChanGwStorageType, mscVRouteRowStatus=mscVRouteRowStatus, mscVsrSvsLCoRequiredRxBandwidth=mscVsrSvsLCoRequiredRxBandwidth, mscSigChanGwGwcEntry=mscSigChanGwGwcEntry, mscVsrIndex=mscVsrIndex, mscVsrSvsAdminState=mscVsrSvsAdminState, mscVRouteInterfaceRowStatus=mscVRouteInterfaceRowStatus, mscVsrSvsRowStatusTable=mscVsrSvsRowStatusTable, mscVRouteAcctDigitsSuppressed=mscVRouteAcctDigitsSuppressed, mscVsrRowStatus=mscVsrRowStatus, voiceNetworkingGroupCA=voiceNetworkingGroupCA, mscVRouteOperStatusEntry=mscVRouteOperStatusEntry, mscVsrSvsFramerFaxRelayCells=mscVsrSvsFramerFaxRelayCells, mscSigChanGw=mscSigChanGw, mscVsrSvsLCoRowStatusTable=mscVsrSvsLCoRowStatusTable, mscVRouteDnaStorageType=mscVRouteDnaStorageType, mscVsrActiveChannels=mscVsrActiveChannels, mscVsrPeakActiveModemChannels=mscVsrPeakActiveModemChannels, mscSigChanICmapResourceUnavailCause=mscSigChanICmapResourceUnavailCause, mscSigChanDegradedSubroutesEntry=mscSigChanDegradedSubroutesEntry, mscVsrCidDataEntry=mscVsrCidDataEntry, mscSigChanNcasCallReference=mscSigChanNcasCallReference, mscSigChanStateEntry=mscSigChanStateEntry, mscVRouteInterfaceEchoTailDelay=mscVRouteInterfaceEchoTailDelay, mscVsrSvsOperationalState=mscVsrSvsOperationalState, mscVsrSvsFramerMvpDebugRowStatusEntry=mscVsrSvsFramerMvpDebugRowStatusEntry, mscVRouteCidDataTable=mscVRouteCidDataTable, mscVsrSvsFramerFrmLostInNetwork=mscVsrSvsFramerFrmLostInNetwork, mscVsrSvsStorageType=mscVsrSvsStorageType, mscVRouteDebugComponentName=mscVRouteDebugComponentName, mscVsrSvsFramerNegotiatedTandemPassThrough=mscVsrSvsFramerNegotiatedTandemPassThrough, mscVsrDebugRowStatus=mscVsrDebugRowStatus, mscVsrStatsTable=mscVsrStatsTable, mscVRouteAcctProvTable=mscVRouteAcctProvTable, mscVRouteCallsClearedOutOfService=mscVRouteCallsClearedOutOfService, mscVsrSvsLCoRequiredSecurity=mscVsrSvsLCoRequiredSecurity, mscVsrSvsFramerFrmToNetworkValue=mscVsrSvsFramerFrmToNetworkValue, mscSigChanDefaultNpiTon=mscSigChanDefaultNpiTon, mscVsrSvsCallingNumber=mscVsrSvsCallingNumber, mscVsrSvsLCoRequiredTxBandwidth=mscVsrSvsLCoRequiredTxBandwidth, mscVsrSvsIfEntryTable=mscVsrSvsIfEntryTable, mscVsrSvsFramerRowStatusEntry=mscVsrSvsFramerRowStatusEntry, mscVsrDebug=mscVsrDebug, mscSigChanSubroutesValue=mscSigChanSubroutesValue, mscVsrSvsLCoBytesFromNetwork=mscVsrSvsLCoBytesFromNetwork, mscVsrIfEntryTable=mscVsrIfEntryTable, mscVRouteAcctStorageType=mscVRouteAcctStorageType, mscVsrSvsLCoCostMetric=mscVsrSvsLCoCostMetric, mscVsrSvsLCoPathTable=mscVsrSvsLCoPathTable, mscVsrCallsRejectedLocally=mscVsrCallsRejectedLocally, mscVsrDebugStorageType=mscVsrDebugStorageType, mscVsrDebugRowStatusEntry=mscVsrDebugRowStatusEntry, mscVsrSvsStatsEntry=mscVsrSvsStatsEntry, mscVsrSvsTotalCallSeconds=mscVsrSvsTotalCallSeconds, mscSigChanAdminState=mscSigChanAdminState, mscVRouteIfEntryTable=mscVRouteIfEntryTable, mscVRouteInterfaceEchoCancellation=mscVRouteInterfaceEchoCancellation, mscVRouteInterfaceRowStatusEntry=mscVRouteInterfaceRowStatusEntry, mscVsrSvsFramerNRatesTrafficIndex=mscVsrSvsFramerNRatesTrafficIndex, mscVsrPeakActiveDataChannels=mscVsrPeakActiveDataChannels, mscVsrSvsLCo=mscVsrSvsLCo, mscVRouteInterfaceSpeechHangoverTime=mscVRouteInterfaceSpeechHangoverTime, mscVsrSvsLCoDiscardPriority=mscVsrSvsLCoDiscardPriority, mscVsrRowStatusTable=mscVsrRowStatusTable, mscVsrSvsCalledNumber=mscVsrSvsCalledNumber, mscVsrProvTable=mscVsrProvTable, mscVsrSvs=mscVsrSvs, mscSigChanOperStatusTable=mscSigChanOperStatusTable, mscSigChanNcasDirection=mscSigChanNcasDirection, mscVRouteInterfaceRowStatusTable=mscVRouteInterfaceRowStatusTable, mscSigChanGwRowStatusTable=mscSigChanGwRowStatusTable, mscSigChanICmapRowStatusTable=mscSigChanICmapRowStatusTable, mscVsrSvsIfEntryEntry=mscVsrSvsIfEntryEntry, mscVRouteTotalCallsFromSubnet=mscVRouteTotalCallsFromSubnet, mscVsrSvsLCoRoundTripDelay=mscVsrSvsLCoRoundTripDelay, mscVRouteAcctIndex=mscVRouteAcctIndex, mscSigChanSubroutesRowStatus=mscSigChanSubroutesRowStatus, mscVsrSvsFramerOperTable=mscVsrSvsFramerOperTable, mscVsrSvsFramerNegotiatedDtmfRegeneration=mscVsrSvsFramerNegotiatedDtmfRegeneration, mscVsrPeakActiveFaxRelayChannels=mscVsrPeakActiveFaxRelayChannels, mscVRouteInterfaceEchoReturnLoss=mscVRouteInterfaceEchoReturnLoss, mscSigChanRowStatusTable=mscSigChanRowStatusTable)
mibBuilder.exportSymbols("Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", mscSigChanICmapRowStatusEntry=mscSigChanICmapRowStatusEntry, mscVRouteInterfaceComponentName=mscVRouteInterfaceComponentName, mscSigChanStateTable=mscSigChanStateTable, mscVRouteIfAdminStatus=mscVRouteIfAdminStatus, mscSigChanGwComponentName=mscSigChanGwComponentName, mscVsrSvsLCoPathFailureCount=mscVsrSvsLCoPathFailureCount, mscVsrSvsFramerNEncodingEntry=mscVsrSvsFramerNEncodingEntry, mscVRouteInterfaceEcanBypassMode=mscVRouteInterfaceEcanBypassMode, mscVsrSvsFramerFrmFromNetworkValue=mscVsrSvsFramerFrmFromNetworkValue, mscVsrSvsFramerStatsTable=mscVsrSvsFramerStatsTable, mscVsrPeakActiveVoiceChannels=mscVsrPeakActiveVoiceChannels, mscVsrSvsStatsTable=mscVsrSvsStatsTable, mscVsrSvsFramerPcmCaptureRowStatusTable=mscVsrSvsFramerPcmCaptureRowStatusTable, mscVsrSvsFramerNegotiatedV17AsG711G726=mscVsrSvsFramerNegotiatedV17AsG711G726, mscVsrActiveTptChannels=mscVsrActiveTptChannels, mscVsrSvsLCoReasonForNoRoute=mscVsrSvsLCoReasonForNoRoute, mscVRouteDegradedSubroutesEntry=mscVRouteDegradedSubroutesEntry, mscVsrSvsLCoStatsTable=mscVsrSvsLCoStatsTable, mscVsrSvsIndex=mscVsrSvsIndex, mscVsrSvsLCoPktsToNetwork=mscVsrSvsLCoPktsToNetwork, mscVRouteRowStatusEntry=mscVRouteRowStatusEntry, mscVsrTotalCallsFromIf=mscVsrTotalCallsFromIf, mscVsrPeakActiveChannels=mscVsrPeakActiveChannels, mscVsrSvsLCoRequiredTrafficType=mscVsrSvsLCoRequiredTrafficType, mscSigChanICmapComponentName=mscSigChanICmapComponentName, mscSigChanICmapNoSuchChannelCause=mscSigChanICmapNoSuchChannelCause, mscSigChanICmapIncompatDestCause=mscSigChanICmapIncompatDestCause, mscSigChanCidDataTable=mscSigChanCidDataTable, mscSigChanBchRowStatusEntry=mscSigChanBchRowStatusEntry, mscVsrIfAdminStatus=mscVsrIfAdminStatus, mscSigChanCustomerIdentifier=mscSigChanCustomerIdentifier, mscSigChanICmapSwitchCongestCause=mscSigChanICmapSwitchCongestCause, mscSigChanNcasStorageType=mscSigChanNcasStorageType, mscVRouteInterfaceStructuredEchoCancellationEntry=mscVRouteInterfaceStructuredEchoCancellationEntry, mscSigChanOctothorpeEod=mscSigChanOctothorpeEod, mscVRouteStorageType=mscVRouteStorageType, mscVRouteIfIndex=mscVRouteIfIndex, mscVsrSvsFramerFrmUnderRuns=mscVsrSvsFramerFrmUnderRuns, mscVsr=mscVsr, mscVRouteAcctProvEntry=mscVRouteAcctProvEntry, mscSigChanBchIndex=mscSigChanBchIndex, mscVsrSvsFramer=mscVsrSvsFramer, mscVsrSvsFramerModemCells=mscVsrSvsFramerModemCells, mscSigChanNcas=mscSigChanNcas, mscVsrSvsFramerFaxIdleCells=mscVsrSvsFramerFaxIdleCells, mscVsrSvsFramerNegotiatedFisG711G726=mscVsrSvsFramerNegotiatedFisG711G726, mscVRouteTypeOfRoute=mscVRouteTypeOfRoute, mscVRouteCallsRejected=mscVRouteCallsRejected, mscVsrSvsFramerStatsEntry=mscVsrSvsFramerStatsEntry, mscVRouteInterfaceStructuredEchoCancellationIndex=mscVRouteInterfaceStructuredEchoCancellationIndex, mscVRouteRowStatusTable=mscVRouteRowStatusTable, mscVsrSvsLCoDelayMetric=mscVsrSvsLCoDelayMetric, mscVsrAddressResolutionFailedCalls=mscVsrAddressResolutionFailedCalls, mscVsrSvsFramerNEncodingIndex=mscVsrSvsFramerNEncodingIndex, mscVsrSvsLCoRequiredCustomerParameter=mscVsrSvsLCoRequiredCustomerParameter, mscVsrSvsLCoPathType=mscVsrSvsLCoPathType, mscVsrSvsFramerOperEntry=mscVsrSvsFramerOperEntry, mscVsrSvsFramerSilenceCells=mscVsrSvsFramerSilenceCells, mscVsrSvsSnmpOperStatus=mscVsrSvsSnmpOperStatus, mscVsrSvsLCoPathValue=mscVsrSvsLCoPathValue, mscVsrSvsDebugComponentName=mscVsrSvsDebugComponentName, mscVsrSvsFramerTotalCells=mscVsrSvsFramerTotalCells, mscSigChanIfEntryEntry=mscSigChanIfEntryEntry, mscSigChanIndex=mscSigChanIndex, mscVsrSvsFramerModemSilenceCells=mscVsrSvsFramerModemSilenceCells, mscVsrSvsLCoOverrideRemoteName=mscVsrSvsLCoOverrideRemoteName, mscVsrActiveDataChannels=mscVsrActiveDataChannels, mscSigChanICmapStorageType=mscSigChanICmapStorageType, mscVRouteInterfaceStorageType=mscVRouteInterfaceStorageType, mscVsrStatsEntry=mscVsrStatsEntry, mscVsrSvsFramerComponentName=mscVsrSvsFramerComponentName, mscVsrSvsTotalCalls=mscVsrSvsTotalCalls, mscVsrSvsOperStatusTable=mscVsrSvsOperStatusTable, mscSigChanBchCalledDirectoryNumber=mscSigChanBchCalledDirectoryNumber, mscVRoutePrivateNetworkIdentifer=mscVRoutePrivateNetworkIdentifer, mscVsrSvsFramerPcmCaptureComponentName=mscVsrSvsFramerPcmCaptureComponentName, mscVRouteDebugRowStatus=mscVRouteDebugRowStatus, mscSigChanICmapIndex=mscSigChanICmapIndex, mscVsrSvsFramerFrmToNetworkEntry=mscVsrSvsFramerFrmToNetworkEntry, mscVsrSvsFramerTptStatus=mscVsrSvsFramerTptStatus, mscVsrSvsFramerStateEntry=mscVsrSvsFramerStateEntry, mscVRouteAcctAccountCollection=mscVRouteAcctAccountCollection, mscSigChanGwGatewayCapIndex=mscSigChanGwGatewayCapIndex, mscVRouteInterfaceIngressAudioGain=mscVRouteInterfaceIngressAudioGain, mscSigChanGwIndex=mscSigChanGwIndex, mscVRouteDegradedSubroutesTable=mscVRouteDegradedSubroutesTable, mscSigChanUsageState=mscSigChanUsageState, mscVsrSvsStateTable=mscVsrSvsStateTable, mscVsrSvsFramerModemFaxCells=mscVsrSvsFramerModemFaxCells, mscVsrSvsFramerOpTptStatus=mscVsrSvsFramerOpTptStatus, mscVsrSvsFramerVfpDebugStorageType=mscVsrSvsFramerVfpDebugStorageType, mscSigChanBch=mscSigChanBch, mscVsrSvsFramerFrmToNetworkTable=mscVsrSvsFramerFrmToNetworkTable, mscVRouteDebugIndex=mscVRouteDebugIndex, mscVsrSvsFramerMvpDebugStorageType=mscVsrSvsFramerMvpDebugStorageType, mscVRouteVoiceNetworkingCallServer=mscVRouteVoiceNetworkingCallServer, mscVsrSvsLCoHoldingPriority=mscVsrSvsLCoHoldingPriority, mscVsrSvsFramerNEncodingValue=mscVsrSvsFramerNEncodingValue, mscSigChanNcasComponentName=mscSigChanNcasComponentName, mscVRouteAcctAccountClass=mscVRouteAcctAccountClass, mscSigChanICmap=mscSigChanICmap, mscVRouteDebugStorageType=mscVRouteDebugStorageType, mscVsrSvsDebugRowStatusEntry=mscVsrSvsDebugRowStatusEntry, mscVsrStorageType=mscVsrStorageType, mscVsrSvsLCoRowStatusEntry=mscVsrSvsLCoRowStatusEntry, mscVsrSvsFramerMvpDebugComponentName=mscVsrSvsFramerMvpDebugComponentName, mscVRouteInterfaceIndex=mscVRouteInterfaceIndex, mscVsrCidDataTable=mscVsrCidDataTable, mscVRouteDnaRowStatusTable=mscVRouteDnaRowStatusTable, mscVRouteAdminState=mscVRouteAdminState, mscVsrSvsFramerCurrentRate=mscVsrSvsFramerCurrentRate, mscSigChanGwStatsEntry=mscSigChanGwStatsEntry, mscSigChanGwRowStatus=mscSigChanGwRowStatus, mscVsrActiveModemChannels=mscVsrActiveModemChannels, mscVsrOperStatusEntry=mscVsrOperStatusEntry, mscSigChanGwGatewayCapValue=mscSigChanGwGatewayCapValue, mscSigChanBchRowStatus=mscSigChanBchRowStatus, mscVsrActiveVoiceChannels=mscVsrActiveVoiceChannels, mscVsrSvsLCoIndex=mscVsrSvsLCoIndex, mscVRouteInterfaceStructuredEchoCancellationValue=mscVRouteInterfaceStructuredEchoCancellationValue, mscSigChanNcasRowStatusTable=mscSigChanNcasRowStatusTable, mscVsrSvsLCoComponentName=mscVsrSvsLCoComponentName, mscSigChanSubroutesTable=mscSigChanSubroutesTable, mscVsrOperationalState=mscVsrOperationalState, mscVRouteInterfaceProvEntry=mscVRouteInterfaceProvEntry, mscVRouteCommentText=mscVRouteCommentText, mscSigChanNcasRowStatusEntry=mscSigChanNcasRowStatusEntry, mscVRouteCallsClearedNoChannel=mscVRouteCallsClearedNoChannel, mscVsrSvsFramerLrcErrors=mscVsrSvsFramerLrcErrors, mscVsrSvsFramerMvpDebug=mscVsrSvsFramerMvpDebug, mscVsrSvsUsageState=mscVsrSvsUsageState, mscVsrPathSetupTimeOutCalls=mscVsrPathSetupTimeOutCalls, mscVsrSvsFramerProvEntry=mscVsrSvsFramerProvEntry, mscVsrSvsLCoStatsEntry=mscVsrSvsLCoStatsEntry, mscSigChanOperStatusEntry=mscSigChanOperStatusEntry, mscVsrRowStatusEntry=mscVsrRowStatusEntry, mscVRouteStateTable=mscVRouteStateTable, mscSigChanICmapEgressLinkOutOfServCause=mscSigChanICmapEgressLinkOutOfServCause, mscVsrSnmpOperStatus=mscVsrSnmpOperStatus, mscSigChanBchStatus=mscSigChanBchStatus, mscSigChanNcasCalledDirectoryNumber=mscSigChanNcasCalledDirectoryNumber, mscSigChanSubroutesEntry=mscSigChanSubroutesEntry, mscVRouteDegradedSubroutesValue=mscVRouteDegradedSubroutesValue, mscVsrInvalidNumberingPlanCalls=mscVsrInvalidNumberingPlanCalls, mscVsrSvsOperTable=mscVsrSvsOperTable, mscVsrSvsLCoPathDataTable=mscVsrSvsLCoPathDataTable, mscVsrSvsFramerStorageType=mscVsrSvsFramerStorageType, mscVsrVoiceRoute=mscVsrVoiceRoute, mscVsrSvsFramerNRatesRateIndex=mscVsrSvsFramerNRatesRateIndex, mscSigChanICmapIntCauseTable=mscSigChanICmapIntCauseTable, mscSigChanOperationalState=mscSigChanOperationalState, mscVsrOperEntry=mscVsrOperEntry, mscVRouteDnaAddressTable=mscVRouteDnaAddressTable, mscVsrSvsLCoBytesToNetwork=mscVsrSvsLCoBytesToNetwork, mscSigChanProvEntry=mscSigChanProvEntry, mscSigChanBchOperEntry=mscSigChanBchOperEntry, mscVsrSvsLCoStorageType=mscVsrSvsLCoStorageType, mscVsrSvsFramerAudioCells=mscVsrSvsFramerAudioCells, mscSigChanBchVsrInstance=mscSigChanBchVsrInstance, voiceNetworkingCapabilitiesCA02A=voiceNetworkingCapabilitiesCA02A, mscVRouteAcctRowStatus=mscVRouteAcctRowStatus, mscVsrCustomerIdentifier=mscVsrCustomerIdentifier, mscSigChanGwStatsTable=mscSigChanGwStatsTable, mscVRoute=mscVRoute, mscVsrSvsLCoSetupPriority=mscVsrSvsLCoSetupPriority, mscVsrAdminState=mscVsrAdminState, mscVsrSvsFramerRowStatusTable=mscVsrSvsFramerRowStatusTable, mscVRouteStateEntry=mscVRouteStateEntry, mscVsrSvsLCoBumpPreference=mscVsrSvsLCoBumpPreference, mscSigChanComponentName=mscSigChanComponentName, mscVsrSvsFramerNRatesValue=mscVsrSvsFramerNRatesValue, mscVRouteSnmpOperStatus=mscVRouteSnmpOperStatus, mscVRouteAcctComponentName=mscVRouteAcctComponentName, mscSigChanBchComponentName=mscSigChanBchComponentName, mscVsrSvsRowStatus=mscVsrSvsRowStatus, mscVRouteAcct=mscVRouteAcct, mscVsrSvsFramerPcmCaptureIndex=mscVsrSvsFramerPcmCaptureIndex, mscVsrPeakActiveTptChannels=mscVsrPeakActiveTptChannels)

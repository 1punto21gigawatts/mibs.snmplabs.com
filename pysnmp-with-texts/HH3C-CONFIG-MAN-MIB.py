#
# PySNMP MIB module HH3C-CONFIG-MAN-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/HH3C-CONFIG-MAN-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:25:48 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ValueRangeConstraint, ConstraintsUnion, ConstraintsIntersection, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsUnion", "ConstraintsIntersection", "SingleValueConstraint")
hh3cCommon, = mibBuilder.importSymbols("HH3C-OID-MIB", "hh3cCommon")
InetAddress, InetAddressType = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddress", "InetAddressType")
ModuleCompliance, NotificationGroup, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup", "ObjectGroup")
MibScalar, MibTable, MibTableRow, MibTableColumn, NotificationType, Integer32, Counter64, Gauge32, Unsigned32, IpAddress, Bits, ObjectIdentity, TimeTicks, ModuleIdentity, Counter32, MibIdentifier, iso = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "NotificationType", "Integer32", "Counter64", "Gauge32", "Unsigned32", "IpAddress", "Bits", "ObjectIdentity", "TimeTicks", "ModuleIdentity", "Counter32", "MibIdentifier", "iso")
RowStatus, TextualConvention, DisplayString, TruthValue = mibBuilder.importSymbols("SNMPv2-TC", "RowStatus", "TextualConvention", "DisplayString", "TruthValue")
hh3cConfig = ModuleIdentity((1, 3, 6, 1, 4, 1, 25506, 2, 4))
hh3cConfig.setRevisions(('2011-11-26 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: hh3cConfig.setRevisionsDescriptions(('Initial revision of this MIB module.',))
if mibBuilder.loadTexts: hh3cConfig.setLastUpdated('201111260000Z')
if mibBuilder.loadTexts: hh3cConfig.setOrganization('Hangzhou H3C Tech. Co., Ltd.')
if mibBuilder.loadTexts: hh3cConfig.setContactInfo('Platform Team Hangzhou H3C Tech. Co., Ltd. Hai-Dian District Beijing P.R. China http://www.h3c.com Zip:100085')
if mibBuilder.loadTexts: hh3cConfig.setDescription('This MIB contains objects for managing the system configuration. It contains the model used to represent configuration data that exists elsewhere in the system and in peripheral devices. There are no constraints on this MIB.')
class ConfigOperationType(TextualConvention, Integer32):
    description = 'Specify operation types on configuration. Currently, following types of operation are provided: running2Startup(1): Update the saved configuration (startup) file used currently with the current configuration running in the system. This operation is equivalent to the [save] command from command line. If current startup configuration file does not exist, then the default startup configuration file is created to save the data and this becomes the current startup configuration file. startup2Running(2): Update the current configuration running in the system with the saved configuration (startup) file used currently. The commands in the file are executed as if they had been entered via the command line. If the current startup configuration file does not exist, the operation will fail with the error opFileOpenError(13). running2Net(3): Send the current configuration running in the system to the network using the specified file transfer protocol. net2Running(4): Update the current configuration running in the system with a remote file from the network using the specified file transfer protocol. The commands in the file are executed as if they had been entered via the command line. net2Startup(5): Download a remote file to the local system using the specified file transfer protocol and replace the saved configuration (startup) file used currently. If current startup configurationfile does not exist, the default startup configuration file is created to save the data and this becomes the current startup configuration file. startup2Net(6): Send the saved configuration (startup) file used currently to the network using the specified file transfer protocol. If the current startup configuration file does not exist, the operation will fail with the error opFileOpenError(13). '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))
    namedValues = NamedValues(("running2Startup", 1), ("startup2Running", 2), ("running2Net", 3), ("net2Running", 4), ("net2Startup", 5), ("startup2Net", 6))

class ConfigOperationStateType(TextualConvention, Integer32):
    description = "The status of the specified operation. opInProgress : Specified operation is active. opOperationSuccess : Specified operation is supported and completed successfully. opInvalidOperation : Command invalid or command/protocol/device combination unsupported. opInvalidProtocol : Invalid protocol specified. opInvalidSourceName : Invalid source file name specified. opInvalidDestName : Invalid target name specified. opInvalidServerAddress : Invalid server address specified. opDeviceBusy : Specified device is in use and locked by another process. opDeviceOpenError : Invalid device name. opDeviceError : Device read, write or erase error. opDeviceNotProgrammable : Device is read-only but a write or erase operation was specified. opDeviceFull : Device is filled to capacity. opFileOpenError : Invalid file name; file not found in partition. opFileTransferError : File transfer was unsuccessful; network failure. opFileChecksumError : File checksum in Flash failed. opNoMemory : System running low on memory. opAuthFail: Invalid user name or password. opTimeOut : File transfer was timeout. opUnknownFailure : Failure unknown. opInvalidConfigFile: Invalid configration file. opSlaveFull : Operation is fail for the slave don't have enough space. opCopyToSlaveFailure : Operation is fail when copy file to the slave. "
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22))
    namedValues = NamedValues(("opInProgress", 1), ("opSuccess", 2), ("opInvalidOperation", 3), ("opInvalidProtocol", 4), ("opInvalidSourceName", 5), ("opInvalidDestName", 6), ("opInvalidServerAddress", 7), ("opDeviceBusy", 8), ("opDeviceOpenError", 9), ("opDeviceError", 10), ("opDeviceNotProgrammable", 11), ("opDeviceFull", 12), ("opFileOpenError", 13), ("opFileTransferError", 14), ("opFileChecksumError", 15), ("opNoMemory", 16), ("opAuthFail", 17), ("opTimeOut", 18), ("opUnknownFailure", 19), ("opInvalidConfigFile", 20), ("opSlaveFull", 21), ("opCopyToSlaveFailure", 22))

hh3cConfigManObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 4, 1))
hh3cCfgLog = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 4, 1, 1))
hh3cCfgRunModifiedLast = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 4, 1, 1, 1), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cCfgRunModifiedLast.setStatus('current')
if mibBuilder.loadTexts: hh3cCfgRunModifiedLast.setDescription('The object records the value of sysUpTime when the current configuration running in the system was last modified. The value will be changed immediately after system detects the current configuration has been changed.')
hh3cCfgRunSavedLast = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 4, 1, 1, 2), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cCfgRunSavedLast.setStatus('current')
if mibBuilder.loadTexts: hh3cCfgRunSavedLast.setDescription('The object records the value of sysUpTime when the current configuration running in the system was last saved. If the value of the object is smaller than hh3cCfgRunModifiedLast, the current configuration has been modified but not saved.')
hh3cCfgStartModifiedLast = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 4, 1, 1, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cCfgStartModifiedLast.setStatus('current')
if mibBuilder.loadTexts: hh3cCfgStartModifiedLast.setDescription('The object records the value of sysUpTime when the saved configuration used currently was last modified. It may have been modified by a save of the current configuration running in the system or other methods such as copy.')
hh3cCfgLogLimitedEntries = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cCfgLogLimitedEntries.setStatus('current')
if mibBuilder.loadTexts: hh3cCfgLogLimitedEntries.setDescription('The object shows the maximum number of rows in hh3cCfgLogTable. The value supported by the system is 10. ')
hh3cCfgLogDeletedEntries = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 4, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cCfgLogDeletedEntries.setStatus('current')
if mibBuilder.loadTexts: hh3cCfgLogDeletedEntries.setDescription('The total number of rows deleted from hh3cCfgLogTable.')
hh3cCfgLogWantBackup = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 4, 1, 1, 6), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cCfgLogWantBackup.setStatus('current')
if mibBuilder.loadTexts: hh3cCfgLogWantBackup.setDescription('Decide whether to backup the value of objects about hh3cCfgLog.')
hh3cCfgLogTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 4, 1, 1, 7), )
if mibBuilder.loadTexts: hh3cCfgLogTable.setStatus('current')
if mibBuilder.loadTexts: hh3cCfgLogTable.setDescription('Table for logging configuration operation in device.')
hh3cCfgLogEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 4, 1, 1, 7, 1), ).setIndexNames((0, "HH3C-CONFIG-MAN-MIB", "hh3cCfgLogIndex"))
if mibBuilder.loadTexts: hh3cCfgLogEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cCfgLogEntry.setDescription('Information of the entry.')
hh3cCfgLogIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 4, 1, 1, 7, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: hh3cCfgLogIndex.setStatus('current')
if mibBuilder.loadTexts: hh3cCfgLogIndex.setDescription('Index of the table beginning from 1.')
hh3cCfgLogTime = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 4, 1, 1, 7, 1, 2), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cCfgLogTime.setStatus('current')
if mibBuilder.loadTexts: hh3cCfgLogTime.setDescription('Specify the sysUpTime when the config log was generated.')
hh3cCfgLogSrcCmd = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 4, 1, 1, 7, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("cmdLine", 1), ("snmp", 2), ("other", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cCfgLogSrcCmd.setStatus('current')
if mibBuilder.loadTexts: hh3cCfgLogSrcCmd.setDescription('Specify the source command which brought the log. Currently we provide the types of source: 1.cmdLine(1):configure log instigated by command line. 2.snmp(2):configure log instigated by snmp. 3.other(3):configure log instigated by other source unknown.')
hh3cCfgLogSrcData = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 4, 1, 1, 7, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("erase", 1), ("runningData", 2), ("commandSource", 3), ("startupData", 4), ("local", 5), ("netFtp", 6), ("hotPlugging", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cCfgLogSrcData.setStatus('current')
if mibBuilder.loadTexts: hh3cCfgLogSrcData.setDescription('The source of the configuration data event. erase erasing destination runningData operational data alive commandSource the command source itself startupData what the system will use next reboot local local NVRAM or flash netFtp FTP network transfer hotPlugging board is inserted or pulled out on line ')
hh3cCfgLogDesData = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 4, 1, 1, 7, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("unknown", 1), ("runningData", 2), ("commandSource", 3), ("startupData", 4), ("local", 5), ("netFtp", 6), ("hotPlugging", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cCfgLogDesData.setStatus('current')
if mibBuilder.loadTexts: hh3cCfgLogDesData.setDescription('The destination for the configuration data event. unknown unknown runningData operational data alive commandSource the command source itself startupData what the system will use next reboot local local NVRAM or flash netFtp FTP network transfer hotPlugging board is inserted or pulled out on line')
hh3cCfgLogTerminalType = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 4, 1, 1, 7, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("notApplicable", 1), ("unknown", 2), ("console", 3), ("terminal", 4), ("virtual", 5), ("auxiliary", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cCfgLogTerminalType.setStatus('current')
if mibBuilder.loadTexts: hh3cCfgLogTerminalType.setDescription("Specifies the terminal type. If hh3cCfgLogSrcCmd is not 'cmdLine', use 'notApplicable'. The value list: notApplicable(1): no meaning at this time. unknown(2): unknown terminal type. console(3): console interface. terminal(4): generic terminal. virtual(5): virtual terminal such as telnet. auxiliary(6): auxiliary interface.")
hh3cCfgLogTerminalUser = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 4, 1, 1, 7, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cCfgLogTerminalUser.setStatus('current')
if mibBuilder.loadTexts: hh3cCfgLogTerminalUser.setDescription("The name of logging user which is available when hh3cCfgLogSrcCmd is 'cmdLine'. Other, a zero length string.")
hh3cCfgLogTerminalNum = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 4, 1, 1, 7, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cCfgLogTerminalNum.setStatus('current')
if mibBuilder.loadTexts: hh3cCfgLogTerminalNum.setDescription("Specifies the terminal number. If hh3cCfgLogSrcCmd is not 'cmdLine', use '-1'")
hh3cCfgLogTerminalLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 4, 1, 1, 7, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cCfgLogTerminalLocation.setStatus('current')
if mibBuilder.loadTexts: hh3cCfgLogTerminalLocation.setDescription("The location of logging user which is available when hh3cCfgLogSrcCmd is 'cmdLine'. Other, a zero length string.")
hh3cCfgLogCmdSrcAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 4, 1, 1, 7, 1, 10), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cCfgLogCmdSrcAddress.setStatus('deprecated')
if mibBuilder.loadTexts: hh3cCfgLogCmdSrcAddress.setDescription("The address from which a request comes when the value of hh3cCfgLogSrcCmd is 'snmp(2)'. The ip address of the remote system connected when the value of hh3cCfgLogTerminalType is 'virtual'. Other, the value of 0.0.0.0. This object is replaced by hh3cCfgLogCmdSrcAddrRev for it only support IPv4.")
hh3cCfgLogVirHost = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 4, 1, 1, 7, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cCfgLogVirHost.setStatus('current')
if mibBuilder.loadTexts: hh3cCfgLogVirHost.setDescription("The host name of remote system connected if hh3cCfgLogTerminalType has the value of 'virtual'. Other, a zero length string.")
hh3cCfgLogUserName = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 4, 1, 1, 7, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cCfgLogUserName.setStatus('current')
if mibBuilder.loadTexts: hh3cCfgLogUserName.setDescription("The user name used when hh3cCfgLogSrcData or hh3cCfgLogDesData has the value of 'netFtp'. Other, a zero length string.")
hh3cCfgLogServerAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 4, 1, 1, 7, 1, 13), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cCfgLogServerAddress.setStatus('deprecated')
if mibBuilder.loadTexts: hh3cCfgLogServerAddress.setDescription("The remote server address when hh3cCfgLogSrcData or hh3cCfgLogDesData has the value of 'netFtp'. Other, a value of 0.0.0.0. This object is replaced by hh3cCfgLogServerAddrRev for it only support IPv4.")
hh3cCfgLogFile = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 4, 1, 1, 7, 1, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cCfgLogFile.setStatus('current')
if mibBuilder.loadTexts: hh3cCfgLogFile.setDescription("The current configuration file name when hh3cCfgLogSrcData has the value of 'netFtp',and hh3cCfgLogDesData has the value of 'startupData'. Other, a zero length string.")
hh3cCfgLogCmdSrcAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 4, 1, 1, 7, 1, 15), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cCfgLogCmdSrcAddrType.setStatus('current')
if mibBuilder.loadTexts: hh3cCfgLogCmdSrcAddrType.setDescription('The type of IP address for the hh3cCfgLogCmdSrcAddrRev.')
hh3cCfgLogCmdSrcAddrRev = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 4, 1, 1, 7, 1, 16), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cCfgLogCmdSrcAddrRev.setStatus('current')
if mibBuilder.loadTexts: hh3cCfgLogCmdSrcAddrRev.setDescription("The address from which a request comes when the value of hh3cCfgLogSrcCmd is 'snmp(2)'. The ip address of the remote system connected when the value of hh3cCfgLogTerminalType is 'virtual'. Other, the value of 0.0.0.0.")
hh3cCfgLogCmdSrcAddrVPNName = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 4, 1, 1, 7, 1, 17), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cCfgLogCmdSrcAddrVPNName.setStatus('current')
if mibBuilder.loadTexts: hh3cCfgLogCmdSrcAddrVPNName.setDescription('The VPN instance of this operation uses.')
hh3cCfgLogServerAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 4, 1, 1, 7, 1, 18), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cCfgLogServerAddrType.setStatus('current')
if mibBuilder.loadTexts: hh3cCfgLogServerAddrType.setDescription('The type of IP address for the hh3cCfgLogServerAddrRev.')
hh3cCfgLogServerAddrRev = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 4, 1, 1, 7, 1, 19), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cCfgLogServerAddrRev.setStatus('current')
if mibBuilder.loadTexts: hh3cCfgLogServerAddrRev.setDescription("The remote server address when hh3cCfgLogSrcData or hh3cCfgLogDesData has the value of 'netFtp'. Other, a value of 0.0.0.0.")
hh3cCfgLogServerAddrVPNName = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 4, 1, 1, 7, 1, 20), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cCfgLogServerAddrVPNName.setStatus('current')
if mibBuilder.loadTexts: hh3cCfgLogServerAddrVPNName.setDescription('The VPN instance of this operation uses.')
hh3cCfgFirstTrapTime = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 4, 1, 1, 8), TimeTicks()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hh3cCfgFirstTrapTime.setStatus('current')
if mibBuilder.loadTexts: hh3cCfgFirstTrapTime.setDescription('Time when the first trap is sent.')
hh3cCfgOperate = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 4, 1, 2))
hh3cCfgOperateGlobalEntryLimit = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 4, 1, 2, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)).clone(5)).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cCfgOperateGlobalEntryLimit.setStatus('current')
if mibBuilder.loadTexts: hh3cCfgOperateGlobalEntryLimit.setDescription('The maximum number of copy entries that may be held in hh3cCfgOperateTable. A particular setting does not guarantee that much data can be held.')
hh3cCfgOperateEntryAgeOutTime = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 4, 1, 2, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60)).clone(5)).setUnits('minute').setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cCfgOperateEntryAgeOutTime.setStatus('current')
if mibBuilder.loadTexts: hh3cCfgOperateEntryAgeOutTime.setDescription('The number of minutes an unactive hh3cCfgOperateEntry SHOULD be kept in the hh3cCfgOperateTable before it is active. The object is a fator taken account of when it needs delete some rows make room in hh3cCfgOperateTable. ')
hh3cCfgOperateResultGlobalEntryLimit = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 4, 1, 2, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 50)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cCfgOperateResultGlobalEntryLimit.setStatus('current')
if mibBuilder.loadTexts: hh3cCfgOperateResultGlobalEntryLimit.setDescription('The maximum number of copy entries that may be held in hh3cCfgOperateResultTable. A particular setting does not guarantee that much data can be held.')
hh3cCfgOperateTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 4, 1, 2, 4), )
if mibBuilder.loadTexts: hh3cCfgOperateTable.setStatus('current')
if mibBuilder.loadTexts: hh3cCfgOperateTable.setDescription('A table of config-operation requests.')
hh3cCfgOperateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 4, 1, 2, 4, 1), ).setIndexNames((0, "HH3C-CONFIG-MAN-MIB", "hh3cCfgOperateIndex"))
if mibBuilder.loadTexts: hh3cCfgOperateEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cCfgOperateEntry.setDescription('An operate request entry.')
hh3cCfgOperateIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 4, 1, 2, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: hh3cCfgOperateIndex.setStatus('current')
if mibBuilder.loadTexts: hh3cCfgOperateIndex.setDescription('The unique index value of a row in this table.')
hh3cCfgOperateType = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 4, 1, 2, 4, 1, 2), ConfigOperationType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cCfgOperateType.setStatus('current')
if mibBuilder.loadTexts: hh3cCfgOperateType.setDescription('Specify the type of operation on configuration.')
hh3cCfgOperateProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 4, 1, 2, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("ftp", 1), ("tftp", 2), ("clusterftp", 3), ("clustertftp", 4)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cCfgOperateProtocol.setStatus('current')
if mibBuilder.loadTexts: hh3cCfgOperateProtocol.setDescription("If the value of hh3cCfgOperateType is running2Net,net2Running,net2Startup or startup2net, this node specify the protocol to be used for file transfer . The default protocol is ftp if no protocol is specified. And for other value of hh3cCfgOperateType , this object may be ignored by the implementation. when clusterftp or clustertftp is selected, the hh3cCfgOperateServerAddress needn't be set, the server address can be acquired automatically, the value of hh3cCfgOperateServerAddress is uncertain during operation. both member switch and commander switch can use them if they support HGMP v2. ")
hh3cCfgOperateFileName = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 4, 1, 2, 4, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 128))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cCfgOperateFileName.setStatus('current')
if mibBuilder.loadTexts: hh3cCfgOperateFileName.setDescription('When the object of hh3cCfgOperateType has the value of net2Startup, net2running or running2Net,the value must be specified. The file name may include the path if applicable. If the value of hh3cCfgOperateType is net2Startup or net2running, this node specify the source file name of transfers.If the value of hh3cCfgOperateType is running2Net , this node specify the destination file name of transfers. When hh3cCfgOperateType has the value of startup2net,the object may not be created instead of using the file name of startup configuration file.')
hh3cCfgOperateServerAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 4, 1, 2, 4, 1, 5), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cCfgOperateServerAddress.setStatus('deprecated')
if mibBuilder.loadTexts: hh3cCfgOperateServerAddress.setDescription('When the operation type is running2Net,net2Running,net2Startup or startup2net , the ip address of the ftp/tftp server from/to which to download/upload must be specified. Values of 0.0.0.0 or FF.FF.FF.FF are not permitted. This object is replaced by hh3cCfgOperateSrvAddrRev for it only support IPv4.')
hh3cCfgOperateUserName = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 4, 1, 2, 4, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cCfgOperateUserName.setStatus('current')
if mibBuilder.loadTexts: hh3cCfgOperateUserName.setDescription('When the operation type is running2Net,net2Running,net2Startup or startup2net , the user name for the ftp server from/to which to download/upload should be specified. The object must be created if hh3cCfgOperateProtocol has the value of ftp. ')
hh3cCfgOperateUserPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 4, 1, 2, 4, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cCfgOperateUserPassword.setStatus('current')
if mibBuilder.loadTexts: hh3cCfgOperateUserPassword.setDescription('When the operation type is running2Net,net2Running,net2Startup or startup2net , the user password for the ftp server from/to which to download/upload should be specified. The object must be created if hh3cCfgOperateProtocol has the value of ftp. ')
hh3cCfgOperateEndNotificationSwitch = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 4, 1, 2, 4, 1, 8), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cCfgOperateEndNotificationSwitch.setStatus('current')
if mibBuilder.loadTexts: hh3cCfgOperateEndNotificationSwitch.setDescription('Specifies whether or not a notification should be issued on the completion of the operation.')
hh3cCfgOperateRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 4, 1, 2, 4, 1, 9), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cCfgOperateRowStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cCfgOperateRowStatus.setDescription("The status of this table entry. When the status is active all the object's value in the entry is not allowed to modified.")
hh3cCfgOperateServerPort = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 4, 1, 2, 4, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cCfgOperateServerPort.setStatus('current')
if mibBuilder.loadTexts: hh3cCfgOperateServerPort.setDescription('When the operation type is running2Net, net2Running, net2Startup or startup2Net, this node is used for specifying the remote port number. If the value is 0 or not specified, the known port number will be used.')
hh3cCfgOperateSrvAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 4, 1, 2, 4, 1, 11), InetAddressType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cCfgOperateSrvAddrType.setStatus('current')
if mibBuilder.loadTexts: hh3cCfgOperateSrvAddrType.setDescription('The type of IP address for hh3cCfgOperateSrvAddrRev.')
hh3cCfgOperateSrvAddrRev = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 4, 1, 2, 4, 1, 12), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cCfgOperateSrvAddrRev.setStatus('current')
if mibBuilder.loadTexts: hh3cCfgOperateSrvAddrRev.setDescription('When the operation type is running2Net,net2Running,net2Startup or startup2net , the ip address of the ftp/tftp server from/to which to download/upload must be specified.')
hh3cCfgOperateSrvVPNName = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 4, 1, 2, 4, 1, 13), DisplayString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cCfgOperateSrvVPNName.setStatus('current')
if mibBuilder.loadTexts: hh3cCfgOperateSrvVPNName.setDescription('The VPN instance of this operation uses.')
hh3cCfgOperateResultTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 4, 1, 2, 5), )
if mibBuilder.loadTexts: hh3cCfgOperateResultTable.setStatus('current')
if mibBuilder.loadTexts: hh3cCfgOperateResultTable.setDescription('A table of config-operation requests result.')
hh3cCfgOperateResultEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 4, 1, 2, 5, 1), ).setIndexNames((0, "HH3C-CONFIG-MAN-MIB", "hh3cCfgOperateResultIndex"))
if mibBuilder.loadTexts: hh3cCfgOperateResultEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cCfgOperateResultEntry.setDescription('The result entries of configuration operation requests.')
hh3cCfgOperateResultIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 4, 1, 2, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: hh3cCfgOperateResultIndex.setStatus('current')
if mibBuilder.loadTexts: hh3cCfgOperateResultIndex.setDescription('The index of Table, which is an incremental integer. The maximum value of the node is 2147483647. The agent should wrap the value to 1 and flush all the existing entries when the maximum value is reached.')
hh3cCfgOperateResultOptIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 4, 1, 2, 5, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cCfgOperateResultOptIndex.setStatus('current')
if mibBuilder.loadTexts: hh3cCfgOperateResultOptIndex.setDescription('The operation index in the hh3cCfgOperateTable.')
hh3cCfgOperateResultOpType = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 4, 1, 2, 5, 1, 3), ConfigOperationType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cCfgOperateResultOpType.setStatus('current')
if mibBuilder.loadTexts: hh3cCfgOperateResultOpType.setDescription('The operation type in the hh3cCfgOperateTable.')
hh3cCfgOperateState = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 4, 1, 2, 5, 1, 4), ConfigOperationStateType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cCfgOperateState.setStatus('current')
if mibBuilder.loadTexts: hh3cCfgOperateState.setDescription('The operation state type in the hh3cCfgOperateTable.')
hh3cCfgOperateTime = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 4, 1, 2, 5, 1, 5), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cCfgOperateTime.setStatus('current')
if mibBuilder.loadTexts: hh3cCfgOperateTime.setDescription('Record the time taken for the operation. This object will be like a stopwatch, starting when the operation starts, and stopping when the operation completes.')
hh3cCfgOperateEndTime = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 4, 1, 2, 5, 1, 6), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cCfgOperateEndTime.setStatus('current')
if mibBuilder.loadTexts: hh3cCfgOperateEndTime.setDescription('The value of sysUpTime when the configuration operation is finished.')
hh3cCfgOperFailReason = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 4, 1, 2, 5, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cCfgOperFailReason.setStatus('current')
if mibBuilder.loadTexts: hh3cCfgOperFailReason.setDescription('The failure reasons of configuration operation.')
hh3cCfgExecuteOperate = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 4, 1, 2, 6))
hh3cCfgExecuteOperateResultEntryLimit = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 4, 1, 2, 6, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 20)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cCfgExecuteOperateResultEntryLimit.setStatus('current')
if mibBuilder.loadTexts: hh3cCfgExecuteOperateResultEntryLimit.setDescription('The maximum number of ConfigOperationType entries that may be held in hh3cCfgExecuteResultTable. A particular setting does not guarantee that much data can be held.')
hh3cCfgExecuteResultTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 4, 1, 2, 6, 2), )
if mibBuilder.loadTexts: hh3cCfgExecuteResultTable.setStatus('current')
if mibBuilder.loadTexts: hh3cCfgExecuteResultTable.setDescription('A table of configuration execute result.')
hh3cCfgExecuteResultEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 4, 1, 2, 6, 2, 1), ).setIndexNames((0, "HH3C-CONFIG-MAN-MIB", "hh3cCfgExecuteResultIndex"))
if mibBuilder.loadTexts: hh3cCfgExecuteResultEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cCfgExecuteResultEntry.setDescription('The result entries of configuration execute operation.')
hh3cCfgExecuteResultIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 4, 1, 2, 6, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: hh3cCfgExecuteResultIndex.setStatus('current')
if mibBuilder.loadTexts: hh3cCfgExecuteResultIndex.setDescription('The index of Table, which is an incremental integer. The maximum value of the node is 2147483647. The agent should wrap the value to 1 and flush all the existing entries when the maximum value is reached.')
hh3cCfgExecuteResultOptIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 4, 1, 2, 6, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cCfgExecuteResultOptIndex.setStatus('current')
if mibBuilder.loadTexts: hh3cCfgExecuteResultOptIndex.setDescription('The configuration execute operation index in the hh3cCfgExecuteResultTable.')
hh3cCfgExecuteResultOpType = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 4, 1, 2, 6, 2, 1, 3), ConfigOperationType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cCfgExecuteResultOpType.setStatus('current')
if mibBuilder.loadTexts: hh3cCfgExecuteResultOpType.setDescription('The operation type in the hh3cCfgExecuteResultTable.')
hh3cCfgExecuteState = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 4, 1, 2, 6, 2, 1, 4), ConfigOperationStateType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cCfgExecuteState.setStatus('current')
if mibBuilder.loadTexts: hh3cCfgExecuteState.setDescription('Record the status of the specified operation.')
hh3cCfgExecuteTime = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 4, 1, 2, 6, 2, 1, 5), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cCfgExecuteTime.setStatus('current')
if mibBuilder.loadTexts: hh3cCfgExecuteTime.setDescription('Record the time of the execution starts.')
hh3cCfgExecuteEndTime = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 4, 1, 2, 6, 2, 1, 6), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cCfgExecuteEndTime.setStatus('current')
if mibBuilder.loadTexts: hh3cCfgExecuteEndTime.setDescription('Record the time of the execution is finished.')
hh3cCfgReset = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 4, 1, 2, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cCfgReset.setStatus('current')
if mibBuilder.loadTexts: hh3cCfgReset.setDescription('Reboot the device with the default configuration.')
hh3cCfgReset2 = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 4, 1, 2, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("normal", 0), ("reset", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cCfgReset2.setStatus('current')
if mibBuilder.loadTexts: hh3cCfgReset2.setDescription("normal:do nothing. reset :reboot the device with the default configuration. 'normal' will be returned when getting. This node differs from hh3cCfgReset in value.")
hh3cConfigManNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 4, 2))
hh3cCfgManEventlog = NotificationType((1, 3, 6, 1, 4, 1, 25506, 2, 4, 2, 1)).setObjects(("HH3C-CONFIG-MAN-MIB", "hh3cCfgLogSrcCmd"), ("HH3C-CONFIG-MAN-MIB", "hh3cCfgLogSrcData"), ("HH3C-CONFIG-MAN-MIB", "hh3cCfgLogDesData"))
if mibBuilder.loadTexts: hh3cCfgManEventlog.setStatus('current')
if mibBuilder.loadTexts: hh3cCfgManEventlog.setDescription("The object calculates the checksum on the current config per 10 minutes and even if it is different from the saved config but if a trap has been sent with the same checksum then don't send again until the checksum is different.")
hh3cCfgOperateCompletion = NotificationType((1, 3, 6, 1, 4, 1, 25506, 2, 4, 2, 2)).setObjects(("HH3C-CONFIG-MAN-MIB", "hh3cCfgOperateType"), ("HH3C-CONFIG-MAN-MIB", "hh3cCfgOperateTime"), ("HH3C-CONFIG-MAN-MIB", "hh3cCfgOperateState"), ("HH3C-CONFIG-MAN-MIB", "hh3cCfgOperateEndTime"), ("HH3C-CONFIG-MAN-MIB", "hh3cCfgOperFailReason"))
if mibBuilder.loadTexts: hh3cCfgOperateCompletion.setStatus('current')
if mibBuilder.loadTexts: hh3cCfgOperateCompletion.setDescription('When create hh3cCfgOperateTable successfully, a notification may be generated.')
hh3cCfgInvalidConfigFile = NotificationType((1, 3, 6, 1, 4, 1, 25506, 2, 4, 2, 3)).setObjects(("HH3C-CONFIG-MAN-MIB", "hh3cCfgOperateType"), ("HH3C-CONFIG-MAN-MIB", "hh3cCfgOperateFileName"), ("HH3C-CONFIG-MAN-MIB", "hh3cCfgFirstTrapTime"))
if mibBuilder.loadTexts: hh3cCfgInvalidConfigFile.setStatus('current')
if mibBuilder.loadTexts: hh3cCfgInvalidConfigFile.setDescription('When the configuration file is invalid, this notification will be generated.')
hh3cConfigManConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 4, 3))
hh3cConfigManCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 4, 3, 1))
hh3cConfigManCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 25506, 2, 4, 3, 1, 1)).setObjects(("HH3C-CONFIG-MAN-MIB", "hh3cCfgManLogGroup"), ("HH3C-CONFIG-MAN-MIB", "hh3cCfgOperateGroup"), ("HH3C-CONFIG-MAN-MIB", "hh3cCfgManNotificationGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hh3cConfigManCompliance = hh3cConfigManCompliance.setStatus('current')
if mibBuilder.loadTexts: hh3cConfigManCompliance.setDescription('The statement of compliance for those implementing the configuration management MIB.')
hh3cConfigManGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 4, 3, 2))
hh3cCfgManLogGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 25506, 2, 4, 3, 2, 1)).setObjects(("HH3C-CONFIG-MAN-MIB", "hh3cCfgRunModifiedLast"), ("HH3C-CONFIG-MAN-MIB", "hh3cCfgRunSavedLast"), ("HH3C-CONFIG-MAN-MIB", "hh3cCfgStartModifiedLast"), ("HH3C-CONFIG-MAN-MIB", "hh3cCfgLogLimitedEntries"), ("HH3C-CONFIG-MAN-MIB", "hh3cCfgLogDeletedEntries"), ("HH3C-CONFIG-MAN-MIB", "hh3cCfgLogTime"), ("HH3C-CONFIG-MAN-MIB", "hh3cCfgLogSrcCmd"), ("HH3C-CONFIG-MAN-MIB", "hh3cCfgLogTerminalType"), ("HH3C-CONFIG-MAN-MIB", "hh3cCfgLogTerminalNum"), ("HH3C-CONFIG-MAN-MIB", "hh3cCfgLogTerminalUser"), ("HH3C-CONFIG-MAN-MIB", "hh3cCfgLogTerminalLocation"), ("HH3C-CONFIG-MAN-MIB", "hh3cCfgLogCmdSrcAddress"), ("HH3C-CONFIG-MAN-MIB", "hh3cCfgLogVirHost"), ("HH3C-CONFIG-MAN-MIB", "hh3cCfgLogServerAddress"), ("HH3C-CONFIG-MAN-MIB", "hh3cCfgLogFile"), ("HH3C-CONFIG-MAN-MIB", "hh3cCfgLogUserName"), ("HH3C-CONFIG-MAN-MIB", "hh3cCfgLogWantBackup"), ("HH3C-CONFIG-MAN-MIB", "hh3cCfgLogSrcData"), ("HH3C-CONFIG-MAN-MIB", "hh3cCfgLogDesData"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hh3cCfgManLogGroup = hh3cCfgManLogGroup.setStatus('current')
if mibBuilder.loadTexts: hh3cCfgManLogGroup.setDescription('A collection of objects configuration log group.')
hh3cCfgOperateGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 25506, 2, 4, 3, 2, 2)).setObjects(("HH3C-CONFIG-MAN-MIB", "hh3cCfgOperateGlobalEntryLimit"), ("HH3C-CONFIG-MAN-MIB", "hh3cCfgOperateEntryAgeOutTime"), ("HH3C-CONFIG-MAN-MIB", "hh3cCfgOperateType"), ("HH3C-CONFIG-MAN-MIB", "hh3cCfgOperateProtocol"), ("HH3C-CONFIG-MAN-MIB", "hh3cCfgOperateFileName"), ("HH3C-CONFIG-MAN-MIB", "hh3cCfgOperateServerAddress"), ("HH3C-CONFIG-MAN-MIB", "hh3cCfgOperateUserName"), ("HH3C-CONFIG-MAN-MIB", "hh3cCfgOperateUserPassword"), ("HH3C-CONFIG-MAN-MIB", "hh3cCfgOperateTime"), ("HH3C-CONFIG-MAN-MIB", "hh3cCfgOperateEndNotificationSwitch"), ("HH3C-CONFIG-MAN-MIB", "hh3cCfgOperateResultGlobalEntryLimit"), ("HH3C-CONFIG-MAN-MIB", "hh3cCfgOperateState"), ("HH3C-CONFIG-MAN-MIB", "hh3cCfgOperateRowStatus"), ("HH3C-CONFIG-MAN-MIB", "hh3cCfgOperateResultOptIndex"), ("HH3C-CONFIG-MAN-MIB", "hh3cCfgOperateResultOpType"), ("HH3C-CONFIG-MAN-MIB", "hh3cCfgOperateEndTime"), ("HH3C-CONFIG-MAN-MIB", "hh3cCfgOperFailReason"), ("HH3C-CONFIG-MAN-MIB", "hh3cCfgOperateServerPort"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hh3cCfgOperateGroup = hh3cCfgOperateGroup.setStatus('current')
if mibBuilder.loadTexts: hh3cCfgOperateGroup.setDescription('A group of configuration operation.')
hh3cCfgManNotificationGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 25506, 2, 4, 3, 2, 3)).setObjects(("HH3C-CONFIG-MAN-MIB", "hh3cCfgManEventlog"), ("HH3C-CONFIG-MAN-MIB", "hh3cCfgOperateCompletion"), ("HH3C-CONFIG-MAN-MIB", "hh3cCfgInvalidConfigFile"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hh3cCfgManNotificationGroup = hh3cCfgManNotificationGroup.setStatus('current')
if mibBuilder.loadTexts: hh3cCfgManNotificationGroup.setDescription('Collection of notification objects.')
mibBuilder.exportSymbols("HH3C-CONFIG-MAN-MIB", hh3cCfgExecuteEndTime=hh3cCfgExecuteEndTime, hh3cCfgOperateGlobalEntryLimit=hh3cCfgOperateGlobalEntryLimit, hh3cCfgLogEntry=hh3cCfgLogEntry, hh3cCfgOperate=hh3cCfgOperate, hh3cCfgExecuteOperateResultEntryLimit=hh3cCfgExecuteOperateResultEntryLimit, hh3cCfgLogIndex=hh3cCfgLogIndex, hh3cCfgManEventlog=hh3cCfgManEventlog, hh3cCfgOperateProtocol=hh3cCfgOperateProtocol, hh3cCfgExecuteState=hh3cCfgExecuteState, hh3cCfgOperateCompletion=hh3cCfgOperateCompletion, hh3cCfgOperateResultEntry=hh3cCfgOperateResultEntry, hh3cCfgManLogGroup=hh3cCfgManLogGroup, hh3cCfgOperateSrvAddrRev=hh3cCfgOperateSrvAddrRev, PYSNMP_MODULE_ID=hh3cConfig, hh3cCfgOperateFileName=hh3cCfgOperateFileName, hh3cCfgOperateUserPassword=hh3cCfgOperateUserPassword, hh3cCfgLogTime=hh3cCfgLogTime, hh3cCfgOperateTable=hh3cCfgOperateTable, hh3cCfgLogTerminalType=hh3cCfgLogTerminalType, hh3cCfgOperateState=hh3cCfgOperateState, hh3cCfgOperateResultOptIndex=hh3cCfgOperateResultOptIndex, hh3cCfgLogServerAddrVPNName=hh3cCfgLogServerAddrVPNName, hh3cCfgLog=hh3cCfgLog, hh3cCfgLogLimitedEntries=hh3cCfgLogLimitedEntries, hh3cCfgOperateGroup=hh3cCfgOperateGroup, hh3cCfgStartModifiedLast=hh3cCfgStartModifiedLast, hh3cCfgInvalidConfigFile=hh3cCfgInvalidConfigFile, hh3cConfigManConformance=hh3cConfigManConformance, hh3cCfgOperateResultOpType=hh3cCfgOperateResultOpType, hh3cCfgLogVirHost=hh3cCfgLogVirHost, ConfigOperationType=ConfigOperationType, hh3cCfgLogServerAddress=hh3cCfgLogServerAddress, hh3cCfgLogTerminalNum=hh3cCfgLogTerminalNum, hh3cCfgOperateResultGlobalEntryLimit=hh3cCfgOperateResultGlobalEntryLimit, hh3cCfgExecuteResultIndex=hh3cCfgExecuteResultIndex, hh3cCfgExecuteResultOpType=hh3cCfgExecuteResultOpType, hh3cCfgOperateUserName=hh3cCfgOperateUserName, hh3cCfgOperateResultTable=hh3cCfgOperateResultTable, hh3cCfgOperateSrvAddrType=hh3cCfgOperateSrvAddrType, hh3cCfgOperateEndNotificationSwitch=hh3cCfgOperateEndNotificationSwitch, hh3cCfgRunModifiedLast=hh3cCfgRunModifiedLast, hh3cConfigManNotifications=hh3cConfigManNotifications, hh3cCfgFirstTrapTime=hh3cCfgFirstTrapTime, hh3cCfgOperateEntry=hh3cCfgOperateEntry, hh3cConfigManObjects=hh3cConfigManObjects, hh3cCfgLogCmdSrcAddrType=hh3cCfgLogCmdSrcAddrType, hh3cCfgLogTerminalUser=hh3cCfgLogTerminalUser, hh3cCfgOperateEntryAgeOutTime=hh3cCfgOperateEntryAgeOutTime, hh3cCfgLogTerminalLocation=hh3cCfgLogTerminalLocation, hh3cCfgOperateType=hh3cCfgOperateType, hh3cCfgExecuteResultOptIndex=hh3cCfgExecuteResultOptIndex, hh3cCfgOperateEndTime=hh3cCfgOperateEndTime, hh3cCfgReset2=hh3cCfgReset2, hh3cCfgLogSrcData=hh3cCfgLogSrcData, ConfigOperationStateType=ConfigOperationStateType, hh3cCfgLogDeletedEntries=hh3cCfgLogDeletedEntries, hh3cCfgOperateServerPort=hh3cCfgOperateServerPort, hh3cCfgLogFile=hh3cCfgLogFile, hh3cCfgExecuteOperate=hh3cCfgExecuteOperate, hh3cCfgLogSrcCmd=hh3cCfgLogSrcCmd, hh3cCfgExecuteTime=hh3cCfgExecuteTime, hh3cCfgLogServerAddrType=hh3cCfgLogServerAddrType, hh3cCfgOperateSrvVPNName=hh3cCfgOperateSrvVPNName, hh3cCfgReset=hh3cCfgReset, hh3cCfgLogCmdSrcAddrVPNName=hh3cCfgLogCmdSrcAddrVPNName, hh3cConfigManGroups=hh3cConfigManGroups, hh3cCfgLogCmdSrcAddress=hh3cCfgLogCmdSrcAddress, hh3cConfigManCompliances=hh3cConfigManCompliances, hh3cConfigManCompliance=hh3cConfigManCompliance, hh3cCfgExecuteResultEntry=hh3cCfgExecuteResultEntry, hh3cCfgOperateServerAddress=hh3cCfgOperateServerAddress, hh3cCfgLogDesData=hh3cCfgLogDesData, hh3cCfgLogWantBackup=hh3cCfgLogWantBackup, hh3cCfgRunSavedLast=hh3cCfgRunSavedLast, hh3cCfgOperateIndex=hh3cCfgOperateIndex, hh3cCfgExecuteResultTable=hh3cCfgExecuteResultTable, hh3cCfgOperateRowStatus=hh3cCfgOperateRowStatus, hh3cCfgManNotificationGroup=hh3cCfgManNotificationGroup, hh3cCfgOperateTime=hh3cCfgOperateTime, hh3cCfgLogServerAddrRev=hh3cCfgLogServerAddrRev, hh3cCfgOperateResultIndex=hh3cCfgOperateResultIndex, hh3cCfgLogTable=hh3cCfgLogTable, hh3cConfig=hh3cConfig, hh3cCfgLogCmdSrcAddrRev=hh3cCfgLogCmdSrcAddrRev, hh3cCfgOperFailReason=hh3cCfgOperFailReason, hh3cCfgLogUserName=hh3cCfgLogUserName)

#
# PySNMP MIB module TIGER (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/TIGER
# Produced by pysmi-0.3.4 at Wed May  1 15:16:43 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueSizeConstraint, ConstraintsIntersection, ValueRangeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsIntersection", "ValueRangeConstraint", "ConstraintsUnion")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Counter32, NotificationType, enterprises, Integer32, IpAddress, ModuleIdentity, Unsigned32, iso, ObjectIdentity, MibIdentifier, Gauge32, Counter64, Bits, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "Counter32", "NotificationType", "enterprises", "Integer32", "IpAddress", "ModuleIdentity", "Unsigned32", "iso", "ObjectIdentity", "MibIdentifier", "Gauge32", "Counter64", "Bits", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks")
DisplayString, RowStatus, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "RowStatus", "TextualConvention")
ngcan = MibIdentifier((1, 3, 6, 1, 4, 1, 1978))
tiger = MibIdentifier((1, 3, 6, 1, 4, 1, 1978, 2))
generalTiger = MibIdentifier((1, 3, 6, 1, 4, 1, 1978, 2, 1))
ifTStack = MibIdentifier((1, 3, 6, 1, 4, 1, 1978, 2, 1, 1))
tsystem = MibIdentifier((1, 3, 6, 1, 4, 1, 1978, 2, 1, 2))
buffers = MibIdentifier((1, 3, 6, 1, 4, 1, 1978, 2, 1, 3))
generalTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 1978, 2, 1, 4))
autif = MibIdentifier((1, 3, 6, 1, 4, 1, 1978, 2, 1, 5))
apath = MibIdentifier((1, 3, 6, 1, 4, 1, 1978, 2, 1, 6))
svcmsg = MibIdentifier((1, 3, 6, 1, 4, 1, 1978, 2, 1, 7))
bootp = MibIdentifier((1, 3, 6, 1, 4, 1, 1978, 2, 1, 8))
mount = MibIdentifier((1, 3, 6, 1, 4, 1, 1978, 2, 1, 9))
dnsRes = MibIdentifier((1, 3, 6, 1, 4, 1, 1978, 2, 1, 10))
vt = MibIdentifier((1, 3, 6, 1, 4, 1, 1978, 2, 1, 11))
class NonNegativeInteger(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 2147483647)

class InterfaceIndex(Integer32):
    pass

class TigerDateAndTime(DisplayString):
    subtypeSpec = DisplayString.subtypeSpec + ConstraintsUnion(ValueSizeConstraint(15, 15), ValueSizeConstraint(20, 20), )
ifTStackTable = MibTable((1, 3, 6, 1, 4, 1, 1978, 2, 1, 1, 1), )
if mibBuilder.loadTexts: ifTStackTable.setStatus('mandatory')
if mibBuilder.loadTexts: ifTStackTable.setDescription("The table containing information on the relationships between the multiple sub-layers of network interfaces. In particular, it contains information on which sub- layers run 'on top of' which other sub-layers. Each sub-layer corresponds to a conceptual row in the ifTable.")
ifTStackEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1978, 2, 1, 1, 1, 1), ).setIndexNames((0, "TIGER", "ifTStackIndex"))
if mibBuilder.loadTexts: ifTStackEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ifTStackEntry.setDescription("Information on a particular relationship between two sub-layers, specifying that one sub-layer runs on 'top' of the other sub-layer. Each sub-layer corresponds to a conceptual row in the ifTable.")
ifTStackIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 1, 1, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifTStackIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ifTStackIndex.setDescription("A unique value for each interface. Its value ranges between 1 and the value of ifNumber. The value for each interface must remain constant at least from one re-initialization of the entity's network management system to the next re- initialization.")
ifTStackHigherLayer = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 1, 1, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifTStackHigherLayer.setStatus('mandatory')
if mibBuilder.loadTexts: ifTStackHigherLayer.setDescription("The value of ifIndex corresponding to the higher sub-layer of the relationship, i.e., the sub-layer which runs on 'top' of the sub-layer identified by the corresponding instance of ifTStackLowerLayer. If there is no higher sub-layer (below the internetwork layer), then this object has the value 0.")
ifTStackLowerLayer = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 1, 1, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifTStackLowerLayer.setStatus('mandatory')
if mibBuilder.loadTexts: ifTStackLowerLayer.setDescription("The value of ifIndex corresponding to the lower sub- layer of the relationship, i.e., the sub-layer which runs 'below' the sub-layer identified by the corresponding instance of ifTStackHigherLayer. If there is no lower sub-layer, then this object has the value 0.")
ifTStackStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 1, 1, 1, 4), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifTStackStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ifTStackStatus.setDescription("The status of the relationship between two sub-layers. Changing the value of this object from 'active' to 'notInService' or 'destroy' will likely have consequences up and down the interface stack. Thus, write access to this object is likely to be inappropriate for some types of interfaces, and many implementations will choose not to support write- access for any type of interface.")
tigSystemDate = MibScalar((1, 3, 6, 1, 4, 1, 1978, 2, 1, 2, 1), TigerDateAndTime()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tigSystemDate.setStatus('mandatory')
if mibBuilder.loadTexts: tigSystemDate.setDescription("The host's notion of the local date and time of day.")
tigSystemExceptionEcho = MibScalar((1, 3, 6, 1, 4, 1, 1978, 2, 1, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tigSystemExceptionEcho.setStatus('mandatory')
if mibBuilder.loadTexts: tigSystemExceptionEcho.setDescription('When enabled it allows the system to send copies of any exceptions to the console port. When disabled, exceptions are not sent to the console port.')
tigSystemExceptionLogging = MibScalar((1, 3, 6, 1, 4, 1, 1978, 2, 1, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tigSystemExceptionLogging.setStatus('mandatory')
if mibBuilder.loadTexts: tigSystemExceptionLogging.setDescription('When enabled, the system will copy exceptions into its log file on the ram file system (/ramdisk/system.log). When disabled, exceptions are not logged into the file.')
tigSystemExceptionSaveLog = MibScalar((1, 3, 6, 1, 4, 1, 1978, 2, 1, 2, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tigSystemExceptionSaveLog.setStatus('mandatory')
if mibBuilder.loadTexts: tigSystemExceptionSaveLog.setDescription("When enabled, any FATAL exception will cause the file '/ramdisk/system.log' to be save onto the flash file system as '/flash/error.log'. When disabled, all logging information saved in '/ramdisk/system.log' is lost.")
tigPCMCIATable = MibTable((1, 3, 6, 1, 4, 1, 1978, 2, 1, 2, 5), )
if mibBuilder.loadTexts: tigPCMCIATable.setStatus('mandatory')
if mibBuilder.loadTexts: tigPCMCIATable.setDescription('An entry shall be placed in the table for each PCMCIA slot that is in use.')
tigPCMCIAEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1978, 2, 1, 2, 5, 1), ).setIndexNames((0, "TIGER", "tigPCMCIASlot"))
if mibBuilder.loadTexts: tigPCMCIAEntry.setStatus('mandatory')
if mibBuilder.loadTexts: tigPCMCIAEntry.setDescription('A (conceptual) entry for one logical token ring port on the host.')
tigPCMCIASlot = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 2, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tigPCMCIASlot.setStatus('mandatory')
if mibBuilder.loadTexts: tigPCMCIASlot.setDescription('The PCMCIA slot identified by this table entry.')
tigPCMCIAIf = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 2, 5, 1, 2), InterfaceIndex()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tigPCMCIAIf.setStatus('mandatory')
if mibBuilder.loadTexts: tigPCMCIAIf.setDescription('The Interface index that is bound to this PCMCIA slot. In the current Tiger environment, slot 0 uses ifIndex 7 and slot 1 uses ifIndex 8.')
tigTokenRingSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 2, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("four", 1), ("sixteen", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tigTokenRingSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: tigTokenRingSpeed.setDescription('Defines the Token Ring speed used on this interface (in Mbit/sec).')
tigPCMCIAType = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 2, 5, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("token-ring", 1), ("modem", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tigPCMCIAType.setStatus('mandatory')
if mibBuilder.loadTexts: tigPCMCIAType.setDescription('Specifies the type of cards that is configured in the slot: token-ring - a Madge Token Ring card modem - a modem card')
tigConfigFile = MibScalar((1, 3, 6, 1, 4, 1, 1978, 2, 1, 2, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tigConfigFile.setStatus('mandatory')
if mibBuilder.loadTexts: tigConfigFile.setDescription('This field contains the file specification for the configuration file used at boot time.')
tigRestartReason = MibScalar((1, 3, 6, 1, 4, 1, 1978, 2, 1, 2, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("power", 1), ("reset-button", 2), ("watchdog", 3), ("config-fail", 4), ("other", 5), ("double-bus-fault", 6), ("fatal-exception", 7), ("reboot-command", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tigRestartReason.setStatus('mandatory')
if mibBuilder.loadTexts: tigRestartReason.setDescription("Informs the NMS why the Tiger most recently restarted: power - due to a power failure reset-button - someone pushed the reset button watchdog - the internal watchdog timer forced a reset config-fail - there was a catastrophic failure in the configuration file causing a system reset. ('tigConfigFile' informs you which config file is currently being used) other - someother unknown reason. (these should never occur) double-bus-fault - a invalid address was being reference while the exception handler for a bus-fault exception (an invalid address was referenced) was being executed. fatal-exception - a fatal software exception occured inside Tiger reboot-command - a user issued a 'reboot' command on a console")
tigClearStats = MibScalar((1, 3, 6, 1, 4, 1, 1978, 2, 1, 2, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("clear", 1), ("cleared", 2), ("cleared-confirmed", 3))).clone('cleared')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tigClearStats.setStatus('mandatory')
if mibBuilder.loadTexts: tigClearStats.setDescription("When set to 'clear' all of TIGERs statistics are cleared to zero. It will affect each of the ports statistics herarcially, and also AUTIF statistics. When read, this object should always return 'cleared' indicating that the clear operation took place. Should the operation be defered, the value will remain as 'clear' until such time as: 1/ all of the statistics have actually been zeroed, and 2/ tigClearStatsTime has been updated with the correct time. Should an NMS read the object and receive a 'cleared' indication, the SNMP agent will set this object to 'cleared-confirmed'. This aids the NMS in determining whether or not the agent successfully received subsequent clear request. Normal operation would be: NMS Agent set 'clear' --> set to 'clear,' perform clearing . read --> . 'clear' <-- . clearing complete, set to 'cleared' . read --> . 'cleared' <-- set to 'cleared-confirmed' . read --> . 'cleared-confirmed' <-- . Rules: 1/ NMS must read 'cleared-confirmed' BEFORE attempting to set 'clear'. 2/ After setting 'clear' the NMS must read 'cleared'. then the NMS must read 'cleared-confirmed'. In this manner, if a 'clear' command was missed by the agent, the variable will still be set to either 'cleared' or 'cleared-confirmed'.")
tigClearStatsTime = MibScalar((1, 3, 6, 1, 4, 1, 1978, 2, 1, 2, 9), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tigClearStatsTime.setStatus('mandatory')
if mibBuilder.loadTexts: tigClearStatsTime.setDescription('The number of ticks when the Tiger last received a tigClearStats command.')
tigCpuTrapControl = MibScalar((1, 3, 6, 1, 4, 1, 1978, 2, 1, 2, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tigCpuTrapControl.setStatus('mandatory')
if mibBuilder.loadTexts: tigCpuTrapControl.setDescription('This option allows a tigCpu trap to be sent when: a) the idle CPU time falls below 5% b) when the idle CPU times exceeds 60% only after having fallen below 5%.')
tigCpuIdleState = MibScalar((1, 3, 6, 1, 4, 1, 1978, 2, 1, 2, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("idle", 1), ("alarm", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tigCpuIdleState.setStatus('mandatory')
if mibBuilder.loadTexts: tigCpuIdleState.setDescription('This tell us if the TIGER is in its CPU idle alarm state. idle (1) - means that the CPU idle time is above 60& alarm (2) - means that the CPU idle time is below 5%.')
tigSystemSerialNum = MibScalar((1, 3, 6, 1, 4, 1, 1978, 2, 1, 2, 12), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tigSystemSerialNum.setStatus('mandatory')
if mibBuilder.loadTexts: tigSystemSerialNum.setDescription('This is used to determine the TIGERs hardware serial number. Although it is defined as a writable variable, TIGER may silently discard that information. If the serial number given does not match the actual number, an error message may be shown.')
tigDomainName = MibScalar((1, 3, 6, 1, 4, 1, 1978, 2, 1, 2, 13), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tigDomainName.setStatus('mandatory')
if mibBuilder.loadTexts: tigDomainName.setDescription('The domain name that this TIGER belongs to. This value must contain a leading and trailing dot. (You do not need to enter these when using the Tiger Configuration Tool. It will automatically add them.) To create the FQDN, concatenate sysName with this value.')
tigPoolNumEntries = MibScalar((1, 3, 6, 1, 4, 1, 1978, 2, 1, 3, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tigPoolNumEntries.setStatus('mandatory')
if mibBuilder.loadTexts: tigPoolNumEntries.setDescription('The number of: WRITE: buffer pools I want to create, READ: buffers that can be created.')
tigPoolTable = MibTable((1, 3, 6, 1, 4, 1, 1978, 2, 1, 3, 2), )
if mibBuilder.loadTexts: tigPoolTable.setStatus('mandatory')
if mibBuilder.loadTexts: tigPoolTable.setDescription("An entry shall be placed in the storage table for each buffer pool. This table is intended to be a useful diagnostic and performance monitoring tool for `out of memory' and `out of buffers' types of failures and tracking.")
tigPoolEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1978, 2, 1, 3, 2, 1), ).setIndexNames((0, "TIGER", "tigPoolIndex"))
if mibBuilder.loadTexts: tigPoolEntry.setStatus('mandatory')
if mibBuilder.loadTexts: tigPoolEntry.setDescription('A (conceptual) entry for one logical storage area on the host.')
tigPoolIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 3, 2, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tigPoolIndex.setStatus('mandatory')
if mibBuilder.loadTexts: tigPoolIndex.setDescription('A unique value for each buffer pool contained by the host. It is the MQX pool number.')
tigPoolSize = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 3, 2, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tigPoolSize.setStatus('mandatory')
if mibBuilder.loadTexts: tigPoolSize.setDescription('The number of buffers in this pool.')
tigPoolBufSize = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 3, 2, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tigPoolBufSize.setStatus('mandatory')
if mibBuilder.loadTexts: tigPoolBufSize.setDescription('The size of each buffer in bytes.')
tigPoolLowThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 3, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100)).clone(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tigPoolLowThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: tigPoolLowThreshold.setDescription('If the number of free buffers remaining in the pool drops below the low water mark (threshold) as a percentage, a trap may be generated if enabled. default: 20% UNITS: percent')
tigPoolHighThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 3, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100)).clone(50)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tigPoolHighThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: tigPoolHighThreshold.setDescription('If the Low threshold has been reached, this defines the number of buffers that must be free in the pool in order to turn off the alarm. A trap may be generated if enabled. default: 50% UNITS: percent')
tigPoolFree = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 3, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tigPoolFree.setStatus('mandatory')
if mibBuilder.loadTexts: tigPoolFree.setDescription('The number of free buffers in this pool.')
tigPoolCommandStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 3, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notInUse", 1), ("create", 2), ("created", 3), ("failed", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tigPoolCommandStatus.setStatus('mandatory')
if mibBuilder.loadTexts: tigPoolCommandStatus.setDescription("When written with a 'create' it causes the pool as defined by the other parameters to be created. As a result, of pool creation, this variable, when read will inform the management system whether the poll was successfuly 'created' or if the create 'failed'.")
tigPoolAllocationFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 3, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tigPoolAllocationFailures.setStatus('mandatory')
if mibBuilder.loadTexts: tigPoolAllocationFailures.setDescription('The number of requests for buffers from this pool that could not be honored due to insufficient buffers. It should be noted that as this object has a SYNTAX of Counter, that it does not have a defined initial value. However, it is recommended that this object be initialized to zero.')
tigPoolTrapControl = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 3, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tigPoolTrapControl.setStatus('mandatory')
if mibBuilder.loadTexts: tigPoolTrapControl.setDescription('This option allows a tigPool trap to be sent when: a) the number of buffers remaining in the pool falls below the low water mark. b) when the number of buffers remaining in the pool exceeds the high water mark (only after having fallen below the low water mark).')
tigPoolTrapStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 3, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("alarm", 1), ("recovery", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tigPoolTrapStatus.setStatus('mandatory')
if mibBuilder.loadTexts: tigPoolTrapStatus.setDescription('Informs the NMS of the reason for the tigPool trap that was received. When read asynchronously, it also indicates the last known state of this pool entry.')
tigPool = NotificationType((1, 3, 6, 1, 4, 1, 1978, 2, 1, 4) + (0,1)).setObjects(("TIGER", "tigPoolIndex"), ("TIGER", "tigPoolTrapStatus"), ("TIGER", "tigPoolFree"))
if mibBuilder.loadTexts: tigPool.setDescription("An tigPool trap signifies that the number of buffers remaining in a pool has crossed either the high or low threshold as defined by: tigPoolLowThreshold and tigPoolHighThreshold. The trap returns: 1/ Index of the pool that changed state, 2/ That pools current status: alarm or recovery, 3/ That pools current number of buffers The 'number of buffers' parameter is really only marginally useful during the 'alarm' state.")
tigRestart = NotificationType((1, 3, 6, 1, 4, 1, 1978, 2, 1, 4) + (0,2)).setObjects(("TIGER", "tigRestartReason"), ("TIGER", "tigSystemDate"))
if mibBuilder.loadTexts: tigRestart.setDescription("An tigRestartTrap signifies that the Tiger has recently restarted for the reason given by 'tigRestartReason' at the (local) time 'tigSystemDate'.")
tigIdle = NotificationType((1, 3, 6, 1, 4, 1, 1978, 2, 1, 4) + (0,3)).setObjects(("TIGER", "tigCpuIdleState"))
if mibBuilder.loadTexts: tigIdle.setDescription("An tigIdle trap signifies that the Tiger has recently changed idle state to/from idling, alarm with the current state given by 'tigCpuIdleState'. It can only be generated if 'tigCpuTrapControl' is enabled.")
autifNumEntries = MibScalar((1, 3, 6, 1, 4, 1, 1978, 2, 1, 5, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: autifNumEntries.setStatus('mandatory')
if mibBuilder.loadTexts: autifNumEntries.setDescription('The number of entries in the table.')
autifTable = MibTable((1, 3, 6, 1, 4, 1, 1978, 2, 1, 5, 2), )
if mibBuilder.loadTexts: autifTable.setStatus('mandatory')
if mibBuilder.loadTexts: autifTable.setDescription('An entry is be placed in the table for each address mapping.')
autifEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1978, 2, 1, 5, 2, 1), ).setIndexNames((0, "TIGER", "autifIndex"))
if mibBuilder.loadTexts: autifEntry.setStatus('mandatory')
if mibBuilder.loadTexts: autifEntry.setDescription('A (conceptual) entry for each address pairing between a Tiger user stream and a TCP or UDP socket/address pair. An autifEntry may support a client, a listener or both depending on the service configured.')
autifIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 5, 2, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autifIndex.setStatus('mandatory')
if mibBuilder.loadTexts: autifIndex.setDescription('A unique value for each address entry.')
autifService = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 5, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("udp", 1), ("tcp", 2), ("system-1", 3), ("continental", 4), ("dlsw", 5), ("listener", 6), ("matip", 7), ("ofep-sabre", 8), ("ofep-sabre-listener", 9)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autifService.setStatus('mandatory')
if mibBuilder.loadTexts: autifService.setDescription("Specifies the type of connection required for this address set. 'udp' implies: - UDP client - Northrop Grumman's proprietary data encapsulation format for message delimiting, using a SYN octet (16h) followed by 2 octets of user data length (big endian), followed by user data: SYN(1) len(2) user data(n) 'tcp' implies: - TCP client - Northrop Grumman's proprietary data encapsulation format for message delimiting, using a SYN octet (16h) followed by 2 octets of user data length (big endian), followed by user data: SYN(1) len(2) user data(n) 'system-1' implies: - UDP - each autif socket is mapped to a (specified) IA - each IA/socket carries an alias source IP address - port numbering: - host destination port = base = remote port - source port = base + TA (converted TA) - encapsulation format: ip header (dstip = autifRemAddress, srcip = autifAliasAddress) udp header (dstport = autifRemotePort, srcport = autifRemotePort + ta) alc data (no header, ends with EOMx) 'continental' implies: - UDP client - each autif socket is mapped to a (specified) IA - each IA/socket carries an alias source IP address - port numbering: - host destination port = base = remote port - source port = base + ta (converted TA) - encapsulation format: ip header (dstip = autifRemAddress, srcip = autifAliasAddress) udp header (dstport = autifRemotePort, srcport = autifRemotePort + ta) header (autifLNIA(2) ta) alc data (ends with EOMx) 'dlsw' implies: - TCP dlsw client(2065) + TCP dlsw listener(2065) - 1 or 2 TCP sockets supporting the flow of DLSw traffic with the defined peer (autifRemAddress). - autifAliasAddress defines this DLSw peer source ip address. - Uses RFC1795 defined message encapsulation format. - TIGER always initiates the connection 'listener' implies: - TCP listener - creates a socket with autifLocalPort defining the 'well known port' for the listener. - A conditional accept is done on all incoming connect requests to verify the remote address. If autifRemAddress is defined as: 0.0.0.0 - a call from any source address is accepted, 'non-zero' - only a call from the specified address is accepted. - Northrop Grumman's proprietary data encapsulation format for message delimiting, using a SYN octet (16h) followed by 2 octets of user data length (big endian), followed by user data: SYN(1) len(2) user data(n). 'matip' implies: - TCP Client/Server depending upon the Mode of the MATIP module - MATIP header contains 4 bytes. The first is version field and is used as as MATIP sync. The 2nd is ignored by AUTIF. The 3rd and 4th is the length of this TCP message. 'ofep-sabre' implies: - TCP Client process for SABRE OFEP Encapsulation/Protocol. - the Load Balancer header is 3 long (a version field and a 2 byte length) - the OFEP header is 4 bytes long (a version field, 2 byte length and a control field. 'ofep-sabre-listener' implies: - TCP Listener process for SABRE OFEP Encapsulation/Protocol - used ONLY for testing purposes. - the Load Balancer header is 3 long (a version field and a 2 byte length) - the OFEP header is 4 bytes long (a version field, 2 byte length and a control field.")
autifRemAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 5, 2, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autifRemAddress.setStatus('mandatory')
if mibBuilder.loadTexts: autifRemAddress.setDescription("The IP address signifying the destination device used for this entry. client operation - it defines the destination host. listener operation - 0.0.0.0 - a call from any source address is accepted, 'non-zero' - only a call from the specified address is accepted.")
autifLocalPort = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 5, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autifLocalPort.setStatus('mandatory')
if mibBuilder.loadTexts: autifLocalPort.setDescription("The local port number for this connection. This field has no meaning for a TCP client since the source port is dynamically assigned. For a TCP listener it specifies the 'well-known port' for the particular application/streams that is attached.")
autifRemotePort = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 5, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autifRemotePort.setStatus('mandatory')
if mibBuilder.loadTexts: autifRemotePort.setDescription("The remote port number for this connection. client - this is the 'well-known port' of the application. When used with an OFEP mode, this is the port of the load balancer. TCP listener - no meaning.")
autifRxBufSize = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 5, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4096)).clone(4096)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autifRxBufSize.setStatus('mandatory')
if mibBuilder.loadTexts: autifRxBufSize.setDescription('The size of the socket receive buffer represented by this entry in bytes. For UDP sockets it must be as large as the largest message to be received, because UDP delivers in a single recv() operation. For TCP sockets it may be configured to be less than the maximum message size, and the autif recieve application will reassemble in Tiger buffers. For TCP = autifTypeAMaxMsgSize / 2 For UDP = autifTypeAMaxMsgSize UNITS: bytes')
autifTxBufSize = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 5, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4096)).clone(4096)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autifTxBufSize.setStatus('mandatory')
if mibBuilder.loadTexts: autifTxBufSize.setDescription('The size of the transmit buffer represented by this entry in bytes. For UDP sockets it must be as large as the largest message to be transmitted, because UDP expects to deliver in a single send() operation. For TCP sockets it may be configured to be less than the maximum message size, and the autif transmit application will coordinate multiple send() operations from the Tiger buffers. For TCP = autifTypeAMaxMsgSize / 2 For UDP = autifTypeAMaxMsgSize UNITS: bytes')
autifSockQueueSize = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 5, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autifSockQueueSize.setStatus('mandatory')
if mibBuilder.loadTexts: autifSockQueueSize.setDescription('The size of the socket receive queue represented by this entry in buffers. For TCP this reflects flow control responsiveness in outbound traffic (streams to socket to Host). UNITS: buffers')
autifTypeAQueueSize = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 5, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autifTypeAQueueSize.setStatus('mandatory')
if mibBuilder.loadTexts: autifTypeAQueueSize.setDescription('The size of the Type A message user stream queue size represented by this entry in buffers. For TCP, this reflects flow control responsiveness for inbound traffic (Host to socket to streams). UNITS: buffers')
autifTypeAMaxMsgSize = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 5, 2, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4096)).clone(4096)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autifTypeAMaxMsgSize.setStatus('mandatory')
if mibBuilder.loadTexts: autifTypeAMaxMsgSize.setDescription('The maximum size of the message expected to flow between the sockets and streams interfaces. UNITS: bytes')
autifInOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 5, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: autifInOctets.setStatus('mandatory')
if mibBuilder.loadTexts: autifInOctets.setDescription('The total number of octets received from the streams interface, destined to the socket/Host, including header characters.')
autifInUcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 5, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: autifInUcastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: autifInUcastPkts.setDescription('The number of subnetwork-unicast packets received from the streams interface, destined to the socket/Host TCP/UDP higher-layer protocol.')
autifInNUcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 5, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: autifInNUcastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: autifInNUcastPkts.setDescription('The number of non-unicast (i.e., subnetwork- broadcast or subnetwork-multicast) packets received from the streams interface, destined to the socket/Host higher-layer protocol.')
autifInDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 5, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: autifInDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: autifInDiscards.setDescription('The number of packets received from the streams interface, destined to the socket/Host which were flused from queues and discarded because the socket went down, and the traffic was not deliverable.')
autifInErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 5, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: autifInErrors.setStatus('mandatory')
if mibBuilder.loadTexts: autifInErrors.setDescription('The number of inbound packets received from the streams interface, destined to the socket/Host that could not be sent due to errors in socket transmision, or instance routing faults.')
autifInUnknownProtos = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 5, 2, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: autifInUnknownProtos.setStatus('mandatory')
if mibBuilder.loadTexts: autifInUnknownProtos.setDescription('The number of packets received via the interface which were discarded because of an unknown or unsupported protocol. Currently not supported in Tiger.')
autifOutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 5, 2, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: autifOutOctets.setStatus('mandatory')
if mibBuilder.loadTexts: autifOutOctets.setDescription('The total number of octets from the Host/sockets interface, destined to the concerned user stream, including header characters.')
autifOutUcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 5, 2, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: autifOutUcastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: autifOutUcastPkts.setDescription('The total number of packets from the Host/sockets interface, destined to the concerned user stream.')
autifOutNUcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 5, 2, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: autifOutNUcastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: autifOutNUcastPkts.setDescription('The total number of packets from the Host/sockets interface, destined to the concerned user stream. (i.e., a subnetwork-broadcast or subnetwork-multicast) address.')
autifOutDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 5, 2, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: autifOutDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: autifOutDiscards.setDescription('The number of outbound packets from the Host/sockets interface, destined to the concerned user stream which could not be delivered for various error reasons, such as insufficient buffers, queuing errors, etc. ')
autifOutErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 5, 2, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: autifOutErrors.setStatus('mandatory')
if mibBuilder.loadTexts: autifOutErrors.setDescription('The number of outbound packets from the Host/sockets interface, destined to the concerned user stream that could not be transmitted because of errors.')
autifIA = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 5, 2, 1, 22), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autifIA.setStatus('mandatory')
if mibBuilder.loadTexts: autifIA.setDescription('This is the IA value associated with this connection. Note that the Configurator will automatically establish this value when an ALC user stream is linked to the autif instance. (The Configurator displays this value in the more human form of hex whereas it is provided here to the Tiger as correspondance code). In system-1 mode, Tiger will strip it from the data message on transmit, and add it (in correpsondance code) on reception prior to passing into the stream.')
autifAliasAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 5, 2, 1, 23), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autifAliasAddress.setStatus('mandatory')
if mibBuilder.loadTexts: autifAliasAddress.setDescription('This is another IP address to which the Tiger will respond and associate with this autif entry (on this socket). When the socket is in use with the DLSw service this IP address should be the IP address of the network peer that supports this service. Used when autifService = tcp, udp, system-1, continental, dlsw.')
autifSockPrecedence = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 5, 2, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("routine", 1), ("priority", 2), ("immediate", 3), ("flash", 4), ("flash-override", 5), ("critical", 6), ("internetwork-control", 7), ("network-control", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autifSockPrecedence.setStatus('mandatory')
if mibBuilder.loadTexts: autifSockPrecedence.setDescription('Specifies the precedence that IP traffic on this socket will be transmitted with. These values define the upper 3 bits of the Type Of Service byte in the IP header.')
autifDestAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 5, 2, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("none", 1), ("ip", 2))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autifDestAddrType.setStatus('mandatory')
if mibBuilder.loadTexts: autifDestAddrType.setDescription("This object controls whether or not the destination address is present in the outgoing data stream from a Type A user to the IP interface logic. It is only applicable for UDP type services (see autifService). To handle alternate access operation, the Destination address can be inserted by the alternate access module (see altaHostSupplementalAddr). 'none' - no additional address information is present, and the message is sent to the sockets default destination IP address. 'ip' - this indicates that the first 4 bytes of the data stream holds the IP address of the destination host. For a UDP style socket this address is used in the applications sendto() call. If the address is all zeros, then the message will be sent to the sockets default destination IP address defined in autifRemAddress. On messages sourced from the IP layer, the source IP address is pre-pended to the data stream before it is forwarded to the alternate access module and multiplexor.")
autifSockOptions = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 5, 2, 1, 26), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autifSockOptions.setStatus('mandatory')
if mibBuilder.loadTexts: autifSockOptions.setDescription('Controls which socket options are enabled. This integer is actually a bit field. With all bits off, no options are enabled. Bit 0 - TCP Keep Alive Bits 1-n - not currently defined, must be zero.')
autifLNIA = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 5, 2, 1, 27), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autifLNIA.setStatus('mandatory')
if mibBuilder.loadTexts: autifLNIA.setDescription("This parameter represents the line and IA characters for the ALC user that may be connected to this AUTIF instance. Although the LNIA is an arbitrary 16 bit hexadecimal quantity, it has various meanings: Continental Mode: - the parameter contains the LNIA characters that are substitute internal values of Line and IA for all socket transmissions to the host. On socket reception the fields are stripped, and internal values of 'line' and 'IA' are applied. OFEP Modes: - the parameter contains the actual line and IA values for the user connected to this AUTIF instance. This parameter is only used when autifService is continental or one of the OFEP modes.")
autifLBName = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 5, 2, 1, 28), OctetString().subtype(subtypeSpec=ValueSizeConstraint(256, 256)).setFixedLength(256)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autifLBName.setStatus('mandatory')
if mibBuilder.loadTexts: autifLBName.setDescription("The DNS Name of the Load Balancer. This variable is only written to if the item 'autifService' is set to either 'ofep-sabre' or 'ofep-sabre-listener'.")
autifOFEPKeepAliveTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 5, 2, 1, 29), Integer32().clone(150)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autifOFEPKeepAliveTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: autifOFEPKeepAliveTimeout.setDescription("OFEP Keepalive period (in SECONDS). OFEP Keepalive messages are generated by the OFEP processor ONLY. The Tiger will monitor the time intervals between OFEP Keepalive messages - this counter is the timeout period that will lead to recovery action by the Tiger (i.e. the reset of the TCP socket). If the timer is set to zero (0), then KeepAlive monitoring is disabled. The KeepAlive monitor is active for all terminal devices associated with this IA. This variable is only written to if the item 'autifService' is set to either 'ofep-sabre' or 'ofep-sabre-listener'.")
autifUserIdleTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 5, 2, 1, 30), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autifUserIdleTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: autifUserIdleTimeout.setDescription("This is the OFEP inactivity timer (in SECONDS). If set, the Tiger will reset the socket after 'autifUserIdleTimeout' many seconds. A value of zero (0) means that the socket is never timed out. This variable is only written to if the item 'autifService' is set to either 'ofep-sabre' or 'ofep-sabre-listener'.")
autifXlatToSocket = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 5, 2, 1, 31), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autifXlatToSocket.setStatus('mandatory')
if mibBuilder.loadTexts: autifXlatToSocket.setDescription('This is an index into the capXlatTable that is used for translating data received from the stream and being sent to the socket. Currently only used in OFEP mode.')
autifXlatFromSocket = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 5, 2, 1, 32), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autifXlatFromSocket.setStatus('mandatory')
if mibBuilder.loadTexts: autifXlatFromSocket.setDescription('This is an index into the capXlatTable that is used for translating data received from the socket and being sent to the stream. Currently only used in OFEP mode.')
autifRealToVTRoutingErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 5, 2, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: autifRealToVTRoutingErrors.setStatus('mandatory')
if mibBuilder.loadTexts: autifRealToVTRoutingErrors.setDescription('Count of the times we were unable to route from Real to Virtual TA')
autifVTToRealRoutingErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 5, 2, 1, 34), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: autifVTToRealRoutingErrors.setStatus('mandatory')
if mibBuilder.loadTexts: autifVTToRealRoutingErrors.setDescription('Count of the times we were unable to route from Virtual TA to Real.')
autifRealToVTHashDepth = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 5, 2, 1, 35), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: autifRealToVTHashDepth.setStatus('mandatory')
if mibBuilder.loadTexts: autifRealToVTHashDepth.setDescription('Count of the times we encountered maximum hash depth encountered in this direction.')
apathNumEntries = MibScalar((1, 3, 6, 1, 4, 1, 1978, 2, 1, 6, 1), NonNegativeInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apathNumEntries.setStatus('mandatory')
if mibBuilder.loadTexts: apathNumEntries.setDescription('Number of type A paths in the table.')
apathTable = MibTable((1, 3, 6, 1, 4, 1, 1978, 2, 1, 6, 2), )
if mibBuilder.loadTexts: apathTable.setStatus('mandatory')
if mibBuilder.loadTexts: apathTable.setDescription('A list of Apath table entries. The number of entries is given by the value of apathNumEntries.')
apathEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1978, 2, 1, 6, 2, 1), ).setIndexNames((0, "TIGER", "apathIndex"))
if mibBuilder.loadTexts: apathEntry.setStatus('mandatory')
if mibBuilder.loadTexts: apathEntry.setDescription('An entry containing information applicable to a particular type A path.')
apathIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 6, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apathIndex.setStatus('mandatory')
if mibBuilder.loadTexts: apathIndex.setDescription('A unique value for each Apath entry.')
apathType = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 6, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("primary", 1), ("secondary", 2), ("primary-mute", 3), ("primary-mute-xlat", 4))).clone('primary')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apathType.setStatus('mandatory')
if mibBuilder.loadTexts: apathType.setDescription("Defines the mode of operation for this Apath: Primary: We send enquiry messages. Secondary: We respond to enquiry messages. Primary-Mute: We won't send enquiry messages. The path is up on on the basis of the connected stream. Primary-Mute-Xlat: Same as Primary-Mute except it enables SABRE/PIA character set translation.")
apathIdleTimerMax = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 6, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000)).clone(30)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apathIdleTimerMax.setStatus('mandatory')
if mibBuilder.loadTexts: apathIdleTimerMax.setDescription('(1..1000 seconds) default=30 (Primary) Timeout to send an enquiry message when no data received. default=39 (Secondary) Timeout to declare the Apath down when nothing received. UNITS=seconds')
apathResponseTimerMax = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 6, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100)).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apathResponseTimerMax.setStatus('mandatory')
if mibBuilder.loadTexts: apathResponseTimerMax.setDescription('(1..100 seconds) default=3 (Primary only) Timeout to wait for a positive end user response to an enquiry message. A negative end user response will allow the timeout to occur. UNITS=seconds')
apathRetryCounterMax = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 6, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apathRetryCounterMax.setStatus('mandatory')
if mibBuilder.loadTexts: apathRetryCounterMax.setDescription(' default=3 (Primary only) Number of consecutive Response Timeouts to declare the Apath down.')
apathEndUserStatusEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 6, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apathEndUserStatusEnable.setStatus('mandatory')
if mibBuilder.loadTexts: apathEndUserStatusEnable.setDescription(' default = enabled Defines whether or not the end user status will be included in the path state. A user down status will declare Apath down.')
apathTrafficIdleTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 6, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100000)).clone(15)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apathTrafficIdleTimer.setStatus('mandatory')
if mibBuilder.loadTexts: apathTrafficIdleTimer.setDescription(" default=15 A non-zero value indicates amount of time that has to pass with no user traffic being sent before this path is declared idle. The path will only be re-connected on user traffic. If the value is zero, then no timming will occur and the path will never be automatically disconnected. This is useful for dial-up connections for 'type A' connections, but is useless for X2X traffic which won't initiate traffic unless the path is already up. UNITS: seconds")
apathConnectTimerMax = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 6, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000)).clone(30)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apathConnectTimerMax.setStatus('mandatory')
if mibBuilder.loadTexts: apathConnectTimerMax.setDescription('(1..1000 seconds) default=30 This amount of time is allowed for the underlying connection to take place, before Apath will begin polling the other end for a path connection. i.e. TimeTillDeclaredDead = apathConnectTimerMax + (apathResponseTimerMax * apathRetryCounterMax) UNITS=seconds')
apathPathUpMsg = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 6, 2, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apathPathUpMsg.setStatus('mandatory')
if mibBuilder.loadTexts: apathPathUpMsg.setDescription('This message is sent on this stream to the host when the host path status changes to UP. This option only applies when apathType is set to any of the primary options. This text is transmitted as entered without any manipulations, translations, headers or trailers.')
apathUserNumEntries = MibScalar((1, 3, 6, 1, 4, 1, 1978, 2, 1, 6, 3), NonNegativeInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apathUserNumEntries.setStatus('mandatory')
if mibBuilder.loadTexts: apathUserNumEntries.setDescription('Number of type A path users in the table.')
apathUserTable = MibTable((1, 3, 6, 1, 4, 1, 1978, 2, 1, 6, 4), )
if mibBuilder.loadTexts: apathUserTable.setStatus('mandatory')
if mibBuilder.loadTexts: apathUserTable.setDescription('A list of User table entries. The number of entries is given by the value of apathNumUserConfiged.')
apathUserEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1978, 2, 1, 6, 4, 1), ).setIndexNames((0, "TIGER", "apathUserIndex"))
if mibBuilder.loadTexts: apathUserEntry.setStatus('mandatory')
if mibBuilder.loadTexts: apathUserEntry.setDescription('An entry containing information applicable to a particular APATH line.')
apathUserIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 6, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apathUserIndex.setStatus('mandatory')
if mibBuilder.loadTexts: apathUserIndex.setDescription('The line interface identifier that can be used to locate this user.')
apathUserApathOperation = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 6, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("mainPrefered", 1), ("switchToBestPath", 2), ("avoidSwitching", 3))).clone('mainPrefered')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apathUserApathOperation.setStatus('mandatory')
if mibBuilder.loadTexts: apathUserApathOperation.setDescription(' default = mainPrefered This defines the switching characteristics of main and alternate paths. MAIN PREFERED Re-connect to the main path only. - continuous retry of main path. - disconnect the alternate path in use and switch to the main path when it is known to be UP. - When the main path fails, then attempt to re-establish the path on one of the alternate paths in the order Alternate 1, then Alternate 2, then Alternate 3. SWITCH TO BEST PATH Connect to the best path. - continuous retry of the main path and any path that is higher than the path currently in use. - disconnect the path ans select the highest priority path that is known to be UP. - when a the current path fails, then attempt to re-establish the path based on the priority order of: main, alternate 1, 2, 3. AVOID SWITCHING No automatic switching occurs. - remain connected with the current path as long as it remains UP. - when it fails, or is commanded to disconnect, then re-establish path based on the priority order of: main, alternate 1, 2, 3.')
apathUserMainApathIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 6, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apathUserMainApathIndex.setStatus('mandatory')
if mibBuilder.loadTexts: apathUserMainApathIndex.setDescription('The index into the apath table that specifies the primary trunk path connection.')
apathUserAlt1ApathIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 6, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apathUserAlt1ApathIndex.setStatus('mandatory')
if mibBuilder.loadTexts: apathUserAlt1ApathIndex.setDescription('The index into the apath table that specifies the first alternate trunk path connection to use if the main path is down.')
apathUserAlt2ApathIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 6, 4, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apathUserAlt2ApathIndex.setStatus('mandatory')
if mibBuilder.loadTexts: apathUserAlt2ApathIndex.setDescription('The index into the apath table that specifies the second alternate trunk to use if the both the main and alternate 1 path connection is down.')
apathUserAlt3ApathIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 6, 4, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apathUserAlt3ApathIndex.setStatus('mandatory')
if mibBuilder.loadTexts: apathUserAlt3ApathIndex.setDescription('The index into the apath table that specifies the third alternate trunk to use if the main, alternate 1 AND alternate 2 path connections are down.')
apathUserType = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 6, 4, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("alc", 1), ("u100", 2), ("x2x", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apathUserType.setStatus('mandatory')
if mibBuilder.loadTexts: apathUserType.setDescription("Defines the type of user traffic that is flowing across this Apath connection. This information is really only used when the Tiger is configured ('apathType') for an Apath primary or primary-mute mode of operation. When it is configured for secondary mode. This field must match the type of user traffic that will be send to it from the remote Tiger.")
apathUserDevStatusEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 6, 4, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apathUserDevStatusEnable.setStatus('mandatory')
if mibBuilder.loadTexts: apathUserDevStatusEnable.setDescription(' default = 1 (Primary only) Include the device status in the Apath enquiry message if enabled.')
apathUserAuxilliaryInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 6, 4, 1, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apathUserAuxilliaryInfo.setStatus('mandatory')
if mibBuilder.loadTexts: apathUserAuxilliaryInfo.setDescription('This octet string contains any additional clarification information for this APATH User stream. For the IA Diversion function, the first octet contains the Tiger Port number (values can be 0x01 - 0x04). The second contains the IA (valid numbers are 0x01 - 0x3F). If the IA Diversion function is not selected, then these values are both zero (i.e. 0x00 0x00); the remainding octets of the string are available for other functions.')
svcmsgNumEntries = MibScalar((1, 3, 6, 1, 4, 1, 1978, 2, 1, 7, 1), NonNegativeInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: svcmsgNumEntries.setStatus('mandatory')
if mibBuilder.loadTexts: svcmsgNumEntries.setDescription('Number of service message profiles in the table.')
svcmsgTable = MibTable((1, 3, 6, 1, 4, 1, 1978, 2, 1, 7, 2), )
if mibBuilder.loadTexts: svcmsgTable.setStatus('mandatory')
if mibBuilder.loadTexts: svcmsgTable.setDescription('A list of service message table entries. The number of entries is given by the value of svcmsgNumEntries.')
svcmsgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1978, 2, 1, 7, 2, 1), ).setIndexNames((0, "TIGER", "svcmsgIndex"))
if mibBuilder.loadTexts: svcmsgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: svcmsgEntry.setDescription('An entry containing information applicable to a particular service message profile.')
svcmsgIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 7, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: svcmsgIndex.setStatus('mandatory')
if mibBuilder.loadTexts: svcmsgIndex.setDescription('A unique value for each service message profile entry.')
svcmsgDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 7, 2, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: svcmsgDescription.setStatus('mandatory')
if mibBuilder.loadTexts: svcmsgDescription.setDescription('This is the description field for this table entry.')
svcmsgNetDown = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 7, 2, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 64)).clone('Network Down')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: svcmsgNetDown.setStatus('mandatory')
if mibBuilder.loadTexts: svcmsgNetDown.setDescription("Message sent when: All links to the network are down, or the network is not responding, Or when an ICMP message 'net unreachable' is received.")
svcmsgNetUp = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 7, 2, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 64)).clone('Network Up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: svcmsgNetUp.setStatus('mandatory')
if mibBuilder.loadTexts: svcmsgNetUp.setDescription('Message sent when: The network is available.')
svcmsgConnecting = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 7, 2, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 64)).clone('Connecting')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: svcmsgConnecting.setStatus('mandatory')
if mibBuilder.loadTexts: svcmsgConnecting.setDescription('Message sent when: Trying to make a connection with the remote end user.')
svcmsgConnected = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 7, 2, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 64)).clone('Connected')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: svcmsgConnected.setStatus('mandatory')
if mibBuilder.loadTexts: svcmsgConnected.setDescription('Message sent when: Connection with the remote end user has been established.')
svcmsgIdle = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 7, 2, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 64)).clone('Idle')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: svcmsgIdle.setStatus('mandatory')
if mibBuilder.loadTexts: svcmsgIdle.setDescription('Message sent when: The network is available, but the local end user has not yet initiated a connection.')
svcmsgDisconnecting = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 7, 2, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 64)).clone('Disconnecting')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: svcmsgDisconnecting.setStatus('mandatory')
if mibBuilder.loadTexts: svcmsgDisconnecting.setDescription('Message sent when: The connection is currently in the process of being cleared.')
svcmsgDisconnected = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 7, 2, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 64)).clone('Disconnected')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: svcmsgDisconnected.setStatus('mandatory')
if mibBuilder.loadTexts: svcmsgDisconnected.setDescription('Message sent when: The connection has broken. No reason is associated with the outage.')
svcmsgDiscRestart = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 7, 2, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 64)).clone('Disconnected/Restart')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: svcmsgDiscRestart.setStatus('mandatory')
if mibBuilder.loadTexts: svcmsgDiscRestart.setDescription('Message sent when: The connection has broken due to a restart condition being received.')
svcmsgDiscUser = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 7, 2, 1, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 64)).clone('Disconnected/User')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: svcmsgDiscUser.setStatus('mandatory')
if mibBuilder.loadTexts: svcmsgDiscUser.setDescription('Message sent when: The connection has been cleared by local intervention, i.e. console command.')
svcmsgDiscMgmt = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 7, 2, 1, 12), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 64)).clone('Disconnected/Mgmt')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: svcmsgDiscMgmt.setStatus('mandatory')
if mibBuilder.loadTexts: svcmsgDiscMgmt.setDescription('Message sent when: The connection has been cleared by local network management.')
svcmsgDiscBusy = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 7, 2, 1, 13), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 64)).clone('Disconnected/Busy')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: svcmsgDiscBusy.setStatus('mandatory')
if mibBuilder.loadTexts: svcmsgDiscBusy.setDescription('Message sent when: The connection has been cleared by the remote end because it already has a connection established with another user.')
svcmsgDiscRPErr = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 7, 2, 1, 14), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 64)).clone('Disconnected/Remote Procedure Error')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: svcmsgDiscRPErr.setStatus('mandatory')
if mibBuilder.loadTexts: svcmsgDiscRPErr.setDescription('Message sent when: The connection has been cleared because a protocol error associated with the remote end has been detected.')
svcmsgDiscLPErr = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 7, 2, 1, 15), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 64)).clone('Disconnected/Local Procedure Error')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: svcmsgDiscLPErr.setStatus('mandatory')
if mibBuilder.loadTexts: svcmsgDiscLPErr.setDescription('Message sent when: The connection has been cleared because a protocol error associated with the local end has been detected.')
svcmsgDiscCongest = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 7, 2, 1, 16), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 64)).clone('Disconnected/Congestion')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: svcmsgDiscCongest.setStatus('mandatory')
if mibBuilder.loadTexts: svcmsgDiscCongest.setDescription('Message sent when: The connection has been cleared because of network congestion.')
svcmsgDiscNotOb = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 7, 2, 1, 17), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 64)).clone('Disconnected/Not Obtainable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: svcmsgDiscNotOb.setStatus('mandatory')
if mibBuilder.loadTexts: svcmsgDiscNotOb.setDescription('Message sent when: The connection has been cleared because the address used for the remote end user is unknown.')
svcmsgDiscOutOrder = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 7, 2, 1, 18), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 64)).clone('Disconnected/Out of Order')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: svcmsgDiscOutOrder.setStatus('mandatory')
if mibBuilder.loadTexts: svcmsgDiscOutOrder.setDescription('Message sent when: The connection has been cleared because: a) the connection cannot be completed, b) has been cleared, c) the remote end user is, or becomes unavailable.')
svcmsgDiscInvFac = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 7, 2, 1, 19), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 64)).clone('Disconnected/Invalid Facility')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: svcmsgDiscInvFac.setStatus('mandatory')
if mibBuilder.loadTexts: svcmsgDiscInvFac.setDescription('Message sent when: The connection has been cleared because a facility that was requested was invalid.')
svcmsgDiscAcsBar = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 7, 2, 1, 20), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 64)).clone('Disconnected/Access Barred')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: svcmsgDiscAcsBar.setStatus('mandatory')
if mibBuilder.loadTexts: svcmsgDiscAcsBar.setDescription('Message sent when: The connection has been cleared because a the local end user does not have permission to access the remote end.')
svcmsgDiscRvsCharge = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 7, 2, 1, 21), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 64)).clone('Disconnected/Reverse Charge not accepted')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: svcmsgDiscRvsCharge.setStatus('mandatory')
if mibBuilder.loadTexts: svcmsgDiscRvsCharge.setDescription('Message sent when: The connection has been cleared because the remote end user cannot accept the reverse charge requested by the local end.')
svcmsgDiscIncDest = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 7, 2, 1, 22), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 64)).clone('Disconnected/Invalid Destination')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: svcmsgDiscIncDest.setStatus('mandatory')
if mibBuilder.loadTexts: svcmsgDiscIncDest.setDescription('Message sent when: The connection has been cleared because the remote end user application is incompatible with the local end.')
svcmsgDiscNoTraf = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 7, 2, 1, 23), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 64)).clone('Disconnected/No Traffic')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: svcmsgDiscNoTraf.setStatus('mandatory')
if mibBuilder.loadTexts: svcmsgDiscNoTraf.setDescription('Message sent when: The connection has been cleared because no traffic has been detected over a specified period of time.')
svcmsgUpAgain = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 7, 2, 1, 24), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 64)).clone('Up Again')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: svcmsgUpAgain.setStatus('mandatory')
if mibBuilder.loadTexts: svcmsgUpAgain.setDescription('Message sent when: A device is detected as having become operable.')
svcmsgNoRoute = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 7, 2, 1, 25), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 64)).clone('No Route To Host')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: svcmsgNoRoute.setStatus('mandatory')
if mibBuilder.loadTexts: svcmsgNoRoute.setDescription('Message sent when: 1/ No route to the host is configured. 2/ There is no alternate host access selected.')
svcmsgOverLength = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 7, 2, 1, 26), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: svcmsgOverLength.setStatus('mandatory')
if mibBuilder.loadTexts: svcmsgOverLength.setDescription('Message sent when: A message was received by a protocol whose length was greater than the configured maximum allowable message length.')
svcmsgCongestion = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 7, 2, 1, 27), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 64)).clone('Congestion')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: svcmsgCongestion.setStatus('mandatory')
if mibBuilder.loadTexts: svcmsgCongestion.setDescription("Message sent when: There is congestion preventing traffic from reaching the destination. Typically due to receiving an ICMP 'source quench'.")
svcmsgHostUnreach = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 7, 2, 1, 28), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 64)).clone('Host Unreachable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: svcmsgHostUnreach.setStatus('mandatory')
if mibBuilder.loadTexts: svcmsgHostUnreach.setDescription("Message sent when: The host, or host application is unreachable. Typically when an ICMP message is received that indicates 'host unreachable' or 'port unreachable'.")
svcmsgZeroLength = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 7, 2, 1, 29), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: svcmsgZeroLength.setStatus('mandatory')
if mibBuilder.loadTexts: svcmsgZeroLength.setDescription('Message sent when: There was no data in a message that was received by a protocol.')
bootpNumEntries = MibScalar((1, 3, 6, 1, 4, 1, 1978, 2, 1, 8, 1), NonNegativeInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bootpNumEntries.setStatus('mandatory')
if mibBuilder.loadTexts: bootpNumEntries.setDescription('Number of bootp command entries in the table.')
bootpTable = MibTable((1, 3, 6, 1, 4, 1, 1978, 2, 1, 8, 2), )
if mibBuilder.loadTexts: bootpTable.setStatus('mandatory')
if mibBuilder.loadTexts: bootpTable.setDescription('A list of bootp command entries. The number of entries is given by the value of bootpNumEntries.')
bootpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1978, 2, 1, 8, 2, 1), ).setIndexNames((0, "TIGER", "bootpIndex"))
if mibBuilder.loadTexts: bootpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: bootpEntry.setDescription('An entry containing information applicable to a particular bootp action.')
bootpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 8, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bootpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: bootpIndex.setDescription('A unique value for each bootp command entry.')
bootpServerName = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 8, 2, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bootpServerName.setStatus('mandatory')
if mibBuilder.loadTexts: bootpServerName.setDescription("An optional string signifying the name of the server that should respond to the BOOTP request. If bcastServerName contains a string, only the server that matches that name/address will answer the request. If bcastServerName is an empty string, then any BOOTP server that received the request may answer. This entry is only required for the first entry of the bootp table since subsequent bootp table entries are only used to perform FTP operations. Any subsequent FTP transactions will be performed to the 'server IP' address that was found in the bootp response.")
bootpUserName = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 8, 2, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 64)).clone('anonymous')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bootpUserName.setStatus('mandatory')
if mibBuilder.loadTexts: bootpUserName.setDescription('bootpUserName defines the user name used for performing an FTP file transfer.')
bootpPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 8, 2, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 64)).clone('guest')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bootpPassword.setStatus('mandatory')
if mibBuilder.loadTexts: bootpPassword.setDescription('bootpPassword defines the password used for performing an FTP file transfer.')
bootpRemoteFile = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 8, 2, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bootpRemoteFile.setStatus('mandatory')
if mibBuilder.loadTexts: bootpRemoteFile.setDescription('If bootpRemoteFile is an empty string, the responding server will use its database entry to inform TIGER of the servers filename to use for this transaction. If bootpRemoteFile contains a value, the BOOTP server will use that string to access its configuration database to determine the corresponding file that will be filled in the BOOTP response to inform TIGER of the servers filename to use for this transaction. Normally, the bootp database will contain a entry that defines this name as the name of the configuration file that should be downloaded first (see bootpLocalFile).')
bootpLocalFile = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 8, 2, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bootpLocalFile.setStatus('mandatory')
if mibBuilder.loadTexts: bootpLocalFile.setDescription("When Tiger's bootp application is performing an FTP transaction, the bootpLocalFile object contains the destination path and filename for the incoming file. If this field is empty, the downloaded file will be placed into a filename created by concatenating '/flash' with the filename (only) from the bootp response. That response will either contain a value specified in the BOOTP server database or if none there, then the value of bootpRemoteFile will be used. When bootpLocalFile is specified it must always contain one of the valid TIGER filesystems of: '/flash' or '/ramdisk'. It is assumed that this variable will always be written last when defining a bootpEntry. When this variable is written, the Bootp (or FTP) transaction will begin.")
mountNumEntries = MibScalar((1, 3, 6, 1, 4, 1, 1978, 2, 1, 9, 1), NonNegativeInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mountNumEntries.setStatus('mandatory')
if mibBuilder.loadTexts: mountNumEntries.setDescription('Number of filesystem entries in the table.')
mountTable = MibTable((1, 3, 6, 1, 4, 1, 1978, 2, 1, 9, 2), )
if mibBuilder.loadTexts: mountTable.setStatus('mandatory')
if mibBuilder.loadTexts: mountTable.setDescription('A list of filesystem entries. The number of entries is given by the value of mountNumEntries.')
mountEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1978, 2, 1, 9, 2, 1), ).setIndexNames((0, "TIGER", "mountIndex"))
if mibBuilder.loadTexts: mountEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mountEntry.setDescription('An entry containing information applicable to a particular mount point.')
mountIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 9, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mountIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mountIndex.setDescription('mountIndex is a unique value for each mount table entry.')
mountRemotePath = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 9, 2, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 256))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mountRemotePath.setStatus('mandatory')
if mibBuilder.loadTexts: mountRemotePath.setDescription('The mountRemotePath variable is a string defines the filesystem mount point on the remote machine. It will typically be of the form: //fulko/u/here/there')
mountLocalPath = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 9, 2, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mountLocalPath.setStatus('mandatory')
if mibBuilder.loadTexts: mountLocalPath.setDescription('The mountLocalPath variable is a string defines the filesystem mount point on the local machine. It will typically be of the form: /mnt/thisdir')
mountMode = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 9, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("read-only", 1), ("read-write", 2))).clone('read-write')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mountMode.setStatus('mandatory')
if mibBuilder.loadTexts: mountMode.setDescription('mountMode defines how the remote file system has been mounted on the local machine. A remote file system can either be mounted as read-only or as read-write. This overides any permission that may be granted by the remote machine.')
mountRemoteInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 9, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("notConnected-NoAccess", 1), ("notConnected-ReadOnly", 2), ("notConnected-WriteOnly", 3), ("notConnected-ReadWrite", 4), ("connected-NoAccess", 5), ("connected-ReadOnly", 6), ("connected-WriteOnly", 7), ("connected-ReadWrite", 8))).clone('notConnected-NoAccess')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mountRemoteInfo.setStatus('mandatory')
if mibBuilder.loadTexts: mountRemoteInfo.setDescription('mountRemoteInfo returns both the connection status of this entry with respect to the remote machine, as well as the access rights that the remote file system allows. This value is actually a bit field, where: the first two bits represent the read and write permissions respectively, the next bit represents the connection status: 0 = not connected, 1 = connected.')
dnsResLocalResolves = MibScalar((1, 3, 6, 1, 4, 1, 1978, 2, 1, 10, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dnsResLocalResolves.setStatus('mandatory')
if mibBuilder.loadTexts: dnsResLocalResolves.setDescription('The count of the number of times that a cached entry resolved the request.')
dnsResCacheFull = MibScalar((1, 3, 6, 1, 4, 1, 1978, 2, 1, 10, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dnsResCacheFull.setStatus('mandatory')
if mibBuilder.loadTexts: dnsResCacheFull.setDescription('The number of occurences when DNS responses were not cached because the cache was full.')
dnsResQueueFull = MibScalar((1, 3, 6, 1, 4, 1, 1978, 2, 1, 10, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dnsResQueueFull.setStatus('mandatory')
if mibBuilder.loadTexts: dnsResQueueFull.setDescription('The number of occurences when DNS responses were not cached because the cache queue was full.')
dnsResClearCache = MibScalar((1, 3, 6, 1, 4, 1, 1978, 2, 1, 10, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dnsResClearCache.setStatus('mandatory')
if mibBuilder.loadTexts: dnsResClearCache.setDescription('When set to reset(2), any persistant resolver state (such as a process) is reinitialized as if the resolver had just been started, and the cache is initialized. When read this variable will always return other(1).')
dnsResConfigMaxCnames = MibScalar((1, 3, 6, 1, 4, 1, 1978, 2, 1, 10, 5), Integer32().clone(16)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dnsResConfigMaxCnames.setReference('RFC-1035 section 7.1.')
if mibBuilder.loadTexts: dnsResConfigMaxCnames.setStatus('mandatory')
if mibBuilder.loadTexts: dnsResConfigMaxCnames.setDescription("Limit on how many CNAMEs the resolver should allow before deciding that there's a CNAME loop. Zero means that resolver has no explicit CNAME limit.")
dnsResNumHosts = MibScalar((1, 3, 6, 1, 4, 1, 1978, 2, 1, 10, 6), NonNegativeInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dnsResNumHosts.setStatus('mandatory')
if mibBuilder.loadTexts: dnsResNumHosts.setDescription('Number of DNS host entries.')
dnsResTable = MibTable((1, 3, 6, 1, 4, 1, 1978, 2, 1, 10, 7), )
if mibBuilder.loadTexts: dnsResTable.setStatus('mandatory')
if mibBuilder.loadTexts: dnsResTable.setDescription('A list of DNS host entries. The number of entries is given by the value of dnsResNumEntries.')
dnsResEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1978, 2, 1, 10, 7, 1), ).setIndexNames((0, "TIGER", "dnsResServerIP"))
if mibBuilder.loadTexts: dnsResEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dnsResEntry.setDescription('An entry containing information applicable to a particular dns point.')
dnsResServerIP = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 10, 7, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dnsResServerIP.setStatus('mandatory')
if mibBuilder.loadTexts: dnsResServerIP.setDescription('The IP address associated with this DNS host.')
dnsResServerName = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 10, 7, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dnsResServerName.setStatus('mandatory')
if mibBuilder.loadTexts: dnsResServerName.setDescription('The fully qualified domain name of this DNS host.')
dnsResQueriesSent = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 10, 7, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dnsResQueriesSent.setStatus('mandatory')
if mibBuilder.loadTexts: dnsResQueriesSent.setDescription('The total count of DNS requests made by this Tiger of this DNS host.')
dnsResSendErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 10, 7, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dnsResSendErrors.setStatus('mandatory')
if mibBuilder.loadTexts: dnsResSendErrors.setDescription('')
dnsResGoodResponses = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 10, 7, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dnsResGoodResponses.setStatus('mandatory')
if mibBuilder.loadTexts: dnsResGoodResponses.setDescription('The number of valid responses received from the requested DNS.')
dnsResTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 10, 7, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dnsResTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: dnsResTimeouts.setDescription('The number of occurences when this DNS host did not respond.')
dnsResBadResponses = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 10, 7, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dnsResBadResponses.setStatus('mandatory')
if mibBuilder.loadTexts: dnsResBadResponses.setDescription('The number of occurences when this DNS host responded incorrectly.')
dnsResCmd = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 10, 7, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noop", 1), ("delete", 2))).clone('noop')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dnsResCmd.setStatus('mandatory')
if mibBuilder.loadTexts: dnsResCmd.setDescription('The dnsResCmd can be set to delete to remove this row from the table. If you need to change the IP address of a host in the DNS table, you must create a new entry corresponding to the new host, and then use this field on the old host entry that should be removed.')
dnsResCacheNumEntries = MibScalar((1, 3, 6, 1, 4, 1, 1978, 2, 1, 10, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dnsResCacheNumEntries.setStatus('mandatory')
if mibBuilder.loadTexts: dnsResCacheNumEntries.setDescription("Number of entries in the Tiger's DNS Cache. This is currently not a dynamically sized table, but has a finite length of 16 entries.")
dnsResCacheTable = MibTable((1, 3, 6, 1, 4, 1, 1978, 2, 1, 10, 9), )
if mibBuilder.loadTexts: dnsResCacheTable.setStatus('mandatory')
if mibBuilder.loadTexts: dnsResCacheTable.setDescription('A list of DNS Cache entries. The number of entries is given by the value of dnsResNumEntries.')
dnsResCacheEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1978, 2, 1, 10, 9, 1), ).setIndexNames((0, "TIGER", "dnsResCacheIpAddress"))
if mibBuilder.loadTexts: dnsResCacheEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dnsResCacheEntry.setDescription('An entry containing information applicable to a particular dns point.')
dnsResCacheHostName = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 10, 9, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dnsResCacheHostName.setStatus('mandatory')
if mibBuilder.loadTexts: dnsResCacheHostName.setDescription('The fully quailfied domain name (FQDN) of the host contained in this entry.')
dnsResCacheIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 10, 9, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dnsResCacheIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: dnsResCacheIpAddress.setDescription('The IP address associated with the host contained in this entry.')
dnsResCacheRRTTL = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 10, 9, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dnsResCacheRRTTL.setStatus('mandatory')
if mibBuilder.loadTexts: dnsResCacheRRTTL.setDescription('Time-To-Live of RR in this cache entry. This is the initial TTL value which was received with the RR when it was originally received.')
dnsResCacheRRElapsedTTL = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 10, 9, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dnsResCacheRRElapsedTTL.setStatus('mandatory')
if mibBuilder.loadTexts: dnsResCacheRRElapsedTTL.setDescription('Elapsed seconds since RR was received.')
dnsResCacheRRSource = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 10, 9, 1, 5), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dnsResCacheRRSource.setStatus('mandatory')
if mibBuilder.loadTexts: dnsResCacheRRSource.setDescription('Host from which RR was received, 0.0.0.0 if unknown.')
vtTable = MibTable((1, 3, 6, 1, 4, 1, 1978, 2, 1, 11, 1), )
if mibBuilder.loadTexts: vtTable.setStatus('mandatory')
if mibBuilder.loadTexts: vtTable.setDescription('This is table associated with each Terminal Device configured on the Tiger to be used in the SABRE OFEP network.')
vtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1978, 2, 1, 11, 1, 1), ).setIndexNames((0, "TIGER", "vtAutifIndex"), (0, "TIGER", "vtRealLnIaTa"))
if mibBuilder.loadTexts: vtEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vtEntry.setDescription('Each row represents the configuration characteristics, status and statistics of each defined terminal/printer. ')
vtAutifIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 11, 1, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vtAutifIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vtAutifIndex.setDescription('A copy of the AUTIF table index.')
vtRealLnIaTa = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 11, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(3, 3)).setFixedLength(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vtRealLnIaTa.setStatus('mandatory')
if mibBuilder.loadTexts: vtRealLnIaTa.setDescription('The actual LNIATA associated with this ALC device. When an AUTIF needs to reference this information, it will use only the first two bytes of this value for matching.')
vtLnIaTa = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 11, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(3, 3)).setFixedLength(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vtLnIaTa.setStatus('mandatory')
if mibBuilder.loadTexts: vtLnIaTa.setDescription('The LNIATA associated with this ALC Device.')
vtOptionsDOD = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 11, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("connect-always", 1), ("connect-on-data", 2))).clone('connect-on-data')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vtOptionsDOD.setStatus('mandatory')
if mibBuilder.loadTexts: vtOptionsDOD.setDescription("Selection for Dial On Demand (DOD). If 'connect-always' is selected, then the session starts immediately. If 'connect-on-data' is selected, then the session is started only when data is received from the ALC device.")
vtOptionsPrinter = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 11, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("terminal", 1), ("printer", 2), ("free", 3))).clone('terminal')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vtOptionsPrinter.setStatus('mandatory')
if mibBuilder.loadTexts: vtOptionsPrinter.setDescription("Selection of the ALC Device type. If the device is a printer, then OFEP and Load Balancer Service Messages will not be forwarded to it. 'Free' indicates that the entry is part of a pool of addresses that can be dynamically allocated.")
vtOptionsClass = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 11, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("by-lniata", 1), ("by-class", 2))).clone('by-lniata')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vtOptionsClass.setStatus('mandatory')
if mibBuilder.loadTexts: vtOptionsClass.setDescription('This variable determines whether we request service from the OFEP Load Balancer by LNIATA or Class. When handled by LNIATA, the 3 byte LNIATA value is known at configuration. When handled by Class, the 3 byte LNIATA is provided to the Tiger by the Load Balancer as part of a Pooling mechanism.')
vtCommand = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 11, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("activate", 1), ("deactivate", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vtCommand.setStatus('mandatory')
if mibBuilder.loadTexts: vtCommand.setDescription('SNMP command trigger to activate or deactivate this LNIATA.')
vtClassName = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 11, 1, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vtClassName.setStatus('mandatory')
if mibBuilder.loadTexts: vtClassName.setDescription('The name of the class or host service that this virtual terminal will request.')
vtState = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 11, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("vts-init", 1), ("vts-dod-wait", 2), ("vts-con-lb", 3), ("vts-lb-dialog", 4), ("vts-lb-config", 5), ("vts-gen-fail", 6), ("vts-con-ofep", 7), ("vts-ofep-dialog", 8), ("vts-ofep-config", 9), ("vts-ofep-up", 10), ("vts-ofep-shutdown", 11)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vtState.setStatus('mandatory')
if mibBuilder.loadTexts: vtState.setDescription('This variable represents the State of this ALC device. The variable is defined as follows: vts-init : init vt instance vts-dod-wait : dial on demand - wait for user enq vts-con-lb : connect to Load Balancer vts-lb-dialog : negotiate with LB vts-lb-config : analyze config, and establish vts-gen-fail : general failure - send svc msg, close, clean up vts-con-ofep : connect to OFEP vts-ofep-dialog : negotiate with OFEP vts-ofep-config : accept OFEP config and establish vts-ofep-up : OFEP data transfer state vts-ofep-shutdown : OFEP shutdown procedure')
vtFailReason = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 11, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("vte-err-gen", 1), ("vte-err-sock-down", 2), ("vte-err-timeout", 3), ("vte-err-ka-timeout", 4), ("vte-err-lb", 5), ("vte-err-ofep", 6), ("vte-err-idle-timeout", 7), ("vte-deactivate", 8), ("vte-cap-off", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vtFailReason.setStatus('mandatory')
if mibBuilder.loadTexts: vtFailReason.setDescription('This variable represents the last known failure reason code. The variable is defined as follows: vte-err-gen : general failure - no resources, etc vte-err-sock-down : socket connection failure vte-err-timeout : timeout expired vte-err-ka-timeout : keep alive timer expired vte-err-lb : trouble with load balancer vte-err-ofep : trouble with OFEP vte-err-idle-timeout : user idle timeout vte-deactivate : deactivate command disabled this entry vte-cap-off : IA stream CAP state change - path switch')
vtFailString = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 11, 1, 1, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vtFailString.setStatus('mandatory')
if mibBuilder.loadTexts: vtFailString.setDescription('The last received failure message from either the Load Balancer or the OFEP.')
vtLBToken = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 11, 1, 1, 12), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: vtLBToken.setStatus('mandatory')
if mibBuilder.loadTexts: vtLBToken.setDescription('The received token for this OFEP session. This is provided by the Load Balancer')
vtCommandStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 11, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ready", 1), ("busy", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vtCommandStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vtCommandStatus.setDescription("Result of the SNMP 'vtCommand'.")
vtLBRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 11, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vtLBRequests.setStatus('mandatory')
if mibBuilder.loadTexts: vtLBRequests.setDescription('The number of request service packets sent to Load Balancer.')
vtLBErrorResponses = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 11, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vtLBErrorResponses.setStatus('mandatory')
if mibBuilder.loadTexts: vtLBErrorResponses.setDescription('The number of bad responses from Load Balancer.')
vtLBTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 11, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vtLBTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: vtLBTimeouts.setDescription('The number of timeout errors with Load Balancer.')
vtOFEPRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 11, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vtOFEPRequests.setStatus('mandatory')
if mibBuilder.loadTexts: vtOFEPRequests.setDescription('The number of config/startup packets sent to OFEP.')
vtOFEPErrorResponses = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 11, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vtOFEPErrorResponses.setStatus('mandatory')
if mibBuilder.loadTexts: vtOFEPErrorResponses.setDescription('The number of error responses from OFEP.')
vtOFEPTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 11, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vtOFEPTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: vtOFEPTimeouts.setDescription('The number of timeout errors with OFEP.')
vtOFEPKeepAliveTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 11, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vtOFEPKeepAliveTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: vtOFEPKeepAliveTimeouts.setDescription('The number of keep alive timeout errors with OFEP.')
vtOFEPReassemblyFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 11, 1, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vtOFEPReassemblyFailures.setStatus('mandatory')
if mibBuilder.loadTexts: vtOFEPReassemblyFailures.setDescription('The number of bad or incomplete message reassemblies.')
vtOFEPUserEnquiries = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 11, 1, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vtOFEPUserEnquiries.setStatus('mandatory')
if mibBuilder.loadTexts: vtOFEPUserEnquiries.setDescription('The number of number of user enquiries sent to OFEP.')
vtOFEPUserResponses = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 11, 1, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vtOFEPUserResponses.setStatus('mandatory')
if mibBuilder.loadTexts: vtOFEPUserResponses.setDescription('The number of number of user responses received from OFEP.')
vtOFEPUserInDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 11, 1, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vtOFEPUserInDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vtOFEPUserInDiscards.setDescription('The number of number of user enquiries discarded.')
vtOFEPUserOutDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 11, 1, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vtOFEPUserOutDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vtOFEPUserOutDiscards.setDescription('The number of number of user responses discarded.')
vtOFEPKeepAlives = MibTableColumn((1, 3, 6, 1, 4, 1, 1978, 2, 1, 11, 1, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vtOFEPKeepAlives.setStatus('mandatory')
if mibBuilder.loadTexts: vtOFEPKeepAlives.setDescription('The number of user OFEP KeepAlive messages received.')
mibBuilder.exportSymbols("TIGER", apathEndUserStatusEnable=apathEndUserStatusEnable, svcmsgDiscRPErr=svcmsgDiscRPErr, apathIndex=apathIndex, svcmsgDiscLPErr=svcmsgDiscLPErr, dnsResCacheRRSource=dnsResCacheRRSource, apathTable=apathTable, svcmsgDiscBusy=svcmsgDiscBusy, dnsResCacheFull=dnsResCacheFull, tigPool=tigPool, apathUserAlt1ApathIndex=apathUserAlt1ApathIndex, mountEntry=mountEntry, mount=mount, svcmsgDiscAcsBar=svcmsgDiscAcsBar, ifTStackEntry=ifTStackEntry, dnsResCacheEntry=dnsResCacheEntry, svcmsgConnecting=svcmsgConnecting, tigPoolSize=tigPoolSize, tigDomainName=tigDomainName, tigPCMCIAIf=tigPCMCIAIf, dnsResCmd=dnsResCmd, buffers=buffers, dnsResCacheRRElapsedTTL=dnsResCacheRRElapsedTTL, tigClearStatsTime=tigClearStatsTime, svcmsgNetDown=svcmsgNetDown, svcmsgDiscCongest=svcmsgDiscCongest, apathResponseTimerMax=apathResponseTimerMax, ifTStackStatus=ifTStackStatus, NonNegativeInteger=NonNegativeInteger, bootpNumEntries=bootpNumEntries, dnsResEntry=dnsResEntry, dnsResBadResponses=dnsResBadResponses, vtLBRequests=vtLBRequests, svcmsgNetUp=svcmsgNetUp, dnsResServerName=dnsResServerName, vtClassName=vtClassName, svcmsgNoRoute=svcmsgNoRoute, bootpEntry=bootpEntry, tigPoolCommandStatus=tigPoolCommandStatus, svcmsgTable=svcmsgTable, tigPoolIndex=tigPoolIndex, autifRealToVTHashDepth=autifRealToVTHashDepth, apathNumEntries=apathNumEntries, tsystem=tsystem, vtOFEPKeepAliveTimeouts=vtOFEPKeepAliveTimeouts, tigPCMCIAType=tigPCMCIAType, vtOFEPUserOutDiscards=vtOFEPUserOutDiscards, tiger=tiger, autifXlatToSocket=autifXlatToSocket, vtOptionsDOD=vtOptionsDOD, svcmsgZeroLength=svcmsgZeroLength, tigPoolTable=tigPoolTable, bootpIndex=bootpIndex, vtLBTimeouts=vtLBTimeouts, apathUserMainApathIndex=apathUserMainApathIndex, dnsResTable=dnsResTable, autifLBName=autifLBName, dnsResTimeouts=dnsResTimeouts, tigIdle=tigIdle, autifRemotePort=autifRemotePort, vtOFEPUserInDiscards=vtOFEPUserInDiscards, autifLNIA=autifLNIA, ifTStack=ifTStack, apathPathUpMsg=apathPathUpMsg, apathEntry=apathEntry, apathUserAlt3ApathIndex=apathUserAlt3ApathIndex, tigPoolHighThreshold=tigPoolHighThreshold, apathUserAuxilliaryInfo=apathUserAuxilliaryInfo, tigPoolFree=tigPoolFree, apathTrafficIdleTimer=apathTrafficIdleTimer, svcmsgUpAgain=svcmsgUpAgain, tigPoolTrapControl=tigPoolTrapControl, vtCommand=vtCommand, vt=vt, autifRemAddress=autifRemAddress, apathUserNumEntries=apathUserNumEntries, autifTypeAMaxMsgSize=autifTypeAMaxMsgSize, vtOptionsClass=vtOptionsClass, apathUserTable=apathUserTable, svcmsgDiscInvFac=svcmsgDiscInvFac, bootpPassword=bootpPassword, apathUserEntry=apathUserEntry, vtRealLnIaTa=vtRealLnIaTa, dnsResCacheNumEntries=dnsResCacheNumEntries, dnsResCacheHostName=dnsResCacheHostName, bootp=bootp, svcmsgHostUnreach=svcmsgHostUnreach, mountTable=mountTable, tigCpuTrapControl=tigCpuTrapControl, svcmsgIndex=svcmsgIndex, bootpLocalFile=bootpLocalFile, tigClearStats=tigClearStats, autifSockOptions=autifSockOptions, svcmsgConnected=svcmsgConnected, svcmsgDiscNoTraf=svcmsgDiscNoTraf, apathUserIndex=apathUserIndex, svcmsgCongestion=svcmsgCongestion, autifOutErrors=autifOutErrors, apathUserDevStatusEnable=apathUserDevStatusEnable, svcmsgDiscMgmt=svcmsgDiscMgmt, vtState=vtState, autifRxBufSize=autifRxBufSize, autifNumEntries=autifNumEntries, autifInUcastPkts=autifInUcastPkts, InterfaceIndex=InterfaceIndex, vtOFEPErrorResponses=vtOFEPErrorResponses, tigPoolEntry=tigPoolEntry, autifUserIdleTimeout=autifUserIdleTimeout, tigSystemSerialNum=tigSystemSerialNum, tigSystemExceptionSaveLog=tigSystemExceptionSaveLog, svcmsgDiscRvsCharge=svcmsgDiscRvsCharge, dnsResCacheTable=dnsResCacheTable, dnsResServerIP=dnsResServerIP, autifOutUcastPkts=autifOutUcastPkts, svcmsgDisconnected=svcmsgDisconnected, bootpUserName=bootpUserName, mountRemoteInfo=mountRemoteInfo, autifOFEPKeepAliveTimeout=autifOFEPKeepAliveTimeout, autifInDiscards=autifInDiscards, apathUserType=apathUserType, dnsRes=dnsRes, apathType=apathType, vtOptionsPrinter=vtOptionsPrinter, svcmsgDiscOutOrder=svcmsgDiscOutOrder, svcmsgDiscIncDest=svcmsgDiscIncDest, dnsResCacheRRTTL=dnsResCacheRRTTL, autifTable=autifTable, autifIndex=autifIndex, tigPCMCIASlot=tigPCMCIASlot, tigPCMCIATable=tigPCMCIATable, autifOutDiscards=autifOutDiscards, dnsResNumHosts=dnsResNumHosts, apathIdleTimerMax=apathIdleTimerMax, TigerDateAndTime=TigerDateAndTime, autif=autif, mountNumEntries=mountNumEntries, autifInErrors=autifInErrors, autifInOctets=autifInOctets, svcmsgIdle=svcmsgIdle, tigRestartReason=tigRestartReason, vtTable=vtTable, tigPoolLowThreshold=tigPoolLowThreshold, apathConnectTimerMax=apathConnectTimerMax, dnsResConfigMaxCnames=dnsResConfigMaxCnames, ifTStackIndex=ifTStackIndex, vtOFEPTimeouts=vtOFEPTimeouts, vtOFEPUserEnquiries=vtOFEPUserEnquiries, tigPCMCIAEntry=tigPCMCIAEntry, autifTypeAQueueSize=autifTypeAQueueSize, ifTStackHigherLayer=ifTStackHigherLayer, vtLBErrorResponses=vtLBErrorResponses, autifAliasAddress=autifAliasAddress, autifIA=autifIA, vtFailString=vtFailString, autifService=autifService, tigPoolTrapStatus=tigPoolTrapStatus, autifOutOctets=autifOutOctets, tigSystemExceptionEcho=tigSystemExceptionEcho, apathRetryCounterMax=apathRetryCounterMax, svcmsgDisconnecting=svcmsgDisconnecting, vtLBToken=vtLBToken, vtCommandStatus=vtCommandStatus, apathUserAlt2ApathIndex=apathUserAlt2ApathIndex, autifXlatFromSocket=autifXlatFromSocket, tigSystemExceptionLogging=tigSystemExceptionLogging, tigPoolBufSize=tigPoolBufSize, svcmsg=svcmsg, bootpTable=bootpTable, autifInUnknownProtos=autifInUnknownProtos, tigPoolNumEntries=tigPoolNumEntries, tigCpuIdleState=tigCpuIdleState, dnsResQueueFull=dnsResQueueFull, autifSockQueueSize=autifSockQueueSize, bootpRemoteFile=bootpRemoteFile, ngcan=ngcan, vtOFEPRequests=vtOFEPRequests, autifEntry=autifEntry, mountIndex=mountIndex, ifTStackLowerLayer=ifTStackLowerLayer, svcmsgDiscNotOb=svcmsgDiscNotOb, autifInNUcastPkts=autifInNUcastPkts, autifSockPrecedence=autifSockPrecedence, generalTiger=generalTiger, dnsResLocalResolves=dnsResLocalResolves, vtOFEPKeepAlives=vtOFEPKeepAlives, dnsResSendErrors=dnsResSendErrors, svcmsgDescription=svcmsgDescription, generalTraps=generalTraps, tigSystemDate=tigSystemDate, svcmsgEntry=svcmsgEntry, tigPoolAllocationFailures=tigPoolAllocationFailures, svcmsgDiscRestart=svcmsgDiscRestart, vtAutifIndex=vtAutifIndex, autifOutNUcastPkts=autifOutNUcastPkts, autifRealToVTRoutingErrors=autifRealToVTRoutingErrors, svcmsgOverLength=svcmsgOverLength, autifVTToRealRoutingErrors=autifVTToRealRoutingErrors, dnsResGoodResponses=dnsResGoodResponses, vtLnIaTa=vtLnIaTa, tigConfigFile=tigConfigFile, vtEntry=vtEntry, autifTxBufSize=autifTxBufSize, mountLocalPath=mountLocalPath, svcmsgDiscUser=svcmsgDiscUser, svcmsgNumEntries=svcmsgNumEntries, autifLocalPort=autifLocalPort, bootpServerName=bootpServerName, dnsResClearCache=dnsResClearCache, dnsResCacheIpAddress=dnsResCacheIpAddress, vtOFEPReassemblyFailures=vtOFEPReassemblyFailures, tigTokenRingSpeed=tigTokenRingSpeed, autifDestAddrType=autifDestAddrType, ifTStackTable=ifTStackTable, mountMode=mountMode, vtFailReason=vtFailReason, vtOFEPUserResponses=vtOFEPUserResponses, apath=apath, tigRestart=tigRestart, dnsResQueriesSent=dnsResQueriesSent, apathUserApathOperation=apathUserApathOperation, mountRemotePath=mountRemotePath)

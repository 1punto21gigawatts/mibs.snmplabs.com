#
# PySNMP MIB module LX-10-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/LX-10-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:09:10 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ValueSizeConstraint, ConstraintsUnion, ConstraintsIntersection, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ValueSizeConstraint", "ConstraintsUnion", "ConstraintsIntersection", "SingleValueConstraint")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
TimeTicks, Counter32, enterprises, Integer32, iso, Bits, Counter64, NotificationType, ObjectIdentity, NotificationType, Gauge32, Unsigned32, MibScalar, MibTable, MibTableRow, MibTableColumn, IpAddress, ModuleIdentity, MibIdentifier = mibBuilder.importSymbols("SNMPv2-SMI", "TimeTicks", "Counter32", "enterprises", "Integer32", "iso", "Bits", "Counter64", "NotificationType", "ObjectIdentity", "NotificationType", "Gauge32", "Unsigned32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "IpAddress", "ModuleIdentity", "MibIdentifier")
TextualConvention, DisplayString, PhysAddress = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString", "PhysAddress")
onstream = MibIdentifier((1, 3, 6, 1, 4, 1, 135))
lx_10 = MibIdentifier((1, 3, 6, 1, 4, 1, 135, 22)).setLabel("lx-10")
sys = MibIdentifier((1, 3, 6, 1, 4, 1, 135, 22, 1))
config = MibIdentifier((1, 3, 6, 1, 4, 1, 135, 22, 2))
fault = MibIdentifier((1, 3, 6, 1, 4, 1, 135, 22, 3))
perf = MibIdentifier((1, 3, 6, 1, 4, 1, 135, 22, 4))
class TimeAndDate(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(6, 6)
    fixedLength = 6

sysGenInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 135, 22, 1, 1))
sysGenInfoShelfName = MibScalar((1, 3, 6, 1, 4, 1, 135, 22, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysGenInfoShelfName.setStatus('mandatory')
if mibBuilder.loadTexts: sysGenInfoShelfName.setDescription('Name of the managed node.')
sysGenInfoCustomerName = MibScalar((1, 3, 6, 1, 4, 1, 135, 22, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysGenInfoCustomerName.setStatus('mandatory')
if mibBuilder.loadTexts: sysGenInfoCustomerName.setDescription('Name of the organization that uses the managed node.')
sysGenInfoPhoneNumber = MibScalar((1, 3, 6, 1, 4, 1, 135, 22, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysGenInfoPhoneNumber.setStatus('mandatory')
if mibBuilder.loadTexts: sysGenInfoPhoneNumber.setDescription('Phone number of the organization that uses the managed node.')
sysGenInfoMaintenanceContact = MibScalar((1, 3, 6, 1, 4, 1, 135, 22, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysGenInfoMaintenanceContact.setStatus('mandatory')
if mibBuilder.loadTexts: sysGenInfoMaintenanceContact.setDescription('Maintenance contact of the managed node.')
sysGenInfoLocation = MibScalar((1, 3, 6, 1, 4, 1, 135, 22, 1, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysGenInfoLocation.setStatus('mandatory')
if mibBuilder.loadTexts: sysGenInfoLocation.setDescription('Location of the managed node.')
sysGenInfoAutoLogoutTime = MibScalar((1, 3, 6, 1, 4, 1, 135, 22, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysGenInfoAutoLogoutTime.setStatus('mandatory')
if mibBuilder.loadTexts: sysGenInfoAutoLogoutTime.setDescription('The time a TELNET or VT-100 terminal user can maintain a session with the managed node without any keyboard action. Unit: minute')
sysGenInfoPassword = MibScalar((1, 3, 6, 1, 4, 1, 135, 22, 1, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 16)).clone('onstream')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysGenInfoPassword.setStatus('mandatory')
if mibBuilder.loadTexts: sysGenInfoPassword.setDescription('Password required to access the managed node using VT-100 terminal or TELNET. A get request always returns a NULL string.')
sysGenInfoShelfId = MibScalar((1, 3, 6, 1, 4, 1, 135, 22, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(255)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysGenInfoShelfId.setStatus('mandatory')
if mibBuilder.loadTexts: sysGenInfoShelfId.setDescription("LX-10 unit identification number required to identify and set up the device's role (primary/secondary). This number should be unique among interconnected devices.")
sysTimeAndDate = MibScalar((1, 3, 6, 1, 4, 1, 135, 22, 1, 2), TimeAndDate()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysTimeAndDate.setStatus('mandatory')
if mibBuilder.loadTexts: sysTimeAndDate.setDescription('Time and date maintained in the managed node.')
sysIpConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 135, 22, 1, 3))
sysIpConfigHostInterfaceTable = MibTable((1, 3, 6, 1, 4, 1, 135, 22, 1, 3, 1), )
if mibBuilder.loadTexts: sysIpConfigHostInterfaceTable.setStatus('mandatory')
if mibBuilder.loadTexts: sysIpConfigHostInterfaceTable.setDescription('Table of available host IP interfaces.')
sysIpConfigHostInterfaceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 135, 22, 1, 3, 1, 1), ).setIndexNames((0, "LX-10-MIB", "sysIpConfigHostInterfaceIndex"))
if mibBuilder.loadTexts: sysIpConfigHostInterfaceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sysIpConfigHostInterfaceEntry.setDescription('Each entry contains the IP address and subnet mask of the specified interface and a flag which enables/disables the managed node to broadcast its (RIP) routing table through the interface.')
sysIpConfigHostInterfaceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 135, 22, 1, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ethernet", 1), ("slip", 2), ("nxt1", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysIpConfigHostInterfaceIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sysIpConfigHostInterfaceIndex.setDescription('')
sysIpConfigHostInterfaceIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 135, 22, 1, 3, 1, 1, 2), IpAddress().clone(hexValue="00000000")).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysIpConfigHostInterfaceIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: sysIpConfigHostInterfaceIpAddress.setDescription("Host's IP address.")
sysIpConfigHostInterfaceSubnetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 135, 22, 1, 3, 1, 1, 3), IpAddress().clone(hexValue="00000000")).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysIpConfigHostInterfaceSubnetMask.setStatus('mandatory')
if mibBuilder.loadTexts: sysIpConfigHostInterfaceSubnetMask.setDescription("Host's IP subnet mask.")
sysIpConfigHostInterfaceXmtRoutingMsg = MibTableColumn((1, 3, 6, 1, 4, 1, 135, 22, 1, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysIpConfigHostInterfaceXmtRoutingMsg.setStatus('mandatory')
if mibBuilder.loadTexts: sysIpConfigHostInterfaceXmtRoutingMsg.setDescription('This object controls whether the managed node should broadcast its (RIP) routing table through the interface.')
sysIpConfigDefaultGateway = MibIdentifier((1, 3, 6, 1, 4, 1, 135, 22, 1, 3, 2))
sysIpConfigDefaultGatewayIpAddress = MibScalar((1, 3, 6, 1, 4, 1, 135, 22, 1, 3, 2, 1), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysIpConfigDefaultGatewayIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: sysIpConfigDefaultGatewayIpAddress.setDescription("Default gateway's IP address.")
sysIpConfigDefaultGatewaySubnetMask = MibScalar((1, 3, 6, 1, 4, 1, 135, 22, 1, 3, 2, 2), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysIpConfigDefaultGatewaySubnetMask.setStatus('mandatory')
if mibBuilder.loadTexts: sysIpConfigDefaultGatewaySubnetMask.setDescription("Default gateway's IP subnet mask.")
sysIpConfigTrapClientTable = MibTable((1, 3, 6, 1, 4, 1, 135, 22, 1, 3, 3), )
if mibBuilder.loadTexts: sysIpConfigTrapClientTable.setStatus('mandatory')
if mibBuilder.loadTexts: sysIpConfigTrapClientTable.setDescription('Trap client table has 4 entries')
sysIpConfigTrapClientEntry = MibTableRow((1, 3, 6, 1, 4, 1, 135, 22, 1, 3, 3, 1), ).setIndexNames((0, "LX-10-MIB", "sysIpConfigTrapClientIndex"))
if mibBuilder.loadTexts: sysIpConfigTrapClientEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sysIpConfigTrapClientEntry.setDescription('Each entry contains IP address and port number of an SNMP manager which receives traps from the managed node.')
sysIpConfigTrapClientIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 135, 22, 1, 3, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysIpConfigTrapClientIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sysIpConfigTrapClientIndex.setDescription('')
sysIpConfigTrapClientIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 135, 22, 1, 3, 3, 1, 2), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysIpConfigTrapClientIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: sysIpConfigTrapClientIpAddress.setDescription("Trap client's IP address.")
sysIpConfigTrapClientSubnetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 135, 22, 1, 3, 3, 1, 3), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysIpConfigTrapClientSubnetMask.setStatus('mandatory')
if mibBuilder.loadTexts: sysIpConfigTrapClientSubnetMask.setDescription("Trap client's IP subnet mask.")
sysIpConfigTrapClientPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 135, 22, 1, 3, 3, 1, 4), Integer32().clone(162)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysIpConfigTrapClientPortNumber.setStatus('mandatory')
if mibBuilder.loadTexts: sysIpConfigTrapClientPortNumber.setDescription("Trap client's port number.")
sysIpConfigCommunityName = MibScalar((1, 3, 6, 1, 4, 1, 135, 22, 1, 3, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64)).clone('onstream')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysIpConfigCommunityName.setStatus('mandatory')
if mibBuilder.loadTexts: sysIpConfigCommunityName.setDescription('Community name of the managed node. A get request for an instance of this object always returns a NULL string.')
sysIpConfigMacAddress = MibScalar((1, 3, 6, 1, 4, 1, 135, 22, 1, 3, 5), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysIpConfigMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: sysIpConfigMacAddress.setDescription('MAC-layer address of the management Ethernet port.')
sysRs232Table = MibTable((1, 3, 6, 1, 4, 1, 135, 22, 1, 4), )
if mibBuilder.loadTexts: sysRs232Table.setStatus('mandatory')
if mibBuilder.loadTexts: sysRs232Table.setDescription('This table contains 2 rows. The first row shows the physical configuration of the port connected to a VT100 termianl. The second row is used to configure the port which supports SLIP. Access to the first row is read-only and access to the second row is read-write.')
sysRs232Entry = MibTableRow((1, 3, 6, 1, 4, 1, 135, 22, 1, 4, 1), ).setIndexNames((0, "LX-10-MIB", "sysRs232Port"))
if mibBuilder.loadTexts: sysRs232Entry.setStatus('mandatory')
if mibBuilder.loadTexts: sysRs232Entry.setDescription('Each entry contains the attributes of a serial port.')
sysRs232Port = MibTableColumn((1, 3, 6, 1, 4, 1, 135, 22, 1, 4, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("port-1", 1), ("port-2", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysRs232Port.setStatus('mandatory')
if mibBuilder.loadTexts: sysRs232Port.setDescription('The managed node has 2 serial ports: port 1 and port 2.')
sysRs232BaudRate = MibTableColumn((1, 3, 6, 1, 4, 1, 135, 22, 1, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("br-300", 1), ("br-1200", 2), ("br-2400", 3), ("br-4800", 4), ("br-9600", 5), ("br-19200", 6), ("br-38400", 7))).clone('br-9600')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysRs232BaudRate.setStatus('mandatory')
if mibBuilder.loadTexts: sysRs232BaudRate.setDescription('Baud rate. The instance of this object in port-1 is read-only.')
sysRs232Parity = MibTableColumn((1, 3, 6, 1, 4, 1, 135, 22, 1, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("even", 2), ("odd", 3))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysRs232Parity.setStatus('mandatory')
if mibBuilder.loadTexts: sysRs232Parity.setDescription('Parity. The instance of this object in port-1 is read-only.')
sysRs232DataBits = MibTableColumn((1, 3, 6, 1, 4, 1, 135, 22, 1, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("db-7", 1), ("db-8", 2))).clone('db-8')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysRs232DataBits.setStatus('mandatory')
if mibBuilder.loadTexts: sysRs232DataBits.setDescription('Number of data bits. The instance of this object in port-1 is read-only.')
sysRs232StopBits = MibTableColumn((1, 3, 6, 1, 4, 1, 135, 22, 1, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("sb-1", 1), ("sb-2", 2))).clone('sb-1')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysRs232StopBits.setStatus('mandatory')
if mibBuilder.loadTexts: sysRs232StopBits.setDescription('Number of stop bits. The instance of this object in port-1 is read-only.')
sysMainProcessorFirmwareRev = MibScalar((1, 3, 6, 1, 4, 1, 135, 22, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(4, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysMainProcessorFirmwareRev.setStatus('mandatory')
if mibBuilder.loadTexts: sysMainProcessorFirmwareRev.setDescription('Firmware revision of the management CPU.')
sysPortCardFirmwareRev = MibScalar((1, 3, 6, 1, 4, 1, 135, 22, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(4, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysPortCardFirmwareRev.setStatus('mandatory')
if mibBuilder.loadTexts: sysPortCardFirmwareRev.setDescription('Firmware revision of the Ethernet (DATA) card.')
configDs1Table = MibTable((1, 3, 6, 1, 4, 1, 135, 22, 2, 1), )
if mibBuilder.loadTexts: configDs1Table.setStatus('mandatory')
if mibBuilder.loadTexts: configDs1Table.setDescription('DS1 configuration table.')
configDs1Entry = MibTableRow((1, 3, 6, 1, 4, 1, 135, 22, 2, 1, 1), ).setIndexNames((0, "LX-10-MIB", "configDs1Port"))
if mibBuilder.loadTexts: configDs1Entry.setStatus('mandatory')
if mibBuilder.loadTexts: configDs1Entry.setDescription('Each entry contains the configuration attributes for a DS1 port.')
configDs1Port = MibTableColumn((1, 3, 6, 1, 4, 1, 135, 22, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configDs1Port.setStatus('mandatory')
if mibBuilder.loadTexts: configDs1Port.setDescription('DS1 port number.')
configDs1AdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 135, 22, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configDs1AdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: configDs1AdminStatus.setDescription('DS1 administrative status.')
configDs1OperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 135, 22, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("down", 1), ("up", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configDs1OperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: configDs1OperStatus.setDescription('DS1 operational status.')
configDs1LBO = MibTableColumn((1, 3, 6, 1, 4, 1, 135, 22, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("dB-0", 1), ("dB-7-5", 2), ("dB-15", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configDs1LBO.setStatus('mandatory')
if mibBuilder.loadTexts: configDs1LBO.setDescription('LBO. This object is not accessible if the managed node is the E1 version of LX10.')
configDs1Encoding = MibTableColumn((1, 3, 6, 1, 4, 1, 135, 22, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("b8zs", 1), ("ami", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configDs1Encoding.setStatus('mandatory')
if mibBuilder.loadTexts: configDs1Encoding.setDescription('Encoding. This object is not accessible if the managed node is the E1 version of LX10.')
configDs1Framing = MibTableColumn((1, 3, 6, 1, 4, 1, 135, 22, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("esf", 1), ("d4", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configDs1Framing.setStatus('mandatory')
if mibBuilder.loadTexts: configDs1Framing.setDescription('Framing format. This object is not accessible if the managed node is the E1 version of LX10.')
configDs1XmtAis = MibTableColumn((1, 3, 6, 1, 4, 1, 135, 22, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configDs1XmtAis.setStatus('mandatory')
if mibBuilder.loadTexts: configDs1XmtAis.setDescription('Enable/disable transmit AIS.')
configDs1Timing = MibScalar((1, 3, 6, 1, 4, 1, 135, 22, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("looped", 1), ("internal", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configDs1Timing.setStatus('mandatory')
if mibBuilder.loadTexts: configDs1Timing.setDescription('DS1 clock Source.')
configAfa = MibIdentifier((1, 3, 6, 1, 4, 1, 135, 22, 2, 3))
configAfaActivationRate = MibScalar((1, 3, 6, 1, 4, 1, 135, 22, 2, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("a-10-4", 1), ("a-10-5", 2), ("a-10-6", 3), ("a-10-7", 4), ("a-10-8", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configAfaActivationRate.setStatus('mandatory')
if mibBuilder.loadTexts: configAfaActivationRate.setDescription("AFA activation rate is used by the managed node to decide when it will disable the operational status of a T1 interface if the interface's BER rate is above the selected activation rate for a period specified by configAfaActivationTime (see below).")
configAfaActivationTime = MibScalar((1, 3, 6, 1, 4, 1, 135, 22, 2, 3, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configAfaActivationTime.setStatus('mandatory')
if mibBuilder.loadTexts: configAfaActivationTime.setDescription('See above description. Unit - minute')
configAfaDeactivationRate = MibScalar((1, 3, 6, 1, 4, 1, 135, 22, 2, 3, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("d-10-6", 1), ("d-10-7", 2), ("d-10-8", 3), ("d-10-9", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configAfaDeactivationRate.setStatus('mandatory')
if mibBuilder.loadTexts: configAfaDeactivationRate.setDescription("AFA deactivation rate is used by the managed node to decide when it will enable the operational status of a T1 interface if the interface's BER rate is below the selected activation rate for a period specified by configAfaDectivationTime (see below).")
configAfaDeactivationTime = MibScalar((1, 3, 6, 1, 4, 1, 135, 22, 2, 3, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(15, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configAfaDeactivationTime.setStatus('mandatory')
if mibBuilder.loadTexts: configAfaDeactivationTime.setDescription('See above description. Unit - minute')
configAfaStatus = MibScalar((1, 3, 6, 1, 4, 1, 135, 22, 2, 3, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configAfaStatus.setStatus('mandatory')
if mibBuilder.loadTexts: configAfaStatus.setDescription('Enable/disable AFA function.')
configAfaFarEndLpbkDetect = MibScalar((1, 3, 6, 1, 4, 1, 135, 22, 2, 3, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configAfaFarEndLpbkDetect.setStatus('mandatory')
if mibBuilder.loadTexts: configAfaFarEndLpbkDetect.setDescription("This object controls whether AFA will be activated when a near end LX-10 detects network loopback in the far end LX-10. If it's disabled, no AFA will be activated because of a far end network loopback.")
configPortCardType = MibScalar((1, 3, 6, 1, 4, 1, 135, 22, 2, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("hsdp", 1), ("ethernet", 2), ("token-ring", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configPortCardType.setStatus('mandatory')
if mibBuilder.loadTexts: configPortCardType.setDescription('There are 3 kinds of cards/port supported by the managed node: HSDP, Ethernet, or Token-Ring. Only one of them can be installed in the managed node. Hsdp is a high speed data port with v.35, rs-422, and HSSI interfaces.')
configHsdp = MibIdentifier((1, 3, 6, 1, 4, 1, 135, 22, 2, 5))
configHsdpMode = MibScalar((1, 3, 6, 1, 4, 1, 135, 22, 2, 5, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("v-35", 1), ("rs-422", 2), ("hssi", 3))).clone('hssi')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configHsdpMode.setStatus('mandatory')
if mibBuilder.loadTexts: configHsdpMode.setDescription('Interface type used by HSDP.')
configHsdpCtsControl = MibScalar((1, 3, 6, 1, 4, 1, 135, 22, 2, 5, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("set", 1), ("no-bandwidth", 2), ("frequency-change", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configHsdpCtsControl.setStatus('mandatory')
if mibBuilder.loadTexts: configHsdpCtsControl.setDescription('CTS line control in HSDP. If the value of an instance of this object is set, the CTS line will always be set. If the value of an instance of this object is no-bandwidth, the CTS line will go low when no bandwidth is available after a hold-off time. If the value of an instance of this object is frequency- change, the CTS line will go low for a hold-off time when there is a frequency change.')
configHsdpCtsStatus = MibScalar((1, 3, 6, 1, 4, 1, 135, 22, 2, 5, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clear", 1), ("set", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configHsdpCtsStatus.setStatus('mandatory')
if mibBuilder.loadTexts: configHsdpCtsStatus.setDescription('Status of CTS line in HSDP.')
configHsdpTermTimingSource = MibScalar((1, 3, 6, 1, 4, 1, 135, 22, 2, 5, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("external", 1), ("internal", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configHsdpTermTimingSource.setStatus('mandatory')
if mibBuilder.loadTexts: configHsdpTermTimingSource.setDescription('Terminal timing source in HSDP. It applies only when the value of the instance of configHsdpMode is v-35 or rs-422.')
configHsdpTermTiming = MibScalar((1, 3, 6, 1, 4, 1, 135, 22, 2, 5, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("inverted", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configHsdpTermTiming.setStatus('mandatory')
if mibBuilder.loadTexts: configHsdpTermTiming.setDescription('Status of terminal timing in HSDP. It applies only when the value of the instance of configHsdpMode is v-35 or rs-422.')
configHsdpRecvTiming = MibScalar((1, 3, 6, 1, 4, 1, 135, 22, 2, 5, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("inverted", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configHsdpRecvTiming.setStatus('mandatory')
if mibBuilder.loadTexts: configHsdpRecvTiming.setDescription('Status of receive timing in HSDP. It applies only when the value of the instance of configHsdpMode is v-35 or rs-422.')
configHsdpHoldoffSeconds = MibScalar((1, 3, 6, 1, 4, 1, 135, 22, 2, 5, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("sec1", 1), ("sec2", 2), ("sec3", 3), ("sec4", 4), ("sec5", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configHsdpHoldoffSeconds.setStatus('mandatory')
if mibBuilder.loadTexts: configHsdpHoldoffSeconds.setDescription('Hold-off time for CA lead. If the hold-off is set at 5 seconds, and if the CTS control is sensitive to no-bandwidth, the CTS line will go low after 5 seconds when no bandwidth is available. If the CTS control is sensitive to frequency-change, the CTS line will stay low for 5 seconds when there is a frequency change, and then back to high.')
configHdlc = MibIdentifier((1, 3, 6, 1, 4, 1, 135, 22, 2, 6))
configHdlcMode = MibScalar((1, 3, 6, 1, 4, 1, 135, 22, 2, 6, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("auto", 1), ("manual", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configHdlcMode.setStatus('mandatory')
if mibBuilder.loadTexts: configHdlcMode.setDescription("Select the way in which HDLC port will be assigned. If mode is manual, the HDLC port is selectable by the NMS. If mode is auto, the 2 LX-10's in the 2 sides will match their HDLC ports automatically.")
configHdlcLocalPort = MibScalar((1, 3, 6, 1, 4, 1, 135, 22, 2, 6, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configHdlcLocalPort.setStatus('mandatory')
if mibBuilder.loadTexts: configHdlcLocalPort.setDescription('Assign one of the DS1 ports as the HDLC port. If its value is 0, no port is asssigned as the HDLC port. ')
configHdlcFarEndPort = MibScalar((1, 3, 6, 1, 4, 1, 135, 22, 2, 6, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configHdlcFarEndPort.setStatus('mandatory')
if mibBuilder.loadTexts: configHdlcFarEndPort.setDescription('The DS1 port currently being used as the HDLC port in the far end LX-10.')
configInverseMux = MibScalar((1, 3, 6, 1, 4, 1, 135, 22, 2, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("secondary", 1), ("primary", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configInverseMux.setStatus('mandatory')
if mibBuilder.loadTexts: configInverseMux.setDescription("Master/slave relationship of the 2 LX-10E's in the point to point connection.")
faultDs1 = MibIdentifier((1, 3, 6, 1, 4, 1, 135, 22, 3, 1))
faultDs1LoopbackTable = MibTable((1, 3, 6, 1, 4, 1, 135, 22, 3, 1, 1), )
if mibBuilder.loadTexts: faultDs1LoopbackTable.setStatus('mandatory')
if mibBuilder.loadTexts: faultDs1LoopbackTable.setDescription('DS1 loopback table for 7 DS1 ports.')
faultDs1LoopbackEntry = MibTableRow((1, 3, 6, 1, 4, 1, 135, 22, 3, 1, 1, 1), ).setIndexNames((0, "LX-10-MIB", "faultDs1LoopbackPort"))
if mibBuilder.loadTexts: faultDs1LoopbackEntry.setStatus('mandatory')
if mibBuilder.loadTexts: faultDs1LoopbackEntry.setDescription('Each entry in the table contains the loopback status of a DS1 port.')
faultDs1LoopbackPort = MibTableColumn((1, 3, 6, 1, 4, 1, 135, 22, 3, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: faultDs1LoopbackPort.setStatus('mandatory')
if mibBuilder.loadTexts: faultDs1LoopbackPort.setDescription('The port number of one of the 7 DS1 ports')
faultDs1LoopbackNetworkLoopback = MibTableColumn((1, 3, 6, 1, 4, 1, 135, 22, 3, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("card", 2), ("line", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: faultDs1LoopbackNetworkLoopback.setStatus('mandatory')
if mibBuilder.loadTexts: faultDs1LoopbackNetworkLoopback.setDescription('DS1 loopback is used to control the loopback state of one of the 7 DS1 interfaces in the managed node.')
faultDs1RemoteLineLoopback = MibScalar((1, 3, 6, 1, 4, 1, 135, 22, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("inactive", 1), ("active", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: faultDs1RemoteLineLoopback.setStatus('mandatory')
if mibBuilder.loadTexts: faultDs1RemoteLineLoopback.setDescription('This loopback status is controlled by the LA/LB leads in the remote node.')
faultDte = MibIdentifier((1, 3, 6, 1, 4, 1, 135, 22, 3, 2))
faultDteLaLead = MibScalar((1, 3, 6, 1, 4, 1, 135, 22, 3, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clear", 1), ("set", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: faultDteLaLead.setStatus('mandatory')
if mibBuilder.loadTexts: faultDteLaLead.setDescription('The state of the LA loopbak lead.')
faultDteLbLead = MibScalar((1, 3, 6, 1, 4, 1, 135, 22, 3, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clear", 1), ("set", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: faultDteLbLead.setStatus('mandatory')
if mibBuilder.loadTexts: faultDteLbLead.setDescription('The state of the LB loopbak lead.')
faultDteLaLbTranslation = MibScalar((1, 3, 6, 1, 4, 1, 135, 22, 3, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("local-line", 2), ("remote-line", 3), ("dte", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: faultDteLaLbTranslation.setStatus('mandatory')
if mibBuilder.loadTexts: faultDteLaLbTranslation.setDescription('The managed node uses the states of the LA and LB leads to decide what kind of loopback to perform if faultLaLbLoopbackEnable (see below) is ENABLED. The meaning of LA and LB leads is as follows: loopback LA-Lead LB-Lead ------------------------------------------------ none clear clear local-line set clear remote-line clear set dte set set ')
faultDteLaLbLoopbackEnable = MibScalar((1, 3, 6, 1, 4, 1, 135, 22, 3, 2, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: faultDteLaLbLoopbackEnable.setStatus('mandatory')
if mibBuilder.loadTexts: faultDteLaLbLoopbackEnable.setDescription('Enable/disable the managed node to use the LA and LB lead states to perform loopbaks.')
faultDteCustomerLoopback = MibScalar((1, 3, 6, 1, 4, 1, 135, 22, 3, 2, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: faultDteCustomerLoopback.setStatus('mandatory')
if mibBuilder.loadTexts: faultDteCustomerLoopback.setDescription('Enable/disable the customer equipment (DTE) to perform loopback toward the managed node.')
faultDteDteLoopback = MibScalar((1, 3, 6, 1, 4, 1, 135, 22, 3, 2, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: faultDteDteLoopback.setStatus('mandatory')
if mibBuilder.loadTexts: faultDteDteLoopback.setDescription('Enable/disable the managed node to perform loopback toward the customer equipment (DTE).')
faultClearCurrentAlarms = MibScalar((1, 3, 6, 1, 4, 1, 135, 22, 3, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: faultClearCurrentAlarms.setStatus('mandatory')
if mibBuilder.loadTexts: faultClearCurrentAlarms.setDescription('A set request clears all entries in the current alarm table. A get/get-next request returns 0.')
faultClearHistoryAlarms = MibScalar((1, 3, 6, 1, 4, 1, 135, 22, 3, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: faultClearHistoryAlarms.setStatus('mandatory')
if mibBuilder.loadTexts: faultClearHistoryAlarms.setDescription('A set request clears all entries in the history alarm table. A get/get-next request returns 0.')
faultCurrentAlarmTable = MibTable((1, 3, 6, 1, 4, 1, 135, 22, 3, 5), )
if mibBuilder.loadTexts: faultCurrentAlarmTable.setStatus('mandatory')
if mibBuilder.loadTexts: faultCurrentAlarmTable.setDescription('Current alarm table.')
faultCurrentAlarmEntry = MibTableRow((1, 3, 6, 1, 4, 1, 135, 22, 3, 5, 1), ).setIndexNames((0, "LX-10-MIB", "faultCurrentAlarmTag"))
if mibBuilder.loadTexts: faultCurrentAlarmEntry.setStatus('mandatory')
if mibBuilder.loadTexts: faultCurrentAlarmEntry.setDescription('Each entry in the table contains the information of a currently active alarm.')
faultCurrentAlarmTag = MibTableColumn((1, 3, 6, 1, 4, 1, 135, 22, 3, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: faultCurrentAlarmTag.setStatus('mandatory')
if mibBuilder.loadTexts: faultCurrentAlarmTag.setDescription('The tag of the alarm in the current alarm table.')
faultCurrentAlarmAlarmType = MibTableColumn((1, 3, 6, 1, 4, 1, 135, 22, 3, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77))).clone(namedValues=NamedValues(("ds1-net-card-lpbk", 1), ("ds1-net-line-lpbk", 2), ("la-lb-dte-lpbk", 3), ("la-lb-local-lpbk", 4), ("la-lb-remote-lpbk", 5), ("remote-line-lpbk", 6), ("dte-lpbk", 7), ("customer-lpbk", 8), ("dte-clk-loss", 9), ("hsdc-ga-oof", 10), ("pll-fail", 11), ("card-fail", 12), ("ds1-los", 13), ("ds1-oof", 14), ("ds1-ais", 15), ("ds1-yel", 16), ("fan1-failed", 17), ("fan2-failed", 18), ("trunk-card-config-mismatch", 19), ("cim-card-config-mismatch", 20), ("cpu-restarted", 21), ("port-alarms-cleared", 22), ("all-alarms-cleared", 23), ("ds1-afa-alarm", 24), ("alarm-history-cleared", 25), ("p1-connected-to-p2", 26), ("p1-connected-to-p3", 27), ("p1-connected-to-p4", 28), ("p1-connected-to-p5", 29), ("p1-connected-to-p6", 30), ("p1-connected-to-p7", 31), ("p2-connected-to-p1", 32), ("p2-connected-to-p3", 33), ("p2-connected-to-p4", 34), ("p2-connected-to-p5", 35), ("p2-connected-to-p6", 36), ("p2-connected-to-p7", 37), ("p3-connected-to-p1", 38), ("p3-connected-to-p2", 39), ("p3-connected-to-p4", 40), ("p3-connected-to-p5", 41), ("p3-connected-to-p6", 42), ("p3-connected-to-p7", 43), ("p4-connected-to-p1", 44), ("p4-connected-to-p2", 45), ("p4-connected-to-p3", 46), ("p4-connected-to-p5", 47), ("p4-connected-to-p6", 48), ("p4-connected-to-p7", 49), ("p5-connected-to-p1", 50), ("p5-connected-to-p2", 51), ("p5-connected-to-p3", 52), ("p5-connected-to-p4", 53), ("p5-connected-to-p6", 54), ("p5-connected-to-p7", 55), ("p6-connected-to-p1", 56), ("p6-connected-to-p2", 57), ("p6-connected-to-p3", 58), ("p6-connected-to-p4", 59), ("p6-connected-to-p5", 60), ("p6-connected-to-p7", 61), ("p7-connected-to-p1", 62), ("p7-connected-to-p2", 63), ("p7-connected-to-p3", 64), ("p7-connected-to-p4", 65), ("p7-connected-to-p5", 66), ("p7-connected-to-p6", 67), ("alarm1-in", 68), ("alarm2-in", 69), ("alarm3-in", 70), ("hdlc-unlocked", 71), ("far-end-loopback", 72), ("remote-afa", 73), ("att-fdl-loopback", 74), ("inband-loopback", 75), ("t1-link-down", 76), ("ports-out-of-sequence", 77)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: faultCurrentAlarmAlarmType.setStatus('mandatory')
if mibBuilder.loadTexts: faultCurrentAlarmAlarmType.setDescription('The alarm type of the alarm.')
faultCurrentAlarmSeverity = MibTableColumn((1, 3, 6, 1, 4, 1, 135, 22, 3, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("minor", 2), ("major", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: faultCurrentAlarmSeverity.setStatus('mandatory')
if mibBuilder.loadTexts: faultCurrentAlarmSeverity.setDescription('The severity of the alarm.')
faultCurrentAlarmCardType = MibTableColumn((1, 3, 6, 1, 4, 1, 135, 22, 3, 5, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("hsdp", 1), ("ethernet", 2), ("token-ring", 3), ("ds1", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: faultCurrentAlarmCardType.setStatus('mandatory')
if mibBuilder.loadTexts: faultCurrentAlarmCardType.setDescription('The type of the card which caused the alarm.')
faultCurrentAlarmPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 135, 22, 3, 5, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: faultCurrentAlarmPortNumber.setStatus('mandatory')
if mibBuilder.loadTexts: faultCurrentAlarmPortNumber.setDescription('The port number of the card which caused the alarm. Its value is between 1 and 7 for DS1 ports and 0 for others.')
faultCurrentAlarmSetTime = MibTableColumn((1, 3, 6, 1, 4, 1, 135, 22, 3, 5, 1, 6), TimeAndDate()).setMaxAccess("readonly")
if mibBuilder.loadTexts: faultCurrentAlarmSetTime.setStatus('mandatory')
if mibBuilder.loadTexts: faultCurrentAlarmSetTime.setDescription('The time when the alarm was set.')
faultCurrentAlarmDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 135, 22, 3, 5, 1, 8), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: faultCurrentAlarmDescription.setStatus('mandatory')
if mibBuilder.loadTexts: faultCurrentAlarmDescription.setDescription("A readable string which describes the alarm. Its format is as follows: <Level> <Card> <Port> <Alarm Type> <Time Occured> 'Level' is the alarm severity. Its value can be 'Info', 'Major', or 'Minor'. 'Card' refers to where the alarm was generated. Its value can be 'HSDP', 'ENET', 'TRING', or 'DS1'. 'Port' refers to which port generated the alarm. Its value can be 1 to 7 for DS1 and 'empty' if no port number can be used for an alarm. 'Alarm Type' is an ASCII string of the alarm type. 'Time Occured' is the time when the alarm was generated. ")
faultHistoryAlarmTable = MibTable((1, 3, 6, 1, 4, 1, 135, 22, 3, 6), )
if mibBuilder.loadTexts: faultHistoryAlarmTable.setStatus('mandatory')
if mibBuilder.loadTexts: faultHistoryAlarmTable.setDescription('History/Information alarm table.')
faultHistoryAlarmEntry = MibTableRow((1, 3, 6, 1, 4, 1, 135, 22, 3, 6, 1), ).setIndexNames((0, "LX-10-MIB", "faultHistoryAlarmTag"))
if mibBuilder.loadTexts: faultHistoryAlarmEntry.setStatus('mandatory')
if mibBuilder.loadTexts: faultHistoryAlarmEntry.setDescription('Each entry in the history alarm table contains either a cleared alarm or an information alarm.')
faultHistoryAlarmTag = MibTableColumn((1, 3, 6, 1, 4, 1, 135, 22, 3, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: faultHistoryAlarmTag.setStatus('mandatory')
if mibBuilder.loadTexts: faultHistoryAlarmTag.setDescription('The tag of the alarm in the history alarm table.')
faultHistoryAlarmAlarmType = MibTableColumn((1, 3, 6, 1, 4, 1, 135, 22, 3, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77))).clone(namedValues=NamedValues(("ds1-net-card-lpbk", 1), ("ds1-net-line-lpbk", 2), ("la-lb-dte-lpbk", 3), ("la-lb-local-lpbk", 4), ("la-lb-remote-lpbk", 5), ("remote-line-lpbk", 6), ("dte-lpbk", 7), ("customer-lpbk", 8), ("dte-clk-loss", 9), ("hsdc-ga-oof", 10), ("pll-fail", 11), ("card-fail", 12), ("ds1-los", 13), ("ds1-oof", 14), ("ds1-ais", 15), ("ds1-yel", 16), ("fan1-failed", 17), ("fan2-failed", 18), ("trunk-card-config-mismatch", 19), ("cim-card-config-mismatch", 20), ("cpu-restarted", 21), ("port-alarms-cleared", 22), ("all-alarms-cleared", 23), ("ds1-afa-alarm", 24), ("alarm-history-cleared", 25), ("p1-connected-to-p2", 26), ("p1-connected-to-p3", 27), ("p1-connected-to-p4", 28), ("p1-connected-to-p5", 29), ("p1-connected-to-p6", 30), ("p1-connected-to-p7", 31), ("p2-connected-to-p1", 32), ("p2-connected-to-p3", 33), ("p2-connected-to-p4", 34), ("p2-connected-to-p5", 35), ("p2-connected-to-p6", 36), ("p2-connected-to-p7", 37), ("p3-connected-to-p1", 38), ("p3-connected-to-p2", 39), ("p3-connected-to-p4", 40), ("p3-connected-to-p5", 41), ("p3-connected-to-p6", 42), ("p3-connected-to-p7", 43), ("p4-connected-to-p1", 44), ("p4-connected-to-p2", 45), ("p4-connected-to-p3", 46), ("p4-connected-to-p5", 47), ("p4-connected-to-p6", 48), ("p4-connected-to-p7", 49), ("p5-connected-to-p1", 50), ("p5-connected-to-p2", 51), ("p5-connected-to-p3", 52), ("p5-connected-to-p4", 53), ("p5-connected-to-p6", 54), ("p5-connected-to-p7", 55), ("p6-connected-to-p1", 56), ("p6-connected-to-p2", 57), ("p6-connected-to-p3", 58), ("p6-connected-to-p4", 59), ("p6-connected-to-p5", 60), ("p6-connected-to-p7", 61), ("p7-connected-to-p1", 62), ("p7-connected-to-p2", 63), ("p7-connected-to-p3", 64), ("p7-connected-to-p4", 65), ("p7-connected-to-p5", 66), ("p7-connected-to-p6", 67), ("alarm1-in", 68), ("alarm2-in", 69), ("alarm3-in", 70), ("hdlc-unlocked", 71), ("far-end-loopback", 72), ("remote-afa", 73), ("att-fdl-loopback", 74), ("inband-loopback", 75), ("t1-link-down", 76), ("ports-out-of-sequence", 77)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: faultHistoryAlarmAlarmType.setStatus('mandatory')
if mibBuilder.loadTexts: faultHistoryAlarmAlarmType.setDescription('The alarm type of the alarm.')
faultHistoryAlarmSeverity = MibTableColumn((1, 3, 6, 1, 4, 1, 135, 22, 3, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("info", 1), ("minor", 2), ("major", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: faultHistoryAlarmSeverity.setStatus('mandatory')
if mibBuilder.loadTexts: faultHistoryAlarmSeverity.setDescription('The severity of the alarm. Its value can be either major or minor for DS1 ports and info for others.')
faultHistoryAlarmCardType = MibTableColumn((1, 3, 6, 1, 4, 1, 135, 22, 3, 6, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("hsdp", 1), ("ethernet", 2), ("token-ring", 3), ("ds1", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: faultHistoryAlarmCardType.setStatus('mandatory')
if mibBuilder.loadTexts: faultHistoryAlarmCardType.setDescription('The type of the card which caused the alarm.')
faultHistoryAlarmPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 135, 22, 3, 6, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: faultHistoryAlarmPortNumber.setStatus('mandatory')
if mibBuilder.loadTexts: faultHistoryAlarmPortNumber.setDescription('The port number of the card which caused the alarm. Its value is between 1 and 7 for DS1 ports and 0 for others.')
faultHistoryAlarmSetTime = MibTableColumn((1, 3, 6, 1, 4, 1, 135, 22, 3, 6, 1, 6), TimeAndDate()).setMaxAccess("readonly")
if mibBuilder.loadTexts: faultHistoryAlarmSetTime.setStatus('mandatory')
if mibBuilder.loadTexts: faultHistoryAlarmSetTime.setDescription('The time when the alarm was set.')
faultHistoryAlarmClearTime = MibTableColumn((1, 3, 6, 1, 4, 1, 135, 22, 3, 6, 1, 7), TimeAndDate()).setMaxAccess("readonly")
if mibBuilder.loadTexts: faultHistoryAlarmClearTime.setStatus('mandatory')
if mibBuilder.loadTexts: faultHistoryAlarmClearTime.setDescription('The time when the alarm was cleared.')
faultHistoryAlarmDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 135, 22, 3, 6, 1, 8), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: faultHistoryAlarmDescription.setStatus('mandatory')
if mibBuilder.loadTexts: faultHistoryAlarmDescription.setDescription("A readable string which describes the alarm. Its format is as follows: <Level> <Card> <Port> <Alarm Type> <Time Occured> <Time Cleared> 'Level' is the alarm severity. Its value can be 'Info', 'Major', or 'Minor'. 'Card' refers to where the alarm was generated. Its value can be 'HSDP', 'ENET', 'TRING', or 'DS1'. 'Port' refers to which port generated the alarm. Its value can be 1 to 7 for DS1 and 'empty' if no port number can be used for an alarm. 'Alarm Type' is an ASCII string of the alarm type. 'Time Occured' is the time when the alarm was generated. 'Time Cleared' is the time when the alarm was cleared. ")
perfClearDs1Performance = MibScalar((1, 3, 6, 1, 4, 1, 135, 22, 4, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: perfClearDs1Performance.setStatus('mandatory')
if mibBuilder.loadTexts: perfClearDs1Performance.setDescription('A set request clears all DS1 performance monitoring data. A get/get-next request returns 0.')
perfClearEnetPortCardStats = MibScalar((1, 3, 6, 1, 4, 1, 135, 22, 4, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: perfClearEnetPortCardStats.setStatus('mandatory')
if mibBuilder.loadTexts: perfClearEnetPortCardStats.setDescription('A set request clears all ethernet port card statistics. A get/get-next request returns 0.')
enetPortCardStats = MibIdentifier((1, 3, 6, 1, 4, 1, 135, 22, 4, 3))
enetPortCardStatsFramesReceived = MibScalar((1, 3, 6, 1, 4, 1, 135, 22, 4, 3, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: enetPortCardStatsFramesReceived.setStatus('mandatory')
if mibBuilder.loadTexts: enetPortCardStatsFramesReceived.setDescription('A count of frames received by the ethernet port card.')
enetPortCardStatsBytesReceived = MibScalar((1, 3, 6, 1, 4, 1, 135, 22, 4, 3, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: enetPortCardStatsBytesReceived.setStatus('mandatory')
if mibBuilder.loadTexts: enetPortCardStatsBytesReceived.setDescription('A count of bytes received by the ethernet port card.')
enetPortCardStatsFramesTransmitted = MibScalar((1, 3, 6, 1, 4, 1, 135, 22, 4, 3, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: enetPortCardStatsFramesTransmitted.setStatus('mandatory')
if mibBuilder.loadTexts: enetPortCardStatsFramesTransmitted.setDescription('A count of frames transmitted on the ethernet port card.')
enetPortCardStatsBytesTransmitted = MibScalar((1, 3, 6, 1, 4, 1, 135, 22, 4, 3, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: enetPortCardStatsBytesTransmitted.setStatus('mandatory')
if mibBuilder.loadTexts: enetPortCardStatsBytesTransmitted.setDescription('A count of bytes transmitted on the ethernet port card.')
enetPortCardStatsAlignmentErrors = MibScalar((1, 3, 6, 1, 4, 1, 135, 22, 4, 3, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: enetPortCardStatsAlignmentErrors.setReference('IEEE 802.3 Layer Management')
if mibBuilder.loadTexts: enetPortCardStatsAlignmentErrors.setStatus('mandatory')
if mibBuilder.loadTexts: enetPortCardStatsAlignmentErrors.setDescription('A count of frames received that are not an integral number of octets in length and do not pass the FCS check. The count represented by an instance of this object is incremented when the alignmentError status is returned by the MAC service to the LLC (or other MAC user). Received frames for which multiple error conditions obtain are, according to the conventions of IEEE 802.3 Layer Management, counted exclusively according to the error status presented to the LLC.')
enetPortCardStatsFCSErrors = MibScalar((1, 3, 6, 1, 4, 1, 135, 22, 4, 3, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: enetPortCardStatsFCSErrors.setReference('IEEE 802.3 Layer Management')
if mibBuilder.loadTexts: enetPortCardStatsFCSErrors.setStatus('mandatory')
if mibBuilder.loadTexts: enetPortCardStatsFCSErrors.setDescription('A count of frames received that are an integral number of octets in length but do not pass the FCS check. The count represented by an instance of this object is incremented when the frameCheckError status is returned by the MAC service to the LLC (or other MAC user). Received frames for which multiple error conditions obtain are, according to the conventions of IEEE 802.3 Layer Management, counted exclusively according to the error status presented to the LLC.')
enetPortCardStatsSingleCollisionFrames = MibScalar((1, 3, 6, 1, 4, 1, 135, 22, 4, 3, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: enetPortCardStatsSingleCollisionFrames.setReference('IEEE 802.3 Layer Management')
if mibBuilder.loadTexts: enetPortCardStatsSingleCollisionFrames.setStatus('mandatory')
if mibBuilder.loadTexts: enetPortCardStatsSingleCollisionFrames.setDescription('A count of successfully transmitted frames for which transmission is inhibited by exactly one collision. A frame that is counted by an instance of this object is not counted by the corresponding instance of the enetPortCardStatsMultipleCollisionFrames object.')
enetPortCardStatsMultipleCollisionFrames = MibScalar((1, 3, 6, 1, 4, 1, 135, 22, 4, 3, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: enetPortCardStatsMultipleCollisionFrames.setReference('IEEE 802.3 Layer Management')
if mibBuilder.loadTexts: enetPortCardStatsMultipleCollisionFrames.setStatus('mandatory')
if mibBuilder.loadTexts: enetPortCardStatsMultipleCollisionFrames.setDescription('A count of successfully transmitted frames for which transmission is inhibited by more than one collision. A frame that is counted by an instance of this object is not counted by the corresponding instance of the enetPortCardStatsSingleCollisionFrames object.')
enetPortCardStatsDeferredTransmissions = MibScalar((1, 3, 6, 1, 4, 1, 135, 22, 4, 3, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: enetPortCardStatsDeferredTransmissions.setReference('IEEE 802.3 Layer Management')
if mibBuilder.loadTexts: enetPortCardStatsDeferredTransmissions.setStatus('mandatory')
if mibBuilder.loadTexts: enetPortCardStatsDeferredTransmissions.setDescription('A count of frames for which the first transmission attempt is delayed because the medium is busy. The count represented by an instance of this object does not include frames involved in collisions.')
enetPortCardStatsLateCollisions = MibScalar((1, 3, 6, 1, 4, 1, 135, 22, 4, 3, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: enetPortCardStatsLateCollisions.setReference('IEEE 802.3 Layer Management')
if mibBuilder.loadTexts: enetPortCardStatsLateCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: enetPortCardStatsLateCollisions.setDescription('The number of times that a collision is detected on later than 512 bit-times into the transmission of a packet. Five hundred and twelve bit-times corresponds to 51.2 microseconds on a 10 Mbit/s system. A (late) collision included in a count represented by an instance of this object is also considered as a (generic) collision for purposes of other collision-related statistics.')
enetPortCardStatsExcessiveCollisions = MibScalar((1, 3, 6, 1, 4, 1, 135, 22, 4, 3, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: enetPortCardStatsExcessiveCollisions.setReference('IEEE 802.3 Layer Management')
if mibBuilder.loadTexts: enetPortCardStatsExcessiveCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: enetPortCardStatsExcessiveCollisions.setDescription('A count of frames for which transmission fails due to excessive collisions.')
enetPortCardStatsInternalMacTransmitErrors = MibScalar((1, 3, 6, 1, 4, 1, 135, 22, 4, 3, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: enetPortCardStatsInternalMacTransmitErrors.setReference('IEEE 802.3 Layer Management')
if mibBuilder.loadTexts: enetPortCardStatsInternalMacTransmitErrors.setStatus('mandatory')
if mibBuilder.loadTexts: enetPortCardStatsInternalMacTransmitErrors.setDescription('A count of frames for which transmission fails due to an internal MAC sublayer transmit error. A frame is only counted by an instance of this object if it is not counted by the corresponding instance of either the enetPortCardStatsLateCollisions object, the enetPortCardStatsExcessiveCollisions object, or the enetPortCardStatsCarrierSenseErrors object. The precise meaning of the count represented by an instance of this object is implementation- specific. In particular, an instance of this object may represent a count of transmission errors that are not otherwise counted.')
enetPortCardStatsCarrierSenseErrors = MibScalar((1, 3, 6, 1, 4, 1, 135, 22, 4, 3, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: enetPortCardStatsCarrierSenseErrors.setReference('IEEE 802.3 Layer Management')
if mibBuilder.loadTexts: enetPortCardStatsCarrierSenseErrors.setStatus('mandatory')
if mibBuilder.loadTexts: enetPortCardStatsCarrierSenseErrors.setDescription('The number of times that the carrier sense condition was lost or never asserted when attempting to transmit a frame. The count represented by an instance of this object is incremented at most once per transmission attempt, even if the carrier sense condition fluctuates during a transmission attempt.')
enetPortCardStatsFrameTooLongs = MibScalar((1, 3, 6, 1, 4, 1, 135, 22, 4, 3, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: enetPortCardStatsFrameTooLongs.setReference('IEEE 802.3 Layer Management')
if mibBuilder.loadTexts: enetPortCardStatsFrameTooLongs.setStatus('mandatory')
if mibBuilder.loadTexts: enetPortCardStatsFrameTooLongs.setDescription('A count of frames received that exceed the maximum permitted frame size. The count represented by an instance of this object is incremented when the frameTooLong status is returned by the MAC service to the LLC (or other MAC user). Received frames for which multiple error conditions obtain are, according to the conventions of IEEE 802.3 Layer Management, counted exclusively according to the error status presented to the LLC.')
perfClearNxT1PortStats = MibScalar((1, 3, 6, 1, 4, 1, 135, 22, 4, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: perfClearNxT1PortStats.setStatus('mandatory')
if mibBuilder.loadTexts: perfClearNxT1PortStats.setDescription('A set request clears all nxt1 port statistics. A get/get-next request returns 0.')
nxt1PortStats = MibIdentifier((1, 3, 6, 1, 4, 1, 135, 22, 4, 5))
nxt1PortStatsFramesReceived = MibScalar((1, 3, 6, 1, 4, 1, 135, 22, 4, 5, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nxt1PortStatsFramesReceived.setStatus('mandatory')
if mibBuilder.loadTexts: nxt1PortStatsFramesReceived.setDescription('A count of frames received by the NxT1 port.')
nxt1PortStatsBytesReceived = MibScalar((1, 3, 6, 1, 4, 1, 135, 22, 4, 5, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nxt1PortStatsBytesReceived.setStatus('mandatory')
if mibBuilder.loadTexts: nxt1PortStatsBytesReceived.setDescription('A count of bytes received by the NxT1 port.')
nxt1PortStatsFramesTransmitted = MibScalar((1, 3, 6, 1, 4, 1, 135, 22, 4, 5, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nxt1PortStatsFramesTransmitted.setStatus('mandatory')
if mibBuilder.loadTexts: nxt1PortStatsFramesTransmitted.setDescription('A count of frames transmitted on the NxT1 port.')
nxt1PortStatsBytesTransmitted = MibScalar((1, 3, 6, 1, 4, 1, 135, 22, 4, 5, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nxt1PortStatsBytesTransmitted.setStatus('mandatory')
if mibBuilder.loadTexts: nxt1PortStatsBytesTransmitted.setDescription('A count of bytes transmitted on the NxT1 port.')
nxt1PortStatsCrcErrors = MibScalar((1, 3, 6, 1, 4, 1, 135, 22, 4, 5, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nxt1PortStatsCrcErrors.setStatus('mandatory')
if mibBuilder.loadTexts: nxt1PortStatsCrcErrors.setDescription('A count of frames received by the NxT1 port that do not pass the CRC check.')
alarmOnReport = NotificationType((1, 3, 6, 1, 4, 1, 135, 22) + (0,1)).setObjects(("LX-10-MIB", "faultCurrentAlarmAlarmType"), ("LX-10-MIB", "faultCurrentAlarmSeverity"), ("LX-10-MIB", "faultCurrentAlarmCardType"), ("LX-10-MIB", "faultCurrentAlarmPortNumber"), ("LX-10-MIB", "faultCurrentAlarmSetTime"), ("LX-10-MIB", "faultCurrentAlarmDescription"))
if mibBuilder.loadTexts: alarmOnReport.setDescription('LX-10-specific trap sent by the managed node when an alarm condition is set.')
alarmOffReport = NotificationType((1, 3, 6, 1, 4, 1, 135, 22) + (0,2)).setObjects(("LX-10-MIB", "faultHistoryAlarmAlarmType"), ("LX-10-MIB", "faultHistoryAlarmSeverity"), ("LX-10-MIB", "faultHistoryAlarmCardType"), ("LX-10-MIB", "faultHistoryAlarmPortNumber"), ("LX-10-MIB", "faultHistoryAlarmSetTime"), ("LX-10-MIB", "faultHistoryAlarmClearTime"), ("LX-10-MIB", "faultHistoryAlarmDescription"))
if mibBuilder.loadTexts: alarmOffReport.setDescription('LX-10-specific trap sent by the managed node when an alarm condition is cleared.')
mibBuilder.exportSymbols("LX-10-MIB", sysRs232DataBits=sysRs232DataBits, faultDte=faultDte, alarmOffReport=alarmOffReport, sysIpConfigTrapClientSubnetMask=sysIpConfigTrapClientSubnetMask, enetPortCardStatsSingleCollisionFrames=enetPortCardStatsSingleCollisionFrames, faultCurrentAlarmCardType=faultCurrentAlarmCardType, configHsdpCtsStatus=configHsdpCtsStatus, sysIpConfigTrapClientTable=sysIpConfigTrapClientTable, configAfaDeactivationRate=configAfaDeactivationRate, faultClearHistoryAlarms=faultClearHistoryAlarms, faultDteLaLbLoopbackEnable=faultDteLaLbLoopbackEnable, enetPortCardStatsCarrierSenseErrors=enetPortCardStatsCarrierSenseErrors, sysIpConfigDefaultGatewayIpAddress=sysIpConfigDefaultGatewayIpAddress, configHsdpMode=configHsdpMode, faultClearCurrentAlarms=faultClearCurrentAlarms, faultDteLbLead=faultDteLbLead, sys=sys, enetPortCardStatsExcessiveCollisions=enetPortCardStatsExcessiveCollisions, faultHistoryAlarmClearTime=faultHistoryAlarmClearTime, sysGenInfoPhoneNumber=sysGenInfoPhoneNumber, faultDteDteLoopback=faultDteDteLoopback, faultCurrentAlarmTag=faultCurrentAlarmTag, enetPortCardStats=enetPortCardStats, lx_10=lx_10, perfClearNxT1PortStats=perfClearNxT1PortStats, configDs1Table=configDs1Table, faultCurrentAlarmEntry=faultCurrentAlarmEntry, enetPortCardStatsBytesReceived=enetPortCardStatsBytesReceived, configAfaFarEndLpbkDetect=configAfaFarEndLpbkDetect, configHdlcFarEndPort=configHdlcFarEndPort, configDs1Entry=configDs1Entry, faultHistoryAlarmPortNumber=faultHistoryAlarmPortNumber, configAfaActivationRate=configAfaActivationRate, faultCurrentAlarmAlarmType=faultCurrentAlarmAlarmType, sysIpConfigHostInterfaceIpAddress=sysIpConfigHostInterfaceIpAddress, sysRs232Table=sysRs232Table, faultHistoryAlarmSetTime=faultHistoryAlarmSetTime, sysGenInfo=sysGenInfo, enetPortCardStatsBytesTransmitted=enetPortCardStatsBytesTransmitted, config=config, configHsdpHoldoffSeconds=configHsdpHoldoffSeconds, faultCurrentAlarmSetTime=faultCurrentAlarmSetTime, configDs1AdminStatus=configDs1AdminStatus, enetPortCardStatsLateCollisions=enetPortCardStatsLateCollisions, configDs1Framing=configDs1Framing, nxt1PortStatsFramesTransmitted=nxt1PortStatsFramesTransmitted, configDs1Port=configDs1Port, enetPortCardStatsFramesTransmitted=enetPortCardStatsFramesTransmitted, onstream=onstream, sysGenInfoMaintenanceContact=sysGenInfoMaintenanceContact, configDs1Timing=configDs1Timing, faultHistoryAlarmAlarmType=faultHistoryAlarmAlarmType, sysIpConfigCommunityName=sysIpConfigCommunityName, configAfaStatus=configAfaStatus, enetPortCardStatsDeferredTransmissions=enetPortCardStatsDeferredTransmissions, configHdlcLocalPort=configHdlcLocalPort, faultDteCustomerLoopback=faultDteCustomerLoopback, sysIpConfigTrapClientIndex=sysIpConfigTrapClientIndex, faultHistoryAlarmSeverity=faultHistoryAlarmSeverity, sysMainProcessorFirmwareRev=sysMainProcessorFirmwareRev, faultCurrentAlarmTable=faultCurrentAlarmTable, faultDs1LoopbackPort=faultDs1LoopbackPort, faultHistoryAlarmTag=faultHistoryAlarmTag, sysIpConfigHostInterfaceXmtRoutingMsg=sysIpConfigHostInterfaceXmtRoutingMsg, faultDteLaLead=faultDteLaLead, faultDteLaLbTranslation=faultDteLaLbTranslation, configAfaActivationTime=configAfaActivationTime, nxt1PortStatsFramesReceived=nxt1PortStatsFramesReceived, configDs1XmtAis=configDs1XmtAis, configAfaDeactivationTime=configAfaDeactivationTime, enetPortCardStatsMultipleCollisionFrames=enetPortCardStatsMultipleCollisionFrames, faultHistoryAlarmEntry=faultHistoryAlarmEntry, sysIpConfigHostInterfaceTable=sysIpConfigHostInterfaceTable, sysIpConfigHostInterfaceEntry=sysIpConfigHostInterfaceEntry, sysIpConfigTrapClientEntry=sysIpConfigTrapClientEntry, configHdlcMode=configHdlcMode, TimeAndDate=TimeAndDate, sysGenInfoPassword=sysGenInfoPassword, configHsdp=configHsdp, sysRs232BaudRate=sysRs232BaudRate, enetPortCardStatsAlignmentErrors=enetPortCardStatsAlignmentErrors, nxt1PortStatsCrcErrors=nxt1PortStatsCrcErrors, sysPortCardFirmwareRev=sysPortCardFirmwareRev, faultHistoryAlarmDescription=faultHistoryAlarmDescription, sysGenInfoAutoLogoutTime=sysGenInfoAutoLogoutTime, nxt1PortStats=nxt1PortStats, faultDs1RemoteLineLoopback=faultDs1RemoteLineLoopback, sysIpConfigDefaultGateway=sysIpConfigDefaultGateway, sysRs232Port=sysRs232Port, sysIpConfigTrapClientIpAddress=sysIpConfigTrapClientIpAddress, faultCurrentAlarmSeverity=faultCurrentAlarmSeverity, faultHistoryAlarmCardType=faultHistoryAlarmCardType, sysIpConfigHostInterfaceSubnetMask=sysIpConfigHostInterfaceSubnetMask, sysGenInfoShelfName=sysGenInfoShelfName, perfClearEnetPortCardStats=perfClearEnetPortCardStats, configDs1Encoding=configDs1Encoding, enetPortCardStatsFramesReceived=enetPortCardStatsFramesReceived, configInverseMux=configInverseMux, configHsdpCtsControl=configHsdpCtsControl, sysGenInfoShelfId=sysGenInfoShelfId, alarmOnReport=alarmOnReport, configPortCardType=configPortCardType, fault=fault, configDs1LBO=configDs1LBO, sysIpConfigHostInterfaceIndex=sysIpConfigHostInterfaceIndex, faultCurrentAlarmPortNumber=faultCurrentAlarmPortNumber, sysGenInfoCustomerName=sysGenInfoCustomerName, configHsdpTermTimingSource=configHsdpTermTimingSource, enetPortCardStatsFrameTooLongs=enetPortCardStatsFrameTooLongs, nxt1PortStatsBytesReceived=nxt1PortStatsBytesReceived, perf=perf, nxt1PortStatsBytesTransmitted=nxt1PortStatsBytesTransmitted, enetPortCardStatsFCSErrors=enetPortCardStatsFCSErrors, faultHistoryAlarmTable=faultHistoryAlarmTable, sysTimeAndDate=sysTimeAndDate, sysIpConfigDefaultGatewaySubnetMask=sysIpConfigDefaultGatewaySubnetMask, configHsdpRecvTiming=configHsdpRecvTiming, configAfa=configAfa, sysRs232Entry=sysRs232Entry, faultDs1LoopbackTable=faultDs1LoopbackTable, enetPortCardStatsInternalMacTransmitErrors=enetPortCardStatsInternalMacTransmitErrors, configDs1OperStatus=configDs1OperStatus, faultCurrentAlarmDescription=faultCurrentAlarmDescription, perfClearDs1Performance=perfClearDs1Performance, faultDs1=faultDs1, sysIpConfigMacAddress=sysIpConfigMacAddress, faultDs1LoopbackEntry=faultDs1LoopbackEntry, sysIpConfig=sysIpConfig, sysRs232Parity=sysRs232Parity, configHsdpTermTiming=configHsdpTermTiming, faultDs1LoopbackNetworkLoopback=faultDs1LoopbackNetworkLoopback, configHdlc=configHdlc, sysRs232StopBits=sysRs232StopBits, sysGenInfoLocation=sysGenInfoLocation, sysIpConfigTrapClientPortNumber=sysIpConfigTrapClientPortNumber)

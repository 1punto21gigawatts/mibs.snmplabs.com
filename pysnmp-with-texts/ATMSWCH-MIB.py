#
# PySNMP MIB module ATMSWCH-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/ATMSWCH-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:31:41 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, SingleValueConstraint, ValueRangeConstraint, ConstraintsUnion, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "SingleValueConstraint", "ValueRangeConstraint", "ConstraintsUnion", "ConstraintsIntersection")
lannet, = mibBuilder.importSymbols("GEN-MIB", "lannet")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Gauge32, Unsigned32, Integer32, ObjectIdentity, Bits, TimeTicks, Counter32, ModuleIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, IpAddress, MibIdentifier, NotificationType, iso, Counter64 = mibBuilder.importSymbols("SNMPv2-SMI", "Gauge32", "Unsigned32", "Integer32", "ObjectIdentity", "Bits", "TimeTicks", "Counter32", "ModuleIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "IpAddress", "MibIdentifier", "NotificationType", "iso", "Counter64")
DisplayString, RowStatus, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "RowStatus", "TextualConvention")
class AtmAddress(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(20, 20)
    fixedLength = 20

class AtmPrefix(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(13, 13)
    fixedLength = 13

atmSwch = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 33))
atmSwchBase = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 33, 1))
atmSwchCpu = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 33, 2))
atmSwchSlot = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 33, 5))
atmSwchPort = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 33, 6))
atmSwchVPort = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 33, 7))
atmSwchSlotRoute = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 33, 8))
atmSwchSlotAddrVcl = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 33, 9))
atmSwchBaseCurrentPrefix = MibScalar((1, 3, 6, 1, 4, 1, 81, 33, 1, 1), AtmPrefix()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSwchBaseCurrentPrefix.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchBaseCurrentPrefix.setDescription('The ATM prefix currently in use for the switch.')
atmSwchBaseConfigPrefix = MibScalar((1, 3, 6, 1, 4, 1, 81, 33, 1, 2), AtmPrefix()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSwchBaseConfigPrefix.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchBaseConfigPrefix.setDescription('The ATM prefix to be used at the next reboot.')
atmSwchBaseEpdThreshold = MibScalar((1, 3, 6, 1, 4, 1, 81, 33, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(50, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSwchBaseEpdThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchBaseEpdThreshold.setDescription('The percentage of the maximum buffer allocation used in the switch fabric before EPD is invoked. Default is 80%.')
atmSwchBaseAmonAdminState = MibScalar((1, 3, 6, 1, 4, 1, 81, 33, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSwchBaseAmonAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchBaseAmonAdminState.setDescription('This enable or disable the AMON statistics gathering in the switch. For Some applications, like Host Statistics, you also need to create a Control Table in order to start the statistics gathering')
atmSwchCpuTable = MibTable((1, 3, 6, 1, 4, 1, 81, 33, 2, 1), )
if mibBuilder.loadTexts: atmSwchCpuTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchCpuTable.setDescription(' A table containing information about each CPU in the hub ')
atmSwchCpuEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 33, 2, 1, 1), ).setIndexNames((0, "ATMSWCH-MIB", "atmSwchCpuIndex"))
if mibBuilder.loadTexts: atmSwchCpuEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchCpuEntry.setDescription(' An entry containing information about a particular CPU in the hub ')
atmSwchCpuIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSwchCpuIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchCpuIndex.setDescription('Index into this table.')
atmSwchCpuHwVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 2, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(3, 3)).setFixedLength(3)).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSwchCpuHwVersion.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchCpuHwVersion.setDescription('CPU Hardware version. Stored in the format :- first Byte - hardware major version number - hardware minor version number last Byte - hardware debug version number.')
atmSwchCpuSoftErrCode = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 2, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSwchCpuSoftErrCode.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchCpuSoftErrCode.setDescription(' Software Error Code. This variable contain a copy of the error code of the last event to have a trap sent.')
atmSwchCpuSoftErrString = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 2, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSwchCpuSoftErrString.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchCpuSoftErrString.setDescription(' Software Error Description. This variable contain a copy of the error string of the last event to have a trap sent.')
atmSwchCpuUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSwchCpuUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchCpuUtilization.setDescription('An estimate of the current CPU utilization in one-hundredths of a percent.')
atmSwchCpuRamSize = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 2, 1, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSwchCpuRamSize.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchCpuRamSize.setDescription('DRAM plus SIMM size on the processor board, in bytes')
atmSwchCpuRamUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 2, 1, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSwchCpuRamUsed.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchCpuRamUsed.setDescription('An estimate of the amount of DRAM plus SIMM currently in use, in bytes.')
atmSwchCpuFlashSize = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 2, 1, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSwchCpuFlashSize.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchCpuFlashSize.setDescription('Flash memory size, in bytes.')
atmSwchCpuFlashUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 2, 1, 1, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSwchCpuFlashUsed.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchCpuFlashUsed.setDescription('Flash memory used, in bytes.')
atmSwchCpuEepromSize = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 2, 1, 1, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSwchCpuEepromSize.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchCpuEepromSize.setDescription('EEPROM memory size, in bytes.')
atmSwchCpuEepromUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 2, 1, 1, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSwchCpuEepromUsed.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchCpuEepromUsed.setDescription('EEPROM memory used, in bytes.')
atmSwchCpuTime = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 2, 1, 1, 12), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSwchCpuTime.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchCpuTime.setDescription('Host time measured in seconds since midnight, 1st January, 1970.')
atmSwchCpuSysUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 2, 1, 1, 13), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSwchCpuSysUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchCpuSysUpTime.setDescription('The time (in hundredths of a second) since the network management portion of the module was last re-initialized. This is like the MIB-2 sysUpTime but for a specific module. In the Master Agent it should be equal to sysUpTime')
atmSwchCpuSvcPtPtInConns = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 2, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSwchCpuSvcPtPtInConns.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchCpuSvcPtPtInConns.setDescription('The number of switched virtual point to point connections through this port, where this port is the point of entry for the call setup.')
atmSwchCpuSvcPtPtOutConns = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 2, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSwchCpuSvcPtPtOutConns.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchCpuSvcPtPtOutConns.setDescription('The number of switched virtual point to point connections through this port, where this port is the point of exit for the call setup.')
atmSwchCpuSvcPtMptRootConns = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 2, 1, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSwchCpuSvcPtMptRootConns.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchCpuSvcPtMptRootConns.setDescription('The number of switched virtual point to multipoint connections through this port, where this port is the point of entry for the call setup.')
atmSwchCpuSvcPtMptLeafConns = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 2, 1, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSwchCpuSvcPtMptLeafConns.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchCpuSvcPtMptLeafConns.setDescription('The number of switched virtual point to multipoint connections through this port, where this port is the point of exit for the call setup.')
atmSwchCpuPvcPtPtConns = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 2, 1, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSwchCpuPvcPtPtConns.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchCpuPvcPtPtConns.setDescription('The number of permanent virtual point to point connections through this port.')
atmSwchSlotTable = MibTable((1, 3, 6, 1, 4, 1, 81, 33, 5, 1), )
if mibBuilder.loadTexts: atmSwchSlotTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchSlotTable.setDescription('A table containing information about each slot in the switch.')
atmSwchSlotEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 33, 5, 1, 1), ).setIndexNames((0, "ATMSWCH-MIB", "atmSwchSlotIndex"))
if mibBuilder.loadTexts: atmSwchSlotEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchSlotEntry.setDescription('An entry containing information about a particular slot in the switch.')
atmSwchSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 5, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSwchSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchSlotIndex.setDescription('Index into this table, by slot number.')
atmSwchSlotRxCellDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 5, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSwchSlotRxCellDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchSlotRxCellDiscards.setDescription('cell discard counter for the Rx path (line to switch).')
atmSwchSlotRouteNextId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 5, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSwchSlotRouteNextId.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchSlotRouteNextId.setDescription('The next available Route index in this Slot. The value of this object can be used as the index by the network manager to create an entry in the atmSwchSlotRouteTable.')
atmSwchSlotAPSMode = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 5, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("uniDirectionalNonRevertive", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSwchSlotAPSMode.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchSlotAPSMode.setDescription('The operation mode of APS. Uni-directional: The uni-directional mode provides protection in one direction. Non-revertive: When the condition that caused a switch to the protection line has been cleared, a non-revertive system remains on the Protection line until another switch request is received. ')
atmSwchSlotAPSCurrentState = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 5, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("noRequest", 1), ("sf", 2), ("sd", 3), ("forcedSwitch", 4), ("manualSwitch", 5), ("doNotRevert", 6), ("noAPS", 7), ("notActive", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSwchSlotAPSCurrentState.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchSlotAPSCurrentState.setDescription('Current state of APS. Sd A signal degrade condition is in effect. Sf A signal failure condition is in effect. Forced switched The current APS transmitting link is a result of a forced switched command Manual Switched The current APS transmitting link is a result of a manual switched command. DoNotRevert Working channel repaired. NoAPS Protection line is not available. notActive No available channels.')
atmSwchSlotAPSSwitchCommand = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 5, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("noCmd", 1), ("clear", 2), ("forcedSwitchWorkToProtect", 3), ("forcedSwitchProtectToWork", 4), ("manualSwitchWorkToProtect", 5), ("manualSwitchProtectToWork", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSwchSlotAPSSwitchCommand.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchSlotAPSSwitchCommand.setDescription('Allows the initiation of an APS switch command. The Switch command values are: noCmd(1) This value should be returned by a read request when no switch Command has been written to APS since the last Non-Volatile Memory reset. This value may not be used in a write operation. clear(2) Clears all of the switch commands listed below. forcedSwitchWorkToProtect(3) Switches from the working link to the protection link. This command has higher priority over the manual switch commands. forcedSwitchProtectToWork(5) Switches from the protection link to the working link. This command has higher priority over the manual switch commands. manualSwitchWorkToProtect(6) Switches the working link to the protection link. manualSwitchProtectToWork(7) Switches from the protection link to the working link. When read this object returns the last command written or noCmd(1) if no command has been written since the last Non-Volatile Memory reset. The return of the last command written does not imply that this command is currently in effect. This request may have been preempted by a higher priority local or remote request. In order to determine the current state of the APS group it is necessary to read the object atmSwchSlotAPSCurrentState. ')
atmSwchSlotAPSSFBerThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 5, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 9))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSwchSlotAPSSFBerThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchSlotAPSSFBerThreshold.setDescription('The Signal Failure Bit Error Rate. The negated value of this number is used as the exponent of 10 for computing the threshold value for the Bit Error Rate (BER). For example, a value of 5 indicates a BER threshold of 10^-5. Default value is 5.')
atmSwchSlotAPSSDBerThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 5, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 9))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSwchSlotAPSSDBerThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchSlotAPSSDBerThreshold.setDescription('The Signal Degrade Bit Error Rate. The negated value of this number is used as the exponent of 10 for computing the threshold value for the Bit Error Rate (BER). For example, a value of 5 indicates a BER threshold of 10^-5. Default value is 5. ')
atmSwchSlotAPSDecision = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 5, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("working", 1), ("protection", 2), ("not-Active", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSwchSlotAPSDecision.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchSlotAPSDecision.setDescription(' APS Decision. The receiving link can be either the working link or the protection link. When both links are down, Not-active value is returned.')
atmSwchPortTable = MibTable((1, 3, 6, 1, 4, 1, 81, 33, 6, 1), )
if mibBuilder.loadTexts: atmSwchPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchPortTable.setDescription('A table containing information about all the physical ports on the switch. Indexed on atmSwchSlotIndex and atmSwchPortIndex.')
atmSwchPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 33, 6, 1, 1), ).setIndexNames((0, "ATMSWCH-MIB", "atmSwchSlotIndex"), (0, "ATMSWCH-MIB", "atmSwchPortIndex"))
if mibBuilder.loadTexts: atmSwchPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchPortEntry.setDescription('An entry containing information about a port on a particular card in the switch.')
atmSwchPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 6, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSwchPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchPortIndex.setDescription('The index of this port within the card.')
atmSwchPortRootVportIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 6, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSwchPortRootVportIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchPortRootVportIndex.setDescription('The index of the root vport in the vport table.')
atmSwchPortNumVPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 6, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSwchPortNumVPorts.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchPortNumVPorts.setDescription('The count of the number of Vports on this physical port.')
atmSwchPortPayloadScramble = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 6, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSwchPortPayloadScramble.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchPortPayloadScramble.setDescription('Payload Scramble for a port.')
atmSwchPortPhysicalType = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 6, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("sonet", 1), ("sdh", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSwchPortPhysicalType.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchPortPhysicalType.setDescription('This variable identifies whether a SONET or a SDH signal is used across this interface.')
atmSwchPortMaxTxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 6, 1, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSwchPortMaxTxRate.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchPortMaxTxRate.setDescription('The Maximum transmit rate (in 1000bits per second) for that port.')
atmSwchPortSvcPtPtInConns = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 6, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSwchPortSvcPtPtInConns.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchPortSvcPtPtInConns.setDescription('The number of switched virtual point to point connections through this port, where this port is the point of entry for the call setup.')
atmSwchPortSvcPtPtOutConns = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 6, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSwchPortSvcPtPtOutConns.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchPortSvcPtPtOutConns.setDescription('The number of switched virtual point to point connections through this port, where this port is the point of exit for the call setup.')
atmSwchPortSvcPtMptRootConns = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 6, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSwchPortSvcPtMptRootConns.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchPortSvcPtMptRootConns.setDescription('The number of switched virtual point to multipoint connections through this port, where this port is the point of entry for the call setup.')
atmSwchPortSvcPtMptLeafConns = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 6, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSwchPortSvcPtMptLeafConns.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchPortSvcPtMptLeafConns.setDescription('The number of switched virtual point to multipoint connections through this port, where this port is the point of exit for the call setup.')
atmSwchPortPvcPtPtConns = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 6, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSwchPortPvcPtPtConns.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchPortPvcPtPtConns.setDescription('The number of permanent virtual point to point connections through this port.')
atmSwchPortPvcPtMptRootConns = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 6, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSwchPortPvcPtMptRootConns.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchPortPvcPtMptRootConns.setDescription('The number of permanent virtual point to multipoint connections through this port, where this port is the point of entry for the call setup.')
atmSwchPortPvcPtMptLeafConns = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 6, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSwchPortPvcPtMptLeafConns.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchPortPvcPtMptLeafConns.setDescription('The number of permanent virtual point to multipoint connections through this port, where this port is the point of exit for the call setup.')
atmSwchPortPvpPtPtConns = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 6, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSwchPortPvpPtPtConns.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchPortPvpPtPtConns.setDescription('The number of permanent virtual point to point path connections through this port.')
atmSwchPortPvpPtMptRootConns = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 6, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSwchPortPvpPtMptRootConns.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchPortPvpPtMptRootConns.setDescription('The number of permanent virtual point to multi-point root path connections through this port.')
atmSwchPortPvpPtMptLeafConns = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 6, 1, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSwchPortPvpPtMptLeafConns.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchPortPvpPtMptLeafConns.setDescription('The number of permanent virtual point to multi-point leaf path connections through this port.')
atmSwchPortdsx3CellMaping = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 6, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dsx3ADM", 1), ("dsx3PLCP", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSwchPortdsx3CellMaping.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchPortdsx3CellMaping.setDescription('This variable describes two different mapping schemes for transporting ATM cells over DS3 transmission systems: a PLCP-based system and a direct mapping system (ADM - Atm Direct Mapping). The two mappings are not compatible although both use DS3 as the underlying transmission system. Default value is ADM.')
atmSwchVPortTable = MibTable((1, 3, 6, 1, 4, 1, 81, 33, 7, 1), )
if mibBuilder.loadTexts: atmSwchVPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchVPortTable.setDescription('A table containing information about all the virtual ports on the switch. Indexed on atmSwchSlotIndex, atmSwchPortIndex and atmSwchVPortIndex.')
atmSwchVPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 33, 7, 1, 1), ).setIndexNames((0, "ATMSWCH-MIB", "atmSwchSlotIndex"), (0, "ATMSWCH-MIB", "atmSwchPortIndex"), (0, "ATMSWCH-MIB", "atmSwchVPortIndex"))
if mibBuilder.loadTexts: atmSwchVPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchVPortEntry.setDescription('An entry containing information about a VPort on a particular card in a switch.')
atmSwchVPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 7, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSwchVPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchVPortIndex.setDescription('The index of this vport within the card/port. This is defined as being the vport identifier + 1.')
atmSwchVPortIsRoot = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 7, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("isRoot", 1), ("notRoot", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSwchVPortIsRoot.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchVPortIsRoot.setDescription('Indicates whether this Vport is the root vport on a given physical port.')
atmSwchVPortAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 7, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSwchVPortAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchVPortAdminStatus.setDescription('The admin state of this interface. Note that an interface must be down in order to change the configuration of that interface.')
atmSwchVPortOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 7, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSwchVPortOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchVPortOperStatus.setDescription('The operational state of this interface. Note that an interface must be down in order to change the configuration of that interface.')
atmSwchVPortCurrentSignallingState = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 7, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("up", 2), ("down", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSwchVPortCurrentSignallingState.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchVPortCurrentSignallingState.setDescription('The state of the signalling stack for this interface.')
atmSwchVPortCurrentILMIState = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 7, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("stackOff", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSwchVPortCurrentILMIState.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchVPortCurrentILMIState.setDescription('The current state of the ILMI link for this port. stack_off means the ILMI link is up but the protocol stack that retrieves neighbor information is off.')
atmSwchVPortCurrentAddrRegEn = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 7, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("enabled", 2), ("disabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSwchVPortCurrentAddrRegEn.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchVPortCurrentAddrRegEn.setDescription('Indicates whether address registration is enabled on this interface.')
atmSwchVPortCurrentLinkType = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 7, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("unknown", 1), ("uni30", 2), ("uni31", 3), ("iisp30", 4), ("iisp31", 5), ("pnni10", 6), ("uni40", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSwchVPortCurrentLinkType.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchVPortCurrentLinkType.setDescription('The type of signalling used on this interface.')
atmSwchVPortCurrentTermType = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 7, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("user", 2), ("network", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSwchVPortCurrentTermType.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchVPortCurrentTermType.setDescription('The type of link termination currently in use at this interface.')
atmSwchVPortConfigILMIState = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 7, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("stackEnabled", 1), ("stackDisabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSwchVPortConfigILMIState.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchVPortConfigILMIState.setDescription('The configured state of the ILMI protocol stack.')
atmSwchVPortConfigAddrRegEn = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 7, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("automatic", 1), ("enabled", 2), ("disabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSwchVPortConfigAddrRegEn.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchVPortConfigAddrRegEn.setDescription('Indicates whether address registration is to be performed on this interface.')
atmSwchVPortConfigLinkType = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 7, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("automatic", 1), ("unknown", 2), ("uni30", 3), ("uni31", 4), ("iisp30", 5), ("iisp31", 6), ("pnni10", 7), ("uni40", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSwchVPortConfigLinkType.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchVPortConfigLinkType.setDescription('The configured type of signalling used on this interface. Attempts to set the unknown state will be rejected.')
atmSwchVPortConfigTermType = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 7, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("automatic", 1), ("user", 2), ("network", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSwchVPortConfigTermType.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchVPortConfigTermType.setDescription('The type of link termination configured for use at this interface.')
atmSwchVPortNeighbourSysName = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 7, 1, 1, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSwchVPortNeighbourSysName.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchVPortNeighbourSysName.setDescription('The sysName for the device at the remote end of the link to this interface.')
atmSwchVPortNeighbourUNIVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 7, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("notKnown", 1), ("uni30", 2), ("uni31", 3), ("uni40", 4), ("iisp", 5), ("pnni10", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSwchVPortNeighbourUNIVersion.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchVPortNeighbourUNIVersion.setDescription('The highest version of stack type usable by the interface at the remote end of the link to this interface.')
atmSwchVPortNeighbourATMAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 7, 1, 1, 16), AtmAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSwchVPortNeighbourATMAddress.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchVPortNeighbourATMAddress.setDescription('The ifPhysAddress used by the interface at the remote end of the link to this interface.')
atmSwchVPortNeighbourIfName = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 7, 1, 1, 17), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSwchVPortNeighbourIfName.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchVPortNeighbourIfName.setDescription('The ifName used by the interface at the remote end of the link to this interface.')
atmSwchVPortMibProbe = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 7, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSwchVPortMibProbe.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchVPortMibProbe.setDescription('Whether the ability to find out proprietary features via the probe MIB (ILMI extensions) is switched on or off.')
atmSwchVPortConfMinSvccVci = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 7, 1, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSwchVPortConfMinSvccVci.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchVPortConfMinSvccVci.setDescription('The minimum VCI that the signalling stack on the vport is configured to support for allocation to switched virtual channel connections.')
atmSwchVPortConfMaxSvccVci = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 7, 1, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSwchVPortConfMaxSvccVci.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchVPortConfMaxSvccVci.setDescription('The maximum VCI that the signalling stack on the vport is configured to support for allocation to switched virtual channel connections.')
atmSwchVPortConfMinVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 7, 1, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSwchVPortConfMinVpi.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchVPortConfMinVpi.setDescription('The minimum VPI available for use by any connection on this virtual port. Curently, this is always 0 for the root vport, while non-root vports take a value greater than the MaxVpi of the root vport. For Non-root vports MinVpi==MaxVpi.')
atmSwchVPortConfMaxVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 7, 1, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSwchVPortConfMaxVpi.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchVPortConfMaxVpi.setDescription('The maximum VPI available for use by any connection on this virtual port. Curently possible values are: 0, 1, 3 and 7, For Non-root vports MinVpi==MaxVpi.')
atmSwchVPortNeighbourIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 7, 1, 1, 23), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSwchVPortNeighbourIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchVPortNeighbourIpAddress.setDescription('The IP address used by the interface at the remote end of the link to this interface.')
atmSwchVPortPcr = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 7, 1, 1, 24), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSwchVPortPcr.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchVPortPcr.setDescription('The Peak Cell Rate (in 1000bits per second) for that Vport. Available only for non-root Vports. The root-vport will always return the value of 0')
atmSwchVPortRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 7, 1, 1, 25), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSwchVPortRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchVPortRowStatus.setDescription("This object is used to create, delete or modify a row in this table. To create a new Vport, this object is initially set to 'createAndWait' or 'createAndGo'. This object should not be set to 'active' unless the following columnar objects have been set to their desired value in this row: atmSwchVPortIndex with the value of vport identifier + 1. The root Vport always exists and cannot be deleted atmSwchVPortConfMinVpi = atmSwchVPortConfMaxVpi with the VPI value associated with the Vport. This VPI should be not be used by other Vports.")
atmSwchSlotRouteTable = MibTable((1, 3, 6, 1, 4, 1, 81, 33, 8, 1), )
if mibBuilder.loadTexts: atmSwchSlotRouteTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchSlotRouteTable.setDescription('a list of ATM routing table addresses')
atmSwchSlotRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 33, 8, 1, 1), ).setIndexNames((0, "ATMSWCH-MIB", "atmSwchSlotIndex"), (0, "ATMSWCH-MIB", "atmSwchSlotRouteId"))
if mibBuilder.loadTexts: atmSwchSlotRouteEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchSlotRouteEntry.setDescription('ATM address routing entry: ATM Address to Port')
atmSwchSlotRouteId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 8, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSwchSlotRouteId.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchSlotRouteId.setDescription('Unique identifier for this row. This value will always match the OID leaf value.')
atmSwchSlotRouteRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 8, 1, 1, 2), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSwchSlotRouteRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchSlotRouteRowStatus.setDescription('This objest is used to create or delete entries in the atmSwchSlotRouteTable. See Textual Convention in RFC 1903. Next available index is: atmSwchSlotRouteNextId active (1), notInService (2), notReady (3), createAndGo (4) - not supported tbd, createAndWait (5) destroy (6) ')
atmSwchSlotRouteAddressPrefix = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 8, 1, 1, 3), AtmAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSwchSlotRouteAddressPrefix.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchSlotRouteAddressPrefix.setDescription('The ATM address to be used for routing.')
atmSwchSlotRoutePrefixLength = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 8, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 152))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSwchSlotRoutePrefixLength.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchSlotRoutePrefixLength.setDescription('The number of bits used in the Address Prefix')
atmSwchSlotRoutePriority = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 8, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 999))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSwchSlotRoutePriority.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchSlotRoutePriority.setDescription('The priority of this route entry (not used at this time)')
atmSwchSlotRouteSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 8, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSwchSlotRouteSlot.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchSlotRouteSlot.setDescription('Identifier for the slot used by the route')
atmSwchSlotRoutePort = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 8, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSwchSlotRoutePort.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchSlotRoutePort.setDescription('Identifier for the port on the above slot to be used by the route')
atmSwchSlotRouteVport = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 8, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSwchSlotRouteVport.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchSlotRouteVport.setDescription('Identifier for the virtual port on the above port to be used by the route.')
atmSwchSlotRouteOrigin = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 8, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("nonVolatile", 1), ("snmp", 2), ("ilmi", 3), ("lane", 4), ("dynamic", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSwchSlotRouteOrigin.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchSlotRouteOrigin.setDescription('Indicates origin of route')
atmSwchSlotRouteOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 8, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSwchSlotRouteOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchSlotRouteOperStatus.setDescription("Indication of route's operational status")
atmSwchSlotAddrVclTable = MibTable((1, 3, 6, 1, 4, 1, 81, 33, 9, 1), )
if mibBuilder.loadTexts: atmSwchSlotAddrVclTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchSlotAddrVclTable.setDescription('This table provides an alternative way to retrieve the atmVclTable. This table can be used to retrieve the indexing to the atmVclTable by an ATM address. Based on the standard atmAddrVclTable with a SlotIndex.')
atmSwchSlotAddrVclEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 33, 9, 1, 1), ).setIndexNames((0, "ATMSWCH-MIB", "atmSwchSlotIndex"), (0, "ATMSWCH-MIB", "atmSwchSlotAddrVclAddr"), (0, "ATMSWCH-MIB", "atmSwchSlotAddrVclAtmIfIndex"), (0, "ATMSWCH-MIB", "atmSwchSlotAddrVclVpi"), (0, "ATMSWCH-MIB", "atmSwchSlotAddrVclVci"))
if mibBuilder.loadTexts: atmSwchSlotAddrVclEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchSlotAddrVclEntry.setDescription('Each entry in this table represents an entry in the atmVclTable of the ATM-MIB by its ATM address. The ATM address is either the calling or called party ATM address of the call. Entries in this table are read only. They show up when entries are created in the atmVclAddrTable.')
atmSwchSlotAddrVclAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 9, 1, 1, 1), AtmAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSwchSlotAddrVclAddr.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchSlotAddrVclAddr.setDescription('An ATM address on one end of the VCL.')
atmSwchSlotAddrVclAtmIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 9, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSwchSlotAddrVclAtmIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchSlotAddrVclAtmIfIndex.setDescription('The interface index of the ATM interface to which this VCL pertains. This object combined with the atmAddrVclVpi and atmAddrVclVci objects serves as an index to the atmVclTable.')
atmSwchSlotAddrVclVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 9, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSwchSlotAddrVclVpi.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchSlotAddrVclVpi.setDescription('The VPI value of the VCL. This object combined with the atmAddrVclAtmIfIndex and atmAddrVclVci objects serves as an index to the atmVclTable.')
atmSwchSlotAddrVclVci = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 9, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSwchSlotAddrVclVci.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchSlotAddrVclVci.setDescription('The VCI value of the VCL. This object combined with the atmAddrVclAtmIfIndex and atmAddrVclVpi objects serves as an index to the atmVclTable.')
atmSwchSlotAddrVclAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 33, 9, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("callingParty", 1), ("calledParty", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSwchSlotAddrVclAddrType.setStatus('mandatory')
if mibBuilder.loadTexts: atmSwchSlotAddrVclAddrType.setDescription('The type of ATM Address represented by the object atmVclAddrAddr. Choices are either calling party address or called party address.')
mibBuilder.exportSymbols("ATMSWCH-MIB", atmSwchCpuSvcPtPtOutConns=atmSwchCpuSvcPtPtOutConns, atmSwchPortPvcPtPtConns=atmSwchPortPvcPtPtConns, atmSwchPortSvcPtMptLeafConns=atmSwchPortSvcPtMptLeafConns, atmSwchCpuSvcPtPtInConns=atmSwchCpuSvcPtPtInConns, atmSwchCpuHwVersion=atmSwchCpuHwVersion, atmSwchVPortAdminStatus=atmSwchVPortAdminStatus, atmSwchSlotAddrVcl=atmSwchSlotAddrVcl, atmSwchVPortEntry=atmSwchVPortEntry, atmSwchSlotRouteId=atmSwchSlotRouteId, atmSwchPortdsx3CellMaping=atmSwchPortdsx3CellMaping, atmSwchSlotRoutePriority=atmSwchSlotRoutePriority, atmSwchVPortRowStatus=atmSwchVPortRowStatus, atmSwchCpuSoftErrString=atmSwchCpuSoftErrString, atmSwchCpuEepromUsed=atmSwchCpuEepromUsed, atmSwchPortPvpPtMptLeafConns=atmSwchPortPvpPtMptLeafConns, atmSwchBaseAmonAdminState=atmSwchBaseAmonAdminState, atmSwchCpuRamUsed=atmSwchCpuRamUsed, atmSwchCpuTable=atmSwchCpuTable, atmSwchPortSvcPtPtOutConns=atmSwchPortSvcPtPtOutConns, atmSwchPortIndex=atmSwchPortIndex, atmSwchSlotIndex=atmSwchSlotIndex, atmSwchVPortCurrentLinkType=atmSwchVPortCurrentLinkType, atmSwchSlotAPSDecision=atmSwchSlotAPSDecision, atmSwchSlotAPSSwitchCommand=atmSwchSlotAPSSwitchCommand, atmSwchCpuFlashSize=atmSwchCpuFlashSize, atmSwchVPortTable=atmSwchVPortTable, atmSwchPortSvcPtPtInConns=atmSwchPortSvcPtPtInConns, atmSwchPortTable=atmSwchPortTable, atmSwchSlotTable=atmSwchSlotTable, atmSwchCpuRamSize=atmSwchCpuRamSize, atmSwchCpuSysUpTime=atmSwchCpuSysUpTime, atmSwchSlotAPSSFBerThreshold=atmSwchSlotAPSSFBerThreshold, atmSwchCpuUtilization=atmSwchCpuUtilization, atmSwchSlotAPSCurrentState=atmSwchSlotAPSCurrentState, atmSwchBaseConfigPrefix=atmSwchBaseConfigPrefix, atmSwchPortPhysicalType=atmSwchPortPhysicalType, atmSwchSlotEntry=atmSwchSlotEntry, atmSwchBaseCurrentPrefix=atmSwchBaseCurrentPrefix, atmSwchPortRootVportIndex=atmSwchPortRootVportIndex, atmSwchSlotAddrVclEntry=atmSwchSlotAddrVclEntry, atmSwchCpuSoftErrCode=atmSwchCpuSoftErrCode, atmSwchSlotRouteRowStatus=atmSwchSlotRouteRowStatus, atmSwchSlotRouteSlot=atmSwchSlotRouteSlot, atmSwchSlotRoutePort=atmSwchSlotRoutePort, atmSwchVPortConfigILMIState=atmSwchVPortConfigILMIState, atmSwchVPortNeighbourUNIVersion=atmSwchVPortNeighbourUNIVersion, atmSwchVPortCurrentSignallingState=atmSwchVPortCurrentSignallingState, atmSwchSlotRouteNextId=atmSwchSlotRouteNextId, atmSwchPortEntry=atmSwchPortEntry, atmSwchVPortIndex=atmSwchVPortIndex, atmSwchVPort=atmSwchVPort, atmSwchBaseEpdThreshold=atmSwchBaseEpdThreshold, atmSwchVPortCurrentILMIState=atmSwchVPortCurrentILMIState, atmSwchVPortNeighbourATMAddress=atmSwchVPortNeighbourATMAddress, atmSwchVPortMibProbe=atmSwchVPortMibProbe, AtmAddress=AtmAddress, atmSwchCpuSvcPtMptLeafConns=atmSwchCpuSvcPtMptLeafConns, atmSwchSlotRoutePrefixLength=atmSwchSlotRoutePrefixLength, atmSwchPortSvcPtMptRootConns=atmSwchPortSvcPtMptRootConns, atmSwchBase=atmSwchBase, atmSwchVPortOperStatus=atmSwchVPortOperStatus, atmSwchPortNumVPorts=atmSwchPortNumVPorts, atmSwchVPortConfigAddrRegEn=atmSwchVPortConfigAddrRegEn, atmSwchPortPvpPtMptRootConns=atmSwchPortPvpPtMptRootConns, atmSwchVPortConfMaxVpi=atmSwchVPortConfMaxVpi, atmSwchSlotAddrVclTable=atmSwchSlotAddrVclTable, atmSwchVPortIsRoot=atmSwchVPortIsRoot, atmSwchVPortPcr=atmSwchVPortPcr, atmSwchSlotRouteAddressPrefix=atmSwchSlotRouteAddressPrefix, atmSwchSlotRouteOrigin=atmSwchSlotRouteOrigin, atmSwchSlotAddrVclAtmIfIndex=atmSwchSlotAddrVclAtmIfIndex, atmSwchVPortConfigLinkType=atmSwchVPortConfigLinkType, atmSwchVPortNeighbourIfName=atmSwchVPortNeighbourIfName, atmSwchSlotRouteEntry=atmSwchSlotRouteEntry, atmSwchCpuEepromSize=atmSwchCpuEepromSize, atmSwchCpuTime=atmSwchCpuTime, atmSwchSlotAddrVclVpi=atmSwchSlotAddrVclVpi, atmSwchSlotAddrVclAddrType=atmSwchSlotAddrVclAddrType, AtmPrefix=AtmPrefix, atmSwchPortPvpPtPtConns=atmSwchPortPvpPtPtConns, atmSwchSlotRxCellDiscards=atmSwchSlotRxCellDiscards, atmSwchSlotAPSSDBerThreshold=atmSwchSlotAPSSDBerThreshold, atmSwchSlotRouteOperStatus=atmSwchSlotRouteOperStatus, atmSwchPort=atmSwchPort, atmSwchVPortNeighbourSysName=atmSwchVPortNeighbourSysName, atmSwchPortPvcPtMptRootConns=atmSwchPortPvcPtMptRootConns, atmSwchSlotAddrVclAddr=atmSwchSlotAddrVclAddr, atmSwchVPortNeighbourIpAddress=atmSwchVPortNeighbourIpAddress, atmSwch=atmSwch, atmSwchCpuPvcPtPtConns=atmSwchCpuPvcPtPtConns, atmSwchCpu=atmSwchCpu, atmSwchCpuEntry=atmSwchCpuEntry, atmSwchCpuFlashUsed=atmSwchCpuFlashUsed, atmSwchCpuSvcPtMptRootConns=atmSwchCpuSvcPtMptRootConns, atmSwchSlotAPSMode=atmSwchSlotAPSMode, atmSwchSlotRoute=atmSwchSlotRoute, atmSwchVPortConfMinSvccVci=atmSwchVPortConfMinSvccVci, atmSwchVPortCurrentTermType=atmSwchVPortCurrentTermType, atmSwchVPortConfMaxSvccVci=atmSwchVPortConfMaxSvccVci, atmSwchVPortConfigTermType=atmSwchVPortConfigTermType, atmSwchPortPvcPtMptLeafConns=atmSwchPortPvcPtMptLeafConns, atmSwchSlotRouteVport=atmSwchSlotRouteVport, atmSwchPortPayloadScramble=atmSwchPortPayloadScramble, atmSwchCpuIndex=atmSwchCpuIndex, atmSwchVPortConfMinVpi=atmSwchVPortConfMinVpi, atmSwchPortMaxTxRate=atmSwchPortMaxTxRate, atmSwchVPortCurrentAddrRegEn=atmSwchVPortCurrentAddrRegEn, atmSwchSlotAddrVclVci=atmSwchSlotAddrVclVci, atmSwchSlot=atmSwchSlot, atmSwchSlotRouteTable=atmSwchSlotRouteTable)

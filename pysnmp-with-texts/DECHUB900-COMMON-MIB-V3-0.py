#
# PySNMP MIB module DECHUB900-COMMON-MIB-V3-0 (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/DECHUB900-COMMON-MIB-V3-0
# Produced by pysmi-0.3.4 at Wed May  1 12:37:35 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, SingleValueConstraint, ConstraintsIntersection, ConstraintsUnion, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsIntersection", "ConstraintsUnion", "ValueSizeConstraint")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Bits, Integer32, MibScalar, MibTable, MibTableRow, MibTableColumn, enterprises, ModuleIdentity, Counter32, TimeTicks, ObjectIdentity, MibIdentifier, NotificationType, Unsigned32, iso, Gauge32, Counter64, IpAddress = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Integer32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "enterprises", "ModuleIdentity", "Counter32", "TimeTicks", "ObjectIdentity", "MibIdentifier", "NotificationType", "Unsigned32", "iso", "Gauge32", "Counter64", "IpAddress")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
dec = MibIdentifier((1, 3, 6, 1, 4, 1, 36))
ema = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2))
decMIBextension = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18))
decHub900 = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11))
pubCommon = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2))
pcomSlot = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 1))
pcomHub = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 2))
pcomLed = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 3))
pcomLoad = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 4))
pcomSnmpAuth = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 5))
pcomErrLog = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 6))
pcomEsys = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 7))
pcomEif = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 8))
pcomLigo = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 9))
pcomCon = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 10))
pcom90mgt = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 11))
pcomOperStatus = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("enabled", 1), ("initializing", 2), ("failure", 3), ("nonFatalFailure", 4), ("loading", 5), ("disabled", 6), ("needProgramLoad", 7), ("testing", 8), ("lowPowerMode", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcomOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: pcomOperStatus.setDescription("Describes the current operational state of the device. Operational status may be expressed as one of the following: enabled(1) - indicates that the device in online and fully functional. initializing(2) - indicates that the device is initializing. Devices enter the initializing state when powered on, or when reset. failure(3) - indicates that the device's self-test has detected a fault. The device is functionally offline, and may or may not be powered. nonFatalFailure(4) - indicates that the device's self-test has detected a non-fatal fault. The operates are less than a fully functional level in the presence of non-fatal errors. loading(5) - indicates that the device is attempting to load. disabled(6) - indicates that the device has been disabled. The device must still be able to respond to management messages. needProgramLoad(7) - indicates that the device is waiting to be loaded. testing(8) - indicates that the device in performing some form of diagnostic testing. lowPowerMode(9) - indicates that the device is only partially powered. Some classes of device wait in this mode until the Hub Manager to grant additional power. Modules may only be managed via an NMS when they are in the online and/or disabled states. Not all components implement all state of this object. For example, if a component can not report 'failure', then it doesn't. The enabled and disabled states are supported by all components.")
pcomAdminStatus = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("reset", 3), ("restoreToDefaults", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pcomAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: pcomAdminStatus.setDescription("enabled(1) - setting this object to enabled causes the device to begin it's power up sequence and attempt to enter its operational state. If the value of this object was disabled, then the non-volatile value of this object is changed to enabled. As part of the power up sequence, the device's management parameters may or may not be reset. (In other words, the device may go through the equivalent of a reset or before returning to the online state. If the device is capable of going directly from the disabled state to the enabled state without resetting any of its management parameters, then it may do so. Such action is product specific.) disabled(2) - setting this object to offline causes the device to cease network activity and enter a quiescent state. A disabled device must still be able to respond to management messages. The value enable(1) or disable(2) shall be stored in non-volatile memory for the initial reset value of this variable. The factory default NV value is enable(1). reset(3) - setting this object to this state resets the module, including its volatile managed objects. Resetting may involve running the devices self-test diagnostic. If diagnostics fail, this object will remain in the reset state and failure status will be reflected elsewhere in the mib. If diagnostics pass, then the device will automatically return to the enabled state. After reset, this object shall assume the non-volatile value of enable(1) or disable(2). (So, if you reset a disabled module, the device will reset and come back up still in the disabled state.) restoreToDefaults(4) - setting this object to this state restores all of its non-volatile parameters to their factory default state and resets the module (see reset(3)). Note: The default value of this object is, or course, enabled. Note: Some devices may not send a getResponse to a PDU which commands the device to reset. Setting this object to reset, restoreToDefaults, or enable may cause the device to reset.")
pcomDiagFailure = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcomDiagFailure.setStatus('mandatory')
if mibBuilder.loadTexts: pcomDiagFailure.setDescription('This object contains the results of power-on self test. When zero, the unit passed self test okay. When non-zero and pcomOperStatus indicates a failure the value is a module-specific error code. When non-zero and pcomOperStatus indicates a nonFatalFailure the value is a module-specific non-fatal error code.')
pcomSerialNumber = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pcomSerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: pcomSerialNumber.setDescription("Serial number for the module. This variable is set to a zero length string initially. Users may store a serial number for the module. The value of this object in not affected by a 'restoreToDefaults' operation.")
pcomSlotNumber = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcomSlotNumber.setStatus('mandatory')
if mibBuilder.loadTexts: pcomSlotNumber.setDescription('Number of the slot in which module is inserted, as indicated by pins on the backplane connector. If module is not inserted in a hub the value of this object is 0.')
pcomEsn = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcomEsn.setStatus('mandatory')
if mibBuilder.loadTexts: pcomEsn.setDescription("Extended Slot Number assigned to module. An ESN is a 32-bit integer which has a decimal representation that indicates the physical connectivity of both local and remote modules to the hub. The decimal representation is of the form: ss [aa [bb [cc [dd]]]] where [] indicates optional. A module inserted directly in the hub has an ESN 'ss' that is the same as its slot number (e.g 3). A remote module connected to the local module's 'aa' port has ESN ssaa. For example, if a concentrator in slot 3 has a repeater connected to port 2, the repeater has ESN 302. Dec Hubs can manage devices up to four remote hops away from the hub.")
pcomHubId = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 2, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcomHubId.setStatus('deprecated')
if mibBuilder.loadTexts: pcomHubId.setDescription('A 6-byte unique identifier. The HubId is assigned to the component by hub manager when the new component is recognized. The initial HubId is zero. The component stores the HubId in non-volatile memory. There is an internal read-write version of this public common read-only variable. *************************************************************** This object has been deprecated. Not all devices support it. *************************************************************** ')
pcomHubIpAddress = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 2, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcomHubIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: pcomHubIpAddress.setDescription('The IP address used to reach to Hub Manager via the MAC implemented by the component. This is initialized to all zeros (0.0.0.0) at reset. There is an internal read-write version of this public common read-only variable.')
pcomHubCommunity = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 2, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcomHubCommunity.setStatus('mandatory')
if mibBuilder.loadTexts: pcomHubCommunity.setDescription('The public read-only SNMP community string used by the Hub Manager. This value is initialized to the null (zero-length) string at reset. There is an internal read-write version of this public common read-only variable.')
pcomLedTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 3, 1), )
if mibBuilder.loadTexts: pcomLedTable.setStatus('mandatory')
if mibBuilder.loadTexts: pcomLedTable.setDescription('A list of led entries, one for led on the device.')
pcomLedEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 3, 1, 1), ).setIndexNames((0, "DECHUB900-COMMON-MIB-V3-0", "pcomLedIndex"))
if mibBuilder.loadTexts: pcomLedEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pcomLedEntry.setDescription('Values for a led.')
pcomLedIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcomLedIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pcomLedIndex.setDescription('Index into the table.')
pcomLedDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 3, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcomLedDescr.setStatus('mandatory')
if mibBuilder.loadTexts: pcomLedDescr.setDescription('A textual description of the information which the LED is meant to convey. i.e.: +5 Volt Power, DC Okay Ethernet segment activity. Diagnostic status.')
pcomLedProgram = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 3, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 48))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcomLedProgram.setStatus('mandatory')
if mibBuilder.loadTexts: pcomLedProgram.setDescription("The pcomLedProgram string is a sequence of instructions for the LED state. The LED constantly repeats the program. Each LED state is represented by a two octet sequence where the value of the first octet of the pair indicates the color of the LED, and the value of the seconds octet of the pair indicates the duration in which that color will be present. +----------+----------+ --/ /-- +----------+----------+ | Color | Duration | | Color | Duration | +----------+----------+ --/ /-- +----------+----------+ The 'color' octet may have one of the following values: 0 - off 1 - other 2 - red 3 - yellow 4 - green 5 - blue 6 - red-blinking 7 - yellow-blinking 8 - blue-blinking 9 - green-blinking The value 'off' indicates that the led is off. The value 'other' indicates a color not covered by any others in the list. The value of the second octet in each pair indicates the duration in which that color will be present. A value of zero indicates that the LED is off. A value of 0xff indicates that the LED is always on. Values in between 0 and 0xff indicate the duration in 10 ms ticks. A zero length string may be returned if the LED is 'not present'. This indicates that the LED is currently not visible. (This is provided for modules which may attach to different chassis, i.e. an 8-slot chassis or a single-slot chassis, in which a different LEDs may be visible. For example, say an extra three LEDs are visible when the device is inserted in a single-slot chassis. When the device is removed from the single slot chassis and inserted into the 8-slot chassis, these three LEDs may not be visible. Therefore, a zero length string may be returned to indicate that these three LEDs are not present.) Activity LEDs are a special case. Activity LEDs are defined as LEDs which blink whenever data is received on the line. They are typically on solid under heavy activity. Since these LEDs can change rapidly, the following rules apply: o The initial state of activity LEDs is off. o If the line shows activity any time in a 10 second period, then the LED is shown as on. o If the line shown inactivity any time in a 10 second period, then the LED is shown as off. Example: Consider a 4-bank, 12-port repeater: Bank: Ports: ---- ----- Bank A: A1, A2, A3 Bank B: B1, B2, B3 Bank C: C1, C2, C3 Bank D: D1, D2, D3 Which has the following LEDs: LED: pcomLedDescr: pcomLedIndex: --- ------------ ------------ PWR Hub Power On 1 DIAG Diagnostics 2 A Bank Indicator A 3 B Bank Indicator B 4 C Bank Indicator C 5 D Bank Indicator D 6 P1: Port Status 1A/B/C/D 7 P2: Port Status 2A/B/C/D 8 P3: Port Status 3A/B/C/D 9 Assume the ports of this repeater are in the following states: Port: State: ---- ----- 1A Operational, auto-partitioned, media available 2A Not operational 3A Operational, not auto-partitioned, media available 1B Operational, not auto-partitioned, media available 2B Not operational 3B Not operational 1C Operational, not auto-partitioned, media available 2C Operational, auto-partitioned, media available 3C Not operational 1D Operational, auto-partitioned, media available 2D Not operational 3D Operational, auto-partitioned, media available Here are the contents of the pcomLedTable for this example: ledIndex: ledDescr: ledProgram: -------- -------- ---------- 1 Hub Power On 0x04, 0xFF 2 Diagnostics 0x04, 0x32, 0x00, 0x32 3 Bank Indicator A 0x04, 0xC8, 0x00, 0xC8, 0x00, 0xC8, 0x00, 0xC8 4 Bank Indicator B 0x00, 0xC8, 0x04, 0xC8, 0x00, 0xC8, 0x00, 0xC8 5 Bank Indicator C 0x00, 0xC8, 0x00, 0xC8, 0x04, 0xC8, 0x00, 0xC8 6 Bank Indicator D 0x00, 0xC8, 0x00, 0xC8, 0x00, 0xC8, 0x04, 0xC8 7 Port 1A/B/C/D 0x00, 0xC8, 0x04, 0xC8, 0x04, 0xC8, 0x00, 0xC8 8 Port 2A/B/C/D 0x08, 0xC8, 0x08, 0xC8, 0x00, 0xC8, 0x08, 0xC8 9 Port 3A/B/C/D 0x04, 0xC8, 0x08, 0xC8, 0x08, 0xC8, 0x00, 0xC8 This example shows: o LED 1 is green, and always on o LED 2 is blinking at a frequency of 1 Hz (1/2 sec green, 1/2 sec. off) LED's 3-6 indicate for which bank (a-D) of ports status is currently being displayed on LED's 7-9. o LED 3 is on for 2 seconds, then off for 6 seconds o LED 4 is off for 2 seconds, on for 2 seconds, off for 4 seconds o LED 5 is off for 4 seconds, on for 2 seconds, off for 2 seconds o LED 6 is off for 6 seconds, then on for 2 seconds o LED 7 is the status LED for Ports 1A, 1B, 1C and 1D. In this example, it is: off for 2 seconds (indicating port 1A is operational but auto-partitioned), solid green for 4 seconds (indicating ports 1B and 1C are operational, not auto-partitioned with media available), and off for 2 seconds (indicating Port 1D is operational but auto-partitioned) o LED 8 is the status LED for Ports 2A, 2B, 2C and 2D. In this example, it is: Blinking green for 4 seconds (indicating ports 2A and 2B are not operational), off for 2 seconds (indicating port 2C is operational but auto-partitioned), and blinking green for 2 seconds (indicating port 2D is not operational). o LED 9 is the status LED for Ports 3A, 3B, 3C and 3D. In this example, it is: Solid green for 2 seconds (indicating port 3A is operational, not auto-partitioned with media available), Blinking Green for 4 seconds (indicating ports 3B and 3C are not operational), and off for 2 seconds (indicating port 3D is operational but auto-partitioned ).")
pcomLedInterestingChanges = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 3, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcomLedInterestingChanges.setStatus('mandatory')
if mibBuilder.loadTexts: pcomLedInterestingChanges.setDescription("This counter may be polled to determine if any 'interesting changes' in the pcomLedTable have occurred. Changes that meet the criteria of 'interesting' are defined on a module by module basis.")
pcomLoadAdminStatus = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("start-read", 2), ("start-write", 3), ("cancel", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pcomLoadAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: pcomLoadAdminStatus.setDescription('This object is used to control the program load process of a device. When read, the value other(1) is returned. When set to start-read(2) the device initiates a TFTP read operation to read a new program image. When set to start-write(3) the device is placed in such a state as to accept a new program image via a TFTP write operation. Once initiated, the status of the load attempt is reflected in pcomLoadOperStatus. A device shall always reset upon completion of a successful load attempt. It may reset upon unsuccessful completion of the load attempt. When set to cancel(4) the device will attempt to cancel an ongoing load.')
pcomLoadOperStatus = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 4, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("success", 2), ("failure", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcomLoadOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: pcomLoadOperStatus.setDescription("The final state of the last load attempt. none(1) indicates that no load has been attempted, ever. This object is non-volatile. It's default value is none(1).")
pcomLoadFilename = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 4, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pcomLoadFilename.setStatus('mandatory')
if mibBuilder.loadTexts: pcomLoadFilename.setDescription('The name of the file in which to load. When the device is reading, this is the name of the file to be read. When the device is being written, this is the only name of the file in which writes will be accepted - provided the device can check the file name. If the device can not check the file name then this object is ignored. It is the duty of the NMS triggering the device to load this object. This object is non-volatile. The initial and default value of this object in a zero-lengthed string. In the case of multi-file loads (aka segmented loads) this object contains the name of the first file in which to load. It is an application specific issue as to how to get subsequent load files.')
pcomLoadIpHostAddr = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 4, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pcomLoadIpHostAddr.setStatus('mandatory')
if mibBuilder.loadTexts: pcomLoadIpHostAddr.setDescription("The IP address of the host from which to load. When the device is reading, this is the IP address of the host in which the read will be directed. When the device is being written, this is the IP address of the only host in which writes will be accepted. This object is non-volatile. The initial and default value of this object is 0.0.0.0. If the load is 'assisted', and does not use IP, it is the responsibility of the assistant to write this object. (In this case, the object may be useful for debug purposes.)")
pcomLoadDevSpecific = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 4, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcomLoadDevSpecific.setStatus('mandatory')
if mibBuilder.loadTexts: pcomLoadDevSpecific.setDescription('A device specific parameter which may be used to indicate detailed error information about the last attempted load. A value of zero indicates that no load has been attempted, or that there is nothing interesting to report of the last load. This object is non-volatile.')
pcomLoadTftpDirection = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 4, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("pcomLoadTftpDirectionAckWrite", 1), ("pcomLoadTftpDirectionStartRead", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcomLoadTftpDirection.setStatus('mandatory')
if mibBuilder.loadTexts: pcomLoadTftpDirection.setDescription("This device-specific object represents the TFTP capability of the device, in relation to its Management Agent Module (MAM). The TFTP protocol allows initiation of new program downloads to begin with either a TFTP READ packet, or a TFTP WRITE packet. This object is set to pcomLoadTftpDirectionStartRead to indicate that the device expects a TFTP READ packet to begin a new program download procedure. The object is set to pcomLoadTftpDirectionAckWrite, to indicate that the device expects a TFTP WRITE packet to begin a new program download procedure. If an (older) device returns a 'no such object' error code, then the value of pcomLoadTftpDirectionAckWrite will be assumed by the requestor. This object is non-volatile.")
pcomSnmpAuthTrap = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 5, 1))
pcomSnmpAuthTrapCommunity = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 5, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pcomSnmpAuthTrapCommunity.setStatus('mandatory')
if mibBuilder.loadTexts: pcomSnmpAuthTrapCommunity.setDescription("The community string used in SNMP Trap PDUs. This value is initially 'public'.")
pcomSnmpAuthTrapUserTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 5, 1, 2), )
if mibBuilder.loadTexts: pcomSnmpAuthTrapUserTable.setStatus('mandatory')
if mibBuilder.loadTexts: pcomSnmpAuthTrapUserTable.setDescription('A list of IP addresses to which traps will be sent and an associated row creation/deletion object.')
pcomSnmpAuthTrapUserEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 5, 1, 2, 1), ).setIndexNames((0, "DECHUB900-COMMON-MIB-V3-0", "pcomSnmpAuthTrapUserAddr"))
if mibBuilder.loadTexts: pcomSnmpAuthTrapUserEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pcomSnmpAuthTrapUserEntry.setDescription('Objects containing information for a given trap address. Rows are created when pcomSnmpAuthTrapAddr is set, and deleted when pcomSnmpAuthTrapUserStatus is set to invalid(2).')
pcomSnmpAuthTrapUserAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 5, 1, 2, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pcomSnmpAuthTrapUserAddr.setStatus('mandatory')
if mibBuilder.loadTexts: pcomSnmpAuthTrapUserAddr.setDescription('An IP Address to which all SNMP Trap messages will be sent.')
pcomSnmpAuthTrapUserStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 5, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pcomSnmpAuthTrapUserStatus.setStatus('mandatory')
if mibBuilder.loadTexts: pcomSnmpAuthTrapUserStatus.setDescription('Writing invalid(2) to this object removes the corresponding entry. When read, this object always returns a value of other(1).')
pcomSnmpAuthReadOnly = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 5, 2))
pcomSnmpAuthReadOnlyCommunity = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 5, 2, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pcomSnmpAuthReadOnlyCommunity.setStatus('mandatory')
if mibBuilder.loadTexts: pcomSnmpAuthReadOnlyCommunity.setDescription("The community string used to identify an SNMP community with access rights of read-only. This value is initially 'public'.")
pcomSnmpAuthReadOnlyUserTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 5, 2, 2), )
if mibBuilder.loadTexts: pcomSnmpAuthReadOnlyUserTable.setStatus('mandatory')
if mibBuilder.loadTexts: pcomSnmpAuthReadOnlyUserTable.setDescription('A list of Read-only users and associated information.')
pcomSnmpAuthReadOnlyUserEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 5, 2, 2, 1), ).setIndexNames((0, "DECHUB900-COMMON-MIB-V3-0", "pcomSnmpAuthReadOnlyUserAddr"))
if mibBuilder.loadTexts: pcomSnmpAuthReadOnlyUserEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pcomSnmpAuthReadOnlyUserEntry.setDescription('Objects containing information for a given Read-only user. Rows are created when pcomSnmpAuthReadOnlyUserAddr is set, and deleted when pcomSnmpAuthReadOnlyUserStatus is set to invalid(2).')
pcomSnmpAuthReadOnlyUserAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 5, 2, 2, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pcomSnmpAuthReadOnlyUserAddr.setStatus('mandatory')
if mibBuilder.loadTexts: pcomSnmpAuthReadOnlyUserAddr.setDescription("An IP Address, or a set of IP addresses, which has Read-only SNMP access to this agent. If this object is used as a wildcard, bits corresponding to the zero bits in the corresponding euthReadOnlyUserMask are treated as don't-care.")
pcomSnmpAuthReadOnlyUserMask = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 5, 2, 2, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pcomSnmpAuthReadOnlyUserMask.setStatus('mandatory')
if mibBuilder.loadTexts: pcomSnmpAuthReadOnlyUserMask.setDescription("UserMask is used to provide 'wildcard' authorized users. It is a 32-bit mask which is applied to (ANDed with) the source IP address of an incoming SNMP message. If the result of the mask is equal to an address in pcomSnmpAuthReadOnlyUserAddr, the message is considered to have come from a user who has Read-only access. This allows wildcarding. For example, a user address of 16.20.0.0 and a mask of 255.255.0.0 allow access to all NMS's on subnet 16.20. The default value for this mask is all 1's.")
pcomSnmpAuthReadOnlyUserStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 5, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pcomSnmpAuthReadOnlyUserStatus.setStatus('mandatory')
if mibBuilder.loadTexts: pcomSnmpAuthReadOnlyUserStatus.setDescription('Writing invalid(2) to this object removes the corresponding entry. When read, this object always returns a value of other(1).')
pcomSnmpAuthReadWrite = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 5, 3))
pcomSnmpAuthReadWriteCommunity = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 5, 3, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pcomSnmpAuthReadWriteCommunity.setStatus('mandatory')
if mibBuilder.loadTexts: pcomSnmpAuthReadWriteCommunity.setDescription('The community string used to identify an SNMP community with access rights of Read-Write. Note, this object may only be read or written using the read-write community. Read-only access to this object is denied.')
pcomSnmpAuthReadWriteUserTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 5, 3, 2), )
if mibBuilder.loadTexts: pcomSnmpAuthReadWriteUserTable.setStatus('mandatory')
if mibBuilder.loadTexts: pcomSnmpAuthReadWriteUserTable.setDescription('A list of Read-Write users and associated information.')
pcomSnmpAuthReadWriteUserEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 5, 3, 2, 1), ).setIndexNames((0, "DECHUB900-COMMON-MIB-V3-0", "pcomSnmpAuthReadWriteUserAddr"))
if mibBuilder.loadTexts: pcomSnmpAuthReadWriteUserEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pcomSnmpAuthReadWriteUserEntry.setDescription('Objects containing information for a given Read-Write user. Rows are created when pcomSnmpAuthReadWriteUserAddr is set, and deleted when pcomSnmpAuthReadWriteUserStatus is set to invalid(2).')
pcomSnmpAuthReadWriteUserAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 5, 3, 2, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pcomSnmpAuthReadWriteUserAddr.setStatus('mandatory')
if mibBuilder.loadTexts: pcomSnmpAuthReadWriteUserAddr.setDescription("An IP Address, or a set of IP addresses, which has Read-Write SNMP access to this agent. If this object is used as a wildcard, bits corresponding to the zero bits in the corresponding euthReadWriteUserMask are treated as don't-care. Note, this object may only be read or written using the read-write community. Read-only access to this object is denied.")
pcomSnmpAuthReadWriteUserMask = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 5, 3, 2, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pcomSnmpAuthReadWriteUserMask.setStatus('mandatory')
if mibBuilder.loadTexts: pcomSnmpAuthReadWriteUserMask.setDescription("UserMask is used to provide 'wildcard' authorized users. It is a 32-bit mask which is applied to (ANDed with) the source IP address of an incoming SNMP message. If the result of the mask is equal to an address in pcomSnmpAuthReadOnlyUserAddr, the message is considered to have come from a user who has Read-only access. This allows wildcarding. For example, a user address of 16.20.0.0 and a mask of 255.255.0.0 allow access to all NMS's on subnet 16.20. The default value for this mask is all 1's. Note, this object may only be read or written using the read-write community. Read-only access to this object is denied.")
pcomSnmpAuthReadWriteUserStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 5, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pcomSnmpAuthReadWriteUserStatus.setStatus('mandatory')
if mibBuilder.loadTexts: pcomSnmpAuthReadWriteUserStatus.setDescription('Writing invalid(2) to this object removes the corresponding entry. When read, this object always returns a value of other(1). Note, this object may only be read or written using the read-write community. Read-only access to this object is denied.')
pcomSnmpAuthUnauth = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 5, 4))
pcomSnmpAuthUnauthTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 5, 4, 1), )
if mibBuilder.loadTexts: pcomSnmpAuthUnauthTable.setStatus('mandatory')
if mibBuilder.loadTexts: pcomSnmpAuthUnauthTable.setDescription('A list of unauthorized user entries.')
pcomSnmpAuthUnauthEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 5, 4, 1, 1), ).setIndexNames((0, "DECHUB900-COMMON-MIB-V3-0", "pcomSnmpAuthUnauthIndex"))
if mibBuilder.loadTexts: pcomSnmpAuthUnauthEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pcomSnmpAuthUnauthEntry.setDescription('An unauthorized user entry containing information common to a single case where an snmp management message for not authorized.')
pcomSnmpAuthUnauthIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 5, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcomSnmpAuthUnauthIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pcomSnmpAuthUnauthIndex.setDescription('A unique integer used to index this table.')
pcomSnmpAuthUnauthTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 5, 4, 1, 1, 2), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcomSnmpAuthUnauthTimeStamp.setStatus('mandatory')
if mibBuilder.loadTexts: pcomSnmpAuthUnauthTimeStamp.setDescription('The value of sysUpTime when the message was unauthenticated.')
pcomSnmpAuthUnauthIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 5, 4, 1, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcomSnmpAuthUnauthIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: pcomSnmpAuthUnauthIpAddress.setDescription('The IP address upon which the unauthenticated message arrived.')
pcomSnmpAuthUnauthUdpPort = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 5, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcomSnmpAuthUnauthUdpPort.setStatus('mandatory')
if mibBuilder.loadTexts: pcomSnmpAuthUnauthUdpPort.setDescription('The UDP port number upon which the unauthenticated message arrived.')
pcomSnmpAuthUnauthCommunity = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 5, 4, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcomSnmpAuthUnauthCommunity.setStatus('mandatory')
if mibBuilder.loadTexts: pcomSnmpAuthUnauthCommunity.setDescription('The community string present in the unauthenticated message. Only the only the first 32 octets of the community string are kept.')
pcomSnmpAuthUnauthOperation = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 5, 4, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("getRequest", 2), ("getNextRequest", 3), ("getResponse", 4), ("setRequest", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcomSnmpAuthUnauthOperation.setStatus('mandatory')
if mibBuilder.loadTexts: pcomSnmpAuthUnauthOperation.setDescription('The attempted operation.')
pcomSnmpAuthUnauthReason = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 5, 4, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("badComName", 1), ("badComUse", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcomSnmpAuthUnauthReason.setStatus('mandatory')
if mibBuilder.loadTexts: pcomSnmpAuthUnauthReason.setDescription("The reason for failing to authenticate the message. A value of badComName(1) indicates that the community string in the failed message does not match a community supported by the device. This corresponds to the incrementing of the mib-ii object 'snmpInBadCommunityNames'. A value of badComUse(2) indicates that the user id (ip address and udp port) does not match a user id supported by the device. This corresponds the the incrementing of the mib-ii object 'snmpInBadCommunityUses'.")
pcomErrLogNumEntries = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 6, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcomErrLogNumEntries.setStatus('mandatory')
if mibBuilder.loadTexts: pcomErrLogNumEntries.setDescription('The number of entries in the pcomErrLogTable. The value of this object is initially zero. It is incremented as pcomErrLogEntries are added, to a maximum value. The maximum value is implementation specific.')
pcomErrLogTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 6, 2), )
if mibBuilder.loadTexts: pcomErrLogTable.setStatus('mandatory')
if mibBuilder.loadTexts: pcomErrLogTable.setDescription('A table which describes errors encountered by the system.')
pcomErrLogEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 6, 2, 1), ).setIndexNames((0, "DECHUB900-COMMON-MIB-V3-0", "pcomErrLogIndex"))
if mibBuilder.loadTexts: pcomErrLogEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pcomErrLogEntry.setDescription('A list of errors logged by the system.')
pcomErrLogIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 6, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcomErrLogIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pcomErrLogIndex.setDescription('The value of this object uniquely identifies an entry in the pcomErrLogTable.')
pcomErrLogTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 6, 2, 1, 2), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcomErrLogTimeStamp.setStatus('mandatory')
if mibBuilder.loadTexts: pcomErrLogTimeStamp.setDescription('The value of sysUpTime at the time in which the error is logged.')
pcomErrLogResetNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 6, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcomErrLogResetNumber.setStatus('mandatory')
if mibBuilder.loadTexts: pcomErrLogResetNumber.setDescription('The number of resets which have occurred at the time in which the error is logged. (This is the sum of pcomEsysPowerups, pcomEsysMgmtResets, and pcomEsysUnsolicitedResets.)')
pcomErrLogInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 6, 2, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcomErrLogInfo.setStatus('mandatory')
if mibBuilder.loadTexts: pcomErrLogInfo.setDescription('A textual description of the error being logged.')
pcomErrLogFwVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 6, 2, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcomErrLogFwVersion.setStatus('mandatory')
if mibBuilder.loadTexts: pcomErrLogFwVersion.setDescription('The firmware version at the time in which the error is logged.')
pcomEsysPowerups = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 7, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcomEsysPowerups.setStatus('mandatory')
if mibBuilder.loadTexts: pcomEsysPowerups.setDescription('The number of times this device was powered on. Power Ups, Management Resets and Unsolicited Resets are all mutually exclusive.')
pcomEsysMgmtResets = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 7, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcomEsysMgmtResets.setStatus('mandatory')
if mibBuilder.loadTexts: pcomEsysMgmtResets.setDescription('The number of times the device was initialized with a management command. Power Ups, Management Resets and Unsolicited Resets are all mutually exclusive.')
pcomEsysUnsolicitedResets = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 7, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcomEsysUnsolicitedResets.setStatus('mandatory')
if mibBuilder.loadTexts: pcomEsysUnsolicitedResets.setDescription('Number of times the device initialized itself after encountering a fatal error. Power Ups, Management Resets and Unsolicited Resets are all mutually exclusive.')
pcomEsysNVRAMfailedFlag = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 7, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcomEsysNVRAMfailedFlag.setStatus('mandatory')
if mibBuilder.loadTexts: pcomEsysNVRAMfailedFlag.setDescription("When true(1), this flag indicates that the device's non-volatile memory store has failed. Devices whose non-volatile memory store have failed still accept SNMP sets. If the SNMP set request refers to a non-volatile object and this flag is true only the volatile copy of the object is set. If the non-volatile memory failure was detected by the power on selftest then pcomDiagFailure is non-zero.")
pcomEsysNVRAMsize = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 7, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcomEsysNVRAMsize.setStatus('mandatory')
if mibBuilder.loadTexts: pcomEsysNVRAMsize.setDescription('The size of the non-volatile store. Note that this is the unformated size, and as such may not reflects the number usable octets provided by the store.')
pcomEsysNVRAMavailableOctets = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 7, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcomEsysNVRAMavailableOctets.setStatus('mandatory')
if mibBuilder.loadTexts: pcomEsysNVRAMavailableOctets.setDescription('The number of octets currently available in the non-volatile store. Note that this may not provide a one-to-one mapping of user data to availableOctets. For example, in order to store a two characters in an object defined as DisplayString (SIZE( 0..128)) the device may choose to allocate 128 octets. Furthermore, directory overhead information may be allocated from the availableOctets. In other words, this object provides only a rough estimate. Your mileage may vary. Despite these shortcomings, when 0, this object conveys the fact that no non-volatile parameters may be added.')
pcomEsysHubVersion = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 7, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcomEsysHubVersion.setStatus('mandatory')
if mibBuilder.loadTexts: pcomEsysHubVersion.setDescription('The version number of the hub citizenship code that is being used in this device.')
pcomEifTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 8, 1), )
if mibBuilder.loadTexts: pcomEifTable.setStatus('mandatory')
if mibBuilder.loadTexts: pcomEifTable.setDescription('A table which describes extensions for the mib-2 interface group.')
pcomEifEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 8, 1, 1), ).setIndexNames((0, "DECHUB900-COMMON-MIB-V3-0", "pcomEifIndex"))
if mibBuilder.loadTexts: pcomEifEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pcomEifEntry.setDescription('A list of interface information. For each instance of MIB-2 interface group ifIndex there exists a corresponding instance of pcomEifIndex.')
pcomEifIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 8, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcomEifIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pcomEifIndex.setDescription('The value of this object uniquely identifies an entry in the pcomEifTable. Each pcomEifTable corresponds to an instance of ifIndex in the MIB-2 interface group.')
pcomEifInBroadcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 8, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcomEifInBroadcastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: pcomEifInBroadcastPkts.setDescription('Interfaces which support broadcasting (e.g. ethernet-csmacd ports - ifType 6) return the number of broadcast packets delivered to a higher-layer protocol. Interfaces which do not support broadcasting (e.g. slip ports - ifType 28) return zero when queried for this object.')
pcomLigoNumEntries = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 9, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcomLigoNumEntries.setStatus('mandatory')
if mibBuilder.loadTexts: pcomLigoNumEntries.setDescription('The number of entries in the LIGO table.')
pcomLigoTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 9, 2), )
if mibBuilder.loadTexts: pcomLigoTable.setStatus('mandatory')
if mibBuilder.loadTexts: pcomLigoTable.setDescription('A list of LIGOs (building blocks).')
pcomLigoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 9, 2, 1), ).setIndexNames((0, "DECHUB900-COMMON-MIB-V3-0", "pcomLigoIndex"))
if mibBuilder.loadTexts: pcomLigoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pcomLigoEntry.setDescription('A LIGO entry containing objects which describe the building block.')
pcomLigoIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 9, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcomLigoIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pcomLigoIndex.setDescription('A unique value for each LIGO. The value of this object ranges between 1 and n where n is the total number of building blocks supported by the device.')
pcomLigoType = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 9, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("fddi", 2), ("ethernet", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcomLigoType.setStatus('mandatory')
if mibBuilder.loadTexts: pcomLigoType.setDescription("A building block's type.")
pcomLigoSubtypeSelect = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 9, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pcomLigoSubtypeSelect.setStatus('mandatory')
if mibBuilder.loadTexts: pcomLigoSubtypeSelect.setDescription('The pcomLigoSubtypeIndex into the pcomLigoSubtypeTable describes the specific LIGO type is supported. The value of this object must be a valid index in the pcomLigoTable. A value of 0 indicates that no subtype has been selected.')
pcomLigoSubtypeNumEntries = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 9, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcomLigoSubtypeNumEntries.setStatus('mandatory')
if mibBuilder.loadTexts: pcomLigoSubtypeNumEntries.setDescription('The number of entries in the pcomLigoSubtypeTable.')
pcomLigoSubtypeTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 9, 4), )
if mibBuilder.loadTexts: pcomLigoSubtypeTable.setStatus('mandatory')
if mibBuilder.loadTexts: pcomLigoSubtypeTable.setDescription('A list of LIGO (building blocks) subtypes.')
pcomLigoSubtypeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 9, 4, 1), ).setIndexNames((0, "DECHUB900-COMMON-MIB-V3-0", "pcomLigoSubtypeIndex"))
if mibBuilder.loadTexts: pcomLigoSubtypeEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pcomLigoSubtypeEntry.setDescription("An entry containing objects which describe the building block's specific type.")
pcomLigoSubtypeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 9, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcomLigoSubtypeIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pcomLigoSubtypeIndex.setDescription('A unique value for each LIGO subtype.')
pcomLigoSubtypeLigoIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 9, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcomLigoSubtypeLigoIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pcomLigoSubtypeLigoIndex.setDescription('The value of the LigoIndex in the pcomLigoTable that can use this subtype.')
pcomLigoSubtypeLabelIndexMask = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 9, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcomLigoSubtypeLabelIndexMask.setStatus('mandatory')
if mibBuilder.loadTexts: pcomLigoSubtypeLabelIndexMask.setDescription('This object specifies the labels that are used by this LigoSubtype. It is a bit map of if indexes from the pcomLigoLabelTable with bit 0 corresponding to if index 1. Bits set to 1 indicate the labels which are used by the LigoSubtype.')
pcomLigoSubtypeFlavor = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 9, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("fddiRoot-Primary", 1), ("fddiRoot-Secondary", 2), ("fddiNonroot", 3), ("fddiTrunk-A-Primary", 4), ("fddiTrunk-A-Secondary", 5), ("fddiTrunk-B-Primary", 6), ("fddiTrunk-B-Secondary", 7), ("fddiTrunk-AB-Primary", 8), ("fddiTrunk-AB-Secondary", 9), ("fddiStump-Primary", 10), ("fddiStump-Secondary", 11), ("ethernet-front", 12), ("ethernet-back", 13), ("fddiNonroot-M", 14), ("fddiNonroot-S", 15), ("fddiNonroot-SM", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcomLigoSubtypeFlavor.setStatus('mandatory')
if mibBuilder.loadTexts: pcomLigoSubtypeFlavor.setDescription("A building block's type.")
pcomLigoLabelNumEntries = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 9, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcomLigoLabelNumEntries.setStatus('mandatory')
if mibBuilder.loadTexts: pcomLigoLabelNumEntries.setDescription('The number of entries in the pcomLigo label table.')
pcomLigoLabelTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 9, 6), )
if mibBuilder.loadTexts: pcomLigoLabelTable.setStatus('mandatory')
if mibBuilder.loadTexts: pcomLigoLabelTable.setDescription('A list of Labels (for ports).')
pcomLigoLabelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 9, 6, 1), ).setIndexNames((0, "DECHUB900-COMMON-MIB-V3-0", "pcomLigoLabelIndex"))
if mibBuilder.loadTexts: pcomLigoLabelEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pcomLigoLabelEntry.setDescription('An entry containing objects which describe the label of the port affected by the LIGO this module supports.')
pcomLigoLabelIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 9, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcomLigoLabelIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pcomLigoLabelIndex.setDescription('A unique value for each Label. The value of this object ranges between 1 and n where n is the total number of Labels supported by the device.')
pcomLigoLabelString = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 9, 6, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcomLigoLabelString.setStatus('mandatory')
if mibBuilder.loadTexts: pcomLigoLabelString.setDescription('A textual description of the port number associated with a LIGO. If the device is bridge then bridge port numbers are used. If the device is a wiring concentrator then concentrator port numbers are used.')
pcomConTotalConfigChanges = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 10, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcomConTotalConfigChanges.setStatus('mandatory')
if mibBuilder.loadTexts: pcomConTotalConfigChanges.setDescription('The total number of configuration changes since power up.')
pcomConNumEntries = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 10, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcomConNumEntries.setStatus('mandatory')
if mibBuilder.loadTexts: pcomConNumEntries.setDescription('The number of entries in the Connector table.')
pcomConTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 10, 3), )
if mibBuilder.loadTexts: pcomConTable.setStatus('mandatory')
if mibBuilder.loadTexts: pcomConTable.setDescription('A list of front bezel and docking station connectors, internal thinwires, and MACs on a line card.')
pcomConEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 10, 3, 1), ).setIndexNames((0, "DECHUB900-COMMON-MIB-V3-0", "pcomConIndex"))
if mibBuilder.loadTexts: pcomConEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pcomConEntry.setDescription('A connector entry contains objects which describe a front bezel connector, docking station connector, internal thinwire, or MAC.')
pcomConIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 10, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcomConIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pcomConIndex.setDescription('A unique value for each front bezel connector, docking station connector, internal thinwire, or MAC. The value of this object ranges between 1 and n where n is the total number of front bezel connectors, docking station connectors, internal thinwires, and MACs supported by the device.')
pcomConTech = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 10, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("ethernet", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcomConTech.setStatus('mandatory')
if mibBuilder.loadTexts: pcomConTech.setDescription('A front bezel connector, docking station connector, internal thinwire, or MAC technology type.')
pcomConClass = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 10, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("bezcon", 1), ("extcon", 2), ("interthinwire", 3), ("mac", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcomConClass.setStatus('mandatory')
if mibBuilder.loadTexts: pcomConClass.setDescription("An entry's class. This indicates whether a entry is a front bezel connector, docking station connector, internal thinwire, or MAC.")
pcomConGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 10, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pcomConGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: pcomConGroupId.setDescription('The identifier of a connector, internal thinwire, and/or MAC group that are only assignable together to an internal LAN. In other words if you assign one of these connectors you assign them all.')
pcomConGroupSet = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 10, 3, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcomConGroupSet.setStatus('mandatory')
if mibBuilder.loadTexts: pcomConGroupSet.setDescription('This object specifies the group Ids that a connector, internal thinwire, or MAC can join. It is a bit map of pcomConTable Group Ids with bit 1 corresponding to pcomConGroupId 1. Bits set to one indicate the groups that connector, internal thinwire, or MAC can join.')
pcomConLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 10, 3, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcomConLabel.setStatus('mandatory')
if mibBuilder.loadTexts: pcomConLabel.setDescription('Text that contains the connector label on either the front bezel or docking station. If it is an internal thinwire or MAC this text describes the function. This string may change when the Subtype Selected changes.')
pcomConSubtypeSelect = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 10, 3, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pcomConSubtypeSelect.setStatus('mandatory')
if mibBuilder.loadTexts: pcomConSubtypeSelect.setDescription('The pcomConSubtypeIndex points into the pcomConSubtypeTable which describes the specific media type a connector, internal thinwire, or MAC that is selected to support. The value of this object ranges between 0 and n where n is the total number of backplane subtypes described by the pcomConSubtypeTable. A value of 0 indicates that no subtype has been selected. This object in non-volatile.')
pcomConSubtypeNumEntries = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 10, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcomConSubtypeNumEntries.setStatus('mandatory')
if mibBuilder.loadTexts: pcomConSubtypeNumEntries.setDescription('The number of entries in the connector subtype table.')
pcomConSubtypeTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 10, 5), )
if mibBuilder.loadTexts: pcomConSubtypeTable.setStatus('mandatory')
if mibBuilder.loadTexts: pcomConSubtypeTable.setDescription('A list of connector, internal thinwire, and MAC subtypes supported by a line card.')
pcomConSubtypeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 10, 5, 1), ).setIndexNames((0, "DECHUB900-COMMON-MIB-V3-0", "pcomConSubtypeIndex"))
if mibBuilder.loadTexts: pcomConSubtypeEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pcomConSubtypeEntry.setDescription('A backplane subtype entry containing objects which describe the subtypes supported by connectors.')
pcomConSubtypeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 10, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcomConSubtypeIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pcomConSubtypeIndex.setDescription('A unique value for each Flavor supported by a the set of connectors indicated in pcomConSubtypeConSet. The value of this object ranges between 1 and n, where n is the total number of connector subtypes supported by a module.')
pcomConSubtypeConSet = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 10, 5, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcomConSubtypeConSet.setStatus('mandatory')
if mibBuilder.loadTexts: pcomConSubtypeConSet.setDescription('This object specifies the connect indices, in the pcomConTable, which can support the specified pcomConSubtypeFlavor.')
pcomConSubtypeFlavor = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 10, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("default", 1), ("thinwire", 2), ("aui", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcomConSubtypeFlavor.setStatus('mandatory')
if mibBuilder.loadTexts: pcomConSubtypeFlavor.setDescription('The specific media type a connector supports.')
pcomConIntLanNumEntries = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 10, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcomConIntLanNumEntries.setStatus('mandatory')
if mibBuilder.loadTexts: pcomConIntLanNumEntries.setDescription('The number of entries in the internal LAN table.')
pcomConIntLanTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 10, 7), )
if mibBuilder.loadTexts: pcomConIntLanTable.setStatus('mandatory')
if mibBuilder.loadTexts: pcomConIntLanTable.setDescription('A list of internal LANs in a line card. Each line card has a pcomConIntLanTable containing one entry for each of its internal LANs.')
pcomConIntLanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 10, 7, 1), ).setIndexNames((0, "DECHUB900-COMMON-MIB-V3-0", "pcomConIntLanIndex"))
if mibBuilder.loadTexts: pcomConIntLanEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pcomConIntLanEntry.setDescription('An internal LAN entry containing objects which describe a internal LAN.')
pcomConIntLanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 10, 7, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcomConIntLanIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pcomConIntLanIndex.setDescription('A unique value for each internal LAN.')
pcomConIntLanGroupIdMask = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 10, 7, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcomConIntLanGroupIdMask.setStatus('mandatory')
if mibBuilder.loadTexts: pcomConIntLanGroupIdMask.setDescription('This object specifies the group Ids of connectors, internal thinwire, and MACs that can be connected to this internal LAN. It is a bit map of pcomConTable Group Ids with bit 1 corresponding to pcomConGroupId 1. Bits set to one indicate the groups of connector, internal thinwire, and MACs which can access this internal LAN.')
pcomConIntLanName = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 10, 7, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pcomConIntLanName.setStatus('mandatory')
if mibBuilder.loadTexts: pcomConIntLanName.setDescription('Text that contains a name given to an internal LAN. The default value is a zero length string.')
pcomConAssignNumEntries = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 10, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcomConAssignNumEntries.setStatus('mandatory')
if mibBuilder.loadTexts: pcomConAssignNumEntries.setDescription('The number of entries in the connector assignment table.')
pcomConAssignTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 10, 9), )
if mibBuilder.loadTexts: pcomConAssignTable.setStatus('mandatory')
if mibBuilder.loadTexts: pcomConAssignTable.setDescription('A list of connector, internal tw, and MAC groups to internal LAN assignments of a line card. The creation of a table entry, creates a connection of a front connector, MAC, or internal thinwire group to an internal LAN.')
pcomConAssignEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 10, 9, 1), ).setIndexNames((0, "DECHUB900-COMMON-MIB-V3-0", "pcomConAssignIndex"))
if mibBuilder.loadTexts: pcomConAssignEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pcomConAssignEntry.setDescription("A connector group assignment entry contains objects which describe a line card's connections of connectors, internal thinwires, and MACs to internal LANs.")
pcomConAssignIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 10, 9, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pcomConAssignIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pcomConAssignIndex.setDescription('A unique value for each connector group assignment. This object in non-volatile.')
pcomConAssignConGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 10, 9, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pcomConAssignConGroup.setStatus('mandatory')
if mibBuilder.loadTexts: pcomConAssignConGroup.setDescription('Specifies the id of the connector group in the pcomConTable for which the assignment applies. Together with pcomConAssignIntLan, this defines a group of connectors to LAN assignment. This object in non-volatile.')
pcomConAssignIntLan = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 10, 9, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pcomConAssignIntLan.setStatus('mandatory')
if mibBuilder.loadTexts: pcomConAssignIntLan.setDescription('Specifies the index of the internal LAN described in the pcomConIntLanTable for which the assignment applies. Together with pcomConAssignConGroup, this defines a connector to LAN assignment. This object in non-volatile.')
pcomConAssignEntryStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 10, 9, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("valid", 1), ("createRequest", 2), ("underCreation", 3), ("invalid", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pcomConAssignEntryStatus.setStatus('mandatory')
if mibBuilder.loadTexts: pcomConAssignEntryStatus.setDescription('The status of a table entry. This object in non-volatile.')
pcom90mgtBackplaneHubMaster = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 11, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pcom90mgtBackplaneHubMaster.setStatus('mandatory')
if mibBuilder.loadTexts: pcom90mgtBackplaneHubMaster.setDescription("The desired state of the DEChub 90 manager's hub mastership (i.e. it's ability to directly manage repeaters, terminal servers and bridges and discover other modules which reside in the same hub as the agent). This value is retained in non-volatile storage. Its default value is disable(1).")
pcom90mgtBackplaneHubMasterState = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 11, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcom90mgtBackplaneHubMasterState.setStatus('mandatory')
if mibBuilder.loadTexts: pcom90mgtBackplaneHubMasterState.setDescription('Indicates whether the DEChub 90 manager is managing the hub (i.e. capable of directly managing repeaters, terminal servers and bridges and discovering other modules). Its default value is disabled(1).')
pcom90mgtBackplaneConfig = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 2, 11, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notConfigured", 1), ("standAlone", 2), ("single-DEChub90", 3), ("pair-DEChub90", 4), ("decStack90", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pcom90mgtBackplaneConfig.setStatus('mandatory')
if mibBuilder.loadTexts: pcom90mgtBackplaneConfig.setDescription("Indicates whether the DEChub 90 manager is managing the a single DEChub 90, a pair of DEChub 90's, a DECstack 90 or is just stand alone. If this is notConfigured(1) or standAlone(2), then the DEChub 90 manager will consider its pcom90mgtBackplaneHubMasterState as disabled(1). This value is retained in non-volatile storage. It's default value is notConfigured(1). NOTE: A successful set to this object should be followed by a reset to current settings.")
mibBuilder.exportSymbols("DECHUB900-COMMON-MIB-V3-0", pcomConIntLanIndex=pcomConIntLanIndex, pcomConNumEntries=pcomConNumEntries, pcomConSubtypeNumEntries=pcomConSubtypeNumEntries, pcomConTable=pcomConTable, pcomSnmpAuthReadWrite=pcomSnmpAuthReadWrite, pcomSnmpAuthTrapUserStatus=pcomSnmpAuthTrapUserStatus, pcomLedInterestingChanges=pcomLedInterestingChanges, pcomSnmpAuth=pcomSnmpAuth, pcomLigoNumEntries=pcomLigoNumEntries, dec=dec, pcomErrLogTimeStamp=pcomErrLogTimeStamp, pcomLigoLabelTable=pcomLigoLabelTable, pcomLigoLabelIndex=pcomLigoLabelIndex, pcomLigoSubtypeTable=pcomLigoSubtypeTable, decHub900=decHub900, pcomConIntLanTable=pcomConIntLanTable, pcomLigoLabelNumEntries=pcomLigoLabelNumEntries, pcomLigo=pcomLigo, pcomConTotalConfigChanges=pcomConTotalConfigChanges, pcomSnmpAuthTrap=pcomSnmpAuthTrap, pcomSnmpAuthUnauthUdpPort=pcomSnmpAuthUnauthUdpPort, pcomConClass=pcomConClass, pcomConSubtypeEntry=pcomConSubtypeEntry, pcomSnmpAuthUnauthTable=pcomSnmpAuthUnauthTable, pcomConSubtypeTable=pcomConSubtypeTable, pcomHubId=pcomHubId, pcom90mgtBackplaneHubMaster=pcom90mgtBackplaneHubMaster, pcomSlot=pcomSlot, pcomErrLogFwVersion=pcomErrLogFwVersion, pcomSnmpAuthReadWriteUserMask=pcomSnmpAuthReadWriteUserMask, pcomErrLogResetNumber=pcomErrLogResetNumber, pcomLedDescr=pcomLedDescr, pcomLigoSubtypeFlavor=pcomLigoSubtypeFlavor, pcom90mgt=pcom90mgt, pcomConIntLanNumEntries=pcomConIntLanNumEntries, pcomSnmpAuthReadOnlyUserTable=pcomSnmpAuthReadOnlyUserTable, pcomEsys=pcomEsys, pcomConIntLanName=pcomConIntLanName, pubCommon=pubCommon, pcomLigoEntry=pcomLigoEntry, pcomSnmpAuthUnauthCommunity=pcomSnmpAuthUnauthCommunity, pcomConSubtypeFlavor=pcomConSubtypeFlavor, pcomEsysNVRAMsize=pcomEsysNVRAMsize, pcomConAssignTable=pcomConAssignTable, pcomLedIndex=pcomLedIndex, pcomConSubtypeSelect=pcomConSubtypeSelect, pcomErrLogInfo=pcomErrLogInfo, pcomEifEntry=pcomEifEntry, pcomErrLogEntry=pcomErrLogEntry, pcomSnmpAuthTrapCommunity=pcomSnmpAuthTrapCommunity, pcomConGroupId=pcomConGroupId, pcomSnmpAuthReadWriteUserStatus=pcomSnmpAuthReadWriteUserStatus, pcomSnmpAuthReadOnlyCommunity=pcomSnmpAuthReadOnlyCommunity, pcomErrLog=pcomErrLog, pcomSnmpAuthReadOnlyUserStatus=pcomSnmpAuthReadOnlyUserStatus, pcomLoadOperStatus=pcomLoadOperStatus, pcomConSubtypeConSet=pcomConSubtypeConSet, pcomLoadIpHostAddr=pcomLoadIpHostAddr, decMIBextension=decMIBextension, pcomConAssignNumEntries=pcomConAssignNumEntries, pcomLigoType=pcomLigoType, pcomSnmpAuthUnauthTimeStamp=pcomSnmpAuthUnauthTimeStamp, pcomLoad=pcomLoad, pcomConEntry=pcomConEntry, pcomErrLogNumEntries=pcomErrLogNumEntries, pcomSnmpAuthReadOnlyUserAddr=pcomSnmpAuthReadOnlyUserAddr, pcomLedProgram=pcomLedProgram, pcomLigoLabelEntry=pcomLigoLabelEntry, pcomEsysMgmtResets=pcomEsysMgmtResets, pcomLigoSubtypeNumEntries=pcomLigoSubtypeNumEntries, pcomLedEntry=pcomLedEntry, pcomConIndex=pcomConIndex, pcomLigoTable=pcomLigoTable, pcomSlotNumber=pcomSlotNumber, pcomConGroupSet=pcomConGroupSet, pcomSnmpAuthUnauth=pcomSnmpAuthUnauth, pcomSnmpAuthReadWriteUserAddr=pcomSnmpAuthReadWriteUserAddr, pcomCon=pcomCon, pcomConAssignIntLan=pcomConAssignIntLan, pcomEsysHubVersion=pcomEsysHubVersion, pcomAdminStatus=pcomAdminStatus, pcomEsn=pcomEsn, pcomSnmpAuthReadOnlyUserEntry=pcomSnmpAuthReadOnlyUserEntry, pcomSnmpAuthTrapUserTable=pcomSnmpAuthTrapUserTable, pcomSnmpAuthTrapUserEntry=pcomSnmpAuthTrapUserEntry, pcomEifInBroadcastPkts=pcomEifInBroadcastPkts, pcomLoadTftpDirection=pcomLoadTftpDirection, pcomSnmpAuthReadWriteCommunity=pcomSnmpAuthReadWriteCommunity, pcomLigoSubtypeLabelIndexMask=pcomLigoSubtypeLabelIndexMask, pcomErrLogTable=pcomErrLogTable, pcomEif=pcomEif, pcomLigoSubtypeIndex=pcomLigoSubtypeIndex, pcomSnmpAuthUnauthIndex=pcomSnmpAuthUnauthIndex, pcomLigoSubtypeEntry=pcomLigoSubtypeEntry, pcom90mgtBackplaneConfig=pcom90mgtBackplaneConfig, pcomEsysUnsolicitedResets=pcomEsysUnsolicitedResets, pcomLigoSubtypeSelect=pcomLigoSubtypeSelect, pcomHubIpAddress=pcomHubIpAddress, pcomLoadAdminStatus=pcomLoadAdminStatus, pcomSnmpAuthReadOnly=pcomSnmpAuthReadOnly, pcomEsysNVRAMavailableOctets=pcomEsysNVRAMavailableOctets, pcomHub=pcomHub, pcomConAssignEntryStatus=pcomConAssignEntryStatus, pcomLoadFilename=pcomLoadFilename, pcomEsysPowerups=pcomEsysPowerups, pcom90mgtBackplaneHubMasterState=pcom90mgtBackplaneHubMasterState, pcomConTech=pcomConTech, pcomSnmpAuthReadWriteUserTable=pcomSnmpAuthReadWriteUserTable, pcomConSubtypeIndex=pcomConSubtypeIndex, pcomLigoSubtypeLigoIndex=pcomLigoSubtypeLigoIndex, pcomDiagFailure=pcomDiagFailure, pcomSnmpAuthUnauthEntry=pcomSnmpAuthUnauthEntry, pcomConLabel=pcomConLabel, pcomConIntLanGroupIdMask=pcomConIntLanGroupIdMask, pcomEifTable=pcomEifTable, pcomConIntLanEntry=pcomConIntLanEntry, pcomConAssignEntry=pcomConAssignEntry, ema=ema, pcomSnmpAuthUnauthReason=pcomSnmpAuthUnauthReason, pcomSnmpAuthTrapUserAddr=pcomSnmpAuthTrapUserAddr, pcomHubCommunity=pcomHubCommunity, pcomLigoIndex=pcomLigoIndex, pcomOperStatus=pcomOperStatus, pcomEifIndex=pcomEifIndex, pcomSerialNumber=pcomSerialNumber, pcomLoadDevSpecific=pcomLoadDevSpecific, pcomSnmpAuthReadOnlyUserMask=pcomSnmpAuthReadOnlyUserMask, pcomErrLogIndex=pcomErrLogIndex, pcomConAssignIndex=pcomConAssignIndex, pcomSnmpAuthReadWriteUserEntry=pcomSnmpAuthReadWriteUserEntry, pcomEsysNVRAMfailedFlag=pcomEsysNVRAMfailedFlag, pcomLigoLabelString=pcomLigoLabelString, pcomLedTable=pcomLedTable, pcomConAssignConGroup=pcomConAssignConGroup, pcomSnmpAuthUnauthIpAddress=pcomSnmpAuthUnauthIpAddress, pcomSnmpAuthUnauthOperation=pcomSnmpAuthUnauthOperation, pcomLed=pcomLed)

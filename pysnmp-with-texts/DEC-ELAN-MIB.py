#
# PySNMP MIB module DEC-ELAN-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/DEC-ELAN-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:37:27 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, SingleValueConstraint, ConstraintsUnion, ValueRangeConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsUnion", "ValueRangeConstraint", "ConstraintsIntersection")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Unsigned32, enterprises, Gauge32, iso, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, IpAddress, MibIdentifier, Bits, Counter32, ModuleIdentity, Counter64, Integer32, NotificationType, ObjectIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "Unsigned32", "enterprises", "Gauge32", "iso", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "IpAddress", "MibIdentifier", "Bits", "Counter32", "ModuleIdentity", "Counter64", "Integer32", "NotificationType", "ObjectIdentity")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
dec = MibIdentifier((1, 3, 6, 1, 4, 1, 36))
ema = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2))
decMIBextension = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18))
elanext = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 1))
efddi = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 1))
esystem = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 2))
einterfaces = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 3))
ebridge = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4))
eauth = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 5))
efddiSMT = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 1, 1))
efddiMAC = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 1, 2))
efddiPORT = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 1, 3))
efddiFDX = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 1, 4))
efddiSMTTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 1, 1, 1), )
if mibBuilder.loadTexts: efddiSMTTable.setStatus('mandatory')
if mibBuilder.loadTexts: efddiSMTTable.setDescription('A list of SMT entries. The number of entries is given by smtNumber, defined in the FDDI MIB.')
efddiSMTEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 1, 1, 1, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "eSMTIndex"))
if mibBuilder.loadTexts: efddiSMTEntry.setStatus('mandatory')
if mibBuilder.loadTexts: efddiSMTEntry.setDescription('A collection of objects containing information for a given SMT link.')
eSMTIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 1, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eSMTIndex.setStatus('mandatory')
if mibBuilder.loadTexts: eSMTIndex.setDescription('Identifies the SMT Index. The value of this object is the same as the snmpFddiSMTIndex, defined in the FDDI MIB, for this smt entity.')
eSMTStationType = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 1, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("sas", 1), ("dac", 2), ("sac", 3), ("nac", 4), ("das", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: eSMTStationType.setStatus('mandatory')
if mibBuilder.loadTexts: eSMTStationType.setDescription('The Station Type Identification.')
eSMTTracesReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 1, 1, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eSMTTracesReceived.setStatus('mandatory')
if mibBuilder.loadTexts: eSMTTracesReceived.setDescription('The number of PC Traces received by this station.')
efddiMACTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 1, 2, 1), )
if mibBuilder.loadTexts: efddiMACTable.setStatus('mandatory')
if mibBuilder.loadTexts: efddiMACTable.setDescription('A list of MAC entries. The number of entries is given by macNumber, defined in the FDDI MIB.')
efddiMACEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 1, 2, 1, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "eMACSMTIndex"), (0, "DEC-ELAN-MIB", "eMACIndex"))
if mibBuilder.loadTexts: efddiMACEntry.setStatus('mandatory')
if mibBuilder.loadTexts: efddiMACEntry.setDescription('A collection of objects containing information for a given MAC entity.')
eMACSMTIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 1, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eMACSMTIndex.setStatus('mandatory')
if mibBuilder.loadTexts: eMACSMTIndex.setDescription('The value of the SMT index associated with this MAC. The value of this object is the same as the snmpFddiMACSMTIndex, defined in the FDDI MIB, for this MAC entity.')
eMACIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 1, 2, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eMACIndex.setStatus('mandatory')
if mibBuilder.loadTexts: eMACIndex.setDescription('Identifies the MAC Index. The value of this object is the same as the snmpFddiMACIndex, defined in the FDDI MIB, for this MAC entity.')
eMACLinkIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 1, 2, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eMACLinkIndex.setStatus('mandatory')
if mibBuilder.loadTexts: eMACLinkIndex.setDescription('The SMT Resource Index.')
eMACLinkState = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 1, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("offMaint", 1), ("offReady", 2), ("offFaultRecovery", 3), ("onRingInit", 4), ("onRingRun", 5), ("broken", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: eMACLinkState.setStatus('mandatory')
if mibBuilder.loadTexts: eMACLinkState.setDescription('The current state of the link.')
eMACRingPurgerState = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 1, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("purgerOff", 1), ("candidate", 2), ("nonPurger", 3), ("purger", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: eMACRingPurgerState.setStatus('mandatory')
if mibBuilder.loadTexts: eMACRingPurgerState.setDescription('The current Ring Purger state.')
eMACRingPurgerEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 1, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eMACRingPurgerEnable.setStatus('mandatory')
if mibBuilder.loadTexts: eMACRingPurgerEnable.setDescription('If true, this Link will participate in the Ring Purger Election and, if elected, perform the Ring Purger function.')
eMACRingPurgeErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 1, 2, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eMACRingPurgeErrors.setStatus('mandatory')
if mibBuilder.loadTexts: eMACRingPurgeErrors.setDescription('The number of times the MAC PurgeError Event bit was set.')
eMACFrameStripMode = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 1, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("saMatch", 1), ("bridgeStrip", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: eMACFrameStripMode.setStatus('mandatory')
if mibBuilder.loadTexts: eMACFrameStripMode.setDescription('Method of frame removal used by this station.')
eMACFCIStripErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 1, 2, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eMACFCIStripErrors.setStatus('mandatory')
if mibBuilder.loadTexts: eMACFCIStripErrors.setDescription('The number of times a Frame Content Independent Strip operation was terminated by receipt of a token.')
eMACRingErrorReason = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 1, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("noReason", 1), ("ringInitInitiated", 6), ("ringInitReceived", 7), ("ringBeaconingInitiated", 8), ("daDetected", 9), ("duplicateTokenDetected", 10), ("ringPurgeError", 11), ("bridgeStripError", 12), ("ringOpOscillation", 13), ("directedBeaconReceived", 14), ("pcTraceInitiated", 15), ("pcTraceReceived", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: eMACRingErrorReason.setStatus('mandatory')
if mibBuilder.loadTexts: eMACRingErrorReason.setDescription('Reason for last ring disturbance.')
eMACRingInitializationsInitiated = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 1, 2, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eMACRingInitializationsInitiated.setStatus('mandatory')
if mibBuilder.loadTexts: eMACRingInitializationsInitiated.setDescription('Number of Ring Claim Processes initiated by this link entity.')
eMACRingInitializationsReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 1, 2, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eMACRingInitializationsReceived.setStatus('mandatory')
if mibBuilder.loadTexts: eMACRingInitializationsReceived.setDescription('Number of Ring Claim Processes or Ring Beaconing Processes initiated by a remote link entity and detected by this link entity.')
eMACRingBeaconingInitiated = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 1, 2, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eMACRingBeaconingInitiated.setStatus('mandatory')
if mibBuilder.loadTexts: eMACRingBeaconingInitiated.setDescription('The number of Ring Beacon Processes initiated by this link entity.')
eMACDuplicateAddressTestFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 1, 2, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eMACDuplicateAddressTestFailures.setStatus('mandatory')
if mibBuilder.loadTexts: eMACDuplicateAddressTestFailures.setDescription('The number of times the duplicate address test failed.')
eMACDuplicateTokensDetected = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 1, 2, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eMACDuplicateTokensDetected.setStatus('mandatory')
if mibBuilder.loadTexts: eMACDuplicateTokensDetected.setDescription('The number of times this link entity detected a duplicate token.')
eMACUpstreamNbrDuplAddressFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 1, 2, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("true", 1), ("false", 2), ("unknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: eMACUpstreamNbrDuplAddressFlag.setStatus('mandatory')
if mibBuilder.loadTexts: eMACUpstreamNbrDuplAddressFlag.setDescription("The upstream neighbor's duplicate address status, as reported by the NIF frame. Unknown if no NIF frame has been received yet.")
eMACTracesInitiated = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 1, 2, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eMACTracesInitiated.setStatus('mandatory')
if mibBuilder.loadTexts: eMACTracesInitiated.setDescription('The number of PC Traces initiated by this station.')
eMACRestrictedTokenTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 1, 2, 1, 1, 18), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eMACRestrictedTokenTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: eMACRestrictedTokenTimeout.setDescription('The restricted token timeout, which limits how long a single restricted mode dialog may last before being terminated.')
eMACFrameStatusErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 1, 2, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eMACFrameStatusErrors.setStatus('mandatory')
if mibBuilder.loadTexts: eMACFrameStatusErrors.setDescription('The number of frames received on the line that had the E (error detected) indicator set or a missing E indicator.')
eMACFrameAlignmentErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 1, 2, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eMACFrameAlignmentErrors.setStatus('mandatory')
if mibBuilder.loadTexts: eMACFrameAlignmentErrors.setDescription('The number of frames received on the line that contained an odd number of symbols; that is, a non-integral number of octets.')
eMACTransmitUnderruns = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 1, 2, 1, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eMACTransmitUnderruns.setStatus('mandatory')
if mibBuilder.loadTexts: eMACTransmitUnderruns.setDescription("The number of times an underrun occured because the device's transmit FIFO became empty due to insufficient memory. In other words, the device was trying to transmit but could not get into memory fast enough.")
efddiPORTTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 1, 3, 1), )
if mibBuilder.loadTexts: efddiPORTTable.setStatus('mandatory')
if mibBuilder.loadTexts: efddiPORTTable.setDescription('A list of PORT entries. The number of entries is given by portNumber, defined in the FDDI MIB.')
efddiPORTEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 1, 3, 1, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "ePORTSMTIndex"), (0, "DEC-ELAN-MIB", "ePORTIndex"))
if mibBuilder.loadTexts: efddiPORTEntry.setStatus('mandatory')
if mibBuilder.loadTexts: efddiPORTEntry.setDescription('A collection of objects containing information for a given PORT entity.')
ePORTSMTIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 1, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ePORTSMTIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ePORTSMTIndex.setDescription('The value of the SMT index associated with this port. The value of this object is the same as the snmpFddiPORTSMTIndex, defined in the FDDI MIB, for this PORT entity.')
ePORTIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 1, 3, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ePORTIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ePORTIndex.setDescription('Identifies the PORT Index. The value of this object is the same as the snmpFddiPORTIndex, defined in the FDDI MIB, for this PORT entity.')
ePORTPHYIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 1, 3, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ePORTPHYIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ePORTPHYIndex.setDescription('The SMT Resource index. Index of the PHY resource used to identify the PHY PORT in ANSI SMT frames.')
ePORTPMDType = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 1, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("pmdNone", 1), ("pmdMM", 2), ("pmdSM", 3), ("pmdLC", 4), ("pmdTHN", 5), ("pmdSTP", 6), ("pmdUTP", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ePORTPMDType.setStatus('mandatory')
if mibBuilder.loadTexts: ePORTPMDType.setDescription('The physical media type of the PORT.')
ePORTPHYState = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 1, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("offmaintenance", 1), ("broken", 2), ("offready", 3), ("wait", 4), ("starting", 5), ("failed", 6), ("watch", 7), ("inuse", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ePORTPHYState.setStatus('mandatory')
if mibBuilder.loadTexts: ePORTPHYState.setDescription('The PHY state.')
ePORTRejectReason = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 1, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("noReason", 1), ("lctLocal", 2), ("lctRemote", 3), ("lctBoth", 4), ("lemFailure", 5), ("topologyRules", 6), ("tneExpired", 7), ("remoteReject", 8), ("tracesInProgress", 9), ("tracesReceived", 10), ("standby", 11), ("lctProtocol", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ePORTRejectReason.setStatus('mandatory')
if mibBuilder.loadTexts: ePORTRejectReason.setDescription('The current reject reason.')
ePORTConnectionsCompleted = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 1, 3, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ePORTConnectionsCompleted.setStatus('mandatory')
if mibBuilder.loadTexts: ePORTConnectionsCompleted.setDescription('The number of Physical Connections established for this PHY PORT.')
ePORTTNEExpRejects = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 1, 3, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ePORTTNEExpRejects.setStatus('mandatory')
if mibBuilder.loadTexts: ePORTTNEExpRejects.setDescription('The number of times a physical disconnection took place because the TNE Noise Timer expired.')
ePORTElasticityBufferErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 1, 3, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ePORTElasticityBufferErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ePORTElasticityBufferErrors.setDescription('The number of ELM Chip EBUFF_ERROR events.')
efddiFDXTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 1, 4, 1), )
if mibBuilder.loadTexts: efddiFDXTable.setStatus('mandatory')
if mibBuilder.loadTexts: efddiFDXTable.setDescription('A list of FDX entries.')
efddiFDXEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 1, 4, 1, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "eFDXSMTIndex"), (0, "DEC-ELAN-MIB", "eFDXMACIndex"))
if mibBuilder.loadTexts: efddiFDXEntry.setStatus('mandatory')
if mibBuilder.loadTexts: efddiFDXEntry.setDescription('A collection of objects containing information for a given FDX MAC entity.')
eFDXSMTIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 1, 4, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eFDXSMTIndex.setStatus('mandatory')
if mibBuilder.loadTexts: eFDXSMTIndex.setDescription('The value of the SMT index associated with this FDX MAC.')
eFDXMACIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 1, 4, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eFDXMACIndex.setStatus('mandatory')
if mibBuilder.loadTexts: eFDXMACIndex.setDescription('The value of the MAC index associated with this FDX MAC.')
eFDXEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 1, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eFDXEnable.setStatus('mandatory')
if mibBuilder.loadTexts: eFDXEnable.setDescription('When true, this link will participate in the full duplex auto-configuration and, if this is successful, will operate in the full duplex mode.')
eFDXOp = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 1, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: eFDXOp.setStatus('mandatory')
if mibBuilder.loadTexts: eFDXOp.setDescription('When true, this link is operating in the full duplex mode.')
eFDXState = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 1, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("fdxIdle", 1), ("fdxRequest", 2), ("fdxConfirm", 3), ("fdxOperation", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: eFDXState.setStatus('mandatory')
if mibBuilder.loadTexts: eFDXState.setDescription('The state of the full duplex Control process.')
esysChar = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 2, 1))
esysStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 2, 2))
esysCounters = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 2, 3))
esysConcConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 2, 4))
esysRomVersion = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: esysRomVersion.setStatus('mandatory')
if mibBuilder.loadTexts: esysRomVersion.setDescription('The version number of the software stored in ROM.')
esysInitSwitch = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("reset", 2), ("resetWithDefaults", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: esysInitSwitch.setStatus('mandatory')
if mibBuilder.loadTexts: esysInitSwitch.setDescription("This object allows the management action of initializing a device and forcing it to run selftest. It can also be used to reset all information added to the device's NVRAM. When read, it returns a value of other(1).")
esysResetDefaultsSwitch = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: esysResetDefaultsSwitch.setStatus('mandatory')
if mibBuilder.loadTexts: esysResetDefaultsSwitch.setDescription('This object is the state of a hardware switch which, when true, causes the device to reset its parameters to the factory defaults when initialized.')
esysGatewayAddress = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 2, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: esysGatewayAddress.setStatus('mandatory')
if mibBuilder.loadTexts: esysGatewayAddress.setDescription('This object allows the setting of a default gateway address for this device.')
esysTrapAddressTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 2, 1, 5), )
if mibBuilder.loadTexts: esysTrapAddressTable.setStatus('mandatory')
if mibBuilder.loadTexts: esysTrapAddressTable.setDescription('A table of IP Addresses to which this device will send traps.')
esysTrapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 2, 1, 5, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "esysTrapAddress"))
if mibBuilder.loadTexts: esysTrapEntry.setStatus('mandatory')
if mibBuilder.loadTexts: esysTrapEntry.setDescription('Each entry contains an IP Address to which all SNMP Traps will be sent by this device.')
esysTrapAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 2, 1, 5, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: esysTrapAddress.setStatus('mandatory')
if mibBuilder.loadTexts: esysTrapAddress.setDescription('An IP Address to which all SNMP traps generated by this device will be sent.')
esysUpdateSwitch = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: esysUpdateSwitch.setStatus('mandatory')
if mibBuilder.loadTexts: esysUpdateSwitch.setDescription('A software switch that, when set to true, instructs the device to accept a down-line loaded firmware upgrade. If false, the device will not accept upgrades.')
esysLastLoadHost = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 2, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: esysLastLoadHost.setStatus('mandatory')
if mibBuilder.loadTexts: esysLastLoadHost.setDescription("The physical address of the last host, if any, that responded to the device's request for a downline load of software.")
esysDeviceState = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 2, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("init", 1), ("operate", 2), ("broken", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: esysDeviceState.setStatus('mandatory')
if mibBuilder.loadTexts: esysDeviceState.setDescription('The operational state of the device.')
esysDeviceBrokenReason = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 2, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("selftestFail", 2), ("onlineDiagFail", 3), ("firmwareFail", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: esysDeviceBrokenReason.setStatus('mandatory')
if mibBuilder.loadTexts: esysDeviceBrokenReason.setDescription('The reason that the Device State is BROKEN. If current state is not BROKEN and the Unsolicited Resets counter is nonzero, this object show reason for last failure.')
esysNvramFailed = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 2, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: esysNvramFailed.setStatus('mandatory')
if mibBuilder.loadTexts: esysNvramFailed.setDescription('A flag, that, when set to True, indicates that the NVRAM failed selftest following the last initialization of the device.')
esysPowerups = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 2, 3, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: esysPowerups.setStatus('mandatory')
if mibBuilder.loadTexts: esysPowerups.setDescription('The number of times this device was powered on. Power Ups, Management Resets and Unsolicited Resets are all mutually exclusive.')
esysMgmtResets = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 2, 3, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: esysMgmtResets.setStatus('mandatory')
if mibBuilder.loadTexts: esysMgmtResets.setDescription('Number of times the device was initialized with a management command using esysInitSwitch. Power Ups, Management Resets and Unsolicited Resets are all mutually exclusive.')
esysUnsolicitedResets = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 2, 3, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: esysUnsolicitedResets.setStatus('mandatory')
if mibBuilder.loadTexts: esysUnsolicitedResets.setDescription('Number of times the device initialized itself after encountering a fatal error. Power Ups, Management Resets and Unsolicited Resets are all mutually exclusive.')
esysFRUConfigTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 2, 4, 1), )
if mibBuilder.loadTexts: esysFRUConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: esysFRUConfigTable.setDescription('A list of configuration table entries.')
esysFRUConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 2, 4, 1, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "esysFRUIndex"))
if mibBuilder.loadTexts: esysFRUConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: esysFRUConfigEntry.setDescription('A collection of objects containing information for a given configuration entry.')
esysFRUIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 2, 4, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: esysFRUIndex.setStatus('mandatory')
if mibBuilder.loadTexts: esysFRUIndex.setDescription('This object is used for indexing the FRU configuration table.')
esysFRUSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 2, 4, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: esysFRUSlot.setStatus('mandatory')
if mibBuilder.loadTexts: esysFRUSlot.setDescription("The physical slot number in which the module resides, if applicable. If not applicable, this is reported as '0'.")
esysFRUDesc = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 2, 4, 1, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: esysFRUDesc.setStatus('mandatory')
if mibBuilder.loadTexts: esysFRUDesc.setDescription('A textual description of this FRU.')
esysFRUType = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 2, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 19, 20, 21, 22, 23, 24, 25, 26, 27, 29))).clone(namedValues=NamedValues(("empty", 1), ("ansiMgmtCard", 2), ("ansiPortCard4line", 3), ("fan", 4), ("apCard", 5), ("niCard", 6), ("fddiCard", 7), ("controllerBackplane", 8), ("qmCard", 9), ("lowPowerPortCard4line", 10), ("singleModeAnsiPortCard4line", 11), ("thinwirePortCard6line", 12), ("lowPowerPortCard6line", 13), ("stpCopperPortCard6line", 14), ("singleModeMgmtCard", 15), ("ansi-SingleModeMgmtCard", 16), ("singleMode-ANSIMgmtCard", 17), ("upgradeApCard", 19), ("threeNiCard", 20), ("dasAnsiFddiCard", 21), ("dasAnsiASingleModeBfiCard", 22), ("dasSingleModeAAnsiBfiCard", 23), ("dasSingleModeFddiCard", 24), ("sasSingleModeFddiCard", 25), ("opticalBypass", 26), ("obmUartCard", 27), ("ansiPortCard6line", 29)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: esysFRUType.setStatus('mandatory')
if mibBuilder.loadTexts: esysFRUType.setDescription('Integer representation for the FRU type. This is the machine-readable form of the descriptor object.')
esysFRURev = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 2, 4, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: esysFRURev.setStatus('mandatory')
if mibBuilder.loadTexts: esysFRURev.setDescription('This object represents the FRU revision number.')
esysFRUState = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 2, 4, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("empty", 1), ("working", 2), ("marginal", 3), ("broken", 4), ("obrNotSupported", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: esysFRUState.setStatus('mandatory')
if mibBuilder.loadTexts: esysFRUState.setDescription('The operational state of the FRU, if present.')
esysFddiPortTrapSwitch = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 2, 4, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: esysFddiPortTrapSwitch.setStatus('mandatory')
if mibBuilder.loadTexts: esysFddiPortTrapSwitch.setDescription('This is a switch to enable or diable FDDI port up and port down traps. When set to true, the concentrator will send a trap when one of its ports comes up or goes down.')
eifTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 3, 1), )
if mibBuilder.loadTexts: eifTable.setStatus('mandatory')
if mibBuilder.loadTexts: eifTable.setDescription('A list of interface entries. The number of entries is given by ifNumber, defined in MIB-II.')
eifEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 3, 1, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "eifIndex"))
if mibBuilder.loadTexts: eifEntry.setStatus('mandatory')
if mibBuilder.loadTexts: eifEntry.setDescription('A collection of objects containing information for a given interface.')
eifIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eifIndex.setStatus('mandatory')
if mibBuilder.loadTexts: eifIndex.setDescription('Identifies the Interface. The value of this object is the same as the ifIndex, defined in MIB-II, for this interface.')
eifBadFramesReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 3, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eifBadFramesReceived.setStatus('mandatory')
if mibBuilder.loadTexts: eifBadFramesReceived.setDescription('Number of frames received with a bad frame check sequence.')
eifReceiveOverrun = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 3, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eifReceiveOverrun.setStatus('mandatory')
if mibBuilder.loadTexts: eifReceiveOverrun.setDescription('Number of times that the device received a frame loss indication from the hardware on the interface.')
eifOversizeFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 3, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eifOversizeFrames.setStatus('mandatory')
if mibBuilder.loadTexts: eifOversizeFrames.setDescription('Number of frames received on the interface that were larger than the maximum legal size.')
eifTransmitFramesError = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 3, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eifTransmitFramesError.setStatus('mandatory')
if mibBuilder.loadTexts: eifTransmitFramesError.setDescription('Number of frames that were transmitted with an error on the line.')
eifMgmtSetsAllowedSwitch = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: eifMgmtSetsAllowedSwitch.setStatus('mandatory')
if mibBuilder.loadTexts: eifMgmtSetsAllowedSwitch.setDescription('This hardware switch, when true, allows write access to the device. This object has meaning only when the corresponding functionality is present.')
ebrChar = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 1))
ebrStat = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 2))
ebrCoun = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 3))
ebrSpan = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 4))
ebrInterfaces = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 5))
ebrTwoPortStatic = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 6))
ebrMultiPortStatic = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 7))
ebrTwoProtoFilt = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 8))
ebrMultiProtoFilt = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 9))
ebrMultiFiltSw = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 10))
ebrNTP = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 11))
ebrRateLimiting = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 12))
ebrLB100SpanningTreeVer = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrLB100SpanningTreeVer.setStatus('mandatory')
if mibBuilder.loadTexts: ebrLB100SpanningTreeVer.setDescription('The version number of the Spanning Tree algorithm used by the bridge when in the LAN Bridge 100 Spanning Tree mode.')
ebr802SpanningTreeVer = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebr802SpanningTreeVer.setStatus('mandatory')
if mibBuilder.loadTexts: ebr802SpanningTreeVer.setDescription('The version number of the Spanning Tree algorithm used by the bridge when in the 802.1d Spanning Tree mode.')
ebrMaxForwardingDBEntries = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrMaxForwardingDBEntries.setStatus('mandatory')
if mibBuilder.loadTexts: ebrMaxForwardingDBEntries.setDescription('The maximum number of address entries that the bridge can store in its volatile memory.')
ebrMaxNVForwardingDBEntries = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrMaxNVForwardingDBEntries.setStatus('mandatory')
if mibBuilder.loadTexts: ebrMaxNVForwardingDBEntries.setDescription('The maximum number of permanent address entries that the bridge canstore in its NVRAM.')
ebrMaxProtocolDBEntries = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrMaxProtocolDBEntries.setStatus('mandatory')
if mibBuilder.loadTexts: ebrMaxProtocolDBEntries.setDescription('The maximum number of protocol entries that the bridge can store in its protocol database. These entries control the handling of frames based on their Ethernet PT, IEEE 802.2 DSAP or IEEE 802 SNAP Protocol ID.')
ebrMaxNVProtocolDBEntries = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrMaxNVProtocolDBEntries.setStatus('mandatory')
if mibBuilder.loadTexts: ebrMaxNVProtocolDBEntries.setDescription('The maximum number of protocol entries that the bridge can store in its nonvolatile memory. These are retained after a power-down.')
ebrForwardingDBPurgeThreshold = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrForwardingDBPurgeThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: ebrForwardingDBPurgeThreshold.setDescription('The total number of active and inactive address entries that will trigger a purge of the inactive entries.')
ebrPortTestPassedThreshold = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrPortTestPassedThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: ebrPortTestPassedThreshold.setDescription('The number of consecutive successful self-tests needed before the bridge considers a line to be operational.')
ebrPortTestInterval = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrPortTestInterval.setStatus('mandatory')
if mibBuilder.loadTexts: ebrPortTestInterval.setDescription('The interval, in seconds, at which the bridge will run selftests on a line that is in the BROKEN state.')
ebrTopologyChangeTimer = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrTopologyChangeTimer.setStatus('mandatory')
if mibBuilder.loadTexts: ebrTopologyChangeTimer.setDescription('The number of seconds remaining, if this is the Root, for which Topology Change will be propagated in Hello messages. Otherwise this value will be reported as 0.')
ebrManualFilterSwitch = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrManualFilterSwitch.setStatus('mandatory')
if mibBuilder.loadTexts: ebrManualFilterSwitch.setDescription('A switch that controls address filtering. When true, the bridge purges the learned entries from its forwarding database, stops its learning process, and forwards only frames with destination and source addresses that have been specified via management.')
ebrFragmentationSwitch = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrFragmentationSwitch.setStatus('mandatory')
if mibBuilder.loadTexts: ebrFragmentationSwitch.setDescription('A switch that controls whether fragmentation is performed by the bridge when a large IP frame is received on a datalink that supports a higer frame size than the other datalink.')
ebrRemoveMgmtAddress = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("true", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrRemoveMgmtAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ebrRemoveMgmtAddress.setDescription('This object allows the action of removing all management entered addresses from the forwarding database when set to true(2). When read, it returns a value of other(1).')
ebrRemoveMgmtProto = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("true", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrRemoveMgmtProto.setStatus('mandatory')
if mibBuilder.loadTexts: ebrRemoveMgmtProto.setDescription('This object allows the action of removing all management entered protocols from the protocol database when set to true(2). When read, it returns a value of other(1).')
ebrCurrForwardingDBEntries = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 2, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrCurrForwardingDBEntries.setStatus('mandatory')
if mibBuilder.loadTexts: ebrCurrForwardingDBEntries.setDescription("The number of address entries in the bridge's volatile memory. These will be lost upon loss of power.")
ebrCurrNVForwardingDBEntries = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 2, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrCurrNVForwardingDBEntries.setStatus('mandatory')
if mibBuilder.loadTexts: ebrCurrNVForwardingDBEntries.setDescription("The number of address entries in the bridge's NVRAM. These will be retained after loss of power.")
ebrCurrProtocolDBEntries = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 2, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrCurrProtocolDBEntries.setStatus('mandatory')
if mibBuilder.loadTexts: ebrCurrProtocolDBEntries.setDescription("The number of protocol entries that are stored in the bridge's protocol database. These control the handling of frames based on their Ethernet protocol type, IEEE 802.2 DSAP, or 802 SNAP Protocol ID.")
ebrCurrNVProtocolDBEntries = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 2, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrCurrNVProtocolDBEntries.setStatus('mandatory')
if mibBuilder.loadTexts: ebrCurrNVProtocolDBEntries.setDescription("The number of protocol entries in the bridge's NVRAM. These are retained after a power loss.")
ebrMgmtHeardPort = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 2, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrMgmtHeardPort.setStatus('mandatory')
if mibBuilder.loadTexts: ebrMgmtHeardPort.setDescription('The port on which this command was received.')
ebrLB100BeingPolled = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 2, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrLB100BeingPolled.setStatus('mandatory')
if mibBuilder.loadTexts: ebrLB100BeingPolled.setDescription('The address of the LAN Bridge 100 mode bridge that sent this bridge into the LAN Bridge 100 Spanning Tree mode. If this bridge is the Root, this object indicates the bridge that will be polled periodically to determine if it is still necessary to stay in this Spanning Tree mode.')
ebrInactiveForwardingDBEntries = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 2, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrInactiveForwardingDBEntries.setStatus('mandatory')
if mibBuilder.loadTexts: ebrInactiveForwardingDBEntries.setDescription("The number of inactive address entries in the bridge's forwarding database. The bridge marks an address entry inactive when the entry is aged out.")
ebrTimeSinceForwardingDBPurged = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 2, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrTimeSinceForwardingDBPurged.setStatus('mandatory')
if mibBuilder.loadTexts: ebrTimeSinceForwardingDBPurged.setDescription('The number of seconds since the bridge cleared the forwarding database of inactive entries.')
ebrTimeSinceLastHello = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 2, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrTimeSinceLastHello.setStatus('mandatory')
if mibBuilder.loadTexts: ebrTimeSinceLastHello.setDescription('The number of seconds since the bridge last sent a Hello message.')
ebrDeviceFramesLost = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 3, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrDeviceFramesLost.setStatus('mandatory')
if mibBuilder.loadTexts: ebrDeviceFramesLost.setDescription('The number of frames addressed to the bridge itself that the bridge discarded because it did not have sufficient receive buffers available.')
ebrSpanningTreeModeChanges = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 3, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrSpanningTreeModeChanges.setStatus('mandatory')
if mibBuilder.loadTexts: ebrSpanningTreeModeChanges.setDescription('The number of times that the bridge switched from the 802.1d Spanning Tree mode to the LB100 Spanning Tree mode.')
ebrBestRootAge = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 4, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrBestRootAge.setStatus('mandatory')
if mibBuilder.loadTexts: ebrBestRootAge.setDescription('The age, in hundereths of seconds, of the Hello message that established the best root.')
ebrTopologyChangeFlag = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 4, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrTopologyChangeFlag.setStatus('mandatory')
if mibBuilder.loadTexts: ebrTopologyChangeFlag.setDescription('A flag that indicates whether a Topology Change is currently in effect on the extended LAN.')
ebrTellParentFlag = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 4, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrTellParentFlag.setStatus('mandatory')
if mibBuilder.loadTexts: ebrTellParentFlag.setDescription('A flag that indicates if the bridge is attempting to propagate a topology change towards the Root.')
ebrForwardingDBShortAgingTime = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 4, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrForwardingDBShortAgingTime.setStatus('mandatory')
if mibBuilder.loadTexts: ebrForwardingDBShortAgingTime.setDescription('The number of seconds that the bridge keeps learned entries active while a topology change is in effect.')
ebrBadHelloLimit = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 4, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrBadHelloLimit.setStatus('mandatory')
if mibBuilder.loadTexts: ebrBadHelloLimit.setDescription('The number of hello intervals during which the bridge receives one or more bad hellos on a line, before the bridge performs a test on the link. A bad Hello message is one that contains inferior information that is received on a port on which this bridge is Designated.')
ebrBadHelloResetTimer = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 4, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrBadHelloResetTimer.setStatus('mandatory')
if mibBuilder.loadTexts: ebrBadHelloResetTimer.setDescription('The number of Hello intervals without bad Hellos that the bridge will wait before it resets its bad Hello count to zero.')
ebrNoFrameInterval = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 4, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNoFrameInterval.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNoFrameInterval.setDescription('The The number of seconds of inactivity on a line that will cause the bridge to run a test on that line. The bridge considers a line to be inactive if it does not receive any frames on that line.')
ebrLB100PollTime = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 4, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrLB100PollTime.setStatus('mandatory')
if mibBuilder.loadTexts: ebrLB100PollTime.setDescription('The number of seconds that a Root bridge in LAN Bridge 100 mode waits between polling the LAN Bridge 100 that is keeping it in this mode. This polling is done to determine whether the LB100 is still present on the extended LAN.')
ebrLB100ResponseTimeout = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 4, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrLB100ResponseTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: ebrLB100ResponseTimeout.setDescription('The number of seconds that a Root in LAN Bridge 100 Spanning Tree mode will wait for a response from the LAN Bridge 100 which is keeping it in this mode, before which it will assume that the LB100 is no longer on the extended LAN.')
ebrLB100SpanningTreeCompat = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 4, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("autoSelect", 1), ("ieee802", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrLB100SpanningTreeCompat.setStatus('mandatory')
if mibBuilder.loadTexts: ebrLB100SpanningTreeCompat.setDescription('A switch that controls the Spanning Tree mode used by the bridge. If in Auto-Select mode, the bridge will go into 802 Spanning Tree mode by default, but will switch to LB100 mode as soon as a LB100 is detected. In 802 Spanning Tree mode, the bridge will stay in 802 mode.')
ebrIfTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 5, 1), )
if mibBuilder.loadTexts: ebrIfTable.setStatus('mandatory')
if mibBuilder.loadTexts: ebrIfTable.setDescription('A list of interface entries. The number of entries is given by ifNumber, defined in MIB-II.')
ebrIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 5, 1, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "ebrIfIndex"))
if mibBuilder.loadTexts: ebrIfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ebrIfEntry.setDescription('A collection of objects containing information for a given interface.')
ebrIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 5, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ebrIfIndex.setDescription('Identifies the Interface. The value of this object is the same as the ifIndex, defined in MIB-II, for this interface.')
ebrIfLinkBrokenReason = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noFault", 1), ("possibleInternalFault", 2), ("possibleExternalFault", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrIfLinkBrokenReason.setStatus('mandatory')
if mibBuilder.loadTexts: ebrIfLinkBrokenReason.setDescription('The reason why the link was last broken. A possible internal fault(1) indicates a problem with the bridge line itself, a possible external fault(2), indicates a problem with the transmission medium to which the line is attached.')
ebrIfPortRestarts = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 5, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrIfPortRestarts.setStatus('mandatory')
if mibBuilder.loadTexts: ebrIfPortRestarts.setDescription('The number of times the bridge restarted the line.')
ebrIfUnknownDAReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 5, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrIfUnknownDAReceived.setStatus('mandatory')
if mibBuilder.loadTexts: ebrIfUnknownDAReceived.setDescription('The number of frames received on this line for which the bridge had no address entry in its forwarding database.')
ebrIfFramesAddrFiltered = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 5, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrIfFramesAddrFiltered.setStatus('mandatory')
if mibBuilder.loadTexts: ebrIfFramesAddrFiltered.setDescription('The number of frames filtered by the bridge on this port because of address entries in the forwarding database.')
ebrIfMultiFramesFiltered = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 5, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrIfMultiFramesFiltered.setStatus('mandatory')
if mibBuilder.loadTexts: ebrIfMultiFramesFiltered.setDescription('The number of frames with multicast destination addresses that were received on the line on the line and filtered by the bridge.')
ebrIfFramesProtocolFiltered = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 5, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrIfFramesProtocolFiltered.setStatus('mandatory')
if mibBuilder.loadTexts: ebrIfFramesProtocolFiltered.setDescription('The number of frames received on this line that the bridge discarded because of entries set by management in the protocol database.')
ebrIfDeviceFramesSent = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 5, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrIfDeviceFramesSent.setStatus('mandatory')
if mibBuilder.loadTexts: ebrIfDeviceFramesSent.setDescription('The number of frames originating from the bridge itself that were transmitted on this line.')
ebrIfDeviceFramesReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 5, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrIfDeviceFramesReceived.setStatus('mandatory')
if mibBuilder.loadTexts: ebrIfDeviceFramesReceived.setDescription('The number of frames addressed to the bridge itself that were received on this line.')
ebrIfDeviceBytesSent = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 5, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrIfDeviceBytesSent.setStatus('mandatory')
if mibBuilder.loadTexts: ebrIfDeviceBytesSent.setDescription('The number of bytes in the frames originating from the bridge that were transmitted on this line.')
ebrIfDeviceBytesReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 5, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrIfDeviceBytesReceived.setStatus('mandatory')
if mibBuilder.loadTexts: ebrIfDeviceBytesReceived.setDescription('The number of bytes in the frames addressed to the bridge itself that were received on this line.')
ebrIfDeviceFramesLost = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 5, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrIfDeviceFramesLost.setStatus('mandatory')
if mibBuilder.loadTexts: ebrIfDeviceFramesLost.setDescription('The number of frames received on the line addressed to the bridge itself discarded by the bridge because it did not have internal buffers to store them.')
ebrIfMultiBytesSent = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 5, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrIfMultiBytesSent.setStatus('mandatory')
if mibBuilder.loadTexts: ebrIfMultiBytesSent.setDescription('The number of bytes in Multicast Frames sent, as reported in ifOutNUcastPkts, defined in MIB-II.')
ebrIfMultiBytesReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 5, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrIfMultiBytesReceived.setStatus('mandatory')
if mibBuilder.loadTexts: ebrIfMultiBytesReceived.setDescription('The number of bytes in Multicast Frames received, as reported in ifInNUcastPkts, defined in MIB-II.')
ebrIfMultiDeviceFramesSent = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 5, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrIfMultiDeviceFramesSent.setStatus('mandatory')
if mibBuilder.loadTexts: ebrIfMultiDeviceFramesSent.setDescription('The number of frames with multicast destination addresses transmitted by the bridge itself on the line.')
ebrIfMultiDeviceFramesReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 5, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrIfMultiDeviceFramesReceived.setStatus('mandatory')
if mibBuilder.loadTexts: ebrIfMultiDeviceFramesReceived.setDescription('The number of frames with multicast destination addresses received by the bridge itslef on the line.')
ebrIfMultiDeviceBytesSent = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 5, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrIfMultiDeviceBytesSent.setStatus('mandatory')
if mibBuilder.loadTexts: ebrIfMultiDeviceBytesSent.setDescription('The number of bytes in ebrIfMultiDeviceFramesSent.')
ebrIfMultiDeviceBytesReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 5, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrIfMultiDeviceBytesReceived.setStatus('mandatory')
if mibBuilder.loadTexts: ebrIfMultiDeviceBytesReceived.setDescription('The number of bytes in ebrIfMultiDeviceFramesReceived.')
ebrIfBadBytesReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 5, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrIfBadBytesReceived.setStatus('mandatory')
if mibBuilder.loadTexts: ebrIfBadBytesReceived.setDescription('The number of bytes in frames received that had a bad frame check sequence.')
ebrIfBadHelloLimitExceeded = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 5, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrIfBadHelloLimitExceeded.setStatus('mandatory')
if mibBuilder.loadTexts: ebrIfBadHelloLimitExceeded.setDescription('The number of times that the Bad Hellos on the line exceeded the Bad Hello limit.')
ebrIfEtherTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 5, 2), )
if mibBuilder.loadTexts: ebrIfEtherTable.setStatus('mandatory')
if mibBuilder.loadTexts: ebrIfEtherTable.setDescription('A list of interface entries for an Ethernet port.')
ebrIfEtherEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 5, 2, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "ebrIfIndex"))
if mibBuilder.loadTexts: ebrIfEtherEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ebrIfEtherEntry.setDescription('A collection of objects containing information for a given interface.')
ebrIfEthIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 5, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrIfEthIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ebrIfEthIndex.setDescription('Identifies the Interface. The value of this object is the same as the ifIndex, defined in MIB-II, for this interface.')
ebrIfEthPhysicalMediumType = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 5, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 6, 7, 8, 9, 10, 11, 24))).clone(namedValues=NamedValues(("stdAUIInterface", 1), ("thinwireInterface", 2), ("ieeeFiberInterRepeaterLink", 6), ("fiberOpticLink850nmNoIdle", 7), ("fiberOpticLink850nmDualIdle", 8), ("dConnAuiIf", 9), ("thinwireInterfaceNoLoop", 10), ("twistedPairInterface", 11), ("fullDuplexFiberOptic1300nm", 24)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrIfEthPhysicalMediumType.setStatus('mandatory')
if mibBuilder.loadTexts: ebrIfEthPhysicalMediumType.setDescription('The type of physical medium to which this line is attached.')
ebrIfEthCollisionPresenceTestSwitch = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 5, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrIfEthCollisionPresenceTestSwitch.setStatus('mandatory')
if mibBuilder.loadTexts: ebrIfEthCollisionPresenceTestSwitch.setDescription("A switch that informs the bridge whether the transceiver on this line is using the Collision Presence Test (CPT), commonly known as heartbeat. It must be enabled if the line's transceiver has CPT.")
ebrIfEthCollisionTestFailed = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 5, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrIfEthCollisionTestFailed.setStatus('mandatory')
if mibBuilder.loadTexts: ebrIfEthCollisionTestFailed.setDescription('The number of times that a Collision Presence Test (CPT) signal was not detected within 4 microseconds after a transmission on the line. This counter is valid only if ebrIfEthCollisionPresenceTestSwitch is set to true for this line.')
ebrIfEthFramingError = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 5, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrIfEthFramingError.setStatus('mandatory')
if mibBuilder.loadTexts: ebrIfEthFramingError.setDescription('The number of times that a frame received on the line contained both a noninteger multiple of 8 bits and a CRC error.')
ebrIfEthLengthError = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 5, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrIfEthLengthError.setStatus('mandatory')
if mibBuilder.loadTexts: ebrIfEthLengthError.setDescription('The number of 802.3 frames received that contained a Length field inconsistent with the actual number of data bytes in the packet.')
ebrIfEthTransmitMultipleCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 5, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrIfEthTransmitMultipleCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: ebrIfEthTransmitMultipleCollisions.setDescription('The number of times that the bridge had to retry transmission of a frame on the line. This was because of collisions during transmission due to congestion on the physical medium.')
ebrIfEthCarrierLoss = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 5, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrIfEthCarrierLoss.setStatus('mandatory')
if mibBuilder.loadTexts: ebrIfEthCarrierLoss.setDescription('The number of times that the bridge detected a loss of the carrier signal while transmitting a frame on the line.')
ebrIfEthCollisionLimitExceeded = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 5, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrIfEthCollisionLimitExceeded.setStatus('mandatory')
if mibBuilder.loadTexts: ebrIfEthCollisionLimitExceeded.setDescription('The number of times that the bridge failed to transmit a frame on this line after 16 attempts, the collision limit.')
ebrIfFddiTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 5, 3), )
if mibBuilder.loadTexts: ebrIfFddiTable.setStatus('mandatory')
if mibBuilder.loadTexts: ebrIfFddiTable.setDescription('A list of interface entries for an FDDI port.')
ebrIfFddiEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 5, 3, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "ebrIfIndex"))
if mibBuilder.loadTexts: ebrIfFddiEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ebrIfFddiEntry.setDescription('A collection of objects containing information for a given interface.')
ebrIfFddiIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 5, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrIfFddiIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ebrIfFddiIndex.setDescription('Identifies the Interface. The value of this object is the same as the ifIndex, defined in MIB-II, for this interface.')
ebrIfFddiUnprocessedErrorPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 5, 3, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrIfFddiUnprocessedErrorPackets.setStatus('mandatory')
if mibBuilder.loadTexts: ebrIfFddiUnprocessedErrorPackets.setDescription('The number of times that an error frame was received on thisline but the bridge did not have time to decipher it.')
ebrIfFddiIpDatagramsFragmented = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 5, 3, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrIfFddiIpDatagramsFragmented.setStatus('mandatory')
if mibBuilder.loadTexts: ebrIfFddiIpDatagramsFragmented.setDescription('The number or large IP Datagrams that were fragmented into smaller frames because they did not fit into legal size packets on the smaller datalink after translation.')
ebrIfFddiIpDontFragment = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 5, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrIfFddiIpDontFragment.setStatus('mandatory')
if mibBuilder.loadTexts: ebrIfFddiIpDontFragment.setDescription('The number of large IP datagrams that could not be fragmented because the DONT-FRAGMENT bit was set in the IP header.')
ebrIfFddiIpIllegalHeaderLength = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 5, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrIfFddiIpIllegalHeaderLength.setStatus('mandatory')
if mibBuilder.loadTexts: ebrIfFddiIpIllegalHeaderLength.setDescription('The number of large IP datagrams that were discarded instead of being fragmented because the IP header was of illegal length.')
ebrIfFddiIpIllegalSize = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 5, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrIfFddiIpIllegalSize.setStatus('mandatory')
if mibBuilder.loadTexts: ebrIfFddiIpIllegalSize.setDescription('The number of large IP datagrams that were discarded instead of being fragmented because the IP header indicated a length greater than the number of actual bytes in the received datagram.')
ebrIfSpanTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 5, 4), )
if mibBuilder.loadTexts: ebrIfSpanTable.setStatus('mandatory')
if mibBuilder.loadTexts: ebrIfSpanTable.setDescription('A list of interface entries for an FDDI port.')
ebrIfSpanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 5, 4, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "ebrIfIndex"))
if mibBuilder.loadTexts: ebrIfSpanEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ebrIfSpanEntry.setDescription('A collection of objects containing information for a given interface.')
ebrIfSpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 5, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrIfSpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ebrIfSpIndex.setDescription('Identifies the Interface. The value of this object is the same as the ifIndex, defined in MIB-II, for this interface.')
ebrIfSpDesigRootAge = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 5, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrIfSpDesigRootAge.setStatus('mandatory')
if mibBuilder.loadTexts: ebrIfSpDesigRootAge.setDescription('The age, in hundreths of seconds, of the last Hello message received from the designated bridge on the line.')
ebrIfSpForwardDelayTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 5, 4, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrIfSpForwardDelayTimer.setStatus('mandatory')
if mibBuilder.loadTexts: ebrIfSpForwardDelayTimer.setDescription('The time remaining, in hundreths of seconds, before the bridge will leave the Preforwarding state (listening or learning), and enter the Forwarding State. If not in preforwarding, this value will be reported as 0.')
ebrIfSpBadHelloCount = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 5, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrIfSpBadHelloCount.setStatus('mandatory')
if mibBuilder.loadTexts: ebrIfSpBadHelloCount.setDescription('The number of Hello intervals during which at least one Bad Hello was received.')
ebrIfSpPossibleLoopFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 5, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrIfSpPossibleLoopFlag.setStatus('mandatory')
if mibBuilder.loadTexts: ebrIfSpPossibleLoopFlag.setDescription('A flag that indicates whether the bridge detected a loop condition on this line.')
ebrIfSpTopologyChangeAckFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 5, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrIfSpTopologyChangeAckFlag.setStatus('mandatory')
if mibBuilder.loadTexts: ebrIfSpTopologyChangeAckFlag.setDescription('A flag that indicates whether a topology change notification received on a link that we are designated on needs to be acknowledged.')
ebrTwoPortStaticTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 6, 1), )
if mibBuilder.loadTexts: ebrTwoPortStaticTable.setStatus('mandatory')
if mibBuilder.loadTexts: ebrTwoPortStaticTable.setDescription('A table that contains static destination and source address filtering information about unicast and multicast addresses for 2-port bridges.')
ebrTwoPortStaticEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 6, 1, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "ebrTwoPortAddress"))
if mibBuilder.loadTexts: ebrTwoPortStaticEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ebrTwoPortStaticEntry.setDescription('Information about a specific MAC address for which the bridge has some static forwarding and/or filtering information.')
ebrTwoPortAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 6, 1, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrTwoPortAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ebrTwoPortAddress.setDescription("The destination/source MAC Address in a frame to which this entry's filtering information applies.")
ebrTwoPortPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 6, 1, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrTwoPortPortNum.setStatus('mandatory')
if mibBuilder.loadTexts: ebrTwoPortPortNum.setDescription('The Port Number to which this address will be locked-down, if the status is lockDown. Otherwise, this field has a value of 0.')
ebrTwoPortStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 6, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("lockDown", 1), ("hello", 2), ("invalid", 3), ("filter", 4), ("forward", 5), ("rateLimit", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrTwoPortStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ebrTwoPortStatus.setDescription("The status of this entry. The meanings of the values are: lockDown(1) : This address is 'locked-down' to the port specified by the ebrTwoPortPortNum field. This address will be allowed to source frames only from the specified port, and frames destined to this address will be sent out only on the specified port. hello(2) : This is the address used by the bridge in the destination field of Spanning Tree Hellos. It is not a writeable value. invalid(3) : Writing this value to the object removes the corresponding entry. filter(4) : Frames with this address in the source or destination field will be filtered by the bridge. forward(5) : Frames with this address in the destination field will be forwarded by the bridge. rateLimit(6) : Frames with this address in the destination field will be rate-limited by the bridge, if it supports rate limiting. Applicable only to multicast addresses. For more detail, please see the ebrRateLimiting group.")
ebrMultiPortStaticTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 7, 1), )
if mibBuilder.loadTexts: ebrMultiPortStaticTable.setStatus('mandatory')
if mibBuilder.loadTexts: ebrMultiPortStaticTable.setDescription('A table that contains static destination and source address filtering information about unicast and multicast addresses for multi-port bridges.')
ebrMultiPortStaticEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 7, 1, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "ebrMultiPortAddress"), (0, "DEC-ELAN-MIB", "ebrMultiPortReceivePort"))
if mibBuilder.loadTexts: ebrMultiPortStaticEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ebrMultiPortStaticEntry.setDescription('Information about a specific MAC address for which the bridge has some static forwarding and/or filtering information.')
ebrMultiPortAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 7, 1, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrMultiPortAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ebrMultiPortAddress.setDescription("The destination/source MAC Address in a frame to which this entry's filtering information applies.")
ebrMultiPortReceivePort = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 7, 1, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrMultiPortReceivePort.setStatus('mandatory')
if mibBuilder.loadTexts: ebrMultiPortReceivePort.setDescription('The port from which a frame must be received to use the corresponding ebrMultiPortAllowedToGoTo field. A value of zero indicates that this entry applies on all ports of the bridge.')
ebrMultiPortAllowedToGoTo = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 7, 1, 1, 3), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrMultiPortAllowedToGoTo.setStatus('mandatory')
if mibBuilder.loadTexts: ebrMultiPortAllowedToGoTo.setDescription("The set of ports to which frames received from a specific port and sourced from or destined to the address specified by ebrMultiPortAddress are allowed to be forwarded. Each octet within the value of this object specifies a set of eight ports, with the first octet specifying ports 1 through 8, the second octet specifying port 9 through 16 etc. Within each octet, the most significant bit represents the lowest numbered port, and the least significant bit represents the highest numbered port. If a bit has a value of '1', then the corresponding port is included in the set of ports; the port is not included if its bit has a value of '0'.")
ebrMultiPortPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 7, 1, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrMultiPortPortNum.setStatus('mandatory')
if mibBuilder.loadTexts: ebrMultiPortPortNum.setDescription('The Port Number to which this address will be locked-down, if the status is lockDown. Otherwise, this field has a value of zero.')
ebrMultiPortStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 7, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("portMask", 1), ("lockDown", 2), ("maskAndLock", 3), ("hello", 4), ("filter", 5), ("invalid", 6), ("rateLimit", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrMultiPortStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ebrMultiPortStatus.setDescription("The status of this entry. The meanings of the values are: portMask(1) : The static filtering for this address is specified by the MultiPortAllowedToGoTo field. lockDown(2) : The static filtering for this address is specified as 'locked-down' to the port specified by the ebrMultiPortPortNum field. This address will be allowed to source frames only from the specified port, and frames destined to this address will be sent out only on the specified port. maskAndLock(3) : The static filtering for this address is specified by both the ebrMultiPortAllowedToGoTo as well as 'locked-down' as explained above for 'lockDown(2)'. hello(4) : This is the address used by the bridge in the destination field of Spanning Tree Hellos. It is not a writeable value. filter(5) : This address will be filtered on all ports. invalid(6) : Writing this value to the object removes the corresponding entry. rateLimit(7) : Frames with this address in the destination field will be rate-limited by the bridge, if it supports rate limiting. Applicable only to multicast addresses. For more detail, please see the ebrRateLimiting group.")
ebrTwoProtoEnetFilterOther = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 8, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("forward", 1), ("filter", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrTwoProtoEnetFilterOther.setStatus('mandatory')
if mibBuilder.loadTexts: ebrTwoProtoEnetFilterOther.setDescription('Action taken by the bridge on Ethernet protocol types other than those specified in the ebrTwoEnetProtoTable. ')
ebrTwoProtoSapFilterOther = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 8, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("forward", 1), ("filter", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrTwoProtoSapFilterOther.setStatus('mandatory')
if mibBuilder.loadTexts: ebrTwoProtoSapFilterOther.setDescription('Action taken by the bridge on 802.2 DSAPs other than those specified in the ebrTwoSapProtoTable. ')
ebrTwoProtoSnapFilterOther = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 8, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("forward", 1), ("filter", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrTwoProtoSnapFilterOther.setStatus('mandatory')
if mibBuilder.loadTexts: ebrTwoProtoSnapFilterOther.setDescription('Action taken by the bridge on the 5-byte SNAP PIDs other than those specified in the ebrTwoSnapProtoTable. ')
ebrTwoEnetProtoTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 8, 4), )
if mibBuilder.loadTexts: ebrTwoEnetProtoTable.setStatus('mandatory')
if mibBuilder.loadTexts: ebrTwoEnetProtoTable.setDescription('A table that contains filtering information about Ethernet protocol types for 2-port bridges.')
ebrTwoEnetProtoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 8, 4, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "ebrTwoEnetProtoType"))
if mibBuilder.loadTexts: ebrTwoEnetProtoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ebrTwoEnetProtoEntry.setDescription('A table that contains filtering information about Ethernet protocol types for 2-port bridges.')
ebrTwoEnetProtoType = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 8, 4, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrTwoEnetProtoType.setStatus('mandatory')
if mibBuilder.loadTexts: ebrTwoEnetProtoType.setDescription("The protocol type in a frame to which this entry's filtering information applies.")
ebrTwoEnetProtoStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 8, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("forward", 1), ("filter", 2), ("invalid", 3), ("rateLimit", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrTwoEnetProtoStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ebrTwoEnetProtoStatus.setDescription('Action taken by bridge when it sees this ethernet protocol type in a received frame. The meanings of the values are: forward(1) : Frames received with this protocol type are allowed to be forwarded. filter(2) : Frames received with this protocol type should be filtered. invalid(3) : Writing this value to the object removes the corresponding entry. rateLimit(4) : Frames received with this protocol type will be rate-limited by the bridge, if it supports rate limiting. For more detail, please see the ebrRateLimiting group.')
ebrTwoSapProtoTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 8, 5), )
if mibBuilder.loadTexts: ebrTwoSapProtoTable.setStatus('mandatory')
if mibBuilder.loadTexts: ebrTwoSapProtoTable.setDescription('A table that contains filtering information about 802.2 SAPs in the DSAP field for 2-port bridges.')
ebrTwoSapProtoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 8, 5, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "ebrTwoSapIndex"))
if mibBuilder.loadTexts: ebrTwoSapProtoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ebrTwoSapProtoEntry.setDescription('A table that contains filtering information about 802.2 SAPs in the DSAP field for 2-port bridges.')
ebrTwoSapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 8, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrTwoSapIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ebrTwoSapIndex.setDescription('Index of the SAP table.')
ebrTwoSapValue = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 8, 5, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrTwoSapValue.setStatus('mandatory')
if mibBuilder.loadTexts: ebrTwoSapValue.setDescription("The 802.2 DSAP in a frame to which this entry's filtering information applies.")
ebrTwoSapStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 8, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("forward", 1), ("filter", 2), ("invalid", 3), ("rateLimit", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrTwoSapStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ebrTwoSapStatus.setDescription('Action taken by bridge when it sees this 802.2 SAP in the DSAP field of a received frame. The meanings of the values are: forward(1) : Frames received with this sap are allowed to be forwarded. filter(2) : Frames received with this sap should be filtered. invalid(3) : Writing this value to the object removes the corresponding entry. rateLimit(4) : Frames received with this sap will be rate-limited by the bridge, if it supports rate limiting. For more detail, please see the ebrRateLimiting group.')
ebrTwoSnapProtoTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 8, 6), )
if mibBuilder.loadTexts: ebrTwoSnapProtoTable.setStatus('mandatory')
if mibBuilder.loadTexts: ebrTwoSnapProtoTable.setDescription('A table that contains filtering information about 5-byte SNAP PIDs for 2-port bridges.')
ebrTwoSnapProtoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 8, 6, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "ebrTwoSnapIndex"))
if mibBuilder.loadTexts: ebrTwoSnapProtoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ebrTwoSnapProtoEntry.setDescription('A table that contains filtering information about 5-byte SNAP PIDs for 2-port bridges.')
ebrTwoSnapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 8, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrTwoSnapIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ebrTwoSnapIndex.setDescription('The index into the SNAP table.')
ebrTwoSnapValue = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 8, 6, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(5, 5)).setFixedLength(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrTwoSnapValue.setStatus('mandatory')
if mibBuilder.loadTexts: ebrTwoSnapValue.setDescription("The SNAP PID in an 802 frame to which this entry's filtering information applies.")
ebrTwoSnapStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 8, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("forward", 1), ("filter", 2), ("invalid", 3), ("rateLimit", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrTwoSnapStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ebrTwoSnapStatus.setDescription('Action taken by bridge when it sees this SNAP PID in a received 802 frame. The meanings of the values are: forward(1) : Frames received with this snap pid are allowed to be forwarded. filter(2) : Frames received with this snap pid should be filtered. invalid(3) : Writing this value to the object removes the corresponding entry. rateLimit(4) : Frames received with this snap pid will be rate-limited by the bridge, if it supports rate limiting. For more detail, please see the ebrRateLimiting group.')
ebrMultiEnetProtoTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 9, 1), )
if mibBuilder.loadTexts: ebrMultiEnetProtoTable.setStatus('mandatory')
if mibBuilder.loadTexts: ebrMultiEnetProtoTable.setDescription('A table that contains filtering information about Ethernet protocol types for multi-port bridges.')
ebrMultiEnetProtoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 9, 1, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "ebrMultiEnetProtoType"), (0, "DEC-ELAN-MIB", "ebrMultiEnetReceivePort"))
if mibBuilder.loadTexts: ebrMultiEnetProtoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ebrMultiEnetProtoEntry.setDescription('A table that contains filtering information about Ethernet protocol types for multi-port bridges.')
ebrMultiEnetProtoType = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 9, 1, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrMultiEnetProtoType.setStatus('mandatory')
if mibBuilder.loadTexts: ebrMultiEnetProtoType.setDescription("The protocol type in a frame to which this entry's filtering information applies.")
ebrMultiEnetReceivePort = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 9, 1, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrMultiEnetReceivePort.setStatus('mandatory')
if mibBuilder.loadTexts: ebrMultiEnetReceivePort.setDescription('The port from which a frame must be received to use the corresponding ebrMultiPortEnetProtoType field. A value of zero indicates that this entry applies on all ports of the bridge.')
ebrMultiEnetAllowedToGoTo = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 9, 1, 1, 3), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrMultiEnetAllowedToGoTo.setStatus('mandatory')
if mibBuilder.loadTexts: ebrMultiEnetAllowedToGoTo.setDescription("The set of ports to which frames received from a specific port and containing the protocol type specified by ebrMultiEnetProtoType are allowed to be forwarded. Each octet within the value of this object specifies a set of eight ports, with the first octet specifying ports 1 through 8, the second octet specifying port 9 through 16 etc. Within each octet, the most significant bit represents the lowest numbered port, and the least significant bit represents the highest numbered port. If a bit has a value of '1', then the corresponding port is included in the set of ports; the port is not included if its bit has a value of '0'.")
ebrMultiEnetStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 9, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("portMask", 1), ("invalid", 2), ("filter", 3), ("forward", 4), ("rateLimit", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrMultiEnetStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ebrMultiEnetStatus.setDescription('Action taken by bridge when it sees this ethernet protocol type in a received frame. The meanings of the values are: portMask(1) : The static filtering for this address is specified by the MultiEnetAllowedToGoTo field. invalid(2) : Writing this value to the object removes the corresponding entry. filter(3) : Frames received with this protocol type should be filtered. forward(4) : Frames received with this protocol type are allowed to be forwarded. rateLimit(5) : Frames received with this protocol type will be rate-limited by the bridge, if it supports rate limiting. For more detail, please see the ebrRateLimiting group.')
ebrMultiSapProtoTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 9, 2), )
if mibBuilder.loadTexts: ebrMultiSapProtoTable.setStatus('mandatory')
if mibBuilder.loadTexts: ebrMultiSapProtoTable.setDescription('A table that contains filtering information about 802.2 SAPs in the DSAP field for multi-port bridges.')
ebrMultiSapProtoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 9, 2, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "ebrMultiSapValue"), (0, "DEC-ELAN-MIB", "ebrMultiSapReceivePort"))
if mibBuilder.loadTexts: ebrMultiSapProtoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ebrMultiSapProtoEntry.setDescription('A table that contains filtering information about 802.2 SAPs in the DSAP field for multi-port bridges.')
ebrMultiSapValue = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 9, 2, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrMultiSapValue.setStatus('mandatory')
if mibBuilder.loadTexts: ebrMultiSapValue.setDescription("The 802.2 DSAP in a frame to which this entry's filtering information applies.")
ebrMultiSapReceivePort = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 9, 2, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrMultiSapReceivePort.setStatus('mandatory')
if mibBuilder.loadTexts: ebrMultiSapReceivePort.setDescription('The port from which a frame must be received to use the corresponding ebrMultiPortSapProtoType field. A value of zero indicates that this entry applies on all ports of the bridge.')
ebrMultiSapAllowedToGoTo = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 9, 2, 1, 3), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrMultiSapAllowedToGoTo.setStatus('mandatory')
if mibBuilder.loadTexts: ebrMultiSapAllowedToGoTo.setDescription("The set of ports to which frames received from a specific port and containing the DSAP in an 802 frame specified by ebrMultiSapValue are allowed to be forwarded. Each octet within the value of this object specifies a set of eight ports, with the first octet specifying ports 1 through 8, the second octet specifying port 9 through 16 etc. Within each octet, the most significant bit represents the lowest numbered port, and the least significant bit represents the highest numbered port. If a bit has a value of '1', then the corresponding port is included in the set of ports; the port is not included if its bit has a value of '0'.")
ebrMultiSapStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 9, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("portMask", 1), ("invalid", 2), ("filter", 3), ("forward", 4), ("rateLimit", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrMultiSapStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ebrMultiSapStatus.setDescription('Action taken by bridge when it sees this 802.2 SAP in the DSAP field of a received frame. The meanings of the values are: portMask(1) : The static filtering for this address is specified by the MultiSapAllowedToGoTo field. invalid(2) : Writing this value to the object removes the corresponding entry. filter(3) : Frames received with this protocol type should be filtered. forward(4) : Frames received with this protocol type are allowed to be forwarded. rateLimit(5) : Frames received with this protocol type will be rate-limited by the bridge, if it supports rate limiting. For more detail, please see the ebrRateLimiting group.')
ebrMultiSnapProtoTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 9, 3), )
if mibBuilder.loadTexts: ebrMultiSnapProtoTable.setStatus('mandatory')
if mibBuilder.loadTexts: ebrMultiSnapProtoTable.setDescription('A table that contains filtering information about 5-byte SNAP PIDs for multi-port bridges.')
ebrMultiSnapProtoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 9, 3, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "ebrMultiSnapValue"), (0, "DEC-ELAN-MIB", "ebrMultiSnapReceivePort"))
if mibBuilder.loadTexts: ebrMultiSnapProtoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ebrMultiSnapProtoEntry.setDescription('A table that contains filtering information about 5-byte SNAP PIDs for multi-port bridges.')
ebrMultiSnapValue = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 9, 3, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(5, 5)).setFixedLength(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrMultiSnapValue.setStatus('mandatory')
if mibBuilder.loadTexts: ebrMultiSnapValue.setDescription("The SNAP PID in an 802 frame to which this entry's filtering information applies.")
ebrMultiSnapReceivePort = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 9, 3, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrMultiSnapReceivePort.setStatus('mandatory')
if mibBuilder.loadTexts: ebrMultiSnapReceivePort.setDescription('The port from which a frame must be received to use the corresponding ebrMultiPortSnapProtoType field. A value of zero indicates that this entry applies on all ports of the bridge.')
ebrMultiSnapAllowedToGoTo = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 9, 3, 1, 3), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrMultiSnapAllowedToGoTo.setStatus('mandatory')
if mibBuilder.loadTexts: ebrMultiSnapAllowedToGoTo.setDescription("The set of ports to which frames received from a specific port and containing the SNAP PID in an 802 frame specified by ebrMultiSnapValue are allowed to be forwarded. Each octet within the value of this object specifies a set of eight ports, with the first octet specifying ports 1 through 8, the second octet specifying port 9 through 16 etc. Within each octet, the most significant bit represents the lowest numbered port, and the least significant bit represents the highest numbered port. If a bit has a value of '1', then the corresponding port is included in the set of ports; the port is not included if its bit has a value of '0'.")
ebrMultiSnapStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 9, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("portMask", 1), ("invalid", 2), ("filter", 3), ("forward", 4), ("rateLimit", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrMultiSnapStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ebrMultiSnapStatus.setDescription('Action taken by bridge when it sees this SNAP PID in a received 802 frame. The meanings of the values are: portMask(1) : The static filtering for this address is specified by the MultiSnapAllowedToGoTo field. invalid(2) : Writing this value to the object removes the corresponding entry. filter(3) : Frames received with this protocol type should be filtered. forward(4) : Frames received with this protocol type are allowed to be forwarded. rateLimit(5) : Frames received with this protocol type will be rate-limited by the bridge, if it supports rate limiting. For more detail, please see the ebrRateLimiting group.')
ebrMultiSwTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 10, 1), )
if mibBuilder.loadTexts: ebrMultiSwTable.setStatus('mandatory')
if mibBuilder.loadTexts: ebrMultiSwTable.setDescription('A list of interface entries. The number of entries is given by ifNumber, defined in MIB-II.')
ebrMultiSwEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 10, 1, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "ebrMultiSwIndex"))
if mibBuilder.loadTexts: ebrMultiSwEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ebrMultiSwEntry.setDescription('A collection of objects containing information for a given interface.')
ebrMultiSwIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 10, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrMultiSwIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ebrMultiSwIndex.setDescription('Identifies the Interface to which this entry applies.')
ebrMultiSwManualFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 10, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrMultiSwManualFilter.setStatus('mandatory')
if mibBuilder.loadTexts: ebrMultiSwManualFilter.setDescription('A switch that controls address filtering. When true, the bridge purges the learned entries from its forwarding database, stops its learning process, and forwards only frames with destination and source addresses that have been specified via management.')
ebrMultiSwProtoEnetOther = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 10, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("forward", 1), ("filter", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrMultiSwProtoEnetOther.setStatus('mandatory')
if mibBuilder.loadTexts: ebrMultiSwProtoEnetOther.setDescription('Action taken by the bridge on Ethernet protocol types other than those specified in the ebrMultiEnetProtoTable.')
ebrMultiSwProtoSapOther = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 10, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("forward", 1), ("filter", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrMultiSwProtoSapOther.setStatus('mandatory')
if mibBuilder.loadTexts: ebrMultiSwProtoSapOther.setDescription('Action taken by the bridge on 802.2 DSAPs other than those specified in the ebrMultiSapProtoTable.')
ebrMultiSwProtoSnapOther = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 10, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("forward", 1), ("filter", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrMultiSwProtoSnapOther.setStatus('mandatory')
if mibBuilder.loadTexts: ebrMultiSwProtoSnapOther.setDescription('Action taken by the bridge on the 5-byte SNAP PIDs other than those specified in the ebrMultiSnapProtoTable.')
ebrNTPTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 11, 1), )
if mibBuilder.loadTexts: ebrNTPTable.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNTPTable.setDescription('A table of Ethernet protocol types which will selectively be translated in such a way as to guarantee that the form in which a packet was received - Ethernet PT or 802.3 with 1042 format and this PT - will be retained across a pair of these bridges.')
ebrNTPEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 11, 1, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "ebrNTPtype"))
if mibBuilder.loadTexts: ebrNTPEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNTPEntry.setDescription('A list of NTP protocol type entries.')
ebrNTPtype = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 11, 1, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNTPtype.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNTPtype.setDescription('A protocol type in the NTP table.')
ebrNTPStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 11, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNTPStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNTPStatus.setDescription('Writing invalid(2) to this object removes the corresponding entry. When read, this object always returns a value of other(1).')
esysIPXSwitch = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 11, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: esysIPXSwitch.setStatus('mandatory')
if mibBuilder.loadTexts: esysIPXSwitch.setDescription("A software switch that, when set to true, causes the bridge to translate IPX 'raw 802.3' packets into SNAP encapsulated packets on the FDDI. Note that this works only in environments where all IPX stations use only this particular format. It is recommended that the Ethernet v2 format be used on IPX stations for full connectivity of IPX stations across Ethernet as well as FDDI bridged and routed networks.")
ebrRateLimitSwitch = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 12, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrRateLimitSwitch.setStatus('mandatory')
if mibBuilder.loadTexts: ebrRateLimitSwitch.setDescription("By default, rate limiting will be disabled. It can be enabled by setting this object to 'true(1)'.")
ebrRateLimit = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 12, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrRateLimit.setStatus('mandatory')
if mibBuilder.loadTexts: ebrRateLimit.setDescription('This is the maximum number of rate-limited frames per second that the bridge will forward per second.')
ebrRateLimitCounterTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 12, 3), )
if mibBuilder.loadTexts: ebrRateLimitCounterTable.setStatus('mandatory')
if mibBuilder.loadTexts: ebrRateLimitCounterTable.setDescription('A table of the count of frames that were dropped by the bridge due to rate limiting on each port.')
ebrRateLimitCounterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 12, 3, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "ebrRateLimitPort"))
if mibBuilder.loadTexts: ebrRateLimitCounterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ebrRateLimitCounterEntry.setDescription('A list of rate limited frame counter entries.')
ebrRateLimitPort = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 12, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrRateLimitPort.setStatus('mandatory')
if mibBuilder.loadTexts: ebrRateLimitPort.setDescription('The port for which this entry contains rate limit counters information.')
ebrRateLimitAddressFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 12, 3, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrRateLimitAddressFrames.setStatus('mandatory')
if mibBuilder.loadTexts: ebrRateLimitAddressFrames.setDescription('This is the number of frames per second that were filtered due to address rate limiting.')
ebrRateLimitProtocolFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 4, 12, 3, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrRateLimitProtocolFrames.setStatus('mandatory')
if mibBuilder.loadTexts: ebrRateLimitProtocolFrames.setDescription('This is the number of frames per second that were filtered due to protocol rate limiting.')
eauth1 = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 5, 1))
eauthTrapCommunity = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 5, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eauthTrapCommunity.setStatus('mandatory')
if mibBuilder.loadTexts: eauthTrapCommunity.setDescription('The community string used in SNMP Trap PDUs.')
eauthTrapUserTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 5, 1, 2), )
if mibBuilder.loadTexts: eauthTrapUserTable.setStatus('mandatory')
if mibBuilder.loadTexts: eauthTrapUserTable.setDescription('A list of addresses to which traps will be sent and associated information.')
eauthTrapUserEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 5, 1, 2, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "eauthTrapUserAddr"))
if mibBuilder.loadTexts: eauthTrapUserEntry.setStatus('mandatory')
if mibBuilder.loadTexts: eauthTrapUserEntry.setDescription('Objects containing information for a given trap address.')
eauthTrapUserAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 5, 1, 2, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eauthTrapUserAddr.setStatus('mandatory')
if mibBuilder.loadTexts: eauthTrapUserAddr.setDescription('An IP Address to which all SNMP Trap messages will be sent.')
eauthTrapUserStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 5, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eauthTrapUserStatus.setStatus('mandatory')
if mibBuilder.loadTexts: eauthTrapUserStatus.setDescription('Writing invalid(2) to this object removes the corresponding entry. When read, this object always returns a value of other(1).')
eauthReadOnlyCommunity = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 5, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eauthReadOnlyCommunity.setStatus('mandatory')
if mibBuilder.loadTexts: eauthReadOnlyCommunity.setDescription('The community string used to identify an SNMP community with access rights of Read-only.')
eauthReadOnlyUserTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 5, 1, 4), )
if mibBuilder.loadTexts: eauthReadOnlyUserTable.setStatus('mandatory')
if mibBuilder.loadTexts: eauthReadOnlyUserTable.setDescription('A list of Read-only users and associated information.')
eauthReadOnlyUserEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 5, 1, 4, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "eauthReadOnlyUserAddr"))
if mibBuilder.loadTexts: eauthReadOnlyUserEntry.setStatus('mandatory')
if mibBuilder.loadTexts: eauthReadOnlyUserEntry.setDescription('Objects containing information for a given Read-only user.')
eauthReadOnlyUserAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 5, 1, 4, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eauthReadOnlyUserAddr.setStatus('mandatory')
if mibBuilder.loadTexts: eauthReadOnlyUserAddr.setDescription("An IP Address, or a set of IP addresses, which has Read-only SNMP access to this agent. If this object is used as a wildcard, bits corresponding to the zero bits in the corresponding euthReadOnlyUserMask are treated as don't-care.")
eauthReadOnlyUserMask = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 5, 1, 4, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eauthReadOnlyUserMask.setStatus('mandatory')
if mibBuilder.loadTexts: eauthReadOnlyUserMask.setDescription("A 32-bit mask which is applied to (ANDed with) the source IP address of an incoming SNMP message. If the result of the mask is equal to eauthReadOnlyUserAddr, the message is considered to have come from a user who has Read-only access. This allows wildcarding, for example, for all NMS's on a given subnet. For fully specified IP addresses required to be in this community, this mask may be set to all 1's.")
eauthReadOnlyUserStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 5, 1, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eauthReadOnlyUserStatus.setStatus('mandatory')
if mibBuilder.loadTexts: eauthReadOnlyUserStatus.setDescription('Writing invalid(2) to this object removes the corresponding entry. When read, this object always returns a value of other(1).')
eauthReadWriteCommunity = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 5, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eauthReadWriteCommunity.setStatus('mandatory')
if mibBuilder.loadTexts: eauthReadWriteCommunity.setDescription('The community string used to identify an SNMP community with access rights of Read-Write.')
eauthReadWriteUserTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 5, 1, 6), )
if mibBuilder.loadTexts: eauthReadWriteUserTable.setStatus('mandatory')
if mibBuilder.loadTexts: eauthReadWriteUserTable.setDescription('A list of Read-Write users and associated information.')
eauthReadWriteUserEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 5, 1, 6, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "eauthReadWriteUserAddr"))
if mibBuilder.loadTexts: eauthReadWriteUserEntry.setStatus('mandatory')
if mibBuilder.loadTexts: eauthReadWriteUserEntry.setDescription('Objects containing information for a given Read-Write user.')
eauthReadWriteUserAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 5, 1, 6, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eauthReadWriteUserAddr.setStatus('mandatory')
if mibBuilder.loadTexts: eauthReadWriteUserAddr.setDescription("An IP Address, or a set of IP addresses, which has Read-Write SNMP access to this agent. If this object is used as a wildcard, bits corresponding to the zero bits in the corresponding euthReadWriteUserMask are treated as don't-care.")
eauthReadWriteUserMask = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 5, 1, 6, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eauthReadWriteUserMask.setStatus('mandatory')
if mibBuilder.loadTexts: eauthReadWriteUserMask.setDescription("A 32-bit mask which is applied to (ANDed with) the source IP address of an incoming SNMP message. If the result of the mask is equal to eauthReadWriteUserAddr, the message is considered to have come from a user who has Read-Write access. This allows wildcarding, for example, for all NMS's on a given subnet. For fully specified IP addresses required to be in this community, this mask may be set to all 1's.")
eauthReadWriteUserStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 1, 5, 1, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eauthReadWriteUserStatus.setStatus('mandatory')
if mibBuilder.loadTexts: eauthReadWriteUserStatus.setDescription('Writing invalid(2) to this object removes the corresponding entry. When read, this object always returns a value of other(1).')
sysobjid = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 15))
bridges = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 15, 3))
gigaswitch = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3))
minimumGIGAswitchMIBVersionSupported = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: minimumGIGAswitchMIBVersionSupported.setStatus('mandatory')
if mibBuilder.loadTexts: minimumGIGAswitchMIBVersionSupported.setDescription(' When new GIGAswitch MIBs are released to the public, they will be given new version numbers. The implementation strategy allows multiple versions to be supported simultaneously. MIB versions greater than or equal to this version are still supported. ')
maximumGIGAswitchMIBVersionSupported = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: maximumGIGAswitchMIBVersionSupported.setStatus('mandatory')
if mibBuilder.loadTexts: maximumGIGAswitchMIBVersionSupported.setDescription(' When new GIGAswitch MIBs are released to the public, they will be given new version numbers. The implementation strategy allows multiple versions to be supported simultaneously. MIB versions less than or equal to this version are still supported. A management station may load a MIB which is not supported until the GIGAswitch software is updated. ')
gigaversion1 = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3))
gigaBox = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 1))
gigaBridge = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2))
gigaUpgradeSoftware = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 3))
gigaIP = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 4))
gigaSets = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 5))
gigaSnmpDebug = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 6))
gigaXglEthernetGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 7))
serviceClassAssignments = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 5))
filterByReferencedExpression = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 1))
ebrNportMatrixNameTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 1, 1), )
if mibBuilder.loadTexts: ebrNportMatrixNameTable.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportMatrixNameTable.setDescription('This table allows filter matrices to be succinctly specified and named. These matrices may later be used and combined in filter specifications.')
ebrNportMatrixNameEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 1, 1, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "ebrNportMatrixName"))
if mibBuilder.loadTexts: ebrNportMatrixNameEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportMatrixNameEntry.setDescription('A particular named filter matrix.')
ebrNportMatrixName = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 1, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrNportMatrixName.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportMatrixName.setDescription('This name for a filter matrix is whatever the user likes, as long as it is a unique filter matrix name.')
ebrNportMatrixValue = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 1, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportMatrixValue.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportMatrixValue.setDescription('A matrix is expressed using a shorthand that says what input ports can talk to what output ports. An examples of a specification is: 11:1; 1:3-5; 2:0,3; 4-7,9:4-7,9; 10: Semicolons separate expressions. Within each expression, the colon has a left hand side and a right hand side. Bridge ports on the left hand side can send packets to bridge ports on the right hand side. Commas separate items in a list of bridge ports. Hyphens are short-hand for specifying a range of numbers. If there is no right hand side, the bridge ports on the left cannot send packets to any bridge port (unless the matrix is combined with some some other matrix in a filter specification, or unless the filter is overridden). Bridge port numbers are specified in decimal. A matrix will read back in a form equivalent to the form written. It may not read back exactly as written. No single matrix defines whether a packet arriving on a port is forwarded to its destination. Various destination address, source address, protocol, and default filtering specifications are combined to determine whether the packet is forwarded. If the ebrNportMatrixValue is changed, all filters using it are immediately updated.')
ebrNportMatrixStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("invalid", 1), ("permanent", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportMatrixStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportMatrixStatus.setDescription('Assigning the value invalid will result in an error while the matrix is still reference by some filter. All matrices are permanent; it is their usage which may or may not be temporary.')
ebrNportMatrixFppnValue = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 1, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportMatrixFppnValue.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportMatrixFppnValue.setDescription('A matrix is expressed using a shorthand that says what input ports can talk to what output ports. An examples of a specification is: 1.1,2.1-14.2:1.1-14.2; 2.2:5.3,6.4; 10.3:; Semicolons separate expressions. Within each expression, the colon has a left hand side and a right hand side. Front panel ports on the left hand side can send packets to front panel ports on the right hand side. Commas separate items in a list of front panel ports. Hyphens are short-hand for specifying a range of numbers. If there is no right hand side, the front panel ports on the left cannot send packets to any front panel port (unless the matrix is combined with some some other matrix in a filter specification, or unless the filter is overridden). Front panel port numbers are of the form (slot.connector), where slot is the slot number the module is plugged into, and connector is the connector number specified on the front of the card. A matrix will read back in a form equivalent to the form written. It may not read back exactly as written. No single matrix defines whether a packet arriving on a port is forwarded to its destination. Various destination address, source address, protocol, and default filtering specifications are combined to determine whether the packet is forwarded. If the ebrNportMatrixFppnValue is changed, all filters using it are immediately updated. Managers may not specify both ebrNportMatrixValue and ebrNportMatrixFppnValue at the same time to set an entry in this table.')
ebrNportSapNameTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 1, 2), )
if mibBuilder.loadTexts: ebrNportSapNameTable.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportSapNameTable.setDescription('The filters specified by SAP protocol.')
ebrNportSapNameEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 1, 2, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "ebrNportSapName"))
if mibBuilder.loadTexts: ebrNportSapNameEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportSapNameEntry.setDescription('A portion of a particular filter for a particular SAP protocol.')
ebrNportSapName = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 1, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrNportSapName.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportSapName.setDescription('This name for a portion of a filter is whatever the user likes, as long as it is a unique ebrNportSapName. The combination of ebrNportSapNameSap and ebrNportSapMatrixName is unique within this table. Insertions of new names for pre-existing combinations will be denied. ebrNportSapName is present and is the index to give a mnemonic handle on the combination of SAP and matrix for purposes of discussion and of access through the network management station user interface. SAPs, for example, are often just meaningless numbers unless laborious steps are taken to interpret them. ')
ebrNportSapNameSap = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 1, 2, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportSapNameSap.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportSapNameSap.setDescription('The one-byte SAP. Changes to ebrNportSapProtoTable for this SAP are denied while filtering of the SAP is specified by reference to a named matrix using this table.')
ebrNportSapMatrixName = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 1, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportSapMatrixName.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportSapMatrixName.setDescription('A ebrNportMatrixName. Multiple matrices for the same SAP are combined using an elementwise-OR operator.')
ebrNportSapNameDisp = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("filter", 1), ("alwaysFilter", 2), ("alwaysForward", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportSapNameDisp.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportSapNameDisp.setDescription(" filter(1) : The filtering for this SAP is specified by the filter matrix. alwaysFilter(2) : Frames of this SAP (protocol) are filtered regardless of any other alwaysForward dispositions based on the frame's address. The filtering information is specified by the filter matrix. alwaysForward(3) : Frames for this SAP (protocol) are sent to ports specified in the filter matrix regardless of any address filter with a disposition of filter. The alwaysForward disposition also overrides a forwarding disposition of filter in the default filter matrix object. Filters with a disposition of alwaysFilter are never superceded. Setting this object will cause a side effect on the ebrNportSapFilterCharacteristicsTable entry for this SAP. It is here to group information for window-based forms. Setting this object will also cause a side effect on other entries in this table with the same SAP value. ")
ebrNportSapNameStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("invalid", 1), ("permanent", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportSapNameStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportSapNameStatus.setDescription(' This object specifies the permanence of the associated filter matrix, and also provides a means to delete a filter matrix. Writing invalid(1) to the object removes the filter. Writing permanent(2) value to the object indicates the filter is preserved across a bridge reset. ')
ebrNportSnapNameTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 1, 3), )
if mibBuilder.loadTexts: ebrNportSnapNameTable.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportSnapNameTable.setDescription('The filters specified by Protocol ID for the SNAP SAP.')
ebrNportSnapNameEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 1, 3, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "ebrNportSnapName"))
if mibBuilder.loadTexts: ebrNportSnapNameEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportSnapNameEntry.setDescription('A portion of a particular filter for a particular Protocol ID.')
ebrNportSnapName = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 1, 3, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrNportSnapName.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportSnapName.setDescription('This name for a portion of a filter is whatever the user likes, as long as it is a unique ebrNportSnapName. The combination of ebrNportSnapNameSnap and ebrNportSnapMatrixName is unique within this table. Insertions of new names for pre-existing combinations will be denied. ebrNportSnapName is present and is the index to give a mnemonic handle on the combination of protocol and matrix for purposes of discussion and of access through the network management station user interface. Protocol IDs, for example, are often just meaningless numbers unless laborious steps are taken to interpret them. ')
ebrNportSnapNameSnap = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 1, 3, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(5, 5)).setFixedLength(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportSnapNameSnap.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportSnapNameSnap.setDescription('The five-byte PID. Changes to ebrNportSnapProtoTable for this protocol are denied while filtering of the protocol is specified by reference to a named matrix using this table.')
ebrNportSnapMatrixName = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 1, 3, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportSnapMatrixName.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportSnapMatrixName.setDescription('A ebrNportMatrixName. Multiple matrices for the same PID are combined using an elementwise-OR operator.')
ebrNportSnapNameDisp = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 1, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("filter", 1), ("alwaysFilter", 2), ("alwaysForward", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportSnapNameDisp.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportSnapNameDisp.setDescription(" filter(1) : The filtering for this Protocol ID is specified by the filter matrix. alwaysFilter(2) : Frames of this Protocol ID are filtered regardless of any other alwaysForward dispositions based on the frame's address. The filtering information is specified by the filter matrix. alwaysForward(3) : Frames for this Protocol ID are sent to ports specified in the filter matrix regardless of any address filter with a disposition of filter. The alwaysForward disposition also overrides a forwarding disposition of filter in the default filter matrix object. Filters with a disposition of alwaysFilter are never superceded. Setting this object will cause a side effect on the ebrNportSnapFilterCharacteristicsTable entry for this protocol. It is here to group information for window-based forms. Setting this object will also cause a side effect onother entries in this table with the same protocol value. ")
ebrNportSnapNameStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 1, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("invalid", 1), ("permanent", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportSnapNameStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportSnapNameStatus.setDescription(' This object specifies the permanence of the associated filter matrix, and also provides a means to delete a filter matrix. Writing invalid(1) to the object removes the filter. Writing permanent(2) value to the object indicates the filter is preserved across a bridge reset. ')
ebrNportDANameTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 1, 4), )
if mibBuilder.loadTexts: ebrNportDANameTable.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportDANameTable.setDescription('The filters specified by destination address.')
ebrNportDANameEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 1, 4, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "ebrNportDAName"))
if mibBuilder.loadTexts: ebrNportDANameEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportDANameEntry.setDescription('A portion of a particular filter for a particular destination address.')
ebrNportDAName = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 1, 4, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrNportDAName.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportDAName.setDescription(' This name for a portion of a filter is whatever the user likes, as long as it is a unique ebrNportDAName. The combination of ebrNportDANameDA and ebrNportDAMatrixName is unique within this table. Insertions of new names for pre-existing combinations will be denied. ebrNportDAName is present and is the index to give a mnemonic handle on the combination of address and matrix for purposes of discussion and of access through the network management station user interface. Addresses, for example, are often just meaningless numbers unless laborious steps are taken to interpret them. ')
ebrNportDANameDA = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 1, 4, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportDANameDA.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportDANameDA.setDescription('The six-byte destination address. Changes to ebrNportStaticDATable for this address are denied while filtering of the address is specified by reference to a named matrix using this table.')
ebrNportDAMatrixName = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 1, 4, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportDAMatrixName.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportDAMatrixName.setDescription('A ebrNportMatrixName. Multiple matrices for the same address are combined using an elementwise-OR operator.')
ebrNportDANameDisp = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 1, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("filter", 1), ("alwaysFilter", 2), ("alwaysForward", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportDANameDisp.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportDANameDisp.setDescription(" filter(1) : The filtering for this address is specified by the filter matrix. alwaysFilter(2) : Frames destined to address are filtered regardless of any other alwaysForward dispositions based on the frame's source address or protocol type. The filtering information is specified by the filter matrix. alwaysForward(3) : Frames destined to address are always forwarded to ebrNportPortNum if specified. The filter matrix is used to specify ports to which frames may be sent. In both cases, this disposition overrides filters based on the frame's source address or protocol type, unless either of those filters has an alwaysFilter disposition. Setting this object will side effect the ebrNportStaticDAFilterCharacteristicsTable entry for this address. It is here to group information for window-based forms. Setting this object will also cause a side effect on other entries in this table with the same address. ")
ebrNportDANameStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 1, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("invalid", 2), ("permanent", 3), ("deleteOnReset", 4), ("deleteOnTimeout", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportDANameStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportDANameStatus.setDescription(" other(1) - This entry is currently in use, but the conditions under which it will remain so are different from each of the following values. Like other uses of 'other' in MIBs, this value may not be assigned to the object. invalid(2) - Writing this value to the object removes the entry permanent(3) - Writing this value to the object indicates that the entry is preserved across a bridge reset. deleteOnReset(4) - Writing this value removes the permanent entry characteristic. The entry is deleted upon the next bridge reset (SCP or GIGAswitch failure). Writing deleteOnReset is not supported. SNMP does not currently model viewing the non-volatile and volatile data structures independently, which can lead to unexpectedly having no filter if a reset occurs while temporarily trying a change to an existing filter. Writes of this value will result in a bad value return status. It is present for consistency with the Bridge MIB (RFC 1286), which describes address filters. deleteOnTimeout(5) - Writing this value removes the permanent entry characteristic. Since the timers used for aging information within the bridge are hidden from the user, the change may in fact take place immediately. Writing deleteOnTimeout is not supported. SNMP does not currently model viewing the non-volatile and volatile data structures independently, which can lead to unexpectedly having no filter if a reset occurs while temporarily trying a change to an existing filter. Writes of this value will result in a bad value return status. It is present for consistency with the Bridge MIB (RFC 1286), which describes address filters. ")
ebrNportSANameTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 1, 5), )
if mibBuilder.loadTexts: ebrNportSANameTable.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportSANameTable.setDescription('The filters specified by source address.')
ebrNportSANameEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 1, 5, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "ebrNportSAName"))
if mibBuilder.loadTexts: ebrNportSANameEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportSANameEntry.setDescription('A portion of a particular filter for a particular source address.')
ebrNportSAName = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 1, 5, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrNportSAName.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportSAName.setDescription(' This name for a portion of a filter is whatever the user likes, as long as it is a unique ebrNportSAName. The combination of ebrNportSANameSA and ebrNportSAMatrixName is unique within this table. Insertions of new names for pre-existing combinations will be denied. ebrNportSAName is present and is the index to give a mnemonic handle on the combination of address and matrix for purposes of discussion and of access through the network management station user interface. Addresses, for example, are often just meaningless numbers unless laborious steps are taken to interpret them. ')
ebrNportSANameSA = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 1, 5, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportSANameSA.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportSANameSA.setDescription('The six-byte source address. Changes to ebrNportStaticSATable for this address are denied while filtering of the address is specified by reference to a named matrix using this table.')
ebrNportSAMatrixName = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 1, 5, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportSAMatrixName.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportSAMatrixName.setDescription('A ebrNportMatrixName. Multiple matrices for the same address are combined using an elementwise-OR operator.')
ebrNportSANameDisp = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 1, 5, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("portMask", 1), ("alwaysFilter", 2), ("alwaysForward", 3), ("lockdown", 4), ("lockdownportmask", 5), ("filter", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportSANameDisp.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportSANameDisp.setDescription("This object specifies how to interpret the ebrNportPortNum and the ebrNportSAMatrixName objects. portMask(1) : The static filtering for this address is specified by the filter matrix. alwaysFilter(2) : Frames sourced from this address are filtered regardless of any other alwaysForward dispositions based on the frame's destination address or protocol type. The static filtering information is specified by the filter matrix. alwaysForward(3) : Frames sourced from this address are sent to ports specified in the filter matrix regardless of any DA or protocol filter with a disposition of filter. The alwaysForward disposition also overrides a forwarding disposition of filter in the default filter matrix object. Filters with a disposition of alwaysFilter are never superceded. lockdown (4) : Frames sourced from this address are ONLY forwarded if received on the same port as ebrNportPortNum. lockdownportmask (5) : Frames sourced from this address are ONLY forwarded if received on the same port as ebrNportPortNum AND if the frame is destined to a permitted port as specified by the filter matrix. filter(6) : The static filtering for this address is specified by the filter matrix. portMask(1) is the different name with the same effect. Setting this object will side effect the ebrNportStaticSAFilterCharacteristicsTable entry for this address. It is here to group information for window-based forms. Setting this object will also cause a side effect on other entries in this table with the same address. ")
ebrNportSANameStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 1, 5, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("invalid", 2), ("permanent", 3), ("deleteOnReset", 4), ("deleteOnTimeout", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportSANameStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportSANameStatus.setDescription(" other(1) - This entry is currently in use, but the conditions under which it will remain so are different from each of the following values. Like other uses of 'other' in MIBs, this value may not be assigned to the object. invalid(2) - Writing this value to the object removes the entry permanent(3) - Writing this value to the object indicates that the entry is preserved across a bridge reset. deleteOnReset(4) - Writing this value removes the permanent entry characteristic. The entry is deleted upon the next bridge reset (SCP or GIGAswitch failure). Writing deleteOnReset is not supported. SNMP does not currently model viewing the non-volatile and volatile data structures independently, which can lead to unexpectedly having no filter if a reset occurs while temporarily trying a change to an existing filter. Writes of this value will result in a bad value return status. It is present for consistency with the Bridge MIB (RFC 1286), which describes address filters. deleteOnTimeout(5) - Writing this value removes the permanent entry characteristic. Since the timers used for aging information within the bridge are hidden from the user, the change may in fact take place immediately. Writing deleteOnTimeout is not supported. SNMP does not currently model viewing the non-volatile and volatile data structures independently, which can lead to unexpectedly having no filter if a reset occurs while temporarily trying a change to an existing filter. Writes of this value will result in a bad value return status. It is present for consistency with the Bridge MIB (RFC 1286), which describes address filters. ")
ebrNportMatrixNameRowTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 1, 8), )
if mibBuilder.loadTexts: ebrNportMatrixNameRowTable.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportMatrixNameRowTable.setDescription(' This table is another view of ebrNportMatrixNameTable. Changes to this table cause changes to ebrNportMatrixNameTable. Users or programs can choose whichever matrix specification language they feel more comfortable with. This table also side-steps issues of the worst-case ascii representation length on the part of either ebrNportMatrixNameTable or the management station interface. ')
ebrNportMatrixNameRowEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 1, 8, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "ebrNportmatrixName"), (0, "DEC-ELAN-MIB", "ebrNportMatrixReceivePort"))
if mibBuilder.loadTexts: ebrNportMatrixNameRowEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportMatrixNameRowEntry.setDescription('A particular row of a particular named filter matrix.')
ebrNportmatrixName = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 1, 8, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrNportmatrixName.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportmatrixName.setDescription(' This name for a filter matrix is whatever the user likes, as long as it is a unique filter matrix name. Same as ebrNportMatrixName. ')
ebrNportMatrixReceivePort = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 1, 8, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrNportMatrixReceivePort.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportMatrixReceivePort.setDescription('A bridge port number. Zero is treated as in other tables, and is short-hand for all rows not previously mentioned.')
ebrNportMatrixAllowedToGoTo = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 1, 8, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportMatrixAllowedToGoTo.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportMatrixAllowedToGoTo.setDescription("Just like all the other GoTos. The set of ports to which frames received from a specific port are allowed to be forwarded. Each octet of this object specifies a set of eight ports, with the first octet specifying ports 1 through 8, the second octet specifying port 9 through 16 etc. Within each octet, the most significant bit represents the lowest numbered port, and the least significant bit represents the highest numbered port. If a bit has a value of '1', then the corresponding port is included in the set of ports; the port is not included if its bit has a value of '0'. If the ebrNportMatrixAllowedToGoTo is changed, all filters using it are immediately updated.")
ebrNportMatrixNameRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 1, 8, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("invalid", 1), ("permanent", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportMatrixNameRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportMatrixNameRowStatus.setDescription(' Assigning the value invalid will delete the row of the matrix. Attempting to delete the last ebrNportmatrixName entry for a matrix will result in an error while the matrix is still reference by some filter. All matrices are permanent; it is their usage which may or may not be temporary. ')
ebrNportMatrixFppnRowTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 1, 11), )
if mibBuilder.loadTexts: ebrNportMatrixFppnRowTable.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportMatrixFppnRowTable.setDescription(' This table is yet another view of ebrNportMatrixNameTable. Changes to this table cause changes to ebrNportMatrixNameTable. Users or programs can choose whichever matrix specification language they feel more comfortable with. This table also side-steps issues of the worst-case ascii representation length on the part of either ebrNportMatrixNameTable or the management station interface. ')
ebrNportMatrixFppnRowEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 1, 11, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "ebrNportmatrixname"), (0, "DEC-ELAN-MIB", "ebrNportMatrixFppnReceivePort"))
if mibBuilder.loadTexts: ebrNportMatrixFppnRowEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportMatrixFppnRowEntry.setDescription('A particular row of a particular named filter matrix.')
ebrNportmatrixname = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 1, 11, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrNportmatrixname.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportmatrixname.setDescription(' This name for a filter matrix is whatever the user likes, as long as it is a unique filter matrix name. Same as ebrNportMatrixName. ')
ebrNportMatrixFppnReceivePort = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 1, 11, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrNportMatrixFppnReceivePort.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportMatrixFppnReceivePort.setDescription(' Front panel port numbers are of the form (slot.connector), where slot is the slot number the module is plugged into, and connector is the connector number specified on the front of the card. To avoid the syntactic ambiguity, the slot number must take two characters. For example, front panel port number 3.1 must be typed by 03.1. 0.0 is treated as in other tables, and is short-hand for all rows not previously mentioned.')
ebrNportMatrixFppnAllowedToGoTo = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 1, 11, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportMatrixFppnAllowedToGoTo.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportMatrixFppnAllowedToGoTo.setDescription("Just like all the other GoTos. The set of ports to which frames received from a specific port are allowed to be forwarded. Each octet of this object specifies a set of eight ports, with the first octet specifying ports 1 through 8, the second octet specifying port 9 through 16 etc. Within each octet, the most significant bit represents the lowest numbered port, and the least significant bit represents the highest numbered port. If a bit has a value of '1', then the corresponding port is included in the set of ports; the port is not included if its bit has a value of '0'. If the ebrNportMatrixFppnAllowedToGoTo is changed, all filters using it are immediately updated.")
ebrNportMatrixFppnRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 1, 11, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("invalid", 1), ("permanent", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportMatrixFppnRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportMatrixFppnRowStatus.setDescription(' Assigning the value invalid will delete the row of the matrix. Attempting to delete the last ebrNportmatrixname entry for a matrix will result in an error while the matrix is still reference by some filter. All matrices are permanent; it is their usage which may or may not be temporary. ')
ebrNportDefaultMatrixValue = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportDefaultMatrixValue.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportDefaultMatrixValue.setDescription("A matrix is expressed using a shorthand that says what input ports can talk to what output ports. An examples of a specification is: 11:1; 1:3-5; 2:0,3; 4-7,9:4-7,9; 10: Semicolons separate expressions. Within each expression, the colon has a left hand side and a right hand side. Bridge ports on the left hand side can send packets to bridge ports on the right hand side. Commas separate items in a list of bridge ports. Hyphens are short-hand for specifying a range of numbers. If there is no right hand side, the bridge ports on the left cannot send packets to any bridge port (unless the matrix is combined with some some other matrix in a filter specification, or unless the filter is overridden). Bridge port numbers are specified in decimal. A matrix will read back in a form equivalent to the form written. It may not read back exactly as written. No single matrix defines whether a packet arriving on a port is forwarded to its destination. Various destination address, source address, protocol, and default filtering specifications are combined to determine whether the packet is forwarded. Unspecified rows are set to one's, which means that the corresponding input ports can communicate with every output port. ")
ebrNportDefaultMatrixFppnValue = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportDefaultMatrixFppnValue.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportDefaultMatrixFppnValue.setDescription("A matrix is expressed using a shorthand that says what input front panel ports can talk to what output front panel ports. An examples of a specification is: 1.1,2.1-14.2:1.1-14.2; 2.2:5.3,6.4; 10.3:; Semicolons separate expressions. Within each expression, the colon has a left hand side and a right hand side. Front panel ports on the left hand side can send packets to front panel ports on the right hand side. Commas separate items in a list of front panel ports. Hyphens are short-hand for specifying a range of numbers. If there is no right hand side, the front panel ports on the left cannot send packets to any front panel port (unless the matrix is combined with some some other matrix in a filter specification, or unless the filter is overridden). Front panel port numbers are of the form (slot.connector), where slot is the slot number the module is plugged into, and connector is the connector number specified on the front of the card. A matrix will read back in a form equivalent to the form written. It may not read back exactly as written. No single matrix defines whether a packet arriving on a port is forwarded to its destination. Various destination address, source address, protocol, and default filtering specifications are combined to determine whether the packet is forwarded. Unspecified rows are set to one's, which means that the corresponding input ports can communicate with every output port. ")
ebrNportNamedDefaultMatrix = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportNamedDefaultMatrix.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportNamedDefaultMatrix.setDescription("When a matrix name is written to this object, the default matrix is set to the matrix if and only if the matrix exists. Unspecified rows in the matrix are set to one's, which means that the corresponding input ports can communicate with every output port. ")
ebrNportDefaultMatrixRowTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 1, 13), )
if mibBuilder.loadTexts: ebrNportDefaultMatrixRowTable.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportDefaultMatrixRowTable.setDescription(' This table is another view of ebrNportDefaultMatrixValue. ')
ebrNportDefaultMatrixRowEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 1, 13, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "ebrNportDefaultMatrixReceivePort"))
if mibBuilder.loadTexts: ebrNportDefaultMatrixRowEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportDefaultMatrixRowEntry.setDescription(' A particular row of the default matrix. ')
ebrNportDefaultMatrixReceivePort = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 1, 13, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrNportDefaultMatrixReceivePort.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportDefaultMatrixReceivePort.setDescription('A bridge port number.')
ebrNportDefaultMatrixAllowedToGoTo = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 1, 13, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrNportDefaultMatrixAllowedToGoTo.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportDefaultMatrixAllowedToGoTo.setDescription("The set of ports to which frames received from a specific port are allowed to be forwarded by default. Each octet of this object specifies a set of eight ports, with the first octet specifying ports 1 through 8, the second octet specifying port 9 through 16 etc. Within each octet, the most significant bit represents the lowest numbered port, and the least significant bit represents the highest numbered port. If a bit has a value of '1', then the corresponding port is included in the set of ports; the port is not included if its bit has a value of '0'. ")
ebrNportManualFilter = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportManualFilter.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportManualFilter.setDescription('The list of bridge ports in manual mode is listed. Manual mode means that the bridge purges the learned entries for that port from its forwarding database, stops its learning process on that port, and forwards to that port only frames with destination and source addresses that have been specified via management. A comma-separated list of bridge ports, with hyphens used to abbreviate ranges, is supported. The bridge port numbers are in decimal. ')
ebrNportFppnManualFilter = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportFppnManualFilter.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportFppnManualFilter.setDescription('The list of front panel ports in manual mode is listed. Manual mode means that the bridge purges the learned entries for that port from its forwarding database, stops its learning process on that port, and forwards to that port only frames with destination and source addresses that have been specified via management. A comma-separated list of front panel ports, with hyphens used to abbreviate ranges, is supported. Front panel port numbers are of the form (slot.connector), where slot is the slot number the module is plugged into, and connector is the connector number specified on the front of the card. ')
ebrNportFloodMatrixValue = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 1, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportFloodMatrixValue.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportFloodMatrixValue.setDescription("A flood matrix is expressed using a shorthand that says what input ports can be flooded to what output ports. Unspecified rows are set to one's, which means that the corresponding input ports can be flooded to every output port. ")
ebrNportFloodMatrixFppnValue = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 1, 15), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportFloodMatrixFppnValue.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportFloodMatrixFppnValue.setDescription("A flood matrix is expressed using a shorthand that says what input front panel ports can be flooded to what output front panel ports. Unspecified rows are set to one's, which means that the corresponding input ports can be flooded to every output port. ")
ebrNportNamedFloodMatrix = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 1, 16), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportNamedFloodMatrix.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportNamedFloodMatrix.setDescription("When a matrix name is written to this object, the flood matrix is set to the matrix if and only if the matrix exists. Unspecified rows in the matrix are set to one's, which means that the corresponding input ports can be flooded to every output port. ")
ebrNportFloodMatrixRowTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 1, 17), )
if mibBuilder.loadTexts: ebrNportFloodMatrixRowTable.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportFloodMatrixRowTable.setDescription(' This table is another view of ebrNportFloodMatrixValue. ')
ebrNportFloodMatrixRowEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 1, 17, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "ebrNportFloodMatrixReceivePort"))
if mibBuilder.loadTexts: ebrNportFloodMatrixRowEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportFloodMatrixRowEntry.setDescription(' A particular row of the flood matrix. ')
ebrNportFloodMatrixReceivePort = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 1, 17, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrNportFloodMatrixReceivePort.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportFloodMatrixReceivePort.setDescription('A bridge port number.')
ebrNportFloodMatrixAllowedToGoTo = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 1, 17, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ebrNportFloodMatrixAllowedToGoTo.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportFloodMatrixAllowedToGoTo.setDescription('The set of ports to which frames received from a specific port are allowed to be flooded by default. ')
filterByBitmapValue = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 2))
ebrNportStaticDATable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 2, 5), )
if mibBuilder.loadTexts: ebrNportStaticDATable.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportStaticDATable.setDescription('This table contains management-specified destination address filtering information about unicast and multicast addresses for N-port bridges. In RFC 1286 lingo, static objects are those objects which have been specified by network management.')
ebrNportStaticDAEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 2, 5, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "ebrNportDAAddress"), (0, "DEC-ELAN-MIB", "ebrNportDAReceivePort"))
if mibBuilder.loadTexts: ebrNportStaticDAEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportStaticDAEntry.setDescription('Information about a specific MAC address for which the bridge has some management-specified forwarding and/or filtering information.')
ebrNportDAAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 2, 5, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportDAAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportDAAddress.setDescription("The destination MAC Address in a frame to which this entry's filtering information applies.")
ebrNportDAReceivePort = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 2, 5, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportDAReceivePort.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportDAReceivePort.setDescription('The port from which a frame must be received to use the corresponding ebrNportDAAllowedToGoTo field. A value of zero indicates that this entry applies on all ports of the bridge for which there is no other applicable entry.')
ebrNportDAAllowedToGoTo = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 2, 5, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportDAAllowedToGoTo.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportDAAllowedToGoTo.setDescription("The set of ports to which frames received from a specific port and destined to the address specified by ebrNportDAAddress are allowed to be forwarded. Each octet of this object specifies a set of eight ports, with the first octet specifying ports 1 through 8, the second octet specifying port 9 through 16 etc. Within each octet, the most significant bit represents the lowest numbered port, and the least significant bit represents the highest numbered port. If a bit has a value of '1', then the corresponding port is included in the set of ports; the port is not included if its bit has a value of '0'. Filter matrix rows can be initialized or overwritten, but not deleted. Only whole matrices are deleted via the characteristics table. To produce the equivalent of row deletion, set the GoTo according to the following table: Disp GoTo filter/portMask 0xFFFFFFFFF0 alwaysFilter 0xFFFFFFFFF0 alwaysForward 0 ")
ebrNportStaticDAFilterCharacteristicsTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 2, 6), )
if mibBuilder.loadTexts: ebrNportStaticDAFilterCharacteristicsTable.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportStaticDAFilterCharacteristicsTable.setDescription('A table that contains information about how static destination address filters (for unicast and multicast addresses) are used within N-port bridges. Static objects are those objects which have been specified by network management.')
ebrNportStaticDAFilterCharacteristicsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 2, 6, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "ebrNportDestinationAddress"))
if mibBuilder.loadTexts: ebrNportStaticDAFilterCharacteristicsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportStaticDAFilterCharacteristicsEntry.setDescription("Information about a specific static MAC destination address filter's usage within N-port bridges.")
ebrNportDestinationAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 2, 6, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportDestinationAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportDestinationAddress.setDescription("The destination MAC Address in a frame to which this entry's information applies. The value of this object is the same as ebrNportDAAddress.")
ebrNportDADisp = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 2, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("filter", 1), ("alwaysFilter", 2), ("alwaysForward", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportDADisp.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportDADisp.setDescription("This object specifies how to interpret the ebrNportPortNum and ebrNportDAAllowedToGoTo objects. filter(1) : The filtering for this address is specified by the filter matrix. alwaysFilter(2) : Frames destined to address are filtered regardless of any other alwaysForward dispositions based on the frame's source address or protocol type. The filtering information is specified by the filter matrix. alwaysForward(3) : Frames destined to address are always forwarded to ebrNportPortNum if specified. The filter matrix is used to specify ports to which frames may be sent. In both cases, this disposition overrides filters based on the frame's source address or protocol type, unless either of those filters has an alwaysFilter disposition. ")
ebrNportDAStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 2, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("invalid", 2), ("permanent", 3), ("deleteOnReset", 4), ("deleteOnTimeout", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportDAStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportDAStatus.setDescription(" other(1) - This entry is currently in use, but the conditions under which it will remain so are different from each of the following values. Like other uses of 'other' in MIBs, this value may not be assigned to the object. invalid(2) - Writing this value to the object removes the entry permanent(3) - Writing this value to the object indicates that the entry is preserved across a bridge reset. deleteOnReset(4) - Writing this value removes the permanent entry characteristic. The entry is deleted upon the next bridge reset (SCP or GIGAswitch failure). Writing deleteOnReset is not supported. SNMP does not currently model viewing the non-volatile and volatile data structures independently, which can lead to unexpectedly having no filter if a reset occurs while temporarily trying a change to an existing filter. Writes of this value will result in a bad value return status. It is present for consistency with the Bridge MIB (RFC 1286), which describes address filters. deleteOnTimeout(5) - Writing this value removes the permanent entry characteristic. Since the timers used for aging information within the bridge are hidden from the user, the change may in fact take place immediately. Writing deleteOnTimeout is not supported. SNMP does not currently model viewing the non-volatile and volatile data structures independently, which can lead to unexpectedly having no filter if a reset occurs while temporarily trying a change to an existing filter. Writes of this value will result in a bad value return status. It is present for consistency with the Bridge MIB (RFC 1286), which describes address filters. ")
ebrNportDASvcTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 5, 3), )
if mibBuilder.loadTexts: ebrNportDASvcTable.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportDASvcTable.setDescription('A table that contains resource information about unicast and multicast destination addresses for N-port bridges.')
ebrNportDASvcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 5, 3, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "ebrNportSvcAddress"))
if mibBuilder.loadTexts: ebrNportDASvcEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportDASvcEntry.setDescription('Resource information about a specific MAC destination address for N-port bridges.')
ebrNportSvcAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 5, 3, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportSvcAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportSvcAddress.setDescription("The destination MAC Address in a frame to which this entry's resource information applies.")
ebrNportSvc = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 5, 3, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportSvc.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportSvc.setDescription("The service class used to allocate resources and implement service policy within the bridge. The service class associated with a frame is a function of either the frame's destination address or the frame's protocol. The default value for this field is 0. This value is used to assign the single path service class in the absence of a service class associated with the frame's protocol. There are 16 possible service classes, 0-15. The ebrNportSvc allows 32 values to be specified. The specification of a value greater than 15 is used to connote that the service class (ebrNportSvc-16), is to be associated with the frame and that this service class has precedence over a service class associated with a frame's protocol. Service classes 1-11 are reserved for internal or future use. ")
ebrNportSvcStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 5, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("invalid", 1), ("permanent", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportSvcStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportSvcStatus.setDescription(' This object specifies the permanence of the specified service class usage, and also provides a means to delete an entry. Writing invalid(1) to the object removes the entry. Writing permanent(2) value to the object indicates the entry is preserved across a bridge reset. ')
ebrNportPortNumTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 3), )
if mibBuilder.loadTexts: ebrNportPortNumTable.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportPortNumTable.setDescription('A table that contains static (i.e., configured by network management) information about the bridge port on which unicast or multicast addresses reside on N-port bridges.')
ebrNportPortNumEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 3, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "ebrNportPortNumAddress"))
if mibBuilder.loadTexts: ebrNportPortNumEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportPortNumEntry.setDescription('Information about a specific MAC address.')
ebrNportPortNumAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 3, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportPortNumAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportPortNumAddress.setDescription("The MAC Address to which this entry's information applies.")
ebrNportPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 3, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportPortNum.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportPortNum.setDescription('The Port Number to which this address will be translated (to which frames destined for the address will be forwarded). There are some filtering nuances for addresses with specified port numbers which are determined by the source address and destination address filter disposition characteristics. If zero, no port number is specified. This value is a giganet destination address instead of a bridge port number if it is greater than 127.')
ebrNportPortNumStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("invalid", 1), ("permanent", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportPortNumStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportPortNumStatus.setDescription(' This object specifies the permanence of the specified information, and also provides a means to delete an entry. Writing invalid(1) to the object removes the entry. Writing permanent(2) value to the object indicates the entry is preserved across a bridge reset. ')
ebrNportFppnPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 3, 1, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportFppnPortNum.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportFppnPortNum.setDescription('The Front Panel Port Number to which this address will be translated (to which frames destined for the address will be forwarded). There are some filtering nuances for addresses with specified front panel port numbers which are determined by the source address and destination address filter disposition characteristics. Managers may not specify both ebrNportPortNum and ebrNportFppnPortNum at the same time to set an entry in this table.')
ebrNportStaticSATable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 2, 7), )
if mibBuilder.loadTexts: ebrNportStaticSATable.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportStaticSATable.setDescription('A table that contains static source address filtering information about unicast and multicast addresses for N-port bridges. Static objects are those objects which have been specified by network management.')
ebrNportStaticSAEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 2, 7, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "ebrNportSAAddress"), (0, "DEC-ELAN-MIB", "ebrNportSAReceivePort"))
if mibBuilder.loadTexts: ebrNportStaticSAEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportStaticSAEntry.setDescription('Information about a specific MAC address for which the bridge has some static forwarding and/or filtering information.')
ebrNportSAAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 2, 7, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportSAAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportSAAddress.setDescription("The source MAC Address in a frame to which this entry's filtering information applies.")
ebrNportSAReceivePort = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 2, 7, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportSAReceivePort.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportSAReceivePort.setDescription('The port from which a frame must be received to use the corresponding ebrNportSAAllowedToGoTo field. A value of zero indicates that this entry applies on all ports of the bridge for which there is no other applicable entry.')
ebrNportSAAllowedToGoTo = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 2, 7, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportSAAllowedToGoTo.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportSAAllowedToGoTo.setDescription("The set of ports to which frames received from a specific port and sourced from the address specified by ebrNportSAAddress are allowed to be forwarded. Each octet of this object specifies a set of eight ports, with the first octet specifying ports 1 through 8, the second octet specifying port 9 through 16 etc. Within each octet, the most significant bit represents the lowest numbered port, and the least significant bit represents the highest numbered port. If a bit has a value of '1', then the corresponding port is included in the set of ports; the port is not included if its bit has a value of '0'. Filter matrix rows can be initialized or overwritten, but not deleted. Only whole matrices are deleted via the characteristics table. To produce the equivalent of row deletion, set the GoTo according to the following table: Disp GoTo filter/portMask 0xFFFFFFFFF0 alwaysFilter 0xFFFFFFFFF0 alwaysForward 0 ")
ebrNportStaticSAFilterCharacteristicsTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 2, 8), )
if mibBuilder.loadTexts: ebrNportStaticSAFilterCharacteristicsTable.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportStaticSAFilterCharacteristicsTable.setDescription('A table that contains information about how static source address filters (for unicast and multicast addresses) are used within N-port bridges.')
ebrNportStaticSAFilterCharacteristicsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 2, 8, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "ebrNportSourceAddress"))
if mibBuilder.loadTexts: ebrNportStaticSAFilterCharacteristicsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportStaticSAFilterCharacteristicsEntry.setDescription('Static source address filter usage for N-port bridges.')
ebrNportSourceAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 2, 8, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportSourceAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportSourceAddress.setDescription("The source MAC Address in a frame to which this entry's information applies. The value of this object is the same as ebrNportSAAddress.")
ebrNportSADisp = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 2, 8, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("portMask", 1), ("alwaysFilter", 2), ("alwaysForward", 3), ("lockdown", 4), ("lockdownportmask", 5), ("filter", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportSADisp.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportSADisp.setDescription("This object specifies how to interpret the ebrNportPortNum and and the ebrNportSAAllowedToGoTo objects. portMask(1) : The static filtering for this address is specified by the filter matrix. alwaysFilter(2) : Frames sourced from this address are filtered regardless of any other alwaysForward dispositions based on the frame's destination address or protocol type. The static filtering information is specified by the filter matrix. alwaysForward(3) : Frames sourced from this address are sent to ports specified in the filter matrix regardless of any DA or protocol filter with a disposition of filter. The alwaysForward disposition also overrides a forwarding disposition of filter in the default filter matrix object. Filters with a disposition of alwaysFilter are never superceded. lockdown (4) : Frames sourced from this address are ONLY forwarded if received on the same port as ebrNportPortNum. lockdownportmask (5) : Frames sourced from this address are ONLY forwarded if received on the same port as ebrNportPortNum AND if the frame is destined to a permitted port as specified by the filter matrix. filter(6) : The static filtering for this address is specified by the filter matrix. portMask(1) is the different name with the same effect. ")
ebrNportSAStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 2, 8, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("invalid", 2), ("permanent", 3), ("deleteOnReset", 4), ("deleteOnTimeout", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportSAStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportSAStatus.setDescription(" other(1) - This entry is currently in use, but the conditions under which it will remain so are different from each of the following values. Like other uses of 'other' in MIBs, this value may not be assigned to the object. invalid(2) - Writing this value to the object removes the entry permanent(3) - Writing this value to the object indicates that the entry is preserved across a bridge reset. deleteOnReset(4) - Writing this value removes the permanent entry characteristic. The entry is deleted upon the next bridge reset (SCP or GIGAswitch failure). Writing deleteOnReset is not supported. SNMP does not currently model viewing the non-volatile and volatile data structures independently, which can lead to unexpectedly having no filter if a reset occurs while temporarily trying a change to an existing filter. Writes of this value will result in a bad value return status. It is present for consistency with the Bridge MIB (RFC 1286), which describes address filters. deleteOnTimeout(5) - Writing this value removes the permanent entry characteristic. Since the timers used for aging information within the bridge are hidden from the user, the change may in fact take place immediately. Writing deleteOnTimeout is not supported. SNMP does not currently model viewing the non-volatile and volatile data structures independently, which can lead to unexpectedly having no filter if a reset occurs while temporarily trying a change to an existing filter. Writes of this value will result in a bad value return status. It is present for consistency with the Bridge MIB (RFC 1286), which describes address filters. ")
ebrNportSapProtoTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 2, 1), )
if mibBuilder.loadTexts: ebrNportSapProtoTable.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportSapProtoTable.setDescription('A table that contains filtering information about 802.2 SAPs in the DSAP field for N-port bridges.')
ebrNportSapProtoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 2, 1, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "ebrNportSapValue"), (0, "DEC-ELAN-MIB", "ebrNportSapReceivePort"))
if mibBuilder.loadTexts: ebrNportSapProtoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportSapProtoEntry.setDescription('A table that contains filtering information about 802.2 SAPs in the DSAP field for N-port bridges.')
ebrNportSapValue = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 2, 1, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportSapValue.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportSapValue.setDescription("The 802.2 DSAP in a frame to which this entry's filtering information applies.")
ebrNportSapReceivePort = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 2, 1, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportSapReceivePort.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportSapReceivePort.setDescription('The port from which a frame must be received to use the corresponding ebrNportSapAllowedToGoTo. A value of zero indicates that this entry applies on all ports of the bridge for which there is no other applicable entry.')
ebrNportSapAllowedToGoTo = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 2, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportSapAllowedToGoTo.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportSapAllowedToGoTo.setDescription("The set of ports to which frames received from a specific port and containing the DSAP in an 802 frame specified by ebrNportSapValue are allowed to be forwarded. Each octet of this object specifies a set of eight ports, with the first octet specifying ports 1 through 8, the second octet specifying port 9 through 16 etc. Within each octet, the most significant bit represents the lowest numbered port, and the least significant bit represents the highest numbered port. If a bit has a value of '1', then the corresponding port is included in the set of ports; the port is not included if its bit has a value of '0'. Filter matrix rows can be initialized or overwritten, but not deleted. Only whole matrices are deleted via the characteristics table. To produce the equivalent of row deletion, set the GoTo according to the following table: Disp GoTo filter/portMask 0xFFFFFFFFF0 alwaysFilter 0xFFFFFFFFF0 alwaysForward 0 ")
ebrNportSapSvcTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 5, 1), )
if mibBuilder.loadTexts: ebrNportSapSvcTable.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportSapSvcTable.setDescription('A table that contains resource information (e.g., queuing) about 802.2 SAPs in the DSAP field for N-port bridges.')
ebrNportSapSvcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 5, 1, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "ebrNportSapSvcSapValue"))
if mibBuilder.loadTexts: ebrNportSapSvcEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportSapSvcEntry.setDescription('Resource information about an 802.2 SAP in the DSAP field for N-port bridges.')
ebrNportSapSvcSapValue = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 5, 1, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportSapSvcSapValue.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportSapSvcSapValue.setDescription("The 802.2 DSAP in a frame to which this entry's resource information applies.")
ebrNportSapSvc = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 5, 1, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportSapSvc.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportSapSvc.setDescription("The service class used to allocate resources and implement service policy within the bridge. The service class associated with a frame is a function of either the frame's destination address or the frame's protocol. The default value for this field is 0. This value is used to assign the single path service class in the absence of an overriding service class associated with the frame's destination addr. There are 16 possible service classes, 0-15. Service classes 1-11 are reserved for internal or future use. ")
ebrNportSapSvcStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 5, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("invalid", 1), ("permanent", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportSapSvcStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportSapSvcStatus.setDescription(' This object specifies the permanence of the specified service class usage, and also provides a means to delete an entry. Writing invalid(1) to the object removes the entry. Writing permanent(2) value to the object indicates the entry is preserved across a bridge reset. ')
ebrNportSapSinglePath = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 5, 1, 1, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportSapSinglePath.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportSapSinglePath.setDescription(' The ebrNportSapSinglePath object is used to set the single path ports for a ebrNportSapSvcSapValue. The default is to not use the default (single path) service class. ebrNportSapSinglePath is expressed using a shorthand that specifies which physical ports are to be set to the default (single path) service class. An example of a specification would be : (1,6-9,21) where commas separate physical ports and hyphens are short-hand for specifying a range of numbers. This example would assign physical ports 1,6,7,8,9, and 21 to use the default (single path) service class, for the given ebrNportSapSvcSapValue. Physical port numbers are specified in decimal. A ebrNportSapSinglePath will read back in a form equivalent to the form written. It may not read back exactly as written. ')
ebrNportSapFilterCharacteristicsTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 2, 2), )
if mibBuilder.loadTexts: ebrNportSapFilterCharacteristicsTable.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportSapFilterCharacteristicsTable.setDescription('A table that contains information about how 802.2 DSAP filters are used within N-port bridges.')
ebrNportSapFilterCharacteristicsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 2, 2, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "ebrNportSapFilterCharacteristicsSapValue"))
if mibBuilder.loadTexts: ebrNportSapFilterCharacteristicsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportSapFilterCharacteristicsEntry.setDescription('802.2 DSAP filter usage for N-port bridges.')
ebrNportSapFilterCharacteristicsSapValue = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 2, 2, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportSapFilterCharacteristicsSapValue.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportSapFilterCharacteristicsSapValue.setDescription("The 802.2 DSAP in a frame to which this entry's information applies. The value of this object is the same as ebrNportSapValue.")
ebrNportSapDisp = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("filter", 1), ("alwaysFilter", 2), ("alwaysForward", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportSapDisp.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportSapDisp.setDescription("This object specifies how to interpret the ebrNportSapAllowedToGoTo values for the specified SAP. filter(1) : The filtering for this SAP is specified by the filter matrix. alwaysFilter(2) : Frames of this SAP (protocol) are filtered regardless of any other alwaysForward dispositions based on the frame's address. The filtering information is specified by the filter matrix. alwaysForward(3) : Frames for this SAP (protocol) are sent to ports specified in the filter matrix regardless of any address filter with a disposition of filter. The alwaysForward disposition also overrides a forwarding disposition of filter in the default filter matrix object. Filters with a disposition of alwaysFilter are never superceded. ")
ebrNportSapStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("invalid", 1), ("permanent", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportSapStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportSapStatus.setDescription(' This object specifies the permanence of the associated filter matrix, and also provides a means to delete a filter matrix. Writing invalid(1) to the object removes the filter. Writing permanent(2) value to the object indicates the filter is preserved across a bridge reset. ')
ebrNportSnapProtoTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 2, 3), )
if mibBuilder.loadTexts: ebrNportSnapProtoTable.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportSnapProtoTable.setDescription('A table that contains filtering information about 5-byte SNAP Protocol IDs (PIDs) for N-port bridges.')
ebrNportSnapProtoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 2, 3, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "ebrNportSnapValue"), (0, "DEC-ELAN-MIB", "ebrNportSnapReceivePort"))
if mibBuilder.loadTexts: ebrNportSnapProtoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportSnapProtoEntry.setDescription('A table that contains filtering information about 5-byte SNAP Protocol IDs (PIDs) for N-port bridges.')
ebrNportSnapValue = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 2, 3, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(5, 5)).setFixedLength(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportSnapValue.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportSnapValue.setDescription("The SNAP Protocol ID (PID) in an 802 frame to which this entry's filtering information applies.")
ebrNportSnapReceivePort = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 2, 3, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportSnapReceivePort.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportSnapReceivePort.setDescription('The port from which a frame must be received to use the corresponding ebrNportSnapAllowedToGoTo. A value of zero indicates that this entry applies on all ports of the bridge for which there is no other applicable entry.')
ebrNportSnapAllowedToGoTo = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 2, 3, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportSnapAllowedToGoTo.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportSnapAllowedToGoTo.setDescription("The set of ports to which frames received from a specific port and containing the SNAP PID in an 802 frame specified by ebrNportSnapValue are allowed to be forwarded. Each octet of this object specifies a set of eight ports, with the first octet specifying ports 1 through 8, the second octet specifying port 9 through 16 etc. Within each octet, the most significant bit represents the lowest numbered port, and the least significant bit represents the highest numbered port. If a bit has a value of '1', then the corresponding port is included in the set of ports; the port is not included if its bit has a value of '0'. Filter matrix rows can be initialized or overwritten, but not deleted. Only whole matrices are deleted via the characteristics table. To produce the equivalent of row deletion, set the GoTo according to the following table: Disp GoTo filter/portMask 0xFFFFFFFFF0 alwaysFilter 0xFFFFFFFFF0 alwaysForward 0 ")
ebrNportSnapSvcTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 5, 2), )
if mibBuilder.loadTexts: ebrNportSnapSvcTable.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportSnapSvcTable.setDescription('A table that contains resource information (e.g., queuing) about 5-byte SNAP Protocol IDs (PIDs) for N-port bridges.')
ebrNportSnapSvcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 5, 2, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "ebrNportSnapSvcSnapValue"))
if mibBuilder.loadTexts: ebrNportSnapSvcEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportSnapSvcEntry.setDescription('Resource information about a 5-byte SNAP Protocol ID (PID) for N-port bridges.')
ebrNportSnapSvcSnapValue = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 5, 2, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportSnapSvcSnapValue.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportSnapSvcSnapValue.setDescription("The SNAP Protocol ID (PID) in a frame to which this entry's resource information applies.")
ebrNportSnapSvc = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 5, 2, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportSnapSvc.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportSnapSvc.setDescription("The service class used to allocate resources and implement service policy within the bridge. The service class associated with a frame is a function of either the frame's destination address or the frame's protocol. The default value for this field is 0. This value is used to assign the single path service class in the absence of an overriding service class associated with the frame's destination addr. There are 16 possible service classes, 0-15. Service classes 1-11 are reserved for internal or future use. ")
ebrNportSnapSvcStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 5, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("invalid", 1), ("permanent", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportSnapSvcStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportSnapSvcStatus.setDescription(' This object specifies the permanence of the specified service class usage, and also provides a means to delete an entry. Writing invalid(1) to the object removes the entry. Writing permanent(2) value to the object indicates the entry is preserved across a bridge reset. ')
ebrNportSnapSinglePath = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 5, 2, 1, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportSnapSinglePath.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportSnapSinglePath.setDescription(' The ebrNportSnapSinglePath object is used to set the single path ports for a ebrNportSnapSvcSnapValue. The default is to not use the default (single path) service class. ebrNportSnapSinglePath is expressed using a shorthand that specifies which physical ports are to be set to the default (single path) service class. An example of a specification would be : (1,6-9,21) where commas separate physical ports and hyphens are short-hand for specifying a range of numbers. This example would assign physical ports 1,6,7,8,9, and 21 to use the default (single path) service class, for the given ebrNportSnapSvcSnapValue. Physical port numbers are specified in decimal. A ebrNportSnapSinglePath will read back in a form equivalent to the form written. It may not read back exactly as written. ')
ebrNportSnapFilterCharacteristicsTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 2, 4), )
if mibBuilder.loadTexts: ebrNportSnapFilterCharacteristicsTable.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportSnapFilterCharacteristicsTable.setDescription('A table that contains information about how SNAP Protocol ID (PID) filters are used within N-port bridges.')
ebrNportSnapFilterCharacteristicsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 2, 4, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "ebrNportSnapFilterCharacteristicsSnapValue"))
if mibBuilder.loadTexts: ebrNportSnapFilterCharacteristicsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportSnapFilterCharacteristicsEntry.setDescription('802.2 SNAP Protocol ID (PID) filter usage for N-port bridges.')
ebrNportSnapFilterCharacteristicsSnapValue = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 2, 4, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportSnapFilterCharacteristicsSnapValue.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportSnapFilterCharacteristicsSnapValue.setDescription("The SNAP Protocol ID (PID) in a frame to which this entry's information applies. The value of this object is the same as ebrNportSnapValue.")
ebrNportSnapDisp = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 2, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("filter", 1), ("alwaysFilter", 2), ("alwaysForward", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportSnapDisp.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportSnapDisp.setDescription("This object specifies how to interpret the ebrNportSnapAllowedToGoTo values for the specified SNAP PID. filter(1) : The filtering for this Protocol ID is specified by the filter matrix. alwaysFilter(2) : Frames of this Protocol ID are filtered regardless of any other alwaysForward dispositions based on the frame's address. The filtering information is specified by the filter matrix. alwaysForward(3) : Frames for this Protocol ID are sent to ports specified in the filter matrix regardless of any address filter with a disposition of filter. The alwaysForward disposition also overrides a forwarding disposition of filter in the default filter matrix object. Filters with a disposition of alwaysFilter are never superceded. ")
ebrNportSnapStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 2, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("invalid", 1), ("permanent", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportSnapStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportSnapStatus.setDescription(' This object specifies the permanence of the associated filter matrix, and also provides a means to delete a filter matrix. Writing invalid(1) to the object removes the filter. Writing permanent(2) value to the object indicates the filter is preserved across a bridge reset. ')
ebrNportSwTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 2, 9), )
if mibBuilder.loadTexts: ebrNportSwTable.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportSwTable.setDescription('This table describes the default filter matrix.')
ebrNportSwEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 2, 9, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "ebrNportSwReceivePort"))
if mibBuilder.loadTexts: ebrNportSwEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportSwEntry.setDescription('The entry describes a row of the default filter matrix.')
ebrNportSwReceivePort = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 2, 9, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportSwReceivePort.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportSwReceivePort.setDescription('The bridge port on which a frame must be received to use the corresponding ebrNportSwAllowedToGoTo field. A value of zero indicates that this entry applies on all ports of the bridge for which there is no other management-specified entry.')
ebrNportSwAllowedToGoTo = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 2, 9, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportSwAllowedToGoTo.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportSwAllowedToGoTo.setDescription("This object specifies the default forwarding disposition after all DA, SA, and protocol filters have been applied. For those cases where no filter applies to the frame, the forwarding disposition for the frames received on the ebrNportSwReceivePort interface and sent to one or all of the bridge's interfaces is determined by the ebrNportSwAllowedToGoTo object. Each octet of this object specifies a set of eight ports, with the first octet specifying ports 1 through 8, the second octet specifying port 9 through 16 etc. Within each octet, the most significant bit represents the lowest numbered port, and the least significant bit represents the highest numbered port. If a bit has a value of '1', then the corresponding port is included in the set of ports; the port is not included if its bit has a value of '0'. ")
ebrNportSwManualFilter = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 2, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ebrNportSwManualFilter.setStatus('mandatory')
if mibBuilder.loadTexts: ebrNportSwManualFilter.setDescription("A switch that controls address filtering. Specifying a one in a bit position says that the port is in manual mode. Each octet of this object specifies a set of eight ports, with the first octet specifying ports 1 through 8, the second octet specifying port 9 through 16 etc. Within each octet, the most significant bit represents the lowest numbered port, and the least significant bit represents the highest numbered port. If a bit has a value of '1', then the corresponding port is included in the set of ports; the port is not included if its bit has a value of '0'. Manual mode means that the bridge purges the learned entries for that port from its forwarding database, stops its learning process on that port, and forwards to that port only frames with destination and source addresses that have been specified via management.")
cutThrough = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 7))
cutThroughTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 7, 1), )
if mibBuilder.loadTexts: cutThroughTable.setStatus('mandatory')
if mibBuilder.loadTexts: cutThroughTable.setDescription('This table controls the enabling of some hardware performance enhancements that avoid store-and-forward delays during packet forwarding, whenever possible.')
cutThroughEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 7, 1, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "cutThroughBridgePort"))
if mibBuilder.loadTexts: cutThroughEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cutThroughEntry.setDescription('Information about the enabling of some hardware performance enhancements that avoid store-and-forward delays for a specific bridge port.')
cutThroughBridgePort = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 7, 1, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cutThroughBridgePort.setStatus('mandatory')
if mibBuilder.loadTexts: cutThroughBridgePort.setDescription('The dot1dBasePort bridge port number for this table entry.')
cutThroughInbound = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 7, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cutThroughInbound.setStatus('mandatory')
if mibBuilder.loadTexts: cutThroughInbound.setDescription('If true, some hardware performance enhancements are enabled to avoid store-and-forward delays when packets enter the GIGAswitch. If false, the whole packet is buffered on the line card at which the packet enters the GIGAswitch before it is sent to the line card at which the packet leaves the GIGAswitch. Cut-through is normally enabled.')
cutThroughOutbound = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 7, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cutThroughOutbound.setStatus('mandatory')
if mibBuilder.loadTexts: cutThroughOutbound.setDescription('If true, some hardware performance enhancements are enabled to avoid store-and-forward delays when packets leave the GIGAswitch. If false, the whole packet is buffered on the line card at which the packet leaves the GIGAswitch before it is sent out of the GIGAswitch. Cut-through is normally enabled.')
cutThroughFppnTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 7, 2), )
if mibBuilder.loadTexts: cutThroughFppnTable.setStatus('mandatory')
if mibBuilder.loadTexts: cutThroughFppnTable.setDescription('This table controls the enabling of some hardware performance enhancements that avoid store-and-forward delays during packet forwarding, whenever possible.')
cutThroughFppnEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 7, 2, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "cutThroughFppnPort"))
if mibBuilder.loadTexts: cutThroughFppnEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cutThroughFppnEntry.setDescription('Information about the enabling of some hardware performance enhancements that avoid store-and-forward delays for a specific front panel port.')
cutThroughFppnPort = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 7, 2, 1, 1), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cutThroughFppnPort.setStatus('mandatory')
if mibBuilder.loadTexts: cutThroughFppnPort.setDescription('The front panel port number for this table entry. Front panel port numbers are of the form (slot.connector), where slot is the slot number the module is plugged into, and connector is the connector number specified on the front of the card. ')
cutThroughFppnInbound = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 7, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cutThroughFppnInbound.setStatus('mandatory')
if mibBuilder.loadTexts: cutThroughFppnInbound.setDescription('If true, some hardware performance enhancements are enabled to avoid store-and-forward delays when packets enter the GIGAswitch. If false, the whole packet is buffered on the line card at which the packet enters the GIGAswitch before it is sent to the line card at which the packet leaves the GIGAswitch. Cut-through is normally enabled.')
cutThroughFppnOutbound = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 7, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cutThroughFppnOutbound.setStatus('mandatory')
if mibBuilder.loadTexts: cutThroughFppnOutbound.setDescription('If true, some hardware performance enhancements are enabled to avoid store-and-forward delays when packets leave the GIGAswitch. If false, the whole packet is buffered on the line card at which the packet leaves the GIGAswitch before it is sent out of the GIGAswitch. Cut-through is normally enabled.')
clockCard = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 1, 1))
psc = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 1, 2))
powerSupply = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 1, 3))
slot = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 1, 4))
fan = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 1, 5))
battery = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 1, 6))
fppn = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 1, 7))
lineCard = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 1, 8))
led = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 1, 9))
mgmtMemoryAvail = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mgmtMemoryAvail.setStatus('mandatory')
if mibBuilder.loadTexts: mgmtMemoryAvail.setDescription('The number of unused bytes of management memory available on the clock card. The management memory is used for storing management parameters.')
mgmtMemoryAction = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("rewrite", 2), ("rewriting", 3), ("clearAndLock", 4), ("locked", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mgmtMemoryAction.setStatus('mandatory')
if mibBuilder.loadTexts: mgmtMemoryAction.setDescription('This object, when read, returns a value of other(1) unless it is in the middle of rewriting the management memory. At such times, it will return rewriting(3). The state will revert to other(1) when the action is completed. Setting this variable to rewrite(2) will cause the SCP to attempt to rewrite the management Memory on the clock-card. Attempts to set this variable to all other values result in an error. Rewriting the management memory gets rid of duplicate entries, and thus may increase the available space. This action should be allowed to complete before intentionally removing power from the SCP or clock card. If the value is set to clearAndLock(4), management memory is completely erased. From this point on, SNMP operations that write management memory will fail, except for sets to the mgmtMemoryData object. In fact, the clearAndLock action must be set before management memory can be re-written using the mgmtMemoryData object. The GIGAswitch must be rebooted after the clearAndLock action (and after it has been re-written, if so desired) in order to allow future SNMP operations to be logged to management memory. ')
mgmtMemoryTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 1, 1, 3), )
if mibBuilder.loadTexts: mgmtMemoryTable.setStatus('mandatory')
if mibBuilder.loadTexts: mgmtMemoryTable.setDescription('The table for managing management memory.')
mgmtMemoryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 1, 1, 3, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "mgmtMemoryIndex"))
if mibBuilder.loadTexts: mgmtMemoryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mgmtMemoryEntry.setDescription('A record of management memory.')
mgmtMemoryIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 1, 1, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mgmtMemoryIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mgmtMemoryIndex.setDescription('Index of 80 byte binary records')
mgmtMemoryData = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 1, 1, 3, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mgmtMemoryData.setStatus('mandatory')
if mibBuilder.loadTexts: mgmtMemoryData.setDescription(' SNMP object mgmtMemoryData allows the user to read management memory and, with certain restrictions, to write it as well. In particular, this object allows the user to read a management memory image and, at a later time, restore it. Management memory is accessed in uninterpreted 80-byte binary records, numbered starting from 1. As a result, doing a GET of instance number N will return bytes 80*(N-1) through 80*N-1 from management memory. If an attempt is made to read beyond the end of written flash, an error is returned; if a read of a record spans the end of written flash, only the valid data is returned. To restore a management memory image, management memory must first be cleared and locked using the clearAndLock action on the mgmtMemoryAction object. Then management memory may be written sequentially, writing 80 bytes at a time until the last write, at which point less than 80 bytes may be written. During this operation, and until the GIGAswitch is rebooted, other SNMP sets requiring writes to management memory may not be done. It is therefore recommended that the GIGAswitch be booted as soon as possible after management memory has been restored. Any attempt to write a management memory record out of sequence, for example writing record 5 followed by record 4 or record 7, results in an error. ')
pscStatus = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 1, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notPresent", 1), ("okay", 2), ("fault", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pscStatus.setStatus('mandatory')
if mibBuilder.loadTexts: pscStatus.setDescription('The status of the Power System Controller (PSC).')
pscFwRev = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 1, 2, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pscFwRev.setStatus('mandatory')
if mibBuilder.loadTexts: pscFwRev.setDescription('The firmware revision of the Power System Controller (PSC).')
pscHwRev = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 1, 2, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pscHwRev.setStatus('mandatory')
if mibBuilder.loadTexts: pscHwRev.setDescription('The hardware revision of the Power System Controller (PSC).')
keyswitchPosition = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 1, 2, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("fault", 1), ("secure", 2), ("local", 3), ("remote", 4), ("worldAccess", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: keyswitchPosition.setStatus('mandatory')
if mibBuilder.loadTexts: keyswitchPosition.setDescription('Indicates the position of the keyswitch. The keyswitch position determines the type of access allowed to network management and to out-of-band management. For SNMP access, secure means no SNMP access. Local means read-only SNMP access. Other values allow read-write SNMP access. All access is still subject to the community string, IP address, and privileged port restrictions. ')
pscFwImageStatus = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 1, 2, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("okay", 1), ("downloadRequired", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pscFwImageStatus.setStatus('mandatory')
if mibBuilder.loadTexts: pscFwImageStatus.setDescription('The status of the PSC firmware image. If the value of this object is downloadRequired(2), the manager should download a new firmware image to the PSC. This can be done by using objects in the gigaUpgradeSoftware group.')
pscBackplaneStatus = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 1, 2, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("okay", 1), ("fault", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pscBackplaneStatus.setStatus('mandatory')
if mibBuilder.loadTexts: pscBackplaneStatus.setDescription('Status of the GIGAswitch backplane.')
cabinetTemperature = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 1, 2, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("normal", 1), ("high", 2), ("excessivelyHigh", 3), ("low", 4), ("excessivelyLow", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cabinetTemperature.setStatus('mandatory')
if mibBuilder.loadTexts: cabinetTemperature.setDescription('The cabinet temperature.')
temperatureWarning = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 1, 2, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("heedWarning", 1), ("ignoreWarning", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: temperatureWarning.setStatus('mandatory')
if mibBuilder.loadTexts: temperatureWarning.setDescription('The value of this variable determines how the SCP responds to a condition of too high or too low cabinet temperature, or both both fans inoperative. If the value is heedWarning(1) the system will be shut down when the temperature goes outside the designed limits or both fans are inoperative. If the value is ignoreWarning(2), the system will continue to operate when either of these conditions occur. Setting this variable to ignoreWarning(2) allows the manager to cause a system that is too hot or too cold to continue to run. This variable will also allow both fans to be inoperative and still allow the system to continue to run. Managers should note that doing so may be detrimental to the equipment. This object has a default value of heedWarning(1).')
rightPowerStatus = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 1, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notPresent", 1), ("okay", 2), ("fault", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rightPowerStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rightPowerStatus.setDescription('The status of the right power unit.')
rightPowerInputSource = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 1, 3, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("acLine", 1), ("dc48V", 2), ("none", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rightPowerInputSource.setStatus('mandatory')
if mibBuilder.loadTexts: rightPowerInputSource.setDescription('The input source of the right power unit. A value of ACline(1) is returned if the power supply is connected to an AC line. A value of DC48V(2) is returned if the power supply is connected to a 48 volt DC (telecommunications) line. A value of none(3) is returned if the power unit is not present or not powered on. See the batteryUsing object to see if the battery or this power source is being used. ')
rightPowerOutputPower = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 1, 3, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rightPowerOutputPower.setStatus('mandatory')
if mibBuilder.loadTexts: rightPowerOutputPower.setDescription('Output power of right power unit, in watts.')
leftPowerStatus = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 1, 3, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notPresent", 1), ("okay", 2), ("fault", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: leftPowerStatus.setStatus('mandatory')
if mibBuilder.loadTexts: leftPowerStatus.setDescription('The status of the left power unit.')
leftPowerInputSource = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 1, 3, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("acLine", 1), ("dc48V", 2), ("none", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: leftPowerInputSource.setStatus('mandatory')
if mibBuilder.loadTexts: leftPowerInputSource.setDescription('The input source of the left power unit. A value of ACline(1) is returned if the power supply is connected to an AC line. A value of DC48V(2) is returned if the power supply is connected to a 48 volt DC (telecommunications) line. A value of none(3) is returned if the power unit is not present or not powered on. See the batteryUsing object to see if the battery or this power source is being used. ')
leftPowerOutputPower = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 1, 3, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: leftPowerOutputPower.setStatus('mandatory')
if mibBuilder.loadTexts: leftPowerOutputPower.setDescription('Output power of left power unit, in watts.')
slotNumber = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 1, 4, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotNumber.setStatus('mandatory')
if mibBuilder.loadTexts: slotNumber.setDescription('The number of slots in the box.')
scpSlot = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 1, 4, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: scpSlot.setStatus('mandatory')
if mibBuilder.loadTexts: scpSlot.setDescription('Identifies the slot the Switch Control Processor (SCP) occupies. A value of 0 will be returned if an SCP has not been chosen.')
slotTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 1, 4, 3), )
if mibBuilder.loadTexts: slotTable.setStatus('mandatory')
if mibBuilder.loadTexts: slotTable.setDescription('Describes the current configuration of the box.')
slotEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 1, 4, 3, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "slotIndex"))
if mibBuilder.loadTexts: slotEntry.setStatus('mandatory')
if mibBuilder.loadTexts: slotEntry.setDescription('The description and status of the card plugged into the slot.')
slotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 1, 4, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: slotIndex.setDescription('The slot number. Varies from 1 to slotNumber.')
slotCardStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 1, 4, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("notPresent", 1), ("powerDown", 2), ("powerUp", 3), ("powerDownThenUp", 4), ("fault", 5), ("revisionMismatch", 6), ("selfTestInProgress", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: slotCardStatus.setStatus('mandatory')
if mibBuilder.loadTexts: slotCardStatus.setDescription("The status of the card. If the value is read as notPresent(1), then the entire entry should be considered invalid. Writing a value of powerDown(2) will cause the SCP to power down the card. Writing a value of powerUp(3) will cause the SCP to power up the card. Writing a value of powerDownThenUp(4) will cause the SCP to power cycle the line card. Attempts to set any other values will result in a badValue error. The clock and crossbar cards cannot be powered up or down through this object. They are fundamental to the GIGAswitch's operation. Unpopulated slots are notPresent(1), and can not be powered up or down. ")
slotCardType = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 1, 4, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("other", 1), ("fgl2", 2), ("cbs36", 3), ("switchEngine", 4), ("clockCard", 5), ("agl-2", 6), ("fgl4", 7), ("agl-2-plus", 8), ("xgl2", 9), ("xgl4", 10), ("gs2000", 11), ("gs2000-plus", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotCardType.setStatus('mandatory')
if mibBuilder.loadTexts: slotCardType.setDescription('The type of the Card.')
slotCardHwRev = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 1, 4, 3, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotCardHwRev.setStatus('mandatory')
if mibBuilder.loadTexts: slotCardHwRev.setDescription('The Hardware revision number of the card.')
slotCardFwRev = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 1, 4, 3, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotCardFwRev.setStatus('mandatory')
if mibBuilder.loadTexts: slotCardFwRev.setDescription('The Firmware revision number of the card.')
hostSlotTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 1, 4, 4), )
if mibBuilder.loadTexts: hostSlotTable.setStatus('mandatory')
if mibBuilder.loadTexts: hostSlotTable.setDescription('Describes the current IP address and community string of any modules which are hosted in the switch (eg GS2000).')
hostSlotEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 1, 4, 4, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "hostSlotIndex"))
if mibBuilder.loadTexts: hostSlotEntry.setStatus('mandatory')
if mibBuilder.loadTexts: hostSlotEntry.setDescription('The IP and community of the module hosted in the slot corresponding to the index.')
hostSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 1, 4, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: hostSlotIndex.setDescription('The slot number. Varies from 1 to slotNumber.')
hostIP = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 1, 4, 4, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hostIP.setStatus('mandatory')
if mibBuilder.loadTexts: hostIP.setDescription('The IP address of the hosted module.')
fanSpeed = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 1, 5, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("maximum", 1), ("normal", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fanSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: fanSpeed.setDescription(' The speed of the fans. Set this variable to maximum(1) for maximum cooling where noise does not matter. Set this variable to normal(2) to cause fan speeds to be under temperature control.')
rightFanStatus = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 1, 5, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notPresent", 1), ("okay", 2), ("fault", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rightFanStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rightFanStatus.setDescription('The status of the right fan tray.')
leftFanStatus = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 1, 5, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notPresent", 1), ("okay", 2), ("fault", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: leftFanStatus.setStatus('mandatory')
if mibBuilder.loadTexts: leftFanStatus.setDescription('The status of the left fan tray.')
batteryStatus = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 1, 6, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notPresent", 1), ("okay", 2), ("fault", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: batteryStatus.setStatus('mandatory')
if mibBuilder.loadTexts: batteryStatus.setDescription('The status of the backup battery.')
batteryUsing = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 1, 6, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("batteryPower", 1), ("externalPower", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: batteryUsing.setStatus('mandatory')
if mibBuilder.loadTexts: batteryUsing.setDescription('The source of power being used for the box. The value batteryPower(2) indicates that the backup battery unit is being used to power the GIGAswitch. The external power line can be either AC or a 48 volt DC telecommunications power line. ')
batteryCharge = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 1, 6, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("fullyCharged", 1), ("okay", 2), ("low", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: batteryCharge.setStatus('mandatory')
if mibBuilder.loadTexts: batteryCharge.setDescription('The charge-level of the backup battery. Meaningful only if the battery is present.')
batteryTest = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 1, 6, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("pass", 1), ("fail", 2), ("test", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: batteryTest.setStatus('mandatory')
if mibBuilder.loadTexts: batteryTest.setDescription('Only the value test(3) can be written. Writes of other values are erroneous. This shows the result of the last battery test performed. Testing the battery is risky, since the GIGAswitch is temporarily switched to run off the battery, and if the battery-backup system is not working properly, the GIGAswitch fails and restarts. Meaningful only if the battery is present. ')
fppnTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 1, 7, 1), )
if mibBuilder.loadTexts: fppnTable.setStatus('mandatory')
if mibBuilder.loadTexts: fppnTable.setDescription('A list of front panel port number to MIB-II interface number mappings.')
fppnEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 1, 7, 1, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "fppnSlotNumber"), (0, "DEC-ELAN-MIB", "fppnPortOfThatSlot"))
if mibBuilder.loadTexts: fppnEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fppnEntry.setDescription('Assigns the MIB-II interface ifIndex for a physical datalink (cable) connection to the box.')
fppnSlotNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 1, 7, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fppnSlotNumber.setStatus('mandatory')
if mibBuilder.loadTexts: fppnSlotNumber.setDescription('The 1-based slot number of the module.')
fppnPortOfThatSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 1, 7, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fppnPortOfThatSlot.setStatus('mandatory')
if mibBuilder.loadTexts: fppnPortOfThatSlot.setDescription('The 1-based media connection to the module.')
fppnIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 1, 7, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fppnIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fppnIfIndex.setDescription('The assigned MIB-II ifIndex.')
fppnBridgePortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 1, 7, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fppnBridgePortNumber.setStatus('mandatory')
if mibBuilder.loadTexts: fppnBridgePortNumber.setDescription('The assigned Bridge MIB dot1dBasePort.')
mPortTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 1, 8, 1), )
if mibBuilder.loadTexts: mPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: mPortTable.setDescription('A list of mPort entries.')
mPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 1, 8, 1, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "mPortSMTIndex"), (0, "DEC-ELAN-MIB", "mPortMACIndex"))
if mibBuilder.loadTexts: mPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mPortEntry.setDescription('A collection of objects containing information for a given mPort MAC entity')
mPortSMTIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 1, 8, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mPortSMTIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mPortSMTIndex.setDescription('The value of the SMT index associated with this mPort MAC.')
mPortMACIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 1, 8, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mPortMACIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mPortMACIndex.setDescription('The value of the MAC index associated with this mPort MAC.')
mPortEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 1, 8, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mPortEnable.setStatus('mandatory')
if mibBuilder.loadTexts: mPortEnable.setDescription('When true, this link will be enabled to operate in concentrator mode, i.e. mport.')
ledTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 1, 9, 1), )
if mibBuilder.loadTexts: ledTable.setStatus('mandatory')
if mibBuilder.loadTexts: ledTable.setDescription('A list of LED entries, one for each module.')
ledTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 1, 9, 1, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "ledTableIndex"))
if mibBuilder.loadTexts: ledTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ledTableEntry.setDescription('Each entry describes the state of one module.')
ledTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 1, 9, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ledTableIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ledTableIndex.setDescription('The module index into the table. ')
ledCount = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 1, 9, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ledCount.setStatus('mandatory')
if mibBuilder.loadTexts: ledCount.setDescription('The number of LEDs on this module.')
ledSlotTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 1, 9, 2), )
if mibBuilder.loadTexts: ledSlotTable.setStatus('mandatory')
if mibBuilder.loadTexts: ledSlotTable.setDescription('A list of LED entries, one for each module LED.')
ledEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 1, 9, 2, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "ledSlotIndex"), (0, "DEC-ELAN-MIB", "ledLedIndex"))
if mibBuilder.loadTexts: ledEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ledEntry.setDescription('Each entry describes the state of one module LED.')
ledSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 1, 9, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ledSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ledSlotIndex.setDescription('The slot index into the table. ')
ledLedIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 1, 9, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ledLedIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ledLedIndex.setDescription('The led index within the slot given by slotIndex.')
ledDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 1, 9, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ledDescr.setStatus('mandatory')
if mibBuilder.loadTexts: ledDescr.setDescription('A textual description of the information which the LED is meant to convey. i.e.: +5 Volt Power, DC Okay ATM port activity. Diagnostic status.')
ledProgram = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 1, 9, 2, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 48))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ledProgram.setStatus('mandatory')
if mibBuilder.loadTexts: ledProgram.setDescription("The ledProgram string is a sequence of instructions for the LED state. The LED constantly repeats the program. Each LED state is represented by a two octet sequence where the value of the first octet of the pair indicates the color of the LED, and the value of the second octet of the pair indicates the duration in which that color will be present. +----------+----------+ --/ /-- +----------+----------+ | Color | Duration | | Color | Duration | +----------+----------+ --/ /-- +----------+----------+ The 'color' octet may have one of the following values: 0 - off 1 - other 2 - red 3 - yellow 4 - green 5 - blue 6 - red-blinking 7 - yellow-blinking 8 - blue-blinking 9 - green-blinking The value 'off' indicates that the LED is off. The value 'other' indicates a color not covered by any others in the list. The value of the second octet in each pair indicates the duration in which that color will be present. A value of zero indicates that the LED is off. A value of 0xff indicates that the LED is always on. Values in between 0 and 0xff indicate the duration in 10 ms ticks. A zero length string may be returned if the LED is 'not present'. This indicates that the LED is currently not visible. Activity LEDs are a special case. Activity LEDs are defined as LEDs which blink whenever data is received on the line. They are typically on solid under heavy activity. Since these LEDs can change rapidly, the following rules apply: o The initial state of activity LEDs is off. o If the line shows activity any time in a 10 second period, then the LED is shown as on. o If the line shown inactivity any time in a 10 second period, then the LED is shown as off. See the 'pcomLedProgram' object in the DECHUB900-COMMON MIB for examples.")
flooding = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 6))
floodUnknownUnicastRate = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 6, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: floodUnknownUnicastRate.setStatus('mandatory')
if mibBuilder.loadTexts: floodUnknownUnicastRate.setDescription('The maximum bytes-per-second bandwidth of packets multicast because the destination address was not yet learned by the bridge. The resolution of this value is 100 bytes-per-second. The 2 LS digits are rounded down to zero, i.e. 1-99 => 0.')
floodMulticastRate = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 6, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: floodMulticastRate.setStatus('mandatory')
if mibBuilder.loadTexts: floodMulticastRate.setDescription('The maximum bytes-per-second bandwidth of packets multicast because the destination address is a multicast address.The resolution of this value is 100 bytes-per-second. The 2 LS digits are rounded down to zero, i.e. 1-99 => 0.')
floodTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 6, 3), )
if mibBuilder.loadTexts: floodTable.setStatus('mandatory')
if mibBuilder.loadTexts: floodTable.setDescription('Detailed view of the bridge flooding process.')
floodEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 6, 3, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "floodQuotaQualifier"), (0, "DEC-ELAN-MIB", "floodQuotaClass"))
if mibBuilder.loadTexts: floodEntry.setStatus('mandatory')
if mibBuilder.loadTexts: floodEntry.setDescription('Flooding state for a packet class and source.')
floodQuotaQualifier = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 6, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: floodQuotaQualifier.setStatus('mandatory')
if mibBuilder.loadTexts: floodQuotaQualifier.setDescription('The quota qualifier describes an incoming or outgoing port. It is a linear index to the port starting from 1. If n is the quota qualifier for the first port of a two port line card, the quota qualifier for the second port is n + 1. The clock card and the crossbar have zero port, so the index must be skipped over those slots. This numbering scheme may be changed as we have four port line cards.')
floodQuotaClass = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 6, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: floodQuotaClass.setStatus('mandatory')
if mibBuilder.loadTexts: floodQuotaClass.setDescription('The quota class describes the type of packet. Four packet types are classified as follows: 1 - Unknown Destination Packets, 2 - Multicast Packets, 3 - IS-IS Packets, 4 - Bursty Control Packets')
floodBytesSent = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 6, 3, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: floodBytesSent.setStatus('mandatory')
if mibBuilder.loadTexts: floodBytesSent.setDescription(' This object is the count of bytes in flooded packets. It does not include filtered packets or packets discarded due to buffer limitations. Each packet is counted once, regardless of the number of outbound links to which it was flooded. ')
floodPacketsSent = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 6, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: floodPacketsSent.setStatus('mandatory')
if mibBuilder.loadTexts: floodPacketsSent.setDescription('This object is the count of flooded packets. It does not include filtered packets or packets discarded due to buffer limitations. Each packet is counted once, regardless of the number of outbound links to which it was flooded. ')
floodGeezers = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 6, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: floodGeezers.setStatus('mandatory')
if mibBuilder.loadTexts: floodGeezers.setDescription(' This object is the count of packets that could not be flooded because they had remained in the SCP or in the inbound linecard too long. ')
floodLosers = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 6, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: floodLosers.setStatus('mandatory')
if mibBuilder.loadTexts: floodLosers.setDescription(' This object is the count of packets discarded by the SCP flooding software (at the interrupt level) due to insufficient buffering. ')
floodHogs = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 6, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: floodHogs.setStatus('mandatory')
if mibBuilder.loadTexts: floodHogs.setDescription(' This object is the count of packets for which buffer quota conversion to flooding software optimistic quotas failed. This includes packets that were discarded as well as packets that were successfully flooded. ')
floodSinglePathDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 6, 3, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: floodSinglePathDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: floodSinglePathDiscards.setDescription(' This object is the count of packets discarded to prevent packet misordering. Certain protocol types are considered single-path and may not be delivered out of order. If the Destination Address for a packet having a single-path protocol type is learned while the packet is buffered by the flooding software, the packet must be discarded (since line cards would have been directly forwarding packets using the learned address while packets received earlier were buffered on the SCP). ')
floodPacketsFiltered = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 6, 3, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: floodPacketsFiltered.setStatus('mandatory')
if mibBuilder.loadTexts: floodPacketsFiltered.setDescription(' This object is the count of packets discarded by the flooding software because user-configured filtering resulted in no allowed outbound transmit ports. ')
floodPacketsPurged = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 6, 3, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: floodPacketsPurged.setStatus('mandatory')
if mibBuilder.loadTexts: floodPacketsPurged.setDescription(' This object is the count of packets discarded due to the incoming link leaving FORWARDING state while they were buffered by flooding software. ')
floodBytesPurged = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 6, 3, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: floodBytesPurged.setStatus('mandatory')
if mibBuilder.loadTexts: floodBytesPurged.setDescription(' This object is the byte count in packets discarded due to the incoming link leaving FORWARDING state while they were buffered by flooding software. ')
floodLocalCopyPacketsDelivered = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 6, 3, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: floodLocalCopyPacketsDelivered.setStatus('mandatory')
if mibBuilder.loadTexts: floodLocalCopyPacketsDelivered.setDescription(' This object is the count of multicast packets addressed to software modules in the SCP that have been successfully delivered to those modules. ')
floodLocalCopyPacketsDiscarded = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 6, 3, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: floodLocalCopyPacketsDiscarded.setStatus('mandatory')
if mibBuilder.loadTexts: floodLocalCopyPacketsDiscarded.setDescription(' This object is the count of multicast packets addressed to software modules in the SCP that, because of buffer limitations, could not be delivered to those modules. ')
commitFails = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 6, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: commitFails.setStatus('mandatory')
if mibBuilder.loadTexts: commitFails.setDescription('Exercise abort undo code in SNMP commit processing')
doTransfer = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 3, 1))
useTransfer = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 3, 2))
tftpDestination = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 3, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tftpDestination.setStatus('mandatory')
if mibBuilder.loadTexts: tftpDestination.setDescription("This object is the IP address of the host storing the file containing the software image. The object may not be set until the last requested transfer succeeds or fails. So, before setting this object the user should verify that transferStatus does not have the value 'requested' or 'inProgress'.")
mopDestination = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 3, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mopDestination.setStatus('mandatory')
if mibBuilder.loadTexts: mopDestination.setDescription("This object is the 802 48-bit address of the host storing the file containing the software image. The object may not be set until the last requested transfer succeeds or fails. So, before setting this object, the user should verify that transferStatus does not have the value 'requested' or 'inProgress'. Both version 3 and version 4 of MOP are supported. If a unicast address is specified, the transfer will be from that host. If the MOP multicast address ab-00-00-01-00-00 is used, the transfer will be from the first MOP server to respond, as usual.")
transferFileName = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 3, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: transferFileName.setStatus('mandatory')
if mibBuilder.loadTexts: transferFileName.setDescription("This object is the name of the file containing the software image. The object may not be set until the last requested transfer succeeds or fails. Before setting this object, the user should verify that transferStatus does not have the value 'requested' or 'inProgress'. Further, this object may not be set until the last requested copy succeeds or fails. Before setting this object, the user should verify that copyStatus does not have the value 'requested' or 'inProgress'.")
transferAction = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("doMOP", 2), ("doTFTP", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: transferAction.setStatus('mandatory')
if mibBuilder.loadTexts: transferAction.setDescription("To initiate a transfer of a file from a server to the SCP, set this object. If transferFileName is non-empty, and mopDestination is non-zero, setting this object to doMOP(2) will cause a MOP 'load' to be attempted. If transferFileName is non-empty, and tftpDestination is non-zero, setting this object to doTFTP(3) will cause a TFTP 'Get' to be attempted. This object may not be set until the last requested transfer succeeds or fails, and the last requested copy succeeds or fails. So, before setting this object the user should verify that transferStatus does not have the values 'requested' or 'inProgress', and that copyStatus does not have the values 'requested' or 'inProgress'. ")
transferStatus = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("none", 1), ("requested", 2), ("inProgress", 3), ("failed", 4), ("success", 5), ("failedDueToCheckSum", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: transferStatus.setStatus('mandatory')
if mibBuilder.loadTexts: transferStatus.setDescription('This variable can be polled to determine when the transfer has completed. Polling for completion allows other SNMP requests to be processed while the transfer is in progress (the SNMP is single-threaded).')
transferSize = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 3, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: transferSize.setStatus('mandatory')
if mibBuilder.loadTexts: transferSize.setDescription('Size in bytes of the transfered file. This object can be polled along with the transferStatus object to monitor the progress of the transfer.')
copyToSlot = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 3, 2, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: copyToSlot.setStatus('mandatory')
if mibBuilder.loadTexts: copyToSlot.setDescription('The slot number of the card which is to be upgraded. The object may not be set until the last requested copy succeeds or fails.')
copyType = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 3, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("none", 1), ("scp", 2), ("fgl2", 3), ("clock", 4), ("powerSystemController", 5), ("agl-2", 6), ("fgl4", 7), ("agl-2-plus", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: copyType.setStatus('mandatory')
if mibBuilder.loadTexts: copyType.setDescription('The type of the image. The object is set after a transfer succeeds or fails.')
copyAction = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 3, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("none", 1), ("doUpgrade", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: copyAction.setStatus('mandatory')
if mibBuilder.loadTexts: copyAction.setDescription("To initiate a software upgrade of a card, set this object. If copyToSlot is non-zero, and copyType has a value other than 'none', and transferStatus has the value 'success', a software upgrade of the card is attempted. The handler double-checks that the slot requires software of the expected type, and provides demultiplexing when multiple images may be sent to the same slot. The power system controller is updated by sending its image to the clock card slot. The object may not be set until the last requested transfer succeeds, and the last requested copy succeeds or fails. Reading this object always returns the value none(1).")
copyStatus = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 3, 2, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("none", 1), ("requested", 2), ("inProgress", 3), ("failed", 4), ("success", 5), ("failedDueToCardType", 6), ("failedDueToHwRev", 7), ("failedDueToFwRev", 8), ("failedDueToBadImage", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: copyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: copyStatus.setDescription('This variable can be polled to determine when the card upgrade has completed. Polling for completion allows other SNMP requests to be processed while the copy is in progress (the SNMP is single-threaded).')
deleteTransfer = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 3, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("exists", 1), ("notExist", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: deleteTransfer.setStatus('mandatory')
if mibBuilder.loadTexts: deleteTransfer.setDescription('When read, this object indicates whether the result of a file transfer is still present. The value exists indicates that the transferred file is present; the value notExist indicates that no file has been transferred or that it has been deleted. Writing the value exists is an error. Writing the value notExist deletes the transferred file. The object may not be set until the last requested transfer succeeds or fails. It may not be set while a copy is in progress, either.')
arpTimingMechanism = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 4, 1))
arpTimeoutInSeconds = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 4, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: arpTimeoutInSeconds.setStatus('mandatory')
if mibBuilder.loadTexts: arpTimeoutInSeconds.setDescription('The maximum amount of time an IP to LAN address translation will be used if it cannot be re-verified.')
arpPeriodBetweenRequests = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 4, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: arpPeriodBetweenRequests.setStatus('mandatory')
if mibBuilder.loadTexts: arpPeriodBetweenRequests.setDescription('The time, in seconds, between ARP requests that are used to verify or to discover an IP to LAN address translation.')
arpRequestRetries = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 4, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: arpRequestRetries.setStatus('mandatory')
if mibBuilder.loadTexts: arpRequestRetries.setDescription('The number of times ARP requests are used to verify or to discover an IP to LAN address translation.')
arpControlParams = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 4, 3))
arpAgent = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 4, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: arpAgent.setStatus('mandatory')
if mibBuilder.loadTexts: arpAgent.setDescription(' When true, the GIGAswitch will service broadcast ARP requests from its ARP cache. When false, Broadcast ARP frames are flooded. ')
arpStatisticalCounters = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 4, 4))
arpStatisticalTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 4, 4, 1), )
if mibBuilder.loadTexts: arpStatisticalTable.setStatus('mandatory')
if mibBuilder.loadTexts: arpStatisticalTable.setDescription(' This table stores ARP counters. ')
arpStatisticalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 4, 4, 1, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "arpStatisticalIfIndex"))
if mibBuilder.loadTexts: arpStatisticalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: arpStatisticalEntry.setDescription(' Information about the ARP statistical table is stored. ')
arpStatisticalIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 4, 4, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: arpStatisticalIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: arpStatisticalIfIndex.setDescription(' Identifies the Interface. The value of this object is the same as the ifIndex, defined in MIB-II, for this interface. ')
arpUnicastReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 4, 4, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: arpUnicastReceived.setStatus('mandatory')
if mibBuilder.loadTexts: arpUnicastReceived.setDescription(' Unicast ARP requests received on this port. ')
arpBroadcastReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 4, 4, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: arpBroadcastReceived.setStatus('mandatory')
if mibBuilder.loadTexts: arpBroadcastReceived.setDescription(' Broadcast ARP requests received on this port. ')
arpRepliesTransmitted = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 4, 4, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: arpRepliesTransmitted.setStatus('mandatory')
if mibBuilder.loadTexts: arpRepliesTransmitted.setDescription(' ARP replies transmitted on this port. ')
arpFramesFlooded = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 4, 4, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: arpFramesFlooded.setStatus('mandatory')
if mibBuilder.loadTexts: arpFramesFlooded.setDescription(' ARP frames received on this port that required flooding while acting as an ARP agent. ')
arpFramesDiscarded = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 4, 4, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: arpFramesDiscarded.setStatus('mandatory')
if mibBuilder.loadTexts: arpFramesDiscarded.setDescription(' ARP frames received on this port that were discarded due to protocol errors. ')
snmpParameters = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 4, 2))
snmpDuplicateDiscardInterval = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 4, 2, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpDuplicateDiscardInterval.setStatus('mandatory')
if mibBuilder.loadTexts: snmpDuplicateDiscardInterval.setDescription(' If duplicated snmp messages arrive within this interval, all but the first one will be discarded. The unit is a hundredth of second. ')
gigaStp = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 8))
gigaStpPortTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 8, 1), )
if mibBuilder.loadTexts: gigaStpPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: gigaStpPortTable.setDescription(' A list of gigaStp entries ')
gigaStpPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 8, 1, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "gigaStpPortIfIndex"))
if mibBuilder.loadTexts: gigaStpPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gigaStpPortEntry.setDescription(' A collection of objects containing information for a given StpPort ')
gigaStpPortIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 8, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gigaStpPortIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gigaStpPortIfIndex.setDescription('The value of the interface associated with this spanning tree port.')
gigaStpPortSpanningTreeEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 8, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("true", 1), ("false", 2), ("trueNoDelay", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gigaStpPortSpanningTreeEnable.setStatus('mandatory')
if mibBuilder.loadTexts: gigaStpPortSpanningTreeEnable.setDescription('When true, this interface will be enabled to operate as part of the spanning tree. When trueNoDelay, this interface will be enabled to operate as part of the spanning tree but will have a pre-forwarding delay of zero.')
gigaStpDemandLearningEnable = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 8, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gigaStpDemandLearningEnable.setStatus('mandatory')
if mibBuilder.loadTexts: gigaStpDemandLearningEnable.setDescription(' If true, then when a source address is learned, the address is only written to the Translation Table in the bridge port on which it was learned. If the address later occurs as a destination address in a packet received on some other bridge port, the packet is flooded if possible and the address is written to the Translation table of the other bridge port at that time. Thus, a bridge port that receives no packets for a certain address will not have that address in its database unless the address had been learned on that bridge port. If false, then when a source address is learned, the address is promptly written to the Translation Table of every bridge port in the GIGASwitch. This variable should be set to yes if the total number of learned addresses is expected to be greater than the number supported by the linecards and if there is sufficient locality of traffic that the behavior described above will not result in more than that number of addresses being learned on any one bridge port. It should be set to no if the total number of learned addresses is not greater than the number supported by the linecards and if it is desired to avoid flooding of packets to already-learned addresses. ')
translationTableParams = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 9))
ttSize = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 9, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ttSize.setStatus('mandatory')
if mibBuilder.loadTexts: ttSize.setDescription(' The number of entries in the tables used to store learned network addresses. ')
xacInDiscardCounters = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 10))
xacInDiscardUnknownDAUCast = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 10, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xacInDiscardUnknownDAUCast.setStatus('mandatory')
if mibBuilder.loadTexts: xacInDiscardUnknownDAUCast.setDescription('This object shows the number of unknown DA unicast packets which are transmitted from linecards to the SCP for multicasting, but discarded due to the lack of buffer space in the XAC chip. Packets counted here are not included in other, per-port, discard counters because this counter is shared by all the incoming ports. ')
xacInDiscardMulticast = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 10, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xacInDiscardMulticast.setStatus('mandatory')
if mibBuilder.loadTexts: xacInDiscardMulticast.setDescription('This object shows the number of multicast packets which are transmitted from linecards to the SCP for processing, but discarded due to the lack of buffer space in the XAC chip. Packets counted here are not included in other, per-port, discard counters because this counter is shared by all the incoming ports. ')
xacInDiscardIPForwarding = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 10, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xacInDiscardIPForwarding.setStatus('mandatory')
if mibBuilder.loadTexts: xacInDiscardIPForwarding.setDescription('This object shows the number of IP packets which are transmitted from linecards to the SCP for forwarding, but discarded due to the lack of buffer space in the XAC chip. Packets counted here are not included in other, per-port, discard counters because this counter is shared by all the incoming ports. ')
communityString = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 11))
communityStringDelimiter = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 2, 11, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: communityStringDelimiter.setStatus('mandatory')
if mibBuilder.loadTexts: communityStringDelimiter.setDescription(" The communityStringDelimiter object is used to delimit community string suffixes. Community string suffixes give the SNMP agent additional information to process certain objects. If the objects do not need the suffix then the suffix is ignored. If the object uses the suffix and none is supplied, then a default is used. There are two valid suffixes available for the Gigaswitch/Fddi, LDx and LBDx. LDx references learning domains, LD1-LD8. LBDx references logical bridge domains, LBD1- LBD8. Both uppercase and lowercase are valid. The default communityStringDelimiter is the ':'. ex. public:LD3, use learning domain 4 if required public:LBD4, use logical bridge domain 4 if required public, use default if required. The set of Valid communityStringDelimiter is the set of all printable characters minus all the alphas and all the digits. If a LDx suffix is used where an LBDx is required, then the LBD that contains the LDx will be used. If a LBDx suffix is used where an LDx is required, then the lowest numbered LD in that LBD is used. In both cases if there are no members in the LD/LBD then the default is used. The default LD is LD1 and the default LBD is LBD1. ")
ipSwitching = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 4, 5))
ipSwitchEnable = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 4, 5, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipSwitchEnable.setStatus('mandatory')
if mibBuilder.loadTexts: ipSwitchEnable.setDescription(' If true then switched IP filtering is enabled. If false switched IP filtering is disabled. ')
ipSwitchPortsTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 4, 5, 2), )
if mibBuilder.loadTexts: ipSwitchPortsTable.setStatus('mandatory')
if mibBuilder.loadTexts: ipSwitchPortsTable.setDescription(' This table allows the user to assign an address range to logical bridge ports so that all traffic destined to addresses within that range will go out those ports. ')
ipSwitchPortsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 4, 5, 2, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "ipRangeStartAddr"), (0, "DEC-ELAN-MIB", "ipRangeEndAddr"))
if mibBuilder.loadTexts: ipSwitchPortsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ipSwitchPortsEntry.setDescription(' An entry that stores information about a switched IP filtering range. ')
ipRangeStartAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 4, 5, 2, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipRangeStartAddr.setStatus('mandatory')
if mibBuilder.loadTexts: ipRangeStartAddr.setDescription(' An index for the ipSwitchPortsTable. This is the start address of the range of addresses for which the the ipStaticPorts and ipDynamicPorts are valid. ')
ipRangeEndAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 4, 5, 2, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipRangeEndAddr.setStatus('mandatory')
if mibBuilder.loadTexts: ipRangeEndAddr.setDescription(' An index for the ipSwitchPortsTable. This is the end address of the range of addresses for which the the ipStaticPorts and ipDynamicPorts are valid. ')
ipIPAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 4, 5, 2, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipIPAddr.setStatus('mandatory')
if mibBuilder.loadTexts: ipIPAddr.setDescription(' The IP address associated with the range, ipRangeStartAddr and ipRangeEndAddr. ')
ipStaticPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 4, 5, 2, 1, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipStaticPorts.setStatus('mandatory')
if mibBuilder.loadTexts: ipStaticPorts.setDescription(' ipStaticPorts is the set of logical ports that packets will exit the Gigaswitch when the destination address is within the range specified by ipRangeStartAddr and ipRangeEndAddr. ipStaticPorts is expressed using a shorthand that specifies which logical ports are assigned to the address range. An example of a specification would be (1,6-9,21), where commas separate logical ports and hyphens are short-hand for specifying a range of numbers. This example would assign logical ports 1,6,7,8,9, and 21 to the specified address/mask. Logical port numbers are specified in decimal. The ipStaticPorts will read back in a form equivalent to the form written. It may not read back exactly as written. ')
ipDynamicPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 4, 5, 2, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipDynamicPorts.setStatus('mandatory')
if mibBuilder.loadTexts: ipDynamicPorts.setDescription(' ipDynamicPorts is the set of logical ports, learned dynamically, that packets will exit the Gigaswitch when the destination address is within the range specified by ipRangeStartAddr and ipRangeEndAddr. ')
ipPrimaryPorts = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 4, 5, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipPrimaryPorts.setStatus('mandatory')
if mibBuilder.loadTexts: ipPrimaryPorts.setDescription(' ipPrimaryPorts is the set of all logical ports, set by management, that packets will exit the Gigaswitch regardless of the range to which they are addressed to. The ipPrimaryPorts is expressed using a shorthand that specifies the logical ports. An example of a specification would be (1,6-9,21) where commas separate logical ports and hyphens are short-hand for specifying a range of numbers. This example would assign logical ports 1,6,7,8,9, and 21 to the specified address/mask. Logical port numbers are specified in decimal. The ipPrimaryPorts will read back in a form equivalent to the form written. It may not read back exactly as written. ')
ipDynamicPrimaryPorts = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 4, 5, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipDynamicPrimaryPorts.setStatus('mandatory')
if mibBuilder.loadTexts: ipDynamicPrimaryPorts.setDescription(' ipPrimaryPorts is the set of all logical ports, learned dynamically, that packets will exit the Gigaswitch regardless of the range to which they are addressed to. ')
ipDynamicEnabledPorts = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 4, 5, 5), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipDynamicEnabledPorts.setStatus('mandatory')
if mibBuilder.loadTexts: ipDynamicEnabledPorts.setDescription(' ipSwitchDynamicEnabledPorts is the set of bridge ports over which the GIGAswitch sends and receives information about configured IP address ranges. The syntax used to specify it is the same as for ipPrimaryPorts. ')
agl = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 4))
aglConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 4, 1))
aglSonet = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 4, 2))
aglDS3E3 = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 4, 3))
aglAtm = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 4, 4))
aglInterfaceConfTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 4, 1, 1), )
if mibBuilder.loadTexts: aglInterfaceConfTable.setStatus('mandatory')
if mibBuilder.loadTexts: aglInterfaceConfTable.setDescription(' This table contains the AGL specific interface configuration parameters, one entry per ATM interface port. ')
aglInterfaceConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 4, 1, 1, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "aglInterfaceIndex"))
if mibBuilder.loadTexts: aglInterfaceConfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: aglInterfaceConfEntry.setDescription(' This list contains ATM interface configuration parameters and state variables. ')
aglInterfaceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 4, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aglInterfaceIndex.setStatus('mandatory')
if mibBuilder.loadTexts: aglInterfaceIndex.setDescription(' The value of this object identifies the AGL port interface for which this entry contains management information. ')
aglInterfacePhyType = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 4, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("sts3cStm1", 1), ("ds3e3", 2), ("unKnown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aglInterfacePhyType.setStatus('mandatory')
if mibBuilder.loadTexts: aglInterfacePhyType.setDescription(' Indicates the type of physical interface used on the ATM port. Two physical layer types are supported: 1. STS3c/STM1 2. DS3/E3 The type is unknown if the port is not present or its physical layer type is not known. ')
aglInterfaceTrafficRateGranularity = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 4, 1, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aglInterfaceTrafficRateGranularity.setStatus('mandatory')
if mibBuilder.loadTexts: aglInterfaceTrafficRateGranularity.setDescription(' Indicates the granularity in cell/s for assigning peak, average and minimum guaranteed rates for traffic shaped circuits on the AGL port. This value also represents the minimum rate in cells/s that can be assigned to a circuit. The rates subscribed to in the aglVCConnectionTable will be set to a multiple of this rate. ')
aglInterfaceSonetTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 4, 2, 1), )
if mibBuilder.loadTexts: aglInterfaceSonetTable.setStatus('mandatory')
if mibBuilder.loadTexts: aglInterfaceSonetTable.setDescription(' This table contains the AGL specific interface configuration parameters for the SONET/SDH physical layer. ')
aglInterfaceSonetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 4, 2, 1, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "aglInterfaceSonetIndex"))
if mibBuilder.loadTexts: aglInterfaceSonetEntry.setStatus('mandatory')
if mibBuilder.loadTexts: aglInterfaceSonetEntry.setDescription(' This list contains SONET/SDH interface configuration parameters and state variables. ')
aglInterfaceSonetIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 4, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aglInterfaceSonetIndex.setStatus('mandatory')
if mibBuilder.loadTexts: aglInterfaceSonetIndex.setDescription(' The value of this object identifies the AGL port interface for which this entry contains management information and is the same as aglInterfaceIndex. ')
aglInterfaceSonetMode = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 4, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("sonetSTS3c", 1), ("sdhSTM1", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aglInterfaceSonetMode.setStatus('mandatory')
if mibBuilder.loadTexts: aglInterfaceSonetMode.setDescription(' Specifies whether the PHY operates in SONET STS-3c or SDH STM-1 mode. The following code points are used: 1 SONET STS-3c 2 SDH STM-1 ')
aglInterfaceSonetTiming = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 4, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("loopTiming", 1), ("localTiming", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aglInterfaceSonetTiming.setStatus('mandatory')
if mibBuilder.loadTexts: aglInterfaceSonetTiming.setDescription(' Specifies whether the PHY operates in loop-timing or local-timing mode. In loop-timing, the recovered clock from the receive signal is used directly to time transmit data. Hence, the PHY is synchronized to the far-end transmitter. In local timing, transmit data is timed from a local oscillator of frequency 155.52 MHz (20ppm). The following code points are used: 1 loop-timing 2 local-timing ')
aglInterfaceDS3E3Table = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 4, 3, 1), )
if mibBuilder.loadTexts: aglInterfaceDS3E3Table.setStatus('mandatory')
if mibBuilder.loadTexts: aglInterfaceDS3E3Table.setDescription(' This table contains the AGL specific interface configuration parameters for the DS3/E3 physical layer. ')
aglInterfaceDS3E3Entry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 4, 3, 1, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "aglInterfaceDS3E3Index"))
if mibBuilder.loadTexts: aglInterfaceDS3E3Entry.setStatus('mandatory')
if mibBuilder.loadTexts: aglInterfaceDS3E3Entry.setDescription(' This list contains DS3/E3 interface configuration parameters and state variables. ')
aglInterfaceDS3E3Index = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 4, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aglInterfaceDS3E3Index.setStatus('mandatory')
if mibBuilder.loadTexts: aglInterfaceDS3E3Index.setDescription(' The value of this object identifies the AGL port interface for which this entry contains management information and is the same as aglInterfaceIndex. ')
aglInterfaceDS3E3Mode = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 4, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("low-power", 1), ("high-power", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aglInterfaceDS3E3Mode.setStatus('mandatory')
if mibBuilder.loadTexts: aglInterfaceDS3E3Mode.setDescription(' Specifies whether the DS3/E3 PHY operates in low power mode for short distances or high power mode for longer distances. The following code points are used: 1 low-power 2 high-power ')
aglInterfaceDS3E3Plcp = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 4, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aglInterfaceDS3E3Plcp.setStatus('mandatory')
if mibBuilder.loadTexts: aglInterfaceDS3E3Plcp.setDescription(' Specifies whether ATM cells may be mapped into the DS3 PLCP. In the enabled mode, PLCP framing and timing is applied to each ATM cell. ')
aglVCConnectionTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 4, 4, 1), )
if mibBuilder.loadTexts: aglVCConnectionTable.setStatus('mandatory')
if mibBuilder.loadTexts: aglVCConnectionTable.setDescription(' This table contains AGL ATM VCC configuration and performance parameters and state variables. Each entry represents a bidirectional traffic flow. ')
aglVCConnectionTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 4, 4, 1, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "aglVCConnectionPortA"), (0, "DEC-ELAN-MIB", "aglVCConnectionPortAVpi"), (0, "DEC-ELAN-MIB", "aglVCConnectionPortAVci"), (0, "DEC-ELAN-MIB", "aglVCConnectionPortB"), (0, "DEC-ELAN-MIB", "aglVCConnectionPortBVpi"), (0, "DEC-ELAN-MIB", "aglVCConnectionPortBVci"))
if mibBuilder.loadTexts: aglVCConnectionTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: aglVCConnectionTableEntry.setDescription(' A bidirectional circuit. ')
aglVCConnectionPortA = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 4, 4, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aglVCConnectionPortA.setStatus('mandatory')
if mibBuilder.loadTexts: aglVCConnectionPortA.setDescription(' The value of this object identifies the AGL ATM port A of the VCC segment for FDDI-bridged and ATM-to-ATM circuit types. ')
aglVCConnectionPortAVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 4, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aglVCConnectionPortAVpi.setStatus('mandatory')
if mibBuilder.loadTexts: aglVCConnectionPortAVpi.setDescription(' The VPI value at port A for the bidirectional circuit. The maximum VPI value cannot exceed the number supported by the atmInterfaceMaxVpiBits at AGL ATM port A. This value is used for both transmit and receive VPIs ')
aglVCConnectionPortAVci = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 4, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(32, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aglVCConnectionPortAVci.setStatus('mandatory')
if mibBuilder.loadTexts: aglVCConnectionPortAVci.setDescription(' The VCI value at the port A for the bidirectional circuit. The VCI values from 0 to 31 are reserved. The maximum VCI value cannot exceed the number supported by the atmInterfaceMaxVciBits specified for the AGL ATM port A. This value is used for both transmit and receive VCIs ')
aglVCConnectionPortB = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 4, 4, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aglVCConnectionPortB.setStatus('mandatory')
if mibBuilder.loadTexts: aglVCConnectionPortB.setDescription(' The value of this object identifies the AGL ATM port B of the VCC segment for ATM-to-ATM circuit types. For FDDI-bridged circuit types this value should be zero. ')
aglVCConnectionPortBVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 4, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aglVCConnectionPortBVpi.setStatus('mandatory')
if mibBuilder.loadTexts: aglVCConnectionPortBVpi.setDescription(' The VPI value at port B for the bidirectional ATM-to-ATM circuit. The maximum VPI value cannot exceed the number supported by the atmInterfaceMaxVpiBits at AGL ATM port B. This value is used for both transmit and receive VPIs. For other circuit types this value should be zero. ')
aglVCConnectionPortBVci = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 4, 4, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(32, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aglVCConnectionPortBVci.setStatus('mandatory')
if mibBuilder.loadTexts: aglVCConnectionPortBVci.setDescription(' The VCI value at the port B for the bidirectional ATM-to-ATM circuit. The VCI values from 0 to 31 are reserved. The maximum VCI value cannot exceed the number supported by the atmInterfaceMaxVciBits specified for the AGL ATM port B. This value is used for both transmit and receive VCIs. For other circuit types this value should be zero. ')
aglVCConnectionTableEntryStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 4, 4, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("create", 1), ("delete", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aglVCConnectionTableEntryStatus.setStatus('mandatory')
if mibBuilder.loadTexts: aglVCConnectionTableEntryStatus.setDescription(' The status column used for creating, and deleting bidirectional circuit entries in the agl virtual channel connection table. ')
aglVCConnectionTrafficType = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 4, 4, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("fddi-bridged", 1), ("atm-to-atm", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aglVCConnectionTrafficType.setStatus('mandatory')
if mibBuilder.loadTexts: aglVCConnectionTrafficType.setDescription(' The value of this object identifies the circuit type and characteristics of a particular circuit. There are two types of connections supported: 1. FDDI-bridged 2. ATM-to-ATM An FDDI-bridged circuit carries all bridged FDDI traffic on AGL ATM port A. No information is required to be entered for Port B. Only one bridged FDDI circuit per AGL ATM port is supported. The packet format on this circuit is VC based multiplexed bridged FDDI as per RFC 1483. An ATM-to-ATM circuit carries arbitrary packet types between circuits specified on Port A and Port B of the GIGAswitch. Multiple ATM-to-ATM circuits are supported per AGL ATM port. ')
aglVCConnectionAALType = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 4, 4, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("aal34", 1), ("aal5", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aglVCConnectionAALType.setStatus('mandatory')
if mibBuilder.loadTexts: aglVCConnectionAALType.setDescription(' The value of this object identifies the AAL type that should be used on a particular circuit. ')
aglVCConnectionOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 4, 4, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("unknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aglVCConnectionOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: aglVCConnectionOperStatus.setDescription(' This object indicates the operational status of the VCC, i.e., whether the managed VCC segment is up or down. In the down state, no cells can get across this VCC segment. The status is unknown if the OAM is disabled. ')
aglVCConnectionAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 4, 4, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aglVCConnectionAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: aglVCConnectionAdminStatus.setDescription(' This object indicates the desired status of the VCC, i.e., whether the managed VCC segment is enabled or disabled. In the disabled state, no cells can be passed across this VCC segment. ')
aglVCConnectionTrafficShaperPeakRate = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 4, 4, 1, 1, 12), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aglVCConnectionTrafficShaperPeakRate.setStatus('mandatory')
if mibBuilder.loadTexts: aglVCConnectionTrafficShaperPeakRate.setDescription(' The value of this object specifies the peak rate in cells/s that should be used on a particular circuit. The peak rate will be set to a multiple of the aglInterfaceTrafficRateGranularity close to the user specified input. ')
aglVCConnectionTrafficShaperAvgRate = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 4, 4, 1, 1, 13), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aglVCConnectionTrafficShaperAvgRate.setStatus('mandatory')
if mibBuilder.loadTexts: aglVCConnectionTrafficShaperAvgRate.setDescription(' The value of this object specifies the average (sustained) rate in cells/s that should be used on a particular circuit. The average rate must be less than or equal to the peak rate and it will be set to a multiple of the aglInterfaceTrafficRate- Granularity close to the user specified input. ')
aglVCConnectionTrafficShaperMinGuaranteedRate = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 4, 4, 1, 1, 14), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aglVCConnectionTrafficShaperMinGuaranteedRate.setStatus('mandatory')
if mibBuilder.loadTexts: aglVCConnectionTrafficShaperMinGuaranteedRate.setDescription(' The value of this object specifies the minimum guaranteed rate in cells/s that should be used on a particular circuit. For VBR traffic AGL allows the possibility of overbooking link bandwidth (up to 1200%) to achive statistical multiplexing. This parameter specifies the minimum peak bandwidth that you want to guarantee to the circuit. The minimum guaranteed rate must be less than or equal to the peak rate and it will be set to a multiple of the aglInterfaceTrafficRateGranularity close to the user specified input. ')
aglVCConnectionTrafficShaperPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 4, 4, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 12))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aglVCConnectionTrafficShaperPriority.setStatus('mandatory')
if mibBuilder.loadTexts: aglVCConnectionTrafficShaperPriority.setDescription(" The value of this object specifies the priority which should be given to this circuit in assigning opportunistic bandwidth that arises from AGL's bandwidth overbooking policy. ")
aglInterfaceATMTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 4, 4, 2), )
if mibBuilder.loadTexts: aglInterfaceATMTable.setStatus('mandatory')
if mibBuilder.loadTexts: aglInterfaceATMTable.setDescription(' This table contains AGL ATM interface specific settable parameters. ')
aglInterfaceATMTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 4, 4, 2, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "aglInterfaceATMIndex"))
if mibBuilder.loadTexts: aglInterfaceATMTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: aglInterfaceATMTableEntry.setDescription(' The list of settable parameters. ')
aglInterfaceATMIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 4, 4, 2, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aglInterfaceATMIndex.setStatus('mandatory')
if mibBuilder.loadTexts: aglInterfaceATMIndex.setDescription(' The value of this object identifies the AGL port interface for which this entry contains management information and is the same as aglInterfaceIndex. ')
aglInterfaceATMScrambeStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 4, 4, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aglInterfaceATMScrambeStatus.setStatus('mandatory')
if mibBuilder.loadTexts: aglInterfaceATMScrambeStatus.setDescription(' This object indicates the desired status of the cell scramble module. In the enabled state, outgoing cells are scrambed and input cells are descrambled. ')
aglInterfaceATMOAMStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 4, 4, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aglInterfaceATMOAMStatus.setStatus('mandatory')
if mibBuilder.loadTexts: aglInterfaceATMOAMStatus.setDescription(' This object indicates the desired status of the OAM module in the default circuit. In the enabled state, normal OAM cells are exchanged between the peers. ')
aglatmMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 5))
aglatmMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 5, 1))
aglatmInterfaceTrafficEnforcementTypes = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 5, 1, 1))
aglatmInterfaceNoTrafficEnforcement = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 5, 1, 1, 1), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aglatmInterfaceNoTrafficEnforcement.setStatus('mandatory')
if mibBuilder.loadTexts: aglatmInterfaceNoTrafficEnforcement.setDescription('This identifies the no ATM traffic enforcement type.')
aglatmInterfaceTrafficEnforcementType1 = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 5, 1, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aglatmInterfaceTrafficEnforcementType1.setStatus('mandatory')
if mibBuilder.loadTexts: aglatmInterfaceTrafficEnforcementType1.setDescription('This identifies the ATM traffic enforcement type is 1. For type 1 traffic enforcement, parameter 1 specifies CLP=0+1 peak traffic. Parameters 2, 3, 4 and 5 are not used. The peak rate is measured in cells per second.')
aglatmInterfaceTrafficEnforcementType2 = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 5, 1, 1, 3), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aglatmInterfaceTrafficEnforcementType2.setStatus('mandatory')
if mibBuilder.loadTexts: aglatmInterfaceTrafficEnforcementType2.setDescription('This identifies the ATM traffic enforcement type is 2. For type 2 traffic enforcement, parameter 1 specifies CLP=0 peak traffic and parameter 2 specifies CLP=0+1 peak traffic. Parameters 3, 4, and 5 are not used. The peak rate is measured in cells per second.')
aglatmInterfaceTrafficEnforcementType3 = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 5, 1, 1, 4), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aglatmInterfaceTrafficEnforcementType3.setStatus('mandatory')
if mibBuilder.loadTexts: aglatmInterfaceTrafficEnforcementType3.setDescription('This identifies the ATM traffic enforcement type is 3. For type 3 traffic enforcement, parameter 1 specifies CLP=0+1 peak traffic, parameter 2 specifies CLP=0 sustained rate, and parameter 3 specifies CLP=0 maximum burst size. Parameters 4 and 5 are not used. The peak rate is measured in cells per second. The sustained rate is measured in cells per second and burst size is measured in cells.')
aglatmInterfaceTrafficEnforcementType4 = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 5, 1, 1, 5), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aglatmInterfaceTrafficEnforcementType4.setStatus('mandatory')
if mibBuilder.loadTexts: aglatmInterfaceTrafficEnforcementType4.setDescription('This identifies the ATM traffic enforcement type is 4. For type 4 traffic enforcement, parameter 1 specifies CLP=0 peak traffic, parameter 2 specifies CLP=0+1 peak traffic, and parameter 3 specifies tagging (e.g., a value 1 may be used to indicate tagging). Parameters 4 and 5 are not used. The peak rate is measured in cells per second.')
aglatmInterfaceTrafficEnforcementType5 = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 5, 1, 1, 6), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aglatmInterfaceTrafficEnforcementType5.setStatus('mandatory')
if mibBuilder.loadTexts: aglatmInterfaceTrafficEnforcementType5.setDescription('This identifies the ATM traffic enforcement type is 5. For type 5 traffic enforcement, parameter 1 specifies CLP=0+1 peak traffic, parameter 2 specifies CLP=0 sustained rate, parameter 3 specifies CLP=0 maximum burst size, and parameter 4 specifies tagging (e.g., a value 1 may be used to indicate tagging). Parameter 5 is not used.')
aglatmInterfaceTrafficEnforcementType6 = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 5, 1, 1, 7), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aglatmInterfaceTrafficEnforcementType6.setStatus('mandatory')
if mibBuilder.loadTexts: aglatmInterfaceTrafficEnforcementType6.setDescription('This identifies the ATM traffic enforcement type is 6. For type 6 traffic enforcement, parameter 1 specifies CLP=0+1 peak traffic, parameter 2 specifies CLP=0+1 sustained rate, and parameter 3 specifies CLP=0+1 maximum burst size. Parameters 4 and 5 are not used.')
aglatmInterfaceTrafficEnforcementType7 = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 5, 1, 1, 8), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aglatmInterfaceTrafficEnforcementType7.setStatus('mandatory')
if mibBuilder.loadTexts: aglatmInterfaceTrafficEnforcementType7.setDescription('This identifies the ATM traffic enforcement type is 7. For type 7 traffic enforcement, parameter 1 specifies CLP=0+1 peak traffic and parameter 2 specifies best effort traffic (e.g., a value 1 may be used to indicate best effort traffic). Parameters 3, 4 and 5 are not used.')
aglatmInterfaceConfTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 5, 1, 2), )
if mibBuilder.loadTexts: aglatmInterfaceConfTable.setStatus('mandatory')
if mibBuilder.loadTexts: aglatmInterfaceConfTable.setDescription('This table contains ATM local interface configuration parameters and state variables, one entry per ATM interface port.')
aglatmInterfaceConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 5, 1, 2, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "aglatmInterfaceIndex"))
if mibBuilder.loadTexts: aglatmInterfaceConfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: aglatmInterfaceConfEntry.setDescription('This list contains ATM interface configuration parameters and state variables.')
aglatmInterfaceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 5, 1, 2, 1, 1), Integer32())
if mibBuilder.loadTexts: aglatmInterfaceIndex.setStatus('mandatory')
if mibBuilder.loadTexts: aglatmInterfaceIndex.setDescription('The value of this object identifies the ATM port interface for which this entry contains management information.')
aglatmInterfaceMaxVpcs = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 5, 1, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aglatmInterfaceMaxVpcs.setStatus('mandatory')
if mibBuilder.loadTexts: aglatmInterfaceMaxVpcs.setDescription('The maximum number of VPCs supported at this ATM interface.')
aglatmInterfaceMaxVccs = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 5, 1, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aglatmInterfaceMaxVccs.setStatus('mandatory')
if mibBuilder.loadTexts: aglatmInterfaceMaxVccs.setDescription('The maximum number of VCCs supported at the ATM interface.')
aglatmInterfaceConfVpcs = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 5, 1, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aglatmInterfaceConfVpcs.setStatus('mandatory')
if mibBuilder.loadTexts: aglatmInterfaceConfVpcs.setDescription('The number of VPCs configured for use at this ATM interface.')
aglatmInterfaceConfVccs = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 5, 1, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aglatmInterfaceConfVccs.setStatus('mandatory')
if mibBuilder.loadTexts: aglatmInterfaceConfVccs.setDescription('The number of VCCs configured for use at the ATM interface.')
aglatmInterfaceMaxActiveVpiBits = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 5, 1, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aglatmInterfaceMaxActiveVpiBits.setStatus('mandatory')
if mibBuilder.loadTexts: aglatmInterfaceMaxActiveVpiBits.setDescription('The maximum number of active VPI bits configured for use at the ATM interface.')
aglatmInterfaceMaxActiveVciBits = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 5, 1, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aglatmInterfaceMaxActiveVciBits.setStatus('mandatory')
if mibBuilder.loadTexts: aglatmInterfaceMaxActiveVciBits.setDescription('The maximum number of active VCI bits configured for use at this ATM interface.')
aglatmInterfaceIlmiVpiVci = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 5, 1, 2, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aglatmInterfaceIlmiVpiVci.setStatus('mandatory')
if mibBuilder.loadTexts: aglatmInterfaceIlmiVpiVci.setDescription('The decimal value of the three octet VPI/VCI field that identifies the VCC supporting the ILMI at the ATM interface. If the value of this object is greater than 16777215 then the ILMI is not supported at the ATM interface. The default VPI/VCI values for ILMI are VPI=0 and VCI=16.')
aglatmInterfaceSpecific = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 5, 1, 2, 1, 9), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aglatmInterfaceSpecific.setStatus('mandatory')
if mibBuilder.loadTexts: aglatmInterfaceSpecific.setDescription('This object points to the additional information specific to ATM interfaces. For example, if Enterprise specific objects have been defined in addition to this MIB module, then the value of this object refers to that MIB defining these objects. If the additional information is not present, then the value should be {0 0}.')
aglatmInterfaceDs3PlcpTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 5, 1, 3), )
if mibBuilder.loadTexts: aglatmInterfaceDs3PlcpTable.setStatus('mandatory')
if mibBuilder.loadTexts: aglatmInterfaceDs3PlcpTable.setDescription('This table contains ATM interface DS3 PLCP parameters and state variables, one entry per ATM interface port.')
aglatmInterfaceDs3PlcpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 5, 1, 3, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "aglatmInterfaceDs3PlcpIndex"))
if mibBuilder.loadTexts: aglatmInterfaceDs3PlcpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: aglatmInterfaceDs3PlcpEntry.setDescription('This list contains DS3 PLCP parameters and state variables at the ATM interface.')
aglatmInterfaceDs3PlcpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 5, 1, 3, 1, 1), Integer32())
if mibBuilder.loadTexts: aglatmInterfaceDs3PlcpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: aglatmInterfaceDs3PlcpIndex.setDescription('The value of this object identifies the ATM interface port for which this entry contains management information and is the same as the atmInterfaceIndex.')
aglatmInterfaceDs3PlcpSEFSs = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 5, 1, 3, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aglatmInterfaceDs3PlcpSEFSs.setStatus('mandatory')
if mibBuilder.loadTexts: aglatmInterfaceDs3PlcpSEFSs.setDescription('A DS3 Severely Errored Framing Second (SEFS) is a count of one-second intervals containing one or more SEF event.')
aglatmInterfaceDs3PlcpAlarmState = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 5, 1, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noAlarm", 1), ("receivedFarEndAlarm", 2), ("incomingLOF", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aglatmInterfaceDs3PlcpAlarmState.setStatus('mandatory')
if mibBuilder.loadTexts: aglatmInterfaceDs3PlcpAlarmState.setDescription('This variable indicates if there is an alarm present for the DS3 PLCP. The value receivedFarEndAlarm means that the DS3 PLCP has received an incoming Yellow Signal, the value incomingLOF means that the DS3 PLCP has declared a loss of frame (LOF) failure condition, and the value noAlarm means that there are no alarms present.')
aglatmInterfaceDs3PlcpUASs = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 5, 1, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aglatmInterfaceDs3PlcpUASs.setStatus('mandatory')
if mibBuilder.loadTexts: aglatmInterfaceDs3PlcpUASs.setDescription('The counter associated with the number of Unavailable Seconds encountered by the PLCP.')
aglatmInterfaceSonetTCTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 5, 1, 4), )
if mibBuilder.loadTexts: aglatmInterfaceSonetTCTable.setStatus('mandatory')
if mibBuilder.loadTexts: aglatmInterfaceSonetTCTable.setDescription('This table contains ATM interface SONET TC Sublayer parameters and state variables, one entry per ATM interface port.')
aglatmInterfaceSonetTCEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 5, 1, 4, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "aglatmInterfaceSonetTCIndex"))
if mibBuilder.loadTexts: aglatmInterfaceSonetTCEntry.setStatus('mandatory')
if mibBuilder.loadTexts: aglatmInterfaceSonetTCEntry.setDescription('This list contains SONET TC Sublayer parameters and state variables at the ATM interface.')
aglatmInterfaceSonetTCIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 5, 1, 4, 1, 1), Integer32())
if mibBuilder.loadTexts: aglatmInterfaceSonetTCIndex.setStatus('mandatory')
if mibBuilder.loadTexts: aglatmInterfaceSonetTCIndex.setDescription('The value of this object identifies the ATM interface port for which this entry contains management information and is the same as the atmInterfaceIndex.')
aglatmInterfaceSonetTCOCDEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 5, 1, 4, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aglatmInterfaceSonetTCOCDEvents.setStatus('mandatory')
if mibBuilder.loadTexts: aglatmInterfaceSonetTCOCDEvents.setDescription('The number of times the Out of Cell Delineation (OCD) events occur. If seven consecutive ATM cells have Header Error Control (HEC) violations, an OCD event occurs. A high number of OCD events may indicate a problem with the SONET TC Sublayer.')
aglatmInterfaceSonetTCAlarmState = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 5, 1, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noAlarm", 1), ("lcdFailure", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aglatmInterfaceSonetTCAlarmState.setStatus('mandatory')
if mibBuilder.loadTexts: aglatmInterfaceSonetTCAlarmState.setDescription('This variable indicates if there is an alarm present for the SONET TC Sublayer. The value lcdFailure indicates that a Loss of Cell Delineation (LCD) failure state has been declared for the SONET TC Sublayer.')
aglsonetMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 6))
aglsonetObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 6, 1))
aglsonetObjectsPath = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 6, 2))
aglsonetMedium = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 6, 1, 1))
aglsonetSection = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 6, 1, 2))
aglsonetLine = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 6, 1, 3))
aglsonetPath = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 6, 2, 1))
aglsonetMediumTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 6, 1, 1, 1), )
if mibBuilder.loadTexts: aglsonetMediumTable.setStatus('mandatory')
if mibBuilder.loadTexts: aglsonetMediumTable.setDescription('The SONET/SDH Medium table.')
aglsonetMediumEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 6, 1, 1, 1, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "aglsonetMediumIfIndex"))
if mibBuilder.loadTexts: aglsonetMediumEntry.setStatus('mandatory')
if mibBuilder.loadTexts: aglsonetMediumEntry.setDescription('An entry in the SONET/SDH Medium table.')
aglsonetMediumIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 6, 1, 1, 1, 1, 1), Integer32())
if mibBuilder.loadTexts: aglsonetMediumIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: aglsonetMediumIfIndex.setDescription('An index value that uniquely identifies a SONET/SDH Medium/Section/Line Interface.')
aglsonetMediumType = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 6, 1, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("sonet", 1), ("sdh", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aglsonetMediumType.setStatus('mandatory')
if mibBuilder.loadTexts: aglsonetMediumType.setDescription('This variable identifies whether a SONET or a SDH signal is used across this interface.')
aglsonetMediumTimeElapsed = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 6, 1, 1, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aglsonetMediumTimeElapsed.setStatus('mandatory')
if mibBuilder.loadTexts: aglsonetMediumTimeElapsed.setDescription('The number of seconds, including partial seconds, that have elapsed since the beginning of the current error-measurement period.')
aglsonetMediumValidIntervals = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 6, 1, 1, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aglsonetMediumValidIntervals.setStatus('mandatory')
if mibBuilder.loadTexts: aglsonetMediumValidIntervals.setDescription('The number of previous intervals for which valid data has been stored. A SONET device must support at least n intervals. The minimum value of n is 4. The default of n is 32. The maximum value of n is 96. The value of this object will be n unless the device was brought online within the last (nx15) minutes, in which case the value will be the number of complete 15 minute intervals the device has been online.')
aglsonetMediumLineCoding = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 6, 1, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("sonetMediumOther", 1), ("sonetMediumB3ZS", 2), ("sonetMediumCMI", 3), ("sonetMediumNRZ", 4), ("sonetMediumRZ", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aglsonetMediumLineCoding.setStatus('mandatory')
if mibBuilder.loadTexts: aglsonetMediumLineCoding.setDescription('This variable describes the line coding for this interface. The B3ZS and CMI are used for electrical SONET/SDH signals (STS-1 and STS-3). The Non-Return to Zero (NRZ) and the Return to Zero are used for optical SONET/SDH signals.')
aglsonetMediumLineType = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 6, 1, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("sonetOther", 1), ("sonetShortSingleMode", 2), ("sonetLongSingleMode", 3), ("sonetMultiMode", 4), ("sonetCoax", 5), ("sonetUTP", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aglsonetMediumLineType.setStatus('mandatory')
if mibBuilder.loadTexts: aglsonetMediumLineType.setDescription('This variable describes the line type for this interface. The line types are Short and Long Range Single Mode fiber or Multi-Mode fiber interfaces, and coax and UTP for electrical interfaces. The value sonetOther should be used when the Line Type is not one of the listed values.')
aglsonetMediumCircuitIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 6, 1, 1, 1, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aglsonetMediumCircuitIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: aglsonetMediumCircuitIdentifier.setDescription("This variable contains the transmission vendor's circuit identifier, for the purpose of facilitating troubleshooting.")
aglsonetSectionCurrentTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 6, 1, 2, 1), )
if mibBuilder.loadTexts: aglsonetSectionCurrentTable.setStatus('mandatory')
if mibBuilder.loadTexts: aglsonetSectionCurrentTable.setDescription('The SONET/SDH Section Current table.')
aglsonetSectionCurrentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 6, 1, 2, 1, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "aglsonetSectionCurrentIfIndex"))
if mibBuilder.loadTexts: aglsonetSectionCurrentEntry.setStatus('mandatory')
if mibBuilder.loadTexts: aglsonetSectionCurrentEntry.setDescription('An entry in the SONET/SDH Section Current table.')
aglsonetSectionCurrentIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 6, 1, 2, 1, 1, 1), Integer32())
if mibBuilder.loadTexts: aglsonetSectionCurrentIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: aglsonetSectionCurrentIfIndex.setDescription('The index value which uniquely identifies the SONET/SDH Medium/Section/Line Interface.')
aglsonetSectionCurrentStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 6, 1, 2, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aglsonetSectionCurrentStatus.setStatus('mandatory')
if mibBuilder.loadTexts: aglsonetSectionCurrentStatus.setDescription('This variable indicates the status of the interface. The sonetSectionStatus is a bit map represented as a sum, therefore, it can represent multiple defects simultaneously. The sonetSectionNoDefect should be set if and only if no other flag is set. The various bit positions are: 1 sonetSectionNoDefect 2 sonetSectionLOS 4 sonetSectionLOF')
aglsonetSectionCurrentESs = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 6, 1, 2, 1, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aglsonetSectionCurrentESs.setStatus('mandatory')
if mibBuilder.loadTexts: aglsonetSectionCurrentESs.setDescription('The counter associated with the number of Errored Seconds encountered by a SONET/SDH Section in the current 15 minute interval.')
aglsonetSectionCurrentSESs = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 6, 1, 2, 1, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aglsonetSectionCurrentSESs.setStatus('mandatory')
if mibBuilder.loadTexts: aglsonetSectionCurrentSESs.setDescription('The counter associated with the number of Severely Errored Seconds encountered by a SONET/SDH Section in the current 15 minute interval.')
aglsonetSectionCurrentSEFSs = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 6, 1, 2, 1, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aglsonetSectionCurrentSEFSs.setStatus('mandatory')
if mibBuilder.loadTexts: aglsonetSectionCurrentSEFSs.setDescription('The counter associated with the number of Severely Errored Framing Seconds encountered by a SONET/SDH Section in the current 15 minute interval.')
aglsonetSectionCurrentCVs = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 6, 1, 2, 1, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aglsonetSectionCurrentCVs.setStatus('mandatory')
if mibBuilder.loadTexts: aglsonetSectionCurrentCVs.setDescription('The counter associated with the number of Coding Violations encountered by a SONET/SDH Section in the current 15 minute interval.')
aglsonetLineCurrentTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 6, 1, 3, 1), )
if mibBuilder.loadTexts: aglsonetLineCurrentTable.setStatus('mandatory')
if mibBuilder.loadTexts: aglsonetLineCurrentTable.setDescription('The SONET/SDH Line Current table.')
aglsonetLineCurrentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 6, 1, 3, 1, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "aglsonetLineCurrentIfIndex"))
if mibBuilder.loadTexts: aglsonetLineCurrentEntry.setStatus('mandatory')
if mibBuilder.loadTexts: aglsonetLineCurrentEntry.setDescription('An entry in the SONET/SDH Line Current table.')
aglsonetLineCurrentIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 6, 1, 3, 1, 1, 1), Integer32())
if mibBuilder.loadTexts: aglsonetLineCurrentIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: aglsonetLineCurrentIfIndex.setDescription('The index value which uniquely identifies the SONET/SDH Medium/Line Interface.')
aglsonetLineCurrentStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 6, 1, 3, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aglsonetLineCurrentStatus.setStatus('mandatory')
if mibBuilder.loadTexts: aglsonetLineCurrentStatus.setDescription('This variable indicates the status of the interface. The sonetLineStatus is a bit map represented as a sum, therefore, it can represent multiple defects simultaneously. The sonetLineNoDefect should be set if and only if no other flag is set. The various bit positions are: 1 sonetLineNoDefect 2 sonetLineAIS 4 sonetLineRDI')
aglsonetLineCurrentESs = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 6, 1, 3, 1, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aglsonetLineCurrentESs.setStatus('mandatory')
if mibBuilder.loadTexts: aglsonetLineCurrentESs.setDescription('The counter associated with the number of Errored Seconds encountered by a SONET/SDH Line in the current 15 minute interval.')
aglsonetLineCurrentSESs = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 6, 1, 3, 1, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aglsonetLineCurrentSESs.setStatus('mandatory')
if mibBuilder.loadTexts: aglsonetLineCurrentSESs.setDescription('The counter associated with the number of Severely Errored Seconds encountered by a SONET/SDH Line in the current 15 minute interval.')
aglsonetLineCurrentCVs = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 6, 1, 3, 1, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aglsonetLineCurrentCVs.setStatus('mandatory')
if mibBuilder.loadTexts: aglsonetLineCurrentCVs.setDescription('The counter associated with the number of Coding Violations encountered by a SONET/SDH Line in the current 15 minute interval.')
aglsonetLineCurrentUASs = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 6, 1, 3, 1, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aglsonetLineCurrentUASs.setStatus('mandatory')
if mibBuilder.loadTexts: aglsonetLineCurrentUASs.setDescription('The counter associated with the number of Unavailable Seconds encountered by a SONET/SDH Line in the current 15 minute interval.')
aglsonetPathCurrentTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 6, 2, 1, 1), )
if mibBuilder.loadTexts: aglsonetPathCurrentTable.setStatus('mandatory')
if mibBuilder.loadTexts: aglsonetPathCurrentTable.setDescription('The SONET/SDH Path Current table.')
aglsonetPathCurrentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 6, 2, 1, 1, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "aglsonetPathCurrentIfIndex"))
if mibBuilder.loadTexts: aglsonetPathCurrentEntry.setStatus('mandatory')
if mibBuilder.loadTexts: aglsonetPathCurrentEntry.setDescription('An entry in the SONET/SDH Path Current table.')
aglsonetPathCurrentIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 6, 2, 1, 1, 1, 1), Integer32())
if mibBuilder.loadTexts: aglsonetPathCurrentIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: aglsonetPathCurrentIfIndex.setDescription('An index value that uniquely identifies a SONET/SDH Path Interface.')
aglsonetPathCurrentWidth = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 6, 2, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("sts1", 1), ("sts3cSTM1", 2), ("sts12cSTM4", 3), ("sts24c", 4), ("sts48cSTM16", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aglsonetPathCurrentWidth.setStatus('mandatory')
if mibBuilder.loadTexts: aglsonetPathCurrentWidth.setDescription('A value that indicates the type of the SONET/SDH Path. For SONET, the assigned types are the STS-Nc SPEs, where N = 1, 3, 12, 24, and 48. STS-1 is equal to 51.84 Mbps. For SDH, the assigned types are the STM-Nc VCs, where N = 1, 4, and 16.')
aglsonetPathCurrentStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 6, 2, 1, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aglsonetPathCurrentStatus.setStatus('mandatory')
if mibBuilder.loadTexts: aglsonetPathCurrentStatus.setDescription('This variable indicates the status of the interface. The sonetPathStatus is a bit map represented as a sum, therefore, it can represent multiple defects simultaneously. The sonetPathNoDefect should be set if and only if no other flag is set. The various bit positions are: 1 sonetPathNoDefect 2 sonetPathSTSLOP 4 sonetPathSTSAIS 8 sonetPathSTSRDI 16 sonetPathUnequipped 32 sonetPathSignalLabelMismatch')
aglsonetPathCurrentESs = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 6, 2, 1, 1, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aglsonetPathCurrentESs.setStatus('mandatory')
if mibBuilder.loadTexts: aglsonetPathCurrentESs.setDescription('The counter associated with the number of Errored Seconds encountered by a SONET/SDH Path in the current 15 minute interval.')
aglsonetPathCurrentSESs = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 6, 2, 1, 1, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aglsonetPathCurrentSESs.setStatus('mandatory')
if mibBuilder.loadTexts: aglsonetPathCurrentSESs.setDescription('The counter associated with the number of Severely Errored Seconds encountered by a SONET/SDH Path in the current 15 minute interval.')
aglsonetPathCurrentCVs = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 6, 2, 1, 1, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aglsonetPathCurrentCVs.setStatus('mandatory')
if mibBuilder.loadTexts: aglsonetPathCurrentCVs.setDescription('The counter associated with the number of Coding Violations encountered by a SONET/SDH Path in the current 15 minute interval.')
aglsonetPathCurrentUASs = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 6, 2, 1, 1, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aglsonetPathCurrentUASs.setStatus('mandatory')
if mibBuilder.loadTexts: aglsonetPathCurrentUASs.setDescription('The counter associated with the number of Unavailable Seconds encountered by a Path in the current 15 minute, interval.')
portGroupMembershipTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 5, 1), )
if mibBuilder.loadTexts: portGroupMembershipTable.setStatus('mandatory')
if mibBuilder.loadTexts: portGroupMembershipTable.setDescription('The table for storing the port group membership.')
portGroupMembershipEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 5, 1, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "portGroupBridgePort"))
if mibBuilder.loadTexts: portGroupMembershipEntry.setStatus('mandatory')
if mibBuilder.loadTexts: portGroupMembershipEntry.setDescription('An entry stores information about a single port group.')
portGroupBridgePort = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 5, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portGroupBridgePort.setStatus('mandatory')
if mibBuilder.loadTexts: portGroupBridgePort.setDescription('The port group port number. It is unique within this table and must be between 37 and 64. Without management settings, the port group has no members in it. ')
portGroupMembership = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portGroupMembership.setStatus('mandatory')
if mibBuilder.loadTexts: portGroupMembership.setDescription(' This object displays the current state of the port group membership. Managers specify a new port group membership using portGroupMembershipWorkBuf. The new membership becomes effective and remains unchanged after a system crash when portGroupAction is set to doUpdate and the updating process succeeds. ')
portGroupMembershipWorkBuf = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 5, 1, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portGroupMembershipWorkBuf.setStatus('mandatory')
if mibBuilder.loadTexts: portGroupMembershipWorkBuf.setDescription(' Managers can update a new port group membership as many times as they want using this object. Setting this object to a new value does not change the current membership and the value will be resetted after a system crash. The new value is copied to portGroupMembership when portGroupAction is set to doUpdate and the updating process successfully changes the port member. A port group is expressed using a shorthand that says what bridge ports are members of the group. An examples of a specification is: (1,3,5) (32-36) (6,12-24,36) () A list of bridge ports between 1 and 36 are used to represent the members of the port group. A bridge port becoming a member of a port group ceases to operate as a normal bridge port, therefore filters on the port have no effect. If a port group is specified as an empty set, the members in the group will operate as normal bridge ports and take their original brige port numbers. Their original filters will also become effective. Commas separate items in a list of bridge ports. Hyphens are short-hand for specifying a range of numbers. Bridge port numbers are specified in decimal. A port group will read back in a form equivalent to the form written. It may not read back exactly as written. If the manager specifies a member that is overlapped with a member of a preexisting port group in the same object, setting portGroupAction to doUpdate will fail. ')
portGroupPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 5, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("huntGroup", 1), ("reliabilityGroup", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portGroupPortType.setStatus('mandatory')
if mibBuilder.loadTexts: portGroupPortType.setDescription(' This object displays the current state of the port group port type. Managers specify a new port group port type using portGroupPortTypeWorkBuf. The new port type becomes effective and remains unchanged after a system crash when portGroupAction is set to doUpdate and the updating process succeeds. ')
portGroupPortTypeWorkBuf = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 5, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("huntGroup", 1), ("reliabilityGroup", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portGroupPortTypeWorkBuf.setStatus('mandatory')
if mibBuilder.loadTexts: portGroupPortTypeWorkBuf.setDescription(' Managers can update a new port group port type as many times as they want using this object. Setting this object to a new value does not change the current port type and the value will be resetted after a system crash. The new value is copied to portGroupPortType when portGroupAction is set to doUpdate and the updating process successfully changes the port type. Two port group types are supported: 1) the hunt group and 2) the reliability group. All members in the hunt group port work like a single bridge port as far as the bridge functions are concerned and yet provides higher bandwidth due to multiple parallel FDDI links. A state of a port in a reliability group is either operational or backup. Only a single port in the group may be operational, while the other ports in the group are backup. When the operational port fails, one backup mode port will be selected, and quickly become operational. ')
portGroupPortOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 5, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("uninitializedPort", 1), ("preBridging", 2), ("bridging", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portGroupPortOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: portGroupPortOperStatus.setDescription(" This object indicates the operational status of the port group. The status represents the aggregated effect of each member's status. uninitializedPort(1) state indicates one of the followings: 1) the port group has no member in it, 2) no port in the port group is powered on, 3) no port in the port group has successfully completed startup diagnostics. State preBridging(2) means that some ports in the port group have been initialized with the bridge functions, but no port is not yet functioning as part of a bridge port. This is always the case if the datalink is not up. A hunt group member remains in this state if the remote end of the link is not properly configured as part of the hunt group. An inactive member of a reliability group is also in this state if it is up and initialized. State bridging(3) means that at least one port in the port group is functioning as part of a bridge port. The port group must be in this state to carry user data. ")
portGroupFppnMembershipTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 5, 2), )
if mibBuilder.loadTexts: portGroupFppnMembershipTable.setStatus('mandatory')
if mibBuilder.loadTexts: portGroupFppnMembershipTable.setDescription('The table for storing the port group membership specified by FPPN numbers.')
portGroupFppnMembershipEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 5, 2, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "portGroupFppnPort"))
if mibBuilder.loadTexts: portGroupFppnMembershipEntry.setStatus('mandatory')
if mibBuilder.loadTexts: portGroupFppnMembershipEntry.setDescription('An entry stores information about a single port group.')
portGroupFppnPort = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 5, 2, 1, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portGroupFppnPort.setStatus('mandatory')
if mibBuilder.loadTexts: portGroupFppnPort.setDescription('The port group port number. It is unique within this table and must be between 99.37 and 99.64. Without management settings, the port group has no members in it. ')
portGroupFppnMembership = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 5, 2, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portGroupFppnMembership.setStatus('mandatory')
if mibBuilder.loadTexts: portGroupFppnMembership.setDescription(' This object displays the current state of the port group membership. Managers specify a new port group membership using portGroupFppnMembershipWorkBuf. The new membership becomes effective and remains unchanged after a system crash when portGroupAction is set to doUpdate and the updating process succeeds. ')
portGroupFppnMembershipWorkBuf = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 5, 2, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portGroupFppnMembershipWorkBuf.setStatus('mandatory')
if mibBuilder.loadTexts: portGroupFppnMembershipWorkBuf.setDescription(' Managers can update a new port group membership as many times as they want using this object. Setting this object to a new value does not change the current membership and the value will be resetted after a system crash. The new value is copied to portGroupFppnMembership when portGroupAction is set to doUpdate and the updating process successfully changes the port member. A port group is expressed using a shorthand that says what FPPN ports are members of the group. An examples of a specification is: (1.1,3.2,5.1) (13.1-14.2) (4.1,11.1-13.2,14.2) () A list of FPPN ports between 1.1 and 14.2 are used to represent the members of the port group. A port becoming a member of a port group ceases to operate as a normal bridge port, therefore filters on the port have no effect. If a port group is specified as an empty set, the members in the group will operate as normal bridge ports and take their original FPPN port numbers. Their original filters will also become effective. Commas separate items in a list of FPPN ports. Hyphens are short-hand for specifying a range of numbers. FPPN port numbers are of the form (slot.port) where slot is the slot number and port is the port number in the slot. A port group will read back in a form equivalent to the form written. It may not read back exactly as written. If the manager specifies a member that is overlapped with a member of a preexisting port group in the same object, setting portGroupAction to doUpdate will fail. ')
portGroupFppnPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 5, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("huntGroup", 1), ("reliabilityGroup", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portGroupFppnPortType.setStatus('mandatory')
if mibBuilder.loadTexts: portGroupFppnPortType.setDescription(' This object displays the current state of the port group port type. Managers specify a new port group port type using portGroupPortTypeWorkBuf. The new port type becomes effective and remains unchanged after a system crash when portGroupAction is set to doUpdate and the updating process succeeds. ')
portGroupFppnPortTypeWorkBuf = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 5, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("huntGroup", 1), ("reliabilityGroup", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portGroupFppnPortTypeWorkBuf.setStatus('mandatory')
if mibBuilder.loadTexts: portGroupFppnPortTypeWorkBuf.setDescription(' Managers can update a new port group port type as many times as they want using this object. Setting this object to a new value does not change the current port type and the value will be resetted after a system crash. The new value is copied to portGroupPortType when portGroupAction is set to doUpdate and the updating process successfully changes the port type. Two port group types are supported: 1) the hunt group and 2) the reliability group. All members in the hunt group port work like a single bridge port as far as the bridge functions are concerned and yet provides higher bandwidth due to multiple parallel FDDI links. A state of a port in a reliability group is either operational or backup. Only a single port in the group may be operational, while the other ports in the group are backup. When the operational port fails, one backup mode port will be selected, and quickly become operational. ')
portGroupFppnPortOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 5, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("uninitializedPort", 1), ("preBridging", 2), ("bridging", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portGroupFppnPortOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: portGroupFppnPortOperStatus.setDescription(" This object indicates the operational status of the port group. The status represents the aggregated effect of each member's status. uninitializedPort(1) state indicates one of the followings: 1) the port group has no member in it, 2) no port in the port group is powered on, 3) no port in the port group has successfully completed startup diagnostics. State preBridging(2) means that some ports in the port group have been initialized with the bridge functions, but no port is not yet functioning as part of a bridge port. This is always the case if the datalink is not up. A hunt group member remains in this state if the remote end of the link is not properly configured as part of the hunt group. An inactive member of a reliability group is also in this state if it is up and initialized. State bridging(3) means that at least one port in the port group is functioning as part of a bridge port. The port group must be in this state to carry user data. ")
portGroupStatusTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 5, 3), )
if mibBuilder.loadTexts: portGroupStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: portGroupStatusTable.setDescription('The table for storing the port status.')
portGroupStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 5, 3, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "portGroupStatusBridgePort"))
if mibBuilder.loadTexts: portGroupStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: portGroupStatusEntry.setDescription('An entry stores the port status.')
portGroupStatusBridgePort = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 5, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portGroupStatusBridgePort.setStatus('mandatory')
if mibBuilder.loadTexts: portGroupStatusBridgePort.setDescription('The bridge port number runs from 1 to _LASTPHYSPORT_. ')
portGroupStatusPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 5, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portGroupStatusPortNumber.setStatus('mandatory')
if mibBuilder.loadTexts: portGroupStatusPortNumber.setDescription('If the indexed port is a member of a port group, the port group number is returned. Otherwise, the index itself is returned. ')
portGroupStatusPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 5, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("singleton", 1), ("huntGroupMember", 2), ("reliabilityGroupMember", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portGroupStatusPortType.setStatus('mandatory')
if mibBuilder.loadTexts: portGroupStatusPortType.setDescription(' This object represents the port type. ')
portGroupStatusOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 5, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("uninitializedPort", 1), ("portInitializing", 2), ("preBridging", 3), ("bridging", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portGroupStatusOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: portGroupStatusOperStatus.setDescription(' This object indicates the operational status of the indexed port. uninitializedPort(1) state indicates one of the followings: 1) the port is nonexistent, 2) the port is in a slot that is not powered on, 3) the port has not successfully completed startup diagnostics. Ports in portInitializing(2) state are in the process of being initialized. It is a temporary state. State preBridging(3) means that the port has been initialized with the bridge functions, but is not functioning as part of a bridge port. This is always the case if the datalink is not up. A hunt group member remains in this state if the remote end of the link is not properly configured as part of the hunt group. An inactive member of a reliability group is also in this state if it is up and initialized. State bridging(4) means that the port is functioning as part of a bridge port. Ports must be in this state to carry user data. ')
learningDomainMembershipTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 5, 4), )
if mibBuilder.loadTexts: learningDomainMembershipTable.setStatus('mandatory')
if mibBuilder.loadTexts: learningDomainMembershipTable.setDescription(' This table allows learning domains to be created, modified, and deleted. There can be from 1 to 8 learning domains. A learning domain is a collection of port groups (or bridge ports) which share a learning database. Every bridge port is a member of precisely one learning domain. A MAC address that is seen on one port of the learning domain will be taught to the other ports in the learning domain, but not to ports in other learning domains, unless a target learning domain has been set up. Among other things, this allows for the possbility that a single MAC address may be learned on several different ports - as long as they are in separate learning domains. There are a maximum of 8 learning domains, including the default learning domain. The default learning domain is the set of all bridge ports that do not belong to a management defined learning domain. ')
learningDomainMembershipEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 5, 4, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "learningDomainNumber"))
if mibBuilder.loadTexts: learningDomainMembershipEntry.setStatus('mandatory')
if mibBuilder.loadTexts: learningDomainMembershipEntry.setDescription(' A group of objects, indexed by learningDomainNumber, that specify learning domain attributes. ')
learningDomainNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 5, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: learningDomainNumber.setStatus('mandatory')
if mibBuilder.loadTexts: learningDomainNumber.setDescription(' The index for a learning domain is an integer with range, 1-8, where 1 is the default learning domain. ')
learningDomainMembership = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 5, 4, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: learningDomainMembership.setStatus('mandatory')
if mibBuilder.loadTexts: learningDomainMembership.setDescription(' This object displays the current state of the learning domain membership. Managers specify a new learning domain membership using learningDomainMembershipWorkBuf. The new membership becomes effective and remains unchanged, across system reboots, when portGroupAction is set to doUpdate and the updating process succeeds. ')
learningDomainMembershipWorkBuf = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 5, 4, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: learningDomainMembershipWorkBuf.setStatus('mandatory')
if mibBuilder.loadTexts: learningDomainMembershipWorkBuf.setDescription(' The learningDomainMembershipWorkBuf object is used to create,modify, and delete learning domains. Managers can update a learning domain membership as many times as they want using this object. Setting this object to a new value does not change the current membership nor the values stored in non-volatile memory until the object portGroupAction is written with doUpdate. At that time the new values will be written to learningDomainMembership and non-volatile memory and the learning domain changes will take effect. The addition/removal of bridge ports to/from a learning domain is an atomic operation. Because a bridge port can only belong to one learning domain, the last assignment of a bridge port to a learning domain will determine the learning domain in which the bridge port resides. There is a default learning domain, designated by learningDomainNumber 1, which all bridge ports belong to until management changes the assignments of bridge ports to learning domains. If a bridge port is removed from a learning domain, it is placed back into the default learning domain. The default learning domain can not be modified directly. It changes when new learning domains are created or modified. Every learning domain is a member of precisely one logical bridge. The learningDomainMembership is expressed using a shorthand that specifies which bridge ports belong in the learning domain. An example of a specification would be : (1,6-9,21) where commas separate bridge ports and hyphens are short-hand for specifying a range of numbers. This example would assign bridge ports 1,6,7,8,9, and 21 to the specified learning domain. Bridge port numbers are specified in decimal. A learning domain will read back in a form equivalent to the form written. It may not read back exactly as written. ')
learningQuotaTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 5, 11), )
if mibBuilder.loadTexts: learningQuotaTable.setStatus('mandatory')
if mibBuilder.loadTexts: learningQuotaTable.setDescription(' Each logical bridge domain (LBD) has a learning quota. This table allows the setting of theses quotas. ')
learningQuotaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 5, 11, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "learningQuotaNumber"))
if mibBuilder.loadTexts: learningQuotaEntry.setStatus('mandatory')
if mibBuilder.loadTexts: learningQuotaEntry.setDescription(' A group of objects, indexed by learningQuotaNumber, that specify learning quotas. ')
learningQuotaNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 5, 11, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: learningQuotaNumber.setStatus('mandatory')
if mibBuilder.loadTexts: learningQuotaNumber.setDescription(' The index for a learning quota is a learning domain with range, 1 - 8. ')
learningQuota = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 5, 11, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: learningQuota.setStatus('mandatory')
if mibBuilder.loadTexts: learningQuota.setDescription(" Each learning domain has a learning quota. The ports in the domain are guaranteed the ability to use approximately this number of address entries in the Translation Table, so that an excessive number of learned addresses in one domain cannot interfere significantly with learning in another domain. The GIGAswitch keeps track of the count of addresses learned in each domain and deletes addresses from the domains that have most exceeded their learning quotas to make room for addresses learned in other domains. If these quotas are configured so that they add up to less than the size of the SCP Translation Table, there are almost always SCP Translation Table entries available to accommodate new learned addresses. Further, these addresses will not be deleted to make room for others unless the domain's quota is reached or is close to being reached. If the SCP Translation Table is not full, the quotas are allowed to be exceeded. Under such circumstances, the count of learned addresses in a logical bridge may grow until it is close to the number of unused entries in the Translation Table plus the applicable learning quota. The learning quotas are not exact, and addresses may start to be deleted when this limit is within a small number of addresses (initially 100) of being reached. It should be remembered that there are factors other than the learning quotas that may restrict the number of addresses that can be learned, so that a high learning quota does not guarantee that number of addresses may be learned. In particular: 1) If the capacity of the linecard Translation Tables is exceeded, no more addresses may be learned on that linecard. 2) If the sum of the configured learning quotas is greater than the SCP Translation Table size, then no more addresses may be learned once the SCP Translation Table is full, even though no quota may have been exceeded. When either of these situations occur, an attempt is made to solve the problem by deleting addresses in the same manner as when dealing with the learning quota limits. The default value for each learning quota is 32768, the same as the capacity of the SCP Translation Table. This large value means that the quotas have no effect. To see the full benefit of learning quotas, they should be set so that the sum of the quotas over all active domains is less than 32500. ")
portTargetDomainListMembershipTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 5, 5), )
if mibBuilder.loadTexts: portTargetDomainListMembershipTable.setStatus('mandatory')
if mibBuilder.loadTexts: portTargetDomainListMembershipTable.setDescription(' This table allows port target domains lists to be created, modified, and deleted. The port target domain list is the set of all mgmt defined learning domains to which a bridge port, as specified by the index, will learn addresses from. A MAC address that is seen in one of the learning domains in the port target domain list will be learned by the indexed bridge port. Every port target domain is a member of precisely one logical bridge. ')
portTargetDomainListMembershipEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 5, 5, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "portTargetDomainListIndex"))
if mibBuilder.loadTexts: portTargetDomainListMembershipEntry.setStatus('mandatory')
if mibBuilder.loadTexts: portTargetDomainListMembershipEntry.setDescription(' A group of objects, indexed by portTargetDomainListIndex, that specify port target domain attributes. ')
portTargetDomainListIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 5, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portTargetDomainListIndex.setStatus('mandatory')
if mibBuilder.loadTexts: portTargetDomainListIndex.setDescription(' A bridge port number from 1 - 64 . ')
portTargetDomainListMembership = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 5, 5, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portTargetDomainListMembership.setStatus('mandatory')
if mibBuilder.loadTexts: portTargetDomainListMembership.setDescription(' The portTargetDomainListMembership specifies a set of mgmt specified learning domains. This object displays the current state of the port target domain list membership. Managers specify a new port target domain membership, or modify an existing one using portTargetDomainListMembershipWorkBuf. The new membership becomes effective and remains unchanged, across system reboots, when portGroupAction is set to doUpdate and the updating process succeeds. ')
portTargetDomainListMembershipWorkBuf = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 5, 5, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portTargetDomainListMembershipWorkBuf.setStatus('mandatory')
if mibBuilder.loadTexts: portTargetDomainListMembershipWorkBuf.setDescription(' The portTargetDomainListMembership object is used to create, modify, and delete port target domain lists. Managers can update a port target domain membership list as many times as they want using this object. Setting this object to a new value does not change the current membership nor the values stored in mgmt memory until the object portGroupAction is written with doUpdate. At that time the new values will be written to portTargetDomainListMembership and mgmt memory and the target domain changes will take effect. The portTargetDomainListMembership specifies the target domains that a learning domain belongs to. This set of learning domains is called the port target domain list. The portTargetDomainListMembership is expressed using a shorthand that specifies which learning domains belong in the port target domain list. An example of a specification would be : (2-4,6,8) where commas separate learning domains and hyphens are short-hand for specifying a range of numbers.. This example would map the learning domain to the port target domain list consisting of learning_domains 2, 3, 4, 6, and 8. Valid values for learning domains are 1-8. A port target domain list will read back in a form equivalent to the form written. It may not read back exactly as written. ')
lBDomainMembershipTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 5, 6), )
if mibBuilder.loadTexts: lBDomainMembershipTable.setStatus('mandatory')
if mibBuilder.loadTexts: lBDomainMembershipTable.setDescription(' The table for storing the logical bridge domain membership. ')
lBDomainMembershipEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 5, 6, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "lBDomainNumber"))
if mibBuilder.loadTexts: lBDomainMembershipEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lBDomainMembershipEntry.setDescription(' An entry stores information about a logical bridge domain. ')
lBDomainNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 5, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lBDomainNumber.setStatus('mandatory')
if mibBuilder.loadTexts: lBDomainNumber.setDescription(' The logical bridge domain number. It is unique within this table and must be between 1 and 8. ')
lBDomainMembership = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 5, 6, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lBDomainMembership.setStatus('mandatory')
if mibBuilder.loadTexts: lBDomainMembership.setDescription(' This object displays the learning domain numbers which are members of the indexed logical bridge domain in the current box configuration. ')
lBDomainMembershipWorkBuf = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 5, 6, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lBDomainMembershipWorkBuf.setStatus('mandatory')
if mibBuilder.loadTexts: lBDomainMembershipWorkBuf.setDescription(' Managers can specify logical bridge domains as many times as needed without effecting the current box configuration using this object. Setting this object to a new value is stored in a local buffer and the changes are not recorded in the nonvolatile memory. The new value is copied into lBDomainMembership and becomes effective when portGroupAction is set to doUpdate and the updating process successfully upgrades the logical bridge domains. A logical bridge domain is expressed using a shorthand that says what learning domains are members of it. An examples of a specification is: (1,3,5) (2-4) Commas separate items in a list of learning domains. Hyphens are short-hand for specifying a range of numbers. Learning domain numbers are specified in decimal. A logical bridge domain will read back in a form equivalent to the form written. It may not read back exactly as written. Without a management set, the default logical bridge domain (i.e., domain number 1) contains all learning domains. The other logical bridge domains are empty sets. A logical bridge domain is created by specifying what learning domains are members of it. Specified learning domains are deleted from the old logical bridge domain and added to the new logical bridge domain. Deletion and addition of the learning domains are atomic across the SNMP messages. Learning domains left out in the specification will automatically join the default logical bridge domain. Reconfiguring logical bridge domains is an expensive operation. Therefore the manager should not change the configuration very often. ')
portGroupAction = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 5, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("none", 1), ("doUpdate", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portGroupAction.setStatus('mandatory')
if mibBuilder.loadTexts: portGroupAction.setDescription(" To initiate a configuration upgrade of a box, set this object. The tables updated with this set operation are: portGroupMembershipTable, learningDomainMembershipTable, portTargetDomainListMembershipTable, lBDomainMembershipTable The handler checks the consistency of the manager's configuraton of the box specified in the tables' working buffer. If no configuraton error is detected, the box starts the reconfiguration process and the working buffers are copied into their corresponding variables. The changes will survive after a system crash. Reading this object always returns the value none(1). ")
portGroupActionStatus = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 5, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("success", 1), ("failedDueToOthers", 2), ("failedDueToPGSpec", 3), ("failedDueToLDSpec", 4), ("failedDueToTLDSpec", 5), ("failedDueToLBDSpec", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portGroupActionStatus.setStatus('mandatory')
if mibBuilder.loadTexts: portGroupActionStatus.setDescription(' This object shows the result of the most recent setting of portGroupAction to doUpdate(2). ')
trafficGroupMembershipTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 5, 9), )
if mibBuilder.loadTexts: trafficGroupMembershipTable.setStatus('mandatory')
if mibBuilder.loadTexts: trafficGroupMembershipTable.setDescription(' This table allows the user to add and delete physical ports to traffic groups. There can be from 1 to 16 traffic groups. A traffic group is a collection of physical ports that is used to allow single path traffic coming in on physical ports to be transmitted out a single management assigned member port of a hunt group. This is used to restrict single path traffic from being multipathed in a hunt group. Every physical port must belong to one of 16 traffic groups. Traffic group 1 is the default traffic group. All ports that do not belong to traffic groups 2-16 belong to the default traffic group. ')
trafficGroupMembershipEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 5, 9, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "trafficGroupNumber"))
if mibBuilder.loadTexts: trafficGroupMembershipEntry.setStatus('mandatory')
if mibBuilder.loadTexts: trafficGroupMembershipEntry.setDescription(' An entry that stores information about a traffic group. ')
trafficGroupNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 5, 9, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trafficGroupNumber.setStatus('mandatory')
if mibBuilder.loadTexts: trafficGroupNumber.setDescription(' The index for the traffic group membership is a traffic group number. Traffic group numbers are in the range 1-16. Traffic group 1 is the default traffic group. ')
trafficGroupMembership = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 5, 9, 1, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trafficGroupMembership.setStatus('mandatory')
if mibBuilder.loadTexts: trafficGroupMembership.setDescription(' The trafficGroupMembership object allows the user to add and delete physical ports from traffic groups. Because a physical port can only belong to one traffic group, the last assignment of a physical port to a traffic group will determine the traffic group in which the physical port is a member. There is a default traffic group which physical ports belong to until management changes the assignments of physical ports to traffic groups. If a physical port is removed from a traffic group, it is placed back into the default traffic group. The default traffic group can not be modified directly. It changes when new traffic groups are added or removed from other traffic groups. The default traffic group is traffic group 1. The trafficGroupMembership is expressed using a shorthand that specifies which physical ports belong in the traffic group. An example of a specification would be : (1,6-9,21) where commas separate physical ports and hyphens are short- hand for specifying a range of numbers. This example would assign physical ports 1,6,7,8,9, and 21 to the specified traffic group. Physical port numbers are specified in decimal. A traffic group will read back in a form equivalent to the form written. It may not read back exactly as written. ')
trafficGroupAttributeTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 5, 10), )
if mibBuilder.loadTexts: trafficGroupAttributeTable.setStatus('mandatory')
if mibBuilder.loadTexts: trafficGroupAttributeTable.setDescription(' This table allows traffic group attributes to be set. ')
trafficGroupAttributeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 5, 10, 1), ).setIndexNames((0, "DEC-ELAN-MIB", "trafficGroupNum"), (0, "DEC-ELAN-MIB", "trafficGroupHgNumber"))
if mibBuilder.loadTexts: trafficGroupAttributeEntry.setStatus('mandatory')
if mibBuilder.loadTexts: trafficGroupAttributeEntry.setDescription(' An entry that stores traffic group attributes. ')
trafficGroupNum = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 5, 10, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trafficGroupNum.setStatus('mandatory')
if mibBuilder.loadTexts: trafficGroupNum.setDescription(' One of two indexes into the trafficGroupAttributeTable. It is within the range 1-16. ')
trafficGroupHgNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 5, 10, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trafficGroupHgNumber.setStatus('mandatory')
if mibBuilder.loadTexts: trafficGroupHgNumber.setDescription(' Second of two indexes into the trafficGroupAttributeTable. This is the hunt group that all ports in the traffic group are assigned to and is in the range 37-64. ')
trafficGroupHgMember = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 5, 10, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trafficGroupHgMember.setStatus('mandatory')
if mibBuilder.loadTexts: trafficGroupHgMember.setDescription(' The trafficGroupHgMember is a number in the range 1-16 that maps to a member of the hunt group specified by trafficGroupHgNumber. trafficGroupHgMember 1 maps to the lowest numbered member of the hunt group, trafficGroupHgMember 2 maps to the second lowest numbered member of the hunt group, etc. If the trafficGroupHgMember is greater then the number of members in the hunt group, then it wraps. For example : Given that traffic groups 1,2,3,4,5 all have physical ports. hunt group 37 = {3,6,8} For hunt group 37 : traffic group 1 set to member number 1 traffic group 2 set to member number 2 traffic group 3 set to member number 3 traffic group 4 set to member number 4 traffic group 5 set to member number 5 then trafficGroupHgMember 1 maps to port 3 trafficGroupHgMember 2 maps to port 6 trafficGroupHgMember 3 maps to port 8 trafficGroupHgMember 4 maps to port 3 trafficGroupHgMember 5 maps to port 6 ')
trafficGroupCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 5, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("fixed", 1), ("reconfig", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trafficGroupCategory.setStatus('mandatory')
if mibBuilder.loadTexts: trafficGroupCategory.setDescription(' The trafficGroupCatagory is defined as follows : fixed ----- fixed means that traffic is to stay on the same port until the port fails. For this value, the member number is ignored completely. The first physical port that comes up in the hunt group will be assigned the traffic. If the port fails the lowest numbered remaining member of the hunt group will be assigned the traffic. If the traffic category is fixed, sequential delivery of packets is almost guaranteed. reconfig -------- reconfig means that the traffic group may be moved from one hunt group member to another whenever any port joins or leaves the hunt group. If possible, the traffic group must use the hunt group member whose trafficGroupHgMember is configured. If the traffic category is reconfig, sequential delivery of packets is guaranteed, except when members enter or leave the hunt group. ')
xglTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 7, 1), )
if mibBuilder.loadTexts: xglTable.setStatus('mandatory')
if mibBuilder.loadTexts: xglTable.setDescription('This table contains miscellaneous objects for configuring Fast Ethernet interfaces.')
xglEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 7, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: xglEntry.setStatus('mandatory')
if mibBuilder.loadTexts: xglEntry.setDescription('Data for a particular Fast Ethernet interface. This table may be optionally implemented in such a way as to allow pre-configuration of hardware which has not yet been installed.')
xglCompliantMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 7, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xglCompliantMtu.setStatus('mandatory')
if mibBuilder.loadTexts: xglCompliantMtu.setDescription(' When true, packets with a data unit of size <= 1500 bytes are sent and received. When false, packets with a data unit of size <= 1535 bytes are sent and received. ')
xglDisableIcmpErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 7, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xglDisableIcmpErrors.setStatus('mandatory')
if mibBuilder.loadTexts: xglDisableIcmpErrors.setDescription(' When true(1), ICMP redirect message processing is disabled for the specified port. ')
xglTxErrorsToIcmpFifo = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 7, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xglTxErrorsToIcmpFifo.setStatus('mandatory')
if mibBuilder.loadTexts: xglTxErrorsToIcmpFifo.setDescription(' When true(1), transmit errors are sent to the ICMP FIFO. ')
xglRxErrorsToIcmpFifo = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 7, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xglRxErrorsToIcmpFifo.setStatus('mandatory')
if mibBuilder.loadTexts: xglRxErrorsToIcmpFifo.setDescription(' When true(1), receive errors are sent to the ICMP FIFO. ')
xglEnableAppletalkArpII = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 7, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xglEnableAppletalkArpII.setStatus('mandatory')
if mibBuilder.loadTexts: xglEnableAppletalkArpII.setDescription(' When true(1), enables Appletalk ARP II support. ')
xglEnableRawIPX = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 15, 3, 3, 3, 7, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xglEnableRawIPX.setStatus('mandatory')
if mibBuilder.loadTexts: xglEnableRawIPX.setDescription(' When true(1), enables raw IPX support. ')
mibBuilder.exportSymbols("DEC-ELAN-MIB", trafficGroupAttributeEntry=trafficGroupAttributeEntry, ipSwitchEnable=ipSwitchEnable, gigaStpPortIfIndex=gigaStpPortIfIndex, aglsonetLine=aglsonetLine, ebrIfDeviceFramesLost=ebrIfDeviceFramesLost, ebrTwoSnapProtoEntry=ebrTwoSnapProtoEntry, eMACRingPurgeErrors=eMACRingPurgeErrors, aglInterfacePhyType=aglInterfacePhyType, xglTable=xglTable, ebrIfUnknownDAReceived=ebrIfUnknownDAReceived, slotNumber=slotNumber, hostSlotTable=hostSlotTable, esysFRUIndex=esysFRUIndex, batteryUsing=batteryUsing, ebrNportSapReceivePort=ebrNportSapReceivePort, aglInterfaceIndex=aglInterfaceIndex, aglsonetObjectsPath=aglsonetObjectsPath, floodQuotaQualifier=floodQuotaQualifier, esysTrapEntry=esysTrapEntry, ebrMultiEnetProtoEntry=ebrMultiEnetProtoEntry, ebrNportDAReceivePort=ebrNportDAReceivePort, ebrStat=ebrStat, ebrSpanningTreeModeChanges=ebrSpanningTreeModeChanges, ebrBadHelloLimit=ebrBadHelloLimit, copyAction=copyAction, trafficGroupMembership=trafficGroupMembership, portGroupMembership=portGroupMembership, ebrMultiSwTable=ebrMultiSwTable, xglTxErrorsToIcmpFifo=xglTxErrorsToIcmpFifo, aglsonetLineCurrentCVs=aglsonetLineCurrentCVs, ebrIfEntry=ebrIfEntry, ebrRateLimiting=ebrRateLimiting, ebrNTPStatus=ebrNTPStatus, aglVCConnectionTableEntry=aglVCConnectionTableEntry, aglatmInterfaceTrafficEnforcementType6=aglatmInterfaceTrafficEnforcementType6, aglatmInterfaceSonetTCEntry=aglatmInterfaceSonetTCEntry, ledTable=ledTable, arpBroadcastReceived=arpBroadcastReceived, eMACFrameStripMode=eMACFrameStripMode, ipRangeStartAddr=ipRangeStartAddr, learningQuota=learningQuota, eifEntry=eifEntry, eMACRingPurgerState=eMACRingPurgerState, ebrCurrProtocolDBEntries=ebrCurrProtocolDBEntries, ebrIfSpForwardDelayTimer=ebrIfSpForwardDelayTimer, portTargetDomainListMembershipEntry=portTargetDomainListMembershipEntry, ebrMaxForwardingDBEntries=ebrMaxForwardingDBEntries, slotIndex=slotIndex, batteryCharge=batteryCharge, ebrCurrNVForwardingDBEntries=ebrCurrNVForwardingDBEntries, fppnSlotNumber=fppnSlotNumber, ebrManualFilterSwitch=ebrManualFilterSwitch, eMACDuplicateAddressTestFailures=eMACDuplicateAddressTestFailures, ebrRemoveMgmtAddress=ebrRemoveMgmtAddress, aglatmInterfaceIlmiVpiVci=aglatmInterfaceIlmiVpiVci, aglatmInterfaceIndex=aglatmInterfaceIndex, aglatmMIB=aglatmMIB, lBDomainMembership=lBDomainMembership, ebrTwoSnapIndex=ebrTwoSnapIndex, ebrNportMatrixNameRowStatus=ebrNportMatrixNameRowStatus, ebrTimeSinceLastHello=ebrTimeSinceLastHello, batteryStatus=batteryStatus, eFDXEnable=eFDXEnable, floodHogs=floodHogs, ebrNportFloodMatrixRowEntry=ebrNportFloodMatrixRowEntry, ebrIfMultiBytesSent=ebrIfMultiBytesSent, gigaversion1=gigaversion1, portGroupPortTypeWorkBuf=portGroupPortTypeWorkBuf, gigaBridge=gigaBridge, ebrNportSapFilterCharacteristicsTable=ebrNportSapFilterCharacteristicsTable, ebrMultiEnetStatus=ebrMultiEnetStatus, floodPacketsFiltered=floodPacketsFiltered, eMACRingInitializationsReceived=eMACRingInitializationsReceived, copyStatus=copyStatus, ebrNportSnapProtoTable=ebrNportSnapProtoTable, mgmtMemoryTable=mgmtMemoryTable, ebrIfFddiIpDontFragment=ebrIfFddiIpDontFragment, ebrNportDANameStatus=ebrNportDANameStatus, ebrTwoEnetProtoType=ebrTwoEnetProtoType, ebrIfFddiIpDatagramsFragmented=ebrIfFddiIpDatagramsFragmented, mPortMACIndex=mPortMACIndex, ebrBadHelloResetTimer=ebrBadHelloResetTimer, aglsonetMedium=aglsonetMedium, efddiMAC=efddiMAC, portGroupActionStatus=portGroupActionStatus, eMACTransmitUnderruns=eMACTransmitUnderruns, ebrNportSvcAddress=ebrNportSvcAddress, ipRangeEndAddr=ipRangeEndAddr, ebrNportSvcStatus=ebrNportSvcStatus, ebrIfEtherTable=ebrIfEtherTable, eauthTrapUserStatus=eauthTrapUserStatus, aglatmInterfaceDs3PlcpAlarmState=aglatmInterfaceDs3PlcpAlarmState, ebrIfEthCollisionPresenceTestSwitch=ebrIfEthCollisionPresenceTestSwitch, ebrTwoSapProtoTable=ebrTwoSapProtoTable, ePORTRejectReason=ePORTRejectReason, aglatmMIBObjects=aglatmMIBObjects, arpRequestRetries=arpRequestRetries, slotTable=slotTable, communityStringDelimiter=communityStringDelimiter, ipDynamicPorts=ipDynamicPorts, eMACUpstreamNbrDuplAddressFlag=eMACUpstreamNbrDuplAddressFlag, portGroupStatusPortType=portGroupStatusPortType, ebrSpan=ebrSpan, eMACRingPurgerEnable=eMACRingPurgerEnable, cutThrough=cutThrough, ebrNportSwTable=ebrNportSwTable, efddi=efddi, efddiSMTTable=efddiSMTTable, ebrNportDefaultMatrixFppnValue=ebrNportDefaultMatrixFppnValue, ebrNportSourceAddress=ebrNportSourceAddress, ebrTopologyChangeTimer=ebrTopologyChangeTimer, ebrNportSnapSinglePath=ebrNportSnapSinglePath, ebrNportSapProtoEntry=ebrNportSapProtoEntry, ebrNportDAAddress=ebrNportDAAddress, esysUnsolicitedResets=esysUnsolicitedResets, ebrNportSapValue=ebrNportSapValue, portTargetDomainListIndex=portTargetDomainListIndex, rightPowerOutputPower=rightPowerOutputPower, xglCompliantMtu=xglCompliantMtu, xacInDiscardMulticast=xacInDiscardMulticast, snmpDuplicateDiscardInterval=snmpDuplicateDiscardInterval, ebrMultiSwProtoSnapOther=ebrMultiSwProtoSnapOther, ebrTwoSnapStatus=ebrTwoSnapStatus, aglsonetPathCurrentTable=aglsonetPathCurrentTable, esysFRUState=esysFRUState, esystem=esystem, ebrIfFramesProtocolFiltered=ebrIfFramesProtocolFiltered, esysFRUSlot=esysFRUSlot, ebrNportMatrixNameEntry=ebrNportMatrixNameEntry, aglsonetMediumLineType=aglsonetMediumLineType, aglatmInterfaceTrafficEnforcementType7=aglatmInterfaceTrafficEnforcementType7, floodLocalCopyPacketsDiscarded=floodLocalCopyPacketsDiscarded, ePORTTNEExpRejects=ePORTTNEExpRejects, esysMgmtResets=esysMgmtResets, esysStatus=esysStatus, arpStatisticalIfIndex=arpStatisticalIfIndex, ebrBestRootAge=ebrBestRootAge, ebrTwoSnapProtoTable=ebrTwoSnapProtoTable, portGroupFppnPortTypeWorkBuf=portGroupFppnPortTypeWorkBuf, ebrTwoProtoEnetFilterOther=ebrTwoProtoEnetFilterOther, ebrTwoProtoSnapFilterOther=ebrTwoProtoSnapFilterOther, communityString=communityString, ebrNportSnapNameTable=ebrNportSnapNameTable, ebrNportMatrixNameRowTable=ebrNportMatrixNameRowTable, ebrNportMatrixFppnRowEntry=ebrNportMatrixFppnRowEntry, aglsonetPathCurrentStatus=aglsonetPathCurrentStatus, ebrTwoEnetProtoStatus=ebrTwoEnetProtoStatus, cutThroughTable=cutThroughTable, clockCard=clockCard, aglatmInterfaceMaxActiveVciBits=aglatmInterfaceMaxActiveVciBits, ebrNportSapAllowedToGoTo=ebrNportSapAllowedToGoTo, aglVCConnectionPortBVci=aglVCConnectionPortBVci, cutThroughInbound=cutThroughInbound, ebrLB100BeingPolled=ebrLB100BeingPolled, aglInterfaceATMTable=aglInterfaceATMTable, aglInterfaceDS3E3Plcp=aglInterfaceDS3E3Plcp, ebrMaxProtocolDBEntries=ebrMaxProtocolDBEntries, eauthReadOnlyUserMask=eauthReadOnlyUserMask, minimumGIGAswitchMIBVersionSupported=minimumGIGAswitchMIBVersionSupported, xglEntry=xglEntry, ebrIfLinkBrokenReason=ebrIfLinkBrokenReason, hostSlotEntry=hostSlotEntry, aglVCConnectionTrafficShaperPeakRate=aglVCConnectionTrafficShaperPeakRate, efddiPORTEntry=efddiPORTEntry, ebrTwoPortPortNum=ebrTwoPortPortNum, aglVCConnectionOperStatus=aglVCConnectionOperStatus, aglatmInterfaceSonetTCTable=aglatmInterfaceSonetTCTable, esysNvramFailed=esysNvramFailed, ebrIfTable=ebrIfTable, aglInterfaceATMIndex=aglInterfaceATMIndex, filterByBitmapValue=filterByBitmapValue, ePORTElasticityBufferErrors=ePORTElasticityBufferErrors, ebrNportSvc=ebrNportSvc, slot=slot, ebrTwoPortStaticEntry=ebrTwoPortStaticEntry, aglatmInterfaceConfVpcs=aglatmInterfaceConfVpcs, aglatmInterfaceTrafficEnforcementType3=aglatmInterfaceTrafficEnforcementType3, aglInterfaceDS3E3Entry=aglInterfaceDS3E3Entry, ePORTPMDType=ePORTPMDType, ebrIfFddiTable=ebrIfFddiTable, aglInterfaceSonetIndex=aglInterfaceSonetIndex, ebrNportSnapSvcSnapValue=ebrNportSnapSvcSnapValue, esysChar=esysChar, portTargetDomainListMembershipTable=portTargetDomainListMembershipTable, aglsonetMediumEntry=aglsonetMediumEntry, hostSlotIndex=hostSlotIndex, portGroupBridgePort=portGroupBridgePort, ebrTwoProtoFilt=ebrTwoProtoFilt, aglVCConnectionTable=aglVCConnectionTable, aglVCConnectionTrafficShaperAvgRate=aglVCConnectionTrafficShaperAvgRate, ebrMultiPortPortNum=ebrMultiPortPortNum, aglsonetSectionCurrentSEFSs=aglsonetSectionCurrentSEFSs, eauthReadWriteUserEntry=eauthReadWriteUserEntry, arpTimingMechanism=arpTimingMechanism, ema=ema, trafficGroupHgMember=trafficGroupHgMember, mgmtMemoryIndex=mgmtMemoryIndex, portGroupFppnMembership=portGroupFppnMembership, eauthReadOnlyUserAddr=eauthReadOnlyUserAddr, aglInterfaceATMScrambeStatus=aglInterfaceATMScrambeStatus, ledDescr=ledDescr, leftPowerOutputPower=leftPowerOutputPower, portGroupFppnMembershipWorkBuf=portGroupFppnMembershipWorkBuf, fppnEntry=fppnEntry, aglDS3E3=aglDS3E3, ebrIfEthFramingError=ebrIfEthFramingError, esysPowerups=esysPowerups, aglVCConnectionPortB=aglVCConnectionPortB, ebrIfSpPossibleLoopFlag=ebrIfSpPossibleLoopFlag, ebrIfEthTransmitMultipleCollisions=ebrIfEthTransmitMultipleCollisions, aglatmInterfaceConfTable=aglatmInterfaceConfTable, ePORTPHYState=ePORTPHYState, maximumGIGAswitchMIBVersionSupported=maximumGIGAswitchMIBVersionSupported, ebrNportFloodMatrixRowTable=ebrNportFloodMatrixRowTable, trafficGroupHgNumber=trafficGroupHgNumber, eauthTrapCommunity=eauthTrapCommunity, ebrIfEthIndex=ebrIfEthIndex, ipPrimaryPorts=ipPrimaryPorts, ebrNportStaticSAFilterCharacteristicsTable=ebrNportStaticSAFilterCharacteristicsTable, ebrNportSnapReceivePort=ebrNportSnapReceivePort, transferStatus=transferStatus, bridges=bridges, ebrNportDANameTable=ebrNportDANameTable, ebrMultiPortStatus=ebrMultiPortStatus, eFDXMACIndex=eFDXMACIndex, pscFwImageStatus=pscFwImageStatus, aglInterfaceTrafficRateGranularity=aglInterfaceTrafficRateGranularity, eauthReadOnlyUserEntry=eauthReadOnlyUserEntry, ebrLB100SpanningTreeVer=ebrLB100SpanningTreeVer, learningDomainNumber=learningDomainNumber, learningQuotaNumber=learningQuotaNumber, ebrIfDeviceBytesReceived=ebrIfDeviceBytesReceived, fppnTable=fppnTable, ebrNportMatrixAllowedToGoTo=ebrNportMatrixAllowedToGoTo, ebrIfMultiFramesFiltered=ebrIfMultiFramesFiltered, eauthTrapUserEntry=eauthTrapUserEntry, ebrTwoSapProtoEntry=ebrTwoSapProtoEntry, eauth=eauth, cabinetTemperature=cabinetTemperature, ebrNportSnapNameSnap=ebrNportSnapNameSnap, aglatmInterfaceDs3PlcpUASs=aglatmInterfaceDs3PlcpUASs, gigaStpDemandLearningEnable=gigaStpDemandLearningEnable, ePORTSMTIndex=ePORTSMTIndex, floodBytesSent=floodBytesSent, ebrInterfaces=ebrInterfaces, ebrTwoSapStatus=ebrTwoSapStatus, eSMTIndex=eSMTIndex, mgmtMemoryAction=mgmtMemoryAction, ebrMultiFiltSw=ebrMultiFiltSw, aglInterfaceSonetTable=aglInterfaceSonetTable, esysTrapAddressTable=esysTrapAddressTable, trafficGroupNum=trafficGroupNum, ebrNportSapProtoTable=ebrNportSapProtoTable, ebrNportDADisp=ebrNportDADisp)
mibBuilder.exportSymbols("DEC-ELAN-MIB", ipDynamicEnabledPorts=ipDynamicEnabledPorts, ebrMaxNVForwardingDBEntries=ebrMaxNVForwardingDBEntries, ebrLB100PollTime=ebrLB100PollTime, aglsonetPathCurrentSESs=aglsonetPathCurrentSESs, ebrNTPEntry=ebrNTPEntry, portGroupStatusTable=portGroupStatusTable, ebrTimeSinceForwardingDBPurged=ebrTimeSinceForwardingDBPurged, learningQuotaTable=learningQuotaTable, aglatmInterfaceMaxActiveVpiBits=aglatmInterfaceMaxActiveVpiBits, eMACDuplicateTokensDetected=eMACDuplicateTokensDetected, aglsonetLineCurrentTable=aglsonetLineCurrentTable, efddiPORTTable=efddiPORTTable, ebrIfFramesAddrFiltered=ebrIfFramesAddrFiltered, dec=dec, ebrIfEthCollisionTestFailed=ebrIfEthCollisionTestFailed, trafficGroupAttributeTable=trafficGroupAttributeTable, portGroupFppnMembershipTable=portGroupFppnMembershipTable, ebrNportFloodMatrixAllowedToGoTo=ebrNportFloodMatrixAllowedToGoTo, ebrRateLimit=ebrRateLimit, aglConfig=aglConfig, ebrRateLimitPort=ebrRateLimitPort, ebrIfFddiEntry=ebrIfFddiEntry, eauthReadWriteCommunity=eauthReadWriteCommunity, ebrLB100ResponseTimeout=ebrLB100ResponseTimeout, eauthReadWriteUserMask=eauthReadWriteUserMask, transferFileName=transferFileName, ebrIfEthPhysicalMediumType=ebrIfEthPhysicalMediumType, ebrRateLimitSwitch=ebrRateLimitSwitch, ebrMultiSnapStatus=ebrMultiSnapStatus, ebrIfEthLengthError=ebrIfEthLengthError, floodQuotaClass=floodQuotaClass, eifOversizeFrames=eifOversizeFrames, ebrMultiPortAddress=ebrMultiPortAddress, eifReceiveOverrun=eifReceiveOverrun, gigaStpPortTable=gigaStpPortTable, ebrNportDANameDisp=ebrNportDANameDisp, cutThroughFppnInbound=cutThroughFppnInbound, led=led, ebrNportStaticSAFilterCharacteristicsEntry=ebrNportStaticSAFilterCharacteristicsEntry, learningDomainMembershipWorkBuf=learningDomainMembershipWorkBuf, ledTableEntry=ledTableEntry, ledCount=ledCount, ebrNportStaticDAFilterCharacteristicsEntry=ebrNportStaticDAFilterCharacteristicsEntry, transferAction=transferAction, eFDXSMTIndex=eFDXSMTIndex, arpFramesDiscarded=arpFramesDiscarded, aglatmInterfaceMaxVpcs=aglatmInterfaceMaxVpcs, ebrNportSAName=ebrNportSAName, aglVCConnectionPortAVpi=aglVCConnectionPortAVpi, ledSlotIndex=ledSlotIndex, ebrNportFloodMatrixFppnValue=ebrNportFloodMatrixFppnValue, efddiFDX=efddiFDX, ebrNportDAMatrixName=ebrNportDAMatrixName, esysRomVersion=esysRomVersion, ebrMultiEnetProtoTable=ebrMultiEnetProtoTable, floodTable=floodTable, ebrNportMatrixReceivePort=ebrNportMatrixReceivePort, gigaSnmpDebug=gigaSnmpDebug, ebrNportDestinationAddress=ebrNportDestinationAddress, ebrMultiProtoFilt=ebrMultiProtoFilt, filterByReferencedExpression=filterByReferencedExpression, learningDomainMembership=learningDomainMembership, ebrNportSwEntry=ebrNportSwEntry, portGroupMembershipEntry=portGroupMembershipEntry, ebrNportStaticDATable=ebrNportStaticDATable, ebrNportSapSvc=ebrNportSapSvc, ebrDeviceFramesLost=ebrDeviceFramesLost, ebrNportSapMatrixName=ebrNportSapMatrixName, aglsonetPathCurrentWidth=aglsonetPathCurrentWidth, xacInDiscardCounters=xacInDiscardCounters, ebrNportFloodMatrixValue=ebrNportFloodMatrixValue, aglsonetSectionCurrentIfIndex=aglsonetSectionCurrentIfIndex, aglatmInterfaceTrafficEnforcementType4=aglatmInterfaceTrafficEnforcementType4, arpTimeoutInSeconds=arpTimeoutInSeconds, esysTrapAddress=esysTrapAddress, ePORTIndex=ePORTIndex, ebrMultiEnetReceivePort=ebrMultiEnetReceivePort, hostIP=hostIP, lBDomainNumber=lBDomainNumber, ebrRateLimitCounterEntry=ebrRateLimitCounterEntry, ebrMultiSnapProtoEntry=ebrMultiSnapProtoEntry, ebrNportDANameDA=ebrNportDANameDA, ebrNportDAName=ebrNportDAName, aglsonetLineCurrentEntry=aglsonetLineCurrentEntry, ebrNportSANameTable=ebrNportSANameTable, ebrNportDefaultMatrixValue=ebrNportDefaultMatrixValue, eifBadFramesReceived=eifBadFramesReceived, agl=agl, ebrIfEthCarrierLoss=ebrIfEthCarrierLoss, efddiFDXEntry=efddiFDXEntry, ebrNportSnapSvcEntry=ebrNportSnapSvcEntry, ebrNportSwAllowedToGoTo=ebrNportSwAllowedToGoTo, cutThroughFppnTable=cutThroughFppnTable, mPortSMTIndex=mPortSMTIndex, mopDestination=mopDestination, aglInterfaceATMTableEntry=aglInterfaceATMTableEntry, ebrNportSnapFilterCharacteristicsSnapValue=ebrNportSnapFilterCharacteristicsSnapValue, slotCardFwRev=slotCardFwRev, ebrNportSapSvcStatus=ebrNportSapSvcStatus, ebrMultiSnapProtoTable=ebrMultiSnapProtoTable, ebrNportDefaultMatrixRowEntry=ebrNportDefaultMatrixRowEntry, ebrNTPtype=ebrNTPtype, ebrTwoPortStatus=ebrTwoPortStatus, ebrNportSapSinglePath=ebrNportSapSinglePath, ebrNportPortNumAddress=ebrNportPortNumAddress, ebrNportSnapStatus=ebrNportSnapStatus, ebrMultiSwEntry=ebrMultiSwEntry, esysConcConfig=esysConcConfig, aglInterfaceATMOAMStatus=aglInterfaceATMOAMStatus, mgmtMemoryData=mgmtMemoryData, ebrNportSAReceivePort=ebrNportSAReceivePort, eauthReadOnlyCommunity=eauthReadOnlyCommunity, ebrMultiSapProtoTable=ebrMultiSapProtoTable, ipDynamicPrimaryPorts=ipDynamicPrimaryPorts, portGroupStatusEntry=portGroupStatusEntry, esysInitSwitch=esysInitSwitch, portGroupMembershipTable=portGroupMembershipTable, ebrTwoEnetProtoEntry=ebrTwoEnetProtoEntry, gigaUpgradeSoftware=gigaUpgradeSoftware, ebrNportFppnManualFilter=ebrNportFppnManualFilter, aglVCConnectionTrafficType=aglVCConnectionTrafficType, ebrIfMultiDeviceBytesSent=ebrIfMultiDeviceBytesSent, ebrRemoveMgmtProto=ebrRemoveMgmtProto, aglInterfaceDS3E3Table=aglInterfaceDS3E3Table, flooding=flooding, aglVCConnectionPortAVci=aglVCConnectionPortAVci, gigaStpPortEntry=gigaStpPortEntry, ebrIfSpanTable=ebrIfSpanTable, eFDXState=eFDXState, aglatmInterfaceDs3PlcpEntry=aglatmInterfaceDs3PlcpEntry, ebrNportStaticSAEntry=ebrNportStaticSAEntry, esysFRUConfigTable=esysFRUConfigTable, ebrIfMultiDeviceBytesReceived=ebrIfMultiDeviceBytesReceived, ebrMultiPortReceivePort=ebrMultiPortReceivePort, learningDomainMembershipEntry=learningDomainMembershipEntry, ebrNportSAMatrixName=ebrNportSAMatrixName, commitFails=commitFails, aglsonetSectionCurrentESs=aglsonetSectionCurrentESs, aglsonetSection=aglsonetSection, eMACTracesInitiated=eMACTracesInitiated, ebrNportSnapSvcTable=ebrNportSnapSvcTable, ebrMultiSnapAllowedToGoTo=ebrMultiSnapAllowedToGoTo, deleteTransfer=deleteTransfer, battery=battery, fppnIfIndex=fppnIfIndex, rightPowerInputSource=rightPowerInputSource, ebrMultiEnetProtoType=ebrMultiEnetProtoType, aglSonet=aglSonet, keyswitchPosition=keyswitchPosition, aglsonetLineCurrentStatus=aglsonetLineCurrentStatus, ebrNportSnapFilterCharacteristicsTable=ebrNportSnapFilterCharacteristicsTable, gigaswitch=gigaswitch, ebrNportSnapName=ebrNportSnapName, ebrNportSapDisp=ebrNportSapDisp, aglatmInterfaceSonetTCOCDEvents=aglatmInterfaceSonetTCOCDEvents, aglsonetMediumLineCoding=aglsonetMediumLineCoding, portTargetDomainListMembershipWorkBuf=portTargetDomainListMembershipWorkBuf, arpControlParams=arpControlParams, aglsonetPathCurrentIfIndex=aglsonetPathCurrentIfIndex, ebrNportPortNumEntry=ebrNportPortNumEntry, aglVCConnectionTableEntryStatus=aglVCConnectionTableEntryStatus, xacInDiscardUnknownDAUCast=xacInDiscardUnknownDAUCast, ebrMultiPortStaticTable=ebrMultiPortStaticTable, aglInterfaceSonetTiming=aglInterfaceSonetTiming, ebrNportStaticDAFilterCharacteristicsTable=ebrNportStaticDAFilterCharacteristicsTable, ebrNportMatrixName=ebrNportMatrixName, aglatmInterfaceMaxVccs=aglatmInterfaceMaxVccs, eSMTStationType=eSMTStationType, ebrNportDAStatus=ebrNportDAStatus, eauthReadWriteUserAddr=eauthReadWriteUserAddr, copyToSlot=copyToSlot, lBDomainMembershipWorkBuf=lBDomainMembershipWorkBuf, ebrMultiPortAllowedToGoTo=ebrMultiPortAllowedToGoTo, portGroupFppnMembershipEntry=portGroupFppnMembershipEntry, aglInterfaceSonetEntry=aglInterfaceSonetEntry, ebrIfPortRestarts=ebrIfPortRestarts, ebrNportMatrixFppnReceivePort=ebrNportMatrixFppnReceivePort, ebrNportDAAllowedToGoTo=ebrNportDAAllowedToGoTo, floodGeezers=floodGeezers, arpStatisticalCounters=arpStatisticalCounters, ipStaticPorts=ipStaticPorts, floodBytesPurged=floodBytesPurged, gigaXglEthernetGroup=gigaXglEthernetGroup, efddiMACEntry=efddiMACEntry, aglatmInterfaceTrafficEnforcementType5=aglatmInterfaceTrafficEnforcementType5, transferSize=transferSize, eauthTrapUserAddr=eauthTrapUserAddr, ebrNportSapSvcEntry=ebrNportSapSvcEntry, leftFanStatus=leftFanStatus, ledEntry=ledEntry, xglRxErrorsToIcmpFifo=xglRxErrorsToIcmpFifo, translationTableParams=translationTableParams, ebr802SpanningTreeVer=ebr802SpanningTreeVer, lineCard=lineCard, ipSwitchPortsTable=ipSwitchPortsTable, portGroupFppnPortOperStatus=portGroupFppnPortOperStatus, lBDomainMembershipTable=lBDomainMembershipTable, cutThroughBridgePort=cutThroughBridgePort, batteryTest=batteryTest, ebrMultiSapAllowedToGoTo=ebrMultiSapAllowedToGoTo, aglVCConnectionAALType=aglVCConnectionAALType, ebrIfSpTopologyChangeAckFlag=ebrIfSpTopologyChangeAckFlag, ebrMultiSwIndex=ebrMultiSwIndex, ebrNportNamedDefaultMatrix=ebrNportNamedDefaultMatrix, ebrNportFppnPortNum=ebrNportFppnPortNum, floodEntry=floodEntry, pscFwRev=pscFwRev, leftPowerStatus=leftPowerStatus, ebrNportSapName=ebrNportSapName, xacInDiscardIPForwarding=xacInDiscardIPForwarding, ebrNportSapSvcSapValue=ebrNportSapSvcSapValue, cutThroughFppnEntry=cutThroughFppnEntry, ebrNportSnapSvcStatus=ebrNportSnapSvcStatus, esysUpdateSwitch=esysUpdateSwitch, ebrIfBadHelloLimitExceeded=ebrIfBadHelloLimitExceeded, arpFramesFlooded=arpFramesFlooded, aglatmInterfaceDs3PlcpIndex=aglatmInterfaceDs3PlcpIndex, aglatmInterfaceDs3PlcpTable=aglatmInterfaceDs3PlcpTable, aglInterfaceConfEntry=aglInterfaceConfEntry, fan=fan, aglsonetLineCurrentUASs=aglsonetLineCurrentUASs, doTransfer=doTransfer, ebrNportSnapSvc=ebrNportSnapSvc, aglVCConnectionAdminStatus=aglVCConnectionAdminStatus, learningQuotaEntry=learningQuotaEntry, eauthReadOnlyUserStatus=eauthReadOnlyUserStatus, ebrNportStaticSATable=ebrNportStaticSATable, aglsonetPathCurrentCVs=aglsonetPathCurrentCVs, arpRepliesTransmitted=arpRepliesTransmitted, aglatmInterfaceTrafficEnforcementTypes=aglatmInterfaceTrafficEnforcementTypes, portGroupStatusOperStatus=portGroupStatusOperStatus, esysFRUDesc=esysFRUDesc, ebrNportSnapNameStatus=ebrNportSnapNameStatus, ebrNportMatrixFppnRowStatus=ebrNportMatrixFppnRowStatus, cutThroughFppnOutbound=cutThroughFppnOutbound, aglatmInterfaceTrafficEnforcementType2=aglatmInterfaceTrafficEnforcementType2, einterfaces=einterfaces, eSMTTracesReceived=eSMTTracesReceived, ebrTwoSapIndex=ebrTwoSapIndex, ebrIfEtherEntry=ebrIfEtherEntry, aglsonetMediumCircuitIdentifier=aglsonetMediumCircuitIdentifier, trafficGroupMembershipEntry=trafficGroupMembershipEntry, cutThroughOutbound=cutThroughOutbound, eMACRingErrorReason=eMACRingErrorReason, aglatmInterfaceSonetTCAlarmState=aglatmInterfaceSonetTCAlarmState, esysFRUType=esysFRUType, aglInterfaceSonetMode=aglInterfaceSonetMode, floodLosers=floodLosers, decMIBextension=decMIBextension, ebrNportSapFilterCharacteristicsSapValue=ebrNportSapFilterCharacteristicsSapValue, aglsonetMediumTable=aglsonetMediumTable, aglsonetMediumValidIntervals=aglsonetMediumValidIntervals, ebrIfFddiIpIllegalSize=ebrIfFddiIpIllegalSize, ebrNportSAStatus=ebrNportSAStatus)
mibBuilder.exportSymbols("DEC-ELAN-MIB", ebrMultiSapStatus=ebrMultiSapStatus, tftpDestination=tftpDestination, ebrNportSANameSA=ebrNportSANameSA, eauthTrapUserTable=eauthTrapUserTable, powerSupply=powerSupply, ebrIfFddiIpIllegalHeaderLength=ebrIfFddiIpIllegalHeaderLength, leftPowerInputSource=leftPowerInputSource, aglsonetPathCurrentEntry=aglsonetPathCurrentEntry, ebrMultiEnetAllowedToGoTo=ebrMultiEnetAllowedToGoTo, fppnBridgePortNumber=fppnBridgePortNumber, ebrIfDeviceBytesSent=ebrIfDeviceBytesSent, rightPowerStatus=rightPowerStatus, esysLastLoadHost=esysLastLoadHost, aglVCConnectionPortA=aglVCConnectionPortA, ebrNportManualFilter=ebrNportManualFilter, ebrNportStaticDAEntry=ebrNportStaticDAEntry, ebrNportSnapFilterCharacteristicsEntry=ebrNportSnapFilterCharacteristicsEntry, fppn=fppn, ebrNportMatrixFppnRowTable=ebrNportMatrixFppnRowTable, eifIndex=eifIndex, ebrIfDeviceFramesSent=ebrIfDeviceFramesSent, esysFRUConfigEntry=esysFRUConfigEntry, ebrNoFrameInterval=ebrNoFrameInterval, ebrRateLimitAddressFrames=ebrRateLimitAddressFrames, ebrTwoPortStatic=ebrTwoPortStatic, rightFanStatus=rightFanStatus, portGroupFppnPort=portGroupFppnPort, trafficGroupCategory=trafficGroupCategory, ebrNportDefaultMatrixAllowedToGoTo=ebrNportDefaultMatrixAllowedToGoTo, pscHwRev=pscHwRev, aglVCConnectionPortBVpi=aglVCConnectionPortBVpi, eMACRingBeaconingInitiated=eMACRingBeaconingInitiated, trafficGroupMembershipTable=trafficGroupMembershipTable, ebrForwardingDBShortAgingTime=ebrForwardingDBShortAgingTime, mPortTable=mPortTable, ebrIfMultiDeviceFramesReceived=ebrIfMultiDeviceFramesReceived, arpUnicastReceived=arpUnicastReceived, eifTable=eifTable, eifTransmitFramesError=eifTransmitFramesError, ebrNportSnapAllowedToGoTo=ebrNportSnapAllowedToGoTo, eMACIndex=eMACIndex, ebrIfBadBytesReceived=ebrIfBadBytesReceived, ebrNportSnapNameEntry=ebrNportSnapNameEntry, ebrNTP=ebrNTP, ebrNportSAAddress=ebrNportSAAddress, efddiMACTable=efddiMACTable, esysDeviceState=esysDeviceState, ebrIfSpBadHelloCount=ebrIfSpBadHelloCount, ebrNportSANameEntry=ebrNportSANameEntry, ebrIfMultiDeviceFramesSent=ebrIfMultiDeviceFramesSent, ebrNportSANameDisp=ebrNportSANameDisp, ebrNportFloodMatrixReceivePort=ebrNportFloodMatrixReceivePort, scpSlot=scpSlot, aglVCConnectionTrafficShaperPriority=aglVCConnectionTrafficShaperPriority, ebrMgmtHeardPort=ebrMgmtHeardPort, esysFddiPortTrapSwitch=esysFddiPortTrapSwitch, ebrIfSpDesigRootAge=ebrIfSpDesigRootAge, ebrPortTestInterval=ebrPortTestInterval, ebrNportMatrixNameRowEntry=ebrNportMatrixNameRowEntry, aglAtm=aglAtm, efddiSMT=efddiSMT, efddiFDXTable=efddiFDXTable, ebrNportSnapValue=ebrNportSnapValue, lBDomainMembershipEntry=lBDomainMembershipEntry, ePORTConnectionsCompleted=ePORTConnectionsCompleted, ebrTwoEnetProtoTable=ebrTwoEnetProtoTable, xglEnableRawIPX=xglEnableRawIPX, ledProgram=ledProgram, ebrNportSapNameSap=ebrNportSapNameSap, eauth1=eauth1, ebrNportSANameStatus=ebrNportSANameStatus, aglsonetPathCurrentUASs=aglsonetPathCurrentUASs, ebrNportDASvcEntry=ebrNportDASvcEntry, ledSlotTable=ledSlotTable, ebrTwoSapValue=ebrTwoSapValue, eifMgmtSetsAllowedSwitch=eifMgmtSetsAllowedSwitch, ebrMultiPortStatic=ebrMultiPortStatic, eauthReadOnlyUserTable=eauthReadOnlyUserTable, ebrNportDANameEntry=ebrNportDANameEntry, eMACFrameAlignmentErrors=eMACFrameAlignmentErrors, ebrNportSADisp=ebrNportSADisp, eMACRestrictedTokenTimeout=eMACRestrictedTokenTimeout, slotCardHwRev=slotCardHwRev, slotCardStatus=slotCardStatus, sysobjid=sysobjid, floodUnknownUnicastRate=floodUnknownUnicastRate, slotEntry=slotEntry, elanext=elanext, aglsonetMediumIfIndex=aglsonetMediumIfIndex, ebrNportMatrixFppnAllowedToGoTo=ebrNportMatrixFppnAllowedToGoTo, psc=psc, ttSize=ttSize, arpStatisticalTable=arpStatisticalTable, aglsonetLineCurrentESs=aglsonetLineCurrentESs, efddiPORT=efddiPORT, aglsonetMediumType=aglsonetMediumType, ebrNportMatrixNameTable=ebrNportMatrixNameTable, aglInterfaceConfTable=aglInterfaceConfTable, ebrNportSapNameStatus=ebrNportSapNameStatus, ebrMultiSapValue=ebrMultiSapValue, ebrNportMatrixFppnValue=ebrNportMatrixFppnValue, eauthReadWriteUserStatus=eauthReadWriteUserStatus, ebrNTPTable=ebrNTPTable, ebrIfFddiIndex=ebrIfFddiIndex, aglsonetSectionCurrentStatus=aglsonetSectionCurrentStatus, ebrNportMatrixStatus=ebrNportMatrixStatus, ebrNportDASvcTable=ebrNportDASvcTable, ebrNportSapStatus=ebrNportSapStatus, ebridge=ebridge, snmpParameters=snmpParameters, aglatmInterfaceConfVccs=aglatmInterfaceConfVccs, ebrMultiSapProtoEntry=ebrMultiSapProtoEntry, ebrIfFddiUnprocessedErrorPackets=ebrIfFddiUnprocessedErrorPackets, temperatureWarning=temperatureWarning, ebrNportPortNumStatus=ebrNportPortNumStatus, ebrCurrNVProtocolDBEntries=ebrCurrNVProtocolDBEntries, ebrIfSpIndex=ebrIfSpIndex, gigaBox=gigaBox, portTargetDomainListMembership=portTargetDomainListMembership, xglDisableIcmpErrors=xglDisableIcmpErrors, gigaSets=gigaSets, ebrForwardingDBPurgeThreshold=ebrForwardingDBPurgeThreshold, esysGatewayAddress=esysGatewayAddress, aglInterfaceDS3E3Mode=aglInterfaceDS3E3Mode, ebrNportSnapDisp=ebrNportSnapDisp, portGroupFppnPortType=portGroupFppnPortType, ebrRateLimitCounterTable=ebrRateLimitCounterTable, aglsonetMIB=aglsonetMIB, aglatmInterfaceConfEntry=aglatmInterfaceConfEntry, portGroupAction=portGroupAction, aglsonetLineCurrentIfIndex=aglsonetLineCurrentIfIndex, esysDeviceBrokenReason=esysDeviceBrokenReason, ebrTwoSnapValue=ebrTwoSnapValue, pscBackplaneStatus=pscBackplaneStatus, aglsonetSectionCurrentCVs=aglsonetSectionCurrentCVs, aglsonetPathCurrentESs=aglsonetPathCurrentESs, ebrTwoPortAddress=ebrTwoPortAddress, ebrNportmatrixName=ebrNportmatrixName, aglsonetLineCurrentSESs=aglsonetLineCurrentSESs, ebrNportSwManualFilter=ebrNportSwManualFilter, cutThroughFppnPort=cutThroughFppnPort, ebrPortTestPassedThreshold=ebrPortTestPassedThreshold, pscStatus=pscStatus, fppnPortOfThatSlot=fppnPortOfThatSlot, aglatmInterfaceDs3PlcpSEFSs=aglatmInterfaceDs3PlcpSEFSs, mPortEntry=mPortEntry, learningDomainMembershipTable=learningDomainMembershipTable, ebrTopologyChangeFlag=ebrTopologyChangeFlag, portGroupStatusPortNumber=portGroupStatusPortNumber, aglatmInterfaceSonetTCIndex=aglatmInterfaceSonetTCIndex, useTransfer=useTransfer, ebrNportmatrixname=ebrNportmatrixname, aglsonetSectionCurrentTable=aglsonetSectionCurrentTable, ebrChar=ebrChar, ebrIfIndex=ebrIfIndex, mgmtMemoryAvail=mgmtMemoryAvail, aglsonetSectionCurrentEntry=aglsonetSectionCurrentEntry, arpPeriodBetweenRequests=arpPeriodBetweenRequests, ebrMultiSnapReceivePort=ebrMultiSnapReceivePort, aglatmInterfaceSpecific=aglatmInterfaceSpecific, ipSwitchPortsEntry=ipSwitchPortsEntry, ebrTellParentFlag=ebrTellParentFlag, floodLocalCopyPacketsDelivered=floodLocalCopyPacketsDelivered, ebrNportDefaultMatrixReceivePort=ebrNportDefaultMatrixReceivePort, ipIPAddr=ipIPAddr, xglEnableAppletalkArpII=xglEnableAppletalkArpII, eMACLinkState=eMACLinkState, slotCardType=slotCardType, ebrLB100SpanningTreeCompat=ebrLB100SpanningTreeCompat, eMACFCIStripErrors=eMACFCIStripErrors, ebrNportSapSvcTable=ebrNportSapSvcTable, ebrNportSapNameEntry=ebrNportSapNameEntry, ebrTwoProtoSapFilterOther=ebrTwoProtoSapFilterOther, esysResetDefaultsSwitch=esysResetDefaultsSwitch, ebrMaxNVProtocolDBEntries=ebrMaxNVProtocolDBEntries, copyType=copyType, arpAgent=arpAgent, aglatmInterfaceNoTrafficEnforcement=aglatmInterfaceNoTrafficEnforcement, floodPacketsSent=floodPacketsSent, eMACLinkIndex=eMACLinkIndex, ebrNportSnapMatrixName=ebrNportSnapMatrixName, aglVCConnectionTrafficShaperMinGuaranteedRate=aglVCConnectionTrafficShaperMinGuaranteedRate, aglsonetMediumTimeElapsed=aglsonetMediumTimeElapsed, portGroupMembershipWorkBuf=portGroupMembershipWorkBuf, serviceClassAssignments=serviceClassAssignments, eauthReadWriteUserTable=eauthReadWriteUserTable, ebrTwoPortStaticTable=ebrTwoPortStaticTable, aglInterfaceDS3E3Index=aglInterfaceDS3E3Index, portGroupPortType=portGroupPortType, floodMulticastRate=floodMulticastRate, aglsonetObjects=aglsonetObjects, floodSinglePathDiscards=floodSinglePathDiscards, ebrIfDeviceFramesReceived=ebrIfDeviceFramesReceived, trafficGroupNumber=trafficGroupNumber, ebrIfSpanEntry=ebrIfSpanEntry, floodPacketsPurged=floodPacketsPurged, ebrMultiSapReceivePort=ebrMultiSapReceivePort, eMACRingInitializationsInitiated=eMACRingInitializationsInitiated, ebrMultiSwProtoEnetOther=ebrMultiSwProtoEnetOther, ebrNportMatrixValue=ebrNportMatrixValue, aglatmInterfaceTrafficEnforcementType1=aglatmInterfaceTrafficEnforcementType1, esysCounters=esysCounters, ePORTPHYIndex=ePORTPHYIndex, ebrNportSapNameTable=ebrNportSapNameTable, mgmtMemoryEntry=mgmtMemoryEntry, ebrMultiSwProtoSapOther=ebrMultiSwProtoSapOther, portGroupPortOperStatus=portGroupPortOperStatus, ebrInactiveForwardingDBEntries=ebrInactiveForwardingDBEntries, cutThroughEntry=cutThroughEntry, ebrNportDefaultMatrixRowTable=ebrNportDefaultMatrixRowTable, arpStatisticalEntry=arpStatisticalEntry, esysFRURev=esysFRURev, fanSpeed=fanSpeed, aglsonetSectionCurrentSESs=aglsonetSectionCurrentSESs, gigaStp=gigaStp, mPortEnable=mPortEnable, portGroupStatusBridgePort=portGroupStatusBridgePort, efddiSMTEntry=efddiSMTEntry, ledLedIndex=ledLedIndex, ebrNportSAAllowedToGoTo=ebrNportSAAllowedToGoTo, ebrIfMultiBytesReceived=ebrIfMultiBytesReceived, ebrNportNamedFloodMatrix=ebrNportNamedFloodMatrix, ebrNportPortNum=ebrNportPortNum, eMACFrameStatusErrors=eMACFrameStatusErrors, ebrNportPortNumTable=ebrNportPortNumTable, ebrNportSnapProtoEntry=ebrNportSnapProtoEntry, ebrNportSapFilterCharacteristicsEntry=ebrNportSapFilterCharacteristicsEntry, ebrRateLimitProtocolFrames=ebrRateLimitProtocolFrames, ebrCoun=ebrCoun, ledTableIndex=ledTableIndex, ipSwitching=ipSwitching, ebrMultiPortStaticEntry=ebrMultiPortStaticEntry, ebrCurrForwardingDBEntries=ebrCurrForwardingDBEntries, ebrNportSapNameDisp=ebrNportSapNameDisp, ebrNportSwReceivePort=ebrNportSwReceivePort, ebrNportSnapNameDisp=ebrNportSnapNameDisp, aglsonetPath=aglsonetPath, ebrMultiSwManualFilter=ebrMultiSwManualFilter, ebrFragmentationSwitch=ebrFragmentationSwitch, eMACSMTIndex=eMACSMTIndex, ebrIfEthCollisionLimitExceeded=ebrIfEthCollisionLimitExceeded, ebrMultiSnapValue=ebrMultiSnapValue, gigaIP=gigaIP, eFDXOp=eFDXOp, esysIPXSwitch=esysIPXSwitch, gigaStpPortSpanningTreeEnable=gigaStpPortSpanningTreeEnable)

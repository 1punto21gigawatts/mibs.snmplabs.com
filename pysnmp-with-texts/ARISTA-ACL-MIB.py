#
# PySNMP MIB module ARISTA-ACL-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/ARISTA-ACL-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:24:51 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
aristaMibs, = mibBuilder.importSymbols("ARISTA-SMI-MIB", "aristaMibs")
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsIntersection, ValueRangeConstraint, ConstraintsUnion, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsIntersection", "ValueRangeConstraint", "ConstraintsUnion", "ValueSizeConstraint")
InetAddressIPv6, = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressIPv6")
TimeFilter, = mibBuilder.importSymbols("RMON2-MIB", "TimeFilter")
ModuleCompliance, ObjectGroup, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup", "NotificationGroup")
Bits, MibScalar, MibTable, MibTableRow, MibTableColumn, IpAddress, iso, ModuleIdentity, Counter64, Integer32, Unsigned32, ObjectIdentity, Counter32, TimeTicks, Gauge32, NotificationType, MibIdentifier = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "IpAddress", "iso", "ModuleIdentity", "Counter64", "Integer32", "Unsigned32", "ObjectIdentity", "Counter32", "TimeTicks", "Gauge32", "NotificationType", "MibIdentifier")
MacAddress, DisplayString, TextualConvention, TimeStamp, TruthValue = mibBuilder.importSymbols("SNMPv2-TC", "MacAddress", "DisplayString", "TextualConvention", "TimeStamp", "TruthValue")
aristaAclMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 30065, 3, 5))
aristaAclMIB.setRevisions(('2014-08-15 00:00', '2013-02-08 11:00', '2012-06-20 13:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: aristaAclMIB.setRevisionsDescriptions(('Updated postal and e-mail addresses.', 'Revised to correct a syntax error, limit the size of ACL names in INDEXes to match the maximum OID length, and make columns used in INDEXes not-accessible. This last change is not backwards-compatible.', 'Initial version of this MIB.',))
if mibBuilder.loadTexts: aristaAclMIB.setLastUpdated('201408150000Z')
if mibBuilder.loadTexts: aristaAclMIB.setOrganization('Arista Networks, Inc.')
if mibBuilder.loadTexts: aristaAclMIB.setContactInfo('Arista Networks, Inc. Postal: 5453 Great America Parkway Santa Clara, CA 95054 Tel: +1 408 547-5500 E-mail: snmp@arista.com')
if mibBuilder.loadTexts: aristaAclMIB.setDescription('The MIB module for managing Access Control Lists (ACLs) on Arista devices.')
class AristaAclRuleAction(TextualConvention, Integer32):
    description = "Action associated with an ACL rule. If the action has value 'remark(2)', then only the remark field of the ACL rule is meaningful; all other fields are don't-cares."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2))
    namedValues = NamedValues(("permit", 0), ("deny", 1), ("remark", 2))

class AristaAclRangeOperator(TextualConvention, Integer32):
    description = 'Range operator used by an ACL rule.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))
    namedValues = NamedValues(("any", 0), ("eq", 1), ("gt", 2), ("lt", 3), ("neq", 4), ("range", 5))

aristaAcl = MibIdentifier((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1))
aristaAclConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 30065, 3, 5, 2))
aristaIpAcl = MibIdentifier((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 1))
aristaMacAcl = MibIdentifier((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 2))
aristaIpv6Acl = MibIdentifier((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 3))
aristaAclDpSupportFlags = MibScalar((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 4), Bits().clone(namedValues=NamedValues(("acl", 0), ("logging", 1), ("counter", 2), ("routerAcl", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaAclDpSupportFlags.setStatus('current')
if mibBuilder.loadTexts: aristaAclDpSupportFlags.setDescription('This attribute describes the data-plane ACL support matrix. If data-plane ACLs are supported, the acl bit is 1; otherwise, other bits are 0. If data-plane ACLs are supported, the logging, counter and routerAcl bits indicate whether the data plane supports those features for ACLs.')
aristaIpAclTable = MibTable((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 1, 1), )
if mibBuilder.loadTexts: aristaIpAclTable.setStatus('current')
if mibBuilder.loadTexts: aristaIpAclTable.setDescription('A table that contains IP ACLs that are configured on the switch.')
aristaIpAclEntry = MibTableRow((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 1, 1, 1), ).setIndexNames((0, "ARISTA-ACL-MIB", "aristaIpAclName"))
if mibBuilder.loadTexts: aristaIpAclEntry.setStatus('current')
if mibBuilder.loadTexts: aristaIpAclEntry.setDescription('Information about a specific IP ACL that is configured on the switch.')
aristaIpAclName = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 1, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 100)))
if mibBuilder.loadTexts: aristaIpAclName.setStatus('current')
if mibBuilder.loadTexts: aristaIpAclName.setDescription('The name of the IP ACL.')
aristaIpAclReadOnly = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 1, 1, 1, 2), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaIpAclReadOnly.setStatus('current')
if mibBuilder.loadTexts: aristaIpAclReadOnly.setDescription("This attribute has value 'true(1)' if the IP ACL is configured as read-only; otherwise, the value is 'false(2)'.")
aristaIpAclStatsEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 1, 1, 1, 3), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaIpAclStatsEnabled.setStatus('current')
if mibBuilder.loadTexts: aristaIpAclStatsEnabled.setDescription("This attribute has value 'true(1)' if the IP ACL is configured to have per-rule statistics enabled; otherwise, the value is 'false(2)'.")
aristaIpAclCountersIncomplete = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 1, 1, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaIpAclCountersIncomplete.setStatus('current')
if mibBuilder.loadTexts: aristaIpAclCountersIncomplete.setDescription("This attribute has value 'true(1)' if the IP ACL has incomplete counter; otherwise, the value is 'false(2)'.")
aristaIpAclRuleTable = MibTable((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 1, 2), )
if mibBuilder.loadTexts: aristaIpAclRuleTable.setStatus('current')
if mibBuilder.loadTexts: aristaIpAclRuleTable.setDescription('A table that contains IP ACL rules that are configured on the switch.')
aristaIpAclRuleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 1, 2, 1), ).setIndexNames((0, "ARISTA-ACL-MIB", "aristaIpAclName"), (0, "ARISTA-ACL-MIB", "aristaIpAclRuleSeqId"))
if mibBuilder.loadTexts: aristaIpAclRuleEntry.setStatus('current')
if mibBuilder.loadTexts: aristaIpAclRuleEntry.setDescription('Configuration information about a specific IP ACL rule.')
aristaIpAclRuleSeqId = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 1, 2, 1, 1), Unsigned32())
if mibBuilder.loadTexts: aristaIpAclRuleSeqId.setStatus('current')
if mibBuilder.loadTexts: aristaIpAclRuleSeqId.setDescription('This attribute is the sequence ID for this ACL rule.')
aristaIpAclRuleProto = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 1, 2, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaIpAclRuleProto.setStatus('current')
if mibBuilder.loadTexts: aristaIpAclRuleProto.setDescription('This attribute is the IP protocol to be matched by this ACL rule. The value 0 indicates the rule matches any IP protocol.')
aristaIpAclRuleSrc = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 1, 2, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaIpAclRuleSrc.setStatus('current')
if mibBuilder.loadTexts: aristaIpAclRuleSrc.setDescription('This attribute is the IP source address to be matched by this ACL rule, subject to the aristaIpAclRuleSrcMask value.')
aristaIpAclRuleSrcMask = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 1, 2, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaIpAclRuleSrcMask.setStatus('current')
if mibBuilder.loadTexts: aristaIpAclRuleSrcMask.setDescription('This attribute is the IP source-address mask in this ACL rule. For the source address of the packet to match the rule, the bitwise logical-AND of the address and this mask must be equal to the value of aristaIpAclRuleSrc.')
aristaIpAclRuleDest = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 1, 2, 1, 5), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaIpAclRuleDest.setStatus('current')
if mibBuilder.loadTexts: aristaIpAclRuleDest.setDescription('This attribute is the IP destination address to be matched by this ACL rule, subject to the aristaIpAclRuleDestMask value.')
aristaIpAclRuleDestMask = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 1, 2, 1, 6), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaIpAclRuleDestMask.setStatus('current')
if mibBuilder.loadTexts: aristaIpAclRuleDestMask.setDescription('This attribute is the IP destination-address mask in this ACL rule. For the destination address of the packet to match the rule, the bitwise logical-AND of the address and this mask must be equal to the value of aristaIpAclRuleDest.')
aristaIpAclRuleL4PortSrcOper = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 1, 2, 1, 7), AristaAclRangeOperator()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaIpAclRuleL4PortSrcOper.setStatus('current')
if mibBuilder.loadTexts: aristaIpAclRuleL4PortSrcOper.setDescription("This attribute determines TCP/UDP source-port matching behavior in this ACL rule. If this attribute has value 'any(0)', then attribute aristaIpAclRuleL4PortsSrc is ignored.")
aristaIpAclRuleL4PortsSrc = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 1, 2, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 60))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaIpAclRuleL4PortsSrc.setStatus('current')
if mibBuilder.loadTexts: aristaIpAclRuleL4PortsSrc.setDescription('This attribute is a list of TCP/UDP source ports to be matched in this ACL rule. They are represented as decimal strings, separated by spaces. A maximum of 10 ports is allowed. Attribute aristaIpAclRuleL4PortSrcOper determines how the source ports are matched in this ACL rule.')
aristaIpAclRuleL4PortDestOper = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 1, 2, 1, 9), AristaAclRangeOperator()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaIpAclRuleL4PortDestOper.setStatus('current')
if mibBuilder.loadTexts: aristaIpAclRuleL4PortDestOper.setDescription("This attribute determines TCP/UDP destination-port matching behavior in this ACL rule. If this attribute has value 'any(0)', then attribute aristaIpAclRuleL4PortsDest is ignored.")
aristaIpAclRuleL4PortsDest = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 1, 2, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 60))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaIpAclRuleL4PortsDest.setStatus('current')
if mibBuilder.loadTexts: aristaIpAclRuleL4PortsDest.setDescription('This attribute is a list of TCP/UDP destination ports to be matched in this ACL rule. They are represented as decimal strings, separated by spaces. A maximum of 10 ports is allowed. Attribute aristaIpAclRuleL4PortDestOper determines how the destination ports are matched in this ACL rule.')
aristaIpAclRuleTtlOper = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 1, 2, 1, 11), AristaAclRangeOperator()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaIpAclRuleTtlOper.setStatus('current')
if mibBuilder.loadTexts: aristaIpAclRuleTtlOper.setDescription('This attribute is the IP TTL (Time To Live) operation code used in this ACL rule. Combined with attribute aristaIpAclRuleTtl, it specifies the IP TTL matching behavior in this ACL rule.')
aristaIpAclRuleTtl = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 1, 2, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaIpAclRuleTtl.setStatus('current')
if mibBuilder.loadTexts: aristaIpAclRuleTtl.setDescription('This attribute is the IP TTL value in this ACL rule. Attribute aristaIpAclRuleTtlOper determines how the TTL values is matched in this ACL rule.')
aristaIpAclRuleTracked = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 1, 2, 1, 13), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaIpAclRuleTracked.setStatus('current')
if mibBuilder.loadTexts: aristaIpAclRuleTracked.setDescription("This attribute has the value 'true(1)' if this ACL rule is tracked; otherwise, the value is 'false(2)'. A tracked rule matches packets in existing ICMP/UDP/TCP connections.")
aristaIpAclRuleFragments = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 1, 2, 1, 14), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaIpAclRuleFragments.setStatus('current')
if mibBuilder.loadTexts: aristaIpAclRuleFragments.setDescription("This attribute has value 'true(1)' if this ACL rule is configured to match IP fragments; otherwise, the value is 'false(2)'.")
aristaIpAclRuleTcpFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 1, 2, 1, 15), Bits().clone(namedValues=NamedValues(("fin", 0), ("syn", 1), ("rst", 2), ("psh", 3), ("ack", 4), ("urg", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaIpAclRuleTcpFlags.setStatus('current')
if mibBuilder.loadTexts: aristaIpAclRuleTcpFlags.setDescription('This attribute describes TCP flags that are matched by this ACL rule.')
aristaIpAclRuleEstablished = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 1, 2, 1, 16), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaIpAclRuleEstablished.setStatus('current')
if mibBuilder.loadTexts: aristaIpAclRuleEstablished.setDescription("This attribute has value 'true(1)' if this ACL rule matches existing TCP connections; otherwise, the value is 'false(2)'.")
aristaIpAclRuleIcmpType = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 1, 2, 1, 17), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaIpAclRuleIcmpType.setStatus('current')
if mibBuilder.loadTexts: aristaIpAclRuleIcmpType.setDescription('This attribute is the ICMP type that is matched by this ACL rule. The attribute is ignored in the ACL rule if the value is 65535.')
aristaIpAclRuleIcmpCode = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 1, 2, 1, 18), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaIpAclRuleIcmpCode.setStatus('current')
if mibBuilder.loadTexts: aristaIpAclRuleIcmpCode.setDescription('This attribute is the ICMP code that is matched by this ACL rule. The attribute is ignored in the ACL rule if the value is 65535.')
aristaIpAclRuleAction = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 1, 2, 1, 19), AristaAclRuleAction()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaIpAclRuleAction.setStatus('current')
if mibBuilder.loadTexts: aristaIpAclRuleAction.setDescription('This attribute is the action applied to this ACL rule.')
aristaIpAclRuleLog = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 1, 2, 1, 20), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaIpAclRuleLog.setStatus('current')
if mibBuilder.loadTexts: aristaIpAclRuleLog.setDescription("This attribute has value 'true(1)' if logging is required in this ACL rule; otherwise, the value is 'false(2)'.")
aristaIpAclRuleRemark = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 1, 2, 1, 21), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaIpAclRuleRemark.setStatus('current')
if mibBuilder.loadTexts: aristaIpAclRuleRemark.setDescription('This attribute is the remark string applied to this ACL rule.')
aristaIpAclRuleStatsTable = MibTable((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 1, 3), )
if mibBuilder.loadTexts: aristaIpAclRuleStatsTable.setStatus('current')
if mibBuilder.loadTexts: aristaIpAclRuleStatsTable.setDescription('A table that contains statistics for IP ACL rules.')
aristaIpAclRuleStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 1, 3, 1), ).setIndexNames((0, "ARISTA-ACL-MIB", "aristaIpAclRuleTimeMark"), (0, "ARISTA-ACL-MIB", "aristaIpAclName"), (0, "ARISTA-ACL-MIB", "aristaIpAclRuleSeqId"))
if mibBuilder.loadTexts: aristaIpAclRuleStatsEntry.setStatus('current')
if mibBuilder.loadTexts: aristaIpAclRuleStatsEntry.setDescription('Statistics for a specific IP ACL rules.')
aristaIpAclRuleTimeMark = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 1, 3, 1, 1), TimeFilter())
if mibBuilder.loadTexts: aristaIpAclRuleTimeMark.setStatus('current')
if mibBuilder.loadTexts: aristaIpAclRuleTimeMark.setDescription('A TimeFilter for this entry. See the TimeFilter textual convention to see how this works.')
aristaIpAclRuleStatsPktCount = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 1, 3, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaIpAclRuleStatsPktCount.setStatus('current')
if mibBuilder.loadTexts: aristaIpAclRuleStatsPktCount.setDescription('This attribute is the number of packets that this ACL rule matched.')
aristaIpAclRuleStatsLastUpdateTime = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 1, 3, 1, 3), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaIpAclRuleStatsLastUpdateTime.setStatus('current')
if mibBuilder.loadTexts: aristaIpAclRuleStatsLastUpdateTime.setDescription('The value of sysUpTime at the time the aristaIpAclRuleStatsPktCount was last updated for this ACL rule.')
aristaMacAclTable = MibTable((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 2, 1), )
if mibBuilder.loadTexts: aristaMacAclTable.setStatus('current')
if mibBuilder.loadTexts: aristaMacAclTable.setDescription('A table that contains MAC ACLs that are configured on the switch.')
aristaMacAclEntry = MibTableRow((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 2, 1, 1), ).setIndexNames((0, "ARISTA-ACL-MIB", "aristaMacAclName"))
if mibBuilder.loadTexts: aristaMacAclEntry.setStatus('current')
if mibBuilder.loadTexts: aristaMacAclEntry.setDescription('Information about a specific MAC ACL that is configured on the switch.')
aristaMacAclName = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 2, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 100)))
if mibBuilder.loadTexts: aristaMacAclName.setStatus('current')
if mibBuilder.loadTexts: aristaMacAclName.setDescription('The name of the MAC ACL.')
aristaMacAclReadOnly = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 2, 1, 1, 2), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaMacAclReadOnly.setStatus('current')
if mibBuilder.loadTexts: aristaMacAclReadOnly.setDescription("This attribute has value 'true(1)' if the MAC ACL is configured as read-only; otherwise, the value is 'false(2)'.")
aristaMacAclStatsEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 2, 1, 1, 3), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaMacAclStatsEnabled.setStatus('current')
if mibBuilder.loadTexts: aristaMacAclStatsEnabled.setDescription("This attribute has value 'true(1)' if the MAC ACL is configured to have per-entry statistics enabled; otherwise, the value is 'false(2)'.")
aristaMacAclCountersIncomplete = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 2, 1, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaMacAclCountersIncomplete.setStatus('current')
if mibBuilder.loadTexts: aristaMacAclCountersIncomplete.setDescription("This attribute has value 'true(1)' if the MAC ACL has incomplete counter statistics; otherwise, the value is 'false(2)'.")
aristaMacAclRuleTable = MibTable((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 2, 2), )
if mibBuilder.loadTexts: aristaMacAclRuleTable.setStatus('current')
if mibBuilder.loadTexts: aristaMacAclRuleTable.setDescription('A table that contains MAC ACL rules that are configured on the switch.')
aristaMacAclRuleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 2, 2, 1), ).setIndexNames((0, "ARISTA-ACL-MIB", "aristaMacAclName"), (0, "ARISTA-ACL-MIB", "aristaMacAclRuleSeqId"))
if mibBuilder.loadTexts: aristaMacAclRuleEntry.setStatus('current')
if mibBuilder.loadTexts: aristaMacAclRuleEntry.setDescription('Configuration information about a specific MAC ACL rule.')
aristaMacAclRuleSeqId = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 2, 2, 1, 1), Unsigned32())
if mibBuilder.loadTexts: aristaMacAclRuleSeqId.setStatus('current')
if mibBuilder.loadTexts: aristaMacAclRuleSeqId.setDescription('This attribute is the sequence ID for this ACL rule.')
aristaMacAclRuleSrc = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 2, 2, 1, 2), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaMacAclRuleSrc.setStatus('current')
if mibBuilder.loadTexts: aristaMacAclRuleSrc.setDescription('This attribute is the MAC source address to be matched by this ACL rule, subject to the aristaMacAclRuleSrcMask value.')
aristaMacAclRuleSrcMask = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 2, 2, 1, 3), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaMacAclRuleSrcMask.setStatus('current')
if mibBuilder.loadTexts: aristaMacAclRuleSrcMask.setDescription('This attribute is the MAC source-address mask in this ACL rule. For the source address of the packet to match the rule, the bitwise logical-AND of the address and this mask must be equal to the value of aristaMacAclRuleSrc.')
aristaMacAclRuleDest = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 2, 2, 1, 4), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaMacAclRuleDest.setStatus('current')
if mibBuilder.loadTexts: aristaMacAclRuleDest.setDescription('This attribute is the MAC destination address to be matched by this ACL rule, subject to the aristaMacAclRuleSrcMask value.')
aristaMacAclRuleDestMask = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 2, 2, 1, 5), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaMacAclRuleDestMask.setStatus('current')
if mibBuilder.loadTexts: aristaMacAclRuleDestMask.setDescription('This attribute is the MAC destination-address mask in this ACL rule. For the destination address of the packet to match the rule, the bitwise logical-AND of the address and this mask must be equal to the value of aristaMacAclRuleDest.')
aristaMacAclRuleProto = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 2, 2, 1, 6), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaMacAclRuleProto.setStatus('current')
if mibBuilder.loadTexts: aristaMacAclRuleProto.setDescription('This attribute is the MAC protocol number to be matched by this ACL rule. The protocol value 4294967295 (0xFFFFFFFF) is a value that indicates the rule matches any protocol.')
aristaMacAclRuleAction = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 2, 2, 1, 7), AristaAclRuleAction()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaMacAclRuleAction.setStatus('current')
if mibBuilder.loadTexts: aristaMacAclRuleAction.setDescription('This attribute is the action applied to this ACL rule.')
aristaMacAclRuleLog = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 2, 2, 1, 8), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaMacAclRuleLog.setStatus('current')
if mibBuilder.loadTexts: aristaMacAclRuleLog.setDescription("This attribute has value 'true(1)' if logging is required in this ACL rule; otherwise, the value is 'false(2)'.")
aristaMacAclRuleRemark = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 2, 2, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaMacAclRuleRemark.setStatus('current')
if mibBuilder.loadTexts: aristaMacAclRuleRemark.setDescription('This attribute is the remark string applied to this ACL rule.')
aristaMacAclRuleStatsTable = MibTable((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 2, 3), )
if mibBuilder.loadTexts: aristaMacAclRuleStatsTable.setStatus('current')
if mibBuilder.loadTexts: aristaMacAclRuleStatsTable.setDescription('A table that contains statistics information for MAC ACL rules.')
aristaMacAclRuleStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 2, 3, 1), ).setIndexNames((0, "ARISTA-ACL-MIB", "aristaMacAclRuleTimeMark"), (0, "ARISTA-ACL-MIB", "aristaMacAclName"), (0, "ARISTA-ACL-MIB", "aristaMacAclRuleSeqId"))
if mibBuilder.loadTexts: aristaMacAclRuleStatsEntry.setStatus('current')
if mibBuilder.loadTexts: aristaMacAclRuleStatsEntry.setDescription('Statistics for MAC ACL rules.')
aristaMacAclRuleTimeMark = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 2, 3, 1, 1), TimeFilter())
if mibBuilder.loadTexts: aristaMacAclRuleTimeMark.setStatus('current')
if mibBuilder.loadTexts: aristaMacAclRuleTimeMark.setDescription('A TimeFilter for this entry. See the TimeFilter textual convention to see how this works.')
aristaMacAclRuleStatsPktCount = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 2, 3, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaMacAclRuleStatsPktCount.setStatus('current')
if mibBuilder.loadTexts: aristaMacAclRuleStatsPktCount.setDescription('This attribute is the number of packets that this ACL rule matched.')
aristaMacAclRuleStatsLastUpdateTime = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 2, 3, 1, 3), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaMacAclRuleStatsLastUpdateTime.setStatus('current')
if mibBuilder.loadTexts: aristaMacAclRuleStatsLastUpdateTime.setDescription('The value of sysUpTime at the time the aristaMacAclRuleStatsPktCount was last updated for this ACL rule.')
aristaIpv6AclTable = MibTable((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 3, 1), )
if mibBuilder.loadTexts: aristaIpv6AclTable.setStatus('current')
if mibBuilder.loadTexts: aristaIpv6AclTable.setDescription('A table that contains IPv6 ACLs that are configured on the switch.')
aristaIpv6AclEntry = MibTableRow((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 3, 1, 1), ).setIndexNames((0, "ARISTA-ACL-MIB", "aristaIpv6AclName"))
if mibBuilder.loadTexts: aristaIpv6AclEntry.setStatus('current')
if mibBuilder.loadTexts: aristaIpv6AclEntry.setDescription('Information about a specific IPv6 ACL that is configured on the switch.')
aristaIpv6AclName = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 3, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 100)))
if mibBuilder.loadTexts: aristaIpv6AclName.setStatus('current')
if mibBuilder.loadTexts: aristaIpv6AclName.setDescription('The name of the IPv6 ACL.')
aristaIpv6AclReadOnly = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 3, 1, 1, 2), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaIpv6AclReadOnly.setStatus('current')
if mibBuilder.loadTexts: aristaIpv6AclReadOnly.setDescription("This attribute has value 'true(1)' if the IPv6 ACL is configured as read-only; otherwise, the value is 'false(2)'.")
aristaIpv6AclStatsEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 3, 1, 1, 3), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaIpv6AclStatsEnabled.setStatus('current')
if mibBuilder.loadTexts: aristaIpv6AclStatsEnabled.setDescription("This attribute has value 'true(1)' if the IPv6 ACL is configured to have per-entry statistics enabled; otherwise, the value is 'false(2)'.")
aristaIpv6AclCountersIncomplete = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 3, 1, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaIpv6AclCountersIncomplete.setStatus('current')
if mibBuilder.loadTexts: aristaIpv6AclCountersIncomplete.setDescription("This attribute has value 'true(1)' if the IPv6 ACL has incomplete counter statistics; otherwise, the value is 'false(2)'.")
aristaIpv6AclRuleTable = MibTable((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 3, 2), )
if mibBuilder.loadTexts: aristaIpv6AclRuleTable.setStatus('current')
if mibBuilder.loadTexts: aristaIpv6AclRuleTable.setDescription('A table that contains IPv6 ACL rules that are configured on the switch.')
aristaIpv6AclRuleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 3, 2, 1), ).setIndexNames((0, "ARISTA-ACL-MIB", "aristaIpv6AclName"), (0, "ARISTA-ACL-MIB", "aristaIpv6AclRuleSeqId"))
if mibBuilder.loadTexts: aristaIpv6AclRuleEntry.setStatus('current')
if mibBuilder.loadTexts: aristaIpv6AclRuleEntry.setDescription('Configuration information about a specific IPv6 ACL rule.')
aristaIpv6AclRuleSeqId = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 3, 2, 1, 1), Unsigned32())
if mibBuilder.loadTexts: aristaIpv6AclRuleSeqId.setStatus('current')
if mibBuilder.loadTexts: aristaIpv6AclRuleSeqId.setDescription('This attribute is the sequence ID for this ACL rule.')
aristaIpv6AclRuleProto = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 3, 2, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaIpv6AclRuleProto.setStatus('current')
if mibBuilder.loadTexts: aristaIpv6AclRuleProto.setDescription('This attribute is the IPv6 upper layer protocol to be matched by this ACL rule. The value 0 indicates the rule matches any IPv6 protocol.')
aristaIpv6AclRuleSrc = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 3, 2, 1, 3), InetAddressIPv6()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaIpv6AclRuleSrc.setStatus('current')
if mibBuilder.loadTexts: aristaIpv6AclRuleSrc.setDescription('This attribute is the IPv6 source address to be matched by this ACL rule, subject to the aristaIpv6AclRuleSrcMask value.')
aristaIpv6AclRuleSrcMask = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 3, 2, 1, 4), InetAddressIPv6()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaIpv6AclRuleSrcMask.setStatus('current')
if mibBuilder.loadTexts: aristaIpv6AclRuleSrcMask.setDescription('This attribute is the IPv6 source-address mask in this ACL rule. For the source address of the packet to match the rule, the bitwise logical-AND of the address and this mask must be equal to the value of aristaIpv6AclRuleSrc.')
aristaIpv6AclRuleDest = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 3, 2, 1, 5), InetAddressIPv6()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaIpv6AclRuleDest.setStatus('current')
if mibBuilder.loadTexts: aristaIpv6AclRuleDest.setDescription('This attribute is the IPv6 destination address to be matched by this ACL rule, subject to the aristaIpv6AclRuleDestMask value.')
aristaIpv6AclRuleDestMask = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 3, 2, 1, 6), InetAddressIPv6()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaIpv6AclRuleDestMask.setStatus('current')
if mibBuilder.loadTexts: aristaIpv6AclRuleDestMask.setDescription('This attribute is the IPv6 destination-address mask in this ACL rule. For the destination address of the packet to match the rule, the bitwise logical-AND of the address and this mask must be equal to the value of aristaIpv6AclRuleDest.')
aristaIpv6AclRuleL4PortSrcOper = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 3, 2, 1, 7), AristaAclRangeOperator()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaIpv6AclRuleL4PortSrcOper.setStatus('current')
if mibBuilder.loadTexts: aristaIpv6AclRuleL4PortSrcOper.setDescription("This attribute determines TCP/UDP source-port matching behavior in this ACL rule. If this attribute has value 'any(0)', then attribute aristaIpv6AclRuleL4PortsSrc is ignored.")
aristaIpv6AclRuleL4PortsSrc = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 3, 2, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 60))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaIpv6AclRuleL4PortsSrc.setStatus('current')
if mibBuilder.loadTexts: aristaIpv6AclRuleL4PortsSrc.setDescription('This attribute is a list of TCP/UDP source ports to be matched in this ACL rule. They are represented as decimal strings, separated by spaces. A maximum of 10 ports is allowed. Attribute aristaIpv6AclRuleL4PortSrcOper determines how the source ports are matched in this ACL rule.')
aristaIpv6AclRuleL4PortDestOper = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 3, 2, 1, 9), AristaAclRangeOperator()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaIpv6AclRuleL4PortDestOper.setStatus('current')
if mibBuilder.loadTexts: aristaIpv6AclRuleL4PortDestOper.setDescription("This attribute determines TCP/UDP destination-port matching behavior in this ACL rule. If this attribute has value 'any(0)', then attribute aristaIpv6AclRuleL4PortsDest is ignored.")
aristaIpv6AclRuleL4PortsDest = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 3, 2, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 60))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaIpv6AclRuleL4PortsDest.setStatus('current')
if mibBuilder.loadTexts: aristaIpv6AclRuleL4PortsDest.setDescription('This attribute is a list of TCP/UDP destination ports to be matched in this ACL rule. They are represented as decimal strings, separated by spaces. A maximum of 10 ports is allowed. Attribute aristaIpv6AclRuleL4PortDestOper determines how the destination ports are matched in this ACL rule.')
aristaIpv6AclRuleHopLimitOper = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 3, 2, 1, 11), AristaAclRangeOperator()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaIpv6AclRuleHopLimitOper.setStatus('current')
if mibBuilder.loadTexts: aristaIpv6AclRuleHopLimitOper.setDescription('This attribute is the IPv6 Hop Limit operation code used in this ACL rule. Combined with attribute aristaIpv6AclRuleHopLimit, it specifies the IPv6 Hop Limit matching behavior in this ACL rule.')
aristaIpv6AclRuleHopLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 3, 2, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaIpv6AclRuleHopLimit.setStatus('current')
if mibBuilder.loadTexts: aristaIpv6AclRuleHopLimit.setDescription('This attribute is the IPv6 Hop Limit value in this ACL rule. Attribute aristaIpv6AclRuleHopLimitOper determines how the Hop Limit values is matched in this ACL rule.')
aristaIpv6AclRuleTcpFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 3, 2, 1, 13), Bits().clone(namedValues=NamedValues(("fin", 0), ("syn", 1), ("rst", 2), ("psh", 3), ("ack", 4), ("urg", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaIpv6AclRuleTcpFlags.setStatus('current')
if mibBuilder.loadTexts: aristaIpv6AclRuleTcpFlags.setDescription('This attribute describes TCP flags that are matched by this ACL rule.')
aristaIpv6AclRuleEstablished = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 3, 2, 1, 14), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaIpv6AclRuleEstablished.setStatus('current')
if mibBuilder.loadTexts: aristaIpv6AclRuleEstablished.setDescription("This attribute has value 'true(1)' if this ACL rule matches existing TCP connections; otherwise, the value is 'false(2)'.")
aristaIpv6AclRuleIcmpType = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 3, 2, 1, 15), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaIpv6AclRuleIcmpType.setStatus('current')
if mibBuilder.loadTexts: aristaIpv6AclRuleIcmpType.setDescription('This attribute is the ICMP type that is matched by this ACL rule. The attribute is ignored in the ACL rule if the value is 65535.')
aristaIpv6AclRuleIcmpCode = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 3, 2, 1, 16), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaIpv6AclRuleIcmpCode.setStatus('current')
if mibBuilder.loadTexts: aristaIpv6AclRuleIcmpCode.setDescription('This attribute is the ICMP code that is matched by this ACL rule. The attribute is ignored in the ACL rule if the value is 65535.')
aristaIpv6AclRuleAction = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 3, 2, 1, 17), AristaAclRuleAction()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaIpv6AclRuleAction.setStatus('current')
if mibBuilder.loadTexts: aristaIpv6AclRuleAction.setDescription('This attribute is the action applied to this ACL rule.')
aristaIpv6AclRuleLog = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 3, 2, 1, 18), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaIpv6AclRuleLog.setStatus('current')
if mibBuilder.loadTexts: aristaIpv6AclRuleLog.setDescription("This attribute has value 'true(1)' if logging is required in this ACL rule; otherwise, the value is 'false(2)'.")
aristaIpv6AclRuleRemark = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 3, 2, 1, 19), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaIpv6AclRuleRemark.setStatus('current')
if mibBuilder.loadTexts: aristaIpv6AclRuleRemark.setDescription('This attribute is the remark string applied to this ACL rule.')
aristaIpv6AclRuleStatsTable = MibTable((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 3, 3), )
if mibBuilder.loadTexts: aristaIpv6AclRuleStatsTable.setStatus('current')
if mibBuilder.loadTexts: aristaIpv6AclRuleStatsTable.setDescription('A table that contains statistics information for IPv6 ACL rules.')
aristaIpv6AclRuleStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 3, 3, 1), ).setIndexNames((0, "ARISTA-ACL-MIB", "aristaIpv6AclRuleTimeMark"), (0, "ARISTA-ACL-MIB", "aristaIpv6AclName"), (0, "ARISTA-ACL-MIB", "aristaIpv6AclRuleSeqId"))
if mibBuilder.loadTexts: aristaIpv6AclRuleStatsEntry.setStatus('current')
if mibBuilder.loadTexts: aristaIpv6AclRuleStatsEntry.setDescription('Statistics for IPv6 ACL rules.')
aristaIpv6AclRuleTimeMark = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 3, 3, 1, 1), TimeFilter())
if mibBuilder.loadTexts: aristaIpv6AclRuleTimeMark.setStatus('current')
if mibBuilder.loadTexts: aristaIpv6AclRuleTimeMark.setDescription('A TimeFilter for this entry. See the TimeFilter textual convention to see how this works.')
aristaIpv6AclRuleStatsPktCount = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 3, 3, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaIpv6AclRuleStatsPktCount.setStatus('current')
if mibBuilder.loadTexts: aristaIpv6AclRuleStatsPktCount.setDescription('This attribute is the number of packets that this ACL rule matched.')
aristaIpv6AclRuleStatsLastUpdateTime = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 3, 5, 1, 3, 3, 1, 3), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaIpv6AclRuleStatsLastUpdateTime.setStatus('current')
if mibBuilder.loadTexts: aristaIpv6AclRuleStatsLastUpdateTime.setDescription('The value of sysUpTime at the time the aristaIpv6AclRuleStatsPktCount was last updated for this ACL rule.')
aristaAclCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 30065, 3, 5, 2, 1))
aristaAclGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 30065, 3, 5, 2, 2))
aristaAclCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 30065, 3, 5, 2, 1, 1)).setObjects(("ARISTA-ACL-MIB", "aristaAclGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    aristaAclCompliance = aristaAclCompliance.setStatus('current')
if mibBuilder.loadTexts: aristaAclCompliance.setDescription('The compliance statement for Arista switches that support Access Control Lists (ACLs).')
aristaAclGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 30065, 3, 5, 2, 2, 1)).setObjects(("ARISTA-ACL-MIB", "aristaAclDpSupportFlags"), ("ARISTA-ACL-MIB", "aristaIpAclReadOnly"), ("ARISTA-ACL-MIB", "aristaIpAclStatsEnabled"), ("ARISTA-ACL-MIB", "aristaIpAclCountersIncomplete"), ("ARISTA-ACL-MIB", "aristaIpAclRuleProto"), ("ARISTA-ACL-MIB", "aristaIpAclRuleSrc"), ("ARISTA-ACL-MIB", "aristaIpAclRuleSrcMask"), ("ARISTA-ACL-MIB", "aristaIpAclRuleDest"), ("ARISTA-ACL-MIB", "aristaIpAclRuleDestMask"), ("ARISTA-ACL-MIB", "aristaIpAclRuleL4PortSrcOper"), ("ARISTA-ACL-MIB", "aristaIpAclRuleL4PortsSrc"), ("ARISTA-ACL-MIB", "aristaIpAclRuleL4PortDestOper"), ("ARISTA-ACL-MIB", "aristaIpAclRuleL4PortsDest"), ("ARISTA-ACL-MIB", "aristaIpAclRuleTtlOper"), ("ARISTA-ACL-MIB", "aristaIpAclRuleTtl"), ("ARISTA-ACL-MIB", "aristaIpAclRuleTracked"), ("ARISTA-ACL-MIB", "aristaIpAclRuleFragments"), ("ARISTA-ACL-MIB", "aristaIpAclRuleTcpFlags"), ("ARISTA-ACL-MIB", "aristaIpAclRuleEstablished"), ("ARISTA-ACL-MIB", "aristaIpAclRuleIcmpType"), ("ARISTA-ACL-MIB", "aristaIpAclRuleIcmpCode"), ("ARISTA-ACL-MIB", "aristaIpAclRuleAction"), ("ARISTA-ACL-MIB", "aristaIpAclRuleLog"), ("ARISTA-ACL-MIB", "aristaIpAclRuleRemark"), ("ARISTA-ACL-MIB", "aristaIpAclRuleStatsPktCount"), ("ARISTA-ACL-MIB", "aristaIpAclRuleStatsLastUpdateTime"), ("ARISTA-ACL-MIB", "aristaMacAclReadOnly"), ("ARISTA-ACL-MIB", "aristaMacAclStatsEnabled"), ("ARISTA-ACL-MIB", "aristaMacAclCountersIncomplete"), ("ARISTA-ACL-MIB", "aristaMacAclRuleSrc"), ("ARISTA-ACL-MIB", "aristaMacAclRuleSrcMask"), ("ARISTA-ACL-MIB", "aristaMacAclRuleDest"), ("ARISTA-ACL-MIB", "aristaMacAclRuleDestMask"), ("ARISTA-ACL-MIB", "aristaMacAclRuleProto"), ("ARISTA-ACL-MIB", "aristaMacAclRuleAction"), ("ARISTA-ACL-MIB", "aristaMacAclRuleLog"), ("ARISTA-ACL-MIB", "aristaMacAclRuleRemark"), ("ARISTA-ACL-MIB", "aristaMacAclRuleStatsPktCount"), ("ARISTA-ACL-MIB", "aristaMacAclRuleStatsLastUpdateTime"), ("ARISTA-ACL-MIB", "aristaIpv6AclReadOnly"), ("ARISTA-ACL-MIB", "aristaIpv6AclStatsEnabled"), ("ARISTA-ACL-MIB", "aristaIpv6AclCountersIncomplete"), ("ARISTA-ACL-MIB", "aristaIpv6AclRuleProto"), ("ARISTA-ACL-MIB", "aristaIpv6AclRuleSrc"), ("ARISTA-ACL-MIB", "aristaIpv6AclRuleSrcMask"), ("ARISTA-ACL-MIB", "aristaIpv6AclRuleDest"), ("ARISTA-ACL-MIB", "aristaIpv6AclRuleDestMask"), ("ARISTA-ACL-MIB", "aristaIpv6AclRuleL4PortSrcOper"), ("ARISTA-ACL-MIB", "aristaIpv6AclRuleL4PortsSrc"), ("ARISTA-ACL-MIB", "aristaIpv6AclRuleL4PortDestOper"), ("ARISTA-ACL-MIB", "aristaIpv6AclRuleL4PortsDest"), ("ARISTA-ACL-MIB", "aristaIpv6AclRuleHopLimitOper"), ("ARISTA-ACL-MIB", "aristaIpv6AclRuleHopLimit"), ("ARISTA-ACL-MIB", "aristaIpv6AclRuleTcpFlags"), ("ARISTA-ACL-MIB", "aristaIpv6AclRuleEstablished"), ("ARISTA-ACL-MIB", "aristaIpv6AclRuleIcmpType"), ("ARISTA-ACL-MIB", "aristaIpv6AclRuleIcmpCode"), ("ARISTA-ACL-MIB", "aristaIpv6AclRuleAction"), ("ARISTA-ACL-MIB", "aristaIpv6AclRuleLog"), ("ARISTA-ACL-MIB", "aristaIpv6AclRuleRemark"), ("ARISTA-ACL-MIB", "aristaIpv6AclRuleStatsPktCount"), ("ARISTA-ACL-MIB", "aristaIpv6AclRuleStatsLastUpdateTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    aristaAclGroup = aristaAclGroup.setStatus('current')
if mibBuilder.loadTexts: aristaAclGroup.setDescription('The group of required ACL objects.')
mibBuilder.exportSymbols("ARISTA-ACL-MIB", aristaIpAclName=aristaIpAclName, aristaIpv6AclRuleDest=aristaIpv6AclRuleDest, aristaMacAclRuleAction=aristaMacAclRuleAction, aristaIpAclReadOnly=aristaIpAclReadOnly, aristaAclMIB=aristaAclMIB, aristaIpv6AclRuleDestMask=aristaIpv6AclRuleDestMask, aristaIpAclRuleL4PortDestOper=aristaIpAclRuleL4PortDestOper, aristaIpAclRuleLog=aristaIpAclRuleLog, aristaIpAclRuleTimeMark=aristaIpAclRuleTimeMark, aristaIpAclRuleEntry=aristaIpAclRuleEntry, aristaMacAclEntry=aristaMacAclEntry, aristaMacAclTable=aristaMacAclTable, aristaIpAclTable=aristaIpAclTable, aristaMacAclRuleTimeMark=aristaMacAclRuleTimeMark, aristaMacAclRuleRemark=aristaMacAclRuleRemark, aristaMacAclName=aristaMacAclName, aristaMacAclRuleEntry=aristaMacAclRuleEntry, PYSNMP_MODULE_ID=aristaAclMIB, aristaIpv6AclRuleIcmpCode=aristaIpv6AclRuleIcmpCode, aristaIpAclRuleL4PortsSrc=aristaIpAclRuleL4PortsSrc, aristaIpAclRuleSrc=aristaIpAclRuleSrc, aristaMacAclRuleLog=aristaMacAclRuleLog, AristaAclRuleAction=AristaAclRuleAction, aristaIpAclRuleTable=aristaIpAclRuleTable, aristaIpAclRuleIcmpCode=aristaIpAclRuleIcmpCode, aristaAcl=aristaAcl, aristaIpv6AclRuleEntry=aristaIpv6AclRuleEntry, aristaIpv6AclTable=aristaIpv6AclTable, aristaIpv6AclEntry=aristaIpv6AclEntry, aristaIpv6AclStatsEnabled=aristaIpv6AclStatsEnabled, aristaIpAclRuleTtlOper=aristaIpAclRuleTtlOper, aristaIpAclRuleTtl=aristaIpAclRuleTtl, aristaMacAclRuleTable=aristaMacAclRuleTable, aristaIpAclRuleDest=aristaIpAclRuleDest, aristaIpv6AclRuleTcpFlags=aristaIpv6AclRuleTcpFlags, aristaIpAclRuleIcmpType=aristaIpAclRuleIcmpType, aristaAclGroup=aristaAclGroup, aristaIpv6AclRuleL4PortsDest=aristaIpv6AclRuleL4PortsDest, aristaIpAclRuleAction=aristaIpAclRuleAction, aristaAclCompliance=aristaAclCompliance, aristaMacAclRuleStatsTable=aristaMacAclRuleStatsTable, aristaIpv6AclRuleL4PortDestOper=aristaIpv6AclRuleL4PortDestOper, aristaMacAclStatsEnabled=aristaMacAclStatsEnabled, aristaIpv6AclRuleSrc=aristaIpv6AclRuleSrc, aristaIpv6AclRuleRemark=aristaIpv6AclRuleRemark, aristaIpAclRuleRemark=aristaIpAclRuleRemark, aristaIpv6AclRuleLog=aristaIpv6AclRuleLog, aristaIpv6Acl=aristaIpv6Acl, aristaIpAclRuleProto=aristaIpAclRuleProto, aristaIpv6AclRuleTimeMark=aristaIpv6AclRuleTimeMark, aristaMacAclReadOnly=aristaMacAclReadOnly, aristaAclDpSupportFlags=aristaAclDpSupportFlags, aristaIpAclCountersIncomplete=aristaIpAclCountersIncomplete, aristaMacAclRuleSrcMask=aristaMacAclRuleSrcMask, aristaMacAclRuleDest=aristaMacAclRuleDest, aristaIpv6AclRuleSeqId=aristaIpv6AclRuleSeqId, aristaIpv6AclRuleAction=aristaIpv6AclRuleAction, aristaIpv6AclRuleStatsEntry=aristaIpv6AclRuleStatsEntry, aristaIpv6AclRuleEstablished=aristaIpv6AclRuleEstablished, aristaIpAclRuleStatsEntry=aristaIpAclRuleStatsEntry, aristaAclGroups=aristaAclGroups, aristaMacAclRuleSrc=aristaMacAclRuleSrc, aristaIpAclRuleL4PortsDest=aristaIpAclRuleL4PortsDest, aristaIpAclRuleStatsLastUpdateTime=aristaIpAclRuleStatsLastUpdateTime, aristaIpAcl=aristaIpAcl, aristaIpv6AclRuleStatsPktCount=aristaIpv6AclRuleStatsPktCount, aristaIpv6AclCountersIncomplete=aristaIpv6AclCountersIncomplete, aristaIpAclRuleEstablished=aristaIpAclRuleEstablished, aristaMacAclRuleProto=aristaMacAclRuleProto, aristaIpAclRuleDestMask=aristaIpAclRuleDestMask, aristaIpv6AclRuleStatsTable=aristaIpv6AclRuleStatsTable, aristaMacAclRuleStatsEntry=aristaMacAclRuleStatsEntry, aristaIpAclRuleStatsPktCount=aristaIpAclRuleStatsPktCount, aristaIpv6AclRuleIcmpType=aristaIpv6AclRuleIcmpType, aristaIpAclRuleL4PortSrcOper=aristaIpAclRuleL4PortSrcOper, aristaIpAclRuleTcpFlags=aristaIpAclRuleTcpFlags, aristaIpv6AclRuleProto=aristaIpv6AclRuleProto, aristaAclCompliances=aristaAclCompliances, aristaIpv6AclRuleHopLimitOper=aristaIpv6AclRuleHopLimitOper, aristaMacAclCountersIncomplete=aristaMacAclCountersIncomplete, aristaIpAclEntry=aristaIpAclEntry, aristaMacAclRuleStatsPktCount=aristaMacAclRuleStatsPktCount, aristaMacAclRuleSeqId=aristaMacAclRuleSeqId, aristaIpAclRuleFragments=aristaIpAclRuleFragments, aristaMacAclRuleDestMask=aristaMacAclRuleDestMask, aristaIpv6AclRuleL4PortSrcOper=aristaIpv6AclRuleL4PortSrcOper, aristaIpAclRuleTracked=aristaIpAclRuleTracked, aristaIpv6AclRuleTable=aristaIpv6AclRuleTable, aristaIpAclStatsEnabled=aristaIpAclStatsEnabled, aristaMacAcl=aristaMacAcl, aristaIpv6AclName=aristaIpv6AclName, aristaIpv6AclRuleSrcMask=aristaIpv6AclRuleSrcMask, aristaIpv6AclReadOnly=aristaIpv6AclReadOnly, aristaIpAclRuleSrcMask=aristaIpAclRuleSrcMask, aristaIpv6AclRuleStatsLastUpdateTime=aristaIpv6AclRuleStatsLastUpdateTime, aristaMacAclRuleStatsLastUpdateTime=aristaMacAclRuleStatsLastUpdateTime, aristaIpv6AclRuleL4PortsSrc=aristaIpv6AclRuleL4PortsSrc, aristaIpv6AclRuleHopLimit=aristaIpv6AclRuleHopLimit, aristaAclConformance=aristaAclConformance, AristaAclRangeOperator=AristaAclRangeOperator, aristaIpAclRuleSeqId=aristaIpAclRuleSeqId, aristaIpAclRuleStatsTable=aristaIpAclRuleStatsTable)

#
# PySNMP MIB module ATM-FORUM-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/ATM-FORUM-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:31:08 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, SingleValueConstraint, ConstraintsUnion, ValueRangeConstraint, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "SingleValueConstraint", "ConstraintsUnion", "ValueRangeConstraint", "ValueSizeConstraint")
atmfAtmStatsGroup, atmfVpcGroup, atmfAtmLayerGroup, AtmServiceCategory, atmfVccGroup, ClnpAddress, atmfVpcAbrGroup, TruthValue, atmfPhysicalGroup, atmfVccAbrGroup = mibBuilder.importSymbols("ATM-FORUM-TC-MIB", "atmfAtmStatsGroup", "atmfVpcGroup", "atmfAtmLayerGroup", "AtmServiceCategory", "atmfVccGroup", "ClnpAddress", "atmfVpcAbrGroup", "TruthValue", "atmfPhysicalGroup", "atmfVccAbrGroup")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
NotificationType, MibIdentifier, ObjectIdentity, Counter32, Bits, MibScalar, MibTable, MibTableRow, MibTableColumn, iso, IpAddress, Integer32, TimeTicks, Counter64, Unsigned32, ModuleIdentity, Gauge32 = mibBuilder.importSymbols("SNMPv2-SMI", "NotificationType", "MibIdentifier", "ObjectIdentity", "Counter32", "Bits", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "iso", "IpAddress", "Integer32", "TimeTicks", "Counter64", "Unsigned32", "ModuleIdentity", "Gauge32")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
class AtmAddress(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 32)

atmfPortTable = MibTable((1, 3, 6, 1, 4, 1, 353, 2, 1, 1), )
if mibBuilder.loadTexts: atmfPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmfPortTable.setDescription("A table of physical layer status and parameter information for the ATM Interface's physical interface.")
atmfPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 2, 1, 1, 1), ).setIndexNames((0, "ATM-FORUM-MIB", "atmfPortIndex"))
if mibBuilder.loadTexts: atmfPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmfPortEntry.setDescription('An entry in the table, containing information about the physical layer of an ATM Interface.')
atmfPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmfPortIndex.setDescription('The value of 0 which has the special meaning of identifying the ATM Interface over which this message was received.')
atmfPortAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 1, 1, 1, 2), AtmAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfPortAddress.setStatus('obsolete')
if mibBuilder.loadTexts: atmfPortAddress.setDescription('This object should not be implemented except as required for backward compatibility with version 2.0 of the UNI specification. The Address Group, defined in theAddress Registration MIB should be used instead.')
atmfPortTransmissionType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 1, 1, 1, 3), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfPortTransmissionType.setStatus('deprecated')
if mibBuilder.loadTexts: atmfPortTransmissionType.setDescription('This object should not be implemented except as required for backward compatibility with version 3.1 of the UNI specification. Appropriate Network Management MIBs should be used instead.')
atmfPortMediaType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 1, 1, 1, 4), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfPortMediaType.setStatus('deprecated')
if mibBuilder.loadTexts: atmfPortMediaType.setDescription('This object should not be implemented except as required for backward compatibility with version 3.1 of the UNI specification. Appropriate Network Management MIBs should be used instead.')
atmfPortOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("inService", 2), ("outOfService", 3), ("loopBack", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfPortOperStatus.setStatus('deprecated')
if mibBuilder.loadTexts: atmfPortOperStatus.setDescription('This object should not be implemented except as required for backward compatibility with version 3.1 of the UNI specification. Appropriate Network Management MIBs should be used instead.')
atmfPortSpecific = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 1, 1, 1, 6), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfPortSpecific.setStatus('deprecated')
if mibBuilder.loadTexts: atmfPortSpecific.setDescription('This object should not be implemented except as required for backward compatibility with version 3.1 of the UNI specification. Appropriate Network Management MIBs should be used instead.')
atmfPortMyIfName = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 1, 1, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfPortMyIfName.setStatus('mandatory')
if mibBuilder.loadTexts: atmfPortMyIfName.setDescription('A textual name of this interface. If this system is manageable through SNMP, and supports the object ifName, the value of this object must be identical with that of ifName for the ifEntry of the lowest level physical interface for this port. This interface must be uniquely named on this system to distinguish parallel links with a neighboring system. If this interface does not have a textual name, the value of this object is a zero length string.')
atmfPortMyIfIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfPortMyIfIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: atmfPortMyIfIdentifier.setDescription('A unique value for each ATM interface. The scheme used to number the ATM interfaces on an ATM device is implementation specific. One way to generate this value is to use the ifIndex that an SNMP manager would use to identify the port. This interface must be uniquely numbered on this system to distinguish parallel links with a neighboring system.')
atmfMyIpNmAddress = MibScalar((1, 3, 6, 1, 4, 1, 353, 2, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfMyIpNmAddress.setStatus('mandatory')
if mibBuilder.loadTexts: atmfMyIpNmAddress.setDescription('An IP Address to which a Network Management Station can send Network Management protocol messages, e.g. SNMP messages to UDP port 161, in order to access network management information concerning the operation of the ATM device local to this IME. If this object is supported, but the Network Management Agent has not been configured with an IP Address, the IME should return 0.0.0.0.')
atmfMyOsiNmNsapAddress = MibScalar((1, 3, 6, 1, 4, 1, 353, 2, 1, 3), ClnpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfMyOsiNmNsapAddress.setStatus('mandatory')
if mibBuilder.loadTexts: atmfMyOsiNmNsapAddress.setDescription('An NSAP Address to which a Network Management Station can send Network Management protocol messages in order to access network management information concerning the operation of the ATM device local to this IME. If this object is supported, but the Network Management Agent has not been configured with an NSAP Address, the IME should return 0.0.0.0')
atmfMySystemIdentifier = MibScalar((1, 3, 6, 1, 4, 1, 353, 2, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfMySystemIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: atmfMySystemIdentifier.setDescription('A 48 bit identifier, taken from the IEEE universally administered MAC address space, which uniquely identifies the ATM device local to this IME.')
atmfAtmLayerTable = MibTable((1, 3, 6, 1, 4, 1, 353, 2, 2, 1), )
if mibBuilder.loadTexts: atmfAtmLayerTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmfAtmLayerTable.setDescription('A table of ATM layer status and parameter information for the ATM Interface.')
atmfAtmLayerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 2, 2, 1, 1), ).setIndexNames((0, "ATM-FORUM-MIB", "atmfAtmLayerIndex"))
if mibBuilder.loadTexts: atmfAtmLayerEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmfAtmLayerEntry.setDescription('An entry in the table, containing information about the ATM layer of an ATM Interface.')
atmfAtmLayerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfAtmLayerIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmfAtmLayerIndex.setDescription('The value of 0 which has the special meaning of identifying the ATM Interface over which this message was received.')
atmfAtmLayerMaxVPCs = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfAtmLayerMaxVPCs.setStatus('mandatory')
if mibBuilder.loadTexts: atmfAtmLayerMaxVPCs.setDescription('The maximum number of switched and permanent VPCs supported on this ATM Interface. For virtual interfaces (i.e. Virtual Path Connections), the maximum number of VPCs PNNI may communicate over is set to zero.')
atmfAtmLayerMaxVCCs = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 268435456))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfAtmLayerMaxVCCs.setStatus('mandatory')
if mibBuilder.loadTexts: atmfAtmLayerMaxVCCs.setDescription('The maximum number of switched and permanent VCCs supported on this ATM Interface.')
atmfAtmLayerConfiguredVPCs = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfAtmLayerConfiguredVPCs.setStatus('mandatory')
if mibBuilder.loadTexts: atmfAtmLayerConfiguredVPCs.setDescription('The number of permanent VPCs configured for use on this ATM Interface. For virtual interfaces (i.e. Virtual Path Connections used by PNNI), the maximum number of VPCs is set to zero.')
atmfAtmLayerConfiguredVCCs = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 268435456))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfAtmLayerConfiguredVCCs.setStatus('mandatory')
if mibBuilder.loadTexts: atmfAtmLayerConfiguredVCCs.setDescription('The number of permanent VCCs configured for use on this ATM Interface.')
atmfAtmLayerMaxVpiBits = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfAtmLayerMaxVpiBits.setStatus('mandatory')
if mibBuilder.loadTexts: atmfAtmLayerMaxVpiBits.setDescription('The maximum number of active VPI bits on this ATM Interface. For virtual interfaces (i.e. Virtual Path Connections used by PNNI), this value has no meaning and is set to zero.')
atmfAtmLayerMaxVciBits = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfAtmLayerMaxVciBits.setStatus('mandatory')
if mibBuilder.loadTexts: atmfAtmLayerMaxVciBits.setDescription('The maximum number of active VCI bits on this ATM Interface.')
atmfAtmLayerUniType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("public", 1), ("private", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfAtmLayerUniType.setStatus('mandatory')
if mibBuilder.loadTexts: atmfAtmLayerUniType.setDescription('The type of the ATM device, either public or private.')
atmfAtmLayerUniVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("version2point0", 1), ("version3point0", 2), ("version3point1", 3), ("version4point0", 4), ("unsupported", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfAtmLayerUniVersion.setStatus('mandatory')
if mibBuilder.loadTexts: atmfAtmLayerUniVersion.setDescription("An indication of the latest version of the ATM Forum UNI Signalling Specification that is supported on this ATM Interface. If this value is not present, a version of the UNI earlier than 3.1 is supported. If the peer IME's value of this object is the same as, or later than the local IME's value, then the version corresponding to the local IME's value should be attempted. Otherwise, if the peer IME's value of this object is earlier, and supported locally, then the local IME should attempt the version corresponding to the peer IME's value. Otherwise, compatibility of the two IMEs cannot be assumed.")
atmfAtmLayerDeviceType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("user", 1), ("node", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfAtmLayerDeviceType.setStatus('mandatory')
if mibBuilder.loadTexts: atmfAtmLayerDeviceType.setDescription('This object determines the type of the ATM device. This object is used in automatic ATM Interface-Type determination procedure such that a correct operational ATM Interface-type can be determined. An ATM End System shall take the value of user(1), and an ATM network node shall take the value of node(2).')
atmfAtmLayerIlmiVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 2, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("unsupported", 1), ("version4point0", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfAtmLayerIlmiVersion.setStatus('mandatory')
if mibBuilder.loadTexts: atmfAtmLayerIlmiVersion.setDescription("An indication of the latest version of the ATM Forum ILMI Specification that is supported on this ATM Interface. If the peer IME's value of this object is the same as, or later than the local IME's value, then the version corresponding to the local IME's value should be attempted. Otherwise, if the peer IME's value of this object is earlier, and supported locally, then the local IME should attempt the version corresponding to the peer IME's value. Otherwise, compatibility of the two IMEs cannot be assumed. If this object is not present, a version of the ILMI earlier than 4.0 is supported.")
atmfAtmLayerNniSigVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 2, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unsupported", 1), ("iisp", 2), ("pnniVersion1point0", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfAtmLayerNniSigVersion.setStatus('mandatory')
if mibBuilder.loadTexts: atmfAtmLayerNniSigVersion.setDescription("An indication of the latest version of the ATM Forum PNNI Signalling Specification that is supported on this ATM Interface. Note that the PNNI routing version is not determined through ILMI. If the peer IME's value of this object is the same as, or later than the local IME's value, then the version corresponding to the local IME's value should be attempted. Otherwise, if the peer IME's value of this object is earlier, and supported locally, then the local IME should attempt the version corresponding to the peer IME's value. Otherwise, compatibility of the two IMEs cannot be assumed.")
atmfAtmLayerMaxSvpcVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 2, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfAtmLayerMaxSvpcVpi.setStatus('mandatory')
if mibBuilder.loadTexts: atmfAtmLayerMaxSvpcVpi.setDescription('The maximum VPI that the signalling stack on the ATM interface is configured to support for allocation to switched virtual path connections.')
atmfAtmLayerMaxSvccVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 2, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfAtmLayerMaxSvccVpi.setStatus('mandatory')
if mibBuilder.loadTexts: atmfAtmLayerMaxSvccVpi.setDescription('The maximum VPI that the signalling stack on the ATM interface is configured to support for allocation to switched virtual channel connections.')
atmfAtmLayerMinSvccVci = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 2, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfAtmLayerMinSvccVci.setStatus('mandatory')
if mibBuilder.loadTexts: atmfAtmLayerMinSvccVci.setDescription('This is the minimum VCI value that the signalling stack is configured to support for allocation to switched virtual channel connections. The same value applies to all SVCC VPI values for which the signalling stack is configured.')
atmfAtmStatsTable = MibTable((1, 3, 6, 1, 4, 1, 353, 2, 3, 1), )
if mibBuilder.loadTexts: atmfAtmStatsTable.setStatus('deprecated')
if mibBuilder.loadTexts: atmfAtmStatsTable.setDescription('This group is deprecated and should not be implemented except as required for backward compatibility with version 3.1 of the UNI specification.')
atmfAtmStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 2, 3, 1, 1), ).setIndexNames((0, "ATM-FORUM-MIB", "atmfAtmStatsIndex"))
if mibBuilder.loadTexts: atmfAtmStatsEntry.setStatus('deprecated')
if mibBuilder.loadTexts: atmfAtmStatsEntry.setDescription('This object should not be implemented except as required for backward compatibility with version 3.1 of the UNI specification.')
atmfAtmStatsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfAtmStatsIndex.setStatus('deprecated')
if mibBuilder.loadTexts: atmfAtmStatsIndex.setDescription('This object should not be implemented except as required for backward compatibility with version 3.1 of the UNI specification.')
atmfAtmStatsReceivedCells = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 3, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfAtmStatsReceivedCells.setStatus('deprecated')
if mibBuilder.loadTexts: atmfAtmStatsReceivedCells.setDescription('This object should not be implemented except as required for backward compatibility with version 3.1 of the UNI specification.')
atmfAtmStatsDroppedReceivedCells = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 3, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfAtmStatsDroppedReceivedCells.setStatus('deprecated')
if mibBuilder.loadTexts: atmfAtmStatsDroppedReceivedCells.setDescription('This object should not be implemented except as required for backward compatibility with version 3.1 of the UNI specification.')
atmfAtmStatsTransmittedCells = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 3, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfAtmStatsTransmittedCells.setStatus('deprecated')
if mibBuilder.loadTexts: atmfAtmStatsTransmittedCells.setDescription('This object should not be implemented except as required for backward compatibility with version 3.1 of the UNI specification.')
atmfVpcTable = MibTable((1, 3, 6, 1, 4, 1, 353, 2, 4, 1), )
if mibBuilder.loadTexts: atmfVpcTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcTable.setDescription('A table of status and parameter information on the virtual path connections which cross this ATM Interface. There is one entry in this table for each permanent virtual path connection.')
atmfVpcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 2, 4, 1, 1), ).setIndexNames((0, "ATM-FORUM-MIB", "atmfVpcPortIndex"), (0, "ATM-FORUM-MIB", "atmfVpcVpi"))
if mibBuilder.loadTexts: atmfVpcEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcEntry.setDescription('An entry in the table, containing information about a particular virtual path connection.')
atmfVpcPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcPortIndex.setDescription('The value of 0 which has the special meaning of identifying the ATM Interface over which this message was received.')
atmfVpcVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcVpi.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcVpi.setDescription('The VPI value of this Virtual Path Connection at the local ATM Interface.')
atmfVpcOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unknown", 1), ("end2endUp", 2), ("end2endDown", 3), ("localUpEnd2endUnknown", 4), ("localDown", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcOperStatus.setDescription('The present actual operational status of the VPC. A value of end2endUp(2) or end2endDown(3) would be used if the end-to-end status is known. If only local status information is available, a value of localUpEnd2endUnknown(4) or localDown(5) would be used.')
atmfVpcTransmitTrafficDescriptorType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 4, 1, 1, 4), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcTransmitTrafficDescriptorType.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcTransmitTrafficDescriptorType.setDescription('The type of traffic management, applicable to the transmit direction of this VPC. The type may indicate none, or a type with one or more parameters. These parameters are specified as a parameter vector, in the corresponding instances of the objects: atmfVpcTransmitTrafficDescriptorParam1, atmfVpcTransmitTrafficDescriptorParam2, atmfVpcTransmitTrafficDescriptorParam3, atmfVpcTransmitTrafficDescriptorParam4, and atmfVpcTransmitTrafficDescriptorParam5.')
atmfVpcTransmitTrafficDescriptorParam1 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcTransmitTrafficDescriptorParam1.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcTransmitTrafficDescriptorParam1.setDescription('The first parameter of the transmit parameter vector for this VPC, used according to the value of atmfVpcTransmitTrafficDescriptorType.')
atmfVpcTransmitTrafficDescriptorParam2 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 4, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcTransmitTrafficDescriptorParam2.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcTransmitTrafficDescriptorParam2.setDescription('The second parameter of the transmit parameter vector for this VPC, used according to the value of atmfVpcTransmitTrafficDescriptorType.')
atmfVpcTransmitTrafficDescriptorParam3 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 4, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcTransmitTrafficDescriptorParam3.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcTransmitTrafficDescriptorParam3.setDescription('The third parameter of the transmit parameter vector for this VPC, used according to the value of atmfVpcTransmitTrafficDescriptorType.')
atmfVpcTransmitTrafficDescriptorParam4 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 4, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcTransmitTrafficDescriptorParam4.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcTransmitTrafficDescriptorParam4.setDescription('The fourth parameter of the transmit parameter vector for this VPC, used according to the value of atmfVpcTransmitTrafficDescriptorType.')
atmfVpcTransmitTrafficDescriptorParam5 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 4, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcTransmitTrafficDescriptorParam5.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcTransmitTrafficDescriptorParam5.setDescription('The fifth parameter of the transmit parameter vector for this VPC, used according to the value of atmfVpcTransmitTrafficDescriptorType.')
atmfVpcReceiveTrafficDescriptorType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 4, 1, 1, 10), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcReceiveTrafficDescriptorType.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcReceiveTrafficDescriptorType.setDescription('The type of traffic management, applicable to the traffic in the receive direction of this VPC. The type may indicate none, or a type with one or more parameters. These parameters are specified as a parameter vector, in the corresponding instances of the objects: atmfVpcReceiveTrafficDescriptorParam1, atmfVpcReceiveTrafficDescriptorParam2, atmfVpcReceiveTrafficDescriptorParam3, atmfVpcReceiveTrafficDescriptorParam4, and atmfVpcReceiveTrafficDescriptorParam5.')
atmfVpcReceiveTrafficDescriptorParam1 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 4, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcReceiveTrafficDescriptorParam1.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcReceiveTrafficDescriptorParam1.setDescription('The first parameter of the receive parameter vector for this VPC, used according to the value of atmfVpcReceiveTrafficDescriptorType.')
atmfVpcReceiveTrafficDescriptorParam2 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 4, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcReceiveTrafficDescriptorParam2.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcReceiveTrafficDescriptorParam2.setDescription('The second parameter of the receive parameter vector for this VPC, used according to the value of atmfVpcReceiveTrafficDescriptorType.')
atmfVpcReceiveTrafficDescriptorParam3 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 4, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcReceiveTrafficDescriptorParam3.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcReceiveTrafficDescriptorParam3.setDescription('The third parameter of the receive parameter vector for this VPC, used according to the value of atmfVpcReceiveTrafficDescriptorType.')
atmfVpcReceiveTrafficDescriptorParam4 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 4, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcReceiveTrafficDescriptorParam4.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcReceiveTrafficDescriptorParam4.setDescription('The fourth parameter of the receive parameter vector for this VPC, used according to the value of atmfVpcReceiveTrafficDescriptorType.')
atmfVpcReceiveTrafficDescriptorParam5 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 4, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcReceiveTrafficDescriptorParam5.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcReceiveTrafficDescriptorParam5.setDescription('The fifth parameter of the receive parameter vector for this VPC, used according to the value of atmfVpcReceiveTrafficDescriptorType.')
atmfVpcQoSCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 4, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("deterministic", 2), ("statistical", 3), ("unspecified", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcQoSCategory.setStatus('obsolete')
if mibBuilder.loadTexts: atmfVpcQoSCategory.setDescription('This object should not be implemented except as required for backward compatibility with version 2.0 of the UNI specification.')
atmfVpcTransmitQoSClass = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 4, 1, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcTransmitQoSClass.setStatus('deprecated')
if mibBuilder.loadTexts: atmfVpcTransmitQoSClass.setDescription('This object should not be implemented except as required for backward compatibility with version 3.1 of the UNI specification.')
atmfVpcReceiveQoSClass = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 4, 1, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcReceiveQoSClass.setStatus('deprecated')
if mibBuilder.loadTexts: atmfVpcReceiveQoSClass.setDescription('This object should not be implemented except as required for backward compatibility with version 3.1 of the UNI specification.')
atmfVpcBestEffortIndicator = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 4, 1, 1, 19), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcBestEffortIndicator.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcBestEffortIndicator.setDescription('The object is examined when atmfVpcTransmitTrafficDescriptorType or atmfVpcReceiveTrafficDescriptorType for the associated connection is equal to atmfNoClpNoScr. If this object is set to false(2), the network is requested to apply the CBR.1 conformance definition. If this object is set to true(1), the network is requested to apply the UBR.1 conformance definition.')
atmfVpcServiceCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 4, 1, 1, 20), AtmServiceCategory()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcServiceCategory.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcServiceCategory.setDescription('The service category of this virtual path connection.')
atmfVpcAbrTable = MibTable((1, 3, 6, 1, 4, 1, 353, 2, 9, 1), )
if mibBuilder.loadTexts: atmfVpcAbrTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcAbrTable.setDescription('A table of operational parameters related to the ABR virtual path connections which cross this ATM Interface. There is one entry in this table for each ABR virtual path connection. Each virtual path connection represented in this table must also be represented by an entry in the atmfVpcTable.')
atmfVpcAbrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 2, 9, 1, 1), ).setIndexNames((0, "ATM-FORUM-MIB", "atmfVpcAbrPortIndex"), (0, "ATM-FORUM-MIB", "atmfVpcAbrVpi"))
if mibBuilder.loadTexts: atmfVpcAbrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcAbrEntry.setDescription('An entry in the table, containing information about a particular ABR virtual path connection.')
atmfVpcAbrPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 9, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcAbrPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcAbrPortIndex.setDescription('The value of 0 which has the special meaning of identifying the ATM Interface over which this message was received.')
atmfVpcAbrVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 9, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcAbrVpi.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcAbrVpi.setDescription('The VPI value of this ABR Virtual Path Connection at the local ATM Interface.')
atmfVpcAbrTransmitIcr = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 9, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcAbrTransmitIcr.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcAbrTransmitIcr.setDescription('Initial Cell Rate: This is the rate at which the source starts, both initially and after an idle period. The unit is cells per second. The value must not be larger than PCR, and is usually lower.')
atmfVpcAbrTransmitNrm = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 9, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("nrm2", 1), ("nrm4", 2), ("nrm8", 3), ("nrm16", 4), ("nrm32", 5), ("nrm64", 6), ("nrm128", 7), ("nrm256", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcAbrTransmitNrm.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcAbrTransmitNrm.setDescription('The maximum number of data cells a source may send for each forward RM-cell. The default value is nrm32(5).')
atmfVpcAbrTransmitTrm = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 9, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("trm0point78125", 1), ("trm1point5625", 2), ("trm3point125", 3), ("trm6point25", 4), ("trm12point5", 5), ("trm25", 6), ("trm50", 7), ("trm100", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcAbrTransmitTrm.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcAbrTransmitTrm.setDescription('Upper bound on the time between forward RM-cells for an active source (in milliseconds). The default value is trm100(8).')
atmfVpcAbrTransmitCdf = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 9, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("cdf0", 1), ("cdfOneOver64", 2), ("cdfOneOver32", 3), ("cdfOneOver16", 4), ("cdfOneOver8", 5), ("cdfOneOver4", 6), ("cdfOneOver2", 7), ("cdfOne", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcAbrTransmitCdf.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcAbrTransmitCdf.setDescription('Cutoff Decrease Factor: This field controls the rate decrease associated with lost or delayed backward RM cells. Larger values result in faster rate decrease. The default value is cdfOneOver16(4).')
atmfVpcAbrTransmitRif = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 9, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("rifOneOver32768", 1), ("rifOneOver16384", 2), ("rifOneOver8192", 3), ("rifOneOver4096", 4), ("rifOneOver2048", 5), ("rifOneOver1024", 6), ("rifOneOver512", 7), ("rifOneOver256", 8), ("rifOneOver128", 9), ("rifOneOver64", 10), ("rifOneOver32", 11), ("rifOneOver16", 12), ("rifOneOver8", 13), ("rifOneOver4", 14), ("rifOneOver2", 15), ("rifOne", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcAbrTransmitRif.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcAbrTransmitRif.setDescription('Rate Increment Factor: Controls the rate at which the rate increases, when a backward RM-cell is received with CI=0 and NI=0. Larger values lead to faster rate increase. The default value is rifOneOver16(12).')
atmfVpcAbrTransmitRdf = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 9, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("rdfOneOver32768", 1), ("rdfOneOver16384", 2), ("rdfOneOver8192", 3), ("rdfOneOver4096", 4), ("rdfOneOver2048", 5), ("rdfOneOver1024", 6), ("rdfOneOver512", 7), ("rdfOneOver256", 8), ("rdfOneOver128", 9), ("rdfOneOver64", 10), ("rdfOneOver32", 11), ("rdfOneOver16", 12), ("rdfOneOver8", 13), ("rdfOneOver4", 14), ("rdfOneOver2", 15), ("rdfOne", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcAbrTransmitRdf.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcAbrTransmitRdf.setDescription('Rate Decrease Factor: Controls the rate decrease which occurs when backward RM-cells with CI=1, are received. Larger values lead to faster rate decrease. The default value is rdfOneOver16(12).')
atmfVpcAbrTransmitAdtf = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 9, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1023))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcAbrTransmitAdtf.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcAbrTransmitAdtf.setDescription('ACR Decrease Time Factor: Time permitted between sending RM-cells, before the allowed rate (ACR) is decreased to ICR. Range is 10 ms to 10.23 seconds. The unit is 10 milliseconds. For example, the default value of 50 corresponds to a time factor of 500 ms. Larger values allow a source to retain its current rate longer, during periods of relative inactivity. The default is 50 (0.5 seconds).')
atmfVpcAbrTransmitCrm = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 9, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8388608))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcAbrTransmitCrm.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcAbrTransmitCrm.setDescription('RM Cells Before Cutoff: Limits the number of forward RM-cells which may be sent in the absence of received backward RM-cells.')
atmfVccTable = MibTable((1, 3, 6, 1, 4, 1, 353, 2, 5, 1), )
if mibBuilder.loadTexts: atmfVccTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccTable.setDescription('A table of status and parameter information on the virtual channel connections which are visible at this ATM Interface. There is one entry in this table for each permanent virtual channel connection, including reserved VCCs that are supported; e.g., signalling, OAM flows, and ILMI, but not unassigned cells.')
atmfVccEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 2, 5, 1, 1), ).setIndexNames((0, "ATM-FORUM-MIB", "atmfVccPortIndex"), (0, "ATM-FORUM-MIB", "atmfVccVpi"), (0, "ATM-FORUM-MIB", "atmfVccVci"))
if mibBuilder.loadTexts: atmfVccEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccEntry.setDescription('An entry in the table, containing information about a particular virtual channel connection.')
atmfVccPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccPortIndex.setDescription('The value of 0 which has the special meaning of identifying the ATM Interface over which this message was received.')
atmfVccVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccVpi.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccVpi.setDescription('The VPI value of this Virtual Channel Connection at the local ATM Interface. For virtual interfaces (i.e. Virtual Path Connections), this value has no meaning and is set to zero ')
atmfVccVci = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 5, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccVci.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccVci.setDescription('The VCI value of this Virtual Channel Connection at the local ATM Interface.')
atmfVccOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 5, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unknown", 1), ("end2endUp", 2), ("end2endDown", 3), ("localUpEnd2endUnknown", 4), ("localDown", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccOperStatus.setDescription('The present actual operational status of the VCC. A value of end2endUp(2) or end2endUp(3) is used if the end to end status is known. If only local status is known a value of localUpEnd2endUnknown(4) or localDown(5) is used.')
atmfVccTransmitTrafficDescriptorType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 5, 1, 1, 5), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccTransmitTrafficDescriptorType.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccTransmitTrafficDescriptorType.setDescription('The type of traffic management, applicable to the transmit direction of this VCC. The type may indicate none, or a type with one or more parameters. These parameters are specified as a parameter vector, in the corresponding instances of the objects: atmfVccTransmitTrafficDescriptorParam1, atmfVccTransmitTrafficDescriptorParam2, atmfVccTransmitTrafficDescriptorParam3, atmfVccTransmitTrafficDescriptorParam4, and atmfVccTransmitTrafficDescriptorParam5.')
atmfVccTransmitTrafficDescriptorParam1 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 5, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccTransmitTrafficDescriptorParam1.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccTransmitTrafficDescriptorParam1.setDescription('The first parameter of the transmit parameter vector for this VCC, used according to the value of atmfVccTransmitTrafficDescriptorType.')
atmfVccTransmitTrafficDescriptorParam2 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 5, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccTransmitTrafficDescriptorParam2.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccTransmitTrafficDescriptorParam2.setDescription('The second parameter of the transmit parameter vector for this VCC, used according to the value of atmfVccTransmitTrafficDescriptorType.')
atmfVccTransmitTrafficDescriptorParam3 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 5, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccTransmitTrafficDescriptorParam3.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccTransmitTrafficDescriptorParam3.setDescription('The third parameter of the transmit parameter vector for this VCC, used according to the value of atmfVccTransmitTrafficDescriptorType.')
atmfVccTransmitTrafficDescriptorParam4 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 5, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccTransmitTrafficDescriptorParam4.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccTransmitTrafficDescriptorParam4.setDescription('The fourth parameter of the transmit parameter vector for this VCC, used according to the value of atmfVccTransmitTrafficDescriptorType.')
atmfVccTransmitTrafficDescriptorParam5 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 5, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccTransmitTrafficDescriptorParam5.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccTransmitTrafficDescriptorParam5.setDescription('The fifth parameter of the transmit parameter vector for this VCC, used according to the value of atmfVccTransmitTrafficDescriptorType.')
atmfVccReceiveTrafficDescriptorType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 5, 1, 1, 11), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccReceiveTrafficDescriptorType.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccReceiveTrafficDescriptorType.setDescription('The type of traffic management, applicable to the traffic in the receive direction of this VCC. The type may indicate none, or a type with one or more parameters. These parameters are specified as a parameter vector, in the corresponding instances of the objects: atmfVccReceiveTrafficDescriptorParam1, atmfVccReceiveTrafficDescriptorParam2, atmfVccReceiveTrafficDescriptorParam3, atmfVccReceiveTrafficDescriptorParam4, and atmfVccReceiveTrafficDescriptorParam5.')
atmfVccReceiveTrafficDescriptorParam1 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 5, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccReceiveTrafficDescriptorParam1.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccReceiveTrafficDescriptorParam1.setDescription('The first parameter of the receive parameter vector for this VCC, used according to the value of atmfVccReceiveTrafficDescriptorType.')
atmfVccReceiveTrafficDescriptorParam2 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 5, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccReceiveTrafficDescriptorParam2.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccReceiveTrafficDescriptorParam2.setDescription('The second parameter of the receive parameter vector for this VCC, used according to the value of atmfVccReceiveTrafficDescriptorType.')
atmfVccReceiveTrafficDescriptorParam3 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 5, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccReceiveTrafficDescriptorParam3.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccReceiveTrafficDescriptorParam3.setDescription('The third parameter of the receive parameter vector for this VCC, used according to the value of atmfVccReceiveTrafficDescriptorType.')
atmfVccReceiveTrafficDescriptorParam4 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 5, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccReceiveTrafficDescriptorParam4.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccReceiveTrafficDescriptorParam4.setDescription('The fourth parameter of the receive parameter vector for this VCC, used according to the value of atmfVccReceiveTrafficDescriptorType.')
atmfVccReceiveTrafficDescriptorParam5 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 5, 1, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccReceiveTrafficDescriptorParam5.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccReceiveTrafficDescriptorParam5.setDescription('The fifth parameter of the receive parameter vector for this VCC, used according to the value of atmfVccReceiveTrafficDescriptorType.')
atmfVccQoSCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 5, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("deterministic", 2), ("statistical", 3), ("unspecified", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccQoSCategory.setStatus('obsolete')
if mibBuilder.loadTexts: atmfVccQoSCategory.setDescription('This object should not be implemented except as required for backward compatibility with version 2.0 of the UNI specification.')
atmfVccTransmitQoSClass = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 5, 1, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccTransmitQoSClass.setStatus('deprecated')
if mibBuilder.loadTexts: atmfVccTransmitQoSClass.setDescription('This object should not be implemented except as required for backward compatibility with version 3.1 of the UNI specification.')
atmfVccReceiveQoSClass = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 5, 1, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccReceiveQoSClass.setStatus('deprecated')
if mibBuilder.loadTexts: atmfVccReceiveQoSClass.setDescription('This object should not be implemented except as required for backward compatibility with version 3.1 of the UNI specification.')
atmfVccBestEffortIndicator = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 5, 1, 1, 20), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccBestEffortIndicator.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccBestEffortIndicator.setDescription('The object is examined when atmfVccTransmitTrafficDescriptorType or atmfVccReceiveTrafficDescriptorType for the associated connection is equal to atmfNoClpNoScr. If this object is set to false(2), the network is requested to apply the CBR.1 conformance definition. If this object is set to true(1), the network is requested to apply the UBR.1 conformance definition.')
atmfVccTransmitFrameDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 5, 1, 1, 21), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccTransmitFrameDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccTransmitFrameDiscard.setDescription("If set to true(1), this object indicates that the network is requested to treat data for this connection (in the transmit direction) as frames (e.g. AAL5 CPCS_PDU's) rather than as individual cells. While the precise implementation is network-specific, this treatment may for example involve discarding entire frames during congestion, rather than a few cells from many frames. The default value is false(2).")
atmfVccReceiveFrameDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 5, 1, 1, 22), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccReceiveFrameDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccReceiveFrameDiscard.setDescription("If set to true(1), this object indicates that the network is requested to treat data for this connection (in the receive direction) as frames (e.g. AAL5 CPCS_PDU's) rather than as individual cells. While the precise implementation is network-specific, this treatment may for example involve discarding entire frames during congestion, rather than a few cells from many frames. The default value is false(2).")
atmfVccServiceCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 5, 1, 1, 23), AtmServiceCategory()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccServiceCategory.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccServiceCategory.setDescription('The service category of this virtual channel connection.')
atmfVccAbrTable = MibTable((1, 3, 6, 1, 4, 1, 353, 2, 10, 1), )
if mibBuilder.loadTexts: atmfVccAbrTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccAbrTable.setDescription('A table of operational parameters related to the ABR virtual channel connections which cross this ATM Interface. There is one entry in this table for each ABR virtual channel connection. Each virtual channel connection represented in this table must also be represented by an entry in the atmfVccTable.')
atmfVccAbrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 2, 10, 1, 1), ).setIndexNames((0, "ATM-FORUM-MIB", "atmfVccAbrPortIndex"), (0, "ATM-FORUM-MIB", "atmfVccAbrVpi"), (0, "ATM-FORUM-MIB", "atmfVccAbrVci"))
if mibBuilder.loadTexts: atmfVccAbrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccAbrEntry.setDescription('An entry in the table, containing information about a particular ABR virtual channel connection.')
atmfVccAbrPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 10, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccAbrPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccAbrPortIndex.setDescription('The value of 0 which has the special meaning of identifying the ATM Interface over which this message was received.')
atmfVccAbrVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 10, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccAbrVpi.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccAbrVpi.setDescription('The VPI value of this ABR Virtual Channel Connection at the local ATM Interface. For virtual interfaces (i.e. Virtual Path Connections), this value has no meaning and is set to zero ')
atmfVccAbrVci = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 10, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccAbrVci.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccAbrVci.setDescription('The VCI value of this ABR Virtual Channel Connection at the local ATM Interface.')
atmfVccAbrTransmitIcr = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 10, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccAbrTransmitIcr.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccAbrTransmitIcr.setDescription('Initial Cell Rate: This is the rate at which the source starts, both initially and after an idle period. The unit is cells per second. The value must not be larger than PCR, and is usually lower.')
atmfVccAbrTransmitNrm = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 10, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("nrm2", 1), ("nrm4", 2), ("nrm8", 3), ("nrm16", 4), ("nrm32", 5), ("nrm64", 6), ("nrm128", 7), ("nrm256", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccAbrTransmitNrm.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccAbrTransmitNrm.setDescription('The maximum number of data cells a source may send for each forward RM-cell. The default value is nrm32(5).')
atmfVccAbrTransmitTrm = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 10, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("trm0point78125", 1), ("trm1point5625", 2), ("trm3point125", 3), ("trm6point25", 4), ("trm12point5", 5), ("trm25", 6), ("trm50", 7), ("trm100", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccAbrTransmitTrm.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccAbrTransmitTrm.setDescription('Upper bound on the time between forward RM-cells for an active source (in milliseconds). The default value is trm100(8).')
atmfVccAbrTransmitCdf = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 10, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("cdf0", 1), ("cdfOneOver64", 2), ("cdfOneOver32", 3), ("cdfOneOver16", 4), ("cdfOneOver8", 5), ("cdfOneOver4", 6), ("cdfOneOver2", 7), ("cdfOne", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccAbrTransmitCdf.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccAbrTransmitCdf.setDescription('Cutoff Decrease Factor: This field controls the rate decrease associated with lost or delayed backward RM cells. Larger values result in faster rate decrease. The default value is cdfOneOver16(4).')
atmfVccAbrTransmitRif = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 10, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("rifOneOver32768", 1), ("rifOneOver16384", 2), ("rifOneOver8192", 3), ("rifOneOver4096", 4), ("rifOneOver2048", 5), ("rifOneOver1024", 6), ("rifOneOver512", 7), ("rifOneOver256", 8), ("rifOneOver128", 9), ("rifOneOver64", 10), ("rifOneOver32", 11), ("rifOneOver16", 12), ("rifOneOver8", 13), ("rifOneOver4", 14), ("rifOneOver2", 15), ("rifOne", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccAbrTransmitRif.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccAbrTransmitRif.setDescription('Rate Increment Factor: Controls the rate at which the rate increases, when a backward RM-cell is received with CI=0 and NI=0. Larger values lead to faster rate increase. The default value is rifOneOver16(12).')
atmfVccAbrTransmitRdf = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 10, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("rdfOneOver32768", 1), ("rdfOneOver16384", 2), ("rdfOneOver8192", 3), ("rdfOneOver4096", 4), ("rdfOneOver2048", 5), ("rdfOneOver1024", 6), ("rdfOneOver512", 7), ("rdfOneOver256", 8), ("rdfOneOver128", 9), ("rdfOneOver64", 10), ("rdfOneOver32", 11), ("rdfOneOver16", 12), ("rdfOneOver8", 13), ("rdfOneOver4", 14), ("rdfOneOver2", 15), ("rdfOne", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccAbrTransmitRdf.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccAbrTransmitRdf.setDescription('Rate Decrease Factor: Controls the rate decrease which occurs when backward RM-cells with CI=1, are received. Larger values lead to faster rate decrease. The default value is rdfOneOver16(12).')
atmfVccAbrTransmitAdtf = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 10, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1023))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccAbrTransmitAdtf.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccAbrTransmitAdtf.setDescription('ACR Decrease Time Factor: Time permitted between sending RM-cells, before the allowed rate (ACR) is decreased to ICR. Range is 10 ms to 10.23 seconds. The unit is 10 milliseconds. For example, the default value of 50 corresponds to a time factor of 500 ms. Larger values allow a source to retain its current rate longer, during periods of relative inactivity. The default is 50 (0.5 seconds).')
atmfVccAbrTransmitCrm = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 10, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8388608))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccAbrTransmitCrm.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccAbrTransmitCrm.setDescription('RM Cells Before Cutoff: Limits the number of forward RM-cells which may be sent in the absence of received backward RM-cells.')
mibBuilder.exportSymbols("ATM-FORUM-MIB", atmfVccOperStatus=atmfVccOperStatus, atmfAtmLayerMaxVpiBits=atmfAtmLayerMaxVpiBits, atmfVpcQoSCategory=atmfVpcQoSCategory, atmfPortMyIfIdentifier=atmfPortMyIfIdentifier, atmfVpcTransmitQoSClass=atmfVpcTransmitQoSClass, atmfVccAbrPortIndex=atmfVccAbrPortIndex, atmfAtmStatsEntry=atmfAtmStatsEntry, atmfAtmStatsIndex=atmfAtmStatsIndex, atmfAtmLayerIlmiVersion=atmfAtmLayerIlmiVersion, atmfVccReceiveTrafficDescriptorType=atmfVccReceiveTrafficDescriptorType, atmfVpcBestEffortIndicator=atmfVpcBestEffortIndicator, atmfVccVci=atmfVccVci, atmfVpcTable=atmfVpcTable, atmfVccAbrTable=atmfVccAbrTable, atmfVccTransmitTrafficDescriptorParam3=atmfVccTransmitTrafficDescriptorParam3, atmfVpcTransmitTrafficDescriptorParam3=atmfVpcTransmitTrafficDescriptorParam3, atmfVpcEntry=atmfVpcEntry, atmfAtmLayerNniSigVersion=atmfAtmLayerNniSigVersion, atmfPortMyIfName=atmfPortMyIfName, atmfVpcReceiveTrafficDescriptorType=atmfVpcReceiveTrafficDescriptorType, atmfVccServiceCategory=atmfVccServiceCategory, atmfVccAbrTransmitIcr=atmfVccAbrTransmitIcr, atmfVccReceiveTrafficDescriptorParam2=atmfVccReceiveTrafficDescriptorParam2, atmfVccTransmitTrafficDescriptorParam4=atmfVccTransmitTrafficDescriptorParam4, atmfVpcAbrVpi=atmfVpcAbrVpi, atmfAtmLayerConfiguredVPCs=atmfAtmLayerConfiguredVPCs, atmfVpcTransmitTrafficDescriptorParam2=atmfVpcTransmitTrafficDescriptorParam2, atmfAtmLayerMaxSvccVpi=atmfAtmLayerMaxSvccVpi, atmfVccReceiveFrameDiscard=atmfVccReceiveFrameDiscard, atmfAtmStatsTable=atmfAtmStatsTable, atmfVccReceiveTrafficDescriptorParam1=atmfVccReceiveTrafficDescriptorParam1, atmfAtmLayerMaxVPCs=atmfAtmLayerMaxVPCs, atmfVpcReceiveTrafficDescriptorParam2=atmfVpcReceiveTrafficDescriptorParam2, atmfVpcVpi=atmfVpcVpi, atmfVccTransmitQoSClass=atmfVccTransmitQoSClass, atmfPortTransmissionType=atmfPortTransmissionType, atmfPortTable=atmfPortTable, atmfVpcTransmitTrafficDescriptorType=atmfVpcTransmitTrafficDescriptorType, atmfAtmLayerConfiguredVCCs=atmfAtmLayerConfiguredVCCs, atmfVpcAbrTransmitRdf=atmfVpcAbrTransmitRdf, atmfVpcReceiveTrafficDescriptorParam3=atmfVpcReceiveTrafficDescriptorParam3, atmfVpcOperStatus=atmfVpcOperStatus, atmfVpcAbrTransmitRif=atmfVpcAbrTransmitRif, atmfVpcAbrTable=atmfVpcAbrTable, atmfAtmLayerMaxVciBits=atmfAtmLayerMaxVciBits, atmfPortIndex=atmfPortIndex, atmfVpcReceiveTrafficDescriptorParam1=atmfVpcReceiveTrafficDescriptorParam1, atmfVccAbrVci=atmfVccAbrVci, atmfAtmLayerMaxVCCs=atmfAtmLayerMaxVCCs, atmfVpcReceiveTrafficDescriptorParam5=atmfVpcReceiveTrafficDescriptorParam5, atmfVccEntry=atmfVccEntry, atmfVpcPortIndex=atmfVpcPortIndex, atmfAtmLayerDeviceType=atmfAtmLayerDeviceType, atmfMyOsiNmNsapAddress=atmfMyOsiNmNsapAddress, atmfVpcTransmitTrafficDescriptorParam4=atmfVpcTransmitTrafficDescriptorParam4, atmfVccBestEffortIndicator=atmfVccBestEffortIndicator, atmfAtmLayerUniVersion=atmfAtmLayerUniVersion, atmfAtmStatsTransmittedCells=atmfAtmStatsTransmittedCells, atmfVccQoSCategory=atmfVccQoSCategory, atmfVpcAbrTransmitNrm=atmfVpcAbrTransmitNrm, atmfVpcTransmitTrafficDescriptorParam1=atmfVpcTransmitTrafficDescriptorParam1, atmfVpcAbrTransmitCrm=atmfVpcAbrTransmitCrm, atmfVccAbrTransmitRdf=atmfVccAbrTransmitRdf, atmfVpcAbrTransmitCdf=atmfVpcAbrTransmitCdf, atmfMyIpNmAddress=atmfMyIpNmAddress, atmfVpcAbrTransmitIcr=atmfVpcAbrTransmitIcr, atmfVpcReceiveTrafficDescriptorParam4=atmfVpcReceiveTrafficDescriptorParam4, atmfAtmLayerMinSvccVci=atmfAtmLayerMinSvccVci, atmfAtmStatsDroppedReceivedCells=atmfAtmStatsDroppedReceivedCells, atmfPortOperStatus=atmfPortOperStatus, AtmAddress=AtmAddress, atmfAtmStatsReceivedCells=atmfAtmStatsReceivedCells, atmfPortMediaType=atmfPortMediaType, atmfVccTable=atmfVccTable, atmfVccAbrTransmitNrm=atmfVccAbrTransmitNrm, atmfVpcServiceCategory=atmfVpcServiceCategory, atmfVccAbrTransmitRif=atmfVccAbrTransmitRif, atmfVccReceiveTrafficDescriptorParam5=atmfVccReceiveTrafficDescriptorParam5, atmfVccTransmitTrafficDescriptorParam2=atmfVccTransmitTrafficDescriptorParam2, atmfAtmLayerUniType=atmfAtmLayerUniType, atmfPortEntry=atmfPortEntry, atmfVccTransmitFrameDiscard=atmfVccTransmitFrameDiscard, atmfVccAbrTransmitAdtf=atmfVccAbrTransmitAdtf, atmfVccAbrEntry=atmfVccAbrEntry, atmfVpcTransmitTrafficDescriptorParam5=atmfVpcTransmitTrafficDescriptorParam5, atmfVccReceiveQoSClass=atmfVccReceiveQoSClass, atmfVccTransmitTrafficDescriptorParam5=atmfVccTransmitTrafficDescriptorParam5, atmfPortSpecific=atmfPortSpecific, atmfVccAbrVpi=atmfVccAbrVpi, atmfAtmLayerIndex=atmfAtmLayerIndex, atmfAtmLayerMaxSvpcVpi=atmfAtmLayerMaxSvpcVpi, atmfVccTransmitTrafficDescriptorParam1=atmfVccTransmitTrafficDescriptorParam1, atmfVccAbrTransmitCrm=atmfVccAbrTransmitCrm, atmfMySystemIdentifier=atmfMySystemIdentifier, atmfVpcReceiveQoSClass=atmfVpcReceiveQoSClass, atmfPortAddress=atmfPortAddress, atmfVccReceiveTrafficDescriptorParam3=atmfVccReceiveTrafficDescriptorParam3, atmfAtmLayerEntry=atmfAtmLayerEntry, atmfVccAbrTransmitTrm=atmfVccAbrTransmitTrm, atmfVccVpi=atmfVccVpi, atmfVpcAbrEntry=atmfVpcAbrEntry, atmfVpcAbrTransmitAdtf=atmfVpcAbrTransmitAdtf, atmfVpcAbrPortIndex=atmfVpcAbrPortIndex, atmfVccTransmitTrafficDescriptorType=atmfVccTransmitTrafficDescriptorType, atmfAtmLayerTable=atmfAtmLayerTable, atmfVccPortIndex=atmfVccPortIndex, atmfVccReceiveTrafficDescriptorParam4=atmfVccReceiveTrafficDescriptorParam4, atmfVpcAbrTransmitTrm=atmfVpcAbrTransmitTrm, atmfVccAbrTransmitCdf=atmfVccAbrTransmitCdf)

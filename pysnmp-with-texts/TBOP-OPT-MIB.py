#
# PySNMP MIB module TBOP-OPT-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/TBOP-OPT-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:15:30 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ValueRangeConstraint, ValueSizeConstraint, SingleValueConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ValueRangeConstraint", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsIntersection")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
MibScalar, MibTable, MibTableRow, MibTableColumn, Gauge32, enterprises, Unsigned32, Integer32, ModuleIdentity, ObjectIdentity, IpAddress, MibIdentifier, TimeTicks, iso, Bits, NotificationType, Counter64, Counter32 = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Gauge32", "enterprises", "Unsigned32", "Integer32", "ModuleIdentity", "ObjectIdentity", "IpAddress", "MibIdentifier", "TimeTicks", "iso", "Bits", "NotificationType", "Counter64", "Counter32")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
codex = MibIdentifier((1, 3, 6, 1, 4, 1, 449))
cdxProductSpecific = MibIdentifier((1, 3, 6, 1, 4, 1, 449, 2))
cdx6500 = MibIdentifier((1, 3, 6, 1, 4, 1, 449, 2, 1))
cdx6500Configuration = MibIdentifier((1, 3, 6, 1, 4, 1, 449, 2, 1, 2))
cdx6500CfgProtocolGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1))
cdx6500PCTPortProtocolGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 1))
cdx6500Statistics = MibIdentifier((1, 3, 6, 1, 4, 1, 449, 2, 1, 3))
cdx6500StatProtocolGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 1))
cdx6500PSTPortProtocolGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 1, 1))
cdx6500Controls = MibIdentifier((1, 3, 6, 1, 4, 1, 449, 2, 1, 4))
class Counter16(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 65535)

class DisplayString(OctetString):
    pass

cdx6500PPCTTBOPPortTable = MibTable((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 1, 7), )
if mibBuilder.loadTexts: cdx6500PPCTTBOPPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PPCTTBOPPortTable.setDescription('This table contains TBOP Port configuration parameters.')
cdx6500PPCTTBOPPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 1, 7, 1), ).setIndexNames((0, "TBOP-OPT-MIB", "cdx6500TBOPCfgPortNumber"))
if mibBuilder.loadTexts: cdx6500PPCTTBOPPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PPCTTBOPPortEntry.setDescription('Each PortEntry contains the configuration parameters for one TBOP port.')
cdx6500TBOPCfgPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 1, 7, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 54))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500TBOPCfgPortNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500TBOPCfgPortNumber.setDescription('Port number of the port being used by TBOP.')
cdx6500TBOPCfgPortEIAOpt = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 1, 7, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 8, 50, 100))).clone(namedValues=NamedValues(("simp", 0), ("dtr", 1), ("dtrd", 2), ("dtrp", 8), ("newvalSimp", 50), ("nc", 100)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500TBOPCfgPortEIAOpt.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500TBOPCfgPortEIAOpt.setDescription("Specifies the control signal handshake and clocking required for a connection to be made to this port legal values are : simp - Simple, no control signals required. dtr - Dedicated, require the data terminal ready signal (DTR). dtrd - Same as DTR, except data set ready (DSR) drops between calls. dtrp - Same as DTR, except DSR/DCD/CTS are held low in the idle state. newvalSimp - same functionality as 'simp', new enumeration added for RFC1155 compatibility. nc - Parameter not configured.")
cdx6500TBOPCfgPortClockType = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 1, 7, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 50, 100))).clone(namedValues=NamedValues(("int", 0), ("ext", 1), ("newvalInt", 50), ("nc", 100)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500TBOPCfgPortClockType.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500TBOPCfgPortClockType.setDescription("int - internal clock source. ext - external clock source. newval - same functionality as 'int', new enumeration added for RFC1155 compatibility. nc - parameter not configured.")
cdx6500TBOPCfgPortClockSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 1, 7, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 384000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500TBOPCfgPortClockSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500TBOPCfgPortClockSpeed.setDescription('This is the speed of the port in bits per second, Clock Source = int. Legal Range=1200-384000. A value 0 indicates parameter not configured.')
cdx6500TBOPCfgPortTxCoding = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 1, 7, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 50, 100))).clone(namedValues=NamedValues(("nrz", 0), ("nrzi", 1), ("newvalNrz", 50), ("nc", 100)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500TBOPCfgPortTxCoding.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500TBOPCfgPortTxCoding.setDescription("This is the data encoding used on the TBOP port. nrz - Non Return to Zero. nrzi - Non Return to Zero Inverted. newvalNrz - same functionality as 'nrz', new enumeration added for RFC1155 compatibility. nc - Parameter not configured.")
cdx6500TBOPCfgPortByteCount = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 1, 7, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1045))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500TBOPCfgPortByteCount.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500TBOPCfgPortByteCount.setDescription('This is the number of bytes collected from the line before data is forwarded. Legal values are : 128, 256, 384, 512, 640, 768, 896, 1036 and 1045. A value 0 indicates the parameter is not configured.')
cdx6500TBOPCfgPortEIASigAction = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 1, 7, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500TBOPCfgPortEIASigAction.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500TBOPCfgPortEIASigAction.setDescription('This specifies the EIA signaling actions allowed on the port: NONE - none SWITCH - switched carrier CTS - raise CTS in response to RTS A combination of CTS and SWITCH may be specified by summing (e.g. SWITCH+CTS). NC - Indicates the parameter not configued.')
cdx6500TBOPCfgPortOptions = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 1, 7, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 50, 100))).clone(namedValues=NamedValues(("none", 0), ("marki", 1), ("cbr", 2), ("newvalNone", 50), ("nc", 100)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500TBOPCfgPortOptions.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500TBOPCfgPortOptions.setDescription("Select options on this TBOP port as follows: none - port uses flag idle between frame exchanges and operates with as little as 2 idle flags between frames. marki - port uses mark idle between frame exchanges. (Required by System 36 - AS/400 series). cbr - for constant bit rate applications, the port operates with as little as 1 idle flag between frames. Also, if the outbound queue overflows, all frames on this queue will be purged. newvalNone - same functionality as 'none', new enumeration added for RFC1155 compatibility. nc - parameter not configured.")
cdx6500TBOPCfgPortRTSCTSDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 1, 7, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 200))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500TBOPCfgPortRTSCTSDelay.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500TBOPCfgPortRTSCTSDelay.setDescription('This specifies how long the TBOP port will delay CTS after RTS is raised when EIA Signaling Action = CTS. The delay is specified in 50 milliseconds units (1 = 50 milliseconds). Legal Range = 2-200. A value 0 indicates parameter not configured.')
cdx6500TBOPCfgPortDcdOnDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 1, 7, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500TBOPCfgPortDcdOnDelay.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500TBOPCfgPortDcdOnDelay.setDescription('This specifies the length of time that DCD is held high before data is transmitted to the attached device. This is used when EIA Signaling Action = SWITCH. The delay is specified in milliseconds. Legal Range=1-255. A value 0 indicates parameter not configured.')
cdx6500TBOPCfgPortAutoCallMnem = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 1, 7, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500TBOPCfgPortAutoCallMnem.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500TBOPCfgPortAutoCallMnem.setDescription('This mnemonic name is used for auto calling.')
cdx6500TBOPCfgPortAutoCallTO = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 1, 7, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500TBOPCfgPortAutoCallTO.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500TBOPCfgPortAutoCallTO.setDescription('This is the time interval in seconds between call attempts when auto calling.')
cdx6500TBOPCfgPortMaxAutoTries = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 1, 7, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500TBOPCfgPortMaxAutoTries.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500TBOPCfgPortMaxAutoTries.setDescription('This specifies the number of times the TBOP port will attempt to call. A value of 0 will allow unlimited attempts.')
cdx6500TBOPCfgPortSubAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 1, 7, 1, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500TBOPCfgPortSubAddress.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500TBOPCfgPortSubAddress.setDescription('Calls addressed to this node, with this subaddress will be routed to this TBOP port.')
cdx6500TBOPCfgPortCUG = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 1, 7, 1, 15), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(2, 23))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500TBOPCfgPortCUG.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500TBOPCfgPortCUG.setDescription('The TBOP port may be a member of up to 8 different Closed User Groups. Each CUG membership must be a two digit number (except --) and separated by a comma. ( e.g. 12,34,56,09,02,03 ). -- - No CUG Membership 00-99 - CUG Membership')
cdx6500TBOPCfgPortEnableBill = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 1, 7, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 50))).clone(namedValues=NamedValues(("off", 0), ("on", 1), ("newvalOff", 50)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500TBOPCfgPortEnableBill.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500TBOPCfgPortEnableBill.setDescription("This controls whether billing (accounting) records will be created for calls on this TBOP port. newvalOff - same functionality as 'off', new enumeration added for RFC1155 compatibility.")
cdx6500TBOPCfgDimType = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 1, 7, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 50))).clone(namedValues=NamedValues(("off", 0), ("on", 1), ("newvalOff", 50)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500TBOPCfgDimType.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500TBOPCfgDimType.setDescription('This controls the Interface Type.')
cdx6500TBOPCfgPortMaxRxQSize = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 1, 7, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 501))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500TBOPCfgPortMaxRxQSize.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500TBOPCfgPortMaxRxQSize.setDescription("This parameter should be used with extreme caution. If using a non-default value, it is assumed you have discussed your application requirements with the manufacturer's support staff. A non-default value may result in excessive consumption of buffers, which can significantly impair the operation of all traffic over the node. This parameter defines the maximum number of frames which the inbound queue will contain. Frames are placed in this queue when they cannot be forwarded to the network link. If pipelining is enabled, this queue may contain frame segments. Therefore with pipelining enabled, this queue will typicaly contain more entries during network congestion. The default value of zero will result in a queue size between 32 and 100 depending on available memory. Legal Range=0,16-500. A value 501 indicates parameter not configured.")
cdx6500TBOPCfgPortMaxTxQSize = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 1, 7, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 800))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500TBOPCfgPortMaxTxQSize.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500TBOPCfgPortMaxTxQSize.setDescription('This defines the maximum number of frames which the outbound queue will contain. These frames are recombined frames, as they were originaly received by the remote TBOP port.')
cdx6500TBOPCfgPortChanT1E1_Conn = MibScalar((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 1, 7, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 100))).clone(namedValues=NamedValues(("no", 1), ("yes", 2), ("nc", 100)))).setLabel("cdx6500TBOPCfgPortChanT1E1-Conn").setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500TBOPCfgPortChanT1E1_Conn.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500TBOPCfgPortChanT1E1_Conn.setDescription("This specifies whether a frame check sequence is generated for transmitted frames and whether the frame check sequence is stripped from received frames. It should be set to YES when connecting to a virtual TBOP port which maps to a T1 or E1 port. YES - Generate FCS for transmitted frames and strip FCS from received frames. NO - Don't generate FCS for transmitted frames or strip FCS from received frames. NC - Indicates the parameter not configured.")
cdx6500TBOPCfgPortIdleFlagCount = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 1, 7, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500TBOPCfgPortIdleFlagCount.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500TBOPCfgPortIdleFlagCount.setDescription('The Minimum number of Idle flags between frames. If MARKi option is used, this should be greater or equal to 2 and this many number of Idle flags will be inserted between frames apart from Mark Flag(FF)s. Legal Range = 1-15. A value 0 indicates parameter not configured.')
cdx6500TBOPCfgPortElectricalInterfaceType = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 1, 7, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("v24", 1), ("v35", 2), ("v36", 3), ("x21", 4), ("none", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500TBOPCfgPortElectricalInterfaceType.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500TBOPCfgPortElectricalInterfaceType.setDescription('Specify the Electrical Interface Type: V.24 - V.24 Electrical Interface Type V.35 - V.35 Electrical Interface Type V.36 - V.36 Electrical Interface Type X.21 - X.21 Electrical Interface Type NONE - Electrically disabled')
cdx6500TBOPCfgPortV24ElectricalInterfaceOption = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 1, 7, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ri", 1), ("tm", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500TBOPCfgPortV24ElectricalInterfaceOption.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500TBOPCfgPortV24ElectricalInterfaceOption.setDescription('Specify the Pin 22 option: RI - V.24 uses Pin 22 for Ring Indicator output signal TM - V.24 uses Pin 22 for Test Mode input signal')
cdx6500TBOPCfgPortHighSpeedElectricalInterfaceOption = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 1, 7, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("none", 1), ("xover", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500TBOPCfgPortHighSpeedElectricalInterfaceOption.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500TBOPCfgPortHighSpeedElectricalInterfaceOption.setDescription('Specify the cable type: NONE - V.35/V.36/X.21 DCE with straight through cable XOVER - V.35/V.36/X.21 DCE with crossover adapter cable')
cdx6500TBOPCfgPortMaxFrameSize = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 2, 1, 1, 7, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16384))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500TBOPCfgPortMaxFrameSize.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500TBOPCfgPortMaxFrameSize.setDescription('This defines the maximum frame size which can be received by TBOP. The frame size is defined as the total number of octets in between flags. This parameter must be programmed as an even value. Legal Range = 1036-16384. A value 0 indicates the parameter not configured.')
cdx6500PPSTTBOPPortTable = MibTable((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 1, 1, 7), )
if mibBuilder.loadTexts: cdx6500PPSTTBOPPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PPSTTBOPPortTable.setDescription('This table holds statistics items for TBOP ports')
cdx6500PPSTTBOPPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 1, 1, 7, 1), ).setIndexNames((0, "TBOP-OPT-MIB", "cdx6500TBOPStPortNumber"))
if mibBuilder.loadTexts: cdx6500PPSTTBOPPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500PPSTTBOPPortEntry.setDescription('This entry holds the statistics items for one TBOP port.')
cdx6500TBOPStPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 1, 1, 7, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 54))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500TBOPStPortNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500TBOPStPortNumber.setDescription('The port number for this TBOP entry.')
cdx6500TBOPStPortStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 1, 1, 7, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(2, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500TBOPStPortStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500TBOPStPortStatus.setDescription('Specifies current port Status. Up : Port is enabled by the CTP Disabled : Port is disabled by CTP Busy Out : The port is busy out by the CTP Down : Port is not enabled disables, or busy out by the CTP. Note : Port Status indicates Down state only if the TBOP port CMEM record entry portEnable gets corrupted. ')
cdx6500TBOPStPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 1, 1, 7, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500TBOPStPortState.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500TBOPStPortState.setDescription('The EIA state of the port.')
cdx6500TBOPStPortSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 1, 1, 7, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500TBOPStPortSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500TBOPStPortSpeed.setDescription('The measured port speed in bits per second.')
cdx6500TBOPStOverrunErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 1, 1, 7, 1, 5), Counter16()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500TBOPStOverrunErrors.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500TBOPStOverrunErrors.setDescription('Total number of overrun errors counted by the I/O driver.')
cdx6500TBOPStUnderrunErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 1, 1, 7, 1, 6), Counter16()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500TBOPStUnderrunErrors.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500TBOPStUnderrunErrors.setDescription('Total number of underrun errors counted by the I/O driver.')
cdx6500TBOPStCRCErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 1, 1, 7, 1, 7), Counter16()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500TBOPStCRCErrors.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500TBOPStCRCErrors.setDescription('Total number of CRC errors counted by the I/O driver.')
cdx6500TBOPStPortRxChars = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 1, 1, 7, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500TBOPStPortRxChars.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500TBOPStPortRxChars.setDescription('Total number of data characters received since last boot or statistics reset, header characters are not included.')
cdx6500TBOPStPortRxCharsSec = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 1, 1, 7, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500TBOPStPortRxCharsSec.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500TBOPStPortRxCharsSec.setDescription('The average number of characters received per second.')
cdx6500TBOPStPortRxFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 1, 1, 7, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500TBOPStPortRxFrames.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500TBOPStPortRxFrames.setDescription('Total number of SDLC frames received since last boot or statistices reset.')
cdx6500TBOPStPortRxFramesSec = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 1, 1, 7, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500TBOPStPortRxFramesSec.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500TBOPStPortRxFramesSec.setDescription('The average number of frames received per second.')
cdx6500TBOPStPortTxChars = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 1, 1, 7, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500TBOPStPortTxChars.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500TBOPStPortTxChars.setDescription('Total number of data characters transmitted since last boot or statistics reset, header characters are not included.')
cdx6500TBOPStPortTxCharsSec = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 1, 1, 7, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500TBOPStPortTxCharsSec.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500TBOPStPortTxCharsSec.setDescription('The average number of characters transmitted per second.')
cdx6500TBOPStPortTxFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 1, 1, 7, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500TBOPStPortTxFrames.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500TBOPStPortTxFrames.setDescription('Total number of SDLC frames trnsmitted since last boot or statistics reset.')
cdx6500TBOPStPortTxFramesSec = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 1, 1, 7, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500TBOPStPortTxFramesSec.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500TBOPStPortTxFramesSec.setDescription('The average number of frames transmitted per second.')
cdx6500TBOPStPortRxUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 1, 1, 7, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500TBOPStPortRxUtil.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500TBOPStPortRxUtil.setDescription('Percentage of port receive bandwidth used.')
cdx6500TBOPStPortTxUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 1, 1, 7, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500TBOPStPortTxUtil.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500TBOPStPortTxUtil.setDescription('Percentage of port transmit bandwidth used.')
cdx6500TBOPStPortFramesQueued = MibTableColumn((1, 3, 6, 1, 4, 1, 449, 2, 1, 3, 1, 1, 7, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdx6500TBOPStPortFramesQueued.setStatus('mandatory')
if mibBuilder.loadTexts: cdx6500TBOPStPortFramesQueued.setDescription('Number of SDLC frames queued to the I/O drivers.')
mibBuilder.exportSymbols("TBOP-OPT-MIB", cdx6500TBOPStOverrunErrors=cdx6500TBOPStOverrunErrors, cdx6500TBOPCfgPortOptions=cdx6500TBOPCfgPortOptions, cdx6500TBOPCfgPortChanT1E1_Conn=cdx6500TBOPCfgPortChanT1E1_Conn, cdx6500TBOPCfgPortV24ElectricalInterfaceOption=cdx6500TBOPCfgPortV24ElectricalInterfaceOption, cdx6500CfgProtocolGroup=cdx6500CfgProtocolGroup, cdx6500TBOPCfgPortTxCoding=cdx6500TBOPCfgPortTxCoding, cdx6500TBOPCfgPortAutoCallMnem=cdx6500TBOPCfgPortAutoCallMnem, cdx6500TBOPCfgPortAutoCallTO=cdx6500TBOPCfgPortAutoCallTO, cdx6500TBOPStPortStatus=cdx6500TBOPStPortStatus, cdx6500PPCTTBOPPortEntry=cdx6500PPCTTBOPPortEntry, cdx6500TBOPStPortRxFrames=cdx6500TBOPStPortRxFrames, cdx6500TBOPCfgPortEnableBill=cdx6500TBOPCfgPortEnableBill, cdx6500TBOPCfgPortClockSpeed=cdx6500TBOPCfgPortClockSpeed, cdx6500TBOPCfgPortHighSpeedElectricalInterfaceOption=cdx6500TBOPCfgPortHighSpeedElectricalInterfaceOption, cdx6500TBOPStPortRxUtil=cdx6500TBOPStPortRxUtil, cdx6500StatProtocolGroup=cdx6500StatProtocolGroup, Counter16=Counter16, cdx6500TBOPCfgPortByteCount=cdx6500TBOPCfgPortByteCount, cdx6500TBOPCfgPortMaxFrameSize=cdx6500TBOPCfgPortMaxFrameSize, cdx6500TBOPStPortRxCharsSec=cdx6500TBOPStPortRxCharsSec, cdx6500TBOPCfgPortDcdOnDelay=cdx6500TBOPCfgPortDcdOnDelay, cdx6500TBOPCfgPortEIASigAction=cdx6500TBOPCfgPortEIASigAction, cdx6500TBOPCfgPortIdleFlagCount=cdx6500TBOPCfgPortIdleFlagCount, cdx6500PSTPortProtocolGroup=cdx6500PSTPortProtocolGroup, cdxProductSpecific=cdxProductSpecific, codex=codex, cdx6500TBOPCfgPortRTSCTSDelay=cdx6500TBOPCfgPortRTSCTSDelay, cdx6500TBOPCfgPortSubAddress=cdx6500TBOPCfgPortSubAddress, cdx6500TBOPStPortTxFrames=cdx6500TBOPStPortTxFrames, cdx6500TBOPCfgPortMaxTxQSize=cdx6500TBOPCfgPortMaxTxQSize, cdx6500TBOPCfgPortNumber=cdx6500TBOPCfgPortNumber, cdx6500TBOPCfgPortMaxAutoTries=cdx6500TBOPCfgPortMaxAutoTries, cdx6500TBOPStPortState=cdx6500TBOPStPortState, cdx6500TBOPCfgPortClockType=cdx6500TBOPCfgPortClockType, cdx6500PPSTTBOPPortTable=cdx6500PPSTTBOPPortTable, cdx6500Controls=cdx6500Controls, cdx6500TBOPCfgPortEIAOpt=cdx6500TBOPCfgPortEIAOpt, cdx6500TBOPCfgPortElectricalInterfaceType=cdx6500TBOPCfgPortElectricalInterfaceType, cdx6500TBOPStCRCErrors=cdx6500TBOPStCRCErrors, cdx6500TBOPStPortTxUtil=cdx6500TBOPStPortTxUtil, cdx6500PPSTTBOPPortEntry=cdx6500PPSTTBOPPortEntry, cdx6500Configuration=cdx6500Configuration, cdx6500TBOPStPortRxFramesSec=cdx6500TBOPStPortRxFramesSec, cdx6500=cdx6500, cdx6500TBOPStPortTxCharsSec=cdx6500TBOPStPortTxCharsSec, DisplayString=DisplayString, cdx6500Statistics=cdx6500Statistics, cdx6500TBOPStPortSpeed=cdx6500TBOPStPortSpeed, cdx6500TBOPStPortTxFramesSec=cdx6500TBOPStPortTxFramesSec, cdx6500TBOPStPortFramesQueued=cdx6500TBOPStPortFramesQueued, cdx6500TBOPCfgPortCUG=cdx6500TBOPCfgPortCUG, cdx6500TBOPCfgDimType=cdx6500TBOPCfgDimType, cdx6500TBOPStPortTxChars=cdx6500TBOPStPortTxChars, cdx6500PPCTTBOPPortTable=cdx6500PPCTTBOPPortTable, cdx6500TBOPStPortNumber=cdx6500TBOPStPortNumber, cdx6500TBOPStUnderrunErrors=cdx6500TBOPStUnderrunErrors, cdx6500TBOPStPortRxChars=cdx6500TBOPStPortRxChars, cdx6500TBOPCfgPortMaxRxQSize=cdx6500TBOPCfgPortMaxRxQSize, cdx6500PCTPortProtocolGroup=cdx6500PCTPortProtocolGroup)

#
# PySNMP MIB module RADLAN-BRGMACSWITCH-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/RADLAN-BRGMACSWITCH-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:45:29 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, SingleValueConstraint, ConstraintsIntersection, ValueSizeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsIntersection", "ValueSizeConstraint", "ConstraintsUnion")
rnd, = mibBuilder.importSymbols("RADLAN-MIB", "rnd")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
MibIdentifier, Counter64, Unsigned32, IpAddress, Integer32, Gauge32, ModuleIdentity, Bits, TimeTicks, Counter32, NotificationType, ObjectIdentity, iso, MibScalar, MibTable, MibTableRow, MibTableColumn = mibBuilder.importSymbols("SNMPv2-SMI", "MibIdentifier", "Counter64", "Unsigned32", "IpAddress", "Integer32", "Gauge32", "ModuleIdentity", "Bits", "TimeTicks", "Counter32", "NotificationType", "ObjectIdentity", "iso", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn")
TextualConvention, TruthValue, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "TruthValue", "DisplayString")
rlBrgMacSwitch = ModuleIdentity((1, 3, 6, 1, 4, 1, 89, 50))
rlBrgMacSwitch.setRevisions(('2007-01-02 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: rlBrgMacSwitch.setRevisionsDescriptions(('Initial revision.',))
if mibBuilder.loadTexts: rlBrgMacSwitch.setLastUpdated('200701020000Z')
if mibBuilder.loadTexts: rlBrgMacSwitch.setOrganization('Radlan - a MARVELL company. Marvell Semiconductor, Inc.')
if mibBuilder.loadTexts: rlBrgMacSwitch.setContactInfo('www.marvell.com')
if mibBuilder.loadTexts: rlBrgMacSwitch.setDescription('This private MIB module defines Switching Parameters private MIBs.')
rlBrgMacSwVersion = MibScalar((1, 3, 6, 1, 4, 1, 89, 50, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlBrgMacSwVersion.setStatus('current')
if mibBuilder.loadTexts: rlBrgMacSwVersion.setDescription("MIB's version, the current version is 2.")
rlBrgMacSwMaxTableNumber = MibScalar((1, 3, 6, 1, 4, 1, 89, 50, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlBrgMacSwMaxTableNumber.setStatus('current')
if mibBuilder.loadTexts: rlBrgMacSwMaxTableNumber.setDescription('Maximum number of MAC Tables supported by the device.')
rlBrgMacSwDynamicTables = MibScalar((1, 3, 6, 1, 4, 1, 89, 50, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("supported", 1), ("unsupported", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlBrgMacSwDynamicTables.setStatus('current')
if mibBuilder.loadTexts: rlBrgMacSwDynamicTables.setDescription('Specifies whether the device supports port dynamic MAC tables.')
rlBrgMacSwOldEntryDeleteMode = MibScalar((1, 3, 6, 1, 4, 1, 89, 50, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("refreshFlag", 1), ("agingFlag", 2), ("agingTime", 3), ("boundaries", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlBrgMacSwOldEntryDeleteMode.setStatus('current')
if mibBuilder.loadTexts: rlBrgMacSwOldEntryDeleteMode.setDescription("The method used to delete old unused entries refresh_flag: The high level sets a flag when it adds or updates an entry, the Switch clears the flag each time, when it learns the station once more. aging_flag: The high level clears a flag when it adds or updates an entry, the Switch sets the flag each time, when it learns the station once more. aging_time: The high level defines a timeout, the Switch sends a message to the high level each time when the station doesn't send messages during interval between timeout and 2*timeout. Boundaries: The Switch doesn't support any mechanism, and the high level uses two boundaries: red and yellow. When the number of entries exceeds the red boundary, the high level deletes the oldest entries.")
rlBrgMacSwSpanningTree = MibScalar((1, 3, 6, 1, 4, 1, 89, 50, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("supported", 1), ("unsupported", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlBrgMacSwSpanningTree.setStatus('current')
if mibBuilder.loadTexts: rlBrgMacSwSpanningTree.setDescription('Specifies whether the device supports port the Spanning Tree Protocol.')
rlBrgMacSwKeyType = MibScalar((1, 3, 6, 1, 4, 1, 89, 50, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("macOnly", 1), ("tagAndMac", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlBrgMacSwKeyType.setStatus('current')
if mibBuilder.loadTexts: rlBrgMacSwKeyType.setDescription('Specified the used MAC Address Table kye format: macOnly: One global MAC Address Table per device (leaky VLANs). tagAndMac: MAC Address Table per each VLAN (strick VLANs).')
rlBrgMacSwYellowBoundary = MibScalar((1, 3, 6, 1, 4, 1, 89, 50, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlBrgMacSwYellowBoundary.setStatus('current')
if mibBuilder.loadTexts: rlBrgMacSwYellowBoundary.setDescription('The yellow boundary.')
rlBrgMacSwRedBoundary = MibScalar((1, 3, 6, 1, 4, 1, 89, 50, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlBrgMacSwRedBoundary.setStatus('current')
if mibBuilder.loadTexts: rlBrgMacSwRedBoundary.setDescription('The yellow boundary.')
rlBrgMacSwTrapEnable = MibScalar((1, 3, 6, 1, 4, 1, 89, 50, 10), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlBrgMacSwTrapEnable.setStatus('current')
if mibBuilder.loadTexts: rlBrgMacSwTrapEnable.setDescription('This variable indicates whether to create a SNMP trap if adding dynamic mac failed due to full hash chain.')
rlBrgMacSwOperTrapCount = MibScalar((1, 3, 6, 1, 4, 1, 89, 50, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlBrgMacSwOperTrapCount.setStatus('current')
if mibBuilder.loadTexts: rlBrgMacSwOperTrapCount.setDescription("This variable indicates the trap counter status (i.e. number of received MAC addresses since the last trap sent that haven't been inserted into the hash). It is relevant only when trap is enabled.")
rlBrgMacSwAdminTrapFrequency = MibScalar((1, 3, 6, 1, 4, 1, 89, 50, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 86400)).clone(60)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlBrgMacSwAdminTrapFrequency.setStatus('current')
if mibBuilder.loadTexts: rlBrgMacSwAdminTrapFrequency.setDescription('This variable indicates the minimal frequency (in seconds) of sending a trap. It is relevant only when trap is enabled.')
mibBuilder.exportSymbols("RADLAN-BRGMACSWITCH-MIB", rlBrgMacSwTrapEnable=rlBrgMacSwTrapEnable, rlBrgMacSwOldEntryDeleteMode=rlBrgMacSwOldEntryDeleteMode, PYSNMP_MODULE_ID=rlBrgMacSwitch, rlBrgMacSwVersion=rlBrgMacSwVersion, rlBrgMacSwDynamicTables=rlBrgMacSwDynamicTables, rlBrgMacSwRedBoundary=rlBrgMacSwRedBoundary, rlBrgMacSwSpanningTree=rlBrgMacSwSpanningTree, rlBrgMacSwOperTrapCount=rlBrgMacSwOperTrapCount, rlBrgMacSwYellowBoundary=rlBrgMacSwYellowBoundary, rlBrgMacSwitch=rlBrgMacSwitch, rlBrgMacSwKeyType=rlBrgMacSwKeyType, rlBrgMacSwAdminTrapFrequency=rlBrgMacSwAdminTrapFrequency, rlBrgMacSwMaxTableNumber=rlBrgMacSwMaxTableNumber)

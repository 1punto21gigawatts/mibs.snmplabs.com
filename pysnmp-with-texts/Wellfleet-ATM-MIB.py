#
# PySNMP MIB module Wellfleet-ATM-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Wellfleet-ATM-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:39:30 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ValueSizeConstraint, SingleValueConstraint, ConstraintsIntersection, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsIntersection", "ConstraintsUnion")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
iso, ObjectIdentity, IpAddress, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter32, Bits, ModuleIdentity, NotificationType, MibIdentifier, Counter64, Integer32, Gauge32, Unsigned32, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "iso", "ObjectIdentity", "IpAddress", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter32", "Bits", "ModuleIdentity", "NotificationType", "MibIdentifier", "Counter64", "Integer32", "Gauge32", "Unsigned32", "TimeTicks")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
wfAtmInterfaceGroup, wfSonetGroup, wfAtmGroup = mibBuilder.importSymbols("Wellfleet-COMMON-MIB", "wfAtmInterfaceGroup", "wfSonetGroup", "wfAtmGroup")
wfAtmCommonGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1))
wfAtmLinkModuleGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2))
wfAtmCellSwitchGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3))
wfAtm = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 1))
wfAtmDelete = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmDelete.setDescription('Indication to create or delete an ATM Base record.')
wfAtmInterfaceNumber = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmInterfaceNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmInterfaceNumber.setDescription('Number of ATM interfaces in the Wellfleet Router (entries in the wfAtmInterfaceTable), regardless of their current state, present on this system.')
wfAtmOverallStatus = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("healthy", 1), ("interfaceanomaly", 2), ("otheranomaly", 3))).clone('healthy')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmOverallStatus.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmOverallStatus.setDescription('Overall status of ATM interfaces in the Wellfleet Router(entries in the wfAtmInterfaceTable) present on this system. Healthy indicates each configured interfaces are in the UP state. An interface anomaly is indicative of one or more of the configured interfaces being in the DOWN State. Other Anomaly is indicative of one or more ATM interfaces being in the INIT or NOT PRESENT state')
wfAtmGlobalSigStkVersion = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("u30", 1), ("u31", 2), ("sym", 3), ("u40", 4))).clone('u30')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmGlobalSigStkVersion.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmGlobalSigStkVersion.setDescription('Global signalling stack Version. This value will be used to by management entities to know the global version of signalling. The intent here is to have passive placeholder. Active versions of signalling are maintained on a per ATM interface basis in wfAtmSscopEntry and wfAtmSigEntry. If this is considered of no value, please remove at your earliest convenience.')
wfAtmInterfaceTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 2), )
if mibBuilder.loadTexts: wfAtmInterfaceTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmInterfaceTable.setDescription('ATM Interface Table - Router Resident The statistical and configuration parameters for an ATM Interface. There is one MIB instance of this record per Sync or HSSI line configured for ATM DXI support. The Physical ATM DXI interface is managed via this table.')
wfAtmInterfaceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 2, 1), ).setIndexNames((0, "Wellfleet-ATM-MIB", "wfAtmInterfaceLineNumber"), (0, "Wellfleet-ATM-MIB", "wfAtmInterfaceLLIndex"))
if mibBuilder.loadTexts: wfAtmInterfaceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmInterfaceEntry.setDescription('The attributes for a particular ATM DXI Interface')
wfAtmInterfaceDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmInterfaceDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmInterfaceDelete.setDescription('Indication to create or delete an ATM DXI interface. This will remove ATMNET access over this interface The ATM Interface entry instance is removed from the MIB in this case.')
wfAtmInterfaceDisable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmInterfaceDisable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmInterfaceDisable.setDescription('Indicates when an ATM DXI interface is to be enabled or disabled. Disabling will disable ATM Access over this interface. The ATM Interface instance is NOT removed from the MIB in this case.')
wfAtmInterfaceState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("init", 3), ("notpresent", 4))).clone('notpresent')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmInterfaceState.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmInterfaceState.setDescription('Indicates the state for this interface. The state indicates Not Present when the interface has been configured but has not been initialized. Init state indicates that the interface is in the process of being initialized by the system. Up state indicates that the interface is operating normally. Down state indicates that the ATM DXI interface is physically or logically disabled.')
wfAtmInterfaceCircuit = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmInterfaceCircuit.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmInterfaceCircuit.setDescription('The Wellfleet circuit number of this entry')
wfAtmInterfaceMaxSupportedVCs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 2, 1, 5), Integer32().clone(512)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmInterfaceMaxSupportedVCs.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmInterfaceMaxSupportedVCs.setDescription('Maximum number of VCs allowed on this interface. Initially set by configuration system for PVCs only')
wfAtmInterfaceVCsInUse = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmInterfaceVCsInUse.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmInterfaceVCsInUse.setDescription('The number of VCs that are currently configured on this interface')
wfAtmInterfaceDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 2, 1, 7), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmInterfaceDescr.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmInterfaceDescr.setDescription('A textual string describing this ATM interface.')
wfAtmInterfaceType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("ds1", 2), ("ds3", 3))).clone('other')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmInterfaceType.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmInterfaceType.setDescription('The transmission type used at the ATM interface.')
wfAtmInterfaceLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 2, 1, 9), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmInterfaceLastChange.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmInterfaceLastChange.setDescription('The value of sysUpTime at the time the interface entered its current operational state. If the current state was entered prior to the last re-initialization of the local network management subsystem, then this object contains a zero value.')
wfAtmInterfacePlcp = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 2, 1, 10), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmInterfacePlcp.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmInterfacePlcp.setDescription('Identifies the OID of the PLCP object in the MIB If no additional transmission and/or media specific information is available, this object has the value { 0 0 }. ')
wfAtmMpeNull = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("mpe1294", 1), ("null", 2), ("mpe1483", 3))).clone('mpe1483')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmMpeNull.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmMpeNull.setDescription('Used to select Null, Multi-Protocol Encapsulation (RFC 1294) or Multi-Protocol Encapsulation (RFC 1483) layer for this Interface. Null is considered VC Based Multiplexing and is not supported for Bridging.')
wfAtmCsNull = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("aal34", 1), ("null", 2), ("aal5", 3))).clone('aal5')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmCsNull.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmCsNull.setDescription("Used to configure the type of CS_PDU encapsulation supported on the ATM DXI interface based on the ATM Forum's ATM DXI specification. This configuration is on a per Interface basis. The supported values are AAL3/4, AAL5 and Null (no CS_PDU encapsulation). Null is a propriatary configurable value when no CS_PDU encapsulation is desired.")
wfAtmInterfaceMulticast = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmInterfaceMulticast.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmInterfaceMulticast.setDescription('This indicates whether the ATM service provider offers multicast service')
wfAtmDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmDrops.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmDrops.setDescription('The cumulative count of packet drops on this ATM Interface.')
wfAtmInterfaceLmiDisable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmInterfaceLmiDisable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmInterfaceLmiDisable.setDescription('Indicates when an LMI entry is to be enabled or disabled. Disabling will temporarily disable the ability to report CSU/DSU traps and the ability to retrieve statistical information from the CSU/DSU. The ATM LMI instance is NOT removed from the MIB in this case.')
wfAtmInterfaceLineNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 2, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmInterfaceLineNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmInterfaceLineNumber.setDescription('Instance identifier. This value corresponds to the line number of the Wellfleet router.')
wfAtmInterfaceLLIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 2, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmInterfaceLLIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmInterfaceLLIndex.setDescription("Instance identifier. This value corresponds to the port's llindex number. The Lower layer index uniquely identifies the lower layer in cases where the lower layer may be something other than the physical layer.")
wfAtmInterfaceDxiMode = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 2, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("mode1a", 1), ("mode1b", 2), ("mode2", 3), ("modep2", 4))).clone('mode1a')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmInterfaceDxiMode.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmInterfaceDxiMode.setDescription("ATM DXI Mode. This attribute specifies the ATM DXI Mode for this interface based on the ATM Forum's ATM DXI specification. Currently supported is Modes 1a, 1b, 2 and Proprietary 2 (which is an earlier version of Mode 2).")
wfAtmUnknownVCPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 2, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmUnknownVCPkts.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmUnknownVCPkts.setDescription('The count of packets received with an unknown VC')
wfAtmLmiTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 3), )
if mibBuilder.loadTexts: wfAtmLmiTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmLmiTable.setDescription('ATM Local Management Interface Table - Router Resident The statistical and configuration parameters for an ATM DXI Local Management Interface. There is one LMI MIB instance per Sync or HSSI line configured for ATM DXI support. The LMI interface is managed via this table.')
wfAtmLmiEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 3, 1), ).setIndexNames((0, "Wellfleet-ATM-MIB", "wfAtmLmiLineNumber"), (0, "Wellfleet-ATM-MIB", "wfAtmLmiLLIndex"))
if mibBuilder.loadTexts: wfAtmLmiEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmLmiEntry.setDescription('The attributes for a particular ATM Lmi')
wfAtmLmiState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("init", 3), ("notpresent", 4))).clone('notpresent')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmLmiState.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmLmiState.setDescription('Indicates the state of the LMI for this interface The state indicates Not Present when the LMI has been configured but has not been initialized. Init state indicates that the LMI is in the process of being initialized by the system. Up state indicates that the LMI is operating normally. Down state indicates that the LMI is physically or logically disabled.')
wfAtmLmiCircuit = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmLmiCircuit.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmLmiCircuit.setDescription('The circuit number of this entry')
wfAtmLmiNoVCErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 3, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmLmiNoVCErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmLmiNoVCErrors.setDescription("The number of Frames dropped that couldn't be associated with the LMI VPI/VCI")
wfAtmLmiProxyRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmLmiProxyRequests.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmLmiProxyRequests.setDescription('The number of SNMP Proxy Requests')
wfAtmLmiCsuDsuResponses = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmLmiCsuDsuResponses.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmLmiCsuDsuResponses.setDescription('The number of CSU/DSU SNMP Responses to Proxy Requests')
wfAtmLmiCsuDsuTraps = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmLmiCsuDsuTraps.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmLmiCsuDsuTraps.setDescription('The number of CSU/DSU SNMP Traps Received')
wfAtmLmiOtherErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmLmiOtherErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmLmiOtherErrors.setDescription('The number of frames dropped to format or other errors.')
wfAtmLmiLineNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 3, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmLmiLineNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmLmiLineNumber.setDescription('Instance identifier. This value corresponds to the line number of the Wellfleet router.')
wfAtmLmiLLIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 3, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmLmiLLIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmLmiLLIndex.setDescription("Instance identifier. This value corresponds to the port's llindex number. The Lower layer index uniquely identifies the lower layer in cases where the lower layer may be something other than the physical layer.")
wfAtmPlcpTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 4), )
if mibBuilder.loadTexts: wfAtmPlcpTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmPlcpTable.setDescription('The ATM PLCP Table - CSU/DSU Resident The PLCP object reflects information about either DS1 or DS3 PLCP framing status and performance. There is one instance of this object for every ATM DS1 or DS3 UNI. The PLCP object is separated from the other ATM objects for two reasons. First, there may be ATM UNIs which use physical media other than DS1 or DS3, and thus the PLCP object may not apply to them. Second, the PLCP object may also be applied towards management of SMDS Interfaces (SIPs). This PLCP object is essentially a superset of the PLCP object described in the Internet Draft MIB for SMDS (SIPs). It contains variables of interest to some ATM service providers and customers.')
wfAtmPlcpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 4, 1), ).setIndexNames((0, "Wellfleet-ATM-MIB", "wfAtmPlcpLineNumber"), (0, "Wellfleet-ATM-MIB", "wfAtmPlcpLLIndex"))
if mibBuilder.loadTexts: wfAtmPlcpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmPlcpEntry.setDescription('per linenumber/llindex PLCP objects')
wfAtmPlcpCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmPlcpCct.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmPlcpCct.setDescription('Identifies the DS1 or DS3 PLCP port for which this entry contains information. This corresponds to the Wellfleet circuit number')
wfAtmPlcpPhysical = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 4, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmPlcpPhysical.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmPlcpPhysical.setDescription('Identifies the OID of the first object in the standard DS1 or DS3 MIB')
wfAtmPlcpLof = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmPlcpLof.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmPlcpLof.setDescription('True if Loss of Frame has been detected')
wfAtmPlcpLofCFA = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmPlcpLofCFA.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmPlcpLofCFA.setDescription('True if Loss of Frame has been detected over the CFA time period')
wfAtmPlcpYellow = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmPlcpYellow.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmPlcpYellow.setDescription('True if PLCP Yellow (Remote Alarm Indication) has been detected')
wfAtmPlcpYellowCFA = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmPlcpYellowCFA.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmPlcpYellowCFA.setDescription('True if PLCP Yellow (Remote Alarm Indication) has been detected over the CFA time period')
wfAtmPlcpStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 4, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("connected", 1), ("up", 2), ("down", 3), ("other", 4), ("outofframe", 5))).clone('down')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmPlcpStatus.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmPlcpStatus.setDescription('The value of this variable indicates the PLCP status as indicated by the three-bit PLCP LSS code received from the remote end. Connected is LSS code #0, linkUp is LSS code #6, and linkDown is code #3. OtherCode means that one of the other five possible code values is being received. OutOfFrame means that the PLCP is in the out of frame state, and therefore there is no code being received.')
wfAtmPlcpSeconds = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 4, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmPlcpSeconds.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmPlcpSeconds.setDescription('The count of seconds elapsed since event counting began or since the counters were last cleared. The implementation may optionally allow this variable to be set. If set, the set value is ignored, and this variable and all other event counters for this object are reset to zero.')
wfAtmPlcpBipErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 4, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmPlcpBipErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmPlcpBipErrors.setDescription('The count of PLCP Bit Interleaved Parity (BIP) errors detected.')
wfAtmPlcpBipESecs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 4, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmPlcpBipESecs.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmPlcpBipESecs.setDescription('BIP Errored Seconds. The count of seconds during which one or more BIP errors were detected.')
wfAtmPlcpBipSESecs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 4, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmPlcpBipSESecs.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmPlcpBipSESecs.setDescription('BIP Severely Errored Seconds. The count of seconds during which five (5) or more BIP errors were detected.')
wfAtmPlcpFebes = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 4, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmPlcpFebes.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmPlcpFebes.setDescription('The count of PLCP Far End Block Errors (FEBE) detected.')
wfAtmPlcpFebeESecs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 4, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmPlcpFebeESecs.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmPlcpFebeESecs.setDescription('FEBE Errored Seconds. The count of seconds during which one or more FEBE errors were detected.')
wfAtmPlcpFebeSESecs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 4, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmPlcpFebeSESecs.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmPlcpFebeSESecs.setDescription('FEBE Severely Errored Seconds. The count of seconds during which five (5) or more FEBE errors were detected.')
wfAtmPlcpFrameErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 4, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmPlcpFrameErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmPlcpFrameErrors.setDescription('The count of PLCP Frame bit errors detected.')
wfAtmPlcpSevereFrameErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 4, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmPlcpSevereFrameErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmPlcpSevereFrameErrors.setDescription('The count of PLCP Severe Frame errors (aka Out Of Frame Events) detected.')
wfAtmPlcpSEFS = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 4, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmPlcpSEFS.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmPlcpSEFS.setDescription('Severely Errored Framing Seconds. The count of seconds during which one or more PLCP Severe Frame errors were detected.')
wfAtmPlcpUAS = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 4, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmPlcpUAS.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmPlcpUAS.setDescription('Unavailable Seconds. The count of seconds during which the PLCP service was declared to be unavailable.')
wfAtmPlcpLineNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 4, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmPlcpLineNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmPlcpLineNumber.setDescription('Instance identifier. This value corresponds to the line number of the Wellfleet router.')
wfAtmPlcpLLIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 4, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmPlcpLLIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmPlcpLLIndex.setDescription("Instance identifier. This value corresponds to the port's llindex. The Lower layer index uniquely identifies the lower layer in cases where the lower layer may be something other than the physical layer.")
wfAtmUniTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 5), )
if mibBuilder.loadTexts: wfAtmUniTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmUniTable.setDescription("The ATM UNI Table - CSU/DSU Resident The ATM User Network Interface (UNI) object reflects information about a particular ATM UNI. In particular it contains information, both configuration and performance, from the 'ATM' or Cell layer of the ATM protocol hierarchy. It optionally keeps some information on a per-VPI/VCI basis. It 'points to' its associated physical layer object, for example the DS1 or DS3 PLCP object. It also 'points to' the (one or more) higher layer object(s), namely the ATM Adaptation Layer (AAL) object(s) which further process the ATM Cells. It should be noted that in the ATM UNI MIB, the receive (transmit) direction refers to data received from (transmitted to) the ATM UNI interface. ** For DL200 and DL3200 there is only one ATM UNI per DL unit ** and only one AAL object (specifically VBR) per ATM UNI. ")
wfAtmUniEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 5, 1), ).setIndexNames((0, "Wellfleet-ATM-MIB", "wfAtmUniLineNumber"), (0, "Wellfleet-ATM-MIB", "wfAtmUniLLIndex"))
if mibBuilder.loadTexts: wfAtmUniEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmUniEntry.setDescription('per linenumber/llindex User Network Interface (UNI) objects - wfAtmUniLineNumber and wfAtmUniLLIndex corresponds to Wellfleet linenumber/llindex number')
wfAtmUniCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmUniCct.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmUniCct.setDescription('This corresponds to the Wellfleet circuit number')
wfAtmUniPhysical = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 5, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmUniPhysical.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmUniPhysical.setDescription('Identifies the OID of the first object in the standard DS1 or DS3 MIB corresponding to this ATM UNI port')
wfAtmUniAal = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 5, 1, 3), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmUniAal.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmUniAal.setDescription('Identifies the AAL MIB corresponding to this ATM UNI port. There is only one AAL currently for the DXI application.')
wfAtmUniSeconds = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 5, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmUniSeconds.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmUniSeconds.setDescription('The count of seconds elapsed since event counting began or since the counters were last cleared.The implementation may optionally allow this variable to be set.If set, the set value is ignored, and this variable and all other event counters for this object are reset to zero.')
wfAtmUniLineNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 5, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmUniLineNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmUniLineNumber.setDescription('Instance identifier. This value corresponds to the line number of the Wellfleet router.')
wfAtmUniLLIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 5, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmUniLLIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmUniLLIndex.setDescription("Instance identifier. This value corresponds to the port's llindex. The Lower layer index uniquely identifies the lower layer in cases where the lower layer may be something other than the physical layer.")
wfAtmUniAtmTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 6), )
if mibBuilder.loadTexts: wfAtmUniAtmTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmUniAtmTable.setDescription('The ATM UNIATM Table CSU/DSU Resident This list contains ATM Layer parameters, one entry per ATM UNI port. The counts maintained in this table are totals for the UNI, across all VPI/VCIs.')
wfAtmUniAtmEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 6, 1), ).setIndexNames((0, "Wellfleet-ATM-MIB", "wfAtmUniAtmLineNumber"), (0, "Wellfleet-ATM-MIB", "wfAtmUniAtmLLIndex"))
if mibBuilder.loadTexts: wfAtmUniAtmEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmUniAtmEntry.setDescription('per linenumber/llindex UNI ATM Layer objects - wfAtmUniAtmLineNumber and wfAtmUniAtmLLIndex corresponds to Wellfleet linenumber/llindex number')
wfAtmUniAtmCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmUniAtmCct.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmUniAtmCct.setDescription('The ATM UNI port for which corresponds to the Wellfleet circuit number')
wfAtmUniAtmNoBuffers = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 6, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmUniAtmNoBuffers.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmUniAtmNoBuffers.setDescription('Received ATM cells discarded due to the lack of available cell buffers')
wfAtmUniAtmHECs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 6, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmUniAtmHECs.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmUniAtmHECs.setDescription('Received ATM cells discarded due to an uncorrected HEC')
wfAtmUniAtmCHECs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 6, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmUniAtmCHECs.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmUniAtmCHECs.setDescription('Received ATM cells for which a HEC error was detected and corrected')
wfAtmUniAtmNullCells = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 6, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmUniAtmNullCells.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmUniAtmNullCells.setDescription('Received Null (unassigned , empty) cells')
wfAtmUniAtmMisdeliveredCells = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 6, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmUniAtmMisdeliveredCells.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmUniAtmMisdeliveredCells.setDescription('Received cells with an invalid VPI/VCI and were discarded')
wfAtmUniAtmReceives = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 6, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmUniAtmReceives.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmUniAtmReceives.setDescription('Valid (non-null) ATM Cells received at this layer and passed up')
wfAtmUniAtmTransmits = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 6, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmUniAtmTransmits.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmUniAtmTransmits.setDescription('Valid (non-null) ATM Cells transmitted at this layer and passed down to the PLCP layer')
wfAtmUniAtmLineNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 6, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmUniAtmLineNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmUniAtmLineNumber.setDescription('Instance identifier. This value corresponds to the line number of the Wellfleet router.')
wfAtmUniAtmLLIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 6, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmUniAtmLLIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmUniAtmLLIndex.setDescription("Instance identifier. This value corresponds to the port's llindex. The Lower layer index uniquely identifies the lower layer in cases where the lower layer may be something other than the physical layer.")
wfAtmVbrTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 8), )
if mibBuilder.loadTexts: wfAtmVbrTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVbrTable.setDescription('The ATM VBR Table - CSU/DSU Resident The ATM Variable Bit Rate (VBR) object is one of several types of ATM Adaptation Layer (AAL) objects. The ATM VBR object reflects information about a VBR service carried by an ATM UNI on behalf of a DTE interface (e.g. a DXI). In particular, it contains both configuration and performance information about the Segmentation and Reassembly (SAR) sublayer and the Convergence Sublayer (CS). Each instance of the VBR object has only one corresponding DTE interface, and only one corresponding ATM UNI, although it may correspond to several VPI/VCIs within a particular ATM UNI. The VBR object optionally keeps some information on a per-VPI/VCI basis. It should be noted that in the ATM VBR MIB, the receive (transmit) direction refers to data received from (transmitted to) the ATM UNI interface. ** For DL200 and DL3200 DSUs, there is only one ATM UNI per DSU ** and only one AAL object (specifically VBR) per ATM UNI. ** For these products, the DSU does not perform the ** integrity checks for the VBR CS layer, and thus will not ** provide all variables for the VBR CS table. The Router/Host ** is expected to perform these checks and provide these variables. ')
wfAtmVbrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 8, 1), ).setIndexNames((0, "Wellfleet-ATM-MIB", "wfAtmVbrLineNumber"), (0, "Wellfleet-ATM-MIB", "wfAtmVbrLLIndex"))
if mibBuilder.loadTexts: wfAtmVbrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVbrEntry.setDescription('per linenumber/llindex VBR AAL objects - wfAtmVbrLineNumber and wfAtmVbrLLIndex corresponds to Wellfleet linenumber/llindex number')
wfAtmVbrCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 8, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmVbrCct.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVbrCct.setDescription('Identifies the ATM VBR object which corresponds to the Wellfleet circuit number')
wfAtmVbrAtmUni = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 8, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmVbrAtmUni.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVbrAtmUni.setDescription('Identifies the OID of the first object in the ATM UNI MIB corresponding to this ATM VBR-AAL')
wfAtmVbrDxi = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 8, 1, 3), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmVbrDxi.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVbrDxi.setDescription('Identifies the DXI MIB corresponding to this ATM VBR-AAL. There is only one AAL currently for the DXI application.')
wfAtmVbrSeconds = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 8, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmVbrSeconds.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVbrSeconds.setDescription('The count of seconds elapsed since event counting began or since the counters were last cleared. The implementation may optionally allow this variable to be set. If set, the set value is ignored, and this variable and all other event counters for this object are reset to zero.')
wfAtmVbrLineNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 8, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmVbrLineNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVbrLineNumber.setDescription('Instance identifier. This value corresponds to the line number of the Wellfleet router.')
wfAtmVbrLLIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 8, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmVbrLLIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVbrLLIndex.setDescription("Instance identifier. This value corresponds to the port's llindex. The Lower layer index uniquely identifies the lower layer in cases where the lower layer may be something other than the physical layer.")
wfAtmVbrSarTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 9), )
if mibBuilder.loadTexts: wfAtmVbrSarTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVbrSarTable.setDescription('The ATM VBR SAR Table CSU/DSU Resident This table contains ATM VBR-AAL, SAR Layer parameters, the entry per ATM VBR-AAL object. The counts maintained in this table are totals for the VBR, across all VPI/VCIs within the VBR.')
wfAtmVbrSarEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 9, 1), ).setIndexNames((0, "Wellfleet-ATM-MIB", "wfAtmVbrSarLineNumber"), (0, "Wellfleet-ATM-MIB", "wfAtmVbrSarLLIndex"))
if mibBuilder.loadTexts: wfAtmVbrSarEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVbrSarEntry.setDescription('per linenumber/llindex VBR AAL SAR sublayer objects - wfAtmSarLineNumber and wfAtmSarLLIndex corresponds to Wellfleet linenumber/llindex number')
wfAtmVbrSarCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 9, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmVbrSarCct.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVbrSarCct.setDescription('identifies the VBR_SAR object which corresponds to the Wellfleet circuit number')
wfAtmVbrSarAssemblyTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 9, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmVbrSarAssemblyTimer.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVbrSarAssemblyTimer.setDescription('The maximum time period (milliseconds) allowed for CS_PDU assembly process to complete. This is the time between receipt of a BOM and receipt of an EOM SAR_PDU.')
wfAtmVbrSarCrc10Errors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 9, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmVbrSarCrc10Errors.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVbrSarCrc10Errors.setDescription('The count of received SAR_PDUs discarded due to CRC10 error')
wfAtmVbrSarCellMidErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 9, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmVbrSarCellMidErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVbrSarCellMidErrors.setDescription('The count of received SAR_PDUs discarded due to an invalid MID field value')
wfAtmVbrSarCsPduSizeTooBigErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 9, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmVbrSarCsPduSizeTooBigErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVbrSarCsPduSizeTooBigErrors.setDescription('The count of received SAR_PDUs discarded due to CS_PDU size is too big . NOTE: This attribute needs to be moved to router based CS object.')
wfAtmVbrSarNoBufferErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 9, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmVbrSarNoBufferErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVbrSarNoBufferErrors.setDescription('No CS_PDU assembly buffer space')
wfAtmVbrSarComNoProcessErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 9, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmVbrSarComNoProcessErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVbrSarComNoProcessErrors.setDescription('Received COM SAR_PDUs discarded due to lack of an active CS_PDU assembly process')
wfAtmVbrSarEomNoProcessErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 9, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmVbrSarEomNoProcessErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVbrSarEomNoProcessErrors.setDescription('Received EOM SAR_PDUs discarded due to lack of an active CS_PDU assembly process')
wfAtmVbrSarCellSequenceErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 9, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmVbrSarCellSequenceErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVbrSarCellSequenceErrors.setDescription('The count of active CS_PDU assembly processes closed (aborted, accumulation discarded) due to detecting a SAR sequence number error in a received SAR_PDU.')
wfAtmVbrSarCellLengthErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 9, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmVbrSarCellLengthErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVbrSarCellLengthErrors.setDescription('The count of active CS_PDU assembly processes closed (aborted, accumulation discarded) due to detecting a length field error in a received SAR_PDU.')
wfAtmVbrSarBomBeforeEomErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 9, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmVbrSarBomBeforeEomErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVbrSarBomBeforeEomErrors.setDescription('The count of active CS_PDU assembly processes closed (aborted, accumulation discarded) due to receiving a new BOM or SSM SAR_PDU for the same VPI/VCI (and MID) before receiving the EOM SAR_PDU.')
wfAtmVbrSarTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 9, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmVbrSarTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVbrSarTimeouts.setDescription('The count of active CS_PDU assembly processes closed (aborted, accumulation discarded) due to expiration of the assembly timer.')
wfAtmVbrSarLengthExceeds = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 9, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmVbrSarLengthExceeds.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVbrSarLengthExceeds.setDescription('The count of active CS_PDU assembly processes closed (aborted, accumulation discarded) due to receiving more SAR_PDUs (and their payloads) than will fit in the CS_PDU assembly buffer.')
wfAtmVbrSarReceives = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 9, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmVbrSarReceives.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVbrSarReceives.setDescription('The count of received SAR_PDUs (all types, i.e. BOM, COM, EOM, SSM) successfully accumulated into a CS_PDU assembly buffer.')
wfAtmVbrSarTransmits = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 9, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmVbrSarTransmits.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVbrSarTransmits.setDescription('The count of SAR_PDUs (all types, i.e. BOM, COM, EOM, SSM) transmitted to the ATM layer from a CS_PDU segmentation process.')
wfAtmVbrSarLineNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 9, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmVbrSarLineNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVbrSarLineNumber.setDescription('Instance identifier. This value corresponds to the line number of the Wellfleet router.')
wfAtmVbrSarLLIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 9, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmVbrSarLLIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVbrSarLLIndex.setDescription("Instance identifier. This value corresponds to the port's llindex. The Lower layer index uniquely identifies the lower layer in cases where the lower layer may be something other than the physical layer.")
wfAtmVbrCsTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 11), )
if mibBuilder.loadTexts: wfAtmVbrCsTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVbrCsTable.setDescription('The ATM VBR CS Table - Router Resident This table contains ATM VBR-AAL, CS Layer parameters, one entry per ATM VBR-AAL object. The counts maintained in this table are totals for the VBR, across all VPI/VCIs within the VBR.')
wfAtmVbrCsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 11, 1), ).setIndexNames((0, "Wellfleet-ATM-MIB", "wfAtmVbrCsLineNumber"), (0, "Wellfleet-ATM-MIB", "wfAtmVbrCsLLIndex"))
if mibBuilder.loadTexts: wfAtmVbrCsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVbrCsEntry.setDescription('per linenumber/llindex VBR_CS objects - wfAtmVbrCsLineNumber and wfAtmVbrCsLLIndex corresponds to Wellfleet linenumber/llindex number')
wfAtmVbrCsCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 11, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmVbrCsCct.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVbrCsCct.setDescription('Identifies the VBR_CS object which corresponds to the Wellfleet circuit number')
wfAtmVbrCsBETagMismatches = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 11, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmVbrCsBETagMismatches.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVbrCsBETagMismatches.setDescription('The count of received CS_PDUs discarded due to a mismatch when comparing the BETag fields in the CS_PDU header and trailer.')
wfAtmVbrCsLengthMismatches = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 11, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmVbrCsLengthMismatches.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVbrCsLengthMismatches.setDescription('The count of received CS_PDUs discarded due to a mismatch when comparing the CS_PDU header BASize field, the CS_PDU trailer length field and the actual length of the CS_PDU received.')
wfAtmVbrCsMisdeliveredPdus = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 11, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmVbrCsMisdeliveredPdus.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVbrCsMisdeliveredPdus.setDescription('The count of received SAR_PDUs discarded due to an invalid VPI/VCI detected at this layer.')
wfAtmVbrCsReceives = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 11, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmVbrCsReceives.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVbrCsReceives.setDescription('The count of the valid CS_PDUs received from the SAR layer and passed on to the next upper layer for further processing.')
wfAtmVbrCsTransmits = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 11, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmVbrCsTransmits.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVbrCsTransmits.setDescription('The count of CS_PDUs received from upper layers and sent to the SAR layer for segmentation and transmission')
wfAtmVbrCsLineNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 11, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmVbrCsLineNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVbrCsLineNumber.setDescription('Instance identifier. This value corresponds to the line number of the Wellfleet router.')
wfAtmVbrCsLLIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 11, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmVbrCsLLIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVbrCsLLIndex.setDescription("Instance identifier. This value corresponds to the port's llindex number. The Lower layer index uniquely identifies the lower layer in cases where the lower layer may be something other than the physical layer.")
wfAtmVbrCsVciTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 12), )
if mibBuilder.loadTexts: wfAtmVbrCsVciTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVbrCsVciTable.setDescription('The ATM VBR CS_VCI Table - Router Resident This table contains ATM VBR-AAL, CS Layer parameters, one entry per ATM VPI/VCI for which information has been recorded per ATM VBR-AAL object.')
wfAtmVbrCsVciEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 12, 1), ).setIndexNames((0, "Wellfleet-ATM-MIB", "wfAtmVbrCsVciLineNumber"), (0, "Wellfleet-ATM-MIB", "wfAtmVbrCsVciLLIndex"), (0, "Wellfleet-ATM-MIB", "wfAtmVbrCsVciIndex"))
if mibBuilder.loadTexts: wfAtmVbrCsVciEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVbrCsVciEntry.setDescription('per virtual circuit VBR_CS objects')
wfAtmVbrCsVciVbrCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 12, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmVbrCsVciVbrCct.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVbrCsVciVbrCct.setDescription('Identifies the VBR_CS object which corresponds to the Wellfleet circuit number')
wfAtmVbrCsVciIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 12, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8388608))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmVbrCsVciIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVbrCsVciIndex.setDescription('Identifies the VPI/VCI object for which this entry contains information.')
wfAtmVbrCsVciBETagMismatches = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 12, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmVbrCsVciBETagMismatches.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVbrCsVciBETagMismatches.setDescription('The count of received CSVCI_PDUs discarded due to a mismatch when comparing the BETag fields in the CSVCI_PDU header and trailer.')
wfAtmVbrCsVciLengthMismatches = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 12, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmVbrCsVciLengthMismatches.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVbrCsVciLengthMismatches.setDescription('The count of received CSVCI_PDUs discarded due to a mismatch when comparing the CSVCI_PDU header BASize field, the CSVCI_PDU trailer length field and the actual length of the CSVCI_PDU received.')
wfAtmVbrCsVciMisdeliveredPdus = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 12, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmVbrCsVciMisdeliveredPdus.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVbrCsVciMisdeliveredPdus.setDescription('The count of received SAR_PDUs discarded due to an invalid VPI/VCI detected at this layer.')
wfAtmVbrCsVciReceives = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 12, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmVbrCsVciReceives.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVbrCsVciReceives.setDescription('The count of the valid CSVCI_PDUs received from the SAR layer and passed on to the next upper layer for further processing.')
wfAtmVbrCsVciTransmits = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 12, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmVbrCsVciTransmits.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVbrCsVciTransmits.setDescription('The count of CSVCI_PDUs received from upper layers and sent to the SAR layer for segmentation and transmission')
wfAtmVbrCsVciOctetReceives = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 12, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmVbrCsVciOctetReceives.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVbrCsVciOctetReceives.setDescription('The octet count of the valid CSVCI_PDUs received from the SAR layer and passed on to the next upper layer for further processing.')
wfAtmVbrCsVciOctetTransmits = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 12, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmVbrCsVciOctetTransmits.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVbrCsVciOctetTransmits.setDescription('The count of CSVCI_PDUs received from upper layers and sent to the SAR layer for segmentation and transmission')
wfAtmVbrCsVciLineNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 12, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmVbrCsVciLineNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVbrCsVciLineNumber.setDescription('Instance identifier. This value corresponds to the line number of the Wellfleet router.')
wfAtmVbrCsVciLLIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 12, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmVbrCsVciLLIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVbrCsVciLLIndex.setDescription("Instance identifier. This value corresponds to the port's llindex number. The Lower layer index uniquely identifies the lower layer in cases where the lower layer may be something other than the physical layer.")
wfAtmMpeTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 13), )
if mibBuilder.loadTexts: wfAtmMpeTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmMpeTable.setDescription('The ATM MPE Table - Router Resident This table contains ATM DXI MPE Layer parameters, one entry per ATM Circuit.The counts maintained in this table are totals for the MPE Layer, across all VPI/VCIs.')
wfAtmMpeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 13, 1), ).setIndexNames((0, "Wellfleet-ATM-MIB", "wfAtmMpeIndex"))
if mibBuilder.loadTexts: wfAtmMpeEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmMpeEntry.setDescription('per circuit MPE objects - wfAtmMpeIndex corresponds to Wellfleet circuit number')
wfAtmMpeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 13, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmMpeIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmMpeIndex.setDescription('Identifies the MPE object for which this entry contains information. This corresponds to the Wellfleet circuit number')
wfAtmMpeInvalidNlpids = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 13, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmMpeInvalidNlpids.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmMpeInvalidNlpids.setDescription('The count of received MPE_PDUs discarded due to an unknown or unsupported NLPID')
wfAtmMpeInvalidPids = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 13, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmMpeInvalidPids.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmMpeInvalidPids.setDescription('The count of received MPE_PDUs discarded due to an unknown or unsupported PID')
wfAtmMpeInvalidOuis = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 13, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmMpeInvalidOuis.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmMpeInvalidOuis.setDescription('The count of received MPE_PDUs discarded due to an unknown or unsupported OUI')
wfAtmMpeMisdeliveredPdus = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 13, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmMpeMisdeliveredPdus.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmMpeMisdeliveredPdus.setDescription('The count of received MPE_PDUs discarded due to an inactive SAP.')
wfAtmMpeUnsupportedControlFields = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 13, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmMpeUnsupportedControlFields.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmMpeUnsupportedControlFields.setDescription('The count of received MPE_PDUs discarded due to an unknown or unsupported Control field')
wfAtmMpeInvalidSAP = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 13, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmMpeInvalidSAP.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmMpeInvalidSAP.setDescription('The cound of received MPE_PDUs discarded due to either a bad SSAP or DSAP (RFC1483)')
wfAtmPvcTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 14), )
if mibBuilder.loadTexts: wfAtmPvcTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmPvcTable.setDescription('The ATM PVC Table - Router Resident This table contains Virtual Circuit configuration and stats parameters, one entry per ATM VPI/PVC for which information has been recorded.')
wfAtmPvcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 14, 1), ).setIndexNames((0, "Wellfleet-ATM-MIB", "wfAtmPvcLineNumber"), (0, "Wellfleet-ATM-MIB", "wfAtmPvcLLIndex"), (0, "Wellfleet-ATM-MIB", "wfAtmPvcVpi"), (0, "Wellfleet-ATM-MIB", "wfAtmPvcVci"))
if mibBuilder.loadTexts: wfAtmPvcEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmPvcEntry.setDescription('per virtual circuit objects')
wfAtmPvcDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmPvcDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmPvcDelete.setDescription('Used to create/delete an instance of this object. This action will result in a PVC being added or removed from service.')
wfAtmPvcCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 14, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmPvcCct.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmPvcCct.setDescription('Identifies the object which corresponds to the Wellfleet circuit number')
wfAtmPvcVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 14, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmPvcVpi.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmPvcVpi.setDescription('The VPI associated with this PVC')
wfAtmPvcVci = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 14, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(32, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmPvcVci.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmPvcVci.setDescription('The VCI associated with this PVC')
wfAtmPvcReceives = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 14, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmPvcReceives.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmPvcReceives.setDescription('The count of the valid PVC_PDUs received from the SAR layer and passed on to the next upper layer for further processing.')
wfAtmPvcTransmits = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 14, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmPvcTransmits.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmPvcTransmits.setDescription('The count of PVC_PDUs received from upper layers and sent to the SAR layer for segmentation and transmission')
wfAtmPvcOctetReceives = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 14, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmPvcOctetReceives.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmPvcOctetReceives.setDescription('The octet count of the valid PVC_PDUs received from the SAR layer and passed on to the next upper layer for further processing.')
wfAtmPvcOctetTransmits = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 14, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmPvcOctetTransmits.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmPvcOctetTransmits.setDescription('The octet count of PVC_PDUs received from upper layers and sent to the SAR layer for segmentation and transmission')
wfAtmPvcMode = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 14, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("groupaccess", 1), ("hybridaccess", 2), ("direct", 3))).clone('groupaccess')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmPvcMode.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmPvcMode.setDescription("The mode of the given VC. GROUP - treats the VC as one of many vc's on a circuit. HYBRID - treats the VC as one of many vc's on a circuit for protocol traffic, but as a separate circuit for bridging. DIRECT - treats the VC as a separate circuit for all applications.")
wfAtmPvcDirectAccessCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 14, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmPvcDirectAccessCct.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmPvcDirectAccessCct.setDescription('Circuit number to use for this VC for hybrid or direct access routing')
wfAtmPvcState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 14, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("init", 3), ("notpresent", 4))).clone('notpresent')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmPvcState.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmPvcState.setDescription('Indicates the state of the PVC. The state indicates Not Present when the PVC has been configured but has not been initialized. Init state indicates that the PVC is in the process of being initialized by the system. Up state indicates that the PVC is operating normally. Down state indicates that the PVC is disabled.')
wfAtmPvcMpeNull = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 14, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("mpe1294", 1), ("null", 2), ("mpe1483", 3))).clone('mpe1483')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmPvcMpeNull.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmPvcMpeNull.setDescription('Used to select Null, Multi-Protocol Encapsulation (RFC 1294) or Multi-Protocol Encapsulation (RFC 1483) layer for this PVC. Null is considered VC Based Multiplexing and is not supported for Bridging.')
wfAtmPvcCsNull = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 14, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("aal34", 1), ("null", 2), ("aal5", 3))).clone('aal5')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmPvcCsNull.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmPvcCsNull.setDescription("Used to configure the type of CS_PDU encapsulation supported on the ATM DXI PVC based on the ATM Forum's ATM DXI specification. This configuration is on a per Direct VC basis. The supported values are AAL3/4, AAL5 and Null (no CS_PDU encapsulation). Null is a propriatary configurable value when no CS_PDU encapsulation is desired.")
wfAtmPvcDisable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 14, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmPvcDisable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmPvcDisable.setDescription('Used to enable/disable a PVC')
wfAtmPvcDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 14, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmPvcDrops.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmPvcDrops.setDescription('The total count of packets dropped on this VC')
wfAtmPvcMulticast = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 14, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("unicast", 1), ("multicast", 2))).clone('unicast')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmPvcMulticast.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmPvcMulticast.setDescription('Indicates whether this VPI/VCI is used for multicast or single destination.')
wfAtmPvcLineNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 14, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmPvcLineNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmPvcLineNumber.setDescription('Instance identifier. This value corresponds to the line number of the Wellfleet router.')
wfAtmPvcLLIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 14, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmPvcLLIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmPvcLLIndex.setDescription("Instance identifier. This value corresponds to the port's llindex number. The Lower layer index uniquely identifies the lower layer in cases where the lower layer may be something other than the physical layer.")
wfAtmDxiTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 15), )
if mibBuilder.loadTexts: wfAtmDxiTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmDxiTable.setDescription('The ATM DXI Table - An entry in this table is either resident in the Wellfleet MIB or in the Digital Link MIB via the SNMP Proxy. The Component attribute determines local or remote residency. The ATM Data Exchange Interface (DXI) object reflects information about an ATM DXI interface between an ATM DSU and a Router/Host. In particular, it contains both configuration and performance information specific to the DXI (ATM) interface. Each DXI instance typically corresponds to several (ATM) DXIADDRs. The DXI object optionally keeps some information on a per-DXIADDR basis. Each instance of the DXI object typically has only one corresponding ATM -AAL object, but the MIB has been structured so that a DXI may have more than one. It should be noted that in the DXI MIB, the receive (transmit) direction refers to data received from (transmitted to) the ATM interface. With a 23-bit DXIADDR, the range of valid DXIADDR index values is 1 thru 2**23 inclusive. Note that the 23-bit binary DXIADDR field (with values 0 thru 2**23-1) from the Frame Relay header must be incremented by one to yield the DXIADDR index for accessing the tables in the MIB. The DXIADDR consisting of all zeros (with corresponding MIB index value of 1) is reserved for the DXI Local Management Interface (LMI) with the DSU. DxiAddr ::= INTEGER (1..8388608) ** For DL200 and DL3200 DSUs, there is only one ATM DXI per DSU ** and only one AAL object (specifically VBR) per ATM DXI. ** For these products, the mapping between the DXI (Frame Relay) ** DXIADDR and the ATM VPI/VCI is fixed. The LMI DXIADDR has no ** corresponding VPI/VCI. Otherwise, the eight most significant ** bits of the DXIADDR map into the the VPI (the eight most ** significant bits of the VPI/VCI), the fifteen least ** significant bits of the DXIADDR map into the fifteen least ** significant bits of the VCI, and the most significant bit of ** the VCI is set to zero.')
wfAtmDxiEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 15, 1), ).setIndexNames((0, "Wellfleet-ATM-MIB", "wfAtmDxiLineNumber"), (0, "Wellfleet-ATM-MIB", "wfAtmDxiLLIndex"), (0, "Wellfleet-ATM-MIB", "wfAtmDxiComponent"))
if mibBuilder.loadTexts: wfAtmDxiEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmDxiEntry.setDescription('per linenumber/llindex ATM DXI objects - wfAtmDxiLineNumber and wfAtmDxiLLIndex corresponds to Wellfleet linenumber/llindex number')
wfAtmDxiCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 15, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmDxiCct.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmDxiCct.setDescription('Identifies the ATM DXI cct which corresponds to the Wellfleet circuit number')
wfAtmDxiComponent = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 15, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("router", 1), ("csudsu", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmDxiComponent.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmDxiComponent.setDescription('Identifies the component where the ATM DXI parameters are resident - either the router or CSU/DSU.')
wfAtmDxiMaxLmiPduLengthErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 15, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmDxiMaxLmiPduLengthErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmDxiMaxLmiPduLengthErrors.setDescription('The maximum length of an LMI PDU, measured in octets')
wfAtmDxiSeconds = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 15, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmDxiSeconds.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmDxiSeconds.setDescription('The count of seconds elapsed since event counting began or since the counters were last cleared. The implementation may optionally allow this variable to be set. If set, the set value is ignored , and this variable and all other event counters for this object are reset to zero.')
wfAtmDxiDiscardedFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 15, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmDxiDiscardedFrames.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmDxiDiscardedFrames.setDescription('The count of received frames discarded due to lack of buffer space.')
wfAtmDxiAbortedFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 15, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmDxiAbortedFrames.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmDxiAbortedFrames.setDescription('The count of the received frames aborted (and discarded) before the closing flag')
wfAtmDxiNonOctetAlignedFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 15, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmDxiNonOctetAlignedFrames.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmDxiNonOctetAlignedFrames.setDescription('The count of the received frames discarded due to not being octet aligned.')
wfAtmDxiTooLongFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 15, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmDxiTooLongFrames.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmDxiTooLongFrames.setDescription('The count of the received frames discarded due to being longer than the maximum allowed frame length')
wfAtmDxiTooShortFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 15, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmDxiTooShortFrames.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmDxiTooShortFrames.setDescription('The count of the received frames discarded due to being shorter than the minimum allowed frame length (less than 6 octets long)')
wfAtmDxiFrameChecksumErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 15, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmDxiFrameChecksumErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmDxiFrameChecksumErrors.setDescription('The count of the received frames discarded due to detected checksum error (CRC16)')
wfAtmDxiFrameHeaderErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 15, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmDxiFrameHeaderErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmDxiFrameHeaderErrors.setDescription('The count of the received frames discarded due to detected frame relay header errors')
wfAtmDxiValidFrameReceives = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 15, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmDxiValidFrameReceives.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmDxiValidFrameReceives.setDescription('The count of the valid frames received.')
wfAtmDxiFrameTransmits = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 15, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmDxiFrameTransmits.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmDxiFrameTransmits.setDescription('The count of CSVCI_PDUs received from upper layers and sent to the SAR layer for segmentation and transmission')
wfAtmDxiLineNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 15, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmDxiLineNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmDxiLineNumber.setDescription('Instance identifier. This value corresponds to the line number of the Wellfleet router.')
wfAtmDxiLLIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 15, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmDxiLLIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmDxiLLIndex.setDescription("Instance identifier. This value corresponds to the port's llindex number. The Lower layer index uniquely identifies the lower layer in cases where the lower layer may be something other than the physical layer.")
wfAtmDxiDxiAddrTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 16), )
if mibBuilder.loadTexts: wfAtmDxiDxiAddrTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmDxiDxiAddrTable.setDescription('The ATM DXI DXIADDR Table - Router and CSU/DSU Resident This table contains ATM DXI parameters, one entry per DXI DXIADDR for which information has been recorded per DXI DXIADDR Layer. Since the DXIADDR consisting of all zeros (with corresponding MIB index value of 1) is reserved for the DXI Local Management Interface (LMI) with the DSU, there is always at least one entry in the table. ')
wfAtmDxiDxiAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 16, 1), ).setIndexNames((0, "Wellfleet-ATM-MIB", "wfAtmDxiDxiAddrLineNumber"), (0, "Wellfleet-ATM-MIB", "wfAtmDxiDxiAddrLLIndex"), (0, "Wellfleet-ATM-MIB", "wfAtmDxiDxiAddrDxiComponent"), (0, "Wellfleet-ATM-MIB", "wfAtmDxiDxiAddrIndex"))
if mibBuilder.loadTexts: wfAtmDxiDxiAddrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmDxiDxiAddrEntry.setDescription('per DXIADDR ATM DXI objects')
wfAtmDxiDxiAddrDxiCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 16, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmDxiDxiAddrDxiCct.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmDxiDxiAddrDxiCct.setDescription('Identifies the Atm Dxi object for which this entry contains information. This attribute corresponds to the Wellfleet circuit number')
wfAtmDxiDxiAddrDxiComponent = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 16, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("router", 1), ("csudsu", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmDxiDxiAddrDxiComponent.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmDxiDxiAddrDxiComponent.setDescription('Identifies the component where the ATM DXI parameters are resident - either the router or CSU/DSU.')
wfAtmDxiDxiAddrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 16, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8388608))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmDxiDxiAddrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmDxiDxiAddrIndex.setDescription('Identifies the DXIADDR object for which this entry contains information.')
wfAtmDxiDxiAddrAtmVbr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 16, 1, 4), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmDxiDxiAddrAtmVbr.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmDxiDxiAddrAtmVbr.setDescription("The object identifier of the first object in the ATM VBR-AAL MIB which corresponds to this DXIADDR of this DXI port. If there is only one ATM VBR-AAL object associated with this DXI object, then the LMI DXIADDR entry in this table will have a valid value for this variable, even though the LMI DXIADDR has no valid VPI/VCI value.'")
wfAtmDxiDxiAddrVpiVci = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 16, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8388608))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmDxiDxiAddrVpiVci.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmDxiDxiAddrVpiVci.setDescription('The VPI/VCI of the ATM UNI of the ATM VBR-AAL object which corresponds to this DXIADDR of this DXI port. For the LMI DXIADDR there is no valid VPI/VCI value.')
wfAtmDxiDxiAddrReceives = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 16, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmDxiDxiAddrReceives.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmDxiDxiAddrReceives.setDescription('The count of the valid frames received from the next lower layer and passed on to the next upper layer for further processing.')
wfAtmDxiDxiAddrTransmits = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 16, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmDxiDxiAddrTransmits.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmDxiDxiAddrTransmits.setDescription('The count of frames received from upper layers and sent to the next lower layer for transmission')
wfAtmDxiDxiAddrLineNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 16, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmDxiDxiAddrLineNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmDxiDxiAddrLineNumber.setDescription('Instance identifier. This value corresponds to the line number of the Wellfleet router.')
wfAtmDxiDxiAddrLLIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 16, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmDxiDxiAddrLLIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmDxiDxiAddrLLIndex.setDescription("Instance identifier. This value corresponds to the port's llindex number. The Lower layer index uniquely identifies the lower layer in cases where the lower layer may be something other than the physical layer.")
wfAtmInterfaceConfTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 1), )
if mibBuilder.loadTexts: wfAtmInterfaceConfTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmInterfaceConfTable.setDescription('This table contains ATM local interface configuration parameters, one entry per ATM interface port, beyond those supported using the ifTable.')
wfAtmInterfaceConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 1, 1), ).setIndexNames((0, "Wellfleet-ATM-MIB", "wfAtmInterfaceConfIndex"))
if mibBuilder.loadTexts: wfAtmInterfaceConfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmInterfaceConfEntry.setDescription('Entry definition.')
wfAtmInterfaceConfDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("create", 1), ("delete", 2))).clone('create')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmInterfaceConfDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmInterfaceConfDelete.setDescription('Create/delete MIB instance parameter.')
wfAtmInterfaceConfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmInterfaceConfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmInterfaceConfIndex.setDescription('Uniquely identifies the interface (port) that contains the appropriate management information.')
wfAtmInterfaceAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmInterfaceAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmInterfaceAdminStatus.setDescription('Specifies the desired administrative state of the Interface. The up and down states indicate that the traffic flow is enabled and disabled respectively for the VCL.')
wfAtmInterfaceOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("init", 3), ("notpresent", 4))).clone('notpresent')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmInterfaceOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmInterfaceOperStatus.setDescription("Indicates the current operational status of the Interface. The up and down states indicate that the Interface is currently operational, or not operational, respectively. The Init state indicates the status of the Interface is in the process of being initialized and has not yet completed. The 'Not Present' state indicates a problem with that Interface and is not able to bring the Interface up.")
wfAtmInterfaceMaxVpcs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4096)).clone(256)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmInterfaceMaxVpcs.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmInterfaceMaxVpcs.setDescription('The maximum number of VPCs supported at the ATM interface.')
wfAtmInterfaceMaxVccs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65536)).clone(65536)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmInterfaceMaxVccs.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmInterfaceMaxVccs.setDescription('The maximum number of VCCs supported at the ATM interface.')
wfAtmInterfaceConfVpcs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmInterfaceConfVpcs.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmInterfaceConfVpcs.setDescription('The number of VPCs configured for use at the ATM interface.')
wfAtmInterfaceConfVccs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmInterfaceConfVccs.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmInterfaceConfVccs.setDescription('The number of VCCs configured for use at the ATM interface.')
wfAtmInterfaceMaxActiveVpiBits = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 12)).clone(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmInterfaceMaxActiveVpiBits.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmInterfaceMaxActiveVpiBits.setDescription('The maximum number of active VPI bits configured for use at the ATM interface.')
wfAtmInterfaceMaxActiveVciBits = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)).clone(16)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmInterfaceMaxActiveVciBits.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmInterfaceMaxActiveVciBits.setDescription('The maximum number of active VCI bits configured for use at the ATM interface.')
wfAtmInterfaceIlmiVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("default", 1))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmInterfaceIlmiVpi.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmInterfaceIlmiVpi.setDescription('The VPI value of the VCC supporting the ILMI at this ATM interface. If the values of wfAtmInterfaceIlmiVpi and wfAtmInterfaceIlmiVci are both equal to zero then the ILMI is not supported at this ATM interface. Subract 1 from the default! (ILMI VPI = 0).')
wfAtmInterfaceIlmiVci = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(16))).clone(namedValues=NamedValues(("default", 16))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmInterfaceIlmiVci.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmInterfaceIlmiVci.setDescription('The VCI value of the VCC supporting the ILMI at this ATM interface. If the values of wfAtmInterfaceIlmiVpi and wfAtmInterfaceIlmiVci are both equal to zero then the ILMI is not supported at this ATM interface.')
wfAtmInterfaceAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("private", 1), ("nsape164", 2), ("nativee164", 3), ("other", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmInterfaceAddressType.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmInterfaceAddressType.setDescription('The type of ATM address configured for use at the ATM interface.')
wfAtmInterfaceCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 1, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmInterfaceCct.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmInterfaceCct.setDescription('The Wellfleet circuit number of this entry')
wfAtmInterfaceDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmInterfaceDrops.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmInterfaceDrops.setDescription('The cumulative count of packet drops on this ATM Interface above the SSCS layer.')
wfAtmInterfaceSigEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmInterfaceSigEnable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmInterfaceSigEnable.setDescription('Spawning of ATM Signalling by the Control gate is determined by this attr')
wfAtmInterfaceDebug = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 2147483647))).clone(namedValues=NamedValues(("disabled", 1), ("msgs", 2), ("msgsIn", 4), ("msgsOut", 8), ("appMsgs", 16), ("drvMsgs", 32), ("trilMsgs", 64), ("pvcFsm", 128), ("svcFsm", 256), ("oam", 512), ("all", 2147483647))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmInterfaceDebug.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmInterfaceDebug.setDescription('This flag will enable certain debug messages depending on the value set. The values are as follows: 1 - disable debugging (default) 2 - enable Signalling Layer Manager inbound and outbound messages 4 - enable CC inbound messages 8 - enable CC outbound messages 16 - enable CC<->APP messages 32 - enable CC<->DRV messages 64 - enable CC<->TRILL messages 128 - enable CC PVC Interface FSM messages 256 - enable CC PVC Interface FSM messages 4294967295 - All of the above')
wfAtmInterfaceUseHwMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmInterfaceUseHwMacAddr.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmInterfaceUseHwMacAddr.setDescription('If this is enabled, then the auto-generated ESI portion of the ATM address user suffix will be supplied by the hardware driver. If disabled, it will come from wfAtmInterfaceHwMacOverride.')
wfAtmInterfaceHwMacOverride = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 1, 1, 19), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmInterfaceHwMacOverride.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmInterfaceHwMacOverride.setDescription("If wfAtmInterfaceUseHwMacAddr is disabled, this 48-bit Mac address will replace the hardware driver's address during auto-generation of the ESI portion of the ATM address user suffix.")
wfAtmServicePqOverride = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmServicePqOverride.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmServicePqOverride.setDescription(' This value denotes whether driver level PQ is to be applied to packets or driver decides to use the priority set by service level PQ, if both service level and driver level PQ is used.')
wfAtmServiceRecordTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 2), )
if mibBuilder.loadTexts: wfAtmServiceRecordTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmServiceRecordTable.setDescription('This table contains ATM service record configuration parameters, one entry per ATM Wellfleet cct.')
wfAtmServiceRecordEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 2, 1), ).setIndexNames((0, "Wellfleet-ATM-MIB", "wfAtmServiceRecordIndex"), (0, "Wellfleet-ATM-MIB", "wfAtmServiceRecordCct"))
if mibBuilder.loadTexts: wfAtmServiceRecordEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmServiceRecordEntry.setDescription('Entry definition.')
wfAtmServiceRecordDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("create", 1), ("delete", 2))).clone('create')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmServiceRecordDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmServiceRecordDelete.setDescription('Create/delete MIB instance parameter.')
wfAtmServiceRecordEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmServiceRecordEnable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmServiceRecordEnable.setDescription('Enable/Disable MIB instance parameter.')
wfAtmServiceRecordIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmServiceRecordIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmServiceRecordIndex.setDescription('Uniquely identifies the interface (port) that contains the appropriate port information.')
wfAtmServiceRecordCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmServiceRecordCct.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmServiceRecordCct.setDescription('The Wellfleet circuit number of this entry')
wfAtmServiceRecordAalEncapsType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("routedproto", 1), ("bridged8023", 2), ("bridged8025", 3), ("bridged8026", 4), ("lane8023", 5), ("lane8025", 6), ("llcencaps", 7), ("frsscs", 8), ("other", 9), ("unknown", 10), ("frinterwork", 11), ("mpsencaps", 12))).clone('llcencaps')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmServiceRecordAalEncapsType.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmServiceRecordAalEncapsType.setDescription('The type of data encapsulation used over both AAL3/4 and AAL5 SSCS layer. Currently, the only values supported are : ATM_SERVICEREC_ENCAPS_LLCENCAPS - RFC1483 ATM_SERVICEREC_ENCAPS_FRSSCS - RFC1294 ATM_SERVICEREC_ENCAPS_ROUTEDPROTO - NONE')
wfAtmServiceRecordState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("init", 3), ("reject", 4), ("notpresent", 5), ("oamlost", 6))).clone('notpresent')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmServiceRecordState.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmServiceRecordState.setDescription('State of Service Record')
wfAtmServiceRecordVcType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("pvc", 1), ("svc", 2), ("control", 3), ("muxedSvc", 4))).clone('pvc')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmServiceRecordVcType.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmServiceRecordVcType.setDescription("The type of VC for each encapsulation. Applicable for LLC and null type encapsulation enforced from SM - aks. 'muxedSvc' indicates SVCs that can be shared between applications for encapsulations that support muxing. 'control' should not a configurable option. It is defined for consistency with wfAtmVclVcType")
wfAtmServiceRecordNetworkPrefix = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 2, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(13, 13)).setFixedLength(13)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmServiceRecordNetworkPrefix.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmServiceRecordNetworkPrefix.setDescription('ATM Address Network portion')
wfAtmServiceRecordUserSuffix = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 2, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(7, 7)).setFixedLength(7)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmServiceRecordUserSuffix.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmServiceRecordUserSuffix.setDescription('ATM Address User portion')
wfAtmServiceRecordAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 2, 1, 10), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmServiceRecordAtmAddress.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmServiceRecordAtmAddress.setDescription('ATM Address Complete - Inserted by Router after verification of network and user portions')
wfAtmServiceRecordFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("autoaddr", 1))).clone('autoaddr')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmServiceRecordFlag.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmServiceRecordFlag.setDescription('This will be used for internal purposes to have Site Manager flag specific configurations.')
wfAtmServiceRecordMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 2, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9188))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmServiceRecordMtu.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmServiceRecordMtu.setDescription("The size of the largest packet to be used for send/receive on all logical interfaces defined on this service record. This attribute is an alias for 'ifMtu'.")
wfAtmServiceRecordLossPriorityPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmServiceRecordLossPriorityPolicy.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmServiceRecordLossPriorityPolicy.setDescription('This is relevant only for Frame Relay Switch product. This indicates the policy for translating FR DE to ATM CLP on IP truks over ATM. ')
wfAtmServiceRecordDebug = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 8, 2147483647))).clone(namedValues=NamedValues(("disabled", 1), ("pvcFsm", 2), ("svcFsm", 4), ("llcSvcMux", 8), ("all", 2147483647))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmServiceRecordDebug.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmServiceRecordDebug.setDescription('This flag will enable certain debug messages depending on the value set. The values are as follows: 1 - disable debugging (default) 2 - enable Service State Machine debugging 4294967295 - All of the above')
wfAtmServiceRecordName = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 2, 1, 15), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmServiceRecordName.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmServiceRecordName.setDescription('User name for circuit')
wfAtmServiceRecordWanSvcRoutingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disabled", 1), ("normal", 2), ("dialOptimized", 3))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmServiceRecordWanSvcRoutingMode.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmServiceRecordWanSvcRoutingMode.setDescription('This applies ONLY to WAN SVC type ATM service records. It specifies the route updates mode for the WAN SVCs.')
wfAtmSVCOptionsTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 13), )
if mibBuilder.loadTexts: wfAtmSVCOptionsTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSVCOptionsTable.setDescription('This table contains ATM WAN SVC configuration parameters, one entry for each remote ATM destination for which user wishes to specify some/all of the VC config parameters.')
wfAtmSVCOptionsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 13, 1), ).setIndexNames((0, "Wellfleet-ATM-MIB", "wfAtmSVCOptionsCct"), (0, "Wellfleet-ATM-MIB", "wfAtmSVCOptionsIndex"))
if mibBuilder.loadTexts: wfAtmSVCOptionsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSVCOptionsEntry.setDescription('Entry definition.')
wfAtmSVCOptionsDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("create", 1), ("delete", 2))).clone('create')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmSVCOptionsDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSVCOptionsDelete.setDescription('Create/delete MIB instance parameter.')
wfAtmSVCOptionsDisable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 13, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmSVCOptionsDisable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSVCOptionsDisable.setDescription('Enable/Disable MIB instance parameter.')
wfAtmSVCOptionsCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 13, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmSVCOptionsCct.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSVCOptionsCct.setDescription('Circuit Number to which this SVC Options Entry belongs to. (Instance Id 1)')
wfAtmSVCOptionsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 13, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmSVCOptionsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSVCOptionsIndex.setDescription('Sequential index number assigned by configuration tool (Instance Id 2)')
wfAtmSVCOptionsAdjHostAtmAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 13, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmSVCOptionsAdjHostAtmAddr.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSVCOptionsAdjHostAtmAddr.setDescription('ATM Address of the adjacent host to which these SVC config parameters apply.')
wfAtmSVCOptionsXmtPeakCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 13, 1, 6), Integer32().clone(4716)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmSVCOptionsXmtPeakCellRate.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSVCOptionsXmtPeakCellRate.setDescription('Forward Peak Cell Rate (in cells/sec) of the SVC to this adjacent host')
wfAtmSVCOptionsXmtSustCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 13, 1, 7), Integer32().clone(4716)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmSVCOptionsXmtSustCellRate.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSVCOptionsXmtSustCellRate.setDescription('Forward Sustainable Cell Rate (in cells/sec) of the SVC to this adjacent host')
wfAtmSVCOptionsRcvPeakCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 13, 1, 8), Integer32().clone(4716)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmSVCOptionsRcvPeakCellRate.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSVCOptionsRcvPeakCellRate.setDescription('Backward Peak Cell Rate (in cells/sec) of the SVC to this adjacent host')
wfAtmSVCOptionsRcvSustCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 13, 1, 9), Integer32().clone(4716)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmSVCOptionsRcvSustCellRate.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSVCOptionsRcvSustCellRate.setDescription('Backward Sustainable Cell Rate (in cells/sec) of the SVC to this adjacent host')
wfAtmSVCOptionsName = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 13, 1, 10), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmSVCOptionsName.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSVCOptionsName.setDescription('User name for SVC Options Record')
wfAtmVclConfTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 5), )
if mibBuilder.loadTexts: wfAtmVclConfTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVclConfTable.setDescription('')
wfAtmVclConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 5, 1), ).setIndexNames((0, "Wellfleet-ATM-MIB", "wfAtmVclConfIndex"), (0, "Wellfleet-ATM-MIB", "wfAtmVclConfVpi"), (0, "Wellfleet-ATM-MIB", "wfAtmVclConfVci"))
if mibBuilder.loadTexts: wfAtmVclConfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVclConfEntry.setDescription('Entry definition.')
wfAtmVclConfDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 5, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("create", 1), ("delete", 2))).clone('create')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmVclConfDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVclConfDelete.setDescription('Create/delete MIB instance parameter.')
wfAtmVclConfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 5, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmVclConfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVclConfIndex.setDescription('Uniquely identifies the interface (port) that contains the appropriate management information.')
wfAtmVclConfVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 5, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmVclConfVpi.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVclConfVpi.setDescription('The VPI value of the VCL. The maximum VPI value cannot exceed the value allowable by the wfAtmInterfaceMaxActiveVpiBits.')
wfAtmVclConfVci = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 5, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmVclConfVci.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVclConfVci.setDescription('The VCI value of the VCL. The maximum VCI value cannot exceed the value allowable by the wfAtmInterfaceMaxActiveVciBits.')
wfAtmVclAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 5, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmVclAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVclAdminStatus.setDescription('Specifies the desired administrative state of the VCL. The up and down states indicate that the traffic flow is enabled and disabled respectively for the VCL.')
wfAtmVclOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 5, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("init", 3), ("notpresent", 4), ("oamlost", 5), ("misconfig", 6))).clone('notpresent')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmVclOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVclOperStatus.setDescription("Indicates the current operational status of the VCL. The up and down states indicate that the VCL is currently operational, or not operational, respectively. The Init state indicates the status of the VCL is in the process of being initialized and has not yet completed. The 'Not Present' state indicates a problem with that VCL and is not able to bring the VCC up. The 'misconfig' state indicates the VC is misconfigured.")
wfAtmVclLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 5, 1, 7), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmVclLastChange.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVclLastChange.setDescription("The value of MIBII's sysUpTime at the time this VCL entered its current operational state. If the current state was entered prior to the last re-initialization of the agent then this object contains a zero value.")
wfAtmVclXmtPeakCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 5, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 365566)).clone(4716)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmVclXmtPeakCellRate.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVclXmtPeakCellRate.setDescription('Transmit (Forward) Peak Cell Rate in cells/second. This specifies the upper bound on the traffic that can be submitted on an ATM connection.')
wfAtmVclXmtSustainableCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 5, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 365566)).clone(4716)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmVclXmtSustainableCellRate.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVclXmtSustainableCellRate.setDescription("Transmit (Forward) Sustainable Cell Rate in cells/second. This specifies the upper bound on the conforming average rate of an ATM connection, where 'average rate' is the number of cells transmitted divided by the 'duration of the connection'.")
wfAtmVclXmtBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 5, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(40)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmVclXmtBurstSize.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVclXmtBurstSize.setDescription('Transmit (Forward) Burst Size in cells.')
wfAtmVclXmtQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 5, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("class0", 1), ("class1", 2), ("class2", 3), ("class3", 4))).clone('class3')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmVclXmtQosClass.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVclXmtQosClass.setDescription('Transmit (Forward) Quality of Service as specified in Appendix A, Section 4 of the ATM Forum UNI Specification, Version 3.0')
wfAtmVclRcvPeakCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 5, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 365566)).clone(4716)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmVclRcvPeakCellRate.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVclRcvPeakCellRate.setDescription('Receive (Backward) Peak Cell Rate in cells/second. This specifies the upper bound on the traffic that can be submitted on an ATM connection.')
wfAtmVclRcvSustainableCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 5, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 365566)).clone(4716)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmVclRcvSustainableCellRate.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVclRcvSustainableCellRate.setDescription("Receive (Backward) Sustainable Cell Rate in cells/second. This specifies the upper bound on the conforming average rate of an ATM connection, where 'average rate' is the number of cells transmitted divided by the 'duration of the connection'.")
wfAtmVclRcvBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 5, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(40)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmVclRcvBurstSize.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVclRcvBurstSize.setDescription('Receive (Backward) Burst Size in cells.')
wfAtmVclRcvQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 5, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("class0", 1), ("class1", 2), ("class2", 3), ("class3", 4))).clone('class3')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmVclRcvQosClass.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVclRcvQosClass.setDescription('Receive (Backward) Quality of Service as specified in Appendix A, Section 4 of the ATM Forum UNI Specification, Version 3.0')
wfAtmVclAalType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 5, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("type1", 1), ("type34", 2), ("type5", 3), ("other", 4), ("unknown", 5))).clone('type5')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmVclAalType.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVclAalType.setDescription('The type of AAL used on the VCL.')
wfAtmVclAalCpcsTransmitSduSize = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 5, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(4608)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmVclAalCpcsTransmitSduSize.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVclAalCpcsTransmitSduSize.setDescription('The maximum AAL CPCS SDU size in octets that is supported on the transmit direction of this VCC.')
wfAtmVclAalCpcsReceiveSduSize = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 5, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(4608)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmVclAalCpcsReceiveSduSize.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVclAalCpcsReceiveSduSize.setDescription('The maximum AAL CPCS SDU size in octets that is supported on the receive direction of this VCC.')
wfAtmVclAalEncapsType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 5, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("routedproto", 1), ("bridged8023", 2), ("bridged8025", 3), ("bridged8026", 4), ("lane8023", 5), ("lane8025", 6), ("llcencaps", 7), ("frsscs", 8), ("other", 9), ("unknown", 10))).clone('llcencaps')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmVclAalEncapsType.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVclAalEncapsType.setDescription('The type of data encapsulation used over both AAL3/4 and AAL5 SSCS layer. Currently, the only values supported are : ATM_VCLENCAPS_LLCENCAPS - RFC1483 ATM_VCLENCAPS_ROUTEDPROTO - NONE')
wfAtmVclCongestionIndication = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 5, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmVclCongestionIndication.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVclCongestionIndication.setDescription('The desired state of the Congestion Indication (CI) bit in the payload field of each ATM cell for this VCL.')
wfAtmVclCellLossPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 5, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("on", 2), ("drop-preference", 3))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmVclCellLossPriority.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVclCellLossPriority.setDescription("The desired state of the Cell Loss Priority (CLP) bit in the ATM header of each cell for this VCL. For 'drop-preference', the CLP bit will be set if the internal drop preference bit is set.")
wfAtmVclCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 5, 1, 22), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmVclCct.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVclCct.setDescription('Identifies the object which corresponds to the Wellfleet circuit number')
wfAtmVclDirectAccessCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 5, 1, 23), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmVclDirectAccessCct.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVclDirectAccessCct.setDescription('Circuit number to use for this VC for hybrid or direct access routing')
wfAtmVclMulticast = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 5, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("unicast", 1), ("multicast", 2))).clone('unicast')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmVclMulticast.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVclMulticast.setDescription('Indicates whether this VPI/VCI is used for multicast or single destination.')
wfAtmVclMode = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 5, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("groupaccess", 1), ("hybridaccess", 2), ("direct", 3))).clone('groupaccess')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmVclMode.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVclMode.setDescription("The mode of the given VC. GROUP - treats the VC as one of many vc's on a circuit. HYBRID - treats the VC as one of many vc's on a circuit for protocol traffic, but as a separate circuit for bridging. DIRECT - treats the VC as a separate circuit for all applications.")
wfAtmVclDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 5, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmVclDrops.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVclDrops.setDescription('The total count of packets above the SSCS layer dropped on this VC')
wfAtmVclVcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 5, 1, 27), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmVclVcIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVclVcIndex.setDescription('Driver-defined VCI for quick table lookup')
wfAtmVclVcType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 5, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("permanent", 1), ("switched", 2), ("control", 3), ("switchedMux", 4))).clone('permanent')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmVclVcType.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVclVcType.setDescription('Type of VC can be either permanent or switched. Only permanent VCs can be modfied. switchedMux is same as switched but is included here to be consistent with wfAtmServiceRecordVcType')
wfAtmVclXmtTagging = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 5, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmVclXmtTagging.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVclXmtTagging.setDescription('Tagging forward VC messages if peak/sustainable rates exceeded')
wfAtmVclRcvTagging = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 5, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmVclRcvTagging.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVclRcvTagging.setDescription('Tagging backward VC messages if peak/sustainable rates exceeded')
wfAtmVclOamLpbkEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 5, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmVclOamLpbkEnable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVclOamLpbkEnable.setDescription(' PVC OAM F5 Loopback function. ')
wfAtmVclOamLpbkCellInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 5, 1, 32), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmVclOamLpbkCellInterval.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVclOamLpbkCellInterval.setDescription(' This is the time interval between two consecutive OAM loopback cells in numbers of second. ')
wfAtmVclOamLpbkThreshold1 = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 5, 1, 33), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmVclOamLpbkThreshold1.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVclOamLpbkThreshold1.setDescription('This is the number of consecutive loopback OAM cells lost before the VC connection is declared down.')
wfAtmVclOamLpbkThreshold2 = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 5, 1, 34), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmVclOamLpbkThreshold2.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVclOamLpbkThreshold2.setDescription('This is the number of consecutive loopback OAM cells received before the VC connection is declared up.')
wfAtmVclOamAlarmEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 5, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmVclOamAlarmEnable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVclOamAlarmEnable.setDescription(' PVC OAM F5 alarm function. ')
wfAtmVclVcGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 5, 1, 36), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmVclVcGroup.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVclVcGroup.setDescription('The group of VCs this VC is a member of. All VCs in a given group will have the same VcGroup.')
wfAtmVclServiceClass = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 5, 1, 37), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmVclServiceClass.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVclServiceClass.setDescription('The internal service class of the traffic this VC will carry')
wfAtmVclServiceCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 5, 1, 38), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("other", 1), ("cbr", 2), ("vbrRt", 3), ("vbrNRt", 4), ("abr", 5), ("ubr", 6), ("ubrplus", 7))).clone('other')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmVclServiceCategory.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVclServiceCategory.setDescription(' The service category for a connection. other -- none of the following cbr -- constant bit rate vbrRt -- real-time variable bit rate vbrNRt -- non real-time variable bit rate abr -- available bit rate ubr -- unspecified bit rate ubrplus -- unspecified bit rate + Note: May not be supported on all ATM-based platforms.')
wfAtmVclVBRType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 5, 1, 39), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("type1", 1), ("type2", 2))).clone('type1')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmVclVBRType.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVclVBRType.setDescription('Type 1 VBR: CLP=0+1 cells are rescheduled by PCR or SCR according to the GCRA state. Type 2 VBR: CLP=0 cells are rescheduled by PCR or SCR according to the GCRA state. CLP=1 cells are always rescheduled by PCR. Note: May not be supported on all ATM-based platforms.')
wfAtmVclXmtMinimumCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 5, 1, 40), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 365566)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmVclXmtMinimumCellRate.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVclXmtMinimumCellRate.setDescription('Transmit (Forward) Minimum Cell Rate in cells/second. This specifies the minimum cell rate required by an ATM connection (the source is always allowed to send at at LEAST this rate). Note: May not be supported on all ATM-based platforms and/or service categories.')
wfAtmVclXmtInitialCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 5, 1, 41), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 365566)).clone(4716)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmVclXmtInitialCellRate.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVclXmtInitialCellRate.setDescription('Transmit (Forward) Initial Cell Rate in cells/second. The ICR is the rate at which the source should send initially and after an idle period. Note: May not be supported on all ATM-based platforms and/or service categories.')
wfAtmVclXmtRateIncreaseFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 5, 1, 42), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmVclXmtRateIncreaseFactor.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVclXmtRateIncreaseFactor.setDescription('Rate increase factor (RIF) controls the amount by which the cell Tx rate may increase upon receipt of an RM (Resource Management) cell. The value is a power of 2 from 1/32768 to 1. Legal values are 0-15 (0==1, 15==1/32768). The default is 4 (2**-4==1/16) as specified by af-tm-0056.000. Note: May not be supported on all ATM-based platforms and/or service categories.')
wfAtmVclXmtRateDecreaseFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 5, 1, 43), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmVclXmtRateDecreaseFactor.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVclXmtRateDecreaseFactor.setDescription('Rate decrease factor (RDF) controls the decrease in the cell Tx rate. The value is a power of 2 from 1/32768 to 1. Legal values are 0-15 (0==1, 15==1/32768). The default is 4 (2**-4==1/16) as specified by af-tm-0056.000. Note: May not be supported on all ATM-based platforms and/or service categories.')
wfAtmVclStatsTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 6), )
if mibBuilder.loadTexts: wfAtmVclStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVclStatsTable.setDescription('')
wfAtmVclStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 6, 1), ).setIndexNames((0, "Wellfleet-ATM-MIB", "wfAtmVclStatsIndex"), (0, "Wellfleet-ATM-MIB", "wfAtmVclStatsVpi"), (0, "Wellfleet-ATM-MIB", "wfAtmVclStatsVci"))
if mibBuilder.loadTexts: wfAtmVclStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVclStatsEntry.setDescription('Entry definition.')
wfAtmVclStatsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmVclStatsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVclStatsIndex.setDescription('Uniquely identifies the interface that contains the appropriate management information.')
wfAtmVclStatsVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 6, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmVclStatsVpi.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVclStatsVpi.setDescription('The Virtual Path Identifier (VPI) value of the VCL.')
wfAtmVclStatsVci = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 6, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmVclStatsVci.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVclStatsVci.setDescription('The Virtual Channel Identifier (VCI) value of the VCL.')
wfAtmVclStatsVcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 6, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmVclStatsVcIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVclStatsVcIndex.setDescription('Uniquely identifies the virtual channel connection.')
wfAtmVclXmtCells = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 6, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmVclXmtCells.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVclXmtCells.setDescription('Accumulated total of user cells transmitted for this VCL. This attribute is a 64-bit counter. Does not include OAM cells.')
wfAtmVclRcvCells = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 6, 1, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmVclRcvCells.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVclRcvCells.setDescription('Accumulated total of user cells received for this VCL. This attribute is a 64-bit counter. Does not include OAM cells.')
wfAtmVclRcvSequenceNumErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 6, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmVclRcvSequenceNumErrs.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVclRcvSequenceNumErrs.setDescription('Number of times data was being reassembled and a SAR Protocol Data Unit (PDU) was received out of order for this VCL. This count is valid only when the adaptation layer protocol is AAL 3/4.')
wfAtmVclRcvInvalidLenErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 6, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmVclRcvInvalidLenErrs.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVclRcvInvalidLenErrs.setDescription('')
wfAtmVclRcvMissingEomErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 6, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmVclRcvMissingEomErrs.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVclRcvMissingEomErrs.setDescription('')
wfAtmVclRcvBufferOflowErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 6, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmVclRcvBufferOflowErrs.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVclRcvBufferOflowErrs.setDescription('')
wfAtmVclRcvMaxLenExceedErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 6, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmVclRcvMaxLenExceedErrs.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVclRcvMaxLenExceedErrs.setDescription('')
wfAtmVclRcvTrailerErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 6, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmVclRcvTrailerErrs.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVclRcvTrailerErrs.setDescription('')
wfAtmVclRcvAbortErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 6, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmVclRcvAbortErrs.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVclRcvAbortErrs.setDescription('')
wfAtmVclRcvPacketLengthErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 6, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmVclRcvPacketLengthErrs.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVclRcvPacketLengthErrs.setDescription('')
wfAtmVclRcvReassemAbortErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 6, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmVclRcvReassemAbortErrs.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVclRcvReassemAbortErrs.setDescription('')
wfAtmVclRcvCrcErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 6, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmVclRcvCrcErrs.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVclRcvCrcErrs.setDescription('')
wfAtmVclXmtOamCells = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 6, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmVclXmtOamCells.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVclXmtOamCells.setDescription('Count of OAM cells transmitted successfully.')
wfAtmVclRcvOamCells = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 6, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmVclRcvOamCells.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVclRcvOamCells.setDescription('Count of OAM cells received successfully.')
wfAtmVclRcvOamCrcErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 6, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmVclRcvOamCrcErrs.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVclRcvOamCrcErrs.setDescription('Count of OAM cells received with CRC10 error.')
wfAtmSigTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 7), )
if mibBuilder.loadTexts: wfAtmSigTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSigTable.setDescription('This table includes the ATM Signalling MIB record for Q.93B')
wfAtmSigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 7, 1), ).setIndexNames((0, "Wellfleet-ATM-MIB", "wfAtmSigLineNumber"))
if mibBuilder.loadTexts: wfAtmSigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSigEntry.setDescription('This entry contains attributes needed for ATM Q.93B')
wfAtmSigDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 7, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmSigDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSigDelete.setDescription('Create/Delete parameter. Default is created.')
wfAtmSigDisable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 7, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmSigDisable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSigDisable.setDescription('Enable/Disable parameter')
wfAtmSigLineNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 7, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmSigLineNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSigLineNumber.setDescription('Instance identifier. This value is the line number of the router.')
wfAtmSigAtmCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 7, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmSigAtmCct.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSigAtmCct.setDescription('Circuit number of ATM driver associated with this Q.93B instance')
wfAtmSigState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 7, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("init", 3), ("notpresent", 4))).clone('notpresent')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmSigState.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSigState.setDescription('Indicates the state of the Q.93B entity')
wfAtmSigMaxServiceUsers = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 7, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32767)).clone(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmSigMaxServiceUsers.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSigMaxServiceUsers.setDescription('Max number of SAPs (service access points) allowed for users to connect')
wfAtmSigMaxPtPtConnections = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 7, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32767)).clone(1000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmSigMaxPtPtConnections.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSigMaxPtPtConnections.setDescription('Max number of simultaneous point to point connections allowed per port')
wfAtmSigMaxPtMultConnections = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 7, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32767)).clone(40)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmSigMaxPtMultConnections.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSigMaxPtMultConnections.setDescription('Max number of simultaneous point to multipt connections allowed per port')
wfAtmSigMaxPartiesInMultConnect = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 7, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32767)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmSigMaxPartiesInMultConnect.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSigMaxPartiesInMultConnect.setDescription('Max number of simultaneous parties in a point to multipoint connection')
wfAtmSigMaxRoutingRegistrations = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 7, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32767))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmSigMaxRoutingRegistrations.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSigMaxRoutingRegistrations.setDescription('Max number of registrations / routing entries allowed per port')
wfAtmSigMinBufferThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 7, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmSigMinBufferThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSigMinBufferThreshold.setDescription('Min percentage of buffer pool that must be free to enable new calls (sub)')
wfAtmSigTimerResolution = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 7, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255000)).clone(1024)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmSigTimerResolution.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSigTimerResolution.setDescription('Number of system ticks elapsed between successive timer events in tenths')
wfAtmSigVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 7, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmSigVpi.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSigVpi.setDescription('Virtual Path Identifier for the Signalling VC')
wfAtmSigVci = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 7, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmSigVci.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSigVci.setDescription('Virtual Channel Identifier for the Signalling VC')
wfAtmSigStandard = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 7, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("v30", 1), ("v31", 2), ("v40", 3), ("sym", 4))).clone('v30')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmSigStandard.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSigStandard.setDescription('Sig Protocol Standard, Uni3.0, Uni3.1, or Trillium Symmetrical Uni (sub)')
wfAtmSigInterfaceType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 7, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("user", 1), ("network", 2))).clone('user')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmSigInterfaceType.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSigInterfaceType.setDescription('Network Interface type, either USER or NETWORK side (sub)')
wfAtmSigMinVciPtPt = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 7, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(32, 65535)).clone(32)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmSigMinVciPtPt.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSigMinVciPtPt.setDescription('Minimum VCI number that can be associated with a Point to Point VC')
wfAtmSigMaxVciPtPt = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 7, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(32, 65535)).clone(65535)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmSigMaxVciPtPt.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSigMaxVciPtPt.setDescription('Maximum VCI number that can be associated with a Point to Point VC')
wfAtmSigMinVpiPtPt = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 7, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmSigMinVpiPtPt.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSigMinVpiPtPt.setDescription('Minimum VPI number that can be associated with a Point to Point VC')
wfAtmSigMaxVpiPtPt = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 7, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmSigMaxVpiPtPt.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSigMaxVpiPtPt.setDescription('Maximum VPI number that can be associated with a Point to Point VC')
wfAtmSigMinVciPtMltPt = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 7, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(32, 65535)).clone(32)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmSigMinVciPtMltPt.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSigMinVciPtMltPt.setDescription('Minimum VCI number that can be associated with a Point to Multipoint VC')
wfAtmSigMaxVciPtMltPt = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 7, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(32, 65535)).clone(65535)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmSigMaxVciPtMltPt.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSigMaxVciPtMltPt.setDescription('Maximum VCI number that can be associated with a Point to Multipoint VC')
wfAtmSigMinVpiPtMltPt = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 7, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmSigMinVpiPtMltPt.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSigMinVpiPtMltPt.setDescription('Minimum VPI number that can be associated with a Point to Multipoint VC')
wfAtmSigMaxVpiPtMltPt = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 7, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmSigMaxVpiPtMltPt.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSigMaxVpiPtMltPt.setDescription('Maximum VPI number that can be associated with a Point to Multipoint VC')
wfAtmSigT303 = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 7, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 24)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmSigT303.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSigT303.setDescription('Q.93B Setup Sent Timer')
wfAtmSigT308 = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 7, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 180)).clone(30)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmSigT308.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSigT308.setDescription('Q.93B Release Sent Timer')
wfAtmSigT309 = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 7, 1, 27), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 540)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmSigT309.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSigT309.setDescription('Q.93B - SAAL Data Link Connect Timer')
wfAtmSigT310 = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 7, 1, 28), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmSigT310.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSigT310.setDescription('Q.93B Call Proceeding Received Timer')
wfAtmSigT313 = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 7, 1, 29), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 24)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmSigT313.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSigT313.setDescription('Q.93B Connect Sent Timer')
wfAtmSigT316 = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 7, 1, 30), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 720)).clone(120)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmSigT316.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSigT316.setDescription('Q.93B Restart Request Sent on Interface Timer')
wfAtmSigT316c = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 7, 1, 31), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 720)).clone(120)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmSigT316c.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSigT316c.setDescription('Q.93B Restart Request Sent on Channel Timer')
wfAtmSigT322 = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 7, 1, 32), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 24)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmSigT322.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSigT322.setDescription('Q.93B Status Enquiry Sent Timer')
wfAtmSigTDisc = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 7, 1, 33), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 180)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmSigTDisc.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSigTDisc.setDescription('Q.93B SAAL Data Link Disconnect Timer')
wfAtmSigT398 = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 7, 1, 34), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 24)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmSigT398.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSigT398.setDescription('Q.93B Drop Party Sent Timer - Multipoint Connections only')
wfAtmSigT399 = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 7, 1, 35), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 84)).clone(14)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmSigT399.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSigT399.setDescription('Q.93B Add Party Sent Timer - Multipoint Connections only')
wfAtmSigNumRst = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 7, 1, 36), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100)).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmSigNumRst.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSigNumRst.setDescription('Number of restarts to be retransmitted before link considered down')
wfAtmSigNumStat = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 7, 1, 37), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100)).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmSigNumStat.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSigNumStat.setDescription('Number of status enquiries to be retransmitted before link considered down')
wfAtmSigRestart = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 7, 1, 38), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('on')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmSigRestart.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSigRestart.setDescription('Q.93B send restart when the link comes up. (sub)')
wfAtmSigDebug = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 7, 1, 39), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 2147483647))).clone(namedValues=NamedValues(("disabled", 1), ("status", 2), ("detail", 4), ("all", 2147483647))).clone('status')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmSigDebug.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSigDebug.setDescription('This flag will enable certain debug messages depending on the value set. The values are as follows: 1 - disable debugging 2 - Signalling Status events 4294967295 - All of the above')
wfAtmSigCallsSec = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 7, 1, 40), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmSigCallsSec.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSigCallsSec.setDescription('The number of signaling messages per second allowed to flow out of the interface (call pacing). Zero turns this feature off.')
wfAtmSigT301 = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 7, 1, 41), Integer32().subtype(subtypeSpec=ValueRangeConstraint(180, 1024)).clone(180)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmSigT301.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSigT301.setDescription('Q.93B Alert Received Timer')
wfAtmSigT304 = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 7, 1, 42), Integer32().subtype(subtypeSpec=ValueRangeConstraint(30, 120)).clone(30)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmSigT304.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSigT304.setDescription('Q.93B Setup Ack Received Timer')
wfAtmSigT397 = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 7, 1, 43), Integer32().subtype(subtypeSpec=ValueRangeConstraint(180, 1024)).clone(180)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmSigT397.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSigT397.setDescription('Q.93B Alerting or Add Party Alterting Received Timer')
wfAtmSscopTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 8), )
if mibBuilder.loadTexts: wfAtmSscopTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSscopTable.setDescription('This table includes the ATM SSCOP MIB record for Q.SAAL')
wfAtmSscopEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 8, 1), ).setIndexNames((0, "Wellfleet-ATM-MIB", "wfAtmSscopLineNumber"))
if mibBuilder.loadTexts: wfAtmSscopEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSscopEntry.setDescription('This entry contains attributes needed for ATM Q.SAAL')
wfAtmSscopDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 8, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmSscopDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSscopDelete.setDescription('Create/Delete parameter. Default is created.')
wfAtmSscopDisable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 8, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmSscopDisable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSscopDisable.setDescription('Enable/Disable parameter')
wfAtmSscopLineNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 8, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmSscopLineNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSscopLineNumber.setDescription('Instance identifier. This value is the line number of the router.')
wfAtmSscopAtmCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 8, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmSscopAtmCct.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSscopAtmCct.setDescription('Circuit number of ATM driver associated with this Q.SAAL instance')
wfAtmSscopState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 8, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("init", 3), ("notpresent", 4))).clone('notpresent')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmSscopState.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSscopState.setDescription('Indicates the state of the Q.SAAL entity')
wfAtmSscopLowThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 8, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmSscopLowThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSscopLowThreshold.setDescription('Congestion is reached when % of buffer pool goes below this threshold (sub)')
wfAtmSscopUpThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 8, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmSscopUpThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSscopUpThreshold.setDescription('Congestion is stopped when % of buffer pool goes above this threshold (sub)')
wfAtmSscopArbitration = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 8, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("passive", 1), ("active", 2))).clone('active')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmSscopArbitration.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSscopArbitration.setDescription('Determines if Q.SAAL initiates link connection or waits for connect (sub)')
wfAtmSscopPollTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 8, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 120)).clone(7)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmSscopPollTimer.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSscopPollTimer.setDescription('SSCOP Poll Timer. The Maximum time between transmission of a POLL PDU in tenths/sec')
wfAtmSscopKeepAliveTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 8, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 120)).clone(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmSscopKeepAliveTimer.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSscopKeepAliveTimer.setDescription("SSCOP Keep Alive Timer. If no pending SD or SDP PDU's transmit a POLL PDU in tenths/sec")
wfAtmSscopNoResponseTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 8, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 120)).clone(70)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmSscopNoResponseTimer.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSscopNoResponseTimer.setDescription('SSCOP No Response Timer. Max time between receipt of a STAT PDU in tenths/sec')
wfAtmSscopConnectControlTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 8, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 120)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmSscopConnectControlTimer.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSscopConnectControlTimer.setDescription('SSCOP CC Timer. Time between xmt of BGN, END as long as ACK not received in tenths/sec')
wfAtmSscopMaxCc = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 8, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmSscopMaxCc.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSscopMaxCc.setDescription('SSCOP MaxCC. Maximum number of transmissions of a BGN, END or RS PDU.')
wfAtmSscopMaxPd = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 8, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 120)).clone(25)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmSscopMaxPd.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSscopMaxPd.setDescription('SSCOP MaxPD. Maximum value of VT(PD) before transmitting POLL PDU.')
wfAtmSscopMaxStat = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 8, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 120)).clone(67)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmSscopMaxStat.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSscopMaxStat.setDescription('SSCOP MaxSTAT. Maximum number of list elements permissible in a STAT PDU')
wfAtmSscopIdleTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 8, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 400)).clone(150)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmSscopIdleTimer.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSscopIdleTimer.setDescription('SSCOP Idle Timer. Timer used to determine when to enter the transient connection phase. Units in tenths/second.')
wfAtmSscopStandard = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 8, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("v30", 1), ("v31", 2), ("v40", 3))).clone('v30')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmSscopStandard.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSscopStandard.setDescription('SSCOP version switch. UNI_V30, UNI_V31 and UNI_V40 for now. Probably no more than this.')
wfAtmSscopDebug = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 8, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 2147483647))).clone(namedValues=NamedValues(("disabled", 1), ("status", 2), ("detail", 4), ("all", 2147483647))).clone('status')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmSscopDebug.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmSscopDebug.setDescription('This flag will enable certain debug messages depending on the value set. The values are as follows: 1 - disable debugging 2 - SSCOP Status events 4294967295 - All of the above')
wfAtmIlmiTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 9), )
if mibBuilder.loadTexts: wfAtmIlmiTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmIlmiTable.setDescription('This table includes the ATM ILMI MIB record for UME/ILMI')
wfAtmIlmiEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 9, 1), ).setIndexNames((0, "Wellfleet-ATM-MIB", "wfAtmIlmiLineNumber"))
if mibBuilder.loadTexts: wfAtmIlmiEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmIlmiEntry.setDescription('This entry contains attributes needed for ATM UME/ILMI')
wfAtmIlmiDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 9, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmIlmiDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmIlmiDelete.setDescription('Create/Delete parameter. Default is created.')
wfAtmIlmiDisable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 9, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmIlmiDisable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmIlmiDisable.setDescription('Enable/Disable parameter')
wfAtmIlmiLineNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 9, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmIlmiLineNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmIlmiLineNumber.setDescription('Instance identifier. This value is the line number of the router.')
wfAtmIlmiAtmCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 9, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmIlmiAtmCct.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmIlmiAtmCct.setDescription('Circuit number of ATM driver associated with this UME/ILMI instance')
wfAtmIlmiState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 9, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("init", 3), ("notpresent", 4))).clone('notpresent')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmIlmiState.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmIlmiState.setDescription('Indicates the state of the UME/ILMI entity')
wfAtmIlmiLowThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 9, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmIlmiLowThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmIlmiLowThreshold.setDescription('Congestion is reached when % of buffer pool goes below this threshold (sub)')
wfAtmIlmiUpThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 9, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmIlmiUpThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmIlmiUpThreshold.setDescription('Congestion is stopped when % of buffer pool goes above this threshold (sub)')
wfAtmIlmiVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 9, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmIlmiVpi.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmIlmiVpi.setDescription('Virtual Path Identifier for the UME/ILMI VC')
wfAtmIlmiVci = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 9, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(16)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmIlmiVci.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmIlmiVci.setDescription('Virtual Channel Identifier for the UME/ILMI VC')
wfAtmIlmiInterfaceType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 9, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("user", 1), ("network", 2))).clone('user')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmIlmiInterfaceType.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmIlmiInterfaceType.setDescription('Network Interface type, either USER or NETWORK side of the UME/ILMI')
wfAtmIlmiLocalPort = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 9, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmIlmiLocalPort.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmIlmiLocalPort.setDescription('AAL UME/ILMI local port identifier')
wfAtmIlmiRemotePort = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 9, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmIlmiRemotePort.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmIlmiRemotePort.setDescription('AAL UME/ILMI remote port identifier')
wfAtmIlmiGetTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 9, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 120)).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmIlmiGetTimer.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmIlmiGetTimer.setDescription('UME/ILMI Get request timer')
wfAtmIlmiGetRetryCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 9, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100)).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmIlmiGetRetryCnt.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmIlmiGetRetryCnt.setDescription('Max number of retransmissions of the UME/ILMI GET request before link down')
wfAtmIlmiGetNextTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 9, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 120)).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmIlmiGetNextTimer.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmIlmiGetNextTimer.setDescription('UME/ILMI GetNext request timer')
wfAtmIlmiGetNextRetryCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 9, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100)).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmIlmiGetNextRetryCnt.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmIlmiGetNextRetryCnt.setDescription('Max number of retransmits of the UME/ILMI GETNEXT request before link down')
wfAtmIlmiSetTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 9, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 120)).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmIlmiSetTimer.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmIlmiSetTimer.setDescription('UME/ILMI Set request timer')
wfAtmIlmiSetRetryCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 9, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100)).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmIlmiSetRetryCnt.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmIlmiSetRetryCnt.setDescription('Max number of retransmissions of the UME/ILMI SET request before link down')
wfAtmIlmiLocalOid = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 9, 1, 19), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmIlmiLocalOid.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmIlmiLocalOid.setDescription('Identifies the OID of the first object in the standard DS1 or DS3 MIB corresponding to this ATM UNI port')
wfAtmIlmiDebug = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 9, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 2147483647))).clone(namedValues=NamedValues(("disabled", 1), ("status", 2), ("detail", 4), ("all", 2147483647))).clone('status')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmIlmiDebug.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmIlmiDebug.setDescription('This flag will enable certain debug messages depending on the value set. The values are as follows: 1 - disable debugging 2 - ILMI Status events 4294967295 - All of the above')
wfAtmIlmiNetPrefixTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 9, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 120)).clone(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmIlmiNetPrefixTimer.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmIlmiNetPrefixTimer.setDescription('Time to wait for a Net prefix before restarting UME')
wfAtmNetPrefixTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 10), )
if mibBuilder.loadTexts: wfAtmNetPrefixTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmNetPrefixTable.setDescription('This table includes the ATM Network Address Prefix record')
wfAtmNetPrefixEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 10, 1), ).setIndexNames((0, "Wellfleet-ATM-MIB", "wfAtmNetPrefixPort"), (0, "Wellfleet-ATM-MIB", "wfAtmNetPrefixPrefix"))
if mibBuilder.loadTexts: wfAtmNetPrefixEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmNetPrefixEntry.setDescription('This entry contains attributes needed for a ATM Network Address Prefix')
wfAtmNetPrefixPort = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 10, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmNetPrefixPort.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmNetPrefixPort.setDescription('Port which uniquely identifies the UNI (ie. InterfaceIndex or line number)')
wfAtmNetPrefixPrefix = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 10, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmNetPrefixPrefix.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmNetPrefixPrefix.setDescription('Network Prefix used on this UNI')
wfAtmNetPrefixStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2))).clone('valid')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmNetPrefixStatus.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmNetPrefixStatus.setDescription('Status of Network Prefix (being used or not being used)')
wfAtmTableDebugTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 11), )
if mibBuilder.loadTexts: wfAtmTableDebugTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmTableDebugTable.setDescription('This is used to display the contents of internal ATM tables in the event log, for debug purposes.')
wfAtmTableDebugEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 11, 1), ).setIndexNames((0, "Wellfleet-ATM-MIB", "wfAtmTableDebugSlot"))
if mibBuilder.loadTexts: wfAtmTableDebugEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmTableDebugEntry.setDescription('This entry contains attributes needed for debugging internal ATM tables.')
wfAtmTableDebugDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmTableDebugDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmTableDebugDelete.setDescription('Create/Delete attribute.')
wfAtmTableDebugSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 11, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmTableDebugSlot.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmTableDebugSlot.setDescription('Slot that we want to dump ATM tables from.')
wfAtmTableDebugType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 11, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmTableDebugType.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmTableDebugType.setDescription('Slot that we want to dump ATM tables from.')
wfAtmAlcDrvTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 1), )
if mibBuilder.loadTexts: wfAtmAlcDrvTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcDrvTable.setDescription('This table contains line record entries for each driver responsible for the management and control of an ATM/ALC interface.')
wfAtmAlcDrvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 1, 1), ).setIndexNames((0, "Wellfleet-ATM-MIB", "wfAtmAlcSlot"), (0, "Wellfleet-ATM-MIB", "wfAtmAlcPort"))
if mibBuilder.loadTexts: wfAtmAlcDrvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcDrvEntry.setDescription('Entry definition.')
wfAtmAlcDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("create", 1), ("delete", 2))).clone('create')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcDelete.setDescription('Create/delete MIB instance parameter.')
wfAtmAlcDisable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcDisable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcDisable.setDescription('Enable/disable driver parameter.')
wfAtmAlcState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 20))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("init", 3), ("download", 4), ("config", 5), ("notpresent", 20))).clone('notpresent')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcState.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcState.setDescription('Driver state parameter. This parameter does not represent the state of the physical interface!')
wfAtmAlcSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 14))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcSlot.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcSlot.setDescription('Slot number -- instance id.')
wfAtmAlcPort = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("one", 1), ("two", 2), ("three", 3), ("four", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcPort.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcPort.setDescription('Physical port number -- instance id.')
wfAtmAlcCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1023))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcCct.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCct.setDescription('Circuit number for the driver.')
wfAtmAlcLineNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 1, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcLineNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcLineNumber.setDescription('Index value used to uniquely identify an instance of a physical ATM port. This index is generally chosen by SiteManager and shall be used as an instance identifier for ATM MIB objects.')
wfAtmAlcType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("typesonet", 1), ("typeds3", 2), ("type100mb", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcType.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcType.setDescription("The type of interface. This attribute is an alias for 'ifType.")
wfAtmAlcMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4608))).clone(namedValues=NamedValues(("default", 4608)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcMtu.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcMtu.setDescription("The size of the largest packet which can be sent/received on the interface, specified in octets. This attribute is an alias for 'ifMtu'.")
wfAtmAlcSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(155520000, 100000000, 44736000))).clone(namedValues=NamedValues(("speed155mb", 155520000), ("speed100mb", 100000000), ("speed45mb", 44736000)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcSpeed.setDescription("An estimate of the interface's current bandwidth in bits per second. This attribute is an alias for 'ifSpeed'.")
wfAtmAlcLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 1, 1, 11), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcLastChange.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcLastChange.setDescription("The time (in hundreths of a second) since the network management portion of the system was last re-initialized. This attribute is an alias for 'ifLastChange' in the MIBII System Group.")
wfAtmAlcInterfaceStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3), ("unknown", 4), ("dormant", 5))).clone('unknown')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcInterfaceStatus.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcInterfaceStatus.setDescription('MIB-II ifOperStatus')
wfAtmAlcInterfaceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 1, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcInterfaceIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcInterfaceIndex.setDescription('MIB-II interface index')
wfAtmAlcDpNotify = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcDpNotify.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcDpNotify.setDescription('Data Path (DP) notify function. This function, when enabled, will disable the DP interface when the physical interface becomes non-operational.')
wfAtmAlcDpNotifyTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3600)).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcDpNotifyTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcDpNotifyTimeout.setDescription('Data Path (DP) notify function timeout period. This value specifies the number of seconds to wait before implementing the DP notify function. A timer will get set to this value when the state of the physical interface transitions from operational to non-operational when the DP notify function is enabled.')
wfAtmAlcConfControlQSize = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(10))).clone(namedValues=NamedValues(("default", 10))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcConfControlQSize.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcConfControlQSize.setDescription('Number of command elements in each of the two Host Interface control qs')
wfAtmAlcConfIntqSize = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(100))).clone(namedValues=NamedValues(("default", 100))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcConfIntqSize.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcConfIntqSize.setDescription('Number of elements in the Host Interface interrupt queue')
wfAtmAlcConfLogqSize = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(25))).clone(namedValues=NamedValues(("default", 25))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcConfLogqSize.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcConfLogqSize.setDescription('Number of elements in the Host Interface log queue')
wfAtmAlcConfNumXmtQueues = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 1, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(12, 29)).clone(24)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcConfNumXmtQueues.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcConfNumXmtQueues.setDescription('Number of transmit queues in the Host Interface between the Host Driver and the CoP Driver')
wfAtmAlcUseDebugger = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcUseDebugger.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcUseDebugger.setDescription('This attribute controls a debugger which may be built into the Coprocessor image. Shipped code does not include this debugger.')
wfAtmAlcConfXmtClipSlotMax = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 1, 1, 21), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcConfXmtClipSlotMax.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcConfXmtClipSlotMax.setDescription('Number of frames the slot may queue up for transmit before the Host Driver begins to clip. Setting this attribute forces the driver to use the non zero value of the attribute rather than selecting a clip point automatically.')
wfAtmAlcXmtClipSlotMax = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 1, 1, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcXmtClipSlotMax.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcXmtClipSlotMax.setDescription('Number of buffers per slot beyond which the driver will clip on transmit. Set by the driver. May be forced by setting wfAtmAlcConfXmtClipSlotMax != 0')
wfAtmAlcConfXmtClipQueueMax = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 1, 1, 23), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcConfXmtClipQueueMax.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcConfXmtClipQueueMax.setDescription('Number of frames a transmit queue may queue up before the Host Driver begins to clip. Setting this attribute forces the driver to use the non zero value of the attribute rather than selecting a clip point automatically.')
wfAtmAlcXmtClipQueueMax = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 1, 1, 24), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcXmtClipQueueMax.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcXmtClipQueueMax.setDescription('Number of buffers per transmit queue beyond which the driver will clip on transmit. Set by the driver. May be forced by setting wfAtmAlcConfXmtClipQueueMax != 0')
wfAtmAlcConfXmtClipQueueMin = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 1, 1, 25), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcConfXmtClipQueueMin.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcConfXmtClipQueueMin.setDescription('Number of frames a transmit queue will always be permitted to queue up regardless of the current value of wfAtmOutQLen relative to wfAtmXmtClipSlotMax. Setting this attribute forces the driver to use the nonzero value of the attribute rather than selecting a clip point automatically.')
wfAtmAlcXmtClipQueueMin = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 1, 1, 26), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcXmtClipQueueMin.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcXmtClipQueueMin.setDescription('Number of buffers each transmit queue is guaranteed to get before the driver clips due to the value of wfAtmXmtClipSlotMax. Set by the driver. May be forced by setting wfAtmAlcConfXmtClipQueueMin != 0')
wfAtmAlcXmtQueueBurst = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 1, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(40))).clone(namedValues=NamedValues(("default", 40))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcXmtQueueBurst.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcXmtQueueBurst.setDescription('Burst count for all transmit queues in CoP. Specifies the number of buffer(ettes) the CoP will process from a transmit queue in one service opportunity. A value of 0 (zero) will cause the CoP to burst forever (i.e., until either all data is transmitted from the queue or no more buffer(ette)s are available to transmit into.')
wfAtmAlcXmtPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 1, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcXmtPackets.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcXmtPackets.setDescription('Count of Service Data Units (SDUs) transmitted without error.')
wfAtmAlcXmtPacketClips = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 1, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcXmtPacketClips.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcXmtPacketClips.setDescription('Count of packets dropped on transmit.')
wfAtmAlcXmtOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 1, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcXmtOctets.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcXmtOctets.setDescription('Count of octets transmitted without error over the link interface. These octets are associated with user data only and not overhead or padding octets.')
wfAtmAlcOutQLen = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 1, 1, 31), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcOutQLen.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcOutQLen.setDescription("This attribute is an alias for 'ifOutQLen' in the MIBII interface group.")
wfAtmAlcRcvPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 1, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcRcvPackets.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcRcvPackets.setDescription('Count of Service Data Units (SDUs) received without error.')
wfAtmAlcRcvReplenMisses = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 1, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcRcvReplenMisses.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcRcvReplenMisses.setDescription('Number of packet buffer misses while attempting to replenish driver receive ring.')
wfAtmAlcConfRcvBuffersMax = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 1, 1, 34), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcConfRcvBuffersMax.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcConfRcvBuffersMax.setDescription('Number of buffers the driver will try to maintain on its receive queue. Setting this attribute forces the driver to use the non zero value of the attribute rather than selecting a buffer count automatically.')
wfAtmAlcRcvBuffersMax = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 1, 1, 35), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcRcvBuffersMax.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcRcvBuffersMax.setDescription('Number of buffers which the driver will attempt to maintain on the receive queue. Set by the driver. May be forced by setting wfAtmAlcConfRcvBuffersMax != 0')
wfAtmAlcMadrCt = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 1, 1, 36), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcMadrCt.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcMadrCt.setDescription('Number of PROM-based MAC addresses.')
wfAtmAlcMadr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 1, 1, 37), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcMadr.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcMadr.setDescription('First MAC address in canonical format (i.e., 00-00-a2...). The number of subsequent MAC addresses is specified by wfAtmAlcMadrCt which are sequential.')
wfAtmAlcVcInactEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 1, 1, 38), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcVcInactEnable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcVcInactEnable.setDescription('Inactivity timeout function. When this function is enabled, all activated VCs will be polled, at an interval specified by wfAtmAlcCopVcInactTimeout, for inactivity.')
wfAtmAlcXmtBadVcs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 1, 1, 39), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcXmtBadVcs.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcXmtBadVcs.setDescription('Count of packets dropped on transmit because of an invalid VPI/VCI.')
wfAtmAlcXmtqTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 2), )
if mibBuilder.loadTexts: wfAtmAlcXmtqTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcXmtqTable.setDescription('Object created by the Host Driver, one for each transmit queue')
wfAtmAlcXmtqEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 2, 1), ).setIndexNames((0, "Wellfleet-ATM-MIB", "wfAtmAlcXmtqIndex"), (0, "Wellfleet-ATM-MIB", "wfAtmAlcXmtqNumber"))
if mibBuilder.loadTexts: wfAtmAlcXmtqEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcXmtqEntry.setDescription('An entry in the ATM Transmit Queue Table')
wfAtmAlcXmtqIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcXmtqIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcXmtqIndex.setDescription('Uniquely identifies the interface (port) that contains the appropriate management information.')
wfAtmAlcXmtqNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(3, 28))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcXmtqNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcXmtqNumber.setDescription('Identifies a particular instance of a transmit queue.')
wfAtmAlcXmtqState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 20))).clone(namedValues=NamedValues(("created", 1), ("initdone", 2), ("msgsent", 3), ("notpresent", 20))).clone('notpresent')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcXmtqState.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcXmtqState.setDescription('State of the transmit queue.')
wfAtmAlcXmtqStickyMask = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcXmtqStickyMask.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcXmtqStickyMask.setDescription('')
wfAtmAlcXmtqVcs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcXmtqVcs.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcXmtqVcs.setDescription('Number of Virtual Connections (VCs) configured for this queue.')
wfAtmAlcXmtqOutQLen = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 2, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcXmtqOutQLen.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcXmtqOutQLen.setDescription('')
wfAtmAlcXmtqOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcXmtqOctets.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcXmtqOctets.setDescription('')
wfAtmAlcXmtqPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcXmtqPackets.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcXmtqPackets.setDescription('')
wfAtmAlcXmtqPacketClips = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcXmtqPacketClips.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcXmtqPacketClips.setDescription('')
wfAtmAlcCopConfTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 3), )
if mibBuilder.loadTexts: wfAtmAlcCopConfTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopConfTable.setDescription('This table contains basic CONFIGURATION information for the ATM/ALC CoProcessor (CoP) environment.')
wfAtmAlcCopConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 3, 1), ).setIndexNames((0, "Wellfleet-ATM-MIB", "wfAtmAlcCopConfIndex"))
if mibBuilder.loadTexts: wfAtmAlcCopConfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopConfEntry.setDescription('Entry definition.')
wfAtmAlcCopConfDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("create", 1), ("delete", 2))).clone('create')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcCopConfDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopConfDelete.setDescription('Create/delete MIB instance parameter.')
wfAtmAlcCopConfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcCopConfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopConfIndex.setDescription('Uniquely identifies the interface that contains the appropriate management information.')
wfAtmAlcCopBufSize = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(128, 1024)).clone(532)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcCopBufSize.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopBufSize.setDescription('Size in bytes of buffer(ettes).')
wfAtmAlcCopConfXmtBufs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 90)).clone(55)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcCopConfXmtBufs.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopConfXmtBufs.setDescription('Percentage of transmit buffers to allocate in relation to the total packet memory size.')
wfAtmAlcCopConfRcvBufs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 90)).clone(45)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcCopConfRcvBufs.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopConfRcvBufs.setDescription('Percentage of receive buffers to allocate in relation to the total packet memory size.')
wfAtmAlcCopDmaHighWatermark = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 3, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 512)).clone(32)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcCopDmaHighWatermark.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopDmaHighWatermark.setDescription("DMA FIFO high watermark. This value determines the mark upon which the DMA controller will generate an interrupt specifying FIFO 'almost full'.")
wfAtmAlcCopDmaLowWatermark = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 3, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 512)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcCopDmaLowWatermark.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopDmaLowWatermark.setDescription("DMA FIFO low watermark. This value determines the mark upon which the DMA controller will generate an interrupt specifying FIFO 'almost empty'.")
wfAtmAlcCopCacheControl = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("both", 1), ("icache", 2), ("dcache", 3), ("none", 4))).clone('both')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcCopCacheControl.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopCacheControl.setDescription('Determines the state of the cache control register in the CoP.')
wfAtmAlcCopHwModId = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 3, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcCopHwModId.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopHwModId.setDescription('Link module hardware identifier. Includes physical interface type.')
wfAtmAlcCopVcInactTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 3, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(60, 3600)).clone(1200)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcCopVcInactTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopVcInactTimeout.setDescription('Inactivity timeout value for all VCs on this interface in seconds. If no cells have been transmitted or received on an VC over the given timeout period then the VC will be closed.')
wfAtmAlcCopHwTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 4), )
if mibBuilder.loadTexts: wfAtmAlcCopHwTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopHwTable.setDescription('This table contains hardware information relating to the ATM/ALC link module.')
wfAtmAlcCopHwEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 4, 1), ).setIndexNames((0, "Wellfleet-ATM-MIB", "wfAtmAlcCopHwIndex"))
if mibBuilder.loadTexts: wfAtmAlcCopHwEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopHwEntry.setDescription('Entry definition.')
wfAtmAlcCopHwIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcCopHwIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopHwIndex.setDescription('Uniquely identifies the interface that contains the appropriate management information.')
wfAtmAlcCopType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("m68040", 1), ("m68060", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcCopType.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopType.setDescription('CoProcessor type.')
wfAtmAlcCopPktMemSize = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 4, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcCopPktMemSize.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopPktMemSize.setDescription('Size, in octets, of packet memory on the link module.')
wfAtmAlcCopCtlMemSize = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 4, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcCopCtlMemSize.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopCtlMemSize.setDescription('Size, in octets, of control memory on the link module.')
wfAtmAlcCopInsMemSize = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 4, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcCopInsMemSize.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopInsMemSize.setDescription('Size, in octets, of module memory on the link module.')
wfAtmAlcCopAlcClockSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 4, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcCopAlcClockSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopAlcClockSpeed.setDescription('Clock speed of the Adaptation Layer Controller (ALC) device.')
wfAtmAlcCopAlcVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 4, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcCopAlcVersion.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopAlcVersion.setDescription('Revision of the Adaptation Layer Controller (ALC) device.')
wfAtmAlcCopNtcVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 4, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcCopNtcVersion.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopNtcVersion.setDescription('Revision of the Network Termination Controller (NTC) device.')
wfAtmAlcCopAtcVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 4, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcCopAtcVersion.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopAtcVersion.setDescription('Revision of the Address Translation Controller (ATC) device.')
wfAtmAlcCopInfoTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 5), )
if mibBuilder.loadTexts: wfAtmAlcCopInfoTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopInfoTable.setDescription('This table contains general CoP information.')
wfAtmAlcCopInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 5, 1), ).setIndexNames((0, "Wellfleet-ATM-MIB", "wfAtmAlcCopInfoIndex"))
if mibBuilder.loadTexts: wfAtmAlcCopInfoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopInfoEntry.setDescription('Entry definition.')
wfAtmAlcCopInfoIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcCopInfoIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopInfoIndex.setDescription('Uniquely identifies the interface that contains the appropriate management information.')
wfAtmAlcCopState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("operational", 1), ("nonoperational", 2), ("init", 3), ("config", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcCopState.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopState.setDescription('State of the CoP driver.')
wfAtmAlcCopConfigState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4095))).clone(namedValues=NamedValues(("dma", 1), ("sar", 2), ("sartraf", 4), ("sarpcrq", 8), ("sarscrq", 16), ("frmgen", 32), ("frmrcv", 64), ("frmxmt", 128), ("frmoam", 256), ("frmstats", 512), ("frmcsi", 1024), ("frmdma", 2048), ("done", 4095)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcCopConfigState.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopConfigState.setDescription('State of the configuration process. The CoP driver performs a series of configuration events for all the major components on the link module. This state show where in the configuration process the CoP driver resides. Until done, no data will be allowed to be transmitted or received.')
wfAtmAlcCopTotalBufs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 5, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcCopTotalBufs.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopTotalBufs.setDescription('Total number of buffers available for use in packet memory.')
wfAtmAlcCopTotalXmtBufs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 5, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcCopTotalXmtBufs.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopTotalXmtBufs.setDescription('Number of buffers allocated for transmit.')
wfAtmAlcCopTotalRcvBufs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 5, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcCopTotalRcvBufs.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopTotalRcvBufs.setDescription('Number of buffers allocated for receive.')
wfAtmAlcCopDataPathTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 6), )
if mibBuilder.loadTexts: wfAtmAlcCopDataPathTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopDataPathTable.setDescription('This table contains CoP data path statistics such as the number of packets, buffers, and cells transmitted and received.')
wfAtmAlcCopDataPathEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 6, 1), ).setIndexNames((0, "Wellfleet-ATM-MIB", "wfAtmAlcCopDataPathIndex"))
if mibBuilder.loadTexts: wfAtmAlcCopDataPathEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopDataPathEntry.setDescription('Entry definition.')
wfAtmAlcCopDataPathIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcCopDataPathIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopDataPathIndex.setDescription('Uniquely identifies the interface that contains the appropriate management information.')
wfAtmAlcCopXmtPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 6, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcCopXmtPackets.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopXmtPackets.setDescription('Total number of packets transferred to the link module.')
wfAtmAlcCopXmtBuffers = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 6, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcCopXmtBuffers.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopXmtBuffers.setDescription('Total number of CoP buffers used for segmentation (transmit).')
wfAtmAlcCopXmtErrBuffers = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 6, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcCopXmtErrBuffers.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopXmtErrBuffers.setDescription('Total number of CoP transmit buffers returned in error by SAR device.')
wfAtmAlcCopXmtCells = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 6, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcCopXmtCells.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopXmtCells.setDescription('Total number of assigned ATM layer cells transmitted at the transceiver transmit interface (T-count). This attribute is a 64-bit counter.')
wfAtmAlcCopXmtUnassCells = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 6, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcCopXmtUnassCells.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopXmtUnassCells.setDescription('')
wfAtmAlcCopXmtIdleCells = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 6, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcCopXmtIdleCells.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopXmtIdleCells.setDescription('')
wfAtmAlcCopXmtUserCells = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 6, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcCopXmtUserCells.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopXmtUserCells.setDescription('')
wfAtmAlcCopXmtOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 6, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcCopXmtOctets.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopXmtOctets.setDescription('Count of octets transmitted (segmented) successfully.')
wfAtmAlcCopRcvPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 6, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcCopRcvPackets.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopRcvPackets.setDescription('Total number of packets completely reassembled.')
wfAtmAlcCopRcvClipPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 6, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcCopRcvClipPackets.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopRcvClipPackets.setDescription('Total number of packets dropped because no host buffers available to hold the incoming data.')
wfAtmAlcCopRcvBuffers = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 6, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcCopRcvBuffers.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopRcvBuffers.setDescription('Total number of CoP buffers used for reassembly.')
wfAtmAlcCopRcvErrBuffers = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 6, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcCopRcvErrBuffers.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopRcvErrBuffers.setDescription('Total number of CoP receive buffers returned in error by SAR device.')
wfAtmAlcCopRcvClipBuffers = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 6, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcCopRcvClipBuffers.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopRcvClipBuffers.setDescription('Total number of CoP buffers dropped because no receive buffer space were available to hold the incoming data.')
wfAtmAlcCopRcvSarDropBuffers = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 6, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcCopRcvSarDropBuffers.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopRcvSarDropBuffers.setDescription('Total number of CoP buffers dropped by the SAR device.')
wfAtmAlcCopRcvCells = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 6, 1, 16), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcCopRcvCells.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopRcvCells.setDescription('Total number of assigned ATM layer cells received at the transciever receive interface that have not been discarded (R-count). This attribute is a 64-bit counter.')
wfAtmAlcCopRcvDropCells = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 6, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcCopRcvDropCells.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopRcvDropCells.setDescription('Total number of cells received at the transceiver receive interface that have been discarded (D-count). The cells may have been discarded due to the following reasons: physical layer cells ATM layer cell with uncorrectable HEC error ATM layer cell which has been discarded via the discard mask protocol error')
wfAtmAlcCopRcvUnassCells = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 6, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcCopRcvUnassCells.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopRcvUnassCells.setDescription('')
wfAtmAlcCopRcvIdleCells = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 6, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcCopRcvIdleCells.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopRcvIdleCells.setDescription('')
wfAtmAlcCopRcvUserCells = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 6, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcCopRcvUserCells.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopRcvUserCells.setDescription('')
wfAtmAlcCopRcvSarDropCells = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 6, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcCopRcvSarDropCells.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopRcvSarDropCells.setDescription('')
wfAtmAlcCopRcvOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 6, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcCopRcvOctets.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopRcvOctets.setDescription('Count of octets received (reassembled) successfully.')
wfAtmAlcCopXmtOamCells = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 6, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcCopXmtOamCells.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopXmtOamCells.setDescription('Count of OAM cells transmitted successfully.')
wfAtmAlcCopRcvOamCells = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 6, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcCopRcvOamCells.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopRcvOamCells.setDescription('Count of OAM cells received successfully.')
wfAtmAlcCopRcvOamCrcErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 6, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcCopRcvOamCrcErrs.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopRcvOamCrcErrs.setDescription('Count of OAM cells received with CRC10 error.')
wfAtmAlcCopErrorTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 7), )
if mibBuilder.loadTexts: wfAtmAlcCopErrorTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopErrorTable.setDescription('This table contains CoP error statistics.')
wfAtmAlcCopErrorEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 7, 1), ).setIndexNames((0, "Wellfleet-ATM-MIB", "wfAtmAlcCopErrorIndex"))
if mibBuilder.loadTexts: wfAtmAlcCopErrorEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopErrorEntry.setDescription('Entry definition.')
wfAtmAlcCopErrorIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 7, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcCopErrorIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopErrorIndex.setDescription('Uniquely identifies the interface that contains the appropriate management information.')
wfAtmAlcCopHecDetects = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 7, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcCopHecDetects.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopHecDetects.setDescription('')
wfAtmAlcCopHecCorrects = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 7, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcCopHecCorrects.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopHecCorrects.setDescription('')
wfAtmAlcCopB2Febes = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 7, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcCopB2Febes.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopB2Febes.setDescription('')
wfAtmAlcCopB3Febes = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 7, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcCopB3Febes.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopB3Febes.setDescription('')
wfAtmAlcCopF1Febes = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 7, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcCopF1Febes.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopF1Febes.setDescription('')
wfAtmAlcCopF3Febes = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 7, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcCopF3Febes.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopF3Febes.setDescription('')
wfAtmAlcCopG1Febes = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 7, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcCopG1Febes.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopG1Febes.setDescription('')
wfAtmAlcCopDropIntqEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 7, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcCopDropIntqEvents.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopDropIntqEvents.setDescription('')
wfAtmAlcCopDropLogqEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 7, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcCopDropLogqEvents.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopDropLogqEvents.setDescription('')
wfAtmAlcCopDmaFifoOverruns = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 7, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcCopDmaFifoOverruns.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopDmaFifoOverruns.setDescription('')
wfAtmAlcCopDmaFifoUnderruns = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 7, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcCopDmaFifoUnderruns.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopDmaFifoUnderruns.setDescription('')
wfAtmAlcCopLossSignals = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 7, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcCopLossSignals.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopLossSignals.setDescription('Number of occurences of when the framer device detected loss of signal (i.e., no signal detect/no light).')
wfAtmAlcCopLossFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 7, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcCopLossFrames.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopLossFrames.setDescription('')
wfAtmAlcCopLossPointers = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 7, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcCopLossPointers.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopLossPointers.setDescription('')
wfAtmAlcCopOutCellDelins = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 7, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcCopOutCellDelins.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopOutCellDelins.setDescription('Number of occurences of when the framer device went out of cell delineation.')
wfAtmAlcCopInCellDelins = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 7, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcCopInCellDelins.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopInCellDelins.setDescription('Number of occurences of when the framer device went into cell delineation.')
wfAtmAlcCopBufOverflows = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 7, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcCopBufOverflows.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopBufOverflows.setDescription('')
wfAtmAlcCopXmtQueueFulls = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 7, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcCopXmtQueueFulls.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopXmtQueueFulls.setDescription('')
wfAtmAlcCopXmtAtes = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 7, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcCopXmtAtes.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopXmtAtes.setDescription('')
wfAtmAlcCopRcvQueueEmptys = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 7, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcCopRcvQueueEmptys.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopRcvQueueEmptys.setDescription('')
wfAtmAlcCopRcvWriteFails = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 7, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcCopRcvWriteFails.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopRcvWriteFails.setDescription('')
wfAtmAlcCopRcvQueueFulls = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 7, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcCopRcvQueueFulls.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopRcvQueueFulls.setDescription('')
wfAtmAlcCopRcvAtes = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 7, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcCopRcvAtes.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcCopRcvAtes.setDescription('')
wfAtmAlcSarConfTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 8), )
if mibBuilder.loadTexts: wfAtmAlcSarConfTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcSarConfTable.setDescription('This table contains configuration information for the ATM/ALC SAR device.')
wfAtmAlcSarConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 8, 1), ).setIndexNames((0, "Wellfleet-ATM-MIB", "wfAtmAlcSarConfIndex"))
if mibBuilder.loadTexts: wfAtmAlcSarConfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcSarConfEntry.setDescription('Entry definition.')
wfAtmAlcSarConfDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 8, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("create", 1), ("delete", 2))).clone('create')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcSarConfDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcSarConfDelete.setDescription('Create/delete MIB instance parameter.')
wfAtmAlcSarConfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 8, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcSarConfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcSarConfIndex.setDescription('Uniquely identifies the interface that contains the appropriate management information.')
wfAtmAlcSarDmaBurstLength = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 8, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 256)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcSarDmaBurstLength.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcSarDmaBurstLength.setDescription('Limits the max number of SAR DMA access cycles in a single block.')
wfAtmAlcSarDmaModeBw = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 8, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("bit32", 1), ("bit64", 2))).clone('bit32')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcSarDmaModeBw.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcSarDmaModeBw.setDescription('SAR memory interface width.')
wfAtmAlcSarDmaModeBmode = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 8, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("intel", 1), ("motorola", 2))).clone('intel')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcSarDmaModeBmode.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcSarDmaModeBmode.setDescription('SAR memory control signal mode.')
wfAtmAlcSarDmaModeOrder = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 8, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("bigendian", 1), ("littleendian", 2))).clone('bigendian')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcSarDmaModeOrder.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcSarDmaModeOrder.setDescription('SAR memory byte ordering convention.')
wfAtmAlcSarDmaModeMmode = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 8, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("system", 1), ("ram", 2))).clone('ram')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcSarDmaModeMmode.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcSarDmaModeMmode.setDescription('SAR memory mode.')
wfAtmAlcSarDmaModeCmode = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 8, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("standard", 1), ("fast", 2))).clone('fast')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcSarDmaModeCmode.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcSarDmaModeCmode.setDescription('SAR memory cycle time.')
wfAtmAlcSarDmaModeSync = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 8, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("async", 1), ("sync", 2))).clone('async')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcSarDmaModeSync.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcSarDmaModeSync.setDescription('READY/DTACK signal treatment.')
wfAtmAlcSarControlRif = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 8, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("one", 1))).clone('one')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcSarControlRif.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcSarControlRif.setDescription('Receive buffer ready interrupt frequency.')
wfAtmAlcSarControlLoop = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 8, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcSarControlLoop.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcSarControlLoop.setDescription('Loop transmit cell stream into receive cell stream interface.')
wfAtmAlcSarModeRtmr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 8, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notag", 1), ("oneoctettag", 2), ("twooctettag", 3), ("threeoctettag", 4))).clone('notag')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcSarModeRtmr.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcSarModeRtmr.setDescription('Receive routing tag length.')
wfAtmAlcSarModeRid = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 8, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("vci", 1), ("mid", 2))).clone('vci')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcSarModeRid.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcSarModeRid.setDescription('Reassembly ID select.')
wfAtmAlcSarModeAal = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 8, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("set", 1), ("clear", 2))).clone('clear')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcSarModeAal.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcSarModeAal.setDescription('Default receive status/descriptor type field setting.')
wfAtmAlcSarModeDmask = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 8, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcSarModeDmask.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcSarModeDmask.setDescription('Disable transmit queue masking.')
wfAtmAlcSarModeDchain = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 8, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcSarModeDchain.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcSarModeDchain.setDescription('Transmit cell stream daisy chain enable.')
wfAtmAlcSarModeSmode = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 8, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcSarModeSmode.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcSarModeSmode.setDescription('Receive streaming mode enable.')
wfAtmAlcSarModeBchain = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 8, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcSarModeBchain.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcSarModeBchain.setDescription('Receive buffer chaining mode enable.')
wfAtmAlcSarModeHec = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 8, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcSarModeHec.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcSarModeHec.setDescription('Header error check operation.')
wfAtmAlcSarModeVpf = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 8, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcSarModeVpf.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcSarModeVpf.setDescription('Virtual path filter enable.')
wfAtmAlcSarModeBas = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 8, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcSarModeBas.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcSarModeBas.setDescription('Buffer ageing support.')
wfAtmAlcSarModeAm = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 8, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("trickle", 1), ("burst", 2))).clone('trickle')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcSarModeAm.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcSarModeAm.setDescription('Traffic rate averaging method.')
wfAtmAlcSarModeTrtl = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 8, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notag", 1), ("oneoctettag", 2), ("twooctettag", 3), ("threeoctettag", 4))).clone('notag')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcSarModeTrtl.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcSarModeTrtl.setDescription('Transmit routing tag length.')
wfAtmAlcSarTimeoutCtrPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 8, 1, 24), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcSarTimeoutCtrPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcSarTimeoutCtrPeriod.setDescription('Number of DCCK clock periods required to increment the receive buffer ageing time base counter.')
wfAtmAlcSarTimeoutCtrInt = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 8, 1, 25), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcSarTimeoutCtrInt.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcSarTimeoutCtrInt.setDescription('Maximum time period allowed between the arrival of an incoming packet and the host servicing the receive buffer.')
wfAtmAlcSarMaxReceivePktLen = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 8, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4608))).clone(namedValues=NamedValues(("default", 4608))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcSarMaxReceivePktLen.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcSarMaxReceivePktLen.setDescription('Maximum number of bytes of incoming packet data that can be received.')
wfAtmAlcSarTrafficMgtTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 9), )
if mibBuilder.loadTexts: wfAtmAlcSarTrafficMgtTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcSarTrafficMgtTable.setDescription('This table contains information relating to the traffic management controller in the ATM/ALC SAR device.')
wfAtmAlcSarTrafficMgtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 9, 1), ).setIndexNames((0, "Wellfleet-ATM-MIB", "wfAtmAlcSarTrafficMgtIndex"))
if mibBuilder.loadTexts: wfAtmAlcSarTrafficMgtEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcSarTrafficMgtEntry.setDescription('Entry definition.')
wfAtmAlcSarTrafficMgtDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 9, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("create", 1), ("delete", 2))).clone('create')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcSarTrafficMgtDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcSarTrafficMgtDelete.setDescription('Create/delete MIB instance parameter.')
wfAtmAlcSarTrafficMgtIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 9, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcSarTrafficMgtIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcSarTrafficMgtIndex.setDescription('Uniquely identifies the interface that contains the appropriate management information.')
wfAtmAlcSarPeakCellRateEna = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 9, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcSarPeakCellRateEna.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcSarPeakCellRateEna.setDescription('Enable counter for SAR peak transmission rate.')
wfAtmAlcSarAvgCellRateEna = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 9, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcSarAvgCellRateEna.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcSarAvgCellRateEna.setDescription('Enable counter for SAR average trasnmission rate.')
wfAtmAlcSarPeakCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 9, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(365566))).clone(namedValues=NamedValues(("default", 365566))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcSarPeakCellRate.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcSarPeakCellRate.setDescription('Desired value for SAR total peak cell rate (cells/second).')
wfAtmAlcSarAvgCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 9, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(365566))).clone(namedValues=NamedValues(("default", 365566))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcSarAvgCellRate.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcSarAvgCellRate.setDescription('Desired value for SAR total average cell rate (cells/second).')
wfAtmAlcSarMaxBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 9, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(40))).clone(namedValues=NamedValues(("default", 40))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcSarMaxBurstSize.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcSarMaxBurstSize.setDescription('Desired value for SAR maximum burst size (cells).')
wfAtmAlcSarRateQueueTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 10), )
if mibBuilder.loadTexts: wfAtmAlcSarRateQueueTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcSarRateQueueTable.setDescription('This table contains information relating to the peak rate queues provided by the ATM/ALC SAR device.')
wfAtmAlcSarRateQueueEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 10, 1), ).setIndexNames((0, "Wellfleet-ATM-MIB", "wfAtmAlcSarRateQueueIndex"), (0, "Wellfleet-ATM-MIB", "wfAtmAlcSarRateQueueNumber"))
if mibBuilder.loadTexts: wfAtmAlcSarRateQueueEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcSarRateQueueEntry.setDescription('Entry definition.')
wfAtmAlcSarRateQueueIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 10, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcSarRateQueueIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcSarRateQueueIndex.setDescription('Uniquely identifies the interface that contains the appropriate management information.')
wfAtmAlcSarRateQueueNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcSarRateQueueNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcSarRateQueueNumber.setDescription('Identifies a particular instance of a rate queue.')
wfAtmAlcSarRateQueueState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcSarRateQueueState.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcSarRateQueueState.setDescription('Rate queue state parameter: enabled or disabled.')
wfAtmAlcSarRateQueuePcr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 10, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcSarRateQueuePcr.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcSarRateQueuePcr.setDescription('Peak Cell Rate (PCR) of rate queue defined in bits per second.')
wfAtmAlcSarRateQueueVcs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 10, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcSarRateQueueVcs.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcSarRateQueueVcs.setDescription('Number of Virtual Connections (VCs) configured for this queue.')
wfAtmAlcSarRateQueueDef = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("implicit", 1), ("explicit", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcSarRateQueueDef.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcSarRateQueueDef.setDescription('Indicates the method by which this queue was defined: IMPLICIT means that the driver defined the queue when a VC was added; EXPLICIT means that the queue was explicitly defined by an entity other than the driver.')
wfAtmAlcFrmConfTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11), )
if mibBuilder.loadTexts: wfAtmAlcFrmConfTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmConfTable.setDescription('This table contains configuration information for the ATM/ALC FRAMER device.')
wfAtmAlcFrmConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1), ).setIndexNames((0, "Wellfleet-ATM-MIB", "wfAtmAlcFrmConfIndex"))
if mibBuilder.loadTexts: wfAtmAlcFrmConfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmConfEntry.setDescription('Entry definition.')
wfAtmAlcFrmConfDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("create", 1), ("delete", 2))).clone('create')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmConfDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmConfDelete.setDescription('Create/delete MIB instance parameter.')
wfAtmAlcFrmConfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmAlcFrmConfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmConfIndex.setDescription('Uniquely identifies the interface that contains the appropriate management information.')
wfAtmAlcFrmGenEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmGenEnable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmGenEnable.setDescription('Rx/Tx framer enable.')
wfAtmAlcFrmGenFramingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("cell", 1), ("sdh", 2), ("sonet", 3), ("ds3", 4), ("e3", 5), ("sonetsts1", 6), ("ds3nonplcp", 7))).clone('sonet')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmGenFramingMode.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmGenFramingMode.setDescription('Framing (transceiver) mode.')
wfAtmAlcFrmGenScramblerEna = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmGenScramblerEna.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmGenScramblerEna.setDescription('1+x(6)+x(7) frame scrambler. Only applies to framing standards such as SONET/SDH.')
wfAtmAlcFrmGenDescrambleEna = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmGenDescrambleEna.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmGenDescrambleEna.setDescription('1+x(6)+x(7) frame descrambler. Only applies to framing standards such as SONET/SDH.')
wfAtmAlcFrmGenLoopback = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmGenLoopback.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmGenLoopback.setDescription('Transmit to receive framer loopback.')
wfAtmAlcFrmGenSyncFoundCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15)).clone(7)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmGenSyncFoundCnt.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmGenSyncFoundCnt.setDescription('Frame sync found count.')
wfAtmAlcFrmGenSyncLostCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15)).clone(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmGenSyncLostCnt.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmGenSyncLostCnt.setDescription('Frame sync lost count.')
wfAtmAlcFrmRcvCellEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmRcvCellEnable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmRcvCellEnable.setDescription('Cell receiver enable.')
wfAtmAlcFrmRcvOamCrcCheck = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmRcvOamCrcCheck.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmRcvOamCrcCheck.setDescription('OAM cell CRC check.')
wfAtmAlcFrmRcvOamCrcGen = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmRcvOamCrcGen.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmRcvOamCrcGen.setDescription('OAM cell CRC generate.')
wfAtmAlcFrmRcvCellInsPrio = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("user", 1), ("insert", 2))).clone('user')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmRcvCellInsPrio.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmRcvCellInsPrio.setDescription('Cell insert priority.')
wfAtmAlcFrmRcvInsertPcr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4))).clone(namedValues=NamedValues(("default", 4))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmRcvInsertPcr.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmRcvInsertPcr.setDescription('Peak cell insertion rate.')
wfAtmAlcFrmRcvGfcIgnore = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("vpi12", 1), ("vpi8", 2))).clone('vpi8')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmRcvGfcIgnore.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmRcvGfcIgnore.setDescription('GFC field ignore.')
wfAtmAlcFrmRcvDescrambleCtl = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmRcvDescrambleCtl.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmRcvDescrambleCtl.setDescription('Descramble control. Only applies to framing standards such as SONET/SDH.')
wfAtmAlcFrmRcvHecRcvMask = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmRcvHecRcvMask.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmRcvHecRcvMask.setDescription('HEC receive mask.')
wfAtmAlcFrmRcvErrCorrectEna = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmRcvErrCorrectEna.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmRcvErrCorrectEna.setDescription('Error correction enable.')
wfAtmAlcFrmRcvByteAlignment = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("nonalign", 1), ("align", 2))).clone('nonalign')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmRcvByteAlignment.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmRcvByteAlignment.setDescription('Byte alignment.')
wfAtmAlcFrmRcvCellSyncFound = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15)).clone(7)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmRcvCellSyncFound.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmRcvCellSyncFound.setDescription('Cell sync found count.')
wfAtmAlcFrmRcvCellSyncLost = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15)).clone(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmRcvCellSyncLost.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmRcvCellSyncLost.setDescription('Cell sync lost count.')
wfAtmAlcFrmRcvExtUserCell = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("disabled", 1), ("defined", 2), ("undefined", 3), ("invalid", 4))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmRcvExtUserCell.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmRcvExtUserCell.setDescription('Extract user defined cell.')
wfAtmAlcFrmRcvExtMetaSig = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmRcvExtMetaSig.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmRcvExtMetaSig.setDescription('Extract meta signalling.')
wfAtmAlcFrmRcvExtBcastSig = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmRcvExtBcastSig.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmRcvExtBcastSig.setDescription('Extract broadcast signalling.')
wfAtmAlcFrmRcvExtPointSig = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmRcvExtPointSig.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmRcvExtPointSig.setDescription('Extract point-point signalling.')
wfAtmAlcFrmRcvExtIlmiSig = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmRcvExtIlmiSig.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmRcvExtIlmiSig.setDescription('Extract ILMI signalling.')
wfAtmAlcFrmRcvExtF4F5PrfMan = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmRcvExtF4F5PrfMan.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmRcvExtF4F5PrfMan.setDescription('Extract F4/F5 performance man.')
wfAtmAlcFrmRcvExtF1F3PlOam = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmRcvExtF1F3PlOam.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmRcvExtF1F3PlOam.setDescription('Extract F1/F3 PL-OAM.')
wfAtmAlcFrmRcvExtF4Segment = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmRcvExtF4Segment.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmRcvExtF4Segment.setDescription('Extract F4 segment (FM and AD).')
wfAtmAlcFrmRcvExtF4EndEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmRcvExtF4EndEnd.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmRcvExtF4EndEnd.setDescription('Extract F4 end-end (FM and AD).')
wfAtmAlcFrmRcvExtF5Segment = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmRcvExtF5Segment.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmRcvExtF5Segment.setDescription('Extract F5 segment (FM and AD).')
wfAtmAlcFrmRcvExtF5EndEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmRcvExtF5EndEnd.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmRcvExtF5EndEnd.setDescription('Extract F5 end-end (FM and AD).')
wfAtmAlcFrmRcvDisUserCell = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("disabled", 1), ("defined", 2), ("undefined", 3), ("invalid", 4))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmRcvDisUserCell.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmRcvDisUserCell.setDescription('Discard user defined cell.')
wfAtmAlcFrmRcvDisMetaSig = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmRcvDisMetaSig.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmRcvDisMetaSig.setDescription('Discard meta signalling.')
wfAtmAlcFrmRcvDisBcastSig = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmRcvDisBcastSig.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmRcvDisBcastSig.setDescription('Discard broadcast signalling.')
wfAtmAlcFrmRcvDisPointSig = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmRcvDisPointSig.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmRcvDisPointSig.setDescription('Discard point-point signalling.')
wfAtmAlcFrmRcvDisIlmiSig = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 37), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmRcvDisIlmiSig.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmRcvDisIlmiSig.setDescription('Discard ILMI signalling.')
wfAtmAlcFrmRcvDisUnassCell = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 38), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmRcvDisUnassCell.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmRcvDisUnassCell.setDescription('Discard unassigned cell.')
wfAtmAlcFrmRcvDisF4Segment = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 39), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmRcvDisF4Segment.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmRcvDisF4Segment.setDescription('Discard F4 segment (FM and AD).')
wfAtmAlcFrmRcvDisF4EndEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmRcvDisF4EndEnd.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmRcvDisF4EndEnd.setDescription('Discard F4 end-end (FM and AD).')
wfAtmAlcFrmRcvDisF5Segment = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 41), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmRcvDisF5Segment.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmRcvDisF5Segment.setDescription('Discard F5 segment (FM and AD).')
wfAtmAlcFrmRcvDisF5EndEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 42), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmRcvDisF5EndEnd.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmRcvDisF5EndEnd.setDescription('Discard F5 end-end (FM and AD).')
wfAtmAlcFrmXmtCellEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 43), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmXmtCellEnable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmXmtCellEnable.setDescription('Cell transmitter enable.')
wfAtmAlcFrmXmtOamCrcCheck = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 44), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmXmtOamCrcCheck.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmXmtOamCrcCheck.setDescription('OAM cell CRC check.')
wfAtmAlcFrmXmtOamCrcGen = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 45), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmXmtOamCrcGen.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmXmtOamCrcGen.setDescription('OAM cell CRC generate.')
wfAtmAlcFrmXmtCellInsPrio = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 46), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("user", 1), ("insert", 2))).clone('user')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmXmtCellInsPrio.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmXmtCellInsPrio.setDescription('Cell insert priority.')
wfAtmAlcFrmXmtInsertPcr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 47), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4))).clone(namedValues=NamedValues(("default", 4))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmXmtInsertPcr.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmXmtInsertPcr.setDescription('Peak cell insertion rate.')
wfAtmAlcFrmXmtGfcIgnore = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 48), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("vpi12", 1), ("vpi8", 2))).clone('vpi8')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmXmtGfcIgnore.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmXmtGfcIgnore.setDescription('GFC field ignore.')
wfAtmAlcFrmXmtCellDecouple = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 49), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("idle", 1), ("unassign", 2))).clone('unassign')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmXmtCellDecouple.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmXmtCellDecouple.setDescription('Cell rate decoupling.')
wfAtmAlcFrmXmtScrambleCtl = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 50), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmXmtScrambleCtl.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmXmtScrambleCtl.setDescription('Scramble control. Only applies to framing standards such as SONET/SDH.')
wfAtmAlcFrmXmtHecXmtMask = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 51), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmXmtHecXmtMask.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmXmtHecXmtMask.setDescription('HEC transmit mask.')
wfAtmAlcFrmXmtExtUserCell = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 52), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("disabled", 1), ("defined", 2), ("undefined", 3), ("invalid", 4))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmXmtExtUserCell.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmXmtExtUserCell.setDescription('Extract user defined cell.')
wfAtmAlcFrmXmtExtMetaSig = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 53), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmXmtExtMetaSig.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmXmtExtMetaSig.setDescription('Extract meta signalling.')
wfAtmAlcFrmXmtExtBcastSig = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 54), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmXmtExtBcastSig.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmXmtExtBcastSig.setDescription('Extract broadcast signalling.')
wfAtmAlcFrmXmtExtPointSig = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 55), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmXmtExtPointSig.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmXmtExtPointSig.setDescription('Extract point-point signalling.')
wfAtmAlcFrmXmtExtIlmiSig = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 56), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmXmtExtIlmiSig.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmXmtExtIlmiSig.setDescription('Extract ILMI signalling.')
wfAtmAlcFrmXmtExtF4F5PrfMan = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 57), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmXmtExtF4F5PrfMan.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmXmtExtF4F5PrfMan.setDescription('Extract F4/F5 performance man.')
wfAtmAlcFrmXmtExtF4Segment = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 58), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmXmtExtF4Segment.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmXmtExtF4Segment.setDescription('Extract F4 segment (FM and AD).')
wfAtmAlcFrmXmtExtF4EndEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 59), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmXmtExtF4EndEnd.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmXmtExtF4EndEnd.setDescription('Extract F4 end-end (FM and AD).')
wfAtmAlcFrmXmtExtF5Segment = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 60), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmXmtExtF5Segment.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmXmtExtF5Segment.setDescription('Extract F5 segment (FM and AD).')
wfAtmAlcFrmXmtExtF5EndEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 61), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmXmtExtF5EndEnd.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmXmtExtF5EndEnd.setDescription('Extract F5 end-end (FM and AD).')
wfAtmAlcFrmXmtDisUserCell = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 62), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("disabled", 1), ("defined", 2), ("undefined", 3), ("invalid", 4))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmXmtDisUserCell.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmXmtDisUserCell.setDescription('Discard user defined cell.')
wfAtmAlcFrmXmtDisMetaSig = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 63), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmXmtDisMetaSig.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmXmtDisMetaSig.setDescription('Discard meta signalling.')
wfAtmAlcFrmXmtDisBcastSig = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 64), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmXmtDisBcastSig.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmXmtDisBcastSig.setDescription('Discard broadcast signalling.')
wfAtmAlcFrmXmtDisPointSig = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 65), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmXmtDisPointSig.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmXmtDisPointSig.setDescription('Discard point-point signalling.')
wfAtmAlcFrmXmtDisIlmiSig = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 66), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmXmtDisIlmiSig.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmXmtDisIlmiSig.setDescription('Discard ILMI signalling.')
wfAtmAlcFrmXmtDisUnassCell = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 67), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmXmtDisUnassCell.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmXmtDisUnassCell.setDescription('Discard unassigned cell.')
wfAtmAlcFrmXmtDisF4Segment = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 68), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmXmtDisF4Segment.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmXmtDisF4Segment.setDescription('Discard F4 segment (FM and AD).')
wfAtmAlcFrmXmtDisF4EndEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 69), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmXmtDisF4EndEnd.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmXmtDisF4EndEnd.setDescription('Discard F4 end-end (FM and AD).')
wfAtmAlcFrmXmtDisF5Segment = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 70), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmXmtDisF5Segment.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmXmtDisF5Segment.setDescription('Discard F5 segment (FM and AD).')
wfAtmAlcFrmXmtDisF5EndEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 71), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmXmtDisF5EndEnd.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmXmtDisF5EndEnd.setDescription('Discard F5 end-end (FM and AD).')
wfAtmAlcFrmOamEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 72), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmOamEnable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmOamEnable.setDescription('OAM controller enable.')
wfAtmAlcFrmOamInvertBip = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 73), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("invert", 2))).clone('normal')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmOamInvertBip.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmOamInvertBip.setDescription('Invert BIP.')
wfAtmAlcFrmOamTxPathFerf = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 74), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("clear", 1), ("auto", 2), ("set", 3))).clone('clear')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmOamTxPathFerf.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmOamTxPathFerf.setDescription('Tx path FERF.')
wfAtmAlcFrmOamTxSectionFerf = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 75), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("clear", 1), ("auto", 2), ("set", 3))).clone('clear')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmOamTxSectionFerf.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmOamTxSectionFerf.setDescription('Tx section FERF.')
wfAtmAlcFrmOamTxPathAis = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 76), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clear", 1), ("set", 2))).clone('clear')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmOamTxPathAis.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmOamTxPathAis.setDescription('Tx path AIS.')
wfAtmAlcFrmOamTxSectionAis = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 77), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clear", 1), ("set", 2))).clone('clear')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmOamTxSectionAis.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmOamTxSectionAis.setDescription('Tx section AIS.')
wfAtmAlcFrmOamTxPathFebe = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 78), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmOamTxPathFebe.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmOamTxPathFebe.setDescription('Tx path FEBE (B3).')
wfAtmAlcFrmOamTxSectionFebe = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 79), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmOamTxSectionFebe.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmOamTxSectionFebe.setDescription('Tx section FEBE (B3).')
wfAtmAlcFrmStatsSwEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 80), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmStatsSwEnable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmStatsSwEnable.setDescription('Switch statistics handler.')
wfAtmAlcFrmStatsMode = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 81), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("disabled", 1), ("header", 2), ("header16", 3), ("header32", 4))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmStatsMode.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmStatsMode.setDescription('Statistics controller mode.')
wfAtmAlcFrmStatsReceive = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 82), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmStatsReceive.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmStatsReceive.setDescription('Receive user statistics.')
wfAtmAlcFrmStatsTransmit = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 83), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmStatsTransmit.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmStatsTransmit.setDescription('Transmit statistics.')
wfAtmAlcFrmStatsMask = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 84), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("disabled", 1), ("hmask", 2), ("invalid", 3), ("lmask", 4))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmStatsMask.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmStatsMask.setDescription('VP/VC filter mask.')
wfAtmAlcFrmStatsTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 85), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmStatsTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmStatsTimeout.setDescription('Statistics DMA transfer timeout.')
wfAtmAlcFrmStatsTimerEna = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 86), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmStatsTimerEna.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmStatsTimerEna.setDescription('Timer enable (DMA).')
wfAtmAlcFrmStatsOflowEna = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 87), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmStatsOflowEna.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmStatsOflowEna.setDescription('Overflow enable (DMA).')
wfAtmAlcFrmStatsForceDma = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 88), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("dma", 2))).clone('other')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmStatsForceDma.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmStatsForceDma.setDescription('Force DMA transfer.')
wfAtmAlcFrmCsiEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 89), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmCsiEnable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmCsiEnable.setDescription('Cell stream enable.')
wfAtmAlcFrmCsiLoop = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 90), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmCsiLoop.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmCsiLoop.setDescription('CSI rx/tx loopback.')
wfAtmAlcFrmCsiRcvAtcEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 91), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmCsiRcvAtcEnable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmCsiRcvAtcEnable.setDescription('Receive ATC enable.')
wfAtmAlcFrmCsiRcvAte = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 92), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("discard", 1), ("forward", 2))).clone('discard')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmCsiRcvAte.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmCsiRcvAte.setDescription('Address translation error (receive).')
wfAtmAlcFrmCsiRcvClpBitOpt = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 93), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("header", 1), ("xlat", 2), ("force0", 3), ("force1", 4))).clone('header')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmCsiRcvClpBitOpt.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmCsiRcvClpBitOpt.setDescription('CLP bit option (receive).')
wfAtmAlcFrmCsiRcvCongBitOpt = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 94), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("header", 1), ("xlat", 2), ("force0", 3), ("force1", 4))).clone('header')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmCsiRcvCongBitOpt.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmCsiRcvCongBitOpt.setDescription('PLT congestion bit option (receive).')
wfAtmAlcFrmCsiRoutingTag = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 95), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("tag0", 1), ("tag1", 2), ("tag2", 3), ("tag3", 4))).clone('tag0')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmCsiRoutingTag.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmCsiRoutingTag.setDescription('Routing tag byte size.')
wfAtmAlcFrmCsiXmtAtcEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 96), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmCsiXmtAtcEnable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmCsiXmtAtcEnable.setDescription('Transmit ATC enable.')
wfAtmAlcFrmCsiXmtAte = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 97), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("discard", 1), ("forward", 2))).clone('discard')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmCsiXmtAte.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmCsiXmtAte.setDescription('Address translation error (transmit).')
wfAtmAlcFrmCsiXmtClpBitOpt = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 98), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("header", 1), ("xlat", 2), ("force0", 3), ("force1", 4))).clone('header')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmCsiXmtClpBitOpt.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmCsiXmtClpBitOpt.setDescription('CLP bit option (transmit).')
wfAtmAlcFrmCsiXmtCongBitOpt = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 99), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("header", 1), ("xlat", 2), ("force0", 3), ("force1", 4))).clone('header')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmCsiXmtCongBitOpt.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmCsiXmtCongBitOpt.setDescription('PLT congestion bit option (transmit).')
wfAtmAlcFrmCsiOmitHec = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 100), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("cell53byte", 1), ("cell52byte", 2))).clone('cell53byte')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmCsiOmitHec.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmCsiOmitHec.setDescription('Omit HEC byte on transmit.')
wfAtmAlcFrmCsiRcvHecEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 101), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmCsiRcvHecEnable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmCsiRcvHecEnable.setDescription('HEC generator enable.')
wfAtmAlcFrmCsiRcvHecMask = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 102), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmCsiRcvHecMask.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmCsiRcvHecMask.setDescription('ASCI rx path HEC mask.')
wfAtmAlcFrmDmaChan0Enable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 103), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmDmaChan0Enable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmDmaChan0Enable.setDescription('DMA channel 0 enable.')
wfAtmAlcFrmDmaChan1Enable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 104), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmDmaChan1Enable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmDmaChan1Enable.setDescription('DMA channel 1 enable.')
wfAtmAlcFrmDmaChan2Enable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 105), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmDmaChan2Enable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmDmaChan2Enable.setDescription('DMA channel 2 enable.')
wfAtmAlcFrmDmaChan3Enable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 106), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmDmaChan3Enable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmDmaChan3Enable.setDescription('DMA channel 3 enable.')
wfAtmAlcFrmDmaChan4Enable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 107), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmDmaChan4Enable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmDmaChan4Enable.setDescription('DMA channel 4 enable.')
wfAtmAlcFrmDmaChan5Enable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 108), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmDmaChan5Enable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmDmaChan5Enable.setDescription('DMA channel 5 enable.')
wfAtmAlcFrmDmaEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 109), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmDmaEnable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmDmaEnable.setDescription('DMA controller enable.')
wfAtmAlcFrmDmaStop = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 110), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notstopped", 1), ("stopped", 2))).clone('notstopped')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmDmaStop.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmDmaStop.setDescription('DMA stop.')
wfAtmAlcFrmDmaPrioritySel = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 111), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("chan0prio", 1), ("chan5prio", 2))).clone('chan0prio')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmDmaPrioritySel.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmDmaPrioritySel.setDescription('Priority select.')
wfAtmAlcFrmDmaFastXferMode = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 2, 11, 1, 112), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("descdma", 1), ("fastdma", 2))).clone('descdma')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmAlcFrmDmaFastXferMode.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmAlcFrmDmaFastXferMode.setDescription('Fast transfer mode.')
wfAtmizerCfgTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 1), )
if mibBuilder.loadTexts: wfAtmizerCfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerCfgTable.setDescription('ARE ATMizer Configuration Record')
wfAtmizerCfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 1, 1), ).setIndexNames((0, "Wellfleet-ATM-MIB", "wfAtmizerCfgSlot"))
if mibBuilder.loadTexts: wfAtmizerCfgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerCfgEntry.setDescription('Information about a Transmit/Receive pair of ATMizers')
wfAtmizerCfgSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 14))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerCfgSlot.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerCfgSlot.setDescription('Slot number -- instance id.')
wfAtmizerCfgMaxVcl = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerCfgMaxVcl.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerCfgMaxVcl.setDescription('The maximum size of a Virtual Channel Links (VCLs) which can be supported by the ATMizers.')
wfAtmizerCfgCurrVcl = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerCfgCurrVcl.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerCfgCurrVcl.setDescription('The number of Virtual Channel Links (VCLs) currently active on the slot.')
wfAtmizerCfgRxQueueLenMax = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(150))).clone(namedValues=NamedValues(("default", 150))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmizerCfgRxQueueLenMax.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerCfgRxQueueLenMax.setDescription('The maximum size of a receive buffer list which will be delivered by the RX ATMizer to the driver.')
wfAtmizerCfgRxQueueTmoMax = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(100))).clone(namedValues=NamedValues(("default", 100))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmizerCfgRxQueueTmoMax.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerCfgRxQueueTmoMax.setDescription('The maximum amount of idle time (in microseconds) the RX ATMizer will wait before delivering its queue of receive buffers to the driver.')
wfAtmizerCfgRxBuffersMax = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 1, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmizerCfgRxBuffersMax.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerCfgRxBuffersMax.setDescription('The maximum number of receive buffers which the RX ATMizer can own before encountering a lack of resources. This is a configurable option and does not indicate the true value.')
wfAtmizerCfgRxPagesMax = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 1, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmizerCfgRxPagesMax.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerCfgRxPagesMax.setDescription('The maximum number of additional physical pages which the RX ATMizer can own before encountering a lack of resources. This is a configurable option and does not indicate the true value.')
wfAtmizerCfgTxBuffersMax = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 1, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmizerCfgTxBuffersMax.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerCfgTxBuffersMax.setDescription('The maximum number of transmit buffers which the TX ATMizer can own before it begins clipping. This is a configurable option and does not indicate the true value.')
wfAtmizerCfgTxPagesMax = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 1, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmizerCfgTxPagesMax.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerCfgTxPagesMax.setDescription('The maximum number of additional physical pages which the TX ATMizer can own before encountering a lack of resources. This is a configurable option and does not indicate the true value.')
wfAtmizerCfgTxPercentRsrcs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(50))).clone(namedValues=NamedValues(("default", 50))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmizerCfgTxPercentRsrcs.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerCfgTxPercentRsrcs.setDescription('The maximum percentage of transmit buffers which the transmit driver can hold before it begins clipping. This is a configurable option and does not indicate the true value.')
wfAtmizerCfgHeartbeatPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3))).clone(namedValues=NamedValues(("default", 3))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmizerCfgHeartbeatPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerCfgHeartbeatPeriod.setDescription('The timer period, in seconds, which defines how often heartbeat messages are sent to the ATMizers.')
wfAtmizerRxBuffersMax = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 1, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerRxBuffersMax.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerRxBuffersMax.setDescription('The maximum number of receive buffers which the RX ATMizer can own before encountering a lack of resources. This value indicates the true value of the Rx buffers available.')
wfAtmizerRxPagesMax = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 1, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerRxPagesMax.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerRxPagesMax.setDescription('The maximum number of additional physical pages which the RX ATMizer can own before encountering a lack of resources. This value indicates the true value of the Rx Pages available.')
wfAtmizerTxBuffersMax = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 1, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerTxBuffersMax.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerTxBuffersMax.setDescription('The maximum number of transmit buffers which the TX ATMizer can own before it begins clipping. This value indicates the true value of the Tx buffers available.')
wfAtmizerTxPagesMax = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 1, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerTxPagesMax.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerTxPagesMax.setDescription('The maximum number of additional physical pages which the TX ATMizer can own before encountering a lack of resources. This value indicates the true value of the Tx pagess available.')
wfAtmizerTxPercentRsrcs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 1, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerTxPercentRsrcs.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerTxPercentRsrcs.setDescription('The maximum percentage of transmit buffers which the transmit driver can hold before it begins clipping.')
wfAtmizerTxPerVcClipEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmizerTxPerVcClipEnable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerTxPerVcClipEnable.setDescription('Enable/disable Transmit per-VC buffer clipping threshold')
wfAtmizerCfgTxVcBuffersMax = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 1, 1, 18), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmizerCfgTxVcBuffersMax.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerCfgTxVcBuffersMax.setDescription('The maximum number of buffers which the TX ATMizer can queue for a particular virtual connection before clipping. This is a configurable option and does not indicate the true value.')
wfAtmizerTxVcBuffersMax = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 1, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerTxVcBuffersMax.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerTxVcBuffersMax.setDescription('The maximum number of buffers which the TX ATMizer can queue for a particular virtual connection before clipping.')
wfAtmizerDrvCfgTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 2), )
if mibBuilder.loadTexts: wfAtmizerDrvCfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerDrvCfgTable.setDescription('ATMizer Line Driver Configuration Record')
wfAtmizerDrvCfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 2, 1), ).setIndexNames((0, "Wellfleet-ATM-MIB", "wfAtmizerDrvCfgSlot"), (0, "Wellfleet-ATM-MIB", "wfAtmizerDrvCfgPort"))
if mibBuilder.loadTexts: wfAtmizerDrvCfgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerDrvCfgEntry.setDescription('Information about a particular driver')
wfAtmizerDrvCfgDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("create", 1), ("delete", 2))).clone('create')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmizerDrvCfgDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerDrvCfgDelete.setDescription('Create/delete MIB instance parameter.')
wfAtmizerDrvCfgEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmizerDrvCfgEnable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerDrvCfgEnable.setDescription('Enable/disable driver parameter.')
wfAtmizerDrvCfgState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 20))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("init", 3), ("notpresent", 20))).clone('notpresent')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerDrvCfgState.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerDrvCfgState.setDescription('Driver state parameter. This parameter does not represent the state of the physical interface!')
wfAtmizerDrvCfgSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 14))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerDrvCfgSlot.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerDrvCfgSlot.setDescription('Slot number -- instance id.')
wfAtmizerDrvCfgPort = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("one", 1), ("two", 2), ("three", 3), ("four", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerDrvCfgPort.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerDrvCfgPort.setDescription('Physical port number -- instance id.')
wfAtmizerDrvCfgCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1023))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmizerDrvCfgCct.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerDrvCfgCct.setDescription('Circuit number for the driver.')
wfAtmizerDrvCfgLineNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 2, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmizerDrvCfgLineNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerDrvCfgLineNumber.setDescription('The LineNumber is an Index value used to uniquely identify an instance of a physical ATM port. This value shall be used as an instance identifier for ATM MIB objects.')
wfAtmizerDrvCfgType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("sonet", 1), ("ds3", 2), ("e3", 3), ("ds1", 4), ("e1", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerDrvCfgType.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerDrvCfgType.setDescription("The type of interface. This attribute is an alias for 'ifType.")
wfAtmizerDrvCfgMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9188)).clone(4608)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmizerDrvCfgMtu.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerDrvCfgMtu.setDescription("The size of the largest packet which can be sent/received on the interface, specified in octets. This attribute is an alias for 'ifMtu'.")
wfAtmizerDrvCfgSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(622080000, 155520000, 140000000, 100000000, 44736000, 34368000, 2048000, 1544000))).clone(namedValues=NamedValues(("speed622mb", 622080000), ("speed155mb", 155520000), ("speed140mb", 140000000), ("speed100mb", 100000000), ("speed45mb", 44736000), ("speed35mb", 34368000), ("speed2p048mb", 2048000), ("speed1p544mb", 1544000)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerDrvCfgSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerDrvCfgSpeed.setDescription("An estimate of the interface's current bandwidth in bits per second. This attribute is an alias for 'ifSpeed'.")
wfAtmizerDrvCfgDpNotify = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmizerDrvCfgDpNotify.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerDrvCfgDpNotify.setDescription('Data Path (DP) notify function. This function, when enabled, will disable the DP interface when the physical interface becomes non-operational.')
wfAtmizerDrvCfgDpNotifyTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 2, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3600)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmizerDrvCfgDpNotifyTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerDrvCfgDpNotifyTimeout.setDescription('Data Path (DP) notify function timeout period. This value specifies the number of seconds to wait before implementing the DP notify function. A timer will get set to this value when the state of the physical interface transitions from operational to non-operational when the DP notify function is enabled.')
wfAtmizerDrvCfgVcInactEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmizerDrvCfgVcInactEnable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerDrvCfgVcInactEnable.setDescription('Inactivity timeout value for all SVCs on this interface in seconds. If no cells have been transmitted or received on an SVC over the given timeout period then the SVC will be closed. If this value is set to zero, then the SVCs inactivity timer will be disabled for this interface.')
wfAtmizerDrvCfgVcInactTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 2, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(60, 3600)).clone(1200)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmizerDrvCfgVcInactTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerDrvCfgVcInactTimeout.setDescription('Inactivity timeout value for all SVCs on this interface in seconds. If no cells have been transmitted or received on an SVC over the given timeout period then the SVC will be closed.')
wfAtmizerDrvCfgMadrCt = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 2, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerDrvCfgMadrCt.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerDrvCfgMadrCt.setDescription('Number of PROM-based MAC addresses.')
wfAtmizerDrvCfgMadr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 2, 1, 16), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerDrvCfgMadr.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerDrvCfgMadr.setDescription('First MAC address in canonical format (i.e., 00-00-a2...). The number of subsequent MAC addresses is specified by wfAtmizerDrvCfgMadrCt which are sequential.')
wfAtmizerDrvCfgFramingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 2, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14))).clone(namedValues=NamedValues(("sdh", 1), ("sonet", 2), ("cbit", 3), ("m23", 4), ("g751", 5), ("g832", 6), ("cbitnofallback", 7), ("clearchannel", 8), ("t1adm", 9), ("e1adm", 10), ("t1plcp", 11), ("e1plcp", 12), ("t3cbitplcp", 13), ("t3m23plcp", 14))).clone('sonet')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmizerDrvCfgFramingMode.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerDrvCfgFramingMode.setDescription('The framing (transceiver) mode for the physical interface')
wfAtmizerDrvCfgClkSource = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 2, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("intrn", 1), ("extrn", 2))).clone('intrn')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmizerDrvCfgClkSource.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerDrvCfgClkSource.setDescription('Source of the physical interface clocking signal, either internal or external.')
wfAtmizerDrvCfgLogLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 2, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4))).clone(namedValues=NamedValues(("atmcdbg", 1), ("atmcdb2", 2), ("vcmsg", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmizerDrvCfgLogLevel.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerDrvCfgLogLevel.setDescription('Bit mask which controls the amount of logging done by the ATM driver. If a bit in the mask is set, it enables logging of an event class. If a bit is cleared, it disables logging of an event class. ----------------------------------- | | ----------------------------------- 31 0 bit 0 - Link Module Coprocessor debug events bit 1 - VC setup/teardown events')
wfAtmizerDrvCfgDsx3SendCode = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 2, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("none", 1), ("line", 2), ("payload", 3), ("reset", 4), ("loop", 5), ("pattern", 6))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmizerDrvCfgDsx3SendCode.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerDrvCfgDsx3SendCode.setDescription('This variable indicates what type of code is being sent across DS3/E3 interface by the device. (These are optional for E3 interfaces.) The values mean: ATM_DSX3_SEND_CODE_NONE : Sending looped or normal data. ATM_DSX3_SEND_CODE_LINE : Sending a request for line loopback. ATM_DSX3_SEND_CODE_PAYLOAD : Sending a request for a payload loopback. (i.e., all Ds1/E1s in a DS3/E3 frame) ATM_DSX3_SEND_CODE_RESET : Sending a loopback deactivation request. ATM_DSX3_SEND_CODE_DS1_LOOP: Requesting to loopback a particular DS1/E1 within a DS3/E3 frame. ATM_DSX3_SEND_TEST_PATTERN : Sending a test pattern.')
wfAtmizerDrvCfgDsx3LoopbackConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 2, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("payload", 2), ("line", 3), ("other", 4))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmizerDrvCfgDsx3LoopbackConfig.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerDrvCfgDsx3LoopbackConfig.setDescription("This variable represents the loopback configuration of the DS3/E3 interface. Ther values mean: ATM_DSX3_LOOPBACK_NONE : Not in the loopback state/ A device that is not capable of performing a loopback on the interface shall always return this as it's value. ATM_DSX3_LOOPBACK_PAYLOAD : The received signal at this interface is looped through the device. Typically the received signal is looped back for retransmission after it has passed through the device's framing function. ATM_DSX3_LOOPBACK_LINE : The received signal at this interface does not go through the device (minimum penetration) but is looped back out. ATM_DSX3_LOOPBACK_OTHER : Loopback's that are not defined here.")
wfAtmizerDrvCfgDs3Scrambling = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 2, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmizerDrvCfgDs3Scrambling.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerDrvCfgDs3Scrambling.setDescription('This variable represents if scrambling is turned on or off')
wfAtmizerDrvCfgDs3LineBuildOut = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 2, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("short", 1), ("long", 2))).clone('short')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmizerDrvCfgDs3LineBuildOut.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerDrvCfgDs3LineBuildOut.setDescription('This variable represents the Line Build Out for the DS3 short and long cables. ')
wfAtmizerDrvCfgModule = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 2, 1, 24), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerDrvCfgModule.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerDrvCfgModule.setDescription('Module number for ASN type platforms. For non-ASN platforms this attribute will not be used.')
wfAtmizerFramingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 2, 1, 25), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerFramingMode.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerFramingMode.setDescription('The actual framing (transceiver) mode for the physical interface')
wfAtmizerDrvCfgIwfCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 2, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1023))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmizerDrvCfgIwfCct.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerDrvCfgIwfCct.setDescription('This variable represents the circuit number associated with FR/ATM Interworking Service record. ')
wfAtmizerDrvCfgCcType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 2, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4))).clone(namedValues=NamedValues(("none", 1), ("mplsMlm", 2), ("atmCc", 4))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmizerDrvCfgCcType.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerDrvCfgCcType.setDescription('Which one is the Call Control module, ATM or MPLS?')
wfAtmizerDrvCfgMaxVcls = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 2, 1, 28), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerDrvCfgMaxVcls.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerDrvCfgMaxVcls.setDescription('The maximum number of Virtual Channel Links (VCLs) that are supported at the ATM driver interface.')
wfAtmizerDrvCfgCurrVcls = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 2, 1, 29), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerDrvCfgCurrVcls.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerDrvCfgCurrVcls.setDescription('The number of Virtual Channel Links (VCLs) currently active.')
wfAtmizerDrvCfgScrSum = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 2, 1, 30), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerDrvCfgScrSum.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerDrvCfgScrSum.setDescription('Total sum of all VC Sustainable Cell Rates (SCR). Used for Call Admission Control (CAC).')
wfAtmizerDrvCfgExtRate = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 2, 1, 31), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmizerDrvCfgExtRate.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerDrvCfgExtRate.setDescription('A user specified value for line speed which, if non-zero, will be reported as ifEntry.ifSpeed. It has no effect on operation of the interface.')
wfAtmizerIntfStatsTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 3), )
if mibBuilder.loadTexts: wfAtmizerIntfStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerIntfStatsTable.setDescription('ARE Line Driver Statistics Record')
wfAtmizerIntfStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 3, 1), ).setIndexNames((0, "Wellfleet-ATM-MIB", "wfAtmizerIntfSlot"), (0, "Wellfleet-ATM-MIB", "wfAtmizerIntfPort"))
if mibBuilder.loadTexts: wfAtmizerIntfStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerIntfStatsEntry.setDescription('Information about a particular driver')
wfAtmizerIntfSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 14))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerIntfSlot.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerIntfSlot.setDescription('Slot number -- instance id.')
wfAtmizerIntfPort = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("one", 1), ("two", 2), ("three", 3), ("four", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerIntfPort.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerIntfPort.setDescription('Physical port number -- instance id.')
wfAtmizerIntfLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 3, 1, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerIntfLastChange.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerIntfLastChange.setDescription("The time (in hundreths of a second) since the network management portion of the system was last re-initialized. This attribute is an alias for 'ifLastChange' in the MIBII System Group.")
wfAtmizerIntfOutQLen = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 3, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerIntfOutQLen.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerIntfOutQLen.setDescription("This attribute is an alias for 'ifOutQLen' in the MIBII interface group.")
wfAtmizerIntfStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3), ("unknown", 4), ("dormant", 5))).clone('unknown')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerIntfStatus.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerIntfStatus.setDescription('MIB-II ifOperStatus')
wfAtmizerIntfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 3, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerIntfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerIntfIndex.setDescription('MIB-II interface index')
wfAtmizerIntfOcdEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerIntfOcdEvents.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerIntfOcdEvents.setDescription('The number of times the Out of Cell Delineation (OCD) events occur. If seven consecutive ATM cells have Header Error Control (HEC) violations, an OCD event occurs. A high number of OCD events may indicate a problem with the TC sublayer.')
wfAtmizerIntfTcAlarmState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no-alarm", 1), ("failure", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerIntfTcAlarmState.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerIntfTcAlarmState.setDescription('This variable indicates if there is an alarm present for the TC sublayer. The value ATM_LCD_FAILURE indicates that a Loss of Cell Delineation (LCD) failure state has been declared for the TC sublayer. Transition from failure to the ATM_NO_ALARM state occurs when six consecutive ATM cells are received with valid HEC, followed by about 10 seconds of acceptable working signal.')
wfAtmizerIntfRxPacketsOkWrap = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 3, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerIntfRxPacketsOkWrap.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerIntfRxPacketsOkWrap.setDescription('The number of times the wfAtmizerIntfRxPacketsOk counter has wrapped.')
wfAtmizerIntfRxPacketsOk = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 3, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerIntfRxPacketsOk.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerIntfRxPacketsOk.setDescription('The number of Service Data Units (SDUs) received without error.')
wfAtmizerIntfRxCellsOkWrap = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 3, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerIntfRxCellsOkWrap.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerIntfRxCellsOkWrap.setDescription('The number of times the wfAtmizerIntfRxCellsOk counter has wrapped.')
wfAtmizerIntfRxCellsOk = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 3, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerIntfRxCellsOk.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerIntfRxCellsOk.setDescription('The number of reassembled Service Data Unit (SDU) cells received without error.')
wfAtmizerIntfRxOamCount = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 3, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerIntfRxOamCount.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerIntfRxOamCount.setDescription('The number of F4/F5 OAM Cells received on this interface.')
wfAtmizerIntfRxFlowCtrlCount = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 3, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerIntfRxFlowCtrlCount.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerIntfRxFlowCtrlCount.setDescription('The number of Flow Control OAM Cells received on this interface.')
wfAtmizerIntfRxInvalidHeaders = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 3, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerIntfRxInvalidHeaders.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerIntfRxInvalidHeaders.setDescription('The number of receive cells dropped because of bad header fields (invalid VPI/VCI, non-zero GFC, bad PTI field).')
wfAtmizerIntfRxOverSizedSDUs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 3, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerIntfRxOverSizedSDUs.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerIntfRxOverSizedSDUs.setDescription('The number of receive packets dropped because the reassembled SDU was greater than the MTU for this interface.')
wfAtmizerIntfRxCrcErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 3, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerIntfRxCrcErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerIntfRxCrcErrors.setDescription('The number of received cells dropped because of an invalid CRC.')
wfAtmizerIntfRxCrc10Errors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 3, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerIntfRxCrc10Errors.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerIntfRxCrc10Errors.setDescription('The number of OAM cells dropped because of an invalid CRC-10.')
wfAtmizerIntfRxLackBufCredits = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 3, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerIntfRxLackBufCredits.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerIntfRxLackBufCredits.setDescription('The number of received packets lost on this interface because no receive buffer space was available to the receiver for incoming data.')
wfAtmizerIntfRxLackPageCredits = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 3, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerIntfRxLackPageCredits.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerIntfRxLackPageCredits.setDescription('The number of received packets lost on this interface because no physical pages were available to the receiver for incoming data.')
wfAtmizerIntfRxLackBufResc = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 3, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerIntfRxLackBufResc.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerIntfRxLackBufResc.setDescription('The number of received packets lost on this interface because there were no free system buffers available.')
wfAtmizerIntfRxLackPageResc = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 3, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerIntfRxLackPageResc.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerIntfRxLackPageResc.setDescription('The number of received packets lost on this interface because there were no free system pages available.')
wfAtmizerIntfTxPacketsOkWrap = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 3, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerIntfTxPacketsOkWrap.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerIntfTxPacketsOkWrap.setDescription('The number of times the wfAtmizerIntfTxPacketsOk counter has wrapped.')
wfAtmizerIntfTxPacketsOk = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 3, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerIntfTxPacketsOk.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerIntfTxPacketsOk.setDescription('The number of Service Data Units (SDUs) transmitted without error.')
wfAtmizerIntfTxCellsOkWrap = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 3, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerIntfTxCellsOkWrap.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerIntfTxCellsOkWrap.setDescription('The number of times the wfAtmizerIntfTxCellsOk counter has wrapped.')
wfAtmizerIntfTxCellsOk = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 3, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerIntfTxCellsOk.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerIntfTxCellsOk.setDescription('The number of segmented Service Data Unit (SDU) cells transmitted without error.')
wfAtmizerIntfTxOamCount = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 3, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerIntfTxOamCount.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerIntfTxOamCount.setDescription('The number of F4/F5 OAM Cells transmitted on this interface.')
wfAtmizerIntfTxFlowCtrlCount = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 3, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerIntfTxFlowCtrlCount.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerIntfTxFlowCtrlCount.setDescription('The number of Flow Control OAM Cells transmitted on this interface.')
wfAtmizerIntfTxBadVcs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 3, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerIntfTxBadVcs.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerIntfTxBadVcs.setDescription('Count of packets dropped on transmit because of an invalid VPI/VCI.')
wfAtmizerIntfTxOverSizedSDUs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 3, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerIntfTxOverSizedSDUs.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerIntfTxOverSizedSDUs.setDescription('The number of transmit packets dropped because their SDU size was greater than the MTU for this interface.')
wfAtmizerIntfTxLackBufCredits = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 3, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerIntfTxLackBufCredits.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerIntfTxLackBufCredits.setDescription('The number of transmit packets lost on this interface because no buffer space was available to the transmitter for outgoing data.')
wfAtmizerIntfTxLackPageCredits = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 3, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerIntfTxLackPageCredits.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerIntfTxLackPageCredits.setDescription('The number of transmit packets lost on this interface because no physical pages were available to the transmitter for outgoing data.')
wfAtmizerIntfTxDrvClipCount = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 3, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerIntfTxDrvClipCount.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerIntfTxDrvClipCount.setDescription('The number of transmit packets lost on this interface because no buffer space was available to the host transmit driver for outgoing data.')
wfAtmizerIntfHecDetectedCount = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 3, 1, 34), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerIntfHecDetectedCount.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerIntfHecDetectedCount.setDescription('Number of uncorrectable HEC errors detected on this interface.')
wfAtmizerIntfHecCorrectedCount = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 3, 1, 35), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerIntfHecCorrectedCount.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerIntfHecCorrectedCount.setDescription('Number of correctable HEC errors detected on this interface.')
wfAtmizerIntfRxOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 3, 1, 36), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerIntfRxOctets.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerIntfRxOctets.setDescription('Count of octets received successfully. Note: May not be supported on all ATM-based platforms.')
wfAtmizerIntfTxOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 3, 1, 37), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerIntfTxOctets.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerIntfTxOctets.setDescription('Count of octets transmitted successfully. Note: May not be supported on all ATM-based platforms.')
wfAtmizerIntfRxUTOPIAErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 3, 1, 38), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerIntfRxUTOPIAErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerIntfRxUTOPIAErrors.setDescription('Count of cells dropped as a result of UTOPIA parity errors or state machine errors (short or long cells). Note: May not be supported on all ATM-based platforms.')
wfAtmizerIntfRxLengthErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 3, 1, 39), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerIntfRxLengthErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerIntfRxLengthErrors.setDescription('Count of Rx length errors. AAL5 CPCS-PDU length violation. Note: May not be supported on all ATM-based platforms.')
wfAtmizerIntfRxAbortMessages = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 3, 1, 40), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerIntfRxAbortMessages.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerIntfRxAbortMessages.setDescription('Count of abort messages received (AAL5 length field equals 0). Note: May not be supported on all ATM-based platforms.')
wfAtmizerIntfRxSequenceNumberErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 3, 1, 41), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerIntfRxSequenceNumberErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerIntfRxSequenceNumberErrors.setDescription('Count of AAL1 sequence number errors. Note: May not be supported on all ATM-based platforms.')
wfAtmizerVclStatsTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 4), )
if mibBuilder.loadTexts: wfAtmizerVclStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerVclStatsTable.setDescription('Virtual Channel Statistics Record')
wfAtmizerVclStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 4, 1), ).setIndexNames((0, "Wellfleet-ATM-MIB", "wfAtmizerVclIndex"), (0, "Wellfleet-ATM-MIB", "wfAtmizerVclVpi"), (0, "Wellfleet-ATM-MIB", "wfAtmizerVclVci"))
if mibBuilder.loadTexts: wfAtmizerVclStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerVclStatsEntry.setDescription('Information about a particular virtual channel')
wfAtmizerVclIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerVclIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerVclIndex.setDescription('Instance id - Index number of this physical interface.')
wfAtmizerVclVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerVclVpi.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerVclVpi.setDescription('Instance id - Virtual Path Id for this VCL.')
wfAtmizerVclVci = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 4, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerVclVci.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerVclVci.setDescription('Instance id - Virtual Channel Id for this VCL.')
wfAtmizerVclRxPacketsOkWrap = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerVclRxPacketsOkWrap.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerVclRxPacketsOkWrap.setDescription('Number of times the wfAtmizerVclRxPacketsOk has wrapped.')
wfAtmizerVclRxPacketsOk = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 4, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerVclRxPacketsOk.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerVclRxPacketsOk.setDescription('Number of packets received on this VCL.')
wfAtmizerVclRxCellsOkWrap = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 4, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerVclRxCellsOkWrap.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerVclRxCellsOkWrap.setDescription('Number of times the wfAtmizerVclRxCellsOk has wrapped.')
wfAtmizerVclRxCellsOk = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 4, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerVclRxCellsOk.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerVclRxCellsOk.setDescription('Number of cells received on this VCL.')
wfAtmizerVclRxOamCount = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 4, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerVclRxOamCount.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerVclRxOamCount.setDescription('The number of OAM cells received on this VCL.')
wfAtmizerVclRxFlowCtrlCount = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 4, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerVclRxFlowCtrlCount.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerVclRxFlowCtrlCount.setDescription('The number of Flow Control cells received on this VCL.')
wfAtmizerVclRxInvalidHeaders = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 4, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerVclRxInvalidHeaders.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerVclRxInvalidHeaders.setDescription('The number of receive cells dropped because of an invalid ATM header.')
wfAtmizerVclRxOverSizedSDUs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 4, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerVclRxOverSizedSDUs.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerVclRxOverSizedSDUs.setDescription('The number of receive packets dropped on this VCL because the reassembled SDU was greater than the MTU for this interface.')
wfAtmizerVclRxCrcErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 4, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerVclRxCrcErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerVclRxCrcErrors.setDescription('The number of received cells dropped on this VCL because of an invalid CRC.')
wfAtmizerVclRxCrc10Errors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 4, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerVclRxCrc10Errors.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerVclRxCrc10Errors.setDescription('The number of OAM cells dropped on this VCL because of an invalid CRC-10.')
wfAtmizerVclRxLackBufCredits = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 4, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerVclRxLackBufCredits.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerVclRxLackBufCredits.setDescription('The number of received packets lost on this VCL because no receive buffer space was available to the receiver for incoming data.')
wfAtmizerVclRxLackPageCredits = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 4, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerVclRxLackPageCredits.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerVclRxLackPageCredits.setDescription('The number of received packets lost on this VCL because no physical pages were available to the receiver for incoming data.')
wfAtmizerVclRxLackBufResc = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 4, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerVclRxLackBufResc.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerVclRxLackBufResc.setDescription('The number of received packets lost on this VCL because there were no free system buffers available.')
wfAtmizerVclRxLackPageResc = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 4, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerVclRxLackPageResc.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerVclRxLackPageResc.setDescription('The number of received packets lost on this VCL because there were no free system pages available.')
wfAtmizerVclTxPacketsOkWrap = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 4, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerVclTxPacketsOkWrap.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerVclTxPacketsOkWrap.setDescription('Number of times the wfAtmizerVclTxPacketsOk has wrapped.')
wfAtmizerVclTxPacketsOk = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 4, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerVclTxPacketsOk.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerVclTxPacketsOk.setDescription('Number of packets transmitted on this VCL.')
wfAtmizerVclTxCellsOkWrap = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 4, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerVclTxCellsOkWrap.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerVclTxCellsOkWrap.setDescription('Number of times the wfAtmizerVclTxCellsOk has wrapped.')
wfAtmizerVclTxCellsOk = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 4, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerVclTxCellsOk.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerVclTxCellsOk.setDescription('Number of cells transmitted on this VCL.')
wfAtmizerVclTxOamCount = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 4, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerVclTxOamCount.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerVclTxOamCount.setDescription('The number of OAM cells transmitted on this VCL.')
wfAtmizerVclTxFlowCtrlCount = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 4, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerVclTxFlowCtrlCount.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerVclTxFlowCtrlCount.setDescription('The number of Flow Control cells received on this VCL.')
wfAtmizerVclTxOverSizedSDUs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 4, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerVclTxOverSizedSDUs.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerVclTxOverSizedSDUs.setDescription('The number of transmit packets dropped on this VCL because their SDU size was greater than the MTU for this interface.')
wfAtmizerVclTxLackBufCredits = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 4, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerVclTxLackBufCredits.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerVclTxLackBufCredits.setDescription('The number of transmit packets lost on this VCL because no buffer space was available to the transmitter for outgoing data.')
wfAtmizerVclTxLackPageCredits = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 4, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerVclTxLackPageCredits.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerVclTxLackPageCredits.setDescription('The number of transmit packets lost on this VCL because no physical pages were available to the transmitter for outgoing data.')
wfAtmizerVclRxOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 4, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerVclRxOctets.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerVclRxOctets.setDescription('Count of octets received successfully. Note: May not be supported on all ATM-based platforms.')
wfAtmizerVclTxOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 4, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerVclTxOctets.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerVclTxOctets.setDescription('Count of octets transmitted successfully. Note: May not be supported on all ATM-based platforms.')
wfAtmizerVclTxClipFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 4, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerVclTxClipFrames.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerVclTxClipFrames.setDescription('Number of frames clipped (dropped) due to transmit congestion. Note: May not be supported on all ATM-based platforms.')
wfAtmizerVclRxLengthErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 4, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerVclRxLengthErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerVclRxLengthErrors.setDescription('Count of Rx length errors. AAL5 CPCS-PDU length violation. Note: May not be supported on all ATM-based platforms.')
wfAtmizerVclRxAbortMessages = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 4, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerVclRxAbortMessages.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerVclRxAbortMessages.setDescription('Count of abort messages received (AAL5 length field equals 0). Note: May not be supported on all ATM-based platforms.')
wfAtmizerVclRxSequenceNumberErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 4, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerVclRxSequenceNumberErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerVclRxSequenceNumberErrors.setDescription('Count of AAL1 sequence number errors. Note: May not be supported on all ATM-based platforms.')
wfAtmizerDebugTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 5), )
if mibBuilder.loadTexts: wfAtmizerDebugTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerDebugTable.setDescription('ARE ATMizer Debug Record')
wfAtmizerDebugEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 5, 1), ).setIndexNames((0, "Wellfleet-ATM-MIB", "wfAtmizerDebugSlot"))
if mibBuilder.loadTexts: wfAtmizerDebugEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerDebugEntry.setDescription('Information about a Transmit/Receive pair of ATMizers')
wfAtmizerDebugSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 14))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmizerDebugSlot.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerDebugSlot.setDescription('Slot number -- instance id.')
wfAtmizerDebugCmd = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 5, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmizerDebugCmd.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerDebugCmd.setDescription('Debug command to be issued to ATMizers.')
wfAtmizerDebugCmdSize = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 5, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmizerDebugCmdSize.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerDebugCmdSize.setDescription('Number of parameters to the debug command.')
wfAtmizerDebugParam1 = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 5, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmizerDebugParam1.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerDebugParam1.setDescription('The first parameter to the ATMizer debug command.')
wfAtmizerDebugParam2 = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 5, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmizerDebugParam2.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerDebugParam2.setDescription('The second parameter to the ATMizer debug command.')
wfAtmizerDebugParam3 = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 5, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmizerDebugParam3.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerDebugParam3.setDescription('The third parameter to the ATMizer debug command.')
wfAtmizerDebugParam4 = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 5, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmizerDebugParam4.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerDebugParam4.setDescription('The fourth parameter to the ATMizer debug command.')
wfAtmizerDebugParam5 = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 5, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmizerDebugParam5.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerDebugParam5.setDescription('The fifth parameter to the ATMizer debug command.')
wfAtmizerDebugParam6 = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 5, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmizerDebugParam6.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerDebugParam6.setDescription('The sixth parameter to the ATMizer debug command.')
wfAtmizerDebugParam7 = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 5, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmizerDebugParam7.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerDebugParam7.setDescription('The seventh parameter to the ATMizer debug command.')
wfAtmizerDebugParam8 = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 5, 1, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmizerDebugParam8.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerDebugParam8.setDescription('The eighth parameter to the ATMizer debug command.')
wfAtmizerDebugParam9 = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 5, 1, 12), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmizerDebugParam9.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerDebugParam9.setDescription('The nineth parameter to the ATMizer debug command.')
wfAtmizerDebugParam10 = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 5, 1, 13), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmizerDebugParam10.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerDebugParam10.setDescription('The tenth parameter to the ATMizer debug command.')
wfAtmizerDebugRxDone = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 5, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 16))).clone(namedValues=NamedValues(("inprog", 1), ("done", 2), ("err", 16))).clone('inprog')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmizerDebugRxDone.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerDebugRxDone.setDescription('Completion flag indicating that the RX ATMizer has completed the debug command and the result is available in wfAtmizerDebugRxValue.')
wfAtmizerDebugRxValue = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 5, 1, 15), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmizerDebugRxValue.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerDebugRxValue.setDescription('The result of the RX ATMizer debug operation.')
wfAtmizerDebugTxDone = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 5, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 16))).clone(namedValues=NamedValues(("inprog", 1), ("done", 2), ("err", 16))).clone('inprog')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmizerDebugTxDone.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerDebugTxDone.setDescription('Completion flag indicating that the TX ATMizer has completed the debug command and the result is available in wfAtmizerDebugTxValue.')
wfAtmizerDebugTxValue = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 3, 5, 1, 17), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmizerDebugTxValue.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmizerDebugTxValue.setDescription('The result of the TX ATMizer debug operation.')
wfSonetMediumTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 1), )
if mibBuilder.loadTexts: wfSonetMediumTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetMediumTable.setDescription('Statistics for the SONET medium table')
wfSonetMediumEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 1, 1), ).setIndexNames((0, "Wellfleet-ATM-MIB", "wfSonetMediumIndex"))
if mibBuilder.loadTexts: wfSonetMediumEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetMediumEntry.setDescription('An entry in the medium table')
wfSonetMediumIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSonetMediumIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetMediumIndex.setDescription('Index for this physical Sonet interface.')
wfSonetMediumType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSonetMediumType.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetMediumType.setDescription('This variable identifies whether a SONET or a SDH signal is used across this interface.')
wfSonetMediumTimeElapsed = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSonetMediumTimeElapsed.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetMediumTimeElapsed.setDescription('The number of seconds that have elapsed since the beginning of the current error-measurement period.')
wfSonetMediumValidIntervals = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSonetMediumValidIntervals.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetMediumValidIntervals.setDescription('The number of previous intervals for which valid data has been stored.')
wfSonetMediumLineCoding = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("b3zs", 2), ("cmi", 3), ("nrz", 4), ("rz", 5))).clone('nrz')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSonetMediumLineCoding.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetMediumLineCoding.setDescription('This variable describes the line coding for this interface.')
wfSonetMediumLineType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("shortsinglemode", 2), ("longsinglemode", 3), ("multimode", 4), ("coax", 5), ("utp", 6))).clone('shortsinglemode')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSonetMediumLineType.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetMediumLineType.setDescription('This variable describes the line type for this interface.')
wfSonetMediumCircuitIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 1, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSonetMediumCircuitIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetMediumCircuitIdentifier.setDescription("This variable contains the transmission vendor's circuit identifier.")
wfSonetSectionCurrentTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 2), )
if mibBuilder.loadTexts: wfSonetSectionCurrentTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetSectionCurrentTable.setDescription('Statistics for the SONET section current table')
wfSonetSectionCurrentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 2, 1), ).setIndexNames((0, "Wellfleet-ATM-MIB", "wfSonetSectionCurrentIndex"))
if mibBuilder.loadTexts: wfSonetSectionCurrentEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetSectionCurrentEntry.setDescription('An entry in the Section current table')
wfSonetSectionCurrentIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSonetSectionCurrentIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetSectionCurrentIndex.setDescription('Index for this physical Sonet interface.')
wfSonetSectionCurrentStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4))).clone(namedValues=NamedValues(("nodefect", 1), ("los", 2), ("lof", 4))).clone('nodefect')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSonetSectionCurrentStatus.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetSectionCurrentStatus.setDescription('This variable is a bitmask indicating the status of the interface.')
wfSonetSectionCurrentESs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 2, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSonetSectionCurrentESs.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetSectionCurrentESs.setDescription('The counter associated with the number of Errored Seconds encountered by a SONET/SDH Section in the current 15 minute interval.')
wfSonetSectionCurrentSESs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 2, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSonetSectionCurrentSESs.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetSectionCurrentSESs.setDescription('The counter associated with the number of Severely Errored Seconds encountered by a SONET/SDH Section in the current 15 minute interval.')
wfSonetSectionCurrentSEFSs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 2, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSonetSectionCurrentSEFSs.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetSectionCurrentSEFSs.setDescription('The counter associated with the number of Severely Errored Framing Seconds encountered by a SONET/SDH Section in the current 15 minute interval.')
wfSonetSectionCurrentCVs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 2, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSonetSectionCurrentCVs.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetSectionCurrentCVs.setDescription('The counter associated with the number of Coding Violations encountered by a SONET/SDH Section in the current 15 minute interval.')
wfSonetSectionIntervalTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 3), )
if mibBuilder.loadTexts: wfSonetSectionIntervalTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetSectionIntervalTable.setDescription('Statistics for the SONET section interval table')
wfSonetSectionIntervalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 3, 1), ).setIndexNames((0, "Wellfleet-ATM-MIB", "wfSonetSectionIntervalIndex"), (0, "Wellfleet-ATM-MIB", "wfSonetSectionIntervalNumber"))
if mibBuilder.loadTexts: wfSonetSectionIntervalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetSectionIntervalEntry.setDescription('An entry in the Section Interval table')
wfSonetSectionIntervalIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSonetSectionIntervalIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetSectionIntervalIndex.setDescription('Index for this physical Sonet interface.')
wfSonetSectionIntervalNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSonetSectionIntervalNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetSectionIntervalNumber.setDescription('A number between 1 and 96, which identifies the interval for which the set of statistics is available. The interval identified by 1 is the most recently completed 15 minute interval, and the interval identified by N is the interval immediately preceding the one identified by N-1.')
wfSonetSectionIntervalESs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 3, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSonetSectionIntervalESs.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetSectionIntervalESs.setDescription('The counter associated with the number of Errored Seconds encountered by a SONET/SDH Section in a particular 15 minute interval.')
wfSonetSectionIntervalSESs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 3, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSonetSectionIntervalSESs.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetSectionIntervalSESs.setDescription('The counter associated with the number of Severely Errored Seconds encountered by a SONET/SDH Section in a particular 15 minute interval.')
wfSonetSectionIntervalSEFSs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 3, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSonetSectionIntervalSEFSs.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetSectionIntervalSEFSs.setDescription('The counter associated with the number of Severely Errored Framing Seconds encountered by a SONET/SDH Section in a particular 15 minute interval.')
wfSonetSectionIntervalCVs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 3, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSonetSectionIntervalCVs.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetSectionIntervalCVs.setDescription('The counter associated with the number of Coding Violations encountered by a SONET/SDH Section in a particular 15 minute interval.')
wfSonetLineCurrentTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 4), )
if mibBuilder.loadTexts: wfSonetLineCurrentTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetLineCurrentTable.setDescription('Statistics for the SONET line current table')
wfSonetLineCurrentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 4, 1), ).setIndexNames((0, "Wellfleet-ATM-MIB", "wfSonetLineCurrentIndex"))
if mibBuilder.loadTexts: wfSonetLineCurrentEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetLineCurrentEntry.setDescription('An entry in the Line current table')
wfSonetLineCurrentIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSonetLineCurrentIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetLineCurrentIndex.setDescription('Index for this physical Sonet interface.')
wfSonetLineCurrentStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4))).clone(namedValues=NamedValues(("nodefect", 1), ("ais", 2), ("rdi", 4))).clone('nodefect')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSonetLineCurrentStatus.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetLineCurrentStatus.setDescription('This variable is a bitmask indicating the status of the interface.')
wfSonetLineCurrentESs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 4, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSonetLineCurrentESs.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetLineCurrentESs.setDescription('The counter associated with the number of Errored Seconds encountered by a SONET/SDH Line in the current 15 minute interval.')
wfSonetLineCurrentSESs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 4, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSonetLineCurrentSESs.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetLineCurrentSESs.setDescription('The counter associated with the number of Severely Errored Seconds encountered by a SONET/SDH Line in the current 15 minute interval.')
wfSonetLineCurrentCVs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 4, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSonetLineCurrentCVs.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetLineCurrentCVs.setDescription('The counter associated with the number of Coding Violations encountered by a SONET/SDH Line in the current 15 minute interval.')
wfSonetLineCurrentUASs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 4, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSonetLineCurrentUASs.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetLineCurrentUASs.setDescription('The counter associated with the number of Unavailable Seconds encountered by a SONET/SDH Line in the current 15 minute interval.')
wfSonetLineIntervalTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 5), )
if mibBuilder.loadTexts: wfSonetLineIntervalTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetLineIntervalTable.setDescription('Statistics for the SONET line interval table')
wfSonetLineIntervalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 5, 1), ).setIndexNames((0, "Wellfleet-ATM-MIB", "wfSonetLineIntervalIndex"), (0, "Wellfleet-ATM-MIB", "wfSonetLineIntervalNumber"))
if mibBuilder.loadTexts: wfSonetLineIntervalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetLineIntervalEntry.setDescription('An entry in the Line Interval table')
wfSonetLineIntervalIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSonetLineIntervalIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetLineIntervalIndex.setDescription('Index for this physical Sonet interface.')
wfSonetLineIntervalNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 5, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSonetLineIntervalNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetLineIntervalNumber.setDescription('A number between 1 and 96, which identifies the interval for which the set of statistics is available. The interval identified by 1 is the most recently completed 15 minute interval, and the interval identified by N is the interval immediately preceding the one identified by N-1.')
wfSonetLineIntervalESs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 5, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSonetLineIntervalESs.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetLineIntervalESs.setDescription('The counter associated with the number of Errored Seconds encountered by a SONET/SDH Line in a particular 15 minute interval.')
wfSonetLineIntervalSESs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 5, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSonetLineIntervalSESs.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetLineIntervalSESs.setDescription('The counter associated with the number of Severely Errored Seconds encountered by a SONET/SDH Line in a particular 15 minute interval.')
wfSonetLineIntervalCVs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 5, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSonetLineIntervalCVs.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetLineIntervalCVs.setDescription('The counter associated with the number of Coding Violations encountered by a SONET/SDH Line in a particular 15 minute interval.')
wfSonetLineIntervalUASs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 5, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSonetLineIntervalUASs.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetLineIntervalUASs.setDescription('The counter associated with the number of Unavailable Seconds encountered by a SONET/SDH Line in a particular 15 minute interval.')
wfSonetFarEndLineCurrentTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 6), )
if mibBuilder.loadTexts: wfSonetFarEndLineCurrentTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetFarEndLineCurrentTable.setDescription('Statistics for the SONET far end line current table')
wfSonetFarEndLineCurrentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 6, 1), ).setIndexNames((0, "Wellfleet-ATM-MIB", "wfSonetFarEndLineCurrentIndex"))
if mibBuilder.loadTexts: wfSonetFarEndLineCurrentEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetFarEndLineCurrentEntry.setDescription('An entry in the FarEndLine current table')
wfSonetFarEndLineCurrentIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSonetFarEndLineCurrentIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetFarEndLineCurrentIndex.setDescription('Index for this physical Sonet interface.')
wfSonetFarEndLineCurrentESs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 6, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSonetFarEndLineCurrentESs.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetFarEndLineCurrentESs.setDescription('The counter associated with the number of Far End Errored Seconds encountered by a SONET/SDH Medium/Section/Line in the current 15 minute interval.')
wfSonetFarEndLineCurrentSESs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 6, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSonetFarEndLineCurrentSESs.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetFarEndLineCurrentSESs.setDescription('The counter associated with the number of Far End Severely Errored Seconds encountered by a SONET/SDH Medium/Section/Line in the current 15 minute interval.')
wfSonetFarEndLineCurrentCVs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 6, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSonetFarEndLineCurrentCVs.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetFarEndLineCurrentCVs.setDescription('The counter associated with the number of Far End Coding Violations encountered by a SONET/SDH Medium/Section/Line in the current 15 minute interval.')
wfSonetFarEndLineCurrentUASs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 6, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSonetFarEndLineCurrentUASs.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetFarEndLineCurrentUASs.setDescription('The counter associated with the number of Far End Unavailable Seconds encountered by a SONET/SDH Medium/Section/Line in the current 15 minute interval.')
wfSonetFarEndLineIntervalTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 7), )
if mibBuilder.loadTexts: wfSonetFarEndLineIntervalTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetFarEndLineIntervalTable.setDescription('Statistics for the SONET far end line interval table')
wfSonetFarEndLineIntervalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 7, 1), ).setIndexNames((0, "Wellfleet-ATM-MIB", "wfSonetFarEndLineIntervalIndex"), (0, "Wellfleet-ATM-MIB", "wfSonetFarEndLineIntervalNumber"))
if mibBuilder.loadTexts: wfSonetFarEndLineIntervalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetFarEndLineIntervalEntry.setDescription('An entry in the FarEndLine Interval table')
wfSonetFarEndLineIntervalIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 7, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSonetFarEndLineIntervalIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetFarEndLineIntervalIndex.setDescription('Index for this physical Sonet interface.')
wfSonetFarEndLineIntervalNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 7, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSonetFarEndLineIntervalNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetFarEndLineIntervalNumber.setDescription('A number between 1 and 96, which identifies the interval for which the set of statistics is available. The interval identified by 1 is the most recently completed 15 minute interval, and the interval identified by N is the interval immediately preceding the one identified by N-1.')
wfSonetFarEndLineIntervalESs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 7, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSonetFarEndLineIntervalESs.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetFarEndLineIntervalESs.setDescription('The counter associated with the number of Far End Errored Seconds encountered by a SONET/SDH Medium/Section/Line in the current 15 minute interval.')
wfSonetFarEndLineIntervalSESs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 7, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSonetFarEndLineIntervalSESs.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetFarEndLineIntervalSESs.setDescription('The counter associated with the number of Far End Severely Errored Seconds encountered by a SONET/SDH Medium/Section/Line in the current 15 minute interval.')
wfSonetFarEndLineIntervalCVs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 7, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSonetFarEndLineIntervalCVs.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetFarEndLineIntervalCVs.setDescription('The counter associated with the number of Far End Coding Violations encountered by a SONET/SDH Medium/Section/Line in the current 15 minute interval.')
wfSonetFarEndLineIntervalUASs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 7, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSonetFarEndLineIntervalUASs.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetFarEndLineIntervalUASs.setDescription('The counter associated with the number of Far End Unavailable Seconds encountered by a SONET/SDH Medium/Section/Line in the current 15 minute interval.')
wfSonetPathCurrentTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 8), )
if mibBuilder.loadTexts: wfSonetPathCurrentTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetPathCurrentTable.setDescription('Statistics for the SONET path current table')
wfSonetPathCurrentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 8, 1), ).setIndexNames((0, "Wellfleet-ATM-MIB", "wfSonetPathCurrentIndex"))
if mibBuilder.loadTexts: wfSonetPathCurrentEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetPathCurrentEntry.setDescription('An entry in the Path current table')
wfSonetPathCurrentIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 8, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSonetPathCurrentIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetPathCurrentIndex.setDescription('Index for this physical Sonet interface.')
wfSonetPathCurrentWidth = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 8, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("sts1", 1), ("sts3cstm1", 2), ("sts12cstm4", 3), ("sts24c", 4), ("sts48cstm16", 5))).clone('sts3cstm1')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSonetPathCurrentWidth.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetPathCurrentWidth.setDescription('A value that indicates the type of the SONET/SDH Path.')
wfSonetPathCurrentStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 8, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 8, 16, 32))).clone(namedValues=NamedValues(("nodefect", 1), ("stslop", 2), ("stsais", 4), ("stsrdi", 8), ("unequipped", 16), ("siglabelmis", 32))).clone('nodefect')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSonetPathCurrentStatus.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetPathCurrentStatus.setDescription('This variable is a bitmask indicating the status of the interface.')
wfSonetPathCurrentESs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 8, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSonetPathCurrentESs.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetPathCurrentESs.setDescription('The counter associated with the number of Errored Seconds encountered by a SONET/SDH Path in the current 15 minute interval.')
wfSonetPathCurrentSESs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 8, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSonetPathCurrentSESs.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetPathCurrentSESs.setDescription('The counter associated with the number of Severely Errored Seconds encountered by a SONET/SDH Path in the current 15 minute interval.')
wfSonetPathCurrentCVs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 8, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSonetPathCurrentCVs.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetPathCurrentCVs.setDescription('The counter associated with the number of Coding Violations encountered by a SONET/SDH Path in the current 15 minute interval.')
wfSonetPathCurrentUASs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 8, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSonetPathCurrentUASs.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetPathCurrentUASs.setDescription('The counter associated with the number of Unavailable Seconds encountered by a SONET/SDH Path in the current 15 minute interval.')
wfSonetPathIntervalTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 9), )
if mibBuilder.loadTexts: wfSonetPathIntervalTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetPathIntervalTable.setDescription('Statistics for the SONET path interval table')
wfSonetPathIntervalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 9, 1), ).setIndexNames((0, "Wellfleet-ATM-MIB", "wfSonetPathIntervalIndex"), (0, "Wellfleet-ATM-MIB", "wfSonetPathIntervalNumber"))
if mibBuilder.loadTexts: wfSonetPathIntervalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetPathIntervalEntry.setDescription('An entry in the Path Interval table')
wfSonetPathIntervalIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 9, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSonetPathIntervalIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetPathIntervalIndex.setDescription('Index for this physical Sonet interface.')
wfSonetPathIntervalNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 9, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSonetPathIntervalNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetPathIntervalNumber.setDescription('A number between 1 and 96, which identifies the interval for which the set of statistics is available. The interval identified by 1 is the most recently completed 15 minute interval, and the interval identified by N is the interval immediately preceding the one identified by N-1.')
wfSonetPathIntervalESs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 9, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSonetPathIntervalESs.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetPathIntervalESs.setDescription('The counter associated with the number of Errored Seconds encountered by a SONET/SDH Path in a particular 15 minute interval.')
wfSonetPathIntervalSESs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 9, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSonetPathIntervalSESs.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetPathIntervalSESs.setDescription('The counter associated with the number of Severely Errored Seconds encountered by a SONET/SDH Path in a particular 15 minute interval.')
wfSonetPathIntervalCVs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 9, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSonetPathIntervalCVs.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetPathIntervalCVs.setDescription('The counter associated with the number of Coding Violations encountered by a SONET/SDH Path in a particular 15 minute interval.')
wfSonetPathIntervalUASs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 9, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSonetPathIntervalUASs.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetPathIntervalUASs.setDescription('The counter associated with the number of Unavailable Seconds encountered by a SONET/SDH Path in a particular 15 minute interval.')
wfSonetFarEndPathCurrentTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 10), )
if mibBuilder.loadTexts: wfSonetFarEndPathCurrentTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetFarEndPathCurrentTable.setDescription('Statistics for the SONET far end path current table')
wfSonetFarEndPathCurrentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 10, 1), ).setIndexNames((0, "Wellfleet-ATM-MIB", "wfSonetFarEndPathCurrentIndex"))
if mibBuilder.loadTexts: wfSonetFarEndPathCurrentEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetFarEndPathCurrentEntry.setDescription('An entry in the Far End Path current table')
wfSonetFarEndPathCurrentIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 10, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSonetFarEndPathCurrentIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetFarEndPathCurrentIndex.setDescription('Index for this physical Sonet interface.')
wfSonetFarEndPathCurrentESs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 10, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSonetFarEndPathCurrentESs.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetFarEndPathCurrentESs.setDescription('The counter associated with the number of Far End Errored Seconds encountered by a SONET/SDH Path in the current 15 minute interval.')
wfSonetFarEndPathCurrentSESs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 10, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSonetFarEndPathCurrentSESs.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetFarEndPathCurrentSESs.setDescription('The counter associated with the number of Far End Severely Errored Seconds encountered by a SONET/SDH Path in the current 15 minute interval.')
wfSonetFarEndPathCurrentCVs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 10, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSonetFarEndPathCurrentCVs.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetFarEndPathCurrentCVs.setDescription('The counter associated with the number of Far End Coding Violations encountered by a SONET/SDH Path in the current 15 minute interval.')
wfSonetFarEndPathCurrentUASs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 10, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSonetFarEndPathCurrentUASs.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetFarEndPathCurrentUASs.setDescription('The counter associated with the number of Far End Unavailable Seconds encountered by a SONET/SDH Path in the current 15 minute interval.')
wfSonetFarEndPathIntervalTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 11), )
if mibBuilder.loadTexts: wfSonetFarEndPathIntervalTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetFarEndPathIntervalTable.setDescription('Statistics for the SONET far end path interval table')
wfSonetFarEndPathIntervalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 11, 1), ).setIndexNames((0, "Wellfleet-ATM-MIB", "wfSonetFarEndPathIntervalIndex"), (0, "Wellfleet-ATM-MIB", "wfSonetFarEndPathIntervalNumber"))
if mibBuilder.loadTexts: wfSonetFarEndPathIntervalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetFarEndPathIntervalEntry.setDescription('An entry in the Far End Path Interval table')
wfSonetFarEndPathIntervalIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 11, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSonetFarEndPathIntervalIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetFarEndPathIntervalIndex.setDescription('Index for this physical Sonet interface.')
wfSonetFarEndPathIntervalNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 11, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSonetFarEndPathIntervalNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetFarEndPathIntervalNumber.setDescription('A number between 1 and 96, which identifies the interval for which the set of statistics is available. The interval identified by 1 is the most recently completed 15 minute interval, and the interval identified by N is the interval immediately preceding the one identified by N-1.')
wfSonetFarEndPathIntervalESs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 11, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSonetFarEndPathIntervalESs.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetFarEndPathIntervalESs.setDescription('The counter associated with the number of Far End Errored Seconds encountered by a SONET/SDH Path in a particular 15 minute interval.')
wfSonetFarEndPathIntervalSESs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 11, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSonetFarEndPathIntervalSESs.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetFarEndPathIntervalSESs.setDescription('The counter associated with the number of Far End Severely Errored Seconds encountered by a SONET/SDH Path in a particular 15 minute interval.')
wfSonetFarEndPathIntervalCVs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 11, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSonetFarEndPathIntervalCVs.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetFarEndPathIntervalCVs.setDescription('The counter associated with the number of Far End Coding Violations encountered by a SONET/SDH Path in a particular 15 minute interval.')
wfSonetFarEndPathIntervalUASs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 24, 11, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSonetFarEndPathIntervalUASs.setStatus('mandatory')
if mibBuilder.loadTexts: wfSonetFarEndPathIntervalUASs.setDescription('The counter associated with the number of Far End Unavailable Seconds encountered by a SONET/SDH Path in a particular 15 minute interval.')
wfAtmVcGroupTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 12), )
if mibBuilder.loadTexts: wfAtmVcGroupTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVcGroupTable.setDescription('This table contains VC grouping configuration paramters, one entry per VC group.')
wfAtmVcGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 12, 1), ).setIndexNames((0, "Wellfleet-ATM-MIB", "wfAtmVcGroupCct"), (0, "Wellfleet-ATM-MIB", "wfAtmVcGroupIndex"))
if mibBuilder.loadTexts: wfAtmVcGroupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVcGroupEntry.setDescription('Entry definition.')
wfAtmVcGroupDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("create", 1), ("delete", 2))).clone('create')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmVcGroupDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVcGroupDelete.setDescription('Create/delete MIB instance parameter.')
wfAtmVcGroupCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 12, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmVcGroupCct.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVcGroupCct.setDescription('The circuit number that this VC group is configured for.')
wfAtmVcGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 12, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmVcGroupIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVcGroupIndex.setDescription('Uniquely identifies the VC group on a given circuit')
wfAtmVcGroupName = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 23, 1, 12, 1, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmVcGroupName.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmVcGroupName.setDescription('The name for the VC group')
mibBuilder.exportSymbols("Wellfleet-ATM-MIB", wfAtmAlcFrmXmtExtF4Segment=wfAtmAlcFrmXmtExtF4Segment, wfAtmSscopMaxStat=wfAtmSscopMaxStat, wfAtmPlcpSEFS=wfAtmPlcpSEFS, wfAtmVbrCsVciTable=wfAtmVbrCsVciTable, wfAtmVclDrops=wfAtmVclDrops, wfAtmAlcCopConfRcvBufs=wfAtmAlcCopConfRcvBufs, wfAtmInterfaceLLIndex=wfAtmInterfaceLLIndex, wfAtmAlcCopState=wfAtmAlcCopState, wfAtmSigNumRst=wfAtmSigNumRst, wfAtmAlcType=wfAtmAlcType, wfAtmAlcSarRateQueueTable=wfAtmAlcSarRateQueueTable, wfAtmPvcEntry=wfAtmPvcEntry, wfAtmAlcFrmOamTxSectionFerf=wfAtmAlcFrmOamTxSectionFerf, wfAtmAlcFrmRcvCellSyncLost=wfAtmAlcFrmRcvCellSyncLost, wfSonetPathCurrentSESs=wfSonetPathCurrentSESs, wfAtmLinkModuleGroup=wfAtmLinkModuleGroup, wfAtmizerVclTxLackPageCredits=wfAtmizerVclTxLackPageCredits, wfAtmPlcpLLIndex=wfAtmPlcpLLIndex, wfSonetPathIntervalESs=wfSonetPathIntervalESs, wfAtmMpeEntry=wfAtmMpeEntry, wfAtmAlcCopRcvClipPackets=wfAtmAlcCopRcvClipPackets, wfAtmSscopTable=wfAtmSscopTable, wfAtmAlcCopHwModId=wfAtmAlcCopHwModId, wfAtmAlcFrmRcvByteAlignment=wfAtmAlcFrmRcvByteAlignment, wfAtmizerIntfTxOamCount=wfAtmizerIntfTxOamCount, wfSonetLineIntervalSESs=wfSonetLineIntervalSESs, wfAtmUniAal=wfAtmUniAal, wfAtmVbrSarNoBufferErrors=wfAtmVbrSarNoBufferErrors, wfAtmAlcDrvEntry=wfAtmAlcDrvEntry, wfAtmAlcCopErrorTable=wfAtmAlcCopErrorTable, wfAtmMpeMisdeliveredPdus=wfAtmMpeMisdeliveredPdus, wfAtmInterfaceDelete=wfAtmInterfaceDelete, wfAtmSVCOptionsEntry=wfAtmSVCOptionsEntry, wfAtmAlcFrmCsiLoop=wfAtmAlcFrmCsiLoop, wfAtmizerCfgTxPagesMax=wfAtmizerCfgTxPagesMax, wfAtmMpeInvalidPids=wfAtmMpeInvalidPids, wfAtmVclRcvSustainableCellRate=wfAtmVclRcvSustainableCellRate, wfAtmVclStatsEntry=wfAtmVclStatsEntry, wfAtmSigMaxVpiPtPt=wfAtmSigMaxVpiPtPt, wfAtmAlcMadr=wfAtmAlcMadr, wfAtmAlcFrmOamTxPathAis=wfAtmAlcFrmOamTxPathAis, wfAtmVclOamLpbkEnable=wfAtmVclOamLpbkEnable, wfAtmVclXmtInitialCellRate=wfAtmVclXmtInitialCellRate, wfAtmSigVci=wfAtmSigVci, wfAtmServiceRecordVcType=wfAtmServiceRecordVcType, wfAtmAlcCopTotalXmtBufs=wfAtmAlcCopTotalXmtBufs, wfAtmAlcSarModeTrtl=wfAtmAlcSarModeTrtl, wfAtmizerIntfRxPacketsOk=wfAtmizerIntfRxPacketsOk, wfAtmizerDrvCfgMadr=wfAtmizerDrvCfgMadr, wfAtmizerIntfTxBadVcs=wfAtmizerIntfTxBadVcs, wfAtmInterfaceConfVccs=wfAtmInterfaceConfVccs, wfAtmizerDebugTable=wfAtmizerDebugTable, wfAtmizerDebugTxValue=wfAtmizerDebugTxValue, wfAtmAlcState=wfAtmAlcState, wfAtmAlcCopDmaFifoUnderruns=wfAtmAlcCopDmaFifoUnderruns, wfAtmAlcFrmOamTxPathFerf=wfAtmAlcFrmOamTxPathFerf, wfAtmizerDrvCfgType=wfAtmizerDrvCfgType, wfAtmizerDebugEntry=wfAtmizerDebugEntry, wfAtmDxiDxiAddrTable=wfAtmDxiDxiAddrTable, wfAtmVclOamLpbkThreshold2=wfAtmVclOamLpbkThreshold2, wfAtmizerVclRxCellsOkWrap=wfAtmizerVclRxCellsOkWrap, wfAtmizerDebugSlot=wfAtmizerDebugSlot, wfSonetLineIntervalIndex=wfSonetLineIntervalIndex, wfAtmVclServiceClass=wfAtmVclServiceClass, wfAtmAlcFrmXmtExtBcastSig=wfAtmAlcFrmXmtExtBcastSig, wfAtmDxiLineNumber=wfAtmDxiLineNumber, wfAtmSigAtmCct=wfAtmSigAtmCct, wfAtmAlcSarDmaModeBmode=wfAtmAlcSarDmaModeBmode, wfAtmAlcSarControlLoop=wfAtmAlcSarControlLoop, wfSonetFarEndPathCurrentIndex=wfSonetFarEndPathCurrentIndex, wfAtmAlcCopErrorEntry=wfAtmAlcCopErrorEntry, wfAtmAlcSarTrafficMgtTable=wfAtmAlcSarTrafficMgtTable, wfAtmInterfaceDisable=wfAtmInterfaceDisable, wfAtmAlcFrmRcvExtPointSig=wfAtmAlcFrmRcvExtPointSig, wfAtmizerIntfHecCorrectedCount=wfAtmizerIntfHecCorrectedCount, wfAtmVclOamLpbkThreshold1=wfAtmVclOamLpbkThreshold1, wfAtmDxiTooLongFrames=wfAtmDxiTooLongFrames, wfAtmPvcOctetReceives=wfAtmPvcOctetReceives, wfAtmizerDebugParam5=wfAtmizerDebugParam5, wfAtmVbrCsLLIndex=wfAtmVbrCsLLIndex, wfAtmVclXmtCells=wfAtmVclXmtCells, wfAtmVbrSeconds=wfAtmVbrSeconds, wfAtmInterfaceConfTable=wfAtmInterfaceConfTable, wfAtmizerIntfRxInvalidHeaders=wfAtmizerIntfRxInvalidHeaders, wfAtmVclRcvBurstSize=wfAtmVclRcvBurstSize, wfAtmIlmiGetNextTimer=wfAtmIlmiGetNextTimer, wfAtmizerIntfTxOctets=wfAtmizerIntfTxOctets, wfAtmizerVclRxCrc10Errors=wfAtmizerVclRxCrc10Errors, wfAtmAlcCopConfTable=wfAtmAlcCopConfTable, wfSonetFarEndLineCurrentSESs=wfSonetFarEndLineCurrentSESs, wfAtmizerDrvCfgEnable=wfAtmizerDrvCfgEnable, wfAtmAlcCopDataPathIndex=wfAtmAlcCopDataPathIndex, wfAtmizerVclTxOctets=wfAtmizerVclTxOctets, wfAtmAlcCopConfXmtBufs=wfAtmAlcCopConfXmtBufs, wfSonetSectionIntervalESs=wfSonetSectionIntervalESs, wfAtmAlcFrmRcvCellEnable=wfAtmAlcFrmRcvCellEnable, wfSonetFarEndLineIntervalNumber=wfSonetFarEndLineIntervalNumber, wfAtmVclRcvTagging=wfAtmVclRcvTagging, wfAtmizerIntfTxPacketsOkWrap=wfAtmizerIntfTxPacketsOkWrap, wfAtmLmiTable=wfAtmLmiTable, wfAtmSigMaxPtPtConnections=wfAtmSigMaxPtPtConnections, wfAtmPlcpBipErrors=wfAtmPlcpBipErrors, wfSonetSectionCurrentEntry=wfSonetSectionCurrentEntry, wfAtmServiceRecordState=wfAtmServiceRecordState, wfAtmAlcCopRcvSarDropCells=wfAtmAlcCopRcvSarDropCells, wfAtmAlcCopRcvPackets=wfAtmAlcCopRcvPackets, wfAtmVbrCsVciVbrCct=wfAtmVbrCsVciVbrCct, wfAtmizerDebugParam1=wfAtmizerDebugParam1, wfAtmVclStatsTable=wfAtmVclStatsTable, wfAtmAlcCopRcvQueueEmptys=wfAtmAlcCopRcvQueueEmptys, wfAtmizerIntfTxLackBufCredits=wfAtmizerIntfTxLackBufCredits, wfAtmSigMinVciPtMltPt=wfAtmSigMinVciPtMltPt, wfAtmDxiLLIndex=wfAtmDxiLLIndex, wfSonetMediumCircuitIdentifier=wfSonetMediumCircuitIdentifier, wfAtmIlmiLocalPort=wfAtmIlmiLocalPort, wfAtmVclCellLossPriority=wfAtmVclCellLossPriority, wfAtmAlcFrmXmtExtMetaSig=wfAtmAlcFrmXmtExtMetaSig, wfAtmVbrCsVciLineNumber=wfAtmVbrCsVciLineNumber, wfAtmPvcDisable=wfAtmPvcDisable, wfSonetFarEndPathIntervalSESs=wfSonetFarEndPathIntervalSESs, wfAtmInterfaceConfIndex=wfAtmInterfaceConfIndex, wfAtmVclAdminStatus=wfAtmVclAdminStatus, wfAtmPvcTransmits=wfAtmPvcTransmits, wfAtmVclRcvBufferOflowErrs=wfAtmVclRcvBufferOflowErrs, wfAtmLmiCircuit=wfAtmLmiCircuit, wfAtmNetPrefixPort=wfAtmNetPrefixPort, wfSonetSectionCurrentIndex=wfSonetSectionCurrentIndex, wfAtmizerRxBuffersMax=wfAtmizerRxBuffersMax, wfAtmAlcSarModeAal=wfAtmAlcSarModeAal, wfAtmAlcFrmRcvDisUserCell=wfAtmAlcFrmRcvDisUserCell, wfSonetPathIntervalNumber=wfSonetPathIntervalNumber, wfAtmAlcFrmOamTxSectionAis=wfAtmAlcFrmOamTxSectionAis, wfAtmSigTable=wfAtmSigTable, wfAtmizerDebugParam2=wfAtmizerDebugParam2, wfAtmizerDebugCmdSize=wfAtmizerDebugCmdSize, wfAtmInterfaceLmiDisable=wfAtmInterfaceLmiDisable, wfAtmAlcCopXmtUserCells=wfAtmAlcCopXmtUserCells, wfSonetPathCurrentESs=wfSonetPathCurrentESs, wfAtmizerDebugParam3=wfAtmizerDebugParam3, wfAtmizerDrvCfgExtRate=wfAtmizerDrvCfgExtRate, wfAtmAlcXmtClipQueueMax=wfAtmAlcXmtClipQueueMax, wfAtmVbrSarCrc10Errors=wfAtmVbrSarCrc10Errors, wfAtmSscopArbitration=wfAtmSscopArbitration, wfAtmSscopLowThreshold=wfAtmSscopLowThreshold, wfAtmVclConfVpi=wfAtmVclConfVpi, wfAtmSscopEntry=wfAtmSscopEntry, wfAtmIlmiVpi=wfAtmIlmiVpi, wfAtmAlcXmtBadVcs=wfAtmAlcXmtBadVcs, wfAtmizerIntfRxCrcErrors=wfAtmizerIntfRxCrcErrors, wfAtmizerIntfPort=wfAtmizerIntfPort, wfAtmizerIntfTxCellsOk=wfAtmizerIntfTxCellsOk, wfAtmizerDrvCfgDs3LineBuildOut=wfAtmizerDrvCfgDs3LineBuildOut, wfAtmDxiDxiAddrLineNumber=wfAtmDxiDxiAddrLineNumber, wfSonetPathIntervalEntry=wfSonetPathIntervalEntry, wfAtmDelete=wfAtmDelete, wfSonetFarEndLineIntervalIndex=wfSonetFarEndLineIntervalIndex, wfAtmLmiState=wfAtmLmiState, wfAtmAlcXmtqIndex=wfAtmAlcXmtqIndex, wfAtmSscopIdleTimer=wfAtmSscopIdleTimer, wfAtmAlcSarTrafficMgtEntry=wfAtmAlcSarTrafficMgtEntry, wfAtmVclAalCpcsTransmitSduSize=wfAtmVclAalCpcsTransmitSduSize, wfAtmAlcSpeed=wfAtmAlcSpeed, wfAtmVclRcvMaxLenExceedErrs=wfAtmVclRcvMaxLenExceedErrs, wfAtmSscopUpThreshold=wfAtmSscopUpThreshold, wfAtmSVCOptionsAdjHostAtmAddr=wfAtmSVCOptionsAdjHostAtmAddr, wfAtmVbrCsVciMisdeliveredPdus=wfAtmVbrCsVciMisdeliveredPdus, wfAtmSigStandard=wfAtmSigStandard, wfAtmAlcFrmXmtGfcIgnore=wfAtmAlcFrmXmtGfcIgnore, wfAtmVclConfIndex=wfAtmVclConfIndex, wfAtm=wfAtm, wfAtmVbrCsEntry=wfAtmVbrCsEntry, wfAtmAlcFrmGenSyncFoundCnt=wfAtmAlcFrmGenSyncFoundCnt, wfAtmizerDrvCfgMtu=wfAtmizerDrvCfgMtu, wfAtmUniAtmHECs=wfAtmUniAtmHECs, wfAtmDxiAbortedFrames=wfAtmDxiAbortedFrames, wfAtmDxiDxiAddrIndex=wfAtmDxiDxiAddrIndex, wfAtmAlcFrmXmtDisF4EndEnd=wfAtmAlcFrmXmtDisF4EndEnd, wfAtmAlcFrmStatsForceDma=wfAtmAlcFrmStatsForceDma, wfAtmAlcFrmXmtOamCrcGen=wfAtmAlcFrmXmtOamCrcGen, wfSonetFarEndPathIntervalNumber=wfSonetFarEndPathIntervalNumber, wfAtmAlcCopDmaHighWatermark=wfAtmAlcCopDmaHighWatermark, wfAtmAlcFrmStatsSwEnable=wfAtmAlcFrmStatsSwEnable, wfAtmizerIntfRxOamCount=wfAtmizerIntfRxOamCount, wfAtmAlcFrmDmaChan4Enable=wfAtmAlcFrmDmaChan4Enable, wfAtmSigTimerResolution=wfAtmSigTimerResolution, wfAtmAlcXmtOctets=wfAtmAlcXmtOctets, wfAtmInterfaceMulticast=wfAtmInterfaceMulticast, wfAtmAlcSarConfIndex=wfAtmAlcSarConfIndex, wfAtmAlcCopRcvDropCells=wfAtmAlcCopRcvDropCells, wfAtmVbrSarEntry=wfAtmVbrSarEntry, wfAtmMpeInvalidSAP=wfAtmMpeInvalidSAP, wfAtmizerDrvCfgScrSum=wfAtmizerDrvCfgScrSum, wfAtmAlcCopDataPathEntry=wfAtmAlcCopDataPathEntry, wfSonetSectionCurrentSEFSs=wfSonetSectionCurrentSEFSs, wfAtmVclXmtPeakCellRate=wfAtmVclXmtPeakCellRate, wfAtmAlcCopRcvOamCells=wfAtmAlcCopRcvOamCells, wfAtmAlcCopInCellDelins=wfAtmAlcCopInCellDelins, wfAtmIlmiState=wfAtmIlmiState, wfAtmAlcCopPktMemSize=wfAtmAlcCopPktMemSize, wfAtmDxiFrameChecksumErrors=wfAtmDxiFrameChecksumErrors, wfAtmInterfaceType=wfAtmInterfaceType, wfAtmIlmiUpThreshold=wfAtmIlmiUpThreshold, wfAtmVbrSarComNoProcessErrors=wfAtmVbrSarComNoProcessErrors, wfAtmAlcDelete=wfAtmAlcDelete, wfAtmizerDrvCfgCct=wfAtmizerDrvCfgCct, wfAtmizerIntfOcdEvents=wfAtmizerIntfOcdEvents, wfAtmizerDrvCfgDelete=wfAtmizerDrvCfgDelete, wfAtmizerDrvCfgClkSource=wfAtmizerDrvCfgClkSource, wfAtmVbrSarCellLengthErrors=wfAtmVbrSarCellLengthErrors, wfAtmDxiDxiAddrDxiComponent=wfAtmDxiDxiAddrDxiComponent, wfAtmVclRcvOamCells=wfAtmVclRcvOamCells, wfAtmizerDrvCfgState=wfAtmizerDrvCfgState, wfAtmAlcFrmRcvExtIlmiSig=wfAtmAlcFrmRcvExtIlmiSig, wfAtmizerVclRxLackBufResc=wfAtmizerVclRxLackBufResc, wfAtmSscopConnectControlTimer=wfAtmSscopConnectControlTimer, wfAtmAlcFrmRcvErrCorrectEna=wfAtmAlcFrmRcvErrCorrectEna, wfAtmizerIntfTxFlowCtrlCount=wfAtmizerIntfTxFlowCtrlCount, wfAtmizerIntfRxLackPageResc=wfAtmizerIntfRxLackPageResc, wfAtmizerVclTxOamCount=wfAtmizerVclTxOamCount, wfAtmAlcFrmCsiRcvCongBitOpt=wfAtmAlcFrmCsiRcvCongBitOpt, wfSonetSectionIntervalTable=wfSonetSectionIntervalTable, wfAtmVclRcvInvalidLenErrs=wfAtmVclRcvInvalidLenErrs, wfAtmMpeNull=wfAtmMpeNull, wfAtmAlcSarTimeoutCtrInt=wfAtmAlcSarTimeoutCtrInt, wfAtmVbrCsVciLLIndex=wfAtmVbrCsVciLLIndex, wfAtmSigMaxPtMultConnections=wfAtmSigMaxPtMultConnections, wfAtmAlcConfXmtClipQueueMax=wfAtmAlcConfXmtClipQueueMax, wfAtmizerIntfRxCrc10Errors=wfAtmizerIntfRxCrc10Errors, wfAtmTableDebugEntry=wfAtmTableDebugEntry, wfSonetSectionCurrentSESs=wfSonetSectionCurrentSESs, wfAtmizerDrvCfgPort=wfAtmizerDrvCfgPort, wfAtmizerIntfHecDetectedCount=wfAtmizerIntfHecDetectedCount, wfSonetLineIntervalUASs=wfSonetLineIntervalUASs, wfAtmDxiDxiAddrReceives=wfAtmDxiDxiAddrReceives, wfSonetLineIntervalESs=wfSonetLineIntervalESs, wfAtmAlcXmtClipSlotMax=wfAtmAlcXmtClipSlotMax, wfAtmVclXmtBurstSize=wfAtmVclXmtBurstSize, wfAtmizerVclRxOamCount=wfAtmizerVclRxOamCount, wfAtmAlcCopXmtCells=wfAtmAlcCopXmtCells, wfAtmSVCOptionsIndex=wfAtmSVCOptionsIndex, wfAtmVbrCsVciEntry=wfAtmVbrCsVciEntry, wfAtmAlcFrmRcvDescrambleCtl=wfAtmAlcFrmRcvDescrambleCtl, wfAtmAlcCopF1Febes=wfAtmAlcCopF1Febes, wfAtmAlcFrmXmtDisUnassCell=wfAtmAlcFrmXmtDisUnassCell, wfAtmAlcFrmStatsMask=wfAtmAlcFrmStatsMask, wfAtmInterfaceIlmiVci=wfAtmInterfaceIlmiVci, wfAtmTableDebugDelete=wfAtmTableDebugDelete, wfAtmVclRcvPeakCellRate=wfAtmVclRcvPeakCellRate, wfSonetLineCurrentCVs=wfSonetLineCurrentCVs, wfAtmUniAtmLLIndex=wfAtmUniAtmLLIndex, wfAtmGlobalSigStkVersion=wfAtmGlobalSigStkVersion, wfAtmVclXmtRateDecreaseFactor=wfAtmVclXmtRateDecreaseFactor, wfSonetFarEndPathCurrentESs=wfSonetFarEndPathCurrentESs, wfAtmVcGroupTable=wfAtmVcGroupTable)
mibBuilder.exportSymbols("Wellfleet-ATM-MIB", wfAtmAlcCopConfIndex=wfAtmAlcCopConfIndex, wfAtmAlcFrmRcvDisF5Segment=wfAtmAlcFrmRcvDisF5Segment, wfAtmAlcCopConfEntry=wfAtmAlcCopConfEntry, wfSonetFarEndLineCurrentCVs=wfSonetFarEndLineCurrentCVs, wfAtmLmiNoVCErrors=wfAtmLmiNoVCErrors, wfAtmAlcCopInsMemSize=wfAtmAlcCopInsMemSize, wfAtmizerVclRxOctets=wfAtmizerVclRxOctets, wfAtmizerIntfRxLackBufResc=wfAtmizerIntfRxLackBufResc, wfAtmizerDebugCmd=wfAtmizerDebugCmd, wfAtmIlmiSetRetryCnt=wfAtmIlmiSetRetryCnt, wfAtmAlcCopHwIndex=wfAtmAlcCopHwIndex, wfAtmAlcXmtqNumber=wfAtmAlcXmtqNumber, wfAtmVclRcvAbortErrs=wfAtmVclRcvAbortErrs, wfAtmAlcCopHecDetects=wfAtmAlcCopHecDetects, wfAtmizerIntfSlot=wfAtmizerIntfSlot, wfAtmAlcInterfaceStatus=wfAtmAlcInterfaceStatus, wfAtmAlcFrmRcvHecRcvMask=wfAtmAlcFrmRcvHecRcvMask, wfAtmInterfaceConfEntry=wfAtmInterfaceConfEntry, wfAtmDxiTable=wfAtmDxiTable, wfAtmInterfaceAddressType=wfAtmInterfaceAddressType, wfAtmAlcCopDmaLowWatermark=wfAtmAlcCopDmaLowWatermark, wfAtmSigMaxServiceUsers=wfAtmSigMaxServiceUsers, wfAtmServiceRecordAtmAddress=wfAtmServiceRecordAtmAddress, wfAtmNetPrefixTable=wfAtmNetPrefixTable, wfAtmUniCct=wfAtmUniCct, wfAtmAlcCopTotalBufs=wfAtmAlcCopTotalBufs, wfAtmAlcFrmRcvGfcIgnore=wfAtmAlcFrmRcvGfcIgnore, wfAtmizerDrvCfgDs3Scrambling=wfAtmizerDrvCfgDs3Scrambling, wfAtmizerIntfRxOctets=wfAtmizerIntfRxOctets, wfAtmVbrSarEomNoProcessErrors=wfAtmVbrSarEomNoProcessErrors, wfAtmInterfaceUseHwMacAddr=wfAtmInterfaceUseHwMacAddr, wfAtmInterfaceDescr=wfAtmInterfaceDescr, wfAtmSigMaxVpiPtMltPt=wfAtmSigMaxVpiPtMltPt, wfAtmAlcConfRcvBuffersMax=wfAtmAlcConfRcvBuffersMax, wfAtmAlcFrmRcvExtMetaSig=wfAtmAlcFrmRcvExtMetaSig, wfSonetLineCurrentUASs=wfSonetLineCurrentUASs, wfAtmPlcpLineNumber=wfAtmPlcpLineNumber, wfAtmizerIntfLastChange=wfAtmizerIntfLastChange, wfAtmizerVclRxInvalidHeaders=wfAtmizerVclRxInvalidHeaders, wfAtmAlcCopB3Febes=wfAtmAlcCopB3Febes, wfAtmVclConfVci=wfAtmVclConfVci, wfAtmizerIntfTcAlarmState=wfAtmizerIntfTcAlarmState, wfSonetMediumEntry=wfSonetMediumEntry, wfAtmAlcSarPeakCellRateEna=wfAtmAlcSarPeakCellRateEna, wfAtmVclRcvMissingEomErrs=wfAtmVclRcvMissingEomErrs, wfSonetSectionCurrentESs=wfSonetSectionCurrentESs, wfAtmUniEntry=wfAtmUniEntry, wfAtmVcGroupIndex=wfAtmVcGroupIndex, wfAtmAlcCopOutCellDelins=wfAtmAlcCopOutCellDelins, wfAtmizerVclRxCellsOk=wfAtmizerVclRxCellsOk, wfAtmVclStatsVpi=wfAtmVclStatsVpi, wfAtmizerVclTxPacketsOk=wfAtmizerVclTxPacketsOk, wfAtmVbrLLIndex=wfAtmVbrLLIndex, wfAtmSigMinBufferThreshold=wfAtmSigMinBufferThreshold, wfAtmDxiCct=wfAtmDxiCct, wfAtmAlcXmtqEntry=wfAtmAlcXmtqEntry, wfAtmServiceRecordTable=wfAtmServiceRecordTable, wfSonetLineCurrentIndex=wfSonetLineCurrentIndex, wfAtmAlcFrmXmtExtPointSig=wfAtmAlcFrmXmtExtPointSig, wfAtmServicePqOverride=wfAtmServicePqOverride, wfAtmVbrCsVciOctetReceives=wfAtmVbrCsVciOctetReceives, wfAtmInterfaceMaxVccs=wfAtmInterfaceMaxVccs, wfAtmVclMode=wfAtmVclMode, wfAtmIlmiSetTimer=wfAtmIlmiSetTimer, wfAtmAlcSarModeHec=wfAtmAlcSarModeHec, wfAtmAlcSarRateQueueEntry=wfAtmAlcSarRateQueueEntry, wfAtmPlcpLofCFA=wfAtmPlcpLofCFA, wfAtmAlcFrmGenLoopback=wfAtmAlcFrmGenLoopback, wfAtmizerDebugRxDone=wfAtmizerDebugRxDone, wfSonetPathIntervalSESs=wfSonetPathIntervalSESs, wfAtmVbrSarLengthExceeds=wfAtmVbrSarLengthExceeds, wfAtmInterfaceIlmiVpi=wfAtmInterfaceIlmiVpi, wfAtmVclRcvCells=wfAtmVclRcvCells, wfAtmAlcSarRateQueuePcr=wfAtmAlcSarRateQueuePcr, wfAtmAlcFrmXmtDisIlmiSig=wfAtmAlcFrmXmtDisIlmiSig, wfAtmServiceRecordDelete=wfAtmServiceRecordDelete, wfAtmizerVclTxLackBufCredits=wfAtmizerVclTxLackBufCredits, wfAtmSscopLineNumber=wfAtmSscopLineNumber, wfAtmVbrCsVciOctetTransmits=wfAtmVbrCsVciOctetTransmits, wfAtmAlcLastChange=wfAtmAlcLastChange, wfAtmAlcFrmCsiRcvHecMask=wfAtmAlcFrmCsiRcvHecMask, wfAtmTableDebugSlot=wfAtmTableDebugSlot, wfAtmAlcConfIntqSize=wfAtmAlcConfIntqSize, wfAtmAlcFrmDmaChan0Enable=wfAtmAlcFrmDmaChan0Enable, wfAtmUniPhysical=wfAtmUniPhysical, wfAtmAlcRcvBuffersMax=wfAtmAlcRcvBuffersMax, wfAtmSscopDisable=wfAtmSscopDisable, wfAtmAlcSarModeDmask=wfAtmAlcSarModeDmask, wfAtmDxiComponent=wfAtmDxiComponent, wfAtmizerDebugParam9=wfAtmizerDebugParam9, wfAtmServiceRecordWanSvcRoutingMode=wfAtmServiceRecordWanSvcRoutingMode, wfAtmAlcSarRateQueueVcs=wfAtmAlcSarRateQueueVcs, wfAtmSigT322=wfAtmSigT322, wfAtmAlcXmtClipQueueMin=wfAtmAlcXmtClipQueueMin, wfAtmizerDebugParam10=wfAtmizerDebugParam10, wfAtmAlcRcvReplenMisses=wfAtmAlcRcvReplenMisses, wfAtmAlcFrmRcvCellInsPrio=wfAtmAlcFrmRcvCellInsPrio, wfAtmVclConfTable=wfAtmVclConfTable, wfAtmVbrSarLLIndex=wfAtmVbrSarLLIndex, wfAtmAlcSarModeAm=wfAtmAlcSarModeAm, wfSonetPathCurrentStatus=wfSonetPathCurrentStatus, wfAtmSigTDisc=wfAtmSigTDisc, wfAtmPvcLLIndex=wfAtmPvcLLIndex, wfAtmCsNull=wfAtmCsNull, wfAtmIlmiDebug=wfAtmIlmiDebug, wfAtmSigT313=wfAtmSigT313, wfAtmAlcSarAvgCellRate=wfAtmAlcSarAvgCellRate, wfAtmVbrSarCellMidErrors=wfAtmVbrSarCellMidErrors, wfAtmizerIntfTxOverSizedSDUs=wfAtmizerIntfTxOverSizedSDUs, wfSonetFarEndLineCurrentTable=wfSonetFarEndLineCurrentTable, wfSonetLineCurrentTable=wfSonetLineCurrentTable, wfAtmDxiMaxLmiPduLengthErrors=wfAtmDxiMaxLmiPduLengthErrors, wfAtmDxiEntry=wfAtmDxiEntry, wfAtmVclVcIndex=wfAtmVclVcIndex, wfAtmizerDrvCfgFramingMode=wfAtmizerDrvCfgFramingMode, wfAtmizerIntfRxLackPageCredits=wfAtmizerIntfRxLackPageCredits, wfAtmizerDebugParam4=wfAtmizerDebugParam4, wfAtmAlcCopXmtOctets=wfAtmAlcCopXmtOctets, wfAtmDxiFrameTransmits=wfAtmDxiFrameTransmits, wfAtmSigMinVpiPtPt=wfAtmSigMinVpiPtPt, wfAtmAlcRcvPackets=wfAtmAlcRcvPackets, wfSonetMediumTable=wfSonetMediumTable, wfAtmAlcCopRcvUnassCells=wfAtmAlcCopRcvUnassCells, wfAtmAlcCopRcvIdleCells=wfAtmAlcCopRcvIdleCells, wfAtmInterfacePlcp=wfAtmInterfacePlcp, wfAtmAlcCopRcvAtes=wfAtmAlcCopRcvAtes, wfAtmVclRcvSequenceNumErrs=wfAtmVclRcvSequenceNumErrs, wfAtmizerRxPagesMax=wfAtmizerRxPagesMax, wfAtmPlcpLof=wfAtmPlcpLof, wfAtmizerDrvCfgMaxVcls=wfAtmizerDrvCfgMaxVcls, wfAtmVbrSarTimeouts=wfAtmVbrSarTimeouts, wfAtmVbrCsVciIndex=wfAtmVbrCsVciIndex, wfAtmAlcCopF3Febes=wfAtmAlcCopF3Febes, wfAtmAlcFrmXmtDisF5EndEnd=wfAtmAlcFrmXmtDisF5EndEnd, wfAtmVcGroupName=wfAtmVcGroupName, wfAtmizerDebugRxValue=wfAtmizerDebugRxValue, wfAtmVbrDxi=wfAtmVbrDxi, wfAtmizerDrvCfgCurrVcls=wfAtmizerDrvCfgCurrVcls, wfAtmAlcCopConfigState=wfAtmAlcCopConfigState, wfAtmAlcFrmDmaStop=wfAtmAlcFrmDmaStop, wfAtmAlcCopDropIntqEvents=wfAtmAlcCopDropIntqEvents, wfAtmAlcFrmGenSyncLostCnt=wfAtmAlcFrmGenSyncLostCnt, wfAtmAlcSarDmaModeMmode=wfAtmAlcSarDmaModeMmode, wfAtmAlcSarDmaBurstLength=wfAtmAlcSarDmaBurstLength, wfAtmizerCfgHeartbeatPeriod=wfAtmizerCfgHeartbeatPeriod, wfSonetPathIntervalCVs=wfSonetPathIntervalCVs, wfAtmAlcFrmXmtOamCrcCheck=wfAtmAlcFrmXmtOamCrcCheck, wfAtmAlcXmtqOutQLen=wfAtmAlcXmtqOutQLen, wfAtmIlmiNetPrefixTimer=wfAtmIlmiNetPrefixTimer, wfAtmLmiLLIndex=wfAtmLmiLLIndex, wfAtmIlmiGetTimer=wfAtmIlmiGetTimer, wfAtmAlcSarModeBas=wfAtmAlcSarModeBas, wfSonetSectionIntervalSEFSs=wfSonetSectionIntervalSEFSs, wfAtmSigNumStat=wfAtmSigNumStat, wfAtmAlcFrmStatsTimeout=wfAtmAlcFrmStatsTimeout, wfAtmAlcVcInactEnable=wfAtmAlcVcInactEnable, wfAtmDxiDxiAddrDxiCct=wfAtmDxiDxiAddrDxiCct, wfAtmAlcCopLossFrames=wfAtmAlcCopLossFrames, wfAtmAlcFrmGenScramblerEna=wfAtmAlcFrmGenScramblerEna, wfAtmDxiNonOctetAlignedFrames=wfAtmDxiNonOctetAlignedFrames, wfAtmAlcFrmXmtExtF5Segment=wfAtmAlcFrmXmtExtF5Segment, wfAtmizerCfgTable=wfAtmizerCfgTable, wfAtmAlcXmtQueueBurst=wfAtmAlcXmtQueueBurst, wfAtmizerTxBuffersMax=wfAtmizerTxBuffersMax, wfAtmAlcFrmStatsMode=wfAtmAlcFrmStatsMode, wfAtmVclAalType=wfAtmVclAalType, wfSonetMediumType=wfSonetMediumType, wfAtmSscopKeepAliveTimer=wfAtmSscopKeepAliveTimer, wfAtmAlcCopRcvErrBuffers=wfAtmAlcCopRcvErrBuffers, wfAtmVclRcvPacketLengthErrs=wfAtmVclRcvPacketLengthErrs, wfAtmInterfaceCct=wfAtmInterfaceCct, wfAtmVclXmtRateIncreaseFactor=wfAtmVclXmtRateIncreaseFactor, wfAtmVbrSarCsPduSizeTooBigErrors=wfAtmVbrSarCsPduSizeTooBigErrors, wfAtmAlcFrmCsiRcvAtcEnable=wfAtmAlcFrmCsiRcvAtcEnable, wfAtmizerVclRxAbortMessages=wfAtmizerVclRxAbortMessages, wfAtmAlcFrmDmaFastXferMode=wfAtmAlcFrmDmaFastXferMode, wfAtmInterfaceEntry=wfAtmInterfaceEntry, wfAtmDxiDxiAddrAtmVbr=wfAtmDxiDxiAddrAtmVbr, wfAtmPlcpSeconds=wfAtmPlcpSeconds, wfAtmizerVclStatsTable=wfAtmizerVclStatsTable, wfAtmIlmiLocalOid=wfAtmIlmiLocalOid, wfAtmAlcFrmRcvDisIlmiSig=wfAtmAlcFrmRcvDisIlmiSig, wfSonetSectionIntervalSESs=wfSonetSectionIntervalSESs, wfAtmAlcCopInfoEntry=wfAtmAlcCopInfoEntry, wfAtmizerVclTxOverSizedSDUs=wfAtmizerVclTxOverSizedSDUs, wfSonetLineIntervalTable=wfSonetLineIntervalTable, wfAtmSVCOptionsCct=wfAtmSVCOptionsCct, wfAtmAlcSarAvgCellRateEna=wfAtmAlcSarAvgCellRateEna, wfAtmizerVclRxLackBufCredits=wfAtmizerVclRxLackBufCredits, wfSonetFarEndPathIntervalEntry=wfSonetFarEndPathIntervalEntry, wfAtmizerIntfTxPacketsOk=wfAtmizerIntfTxPacketsOk, wfAtmAlcXmtqOctets=wfAtmAlcXmtqOctets, wfAtmAlcXmtqPackets=wfAtmAlcXmtqPackets, wfAtmInterfaceDebug=wfAtmInterfaceDebug, wfAtmizerDebugParam7=wfAtmizerDebugParam7, wfSonetFarEndLineIntervalESs=wfSonetFarEndLineIntervalESs, wfAtmPlcpBipESecs=wfAtmPlcpBipESecs, wfAtmizerVclRxSequenceNumberErrors=wfAtmizerVclRxSequenceNumberErrors, wfAtmPvcCct=wfAtmPvcCct, wfAtmPlcpCct=wfAtmPlcpCct, wfAtmLmiEntry=wfAtmLmiEntry, wfAtmAlcFrmRcvDisF4EndEnd=wfAtmAlcFrmRcvDisF4EndEnd, wfAtmAlcSarTrafficMgtIndex=wfAtmAlcSarTrafficMgtIndex, wfAtmAlcSarDmaModeOrder=wfAtmAlcSarDmaModeOrder, wfSonetMediumIndex=wfSonetMediumIndex, wfAtmAlcXmtqState=wfAtmAlcXmtqState, wfAtmVclAalEncapsType=wfAtmVclAalEncapsType, wfAtmAlcCopLossPointers=wfAtmAlcCopLossPointers, wfAtmPlcpTable=wfAtmPlcpTable, wfAtmAlcFrmConfDelete=wfAtmAlcFrmConfDelete, wfAtmAlcLineNumber=wfAtmAlcLineNumber, wfAtmPlcpFebeSESecs=wfAtmPlcpFebeSESecs, wfAtmAlcSarModeBchain=wfAtmAlcSarModeBchain, wfAtmAlcFrmGenDescrambleEna=wfAtmAlcFrmGenDescrambleEna, wfAtmAlcFrmXmtCellDecouple=wfAtmAlcFrmXmtCellDecouple, wfAtmAlcFrmCsiRcvClpBitOpt=wfAtmAlcFrmCsiRcvClpBitOpt, wfAtmizerDrvCfgLogLevel=wfAtmizerDrvCfgLogLevel, wfAtmInterfaceCircuit=wfAtmInterfaceCircuit, wfAtmSscopNoResponseTimer=wfAtmSscopNoResponseTimer, wfSonetSectionIntervalIndex=wfSonetSectionIntervalIndex, wfSonetLineIntervalEntry=wfSonetLineIntervalEntry, wfAtmAlcCopAtcVersion=wfAtmAlcCopAtcVersion, wfAtmSigT316=wfAtmSigT316, wfAtmAlcFrmOamInvertBip=wfAtmAlcFrmOamInvertBip, wfAtmizerIntfRxCellsOkWrap=wfAtmizerIntfRxCellsOkWrap, wfAtmSVCOptionsRcvPeakCellRate=wfAtmSVCOptionsRcvPeakCellRate, wfAtmAlcFrmXmtHecXmtMask=wfAtmAlcFrmXmtHecXmtMask, wfAtmDxiDxiAddrEntry=wfAtmDxiDxiAddrEntry, wfAtmMpeIndex=wfAtmMpeIndex, wfAtmizerIntfRxAbortMessages=wfAtmizerIntfRxAbortMessages, wfAtmizerVclTxCellsOkWrap=wfAtmizerVclTxCellsOkWrap, wfAtmVclDirectAccessCct=wfAtmVclDirectAccessCct, wfAtmPvcTable=wfAtmPvcTable, wfAtmServiceRecordAalEncapsType=wfAtmServiceRecordAalEncapsType, wfAtmVclRcvCrcErrs=wfAtmVclRcvCrcErrs, wfAtmAlcSarTimeoutCtrPeriod=wfAtmAlcSarTimeoutCtrPeriod, wfAtmizerCfgTxVcBuffersMax=wfAtmizerCfgTxVcBuffersMax, wfAtmDxiDxiAddrLLIndex=wfAtmDxiDxiAddrLLIndex, wfAtmAlcFrmXmtExtIlmiSig=wfAtmAlcFrmXmtExtIlmiSig, wfAtmizerVclVpi=wfAtmizerVclVpi, wfAtmAlcFrmXmtInsertPcr=wfAtmAlcFrmXmtInsertPcr, wfAtmMpeInvalidOuis=wfAtmMpeInvalidOuis, wfAtmVbrTable=wfAtmVbrTable, wfAtmAlcFrmCsiEnable=wfAtmAlcFrmCsiEnable, wfAtmSigT399=wfAtmSigT399, wfAtmizerDrvCfgIwfCct=wfAtmizerDrvCfgIwfCct, wfAtmVcGroupEntry=wfAtmVcGroupEntry, wfAtmVclStatsVcIndex=wfAtmVclStatsVcIndex, wfAtmAlcCopRcvBuffers=wfAtmAlcCopRcvBuffers, wfSonetFarEndLineCurrentUASs=wfSonetFarEndLineCurrentUASs, wfAtmizerVclRxLackPageCredits=wfAtmizerVclRxLackPageCredits, wfAtmSigMaxVciPtPt=wfAtmSigMaxVciPtPt, wfAtmUniAtmNullCells=wfAtmUniAtmNullCells, wfAtmAlcFrmRcvExtF4Segment=wfAtmAlcFrmRcvExtF4Segment)
mibBuilder.exportSymbols("Wellfleet-ATM-MIB", wfAtmAlcFrmRcvDisF5EndEnd=wfAtmAlcFrmRcvDisF5EndEnd, wfAtmAlcFrmCsiXmtAtcEnable=wfAtmAlcFrmCsiXmtAtcEnable, wfAtmAlcFrmGenEnable=wfAtmAlcFrmGenEnable, wfAtmAlcFrmDmaEnable=wfAtmAlcFrmDmaEnable, wfAtmIlmiVci=wfAtmIlmiVci, wfSonetPathIntervalUASs=wfSonetPathIntervalUASs, wfAtmizerCfgRxBuffersMax=wfAtmizerCfgRxBuffersMax, wfAtmAlcSarDmaModeBw=wfAtmAlcSarDmaModeBw, wfAtmAlcSarPeakCellRate=wfAtmAlcSarPeakCellRate, wfAtmPvcMpeNull=wfAtmPvcMpeNull, wfAtmVclOamLpbkCellInterval=wfAtmVclOamLpbkCellInterval, wfAtmInterfaceMaxActiveVpiBits=wfAtmInterfaceMaxActiveVpiBits, wfAtmAlcCopNtcVersion=wfAtmAlcCopNtcVersion, wfAtmUniAtmTable=wfAtmUniAtmTable, wfSonetPathCurrentEntry=wfSonetPathCurrentEntry, wfAtmNetPrefixStatus=wfAtmNetPrefixStatus, wfAtmAlcCopCacheControl=wfAtmAlcCopCacheControl, wfAtmInterfaceDxiMode=wfAtmInterfaceDxiMode, wfAtmInterfaceMaxActiveVciBits=wfAtmInterfaceMaxActiveVciBits, wfAtmSigT308=wfAtmSigT308, wfAtmAlcFrmStatsTimerEna=wfAtmAlcFrmStatsTimerEna, wfAtmizerVclRxPacketsOk=wfAtmizerVclRxPacketsOk, wfAtmVbrCsTable=wfAtmVbrCsTable, wfAtmAlcFrmXmtExtF4EndEnd=wfAtmAlcFrmXmtExtF4EndEnd, wfAtmizerDrvCfgTable=wfAtmizerDrvCfgTable, wfAtmAlcFrmCsiXmtCongBitOpt=wfAtmAlcFrmCsiXmtCongBitOpt, wfAtmAlcCopRcvUserCells=wfAtmAlcCopRcvUserCells, wfAtmizerDrvCfgMadrCt=wfAtmizerDrvCfgMadrCt, wfSonetFarEndPathCurrentSESs=wfSonetFarEndPathCurrentSESs, wfSonetFarEndPathCurrentUASs=wfSonetFarEndPathCurrentUASs, wfAtmIlmiLowThreshold=wfAtmIlmiLowThreshold, wfSonetMediumTimeElapsed=wfSonetMediumTimeElapsed, wfAtmPlcpPhysical=wfAtmPlcpPhysical, wfAtmVcGroupDelete=wfAtmVcGroupDelete, wfAtmAlcFrmCsiRoutingTag=wfAtmAlcFrmCsiRoutingTag, wfAtmVclVcType=wfAtmVclVcType, wfAtmMpeInvalidNlpids=wfAtmMpeInvalidNlpids, wfAtmizerTxPagesMax=wfAtmizerTxPagesMax, wfAtmSVCOptionsName=wfAtmSVCOptionsName, wfAtmAlcConfXmtClipQueueMin=wfAtmAlcConfXmtClipQueueMin, wfAtmDxiTooShortFrames=wfAtmDxiTooShortFrames, wfAtmAlcFrmRcvExtBcastSig=wfAtmAlcFrmRcvExtBcastSig, wfAtmAlcFrmOamEnable=wfAtmAlcFrmOamEnable, wfSonetLineCurrentEntry=wfSonetLineCurrentEntry, wfAtmAlcCopXmtUnassCells=wfAtmAlcCopXmtUnassCells, wfAtmSigRestart=wfAtmSigRestart, wfAtmSigDebug=wfAtmSigDebug, wfAtmAlcCopRcvSarDropBuffers=wfAtmAlcCopRcvSarDropBuffers, wfAtmAlcFrmRcvOamCrcGen=wfAtmAlcFrmRcvOamCrcGen, wfAtmInterfaceMaxVpcs=wfAtmInterfaceMaxVpcs, wfAtmAlcXmtqPacketClips=wfAtmAlcXmtqPacketClips, wfAtmDxiDxiAddrTransmits=wfAtmDxiDxiAddrTransmits, wfAtmSscopMaxPd=wfAtmSscopMaxPd, wfAtmSigT301=wfAtmSigT301, wfAtmizerVclRxOverSizedSDUs=wfAtmizerVclRxOverSizedSDUs, wfAtmAlcCopXmtBuffers=wfAtmAlcCopXmtBuffers, wfSonetFarEndLineCurrentEntry=wfSonetFarEndLineCurrentEntry, wfAtmUniAtmEntry=wfAtmUniAtmEntry, wfAtmizerDebugParam8=wfAtmizerDebugParam8, wfAtmSigT303=wfAtmSigT303, wfAtmAlcFrmXmtDisPointSig=wfAtmAlcFrmXmtDisPointSig, wfAtmAlcFrmRcvDisUnassCell=wfAtmAlcFrmRcvDisUnassCell, wfAtmIlmiAtmCct=wfAtmIlmiAtmCct, wfAtmSigMinVpiPtMltPt=wfAtmSigMinVpiPtMltPt, wfAtmLmiCsuDsuTraps=wfAtmLmiCsuDsuTraps, wfAtmSigState=wfAtmSigState, wfAtmVbrCsVciReceives=wfAtmVbrCsVciReceives, wfAtmInterfaceTable=wfAtmInterfaceTable, wfAtmAlcInterfaceIndex=wfAtmAlcInterfaceIndex, wfAtmAlcFrmOamTxPathFebe=wfAtmAlcFrmOamTxPathFebe, wfSonetFarEndLineIntervalSESs=wfSonetFarEndLineIntervalSESs, wfAtmizerDrvCfgSlot=wfAtmizerDrvCfgSlot, wfAtmAlcFrmDmaChan1Enable=wfAtmAlcFrmDmaChan1Enable, wfAtmAlcSarMaxBurstSize=wfAtmAlcSarMaxBurstSize, wfAtmAlcFrmXmtExtF4F5PrfMan=wfAtmAlcFrmXmtExtF4F5PrfMan, wfSonetSectionIntervalCVs=wfSonetSectionIntervalCVs, wfSonetFarEndPathCurrentCVs=wfSonetFarEndPathCurrentCVs, wfSonetFarEndPathIntervalIndex=wfSonetFarEndPathIntervalIndex, wfAtmAlcCct=wfAtmAlcCct, wfAtmAlcFrmCsiRcvHecEnable=wfAtmAlcFrmCsiRcvHecEnable, wfAtmAlcCopG1Febes=wfAtmAlcCopG1Febes, wfAtmSigCallsSec=wfAtmSigCallsSec, wfAtmLmiOtherErrors=wfAtmLmiOtherErrors, wfAtmSigT304=wfAtmSigT304, wfAtmVbrSarCellSequenceErrors=wfAtmVbrSarCellSequenceErrors, wfSonetFarEndPathCurrentTable=wfSonetFarEndPathCurrentTable, wfAtmSigLineNumber=wfAtmSigLineNumber, wfAtmAlcFrmStatsOflowEna=wfAtmAlcFrmStatsOflowEna, wfAtmAlcFrmRcvExtF5Segment=wfAtmAlcFrmRcvExtF5Segment, wfAtmAlcSarTrafficMgtDelete=wfAtmAlcSarTrafficMgtDelete, wfAtmAlcFrmCsiOmitHec=wfAtmAlcFrmCsiOmitHec, wfSonetPathCurrentTable=wfSonetPathCurrentTable, wfAtmPlcpYellowCFA=wfAtmPlcpYellowCFA, wfAtmizerDrvCfgDsx3LoopbackConfig=wfAtmizerDrvCfgDsx3LoopbackConfig, wfAtmizerIntfRxLackBufCredits=wfAtmizerIntfRxLackBufCredits, wfAtmVclStatsIndex=wfAtmVclStatsIndex, wfAtmAlcSarConfDelete=wfAtmAlcSarConfDelete, wfAtmPvcDirectAccessCct=wfAtmPvcDirectAccessCct, wfAtmizerTxPerVcClipEnable=wfAtmizerTxPerVcClipEnable, wfAtmPvcVci=wfAtmPvcVci, wfAtmIlmiLineNumber=wfAtmIlmiLineNumber, wfAtmAlcDpNotify=wfAtmAlcDpNotify, wfSonetFarEndLineIntervalEntry=wfSonetFarEndLineIntervalEntry, wfAtmPlcpFrameErrors=wfAtmPlcpFrameErrors, wfAtmizerVclStatsEntry=wfAtmizerVclStatsEntry, wfAtmSigMinVciPtPt=wfAtmSigMinVciPtPt, wfAtmAlcPort=wfAtmAlcPort, wfSonetFarEndPathIntervalUASs=wfSonetFarEndPathIntervalUASs, wfAtmAlcCopB2Febes=wfAtmAlcCopB2Febes, wfAtmDxiSeconds=wfAtmDxiSeconds, wfAtmVbrCsBETagMismatches=wfAtmVbrCsBETagMismatches, wfAtmizerDrvCfgVcInactTimeout=wfAtmizerDrvCfgVcInactTimeout, wfAtmAlcFrmCsiXmtAte=wfAtmAlcFrmCsiXmtAte, wfAtmSigT398=wfAtmSigT398, wfAtmUniLLIndex=wfAtmUniLLIndex, wfAtmVbrAtmUni=wfAtmVbrAtmUni, wfSonetLineIntervalCVs=wfSonetLineIntervalCVs, wfAtmPvcVpi=wfAtmPvcVpi, wfAtmInterfaceVCsInUse=wfAtmInterfaceVCsInUse, wfAtmAlcConfNumXmtQueues=wfAtmAlcConfNumXmtQueues, wfAtmizerIntfStatus=wfAtmizerIntfStatus, wfAtmServiceRecordEnable=wfAtmServiceRecordEnable, wfAtmIlmiInterfaceType=wfAtmIlmiInterfaceType, wfAtmAlcCopRcvCells=wfAtmAlcCopRcvCells, wfAtmAlcFrmRcvExtF4EndEnd=wfAtmAlcFrmRcvExtF4EndEnd, wfAtmPlcpFebes=wfAtmPlcpFebes, wfAtmizerIntfRxCellsOk=wfAtmizerIntfRxCellsOk, wfAtmSigEntry=wfAtmSigEntry, wfAtmAlcSarDmaModeCmode=wfAtmAlcSarDmaModeCmode, wfAtmAlcFrmXmtDisMetaSig=wfAtmAlcFrmXmtDisMetaSig, wfAtmUniAtmReceives=wfAtmUniAtmReceives, wfAtmizerVclIndex=wfAtmizerVclIndex, wfAtmSVCOptionsDisable=wfAtmSVCOptionsDisable, wfAtmizerDrvCfgVcInactEnable=wfAtmizerDrvCfgVcInactEnable, wfAtmVbrSarAssemblyTimer=wfAtmVbrSarAssemblyTimer, wfAtmVbrCsLineNumber=wfAtmVbrCsLineNumber, wfAtmAlcCopErrorIndex=wfAtmAlcCopErrorIndex, wfAtmMpeUnsupportedControlFields=wfAtmMpeUnsupportedControlFields, wfAtmDxiDxiAddrVpiVci=wfAtmDxiDxiAddrVpiVci, wfAtmizerCfgTxPercentRsrcs=wfAtmizerCfgTxPercentRsrcs, wfAtmSscopAtmCct=wfAtmSscopAtmCct, wfAtmAlcXmtPackets=wfAtmAlcXmtPackets, wfAtmizerIntfTxCellsOkWrap=wfAtmizerIntfTxCellsOkWrap, wfAtmAlcSarModeRtmr=wfAtmAlcSarModeRtmr, wfSonetPathCurrentUASs=wfSonetPathCurrentUASs, wfAtmAlcCopDropLogqEvents=wfAtmAlcCopDropLogqEvents, wfAtmInterfaceConfVpcs=wfAtmInterfaceConfVpcs, wfAtmizerIntfIndex=wfAtmizerIntfIndex, wfSonetPathCurrentIndex=wfSonetPathCurrentIndex, wfAtmAlcCopInfoTable=wfAtmAlcCopInfoTable, wfAtmServiceRecordName=wfAtmServiceRecordName, wfAtmizerVclTxPacketsOkWrap=wfAtmizerVclTxPacketsOkWrap, wfAtmDrops=wfAtmDrops, wfSonetPathIntervalTable=wfSonetPathIntervalTable, wfAtmAlcSarModeDchain=wfAtmAlcSarModeDchain, wfAtmAlcFrmConfIndex=wfAtmAlcFrmConfIndex, wfAtmSVCOptionsDelete=wfAtmSVCOptionsDelete, wfAtmizerDrvCfgLineNumber=wfAtmizerDrvCfgLineNumber, wfAtmAlcFrmDmaChan3Enable=wfAtmAlcFrmDmaChan3Enable, wfAtmVcGroupCct=wfAtmVcGroupCct, wfAtmizerIntfTxDrvClipCount=wfAtmizerIntfTxDrvClipCount, wfAtmVclXmtTagging=wfAtmVclXmtTagging, wfAtmizerIntfOutQLen=wfAtmizerIntfOutQLen, wfAtmAlcCopXmtQueueFulls=wfAtmAlcCopXmtQueueFulls, wfAtmizerIntfTxLackPageCredits=wfAtmizerIntfTxLackPageCredits, wfAtmizerIntfRxSequenceNumberErrors=wfAtmizerIntfRxSequenceNumberErrors, wfAtmPlcpSevereFrameErrors=wfAtmPlcpSevereFrameErrors, wfAtmVclConfEntry=wfAtmVclConfEntry, wfAtmNetPrefixEntry=wfAtmNetPrefixEntry, wfAtmVbrEntry=wfAtmVbrEntry, wfAtmAlcXmtPacketClips=wfAtmAlcXmtPacketClips, wfAtmAlcFrmDmaChan5Enable=wfAtmAlcFrmDmaChan5Enable, wfSonetPathIntervalIndex=wfSonetPathIntervalIndex, wfAtmVclAalCpcsReceiveSduSize=wfAtmVclAalCpcsReceiveSduSize, wfAtmizerCfgRxPagesMax=wfAtmizerCfgRxPagesMax, wfAtmPvcDrops=wfAtmPvcDrops, wfAtmAlcFrmXmtCellInsPrio=wfAtmAlcFrmXmtCellInsPrio, wfAtmSVCOptionsXmtPeakCellRate=wfAtmSVCOptionsXmtPeakCellRate, wfAtmVclCongestionIndication=wfAtmVclCongestionIndication, wfAtmAlcCopXmtPackets=wfAtmAlcCopXmtPackets, wfAtmizerDrvCfgModule=wfAtmizerDrvCfgModule, wfAtmSigMaxVciPtMltPt=wfAtmSigMaxVciPtMltPt, wfAtmSVCOptionsTable=wfAtmSVCOptionsTable, wfAtmUniAtmTransmits=wfAtmUniAtmTransmits, wfSonetLineCurrentESs=wfSonetLineCurrentESs, wfAtmInterfaceAdminStatus=wfAtmInterfaceAdminStatus, wfSonetSectionIntervalEntry=wfSonetSectionIntervalEntry, wfAtmAlcCopCtlMemSize=wfAtmAlcCopCtlMemSize, wfAtmLmiLineNumber=wfAtmLmiLineNumber, wfAtmizerIntfStatsEntry=wfAtmizerIntfStatsEntry, wfAtmAlcSarMaxReceivePktLen=wfAtmAlcSarMaxReceivePktLen, wfAtmAlcSarRateQueueState=wfAtmAlcSarRateQueueState, wfAtmVbrSarCct=wfAtmVbrSarCct, wfAtmIlmiGetRetryCnt=wfAtmIlmiGetRetryCnt, wfAtmAlcFrmRcvExtF4F5PrfMan=wfAtmAlcFrmRcvExtF4F5PrfMan, wfSonetLineIntervalNumber=wfSonetLineIntervalNumber, wfAtmServiceRecordFlag=wfAtmServiceRecordFlag, wfAtmAlcCopTotalRcvBufs=wfAtmAlcCopTotalRcvBufs, wfAtmServiceRecordNetworkPrefix=wfAtmServiceRecordNetworkPrefix, wfAtmAlcCopRcvQueueFulls=wfAtmAlcCopRcvQueueFulls, wfAtmVclStatsVci=wfAtmVclStatsVci, wfAtmVbrCsTransmits=wfAtmVbrCsTransmits, wfAtmizerDrvCfgSpeed=wfAtmizerDrvCfgSpeed, wfAtmVbrLineNumber=wfAtmVbrLineNumber, wfAtmAlcDrvTable=wfAtmAlcDrvTable, wfAtmVbrCct=wfAtmVbrCct, wfAtmIlmiRemotePort=wfAtmIlmiRemotePort, wfAtmUnknownVCPkts=wfAtmUnknownVCPkts, wfAtmAlcCopConfDelete=wfAtmAlcCopConfDelete, wfAtmAlcCopBufOverflows=wfAtmAlcCopBufOverflows, wfAtmAlcFrmRcvExtF5EndEnd=wfAtmAlcFrmRcvExtF5EndEnd, wfAtmizerFramingMode=wfAtmizerFramingMode, wfAtmizerVclRxLengthErrors=wfAtmizerVclRxLengthErrors, wfAtmPlcpEntry=wfAtmPlcpEntry, wfAtmCommonGroup=wfAtmCommonGroup, wfAtmInterfaceSigEnable=wfAtmInterfaceSigEnable, wfAtmizerDrvCfgDsx3SendCode=wfAtmizerDrvCfgDsx3SendCode, wfAtmAlcSarRateQueueDef=wfAtmAlcSarRateQueueDef, wfAtmAlcSarConfTable=wfAtmAlcSarConfTable, wfAtmServiceRecordEntry=wfAtmServiceRecordEntry, wfAtmAlcFrmRcvDisMetaSig=wfAtmAlcFrmRcvDisMetaSig, wfAtmPvcDelete=wfAtmPvcDelete, wfAtmVclOperStatus=wfAtmVclOperStatus, wfAtmVclXmtSustainableCellRate=wfAtmVclXmtSustainableCellRate, wfAtmDxiDiscardedFrames=wfAtmDxiDiscardedFrames, wfAtmVbrSarLineNumber=wfAtmVbrSarLineNumber, wfAtmAlcCopRcvClipBuffers=wfAtmAlcCopRcvClipBuffers, wfAtmAlcFrmXmtExtUserCell=wfAtmAlcFrmXmtExtUserCell, wfAtmAlcFrmOamTxSectionFebe=wfAtmAlcFrmOamTxSectionFebe, wfSonetPathCurrentWidth=wfSonetPathCurrentWidth, wfAtmizerVclTxFlowCtrlCount=wfAtmizerVclTxFlowCtrlCount, wfAtmUniLineNumber=wfAtmUniLineNumber, wfAtmUniAtmCHECs=wfAtmUniAtmCHECs, wfAtmVclRcvTrailerErrs=wfAtmVclRcvTrailerErrs, wfAtmAlcFrmRcvExtUserCell=wfAtmAlcFrmRcvExtUserCell, wfAtmVbrSarTable=wfAtmVbrSarTable, wfAtmPvcReceives=wfAtmPvcReceives, wfAtmAlcFrmConfEntry=wfAtmAlcFrmConfEntry, wfAtmIlmiTable=wfAtmIlmiTable, wfSonetLineCurrentStatus=wfSonetLineCurrentStatus, wfAtmAlcFrmStatsTransmit=wfAtmAlcFrmStatsTransmit, wfAtmAlcCopVcInactTimeout=wfAtmAlcCopVcInactTimeout, wfAtmAlcCopRcvWriteFails=wfAtmAlcCopRcvWriteFails, wfAtmAlcFrmStatsReceive=wfAtmAlcFrmStatsReceive, wfAtmAlcDpNotifyTimeout=wfAtmAlcDpNotifyTimeout, wfSonetSectionIntervalNumber=wfSonetSectionIntervalNumber, wfAtmInterfaceDrops=wfAtmInterfaceDrops, wfAtmServiceRecordIndex=wfAtmServiceRecordIndex, wfAtmInterfaceLineNumber=wfAtmInterfaceLineNumber, wfAtmAlcSarControlRif=wfAtmAlcSarControlRif, wfAtmIlmiEntry=wfAtmIlmiEntry, wfAtmInterfaceOperStatus=wfAtmInterfaceOperStatus, wfAtmAlcConfLogqSize=wfAtmAlcConfLogqSize, wfAtmAlcCopHwTable=wfAtmAlcCopHwTable)
mibBuilder.exportSymbols("Wellfleet-ATM-MIB", wfAtmPlcpFebeESecs=wfAtmPlcpFebeESecs, wfAtmizerCfgTxBuffersMax=wfAtmizerCfgTxBuffersMax, wfAtmLmiCsuDsuResponses=wfAtmLmiCsuDsuResponses, wfAtmAlcXmtqVcs=wfAtmAlcXmtqVcs, wfAtmAlcSarModeVpf=wfAtmAlcSarModeVpf, wfSonetMediumLineType=wfSonetMediumLineType, wfSonetFarEndLineIntervalCVs=wfSonetFarEndLineIntervalCVs, wfSonetMediumValidIntervals=wfSonetMediumValidIntervals, wfAtmSigDisable=wfAtmSigDisable, wfAtmizerIntfRxLengthErrors=wfAtmizerIntfRxLengthErrors, wfAtmizerVclRxFlowCtrlCount=wfAtmizerVclRxFlowCtrlCount, wfAtmSigMaxPartiesInMultConnect=wfAtmSigMaxPartiesInMultConnect, wfAtmAlcFrmConfTable=wfAtmAlcFrmConfTable, wfAtmServiceRecordLossPriorityPolicy=wfAtmServiceRecordLossPriorityPolicy, wfAtmizerIntfRxUTOPIAErrors=wfAtmizerIntfRxUTOPIAErrors, wfSonetFarEndLineIntervalTable=wfSonetFarEndLineIntervalTable, wfAtmAlcOutQLen=wfAtmAlcOutQLen, wfAtmAlcSarModeSmode=wfAtmAlcSarModeSmode, wfAtmAlcSarRateQueueIndex=wfAtmAlcSarRateQueueIndex, wfAtmAlcFrmXmtDisBcastSig=wfAtmAlcFrmXmtDisBcastSig, wfSonetSectionCurrentCVs=wfSonetSectionCurrentCVs, wfAtmAlcDisable=wfAtmAlcDisable, wfAtmSigT316c=wfAtmSigT316c, wfAtmSVCOptionsXmtSustCellRate=wfAtmSVCOptionsXmtSustCellRate, wfAtmNetPrefixPrefix=wfAtmNetPrefixPrefix, wfAtmizerDrvCfgEntry=wfAtmizerDrvCfgEntry, wfAtmServiceRecordMtu=wfAtmServiceRecordMtu, wfAtmizerVclTxCellsOk=wfAtmizerVclTxCellsOk, wfAtmServiceRecordDebug=wfAtmServiceRecordDebug, wfAtmAlcFrmRcvDisPointSig=wfAtmAlcFrmRcvDisPointSig, wfAtmizerDebugTxDone=wfAtmizerDebugTxDone, wfAtmAlcXmtqStickyMask=wfAtmAlcXmtqStickyMask, wfAtmVclConfDelete=wfAtmVclConfDelete, wfAtmAlcCopDmaFifoOverruns=wfAtmAlcCopDmaFifoOverruns, wfAtmTableDebugType=wfAtmTableDebugType, wfAtmUniAtmCct=wfAtmUniAtmCct, wfAtmizerVclRxPacketsOkWrap=wfAtmizerVclRxPacketsOkWrap, wfAtmizerCfgRxQueueTmoMax=wfAtmizerCfgRxQueueTmoMax, wfAtmPvcOctetTransmits=wfAtmPvcOctetTransmits, wfAtmVclRcvReassemAbortErrs=wfAtmVclRcvReassemAbortErrs, wfAtmIlmiDelete=wfAtmIlmiDelete, wfAtmAlcFrmCsiRcvAte=wfAtmAlcFrmCsiRcvAte, wfAtmInterfaceHwMacOverride=wfAtmInterfaceHwMacOverride, wfAtmizerVclTxClipFrames=wfAtmizerVclTxClipFrames, wfAtmSigVpi=wfAtmSigVpi, wfSonetLineCurrentSESs=wfSonetLineCurrentSESs, wfAtmAlcCopType=wfAtmAlcCopType, wfAtmAlcCopXmtAtes=wfAtmAlcCopXmtAtes, wfAtmizerDrvCfgDpNotifyTimeout=wfAtmizerDrvCfgDpNotifyTimeout, wfAtmizerVclVci=wfAtmizerVclVci, wfAtmVclLastChange=wfAtmVclLastChange, wfAtmSscopDebug=wfAtmSscopDebug, wfAtmizerDrvCfgCcType=wfAtmizerDrvCfgCcType, wfAtmAlcSarRateQueueNumber=wfAtmAlcSarRateQueueNumber, wfAtmAlcFrmXmtExtF5EndEnd=wfAtmAlcFrmXmtExtF5EndEnd, wfAtmizerVclRxCrcErrors=wfAtmizerVclRxCrcErrors, wfAtmInterfaceConfDelete=wfAtmInterfaceConfDelete, wfAtmAlcFrmXmtDisF4Segment=wfAtmAlcFrmXmtDisF4Segment, wfAtmVbrCsReceives=wfAtmVbrCsReceives, wfAtmAlcFrmXmtCellEnable=wfAtmAlcFrmXmtCellEnable, wfAtmAlcFrmRcvInsertPcr=wfAtmAlcFrmRcvInsertPcr, wfAtmizerIntfRxOverSizedSDUs=wfAtmizerIntfRxOverSizedSDUs, wfAtmVclXmtMinimumCellRate=wfAtmVclXmtMinimumCellRate, wfAtmInterfaceLastChange=wfAtmInterfaceLastChange, wfAtmPvcMulticast=wfAtmPvcMulticast, wfAtmizerCfgEntry=wfAtmizerCfgEntry, wfAtmAlcMtu=wfAtmAlcMtu, wfAtmAlcSarConfEntry=wfAtmAlcSarConfEntry, wfAtmSigDelete=wfAtmSigDelete, wfAtmVbrCsVciBETagMismatches=wfAtmVbrCsVciBETagMismatches, wfSonetPathCurrentCVs=wfSonetPathCurrentCVs, wfAtmVclXmtQosClass=wfAtmVclXmtQosClass, wfAtmAlcCopXmtOamCells=wfAtmAlcCopXmtOamCells, wfAtmUniAtmNoBuffers=wfAtmUniAtmNoBuffers, wfAtmAlcUseDebugger=wfAtmAlcUseDebugger, wfAtmizerCfgRxQueueLenMax=wfAtmizerCfgRxQueueLenMax, wfAtmIlmiDisable=wfAtmIlmiDisable, wfAtmAlcFrmDmaPrioritySel=wfAtmAlcFrmDmaPrioritySel, wfAtmInterfaceMaxSupportedVCs=wfAtmInterfaceMaxSupportedVCs, wfAtmAlcCopRcvOamCrcErrs=wfAtmAlcCopRcvOamCrcErrs, wfSonetSectionCurrentTable=wfSonetSectionCurrentTable, wfAtmUniAtmMisdeliveredCells=wfAtmUniAtmMisdeliveredCells, wfAtmSigT397=wfAtmSigT397, wfAtmVclXmtOamCells=wfAtmVclXmtOamCells, wfAtmPlcpStatus=wfAtmPlcpStatus, wfAtmAlcXmtqTable=wfAtmAlcXmtqTable, wfAtmVclCct=wfAtmVclCct, wfAtmVbrCsLengthMismatches=wfAtmVbrCsLengthMismatches, wfAtmSigT310=wfAtmSigT310, wfAtmVbrCsCct=wfAtmVbrCsCct, wfAtmVclMulticast=wfAtmVclMulticast, wfAtmAlcSarDmaModeSync=wfAtmAlcSarDmaModeSync, wfAtmAlcFrmRcvDisF4Segment=wfAtmAlcFrmRcvDisF4Segment, wfAtmAlcFrmXmtDisUserCell=wfAtmAlcFrmXmtDisUserCell, wfAtmPlcpBipSESecs=wfAtmPlcpBipSESecs, wfAtmVbrSarBomBeforeEomErrors=wfAtmVbrSarBomBeforeEomErrors, wfAtmAlcFrmXmtDisF5Segment=wfAtmAlcFrmXmtDisF5Segment, wfAtmizerDrvCfgDpNotify=wfAtmizerDrvCfgDpNotify, wfAtmSigInterfaceType=wfAtmSigInterfaceType, wfSonetSectionCurrentStatus=wfSonetSectionCurrentStatus, wfAtmAlcFrmRcvOamCrcCheck=wfAtmAlcFrmRcvOamCrcCheck, wfAtmSscopState=wfAtmSscopState, wfAtmAlcFrmRcvExtF1F3PlOam=wfAtmAlcFrmRcvExtF1F3PlOam, wfAtmizerTxVcBuffersMax=wfAtmizerTxVcBuffersMax, wfSonetFarEndLineCurrentIndex=wfSonetFarEndLineCurrentIndex, wfAtmVbrSarReceives=wfAtmVbrSarReceives, wfAtmSscopMaxCc=wfAtmSscopMaxCc, wfAtmSVCOptionsRcvSustCellRate=wfAtmSVCOptionsRcvSustCellRate, wfAtmAlcFrmGenFramingMode=wfAtmAlcFrmGenFramingMode, wfAtmCellSwitchGroup=wfAtmCellSwitchGroup, wfAtmAlcConfControlQSize=wfAtmAlcConfControlQSize, wfAtmVclRcvQosClass=wfAtmVclRcvQosClass, wfAtmAlcCopAlcVersion=wfAtmAlcCopAlcVersion, wfAtmLmiProxyRequests=wfAtmLmiProxyRequests, wfAtmSigMaxRoutingRegistrations=wfAtmSigMaxRoutingRegistrations, wfSonetFarEndPathIntervalTable=wfSonetFarEndPathIntervalTable, wfAtmIlmiGetNextRetryCnt=wfAtmIlmiGetNextRetryCnt, wfAtmOverallStatus=wfAtmOverallStatus, wfAtmUniSeconds=wfAtmUniSeconds, wfAtmAlcCopAlcClockSpeed=wfAtmAlcCopAlcClockSpeed, wfAtmizerIntfRxFlowCtrlCount=wfAtmizerIntfRxFlowCtrlCount, wfAtmizerDebugParam6=wfAtmizerDebugParam6, wfAtmDxiFrameHeaderErrors=wfAtmDxiFrameHeaderErrors, wfAtmPlcpYellow=wfAtmPlcpYellow, wfAtmAlcCopRcvOctets=wfAtmAlcCopRcvOctets, wfAtmPvcCsNull=wfAtmPvcCsNull, wfAtmServiceRecordCct=wfAtmServiceRecordCct, wfSonetFarEndPathIntervalESs=wfSonetFarEndPathIntervalESs, wfAtmAlcFrmRcvDisBcastSig=wfAtmAlcFrmRcvDisBcastSig, wfSonetFarEndLineIntervalUASs=wfSonetFarEndLineIntervalUASs, wfSonetFarEndPathIntervalCVs=wfSonetFarEndPathIntervalCVs, wfAtmUniTable=wfAtmUniTable, wfSonetMediumLineCoding=wfSonetMediumLineCoding, wfAtmAlcCopHwEntry=wfAtmAlcCopHwEntry, wfAtmPlcpUAS=wfAtmPlcpUAS, wfAtmVclRcvOamCrcErrs=wfAtmVclRcvOamCrcErrs, wfAtmAlcConfXmtClipSlotMax=wfAtmAlcConfXmtClipSlotMax, wfAtmAlcFrmCsiXmtClpBitOpt=wfAtmAlcFrmCsiXmtClpBitOpt, wfAtmAlcCopHecCorrects=wfAtmAlcCopHecCorrects, wfAtmVclOamAlarmEnable=wfAtmVclOamAlarmEnable, wfAtmizerTxPercentRsrcs=wfAtmizerTxPercentRsrcs, wfAtmizerVclRxLackPageResc=wfAtmizerVclRxLackPageResc, wfAtmInterfaceNumber=wfAtmInterfaceNumber, wfAtmInterfaceState=wfAtmInterfaceState, wfAtmPvcLineNumber=wfAtmPvcLineNumber, wfAtmMpeTable=wfAtmMpeTable, wfAtmUniAtmLineNumber=wfAtmUniAtmLineNumber, wfAtmAlcSarModeRid=wfAtmAlcSarModeRid, wfAtmAlcCopXmtErrBuffers=wfAtmAlcCopXmtErrBuffers, wfAtmAlcMadrCt=wfAtmAlcMadrCt, wfSonetFarEndLineCurrentESs=wfSonetFarEndLineCurrentESs, wfAtmVclVBRType=wfAtmVclVBRType, wfAtmizerCfgSlot=wfAtmizerCfgSlot, wfAtmDxiValidFrameReceives=wfAtmDxiValidFrameReceives, wfAtmizerCfgCurrVcl=wfAtmizerCfgCurrVcl, wfAtmVclServiceCategory=wfAtmVclServiceCategory, wfAtmVclVcGroup=wfAtmVclVcGroup, wfAtmPvcMode=wfAtmPvcMode, wfAtmPvcState=wfAtmPvcState, wfAtmizerIntfRxPacketsOkWrap=wfAtmizerIntfRxPacketsOkWrap, wfAtmAlcFrmRcvCellSyncFound=wfAtmAlcFrmRcvCellSyncFound, wfAtmAlcFrmXmtScrambleCtl=wfAtmAlcFrmXmtScrambleCtl, wfAtmizerCfgMaxVcl=wfAtmizerCfgMaxVcl, wfAtmVbrCsVciLengthMismatches=wfAtmVbrCsVciLengthMismatches, wfSonetFarEndPathCurrentEntry=wfSonetFarEndPathCurrentEntry, wfAtmSscopPollTimer=wfAtmSscopPollTimer, wfAtmAlcSlot=wfAtmAlcSlot, wfAtmVbrSarTransmits=wfAtmVbrSarTransmits, wfAtmSscopDelete=wfAtmSscopDelete, wfAtmTableDebugTable=wfAtmTableDebugTable, wfAtmAlcCopLossSignals=wfAtmAlcCopLossSignals, wfAtmServiceRecordUserSuffix=wfAtmServiceRecordUserSuffix, wfAtmSigT309=wfAtmSigT309, wfAtmVbrCsVciTransmits=wfAtmVbrCsVciTransmits, wfAtmAlcFrmDmaChan2Enable=wfAtmAlcFrmDmaChan2Enable, wfAtmizerIntfStatsTable=wfAtmizerIntfStatsTable, wfAtmAlcCopDataPathTable=wfAtmAlcCopDataPathTable, wfAtmAlcCopInfoIndex=wfAtmAlcCopInfoIndex, wfAtmAlcCopXmtIdleCells=wfAtmAlcCopXmtIdleCells, wfAtmSscopStandard=wfAtmSscopStandard, wfAtmVbrCsMisdeliveredPdus=wfAtmVbrCsMisdeliveredPdus, wfAtmAlcCopBufSize=wfAtmAlcCopBufSize)

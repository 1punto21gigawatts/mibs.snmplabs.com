#
# PySNMP MIB module DACS-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/DACS-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:36:34 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ConstraintsIntersection, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ConstraintsIntersection", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
NotificationType, Counter64, Bits, Counter32, Gauge32, Integer32, iso, IpAddress, Unsigned32, MibIdentifier, TimeTicks, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, ObjectIdentity, enterprises, ModuleIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "NotificationType", "Counter64", "Bits", "Counter32", "Gauge32", "Integer32", "iso", "IpAddress", "Unsigned32", "MibIdentifier", "TimeTicks", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ObjectIdentity", "enterprises", "ModuleIdentity")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
class MacAddress(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(6, 6)
    fixedLength = 6

rad = MibIdentifier((1, 3, 6, 1, 4, 1, 164))
radTokenRing = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 1))
radFddi = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 2))
radWan = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3))
radBridges = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 4))
radConverters = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 5))
radGen = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6))
radStkHub = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 7))
systems = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1))
radSysTR = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 1))
radRADring = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 1, 1))
radTMA = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 1, 2))
radRingMonitor = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 1, 3))
radSysFddi = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 2))
radFDX100 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 2, 1))
radSysWan = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3))
radMP2100 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 1))
radMP2104 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 2))
radMP2100B = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 3))
radMP2100F = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 4))
radMP2100H = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 5))
radMP2104H = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 6))
radMP2200B = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 7))
radMP2200F = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 8))
radMX3000 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 9))
radMX3004 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 10))
radMX30 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 11))
radMX300 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 12))
radVOIP = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 13))
radKM2100 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 15))
radKM2104 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 16))
radDXC30 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 20))
radDXC10A = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 21))
radDXC8R = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 22))
radDXC30E = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 23))
radFcdT1 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 30))
radFcdE1 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 31))
radFcdE1I = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 32))
radFcdT1M = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 33))
radFcdE1M = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 34))
radFcdIP = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 35))
radFcdT1A = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 36))
radFcdE1A = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 37))
radFcdW = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 38))
radHtuE1Sa = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 40))
radHtuE1 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 41))
radHtu2Sa = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 42))
radHtu2 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 43))
radAsmi450R768Sa = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 44))
radAsmi450R768 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 45))
radAsmi450R1152Sa = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 46))
radAsmi450R1152 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 47))
radLrs12F = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 48))
radLrs12B = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 49))
radHcdE1Sa = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 51))
radHcdE1 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 52))
radHtuT1Sa = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 53))
radHtuT1 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 54))
radOptimux4E1 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 55))
radOptimux4T1 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 56))
radOptimuxXLE1 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 57))
radOptimuxXLT1 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 58))
radOptimuxXL16E1 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 59))
radImx64 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 60))
radImx6L = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 61))
radImx2 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 62))
radImx4T1 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 63))
radImx4E1 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 64))
radImx2T1E1 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 65))
radHtuE1SaV2 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 70))
radHtuE1V2 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 71))
radFomiE3 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 72))
radFomiT3 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 73))
radOpt4E1C = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 74))
radOpt4T1C = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 75))
radPrbiE3 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 76))
radPrbiT3 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 77))
radHcd4Sa = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 78))
radFRmon = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 3, 80))
radSysBRG = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 4))
radTRE1 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 4, 1))
radTRE1D = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 4, 2))
radTRE8 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 4, 3))
radTRE8D = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 4, 4))
radMBE1 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 4, 5))
radMBE1D = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 4, 6))
radMBE8 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 4, 7))
radMBE8D = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 4, 8))
radMLBT = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 4, 9))
radFEB4DAS = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 4, 10))
radTrimBrg10 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 4, 11))
radTrimBrg16 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 4, 12))
radRRTRE8 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 4, 13))
radRRTRE8D = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 4, 14))
radRRMLBT = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 4, 15))
radRRMLBTF = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 4, 16))
radRRTRE1D = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 4, 17))
radTRERAS = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 4, 18))
radTRERASa = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 4, 19))
radMBERAS = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 4, 20))
radMBERASa = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 4, 21))
radFEB4FDX = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 4, 22))
radFEB4SAS = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 4, 23))
radRRFTBDAS = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 4, 24))
radRRFTBSAS = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 4, 25))
radFTBDAS = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 4, 26))
radFTBSAS = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 4, 27))
radFastWay100 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 4, 28))
radSysCnvrtr = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 5))
radSTC1 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 5, 1))
radSTC2 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 5, 3))
radSTC1UDP = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 5, 4))
radSTC2UDP = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 5, 6))
radFTC1 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 5, 10))
radFTC2 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 5, 12))
radFTC1UDP = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 5, 13))
radFTC2UDP = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 5, 15))
radSEC1 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 5, 20))
radSEC2 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 5, 22))
radSEC1UDP = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 5, 23))
radSEC2UDP = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 5, 25))
radFEC1 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 5, 30))
radFEC2 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 5, 32))
radFEC1UDP = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 5, 33))
radFEC2UDP = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 5, 35))
radSysStkHub = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 7))
radRBHE = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 7, 1))
radRBHT = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 7, 2))
radETS4fddiDAS = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 7, 3))
radETS4fddiSAS = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 7, 4))
radSAHEMX = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 7, 5))
radSAHTM = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 7, 6))
radETS4 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 7, 7))
radSAHEMU = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 7, 8))
unknown = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 7, 9))
radSAH16Eint = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 7, 10))
radSAH16Tint = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 7, 11))
radSAH16Eext = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 7, 12))
radSAH16Text = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 7, 13))
radSysPS = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 8))
radSPS2 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 8, 1))
radSPS3 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 8, 2))
radSPS6 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 8, 3))
radSPS9 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 8, 4))
radSPS12 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 8, 5))
radAPD2 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 8, 6))
radAPD8 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 8, 7))
radAPS8 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 8, 8))
radAPS16 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 8, 9))
radAPS24 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 8, 10))
radSPS3S = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 8, 11))
radFPS8 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 8, 12))
radFPS12 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 8, 13))
radSPS3ScSL = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 8, 14))
radSPS3Sc2S = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 8, 15))
radFPS8c = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 8, 16))
radFPS4 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 8, 17))
radSysEth = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 9))
radEP8T = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 9, 1))
radEP4TAUI = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 9, 2))
radEP4T2FL = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 9, 3))
radEP4TFL = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 9, 4))
radEP4FL = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 9, 5))
radEPR8T = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 9, 7))
radEPR4TAUI = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 9, 8))
radEPR4T2FL = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 9, 9))
radEPR4TFL = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 9, 10))
radEPR4FL = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 9, 11))
radSysRtr = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 11))
radRTED = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 11, 1))
radRTEM = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 11, 2))
radRTEC = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 11, 3))
radWebRanger = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 11, 4))
radTinyRouter = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 11, 5))
radSysAtm = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 12))
radStarSwitch = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 1))
radStarSwitchATM25 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 1, 1))
radStarSwitchATM25L = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 1, 2))
radStarSwitchATM155 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 1, 3))
radAtmCsuDsu = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 2))
radAmcdE1 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 2, 1))
radAmcdT1 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 2, 2))
radAce20E = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 2, 3))
radAce20T = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 2, 4))
radAce2005 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 2, 5))
radAce2002 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 2, 6))
radAce2E = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 2, 8))
radAce2T = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 2, 9))
radAce = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 3))
radAce101 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 3, 1))
radAce102 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1, 12, 3, 2))
agnt = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 2))
agnHwVersion = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 1), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnHwVersion.setStatus('mandatory')
if mibBuilder.loadTexts: agnHwVersion.setDescription("ASCII string for description and display of the agent hardware version, as it is known by the agent software.The user can update the version upon request when he changes components in the agent's module ")
agnTrapMask = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnTrapMask.setStatus('mandatory')
if mibBuilder.loadTexts: agnTrapMask.setDescription("The value of this attribute determines the type of traps the agent should mask and not send to the management console. The value is differently determined for different products. There are mainly two methods: - an integer number, specifying the traps' severity. - a sum of 2**n, where n is a bit assigned to a certain masked trap group. User should consult the product specification, to find out the method employed.")
agnTrapValue = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnTrapValue.setStatus('deprecated')
if mibBuilder.loadTexts: agnTrapValue.setDescription('The value of the trap decoded in internal RAD format. Full description is given in the Trap definition file')
agnChangeCnt = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnChangeCnt.setStatus('mandatory')
if mibBuilder.loadTexts: agnChangeCnt.setDescription('The number of changes in system configuration that were reported to the manager since last cold start')
agnSpecific = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 5), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSpecific.setStatus('mandatory')
if mibBuilder.loadTexts: agnSpecific.setDescription(' Object identifier of entity containing additional information regarding this instance.')
agnConfigMsg = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnConfigMsg.setStatus('mandatory')
if mibBuilder.loadTexts: agnConfigMsg.setDescription("Full configuration message coded in internal RAD application format. This entry describes agent's configuration. For MP-2200 R3, this object describes agent's support of the V5.1 feature: 1 octet ; bit 0 (LSB). '1' - V5.1 feature is supported '0' - V5.1 feature is not supported.")
mngTrapIpTable = MibTable((1, 3, 6, 1, 4, 1, 164, 6, 2, 7), )
if mibBuilder.loadTexts: mngTrapIpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mngTrapIpTable.setDescription('This table indicates the destination address of the traps. Internally it will be limited to ten addresses. ')
mngEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 6, 2, 7, 1), ).setIndexNames((0, "DACS-MIB", "mngID"))
if mibBuilder.loadTexts: mngEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mngEntry.setDescription('')
mngID = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 7, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mngID.setStatus('mandatory')
if mibBuilder.loadTexts: mngID.setDescription(' This value indicates an index of a specific IP address')
mngIP = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 7, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mngIP.setStatus('mandatory')
if mibBuilder.loadTexts: mngIP.setDescription('This value indicates the destination address of the traps. IP 0.0.0.0 removes the entry. ')
mngIPMask = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 7, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mngIPMask.setStatus('deprecated')
if mibBuilder.loadTexts: mngIPMask.setDescription('This value indicates the mask of the destination addresses of the traps. ')
mngTrapMask = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 7, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mngTrapMask.setStatus('mandatory')
if mibBuilder.loadTexts: mngTrapMask.setDescription("The value of this attribute determines the type of traps the agent should mask and not send to this NMS. The value is differently determined for different products. There are mainly two methods: - an integer number, specifying the traps' severity. - a sum of 2**n, where n is a bit assigned to a certain masked trap group. User should consult the product specification, to find out the method employed.")
agnIndication = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("faulty", 1), ("warning", 2), ("normal", 3), ("minor", 4), ("major", 5), ("event", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnIndication.setStatus('mandatory')
if mibBuilder.loadTexts: agnIndication.setDescription('Attribute describing the state of the entity the agent is responsible for. In case of a modular entity, the value of this attribute will be according to the component which is in the worst state. The order of severity (from top to bottom) is: faulty (critical)-> major-> minor-> warning-> event-> normal (off).')
agnMonitorModeCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnMonitorModeCmd.setStatus('mandatory')
if mibBuilder.loadTexts: agnMonitorModeCmd.setDescription('Setting this attribute to ON, will enforce the agent to change its mode of operation to Monitor Mode')
agnLed = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 10), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnLed.setStatus('mandatory')
if mibBuilder.loadTexts: agnLed.setDescription('This entry specifies the LEDs status of the agent module . Each led will be represented by 4 bits where the first 2 bits (left) will specify the status : (00=NA, 01=OFF, 10=ON, 11=BLINK), and the next two bits (right) will specify the color : (00=GREEN, 01=RED, 10=YELLOW, 11=ORANGE)')
trapTable = MibTable((1, 3, 6, 1, 4, 1, 164, 6, 2, 11), )
if mibBuilder.loadTexts: trapTable.setStatus('mandatory')
if mibBuilder.loadTexts: trapTable.setDescription('This table includes the last few traps generated by the agent, for future retrieval. The table has a limited capacity. If traps are not retrieved in proper time, they will be over-written by new traps ')
trapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 6, 2, 11, 1), ).setIndexNames((0, "DACS-MIB", "trapID"))
if mibBuilder.loadTexts: trapEntry.setStatus('mandatory')
if mibBuilder.loadTexts: trapEntry.setDescription('')
trapID = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 11, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trapID.setStatus('mandatory')
if mibBuilder.loadTexts: trapID.setDescription(' This value indicates an index of a specific trap ')
trapVal = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 11, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trapVal.setStatus('mandatory')
if mibBuilder.loadTexts: trapVal.setDescription('This value is the actual ASCII description of the trap. ')
trapTimeSinceOccurrence = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 11, 1, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trapTimeSinceOccurrence.setStatus('mandatory')
if mibBuilder.loadTexts: trapTimeSinceOccurrence.setDescription('This value indicates the amount of time passed since the occurrence of the event that trigger this trap. ')
fileTransfer = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 2, 12))
fileServerIP = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fileServerIP.setStatus('mandatory')
if mibBuilder.loadTexts: fileServerIP.setDescription('The IP address of the server from which the file is loaded ')
fileName = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fileName.setStatus('mandatory')
if mibBuilder.loadTexts: fileName.setDescription('The name of the file to be loaded. For protection, read returns NULL. ')
fileTransCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 255))).clone(namedValues=NamedValues(("swDwnLoad", 1), ("configDwnLoad", 2), ("configUpLoad", 3), ("coProcDwnLoad", 4), ("stateUpLoad", 5), ("dwnLoadUserFile", 6), ("upLoadUserFile", 7), ("noOp", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fileTransCmd.setStatus('mandatory')
if mibBuilder.loadTexts: fileTransCmd.setDescription('The command to be executed on fileName at fileServerIP.')
tftpRetryTimeOut = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tftpRetryTimeOut.setStatus('mandatory')
if mibBuilder.loadTexts: tftpRetryTimeOut.setDescription(' General Retransmission time-out value (seconds) ')
tftpTotalTimeOut = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tftpTotalTimeOut.setStatus('mandatory')
if mibBuilder.loadTexts: tftpTotalTimeOut.setDescription(' Total Retransmission time-out value (seconds) ')
tftpStatus = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("noOp", 2), ("connecting", 3), ("transferringData", 4), ("endedTimeOut", 5), ("endedOk", 6), ("error", 7))).clone('noOp')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tftpStatus.setStatus('mandatory')
if mibBuilder.loadTexts: tftpStatus.setDescription("Status of tftp session. When a session ended with success, the tftpStatus should be endedOk(6). Before restarting a tftp session, the NMS should set the tftpStatus to noOp(2). That's the reason of ACCESS read-write to this field.")
tftpError = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2).clone(hexValue="0000")).setMaxAccess("readonly")
if mibBuilder.loadTexts: tftpError.setStatus('mandatory')
if mibBuilder.loadTexts: tftpError.setDescription(' The MSB represents the standard error code. The LSB represents the private error code. 0x0000 is No Error 0x0100 is File Not Found 0x0400 is Illegal TFTP operation 0x0500 is Unknown transfer ID 0x0001 is Server Overflow 0x0002 is No empty UDP port 0x0003 is No empty connection 0x0004 is Illegal File Mode 0x0007 is Illegal PDU size ')
fileTransferToSubSystems = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 8), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fileTransferToSubSystems.setStatus('mandatory')
if mibBuilder.loadTexts: fileTransferToSubSystems.setDescription(" This object represents the sub-systems the fileTransCmd refers to. It should be used when a system is divided to sub-systems and each sub-system (or part of them) can have a different SW/Configuration. Each bit of this object will represent one of the sub-systems. Bit='1' - APPLY to respective sub-system Bit='0' - DO NOT APPLY to respective sub-system For the meaning of each bit, see product's specification. User will select the sub-systems envolved by filling-in the bits that represent these sub-systems. In this case, the file represented by 'fileName' will include several parts, each representing one of the sub-systems. The agent will refer only to the part/s indicated by this object. 0 Octet Strings = not applicable DEFVAL = 0h for the products that support this object.")
fileNameWithinProduct = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 9), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fileNameWithinProduct.setStatus('mandatory')
if mibBuilder.loadTexts: fileNameWithinProduct.setDescription('The file name used by the product within the product file system.')
systemReset = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("off", 2), ("on", 3), ("resetConfig", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systemReset.setStatus('mandatory')
if mibBuilder.loadTexts: systemReset.setDescription('Reset action to be performed on the system.')
systemTiming = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 2, 14))
systemDate = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 14, 1), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systemDate.setStatus('mandatory')
if mibBuilder.loadTexts: systemDate.setDescription('System date.')
systemTime = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 14, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systemTime.setStatus('mandatory')
if mibBuilder.loadTexts: systemTime.setDescription('System time.')
systemPort = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 2, 15))
physicalConnectorTable = MibTable((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 1), )
if mibBuilder.loadTexts: physicalConnectorTable.setStatus('mandatory')
if mibBuilder.loadTexts: physicalConnectorTable.setDescription('This table includes the connector type of ports or interfaces.')
physicalConnectorEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 1, 1), ).setIndexNames((0, "DACS-MIB", "portIdx"))
if mibBuilder.loadTexts: physicalConnectorEntry.setStatus('mandatory')
if mibBuilder.loadTexts: physicalConnectorEntry.setDescription('')
portIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portIdx.setStatus('mandatory')
if mibBuilder.loadTexts: portIdx.setDescription('This object is an index of the specific port or interface. For a port, the index will be as agreed between agent and application. For an interface, ifIndex may be used.')
physicalConnector = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 40, 41, 255))).clone(namedValues=NamedValues(("other", 1), ("v35", 2), ("rs530", 3), ("x21", 4), ("bnc", 5), ("utp", 6), ("aui", 7), ("rs422", 8), ("crossUtp", 9), ("rj45", 10), ("v24", 11), ("g703", 12), ("termBlock3AndRj45", 13), ("terminalBlock3", 14), ("terminalBlock5", 15), ("terminalBlock7", 16), ("db25", 17), ("db15", 18), ("rj45ethernet", 19), ("termBlock5AndRj45", 20), ("db9", 21), ("g703E1", 22), ("g703E1-LTU", 23), ("sc", 24), ("st", 25), ("stl", 26), ("fc", 27), ("tb5w", 28), ("termBlock6AndRj45", 29), ("ethBnc", 30), ("scsi26", 31), ("eth4381", 32), ("twoBnc", 33), ("scsi50", 34), ("twoMiniBnc", 35), ("sf1", 36), ("terminalBlock4", 37), ("sf2", 38), ("v36", 40), ("block4W", 41), ("none", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: physicalConnector.setStatus('mandatory')
if mibBuilder.loadTexts: physicalConnector.setDescription('The connector of the port/interface. other - none of the specified connectors none - no connector.')
portOptWaveLength = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notApplicable", 1), ("nm850", 2), ("nm1300", 3), ("nm1300Laser", 4), ("nm1550Laser", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portOptWaveLength.setStatus('mandatory')
if mibBuilder.loadTexts: portOptWaveLength.setDescription('Wave Length of an Optical interface/port in [nm] and specification if Laser or not. notApplicable - for non-optical ports.')
prtSupervisory = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 2))
prtSpTable = MibTable((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 2, 1), )
if mibBuilder.loadTexts: prtSpTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtSpTable.setDescription('')
prtSpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 2, 1, 1), ).setIndexNames((0, "DACS-MIB", "prtSupervisoryIndex"))
if mibBuilder.loadTexts: prtSpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtSpEntry.setDescription('Supervisory port parameter table.')
prtSupervisoryIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSupervisoryIndex.setStatus('mandatory')
if mibBuilder.loadTexts: prtSupervisoryIndex.setDescription('The SP port index. The LS byte of the integer is the port index 1..255. The MS byte is different than 0 only if the port belongs to a module. In that case it is the module number.')
prtSupervisoryRate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("auto", 1), ("s300bps", 2), ("s1200bps", 3), ("s2400bps", 4), ("s4800bps", 5), ("s9600bps", 6), ("s19200bps", 7), ("s38400bps", 8), ("s57600bps", 9), ("s115200bps", 10)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtSupervisoryRate.setStatus('mandatory')
if mibBuilder.loadTexts: prtSupervisoryRate.setDescription('This attribute indicates the operation rate (speed) of the port. auto - automatic rate selection, by the agent.')
prtSupervisoryDataBits = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dataBits7", 1), ("dataBits8", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtSupervisoryDataBits.setStatus('mandatory')
if mibBuilder.loadTexts: prtSupervisoryDataBits.setDescription('This attribute indicates the number of data bits in an async frame')
prtSupervisoryParity = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("odd", 2), ("even", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtSupervisoryParity.setStatus('mandatory')
if mibBuilder.loadTexts: prtSupervisoryParity.setDescription('This attribute indicates the parity mode in an async frame')
prtSupervisoryStopBits = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("stopBits1", 2), ("stopBits1dot5", 3), ("stopBits2", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSupervisoryStopBits.setStatus('mandatory')
if mibBuilder.loadTexts: prtSupervisoryStopBits.setDescription('This attribute indicates the parity mode in an async frame.')
prtSupervisoryUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("unknown", 1), ("noUse", 2), ("terminal", 3), ("nmsSlip", 4), ("nmsPpp", 5), ("muxSlip", 6), ("muxPpp", 7), ("dialOut", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtSupervisoryUsage.setStatus('mandatory')
if mibBuilder.loadTexts: prtSupervisoryUsage.setDescription('This attribute indicates the usage of the SP port.')
prtSupervisoryInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("dce", 2), ("dte", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtSupervisoryInterface.setStatus('mandatory')
if mibBuilder.loadTexts: prtSupervisoryInterface.setDescription('This attribute indicates the supervisory port interface.')
prtSupervisoryCTS = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notApplicable", 1), ("on", 2), ("rts", 3), ("dteWait", 4), ("dteIgnore", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtSupervisoryCTS.setStatus('mandatory')
if mibBuilder.loadTexts: prtSupervisoryCTS.setDescription('CTS line state.')
prtSupervisoryDcdDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("notApplicable", 1), ("d0", 2), ("d10", 3), ("d50", 4), ("d100", 5), ("d200", 6), ("d300", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtSupervisoryDcdDelay.setStatus('mandatory')
if mibBuilder.loadTexts: prtSupervisoryDcdDelay.setDescription('DCD delay in msec.')
prtSupervisoryDSR = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("on", 2), ("dtr", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtSupervisoryDSR.setStatus('mandatory')
if mibBuilder.loadTexts: prtSupervisoryDSR.setDescription('DSR line state.')
prtSupervisoryRoutProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 2, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("none", 2), ("proprietary", 3), ("rip2", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtSupervisoryRoutProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: prtSupervisoryRoutProtocol.setDescription('This attribute indicates the routing protocol of the port. notApplicable - for DP.')
prtPerformance = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 3))
prtPerfTable = MibTable((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 3, 1), )
if mibBuilder.loadTexts: prtPerfTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtPerfTable.setDescription('This table includes G.826 ports or interfaces.')
prtPerfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 3, 1, 1), ).setIndexNames((0, "DACS-MIB", "prtPerfIdx"), (0, "DACS-MIB", "prtPerfPeriodRef"))
if mibBuilder.loadTexts: prtPerfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtPerfEntry.setDescription('')
prtPerfIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtPerfIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtPerfIdx.setDescription('This object is an index of the specific port or interface. For a port, the index will be as agreed between agent and application. For an interface, ifIndex may be used.')
prtPerfPeriodRef = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("currentPeriod", 1), ("lastPeriod", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtPerfPeriodRef.setStatus('mandatory')
if mibBuilder.loadTexts: prtPerfPeriodRef.setDescription('This object is an index that specifies which period of time, the next 5 objects refer to. currentPeriod - the period since last prtPerfSaveAndResetCmd received or since Start-up (if no prtPerfSaveAndResetCmd was received since Start-up) until now. lastPeriod - the period between last two commands of prtPerfSaveAndResetCmd. - If only one command occured since Start-up: the period between Start-up and last command. - If no command occured since Start-up: this period will not actually exist. In this case, he following 5 objects will be 0.')
prtPerfElapsedTime = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 3, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtPerfElapsedTime.setStatus('mandatory')
if mibBuilder.loadTexts: prtPerfElapsedTime.setDescription('Elapsed Time in seconds. - for prtPerfPeriodRef=currentPeriod: The period since last prtPerfSaveAndResetCmd received or since Start-up (if no prtPerfSaveAndResetCmd was received since Start-up) until now. - for prtPerfPeriodRef=lastPeriod: The value of prtPerfElapsedTime when last prtPerfSaveAndResetCmd was received.')
prtPerfUAS = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 3, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtPerfUAS.setStatus('mandatory')
if mibBuilder.loadTexts: prtPerfUAS.setDescription('Number of Unavailable Seconds for the reference period (prtPerfPeriodRef).')
prtPerfES = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 3, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtPerfES.setStatus('mandatory')
if mibBuilder.loadTexts: prtPerfES.setDescription('Number of Errored Seconds for the reference period (prtPerfPeriodRef).')
prtPerfSES = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 3, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtPerfSES.setStatus('mandatory')
if mibBuilder.loadTexts: prtPerfSES.setDescription('Number of Severely Errored Seconds for the reference period (prtPerfPeriodRef).')
prtPerfBBE = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 3, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtPerfBBE.setStatus('mandatory')
if mibBuilder.loadTexts: prtPerfBBE.setDescription('Number of Background Block (or Frame) Errors for the reference period (prtPerfPeriodRef).')
prtPerfBlocksPerSec = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 3, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtPerfBlocksPerSec.setStatus('mandatory')
if mibBuilder.loadTexts: prtPerfBlocksPerSec.setDescription('Blocks per second (or frames per second) of the port/interface indicated by portIdx. This object is constant for a certain port/interface. It is not affected by the prtPerfPeriodRef index.')
prtPerfTimeTag = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 3, 1, 1, 9), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtPerfTimeTag.setStatus('mandatory')
if mibBuilder.loadTexts: prtPerfTimeTag.setDescription('Time Tag of Last Period: sysUpTime when last prtPerfSaveAndResetCmd was executed. This object is applicable only for prtPerfPeriodRef=lastPeriod. For prtPerfPeriodRef=currentPeriod, the value will always be 0.')
prtPerfSaveAndResetCmd = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtPerfSaveAndResetCmd.setStatus('mandatory')
if mibBuilder.loadTexts: prtPerfSaveAndResetCmd.setDescription('A command per port/interface, to Save data of Current Period in Last Period data-set and start a new counting period for Current Period. This object is applicable only for prtPerfPeriodRef=currentPeriod. Setting this object to on(3) for prtPerfPeriodRef=last, will cause the agent to return: Bad Value response. When setting validly this object to on(3), agent will perform the required command and will reset automatically the value of this object to off(2). Setting this object to off(2), will do nothing.')
prtTest = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 4))
prtTestTable = MibTable((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 4, 1), )
if mibBuilder.loadTexts: prtTestTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtTestTable.setDescription('This table includes test data for ports or interfaces.')
prtTestEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 4, 1, 1), ).setIndexNames((0, "DACS-MIB", "prtTestIdx"))
if mibBuilder.loadTexts: prtTestEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtTestEntry.setDescription('')
prtTestIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 4, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtTestIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtTestIdx.setDescription('This object is an index of the specific port or interface. For a port, the index will be as agreed between agent and application. For an interface, ifIndex may be used.')
prtTestCmdAndStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 4, 1, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtTestCmdAndStatus.setStatus('mandatory')
if mibBuilder.loadTexts: prtTestCmdAndStatus.setDescription("Setting this object to a value as detailed furter on (except 0) will initiate a test on the specific port. The test/s requested will be set according to the respective bit. The value of this object will be a sum of (2**n), where n is the Bit: TEST BIT VALUE ----------- --- ------ reserved 0 1 PayloadLoop=RLB 1 (=Remote Loopback) 2 LineLoop=DIG 2 (=Digital) 4 OtherLoop 3 8 InwardLoop=LLB 4 (=Local Loopback) 16 BERT 5 32 LC 6 64 e.g : If the requested value is 20 -> 010100 -> Bits 2 & 4 are set -> the requested tests are : LineLoopback=DIG InwardLoopback=LLB Not all tests combinations are valid. For valid test combination, see each product's specification. The terminology and order of tests (except BERT) is according to the one used for Test Status of DS1 and DS3 standards. Setting this object to stop (value=0 ; all bits are 0), will stop all the user requested tests running on the selected port. When no test is running on the port, the Get value (test status) will be 0. PayloadLoop=RLB The received signal at this interface is looped through the device. Typically the received signal is looped back for retransmission after it has passed through the device's framing function. LineLoop=DIG The received signal at this interface does not go through the device (minimum penetration) but is looped back out. OtherLoop Loopbacks that are not defined here. InwardLoop=LLB The sent signal at this interface is looped back through the device. LC This loop is applicable only for HSSI interface, towards the router .")
prtBertCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 4, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtBertCounter.setStatus('mandatory')
if mibBuilder.loadTexts: prtBertCounter.setDescription('This object indicates the number of BERT errors encountered during the BERT operation. It is valid only when BERT (Bit Error Rate Test) is active on the specific port. The Counter starts from zero (0) anytime BERT is initiated.')
prtTestInitiator = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("user", 2), ("remoteUnit", 3), ("dteRouter", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtTestInitiator.setStatus('mandatory')
if mibBuilder.loadTexts: prtTestInitiator.setDescription("This object indicates who initiated this port's test/s.")
prtParam = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 5))
prtParamTable = MibTable((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 5, 1), )
if mibBuilder.loadTexts: prtParamTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtParamTable.setDescription('This table includes the connector type of ports or interfaces.')
prtParamEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 5, 1, 1), ).setIndexNames((0, "DACS-MIB", "prtParamIdx"))
if mibBuilder.loadTexts: prtParamEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtParamEntry.setDescription('')
prtParamIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 5, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtParamIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtParamIdx.setDescription('This object is an index of the specific port or interface. For a port, the index will be as agreed between agent and application. For an interface, ifIndex may be used.')
prtControlCnfg = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 15, 5, 1, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtControlCnfg.setStatus('mandatory')
if mibBuilder.loadTexts: prtControlCnfg.setDescription("This object may be used for port RW general parameter/s. For detailed meaning, see product's spec. Supported by: PRBi-E3/T3.")
systemResetAllStatsCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systemResetAllStatsCmd.setStatus('mandatory')
if mibBuilder.loadTexts: systemResetAllStatsCmd.setDescription('Reset statistics of all ports and connections of the device.')
systemClearTablesCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("tempCnfgTables", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systemClearTablesCmd.setStatus('mandatory')
if mibBuilder.loadTexts: systemClearTablesCmd.setDescription("tempCnfgTables - Set *RowStatus = destroy for all entries of some tables having *RowStatus object, for temporary configuration only! (255). For the relevant tables, see product's specification. This object should be used by WAN product applications before performing the Update operation, in order to clear old entries of these tables. off - agent will automatically change to this value, after performing the command. ")
systemParameter = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 18), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systemParameter.setStatus('mandatory')
if mibBuilder.loadTexts: systemParameter.setDescription('This parameter can be used for different purposes: - TELNET session time-out in seconds. - Ace20: when trying to create row in a table that already has row with the same values, if set of values has to be uniqe in table, this attribute is set to the index of the existing row.')
agnGlobalAlarmMask = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 19), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnGlobalAlarmMask.setStatus('mandatory')
if mibBuilder.loadTexts: agnGlobalAlarmMask.setDescription('The value of this attribute determines the alarm traps the agent should mask and not send to the managers. Each bit from a certain octet represents a certain alarm.')
alarmSeverity = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("event", 3), ("minor", 4), ("major", 5), ("warning", 6), ("critical", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: alarmSeverity.setStatus('mandatory')
if mibBuilder.loadTexts: alarmSeverity.setDescription('This object specifies the severity of the alarms.')
alarmState = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: alarmState.setStatus('mandatory')
if mibBuilder.loadTexts: alarmState.setDescription('.')
agnTestStatus = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnTestStatus.setStatus('mandatory')
if mibBuilder.loadTexts: agnTestStatus.setDescription('Indicates the current test status (for all levels: system, card, port). This attribute will be set to: on(3): when there is at least one test in progress on the system/card/port off(2): when there is NO test in progress on the system/card/port')
systemSaveAndResetAllStatsCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systemSaveAndResetAllStatsCmd.setStatus('mandatory')
if mibBuilder.loadTexts: systemSaveAndResetAllStatsCmd.setDescription('on - a command to Save data of Current Period in Last Period data-set and start a new counting period for Current Period. off - agent will automatically change to this value, after performing the command.')
systemDefaultGateway = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 24), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systemDefaultGateway.setStatus('mandatory')
if mibBuilder.loadTexts: systemDefaultGateway.setDescription("Default Gateway's IP Address.")
systemPsTable = MibTable((1, 3, 6, 1, 4, 1, 164, 6, 2, 25), )
if mibBuilder.loadTexts: systemPsTable.setStatus('mandatory')
if mibBuilder.loadTexts: systemPsTable.setDescription("This table describes the PS types of a device. Usage of this table is specified in the device's NMS SRS")
systemPsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 6, 2, 25, 1), ).setIndexNames((0, "DACS-MIB", "systemPsIndex1"), (0, "DACS-MIB", "systemPsIndex2"))
if mibBuilder.loadTexts: systemPsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: systemPsEntry.setDescription('')
systemPsIndex1 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 25, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: systemPsIndex1.setStatus('mandatory')
if mibBuilder.loadTexts: systemPsIndex1.setDescription('First Index. In HUBs: 1 = PS-A slot 2 = PS-B slot. In SA units: 1 = PS1 2 = PS2 Default = 1')
systemPsIndex2 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 25, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: systemPsIndex2.setStatus('mandatory')
if mibBuilder.loadTexts: systemPsIndex2.setDescription('Second Index. In HUBs: 1 always. In SA units: 1 = Local 2 = Remote Default = 1.')
systemPsType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 25, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("ac", 2), ("dc", 3), ("acDc", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: systemPsType.setStatus('mandatory')
if mibBuilder.loadTexts: systemPsType.setDescription('The type of PS, for a stand-alone product. acDc - AC with rj45 DC.')
tftpStatusChangeTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1) + (0,1)).setObjects(("DACS-MIB", "tftpStatus"))
if mibBuilder.loadTexts: tftpStatusChangeTrap.setDescription('This trap is sent whenever the status of tftp changed.')
agnStatusChangeTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1) + (0,2)).setObjects(("DACS-MIB", "agnIndication"))
if mibBuilder.loadTexts: agnStatusChangeTrap.setDescription('This trap is sent whenever the state of the entity the agent is responsible for changed. TDM devices will send agnTestStatus variable to indicate the current test status.')
prtStatusChangeTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1) + (0,3))
if mibBuilder.loadTexts: prtStatusChangeTrap.setDescription('This trap is sent whenever the state of a port changed. Attached, will be parameter/s that indicate the new port status. The attached variables will be specified in the specifications of the products supporting this trap.')
wanGen = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1))
muxHub = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 2))
chasWanGen = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 1))
agnWanGen = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 2))
mdlWanGen = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 3))
prtWanGen = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 4))
mapWanGen = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 5))
diverseIfWanGen = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 6))
statAgnGen = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1))
cnfgAgnGen = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2))
cmprAgnGen = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3))
alrBuffGen = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 4))
agnFlipDb = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5))
agnSa = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 6))
agnListDecoding = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 7))
agnSystemDlci = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 8))
agnVoiceSwitching = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 9))
agnSigProfile = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 10))
agnSystemTs = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 11))
statMdlGen = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 1))
cnfgMdlGen = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 2))
cmprMdlGen = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 3))
statPrtGen = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1))
cnfgPrtGen = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2))
cmprPrtGen = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 3))
agnMux = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 2, 1))
mdlMux = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 2, 2))
prtMux = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 2, 3))
statPrtMux = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 1))
cnfgPrtMux = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2))
prtClCnfg = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 1))
prtPh1MlCnfg = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2))
prtPhPlCnfg = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3))
prtLs2Cnfg = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 4))
prtHs4Cnfg = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 7))
prtHsiCnfg = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 8))
prtPVc4Cnfg = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9))
prtHsrCnfg = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 10))
prtMbeCnfg = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 11))
prtTreCnfg = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 12))
prtLs6Cnfg = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13))
prtVc3Cnfg = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 14))
prtVcPbxCnfg = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15))
prtIsdnCnfg = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16))
prtLogicalCnfg = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 17))
prtFrPlusCnfg = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 18))
prtMl4Cnfg = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 19))
prtAcmCnfg = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 20))
chasVersion = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasVersion.setStatus('mandatory')
if mibBuilder.loadTexts: chasVersion.setDescription('An ASCII string for description and display of the agent chassis version.')
chasTotalNoOfSlt = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasTotalNoOfSlt.setStatus('mandatory')
if mibBuilder.loadTexts: chasTotalNoOfSlt.setDescription('This entry indicates the number of physical slots in the chassis.')
chasTotalNoOfIoSlt = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasTotalNoOfIoSlt.setStatus('mandatory')
if mibBuilder.loadTexts: chasTotalNoOfIoSlt.setDescription('This entry indicates the total number of physical IO slots in the chassis, (not all slots hardware should be occupied and active) .')
chasTotalNoOfPsSlt = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasTotalNoOfPsSlt.setStatus('mandatory')
if mibBuilder.loadTexts: chasTotalNoOfPsSlt.setDescription('This entry indicates the number of physical Power Supply slots in the chassis.')
chasTotalNoOfClSlt = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasTotalNoOfClSlt.setStatus('mandatory')
if mibBuilder.loadTexts: chasTotalNoOfClSlt.setDescription('This entry indicates the number of physical Common Logic slots in the chassis.')
agnSDateFormat = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("ddMMYYYY", 1), ("mmDDYYYY", 2), ("yyyyDDMM", 3), ("yyyyMMDD", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnSDateFormat.setStatus('mandatory')
if mibBuilder.loadTexts: agnSDateFormat.setDescription("This entry indicates the date and time format used for the agnSDateAndTimeCmd and for the alarm history report. MP-2100H, MP-2100 r1-r4 and MAXcess products do not support the 'yyyyMMDD' format.")
agnSDateCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnSDateCmd.setStatus('mandatory')
if mibBuilder.loadTexts: agnSDateCmd.setDescription('This entry indicates the current date as it is known by the agent using its own real-time clock. The format would be as specified by the agnSDateFormat. This parameter can be set for time synchronization between the NMS and the Agent.')
agnSTimeCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnSTimeCmd.setStatus('mandatory')
if mibBuilder.loadTexts: agnSTimeCmd.setDescription('This entry indicates the current time as it is known by the agent using its own real-time clock. This parameter can be set for time synchronization between the NMS and the Agent.')
agnSActiveCnfg = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSActiveCnfg.setStatus('mandatory')
if mibBuilder.loadTexts: agnSActiveCnfg.setDescription('This entry specifies the unique identifier of the configuration, that is currently active and running.')
agnSEditCnfg = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSEditCnfg.setStatus('mandatory')
if mibBuilder.loadTexts: agnSEditCnfg.setDescription('This entry indicates the unique identifier of the configuration that is currently loaded into the tmp working space for manipulation and update operations. Value of 255 means no config. is under editing process.')
agnSLastCnfgFlipTime = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSLastCnfgFlipTime.setStatus('mandatory')
if mibBuilder.loadTexts: agnSLastCnfgFlipTime.setDescription('This entry indicates the Date & Time of the last flip to the current configuration at the agent.')
agnSLastCnfgFlipCause = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSLastCnfgFlipCause.setStatus('mandatory')
if mibBuilder.loadTexts: agnSLastCnfgFlipCause.setDescription("This entry describes the flip's cause.")
agnSEditBy = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("none", 1), ("snmp", 2), ("terCon1", 3), ("terCon2", 4), ("terInbandCon1", 5), ("terInbandCon2", 6), ("lcd", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSEditBy.setStatus('mandatory')
if mibBuilder.loadTexts: agnSEditBy.setDescription('This entry indicates which MMI application is working on the edited config. The editing phase starts at the first modify operation and ends after an update(load) operation.')
agnSClkSrc = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("master", 1), ("fallback", 2), ("internal", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSClkSrc.setStatus('mandatory')
if mibBuilder.loadTexts: agnSClkSrc.setDescription('This entry indicates the source of the system clock.')
agnSAlrStatus = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("off", 2), ("event", 3), ("minor", 4), ("major", 5), ("warning", 6), ("critical", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSAlrStatus.setStatus('mandatory')
if mibBuilder.loadTexts: agnSAlrStatus.setDescription('Indicates the alarm state in the agent level, i.e. lower level (card/port) alarms not included. critical(7) - when there is at least one active (state ON) critical alarm, otherwise it will be set to major(5) - when there is at least one active (state ON) major alarm, otherwise it will be set to minor(4) - if there is at least one active (state ON) minor alarm, otherwise it will be set to warning(6) - if there is at least one active (state ON) warning alarm, otherwise it will be set to event(3) - if there was at least one alarm event (including state on,off events) since the last clear operation.')
agnSAlrStatusAll = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("off", 2), ("event", 3), ("minor", 4), ("major", 5), ("warning", 6), ("critical", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSAlrStatusAll.setStatus('mandatory')
if mibBuilder.loadTexts: agnSAlrStatusAll.setDescription('Indicates the alarm state of the entire agent, i.e. including card and port alarms status. critical(7) - when there is at least one active (state ON) critical alarm, otherwise it will be set to major(5) - when there is at least one active (state ON) major alarm, otherwise it will be set to minor(4) - if there is at least one active (state ON) minor alarm, otherwise it will be set to warning(6) - if there is at least one active (state ON) warning alarm, otherwise it will be set to event(3) - if there was at least one alarm event (including state on,off events) since the last clear operation.')
agnSMaskedAlrStat = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("off", 2), ("event", 3), ("minor", 4), ("major", 5), ("warning", 6), ("critical", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSMaskedAlrStat.setStatus('mandatory')
if mibBuilder.loadTexts: agnSMaskedAlrStat.setDescription('Indicates the alarm state in the agent level,[ i.e. lower level (card/port) alarms not included] including Masked alarms. critical(7) - when there is at least one active (state ON) critical alarm, otherwise it will be set to major(5) - when there is at least one active (state ON) major alarm, otherwise it will be set to minor(4) - if there is at least one active (state ON) minor alarm, otherwise it will be set to warning(6) - if there is at least one active (state ON) warning alarm, otherwise it will be set to event(3) - if there was at least one alarm event (including state on,off events) since the last clear operation.')
agnSMaskedAlrStatAll = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("off", 2), ("event", 3), ("minor", 4), ("major", 5), ("warning", 6), ("critical", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSMaskedAlrStatAll.setStatus('mandatory')
if mibBuilder.loadTexts: agnSMaskedAlrStatAll.setDescription('Indicates the alarm state of the entire agent, i.e. including card and port alarms status,including Masked alarms. critical(7) - when there is at least one active (state ON) critical alarm, otherwise it will be set to major(5) - when there is at least one active (state ON) major alarm, otherwise it will be set to minor(4) - if there is at least one active (state ON) minor alarm, otherwise it will be set to warning(6) - if there is at least one active (state ON) warning alarm, otherwise it will be set to event(3) - if there was at least one alarm event (including state on,off events) since the last clear operation.')
agnSTstStatAll = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSTstStatAll.setStatus('mandatory')
if mibBuilder.loadTexts: agnSTstStatAll.setDescription('on(3) - when there is at least one test in progress in one of the agent cards, otherwise the value will be off(2).')
agnSAlrTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 15), )
if mibBuilder.loadTexts: agnSAlrTable.setStatus('mandatory')
if mibBuilder.loadTexts: agnSAlrTable.setDescription('List of agent related alarms and indications for alarms at system level.')
agnSAlrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 15, 1), ).setIndexNames((0, "DACS-MIB", "agnSAlrIdx"))
if mibBuilder.loadTexts: agnSAlrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: agnSAlrEntry.setDescription('')
agnSAlrIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 15, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSAlrIdx.setStatus('mandatory')
if mibBuilder.loadTexts: agnSAlrIdx.setDescription('A unique number to identify an entry in the alarm status table of the agent.')
agnSAlrCodeDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 15, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSAlrCodeDescription.setStatus('mandatory')
if mibBuilder.loadTexts: agnSAlrCodeDescription.setDescription('This attribute is a full text description of the alarm . The alarm description includes the following information: alarm code, alarm text, alarm severity, Masked or Inverted flag and counter.')
agnSAlrCode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 15, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSAlrCode.setStatus('mandatory')
if mibBuilder.loadTexts: agnSAlrCode.setDescription('A code identifying the alarm of an entry in the alarm status table at system level.')
agnSAlrSeverity = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 15, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("event", 3), ("minor", 4), ("major", 5), ("warning", 6), ("critical", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSAlrSeverity.setStatus('mandatory')
if mibBuilder.loadTexts: agnSAlrSeverity.setDescription('The severity of the alarm.')
agnSAlrState = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 15, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSAlrState.setStatus('mandatory')
if mibBuilder.loadTexts: agnSAlrState.setDescription('State of the alarm.')
agnSAlrCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 15, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSAlrCounter.setStatus('mandatory')
if mibBuilder.loadTexts: agnSAlrCounter.setDescription('A counter - how many times the alarm occured since last clear operation. ON and OFF Alarm will be counted separately.')
agnSAlrMask = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 15, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSAlrMask.setStatus('mandatory')
if mibBuilder.loadTexts: agnSAlrMask.setDescription('Alarm mask : on/off.')
agnSAlrInvert = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 15, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSAlrInvert.setStatus('mandatory')
if mibBuilder.loadTexts: agnSAlrInvert.setDescription('Alarm invert : on/off.')
agnSClearAlrCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnSClearAlrCmd.setStatus('mandatory')
if mibBuilder.loadTexts: agnSClearAlrCmd.setDescription('Setting this attribute to ON, enforce a clear operation on all the agent(general) events. General alarms are alarms which are not specific to a card or port. The clear operation will not be applied for masked/inverted alarms.')
agnSClearAllAlrCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnSClearAllAlrCmd.setStatus('mandatory')
if mibBuilder.loadTexts: agnSClearAllAlrCmd.setDescription('Setting this attribute to ON, enforce a clear operation on all MUX alarm events at the levels of agent, slots and ports. The clear operation will not be applied for masked/inverted alarms.')
agnSSanityCheckStatus = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("fail", 2), ("warning", 3), ("ok", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSSanityCheckStatus.setStatus('mandatory')
if mibBuilder.loadTexts: agnSSanityCheckStatus.setDescription('Upon completion of the Sanity check process on the TmpCnfg this attribute will be set to: FAIL(2) - when there is at least one error encountered and possibly some warnings. WARNING(3) - when there are only warnings. otherwise, the value will be OK(4). The value will be UNKNOWN(1) if changes were made in the TmpCnfg following the last Sanity check.')
agnSNoOfSanityCheckErr = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSNoOfSanityCheckErr.setStatus('mandatory')
if mibBuilder.loadTexts: agnSNoOfSanityCheckErr.setDescription('This entry indicates the number of errors/warnings discovered by the last SanityCheck process.')
agnSErrListTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 20), )
if mibBuilder.loadTexts: agnSErrListTable.setStatus('mandatory')
if mibBuilder.loadTexts: agnSErrListTable.setDescription('List of errors and warnings found during Sanity Check process.')
agnSErrListEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 20, 1), ).setIndexNames((0, "DACS-MIB", "agnSErrIdx"))
if mibBuilder.loadTexts: agnSErrListEntry.setStatus('mandatory')
if mibBuilder.loadTexts: agnSErrListEntry.setDescription('')
agnSErrIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 20, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSErrIdx.setStatus('mandatory')
if mibBuilder.loadTexts: agnSErrIdx.setDescription("Unique number to identify an entry in the error list table. The maximum entry value cannot exceed the value of 'agnSNoOfSanityCheckErr'. ")
agnSErrDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 20, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSErrDescription.setStatus('mandatory')
if mibBuilder.loadTexts: agnSErrDescription.setDescription('This attribute is a full text description of the sanity check error including error code, slot and port numbers related to the code .')
agnSMaxNoOfCnfg = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSMaxNoOfCnfg.setStatus('mandatory')
if mibBuilder.loadTexts: agnSMaxNoOfCnfg.setDescription('Maximum number of configurations that can be defined and stored in the MUX. If the mux has a large capacity, the maximum will be limited to 254.')
agnSCnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 22), )
if mibBuilder.loadTexts: agnSCnfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: agnSCnfgTable.setDescription('This table contains an entry per configuration. It indicates if the configuration is valid.')
agnSCnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 22, 1), ).setIndexNames((0, "DACS-MIB", "agnSEntryIdx"))
if mibBuilder.loadTexts: agnSCnfgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: agnSCnfgEntry.setDescription('')
agnSEntryIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 22, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSEntryIdx.setStatus('mandatory')
if mibBuilder.loadTexts: agnSEntryIdx.setDescription('Unique number to identify an entry in the configuration table.')
agnSEntryIsValid = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 1, 22, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSEntryIsValid.setStatus('mandatory')
if mibBuilder.loadTexts: agnSEntryIsValid.setDescription('This attribute indicates whether the specific configuration is valid in the MUX . Value of NO indicates: no such configuration in the MUX. ')
agnCSanityCheckCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCSanityCheckCmd.setStatus('mandatory')
if mibBuilder.loadTexts: agnCSanityCheckCmd.setDescription('Setting this attribute to on(3) will initiate the process of Sanity check on the TmpCnfg. Upon completion the value will automatically be changed to off(2).')
agnCSaveCnfgIdxCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCSaveCnfgIdxCmd.setStatus('mandatory')
if mibBuilder.loadTexts: agnCSaveCnfgIdxCmd.setDescription('This attribute specifies the Id of the target RealCnfg to which the TmpCnfg should be transferred. Upon set command the MUX will initiate the Sanity-Check process first. If successful, the actual transfer will be performed. If warnings are detected, the user will have to perform the command again to confirm the operation. Setting this object a second time to the same value without performing any change in the database, will cause the result: agnSSanityCheckStatus = unknown')
agnCLoadCnfgIdxCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCLoadCnfgIdxCmd.setStatus('mandatory')
if mibBuilder.loadTexts: agnCLoadCnfgIdxCmd.setDescription('This attribute specifies the Id of the source Cnfg to be loaded into the TmpCnfg. Upon set operation the actual transfer will be initiated. The operation is valid only on Valid configurations (agnSEntryIsValid)')
agnCClkSrcTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 4), )
if mibBuilder.loadTexts: agnCClkSrcTable.setStatus('mandatory')
if mibBuilder.loadTexts: agnCClkSrcTable.setDescription('All the entries of this table are identical (have the same value) for all the configurations (1..100) except the TmpCnfg. The write operation into the Table Objects is valid only for the TmpCnfg entry.')
agnCClkSrcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 4, 1), ).setIndexNames((0, "DACS-MIB", "agnCClkCnfgIdx"), (0, "DACS-MIB", "agnCClkSrcIdx"))
if mibBuilder.loadTexts: agnCClkSrcEntry.setStatus('mandatory')
if mibBuilder.loadTexts: agnCClkSrcEntry.setDescription('')
agnCClkCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnCClkCnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: agnCClkCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg(1..100) being accessed and Idx 255 relates to the TmpCnfg.')
agnCClkSrcIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnCClkSrcIdx.setStatus('mandatory')
if mibBuilder.loadTexts: agnCClkSrcIdx.setDescription('An index to the table. There are only two entries to this table. Index 1 points to the Master clock parameters and Index 2 points to the Fallback clock parameters')
agnCClkSrcMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("internal", 1), ("rxClk", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCClkSrcMode.setStatus('mandatory')
if mibBuilder.loadTexts: agnCClkSrcMode.setDescription('The source of the nodal timing.')
agnCClkSrcSlt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("notApplicable", 1), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCClkSrcSlt.setStatus('mandatory')
if mibBuilder.loadTexts: agnCClkSrcSlt.setDescription("This entry is valid only when we are working in rxClk mode. For an invalid entry, the return value will be '7fff'h.")
agnCClkSrcPrt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 100))).clone(namedValues=NamedValues(("exPrt1", 1), ("exPrt2", 2), ("exPrt3", 3), ("exPrt4", 4), ("exPrt5", 5), ("exPrt6", 6), ("exPrt7", 7), ("exPrt8", 8), ("exPrt9", 9), ("exPrt10", 10), ("exPrt11", 11), ("exPrt12", 12), ("notApplicable", 100)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCClkSrcPrt.setStatus('mandatory')
if mibBuilder.loadTexts: agnCClkSrcPrt.setDescription("This entry is valid only when we are working in rxClk mode. For an invalid entry, the return value will be '7fff'h.")
agnCDeleteCnfgIdxCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCDeleteCnfgIdxCmd.setStatus('mandatory')
if mibBuilder.loadTexts: agnCDeleteCnfgIdxCmd.setDescription('Setting this attribute will delete the requested DB from the NVRAM .')
agnCDefaultCnfgIdxCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCDefaultCnfgIdxCmd.setStatus('mandatory')
if mibBuilder.loadTexts: agnCDefaultCnfgIdxCmd.setDescription('Setting this attribute will define the desired working configuration when no conditions of the Flip DB Table are fulfilled and no Net GO command was issued. This command will be accepted only if the Configuration number exists (agnSEntryIsValid=yes).')
agnCnfgDataTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 7), )
if mibBuilder.loadTexts: agnCnfgDataTable.setStatus('mandatory')
if mibBuilder.loadTexts: agnCnfgDataTable.setDescription('This table contains data about the agent configurations. The table will support only data about valid configurations of the agent.')
agnCnfgDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 7, 1), ).setIndexNames((0, "DACS-MIB", "agnCnfgIdx"))
if mibBuilder.loadTexts: agnCnfgDataEntry.setStatus('mandatory')
if mibBuilder.loadTexts: agnCnfgDataEntry.setDescription('')
agnCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 7, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnCnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: agnCnfgIdx.setDescription("This object indicates the Idx of the agent' Cnfg the following objects refer. 255=Temporary Cnfg (Set is done only to this configuration).")
agnCnfgDesc = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 7, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCnfgDesc.setStatus('mandatory')
if mibBuilder.loadTexts: agnCnfgDesc.setDescription('This object is a description of the Configuration, entered by user, to enhance Cnfg recognition.')
agnCnfgUpdDate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 7, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnCnfgUpdDate.setStatus('mandatory')
if mibBuilder.loadTexts: agnCnfgUpdDate.setDescription('This object indicates the date when last update of this configuration was performed, as it is known by the agent using its own real-time clock. The format would be as specified by the agnSDateFormat. When update is performed, the agent should save the date.')
agnCnfgUpdTime = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 7, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnCnfgUpdTime.setStatus('mandatory')
if mibBuilder.loadTexts: agnCnfgUpdTime.setDescription('This object indicates the time when last update of this configuration was performed, as it is known by the agent using its own real-time clock. When update is performed, the agent should save the time.')
agnCnfgUpdMnger = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 7, 1, 5), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnCnfgUpdMnger.setStatus('mandatory')
if mibBuilder.loadTexts: agnCnfgUpdMnger.setDescription('This object indicates the IP Address of the Manager who performed the last update of this configuration. When update is performed, the agent should save the IP Address of the Manager who commanded the update. That will enable a manager to know if he performed the last update, or another manager did.')
agnCnfgAlarm = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 8))
agnCnfgAlrFilterWindow = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 8, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCnfgAlrFilterWindow.setStatus('mandatory')
if mibBuilder.loadTexts: agnCnfgAlrFilterWindow.setDescription("Window of time, in minutes. During this Window, the alarms filter is performed. Same Window for all agent alarms that need filtering. Upon end of the Window, the state of the alarm is updated and a new Window starts. If no alarm needs filtering, this object's value will not be used.")
agnCnfgAlrTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 8, 2), )
if mibBuilder.loadTexts: agnCnfgAlrTable.setStatus('mandatory')
if mibBuilder.loadTexts: agnCnfgAlrTable.setDescription("This table enables the user to set attributes to each alarm. Setting for a non-existing entry agnCnfgAlrMask, agnCnfgAlrInvert or agnCnfgAlrFilter to 'yes'(or yesAndSave for Mask) will add this new entry to the table. Setting for an existing entry agnCnfgAlrMask/ agnCnfgAlrInvert/agnCnfgAlrFilter (one or more) to 'no' (noAndSave for Mask) so that ALL these objects' values are 'no' , will delete this entry from the table. For agnCnfgAlrMask, only if [(last saved value=noAndSave) AND (new value is 'no' or 'noAndSave')] the object's value is considered 'no' for deleting the entry.")
agnCnfgAlrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 8, 2, 1), ).setIndexNames((0, "DACS-MIB", "agnCnfgAlrCode"), (0, "DACS-MIB", "agnCnfgAlrSlot"), (0, "DACS-MIB", "agnCnfgAlrPort"))
if mibBuilder.loadTexts: agnCnfgAlrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: agnCnfgAlrEntry.setDescription('')
agnCnfgAlrCode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 8, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnCnfgAlrCode.setStatus('mandatory')
if mibBuilder.loadTexts: agnCnfgAlrCode.setDescription('The alarm code. The following attributes refer this code.')
agnCnfgAlrSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 8, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 200, 255))).clone(namedValues=NamedValues(("psA", 1), ("psB", 2), ("clA", 3), ("clB", 4), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("io13", 17), ("io14", 18), ("io15", 19), ("all", 200), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnCnfgAlrSlot.setStatus('mandatory')
if mibBuilder.loadTexts: agnCnfgAlrSlot.setDescription('The alarm slot. The following attributes apply for the alarm code and slot selected. all = the attributes apply to all slots. notApplicable = the selected alarm is for system level.')
agnCnfgAlrPort = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 8, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnCnfgAlrPort.setStatus('mandatory')
if mibBuilder.loadTexts: agnCnfgAlrPort.setDescription("The alarm port. The following attributes apply for the alarm code,slot and port selected. 200 = all = the attributes apply to all ports of the selected slot. When selected Slot is 'all', only 'all' or 'notApplicable' are valid Port selections. notApplicable = the selected alarm is for system or card level. =255 for MP =100 for DXC - For MP, valid cards' ports are: exPrt1(1)..exPrt12(12) inPrt1(101)..inPrt48 (148) - For DXC, the port index will include the Slot, as for all DXC tables: [(IO Slot+10)&n] ; n=odd for external ports n=even for internal ports.")
agnCnfgAlrMask = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 8, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("no", 1), ("noAndSave", 2), ("yes", 3), ("yesAndSave", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCnfgAlrMask.setStatus('mandatory')
if mibBuilder.loadTexts: agnCnfgAlrMask.setDescription("An attribute defining the desired Mask state of an alarm . no - unmask (this command is not saved in agent's common database) noAndSave - unmask ; this command is saved in agent's common database yes - mask (this command is not saved in agent's common database) yesAndSave - mask ; this command is saved in agent's common database. Commands that are not saved, will be lost upon power-up or selected card removal. ")
agnCnfgAlrInvert = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 8, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCnfgAlrInvert.setStatus('mandatory')
if mibBuilder.loadTexts: agnCnfgAlrInvert.setDescription('An attribute defining the desired Invert state of an alarm . no - not inverted. yes - inverted. For MP, it is not applicable for alarms that are currently OFF.')
agnCnfgAlrFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 8, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCnfgAlrFilter.setStatus('mandatory')
if mibBuilder.loadTexts: agnCnfgAlrFilter.setDescription('An attribute defining if Filter is desired for the alarm . no - no filter. yes - filter activate. This filter is activated within a window of time defined by agnCnfgAlrFilterWindow. Its purpose is to avoid frequent changes of an alarm between ON/OFF states.')
agnCnfgAlrFilterSet = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 8, 2, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCnfgAlrFilterSet.setStatus('mandatory')
if mibBuilder.loadTexts: agnCnfgAlrFilterSet.setDescription('This is a top threshold causing the alarm that passes it, to be declared Set (ON) at the end of the respective window of time. - For alarms defined by default as state alarms (minor,major) this value will be in [%]. - For alarms defined by default as events, this value will be an integer meaning how many times this event should appear at least, during the window in order to be considered ON. The maximum valuewill be 255. This value should be greater than the one of agnCnfgAlrFilterReset. Agents that do not support Alarms Filter, will return 0.')
agnCnfgAlrFilterReset = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 8, 2, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCnfgAlrFilterReset.setStatus('mandatory')
if mibBuilder.loadTexts: agnCnfgAlrFilterReset.setDescription('This is a bottom threshold causing the alarm that does not pass it, to be declared Reset (ON) at the end of the respective window of time. - For alarms defined by default as state alarms (minor,major) this value will be in [%]. - For alarms defined by default as events, this value will be an integer meaning how many times this event should appear at most, during the window, in order to be considered OFF. This value should be less than the one of agnCnfgAlrFilterSet. Agents that do not support Alarms Filter, will return 0.')
agnCnfgAlrReportTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 8, 3), )
if mibBuilder.loadTexts: agnCnfgAlrReportTable.setStatus('mandatory')
if mibBuilder.loadTexts: agnCnfgAlrReportTable.setDescription('This table enables the user to configure the desired Alarm Reports according to alarms severity.')
agnCnfgAlrReportEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 8, 3, 1), ).setIndexNames((0, "DACS-MIB", "agnCnfgAlrReportType"))
if mibBuilder.loadTexts: agnCnfgAlrReportEntry.setStatus('mandatory')
if mibBuilder.loadTexts: agnCnfgAlrReportEntry.setDescription('')
agnCnfgAlrReportType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 8, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("trap", 1), ("buffer", 2), ("relay", 3), ("alrLedOn", 4), ("alrLedBlink", 5), ("relay2", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnCnfgAlrReportType.setStatus('mandatory')
if mibBuilder.loadTexts: agnCnfgAlrReportType.setDescription("The alarm report type. trap - traps will be sent only for alarms having the selected On/Off severity or higher. buffer - only alarms having the selected On/Off severity and higher, will be reported to the buffer. relay - relay contact will be activated only for alarms having the selected On severity or higher. For products having 2 relays, this is the Minor Relay. alrLedOn/alrLedBlink - user should select a higher severity (ReportOn) for alrLedBlink than for alrLedOn (Blinking Led means a more severe alarm than steady ON Led). alrLedOn - MTCL-1 Alarm Led will be ON only when agnSAlrStatusAll equals the selected severity or higher, but lower severity than that selected for 'alrLedBlink'. For products having 2 LEDs, this is the Minor LED. alrLedBlink - MTCL-1 Alarm Led will Blink only when agnSAlrStatusAll equals the selected severity or higher. For products having 2 LEDs, this is the Major LED. relay2 - relay 2 contact will be activated only for alarms having the selected On severity or higher. This is the Major Relay.")
agnCnfgAlrStartReportOn = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 8, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("noReport", 2), ("event", 3), ("minor", 4), ("major", 5), ("warning", 6), ("critical", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCnfgAlrStartReportOn.setStatus('mandatory')
if mibBuilder.loadTexts: agnCnfgAlrStartReportOn.setDescription('This object specifies the severity from which alarms will be reported. Alarms having this severity or higher, will be reported. This object specifies the report severity only for alarms that turn to ON state. noReport - no Report at all (for any severity).')
agnCnfgAlrStartReportOff = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 8, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("notApplicable", 1), ("noReport", 2), ("event", 3), ("minor", 4), ("major", 5), ("warning", 6), ("critical", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCnfgAlrStartReportOff.setStatus('mandatory')
if mibBuilder.loadTexts: agnCnfgAlrStartReportOff.setDescription("This object specifies the severity from which alarms will be reported. Alarms having this severity or higher, will be reported. This object specifies the report severity only for alarms that turn to OFF state. notApplicable - for 'relay','alrLedOn','alrLedBlink', 'relay2' report types, in MP. noReport - no Report at all (for any severity).")
agnCOffsetCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 2, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("normal", 2), ("u1", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCOffsetCmd.setStatus('mandatory')
if mibBuilder.loadTexts: agnCOffsetCmd.setDescription('An object defining special user request. notApplicable - is RO value for products that do not support this object. normal - nothing special u1 - user 1 - for all Voice cards, the DISPLAYED Tx and Rx Levels will have the following Offsets: - 2 Wires port: Tx Level: the base value (for 0dBm) = 0 Rx Level: the base value (for 0dBm) = -2 - 4 Wires port: Tx Level: the base value (for 0dBm) = -16 Rx Level: the base value (for 0dBm) = 7 The MIB and application DB will use the values without Offset.')
agnCmprTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 1), )
if mibBuilder.loadTexts: agnCmprTable.setStatus('mandatory')
if mibBuilder.loadTexts: agnCmprTable.setDescription('')
agnCmprEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 1, 1), ).setIndexNames((0, "DACS-MIB", "agnCmprTypIdx"), (0, "DACS-MIB", "agnCmprCnfgIdx"), (0, "DACS-MIB", "agnCmprVersion"))
if mibBuilder.loadTexts: agnCmprEntry.setStatus('mandatory')
if mibBuilder.loadTexts: agnCmprEntry.setDescription('')
agnCmprTypIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnCmprTypIdx.setStatus('mandatory')
if mibBuilder.loadTexts: agnCmprTypIdx.setDescription('This attribute indicates the Type of the Compressed being referred.')
agnCmprCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnCmprCnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: agnCmprCnfgIdx.setDescription('This attribute indicates the configuration to which the Compressed information is related.')
agnCmprVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnCmprVersion.setStatus('mandatory')
if mibBuilder.loadTexts: agnCmprVersion.setDescription('This attribute indicates the version of the internal format of the Compressed data')
agnCmprObj = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 1, 1, 4), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCmprObj.setStatus('mandatory')
if mibBuilder.loadTexts: agnCmprObj.setDescription('This attribute is the compressed information itself.')
agnDlciCmprTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 2), )
if mibBuilder.loadTexts: agnDlciCmprTable.setStatus('mandatory')
if mibBuilder.loadTexts: agnDlciCmprTable.setDescription('')
agnDlciCmprEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 2, 1), ).setIndexNames((0, "DACS-MIB", "agnDlciCmprCnfgIdx"), (0, "DACS-MIB", "agnDlciCmprVersion"), (0, "DACS-MIB", "agnDlciCmprDlciIdx"))
if mibBuilder.loadTexts: agnDlciCmprEntry.setStatus('mandatory')
if mibBuilder.loadTexts: agnDlciCmprEntry.setDescription('')
agnDlciCmprCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnDlciCmprCnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: agnDlciCmprCnfgIdx.setDescription('This attribute indicates the configuration to which the Compressed information is related.')
agnDlciCmprVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnDlciCmprVersion.setStatus('mandatory')
if mibBuilder.loadTexts: agnDlciCmprVersion.setDescription('This attribute indicates the version of the internal format of the Compressed data')
agnDlciCmprDlciIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnDlciCmprDlciIdx.setStatus('mandatory')
if mibBuilder.loadTexts: agnDlciCmprDlciIdx.setDescription('This attribute indicates a unique identifier of the Dlci, the compressed information relates to. The values are between 16 - 991.')
agnDlciCmprObj = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 2, 1, 4), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnDlciCmprObj.setStatus('mandatory')
if mibBuilder.loadTexts: agnDlciCmprObj.setDescription('This attribute is the compressed information itself.')
agnAlarmsCmprTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 3), )
if mibBuilder.loadTexts: agnAlarmsCmprTable.setStatus('mandatory')
if mibBuilder.loadTexts: agnAlarmsCmprTable.setDescription('')
agnAlarmsCmprEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 3, 1), ).setIndexNames((0, "DACS-MIB", "agnAlarmsCmprVersion"), (0, "DACS-MIB", "agnAlarmsCmprAlarmIdx"))
if mibBuilder.loadTexts: agnAlarmsCmprEntry.setStatus('mandatory')
if mibBuilder.loadTexts: agnAlarmsCmprEntry.setDescription('')
agnAlarmsCmprVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnAlarmsCmprVersion.setStatus('mandatory')
if mibBuilder.loadTexts: agnAlarmsCmprVersion.setDescription('This attribute indicates the version of the internal format of the Compressed data')
agnAlarmsCmprAlarmIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnAlarmsCmprAlarmIdx.setStatus('mandatory')
if mibBuilder.loadTexts: agnAlarmsCmprAlarmIdx.setDescription('A unique number to identify an entry in the alarm status table of the agent.')
agnAlarmsCmprObj = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 3, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnAlarmsCmprObj.setStatus('mandatory')
if mibBuilder.loadTexts: agnAlarmsCmprObj.setDescription('This attribute is the compressed information itself.')
agnAlrBufCmprTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 4), )
if mibBuilder.loadTexts: agnAlrBufCmprTable.setStatus('mandatory')
if mibBuilder.loadTexts: agnAlrBufCmprTable.setDescription('')
agnAlrBufCmprEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 4, 1), ).setIndexNames((0, "DACS-MIB", "agnAlrBufCmprVersion"), (0, "DACS-MIB", "agnAlrBufCmprAlarmIdx"))
if mibBuilder.loadTexts: agnAlrBufCmprEntry.setStatus('mandatory')
if mibBuilder.loadTexts: agnAlrBufCmprEntry.setDescription('')
agnAlrBufCmprVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnAlrBufCmprVersion.setStatus('mandatory')
if mibBuilder.loadTexts: agnAlrBufCmprVersion.setDescription('This attribute indicates the version of the internal format of the Compressed data')
agnAlrBufCmprAlarmIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnAlrBufCmprAlarmIdx.setStatus('mandatory')
if mibBuilder.loadTexts: agnAlrBufCmprAlarmIdx.setDescription('A unique number to identify an entry in the history alarms buffer of the agent.')
agnAlrBufCmprObj = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 4, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnAlrBufCmprObj.setStatus('mandatory')
if mibBuilder.loadTexts: agnAlrBufCmprObj.setDescription('This attribute is the compressed information itself.')
agnSCmprErrListTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 5), )
if mibBuilder.loadTexts: agnSCmprErrListTable.setStatus('mandatory')
if mibBuilder.loadTexts: agnSCmprErrListTable.setDescription('')
agnSCmprErrListEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 5, 1), ).setIndexNames((0, "DACS-MIB", "agnSCmprErrVersion"), (0, "DACS-MIB", "agnSCmprErrIdx"))
if mibBuilder.loadTexts: agnSCmprErrListEntry.setStatus('mandatory')
if mibBuilder.loadTexts: agnSCmprErrListEntry.setDescription('')
agnSCmprErrVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSCmprErrVersion.setStatus('mandatory')
if mibBuilder.loadTexts: agnSCmprErrVersion.setDescription('The version of the compressed data ')
agnSCmprErrIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 5, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSCmprErrIdx.setStatus('mandatory')
if mibBuilder.loadTexts: agnSCmprErrIdx.setDescription("Unique number to identify an entry in the errors list table. The maximum entry value cannot exceed the value of 'agnSNoOfSanityCheckErr'. ")
agnSCmprErrObj = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 5, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSCmprErrObj.setStatus('mandatory')
if mibBuilder.loadTexts: agnSCmprErrObj.setDescription('This attribute is a full text description of the error, including: error code, slot and port numbers related to the code .')
agnTsCmprTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 6), )
if mibBuilder.loadTexts: agnTsCmprTable.setStatus('mandatory')
if mibBuilder.loadTexts: agnTsCmprTable.setDescription('')
agnTsCmprEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 6, 1), ).setIndexNames((0, "DACS-MIB", "agnTsCmprVerIdx"), (0, "DACS-MIB", "agnTsCmprCnfgIdx"), (0, "DACS-MIB", "agnTsCmprSlotIdx"), (0, "DACS-MIB", "agnTsCmprPortIdx"), (0, "DACS-MIB", "agnTsCmprPduIdx"))
if mibBuilder.loadTexts: agnTsCmprEntry.setStatus('mandatory')
if mibBuilder.loadTexts: agnTsCmprEntry.setDescription('')
agnTsCmprVerIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnTsCmprVerIdx.setStatus('mandatory')
if mibBuilder.loadTexts: agnTsCmprVerIdx.setDescription('This object indicates the version of the internal format of the Compressed data.')
agnTsCmprCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 6, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnTsCmprCnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: agnTsCmprCnfgIdx.setDescription('This object indicates the configuration to which the Compressed information is related. 255=temporary configuration. Set can be performed only to the temporary configuration.')
agnTsCmprSlotIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 6, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnTsCmprSlotIdx.setStatus('mandatory')
if mibBuilder.loadTexts: agnTsCmprSlotIdx.setDescription('This object indicates the Slot to which the Compressed information is related. For MP-2100: IO-1..IO-12 = (5).. (16) For DXC-30 : IO-1..IO-15 = (5).. (19).')
agnTsCmprPortIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 6, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnTsCmprPortIdx.setStatus('mandatory')
if mibBuilder.loadTexts: agnTsCmprPortIdx.setDescription("This object indicates the Port within the Slot, to which the Compressed information is related. For Port Index see each product's spec.")
agnTsCmprPduIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 6, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnTsCmprPduIdx.setStatus('mandatory')
if mibBuilder.loadTexts: agnTsCmprPduIdx.setDescription('This object indicates the PDU index within the same port. That provides for the case when one PDU is not sufficient for all TS Assignment data of the same port.')
agnTsCmprData = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 6, 1, 6), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnTsCmprData.setStatus('mandatory')
if mibBuilder.loadTexts: agnTsCmprData.setDescription('This object is the compressed information itself. It provides information about all TSs of a port.')
agnXCmprTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 7), )
if mibBuilder.loadTexts: agnXCmprTable.setStatus('mandatory')
if mibBuilder.loadTexts: agnXCmprTable.setDescription('')
agnXCmprEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 7, 1), ).setIndexNames((0, "DACS-MIB", "agnXCmprTypIdx"), (0, "DACS-MIB", "agnXCmprVersion"), (0, "DACS-MIB", "agnXCmprIdx3"), (0, "DACS-MIB", "agnXCmprIdx4"), (0, "DACS-MIB", "agnXCmprIdx5"), (0, "DACS-MIB", "agnXCmprIdx6"), (0, "DACS-MIB", "agnXCmprIdx7"))
if mibBuilder.loadTexts: agnXCmprEntry.setStatus('mandatory')
if mibBuilder.loadTexts: agnXCmprEntry.setDescription('')
agnXCmprTypIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 7, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnXCmprTypIdx.setStatus('mandatory')
if mibBuilder.loadTexts: agnXCmprTypIdx.setDescription('This attribute indicates the Type of the Compressed being referred. One of the types is V5.1 Variant data.')
agnXCmprVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 7, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnXCmprVersion.setStatus('mandatory')
if mibBuilder.loadTexts: agnXCmprVersion.setDescription('This attribute indicates the version of the internal format of the Compressed data.')
agnXCmprIdx3 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 7, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnXCmprIdx3.setStatus('mandatory')
if mibBuilder.loadTexts: agnXCmprIdx3.setDescription('3rd index - can be used for any purpose according to the agnXCmprTypIdx. Example: for V5.1 Variant, this attribute indicates the configuration to which the Compressed information is related. 255=temporary configuration. Set can be performed only to the temporary configuration.')
agnXCmprIdx4 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 7, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnXCmprIdx4.setStatus('mandatory')
if mibBuilder.loadTexts: agnXCmprIdx4.setDescription('4th index - can be used for any purpose according to the agnXCmprTypIdx. Example: for V5.1 Variant,this attribute indicates a unique number of the slot position where the card is inserted. Valid values: psA(1),psB(2),clA(3),clB(4),io1(5)..io12(16); notApplicable=255.')
agnXCmprIdx5 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 7, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnXCmprIdx5.setStatus('mandatory')
if mibBuilder.loadTexts: agnXCmprIdx5.setDescription('5th index - can be used for any purpose according to the agnXCmprTypIdx. Example: for V5.1 Variant,this attribute indicates a unique identifier of the port the compressed information relates to. Valid values: exPrt1 (1) .. exPrt12 (12) , inPrt1 (101) .. inPrt48 (148).')
agnXCmprIdx6 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 7, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnXCmprIdx6.setStatus('mandatory')
if mibBuilder.loadTexts: agnXCmprIdx6.setDescription('6th index - can be used for any purpose according to the agnXCmprTypIdx. Example: for V5.1 Variant,this attribute indicates the Variant index. Valid values are: 0..127, 255 (= temp cnfg).Set can be performed only to the temporary configuration.')
agnXCmprIdx7 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 7, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnXCmprIdx7.setStatus('mandatory')
if mibBuilder.loadTexts: agnXCmprIdx7.setDescription('7th index - can be used for any purpose according to the agnXCmprTypIdx. Example: for V5.1 Variant,this attribute is not needed. Therefore, its value will be always 255=notApplicable.')
agnXCmprObj = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 3, 7, 1, 8), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnXCmprObj.setStatus('mandatory')
if mibBuilder.loadTexts: agnXCmprObj.setDescription('This attribute is the compressed information itself.')
agnLinkMapTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 5, 1), )
if mibBuilder.loadTexts: agnLinkMapTable.setStatus('mandatory')
if mibBuilder.loadTexts: agnLinkMapTable.setDescription('')
agnLinkMapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 5, 1, 1), ).setIndexNames((0, "DACS-MIB", "mapLinkId"))
if mibBuilder.loadTexts: agnLinkMapEntry.setStatus('mandatory')
if mibBuilder.loadTexts: agnLinkMapEntry.setDescription('')
mapLinkId = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 5, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mapLinkId.setStatus('mandatory')
if mibBuilder.loadTexts: mapLinkId.setDescription('A unique identifier of the link')
mapLinkSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("noConnect", 2), ("clA", 3), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mapLinkSltIdx.setStatus('mandatory')
if mibBuilder.loadTexts: mapLinkSltIdx.setDescription('This attribute indicates a unique slot position where the card is inserted. In the ?004 Unit the entries clA(3), io6(10)..io12(16) are not valid.')
mapLinkPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 5, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112))).clone(namedValues=NamedValues(("exPrt1", 1), ("exPrt2", 2), ("exPrt3", 3), ("exPrt4", 4), ("exPrt5", 5), ("exPrt6", 6), ("exPrt7", 7), ("exPrt8", 8), ("exPrt9", 9), ("exPrt10", 10), ("exPrt11", 11), ("exPrt12", 12), ("noConnect", 100), ("inPrt1", 101), ("inPrt2", 102), ("inPrt3", 103), ("inPrt4", 104), ("inPrt5", 105), ("inPrt6", 106), ("inPrt7", 107), ("inPrt8", 108), ("inPrt9", 109), ("inPrt10", 110), ("inPrt11", 111), ("inPrt12", 112)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mapLinkPrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: mapLinkPrtIdx.setDescription('This attribute indicates a unique port number. ')
mapLinkStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 5, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("down", 2), ("up", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mapLinkStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mapLinkStatus.setDescription('This attribute indicates the status of the link between the two muxes')
ethIf = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1))
ethIfTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 1), )
if mibBuilder.loadTexts: ethIfTable.setStatus('mandatory')
if mibBuilder.loadTexts: ethIfTable.setDescription('')
ethIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 1, 1), ).setIndexNames((0, "DACS-MIB", "ethIfIdx"))
if mibBuilder.loadTexts: ethIfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ethIfEntry.setDescription('')
ethIfIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIfIdx.setStatus('mandatory')
if mibBuilder.loadTexts: ethIfIdx.setDescription('A unique index of the ethernet interface/port.')
ethMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("halfDuplex", 1), ("fullDuplex", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethMode.setStatus('mandatory')
if mibBuilder.loadTexts: ethMode.setDescription('This object indicates the Ethernet mode of operation.')
ethBridgingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 6, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("filtered", 1), ("transparent", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethBridgingMode.setStatus('mandatory')
if mibBuilder.loadTexts: ethBridgingMode.setDescription('This object indicates the bridging mode of the Ethernet interface. ')
alrBufTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 4, 1), )
if mibBuilder.loadTexts: alrBufTable.setStatus('mandatory')
if mibBuilder.loadTexts: alrBufTable.setDescription('')
alrBufEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 4, 1, 1), ).setIndexNames((0, "DACS-MIB", "alrBufIdx"))
if mibBuilder.loadTexts: alrBufEntry.setStatus('mandatory')
if mibBuilder.loadTexts: alrBufEntry.setDescription('')
alrBufIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 4, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alrBufIdx.setStatus('mandatory')
if mibBuilder.loadTexts: alrBufIdx.setDescription('This attribute indicates a unique number to identify this entry')
alrBufDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 4, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: alrBufDescription.setStatus('mandatory')
if mibBuilder.loadTexts: alrBufDescription.setDescription('This entry is a unique text description of the alarm in the buffer. The alarm description includes the following information: alarm code, slot id, card type, channel id , alarm text, alarm status, masked flag and event counter')
agnCAgendaTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 1), )
if mibBuilder.loadTexts: agnCAgendaTable.setStatus('mandatory')
if mibBuilder.loadTexts: agnCAgendaTable.setDescription('This table devides the week days into categories needed for DB flip consideration.')
agnCAgendaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 1, 1), ).setIndexNames((0, "DACS-MIB", "agnCAgendaCnfgIdx"), (0, "DACS-MIB", "agnCAgendaDayIdx"))
if mibBuilder.loadTexts: agnCAgendaEntry.setStatus('mandatory')
if mibBuilder.loadTexts: agnCAgendaEntry.setDescription('')
agnCAgendaCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 255))).clone(namedValues=NamedValues(("active", 1), ("temporary", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnCAgendaCnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: agnCAgendaCnfgIdx.setDescription('Active or Temporary Agenda Table. Both configurations can be read but only the Temporary can be written to.')
agnCAgendaDayIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("sunday", 1), ("monday", 2), ("tuesday", 3), ("wednesday", 4), ("thursday", 5), ("friday", 6), ("saturday", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnCAgendaDayIdx.setStatus('mandatory')
if mibBuilder.loadTexts: agnCAgendaDayIdx.setDescription('Day of week')
agnCAgendaDayCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("fullWorkday", 1), ("partialWorkday", 2), ("weekend", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCAgendaDayCategory.setStatus('mandatory')
if mibBuilder.loadTexts: agnCAgendaDayCategory.setDescription('The Category of the Day ')
agnCFlipNetEventsTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 2), )
if mibBuilder.loadTexts: agnCFlipNetEventsTable.setStatus('mandatory')
if mibBuilder.loadTexts: agnCFlipNetEventsTable.setDescription('This table holds the Net Events the MUX should trace')
agnCFlipNetEventsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 2, 1), ).setIndexNames((0, "DACS-MIB", "agnCFlipNetEventsCnfgIdx"), (0, "DACS-MIB", "agnCFlipNetEventIdx"))
if mibBuilder.loadTexts: agnCFlipNetEventsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: agnCFlipNetEventsEntry.setDescription('')
agnCFlipNetEventsCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 255))).clone(namedValues=NamedValues(("active", 1), ("temporary", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnCFlipNetEventsCnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: agnCFlipNetEventsCnfgIdx.setDescription('Active or Temporary Net Events Table. Both configurations can be read but only the Temporary can be written to.')
agnCFlipNetEventIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnCFlipNetEventIdx.setStatus('mandatory')
if mibBuilder.loadTexts: agnCFlipNetEventIdx.setDescription('Entry within the table')
agnCFlipNetEventActive = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCFlipNetEventActive.setStatus('mandatory')
if mibBuilder.loadTexts: agnCFlipNetEventActive.setDescription('Indicates if the entry is valid. In order to Add/Modify parameters of an entry, this object should be set to Yes. In order to delete an entry, this object should be Set to No.')
agnCFlipNetEventType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("time", 1), ("linkDown", 2), ("congestion", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCFlipNetEventType.setStatus('mandatory')
if mibBuilder.loadTexts: agnCFlipNetEventType.setDescription('The Net Event type ')
agnCFlipNetEventNo = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 512))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCFlipNetEventNo.setStatus('mandatory')
if mibBuilder.loadTexts: agnCFlipNetEventNo.setDescription('The Net Event No. (Bit Index)')
agnCFlipNetEventSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("notApplicable", 1), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCFlipNetEventSlot.setStatus('mandatory')
if mibBuilder.loadTexts: agnCFlipNetEventSlot.setDescription('The slot to which the net event relates . Not applicable for time event')
agnCFlipNetEventPort = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 100, 101, 102, 103, 104, 105, 106, 107, 108))).clone(namedValues=NamedValues(("exPrt1", 1), ("exPrt2", 2), ("exPrt3", 3), ("exPrt4", 4), ("exPrt5", 5), ("exPrt6", 6), ("exPrt7", 7), ("exPrt8", 8), ("exPrt9", 9), ("exPrt10", 10), ("exPrt11", 11), ("exPrt12", 12), ("notApplicable", 100), ("inPrt1", 101), ("inPrt2", 102), ("inPrt3", 103), ("inPrt4", 104), ("inPrt5", 105), ("inPrt6", 106), ("inPrt7", 107), ("inPrt8", 108)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCFlipNetEventPort.setStatus('mandatory')
if mibBuilder.loadTexts: agnCFlipNetEventPort.setDescription('The port within the relevant slot')
agnCFlipNetEventISD = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 999))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCFlipNetEventISD.setStatus('mandatory')
if mibBuilder.loadTexts: agnCFlipNetEventISD.setDescription('The time in seconds since the Net Event was reported as ON until it is considered as ON. Not relevant for time events.')
agnCFlipNetEventOSD = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 999))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCFlipNetEventOSD.setStatus('mandatory')
if mibBuilder.loadTexts: agnCFlipNetEventOSD.setDescription('The time in seconds since the net event was reported as OFF until it is considered as OFF. Not relevant for time events.')
agnCFlipNetEventDayType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("fullWorkday", 2), ("partialWorkday", 3), ("weekend", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCFlipNetEventDayType.setStatus('mandatory')
if mibBuilder.loadTexts: agnCFlipNetEventDayType.setDescription('The time event relates to all days defined in this category in the agnCAgendaTable. Applicable only for time event')
agnCFlipNetEventStartTime = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 2, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(5, 5)).setFixedLength(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCFlipNetEventStartTime.setStatus('mandatory')
if mibBuilder.loadTexts: agnCFlipNetEventStartTime.setDescription('The time event will be activated at this time. The format is hh:mm.')
agnCFlipNetEventEndTime = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 2, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(5, 5)).setFixedLength(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCFlipNetEventEndTime.setStatus('mandatory')
if mibBuilder.loadTexts: agnCFlipNetEventEndTime.setDescription('The time event will be deactivated at this time. The format is hh:mm.')
agnCFlipTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 3), )
if mibBuilder.loadTexts: agnCFlipTable.setStatus('mandatory')
if mibBuilder.loadTexts: agnCFlipTable.setDescription('The DB Flip Decisions Table')
agnCFlipEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 3, 1), ).setIndexNames((0, "DACS-MIB", "agnCFlipCnfgIdx"), (0, "DACS-MIB", "agnCFlipIdx"))
if mibBuilder.loadTexts: agnCFlipEntry.setStatus('mandatory')
if mibBuilder.loadTexts: agnCFlipEntry.setDescription('')
agnCFlipCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 255))).clone(namedValues=NamedValues(("active", 1), ("temporary", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnCFlipCnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: agnCFlipCnfgIdx.setDescription('Active or Temporary Flip Decisions Table. Both configurations can be read but only the Temporary can be written to.')
agnCFlipIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnCFlipIdx.setStatus('mandatory')
if mibBuilder.loadTexts: agnCFlipIdx.setDescription('Entry number within the table')
agnCFlipActive = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCFlipActive.setStatus('mandatory')
if mibBuilder.loadTexts: agnCFlipActive.setDescription('Indicates if the entry is valid. In order to Add/Modify parameters of an entry this object should be Set to Yes. In order to delete an entry, this object should be Set to No.')
agnCFlipLogicalExp = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 3, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCFlipLogicalExp.setStatus('mandatory')
if mibBuilder.loadTexts: agnCFlipLogicalExp.setDescription("A logical expression composed of events numbers (which were configured in the 'AgnCFlipNetEvantsTable') and logical operators ('|', '&', '!', '(', ')') between them. e.g - (1 & !2) | (121 & 230)")
agnCFlipDbNo = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCFlipDbNo.setStatus('mandatory')
if mibBuilder.loadTexts: agnCFlipDbNo.setDescription('The ID of the required DB ')
agnCFlipDiscardDe = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCFlipDiscardDe.setStatus('mandatory')
if mibBuilder.loadTexts: agnCFlipDiscardDe.setDescription('Indicates whether the Mux should start discarding all DE. (MP3000 Only).')
agnFlipDbControls = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 4))
agnCFlipDbSanityCheckCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCFlipDbSanityCheckCmd.setStatus('mandatory')
if mibBuilder.loadTexts: agnCFlipDbSanityCheckCmd.setDescription('Setting this attribute to on(3) will initiate the process of Sanity check on the Temp Flip Db and automatically be changed to off(2).')
agnCSaveFlipDbCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 4, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCSaveFlipDbCmd.setStatus('mandatory')
if mibBuilder.loadTexts: agnCSaveFlipDbCmd.setDescription("Setting this attribute to on(3) will initiate the process of Sanity check on the Temp Flip Db and if it is OK, it will save the Flip Db in the NVRAM, activating the new Flip DB . If check detects errors, the save will not be performed. Afterwards, the object's value will change automatically to off(2).")
agnCSaveNetCnfgIdxCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 4, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCSaveNetCnfgIdxCmd.setStatus('mandatory')
if mibBuilder.loadTexts: agnCSaveNetCnfgIdxCmd.setDescription("This attribute specifies the Id of the target NVRAM Cnfg to which the TmpCnfg should be transferred. Upon set command the MUX will initiate the Sanity-Check process first. If successful, the actual transfer will be performed. If warnings are detected, the user will have to perform the command again to confirm the operation. Setting this object a second time to the same value without performing any change in the database, will cause the result: agnSSanityCheckStatus = unknown. This attribute doesn't cause actual Flip.")
agnCSaveNetFlipDbCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 4, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCSaveNetFlipDbCmd.setStatus('mandatory')
if mibBuilder.loadTexts: agnCSaveNetFlipDbCmd.setDescription('Setting this attribute to on(3) will save the Temp Flip DB Into the NVRAM without actual flip.')
agnCNetGoCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 4, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCNetGoCmd.setStatus('mandatory')
if mibBuilder.loadTexts: agnCNetGoCmd.setDescription("Setting this attribute to On will broadcast a 'GO' command to the network. When a Mux receives a 'GO' command it issues a delay for 'agnCNetDelay' seconds and then activates the DB which was pre-defined by one of the commands : 'agnCSaveNetCnfgIdxCmd' or 'agnCSaveNetFlipDbCmd'.")
agnCNetDelay = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 4, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 999))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCNetDelay.setStatus('mandatory')
if mibBuilder.loadTexts: agnCNetDelay.setDescription("This attribute determines the period of time in seconds that takes for a message to be transferred over all the network. After a 'GO' command the MUX issues a delay of 'agnCNetDelay' before activating the appropriate DB. The delay will be applied only after performing agnCSaveFlipDbCmd.")
agnCNetEventsBcast = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 4, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCNetEventsBcast.setStatus('mandatory')
if mibBuilder.loadTexts: agnCNetEventsBcast.setDescription('This object determines if the Net Events will be Broadcasted to other Muxes of the Net or not. disabled - Net Events will NOT be Broadcasted enabled - Net Events will be Broadcasted. Default=disabled. The value will be applied only after performing agnCSaveFlipDbCmd.')
agnCNetEventsBcastInterval = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 5, 4, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnCNetEventsBcastInterval.setStatus('mandatory')
if mibBuilder.loadTexts: agnCNetEventsBcastInterval.setDescription('When agnCNetEventsBcast is enabled, this object determines the interval of time in seconds, between two consecutive Net Events transferred over the network. Default=40 sec. The interval will be applied only after performing agnCSaveFlipDbCmd.')
agnSaSwchStatus = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 6, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSaSwchStatus.setStatus('mandatory')
if mibBuilder.loadTexts: agnSaSwchStatus.setDescription("This object indicates the status of the switches on the stand-alone unit. Each switch is represented by a bit. The status is a sum of 2**n, according to the bits: bit 0 NMS (LSB) bit 1 Terminal '1' = forces the DCE to be terminal with Rate=9600bps, Data bits=8, Stop bits=1 bit 2 Xray bit 3 SW-Load '1' = when SW is loaded bit 4 DBS Default of all bits=0 When the status of these switches is unknown, the value of this object is 255.")
agnListDecodingTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 7, 1), )
if mibBuilder.loadTexts: agnListDecodingTable.setStatus('mandatory')
if mibBuilder.loadTexts: agnListDecodingTable.setDescription('A decoding table . For each type of list, a description is given for each existing code.')
agnListDecodingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 7, 1, 1), ).setIndexNames((0, "DACS-MIB", "agnListDecodingType"), (0, "DACS-MIB", "agnListDecodingCode"))
if mibBuilder.loadTexts: agnListDecodingEntry.setStatus('mandatory')
if mibBuilder.loadTexts: agnListDecodingEntry.setDescription('')
agnListDecodingType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 7, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("alr", 1), ("sanity", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnListDecodingType.setStatus('mandatory')
if mibBuilder.loadTexts: agnListDecodingType.setDescription('The type of list the decoding data refers to. alr - Alarms list sanity - Sanity Check Error list. ')
agnListDecodingCode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 7, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnListDecodingCode.setStatus('mandatory')
if mibBuilder.loadTexts: agnListDecodingCode.setDescription('The specific code for which decoding is needed. ')
agnListDecodingDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 7, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnListDecodingDescription.setStatus('mandatory')
if mibBuilder.loadTexts: agnListDecodingDescription.setDescription('The description fitting the specific code and type of list required. ')
agnListDecodingDefState = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 7, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 4, 5))).clone(namedValues=NamedValues(("notApplicable", 1), ("event", 3), ("minor", 4), ("major", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnListDecodingDefState.setStatus('mandatory')
if mibBuilder.loadTexts: agnListDecodingDefState.setDescription('This object is applicable only for agnListDecodingType=alr. It reports the default state/severity of each alarm. User can change the severity of the alarms defined by this default via the agnListDecodingSeverity object.')
agnListDecodingSeverity = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 7, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("notApplicable", 1), ("event", 3), ("minor", 4), ("major", 5), ("warning", 6), ("critical", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnListDecodingSeverity.setStatus('mandatory')
if mibBuilder.loadTexts: agnListDecodingSeverity.setDescription("This object is applicable only for agnListDecodingType=alr. It enables the user to select a severity for each alarm. The severity is set per alarm code (same for all slots/ports using this code). event - can be set only for an alarm that is defined by default as 'event'. User can change the severity of the alarms defined by default as minor or major. The severity of an event may be set to another severity, but the change will actually happen only if the event threshold is active and passed the Set/ON condition. An event alarm that passed the threshold and changed its severity, will return automatically to event severity when meeting its Reset/OFF condition.")
agnListDecodingAcmRelaySlt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 7, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("none", 1), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnListDecodingAcmRelaySlt.setStatus('mandatory')
if mibBuilder.loadTexts: agnListDecodingAcmRelaySlt.setDescription('This object indicates the ACM slot, desired for outbound relay (report) for the selected alarm. In the ?004 Unit the entries io6(10)..io12(16) are not valid. none - when agnListDecodingType=alr AND the selected alarm should not be reported by an ACM card. notApplicable - when agnListDecodingType=sanity OR when [agnListDecodingType=alr and there is no ACM card installed in the Mux].')
agnListDecodingAcmRelayPrt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 7, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 255))).clone(namedValues=NamedValues(("exPrt1", 1), ("exPrt2", 2), ("exPrt3", 3), ("exPrt4", 4), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnListDecodingAcmRelayPrt.setStatus('mandatory')
if mibBuilder.loadTexts: agnListDecodingAcmRelayPrt.setDescription('This object indicates the ACM port within the slot, desired for outbound relay (report) for the selected alarm. notApplicable - when agnListDecodingType=sanity OR when agnListDecodingAcmRelaySlt=notApplicable.')
agnDlciTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 8, 1), )
if mibBuilder.loadTexts: agnDlciTable.setStatus('mandatory')
if mibBuilder.loadTexts: agnDlciTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry.')
agnDlciEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 8, 1, 1), ).setIndexNames((0, "DACS-MIB", "agnDlciCnfgIdx"), (0, "DACS-MIB", "agnDlciLSltIdx"), (0, "DACS-MIB", "agnDlciLPrtIdx"), (0, "DACS-MIB", "agnDlciHIdx"), (0, "DACS-MIB", "agnDlciHSltIdx"), (0, "DACS-MIB", "agnDlciHPrtIdx"), (0, "DACS-MIB", "agnDlciLIdx"))
if mibBuilder.loadTexts: agnDlciEntry.setStatus('mandatory')
if mibBuilder.loadTexts: agnDlciEntry.setDescription('')
agnDlciCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 8, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnDlciCnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: agnDlciCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg. ')
agnDlciLSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 8, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 254, 255))).clone(namedValues=NamedValues(("cl", 3), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("vs", 254), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnDlciLSltIdx.setStatus('mandatory')
if mibBuilder.loadTexts: agnDlciLSltIdx.setDescription('This attribute indicates a unique slot position where the card is inserted. vs=Voice Switching In the ?004 Unit the entries io6(10)..io16) are not valid. For ISDN BRI ports of MX300/30 units: io1(5) = isdn1(5) and io2(6) = isdn2(6) LSlotIdx is defined according one of the following possiblities: 1. LSlotIdx is < HSlotIdx. 2. LSlotIdx is = HSlotIdx and LPrtIdx is < HPrtIdx. 3. LSlotIdx is = HSlotIdx and LPrtIdx is = HPrtIdx but LIdx is < HIdx.')
agnDlciLPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 8, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnDlciLPrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: agnDlciLPrtIdx.setDescription('This attribute indicates a unique external or internal port number, including linkSelector or encapsulator. 100=noConnect (for voice switching) LPrtIdx is defined according one of the following possiblities: 1. LSlotIdx is < HSlotIdx. 2. LSlotIdx is = HSlotIdx and LPrtIdx is < HPrtIdx. 3. LSlotIdx is = HSlotIdx and LPrtIdx is = HPrtIdx but LIdx is < HIdx.')
agnDlciLIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 8, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 991))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnDlciLIdx.setStatus('mandatory')
if mibBuilder.loadTexts: agnDlciLIdx.setDescription('This attribute indicates a unique index for each possible used dlci(16..991). 0=notApplicable (for voice switching) LIdx is defined according one of the following possiblities: 1. LSlotIdx is < HSlotIdx. 2. LSlotIdx is = HSlotIdx and LPrtIdx is < HPrtIdx. 3. LSlotIdx is = HSlotIdx and LPrtIdx is = HPrtIdx but LIdx is < HIdx.')
agnDlciHSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 8, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("cl", 3), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnDlciHSltIdx.setStatus('mandatory')
if mibBuilder.loadTexts: agnDlciHSltIdx.setDescription('This attribute indicates a unique slot position In the Mux (Agent) where the dlci is routed to. For ISDN BRI ports of MX300/30 units: io1(5) = isdn1(5) and io2(6) = isdn2(6) In the ?004 Unit the entries io6(10)..io16) are not valid')
agnDlciHPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 8, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnDlciHPrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: agnDlciHPrtIdx.setDescription('This attribute indicates a unique port id which the dlci is routed to.')
agnDlciHIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 8, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 991))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnDlciHIdx.setStatus('mandatory')
if mibBuilder.loadTexts: agnDlciHIdx.setDescription('This attribute indicates a unique internal connection dlci number which the src dlci is routed to.')
agnDlciTxBc = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 8, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43))).clone(namedValues=NamedValues(("full", 1), ("zero", 2), ("txBc5100bps", 3), ("txBc6400bps", 4), ("txBc8300bps", 5), ("txBc9600bps", 6), ("txBc14400bps", 7), ("txBc19200bps", 8), ("txBc28800bps", 9), ("txBc32000bps", 10), ("txBc38400bps", 11), ("txBc48000bps", 12), ("txBc56000bps", 13), ("txBc57600bps", 14), ("txBc64Kbps", 15), ("txBc128Kbps", 16), ("txBc192Kbps", 17), ("txBc256Kbps", 18), ("txBc320Kbps", 19), ("txBc384Kbps", 20), ("txBc448Kbps", 21), ("txBc512Kbps", 22), ("txBc768Kbps", 23), ("txBc896Kbps", 24), ("txBc1024Kbps", 25), ("txBc1152Kbps", 26), ("txBc1280Kbps", 27), ("txBc1344Kbps", 28), ("txBc1472Kbps", 29), ("txBc1600Kbps", 30), ("txBc1728Kbps", 31), ("txBc1856Kbps", 32), ("txBc1920Kbps", 33), ("txBc1984Kbps", 34), ("txBc2048Kbps", 35), ("txBc16000bps", 36), ("txBc112Kbps", 37), ("txBc168Kbps", 38), ("txBc224Kbps", 39), ("txBc336Kbps", 40), ("txBc672Kbps", 41), ("txBc1536Kbps", 42), ("txBc1792Kbps", 43))).clone('full')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnDlciTxBc.setStatus('mandatory')
if mibBuilder.loadTexts: agnDlciTxBc.setDescription('This attribute indicates a unique Tx committed bandwidth on the user transmit line or at the port receive line.')
agnDlciTxBe = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 8, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43))).clone(namedValues=NamedValues(("full", 1), ("zero", 2), ("txBe5100bps", 3), ("txBe6400bps", 4), ("txBe8300bps", 5), ("txBe9600bps", 6), ("txBe14400bps", 7), ("txBe19200bps", 8), ("txBe28800bps", 9), ("txBe32000bps", 10), ("txBe38400bps", 11), ("txBe48000bps", 12), ("txBe56000bps", 13), ("txBe57600bps", 14), ("txBe64Kbps", 15), ("txBe128Kbps", 16), ("txBe192Kbps", 17), ("txBe256Kbps", 18), ("txBe320Kbps", 19), ("txBe384Kbps", 20), ("txBe448Kbps", 21), ("txBe512Kbps", 22), ("txBe768Kbps", 23), ("txBe896Kbps", 24), ("txBe1024Kbps", 25), ("txBe1152Kbps", 26), ("txBe1280Kbps", 27), ("txBe1344Kbps", 28), ("txBe1472Kbps", 29), ("txBe1600Kbps", 30), ("txBe1728Kbps", 31), ("txBe1856Kbps", 32), ("txBe1920Kbps", 33), ("txBe1984Kbps", 34), ("txBe2048Kbps", 35), ("txBe16000bps", 36), ("txBe112Kbps", 37), ("txBe168Kbps", 38), ("txBe224Kbps", 39), ("txBe336Kbps", 40), ("txBe672Kbps", 41), ("txBe1536Kbps", 42), ("txBe1792Kbps", 43))).clone('zero')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnDlciTxBe.setStatus('mandatory')
if mibBuilder.loadTexts: agnDlciTxBe.setDescription('This attribute indicates a unique Tx excess bandwidth on the user transmit line or at the port receive line.')
agnDlciRxBc = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 8, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43))).clone(namedValues=NamedValues(("full", 1), ("zero", 2), ("rxBc5100bps", 3), ("rxBc6400bps", 4), ("rxBc8300bps", 5), ("rxBc9600bps", 6), ("rxBc14400bps", 7), ("rxBc19200bps", 8), ("rxBc28800bps", 9), ("rxBc32000bps", 10), ("rxBc38400bps", 11), ("rxBc48000bps", 12), ("rxBc56000bps", 13), ("rxBc57600bps", 14), ("rxBc64Kbps", 15), ("rxBc128Kbps", 16), ("rxBc192Kbps", 17), ("rxBc256Kbps", 18), ("rxBc320Kbps", 19), ("rxBc384Kbps", 20), ("rxBc448Kbps", 21), ("rxBc512Kbps", 22), ("rxBc768Kbps", 23), ("rxBc896Kbps", 24), ("rxBc1024Kbps", 25), ("rxBc1152Kbps", 26), ("rxBc1280Kbps", 27), ("rxBc1344Kbps", 28), ("rxBc1472Kbps", 29), ("rxBc1600Kbps", 30), ("rxBc1728Kbps", 31), ("rxBc1856Kbps", 32), ("rxBc1920Kbps", 33), ("rxBc1984Kbps", 34), ("rxBc2048Kbps", 35), ("rxBc16000bps", 36), ("rxBc112Kbps", 37), ("rxBc168Kbps", 38), ("rxBc224Kbps", 39), ("rxBc336Kbps", 40), ("rxBc672Kbps", 41), ("rxBc1536Kbps", 42), ("rxBc1792Kbps", 43))).clone('full')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnDlciRxBc.setStatus('mandatory')
if mibBuilder.loadTexts: agnDlciRxBc.setDescription('This attribute indicates a unique Rx committed bandwidth on the user receive line or at the port transmit line.')
agnDlciRxBe = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 8, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43))).clone(namedValues=NamedValues(("full", 1), ("zero", 2), ("rxBe5100bps", 3), ("rxBe6400bps", 4), ("rxBe8300bps", 5), ("rxBe9600bps", 6), ("rxBe14400bps", 7), ("rxBe19200bps", 8), ("rxBe28800bps", 9), ("rxBe32000bps", 10), ("rxBe38400bps", 11), ("rxBe48000bps", 12), ("rxBe56000bps", 13), ("rxBe57600bps", 14), ("rxBe64Kbps", 15), ("rxBe128Kbps", 16), ("rxBe192Kbps", 17), ("rxBe256Kbps", 18), ("rxBe320Kbps", 19), ("rxBe384Kbps", 20), ("rxBe448Kbps", 21), ("rxBe512Kbps", 22), ("rxBe768Kbps", 23), ("rxBe896Kbps", 24), ("rxBe1024Kbps", 25), ("rxBe1152Kbps", 26), ("rxBe1280Kbps", 27), ("rxBe1344Kbps", 28), ("rxBe1472Kbps", 29), ("rxBe1600Kbps", 30), ("rxBe1728Kbps", 31), ("rxBe1856Kbps", 32), ("rxBe1920Kbps", 33), ("rxBe1984Kbps", 34), ("rxBe2048Kbps", 35), ("rxBe16000bps", 36), ("rxBe112Kbps", 37), ("rxBe168Kbps", 38), ("rxBe224Kbps", 39), ("rxBe336Kbps", 40), ("rxBe672Kbps", 41), ("rxBe1536Kbps", 42), ("rxBe1792Kbps", 43))).clone('zero')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnDlciRxBe.setStatus('mandatory')
if mibBuilder.loadTexts: agnDlciRxBe.setDescription('This attribute indicates a unique Rx excess bandwidth on the user receive line or at the port transmit line.')
agnDlciPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 8, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnDlciPriority.setStatus('mandatory')
if mibBuilder.loadTexts: agnDlciPriority.setDescription('This attribute indicates a unique priority of the pcv. 1 is the lowest priority and 7 is the highest priority.')
agnDlciStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 8, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disconnected", 1), ("connected", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnDlciStatus.setStatus('mandatory')
if mibBuilder.loadTexts: agnDlciStatus.setDescription('This attribute indicates the status of the pvc. The status is disconnected(1) when one of the sides is programmed as not connected')
agnDlciSpoofing = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 8, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnDlciSpoofing.setStatus('mandatory')
if mibBuilder.loadTexts: agnDlciSpoofing.setDescription('This object refers to sending of RIP messages: - yes : RIP messages will be sent ONLY if there is a change in the Net. - no : RIP messages will be always sent. This object is relevant only when one side of the DLCI is a CL-NMS interface. Default=no. ')
agnDlciFunnelEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 8, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnDlciFunnelEnable.setStatus('mandatory')
if mibBuilder.loadTexts: agnDlciFunnelEnable.setDescription('This object selects Funnel activation enable/disable: - disabled: Funnel operation disabled. The agnDlciTxBe and agnDlciTxBc values are not used for funneling. - enabled : Funnel operation enabled. The agnDlciTxBe and agnDlciTxBc values are used for funneling calculations. This object is relevant only for an encapsulating DLCI. In case of a Link Selector DLCI, the agnDlciTxBe and agnDlciTxBc values are used for bandwidth of Link Selector. Default=disabled. ')
agnDlciRoutingProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 8, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("rip", 2), ("rip2", 3), ("none", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnDlciRoutingProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: agnDlciRoutingProtocol.setDescription('This object is relevant only when one side of the DLCI is a CL-NMS interface. It defines which Routing Protocol will be used for management via CL-NMS port. notApplicable will be used for all slots but CL. rip is a proprietary rip protocol. Default=rip. ')
agnDlciRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 8, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 6))).clone(namedValues=NamedValues(("active", 1), ("destroy", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnDlciRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: agnDlciRowStatus.setDescription('This attribute allows to create/delete a row in this table. For creating a row, the NMS should set agnRowStatus.255.id2.id3.id4.id5.id6.id7 = active(1). For destroying a row, the NMS should set: agnRowStatus.255.id2.id3.id4.id5.id6.id7 = destroy(6). Only rows with status active(1) are relevant.')
agnVoiceSwConfTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 9, 1), )
if mibBuilder.loadTexts: agnVoiceSwConfTable.setStatus('mandatory')
if mibBuilder.loadTexts: agnVoiceSwConfTable.setDescription('MXcess Configuration for Voice Switching.')
agnVoiceSwConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 9, 1, 1), ).setIndexNames((0, "DACS-MIB", "agnVoiceSwConfIdx"))
if mibBuilder.loadTexts: agnVoiceSwConfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: agnVoiceSwConfEntry.setDescription('')
agnVoiceSwConfIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 9, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 255))).clone(namedValues=NamedValues(("active", 1), ("temporary", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnVoiceSwConfIdx.setStatus('mandatory')
if mibBuilder.loadTexts: agnVoiceSwConfIdx.setDescription('Active or Temporary Table. Both configurations can be read but only the Temporary can be written to.')
agnVoiceSwConfZoneId = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 9, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 2))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnVoiceSwConfZoneId.setStatus('mandatory')
if mibBuilder.loadTexts: agnVoiceSwConfZoneId.setDescription('1 or 2 digits, (0-9)(1-9).')
agnVoiceSwConfNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 9, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 3))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnVoiceSwConfNodeId.setStatus('mandatory')
if mibBuilder.loadTexts: agnVoiceSwConfNodeId.setDescription('1, 2 or 3 digits, (1-9),(0-9),(0-9).')
agnVoiceSwConfNoOfHops = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 9, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnVoiceSwConfNoOfHops.setStatus('mandatory')
if mibBuilder.loadTexts: agnVoiceSwConfNoOfHops.setDescription('Number of hops the frame will go through the net before deciding to discard the frame (like time-to-live in IP). 0 = notApplicable Default=20 .')
agnVoiceSwConfRtTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 9, 2), )
if mibBuilder.loadTexts: agnVoiceSwConfRtTable.setStatus('mandatory')
if mibBuilder.loadTexts: agnVoiceSwConfRtTable.setDescription('Routing Table for Voice Switching.')
agnVoiceSwConfRtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 9, 2, 1), ).setIndexNames((0, "DACS-MIB", "agnVoiceSwConfRtDbId"), (0, "DACS-MIB", "agnVoiceSwConfRtIdx"))
if mibBuilder.loadTexts: agnVoiceSwConfRtEntry.setStatus('mandatory')
if mibBuilder.loadTexts: agnVoiceSwConfRtEntry.setDescription('')
agnVoiceSwConfRtDbId = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 9, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 255))).clone(namedValues=NamedValues(("active", 1), ("temporary", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnVoiceSwConfRtDbId.setStatus('mandatory')
if mibBuilder.loadTexts: agnVoiceSwConfRtDbId.setDescription('Active or Temporary Table. Both configurations can be read but only the Temporary can be written to.')
agnVoiceSwConfRtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 9, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnVoiceSwConfRtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: agnVoiceSwConfRtIdx.setDescription(' The Index of the row.')
agnVoiceSwConfRtDigits = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 9, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnVoiceSwConfRtDigits.setStatus('mandatory')
if mibBuilder.loadTexts: agnVoiceSwConfRtDigits.setDescription(" Serie of digits or keyword 'ELSE'..")
agnVoiceSwConfRtAction = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 9, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("notApplicable", 1), ("zone", 2), ("node", 3), ("shortDialing", 4), ("in", 5), ("hgr", 6), ("del", 7), ("rep", 8))).clone('notApplicable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnVoiceSwConfRtAction.setStatus('mandatory')
if mibBuilder.loadTexts: agnVoiceSwConfRtAction.setDescription(' Action that the system should perform for this digits: agnVoiceSwConfRtDigits.')
agnVoiceSwConfRtData = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 9, 2, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnVoiceSwConfRtData.setStatus('mandatory')
if mibBuilder.loadTexts: agnVoiceSwConfRtData.setDescription(' This field is relevant for actions hgr(6), del(7) and rep(8).')
agnVoiceSwConfRtSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 9, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("noConnect", 2), ("cl", 3), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255))).clone('noConnect')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnVoiceSwConfRtSlot.setStatus('mandatory')
if mibBuilder.loadTexts: agnVoiceSwConfRtSlot.setDescription(' Routing Slot- Relevant for actions zone(2) and node(3).')
agnVoiceSwConfRtPort = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 9, 2, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnVoiceSwConfRtPort.setStatus('mandatory')
if mibBuilder.loadTexts: agnVoiceSwConfRtPort.setDescription(' Routing Port- Relevant for actions zone(2) and node(3). 100=noConnect (for non-routing case).')
agnVoiceSwConfRtDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 9, 2, 1, 8), Integer32().clone(15)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnVoiceSwConfRtDlci.setStatus('mandatory')
if mibBuilder.loadTexts: agnVoiceSwConfRtDlci.setDescription(' Routing DLCI- Relevant for actions zone(2) and node(3). Valid values: 0=notApplicable (for non-routing case). 1, 16..991 ')
agnVoiceSwConfRtRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 9, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("active", 1), ("notInService", 2), ("notReady", 3), ("createAndGo", 4), ("createAndWait", 5), ("destroy", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnVoiceSwConfRtRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: agnVoiceSwConfRtRowStatus.setDescription(' Status of the row for creating/deleting entries in the table.')
agnVoiceSwConfHGTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 9, 5), )
if mibBuilder.loadTexts: agnVoiceSwConfHGTable.setStatus('mandatory')
if mibBuilder.loadTexts: agnVoiceSwConfHGTable.setDescription('Table of Hunt Groups.')
agnVoiceSwConfHGEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 9, 5, 1), ).setIndexNames((0, "DACS-MIB", "agnVoiceSwConfHGdbIdx"), (0, "DACS-MIB", "agnVoiceSwConfHGIdx"))
if mibBuilder.loadTexts: agnVoiceSwConfHGEntry.setStatus('mandatory')
if mibBuilder.loadTexts: agnVoiceSwConfHGEntry.setDescription('')
agnVoiceSwConfHGdbIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 9, 5, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 255))).clone(namedValues=NamedValues(("active", 1), ("temporary", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnVoiceSwConfHGdbIdx.setStatus('mandatory')
if mibBuilder.loadTexts: agnVoiceSwConfHGdbIdx.setDescription('Active or Temporary Table. Both configurations can be read but only the Temporary can be written to.')
agnVoiceSwConfHGIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 9, 5, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnVoiceSwConfHGIdx.setStatus('mandatory')
if mibBuilder.loadTexts: agnVoiceSwConfHGIdx.setDescription("There may be up to 10 Hunt Groups per MXcess. That's the index of the hunt group relevant to this row.")
agnVoiceSwConfHGConnect = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 9, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnVoiceSwConfHGConnect.setStatus('mandatory')
if mibBuilder.loadTexts: agnVoiceSwConfHGConnect.setDescription('This attribute indicates whether the hunt group should be considered in any of the mux algorithms.')
agnVoiceSwConfHGExt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 9, 5, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 99))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnVoiceSwConfHGExt.setStatus('mandatory')
if mibBuilder.loadTexts: agnVoiceSwConfHGExt.setDescription('This is the extension number of the hunt group. 0 is for not valid. The allowed range is 10 - 99.')
agnSigProfileTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 10, 1), )
if mibBuilder.loadTexts: agnSigProfileTable.setStatus('mandatory')
if mibBuilder.loadTexts: agnSigProfileTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry.')
agnSigProfileEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 10, 1, 1), ).setIndexNames((0, "DACS-MIB", "agnSigProfileCnfgIdx"), (0, "DACS-MIB", "agnSigProfileIdx"), (0, "DACS-MIB", "agnSigProfileRxTx"))
if mibBuilder.loadTexts: agnSigProfileEntry.setStatus('mandatory')
if mibBuilder.loadTexts: agnSigProfileEntry.setDescription('')
agnSigProfileCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 10, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSigProfileCnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: agnSigProfileCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg. The write operation is valid only to the TmpCnfg.')
agnSigProfileIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 10, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSigProfileIdx.setStatus('mandatory')
if mibBuilder.loadTexts: agnSigProfileIdx.setDescription('This attribute indicates the Signaling Profile (1..5).')
agnSigProfileRxTx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 10, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("rx", 1), ("tx", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSigProfileRxTx.setStatus('mandatory')
if mibBuilder.loadTexts: agnSigProfileRxTx.setDescription('This attribute indicates if the following objects refer to: Rx or Tx translation. Rx : ML->IO Tx : IO->ML .')
agnSigProfileABCD = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 10, 1, 1, 4), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnSigProfileABCD.setStatus('mandatory')
if mibBuilder.loadTexts: agnSigProfileABCD.setDescription('This object represents 6 parameters, by 3 Octets : Busy Code-MSB nibble, - applicable only for Rx translation Idle Code- nibble, - applicable only for Rx translation D Bit Code- nibble, C Bit Code- nibble, B Bit Code- nibble, A Bit Code-LSB nibble. Each of Busy and Idle Code nibble will have the valid values: 0000 .. FFFF. Each of A,B,C,D Bit Code nibble represents: 0 hex = 0000 = 0 1 hex = 0001 = 1 2 hex = 0010 = A bit 3 hex = 0011 = B bit 4 hex = 0100 = C bit 5 hex = 0101 = D bit 6 hex = 0110 = A bit inverse 7 hex = 0111 = B bit inverse 8 hex = 1000 = C bit inverse 9 hex = 1001 = D bit inverse A-F hex - not used (invalid values) ')
mdlSInstTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 1, 1), )
if mibBuilder.loadTexts: mdlSInstTable.setStatus('mandatory')
if mibBuilder.loadTexts: mdlSInstTable.setDescription('')
mdlSInstEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 1, 1, 1), ).setIndexNames((0, "DACS-MIB", "mdlSInstSltIdx"))
if mibBuilder.loadTexts: mdlSInstEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mdlSInstEntry.setDescription('')
mdlSInstSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("psA", 1), ("psB", 2), ("clA", 3), ("clB", 4), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlSInstSltIdx.setStatus('mandatory')
if mibBuilder.loadTexts: mdlSInstSltIdx.setDescription('A unique number to identify a slot position in the mux. In the ?004 Unit the entries PsB(2),ClB(4),io6(10)..io(16) are not valid.')
mdlSInstCardType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 9, 10, 11, 20, 21, 22, 23, 24, 25, 31, 32, 33, 34, 35, 36, 60, 61, 72, 80, 81, 82, 83, 84, 85, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 120, 121, 122, 123, 124, 125, 126, 127, 130, 131, 132, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 204, 210, 211, 212, 213, 214, 215, 220, 221, 222, 223, 230, 231, 232, 233, 234, 235, 236, 237, 240, 241, 242, 243, 253, 254))).clone(namedValues=NamedValues(("unknown", 1), ("empty", 2), ("acm", 9), ("ps60W", 10), ("ps100W", 11), ("cl1", 20), ("clEth", 21), ("cl2", 22), ("cl2Eth", 23), ("cl3", 24), ("cl3Eth", 25), ("mPh1", 31), ("mPh3", 32), ("mPh1T1DSU", 33), ("mPh1T1CSU", 34), ("mPh1E1DSU", 35), ("mPh1E1LTU", 36), ("mPl6", 60), ("mPl3", 61), ("mPv4", 72), ("vf3EandM", 80), ("vf3Fxs", 81), ("vf3Fxo", 82), ("vfPbx", 83), ("vfPbxT1", 84), ("vfPbxE1", 85), ("mtMlF2T1", 88), ("mtMlF2E1", 89), ("mtMlT1Fiber", 90), ("mtMlE1Fiber", 91), ("mtMlT1FiberFb", 92), ("mtMlE1FiberFb", 93), ("mtmlHE1", 94), ("mtmlH1E1", 95), ("mtmlHSE1", 96), ("ml20", 97), ("mtMl4T1", 98), ("mtMl4E1", 99), ("mtMl1T1DSU", 100), ("mtMl1T1CSU", 101), ("mtMl1E1DSU", 102), ("mtMl1E1LTU", 103), ("mtMl1T1DSUfb", 104), ("mtMl1T1CSUfb", 105), ("mtMl1E1DSUfb", 106), ("mtMl1E1LTUfb", 107), ("mtMl2T1", 108), ("mtMl2E1", 109), ("ls2CcittX50", 110), ("ls2CcittX58", 111), ("ls2ATandTSdm", 112), ("ls2ACcittX50", 113), ("ls2ACcittX58", 114), ("ls2AATandTSdm", 115), ("ls2A2Ts", 116), ("ls2M", 117), ("hs2", 120), ("hs3", 121), ("hsq", 122), ("hs703", 123), ("hsQM", 124), ("hsqN", 125), ("hs6", 126), ("hs12", 127), ("hs4T1", 130), ("hs4E1", 131), ("hs4", 132), ("vc2EandM", 140), ("vc2Fxs1Plar", 141), ("vc2Fxo1", 142), ("vc2Fxs2", 143), ("vc2Fxo2", 144), ("vc2Fxs3", 145), ("vc2Fxo3", 146), ("vc26EandM", 147), ("mtvc2", 148), ("vc2R2Fxs", 149), ("hsu", 150), ("mbeA", 151), ("mbeB", 152), ("mbeU", 153), ("tre", 154), ("hsuI", 155), ("hsr", 156), ("hss", 157), ("hsu1", 158), ("ls12", 159), ("ls6", 160), ("ls6V1EandM", 161), ("ls6V1Fxo", 162), ("ls6V1Fxs", 163), ("ls6V2EandM", 164), ("ls6V2Fxo", 165), ("ls6V2Fxs", 166), ("ls6VfEandM", 167), ("ls6VfFxo", 168), ("ls6VfFxs", 169), ("vc3EandM", 170), ("vc3Fxo", 171), ("vc3Fxs", 172), ("vcPbx", 173), ("vcPbxT1", 174), ("vcPbxE1", 175), ("vc6EandM", 176), ("vc6Fxo", 177), ("vc6Fxs", 178), ("vcq", 179), ("mhs1V36", 181), ("mhs1V35", 182), ("mhs1G703", 183), ("mhs1DDS", 184), ("mhs3", 185), ("mhs1X21", 186), ("mhs1V24", 187), ("mhs4", 188), ("mhsE1Hs", 189), ("mhsT1Hs", 190), ("mhsHyE1Hs", 191), ("mhsHyT1Hs", 192), ("mlfHybE1Hs", 193), ("mlfHybT1Hs", 194), ("mhs2e1", 195), ("mhs2t1", 196), ("mhsHy2e1", 197), ("mhsHy2t1", 198), ("mlfHybE12", 199), ("mls6", 200), ("mls3", 201), ("mlfHybT12", 204), ("mvc4", 210), ("mvc4PbxE1", 211), ("mvc4PbxT1Dsu", 212), ("mvc4PbxT1Csu", 213), ("mvc4PbxE1Slave", 214), ("mvc4PbxT1Slave", 215), ("mhsS", 220), ("mhsU", 221), ("mhsPriE1", 222), ("mhsPriT1", 223), ("vc12EandM", 230), ("vc12Fxo", 231), ("vc12Fxs", 232), ("vc6aEandM", 233), ("vc6aFxo", 234), ("vc6aFxs", 235), ("vc6AgFxo", 236), ("vc6AgFxs", 237), ("hsu12", 240), ("hsu6", 241), ("hss12", 242), ("hss6", 243), ("mvg1Lan", 253), ("mvg2Lan", 254)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlSInstCardType.setStatus('mandatory')
if mibBuilder.loadTexts: mdlSInstCardType.setDescription('This attribute indicates the type of card installed in the specific slot position. Only PS cards are possible in the PS slots. Only CL cards are possible in the CL slots. Only IO cards are possible in the IO slots.')
mdlSHwVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 1, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlSHwVersion.setStatus('mandatory')
if mibBuilder.loadTexts: mdlSHwVersion.setDescription('This attribute indicates the Hardware version of the installed card in the specific slot position.')
mdlSSwVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 1, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlSSwVersion.setStatus('mandatory')
if mibBuilder.loadTexts: mdlSSwVersion.setDescription('This attribute indicates the Software version of the installed card in the specific slot position.')
mdlSAlrStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("off", 2), ("event", 3), ("minor", 4), ("major", 5), ("warning", 6), ("critical", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlSAlrStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mdlSAlrStatus.setDescription('Indicates the alarm state at module level, i.e. lower level (port alarms) status is not included. This attribute will be set to: critical(7) - when there is at least one active (state ON) critical alarm, otherwise it will be set to major(5) - when there is at least one active (state ON) major alarm, otherwise it will be set to minor(4) - if there is at least one active (state ON) minor alarm, otherwise it will be set to warning(6) - if there is at least one active (state ON) warning alarm, otherwise it will be set to event(3) - if there was at least one alarm event (including state on,off events) since the last clear operation.')
mdlSAlrStatusAll = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("off", 2), ("event", 3), ("minor", 4), ("major", 5), ("warning", 6), ("critical", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlSAlrStatusAll.setStatus('mandatory')
if mibBuilder.loadTexts: mdlSAlrStatusAll.setDescription('Indicates the alarm state in the module-all level, i.e. lower level (port alarms) included. This attribute will be set to: critical(7) - when there is at least one active (state ON) critical alarm, otherwise it will be set to major(5) - when there is at least one active (state ON) major alarm, otherwise it will be set to minor(4) - if there is at least one active (state ON) minor alarm, otherwise it will be set to warning(6) - if there is at least one active (state ON) warning alarm, otherwise it will be set to event(3) - if there was at least one alarm event (including state on,off events) since the last clear operation.')
mdlSMaskedAlrStat = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("off", 2), ("event", 3), ("minor", 4), ("major", 5), ("warning", 6), ("critical", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlSMaskedAlrStat.setStatus('mandatory')
if mibBuilder.loadTexts: mdlSMaskedAlrStat.setDescription('Indicates the alarm state at module level, [i.e. lower level (port alarms) status is not included],including Masked alarms. This attribute will be set to: critical(7) - when there is at least one active (state ON) critical alarm, otherwise it will be set to major(5) - when there is at least one active (state ON) major alarm, otherwise it will be set to minor(4) - if there is at least one active (state ON) minor alarm, otherwise it will be set to warning(6) - if there is at least one active (state ON) warning alarm, otherwise it will be set to event(3) - if there was at least one alarm event (including state on,off events) since the last clear operation.')
mdlSMaskedAlrStatAll = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("off", 2), ("event", 3), ("minor", 4), ("major", 5), ("warning", 6), ("critical", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlSMaskedAlrStatAll.setStatus('mandatory')
if mibBuilder.loadTexts: mdlSMaskedAlrStatAll.setDescription('Indicates the alarm state in the module-all level, i.e. lower level (port alarms) included, including Masked alarms. This attribute will be set to: critical(7) - when there is at least one active (state ON) critical alarm, otherwise it will be set to major(5) - when there is at least one active (state ON) major alarm, otherwise it will be set to minor(4) - if there is at least one active (state ON) minor alarm, otherwise it will be set to warning(6) - if there is at least one active (state ON) warning alarm, otherwise it will be set to event(3) - if there was at least one alarm event (including state on,off events) since the last clear operation.')
mdlSTstStatusAll = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlSTstStatusAll.setStatus('mandatory')
if mibBuilder.loadTexts: mdlSTstStatusAll.setDescription('This attribute will be set to on(3) when there is at least one test in progress on a channel of the card, otherwise the value will be off(2).')
mdlSClearAlrCmd = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mdlSClearAlrCmd.setStatus('mandatory')
if mibBuilder.loadTexts: mdlSClearAlrCmd.setDescription('Setting this command to ON, enforces a clear of all the alarms in the given slot, excluding alarms of port level. The clear operation will not be applied for masked/inverted alarms.')
mdlSClearAllAlrCmd = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mdlSClearAllAlrCmd.setStatus('mandatory')
if mibBuilder.loadTexts: mdlSClearAllAlrCmd.setDescription('Setting this command to ON, enforces a clear of all the alarms in the given slot, including all its ports alarms. The clear operation will not be applied for masked/inverted alarms.')
mdlSAlrTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 1, 2), )
if mibBuilder.loadTexts: mdlSAlrTable.setStatus('mandatory')
if mibBuilder.loadTexts: mdlSAlrTable.setDescription('The list of card agent alarms ; includes also an alarm indicating existence of alarms on its ports if there are any.')
mdlSAlrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 1, 2, 1), ).setIndexNames((0, "DACS-MIB", "mdlSAlrSltIdx"), (0, "DACS-MIB", "mdlSAlrIdx"))
if mibBuilder.loadTexts: mdlSAlrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mdlSAlrEntry.setDescription('')
mdlSAlrIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 1, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlSAlrIdx.setStatus('mandatory')
if mibBuilder.loadTexts: mdlSAlrIdx.setDescription('A unique number to identify an entry in the alarm status table. Users should use the get next function to read this table because the indexes are not consecutive.')
mdlSAlrSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("psA", 1), ("psB", 2), ("clA", 3), ("clB", 4), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlSAlrSltIdx.setStatus('mandatory')
if mibBuilder.loadTexts: mdlSAlrSltIdx.setDescription('This attribute indicates the desired slot position. In the ?004 Unit the entries PsB(2),ClB(4),io6(10)..io12(16) are not valid.')
mdlSAlrCodeDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 1, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlSAlrCodeDescription.setStatus('mandatory')
if mibBuilder.loadTexts: mdlSAlrCodeDescription.setDescription('This attribute is a full text description of the alarm . The alarm description includes the following information: alarm code, alarm text, alarm severity, Masked or Inverted flag and counter.')
mdlSAlrCode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 1, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlSAlrCode.setStatus('mandatory')
if mibBuilder.loadTexts: mdlSAlrCode.setDescription('A code identifying the alarm of an entry in the alarm status table at card level.')
mdlSAlrSeverity = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("event", 3), ("minor", 4), ("major", 5), ("warning", 6), ("critical", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlSAlrSeverity.setStatus('mandatory')
if mibBuilder.loadTexts: mdlSAlrSeverity.setDescription('The severity of the alarm.')
mdlSAlrState = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 1, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlSAlrState.setStatus('mandatory')
if mibBuilder.loadTexts: mdlSAlrState.setDescription('State of the alarm.')
mdlSAlrCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 1, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlSAlrCounter.setStatus('mandatory')
if mibBuilder.loadTexts: mdlSAlrCounter.setDescription('A counter - how many times the alarm occured since last clear operation. ON and OFF Alarm will be counted separately.')
mdlSAlrMask = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 1, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlSAlrMask.setStatus('mandatory')
if mibBuilder.loadTexts: mdlSAlrMask.setDescription('Alarm mask : on/off.')
mdlSAlrInvert = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 1, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlSAlrInvert.setStatus('mandatory')
if mibBuilder.loadTexts: mdlSAlrInvert.setDescription('Alarm invert : on/off.')
mdlCPrgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 2, 1), )
if mibBuilder.loadTexts: mdlCPrgTable.setStatus('mandatory')
if mibBuilder.loadTexts: mdlCPrgTable.setDescription('')
mdlCPrgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 2, 1, 1), ).setIndexNames((0, "DACS-MIB", "mdlCCnfgIdx"), (0, "DACS-MIB", "mdlCSltIdx"))
if mibBuilder.loadTexts: mdlCPrgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mdlCPrgEntry.setDescription('')
mdlCCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlCCnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: mdlCCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg(1..100) being referred. Value 255 specifies the TmpCnfg ')
mdlCSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("psA", 1), ("psB", 2), ("clA", 3), ("clB", 4), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlCSltIdx.setStatus('mandatory')
if mibBuilder.loadTexts: mdlCSltIdx.setDescription('This attribute indicates a unique number of the slot position where the card is inserted. In the ?004 Unit the entries psB(2),clB(4),io6(10)..io(16) are not valid.')
mdlCPrgCardType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 9, 10, 11, 12, 13, 14, 15, 16, 20, 21, 22, 23, 24, 25, 31, 32, 33, 34, 35, 36, 60, 80, 81, 82, 83, 84, 85, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 120, 121, 122, 123, 124, 125, 126, 127, 130, 131, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 204, 210, 211, 212, 213, 214, 215, 220, 221, 222, 223, 230, 231, 232, 233, 234, 235, 236, 237, 240, 241, 242, 243, 253, 254))).clone(namedValues=NamedValues(("unknown", 1), ("empty", 2), ("acm", 9), ("ps48x60W", 10), ("ps48x100W", 11), ("ps110x60W", 12), ("ps110x100W", 13), ("ps220x60W", 14), ("ps220x100W", 15), ("ps180W", 16), ("cl1", 20), ("clEth", 21), ("cl2", 22), ("cl2Eth", 23), ("cl3", 24), ("cl3Eth", 25), ("mPh1", 31), ("mPh3", 32), ("mPh1T1DSU", 33), ("mPh1T1CSU", 34), ("mPh1E1DSU", 35), ("mPh1E1LTU", 36), ("mPl6", 60), ("vf3EandM", 80), ("vf3Fxs", 81), ("vf3Fxo", 82), ("vfPbx", 83), ("vfPbxT1", 84), ("vfPbxE1", 85), ("mtMlF2T1", 88), ("mtMlF2E1", 89), ("mtMlT1Fiber", 90), ("mtMlE1Fiber", 91), ("mtMlT1FiberFb", 92), ("mtMlE1FiberFb", 93), ("mtmlHE1", 94), ("mtmlH1E1", 95), ("mtmlHSE1", 96), ("ml20", 97), ("mtMl4T1", 98), ("mtMl4E1", 99), ("mtMl1T1DSU", 100), ("mtMl1T1CSU", 101), ("mtMl1E1DSU", 102), ("mtMl1E1LTU", 103), ("mtMl1T1DSUfb", 104), ("mtMl1T1CSUfb", 105), ("mtMl1E1DSUfb", 106), ("mtMl1E1LTUfb", 107), ("mtMl2T1", 108), ("mtMl2E1", 109), ("ls2CcittX50", 110), ("ls2CcittX58", 111), ("ls2ATandTSdm", 112), ("ls2ACcittX50", 113), ("ls2ACcittX58", 114), ("ls2AATandTSdm", 115), ("ls2A2Ts", 116), ("ls2M", 117), ("hs2", 120), ("hs3", 121), ("hsq", 122), ("hs703", 123), ("hsQM", 124), ("hsqN", 125), ("hs6", 126), ("hs12", 127), ("hs4T1", 130), ("hs4E1", 131), ("vc2EandM", 140), ("vc2Fxs1Plar", 141), ("vc2Fxo1", 142), ("vc2Fxs2", 143), ("vc2Fxo2", 144), ("vc2Fxs3", 145), ("vc2Fxo3", 146), ("vc26EandM", 147), ("mtvc2", 148), ("vc2R2Fxs", 149), ("hsu", 150), ("mbeA", 151), ("mbeB", 152), ("mbeU", 153), ("tre", 154), ("hsuI", 155), ("hsr", 156), ("hss", 157), ("hsu1", 158), ("ls12", 159), ("ls6", 160), ("ls6V1EandM", 161), ("ls6V1Fxo", 162), ("ls6V1Fxs", 163), ("ls6V2EandM", 164), ("ls6V2Fxo", 165), ("ls6V2Fxs", 166), ("ls6VfEandM", 167), ("ls6VfFxo", 168), ("ls6VfFxs", 169), ("vc3EandM", 170), ("vc3Fxo", 171), ("vc3Fxs", 172), ("vcPbx", 173), ("vcPbxT1", 174), ("vcPbxE1", 175), ("vc6EandM", 176), ("vc6Fxo", 177), ("vc6Fxs", 178), ("vcq", 179), ("mhs1V36", 181), ("mhs1V35", 182), ("mhs1G703", 183), ("mhs1DDS", 184), ("mhs3", 185), ("mhs1X21", 186), ("mhs1V24", 187), ("mhs4", 188), ("mhsE1Hs", 189), ("mhsT1Hs", 190), ("mhsHyE1Hs", 191), ("mhsHyT1Hs", 192), ("mlfHybE1Hs", 193), ("mlfHybT1Hs", 194), ("mhs2e1", 195), ("mhs2t1", 196), ("mhsHy2e1", 197), ("mhsHy2t1", 198), ("mlfHybE12", 199), ("mls6", 200), ("mls3", 201), ("mlfHybT12", 204), ("mvc4", 210), ("mvc4PbxE1", 211), ("mvc4PbxT1Dsu", 212), ("mvc4PbxT1Csu", 213), ("mvc4PbxE1Slave", 214), ("mvc4PbxT1Slave", 215), ("mhsS", 220), ("mhsU", 221), ("mhsPriE1", 222), ("mhsPriT1", 223), ("vc12EandM", 230), ("vc12Fxo", 231), ("vc12Fxs", 232), ("vc6aEandM", 233), ("vc6aFxo", 234), ("vc6aFxs", 235), ("vc6AgFxo", 236), ("vc6AgFxs", 237), ("hsu12", 240), ("hsu6", 241), ("hss12", 242), ("hss6", 243), ("mvg1Lan", 253), ("mvg2Lan", 254)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mdlCPrgCardType.setStatus('mandatory')
if mibBuilder.loadTexts: mdlCPrgCardType.setDescription('This attribute indicates the type of card assigned to the specific slot in the common configuration. This object is identical in all the configurations (1..100). Only the TmpCnf(255) may have different value. The write operation is valid only to the TmpCnfg entry.')
mdlCNoOfExternPrt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 2, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlCNoOfExternPrt.setStatus('mandatory')
if mibBuilder.loadTexts: mdlCNoOfExternPrt.setDescription('Number of external ports in the programmed card of the specific slot position')
mdlCNoOfInternPrt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 2, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlCNoOfInternPrt.setStatus('mandatory')
if mibBuilder.loadTexts: mdlCNoOfInternPrt.setDescription('Number of internal ports in the programmed card of the specific slot position.')
mdlCmprTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 3, 1), )
if mibBuilder.loadTexts: mdlCmprTable.setStatus('mandatory')
if mibBuilder.loadTexts: mdlCmprTable.setDescription('')
mdlCmprEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 3, 1, 1), ).setIndexNames((0, "DACS-MIB", "mdlCmprTypIdx"), (0, "DACS-MIB", "mdlCmprCnfgIdx"), (0, "DACS-MIB", "mdlCmprVersion"), (0, "DACS-MIB", "mdlCmprSltIdx"))
if mibBuilder.loadTexts: mdlCmprEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mdlCmprEntry.setDescription('')
mdlCmprTypIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlCmprTypIdx.setStatus('mandatory')
if mibBuilder.loadTexts: mdlCmprTypIdx.setDescription('This attribute indicates the Type of the Compressed being referred.')
mdlCmprCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 3, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlCmprCnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: mdlCmprCnfgIdx.setDescription('This attribute indicates the configuration to which the Compressed information is related.')
mdlCmprVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 3, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlCmprVersion.setStatus('mandatory')
if mibBuilder.loadTexts: mdlCmprVersion.setDescription('This attribute indicates the version of the internal format of the Compressed data')
mdlCmprSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("psA", 1), ("psB", 2), ("clA", 3), ("clB", 4), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlCmprSltIdx.setStatus('mandatory')
if mibBuilder.loadTexts: mdlCmprSltIdx.setDescription('This attribute indicates a unique number of the slot position where the card is inserted. In the ?004 Unit the entries psB(2),clB(4),io6(10)..io(16) are not valid.')
mdlCmprObj = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 3, 1, 1, 5), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mdlCmprObj.setStatus('mandatory')
if mibBuilder.loadTexts: mdlCmprObj.setDescription('This attribute is the compressed information itself.')
mdlAlarmsCmprTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 3, 2), )
if mibBuilder.loadTexts: mdlAlarmsCmprTable.setStatus('mandatory')
if mibBuilder.loadTexts: mdlAlarmsCmprTable.setDescription('')
mdlAlarmsCmprEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 3, 2, 1), ).setIndexNames((0, "DACS-MIB", "mdlAlarmsCmprVersion"), (0, "DACS-MIB", "mdlAlarmsCmprAlarmSlot"), (0, "DACS-MIB", "mdlAlarmsCmprAlarmIdx"))
if mibBuilder.loadTexts: mdlAlarmsCmprEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mdlAlarmsCmprEntry.setDescription('')
mdlAlarmsCmprVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlAlarmsCmprVersion.setStatus('mandatory')
if mibBuilder.loadTexts: mdlAlarmsCmprVersion.setDescription('This attribute indicates the version of the internal format of the Compressed data')
mdlAlarmsCmprAlarmSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 3, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlAlarmsCmprAlarmSlot.setStatus('mandatory')
if mibBuilder.loadTexts: mdlAlarmsCmprAlarmSlot.setDescription('This attribute indicates the desired slot position. In the ?004 Unit the entries PsB(2),ClB(4),io6(10)..io(16) are not valid.')
mdlAlarmsCmprAlarmIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 3, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlAlarmsCmprAlarmIdx.setStatus('mandatory')
if mibBuilder.loadTexts: mdlAlarmsCmprAlarmIdx.setDescription('A unique number to identify an entry in the alarm status table of the agent.')
mdlAlarmsCmprObj = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 3, 3, 2, 1, 4), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mdlAlarmsCmprObj.setStatus('mandatory')
if mibBuilder.loadTexts: mdlAlarmsCmprObj.setDescription('This attribute is the compressed information itself.')
prtSInstTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 1), )
if mibBuilder.loadTexts: prtSInstTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtSInstTable.setDescription('')
prtSInstEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 1, 1), ).setIndexNames((0, "DACS-MIB", "prtSInstSltIdx"), (0, "DACS-MIB", "prtSInstPrtIdx"))
if mibBuilder.loadTexts: prtSInstEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtSInstEntry.setDescription('')
prtSInstSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("clA", 3), ("clB", 4), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSInstSltIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtSInstSltIdx.setDescription('This attribute indicates a unique number to identify the slot where the card is inserted. In the ?004 Unit the entries io6(10)..io(16) are not valid.')
prtSInstPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSInstPrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtSInstPrtIdx.setDescription('This attribute indicates a unique number to identify a port in a specific card. The valid ports depend on the installed card: the valid external ports (interfaces) are (1..mdlCNoOfExternPrt) if any, and the valid internal ports are (101..100+mdlCNoOfInternPrt) if any. Generally: exPrt1 (1) .. exPrt12 (12), inPrt14 (114) .. inPrt48 (148) ')
prtSInstPrtType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("external", 2), ("internal", 3), ("highSpeedV35", 4), ("highSpeedV24", 5), ("highSpeedV36", 6), ("highSpeedX21", 7), ("highSpeedG703", 8), ("highSpeedDDS", 9), ("lowSpeed", 10), ("voice", 11), ("cl", 12), ("isdns", 13), ("isdnu", 14), ("ethernet", 15), ("voiceS0", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSInstPrtType.setStatus('mandatory')
if mibBuilder.loadTexts: prtSInstPrtType.setDescription("This attribute describes the type of the designated port. In MX 3000 only external & internal options are used. All the other options are only for MX 30/300 which need special handling. In order to support interface types in MX 3000, return an ascii string for prtSInterfaceType in this table or support the general RAD value of physicalConnector. External port - is a port with a physical connector. Internal port - might be of two types: a) A composite port which collects a few external ports data into a common bandwidth (usually routed through DS1 link) b) A port which gets only part of the external ports (usually a few DS0's) The following types are used when all ports are external/ internal and the connector/interface type is necessary (for example, stand-alone units): High Speed port types Low Speed port types Voice port types, CL port types.")
prtSInstIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSInstIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: prtSInstIfIndex.setDescription("This attribute indicates the unique interface number assigned to the port. The specific interface of this attribute is the same as the interface identified by the value of ifindex in MIB-II.If there is no interface for the specific prtIdx the value will be '7fffffff'h.")
prtSActiveStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("unknown", 1), ("notUsed", 2), ("offLine", 3), ("onLine", 4), ("offLineRedundancy", 5), ("onLineRedundancy", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSActiveStatus.setStatus('mandatory')
if mibBuilder.loadTexts: prtSActiveStatus.setDescription('This attribute describes the activity status of the port. unknown(1) indicates that the information is not supported. notUsed(2) indicates that the ch is not connected according to the active config. offLine(3) indicates that the ch is down (not working) because of any problem. onLine(4) indicates that the ch is up (working) offLineRedundancy(5) indicates that the ch is down, because it is redundant port. onLineRedundancy(6) indicates that the ch is up, and it is the active link')
prtSAlrStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("off", 2), ("event", 3), ("minor", 4), ("major", 5), ("warning", 6), ("critical", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSAlrStatus.setStatus('mandatory')
if mibBuilder.loadTexts: prtSAlrStatus.setDescription('Indicates the alarm state in the port(ch) agent level. This attribute will be set to: critical(7) - when there is at least one active (state ON) critical alarm, otherwise it will be set to major(5) - when there is at least one active (state ON) major alarm, otherwise it will be set to minor(4) - if there is at least one active (state ON) minor alarm, otherwise it will be set to warning(6) - if there is at least one active (state ON) warning alarm, otherwise it will be set to event(3) - if there was at least one alarm event (including state on,off events) since the last clear operation.')
prtSMaskedAlrStat = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("off", 2), ("event", 3), ("minor", 4), ("major", 5), ("warning", 6), ("critical", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSMaskedAlrStat.setStatus('mandatory')
if mibBuilder.loadTexts: prtSMaskedAlrStat.setDescription('Indicates the alarm state in the port(ch) agent level, including Masked alarms. This attribute will be set to: critical(7) - when there is at least one active (state ON) critical alarm, otherwise it will be set to major(5) - when there is at least one active (state ON) major alarm, otherwise it will be set to minor(4) - if there is at least one active (state ON) minor alarm, otherwise it will be set to warning(6) - if there is at least one active (state ON) warning alarm, otherwise it will be set to event(3) - if there was at least one alarm event (including state on,off events) since the last clear operation.')
prtSClearAlrCmd = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtSClearAlrCmd.setStatus('mandatory')
if mibBuilder.loadTexts: prtSClearAlrCmd.setDescription('Setting this attribute to on(3) enforces a clear operation of the alarm status events in the given port. The clear operation will not be applied for masked/inverted alarms.')
prtSTestMask = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSTestMask.setStatus('mandatory')
if mibBuilder.loadTexts: prtSTestMask.setDescription("This is a mask which indicates which tests from the 'prtSTstCmd' list are allowed for the requested port. If a specific test is allowed, its respective bit will be SET in the mask : TEST BIT ----------- --- local-loop 1 remote-loop 2 loc-and-rem-main-loops 3 remote-analog-loop 4 remote-digital-loop 5 rem-loop-on-ext-unit 6 bert 7 tone-injection 8 dlci local-loop 9 all dlci local-loop 10 dlci remote-loop 11 all dlci remote-loop 12 bert-and-rem-loop-on-rem-unit 13 rem-loop-on-rem-unit 14 block 15 backward-tone-inject 16 llb 17 rlb 18 ft1Enable 21 lbbd 22 --for 2B+D lb1 23 --for B1 lb2 24 --for B2 e.g : If the return value is 3 -> 0000000000000011 -> Bits 1 & 2 are set -> the allowed tests are : local-loop remote-loop ")
prtSTstCmd = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24))).clone(namedValues=NamedValues(("none", 1), ("localLoop", 2), ("remoteLoop", 3), ("locAndRemMainLoops", 4), ("remoteAnalogLoop", 5), ("remoteDigitalLoop", 6), ("remLoopOnExtUnit", 7), ("bert", 8), ("toneInjection", 9), ("dlciLocalLoop", 10), ("allDlciLocalLoop", 11), ("dlciRemoteLoop", 12), ("allDlciRemoteLoop", 13), ("extInitLocalLoop", 14), ("bertAndRemLoopOnRemUnit", 15), ("remLoopOnRemUnit", 16), ("block", 17), ("backwardToneInject", 18), ("llb", 19), ("rlb", 20), ("ft1Enable", 21), ("lbbd", 22), ("lb1", 23), ("lb2", 24)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtSTstCmd.setStatus('mandatory')
if mibBuilder.loadTexts: prtSTstCmd.setDescription("Setting this attribute to any of the above values will initiate a test on the specific port if the operation is legal. If the operation is not legal, the mux will ignore the operation. If a test time out is needed, the test will be set with a default timeout of 2 minutes until the user will set the parameter 'prtSTstDuration' to the required time out. If no time out is needed , the test will be set with infinite timeout until the user will set the parameter 'prtSTstDuration' to the required time out.")
prtSTstDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 1, 1, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtSTstDuration.setStatus('mandatory')
if mibBuilder.loadTexts: prtSTstDuration.setDescription("This attribute indicates the maximum duration of executing a test on the specific port. This entry applies to all the test operations. The resolution will be a minute, and the maximum duration is limited to 30 minutes . A zero value specifies no time limitation. When the test isn't active, the agent initiates this object to 2 when the duration is needed and to 0 if its not required. The user should set this parameter after setting the 'prtSTstCmd' parameter.")
prtSBertClrCmd = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtSBertClrCmd.setStatus('mandatory')
if mibBuilder.loadTexts: prtSBertClrCmd.setDescription('Setting this attribute initiates bert count clear operation. It is valid only when bert test is active on the specific port.')
prtSBertTstRslt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 1, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSBertTstRslt.setStatus('mandatory')
if mibBuilder.loadTexts: prtSBertTstRslt.setDescription('This attribute indicates the number of Bit Error Rate indicated during the BERT operation. It is valid only when bert test is active on the specific port.')
prtSInterfaceType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 1, 1, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSInterfaceType.setStatus('mandatory')
if mibBuilder.loadTexts: prtSInterfaceType.setDescription('This attribute indicates a unique HW interface type of the selected port.')
prtSParamStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 1, 1, 15), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSParamStatus.setStatus('mandatory')
if mibBuilder.loadTexts: prtSParamStatus.setDescription("This object indicates Status of parameters specific to the selected port. - For a port that has no special status or is supported by prtSExHsfStatTable - 1 Octet: 00hex - For VC-6, VC-12, VC-12/6 external ports - 1 Octet : Bit 7 (MSB)..Bit 2 = 0 (NA) Bit 1: Tx Signaling '1'=On ; '0'=Off Bit 0 (LSB): Rx Signaling '1'=On ; '0'=Off - For VC-6A and VC-6AG external ports - 1 Octet : Bit 7 (MSB)..Bit 3 = 0 (NA) Bit 2: ADPCM module '1' =Exist ; '0' =Not Exist Bit 1: Tx Signaling '1'=On ; '0'=Off Bit 0 (LSB): Rx Signaling '1'=On ; '0'=Off - For VC-2/R2(FXS) external ports - 1 Octet : Bit - 7 6 5 4 3 2 1 0 |_| |_________| Call Call State Direction Bit 7 (MSB) and Bit 6 : Call Direction 00 - Incoming 01 - Outgoing Bit 5..Bit 0: Call State 000000 - Idle 000001 - Seized 000010 - Both-Way Conflict 000011 - Seizure Ack 000100 - Answered 000101 - Clear Backward 000110 - Clear Forward 000111 - Blocked 001000 - Fault 001001 - Fault 3 001010 - Fault 4 001011 - Fault 5 001100 - Fault 6 001101 - Fault 7 - For ML-20 external port - 3 Octets : - 1 MS Octet will represent the Real Rate used: Bit - 7 6 5 4 3 2 1 0 |___| |_______| spare Rate Valid values: 0..31, meaning 0..31x64Kbps Invalid values: 32..255. - 2 LS Octets will represent the Status of 7 Control Signals: Signal - --- CTS DSR DCD RJ TM DTR RTS Bit - 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0 Octet - 2 3 (LS) '---' will always have the value 00 Rest of the Signals (2 bits each) can have the following values: 00=NA ; 01=unused ; 10=Off ; 11=On - For ML-H/E1, ML-H/1/E1, ML-H/S/E1 internal port - 1 Octet Bit - 7 6 5 4 3 2 1 0 |___________| spare Mode of Operation Mode of Operation: '1'=Central ; '0'=Remote - For ACM external port - 1 Octet Bit - 7 6 5 4 3 2 1 0 |_________| spare Alarm State Alarm State: according to bits 1,0: 00=NA ; 01=unused ; 10=Off ; 11=On - For HS-U/1 external port - 1 Octet Bit 7 6 5 4 3 2 1 0 LSB |________| |__| |__| spare modem sync modem: 00 = unknown sync: 00 = not sync 01 = ASMi-31 01 = sync 10 = other 10 = reserved 11 = reserved 11 = reserved ")
prtSAlrTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 2), )
if mibBuilder.loadTexts: prtSAlrTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtSAlrTable.setDescription('The list of port agent alarms.')
prtSAlrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 2, 1), ).setIndexNames((0, "DACS-MIB", "prtSAlrSltIdx"), (0, "DACS-MIB", "prtSAlrPrtIdx"), (0, "DACS-MIB", "prtSAlrIdx"))
if mibBuilder.loadTexts: prtSAlrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtSAlrEntry.setDescription('')
prtSAlrIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSAlrIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtSAlrIdx.setDescription('A unique number to identify an entry in the alarm status table. Users should use the get next function to read this table because the indexes are not consecutive')
prtSAlrSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("psA", 1), ("psB", 2), ("clA", 3), ("clB", 4), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSAlrSltIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtSAlrSltIdx.setDescription('This attribute indicates a unique identifier of the slot where the card is inserted. In the ?004 Unit the entries PsB(2),ClB(4),io6(10)..io12(16) are not valid.')
prtSAlrPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSAlrPrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtSAlrPrtIdx.setDescription('This attribute indicates a unique identifier of the port the alarm applies to. All the values are valid. No alarms exist for a port which does not physically exist. Valid values: exPrt1 (1) .. exPrt12 (12) , inPrt1 (101) .. inPrt48 (148).')
prtSAlrCodeDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 2, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSAlrCodeDescription.setStatus('mandatory')
if mibBuilder.loadTexts: prtSAlrCodeDescription.setDescription('This attribute is a full text description of the alarm. The alarm description includes the following information: alarm code, alarm text, alarm severity, Masked or Inverted flag and counter.')
prtSAlrCode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSAlrCode.setStatus('mandatory')
if mibBuilder.loadTexts: prtSAlrCode.setDescription('A code identifying the alarm of an entry in the alarm status table at port level.')
prtSAlrSeverity = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("event", 3), ("minor", 4), ("major", 5), ("warning", 6), ("critical", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSAlrSeverity.setStatus('mandatory')
if mibBuilder.loadTexts: prtSAlrSeverity.setDescription('The severity of the alarm.')
prtSAlrState = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSAlrState.setStatus('mandatory')
if mibBuilder.loadTexts: prtSAlrState.setDescription('State of the alarm.')
prtSAlrCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 2, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSAlrCounter.setStatus('mandatory')
if mibBuilder.loadTexts: prtSAlrCounter.setDescription('A counter - how many times the alarm occured since last clear operation. ON and OFF Alarm will be counted separately.')
prtSAlrMask = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSAlrMask.setStatus('mandatory')
if mibBuilder.loadTexts: prtSAlrMask.setDescription('Alarm mask : on/off.')
prtSAlrInvert = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSAlrInvert.setStatus('mandatory')
if mibBuilder.loadTexts: prtSAlrInvert.setDescription('Alarm invert : on/off.')
statisPrtGen = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3))
prtFrStatis = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 1))
prtCrStatis = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 2))
prtDlciStatis = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 3))
prtT1Statis = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 4))
prtFrStatisTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 1, 1), )
if mibBuilder.loadTexts: prtFrStatisTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtFrStatisTable.setDescription('This table is applicable only for an active port running an FR protocol .')
prtFrStatisEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 1, 1, 1), ).setIndexNames((0, "DACS-MIB", "prtFrStatisSltIdx"), (0, "DACS-MIB", "prtFrStatisPrtIdx"), (0, "DACS-MIB", "prtFrStatisInvIdx"))
if mibBuilder.loadTexts: prtFrStatisEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtFrStatisEntry.setDescription('')
prtFrStatisSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtFrStatisSltIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtFrStatisSltIdx.setDescription('This attribute indicates a unique slot position where the module is inserted. In the ?004 Unit the entries io6(10)..io12(16) are not valid. For stand-alone units this index will be notApplicable (255).')
prtFrStatisPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("exPrt1", 1), ("exPrt2", 2), ("exPrt3", 3), ("exPrt4", 4), ("exPrt5", 5), ("exPrt6", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtFrStatisPrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtFrStatisPrtIdx.setDescription('This attribute indicates a unique port number.')
prtFrStatisInvIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("currentInv", 1), ("last", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtFrStatisInvIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtFrStatisInvIdx.setDescription('The Interval of 15 min. for which the following statistics counters are applicable.')
prtFrTimeElapsed = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 899))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtFrTimeElapsed.setStatus('mandatory')
if mibBuilder.loadTexts: prtFrTimeElapsed.setDescription('The number of seconds that have elapsed since the beginning of the current error-measurement interval. This object is applicable mainly for the current interval. For other interval: - if data is available: value will be 899. - if data is not available: value will be 0.')
prtFrRxTotalFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 1, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtFrRxTotalFrames.setStatus('mandatory')
if mibBuilder.loadTexts: prtFrRxTotalFrames.setDescription('The total number of frames received by this port during the selected interval.')
prtFrTxTotalFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 1, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtFrTxTotalFrames.setStatus('mandatory')
if mibBuilder.loadTexts: prtFrTxTotalFrames.setDescription('The total number of frames sent by this port during the selected interval.')
prtFrRxTotalBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 1, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtFrRxTotalBytes.setStatus('mandatory')
if mibBuilder.loadTexts: prtFrRxTotalBytes.setDescription('The total number of bytes received by this port during the selected interval.')
prtFrTxTotalBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 1, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtFrTxTotalBytes.setStatus('mandatory')
if mibBuilder.loadTexts: prtFrTxTotalBytes.setDescription('The total number of bytes sent by this port during the selected interval.')
prtFrRxMngFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 1, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtFrRxMngFrames.setStatus('mandatory')
if mibBuilder.loadTexts: prtFrRxMngFrames.setDescription('The management number of frames received by this port during the selected interval.')
prtFrTxMngFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 1, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtFrTxMngFrames.setStatus('mandatory')
if mibBuilder.loadTexts: prtFrTxMngFrames.setDescription('The management number of frames sent by this port during the selected interval.')
prtFrRxDeFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 1, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtFrRxDeFrames.setStatus('mandatory')
if mibBuilder.loadTexts: prtFrRxDeFrames.setDescription('The number of De frames received by this port during the selected interval.')
prtFrTxDeFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 1, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtFrTxDeFrames.setStatus('mandatory')
if mibBuilder.loadTexts: prtFrTxDeFrames.setDescription('The number of De frames sent by this port during the selected interval.')
prtFrRxDcrdCongDeFr = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 1, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtFrRxDcrdCongDeFr.setStatus('mandatory')
if mibBuilder.loadTexts: prtFrRxDcrdCongDeFr.setDescription('The number of De frames discarded due to congestion, received by this port during the selected interval.')
prtFrTxDcrdCongDeFr = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 1, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtFrTxDcrdCongDeFr.setStatus('mandatory')
if mibBuilder.loadTexts: prtFrTxDcrdCongDeFr.setDescription('The number of De frames discarded due to congestion, sent by this port during the selected interval.')
prtFrRxDcrdCongAllFr = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 1, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtFrRxDcrdCongAllFr.setStatus('mandatory')
if mibBuilder.loadTexts: prtFrRxDcrdCongAllFr.setDescription('All the frames discarded due to congestion, received by this port during the selected interval.')
prtFrTxDcrdCongAllFr = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 1, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtFrTxDcrdCongAllFr.setStatus('mandatory')
if mibBuilder.loadTexts: prtFrTxDcrdCongAllFr.setDescription('All the frames discarded due to congestion, sent by this port during the selected interval.')
prtFrRxFecn = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 1, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtFrRxFecn.setStatus('mandatory')
if mibBuilder.loadTexts: prtFrRxFecn.setDescription('Number of frames received by this port during the selected interval, indicating forward congestion.')
prtFrTxFecn = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 1, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtFrTxFecn.setStatus('mandatory')
if mibBuilder.loadTexts: prtFrTxFecn.setDescription('Number of frames sent by this port during the selected interval, indicating forward congestion.')
prtFrRxBecn = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 1, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtFrRxBecn.setStatus('mandatory')
if mibBuilder.loadTexts: prtFrRxBecn.setDescription('Number of frames received by this port during the selected interval, indicating backward congestion.')
prtFrTxBecn = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 1, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtFrTxBecn.setStatus('mandatory')
if mibBuilder.loadTexts: prtFrTxBecn.setDescription('Number of frames sent by this port during the selected interval, indicating backward congestion.')
prtFrRxBeViol = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 1, 1, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtFrRxBeViol.setStatus('mandatory')
if mibBuilder.loadTexts: prtFrRxBeViol.setDescription('Number of data frames received by this port during the selected interval, exceeding the Burst Excess value.')
prtFrTxBeViol = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 1, 1, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtFrTxBeViol.setStatus('mandatory')
if mibBuilder.loadTexts: prtFrTxBeViol.setDescription('Number of data frames sent by this port during the selected interval, exceeding the Burst Excess value.')
prtFrRxBcViol = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 1, 1, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtFrRxBcViol.setStatus('mandatory')
if mibBuilder.loadTexts: prtFrRxBcViol.setDescription('Number of data frames received by this port during the selected interval, exceeding the Burst Committed value.')
prtFrTxBcViol = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 1, 1, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtFrTxBcViol.setStatus('mandatory')
if mibBuilder.loadTexts: prtFrTxBcViol.setDescription('Number of data frames sent by this port during the selected interval, exceeding the Burst Committed value.')
prtCrStatisTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 2, 1), )
if mibBuilder.loadTexts: prtCrStatisTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtCrStatisTable.setDescription('This table is applicable only for an active port running a CR protocol .')
prtCrStatisEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 2, 1, 1), ).setIndexNames((0, "DACS-MIB", "prtCrStatisSltIdx"), (0, "DACS-MIB", "prtCrStatisPrtIdx"), (0, "DACS-MIB", "prtCrStatisInvIdx"))
if mibBuilder.loadTexts: prtCrStatisEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtCrStatisEntry.setDescription('')
prtCrStatisSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtCrStatisSltIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtCrStatisSltIdx.setDescription('This attribute indicates a unique slot position where the module is inserted. In the ?004 Unit the entries io6(10)..io12(16) are not valid. For stand-alone units this index will be notApplicable (255).')
prtCrStatisPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("exPrt1", 1), ("exPrt2", 2), ("exPrt3", 3), ("exPrt4", 4), ("exPrt5", 5), ("exPrt6", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtCrStatisPrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtCrStatisPrtIdx.setDescription('This attribute indicates a unique port number.')
prtCrStatisInvIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("currentInv", 1), ("last", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtCrStatisInvIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtCrStatisInvIdx.setDescription('The Interval of 15 min. for which the following statistics counters are applicable.')
prtCrTimeElapsed = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 899))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtCrTimeElapsed.setStatus('mandatory')
if mibBuilder.loadTexts: prtCrTimeElapsed.setDescription('The number of seconds that have elapsed since the beginning of the current error-measurement interval. This object is applicable mainly for the current interval. For other interval: - if data is available: value will be 899. - if data is not available: value will be 0.')
prtCrRxTotalCells = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 2, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtCrRxTotalCells.setStatus('mandatory')
if mibBuilder.loadTexts: prtCrRxTotalCells.setDescription('The total number of cells received by this port during the selected interval.')
prtCrTxTotalCells = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 2, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtCrTxTotalCells.setStatus('mandatory')
if mibBuilder.loadTexts: prtCrTxTotalCells.setDescription('The total number of cells sent by this port during the selected interval.')
prtCrRxDataCells = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 2, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtCrRxDataCells.setStatus('mandatory')
if mibBuilder.loadTexts: prtCrRxDataCells.setDescription('The number of Data Cells received by this port during the selected interval.')
prtCrTxDataCells = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 2, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtCrTxDataCells.setStatus('mandatory')
if mibBuilder.loadTexts: prtCrTxDataCells.setDescription('The number of Data Cells sent by this port during the selected interval.')
prtDlciStatisTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 3, 1), )
if mibBuilder.loadTexts: prtDlciStatisTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtDlciStatisTable.setDescription('This table is applicable only for an active port running an FR, FR+ or CR protocol, with valid DLCIs .')
prtDlciStatisEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 3, 1, 1), ).setIndexNames((0, "DACS-MIB", "prtDlciSltIdx"), (0, "DACS-MIB", "prtDlciPrtIdx"), (0, "DACS-MIB", "prtDlciIdx"))
if mibBuilder.loadTexts: prtDlciStatisEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtDlciStatisEntry.setDescription('')
prtDlciSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDlciSltIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtDlciSltIdx.setDescription('This attribute indicates a unique slot position where the module is inserted. In the ?004 Unit the entries io6(10)..io12(16) are not valid. For stand-alone units this index will be notApplicable (255).')
prtDlciPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("exPrt1", 1), ("exPrt2", 2), ("exPrt3", 3), ("exPrt4", 4), ("exPrt5", 5), ("exPrt6", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDlciPrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtDlciPrtIdx.setDescription('This attribute indicates a unique port number.')
prtDlciIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 991))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDlciIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtDlciIdx.setDescription('This attribute indicates a unique DLCI index for each valid DLCI (16..991). ')
prtDlciRxDeFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 3, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDlciRxDeFrames.setStatus('mandatory')
if mibBuilder.loadTexts: prtDlciRxDeFrames.setDescription('The number of De frames received by this DLCI.')
prtDlciTxDeFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 3, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDlciTxDeFrames.setStatus('mandatory')
if mibBuilder.loadTexts: prtDlciTxDeFrames.setDescription('The number of De frames sent by this DLCI.')
prtDlciRxDcrdCongDeFr = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 3, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDlciRxDcrdCongDeFr.setStatus('mandatory')
if mibBuilder.loadTexts: prtDlciRxDcrdCongDeFr.setDescription('The number of De frames discarded due to congestion, received by this DLCI.')
prtDlciTxDcrdCongDeFr = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 3, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDlciTxDcrdCongDeFr.setStatus('mandatory')
if mibBuilder.loadTexts: prtDlciTxDcrdCongDeFr.setDescription('The number of De frames discarded due to congestion, sent by this DLCI.')
prtDlciRxDcrdCongAllFr = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 3, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDlciRxDcrdCongAllFr.setStatus('mandatory')
if mibBuilder.loadTexts: prtDlciRxDcrdCongAllFr.setDescription('All the frames discarded due to congestion, received by this DLCI.')
prtDlciTxDcrdCongAllFr = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 3, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDlciTxDcrdCongAllFr.setStatus('mandatory')
if mibBuilder.loadTexts: prtDlciTxDcrdCongAllFr.setDescription('All the frames discarded due to congestion, sent by this DLCI.')
prtDlciTxFecn = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 3, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDlciTxFecn.setStatus('mandatory')
if mibBuilder.loadTexts: prtDlciTxFecn.setDescription('Number of frames sent by this DLCI, indicating forward congestion.')
prtDlciTxBecn = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 3, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDlciTxBecn.setStatus('mandatory')
if mibBuilder.loadTexts: prtDlciTxBecn.setDescription('Number of frames sent by this DLCI, indicating backward congestion.')
prtDlciRxBeViol = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 3, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDlciRxBeViol.setStatus('mandatory')
if mibBuilder.loadTexts: prtDlciRxBeViol.setDescription('Number of data frames received by this DLCI, exceeding the Burst Excess value.')
prtDlciTxBeViol = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 3, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDlciTxBeViol.setStatus('mandatory')
if mibBuilder.loadTexts: prtDlciTxBeViol.setDescription('Number of data frames sent by this DLCI, exceeding the Burst Excess value.')
prtDlciRxBcViol = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 3, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDlciRxBcViol.setStatus('mandatory')
if mibBuilder.loadTexts: prtDlciRxBcViol.setDescription('Number of data frames received by this DLCI, exceeding the Burst Committed value.')
prtDlciTxBcViol = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 3, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDlciTxBcViol.setStatus('mandatory')
if mibBuilder.loadTexts: prtDlciTxBcViol.setDescription('Number of data frames sent by this DLCI, exceeding the Burst Committed value.')
prtT1FdlMsgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 4, 1), )
if mibBuilder.loadTexts: prtT1FdlMsgTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtT1FdlMsgTable.setDescription("This table is applicable for a T1 interface with 'esf' LineType .")
prtT1FdlMsgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 4, 1, 1), ).setIndexNames((0, "DACS-MIB", "prtT1FdlMsgSltIdx"), (0, "DACS-MIB", "prtT1FdlMsgPrtIdx"), (0, "DACS-MIB", "prtT1FdlMsgFdlTxRx"))
if mibBuilder.loadTexts: prtT1FdlMsgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtT1FdlMsgEntry.setDescription('')
prtT1FdlMsgSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtT1FdlMsgSltIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtT1FdlMsgSltIdx.setDescription('This attribute indicates a unique slot position where the module is inserted. In the ?004 Unit the entries io6(10)..io12(16) are not valid.')
prtT1FdlMsgPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("exPrt1", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtT1FdlMsgPrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtT1FdlMsgPrtIdx.setDescription('This attribute indicates a unique port number. MTML-1/T1 modules have just one external interface.')
prtT1FdlMsgFdlTxRx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("tx", 1), ("rx", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtT1FdlMsgFdlTxRx.setStatus('mandatory')
if mibBuilder.loadTexts: prtT1FdlMsgFdlTxRx.setDescription('The Fdl tx/rx reference of the Fdl message.')
prtT1FdlMsg = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 1, 3, 4, 1, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtT1FdlMsg.setStatus('mandatory')
if mibBuilder.loadTexts: prtT1FdlMsg.setDescription('FDL message.')
prtExTsSplitTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 1), )
if mibBuilder.loadTexts: prtExTsSplitTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtExTsSplitTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry.')
prtExTsSplitEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 1, 1), ).setIndexNames((0, "DACS-MIB", "prtExTsCnfgIdx"), (0, "DACS-MIB", "prtExTsSltIdx"), (0, "DACS-MIB", "prtExTsPrtIdx"), (0, "DACS-MIB", "prtExTsIdx"), (0, "DACS-MIB", "prtExTsBit"))
if mibBuilder.loadTexts: prtExTsSplitEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtExTsSplitEntry.setDescription('')
prtExTsCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExTsCnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtExTsCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg. ')
prtExTsSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExTsSltIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtExTsSltIdx.setDescription('This attribute indicates a unique slot position where the card is inserted. In the ?004 Unit the entries io6(10)..io12(16) are not valid. notApplicable - for stand-alone units.')
prtExTsPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExTsPrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtExTsPrtIdx.setDescription("This attribute indicates a unique port number. Most ML cards have only one external interface. inPrt1 - for MTML-H/E1 cards. For other products' index see their specification.")
prtExTsIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExTsIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtExTsIdx.setDescription('This attribute indicates a unique time slot position. The valid time slots are: 1..24 for T1 Card and 1..31 for E1 interface. In G732S-E1 lines, time slot 16 is not valid for data, it is dedicated to multiframe synchronization bits and voice signaling.')
prtExTsBit = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExTsBit.setStatus('mandatory')
if mibBuilder.loadTexts: prtExTsBit.setDescription('This attribute indicates a unique Bit within the time slot. The valid Bits are: 1..8.')
prtExTsIConSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("noConnect", 2), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExTsIConSlot.setStatus('mandatory')
if mibBuilder.loadTexts: prtExTsIConSlot.setDescription('This attribute indicates whether the specified time slot is connected/routed internally in the Agent and to which card it is connected. In the ?004 Unit the entries io6(10)..io12(16) are not valid. notApplicable - for stand-alone units.')
prtExTsIConPrt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 1, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExTsIConPrt.setStatus('mandatory')
if mibBuilder.loadTexts: prtExTsIConPrt.setDescription("This attribute indicates the internally (In Mux) connected/routed port. For other products' index see their specification.")
prtCnfgAgenda = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 2))
prtAgendaBehaviourTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 2, 1), )
if mibBuilder.loadTexts: prtAgendaBehaviourTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtAgendaBehaviourTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry.')
prtAgendaBehaviourEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 2, 1, 1), ).setIndexNames((0, "DACS-MIB", "prtAgendaBehaviourCnfgIdx"), (0, "DACS-MIB", "prtAgendaBehaviourSltIdx"), (0, "DACS-MIB", "prtAgendaBehaviourPrtIdx"))
if mibBuilder.loadTexts: prtAgendaBehaviourEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtAgendaBehaviourEntry.setDescription('')
prtAgendaBehaviourCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtAgendaBehaviourCnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtAgendaBehaviourCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg. ')
prtAgendaBehaviourSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 2, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtAgendaBehaviourSltIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtAgendaBehaviourSltIdx.setDescription('This parameter should be: - slot number for MX3000 - 255 = N/A for MX300/30. ')
prtAgendaBehaviourPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 2, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtAgendaBehaviourPrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtAgendaBehaviourPrtIdx.setDescription('This parameter should be: - port number for MX300/30 - 100 = N/A for MX3000. ')
prtAgendaBehaviourOnOff = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("off", 2), ("on", 3))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtAgendaBehaviourOnOff.setStatus('mandatory')
if mibBuilder.loadTexts: prtAgendaBehaviourOnOff.setDescription('Setting this command to on(3) enables the agenda function at module (3000) or port (300/30) level.')
prtCnfgAgendaTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 2, 2), )
if mibBuilder.loadTexts: prtCnfgAgendaTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtCnfgAgendaTable.setDescription('This table allows the user to schedule the time a session is active per week basis.')
prtCnfgAgendaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 2, 2, 1), ).setIndexNames((0, "DACS-MIB", "prtCnfgAgendaCnfgIdx"), (0, "DACS-MIB", "prtCnfgAgendaSltIdx"), (0, "DACS-MIB", "prtCnfgAgendaPrtIdx"), (0, "DACS-MIB", "prtCnfgAgendaDayIdx"), (0, "DACS-MIB", "prtCnfgAgendaSesId"))
if mibBuilder.loadTexts: prtCnfgAgendaEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtCnfgAgendaEntry.setDescription('')
prtCnfgAgendaCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtCnfgAgendaCnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtCnfgAgendaCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg. ')
prtCnfgAgendaSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 2, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtCnfgAgendaSltIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtCnfgAgendaSltIdx.setDescription('This attribute is equal to: -slot number for MX3000 -255 = N/A for MX300/30')
prtCnfgAgendaPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 2, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtCnfgAgendaPrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtCnfgAgendaPrtIdx.setDescription('This attribute is equal to: -port number for MX300/30 -100 = N/A for MX3000')
prtCnfgAgendaDayIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("monday", 1), ("tuesday", 2), ("wednesday", 3), ("thursday", 4), ("friday", 5), ("saturday", 6), ("sunday", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtCnfgAgendaDayIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtCnfgAgendaDayIdx.setDescription('This attribute for which day of the week this row applies.')
prtCnfgAgendaSesId = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtCnfgAgendaSesId.setStatus('mandatory')
if mibBuilder.loadTexts: prtCnfgAgendaSesId.setDescription('The user may define 4 different active intervals per day.')
prtCnfgAgendaFrom = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 2, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 86400)).clone(86400)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtCnfgAgendaFrom.setStatus('mandatory')
if mibBuilder.loadTexts: prtCnfgAgendaFrom.setDescription('Start from time interval in seconds.')
prtCnfgAgendaTo = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 2, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 86400)).clone(86400)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtCnfgAgendaTo.setStatus('mandatory')
if mibBuilder.loadTexts: prtCnfgAgendaTo.setDescription('To time interval in seconds.')
prtGenCnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 3), )
if mibBuilder.loadTexts: prtGenCnfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtGenCnfgTable.setDescription('This table allows the user to configure general port parameters.')
prtGenCnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 3, 1), ).setIndexNames((0, "DACS-MIB", "prtGenCnfgIdx"), (0, "DACS-MIB", "prtGenCnfgSltIdx"), (0, "DACS-MIB", "prtGenCnfgPrtIdx"))
if mibBuilder.loadTexts: prtGenCnfgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtGenCnfgEntry.setDescription('')
prtGenCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtGenCnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtGenCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg. The write operation is valid only to the TmpCnfg.')
prtGenCnfgSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtGenCnfgSltIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtGenCnfgSltIdx.setDescription('This attribute indicates a unique slot position where the card is inserted.')
prtGenCnfgPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtGenCnfgPrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtGenCnfgPrtIdx.setDescription('This attribute indicates a unique external or internal port number. For MP: exPrt1 (1) .. exPrt12 (12) , notApplicable(100), inPrt1 (101) .. inPrt48 (148) ')
prtGenCnfgLinkToSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtGenCnfgLinkToSlot.setStatus('mandatory')
if mibBuilder.loadTexts: prtGenCnfgLinkToSlot.setDescription('This attribute indicates the slot of the ML card to which the IO port is mapped.')
prtGenCnfgLinkToPort = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 3, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtGenCnfgLinkToPort.setStatus('mandatory')
if mibBuilder.loadTexts: prtGenCnfgLinkToPort.setDescription('This attribute indicates the port in the prtGenCnfgLinkToSlot of the ML card to which the IO port is mapped. For MP: exPrt1 (1) , exPrt2 (2) , exPrt3 (3) , exPrt4 (4) , inPrt1 (101) notApplicable (255)')
prtGenCnfgPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 2, 3, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtGenCnfgPortId.setStatus('mandatory')
if mibBuilder.loadTexts: prtGenCnfgPortId.setDescription('IO Port Id for V5.1 use. This object is applicable only for part of the PSTN and ISDN IO ports. Generally, 0 is a valid value. Nevertheless, for ports that do not support this object, the value will be: notApplicable= 0')
prtCmprTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 3, 1), )
if mibBuilder.loadTexts: prtCmprTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtCmprTable.setDescription('')
prtCmprEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 3, 1, 1), ).setIndexNames((0, "DACS-MIB", "prtCmprTypIdx"), (0, "DACS-MIB", "prtCmprCnfgIdx"), (0, "DACS-MIB", "prtCmprVersion"), (0, "DACS-MIB", "prtCmprSltIdx"), (0, "DACS-MIB", "prtCmprPrtIdx"))
if mibBuilder.loadTexts: prtCmprEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtCmprEntry.setDescription('')
prtCmprTypIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtCmprTypIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtCmprTypIdx.setDescription('This attribute indicates the Type of the Compressed being referred.')
prtCmprCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 3, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtCmprCnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtCmprCnfgIdx.setDescription('This attribute indicates the configuration to which the Compressed information is related.')
prtCmprVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 3, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtCmprVersion.setStatus('mandatory')
if mibBuilder.loadTexts: prtCmprVersion.setDescription('This attribute indicates the version of the internal format of the Compressed data')
prtCmprSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("psA", 1), ("psB", 2), ("clA", 3), ("clB", 4), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtCmprSltIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtCmprSltIdx.setDescription('This attribute indicates a unique number of the slot position where the card is inserted. In the ?004 Unit the entries psB(2),clB(4),io6(10)..io(16) are not valid.')
prtCmprPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 3, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtCmprPrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtCmprPrtIdx.setDescription('This attribute indicates a unique identifier of the port the compressed information relates to. Valid values: exPrt1 (1) .. exPrt12 (12) , inPrt1 (101) .. inPrt48 (148).')
prtCmprObj = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 3, 1, 1, 6), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtCmprObj.setStatus('mandatory')
if mibBuilder.loadTexts: prtCmprObj.setDescription('This attribute is the compressed information itself.')
prtDlciCmprTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 3, 2), )
if mibBuilder.loadTexts: prtDlciCmprTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtDlciCmprTable.setDescription('')
prtDlciCmprEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 3, 2, 1), ).setIndexNames((0, "DACS-MIB", "prtDlciCmprCnfgIdx"), (0, "DACS-MIB", "prtDlciCmprVersion"), (0, "DACS-MIB", "prtDlciCmprSltIdx"), (0, "DACS-MIB", "prtDlciCmprPrtIdx"), (0, "DACS-MIB", "prtDlciCmprDlciIdx"))
if mibBuilder.loadTexts: prtDlciCmprEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtDlciCmprEntry.setDescription('')
prtDlciCmprCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDlciCmprCnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtDlciCmprCnfgIdx.setDescription('This attribute indicates the configuration to which the Compressed information is related.')
prtDlciCmprVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 3, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDlciCmprVersion.setStatus('mandatory')
if mibBuilder.loadTexts: prtDlciCmprVersion.setDescription('This attribute indicates the version of the internal format of the Compressed data')
prtDlciCmprSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDlciCmprSltIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtDlciCmprSltIdx.setDescription('This attribute indicates a unique number of the slot position where the module is inserted. In the ?004 Unit the entries psB(2),clB(4),io6(10)..io(16) are not valid.')
prtDlciCmprPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 3, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112))).clone(namedValues=NamedValues(("exPrt1", 1), ("exPrt2", 2), ("exPrt3", 3), ("exPrt4", 4), ("exPrt5", 5), ("exPrt6", 6), ("exPrt7", 7), ("exPrt8", 8), ("exPrt9", 9), ("exPrt10", 10), ("inPrt1", 101), ("inPrt2", 102), ("inPrt3", 103), ("inPrt4", 104), ("inPrt5", 105), ("inPrt6", 106), ("inPrt7", 107), ("inPrt8", 108), ("inPrt9", 109), ("inPrt10", 110), ("inPrt11", 111), ("inPrt12", 112)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDlciCmprPrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtDlciCmprPrtIdx.setDescription('This attribute indicates a unique identifier of the port the compressed information relates to. All the values are valid.')
prtDlciCmprDlciIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 3, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDlciCmprDlciIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtDlciCmprDlciIdx.setDescription('This attribute indicates a unique identifier of the Dlci the compressed information relates to. The values are between 16 - 991.')
prtDlciCmprObj = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 3, 2, 1, 6), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtDlciCmprObj.setStatus('mandatory')
if mibBuilder.loadTexts: prtDlciCmprObj.setDescription('This attribute is the compressed information itself.')
prtAlarmsCmprTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 3, 3), )
if mibBuilder.loadTexts: prtAlarmsCmprTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtAlarmsCmprTable.setDescription('')
prtAlarmsCmprEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 3, 3, 1), ).setIndexNames((0, "DACS-MIB", "prtAlarmsCmprVersion"), (0, "DACS-MIB", "prtAlarmsCmprAlarmSlot"), (0, "DACS-MIB", "prtAlarmsCmprAlarmPort"), (0, "DACS-MIB", "prtAlarmsCmprAlarmIdx"))
if mibBuilder.loadTexts: prtAlarmsCmprEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtAlarmsCmprEntry.setDescription('')
prtAlarmsCmprVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 3, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtAlarmsCmprVersion.setStatus('mandatory')
if mibBuilder.loadTexts: prtAlarmsCmprVersion.setDescription('This attribute indicates the version of the internal format of the Compressed data')
prtAlarmsCmprAlarmSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 3, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtAlarmsCmprAlarmSlot.setStatus('mandatory')
if mibBuilder.loadTexts: prtAlarmsCmprAlarmSlot.setDescription('This attribute indicates the desired slot position. In the ?004 Unit the entries PsB(2),ClB(4),io6(10)..io(16) are not valid. For Stand-alone units, notApplicable(255) will appear.')
prtAlarmsCmprAlarmPort = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 3, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtAlarmsCmprAlarmPort.setStatus('mandatory')
if mibBuilder.loadTexts: prtAlarmsCmprAlarmPort.setDescription('This attribute indicates a unique identifier of the port the alarm applies to. All the values are valid. No alarms exist for a non-physical port')
prtAlarmsCmprAlarmIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 3, 3, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtAlarmsCmprAlarmIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtAlarmsCmprAlarmIdx.setDescription('A unique number to identify an entry in the alarm status table of the agent.')
prtAlarmsCmprObj = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 4, 3, 3, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtAlarmsCmprObj.setStatus('mandatory')
if mibBuilder.loadTexts: prtAlarmsCmprObj.setDescription('This attribute is the compressed information itself.')
prtSExHsfStatTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 1, 6), )
if mibBuilder.loadTexts: prtSExHsfStatTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtSExHsfStatTable.setDescription('')
prtSExHsfStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 1, 6, 1), ).setIndexNames((0, "DACS-MIB", "prtSExHsfSltIdx"), (0, "DACS-MIB", "prtSExHsfPrtIdx"))
if mibBuilder.loadTexts: prtSExHsfStatEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtSExHsfStatEntry.setDescription('')
prtSExHsfSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 1, 6, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSExHsfSltIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtSExHsfSltIdx.setDescription('This attribute indicates a unique slot position where the card is inserted. In the ?004 Unit the entries io6(10)..io16) are not valid.')
prtSExHsfPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 1, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("exPrt1", 1), ("exPrt2", 2), ("exPrt3", 3), ("exPrt4", 4), ("exPrt5", 5), ("exPrt6", 6), ("exPrt7", 7), ("exPrt8", 8), ("exPrt9", 9), ("exPrt10", 10), ("exPrt11", 11), ("exPrt12", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSExHsfPrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtSExHsfPrtIdx.setDescription('This attribute indicates a unique port number. ')
prtSExHsfInterfaceTyp = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 1, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("v35", 2), ("rs422", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSExHsfInterfaceTyp.setStatus('mandatory')
if mibBuilder.loadTexts: prtSExHsfInterfaceTyp.setDescription('This attribute indicates a unique interface type of a selected port.')
prtSExHsfRts = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 1, 6, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("notActive", 2), ("active", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSExHsfRts.setStatus('mandatory')
if mibBuilder.loadTexts: prtSExHsfRts.setDescription('This attribute indicates a unique RTS control signal state.')
cnfgMdlMux = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 2, 2, 1))
mdlPbxFramerCnfg = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 2, 2, 1, 1))
mdlPbxFramerCnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 2, 1, 1, 1), )
if mibBuilder.loadTexts: mdlPbxFramerCnfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: mdlPbxFramerCnfgTable.setDescription('This table contains parameters relevant to a module belonging to a digital voice system, except mdlPbxFraEnhEcho which is relevant also for analog cards.')
mdlPbxFramerCnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 2, 1, 1, 1, 1), ).setIndexNames((0, "DACS-MIB", "mdlPbxFraCnfgIdx"), (0, "DACS-MIB", "mdlPbxFraSltIdx"))
if mibBuilder.loadTexts: mdlPbxFramerCnfgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mdlPbxFramerCnfgEntry.setDescription('')
mdlPbxFraCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 2, 1, 1, 1, 1, 1), Integer32().clone(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlPbxFraCnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: mdlPbxFraCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg. ')
mdlPbxFraSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 2, 1, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlPbxFraSltIdx.setStatus('mandatory')
if mibBuilder.loadTexts: mdlPbxFraSltIdx.setDescription('The slot relevant to this module.')
mdlPbxFraEnhEcho = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 2, 1, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("disabled", 2), ("ms16", 3), ("ms32", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mdlPbxFraEnhEcho.setStatus('mandatory')
if mibBuilder.loadTexts: mdlPbxFraEnhEcho.setDescription('Refers to external ports of an analogue module and to the internal ports of the other mvc4 types of modules. ms16(3) means that the four voice ports have enhanced echo of 16ms. ms32(4) means that the two first ports have enhanced echo of 32 ms while the last two ports have no enhanced echo.')
mdlPbxFraTSGroupAss = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 2, 1, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 255))).clone(namedValues=NamedValues(("group1", 1), ("group2", 2), ("group3", 3), ("group4", 4), ("group5", 5), ("group6", 6), ("group7", 7), ("group8", 8), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mdlPbxFraTSGroupAss.setStatus('mandatory')
if mibBuilder.loadTexts: mdlPbxFraTSGroupAss.setDescription('In case of T1 modules: group1=(1,2,3,4), ...., group6=(21,22,23,24) while in case of E1 modules: - If prtExPh1MlLineType=g732sE1 or g732sE1CRC: group1=(1,2,3,4),..,group4=(13,14,15,17), group5=(18,19,20,21),...,group7=(26,27,28,29) group8=(30,31). - If prtExPh1MlLineType=g732nE1 or g732nE1CRC: group1=(1,2,3,4),..,group4=(13,14,15,16), group5=(17,18,19,20),...,group7=(25,26,27,28) group8=(29,30,31).')
mdlPbxFraSignalMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 2, 1, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("notApplicable", 1), ("tieTrunk", 2), ("tieInvert", 3), ("casTrans", 4), ("userDefined", 5), ("ccsTrans", 6))).clone('casTrans')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mdlPbxFraSignalMode.setStatus('mandatory')
if mibBuilder.loadTexts: mdlPbxFraSignalMode.setDescription('Refers to the signaling mode of the Framer module. tieTrunk(2), tieInvert(3), casTrans(4) are standard coding of the signaling protocol. casTrans(4) is Channel Associated Signaling (the signaling is within the channels time slot). ccsTrans(6) is Common Channel Signaling (the signaling is not within the channels time slot). userDefined(5) allows the user to define the signaling protocol he wants. In this case, the next two MIB fields are relevant.')
mdlPbxFraSignalVector = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 2, 1, 1, 1, 1, 6), OctetString().clone(hexValue="0000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mdlPbxFraSignalVector.setStatus('mandatory')
if mibBuilder.loadTexts: mdlPbxFraSignalVector.setDescription('In the case of mdlPbxFraSignalMode = userDefined(5), this field defines the A,B,C Bits. D bit is supplied for future versions. Bit 1 = Bit A ON Hook - Local Bit 2 = Bit B ON Hook - Local Bit 3 = Bit C ON Hook - Local Bit 4 = Bit D ON Hook - Local Bit 5 = Bit A OFF Hook - Local Bit 6 = Bit B OFF Hook - Local Bit 7 = Bit C OFF Hook - Local Bit 8 = Bit D OFF Hook - Local Bit 9 = Bit A ON Hook - Remote Bit 10 = Bit B ON Hook - Remote Bit 11 = Bit C ON Hook - Remote Bit 12 = Bit D ON Hook - Remote Bit 13 = Bit A OFF Hook - Remote Bit 14 = Bit B OFF Hook - Remote Bit 15 = Bit C OFF Hook - Remote Bit 16 = Bit D OFF Hook - Remote In conjunction with the Mask, mdlPbxFraSignalMask, it is possible to compute the signal mode.')
mdlPbxFraSignalMask = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 2, 1, 1, 1, 1, 7), OctetString().clone(hexValue="ffff")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mdlPbxFraSignalMask.setStatus('mandatory')
if mibBuilder.loadTexts: mdlPbxFraSignalMask.setDescription("In the case of mdlPbxFraSignalMode = userDefined(5), this field defines the 'don't care' A,B,C Bits. D bit is supplied for future versions. Bit 1 = Bit A ON Hook - Local Bit 2 = Bit B ON Hook - Local Bit 3 = Bit C ON Hook - Local Bit 4 = Bit D ON Hook - Local Bit 5 = Bit A OFF Hook - Local Bit 6 = Bit B OFF Hook - Local Bit 7 = Bit C OFF Hook - Local Bit 8 = Bit D OFF Hook - Local Bit 9 = Bit A ON Hook - Remote Bit 10 = Bit B ON Hook - Remote Bit 11 = Bit C ON Hook - Remote Bit 12 = Bit D ON Hook - Remote Bit 13 = Bit A OFF Hook - Remote Bit 14 = Bit B OFF Hook - Remote Bit 15 = Bit C OFF Hook - Remote Bit 16 = Bit D OFF Hook - Remote.")
mdlPbxFraFramerSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 2, 1, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mdlPbxFraFramerSlot.setStatus('mandatory')
if mibBuilder.loadTexts: mdlPbxFraFramerSlot.setDescription('Slot where is sitting the Framer.')
mdlPbxFraSignaling = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 2, 1, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("endToEnd", 2), ("localTermination", 3))).clone('endToEnd')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mdlPbxFraSignaling.setStatus('mandatory')
if mibBuilder.loadTexts: mdlPbxFraSignaling.setDescription('Signaling - describes the way the signaling ABCD bits pass from the local extension to the remote extension and vice-versa. endToEnd = the signaling ABCD bits pass without change from local to remote extension. localTermination = the signaling ABCD bits received from the local extension are translated to different ON Hook/OFF Hook bit values and then passed to remote extension. This is relevant when the Local and Remote ON Hook/OFF Hook values are different.')
prtExClCnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 1, 1), )
if mibBuilder.loadTexts: prtExClCnfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtExClCnfgTable.setDescription('')
prtExClCnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 1, 1, 1), ).setIndexNames((0, "DACS-MIB", "prtExClCnfgIdx"), (0, "DACS-MIB", "prtExClSltIdx"), (0, "DACS-MIB", "prtExClPrtIdx"))
if mibBuilder.loadTexts: prtExClCnfgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtExClCnfgEntry.setDescription('All the entries at this table are identical (have the same value) for all the configurations (1..100) except the TmpCnfg. The write operation into the Table Objects is valid only to the TmpCnfg entry.')
prtExClCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExClCnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtExClCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg.')
prtExClSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 255))).clone(namedValues=NamedValues(("clA", 3), ("clB", 4), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExClSltIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtExClSltIdx.setDescription('This attribute indicates a unique slot position where the card is inserted. Because the second Cl is only for redundancy, all the parameters are identical in the two modules, i.e. change of any parameter in one module will change automatically the value of the other module.. In the ?004 Unit the entry clB(4) is not valid.')
prtExClPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("exPrt1", 1), ("exPrt2", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExClPrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtExClPrtIdx.setDescription('This attribute indicates a unique port number. ')
prtExClUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("unknown", 1), ("noUse", 2), ("nmsSlip", 3), ("nmsPpp", 4), ("muxSlip", 5), ("muxPpp", 6), ("terminal", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExClUsage.setStatus('mandatory')
if mibBuilder.loadTexts: prtExClUsage.setDescription('This attribute indicates what is the usage of the port.')
prtExClRate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("r300Bps", 1), ("r1200Bps", 2), ("r2400Bps", 3), ("r4800Bps", 4), ("r9600Bps", 5), ("r19200Bps", 6), ("r38400Bps", 7), ("r57600Bps", 8), ("r115200Bps", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExClRate.setStatus('mandatory')
if mibBuilder.loadTexts: prtExClRate.setDescription('This attribute indicates the operation rate of the port.')
prtExClDataBits = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dataBits7Bits", 1), ("dataBits8Bits", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExClDataBits.setStatus('mandatory')
if mibBuilder.loadTexts: prtExClDataBits.setDescription('This attribute indicates the number of data bits in async frame')
prtExClParity = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("odd", 1), ("even", 2), ("none", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExClParity.setStatus('mandatory')
if mibBuilder.loadTexts: prtExClParity.setDescription('This attribute indicates if the parity operation mode in async frame')
prtExClStopBits = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("stopBits1Bit", 1), ("stopBits1dot5Bits", 2), ("stopBits2Bits", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExClStopBits.setStatus('mandatory')
if mibBuilder.loadTexts: prtExClStopBits.setDescription('This attribute indicates the minimum number of stop bits in the tx async frame')
prtExClRoutingProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("none", 1), ("rip2", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExClRoutingProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: prtExClRoutingProtocol.setDescription("This attribute indicates the routing protocol of the port. When prtExClUsage is nmsSlip or nmsPpp - all values are applicable . Else - only 'none' is applicable.")
prtExPh1MlCnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 1), )
if mibBuilder.loadTexts: prtExPh1MlCnfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPh1MlCnfgTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry.')
prtExPh1MlCnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 1, 1), ).setIndexNames((0, "DACS-MIB", "prtExPh1MlCnfgIdx"), (0, "DACS-MIB", "prtExPh1MlSltIdx"), (0, "DACS-MIB", "prtExPh1MlPrtIdx"))
if mibBuilder.loadTexts: prtExPh1MlCnfgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPh1MlCnfgEntry.setDescription('')
prtExPh1MlCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExPh1MlCnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPh1MlCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg. ')
prtExPh1MlSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExPh1MlSltIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPh1MlSltIdx.setDescription('This attribute indicates a unique slot position where the module is inserted. In the ?004 Unit the entries io6(10)..io16) are not valid.')
prtExPh1MlPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 101))).clone(namedValues=NamedValues(("exPrt1", 1), ("exPrt2", 2), ("exPrt3", 3), ("exPrt4", 4), ("inPrt1", 101)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExPh1MlPrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPh1MlPrtIdx.setDescription('This attribute indicates a unique port number. MTML-1/E1 and MTML-1/T1 cards have only one external interface. inPrt1 - for MTML-H/E1 cards. exPrt2..exPrt4 - for MTML-4 cards and others.')
prtExPh1MlConnect = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPh1MlConnect.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPh1MlConnect.setDescription('This attribute indicates whether the port should be considered in any of the mux algorithms. It also affects all the card considerations because it may indicate that the module has only one physical interface.')
prtExPh1MlLineType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("esfT1", 2), ("sfT1", 3), ("g732nE1", 4), ("g732nE1CRC", 5), ("g732sE1", 6), ("g732sE1CRC", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPh1MlLineType.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPh1MlLineType.setDescription('This attribute is the line type parameter for T1/E1 interface. The user should select only the parameters which are relevant to the specific card: T1 line code parameters for the MPH.1/T1 E1 line code parameters for the MPH.1/E1. This parameter has the same values as dsx1LineType in T1/E1 MIB (RFC-1406). The parameters in dsx1LineType are: other (1) esfT1 dsx1ESF (2) sfT1 dsx1D4 (3) g732nE1 dsx1E1 (4) g732nE1CRC dsx1E1-CRC (5) g732sE1 dsx1E1-MF (6) g732sE1CRC dsx1E1-MF-CRC (7)')
prtExPh1MlLineCode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 255))).clone(namedValues=NamedValues(("b7T1", 1), ("b8zsT1", 2), ("transT1", 3), ("hdb3E1", 4), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPh1MlLineCode.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPh1MlLineCode.setDescription('This attribute is the line code parameter used for T1/E1 interface. The user should select only the parameters which are relevant to the specific card: T1 line code parameters for MPH.1/T1 E1 line code parameters for MPH.1/E1. This parameter has the same values as dsx1LineCoding in T1/E1 MIB (RFC-1406). The parameters in dsx1LineCoding are: dsx1JBZS (1) dsx1B8ZS (2) dsx1HDB3 (3) dsx1ZBTSI (4) dsx1AMI (5) other (6)')
prtExPh1MlLineLen = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 255))).clone(namedValues=NamedValues(("unknown", 1), ("len0p133ft", 2), ("len134p266ft", 3), ("len267p399ft", 4), ("len400p533ft", 5), ("len534p655ft", 6), ("lenFcc68", 7), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPh1MlLineLen.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPh1MlLineLen.setDescription('This attribute is the line length parameter used only for T1/DSU interfaces. lenXXXpXXXft = len-XXX-XXXft.')
prtExPh1MlRestoreTime = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("restoreT1secFast", 2), ("restoreT10sec62411", 3), ("ccittE1", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPh1MlRestoreTime.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPh1MlRestoreTime.setDescription('The time passing from the disappearance of the loss of synchronization condition (red alarm) to the restoration of normal service. The options 1secFast(2) and 10sec62411(3) for E1 interfaces are proprietary implementation of the T1 standard to the E1 interface.')
prtExPh1MlTxGain = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notApplicable", 1), ("txGain0db", 2), ("txGain7dot5db", 3), ("txGain15db", 4), ("txGain22dot5db", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPh1MlTxGain.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPh1MlTxGain.setDescription('This attribute is the tx gain parameter used only for T1/CSU interfaces.')
prtExPh1MlRxSensitivity = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notApplicable", 1), ("low26dBm", 2), ("high36dBm", 3), ("shortHaul", 4), ("longHaul", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPh1MlRxSensitivity.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPh1MlRxSensitivity.setDescription('This attribute is the rx line sensitivity parameter. low26dBm, high36dBm - applicable for T1-CSU shortHaul, longHaul - applicable for MTML-4 cards.')
prtExPh1MlIdleCode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 1, 1, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPh1MlIdleCode.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPh1MlIdleCode.setDescription('Determines the code for transmission in empty time slots. Type value(00-FFH), Excluding 0H,8H,10H,12H,21H,24H,42H,49H, 84H,92H')
prtExPh1MlTdmTrunk = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 255))).clone(namedValues=NamedValues(("linkA", 1), ("linkB", 2), ("none", 3), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPh1MlTdmTrunk.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPh1MlTdmTrunk.setDescription('This attribute indicates whether the port is used to transfer TDM cards data and through which Bus.')
prtExPh1MlClkMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("internalLocal", 1), ("loopBackLocal", 2), ("nodalTiming", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPh1MlClkMode.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPh1MlClkMode.setDescription('Defines the clock operation mode of the T1/E1 interface. Ports that are connected to the TDM Buses must be in nodalTiming(3) clock mode. ')
prtExPh1MlMfClkSrcSlt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("notApplicable", 1), ("local", 2), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPh1MlMfClkSrcSlt.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPh1MlMfClkSrcSlt.setDescription("This attribute indicates whether the port Tx multiframe is synchronized with Rx multiframe of another port and the slot position of that port. This operation is required in order to bypass signaling of PCM voice channels. Its value is always local(2) when the port isn't connected to any TDM bus. When it's value is local(2) there is no meaning to 'prtExPh1MlMfClkSrcPrt' parameter. In the ?004 Unit the entries io6(10)..io16) are not valid")
prtExPh1MlMfClkSrcPrt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 101, 255))).clone(namedValues=NamedValues(("exPrt1", 1), ("exPrt2", 2), ("inPrt1", 101), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPh1MlMfClkSrcPrt.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPh1MlMfClkSrcPrt.setDescription('A unique number to identify a port position in the mux. It has no effect when the prtExPh1MlMfClkSrcSlt selected is Local. inPrt1 - for MTML-H/E1 cards.')
prtExPh1MlFdlType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("response", 2), ("command", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPh1MlFdlType.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPh1MlFdlType.setDescription("A unique number to identify the side of the FDL operation. Normal: 'response' for the user side and 'command' for the PTT side. Applicable only when working with ESF-T1 link")
prtExPh1MlInbandMng = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 255))).clone(namedValues=NamedValues(("off", 2), ("fdlOrTs0", 3), ("dedicatedTs", 4), ("dedicatedPpp", 5), ("dedicatedFr", 6), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPh1MlInbandMng.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPh1MlInbandMng.setDescription('A unique number to identify an Inband management over the link.')
prtExPh1MlInbandMngRate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("notApplicable", 1), ("r4k", 2), ("r8k", 3), ("r12k", 4), ("r16k", 5), ("r32k", 6), ("r64k", 7), ("r20k", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPh1MlInbandMngRate.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPh1MlInbandMngRate.setDescription('A unique number to identify the rate of the Inband management. E1 port - it is not applicable when prtExPh1MlInbandMng selected is off. T1 port - it is not applicable when prtExPh1MlInbandMng selected is off OR fdlOrTs0.')
prtExPh1MlRedundType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("dualCableAIS", 2), ("yCable", 3), ("dualCableParallelTx", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPh1MlRedundType.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPh1MlRedundType.setDescription("This object determines the ML redundancy type: none - no ML redundacy dualCableAIS - each ML card is connected by a separate dualCableParallelTx cable to the other MUX (two cables connect two MUXes). There are two types of dual redundancy. yCable - Y cable is connected to both ML cards (one cable connects two MUXes). Default=none When only one ML card exists, the type can be only 'none'. The value should be the same for both ML slots.")
prtExPh1MlRedundSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("notApplicable", 1), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPh1MlRedundSlot.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPh1MlRedundSlot.setDescription("This object indicates the slot containing the redundacy ML card, coupled with the current ML (prtExPh1MlSltIdx). When prtExPh1MlRedundType=none (no ML redundancy) this object will be 'notApplicable'. In the ?004 Unit the entries io6(10)..io12(16) are not valid When value is not 'none', it should be mutual to the redundant ML slot.")
prtExPh1MlRedundPort = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 101, 255))).clone(namedValues=NamedValues(("exPrt1", 1), ("exPrt2", 2), ("exPrt3", 3), ("exPrt4", 4), ("inPrt1", 101), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPh1MlRedundPort.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPh1MlRedundPort.setDescription("This object indicates the redundacy ML port, coupled with the current ML port (prtExPh1MlPrtIdx). When prtExPh1MlRedundType=none (no ML redundancy) this object will be 'notApplicable'. When value is not 'none', it should be mutual to the redundant ML port. inPrt1 - for MTML-H/E1 cards. exPrt2..exPrt4 - for MTML-4 cards.")
prtExPh1MlRedundRecTime = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 1, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPh1MlRedundRecTime.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPh1MlRedundRecTime.setDescription('Redundancy Recovery Time (sec). After switching the ML card to the current (prtExPh1MlSltIdx), the next ML switch can be performed only after a minimum time, indicated by this object.')
prtExPh1MlInbandMngRoutProt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 1, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("rip2", 2), ("proprietary", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPh1MlInbandMngRoutProt.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPh1MlInbandMngRoutProt.setDescription('This attribute indicates the Inband Mng routing protocol of the port.')
prtExPh1MlIfType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 1, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("csu", 2), ("dsu", 3), ("ltu", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPh1MlIfType.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPh1MlIfType.setDescription('Interface type of the port. For T1 - csu, dsu are the valid values For E1 - dsu, ltu are the valid values.')
prtExPh1MlTsTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 2), )
if mibBuilder.loadTexts: prtExPh1MlTsTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPh1MlTsTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry.')
prtExPh1MlTsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 2, 1), ).setIndexNames((0, "DACS-MIB", "prtExPh1MlTsCnfgIdx"), (0, "DACS-MIB", "prtExPh1MlTsSltIdx"), (0, "DACS-MIB", "prtExPh1MlTsPrtIdx"), (0, "DACS-MIB", "prtExPh1MlTsIdx"))
if mibBuilder.loadTexts: prtExPh1MlTsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPh1MlTsEntry.setDescription('')
prtExPh1MlTsCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExPh1MlTsCnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPh1MlTsCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg. ')
prtExPh1MlTsSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExPh1MlTsSltIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPh1MlTsSltIdx.setDescription('This attribute indicates a unique slot position where the card is inserted. In the ?004 Unit the entries io6(10)..io16) are not valid')
prtExPh1MlTsPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 101))).clone(namedValues=NamedValues(("exPrt1", 1), ("exPrt2", 2), ("exPrt3", 3), ("exPrt4", 4), ("inPrt1", 101)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExPh1MlTsPrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPh1MlTsPrtIdx.setDescription('This attribute indicates a unique port number. MPH.1/E1 and MPH.1/T1 cards have only one external interface. exPrt2 - for ME1-2, MT1-2 and mhsPri cards. exPrt3, exPrt4 - for mhsPri cards. inPrt1 - for MTML-H/E1 cards.')
prtExPh1MlTsIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExPh1MlTsIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPh1MlTsIdx.setDescription('This attribute indicates a unique time slot position. The valid time slots are 1..24 for T1 Card and 1..31 for E1 interface. In G732S-E1 lines time slot 16 is not valid for data, it is dedicated for multiframe synchronization bits and voice signaling.')
prtExPh1MlTsIConSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("noConnect", 2), ("split", 4), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPh1MlTsIConSlot.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPh1MlTsIConSlot.setDescription('This attribute indicates whether the specified time slot is connected/routed internally in the Agent and to which card it is connected. In the ?004 Unit the entries io6(10)..io16) are not valid. split - will be used when the Src TS is connected to more than one slot OR more than one port (each needing less than a whole TS).')
prtExPh1MlTsIConPrt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 2, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPh1MlTsIConPrt.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPh1MlTsIConPrt.setDescription('This attribute indicates the internally (In Mux) connected/routed port. For MP, the values will be: { exPrt1 (1) , exPrt2 (2) , exPrt3 (3) , exPrt4 (4) , exPrt5 (5) , exPrt6 (6) , exPrt7 (7) , exPrt8 (8) , exPrt9 (9) , exPrt10 (10) , exPrt11 (11) , exPrt12 (12) , noConnect (100), inPrt1 (101) , inPrt2 (102) , inPrt3 (103) , inPrt4 (104) , inPrt5 (105) , inPrt6 (106) , inPrt7 (107) , inPrt8 (108) , inPrt9 (109) , inPrt10 (110) , inPrt11 (111) , inPrt12 (112) } ')
prtExPh1MlTsIConTs = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 2, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPh1MlTsIConTs.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPh1MlTsIConTs.setDescription('This attribute indicates a unique time slot position. The valid time slots are 1..24 for T1 Card and 1..31 for E1 interface. In G732S-E1 lines time slot 16 is not valid for data, it is dedicated to multiframe synchronization and voice signaling.')
prtExPh1MlTsExt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 2, 1, 8), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExPh1MlTsExt.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPh1MlTsExt.setDescription("A pointer to an extension of this table: prtExTsSplitTable. - If prtExPh1MlTsIConSlot='split', its value should be set to the OBJECT IDENTIFIER of the prtExTsSplitTable, with its relevant CnfgIdx, SltIdx, PrtIdx, TsIdx and 1st TsBit. - If prtExPh1MlTsIConSlot is not 'split', its value should be set to the OBJECT IDENTIFIER { 0 0 }. ")
prtInPh1MlCnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 3), )
if mibBuilder.loadTexts: prtInPh1MlCnfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtInPh1MlCnfgTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry.')
prtInPh1MlCnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 3, 1), ).setIndexNames((0, "DACS-MIB", "prtInPh1MlCnfgIdx"), (0, "DACS-MIB", "prtInPh1MlSltType"), (0, "DACS-MIB", "prtInPh1MlPrtIdx"))
if mibBuilder.loadTexts: prtInPh1MlCnfgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtInPh1MlCnfgEntry.setDescription('')
prtInPh1MlCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtInPh1MlCnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtInPh1MlCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg. ')
prtInPh1MlSltType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtInPh1MlSltType.setStatus('mandatory')
if mibBuilder.loadTexts: prtInPh1MlSltType.setDescription('This attribute indicates a unique slot position where the card is inserted. For ISDN BRI port of MX300/30: io1(5) = isdn1(5) and io2(6) = isdn2(6) In the ?004 Unit the entries io6(10)..io12(16) are not valid')
prtInPh1MlPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtInPh1MlPrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtInPh1MlPrtIdx.setDescription('This attribute indicates a unique port number. MPH.1/E1 and MPH.1/T1 cards have three internal interfaces. MX3000 modules may have up to 50 internal ports.')
prtInPh1MlConnect = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInPh1MlConnect.setStatus('mandatory')
if mibBuilder.loadTexts: prtInPh1MlConnect.setDescription('This attribute indicates whether the port should be considered in any of the mux algorithms.')
prtInPh1MlRate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 100))).clone(namedValues=NamedValues(("r1x56eq56Kbps", 1), ("r1x64eq64Kbps", 2), ("r2x56eq112Kbps", 3), ("r2x64eq128Kbps", 4), ("r3x56eq168Kbps", 5), ("r3x64eq192Kbps", 6), ("r4x56eq224Kbps", 7), ("r4x64eq256Kbps", 8), ("r5x56eq280Kbps", 9), ("r5x64eq320Kbps", 10), ("r6x56eq336Kbps", 11), ("r6x64eq384Kbps", 12), ("r7x56eq392Kbps", 13), ("r7x64eq448Kbps", 14), ("r8x56eq448Kbps", 15), ("r8x64eq512Kbps", 16), ("r9x56eq504Kbps", 17), ("r9x64eq576Kbps", 18), ("r10x56eq560Kbps", 19), ("r10x64eq640Kbps", 20), ("r11x56eq616Kbps", 21), ("r11x64eq704Kbps", 22), ("r12x56eq672Kbps", 23), ("r12x64eq768Kbps", 24), ("r13x56eq728Kbps", 25), ("r13x64eq832Kbps", 26), ("r14x56eq784Kbps", 27), ("r14x64eq896Kbps", 28), ("r15x56eq840Kbps", 29), ("r15x64eq960Kbps", 30), ("r16x56eq896Kbps", 31), ("r16x64eq1024Kbps", 32), ("r17x56eq952Kbps", 33), ("r17x64eq1088Kbps", 34), ("r18x56eq1008Kbps", 35), ("r18x64eq1152Kbps", 36), ("r19x56eq1064Kbps", 37), ("r19x64eq1216Kbps", 38), ("r20x56eq1120Kbps", 39), ("r20x64eq1280Kbps", 40), ("r21x56eq1176Kbps", 41), ("r21x64eq1344Kbps", 42), ("r22x56eq1232Kbps", 43), ("r22x64eq1408Kbps", 44), ("r23x56eq1288Kbps", 45), ("r23x64eq1472Kbps", 46), ("r24x56eq1344Kbps", 47), ("r24x64eq1536Kbps", 48), ("r25x56eq1400Kbps", 49), ("r25x64eq1600Kbps", 50), ("r26x56eq1456Kbps", 51), ("r26x64eq1664Kbps", 52), ("r27x56eq1512Kbps", 53), ("r27x64eq1728Kbps", 54), ("r28x56eq1568Kbps", 55), ("r28x64eq1792Kbps", 56), ("r29x56eq1624Kbps", 57), ("r29x64eq1856Kbps", 58), ("r30x56eq1680Kbps", 59), ("r30x64eq1920Kbps", 60), ("r31x56eq1736Kbps", 61), ("r31x64eq1984Kbps", 62), ("noRate", 100)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInPh1MlRate.setStatus('mandatory')
if mibBuilder.loadTexts: prtInPh1MlRate.setDescription('This attribute indicates the port speed. ')
prtInPh1MlProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("fr", 1), ("frPlus", 2), ("pCellRelay", 3), ("hdlcSdlc", 4), ("transparentHdlc", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInPh1MlProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: prtInPh1MlProtocol.setDescription('This attribute indicates the applied protocol.')
prtInPh1MlConnectionTyp = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 255))).clone(namedValues=NamedValues(("sameNetManaged", 1), ("sameNetNotMana", 2), ("user", 3), ("otherNet", 4), ("pubNet", 5), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInPh1MlConnectionTyp.setStatus('mandatory')
if mibBuilder.loadTexts: prtInPh1MlConnectionTyp.setDescription('This attribute indicates the link connection type. It is required for three reasons: FR/CR Inband management operation (LMI,CLMM...). CIR check. NMS network management. SameNetManaged - indicates network internal line. SameNetNotMana - indicates network internal line, but the remote mux is not managed by the nms. User - User to Network Interface. OtherNet - Network To Network Interfce. PubNet - Access Mux To PubNet Interface.')
prtInPh1MlCongResponse = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("flowControl", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInPh1MlCongResponse.setStatus('mandatory')
if mibBuilder.loadTexts: prtInPh1MlCongResponse.setDescription('This attribute indicates how to handle the congestion indication to/from the mux internal connection side (for example transmit/receive becn to/from the network). no - do nothing FlowControl - translate the congestion indication between the port and the internal connection port according to the definition of the prtInPh1MlFlowControl parameters. The operation is done in both directions.')
prtInPh1MlCongLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 3, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInPh1MlCongLevel.setStatus('mandatory')
if mibBuilder.loadTexts: prtInPh1MlCongLevel.setDescription('This attribute indicates the level of delayed data in precents of the total available dynamic memory, for which the port will start to operate . The resolution of the parameter is 5 percent. Valid values: 10..70, 255. 255=notApplicable.')
prtInPh1MlTc = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 3, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 255))).clone(namedValues=NamedValues(("tc1sec", 1), ("tc2sec", 2), ("tc3sec", 3), ("tc4sec", 4), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInPh1MlTc.setStatus('mandatory')
if mibBuilder.loadTexts: prtInPh1MlTc.setDescription('This attribute indicates the Tc parameter which is the time period of the sliding window in which the Bc/Be are tested. The value of this parameter is identical for all the ports in the specific card. 255=notApplicable.')
prtInPh1MlFlowControl = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 3, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("none", 2), ("fecnBecn", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInPh1MlFlowControl.setStatus('mandatory')
if mibBuilder.loadTexts: prtInPh1MlFlowControl.setDescription('This attribute indicates the required flow control betweeen the port and the remote equipment.')
prtInPh1MlSegment = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 3, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("notApplicable", 1), ("s36Byte", 2), ("s150Byte", 3), ("s264Byte", 4), ("s378Byte", 5), ("s492Byte", 6), ("s236Byte", 7), ("s472Byte", 8), ("s708Byte", 9), ("s944Byte", 10), ("s1180Byte", 11)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInPh1MlSegment.setStatus('mandatory')
if mibBuilder.loadTexts: prtInPh1MlSegment.setDescription('This object is the Segmentation in Bytes. In protocol FR+, ISDN internals, MX 30/300 the segmentation is: 50 (2) ,158 (3) ,266 (4) ,376 (5), 484 (6) In MX 3000/4: For protocol FR+ (internal ISDN ports of MHS.S, MHS.U, MHS.E1, MHS.T1 cards) segmentation values are: 236 (7),472 (8), 708 (9), 944 (10) ,1180 (11)')
prtInPh1MlFrMngProt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 3, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notApplicable", 1), ("none", 2), ("lmi", 3), ("ansiT1", 4), ("annexA", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInPh1MlFrMngProt.setStatus('mandatory')
if mibBuilder.loadTexts: prtInPh1MlFrMngProt.setDescription('This object indicates the Frame-Relay management protocol. ansiT1 = ANSI T1.617 Annex D (this is the default value). This parameter is applicable only for FR and FR+ protocols. When prtInPh1MlConnectionTyp = sameNetManaged, this object will be RO (internally determined). ')
prtInPh1MlEnqPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 3, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInPh1MlEnqPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: prtInPh1MlEnqPeriod.setDescription('This object is the Status Enquiry Period, in seconds. It determines the frequency of the Status Enquiry message as sent by the FR user side. At the FR network side, it determines the timeout for this message reception. Default = 4 seconds. This parameter is applicable only for FR and FR+ protocols AND only when prtInPh1MlFrMngProt is NOT (notApplicable or none). 0=notApplicable.')
prtInPh1MlFullRptPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 3, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInPh1MlFullRptPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: prtInPh1MlFullRptPeriod.setDescription('This object is the Full Report Frequency. It determines the number of the Status Enquiry messages sent by the FR user side, before a Full Report Request is sent. The units are : Status Enquiry messages (periods). Valid values: 1 .. 255. 255 = infinite (never sent). This parameter is applicable only for FR and FR+ protocols AND only when prtInPh1MlFrMngProt is NOT (notApplicable or none). 0=notApplicable.')
prtInPh1MlFrWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 3, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInPh1MlFrWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: prtInPh1MlFrWindowSize.setDescription('This object is the FR Window Size. It determines the number of samplings in the sliding window that counts the errors. This parameter is applicable only for FR and FR+ protocols AND only when prtInPh1MlFrMngProt is NOT (notApplicable or none). 0=notApplicable.')
prtInPh1MlErrorsThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 3, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInPh1MlErrorsThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: prtInPh1MlErrorsThreshold.setDescription('This object is the Max Errors. It determines the number of Status Enquiry Errors that occured within the FR sliding window, before this port is considered DOWN (threshold). This parameter is applicable only for FR and FR+ protocols AND only when prtInPh1MlFrMngProt is NOT (notApplicable or none). 0=notApplicable. ')
prtInPh1MlMaxIdleTime = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 3, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1800)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInPh1MlMaxIdleTime.setStatus('mandatory')
if mibBuilder.loadTexts: prtInPh1MlMaxIdleTime.setDescription('Move to higher prioritized connected link after this period of seconds of silence on the current link. 0=Never. Never move to higher prioritized connected link. UNIT is seconds. Valid values are: 0, 1, 2, 3, 4, 5, 10, 20, 30, 40, 50, 60, 120, 180, 240, 300, 360, 420, 480, 540, 600, 900, 1200, 1500, 1800. Attempt to Set an invalid value will result in getting the default value.')
prtInPh1MlBearerCh = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 3, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 4, 5, 255))).clone(namedValues=NamedValues(("notApplicable", 1), ("channelB1", 3), ("channelB2", 4), ("chB1andchB2", 5), ("none", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInPh1MlBearerCh.setStatus('mandatory')
if mibBuilder.loadTexts: prtInPh1MlBearerCh.setDescription('Defines which B (bearer) channels are used for transferring ISDN data. Default value is: none (255). anyChannel (2) is skipped because it is not in use here.')
prtInPh1MlAssociatedExCh = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 3, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 255))).clone(namedValues=NamedValues(("exPrt1", 1), ("exPrt2", 2), ("exPrt3", 3), ("exPrt4", 4), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInPh1MlAssociatedExCh.setStatus('mandatory')
if mibBuilder.loadTexts: prtInPh1MlAssociatedExCh.setDescription('This object indicates the external port associated to this internal port. At present, it is used by the Hybrid (mp2100h), MHS-4 cards which can have up to 64 dynamic internal ports associated with External ports. For ISDN cards, the value will be: notApplicable (255). The associated external of an ISDN internal port is represented by the MIB object: prtIsdnDirectoryPrtNu.')
prtInPh1MlClockEncoding = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 3, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("notApplicable", 1), ("nrz", 2), ("nrzI", 3), ("fm0", 4), ("manchester", 5), ("diffManchester", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInPh1MlClockEncoding.setStatus('mandatory')
if mibBuilder.loadTexts: prtInPh1MlClockEncoding.setDescription('This object is the Encoding type of the Line. This parameter is applicable only for FR and FR+ protocols.')
prtInPh1MlMinSeparators = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 3, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInPh1MlMinSeparators.setStatus('mandatory')
if mibBuilder.loadTexts: prtInPh1MlMinSeparators.setDescription('Minimum number of bytes separating between two adjacent frames (HDLC item). 0 = notApplicable')
prtInPh1MlCcittCrc = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 3, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("crc16", 2), ("crc32", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInPh1MlCcittCrc.setStatus('mandatory')
if mibBuilder.loadTexts: prtInPh1MlCcittCrc.setDescription('This object indicates how many Bits are used for CRC (HDLC item).')
prtInPh1MlFrameSeparator = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 3, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("idles", 2), ("flags", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInPh1MlFrameSeparator.setStatus('mandatory')
if mibBuilder.loadTexts: prtInPh1MlFrameSeparator.setDescription('This object indicates what should be transferred on the line when there are no frames to pass (HDLC item). idles: mean that FF will pass on the line flags: mean that 7E will pass on the line.')
prtInPh1MlDlciTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 4), )
if mibBuilder.loadTexts: prtInPh1MlDlciTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtInPh1MlDlciTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry.')
prtInPh1MlDlciEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 4, 1), ).setIndexNames((0, "DACS-MIB", "prtInPh1MlDlciCnfgIdx"), (0, "DACS-MIB", "prtInPh1MlDlciSltIdx"), (0, "DACS-MIB", "prtInPh1MlDlciPrtIdx"), (0, "DACS-MIB", "prtInPh1MlDlciIdx"))
if mibBuilder.loadTexts: prtInPh1MlDlciEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtInPh1MlDlciEntry.setDescription('')
prtInPh1MlDlciCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtInPh1MlDlciCnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtInPh1MlDlciCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg. ')
prtInPh1MlDlciSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtInPh1MlDlciSltIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtInPh1MlDlciSltIdx.setDescription('This attribute indicates a unique slot position where the card is inserted. In the ?004 Unit the entries io6(10)..io16) are not valid')
prtInPh1MlDlciPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(101, 102, 103))).clone(namedValues=NamedValues(("inPrt1", 101), ("inPrt2", 102), ("inPrt3", 103)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtInPh1MlDlciPrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtInPh1MlDlciPrtIdx.setDescription('This attribute indicates a unique internal port number. MPH.1/E1 and MPH.1/T1 cards have three internal ports.')
prtInPh1MlDlciIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 991))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtInPh1MlDlciIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtInPh1MlDlciIdx.setDescription("This attribute indicates a unique index for each possible used dlci(16..991). When the protocol is not Multiplexing protocol, then its type is 'user' and the only valid index is 1.")
prtInPh1MlDlciValid = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInPh1MlDlciValid.setStatus('mandatory')
if mibBuilder.loadTexts: prtInPh1MlDlciValid.setDescription('This attribute indicates whether the attributes in this entry are valid or not. The user can add/delete pvc (dlci to dlci connection) by modifing this object')
prtInPh1MlDlciIConSlt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("noConnect", 2), ("cl", 3), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInPh1MlDlciIConSlt.setStatus('mandatory')
if mibBuilder.loadTexts: prtInPh1MlDlciIConSlt.setDescription('This attribute indicates a unique slot position In the Mux (Agent) where the dlci is routed to. In the ?004 Unit the entries io6(10)..io16) are not valid')
prtInPh1MlDlciIConPrt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 4, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112))).clone(namedValues=NamedValues(("exPrt1", 1), ("exPrt2", 2), ("exPrt3", 3), ("exPrt4", 4), ("exPrt5", 5), ("exPrt6", 6), ("exPrt7", 7), ("exPrt8", 8), ("exPrt9", 9), ("exPrt10", 10), ("clNMS", 99), ("noConnect", 100), ("inPrt1", 101), ("inPrt2", 102), ("inPrt3", 103), ("inPrt4", 104), ("inPrt5", 105), ("inPrt6", 106), ("inPrt7", 107), ("inPrt8", 108), ("inPrt9", 109), ("inPrt10", 110), ("inPrt11", 111), ("inPrt12", 112)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInPh1MlDlciIConPrt.setStatus('mandatory')
if mibBuilder.loadTexts: prtInPh1MlDlciIConPrt.setDescription('This attribute indicates a unique port id which the dlci is routed to.')
prtInPh1MlDlciIConDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 4, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 991))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInPh1MlDlciIConDlci.setStatus('mandatory')
if mibBuilder.loadTexts: prtInPh1MlDlciIConDlci.setDescription('This attribute indicates a unique internal connection dlci number which the src dlci is routed to.')
prtInPh1MlDlciTxBc = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 4, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21))).clone(namedValues=NamedValues(("full", 1), ("zero", 2), ("txBc9600bps", 3), ("txBc14200bps", 4), ("txBc19200bps", 5), ("txBc28800bps", 6), ("txBc32000bps", 7), ("txBc38400bps", 8), ("txBc48000bps", 9), ("txBc56000bps", 10), ("txBc57600bps", 11), ("txBc64Kbps", 12), ("txBc128Kbps", 13), ("txBc192Kbps", 14), ("txBc256Kbps", 15), ("txBc320Kbps", 16), ("txBc384Kbps", 17), ("txBc448Kbps", 18), ("txBc512Kbps", 19), ("txBc768Kbps", 20), ("txBc1024Kbps", 21)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInPh1MlDlciTxBc.setStatus('mandatory')
if mibBuilder.loadTexts: prtInPh1MlDlciTxBc.setDescription('This attribute indicates a unique Tx committed bandwidth on the user transmit line or at the port receive line.')
prtInPh1MlDlciTxBe = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 4, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21))).clone(namedValues=NamedValues(("full", 1), ("zero", 2), ("txBe9600bps", 3), ("txBe14200bps", 4), ("txBe19200bps", 5), ("txBe28800bps", 6), ("txBe32000bps", 7), ("txBe38400bps", 8), ("txBe48000bps", 9), ("txBe56000bps", 10), ("txBe57600bps", 11), ("txBe64Kbps", 12), ("txBe128Kbps", 13), ("txBe192Kbps", 14), ("txBe256Kbps", 15), ("txBe320Kbps", 16), ("txBe384Kbps", 17), ("txBe448Kbps", 18), ("txBe512Kbps", 19), ("txBe768Kbps", 20), ("txBe1024Kbps", 21)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInPh1MlDlciTxBe.setStatus('mandatory')
if mibBuilder.loadTexts: prtInPh1MlDlciTxBe.setDescription('This attribute indicates a unique Tx excess bandwidth on the user transmit line or at the port receive line.')
prtInPh1MlDlciRxBc = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 4, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21))).clone(namedValues=NamedValues(("full", 1), ("zero", 2), ("rxBc9600bps", 3), ("rxBc14200bps", 4), ("rxBc19200bps", 5), ("rxBc28800bps", 6), ("rxBc32000bps", 7), ("rxBc38400bps", 8), ("rxBc48000bps", 9), ("rxBc56000bps", 10), ("rxBc57600bps", 11), ("rxBc64Kbps", 12), ("rxBc128Kbps", 13), ("rxBc192Kbps", 14), ("rxBc256Kbps", 15), ("rxBc320Kbps", 16), ("rxBc384Kbps", 17), ("rxBc448Kbps", 18), ("rxBc512Kbps", 19), ("rxBc768Kbps", 20), ("rxBc1024Kbps", 21)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInPh1MlDlciRxBc.setStatus('mandatory')
if mibBuilder.loadTexts: prtInPh1MlDlciRxBc.setDescription('This attribute indicates a unique Rx committed bandwidth on the user receive line or at the port transmit line.')
prtInPh1MlDlciRxBe = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 4, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21))).clone(namedValues=NamedValues(("full", 1), ("zero", 2), ("rxBe9600bps", 3), ("rxBe14200bps", 4), ("rxBe19200bps", 5), ("rxBe28800bps", 6), ("rxBe32000bps", 7), ("rxBe38400bps", 8), ("rxBe48000bps", 9), ("rxBe56000bps", 10), ("rxBe57600bps", 11), ("rxBe64Kbps", 12), ("rxBe128Kbps", 13), ("rxBe192Kbps", 14), ("rxBe256Kbps", 15), ("rxBe320Kbps", 16), ("rxBe384Kbps", 17), ("rxBe448Kbps", 18), ("rxBe512Kbps", 19), ("rxBe768Kbps", 20), ("rxBe1024Kbps", 21)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInPh1MlDlciRxBe.setStatus('mandatory')
if mibBuilder.loadTexts: prtInPh1MlDlciRxBe.setDescription('This attribute indicates a unique Rx excess bandwidth on the user receive line or at the port transmit line.')
prtInPh1MlDlciPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 4, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInPh1MlDlciPriority.setStatus('mandatory')
if mibBuilder.loadTexts: prtInPh1MlDlciPriority.setDescription('This attribute indicates a unique priority of the pcv. 1 is the lowest priority and 8 is the highest priority.')
prtInPh1MlDlciStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 4, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disconnected", 1), ("connected", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtInPh1MlDlciStatus.setStatus('mandatory')
if mibBuilder.loadTexts: prtInPh1MlDlciStatus.setDescription('This attribute indicates the status of the pvc. The status is disconnected(1) when one of the sides is programmed as not connected')
prtPhMlCnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 5), )
if mibBuilder.loadTexts: prtPhMlCnfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtPhMlCnfgTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry.')
prtPhMlCnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 5, 1), ).setIndexNames((0, "DACS-MIB", "prtPhMlCnfgIdx"), (0, "DACS-MIB", "prtPhMlSltIdx"), (0, "DACS-MIB", "prtPhMlPrtIdx"))
if mibBuilder.loadTexts: prtPhMlCnfgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtPhMlCnfgEntry.setDescription('')
prtPhMlCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtPhMlCnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtPhMlCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg. ')
prtPhMlSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtPhMlSltIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtPhMlSltIdx.setDescription('This attribute indicates a unique slot position where the module is inserted. In the ?004 Unit the entries io6(10)..io12(16) are not valid.')
prtPhMlPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("exPrt1", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtPhMlPrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtPhMlPrtIdx.setDescription('This attribute indicates a unique port number. ML-20 cards have just one external interface.')
prtPhMlConnect = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 5, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtPhMlConnect.setStatus('mandatory')
if mibBuilder.loadTexts: prtPhMlConnect.setDescription('This attribute indicates whether the port should be considered in any of the mux algorithms.')
prtPhMlRate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 5, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62))).clone(namedValues=NamedValues(("r2x64eq128Kbps", 4), ("r3x64eq192Kbps", 6), ("r4x64eq256Kbps", 8), ("r5x64eq320Kbps", 10), ("r6x64eq384Kbps", 12), ("r7x64eq448Kbps", 14), ("r8x64eq512Kbps", 16), ("r9x64eq576Kbps", 18), ("r10x64eq640Kbps", 20), ("r11x64eq704Kbps", 22), ("r12x64eq768Kbps", 24), ("r13x64eq832Kbps", 26), ("r14x64eq896Kbps", 28), ("r15x64eq960Kbps", 30), ("r16x64eq1024Kbps", 32), ("r17x64eq1088Kbps", 34), ("r18x64eq1152Kbps", 36), ("r19x64eq1216Kbps", 38), ("r20x64eq1280Kbps", 40), ("r21x64eq1344Kbps", 42), ("r22x64eq1408Kbps", 44), ("r23x64eq1472Kbps", 46), ("r24x64eq1536Kbps", 48), ("r25x64eq1600Kbps", 50), ("r26x64eq1664Kbps", 52), ("r27x64eq1728Kbps", 54), ("r28x64eq1792Kbps", 56), ("r29x64eq1856Kbps", 58), ("r30x64eq1920Kbps", 60), ("r31x64eq1984Kbps", 62)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtPhMlRate.setStatus('mandatory')
if mibBuilder.loadTexts: prtPhMlRate.setDescription('This attribute indicates the port speed.')
prtPhMlCAS = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 5, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtPhMlCAS.setStatus('mandatory')
if mibBuilder.loadTexts: prtPhMlCAS.setDescription('This attribute indicates whether Channel Associated Signaling (CAS) is used.')
prtPhMlClockMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 5, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("dce", 2), ("ext-dce", 3), ("dte", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtPhMlClockMode.setStatus('mandatory')
if mibBuilder.loadTexts: prtPhMlClockMode.setDescription('Clock mode.')
prtPhMlSatBuffer = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 5, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtPhMlSatBuffer.setStatus('mandatory')
if mibBuilder.loadTexts: prtPhMlSatBuffer.setDescription('Satellite Buffer (+/- 256).')
prtPhMlDialProcess = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 5, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("no", 2), ("callIn", 3), ("callOut", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtPhMlDialProcess.setStatus('mandatory')
if mibBuilder.loadTexts: prtPhMlDialProcess.setDescription('Dial Process.')
prtPhMlSyncRestore = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 5, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtPhMlSyncRestore.setStatus('mandatory')
if mibBuilder.loadTexts: prtPhMlSyncRestore.setDescription('Sync Restoration time, in seconds. notApplicable=0. ')
prtPhMlBus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 5, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("busA", 2), ("busB", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtPhMlBus.setStatus('mandatory')
if mibBuilder.loadTexts: prtPhMlBus.setDescription('The TDM BUS this port is linked to.')
prtPhMlMfSyncSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 2, 5, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("none", 2), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtPhMlMfSyncSlot.setStatus('mandatory')
if mibBuilder.loadTexts: prtPhMlMfSyncSlot.setDescription('This attribute indicates whether the sync is synchronized according to a certain card and the slot of this card. This operation is required in order to bypass signaling of PCM voice channels. In the ?004 Unit the entries io6(10)..io12(16) are not valid')
prtLogicalCnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 17, 1), )
if mibBuilder.loadTexts: prtLogicalCnfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtLogicalCnfgTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry.')
prtLogicalCnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 17, 1, 1), ).setIndexNames((0, "DACS-MIB", "prtLogicalCnfgIdx"), (0, "DACS-MIB", "prtLogicalSltIdx"), (0, "DACS-MIB", "prtLogicalPrtIdx"))
if mibBuilder.loadTexts: prtLogicalCnfgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtLogicalCnfgEntry.setDescription('')
prtLogicalCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 17, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtLogicalCnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtLogicalCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg. ')
prtLogicalSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 17, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtLogicalSltIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtLogicalSltIdx.setDescription('Slot Index. For ISDN BRI Ports of MX300/30, io1(5) = isdn1(5) and io2(6) = isdn2(6).')
prtLogicalPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 17, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtLogicalPrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtLogicalPrtIdx.setDescription('This attribute indicates a unique port number. This port number should be an internal port number: inPrt1(101)->inPrt50(150), linkSel1(200)->linkSel50(250), encaps1(300)-> encaps50(350), huntGr1(101) -> huntGr10(110).')
prtLogicalConnect = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 17, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtLogicalConnect.setStatus('mandatory')
if mibBuilder.loadTexts: prtLogicalConnect.setDescription('This attribute indicates whether the port should be considered in any of the mux algorithms.')
prtLogicalFunction = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 17, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("linkSelector", 2), ("encapsulator", 3), ("huntGroup", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtLogicalFunction.setStatus('mandatory')
if mibBuilder.loadTexts: prtLogicalFunction.setDescription('This parameter defines the function of the relevant channel.')
prtLogicalRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 17, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 6))).clone(namedValues=NamedValues(("active", 1), ("destroy", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtLogicalRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: prtLogicalRowStatus.setDescription('This parameter allows the NMS to create/delete logical ports.')
linkSelectorCnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 17, 2), )
if mibBuilder.loadTexts: linkSelectorCnfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: linkSelectorCnfgTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry.')
linkSelectorCnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 17, 2, 1), ).setIndexNames((0, "DACS-MIB", "linkSelectorCnfgIdx"), (0, "DACS-MIB", "linkSelectorSltIdx"), (0, "DACS-MIB", "linkSelectorPrtIdx"))
if mibBuilder.loadTexts: linkSelectorCnfgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: linkSelectorCnfgEntry.setDescription('')
linkSelectorCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 17, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: linkSelectorCnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: linkSelectorCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg. ')
linkSelectorSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 17, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: linkSelectorSltIdx.setStatus('mandatory')
if mibBuilder.loadTexts: linkSelectorSltIdx.setDescription('Slot Index')
linkSelectorPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 17, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: linkSelectorPrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: linkSelectorPrtIdx.setDescription('This attribute indicates a unique port number. This port number should be internal port number: higher or equal to linkSeL1(201).')
linkSelectorMaxIdleTime = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 17, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: linkSelectorMaxIdleTime.setStatus('mandatory')
if mibBuilder.loadTexts: linkSelectorMaxIdleTime.setDescription('Move to higher prioritized connected link after this period of seconds of silence on the current link. 0=move immediately to higher prioritized connected link. UNIT is seconds.')
linkSelectorMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 17, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("backup", 2), ("bod", 3))).clone('backup')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: linkSelectorMode.setStatus('mandatory')
if mibBuilder.loadTexts: linkSelectorMode.setDescription(' If the link selector is in mode: backup(2)=then the link with the lower priority will be used in case of failure of the higher priority link, bod(3)=bandwidth on demand or dynamic bandwidth allocation means that links with lower priority will be used whenever additional bandwidth is required. ')
linkSelectorRevert = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 17, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("auto", 2), ("manual", 3))).clone('auto')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: linkSelectorRevert.setStatus('mandatory')
if mibBuilder.loadTexts: linkSelectorRevert.setDescription(' If the link selector is in mode backup: auto(2)=return automatically to Main link when it is OK. manual(3)=stays connected to backup link.')
linkSelectorMinBUSession = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 17, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: linkSelectorMinBUSession.setStatus('mandatory')
if mibBuilder.loadTexts: linkSelectorMinBUSession.setDescription('Minimum duration of a backup session before returning to Main Link. Relevant in Backup Mode and when Revert is auto(2). Value 255 is for NEVER which means never return to Main Link. UNIT is minutes.')
linkSelectorPLinkTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 17, 3), )
if mibBuilder.loadTexts: linkSelectorPLinkTable.setStatus('mandatory')
if mibBuilder.loadTexts: linkSelectorPLinkTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry.')
linkSelectorPLinkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 17, 3, 1), ).setIndexNames((0, "DACS-MIB", "pLinkCnfgIdx"), (0, "DACS-MIB", "pLinkSltIdx"), (0, "DACS-MIB", "pLinkPrtIdx"), (0, "DACS-MIB", "pLinkIdx"))
if mibBuilder.loadTexts: linkSelectorPLinkEntry.setStatus('mandatory')
if mibBuilder.loadTexts: linkSelectorPLinkEntry.setDescription('')
pLinkCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 17, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pLinkCnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: pLinkCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg. ')
pLinkSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 17, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pLinkSltIdx.setStatus('mandatory')
if mibBuilder.loadTexts: pLinkSltIdx.setDescription('Slot Index')
pLinkPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 17, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(200, 250))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pLinkPrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: pLinkPrtIdx.setDescription('This attribute indicates a unique port number. This port number should be the link selector number.')
pLinkIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 17, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pLinkIdx.setStatus('mandatory')
if mibBuilder.loadTexts: pLinkIdx.setDescription('This index is the row number.')
pLinkSlotNu = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 17, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("noConnect", 2), ("cl", 3), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255))).clone('noConnect')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pLinkSlotNu.setStatus('mandatory')
if mibBuilder.loadTexts: pLinkSlotNu.setDescription('The slot of the prioritized link. For ISDN BRI ports of MX300/30, io1(5) = isdn1(5) and io2(6) = isdn2(6).')
pLinkPortNu = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 17, 3, 1, 6), Integer32().clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pLinkPortNu.setStatus('mandatory')
if mibBuilder.loadTexts: pLinkPortNu.setDescription('The port of the prioritized link. Value 100 is for noConnect.')
pLinkPrioNu = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 17, 3, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pLinkPrioNu.setStatus('mandatory')
if mibBuilder.loadTexts: pLinkPrioNu.setDescription('The priority of the prioritized link. MIN=1...., MAX=8.')
pLinkVRate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 17, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 100))).clone(namedValues=NamedValues(("r1x56eq56Kbps", 1), ("r1x64eq64Kbps", 2), ("r2x56eq112Kbps", 3), ("r2x64eq128Kbps", 4), ("r3x56eq168Kbps", 5), ("r3x64eq192Kbps", 6), ("r4x56eq224Kbps", 7), ("r4x64eq256Kbps", 8), ("r5x56eq280Kbps", 9), ("r5x64eq320Kbps", 10), ("r6x56eq336Kbps", 11), ("r6x64eq384Kbps", 12), ("r7x56eq392Kbps", 13), ("r7x64eq448Kbps", 14), ("r8x56eq448Kbps", 15), ("r8x64eq512Kbps", 16), ("r9x56eq504Kbps", 17), ("r9x64eq576Kbps", 18), ("r10x56eq560Kbps", 19), ("r10x64eq640Kbps", 20), ("r11x56eq616Kbps", 21), ("r11x64eq704Kbps", 22), ("r12x56eq672Kbps", 23), ("r12x64eq768Kbps", 24), ("r13x56eq728Kbps", 25), ("r13x64eq832Kbps", 26), ("r14x56eq784Kbps", 27), ("r14x64eq896Kbps", 28), ("r15x56eq840Kbps", 29), ("r15x64eq960Kbps", 30), ("r16x56eq896Kbps", 31), ("r16x64eq1024Kbps", 32), ("r17x56eq952Kbps", 33), ("r17x64eq1088Kbps", 34), ("r18x56eq1008Kbps", 35), ("r18x64eq1152Kbps", 36), ("r19x56eq1064Kbps", 37), ("r19x64eq1216Kbps", 38), ("r20x56eq1120Kbps", 39), ("r20x64eq1280Kbps", 40), ("r21x56eq1176Kbps", 41), ("r21x64eq1344Kbps", 42), ("r22x56eq1232Kbps", 43), ("r22x64eq1408Kbps", 44), ("r23x56eq1288Kbps", 45), ("r23x64eq1472Kbps", 46), ("r24x56eq1344Kbps", 47), ("r24x64eq1536Kbps", 48), ("r25x56eq1400Kbps", 49), ("r25x64eq1600Kbps", 50), ("r26x56eq1456Kbps", 51), ("r26x64eq1664Kbps", 52), ("r27x56eq1512Kbps", 53), ("r27x64eq1728Kbps", 54), ("r28x56eq1568Kbps", 55), ("r28x64eq1792Kbps", 56), ("r29x56eq1624Kbps", 57), ("r29x64eq1856Kbps", 58), ("r30x56eq1680Kbps", 59), ("r30x64eq1920Kbps", 60), ("r31x56eq1736Kbps", 61), ("r31x64eq1984Kbps", 62), ("noRate", 100))).clone('noRate')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pLinkVRate.setStatus('mandatory')
if mibBuilder.loadTexts: pLinkVRate.setDescription('The rate to use with this link.')
prtExPhPlCnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1), )
if mibBuilder.loadTexts: prtExPhPlCnfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPhPlCnfgTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry.')
prtExPhPlCnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1, 1), ).setIndexNames((0, "DACS-MIB", "prtExPhPlCnfgIdx"), (0, "DACS-MIB", "prtExPhPlSltIdx"), (0, "DACS-MIB", "prtExPhPlPrtIdx"))
if mibBuilder.loadTexts: prtExPhPlCnfgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPhPlCnfgEntry.setDescription('')
prtExPhPlCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExPhPlCnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPhPlCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg. ')
prtExPhPlSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExPhPlSltIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPhPlSltIdx.setDescription('This attribute indicates a unique slot position where the card is inserted. In the ?004 Unit the entries io6(10)..io12(16) are not valid')
prtExPhPlPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("exPrt1", 1), ("exPrt2", 2), ("exPrt3", 3), ("exPrt4", 4), ("exPrt5", 5), ("exPrt6", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExPhPlPrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPhPlPrtIdx.setDescription('This attribute indicates a unique port number. In case of PH.1 card, only exPrt(1) is valid.')
prtExPhPlConnect = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlConnect.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPhPlConnect.setDescription('This attribute indicates whether the port should be considered in any of the mux algorithms.')
prtExPhPlHRate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 65, 66, 67, 68, 69, 70, 71, 72, 73))).clone(namedValues=NamedValues(("notApplicable", 1), ("r32KbpsNLE", 2), ("r48KbpsNLE", 3), ("r56KbpsNLE", 4), ("r64KbpsNLE", 5), ("r112KbpsNLE", 6), ("r128KbpsNLE", 7), ("r168KbpsNLE", 8), ("r192KbpsNLE", 9), ("r224KbpsNLE", 10), ("r256KbpsNLE", 11), ("r280KbpsE", 12), ("r320KbpsE", 13), ("r336KbpsNLE", 14), ("r384KbpsNLE", 15), ("r392KbpsE", 16), ("r448KbpsNLE", 17), ("r504KbpsLE", 18), ("r512KbpsE", 19), ("r560KbpsE", 20), ("r576KbpsLE", 21), ("r616KbpsE", 22), ("r640KbpsE", 23), ("r672KbpsNLE", 24), ("r704KbpsE", 25), ("r728KbpsE", 26), ("r768KbpsNLE", 27), ("r784KbpsE", 28), ("r832KbpsE", 29), ("r840KbpsE", 30), ("r896KbpsNLE", 31), ("r952KbpsE", 32), ("r960KbpsE", 33), ("r1008KbpsLE", 34), ("r1024KbpsE", 35), ("r1064KbpsE", 36), ("r1088KbpsE", 37), ("r1120KbpsE", 38), ("r1152KbpsLE", 39), ("r1176KbpsE", 40), ("r1216KbpsE", 41), ("r1232KbpsE", 42), ("r1280KbpsE", 43), ("r1288KbpsE", 44), ("r1344KbpsNLE", 45), ("r1400KbpsE", 46), ("r1408KbpsE", 47), ("r1456KbpsE", 48), ("r1472KbpsE", 49), ("r1512KbpsE", 50), ("r1536KbpsE", 51), ("r1568KbpsE", 52), ("r1600KbpsE", 53), ("r1624KbpsE", 54), ("r1664KbpsE", 55), ("r1680KbpsE", 56), ("r1728KbpsE", 57), ("r1736KbpsE", 58), ("r1792KbpsNLE", 59), ("r1856KbpsE", 60), ("r1920KbpsE", 61), ("r1984KbpsE", 62), ("r2048KbpsE", 63), ("r9d6KbpsNLE", 65), ("r14d4KbpsNLE", 66), ("r16KbpsNLE", 67), ("r19d2KbpsNLE", 68), ("r28d8KbpsNLE", 69), ("r38d4KbpsNLE", 70), ("r57d6KbpsNLE", 71), ("r115d2KbpsNLE", 72), ("r24000bps", 73)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlHRate.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPhPlHRate.setDescription("This attribute indicates the port speed for HIGH speed cards. The card has limitations about the maximum sigma channel speeds and about the possible rates for each clock mode . N - The rate is valid for DCE and EXT-DCE Nodal clock mode. L - The rate is valid for DCE and EXT-DCE Local clock mode. E - The rate is valid for DTE External clock mode. 'r9d6KbpsNLE' means rate of 9.6 Kbps ('d'=dot). Note: Some rate attributes have been changed. As the MIB was already released with the old attributes, the names of the options were not changed. The new names + attributes are in a comment. Example: r2048KbpsE (63), -- r2048KbpsNLE")
prtExPhPlLRate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23))).clone(namedValues=NamedValues(("notApplicable", 1), ("r300bpsNLE", 2), ("r600bpsNLE", 3), ("r800bpsNLE", 4), ("r1200bpsNLE", 5), ("r2400bpsNLE", 6), ("r4800bpsNLE", 7), ("r9600bpsNLE", 8), ("r14400bpsLE", 9), ("r19200bpsNLE", 10), ("r28800bpsLE", 11), ("r32000bpsNLE", 12), ("r38400bpsNLE", 13), ("r48000bpsNLE", 14), ("r56000bpsNLE", 15), ("r57600bpsLE", 16), ("r64000bpsNLE", 17), ("r112000bps", 18), ("r115200bps", 19), ("r16000bpsNLE", 20), ("r100bpsNLE", 21), ("r128000bps", 22), ("r24000bps", 23)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlLRate.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPhPlLRate.setDescription('This attribute indicates the port speed for LOW speed cards. The card has limitations about the possible rates for each clock mode. N - The rate is valid for DCE and EXT-DCE Nodal clock mode. L - The rate is valid for DCE and EXT-DCE Local clock mode. E - The rate is valid for DTE External clock mode. Note: Some rate attributes have been changed. As the MIB was already released with the old attributes, the names of the options were not changed. The new names + attributes are in a comment. Example: r57600bpsLE (16), -- r57600bpsNLE ')
prtExPhPlProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("fr", 1), ("frPlus", 2), ("pCellRelay", 3), ("hdlcSdlc", 4), ("transparentHdlc", 5), ("async", 6), ("asyncReliable", 7), ("activePPP", 8), ("slip", 9), ("pppAgent", 10), ("slipAgent", 11), ("transparent", 12), ("sna", 13)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPhPlProtocol.setDescription('This object indicates the applied protocol.')
prtExPhPlConnectionTyp = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 255))).clone(namedValues=NamedValues(("sameNetManaged", 1), ("sameNetNotMana", 2), ("user", 3), ("otherNet", 4), ("pubNet", 5), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlConnectionTyp.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPhPlConnectionTyp.setDescription('This attribute indicates the link connection type. It is required for three reasons: FR/CR Inband management opration (LMI,CLMM...). CIR check. NMS network management. SameNetManaged - indicates network internal line. SameNetMotMana - indicates network internal line, but the remote mux is not managed by the NMS. User - User to Network Interface. OtherNet - Network To Network Interface. PubNet - Access Mux To PubNet Interface.')
prtExPhPlClkMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("dce", 1), ("extDce", 2), ("dte", 3), ("int", 4), ("lbt", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlClkMode.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPhPlClkMode.setDescription('Clock mode.')
prtExPhPlDceClkSrc = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("local", 2), ("nodalTiming", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlDceClkSrc.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPhPlDceClkSrc.setDescription("This attribute indicates the source of the clock when working in dce or ext-dce clock mode. notApplicable(1) - is applied for dte(3) and lbt(5) clock modes. When clock mode is dte, the clock source is always external, therefore this object's value is notApplicable. local(2) and nodalTiming(3) - are valid in dce(1), extDce(2) or int(4) clock modes. The recommended clock source is local(2).")
prtExPhPlCongResponse = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("no", 2), ("flowControl", 3), ("toFlowControl", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlCongResponse.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPhPlCongResponse.setDescription('This attribute indicates how to handle the congestion indication to/from the mux internal connection side (for example transmit/received becn to/from the network). no - do nothing flowControl - translates the congestion indication between the port and the internal connection port according to the definition of the prtInPh1MlFlowControl parameters. The operation is done on both directions. toFlowControl- translates the backward congestion indication received from the internal connection port (normally the network side) to flow control and do nothing in the other direction.')
prtExPhPlCongLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 70))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlCongLevel.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPhPlCongLevel.setDescription('This attribute indicates the level of delayed data in precents of total available dynamic memory, for which the port will start to operate as congested. The resolution of the parameter is 5 percent.')
prtExPhPlTc = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 255))).clone(namedValues=NamedValues(("tc1sec", 1), ("tc2sec", 2), ("tc3sec", 3), ("tc4sec", 4), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlTc.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPhPlTc.setDescription('This attribute indicates the Tc parameter which is the time period of the sliding window in which the Bc/Be are tested. The value of this parameter is identical for all the ports of a specific card .')
prtExPhPlFlowControl = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("none", 2), ("fecnBecn", 3), ("xonXoff", 4), ("dtrCts", 5), ("speedReduction", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlFlowControl.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPhPlFlowControl.setDescription('This attribute indicates the required flow control betweeen the port and the remote equipment. fecnBecn - is valid only for FR, FR+ and CR protocols. xonXoff,dtrCts - are valid only for Async protocols. speedReduction - is valid only for DLC protocol when the Clock Mode is DCE and the Clock Source is Local.')
prtExPhPlDcdRts = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("on", 2), ("endToEnd", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlDcdRts.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPhPlDcdRts.setDescription('Protocol may require end to end connect indication over the network. End to end link connection establishment over the FR network will be indicated to the user by using DCD or RTS control signals, depending on the clock mode: DCE or DTE respectively. The options are : - On : DCD(DCE)/RTS(DTE) will be constantly ON no matter if the End to End connection is established or not. - End to End: The DCD(DCE)/RTS(DTE) will be according to the status of the End to End connection.')
prtExPhPlDcdRtsControlPath = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlDcdRtsControlPath.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPhPlDcdRtsControlPath.setDescription('Protocol may require end to end connect indication over the network. This parameter defines whether to take the user connection status (RTS(DCE)/DCD(DTE)) and forward it to the network side. - on : Transmit active connection to the network regardless the RTS/DCD control lines status. - off: Transmit active connection to the network according to the status of the RTS/DCD pin. ')
prtExPhPlDataBits = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("dataBits7Bits", 2), ("dataBits8Bits", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlDataBits.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPhPlDataBits.setDescription('This attribute indicates the number of data bits in async frame. It is relevant only for Async protocols.')
prtExPhPlParity = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("odd", 2), ("even", 3), ("none", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlParity.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPhPlParity.setDescription('This attribute indicates the parity operation mode in async frame. It is relevant only for Async protocols.')
prtExPhPlStopBits = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("sb1Bit", 2), ("sb1dot5Bits", 3), ("sb2Bits", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlStopBits.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPhPlStopBits.setDescription('This attribute indicates the minimum number of stop bits in the tx async frame. It is relevant only for Async protocols.')
prtExPhPlLXon = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1, 1, 20), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlLXon.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPhPlLXon.setDescription("This attribute indicates the character used as X-On to notify receive enable. This parameter is valid only for async protocols. Valid values: 0..255. The value 256 indicates that it's not applicable ")
prtExPhPlLXoff = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1, 1, 21), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlLXoff.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPhPlLXoff.setDescription("This attribute indicates the character used as X-Off to notify receive disable. This parameter is valid only for async protocols. Valid values: 0..255. The value 256 indicates that it's not applicable ")
prtExPhPlFrMngProt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notApplicable", 1), ("none", 2), ("lmi", 3), ("ansiT1", 4), ("annexA", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlFrMngProt.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPhPlFrMngProt.setDescription('This object indicates the Frame-Relay management protocol. ansiT1 = ANSI T1.617 Annex D (this is the default value). This parameter is applicable only for FR and FR+ protocols. When prtExPhPlConnectionTyp = sameNetManaged, this object will be RO (internally determined). ')
prtExPhPlEnqPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlEnqPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPhPlEnqPeriod.setDescription('This object is the Status Enquiry Period, in seconds. It determines the frequency of the Status Enquiry message as sent by the FR user side. At the FR network side, it determines the timeout for this message reception. Default = 4 seconds. This parameter is applicable only for FR and FR+ protocols AND only when prtExPhPlFrMngProt is NOT (notApplicable or none).')
prtExPhPlFullRptPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlFullRptPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPhPlFullRptPeriod.setDescription('This object is the Full Report Frequency. It determines the number of the Status Enquiry messages sent by the FR user side, before a Full Report Request is sent. The units are : Status Enquiry messages (periods). Valid values: 1 .. 255. 255 = infinite. This parameter is applicable only for FR and FR+ protocols AND only when prtExPhPlFrMngProt is NOT (notApplicable or none).')
prtExPhPlFrWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlFrWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPhPlFrWindowSize.setDescription('This object is the FR Window Size. It determines the number of samplings in the sliding window that counts the errors. This parameter is applicable only for FR and FR+ protocols AND only when prtExPhPlFrMngProt is NOT (notApplicable or none).')
prtExPhPlErrorsThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlErrorsThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPhPlErrorsThreshold.setDescription('This object is the Max Errors. It determines the number of Status Enquiry Errors that occured within the FR sliding window, before this port is considered DOWN (threshold). This parameter is applicable only for FR and FR+ protocols AND only when prtExPhPlFrMngProt is NOT (notApplicable or none).')
prtExPhPlPvcCreateMsg = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlPvcCreateMsg.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPhPlPvcCreateMsg.setDescription('This object is Update Message (if required or not). It determines whether a message of a New PVC Creation is requested or not (yes/no). Default = no. This parameter is applicable only for FR and FR+ protocols AND only when prtExPhPlFrMngProt is NOT (notApplicable or none).')
prtExPhPlCllmMsg = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlCllmMsg.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPhPlCllmMsg.setDescription('This object is CLLM Message (if required or not). It determines whether to send (or not) a congestion message when the port is Rx congested. Default = no. This parameter is applicable only for FR and FR+ protocols AND only when prtExPhPlFrMngProt is NOT (notApplicable or none).')
prtExPhPlProtDelayLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("notApplicable", 1), ("s36Byte", 2), ("s150Byte", 3), ("s264Byte", 4), ("s378Byte", 5), ("s492Byte", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlProtDelayLevel.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPhPlProtDelayLevel.setDescription('This object is the Segmentation in Bytes. In some cases, the enumerated values will mean other segmentation values than specified: Product: MX-3000 MX-3000 MX-300/MX-30 Protocol: FR+ Transparent FR+ ----------------------------------------------------- level 1 50 Bytes 44 Bytes 50 Bytes level 2 158 Bytes 155 Bytes 158 Bytes level 3 266 Bytes 266 Bytes 266 Bytes level 4 376 Bytes 377 Bytes 376 Bytes level 5 484 Bytes 488 Bytes 484 Bytes Defval=level 1 value This parameter is applicable only for FR+ and transparent protocols.')
prtExPhPlClockEncoding = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("notApplicable", 1), ("nrz", 2), ("nrzI", 3), ("fm0", 4), ("manchester", 5), ("diffManchester", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlClockEncoding.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPhPlClockEncoding.setDescription('This object is the Encoding type of the Line. This parameter is applicable only for FR and FR+ protocols.')
prtExPhPlMinSeparators = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1, 1, 31), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlMinSeparators.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPhPlMinSeparators.setDescription('Minimum number of bytes separating between two adjacent frames (HDLC item). 0 = notApplicable')
prtExPhPlCcittCrc = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("crc16", 2), ("crc32", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlCcittCrc.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPhPlCcittCrc.setDescription('This object indicates how many Bits are used for CRC (HDLC item).')
prtExPhPlFrameSeparator = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 1, 1, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("idles", 2), ("flags", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlFrameSeparator.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPhPlFrameSeparator.setDescription('This object indicates what should be transferred on the line when there are no frames to pass (HDLC item). idles: mean that FF will pass on the line flags: mean that 7E will pass on the line.')
prtExPhPlDlciTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 2), )
if mibBuilder.loadTexts: prtExPhPlDlciTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPhPlDlciTable.setDescription('The write operation into the Table Objects is valid only at the TmpCnfg entry.')
prtExPhPlDlciEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 2, 1), ).setIndexNames((0, "DACS-MIB", "prtExPhPlDlciCnfgIdx"), (0, "DACS-MIB", "prtExPhPlDlciSltIdx"), (0, "DACS-MIB", "prtExPhPlDlciPrtIdx"), (0, "DACS-MIB", "prtExPhPlDlciIdx"))
if mibBuilder.loadTexts: prtExPhPlDlciEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPhPlDlciEntry.setDescription('')
prtExPhPlDlciCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExPhPlDlciCnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPhPlDlciCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg. ')
prtExPhPlDlciSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExPhPlDlciSltIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPhPlDlciSltIdx.setDescription('This attribute indicates a unique slot position where the card is inserted. In the ?004 Unit the entries io6(10)..io16) are not valid')
prtExPhPlDlciPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("exPrt1", 1), ("exPrt2", 2), ("exPrt3", 3), ("exPrt4", 4), ("exPrt5", 5), ("exPrt6", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExPhPlDlciPrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPhPlDlciPrtIdx.setDescription('This attribute indicates a unique internal port number. PH.1/E1 and PH.1/T1 cards have three internal ports. Stand-alone units may have six such ports.')
prtExPhPlDlciIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 991))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExPhPlDlciIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPhPlDlciIdx.setDescription("This attribute indicates a unique index for each possible used dlci(16..991). When the protocol is not Multiplexing protocol, its type is 'user' and the only valid index is 1.")
prtExPhPlDlciValid = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlDlciValid.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPhPlDlciValid.setDescription('This attribute indicates whether the attributes in this entry are valid or not. The user can add/delete pvc (dlci to dlci connection) by modifing this object')
prtExPhPlDlciIConSlt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("noConnect", 2), ("cl", 3), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlDlciIConSlt.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPhPlDlciIConSlt.setDescription('This attribute indicates a unique slot position In the Mux (Agent) where the dlci is routed to. cl - will represent any of the CL slots. This value can be selected for multiple DLCIs of the product. In the ?004 Unit the entries io6(10)..io16) are not valid')
prtExPhPlDlciIConPrt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110))).clone(namedValues=NamedValues(("exPrt1", 1), ("exPrt2", 2), ("exPrt3", 3), ("exPrt4", 4), ("exPrt5", 5), ("exPrt6", 6), ("exPrt7", 7), ("exPrt8", 8), ("exPrt9", 9), ("exPrt10", 10), ("clNMS", 99), ("noConnect", 100), ("inPrt1", 101), ("inPrt2", 102), ("inPrt3", 103), ("inPrt4", 104), ("inPrt5", 105), ("inPrt6", 106), ("inPrt7", 107), ("inPrt8", 108), ("inPrt9", 109), ("inPrt10", 110)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlDlciIConPrt.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPhPlDlciIConPrt.setDescription("This attribute indicates a unique port id which the dlci is routed to. clNMS - will be used for NMS SNMP messages. It can be any port of the CL card. This value will be selectable only if prtExPhPlDlciIConSlt='cl' or 'notApplicable'.")
prtExPhPlDlciIConDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 991))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlDlciIConDlci.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPhPlDlciIConDlci.setDescription('This attribute indicates a unique internal connection dlci number, the dlci is routed to.')
prtExPhPlDlciTxBc = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 25, 26))).clone(namedValues=NamedValues(("full", 1), ("zero", 2), ("txBc9600bps", 3), ("txBc14400bps", 4), ("txBc19200bps", 5), ("txBc28800bps", 6), ("txBc32000bps", 7), ("txBc38400bps", 8), ("txBc48000bps", 9), ("txBc56000bps", 10), ("txBc57600bps", 11), ("txBc64Kbps", 12), ("txBc128Kbps", 13), ("txBc192Kbps", 14), ("txBc256Kbps", 15), ("txBc320Kbps", 16), ("txBc384Kbps", 17), ("txBc448Kbps", 18), ("txBc512Kbps", 19), ("txBc768Kbps", 20), ("txBc1024Kbps", 21), ("txBc16000bps", 25), ("txBc112Kbps", 26)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlDlciTxBc.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPhPlDlciTxBc.setDescription('This attribute indicates a unique Tx committed bandwidth on the user transmit line (or at the port receive line).')
prtExPhPlDlciTxBe = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 25, 26))).clone(namedValues=NamedValues(("full", 1), ("zero", 2), ("txBe9600bps", 3), ("txBe14400bps", 4), ("txBe19200bps", 5), ("txBe28800bps", 6), ("txBe32000bps", 7), ("txBe38400bps", 8), ("txBe48000bps", 9), ("txBe56000bps", 10), ("txBe57600bps", 11), ("txBe64Kbps", 12), ("txBe128Kbps", 13), ("txBe192Kbps", 14), ("txBe256Kbps", 15), ("txBe320Kbps", 16), ("txBe384Kbps", 17), ("txBe448Kbps", 18), ("txBe512Kbps", 19), ("txBe768Kbps", 20), ("txBe1024Kbps", 21), ("txBc16000bps", 25), ("txBc112Kbps", 26)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlDlciTxBe.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPhPlDlciTxBe.setDescription('This attribute indicates a unique Tx excess bandwidth on the user transmit line (or at the port receive line).')
prtExPhPlDlciRxBc = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 25, 26))).clone(namedValues=NamedValues(("full", 1), ("zero", 2), ("rxBc9600bps", 3), ("rxBc14400bps", 4), ("rxBc19200bps", 5), ("rxBc28800bps", 6), ("rxBc32000bps", 7), ("rxBc38400bps", 8), ("rxBc48000bps", 9), ("rxBc56000bps", 10), ("rxBc57600bps", 11), ("rxBc64Kbps", 12), ("rxBc128Kbps", 13), ("rxBc192Kbps", 14), ("rxBc256Kbps", 15), ("rxBc320Kbps", 16), ("rxBc384Kbps", 17), ("rxBc448Kbps", 18), ("rxBc512Kbps", 19), ("rxBc768Kbps", 20), ("rxBc1024Kbps", 21), ("rxBc16000bps", 25), ("rxBc112Kbps", 26)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlDlciRxBc.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPhPlDlciRxBc.setDescription('This attribute indicates a unique Rx committed bandwidth on the user receive line (or at the port transmit line).')
prtExPhPlDlciRxBe = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 25, 26))).clone(namedValues=NamedValues(("full", 1), ("zero", 2), ("rxBe9600bps", 3), ("rxBe14400bps", 4), ("rxBe19200bps", 5), ("rxBe28800bps", 6), ("rxBe32000bps", 7), ("rxBe38400bps", 8), ("rxBe48000bps", 9), ("rxBe56000bps", 10), ("rxBe57600bps", 11), ("rxBe64Kbps", 12), ("rxBe128Kbps", 13), ("rxBe192Kbps", 14), ("rxBe256Kbps", 15), ("rxBe320Kbps", 16), ("rxBe384Kbps", 17), ("rxBe448Kbps", 18), ("rxBe512Kbps", 19), ("rxBe768Kbps", 20), ("rxBe1024Kbps", 21), ("rxBc16000bps", 25), ("rxBc112Kbps", 26)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlDlciRxBe.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPhPlDlciRxBe.setDescription('This attribute indicates a unique Rx excess bandwidth on the user receive line (or at the port transmit line).')
prtExPhPlDlciPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 2, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlDlciPriority.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPhPlDlciPriority.setDescription('This attribute indicates a unique priority of the pcv. 1 is the lowest priority and 8 is the highest priority.')
prtExPhPlDlciStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disconnected", 1), ("connected", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExPhPlDlciStatus.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPhPlDlciStatus.setDescription('This attribute indicates the status of the pvc. The status is disconnected(1) when one of the sides is programmed as not connected')
prtExPhPlModemTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 3), )
if mibBuilder.loadTexts: prtExPhPlModemTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPhPlModemTable.setDescription('External Modem Parameters. The write operation into the Table Objects is valid only for the TmpCnfg entry.')
prtExPhPlModemEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 3, 1), ).setIndexNames((0, "DACS-MIB", "prtExPhPlModemCnfgIdx"), (0, "DACS-MIB", "prtExPhPlModemSltIdx"), (0, "DACS-MIB", "prtExPhPlModemPrtIdx"))
if mibBuilder.loadTexts: prtExPhPlModemEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPhPlModemEntry.setDescription('')
prtExPhPlModemCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExPhPlModemCnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPhPlModemCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg. ')
prtExPhPlModemSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExPhPlModemSltIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPhPlModemSltIdx.setDescription('This attribute indicates a unique slot position where the card is inserted. In the ?004 Unit the entries io6(10)..io12(16) are not valid')
prtExPhPlModemPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("exPrt1", 1), ("exPrt2", 2), ("exPrt3", 3), ("exPrt4", 4), ("exPrt5", 5), ("exPrt6", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExPhPlModemPrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPhPlModemPrtIdx.setDescription('This attribute indicates a unique port number. In case of PH.1 card, only exPrt(1) is valid.')
prtExPhPlModemStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("disable", 2), ("enable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlModemStatus.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPhPlModemStatus.setDescription('This object indicates whether a Dial Up Modem is enabled on this port. Default: disable')
prtExPhPlModemActivate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 255))).clone(namedValues=NamedValues(("onFirstFrame", 2), ("always", 3), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlModemActivate.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPhPlModemActivate.setDescription('This object indicates whether the Dial Up Modem is activated when the first frame is received or it is always activated. Default: onFirstFrame')
prtExPhPlModemMaxIdleTime = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 3, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlModemMaxIdleTime.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPhPlModemMaxIdleTime.setDescription('Max Time allowed in Seconds without any traffic before the line is disconnected. Legal Values are: 1 sec, 2 sec .. 5 sec, 10 sec, 20 sec.. 1 min, 2 min .. 10 min, 15 min, 20 min, 25 min, 30 min. 65535 sec. means that this parameter is not applicable. Default: 1 sec.')
prtExPhPlModemTimeBtwnCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 3, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlModemTimeBtwnCalls.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPhPlModemTimeBtwnCalls.setDescription('Minimum Time in Seconds which is required after a call was disconnected. In this time no other call will be initiated from this Modem port even if there were frames transmitted to this port. This time is required for some Modems which have initializations that take a few seconds. Legal Values are: 0 sec. - 30 sec., 1-5 min. 65535 sec. means that this parameter is not applicable. Default: 0 sec')
prtExPhPlModemCallDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 3, 3, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPhPlModemCallDelay.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPhPlModemCallDelay.setDescription('Time in Seconds that the device will wait before dialing to the remote device. This feature is mostly used when there is a backup modem to the main link and the main link is down. In this case it is important to prevent the 2 devices from dialing through the backup modems to each other at the same time. It is advised to configure one side with a small call delay and the other side with a large call delay. Legal Values are: 0 - 30, 60, 120, 180, 240, 300, 600, 900, 1200, 1500, 1800 . 65535 sec. means that this parameter is not applicable. Default: 0 sec')
prtExLs2CnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 4, 1), )
if mibBuilder.loadTexts: prtExLs2CnfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtExLs2CnfgTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry.')
prtExLs2CnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 4, 1, 1), ).setIndexNames((0, "DACS-MIB", "prtExLs2CnfgIdx"), (0, "DACS-MIB", "prtExLs2SltIdx"), (0, "DACS-MIB", "prtExLs2PrtIdx"))
if mibBuilder.loadTexts: prtExLs2CnfgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtExLs2CnfgEntry.setDescription('')
prtExLs2CnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExLs2CnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtExLs2CnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg')
prtExLs2SltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExLs2SltIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtExLs2SltIdx.setDescription('This attribute indicates a unique slot position where the card is inserted. In the ?004 Unit the entries io6(10)..io16) are not valid.')
prtExLs2PrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("exPrt1", 1), ("exPrt2", 2), ("exPrt3", 3), ("exPrt4", 4), ("exPrt5", 5), ("exPrt6", 6), ("exPrt7", 7), ("exPrt8", 8), ("exPrt9", 9), ("exPrt10", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExLs2PrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtExLs2PrtIdx.setDescription('This attribute indicates a unique port index. For the Ls2/X.58 exPrt(7)..exPrt(10) are not valid.')
prtExLs2Connect = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExLs2Connect.setStatus('mandatory')
if mibBuilder.loadTexts: prtExLs2Connect.setDescription('This attribute indicates whether the port should be considered in any of the mux algorithms.')
prtExLs2Rate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5))).clone(namedValues=NamedValues(("r2400bps", 2), ("r4800bps", 3), ("r9600bps", 4), ("r19200bps", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExLs2Rate.setStatus('mandatory')
if mibBuilder.loadTexts: prtExLs2Rate.setDescription('Port rates.')
prtExLs2ClkMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 4, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("dce", 1), ("ext-dce", 2), ("dte", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExLs2ClkMode.setStatus('mandatory')
if mibBuilder.loadTexts: prtExLs2ClkMode.setDescription('This attribute indicates a unique port operation clock mode.')
prtExLs2Cts = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 4, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("on", 2), ("rts-min", 3), ("rts-max", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExLs2Cts.setStatus('mandatory')
if mibBuilder.loadTexts: prtExLs2Cts.setDescription('CTS.')
prtExLs2Dcd = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 4, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("on", 2), ("card-sync", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExLs2Dcd.setStatus('mandatory')
if mibBuilder.loadTexts: prtExLs2Dcd.setDescription('DCD.')
prtExLs2EnvIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 4, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 24))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExLs2EnvIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtExLs2EnvIdx.setDescription('Envelope Index. When prtInLs2EnvAssign=auto, the value is 0 (not applicable).')
prtInLs2CnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 4, 2), )
if mibBuilder.loadTexts: prtInLs2CnfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtInLs2CnfgTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry.')
prtInLs2CnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 4, 2, 1), ).setIndexNames((0, "DACS-MIB", "prtInLs2CnfgIdx"), (0, "DACS-MIB", "prtInLs2SltIdx"), (0, "DACS-MIB", "prtInLs2PrtIdx"))
if mibBuilder.loadTexts: prtInLs2CnfgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtInLs2CnfgEntry.setDescription('')
prtInLs2CnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 4, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtInLs2CnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtInLs2CnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg')
prtInLs2SltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 4, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtInLs2SltIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtInLs2SltIdx.setDescription('This attribute indicates a unique slot position where the card is inserted. In the ?004 Unit the entries io6(10)..io16) are not valid.')
prtInLs2PrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 4, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(101, 102))).clone(namedValues=NamedValues(("inPrt1", 101), ("inPrt2", 102)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtInLs2PrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtInLs2PrtIdx.setDescription('This attribute indicates a unique internal port index.')
prtInLs2Connect = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 4, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInLs2Connect.setStatus('mandatory')
if mibBuilder.loadTexts: prtInLs2Connect.setDescription('This attribute indicates whether the port should be considered in any of the mux algorithms. It also affects all the module considerations because the module has only one Internal interface which is the composite channel.')
prtInLs2Group = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 4, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 12))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInLs2Group.setStatus('mandatory')
if mibBuilder.loadTexts: prtInLs2Group.setDescription('This attribute indicates the group number of the port. LS-2 internal ports with the same group number share the same Time slot of the main link')
prtInLs2Member = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 4, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInLs2Member.setStatus('mandatory')
if mibBuilder.loadTexts: prtInLs2Member.setDescription('This attribute indicates the group member id of the port. This parameter is for the automatic envelope assignment algorithm.')
prtInLs2LinkTo = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 4, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInLs2LinkTo.setStatus('deprecated')
if mibBuilder.loadTexts: prtInLs2LinkTo.setDescription('It indicates the slot of the main link card to which the LS2 card is mapped. STATUS deprecated - this object is replaced by prtGenCnfgLinkToSlot and prtGenCnfgLinkToPort.')
prtInLs2EnvAssign = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 4, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("auto", 2), ("manual", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInLs2EnvAssign.setStatus('mandatory')
if mibBuilder.loadTexts: prtInLs2EnvAssign.setDescription('Envelope assignment type.')
prtVc2CnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 5), )
if mibBuilder.loadTexts: prtVc2CnfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtVc2CnfgTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry.')
prtVc2CnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 5, 1), ).setIndexNames((0, "DACS-MIB", "prtVc2CnfgIdx"), (0, "DACS-MIB", "prtVc2SltIdx"), (0, "DACS-MIB", "prtVc2PrtIdx"))
if mibBuilder.loadTexts: prtVc2CnfgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtVc2CnfgEntry.setDescription('')
prtVc2CnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtVc2CnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtVc2CnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg')
prtVc2SltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtVc2SltIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtVc2SltIdx.setDescription('This attribute indicates a unique slot position where the card is inserted. For Stand Alone products like WR: notApplicable (255)')
prtVc2PrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("exPrt1", 1), ("exPrt2", 2), ("exPrt3", 3), ("exPrt4", 4), ("exPrt5", 5), ("exPrt6", 6), ("exPrt7", 7), ("exPrt8", 8), ("exPrt9", 9), ("exPrt10", 10), ("exPrt11", 11), ("exPrt12", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtVc2PrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtVc2PrtIdx.setDescription('A unique identifier of the port, within the card.')
prtExVc2Connect = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 5, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVc2Connect.setStatus('mandatory')
if mibBuilder.loadTexts: prtExVc2Connect.setDescription('This attribute indicates whether the port should be considered in any of the mux algorithms.')
prtExVc2TransGain = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 5, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVc2TransGain.setStatus('mandatory')
if mibBuilder.loadTexts: prtExVc2TransGain.setDescription('Transmit gain in dBm. For ports of VC-6A and VC-6AG cards, the units will be 0.1dBm because valid values can be in 0.5dBm steps.')
prtExVc2ReceiveGain = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 5, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVc2ReceiveGain.setStatus('mandatory')
if mibBuilder.loadTexts: prtExVc2ReceiveGain.setDescription('Receive gain in dBm. For ports of VC-6A and VC-6AG cards, the units will be 0.1dBm because valid values can be in 0.5dBm steps.')
prtExVc2Wire = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 5, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("w2wire", 1), ("w4wire", 2), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVc2Wire.setStatus('mandatory')
if mibBuilder.loadTexts: prtExVc2Wire.setDescription('This object is equal for all the ports in the specific card because of HW limitations. For FXO & FXS this parameter is not applicable.')
prtExVc2CodingLaw = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 5, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("aLAW", 1), ("uLAW", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVc2CodingLaw.setStatus('mandatory')
if mibBuilder.loadTexts: prtExVc2CodingLaw.setDescription('This attribute indicates the Method/Law for decoding/encoding the voice information. aLaw(1) is the standard Law for E1 links. uLaw(2) is the standard Law for T1 links. This object is equal for all the ports in the specific module because of HW limitations')
prtExVc2Sig = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 5, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("noSignaling", 1), ("robbedBitMultiFrame", 2), ("chAssociatedE1", 3), ("robbedBitFrame", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVc2Sig.setStatus('mandatory')
if mibBuilder.loadTexts: prtExVc2Sig.setDescription('This attribute indicates the method for decoding/encoding the signaling information(on/off hook). noSignaling (1) - not using signaling (only voice). robbedBitMultiFrame(2) - is the standard method for T1 links and proprietary method for E1 links. chAssociatedE1 (3) - is valid only for E1 G.732S links. robbedBitFrame (4) - is proprietary method implimenting 7 bit for the voice and 1 bit dedicated for signaling. This object is equal for all the ports in the specific module because of HW limitations.')
prtExVc2Oos = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 5, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("forcedIdle", 1), ("forcedBusy", 2), ("busyIdle", 3), ("idleBusy", 4), ("notApplicable", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVc2Oos.setStatus('mandatory')
if mibBuilder.loadTexts: prtExVc2Oos.setDescription('This object is equal for all the ports in the specific card because of HW limitations')
prtExVc2LinkTo = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 5, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVc2LinkTo.setStatus('deprecated')
if mibBuilder.loadTexts: prtExVc2LinkTo.setDescription('This attribute indicates the slot of the ML card to which the VC card is mapped. STATUS deprecated - this object is replaced by prtGenCnfgLinkToSlot and prtGenCnfgLinkToPort.')
prtExVc2OperMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 5, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("normal", 2), ("unidirectRx", 3), ("broadcast", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVc2OperMode.setStatus('mandatory')
if mibBuilder.loadTexts: prtExVc2OperMode.setDescription('This object indicates the operation mode of the port. normal = bi-directional (Tx/Rx) unidirectRx = unidirectional Rx. broadcast = Tx upon request.')
prtExVc2SigProfile = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 5, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("notApplicable", 1), ("manual", 2), ("p1", 3), ("p2", 4), ("p3Fxo3S3", 5), ("reversePolarity", 6), ("meteringPulse", 7), ("p4", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVc2SigProfile.setStatus('mandatory')
if mibBuilder.loadTexts: prtExVc2SigProfile.setDescription('This object indicates the Signaling Profile of the port. notApplicable - for VC-2 family and when prtExVc2Sig=noSignaling(1) p1 = profile 1 p2 = profile 2 p3 = profile 3 p4 = profile 4 ')
prtExVc2CallEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 5, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("incoming", 2), ("outgoing", 3), ("both", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVc2CallEnable.setStatus('mandatory')
if mibBuilder.loadTexts: prtExVc2CallEnable.setDescription('This object indicates the Enabled Call direction. notApplicable - for all cards except VC-2/R2. both - incoming + outgoing.')
prtExVc2R2Delay = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 5, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("terrestrial", 2), ("satellite", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVc2R2Delay.setStatus('mandatory')
if mibBuilder.loadTexts: prtExVc2R2Delay.setDescription('This object indicates the R2 Delay. notApplicable - for all cards except VC-2/R2.')
prtExVc2CasStd = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 5, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("notApplicable", 1), ("r2Q422", 2), ("specialA", 3), ("specialB", 4), ("specialC", 5), ("specialD", 6), ("specialE", 7), ("specialF", 8), ("specialG", 9)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVc2CasStd.setStatus('mandatory')
if mibBuilder.loadTexts: prtExVc2CasStd.setDescription('This object indicates the CAS (Channel Associated Signaling) Standard. notApplicable - for all cards except VC-2/R2.')
prtExVc2EchoCanceler = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 5, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVc2EchoCanceler.setStatus('mandatory')
if mibBuilder.loadTexts: prtExVc2EchoCanceler.setDescription('Echo canceler activation. notApplicable - for VC-2 and VC-6 cards.')
prtExVc2IfType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 5, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notApplicable", 1), ("w2Em", 2), ("w4Em", 3), ("fxo", 4), ("fxs", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVc2IfType.setStatus('mandatory')
if mibBuilder.loadTexts: prtExVc2IfType.setDescription('Interface Type.')
prtExVc2Encoding = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 5, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("pcm", 2), ("adpcm", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVc2Encoding.setStatus('mandatory')
if mibBuilder.loadTexts: prtExVc2Encoding.setDescription('Voice Encoding Mode.')
prtExVc2TxBitCode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 5, 1, 20), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVc2TxBitCode.setStatus('mandatory')
if mibBuilder.loadTexts: prtExVc2TxBitCode.setDescription(' - - - For MP & FCD - - - This object represents 4 parameters, by 2 Octets : Tx D Bit Code-MSB nibble, Tx C Bit Code- nibble, Tx B Bit Code- nibble, Tx A Bit Code-LSB nibble. Each nibble: 0 hex = 0000 = Not Applicable 1 hex = 0001 = M lead 2 hex = 0010 = M lead inverse 3 hex = 0011 = Reverse Polarity 4 hex = 0100 = Metering Pulse 5 hex = 0101 = Forced 1 6 hex = 0110 = Forced 0 7-F hex - not used (invalid values) This object will be RO if prtExVc2SigProfile is NOT manual. - - - For WR II - - - This object represents the following 4 parameters by 2 Octets: 1. On/Off hook signaling transmission mode from the FXS towards the T1/E1 (MSB nibble 1). 2. Default signaling bits that are not in use (nibble 2). 3. Ring Detection signaling transmission mode from the FXO towards the T1/E1(nibble 3). 4. M (Mouth) Signaling transmission mode from the E&M towards the T1/E1(LSB nibble 4). Each nibble: --------------------------------------------------------------------------------------- Value On/Off Hook Default sig. Ring Detect. M (Mouth) --------------------------------------------------------------------------------------- 0 hex = 0000 Not Applicable Not Applicable. Not Applicable Not Applicable 1 hex = 0001 Tx A bit Values 1-3 are Tx A bit Tx A bit 2 hex = 0010 Tx A bit inverse for On/Off Hook Tx A bit inv. Tx A bit inv. 3 hex = 0011 Tx B bit A,B,A Inv,B Inv. Tx B bit Tx B bit 4 hex = 0100 Tx B bit inverse Values 4-7 are Tx B bit inv. Tx B bit inv. 5 hex = 0101 not Used-invalid for On/Off Hook not Used-invalid not Used-invalid 6 hex = 0110 not Used-invalid A, A Inverse. not Used-invalid not Used-invalid 7 hex = 0111 not Used-invalid not Used-invalid not Used-invalid 8 hex = 1000 not Used-invalid Values 8-11 are not Used-invalid not Used-invalid 9 hex = 1001 not Used-invalid for On/Off Hook not Used-invalid not Used-invalid A hex = 1010 not used-invalid B, B Inverse. not Used-invalid not Used-invalid B hex = 1011 not used-invalid The Bits order: not Used-invalid not Used-invalid C-F hex not used-invalid ABCD not Used-invalid not Used-invalid Default value: 11 11 ')
prtExVc2RxBitOutput = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 5, 1, 21), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVc2RxBitOutput.setStatus('mandatory')
if mibBuilder.loadTexts: prtExVc2RxBitOutput.setDescription(' - - - For MP & FCD - - - This object represents 3 parameters by 2 Octets: Spare -MSB nibble, always=0 hex E Lead Output - nibble, Reverse Polarity Output- nibble, Metering Pulse Output -LSB nibble. Each nibble: 0 hex = 0000 = Not Applicable 1 hex = 0001 = Rx A bit 2 hex = 0010 = Rx A bit inverse 3 hex = 0011 = Rx B bit 4 hex = 0100 = Rx B bit inverse 5 hex = 0101 = Rx C bit 6 hex = 0110 = Rx C bit inverse 7 hex = 0111 = Rx D bit 8 hex = 1000 = Rx D bit inverse 9 hex = 1001 = none A-F hex - not used (invalid values) This object will be RO if prtExVc2SigProfile is NOT manual. - - - For WR II - - - This object represents the following 2 parameters in 1 Octet: 1. On/Off hook signaling receive mode from the T1/E1 into the FXS/FXO (MSB nibble 1). 2. E (Ear) Signaling receive mode from the T1/E1 into the E&M (LSB nibble 2). Each nibble: --------------------------------------------------------------------------------------- Value On/Off Hook E (Ear) --------------------------------------------------------------------------------------- 0 hex = 0000 Not Applicable Not Applicable 1 hex = 0001 Rx A bit Rx A bit 2 hex = 0010 Rx A bit inverse Rx A bit inverse 3 hex = 0011 Rx B bit Rx B bit 4 hex = 0100 Rx B bit inverse Rx B bit inverse 5-F hex not used-invalid not Used-invalid Default value: 11 ')
prtExVc2MeterRate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 5, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("r16Khz", 2), ("r12Khz", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVc2MeterRate.setStatus('mandatory')
if mibBuilder.loadTexts: prtExVc2MeterRate.setDescription("This entry is applicable only for VC-6A/FXO and VC-6A/FXS. Meter Rate means rate of Call Meter in Public Phones, in KHz units. Must be the same for all card's ports.")
prtExVc2IfSignaling = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 5, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("loopStart", 2), ("groundStart", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVc2IfSignaling.setStatus('mandatory')
if mibBuilder.loadTexts: prtExVc2IfSignaling.setDescription("This entry is applicable only for VC-6A and VC-6AG cards. Interface Analog Signaling. Must be the same for all card's ports. loopStart - for the usual trunk/phone types. groundStart - for trunks that need Ground signaling (applicable for VC-6AG cards.")
prtExVc2SeizeAck = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 5, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVc2SeizeAck.setStatus('mandatory')
if mibBuilder.loadTexts: prtExVc2SeizeAck.setDescription('This parameter shows whether the device will acknowledge a seize signal (On/Off Hook). When the value is set to yes(3) & the device receives an on/off hook signal it will transmit back an on/off hook signal. When the value is set to no(2) & the device receives an on/off hook signal it will NOT transmit back an on/off hook signal. Default value for WR FXO: no(2).')
prtExVc2EandMType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 5, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notApplicable", 1), ("type1", 2), ("type2", 3), ("type3", 4), ("type5", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVc2EandMType.setStatus('mandatory')
if mibBuilder.loadTexts: prtExVc2EandMType.setDescription('This is the signaling type on the E&M analog side. The analog signaling includes voltage, no. of pins and other parameters.')
prtHsfCnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 6), )
if mibBuilder.loadTexts: prtHsfCnfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtHsfCnfgTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry.')
prtHsfCnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 6, 1), ).setIndexNames((0, "DACS-MIB", "prtHsfCnfgIdx"), (0, "DACS-MIB", "prtHsfSltIdx"), (0, "DACS-MIB", "prtHsfPrtIdx"))
if mibBuilder.loadTexts: prtHsfCnfgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtHsfCnfgEntry.setDescription('')
prtHsfCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtHsfCnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtHsfCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relate to the TmpCnfg. ')
prtHsfSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtHsfSltIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtHsfSltIdx.setDescription('This attribute indicates a unique slot position where the card is inserted. In the ?004 Unit the entries io6(10)..io16) are not valid.')
prtHsfPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("exPrt1", 1), ("exPrt2", 2), ("exPrt3", 3), ("exPrt4", 4), ("exPrt5", 5), ("exPrt6", 6), ("exPrt7", 7), ("exPrt8", 8), ("exPrt9", 9), ("exPrt10", 10), ("exPrt11", 11), ("exPrt12", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtHsfPrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtHsfPrtIdx.setDescription('This attribute indicates a unique external port index. Hs2 has only two ports (exPrt1,exPrt2). Hs3 has three ports (exPrt1,exPrt2,exPrt3). Hsq and hsqN has four ports. Hs6 has six external ports. Hs12 has twelve external ports.')
prtExHsfConnect = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 6, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHsfConnect.setStatus('mandatory')
if mibBuilder.loadTexts: prtExHsfConnect.setDescription('This attribute indicates whether the port should be considered in any of the mux algorithms.')
prtExHsfRate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 6, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63))).clone(namedValues=NamedValues(("r1x56eq56Kbps", 1), ("r1x64eq64Kbps", 2), ("r2x56eq112Kbps", 3), ("r2x64eq128Kbps", 4), ("r3x56eq168Kbps", 5), ("r3x64eq192Kbps", 6), ("r4x56eq224Kbps", 7), ("r4x64eq256Kbps", 8), ("r5x56eq280Kbps", 9), ("r5x64eq320Kbps", 10), ("r6x56eq336Kbps", 11), ("r6x64eq384Kbps", 12), ("r7x56eq392Kbps", 13), ("r7x64eq448Kbps", 14), ("r8x56eq448Kbps", 15), ("r8x64eq512Kbps", 16), ("r9x56eq504Kbps", 17), ("r9x64eq576Kbps", 18), ("r10x56eq560Kbps", 19), ("r10x64eq640Kbps", 20), ("r11x56eq616Kbps", 21), ("r11x64eq704Kbps", 22), ("r12x56eq672Kbps", 23), ("r12x64eq768Kbps", 24), ("r13x56eq728Kbps", 25), ("r13x64eq832Kbps", 26), ("r14x56eq784Kbps", 27), ("r14x64eq896Kbps", 28), ("r15x56eq840Kbps", 29), ("r15x64eq960Kbps", 30), ("r16x56eq896Kbps", 31), ("r16x64eq1024Kbps", 32), ("r17x56eq952Kbps", 33), ("r17x64eq1088Kbps", 34), ("r18x56eq1008Kbps", 35), ("r18x64eq1152Kbps", 36), ("r19x56eq1064Kbps", 37), ("r19x64eq1216Kbps", 38), ("r20x56eq1120Kbps", 39), ("r20x64eq1280Kbps", 40), ("r21x56eq1176Kbps", 41), ("r21x64eq1344Kbps", 42), ("r22x56eq1232Kbps", 43), ("r22x64eq1408Kbps", 44), ("r23x56eq1288Kbps", 45), ("r23x64eq1472Kbps", 46), ("r24x56eq1344Kbps", 47), ("r24x64eq1536Kbps", 48), ("r25x56eq1400Kbps", 49), ("r25x64eq1600Kbps", 50), ("r26x56eq1456Kbps", 51), ("r26x64eq1664Kbps", 52), ("r27x56eq1512Kbps", 53), ("r27x64eq1728Kbps", 54), ("r28x56eq1568Kbps", 55), ("r28x64eq1792Kbps", 56), ("r29x56eq1624Kbps", 57), ("r29x64eq1856Kbps", 58), ("r30x56eq1680Kbps", 59), ("r30x64eq1920Kbps", 60), ("r31x56eq1736Kbps", 61), ("r31x64eq1984Kbps", 62), ("r32Kbps", 63)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHsfRate.setStatus('mandatory')
if mibBuilder.loadTexts: prtExHsfRate.setDescription('This attribute indicates the port speed. ')
prtExHsfClkMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 6, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("dce", 1), ("ext-dce", 2), ("dte", 3), ("none", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHsfClkMode.setStatus('mandatory')
if mibBuilder.loadTexts: prtExHsfClkMode.setDescription('This attribute indicates a unique port operation clock mode.')
prtExHsfCts = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 6, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("on", 2), ("rts", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHsfCts.setStatus('mandatory')
if mibBuilder.loadTexts: prtExHsfCts.setDescription('This attribute indicates a unique CTS control line operation mode.')
prtExHsfFifoSize = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 6, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("auto", 2), ("s16bits", 3), ("s30bits", 4), ("s52bits", 5), ("s72bits", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHsfFifoSize.setStatus('mandatory')
if mibBuilder.loadTexts: prtExHsfFifoSize.setDescription('Size in bits.')
prtExHsfLinkTo = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 6, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHsfLinkTo.setStatus('deprecated')
if mibBuilder.loadTexts: prtExHsfLinkTo.setDescription('This attribute indicates a slot of Main Link module, that the port is linked to. This object is the same for all the ports in the specific card because of HW limitations. STATUS deprecated - this object is replaced by prtGenCnfgLinkToSlot and prtGenCnfgLinkToPort.')
prtExHsfOperMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 6, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("normal", 2), ("unidirectRx", 3), ("broadcast", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHsfOperMode.setStatus('mandatory')
if mibBuilder.loadTexts: prtExHsfOperMode.setDescription('This object indicates the operation mode of the port. normal = bi-directional (Tx/Rx) unidirectRx = unidirectional Rx. broadcast = Tx upon request.')
prtExHsfInbandLoopback = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 6, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("disabled", 2), ("ft1Enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHsfInbandLoopback.setStatus('mandatory')
if mibBuilder.loadTexts: prtExHsfInbandLoopback.setDescription('This object indicates if Inband Loopback from the Network should be enabled or disabled.')
prtExHsfClkPolarity = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 6, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("normal", 2), ("invert", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHsfClkPolarity.setStatus('mandatory')
if mibBuilder.loadTexts: prtExHsfClkPolarity.setDescription('This object indicates the clock polarity. For FCD-M this object will be applicable only for the fixed HS port (the fixed port on the device).')
prtExHs4CnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 7, 1), )
if mibBuilder.loadTexts: prtExHs4CnfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtExHs4CnfgTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry.')
prtExHs4CnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 7, 1, 1), ).setIndexNames((0, "DACS-MIB", "prtExHs4CnfgIdx"), (0, "DACS-MIB", "prtExHs4SltIdx"), (0, "DACS-MIB", "prtExHs4PrtIdx"))
if mibBuilder.loadTexts: prtExHs4CnfgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtExHs4CnfgEntry.setDescription('')
prtExHs4CnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 7, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExHs4CnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtExHs4CnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg')
prtExHs4SltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 7, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExHs4SltIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtExHs4SltIdx.setDescription('This attribute indicates a unique slot position where the card is inserted.')
prtExHs4PrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 7, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("exPrt1", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExHs4PrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtExHs4PrtIdx.setDescription('A unique identifier of the port, within the card.')
prtExHs4Connect = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 7, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHs4Connect.setStatus('mandatory')
if mibBuilder.loadTexts: prtExHs4Connect.setDescription('This attribute indicates whether the port should be considered in any of the mux algorithm. It also affects all the module considerations because the card has only one external (physical) interface.')
prtExHs4LineType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 7, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("esfT1", 2), ("sfT1", 3), ("g732nE1", 4), ("g732nE1CRC", 5), ("g732sE1", 6), ("g732sE1CRC", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHs4LineType.setStatus('mandatory')
if mibBuilder.loadTexts: prtExHs4LineType.setDescription('This attribute is the line type parameter for T1/E1 interface. The user should select only the parameters relevant to the specific card: T1 line code parameters for the HS-4/1 and E1 line code parameters for the HS-4/2. This parameter has the same values as dsx1LineType in T1/E1 MIB (RFC-1406). The parameters in dsx1LineType are: other (1) dsx1ESF (2) dsx1D4 (3) dsx1E1 (4) dsx1E1-CRC (5) dsx1E1-MF (6) dsx1E1-MF-CRC (7)')
prtExHs4LineCode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 7, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4))).clone(namedValues=NamedValues(("b7T1", 1), ("b8zsT1", 2), ("hdb3E1", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHs4LineCode.setStatus('mandatory')
if mibBuilder.loadTexts: prtExHs4LineCode.setDescription('This attribute is the line code parameter used for T1/E1 interface. The user should select only the parameters relevant to the specific card: T1 line code parameters for the MPH.1/T1 and E1 line code parameters for the MPH.1/E1. This parameter has the same values as dsx1LineCoding in T1/E1 MIB (RFC-1406). The parameters in dsx1LineCoding are: dsx1JBZS (1) dsx1B8ZS (2) dsx1HDB3 (3) dsx1ZBTSI (4) dsx1AMI (5) other (6)')
prtExHs4LineLen = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 7, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("unknown", 1), ("len0p133ft", 2), ("len134p266ft", 3), ("len267p399ft", 4), ("len400p533ft", 5), ("len534p655ft", 6), ("fcc68", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHs4LineLen.setStatus('mandatory')
if mibBuilder.loadTexts: prtExHs4LineLen.setDescription('This attribute is the line length parameter used only for T1 interfaces. len399p533ft=len-399-533ft ')
prtExHs4RestoreT = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 7, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("restoreT1secFast", 2), ("restoreT10sec62411", 3), ("ccittE1", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHs4RestoreT.setStatus('mandatory')
if mibBuilder.loadTexts: prtExHs4RestoreT.setDescription('Time passing from the disappearance of the loss of synchronization condition (red alarm), to the restoration of normal service.')
prtExHs4OosSig = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 7, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("notsupported", 2), ("forcedIdle", 3), ("forcedBusy", 4), ("busyIdle", 5), ("idleBusy", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHs4OosSig.setStatus('mandatory')
if mibBuilder.loadTexts: prtExHs4OosSig.setDescription('Out of Service signal type.')
prtExHs4OosCode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 7, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("notsupported", 2), ("oosCode00H", 3), ("oosCode1aH", 4), ("oosCode54H", 5), ("oosCode7eH", 6), ("oosCode7fH", 7), ("oosCode98H", 8), ("oosCode9eH", 9), ("oosCoded5H", 10), ("oosCodee4H", 11), ("oosCodeffH", 12)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHs4OosCode.setStatus('mandatory')
if mibBuilder.loadTexts: prtExHs4OosCode.setDescription('OOS Code')
prtExHs4IdleCode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 7, 1, 1, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHs4IdleCode.setStatus('mandatory')
if mibBuilder.loadTexts: prtExHs4IdleCode.setDescription(' Type value(00 - FF HEX), excluding 0H,8H,10H,12H,21H,24H, 42H,49H,84H,92H')
prtExHs4MfClkSrcSlt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 7, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("local", 2), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHs4MfClkSrcSlt.setStatus('mandatory')
if mibBuilder.loadTexts: prtExHs4MfClkSrcSlt.setDescription("This attribute indicates whether the port Tx is multiframe synchronized with Rx multiframe of another port and the slot position of that port. This opration is required in order to bypass signaling of PCM voice channels. When its value is Local(2) there is no meaning to 'prtExHs4MfClkSrcPrt' parameter. In the ?004 Unit the entries io6(10)..io16) are not valid")
prtExHs4MfClkSrcPrt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 7, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 101))).clone(namedValues=NamedValues(("exPrt1", 1), ("exPrt2", 2), ("inPrt1", 101)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHs4MfClkSrcPrt.setStatus('mandatory')
if mibBuilder.loadTexts: prtExHs4MfClkSrcPrt.setDescription('A unique number to identify a port position in the mux if the MultiFrame clock source is valid (YES). inPrt1 - for MTML-H/E1 cards.')
prtExHs4TsCnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 7, 2), )
if mibBuilder.loadTexts: prtExHs4TsCnfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtExHs4TsCnfgTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry.')
prtExHs4TsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 7, 2, 1), ).setIndexNames((0, "DACS-MIB", "prtExHs4TsCnfgIdx"), (0, "DACS-MIB", "prtExHs4TsSltIdx"), (0, "DACS-MIB", "prtExHs4TsPrtIdx"), (0, "DACS-MIB", "prtExHs4TsIdx"))
if mibBuilder.loadTexts: prtExHs4TsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtExHs4TsEntry.setDescription('')
prtExHs4TsCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 7, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExHs4TsCnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtExHs4TsCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg. ')
prtExHs4TsSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 7, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExHs4TsSltIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtExHs4TsSltIdx.setDescription('This attribute indicates a unique slot position where the card is inserted. In the ?004 Unit the entries io6(10)..io16) are not valid')
prtExHs4TsPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 7, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("exPrt1", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExHs4TsPrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtExHs4TsPrtIdx.setDescription('This attribute indicates a unique port number. Hs4/T1 and Hs4/T1 cards have only one external interface.')
prtExHs4TsIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 7, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExHs4TsIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtExHs4TsIdx.setDescription('This attribute indicates a unique time slot position. The valid time slots are: 1..24 for T1 Card and 1..31 for E1 interface. In G732S-E1 lines, time slot 16 is not valid for data, it is dedicated to multiframe synchronization bits and voice signaling.')
prtExHs4TsIConSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 7, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 100))).clone(namedValues=NamedValues(("noConnect", 2), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("split", 100)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHs4TsIConSlot.setStatus('mandatory')
if mibBuilder.loadTexts: prtExHs4TsIConSlot.setDescription('This attribute indicates whether the specified time slot is connected/routed internally in the Agent and to which card it is connected. In the ?004 Unit the entries io6(10)..io16) are not valid. split - will be used when the Src TS is connected to more than one slot OR more than one port (each needing less than a whole TS).')
prtExHs4TsIConPrt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 7, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 100))).clone(namedValues=NamedValues(("exPrt1", 1), ("exPrt2", 2), ("exPrt3", 3), ("exPrt4", 4), ("exPrt5", 5), ("exPrt6", 6), ("exPrt7", 7), ("exPrt8", 8), ("exPrt9", 9), ("exPrt10", 10), ("exPrt11", 11), ("exPrt12", 12), ("noConnect", 100)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHs4TsIConPrt.setStatus('mandatory')
if mibBuilder.loadTexts: prtExHs4TsIConPrt.setDescription('This attribute indicates the internally (In Mux) connected/routed port.')
prtExHs4TsIConTs = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 7, 2, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHs4TsIConTs.setStatus('mandatory')
if mibBuilder.loadTexts: prtExHs4TsIConTs.setDescription('This attribute indicates a unique time slot position. The valid time slots are: 1..24 for T1 Module and 1..31 for E1 interface. In G732S-E1 lines time slot 16 is not valid for data, it is dedicated for multiframe synchronization bits and voice signaling.')
prtExHsiCnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 8, 1), )
if mibBuilder.loadTexts: prtExHsiCnfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtExHsiCnfgTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry.')
prtExHsiCnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 8, 1, 1), ).setIndexNames((0, "DACS-MIB", "prtExHsiCnfgIdx"), (0, "DACS-MIB", "prtExHsiSltIdx"), (0, "DACS-MIB", "prtExHsiPrtIdx"))
if mibBuilder.loadTexts: prtExHsiCnfgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtExHsiCnfgEntry.setDescription('')
prtExHsiCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 8, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExHsiCnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtExHsiCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg')
prtExHsiSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 8, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExHsiSltIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtExHsiSltIdx.setDescription('This attribute indicates a unique slot position where the card is inserted.')
prtExHsiPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 8, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("exPrt1", 1), ("exPrt2", 2), ("exPrt3", 3), ("exPrt4", 4), ("exPrt5", 5), ("exPrt6", 6), ("exPrt7", 7), ("exPrt8", 8), ("exPrt9", 9), ("exPrt10", 10), ("exPrt11", 11), ("exPrt12", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExHsiPrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtExHsiPrtIdx.setDescription('A unique prt identifier within the card.')
prtExHsiConnect = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 8, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("no", 2), ("yes", 3), ("v51", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHsiConnect.setStatus('mandatory')
if mibBuilder.loadTexts: prtExHsiConnect.setDescription("This attribute indicates whether the port should be considered in any of the mux algorithms. v51 - this port is connected to a V5.1 interface. All rest of the values will be 'notApplicable' in this case. V5.1 MIB will be used instead.")
prtExHsiRate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 8, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 255))).clone(namedValues=NamedValues(("r600bps", 2), ("r1200bps", 3), ("r2400bps", 4), ("r4800bps", 5), ("r9600bps", 6), ("r19200bps", 7), ("r38400bps", 8), ("r48kbps", 9), ("r56kbps", 10), ("r64kbps", 11), ("r128kbps", 12), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHsiRate.setStatus('mandatory')
if mibBuilder.loadTexts: prtExHsiRate.setDescription('This attribute indicates the port speed.')
prtExHsiLinkTo = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 8, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHsiLinkTo.setStatus('deprecated')
if mibBuilder.loadTexts: prtExHsiLinkTo.setDescription('It indicates the slot of the main link card to which the HS-? card is mapped. STATUS deprecated - this object is replaced by prtGenCnfgLinkToSlot and prtGenCnfgLinkToPort.')
prtExHsiInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 8, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 255))).clone(namedValues=NamedValues(("lt", 1), ("nt", 2), ("te", 3), ("lt1", 4), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHsiInterface.setStatus('mandatory')
if mibBuilder.loadTexts: prtExHsiInterface.setDescription("It indicates the interface type: lt = line termination nt = network termination te = terminal equipment. lt1 - for ASMi-31 connection (not ISDN) For HS-U/I and HS-U/1 only 'lt' and 'nt' are applicable. For HS-S , only 'te' and 'nt' are applicable. For HS-U, this object is not applicable. For HS-U6, HS-U12, are applicable: 'lt'=lt-i,'nt'=nt-i, lt1.")
prtExHsiActType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 8, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("type1", 2), ("type2", 3), ("type3", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHsiActType.setStatus('mandatory')
if mibBuilder.loadTexts: prtExHsiActType.setDescription('It indicates the Activation Type. Activation Type is the Synchronization type towards the PBX. It is applicable only when prtExHsiInterface=nt. notApplicable - for cards that do not support this object, or when prtExHsiInterface is NOT nt.')
prtInHsiCnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 8, 2), )
if mibBuilder.loadTexts: prtInHsiCnfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtInHsiCnfgTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry. This table is not applicable for HS-U card type.')
prtInHsiCnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 8, 2, 1), ).setIndexNames((0, "DACS-MIB", "prtInHsiCnfgIdx"), (0, "DACS-MIB", "prtInHsiSltIdx"), (0, "DACS-MIB", "prtInHsiPrtIdx"))
if mibBuilder.loadTexts: prtInHsiCnfgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtInHsiCnfgEntry.setDescription('')
prtInHsiCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 8, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtInHsiCnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtInHsiCnfgIdx.setDescription('This object indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg')
prtInHsiSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 8, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtInHsiSltIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtInHsiSltIdx.setDescription('This object indicates a unique slot position where the card is inserted.')
prtInHsiPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 8, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtInHsiPrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtInHsiPrtIdx.setDescription('A unique port identifier within the card. Valid values: inPrt1 (101) .. inPrt48 (148).')
prtInHsiConnect = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 8, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInHsiConnect.setStatus('mandatory')
if mibBuilder.loadTexts: prtInHsiConnect.setDescription('This attribute indicates whether the port should be considered in any of the mux algorithms.')
prtInHsiRate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 8, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 255))).clone(namedValues=NamedValues(("r600bps", 2), ("r1200bps", 3), ("r2400bps", 4), ("r4800bps", 5), ("r9600bps", 6), ("r19200bps", 7), ("r38400bps", 8), ("r48kbps", 9), ("r56kbps", 10), ("r64kbps", 11), ("r128kbps", 12), ("concentrated", 13), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInHsiRate.setStatus('mandatory')
if mibBuilder.loadTexts: prtInHsiRate.setDescription('This object indicates the port speed. For HS-U/I and HS-S ports: 2 bit - up to 9600bps 4 bit - 19200bps 8 bit - 38400bps .. 64kbps. concentrated - this D channel goes to a Concentration channel, that represents many channels that this value was selected for them. The Concentrated channel is an Internal D Channel of the same card. This value is applicable only for D channels, except Concentration channel itself. --for HS-S and HS-U/I cards the Concentration channel will always be: internal-13 --for HS-S12, HS-S6, HS-U12, HS-U6, the Concentration channel is selected via the prtInHsiConcentratedTo object.')
prtInHsiConcentratedTo = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 8, 2, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInHsiConcentratedTo.setStatus('mandatory')
if mibBuilder.loadTexts: prtInHsiConcentratedTo.setDescription('The Concentration D Channel of the prtInHsiPrtIdx port. The port always belongs to the same card as prtInHsiPrtIdx port. This object is applicable only when prtInHsiRate=concentrated. Valid values: - notApplicable: 255 - for HS-S12, HS-U12 cards: inPrt37 (137) .. inPrt48 (148).')
prtExHsrCnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 10, 1), )
if mibBuilder.loadTexts: prtExHsrCnfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtExHsrCnfgTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry.')
prtExHsrCnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 10, 1, 1), ).setIndexNames((0, "DACS-MIB", "prtExHsrCnfgIdx"), (0, "DACS-MIB", "prtExHsrSltIdx"), (0, "DACS-MIB", "prtExHsrPrtIdx"))
if mibBuilder.loadTexts: prtExHsrCnfgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtExHsrCnfgEntry.setDescription('')
prtExHsrCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 10, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExHsrCnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtExHsrCnfgIdx.setDescription('This object indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg')
prtExHsrSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 10, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExHsrSltIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtExHsrSltIdx.setDescription('This object indicates a unique slot position where the card is inserted.')
prtExHsrPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 10, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExHsrPrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtExHsrPrtIdx.setDescription('A unique prt identifier within the card. Valid values: - For HS-R cards: exPrt1 (1) .. exPrt4 (4) - For HS-U/1 cards: inPrt1 (101) .. inPrt4 (104) - For HS-S12, HS-S6, HS-U12, HS-U6 cards: exPrt1 (1) .. exPrt12 (12). This MIB table is used only for LT-1 interface. ')
prtExHsrConnect = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 10, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHsrConnect.setStatus('mandatory')
if mibBuilder.loadTexts: prtExHsrConnect.setDescription('This object indicates whether the port should be considered in any of the mux algorithms.')
prtExHsrProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 10, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("sync", 2), ("async", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHsrProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: prtExHsrProtocol.setDescription('This object indicates the protocol.')
prtExHsrRate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 10, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("r600bps", 2), ("r1200bps", 3), ("r2400bps", 4), ("r4800bps", 5), ("r9600bps", 6), ("r19200bps", 7), ("r38400bps", 8), ("r48kbps", 9), ("r56kbps", 10), ("r64kbps", 11), ("r16000bps", 12), ("r32000bps", 13), ("r57600bps", 14), ("r115200bps", 15), ("r128000bps", 16)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHsrRate.setStatus('mandatory')
if mibBuilder.loadTexts: prtExHsrRate.setDescription('This object indicates the port speed. The 16,32,48,56,64 and 128 kbps rates are applicable only for Sync protocol. The 57.6 and 115.2 kbps rates are applicable only for Async protocol.')
prtExHsrDataBits = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 10, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 255))).clone(namedValues=NamedValues(("d5bits", 1), ("d6bits", 2), ("d7bits", 3), ("d8bits", 4), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHsrDataBits.setStatus('mandatory')
if mibBuilder.loadTexts: prtExHsrDataBits.setDescription('Data Bits. This object is applicable for Async protocol only.')
prtExHsrParity = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 10, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 255))).clone(namedValues=NamedValues(("no", 2), ("yes", 3), ("odd", 4), ("even", 5), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHsrParity.setStatus('mandatory')
if mibBuilder.loadTexts: prtExHsrParity.setDescription("- For HS-R card, this object indicates if the parity bit is needed or not. Therefore, the 'no' and 'yes; values are applicable. - For HS-S12, HS-U12, the parity type is selected: no, odd, even. This object is applicable for Async protocol only.")
prtExHsrStopBits = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 10, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("stopBits1Bit", 1), ("stopBits2Bits", 2), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHsrStopBits.setStatus('mandatory')
if mibBuilder.loadTexts: prtExHsrStopBits.setDescription('This object indicates the minimum number of stop bits in the tx async frame. This object is applicable for Async protocol only.')
prtExHsrCts = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 10, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 255))).clone(namedValues=NamedValues(("on", 2), ("rts", 3), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHsrCts.setStatus('mandatory')
if mibBuilder.loadTexts: prtExHsrCts.setDescription('CTS. This object is applicable for Async protocol only.')
prtExHsrClkMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 10, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("dce", 1), ("extDce", 2), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHsrClkMode.setStatus('mandatory')
if mibBuilder.loadTexts: prtExHsrClkMode.setDescription('Clock mode. This object is applicable for Sync protocol only.')
prtExHsrLinkTo = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 10, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("notApplicable", 1), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHsrLinkTo.setStatus('deprecated')
if mibBuilder.loadTexts: prtExHsrLinkTo.setDescription('It indicates the slot of the main link card to which the HS-R card is mapped. notApplicable - for HS-U/1 internal ports. STATUS deprecated - this object is replaced by prtGenCnfgLinkToSlot and prtGenCnfgLinkToPort.')
prtExHsrDcdDsr = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 10, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("local", 2), ("endToEnd", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHsrDcdDsr.setStatus('mandatory')
if mibBuilder.loadTexts: prtExHsrDcdDsr.setDescription('DCD & DSR.')
prtExHsrOperMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 10, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("normal", 2), ("unidirectRx", 3), ("broadcast", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHsrOperMode.setStatus('mandatory')
if mibBuilder.loadTexts: prtExHsrOperMode.setDescription('This object indicates the operation mode of the port. normal = bi-directional (Tx/Rx) unidirectRx = unidirectional Rx. broadcast = Tx upon request.')
prtExHsrRtsDtr = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 10, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("local", 2), ("endToEnd", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHsrRtsDtr.setStatus('mandatory')
if mibBuilder.loadTexts: prtExHsrRtsDtr.setDescription('RTS & DTR.')
prtExHsrLlbEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 10, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHsrLlbEnable.setStatus('mandatory')
if mibBuilder.loadTexts: prtExHsrLlbEnable.setDescription('Enable/Disable LLB.')
prtExHsrRlbEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 10, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHsrRlbEnable.setStatus('mandatory')
if mibBuilder.loadTexts: prtExHsrRlbEnable.setDescription('Enable/Disable RLB.')
prtExHsrRateAdapt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 10, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("proprietary", 2), ("v110", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExHsrRateAdapt.setStatus('mandatory')
if mibBuilder.loadTexts: prtExHsrRateAdapt.setDescription('Rate Adaptation - takes a low rate and adapts it to 64Kbps. This object specifies the means this adaptation is done by.')
prtExMbeCnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 11, 1), )
if mibBuilder.loadTexts: prtExMbeCnfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtExMbeCnfgTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry.')
prtExMbeCnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 11, 1, 1), ).setIndexNames((0, "DACS-MIB", "prtExMbeCnfgIdx"), (0, "DACS-MIB", "prtExMbeSltIdx"), (0, "DACS-MIB", "prtExMbePrtIdx"))
if mibBuilder.loadTexts: prtExMbeCnfgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtExMbeCnfgEntry.setDescription('')
prtExMbeCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 11, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExMbeCnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtExMbeCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg')
prtExMbeSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 11, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExMbeSltIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtExMbeSltIdx.setDescription('This attribute indicates a unique slot position where the card is inserted. In the ?004 Unit the entries io6(10)..io16) are not valid.')
prtExMbePrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 11, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("exPrt1", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExMbePrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtExMbePrtIdx.setDescription('A unique port identifier within the card.')
prtExMbeLan = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 11, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("remote", 1), ("main", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExMbeLan.setStatus('mandatory')
if mibBuilder.loadTexts: prtExMbeLan.setDescription('This attribute indicates whether the MBE port is operated as main or remote bridge.')
prtInMbeCnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 11, 2), )
if mibBuilder.loadTexts: prtInMbeCnfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtInMbeCnfgTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry.')
prtInMbeCnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 11, 2, 1), ).setIndexNames((0, "DACS-MIB", "prtInMbeCnfgIdx"), (0, "DACS-MIB", "prtInMbeSltIdx"), (0, "DACS-MIB", "prtInMbePrtIdx"))
if mibBuilder.loadTexts: prtInMbeCnfgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtInMbeCnfgEntry.setDescription('')
prtInMbeCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 11, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtInMbeCnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtInMbeCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg')
prtInMbeSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 11, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtInMbeSltIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtInMbeSltIdx.setDescription('This attribute indicates a unique slot position where the card is inserted. In the ?004 Unit the entries io6(10)..io16) are not valid.')
prtInMbePrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 11, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(101))).clone(namedValues=NamedValues(("inPrt1", 101)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtInMbePrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtInMbePrtIdx.setDescription('A unique port identifier within the card.')
prtInMbeConnect = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 11, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInMbeConnect.setStatus('mandatory')
if mibBuilder.loadTexts: prtInMbeConnect.setDescription('This attribute indicates whether the port should be considered in any of the mux algorithms.')
prtInMbeRate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 11, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24))).clone(namedValues=NamedValues(("r1x64eq64Kbps", 1), ("r2x64eq128Kbps", 2), ("r3x64eq192Kbps", 3), ("r4x64eq256Kbps", 4), ("r5x64eq320Kbps", 5), ("r6x64eq384Kbps", 6), ("r7x64eq448Kbps", 7), ("r8x64eq512Kbps", 8), ("r9x64eq576Kbps", 9), ("r10x64eq640Kbps", 10), ("r11x64eq704Kbps", 11), ("r12x64eq768Kbps", 12), ("r13x64eq832Kbps", 13), ("r14x64eq896Kbps", 14), ("r15x64eq960Kbps", 15), ("r16x64eq1024Kbps", 16), ("r17x64eq1088Kbps", 17), ("r18x64eq1152Kbps", 18), ("r19x64eq1216Kbps", 19), ("r20x64eq1280Kbps", 20), ("r21x64eq1344Kbps", 21), ("r22x64eq1408Kbps", 22), ("r23x64eq1472Kbps", 23), ("r24x64eq1536Kbps", 24)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInMbeRate.setStatus('mandatory')
if mibBuilder.loadTexts: prtInMbeRate.setDescription('This attribute indicates the port speed.')
prtInMbeLinkTo = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 11, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInMbeLinkTo.setStatus('deprecated')
if mibBuilder.loadTexts: prtInMbeLinkTo.setDescription('It indicates the slot of the main link card to which the MBE card is mapped. In the ?004 Unit the entries io6(10)..io16) are not valid. STATUS deprecated - this object is replaced by prtGenCnfgLinkToSlot and prtGenCnfgLinkToPort.')
prtExTreCnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 12, 1), )
if mibBuilder.loadTexts: prtExTreCnfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtExTreCnfgTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry.')
prtExTreCnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 12, 1, 1), ).setIndexNames((0, "DACS-MIB", "prtExTreCnfgIdx"), (0, "DACS-MIB", "prtExTreSltIdx"), (0, "DACS-MIB", "prtExTrePrtIdx"))
if mibBuilder.loadTexts: prtExTreCnfgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtExTreCnfgEntry.setDescription('')
prtExTreCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 12, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExTreCnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtExTreCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg')
prtExTreSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 12, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExTreSltIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtExTreSltIdx.setDescription('This attribute indicates a unique slot position where the card is inserted. In the ?004 Unit the entries io6(10)..io16) are not valid.')
prtExTrePrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 12, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("exPrt1", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExTrePrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtExTrePrtIdx.setDescription('A unique port identifier within the card.')
prtExTreLan = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 12, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("remote", 1), ("main", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExTreLan.setStatus('mandatory')
if mibBuilder.loadTexts: prtExTreLan.setDescription('This attribute indicates whether the TRE port is operated as main or remote bridge. Default=remote.')
prtExTreLanRate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 12, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("r4M", 1), ("r16M", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExTreLanRate.setStatus('mandatory')
if mibBuilder.loadTexts: prtExTreLanRate.setDescription('This attribute indicates the Rate of the TRE port in Mbit/sec. Default-r4M.')
prtInTreCnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 12, 2), )
if mibBuilder.loadTexts: prtInTreCnfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtInTreCnfgTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry.')
prtInTreCnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 12, 2, 1), ).setIndexNames((0, "DACS-MIB", "prtInTreCnfgIdx"), (0, "DACS-MIB", "prtInTreSltIdx"), (0, "DACS-MIB", "prtInTrePrtIdx"))
if mibBuilder.loadTexts: prtInTreCnfgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtInTreCnfgEntry.setDescription('')
prtInTreCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 12, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtInTreCnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtInTreCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg')
prtInTreSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 12, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtInTreSltIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtInTreSltIdx.setDescription('This attribute indicates a unique slot position where the card is inserted. In the ?004 Unit the entries io6(10)..io16) are not valid.')
prtInTrePrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 12, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(101))).clone(namedValues=NamedValues(("inPrt1", 101)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtInTrePrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtInTrePrtIdx.setDescription('A unique port identifier within the card.')
prtInTreConnect = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 12, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInTreConnect.setStatus('mandatory')
if mibBuilder.loadTexts: prtInTreConnect.setDescription('This attribute indicates whether the port should be considered in any of the mux algorithms.')
prtInTreRate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 12, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17))).clone(namedValues=NamedValues(("r1x56eq56Kbps", 1), ("r1x64eq64Kbps", 2), ("r2x56eq112Kbps", 3), ("r2x64eq128Kbps", 4), ("r3x56eq168Kbps", 5), ("r3x64eq192Kbps", 6), ("r4x56eq224Kbps", 7), ("r4x64eq256Kbps", 8), ("r5x56eq280Kbps", 9), ("r5x64eq320Kbps", 10), ("r6x56eq336Kbps", 11), ("r6x64eq384Kbps", 12), ("r7x56eq392Kbps", 13), ("r7x64eq448Kbps", 14), ("r8x56eq448Kbps", 15), ("r8x64eq512Kbps", 16), ("r9x56eq504Kbps", 17)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInTreRate.setStatus('mandatory')
if mibBuilder.loadTexts: prtInTreRate.setDescription('This attribute indicates the port speed.')
prtInTreLinkTo = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 12, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInTreLinkTo.setStatus('deprecated')
if mibBuilder.loadTexts: prtInTreLinkTo.setDescription('It indicates the slot of the main link card to which the MBE card is mapped. In the ?004 Unit the entries io6(10)..io16) are not valid. STATUS deprecated - this object is replaced by prtGenCnfgLinkToSlot and prtGenCnfgLinkToPort.')
prtExPVc4CnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1), )
if mibBuilder.loadTexts: prtExPVc4CnfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPVc4CnfgTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry.')
prtExPVc4CnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1), ).setIndexNames((0, "DACS-MIB", "prtExPVc4CnfgIdx"), (0, "DACS-MIB", "prtExPVc4SltIdx"), (0, "DACS-MIB", "prtExPVc4PrtIdx"))
if mibBuilder.loadTexts: prtExPVc4CnfgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPVc4CnfgEntry.setDescription('')
prtExPVc4CnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExPVc4CnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPVc4CnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg')
prtExPVc4SltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExPVc4SltIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPVc4SltIdx.setDescription('This attribute indicates a unique slot position where the card is inserted.')
prtExPVc4PrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 101, 102, 103, 104))).clone(namedValues=NamedValues(("exPrt1", 1), ("exPrt2", 2), ("exPrt3", 3), ("exPrt4", 4), ("inPrt1", 101), ("inPrt2", 102), ("inPrt3", 103), ("inPrt4", 104)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExPVc4PrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPVc4PrtIdx.setDescription('This object indicates the port number in the selected card (slot).')
prtExPVc4PrtType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("eAndM", 1), ("fxo", 2), ("fxs", 3), ("internal", 4), ("s0", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExPVc4PrtType.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPVc4PrtType.setDescription('This object indicates the type of the selected port. In Mx 30/300: s0 is for Voice over ISDN.')
prtExPVc4Connect = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4Connect.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPVc4Connect.setDescription('This attribute indicates whether the port should be considered in any of the mux algorithms.')
prtExPVc4IfType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("unknown", 1), ("eAndM4wires", 2), ("eAndM2wires", 3), ("fxoGnd", 4), ("fxoLoop", 5), ("fxsGnd", 6), ("fxsLoop", 7), ("e1Framer", 8), ("e1Slave", 9), ("t1Framer", 10), ("t1Slave", 11)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExPVc4IfType.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPVc4IfType.setDescription('This attribute indicates the interface type of the port. eAndM4wires and eAndM2wires - are valid only for E&M port type eAndM4wires - means 2/4 wires fxoGnd and fxoLoop - are valid only for FXO port type fxsGnd and fxsLoop - are valid only for FXS port type e1Framer, e1Slave, t1Framer, t1Slave - are applicable for the mvc4Pbx cards only.')
prtExPVc4TxGain = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4TxGain.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPVc4TxGain.setDescription('Transmission gain in dBm.')
prtExPVc4RxGain = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4RxGain.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPVc4RxGain.setDescription('Reception gain in dBm.')
prtExPVc4MaxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notConnected", 1), ("r4800bps", 2), ("r7200bps", 3), ("r9600bps", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4MaxRate.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPVc4MaxRate.setDescription('Voice rate.')
prtExPVc4Tc = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("t1sec", 1), ("t2sec", 2), ("t3sec", 3), ("t4sec", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4Tc.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPVc4Tc.setDescription("Time interval for CIR control, in seconds. The value will be the same for all cards' ports.")
prtExPVc4Oos = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("notSupported", 2), ("forcedIdle", 3), ("forcedBusy", 4), ("busyIdle", 5), ("idleBusy", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4Oos.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPVc4Oos.setDescription('Handling type, when connection is lost.')
prtExPVc4EchoCanceler = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4EchoCanceler.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPVc4EchoCanceler.setDescription('Echo canceler activation.')
prtExPVc4VarDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 300))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4VarDelay.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPVc4VarDelay.setDescription('Maximum variant delay of the FR network, in msec.')
prtExPVc4CongLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 70))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4CongLevel.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPVc4CongLevel.setDescription('This object indicates the level of delayed data in precents of total available dynamic memory, for which the port will start to operate as congested. The resolution of the parameter is 5%.')
prtExPVc4Wire = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("w2wire", 1), ("w4wire", 2), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4Wire.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPVc4Wire.setDescription('This object indicates the wiring of the E&M port. It is applicable only for E&M card type.')
prtExPVc4ExtensionType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("forceConnect", 2), ("voiceSwitching", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4ExtensionType.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPVc4ExtensionType.setDescription('This object indicates the type of extension relevant to this port.')
prtExPVc4ExtensionNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 17), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4ExtensionNumber.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPVc4ExtensionNumber.setDescription('This is the extension number of this port. This field is relevant only when the extension type is voice switching and is read only if the port is member of a hunt group.')
prtExPVc4OutPulsing = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4OutPulsing.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPVc4OutPulsing.setDescription('This field indicates whether to outpulse the received digits. It is notApplicable(1) when the extension type is forceConnect(2).')
prtExPVc4HuntGroupMb = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4HuntGroupMb.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPVc4HuntGroupMb.setDescription('This object indicates if this port belongs to an hunt group.')
prtExPVc4HuntGroupIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4HuntGroupIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPVc4HuntGroupIdx.setDescription('If it belongs to an hunt group, this fields indicates the index of the relevant hunt group. 0 = notApplicable ')
prtExPVc4AutoFaxMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4AutoFaxMode.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPVc4AutoFaxMode.setDescription('This object indicates if the system will switch automatically to FAX mode when detecting FAX activity. Default=Yes.')
prtExPVc4FaxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notConnected", 1), ("r4800bps", 2), ("r7200bps", 3), ("r9600bps", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4FaxRate.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPVc4FaxRate.setDescription('FAX initial rate. Default=9600 bps.')
prtExPVc4SeizeAck = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4SeizeAck.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPVc4SeizeAck.setDescription("This parameter shows whether the device will acknowledge a seize signal (On/Off Hook). When the value is set to yes(3) & the device receives an on/off hook signal it will transmit back an on/off hook signal. When the value is set to no(2) & the device receives an on/off hook signal it will NOT transmit back an on/off hook signal. Example: If Seize Ack Parameter = YES, when the MVC.4 receives a seize signal (Off Hook) from the PBX it will send an Off Hook to the PBX. The Seize Parameter is relevant for all the following cards: MVC-4 MVC-4/E1-Framer MVC-4/T1-DSU-Framer MVC-4/T1-CSU-Framer MVC-4/E1-SLAVE MVC-4/T1-SLAVE Default values: Analog FXS - No (value can't be changed). Analog FXO - Yes (value can't be changed). Analog E&M - No (values NO/YES). Digital E1/T1 Framer & Slave - No.")
prtExPVc4SignalingProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("delayStart", 2), ("immediateStart", 3), ("winkStart", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4SignalingProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPVc4SignalingProtocol.setDescription('The signaling protocol that will be used between the PABX & the voice port. Delay Start Protocol: the line is seized by sending an Off hook signal and after a delay, if the called party is available (On hook) DTMF (Dual Tone Multi Frequency) digits are sent towards the called party. Immediate Start Protocol: the line is seized by sending an Off Hook signal and immediately DTMF digits are sent towards the called party. Wink start protocol: the line is seized by sending an Off Hook signal and then the called party sends a short Off Hook wink signal. Now the calling party starts sending DTMF digits.')
prtExPVc4DelayStart = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 25), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4DelayStart.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPVc4DelayStart.setDescription('This parameter is used only for Delay Protocol. This is the time that the calling party will wait after sending an Off hook signal and before sending DTMF digits to the called party. The delay values are 100..4000 msec in intervals of 100 msec.')
prtExPVc4WinkMinDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 26), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4WinkMinDuration.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPVc4WinkMinDuration.setDescription('This parameter is used only for Wink Protocol. Min Duration of the Wink Signal (off hook duration from the called party). Legal values: 40..400 msec in intervals of 10 msec.')
prtExPVc4WinkMaxDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 1, 1, 27), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4WinkMaxDuration.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPVc4WinkMaxDuration.setDescription('This parameter is used only for Wink Protocol. Max Duration of the Wink Signal (off hook duration from the called party). Legal values: 40..400 msec in intervals of 10 msec.')
prtExPVc4DlciTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 2), )
if mibBuilder.loadTexts: prtExPVc4DlciTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPVc4DlciTable.setDescription('The write operation into the Table Objects is valid only at the TmpCnfg entry.')
prtExPVc4DlciEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 2, 1), ).setIndexNames((0, "DACS-MIB", "prtExPVc4DlciCnfgIdx"), (0, "DACS-MIB", "prtExPVc4DlciSltIdx"), (0, "DACS-MIB", "prtExPVc4DlciPrtIdx"))
if mibBuilder.loadTexts: prtExPVc4DlciEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPVc4DlciEntry.setDescription('')
prtExPVc4DlciCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExPVc4DlciCnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPVc4DlciCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg. ')
prtExPVc4DlciSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExPVc4DlciSltIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPVc4DlciSltIdx.setDescription('This attribute indicates a unique slot position where the card is inserted. In the ?004 Unit the entries io6(10)..io16) are not valid')
prtExPVc4DlciPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("exPrt1", 1), ("exPrt2", 2), ("exPrt3", 3), ("exPrt4", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExPVc4DlciPrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPVc4DlciPrtIdx.setDescription('This attribute indicates a unique internal port number. VC4 cards have four external ports.')
prtExPVc4DlciValid = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4DlciValid.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPVc4DlciValid.setDescription('This attribute indicates whether the attributes in this entry are valid or not. The user can add/delete pvc (dlci to dlci connection) by modifing this object')
prtExPVc4DlciIConSlt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("noConnect", 2), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4DlciIConSlt.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPVc4DlciIConSlt.setDescription('This attribute indicates a unique slot position In the Mux (Agent) where the dlci is routed to. In the ?004 Unit the entries io6(10)..io16) are not valid')
prtExPVc4DlciIConPrt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112))).clone(namedValues=NamedValues(("exPrt1", 1), ("exPrt2", 2), ("exPrt3", 3), ("exPrt4", 4), ("exPrt5", 5), ("exPrt6", 6), ("exPrt7", 7), ("exPrt8", 8), ("exPrt9", 9), ("exPrt10", 10), ("noConnect", 100), ("inPrt1", 101), ("inPrt2", 102), ("inPrt3", 103), ("inPrt4", 104), ("inPrt5", 105), ("inPrt6", 106), ("inPrt7", 107), ("inPrt8", 108), ("inPrt9", 109), ("inPrt10", 110), ("inPrt11", 111), ("inPrt12", 112)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4DlciIConPrt.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPVc4DlciIConPrt.setDescription('This attribute indicates a unique port id which the dlci is routed to.')
prtExPVc4DlciIConDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 991))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4DlciIConDlci.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPVc4DlciIConDlci.setDescription('This attribute indicates a unique internal connection dlci number, the dlci is routed to.')
prtExPVc4DlciTxBc = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 25, 26))).clone(namedValues=NamedValues(("full", 1), ("zero", 2), ("txBc9600bps", 3), ("txBc14400bps", 4), ("txBc19200bps", 5), ("txBc28800bps", 6), ("txBc32000bps", 7), ("txBc38400bps", 8), ("txBc48000bps", 9), ("txBc56000bps", 10), ("txBc57600bps", 11), ("txBc64Kbps", 12), ("txBc128Kbps", 13), ("txBc192Kbps", 14), ("txBc256Kbps", 15), ("txBc320Kbps", 16), ("txBc384Kbps", 17), ("txBc448Kbps", 18), ("txBc512Kbps", 19), ("txBc768Kbps", 20), ("txBc1024Kbps", 21), ("txBc16000bps", 25), ("txBc112Kbps", 26)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4DlciTxBc.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPVc4DlciTxBc.setDescription('This attribute indicates a unique Tx committed bandwidth on the user transmit line (or at the port receive line).')
prtExPVc4DlciTxBe = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 25, 26))).clone(namedValues=NamedValues(("full", 1), ("zero", 2), ("txBe9600bps", 3), ("txBe14400bps", 4), ("txBe19200bps", 5), ("txBe28800bps", 6), ("txBe32000bps", 7), ("txBe38400bps", 8), ("txBe48000bps", 9), ("txBe56000bps", 10), ("txBe57600bps", 11), ("txBe64Kbps", 12), ("txBe128Kbps", 13), ("txBe192Kbps", 14), ("txBe256Kbps", 15), ("txBe320Kbps", 16), ("txBe384Kbps", 17), ("txBe448Kbps", 18), ("txBe512Kbps", 19), ("txBe768Kbps", 20), ("txBe1024Kbps", 21), ("txBc16000bps", 25), ("txBc112Kbps", 26)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4DlciTxBe.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPVc4DlciTxBe.setDescription('This attribute indicates a unique Tx excess bandwidth on the user transmit line (or at the port receive line).')
prtExPVc4DlciRxBc = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 25, 26))).clone(namedValues=NamedValues(("full", 1), ("zero", 2), ("rxBc9600bps", 3), ("rxBc14400bps", 4), ("rxBc19200bps", 5), ("rxBc28800bps", 6), ("rxBc32000bps", 7), ("rxBc38400bps", 8), ("rxBc48000bps", 9), ("rxBc56000bps", 10), ("rxBc57600bps", 11), ("rxBc64Kbps", 12), ("rxBc128Kbps", 13), ("rxBc192Kbps", 14), ("rxBc256Kbps", 15), ("rxBc320Kbps", 16), ("rxBc384Kbps", 17), ("rxBc448Kbps", 18), ("rxBc512Kbps", 19), ("rxBc768Kbps", 20), ("rxBc1024Kbps", 21), ("rxBc16000bps", 25), ("rxBc112Kbps", 26)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4DlciRxBc.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPVc4DlciRxBc.setDescription('This attribute indicates a unique Rx committed bandwidth on the user receive line (or at the port transmit line).')
prtExPVc4DlciRxBe = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 25, 26))).clone(namedValues=NamedValues(("full", 1), ("zero", 2), ("rxBe9600bps", 3), ("rxBe14400bps", 4), ("rxBe19200bps", 5), ("rxBe28800bps", 6), ("rxBe32000bps", 7), ("rxBe38400bps", 8), ("rxBe48000bps", 9), ("rxBe56000bps", 10), ("rxBe57600bps", 11), ("rxBe64Kbps", 12), ("rxBe128Kbps", 13), ("rxBe192Kbps", 14), ("rxBe256Kbps", 15), ("rxBe320Kbps", 16), ("rxBe384Kbps", 17), ("rxBe448Kbps", 18), ("rxBe512Kbps", 19), ("rxBe768Kbps", 20), ("rxBe1024Kbps", 21), ("rxBc16000bps", 25), ("rxBc112Kbps", 26)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4DlciRxBe.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPVc4DlciRxBe.setDescription('This attribute indicates a unique Rx excess bandwidth on the user receive line (or at the port transmit line).')
prtExPVc4DlciPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 2, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(6, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExPVc4DlciPriority.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPVc4DlciPriority.setDescription('This attribute indicates a unique priority of the pvc. 6 is the lowest priority and 8 is the highest priority.')
prtExPVc4DlciStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 9, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disconnected", 1), ("connected", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExPVc4DlciStatus.setStatus('mandatory')
if mibBuilder.loadTexts: prtExPVc4DlciStatus.setDescription('This attribute indicates the status of the pvc. The status is disconnected(1) when one of the sides is programmed as not connected')
prtExLs6CnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13, 1), )
if mibBuilder.loadTexts: prtExLs6CnfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtExLs6CnfgTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry.')
prtExLs6CnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13, 1, 1), ).setIndexNames((0, "DACS-MIB", "prtExLs6CnfgIdx"), (0, "DACS-MIB", "prtExLs6SltIdx"), (0, "DACS-MIB", "prtExLs6PrtIdx"))
if mibBuilder.loadTexts: prtExLs6CnfgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtExLs6CnfgEntry.setDescription('')
prtExLs6CnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExLs6CnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtExLs6CnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg')
prtExLs6SltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExLs6SltIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtExLs6SltIdx.setDescription('This attribute indicates a unique slot position where the card is inserted. In the ?004 Unit the entries io6(10)..io12(16) are not valid.')
prtExLs6PrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("exPrt1", 1), ("exPrt2", 2), ("exPrt3", 3), ("exPrt4", 4), ("exPrt5", 5), ("exPrt6", 6), ("exPrt7", 7), ("exPrt8", 8), ("exPrt9", 9), ("exPrt10", 10), ("exPrt11", 11), ("exPrt12", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExLs6PrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtExLs6PrtIdx.setDescription('This attribute indicates a unique port index.')
prtExLs6Connect = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExLs6Connect.setStatus('mandatory')
if mibBuilder.loadTexts: prtExLs6Connect.setDescription('This attribute indicates whether the port should be considered in any of the mux algorithms.')
prtExLs6Protocol = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("sync", 2), ("async", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExLs6Protocol.setStatus('mandatory')
if mibBuilder.loadTexts: prtExLs6Protocol.setDescription('This attribute indicates the protocol. async - can be selected only for ports 1-2.')
prtExLs6Rate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20))).clone(namedValues=NamedValues(("r300bps", 2), ("r600bps", 3), ("r1200bps", 4), ("r2400bps", 5), ("r4800bps", 6), ("r7200bps", 7), ("r8000bps", 8), ("r9600bps", 9), ("r14400bps", 10), ("r16000bps", 11), ("r19200bps", 12), ("r24000bps", 13), ("r28800bps", 14), ("r32000bps", 15), ("r38400bps", 16), ("r48000bps", 17), ("r56000bps", 18), ("r57600bps", 19), ("r64000bps", 20)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExLs6Rate.setStatus('mandatory')
if mibBuilder.loadTexts: prtExLs6Rate.setDescription('Port rates in bps. g1 - contains the values : (2)-(6),(9),(12),(16) g2 - contains the values : (7),(10),(14),(19) g3 - contains the values : (8),(11),(13),(15),(17),(18),(20); it is not applicable when using Async protocol. Rates of pair ports (1-2, 3-4, 5-6) must be from the same group.')
prtExLs6ClkMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 255))).clone(namedValues=NamedValues(("dce", 1), ("extDce", 2), ("dte1", 3), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExLs6ClkMode.setStatus('mandatory')
if mibBuilder.loadTexts: prtExLs6ClkMode.setDescription('This attribute indicates a unique port operation clock mode. It is applicable for Sync protocol only .')
prtExLs6CtrlSignal = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("local", 2), ("rts", 3), ("dtrAndRts", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExLs6CtrlSignal.setStatus('mandatory')
if mibBuilder.loadTexts: prtExLs6CtrlSignal.setDescription('Control Signal.')
prtExLs6DataBits = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 255))).clone(namedValues=NamedValues(("d6bits", 1), ("d7bits", 2), ("d8bits", 3), ("d9bits", 4), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExLs6DataBits.setStatus('mandatory')
if mibBuilder.loadTexts: prtExLs6DataBits.setDescription('Data Bits. This object is applicable for Async protocol only.')
prtExLs6Cts = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("on", 2), ("rts", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExLs6Cts.setStatus('mandatory')
if mibBuilder.loadTexts: prtExLs6Cts.setDescription('This object indicates the CTS control line operation mode.')
prtExLs6LinkToInternal = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(101, 102, 255))).clone(namedValues=NamedValues(("inPrt1", 101), ("inPrt2", 102), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExLs6LinkToInternal.setStatus('mandatory')
if mibBuilder.loadTexts: prtExLs6LinkToInternal.setDescription('This object indicates which internal port of the card, the external port is linked to.')
prtExLs6VCnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13, 2), )
if mibBuilder.loadTexts: prtExLs6VCnfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtExLs6VCnfgTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry.')
prtExLs6VCnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13, 2, 1), ).setIndexNames((0, "DACS-MIB", "prtExLs6VCnfgIdx"), (0, "DACS-MIB", "prtExLs6VSltIdx"), (0, "DACS-MIB", "prtExLs6VPrtIdx"))
if mibBuilder.loadTexts: prtExLs6VCnfgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtExLs6VCnfgEntry.setDescription('')
prtExLs6VCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExLs6VCnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtExLs6VCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg')
prtExLs6VSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExLs6VSltIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtExLs6VSltIdx.setDescription('This attribute indicates a unique slot position where the card is inserted. In the ?004 Unit the entries io6(10)..io12(16) are not valid.')
prtExLs6VPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(7, 8))).clone(namedValues=NamedValues(("exPrt7", 7), ("exPrt8", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExLs6VPrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtExLs6VPrtIdx.setDescription('A unique identifier of the port, within the card.')
prtExLs6VConnect = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExLs6VConnect.setStatus('mandatory')
if mibBuilder.loadTexts: prtExLs6VConnect.setDescription('This attribute indicates whether the port should be considered in any of the mux algorithms.')
prtExLs6VRate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("r6400bps", 2), ("r7200bps", 3), ("r8000bps", 4), ("r9600bps", 5), ("r16000bps", 6), ("r24000bps", 7), ("r32000bps", 8), ("r64000bps", 9)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExLs6VRate.setStatus('mandatory')
if mibBuilder.loadTexts: prtExLs6VRate.setDescription('Rate (bps) used for FAX transmission and Voice coding.')
prtExLs6VEchoCanceler = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExLs6VEchoCanceler.setStatus('mandatory')
if mibBuilder.loadTexts: prtExLs6VEchoCanceler.setDescription('Echo canceler activation.')
prtExLs6VIfType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("w2wire", 1), ("w4wire", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExLs6VIfType.setStatus('mandatory')
if mibBuilder.loadTexts: prtExLs6VIfType.setDescription('This attribute indicates the interface type of the port. w4wire - is applicable only for E&M port type.')
prtExLs6VTxGain = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13, 2, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExLs6VTxGain.setStatus('mandatory')
if mibBuilder.loadTexts: prtExLs6VTxGain.setDescription('Transmit gain in dBm. E&M - values range: -17 .. 8 FXO - values range: -16 .. 4 FXS - values range: -13 .. 8 ')
prtExLs6VRxGain = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13, 2, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExLs6VRxGain.setStatus('mandatory')
if mibBuilder.loadTexts: prtExLs6VRxGain.setDescription('Receive gain in dBm. E&M - values range: -17 .. 2 FXO - values range: -17 .. -1 FXS - values range: -17 .. 2 ')
prtExLs6VOos = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("forcedIdle", 1), ("forcedBusy", 2), ("busyIdle", 3), ("idleBusy", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExLs6VOos.setStatus('mandatory')
if mibBuilder.loadTexts: prtExLs6VOos.setDescription('Out of Service signaling mode.')
prtInLs6CnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13, 3), )
if mibBuilder.loadTexts: prtInLs6CnfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtInLs6CnfgTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry.')
prtInLs6CnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13, 3, 1), ).setIndexNames((0, "DACS-MIB", "prtInLs6CnfgIdx"), (0, "DACS-MIB", "prtInLs6SltIdx"), (0, "DACS-MIB", "prtInLs6PrtIdx"))
if mibBuilder.loadTexts: prtInLs6CnfgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtInLs6CnfgEntry.setDescription('')
prtInLs6CnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtInLs6CnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtInLs6CnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg')
prtInLs6SltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtInLs6SltIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtInLs6SltIdx.setDescription('This attribute indicates a unique slot position where the card is inserted. In the ?004 Unit the entries io6(10)..io12(16) are not valid.')
prtInLs6PrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(101, 102))).clone(namedValues=NamedValues(("inPrt1", 101), ("inPrt2", 102)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtInLs6PrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtInLs6PrtIdx.setDescription('This attribute indicates a unique internal port index.')
prtInLs6Connect = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInLs6Connect.setStatus('mandatory')
if mibBuilder.loadTexts: prtInLs6Connect.setDescription('This attribute indicates whether the port should be considered in any of the mux algorithms. It also affects all the module considerations because the module has only one Internal interface which is the composite channel.')
prtInLs6TandemMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noTandem", 1), ("tandemMaster", 2), ("tandemSlave", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInLs6TandemMode.setStatus('mandatory')
if mibBuilder.loadTexts: prtInLs6TandemMode.setDescription("This object indicates the Tandem Mode. tandemSlave - is valid only for an LS-6 card having on the (current slot-1) an LS-6 card with 'tandemMaster' mode.")
prtInLs6Rate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("r32Kbps", 1), ("r56Kbps", 2), ("r64Kpbs", 3), ("r128Kbps", 4), ("r256Kbps", 5), ("r384Kbps", 6), ("r192Kbps", 7), ("r512Kbps", 8), ("r768Kbps", 9)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInLs6Rate.setStatus('mandatory')
if mibBuilder.loadTexts: prtInLs6Rate.setDescription('Main Rate in Kbps.')
prtInLs6RemoteType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 255))).clone(namedValues=NamedValues(("ls6", 1), ("km2kSlave", 2), ("km2kStandalone", 3), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInLs6RemoteType.setStatus('mandatory')
if mibBuilder.loadTexts: prtInLs6RemoteType.setDescription('Remote Type. notApplicable - when prtInLs6TandemMode=tandemSlave ')
prtInLs6LinkTo = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 13, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInLs6LinkTo.setStatus('deprecated')
if mibBuilder.loadTexts: prtInLs6LinkTo.setDescription('It indicates the slot of the main link card to which the Ls6 card is mapped. In the ?004 Unit the entries io6(10)..io12(16) are not valid. notApplicable - when prtInLs6TandemMode=tandemSlave. STATUS deprecated - this object is replaced by prtGenCnfgLinkToSlot and prtGenCnfgLinkToPort. ')
prtExVc3CnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 14, 1), )
if mibBuilder.loadTexts: prtExVc3CnfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtExVc3CnfgTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry.')
prtExVc3CnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 14, 1, 1), ).setIndexNames((0, "DACS-MIB", "prtExVc3CnfgIdx"), (0, "DACS-MIB", "prtExVc3SltIdx"), (0, "DACS-MIB", "prtExVc3PrtIdx"))
if mibBuilder.loadTexts: prtExVc3CnfgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtExVc3CnfgEntry.setDescription('')
prtExVc3CnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 14, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExVc3CnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtExVc3CnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg')
prtExVc3SltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 14, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExVc3SltIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtExVc3SltIdx.setDescription('This attribute indicates a unique slot position where the card is inserted. In the ?004 Unit the entries io6(10)..io12(16) are not valid.')
prtExVc3PrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 14, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("exPrt1", 1), ("exPrt2", 2), ("exPrt3", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExVc3PrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtExVc3PrtIdx.setDescription('A unique identifier of the port, within the card.')
prtExVc3Connect = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 14, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVc3Connect.setStatus('mandatory')
if mibBuilder.loadTexts: prtExVc3Connect.setDescription('This attribute indicates whether the port should be considered in any of the mux algorithms.')
prtExVc3TransGain = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 14, 1, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVc3TransGain.setStatus('mandatory')
if mibBuilder.loadTexts: prtExVc3TransGain.setDescription('Transmit gain in dBm.')
prtExVc3ReceiveGain = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 14, 1, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVc3ReceiveGain.setStatus('mandatory')
if mibBuilder.loadTexts: prtExVc3ReceiveGain.setDescription('Receive gain in dBm.')
prtExVc3Wire = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 14, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("w2wire", 1), ("w4wire", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVc3Wire.setStatus('mandatory')
if mibBuilder.loadTexts: prtExVc3Wire.setDescription('This object is equal for all the ports in the specific card because of HW limitations')
prtExVc3Rate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 14, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("r9600bps", 1), ("r4800bps", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVc3Rate.setStatus('mandatory')
if mibBuilder.loadTexts: prtExVc3Rate.setDescription('Rate in bps.')
prtExVc3EchoCanceler = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 14, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVc3EchoCanceler.setStatus('mandatory')
if mibBuilder.loadTexts: prtExVc3EchoCanceler.setDescription("Echo canceler activation. The value will be the same for all the card's external ports.")
prtInVc3CnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 14, 2), )
if mibBuilder.loadTexts: prtInVc3CnfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtInVc3CnfgTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry.')
prtInVc3CnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 14, 2, 1), ).setIndexNames((0, "DACS-MIB", "prtInVc3CnfgIdx"), (0, "DACS-MIB", "prtInVc3SltIdx"), (0, "DACS-MIB", "prtInVc3PrtIdx"))
if mibBuilder.loadTexts: prtInVc3CnfgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtInVc3CnfgEntry.setDescription('')
prtInVc3CnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 14, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtInVc3CnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtInVc3CnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg')
prtInVc3SltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 14, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtInVc3SltIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtInVc3SltIdx.setDescription('This attribute indicates a unique slot position where the card is inserted. In the ?004 Unit the entries io6(10)..io12(16) are not valid.')
prtInVc3PrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 14, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(101))).clone(namedValues=NamedValues(("inPrt1", 101)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtInVc3PrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtInVc3PrtIdx.setDescription('A unique identifier of the port, within the card.')
prtInVc3Connect = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 14, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInVc3Connect.setStatus('mandatory')
if mibBuilder.loadTexts: prtInVc3Connect.setDescription('This attribute indicates whether the port should be considered in any of the mux algorithms.')
prtInVc3Rate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 14, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("r32000bps", 1), ("r16000bps", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInVc3Rate.setStatus('mandatory')
if mibBuilder.loadTexts: prtInVc3Rate.setDescription('Rate in bps.')
prtInVc3Oos = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 14, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("forcedIdle", 1), ("forcedBusy", 2), ("busyIdle", 3), ("idleBusy", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInVc3Oos.setStatus('mandatory')
if mibBuilder.loadTexts: prtInVc3Oos.setDescription(' This object is equal for all the ports in the specific card because of HW limitations')
prtInVc3LinkTo = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 14, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtInVc3LinkTo.setStatus('deprecated')
if mibBuilder.loadTexts: prtInVc3LinkTo.setDescription('This attribute indicates the slot of the ML card to which the VC card is mapped. In the ?004 Unit the entries io6(10)..io12(16) are not valid. STATUS deprecated - this object is replaced by prtGenCnfgLinkToSlot and prtGenCnfgLinkToPort.')
prtExVcPbxCnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 1), )
if mibBuilder.loadTexts: prtExVcPbxCnfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtExVcPbxCnfgTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry.')
prtExVcPbxCnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 1, 1), ).setIndexNames((0, "DACS-MIB", "prtExVcPbxCnfgIdx"), (0, "DACS-MIB", "prtExVcPbxSltIdx"), (0, "DACS-MIB", "prtExVcPbxPrtIdx"))
if mibBuilder.loadTexts: prtExVcPbxCnfgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtExVcPbxCnfgEntry.setDescription('')
prtExVcPbxCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExVcPbxCnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtExVcPbxCnfgIdx.setDescription('This object indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg')
prtExVcPbxSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExVcPbxSltIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtExVcPbxSltIdx.setDescription('This object indicates a unique slot position where the card is inserted. In the ?004 Unit the entries io6(10)..io12(16) are not valid.')
prtExVcPbxPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("exPrt1", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExVcPbxPrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtExVcPbxPrtIdx.setDescription('A unique identifier of the port, within the card.')
prtExVcPbxConnect = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVcPbxConnect.setStatus('mandatory')
if mibBuilder.loadTexts: prtExVcPbxConnect.setDescription('This object indicates whether the port should be considered in any of the mux algorithms.')
prtExVcPbxGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExVcPbxGroup.setStatus('mandatory')
if mibBuilder.loadTexts: prtExVcPbxGroup.setDescription('The group object links together several VC-PBX cards, concerning compression of the same input T1/E1 link time-slots. When ports of different slots have the same group, they are linked. When ports have a different group, they are not linked. For VC-PBX/T1 and E1 cards, this object is - their own IO Slot. In the ?004 Unit the entries io6(10)..io12(16) are not valid.')
prtExVcPbxTransparent = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 255))).clone(namedValues=NamedValues(("no", 2), ("yes", 3), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVcPbxTransparent.setStatus('mandatory')
if mibBuilder.loadTexts: prtExVcPbxTransparent.setDescription('This object indicates whether the Transparent transfer of Time-Slots is required or not. Time-Slots transferred by Transparent, will not be compressed. no - applicable only for VC-PBX/T1 and VC-PBX/E1 cards yes - applicable only for VC-PBX/T1 and VC-PBX/E1 cards notApplicable - only for VC-PBX cards.')
prtExVcPbxTransSignalTs = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 1, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVcPbxTransSignalTs.setStatus('mandatory')
if mibBuilder.loadTexts: prtExVcPbxTransSignalTs.setDescription("This object specifies the ML Time-Slot dedicated to the signaling of the PABX Transparent TSs. None = 255. When prtExVcPbxTransparent=no this object's value=None (255) When prtExVcPbxTransparent=notApplicable, this object's value=None (255). When prtExVcPbxTransparent=yes: - for VC-PBX/T1 ports, this object's valid values are 1..16 or None (255). - for VC-PBX/E1 ports, this object's value will be 16 or None (255).")
prtExVcPbxFrame = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7, 255))).clone(namedValues=NamedValues(("esfT1", 2), ("sfT1", 3), ("g732nE1", 4), ("g732nE1CRC", 5), ("g732sE1", 6), ("g732sE1CRC", 7), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVcPbxFrame.setStatus('mandatory')
if mibBuilder.loadTexts: prtExVcPbxFrame.setDescription('This object is the frame parameter for T1/E1 interface. The user should select only the parameters which are relevant to the specific card: T1 values for the VC-PBX/T1 card. E1 values for the VC-PBX/E1 card. notApplicable - for the VC-PBX card. This parameter has the same values as dsx1LineType in T1/E1 MIB (RFC-1406). The parameters in dsx1LineType are: other (1) esfT1 dsx1ESF (2) sfT1 dsx1D4 (3) g732nE1 dsx1E1 (4) g732nE1CRC dsx1E1-CRC (5) g732sE1 dsx1E1-MF (6) g732sE1CRC dsx1E1-MF-CRC (7) ')
prtExVcPbxRestoreTime = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 255))).clone(namedValues=NamedValues(("restoreT1secFast", 2), ("restoreT10sec62411", 3), ("ccittE1", 4), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVcPbxRestoreTime.setStatus('mandatory')
if mibBuilder.loadTexts: prtExVcPbxRestoreTime.setDescription('The time passing from the disappearance of the loss of synchronization condition (red alarm) to the restoration of normal service. The options 1secFast(2) and 10sec62411(3) for E1 interfaces are proprietary implementation of the T1 standard to the E1 interface. ccittE1 - is applicable only for VC-PBX/E1 card notApplicable - is applicable for VC-PBX card')
prtExVcPbxLineCode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 255))).clone(namedValues=NamedValues(("b7zsT1", 1), ("b8zsT1", 2), ("transT1", 3), ("hdb3E1", 4), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVcPbxLineCode.setStatus('mandatory')
if mibBuilder.loadTexts: prtExVcPbxLineCode.setDescription('This object is the line code parameter used for T1/E1 interface. The user should select only the parameters which are relevant to the specific card: T1 line code parameters for VC-PBX/T1 E1 line code parameters for VC-PBX/E1 notApplicable - for VC-PBX This parameter has the same values as dsx1LineCoding in T1/E1 MIB (RFC-1406). The parameters in dsx1LineCoding are: dsx1JBZS (1) dsx1B8ZS (2) dsx1HDB3 (3) dsx1ZBTSI (4) dsx1AMI (5) other (6)')
prtExVcPbxLineLength = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 255))).clone(namedValues=NamedValues(("unknown", 1), ("len0p133ft", 2), ("len134p266ft", 3), ("len267p399ft", 4), ("len400p533ft", 5), ("len534p655ft", 6), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVcPbxLineLength.setStatus('mandatory')
if mibBuilder.loadTexts: prtExVcPbxLineLength.setDescription('This object is the line length parameter. It is applicable only for the VC-PBX/T1 card. notApplicable - for the VC-PBX and VC-PBX/E1 card. lenXXXpXXXft = len-XXX-XXXft.')
prtExVcPbxLinkTo = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVcPbxLinkTo.setStatus('deprecated')
if mibBuilder.loadTexts: prtExVcPbxLinkTo.setDescription('This object indicates the slot of the ML card to which the VC-PBX/T1, VC-PBX/E1 card Transparent TSs are mapped. notApplicable - for VC-PBX card AND for VC-PBX/T1, VC-PBX/E1 cards, when prtExVcPbxTransparent=no . In the ?004 Unit the entries io6(10)..io12(16) are not valid. STATUS deprecated - this object is replaced by prtGenCnfgLinkToSlot and prtGenCnfgLinkToPort.')
prtExVcPbxSignalOper = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("normal", 2), ("bEqA", 3), ("inverseA", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVcPbxSignalOper.setStatus('mandatory')
if mibBuilder.loadTexts: prtExVcPbxSignalOper.setDescription('This object indicates the Signaling Operation of the VC-PBX/T1, VC-PBX/E1 external port. notApplicable - for VC-PBX card normal - all 4 signaling bits are transferred. bEqA - copy the A bit into the B bit. Applicable only for VC-PBX/T1.')
prtExVcPbxIdleCode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("notApplicable", 1), ("hff", 2), ("he4", 3), ("hd5", 4), ("h9e", 5), ("h98", 6), ("h7f", 7), ("h7e", 8), ("h54", 9), ("h1a", 10)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVcPbxIdleCode.setStatus('mandatory')
if mibBuilder.loadTexts: prtExVcPbxIdleCode.setDescription('Determines the code for transmission in empty time slots. notApplicable - for VC-PBX card .')
prtIn1p6VcPbxCnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 2), )
if mibBuilder.loadTexts: prtIn1p6VcPbxCnfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtIn1p6VcPbxCnfgTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry.')
prtIn1p6VcPbxCnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 2, 1), ).setIndexNames((0, "DACS-MIB", "prtIn1p6VcPbxCnfgIdx"), (0, "DACS-MIB", "prtIn1p6VcPbxSltIdx"), (0, "DACS-MIB", "prtIn1p6VcPbxPrtIdx"))
if mibBuilder.loadTexts: prtIn1p6VcPbxCnfgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtIn1p6VcPbxCnfgEntry.setDescription('')
prtIn1p6VcPbxCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtIn1p6VcPbxCnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtIn1p6VcPbxCnfgIdx.setDescription('This object indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg')
prtIn1p6VcPbxSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtIn1p6VcPbxSltIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtIn1p6VcPbxSltIdx.setDescription('This object indicates a unique slot position where the card is inserted. In the ?004 Unit the entries io6(10)..io12(16) are not valid.')
prtIn1p6VcPbxPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(101, 102, 103, 104, 105, 106))).clone(namedValues=NamedValues(("inPrt1", 101), ("inPrt2", 102), ("inPrt3", 103), ("inPrt4", 104), ("inPrt5", 105), ("inPrt6", 106)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtIn1p6VcPbxPrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtIn1p6VcPbxPrtIdx.setDescription('A unique identifier of the port, within the card.')
prtIn1p6VcPbxConnect = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIn1p6VcPbxConnect.setStatus('mandatory')
if mibBuilder.loadTexts: prtIn1p6VcPbxConnect.setDescription('This object indicates whether the port should be considered in any of the mux algorithms.')
prtIn1p6VcPbxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("r4800bps", 1), ("r6400bps", 2), ("r7200bps", 3), ("r8000bps", 4), ("r9600bps", 5), ("r12800bps", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIn1p6VcPbxRate.setStatus('mandatory')
if mibBuilder.loadTexts: prtIn1p6VcPbxRate.setDescription('This object indicates the port Rate. For Normal mode (prtIn7p8VcPbxMode=normal), only part of the values are valid (constant rate). For Server mode (prtIn7p8VcPbxMode=server), all values are applicable (user can select the desired compression rate). ')
prtIn1p6VcPbxEchoCanceler = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIn1p6VcPbxEchoCanceler.setStatus('mandatory')
if mibBuilder.loadTexts: prtIn1p6VcPbxEchoCanceler.setDescription('Echo canceler activation.')
prtIn1p6VcPbxPabxTs = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtIn1p6VcPbxPabxTs.setStatus('mandatory')
if mibBuilder.loadTexts: prtIn1p6VcPbxPabxTs.setDescription('This object defines the PABX Time-Slot assigned to this internal port. For a T1 link, the valid values are: 1 .. 24. For an E1 link, the valid values are: 1 .. 31. This object is NOT applicable when prtIn1p6VcPbxConnect=no. This object is applicable for all cards of VC-PBX family. Default=the internal port index (1..6).')
prtIn7p8VcPbxCnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 3), )
if mibBuilder.loadTexts: prtIn7p8VcPbxCnfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtIn7p8VcPbxCnfgTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry.')
prtIn7p8VcPbxCnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 3, 1), ).setIndexNames((0, "DACS-MIB", "prtIn7p8VcPbxCnfgIdx"), (0, "DACS-MIB", "prtIn7p8VcPbxSltIdx"), (0, "DACS-MIB", "prtIn7p8VcPbxPrtIdx"))
if mibBuilder.loadTexts: prtIn7p8VcPbxCnfgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtIn7p8VcPbxCnfgEntry.setDescription('')
prtIn7p8VcPbxCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtIn7p8VcPbxCnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtIn7p8VcPbxCnfgIdx.setDescription('This object indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg')
prtIn7p8VcPbxSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtIn7p8VcPbxSltIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtIn7p8VcPbxSltIdx.setDescription('This object indicates a unique slot position where the card is inserted. In the ?004 Unit the entries io6(10)..io12(16) are not valid.')
prtIn7p8VcPbxPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(107, 108))).clone(namedValues=NamedValues(("inPrt7", 107), ("inPrt8", 108)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtIn7p8VcPbxPrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtIn7p8VcPbxPrtIdx.setDescription('A unique identifier of the port, within the card.')
prtIn7p8VcPbxConnect = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIn7p8VcPbxConnect.setStatus('mandatory')
if mibBuilder.loadTexts: prtIn7p8VcPbxConnect.setDescription('This object indicates whether the port should be considered in any of the mux algorithms.')
prtIn7p8VcPbxMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("server", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIn7p8VcPbxMode.setStatus('mandatory')
if mibBuilder.loadTexts: prtIn7p8VcPbxMode.setDescription('This object indicates the working mode of the port: - normal - the compressed voice will be sent to an MTML card inside the Mux. - server - the compressed voice will be sent to the Digital Voice connector, as a service to an outside user.')
prtIn7p8VcPbxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("r32Kbps", 1), ("r16Kbps", 2), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIn7p8VcPbxRate.setStatus('mandatory')
if mibBuilder.loadTexts: prtIn7p8VcPbxRate.setDescription('This object indicates the port Main Rate. For Server mode (prtIn7p8VcPbxMode=server), the value will be notApplicable. ')
prtIn7p8VcPbxSignalMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("aBit", 2), ("abcBit", 3), ("abcdBit", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIn7p8VcPbxSignalMode.setStatus('mandatory')
if mibBuilder.loadTexts: prtIn7p8VcPbxSignalMode.setDescription('This object indicates the Signal Mode. For Server mode (prtIn7p8VcPbxMode=server), the only valid values are: - none - aBit ')
prtIn7p8VcPbxOos = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("forcedIdle", 1), ("forcedBusy", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIn7p8VcPbxOos.setStatus('mandatory')
if mibBuilder.loadTexts: prtIn7p8VcPbxOos.setDescription(' Out of service Signaling mode.')
prtIn7p8VcPbxLinkTo = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIn7p8VcPbxLinkTo.setStatus('deprecated')
if mibBuilder.loadTexts: prtIn7p8VcPbxLinkTo.setDescription('This object indicates the slot of the ML card to which the VC card is mapped. In the ?004 Unit the entries io6(10)..io12(16) are not valid. For Server mode (prtIn7p8VcPbxMode=server), this object is not applicable. Both ports, 7 and 8 should be linked to the same Slot. STATUS deprecated - this object is replaced by prtGenCnfgLinkToSlot and prtGenCnfgLinkToPort.')
prtExVcPbxTsTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 4), )
if mibBuilder.loadTexts: prtExVcPbxTsTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtExVcPbxTsTable.setDescription('The write operation into the table objects is valid only to the TmpCnfg entry.')
prtExVcPbxTsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 4, 1), ).setIndexNames((0, "DACS-MIB", "prtExVcPbxTsCnfgIdx"), (0, "DACS-MIB", "prtExVcPbxTsSltIdx"), (0, "DACS-MIB", "prtExVcPbxTsPrtIdx"), (0, "DACS-MIB", "prtExVcPbxTsIdx"))
if mibBuilder.loadTexts: prtExVcPbxTsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtExVcPbxTsEntry.setDescription('')
prtExVcPbxTsCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExVcPbxTsCnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtExVcPbxTsCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg. ')
prtExVcPbxTsSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExVcPbxTsSltIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtExVcPbxTsSltIdx.setDescription('This attribute indicates a unique slot position where the card is inserted. In the ?004 Unit the entries io6(10)..io12(16) are not valid')
prtExVcPbxTsPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("exPrt1", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExVcPbxTsPrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtExVcPbxTsPrtIdx.setDescription('This attribute indicates a unique port number. VCPBX/E1 and VCPBX/T1 cards have only one external interface.')
prtExVcPbxTsIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 4, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtExVcPbxTsIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtExVcPbxTsIdx.setDescription('This attribute indicates a unique PABX time slot position. The valid time slots are 1..24 for VC-PBX/T1 and 1..31 for VC-PBX/E1.')
prtExVcPbxTsMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unused", 1), ("compressed", 2), ("transparent", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVcPbxTsMode.setStatus('mandatory')
if mibBuilder.loadTexts: prtExVcPbxTsMode.setDescription('This attribute indicates the usage, process and way of the specific PABX TS towards its destination: unused - the TS is not used (no processing, no destination). compressed - the TS is used, sent for compression to an internal port 1..6 of either the same card or a VC-PBX card of the same group. transparent - the TS is used, no processing, it is sent directly to the ML card the VC-PBX/T1,(E1) is linked to.')
prtExVcPbxTsIConSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("noConnect", 2), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVcPbxTsIConSlot.setStatus('mandatory')
if mibBuilder.loadTexts: prtExVcPbxTsIConSlot.setDescription("The object's io1..io12 values are applicable only when prtExVcPbxTsMode=compressed. Otherwise, its value should be noConnect. This object indicates whether the specified compressed time slot is connected/routed internally in the Agent and to which card it is connected. The valid selectable slots are either the current one, (prtExVcPbxTsSltIdx), or a slot containing a VC-PBX card. In the ?004 Unit the entries io6(10)..io12(16) are not valid.")
prtExVcPbxTsIConPrt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 15, 4, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(100, 101, 102, 103, 104, 105, 106))).clone(namedValues=NamedValues(("noConnect", 100), ("inPrt1", 101), ("inPrt2", 102), ("inPrt3", 103), ("inPrt4", 104), ("inPrt5", 105), ("inPrt6", 106)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtExVcPbxTsIConPrt.setStatus('mandatory')
if mibBuilder.loadTexts: prtExVcPbxTsIConPrt.setDescription('This attribute indicates the internal VC-PBX port to which this PABX TS is connected for compression. noConnect - when prtExVcPbxTsIConSlot=noConnect.')
prtIsdnCnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 1), )
if mibBuilder.loadTexts: prtIsdnCnfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtIsdnCnfgTable.setDescription('The write operation into the table objects is valid only to the TmpCnfg entry.')
prtIsdnCnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 1, 1), ).setIndexNames((0, "DACS-MIB", "prtIsdnCnfgIdx"), (0, "DACS-MIB", "prtIsdnSltIdx"), (0, "DACS-MIB", "prtIsdnPrtIdx"))
if mibBuilder.loadTexts: prtIsdnCnfgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtIsdnCnfgEntry.setDescription('')
prtIsdnCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtIsdnCnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtIsdnCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg. ')
prtIsdnSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 103, 104, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("kmxMlA", 103), ("kmxMlB", 104), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtIsdnSltIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtIsdnSltIdx.setDescription("This attribute indicates a unique slot position where the card is inserted. In the ?004 Unit the entries io6(10)..io12(16) are not valid For KM2100/4 Valid entries are 'kmxMlA ' or 'kmxMlB'")
prtIsdnPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtIsdnPrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtIsdnPrtIdx.setDescription('This attribute indicates a unique port number. For MAXcess the values will be: exPrt1(1), exPrt2(2), exPrt3(3), exPrt4(4), For KM-2100 the port index is calculated as follows: 100*Slot+Ch')
prtIsdnConnect = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIsdnConnect.setStatus('mandatory')
if mibBuilder.loadTexts: prtIsdnConnect.setDescription('This attribute indicates if the port is connected.')
prtIsdnSignalingProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 6, 7, 9, 10, 17, 18, 255))).clone(namedValues=NamedValues(("other", 1), ("etsi", 3), ("ess5", 6), ("dms100", 7), ("ni1", 9), ("ni2", 10), ("ins64", 17), ("ins1500", 18), ("notApplicable", 255))).clone('etsi')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIsdnSignalingProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: prtIsdnSignalingProtocol.setDescription('This attribute fixes which signaling protocol is used at this port (D-Channel). It is equivalent to isdnSignalingProtocol in the isdn MIB.')
prtIsdnBasicRateLineTopology = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("pointToPoint", 1), ("pointToMultipoint", 2), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIsdnBasicRateLineTopology.setStatus('mandatory')
if mibBuilder.loadTexts: prtIsdnBasicRateLineTopology.setDescription('This attribute is relevant for ISDN BRI only. It is equivalent to isdnBasicRateLineTopology in the isdn MIB.')
prtIsdnMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 255))).clone(namedValues=NamedValues(("dialup", 1), ("leased", 2), ("syncLeased", 3), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIsdnMode.setStatus('mandatory')
if mibBuilder.loadTexts: prtIsdnMode.setDescription('This attribute allows the user to configure the port as leased(2) in case of connection to a TDM network.')
prtIsdnFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("answerAll", 2), ("rejectAll", 3), ("selective", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIsdnFilter.setStatus('mandatory')
if mibBuilder.loadTexts: prtIsdnFilter.setDescription('This attribute allows the user to configure the port: answerAll(2): accept all incoming calls, rejectAll(3): reject all incoming calls, selective(4): accept or reject according directory table.')
prtIsdnSimultaneousCall = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("accept", 2), ("reject", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIsdnSimultaneousCall.setStatus('mandatory')
if mibBuilder.loadTexts: prtIsdnSimultaneousCall.setDescription('In case of simultaneous call (local,remote and remote,local): accept(2): accept the incoming call, reject(3): reject the incoming call.')
prtIsdnNumOfAbstractTerm = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 1, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIsdnNumOfAbstractTerm.setStatus('mandatory')
if mibBuilder.loadTexts: prtIsdnNumOfAbstractTerm.setDescription('An object for KM2100/4 agents. 255=Not Applicable When ISDN Standard = ETSI or NTT (European) the value should be 255 (NotApplicable) else If ML speed is 64Kbps value should be 1. If ML speed is 128Kbps value can be either 1 or 2 (user selection).')
prtIsdnSwitchMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("auto", 2), ("manual", 3), ("connect", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIsdnSwitchMode.setStatus('mandatory')
if mibBuilder.loadTexts: prtIsdnSwitchMode.setDescription("For KM2100. auto - The call is initiated automatically by one of the IO cards connected to KML.10(ISDN card) having ISDN Switch Mode. manual - The call is initiated by the user manually, for KML.10 having ISDN Switch Mode (via mdlSCmd). connect- The call is initiated 'immediately', for KML.10 having ISDN Switch Mode. 'immediately'- means: immediately after power-up (when product performed Reset) OR, since this value appears in the active configuration. In this case, the call can be disconnected only by power-off of the product or by changing this object to another value (or actual Remove of the KML.10 relevant card). notApplicable - For other card types.")
prtIsdnEndpointTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 2), )
if mibBuilder.loadTexts: prtIsdnEndpointTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtIsdnEndpointTable.setDescription('The write operation into the table objects is valid only to the TmpCnfg entry.')
prtIsdnEndpointEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 2, 1), ).setIndexNames((0, "DACS-MIB", "prtIsdnEndpointCnfgIdx"), (0, "DACS-MIB", "prtIsdnEndpointSltIdx"), (0, "DACS-MIB", "prtIsdnEndpointPrtIdx"), (0, "DACS-MIB", "prtIsdnEndpointIdx"))
if mibBuilder.loadTexts: prtIsdnEndpointEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtIsdnEndpointEntry.setDescription('')
prtIsdnEndpointCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtIsdnEndpointCnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtIsdnEndpointCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg. ')
prtIsdnEndpointSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 103, 104, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("kmxMlA", 103), ("kmxMlB", 104), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtIsdnEndpointSltIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtIsdnEndpointSltIdx.setDescription("This attribute indicates a unique slot position where the card is inserted. In ?004 Unit the entries io6(10)..io12(16) are not valid For KM2100/4 Valid entries are 'kmxMlA ' or 'kmxMlB'")
prtIsdnEndpointPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtIsdnEndpointPrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtIsdnEndpointPrtIdx.setDescription('This attribute indicates a unique port number. For MAXcess the values will be: exPrt1(1), exPrt2(2), exPrt3(3), exPrt4(4), For KM-2100 the port index is calculated as follows: 100*Slot+Ch')
prtIsdnEndpointIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("atei1", 1), ("atei2", 2))).clone('atei1')).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtIsdnEndpointIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtIsdnEndpointIdx.setDescription('Since more than one endpoint may be defined per isdn entity, this field is a simple index. It corresponds to isdnEndpointIdx in the isdn MIB.')
prtIsdnEndpointTeiType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("dynamic", 1), ("static", 2), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIsdnEndpointTeiType.setStatus('mandatory')
if mibBuilder.loadTexts: prtIsdnEndpointTeiType.setDescription('The type of TEI (Terminal Endpoint Identifier) used for this Terminal Endpoint. In case of dynamic(1), the TEI value is selected by the switch. In case of static(2), a valid TEI value has to be entered in the isdnEndpointTeiValue object. interface type as well as the Terminal Endpoint type. static(2). On Basic Rate interfaces the default value is dynamic(1) for isdn(63) Terminal Endpoints. It corresponds to isdnEndpointTeiType in the isdn MIB.')
prtIsdnEndpointTeiValue = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 2, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIsdnEndpointTeiValue.setStatus('mandatory')
if mibBuilder.loadTexts: prtIsdnEndpointTeiValue.setDescription('When the TEI Type is static, the value of the TEI should be between 0 and 63. Else, it is not selectable by user. 255 = notApplicable. It corresponds to isdnEndpointTeiValue in the isdn MIB')
prtIsdnEndpointSpid = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 2, 1, 7), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIsdnEndpointSpid.setStatus('mandatory')
if mibBuilder.loadTexts: prtIsdnEndpointSpid.setDescription('The Service profile IDentifier (SPID) information for this Terminal Endpoint. It is is composed of 9-20 numeric characters. It corresponds to isdnEndpointSpid in the isdn MIB.')
prtIsdnEndpointBearerCh = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("anyChannel", 2), ("channelB1", 3), ("channelB2", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIsdnEndpointBearerCh.setStatus('mandatory')
if mibBuilder.loadTexts: prtIsdnEndpointBearerCh.setDescription('This is the selected dialing channel. anyChannel - the system selects the dialing channel.')
prtIsdnEndpointRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 6))).clone(namedValues=NamedValues(("active", 1), ("destroy", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIsdnEndpointRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: prtIsdnEndpointRowStatus.setDescription('This field indicates whether to consider this endpoint or not.')
prtIsdnDirectoryTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 3), )
if mibBuilder.loadTexts: prtIsdnDirectoryTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtIsdnDirectoryTable.setDescription('The write operation into the table objects is valid only to the TmpCnfg entry.')
prtIsdnDirectoryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 3, 1), ).setIndexNames((0, "DACS-MIB", "prtIsdnDirectoryCnfgIdx"), (0, "DACS-MIB", "prtIsdnDirectorySltIdx"), (0, "DACS-MIB", "prtIsdnDirectoryPrtIdx"))
if mibBuilder.loadTexts: prtIsdnDirectoryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtIsdnDirectoryEntry.setDescription('')
prtIsdnDirectoryCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtIsdnDirectoryCnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtIsdnDirectoryCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg. ')
prtIsdnDirectorySltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 103, 104))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("kmxMlA", 103), ("kmxMlB", 104)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtIsdnDirectorySltIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtIsdnDirectorySltIdx.setDescription("This attribute indicates a unique slot position where the card is inserted. For MX300/30 ports: io1(5) = isdn1(5) and io2(6) = isdn2(6). In ?004 Unit the entries io6(10)..io12(16) are not valid For KM2100/4 Valid entries are 'kmxMlA ' or 'kmxMlB'")
prtIsdnDirectoryPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtIsdnDirectoryPrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtIsdnDirectoryPrtIdx.setDescription('For MAXcess this is the internal port number: 101, 102,.... For KM-2100 the port index is calculated as follows: 100*Slot+Ch')
prtIsdnDirectoryLocalAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 3, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(17, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIsdnDirectoryLocalAddr.setStatus('mandatory')
if mibBuilder.loadTexts: prtIsdnDirectoryLocalAddr.setDescription('This is the local address associated with this entry. - For MX: Size=17 , Default=0 (17 characters) - For KM: Size=20, Default=blank (20 characters) ')
prtIsdnDirectoryLocalSubAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 3, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(4, 6))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIsdnDirectoryLocalSubAddr.setStatus('mandatory')
if mibBuilder.loadTexts: prtIsdnDirectoryLocalSubAddr.setDescription('This is the local subaddress associated with this entry. - For MX: Size=6 , Default=0 (6 characters) - For KM: Size=4 , Default=blank (4 characters)')
prtIsdnDirectoryRemoteAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 3, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(17, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIsdnDirectoryRemoteAddr.setStatus('mandatory')
if mibBuilder.loadTexts: prtIsdnDirectoryRemoteAddr.setDescription('This is the remote address associated with this entry. - For MX: Size=17 , Default=0 (17 characters) - For KM: Size=20, Default=blank (20 characters)')
prtIsdnDirectoryRemoteSubAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 3, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(4, 6))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIsdnDirectoryRemoteSubAddr.setStatus('mandatory')
if mibBuilder.loadTexts: prtIsdnDirectoryRemoteSubAddr.setDescription('This is the remote subaddress associated with this entry. - For MX: Size=6 , Default=0 (6 characters) - For KM: Size=4 , Default=blank (4 characters)')
prtIsdnDirectoryPrtNu = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 3, 1, 8), Integer32().clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIsdnDirectoryPrtNu.setStatus('mandatory')
if mibBuilder.loadTexts: prtIsdnDirectoryPrtNu.setDescription('This is the external port number connected to this entry.')
prtIsdnDirectoryTeiId = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 3, 1, 9), Integer32().clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIsdnDirectoryTeiId.setStatus('mandatory')
if mibBuilder.loadTexts: prtIsdnDirectoryTeiId.setDescription('This is the abstract terminal id if relevant, connected to this entry.')
prtIsdnDirectoryRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 3, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 6))).clone(namedValues=NamedValues(("active", 1), ("destroy", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIsdnDirectoryRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: prtIsdnDirectoryRowStatus.setDescription('This is the status for the row. It allows to know whether to consider this row or not.')
prtIsdnDirectoryLocalAddr2 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 3, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(17, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIsdnDirectoryLocalAddr2.setStatus('mandatory')
if mibBuilder.loadTexts: prtIsdnDirectoryLocalAddr2.setDescription('This is the second local address associated with this entry. - For MX: Size=17 , Default=0 (17 characters) - For KM: Size=20, Default=blank (20 characters)')
prtIsdnDirectoryLocalSubAddr2 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 3, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(4, 6))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIsdnDirectoryLocalSubAddr2.setStatus('mandatory')
if mibBuilder.loadTexts: prtIsdnDirectoryLocalSubAddr2.setDescription('This is the second local subaddress associated with this entry. - For MX: Size=6 , Default=0 (6 characters) - For KM: Size=4 , Default=blank (4 characters)')
prtIsdnDirectoryRemoteAddr2 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 3, 1, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(17, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIsdnDirectoryRemoteAddr2.setStatus('mandatory')
if mibBuilder.loadTexts: prtIsdnDirectoryRemoteAddr2.setDescription('This is the second remote address associated with this entry. - For MX: Size=17 , Default=0 (17 characters) - For KM: Size=20, Default=blank(20 characters) ')
prtIsdnDirectoryRemoteSubAddr2 = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 16, 3, 1, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(4, 6))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIsdnDirectoryRemoteSubAddr2.setStatus('mandatory')
if mibBuilder.loadTexts: prtIsdnDirectoryRemoteSubAddr2.setDescription('This is the second remote subaddress associated with this entry. - For MX: Size=6 , Default=0 (6 characters) - For KM: Size=4 , Default=blank (4 characters) ')
prtFrPlusCnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 18, 1), )
if mibBuilder.loadTexts: prtFrPlusCnfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtFrPlusCnfgTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry.')
prtFrPlusCnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 18, 1, 1), ).setIndexNames((0, "DACS-MIB", "prtFrPlusCnfgIdx"), (0, "DACS-MIB", "prtFrPlusSltIdx"), (0, "DACS-MIB", "prtFrPlusPrtIdx"))
if mibBuilder.loadTexts: prtFrPlusCnfgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtFrPlusCnfgEntry.setDescription('')
prtFrPlusCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 18, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtFrPlusCnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtFrPlusCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg. ')
prtFrPlusSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 18, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtFrPlusSltIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtFrPlusSltIdx.setDescription('Slot Index. For ISDN BRI Ports of MX300/30, io1(5) = isdn1(5) and io2(6) = isdn2(6).')
prtFrPlusPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 18, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtFrPlusPrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtFrPlusPrtIdx.setDescription('This attribute indicates a unique port number. This port number should be: - for ISDN cards: inPrt1(101)->inPrt50(150) - for MHS1 card : exPrt1(1) - for MHS3, MLS3 cards: exPrt1(1)->exPrt3(3) - for MLS6 cards: exPrt1(1)->exPrt6(6).')
prtFrPlusNotSegmentedPriorities = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 18, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1).clone(hexValue="00")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtFrPlusNotSegmentedPriorities.setStatus('mandatory')
if mibBuilder.loadTexts: prtFrPlusNotSegmentedPriorities.setDescription("This parameter is relevant only for FR+ protocol and asks the MXcess NOT to segment data with specified priorities: from LSB: bit 1 is for priority 1, bit 2 is for priority 2, .... till bit 7 for priority 7. - a priority selected to be segmented : its bit will be '0' - a priority not to be segmented : its bit will be '1' Default is 00000000; i.e, segment all priorities.")
prtMl4CnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 19, 1), )
if mibBuilder.loadTexts: prtMl4CnfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtMl4CnfgTable.setDescription('This is an extension table for MTML-4 card parameters.')
prtMl4CnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 19, 1, 1), ).setIndexNames((0, "DACS-MIB", "prtMl4CnfgIdx"), (0, "DACS-MIB", "prtMl4SltIdx"), (0, "DACS-MIB", "prtMl4PrtIdx"))
if mibBuilder.loadTexts: prtMl4CnfgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtMl4CnfgEntry.setDescription('')
prtMl4CnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 19, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtMl4CnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtMl4CnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg. The write operation is valid only to the TmpCnfg.')
prtMl4SltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 19, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtMl4SltIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtMl4SltIdx.setDescription('This attribute indicates a unique slot position where the module is inserted.')
prtMl4PrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 19, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("exPrt1", 1), ("exPrt2", 2), ("exPrt3", 3), ("exPrt4", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtMl4PrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtMl4PrtIdx.setDescription('This attribute indicates a unique port number.')
prtMl4SigProfile = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 19, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("notApplicable", 1), ("none", 2), ("p1", 3), ("p2", 4), ("p3", 5), ("p4", 6), ("p5", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtMl4SigProfile.setStatus('mandatory')
if mibBuilder.loadTexts: prtMl4SigProfile.setDescription('This object indicates the Signaling Profile of the port. none - when the Frame is G732N (no MF). p1 = profile 1 p2 = profile 2 p3 = profile 3 p4 = profile 4 p5 = profile 5 ')
prtMl4CGA = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 19, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("trans", 2), ("full", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtMl4CGA.setStatus('mandatory')
if mibBuilder.loadTexts: prtMl4CGA.setDescription("This object selects the method used to signal the CGA state to the other end, through the main link. 'none' - non-transparent mode. When one of the links (main) will be in Out Of Service state, both 'Data/Voice Oos' and 'Oos' will be transmitted to the other end. 'trans' - when one of the links (main) will be in Out Of Service state, 'Data/Voice Oos' will be transmitted to the other end. 'full' - fully-transparent mode. When one of the links (main) will be in Out Of Service state, neither 'Data/Voice Oos' nor 'Oos' will be transmitted to the other end.")
prtMl4Oos = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 19, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("notSupported", 2), ("forcedIdle", 3), ("forcedBusy", 4), ("busyIdle", 5), ("idleBusy", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtMl4Oos.setStatus('mandatory')
if mibBuilder.loadTexts: prtMl4Oos.setDescription("'idle' = '0' = on-hook, idle state 'busy' = '1' = off-hook, busy state 'forcedIdle' = SP = both A and B signaling bits are forced to '0' during out-of-service periods. 'forcedBusy' = MK = both A and B signaling bits are forced to '1' during out-of-service periods. 'busyIdle' = MK_SP = A and B bits are forced to '1' for 2.5 seconds; then they are switched to '0' until out-of-service condition disappears. 'idleBusy' = SP_MK = A and B bits are forced to '0' for 2.5 seconds; then they are switched to '1' until out-of-service condition disappears. - for T1: '0'=0 ; '1'=1 - for E1: '0'=1 ; '1'=0 ")
prtMl4VoiceOos = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 19, 1, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtMl4VoiceOos.setStatus('mandatory')
if mibBuilder.loadTexts: prtMl4VoiceOos.setDescription('Voice Out-Of-Service code. Valid range: (0 - FF HEX). For agents that do not support this feature, the value will always be 0.')
prtMl4DataOos = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 19, 1, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtMl4DataOos.setStatus('mandatory')
if mibBuilder.loadTexts: prtMl4DataOos.setDescription('Data Out-Of-Service code. Valid range: (0 - FF HEX). For agents that do not support this feature, the value will always be 0.')
prtMl4Service = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 19, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("leasedLine", 2), ("v51", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtMl4Service.setStatus('mandatory')
if mibBuilder.loadTexts: prtMl4Service.setDescription('Link Service. leasedLine - usual TDM interface. v51 - V5.1 interface. ')
prtAcmCnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 20, 1), )
if mibBuilder.loadTexts: prtAcmCnfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtAcmCnfgTable.setDescription('This is a table for ACM port parameters.')
prtAcmCnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 20, 1, 1), ).setIndexNames((0, "DACS-MIB", "prtAcmCnfgIdx"), (0, "DACS-MIB", "prtAcmSltIdx"), (0, "DACS-MIB", "prtAcmPrtIdx"))
if mibBuilder.loadTexts: prtAcmCnfgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtAcmCnfgEntry.setDescription('')
prtAcmCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 20, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtAcmCnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtAcmCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg. The write operation is valid only to the TmpCnfg.')
prtAcmSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 20, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtAcmSltIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtAcmSltIdx.setDescription('This attribute indicates a unique slot position where the module is inserted.')
prtAcmPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 20, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("exPrt1", 1), ("exPrt2", 2), ("exPrt3", 3), ("exPrt4", 4), ("exPrt5", 5), ("exPrt6", 6), ("exPrt7", 7), ("exPrt8", 8), ("exPrt9", 9), ("exPrt10", 10), ("exPrt11", 11), ("exPrt12", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtAcmPrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtAcmPrtIdx.setDescription('This attribute indicates a unique port number.')
prtAcmConnect = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 20, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtAcmConnect.setStatus('mandatory')
if mibBuilder.loadTexts: prtAcmConnect.setDescription('This attribute indicates whether the port should be connected or not. Only a connected port can perform activity.')
prtAcmActiveState = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 20, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("low", 2), ("high", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtAcmActiveState.setStatus('mandatory')
if mibBuilder.loadTexts: prtAcmActiveState.setDescription('This attribute indicates the Electric Active State of the port.')
prtAcmAlrString = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 2, 3, 2, 20, 1, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 35))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtAcmAlrString.setStatus('mandatory')
if mibBuilder.loadTexts: prtAcmAlrString.setDescription('Alarm string selected by user for the Inbound ports. This object is applicable only for the Inbound Ports: ext-5..ext-12. For the Outbound Ports (ext-1..ext-4), the size of this string will be 0.')
alarmsTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 3, 2) + (0,1)).setObjects(("DACS-MIB", "alrBufDescription"))
if mibBuilder.loadTexts: alarmsTrap.setDescription('This trap is sent whenever alarm occurs in the agent.')
sanityTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 3, 2) + (0,2)).setObjects(("DACS-MIB", "agnSSanityCheckStatus"), ("DACS-MIB", "agnCSaveCnfgIdxCmd"))
if mibBuilder.loadTexts: sanityTrap.setDescription('This trap is sent after a data base update. It returns the sanity result status and the configuration no. checked. If the result is of Flip DB Sanity Check, the configuration no. sent will be 0. If the result is of Variant Sanity Check, the configuration no. sent will be 100.')
cnfgFlipTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 3, 2) + (0,3)).setObjects(("DACS-MIB", "agnSActiveCnfg"))
if mibBuilder.loadTexts: cnfgFlipTrap.setDescription('This trap is sent upon change of the active Configuration DB. Attached, is the new active Configuration no.')
flipDbChangeTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 3, 2) + (0,4))
if mibBuilder.loadTexts: flipDbChangeTrap.setDescription('This trap is sent upon change of the active Flip tables (Flip DB).')
statusChangedTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 3, 2) + (0,5)).setObjects(("DACS-MIB", "agnLed"))
if mibBuilder.loadTexts: statusChangedTrap.setDescription('This trap is sent upon any change of the LEDs status.')
agnTsTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 11, 1), )
if mibBuilder.loadTexts: agnTsTable.setStatus('mandatory')
if mibBuilder.loadTexts: agnTsTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry.')
agnTsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 11, 1, 1), ).setIndexNames((0, "DACS-MIB", "agnTsCnfgIdx"), (0, "DACS-MIB", "agnTsSltIdx"), (0, "DACS-MIB", "agnTsPrtIdx"), (0, "DACS-MIB", "agnTsIdx"), (0, "DACS-MIB", "agnTsBitIdx"), (0, "DACS-MIB", "agnTsConSltIdx"), (0, "DACS-MIB", "agnTsConPrtIdx"), (0, "DACS-MIB", "agnTsConIdx"))
if mibBuilder.loadTexts: agnTsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: agnTsEntry.setDescription('')
agnTsCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 11, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnTsCnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: agnTsCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg. ')
agnTsSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 11, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("io13", 17), ("io14", 18), ("io15", 19), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnTsSltIdx.setStatus('mandatory')
if mibBuilder.loadTexts: agnTsSltIdx.setDescription('This attribute indicates a unique slot position where the card is inserted.')
agnTsPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 11, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnTsPrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: agnTsPrtIdx.setDescription('This attribute indicates a unique external or internal port number. For MP: exPrt1 (1) , exPrt2 (2) , exPrt3 (3) , exPrt4 (4) , exPrt5 (5) , exPrt6 (6) , exPrt7 (7) , exPrt8 (8) , exPrt9 (9) , exPrt10 (10) , exPrt11 (11) , exPrt12 (12) , inPrt1 (101) , inPrt2 (102) , inPrt3 (103) , inPrt4 (104) , inPrt5 (105) , inPrt6 (106) , inPrt7 (107) , inPrt8 (108) , inPrt9 (109) , inPrt10 (110) , inPrt11 (111) , inPrt12 (112) ')
agnTsIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 11, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnTsIdx.setStatus('mandatory')
if mibBuilder.loadTexts: agnTsIdx.setDescription('This attribute indicates a unique index for TS (Time-Slot). - for T1 ports - 1..24, Fbit(25) - for E1 ports - 1..31 - for HDSL ports - 1..32 ; 32 will represent TS0.')
agnTsBitIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 11, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnTsBitIdx.setStatus('mandatory')
if mibBuilder.loadTexts: agnTsBitIdx.setDescription('This attribute indicates a unique index for the Bit of each TS (Time-Slot). 1..8 - Bit 1.. Bit 8 255 - notApplicable This object is applicable only in Split Time-Slot cases.')
agnTsConSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 11, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("io13", 17), ("io14", 18), ("io15", 19), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnTsConSltIdx.setStatus('mandatory')
if mibBuilder.loadTexts: agnTsConSltIdx.setDescription('This attribute indicates a unique slot position In the Mux where the TS is routed to.')
agnTsConPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 11, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnTsConPrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: agnTsConPrtIdx.setDescription('This attribute indicates a unique port id the TS is routed to. notApplicable - when agnTsType=mng or spare For MP: exPrt1 (1) .. exPrt12 (12) , notApplicable(100), inPrt1 (101) .. inPrt48 (148). ')
agnTsConIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 11, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnTsConIdx.setStatus('mandatory')
if mibBuilder.loadTexts: agnTsConIdx.setDescription("This attribute indicates a unique TS number the Src TS is routed to. Valid values: - for T1 ports - 1..24, Fbit(25) - for E1 ports - 1..31 - for HDSL ports - 1..32 ; 32 will represent TS0. - notApplicable - 255 (for ports that don't have TSs).")
agnTsType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 11, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 6, 7))).clone(namedValues=NamedValues(("unknown", 1), ("voice", 2), ("data", 3), ("vcMP", 4), ("mng", 6), ("spare", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnTsType.setStatus('mandatory')
if mibBuilder.loadTexts: agnTsType.setDescription('Time-Slot Type - regarding its connection and media type. voice, data, vcMP - connected and the media is specified. mng - management. This TS is Dedicated to Management (not disconnected, but not connected to another port). spare - applicable for ML-20 only. These TSs should be reserved for future connection, though at the moment are not connected.')
agnTsRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 11, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 6))).clone(namedValues=NamedValues(("active", 1), ("destroy", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnTsRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: agnTsRowStatus.setDescription('This attribute allows to create/delete a row in this table. For creating a row, the NMS should set agnTsRowStatus.255.id2.id3.id4.id5.id6.id7.id8 = active(1). For destroying a row, the NMS should set: agnTsRowStatus.255.id2.id3.id4.id5.id6.id7.id8 = destroy(6). Only rows with status active(1) are relevant.')
agnTsDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 1, 2, 11, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("notApplicable", 1), ("rx", 2), ("tx", 3), ("both", 4), ("bcastSrc", 5), ("bcastDst", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnTsDirection.setStatus('mandatory')
if mibBuilder.loadTexts: agnTsDirection.setDescription("Direction of the connection. This parameter is especially important when in MP a ML is connected to an IO port that has no TSs, so it doesn't appear in the TS Assignment for the first 5 indexes. notApplicable - for products that do not support this object or for certain TS Types (for example: mng, spare) rx - the ML only Receives from the IO Port (the ML will appear in the first 5 indexes). tx - the ML only Transmits to the IO Port (the ML will appear in the first 5 indexes). Nothing is received back. both - the ML Receives and Transmits to the IO Port (the ML will appear in the first 5 indexes). bcastSrc - the ML is a Broadcast-Bidirectional Source. It Transmits to one or several IO Ports (including the one that appears in the last 3 indexes) and sometimes receives. The Port that responds is dynamic (it can be another each time). The ML will appear in the first 5 indexes. bcastDst - the ML is a Broadcast-Bidirectional Destination. Therefore, it Receives and sometimes Transmits. The ML will appear in the first 5 indexes.")
dacsMux = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 3))
systemDacsMux = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 3, 1))
mdlDacsMux = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 3, 2))
prtDacsMux = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 3, 3))
genDacsMux = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 3, 4))
sysSa = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 1))
sysHub = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 2))
sysStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3))
sysCurrentAlr = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 4))
sysBufferAlr = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 5))
sysConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6))
sysDbase = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 7))
sysSaSwchStatus = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSaSwchStatus.setStatus('mandatory')
if mibBuilder.loadTexts: sysSaSwchStatus.setDescription("This object indicates the status of the switches on the SA unit. Each switch is represented by a bit. The status is a sum of 2**n, according to the bits. For SMODs products see modem's specification. For DXC product see the following: There are 4 switches: bit 0 SP-PAR (LSB) '1' - Default parameters bit 1 PSWRD '1' - Password=default '0' - Password=user selected bit 2 DB-INIT '1' - DB initiated with default '0' - DB initiated with NVRAM contents bit 3 PC-SP (MSB) '1' - Management by terminal only '0' - Management by NMS Example: If SP-PAR and PSWRD bits are set ('1'), the value will be 3 (2**1 + 2**0). When the status of the switches is unknown, the value of this object will be 255.")
sysSaSwRevision = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSaSwRevision.setStatus('mandatory')
if mibBuilder.loadTexts: sysSaSwRevision.setDescription('This object indicates the Software revision of the system.')
sysSaHwVersion = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSaHwVersion.setStatus('mandatory')
if mibBuilder.loadTexts: sysSaHwVersion.setDescription('This object indicates the Hardware version of the system.')
sysSaPorts = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSaPorts.setStatus('mandatory')
if mibBuilder.loadTexts: sysSaPorts.setDescription("This object indicates the ports that are present in the system. Each possible port is represented by a bit. The value of this object is a sum of 2**n, n=number of bits. '1' - means that the port exists '0' - means that the port does not exist For detailed bit assignment, see product's spec. Bit 0 = LSB When this object is not relevant, the value will be 0. In some cases, this object may represent ports configuration of the system AND its far-end unit.")
sysSaReadSwch = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSaReadSwch.setStatus('mandatory')
if mibBuilder.loadTexts: sysSaReadSwch.setDescription('This object indicates wether the configuration will be read from the DIP switches on the SA (stand alone) unit. Each switch is represented by a bit. If the bit is 1: the configuration will be read from the HW switch position. If the bit is 0: the configuration will be read from the SW user configuration. The DIP switches are different in each of the RAD devices. In the Tiny Router (starting from the LSB) the following switches exist: Bit 0: WAN Loop Bit 1: LAN Full Duplex (When LAN AUI connector, it is SQE) Bit 2: PPP (When WAN 4 Wire connector, it is LONG) Bit 3: IP Learn')
sysChas = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 2, 1))
chassTotalNoOfSlt = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassTotalNoOfSlt.setStatus('mandatory')
if mibBuilder.loadTexts: chassTotalNoOfSlt.setDescription('This object indicates the number of physical slots in the Hub chassis.')
chassTotalNoOfIoSlt = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassTotalNoOfIoSlt.setStatus('mandatory')
if mibBuilder.loadTexts: chassTotalNoOfIoSlt.setDescription('This object indicates the total number of physical IO slots in the chassis, (not all slots must be occupied and active).')
chassTotalNoOfPsSlt = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassTotalNoOfPsSlt.setStatus('mandatory')
if mibBuilder.loadTexts: chassTotalNoOfPsSlt.setDescription('This object indicates the number of physical Power Supply slots in the chassis.')
chassTotalNoOfClSlt = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassTotalNoOfClSlt.setStatus('mandatory')
if mibBuilder.loadTexts: chassTotalNoOfClSlt.setDescription('This object indicates the number of physical Common Logic slots in the chassis.')
chassTotalNoOfMlSlt = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassTotalNoOfMlSlt.setStatus('mandatory')
if mibBuilder.loadTexts: chassTotalNoOfMlSlt.setDescription('This object indicates the number of physical Main Link slots in the chassis (Kmux).')
sysDcl = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 2, 2))
sysDclTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 2, 2, 1), )
if mibBuilder.loadTexts: sysDclTable.setStatus('mandatory')
if mibBuilder.loadTexts: sysDclTable.setDescription('All the entries of this table are identical (have the same value) for all the configurations (1..255) except the TmpCnfg. The write operation into the Table Objects is valid only for the TmpCnfg entry.')
sysDclEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 2, 2, 1, 1), ).setIndexNames((0, "DACS-MIB", "sysDclCnfgIdx"))
if mibBuilder.loadTexts: sysDclEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sysDclEntry.setDescription('')
sysDclCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 2, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysDclCnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: sysDclCnfgIdx.setDescription('This object indicates the Idx of the Cnfg(1..255) being accessed ; Idx of 255 relates to the TmpCnfg. This object is identical for all the configurations (1..255). Only the TmpCnf(255) might have a different value.')
sysDclRedundancy = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 2, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDclRedundancy.setStatus('mandatory')
if mibBuilder.loadTexts: sysDclRedundancy.setDescription(' DCL redundancy desired state.')
sysDclActiveCl = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 2, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("auto", 1), ("dclA", 2), ("dclB", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDclActiveCl.setStatus('mandatory')
if mibBuilder.loadTexts: sysDclActiveCl.setDescription("Active desired DCL. When 'auto' is selected, the system automatically selects the active DCL.")
sysDclFlipDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 2, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("t1min", 1), ("t2min", 2), ("t3min", 3), ("t4min", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDclFlipDelay.setStatus('mandatory')
if mibBuilder.loadTexts: sysDclFlipDelay.setDescription('If one DCL flip occured and a second one should be performed, the time from the previous flip is checked. If the time is shorter than the delay specified here (in minutes), the system should delay the flip operation until time reaches the specified delay.')
sysDclOnline = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 2, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dclA", 1), ("dclB", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysDclOnline.setStatus('mandatory')
if mibBuilder.loadTexts: sysDclOnline.setDescription('The active Dcl card of the agent.')
sysDclCopyDbTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 2, 2, 3), )
if mibBuilder.loadTexts: sysDclCopyDbTable.setStatus('mandatory')
if mibBuilder.loadTexts: sysDclCopyDbTable.setDescription('This table enables to copy a cofiguration from the Offline Dcl to the Online Dcl.')
sysDclCopyDbEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 2, 2, 3, 1), ).setIndexNames((0, "DACS-MIB", "sysDclCopyDbIdx"))
if mibBuilder.loadTexts: sysDclCopyDbEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sysDclCopyDbEntry.setDescription('')
sysDclCopyDbIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 2, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysDclCopyDbIdx.setStatus('mandatory')
if mibBuilder.loadTexts: sysDclCopyDbIdx.setDescription('This object indicates the Idx of the Cnfg(1..255) being accessed. ')
sysDclCopyDbCmd = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 2, 2, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDclCopyDbCmd.setStatus('mandatory')
if mibBuilder.loadTexts: sysDclCopyDbCmd.setDescription('When this command is sent to the agent, on(3), the Database specified (Db Idx), will be copied from the Offline Dcl to the Online Dcl. Afterwards the value of this object will automatically change to off(2). ')
sysSDateFormat = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4))).clone(namedValues=NamedValues(("ddMMYYYY", 1), ("mmDDYYYY", 2), ("yyyyMMDD", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSDateFormat.setStatus('mandatory')
if mibBuilder.loadTexts: sysSDateFormat.setDescription("This object indicates the date and time format used for the sysSDateAndTimeCmd and for the alarm buffer report. KM-2100 V1 and FCD-T1/E1 do not support the 'yyyyMMDD' format.")
sysSDateCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSDateCmd.setStatus('mandatory')
if mibBuilder.loadTexts: sysSDateCmd.setDescription("This object indicates the current date as it is known by the agent using its own real-time clock. The format would be as specified by the sysSDateFormat. This parameter can be set for time synchronization between the NMS and the Agent. * For KM-2100 V1 and FCD-T1/E1 - the string should contain '/' signs between day, month and year. Example: 12/08/1998. * For DXC and rest of the products - the string should contain '-' signs between day, month and year. Example: 12-08-1998. The day value will be in the range: 1..31. The month value will be in the range: 1..12. The year value will be in the range: 1996..2050 for products supporting the '-' format.")
sysSTimeCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSTimeCmd.setStatus('mandatory')
if mibBuilder.loadTexts: sysSTimeCmd.setDescription("This object indicates the current time as it is known by the agent using its own real-time clock. This parameter can be set for time synchronization between the NMS and the Agent. The string should contain ':' signs between hour, minute and second. Example: 11:05:58.")
sysSActiveCnfg = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSActiveCnfg.setStatus('mandatory')
if mibBuilder.loadTexts: sysSActiveCnfg.setDescription('This object specifies the configuration number, that is currently active and running.')
sysSEditCnfg = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSEditCnfg.setStatus('mandatory')
if mibBuilder.loadTexts: sysSEditCnfg.setDescription('This object indicates the unique configuration number that is currently loaded into the tmp working space for manipulation and update operations. Value of 255 means no config. is under editing process.')
sysSEditBy = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("none", 1), ("snmp", 2), ("terCon1", 3), ("terCon2", 4), ("terInbandCon1", 5), ("terInbandCon2", 6), ("lcd", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSEditBy.setStatus('mandatory')
if mibBuilder.loadTexts: sysSEditBy.setDescription('This entry indicates which MMI application is working on the edited config. The editing phase starts at the first modify operation and ends after a load operation.')
sysSClkSrc = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("master", 1), ("fallback", 2), ("internal", 3), ("ml", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSClkSrc.setStatus('mandatory')
if mibBuilder.loadTexts: sysSClkSrc.setDescription('This entry indicates the source of the system clock.')
sysSAlrStatus = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("off", 2), ("major", 3), ("minor", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSAlrStatus.setStatus('mandatory')
if mibBuilder.loadTexts: sysSAlrStatus.setDescription('Indicates the current alarm state only for system level. This object will be set to: - major (3): when there is at least one active (ON) major alarm . - minor (4): when there is no active major alarm, but there is at least one active minor alarm. - off(2): when there is no active (ON) major or minor alarms (since last clear operation).')
sysSAlrStatusAll = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("off", 2), ("major", 3), ("minor", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSAlrStatusAll.setStatus('mandatory')
if mibBuilder.loadTexts: sysSAlrStatusAll.setDescription('Indicates the current alarm state including all levels: system, card, port. This object will be set to: - major (3): when there is at least one active (ON) major alarm . - minor (4): when there is no active major alarm, but there is at least one active minor alarm. - off(2): when there is no active (ON) major or minor alarms (since last clear operation).')
sysSTestStatus = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSTestStatus.setStatus('mandatory')
if mibBuilder.loadTexts: sysSTestStatus.setDescription('Indicates the current test status (for all levels: system, card, port). This attribute will be set to: - on(3): when there is at least one test in progress on the system/card/port otherwise the value will be off(2).')
sysSSanityCheckStatus = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("fail", 2), ("warning", 3), ("ok", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSSanityCheckStatus.setStatus('mandatory')
if mibBuilder.loadTexts: sysSSanityCheckStatus.setDescription('Upon completion of the Sanity Check process on the TmpCnfg this object will be set to: - fail(2): when there is at least one error (which is not just a warning) encountered otherwise, - warning(3): when there are only warnings otherwise, - ok(4). The value should be unknown(1), if the TmpCnfg was changed after the last Sanity check.')
sysSNoOfSanityCheckErr = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSNoOfSanityCheckErr.setStatus('mandatory')
if mibBuilder.loadTexts: sysSNoOfSanityCheckErr.setDescription('This object indicates the number of errors/warnings discovered by the last Sanity Check process.')
sysSErrListTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 13), )
if mibBuilder.loadTexts: sysSErrListTable.setStatus('mandatory')
if mibBuilder.loadTexts: sysSErrListTable.setDescription('')
sysSErrListEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 13, 1), ).setIndexNames((0, "DACS-MIB", "sysSErrType"), (0, "DACS-MIB", "sysSErrIdx"))
if mibBuilder.loadTexts: sysSErrListEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sysSErrListEntry.setDescription('')
sysSErrType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("error", 1), ("warning", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSErrType.setStatus('mandatory')
if mibBuilder.loadTexts: sysSErrType.setDescription('The errors are recorded in the agent, in two separate lists, according to their type: error or warning.')
sysSErrIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 13, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSErrIdx.setStatus('mandatory')
if mibBuilder.loadTexts: sysSErrIdx.setDescription("Unique index number to identify an entry in the error or warning list . The maximum value cannot exceed the value of 'sysSNoOfSanityCheckErr' (actually, the sum of the Errors list max. index and the Warning list max. index should equal the value of'sysSNoOfSanityCheckErr').")
sysSErrDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 13, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSErrDescription.setStatus('mandatory')
if mibBuilder.loadTexts: sysSErrDescription.setDescription('This object is a full text description of the sanity check error including error code, IO slot and port numbers related to the code .')
sysSMaxNoOfCnfg = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSMaxNoOfCnfg.setStatus('mandatory')
if mibBuilder.loadTexts: sysSMaxNoOfCnfg.setDescription('Maximum number of configurations that can be defined and stored in the DACS agent. If the DACS agent has a large capacity, the maximum will be limited to 254.')
sysSSelfTestResult = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSSelfTestResult.setStatus('mandatory')
if mibBuilder.loadTexts: sysSSelfTestResult.setDescription("The test is performed by the active Common Logic card. The result will be a sum of 2**n according to the following bit convention: For DXC: bit 0 Database 1 Checksum Error (LSB) bit 1 Database 2 Checksum Error bit 2 I/O Expander Error bit 3 Counter Error bit 4 Matrix DPR Error bit 5 PS-A 5 Volt Error bit 6 PS-A 12 Volt Error bit 7 PS-B 5 Volt Error bit 8 PS-B 12 Volt Error bit 9 EPROM Failure For FCD: bit 0 I/O Expander Error (LSB) bit 1 Counter Error bit 2 EPROM Failure bit 3 Illegal Sys Config bit 4 SFIFO bit 5 EPIC Failure (ISDN) When a bit is ('1'), the error exists. When NO ERROR is encountered, this object's value will be 0.")
sysSRelayState = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("off", 2), ("on", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSRelayState.setStatus('mandatory')
if mibBuilder.loadTexts: sysSRelayState.setDescription('Indicates the current state of the alarm relay. notApplicable - for agents that do not support this object.')
sysSInvertedAlr = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("no", 2), ("yes", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSInvertedAlr.setStatus('mandatory')
if mibBuilder.loadTexts: sysSInvertedAlr.setDescription('Indicates if there is any Inverted alarm at any level of the system (sys, card, port). notApplicable - for agents that do not support this object.')
sysSRdnFlipTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 18), )
if mibBuilder.loadTexts: sysSRdnFlipTable.setStatus('mandatory')
if mibBuilder.loadTexts: sysSRdnFlipTable.setDescription('This table includes all the Flip events due to I/O Redundancy since last Clear command of this table.')
sysSRdnFlipEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 18, 1), ).setIndexNames((0, "DACS-MIB", "sysSRdnFlipIdx"))
if mibBuilder.loadTexts: sysSRdnFlipEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sysSRdnFlipEntry.setDescription('')
sysSRdnFlipIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 18, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSRdnFlipIdx.setStatus('mandatory')
if mibBuilder.loadTexts: sysSRdnFlipIdx.setDescription('Unique index number to identify an entry in the Redundancy Flip list.')
sysSRdnFlipSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 18, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("io13", 17), ("io14", 18), ("io15", 19), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSRdnFlipSlot.setStatus('mandatory')
if mibBuilder.loadTexts: sysSRdnFlipSlot.setDescription('The slot number from which Flip was performed.')
sysSRdnFlipPort = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 18, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSRdnFlipPort.setStatus('mandatory')
if mibBuilder.loadTexts: sysSRdnFlipPort.setDescription('The port number from which Flip was performed. For DXC: For external ports the convention used will be: - first two digits will be: (IO slot number+10) - last one/two digits will be the port number within the card, in odd numbers: port1 = 1 port2 = 3 port3 = 5 etc... Example: port2 of IO slot 11 will be: 213 . For internal ports the convention used will be: - first two digits will be: (IO slot number+10) - last one/two digits will be the port number within the card, in even numbers: port1 = 2 port2 = 4 port3 = 6 etc... Example: port2 of IO slot 11 will be: 214 . For MP: For external ports, the value will be as that of the port in the card. Example: external-3 -> 3 external-4 -> 4 For internal ports, the value will be 100 + the port in the card. Example: internal-1 -> 101 internal-4 -> 104 100=notApplicable (when Redundancy is at card level).')
sysSRdnFlipCause = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 18, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSRdnFlipCause.setStatus('mandatory')
if mibBuilder.loadTexts: sysSRdnFlipCause.setDescription('The last cause that caused the Flip from the Slot (Port) of sysSRdnSlot, sysSRdnPort.')
sysSRdnFlipDate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 18, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSRdnFlipDate.setStatus('mandatory')
if mibBuilder.loadTexts: sysSRdnFlipDate.setDescription('Flip event Date. The format will be the one selected by user for sysSDateFormat.')
sysSRdnFlipTime = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 18, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSRdnFlipTime.setStatus('mandatory')
if mibBuilder.loadTexts: sysSRdnFlipTime.setDescription('Flip event Time. The format will be hh:mm:ss.')
sysSRdnFlipTableClearCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSRdnFlipTableClearCmd.setStatus('mandatory')
if mibBuilder.loadTexts: sysSRdnFlipTableClearCmd.setDescription("This command, when Set to 'on', clears the Redundancy Flip table (sysSRdnFlipTable). After clear is performed, the agent will turn the value to 'off' automatically.")
sysSRdnFlipCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 3, 20), ObjectIdentifier()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSRdnFlipCmd.setStatus('mandatory')
if mibBuilder.loadTexts: sysSRdnFlipCmd.setDescription('This object enables the user to send a command to the Agent, to Flip from a current Online IO card to its Redundant card. The value sent will be an Object Identifier of an entry in the sysCRdnTable. This entry defines the Redundant couple of Slots on which the Flip is applied. Setting this object, will cause the Agent to Flip from current Online card to its Redundant card. This manual flip command is applicable only for entries having Redundancy Mode=Y Cable. Agent will send the value 0 for Get.')
sysSAlrTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 4, 1), )
if mibBuilder.loadTexts: sysSAlrTable.setStatus('mandatory')
if mibBuilder.loadTexts: sysSAlrTable.setDescription('List of system level current existing alarms .')
sysSAlrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 4, 1, 1), ).setIndexNames((0, "DACS-MIB", "sysSAlrIdx"))
if mibBuilder.loadTexts: sysSAlrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sysSAlrEntry.setDescription('')
sysSAlrIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 4, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSAlrIdx.setStatus('mandatory')
if mibBuilder.loadTexts: sysSAlrIdx.setDescription('An index number of the current system alarms.')
sysSAlrCode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 4, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSAlrCode.setStatus('mandatory')
if mibBuilder.loadTexts: sysSAlrCode.setDescription('This object indicates a code related to a specific alarm description. The list of codes and their related descriptions will be sent to NMS request (for display purpose) by alrGenTable.')
sysSAlrState = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4, 5))).clone(namedValues=NamedValues(("minor", 4), ("major", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSAlrState.setStatus('mandatory')
if mibBuilder.loadTexts: sysSAlrState.setDescription('This object indicates the alarm state.')
sysSAlarmMask = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSAlarmMask.setStatus('mandatory')
if mibBuilder.loadTexts: sysSAlarmMask.setDescription('Alarm Mask is : on/off.')
sysSAlarmInvert = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSAlarmInvert.setStatus('mandatory')
if mibBuilder.loadTexts: sysSAlarmInvert.setDescription('Alarm Invert is : on/off.')
sysSAlrClearCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 4, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSAlrClearCmd.setStatus('mandatory')
if mibBuilder.loadTexts: sysSAlrClearCmd.setDescription('Setting this attribute to ON, will enforce a clear operation on the system level alarms . Upon completion, the value will automatically change to off(2).')
sysSAlrClearAllCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 4, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSAlrClearAllCmd.setStatus('mandatory')
if mibBuilder.loadTexts: sysSAlrClearAllCmd.setDescription('Setting this attribute to ON, will enforce a clear operation on all levels alarms . Upon completion, the value will automatically change to off(2).')
sysSAlrMaskAll = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 4, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSAlrMaskAll.setStatus('mandatory')
if mibBuilder.loadTexts: sysSAlrMaskAll.setDescription('on(3) - will cause masking of all the system level alarms. These alarms will not be sent to NMS and will not be taken into account for Alarms Status. off(2) - will unmask all system level alarms except those masked via the sysSAlrMask. ')
sysSAlrMask = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 4, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSAlrMask.setStatus('mandatory')
if mibBuilder.loadTexts: sysSAlrMask.setDescription("This object is a mask that indicates which system level alarms are masked. The masked alarms (their bit is set to '1') are neither sent to the manager, nor taken into account for alarm status and LEDs. Bit no. = Alarm code The bits that do not belong to the system level will be 0. This object is applicable only when sysSAlrMaskAll=off (otherwise all system alarms are masked). Example: When Alarms having the codes 6 and 11 are masked, the value of this object will be 840 (hex).")
sysSAlrDataUpdateCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 4, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSAlrDataUpdateCmd.setStatus('mandatory')
if mibBuilder.loadTexts: sysSAlrDataUpdateCmd.setDescription('on(3) - will cause Update of the Alarms Severity, Attributes and Report tables. off(2) - Upon completion, the value will automatically change to off(2).')
sysBufferAlrTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 5, 1), )
if mibBuilder.loadTexts: sysBufferAlrTable.setStatus('mandatory')
if mibBuilder.loadTexts: sysBufferAlrTable.setDescription('List of current existing alarms (of all levels).')
sysBufferAlrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 5, 1, 1), ).setIndexNames((0, "DACS-MIB", "sysBufferAlrIdx"))
if mibBuilder.loadTexts: sysBufferAlrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sysBufferAlrEntry.setDescription('')
sysBufferAlrIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 5, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysBufferAlrIdx.setStatus('mandatory')
if mibBuilder.loadTexts: sysBufferAlrIdx.setDescription('An index number of the current alarms.')
sysBufferAlrCode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 5, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysBufferAlrCode.setStatus('mandatory')
if mibBuilder.loadTexts: sysBufferAlrCode.setDescription("This object indicates a code related to a specific alarm description. The list of codes and thir related descriptions will be known by the NMS (for display purpose) and will appear in the unit's user manual.")
sysBufferAlrState = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 5, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 4, 5))).clone(namedValues=NamedValues(("off", 2), ("minor", 4), ("major", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysBufferAlrState.setStatus('mandatory')
if mibBuilder.loadTexts: sysBufferAlrState.setDescription('This object indicates the alarm type. minor/major - indicates appearance of the problem and the type. event - indicates occurence of an event. off - indicates disappearance of a minor/major type alarm. ')
sysBufferAlrSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 5, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 255))).clone(namedValues=NamedValues(("psA", 1), ("psB", 2), ("clA", 3), ("clB", 4), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("io13", 17), ("io14", 18), ("io15", 19), ("kmxPsA", 101), ("kmxPsB", 102), ("kmxMlA", 103), ("kmxMlB", 104), ("kmxCl", 105), ("kmxOpt", 106), ("kmxIO1", 107), ("kmxIO2", 108), ("kmxIO3", 109), ("kmxIO4", 110), ("kmxIO5", 111), ("kmxIO6", 112), ("kmxIO7", 113), ("kmxIO8", 114), ("kmxIO9", 115), ("kmxIO10", 116), ("kmxIO11", 117), ("kmxIO12", 118), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysBufferAlrSlot.setStatus('mandatory')
if mibBuilder.loadTexts: sysBufferAlrSlot.setDescription("The slot number this alarm refers to. When the alarm refers to a system function OR the DACS agent is a stand-alone unit, the value will be 'notApplicable(255)'.")
sysBufferAlrPort = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 5, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysBufferAlrPort.setStatus('mandatory')
if mibBuilder.loadTexts: sysBufferAlrPort.setDescription('The port number this alarm refers to. If the port number is irrelevant to this alarm (if it is a system/card level alarm) the value will be 9999.')
sysBufferAlrDate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 5, 1, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysBufferAlrDate.setStatus('mandatory')
if mibBuilder.loadTexts: sysBufferAlrDate.setDescription('The date when the alarm occured. The format will be according to sysSDateFormat.')
sysBufferAlrTime = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 5, 1, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysBufferAlrTime.setStatus('mandatory')
if mibBuilder.loadTexts: sysBufferAlrTime.setDescription('The time when the alarm occured.')
sysBufferAlrClearCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 5, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysBufferAlrClearCmd.setStatus('mandatory')
if mibBuilder.loadTexts: sysBufferAlrClearCmd.setDescription('Setting this attribute to ON, will enforce a clear operation on the Alarms Buffer. Upon completion, the value will automatically change to off(2).')
sysCClkSrcTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 1), )
if mibBuilder.loadTexts: sysCClkSrcTable.setStatus('mandatory')
if mibBuilder.loadTexts: sysCClkSrcTable.setDescription('All the entries of this table are identical (have the same value) for all the configurations (1..255) except the TmpCnfg. The write operation into the Table Objects is valid only for the TmpCnfg entry.')
sysCClkSrcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 1, 1), ).setIndexNames((0, "DACS-MIB", "sysCClkCnfgIdx"), (0, "DACS-MIB", "sysCClkSrcIdx"))
if mibBuilder.loadTexts: sysCClkSrcEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sysCClkSrcEntry.setDescription('')
sysCClkCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysCClkCnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: sysCClkCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg(1..255) being accessed ; Idx of 255 relates to the TmpCnfg.')
sysCClkSrcIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("master", 1), ("fallback", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysCClkSrcIdx.setStatus('mandatory')
if mibBuilder.loadTexts: sysCClkSrcIdx.setDescription('An index in the table. There are only two entries in the table. master - refers Master clock parameters fallback - refers Fallback clock parameters')
sysCClkSrcMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 255))).clone(namedValues=NamedValues(("none", 1), ("internal", 2), ("rxClk", 3), ("station", 4), ("lbt", 5), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysCClkSrcMode.setStatus('mandatory')
if mibBuilder.loadTexts: sysCClkSrcMode.setDescription('This entry indicates the source the nodal timing is locked to. none - is an invalid option for Master clock. internal - is an invalid option for Fallback clock . station - is an invalid option for a stand-alone unit. lbt - loop-back timing notApplicable - for ML source of Kmux or ML Timing combinations when Master/Fallback clock are not applicable.')
sysCClkSrcPrt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 1, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysCClkSrcPrt.setStatus('mandatory')
if mibBuilder.loadTexts: sysCClkSrcPrt.setDescription('This entry is valid only when working in rxClk mode. For invalid entry the return value will be 9999. The valid port number depends on the IO slot no., the installed card type and the port type: outside, inside, SP. * The SP ports will be numbered as follows: - SP port 1 : 1 - SP port 2 : 2 For external ports the convention used will be (for DXC): - first two digits will be: (IO slot number+10) - last one/two digits will be the port number within the card, in odd numbers: port1 = 1 port2 = 3 port3 = 5 etc... Example: port2 of IO slot 11 will be: 213 . For internal ports the convention used will be (for DXC): - first two digits will be: (IO slot number+10) - last one/two digits will be the port number within the card, in even numbers: port1 = 2 port2 = 4 port3 = 6 etc... Example: port2 of IO slot 11 will be: 214 . For Kmux, the port will be according to : Slot*100+Ch.')
sysCClkStationFreq = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("f1544Khz", 2), ("f2048Khz", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysCClkStationFreq.setStatus('mandatory')
if mibBuilder.loadTexts: sysCClkStationFreq.setDescription("This entry indicates the frequency of the station clock when the source is 'station'. The value will be applicable only when the sysCClkSrcMode is 'station'. ")
sysCnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 2), )
if mibBuilder.loadTexts: sysCnfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: sysCnfgTable.setDescription('All the entries of this table are identical (have the same value) for all the configurations (1..255) except the TmpCnfg. The write operation into the Table Objects is valid only for the TmpCnfg entry.')
sysCnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 2, 1), ).setIndexNames((0, "DACS-MIB", "sysCnfgIdx"))
if mibBuilder.loadTexts: sysCnfgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sysCnfgEntry.setDescription('')
sysCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysCnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: sysCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg(1..255) being accessed ; Idx of 255 relates to the TmpCnfg.')
sysCMatrixMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("bidirectional", 2), ("unidirectional", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysCMatrixMode.setStatus('mandatory')
if mibBuilder.loadTexts: sysCMatrixMode.setDescription('Indicates the TS Matrix Mode: bidirectional - TS Assignment Matrix is symmetric. unidirectional - TS Assignment Matrix can be asymmetric. notApplicable - for agents that do not support this feature.')
sysCIsdnFormat = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("te", 2), ("nt", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysCIsdnFormat.setStatus('mandatory')
if mibBuilder.loadTexts: sysCIsdnFormat.setDescription('ISDN format. This parameter controls the operation mode of the ISDN ports. te - ISDN timing is derived from the signal received from the equipment it is connected to. nt - timing of the transmit path is locked to the nodal timing source. notApplicable - for agents that do not support this feature.')
sysCRoutingOnEth = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("none", 2), ("proprietary", 3), ("rip2", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysCRoutingOnEth.setStatus('mandatory')
if mibBuilder.loadTexts: sysCRoutingOnEth.setDescription('Mng Routing Protocol on the online CL Ethernet port.')
sysCRdnTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 3), )
if mibBuilder.loadTexts: sysCRdnTable.setStatus('mandatory')
if mibBuilder.loadTexts: sysCRdnTable.setDescription('Configuration of all Redundant I/O cards and ports. The write operation into the table objects is valid only for the TmpCnfg. A Slot/Port that have no Redundancy, will not exist in this table.')
sysCRdnEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 3, 1), ).setIndexNames((0, "DACS-MIB", "sysCRdnCnfgIdx"), (0, "DACS-MIB", "sysCRdnPrimeSlot"), (0, "DACS-MIB", "sysCRdnPrimePort"))
if mibBuilder.loadTexts: sysCRdnEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sysCRdnEntry.setDescription('')
sysCRdnCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysCRdnCnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: sysCRdnCnfgIdx.setDescription('This object indicates the Idx of the Cnfg(1..255) being accessed ; Idx of 255 relates to the TmpCnfg.')
sysCRdnPrimeSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("io13", 17), ("io14", 18), ("io15", 19), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysCRdnPrimeSlot.setStatus('mandatory')
if mibBuilder.loadTexts: sysCRdnPrimeSlot.setDescription('The slot number of the Primary card of Redundancy. The Primary card should be the card that user wishes to be the online card (usually the more important one). For some Redundancy modes the importance of the redundant cards/ports is the same. ')
sysCRdnPrimePort = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysCRdnPrimePort.setStatus('mandatory')
if mibBuilder.loadTexts: sysCRdnPrimePort.setDescription('The port number. For DXC: For external ports the convention used will be: - first two digits will be: (IO slot number+10) - last one/two digits will be the port number within the card, in odd numbers: port1 = 1 port2 = 3 port3 = 5 etc... Example: port2 of IO slot 11 will be: 213 . For internal ports the convention used will be: - first two digits will be: (IO slot number+10) - last one/two digits will be the port number within the card, in even numbers: port1 = 2 port2 = 4 port3 = 6 etc... Example: port2 of IO slot 11 will be: 214 . For MP: For external ports, the value will be as that of the port in the card. Example: external-3 -> 3 external-4 -> 4 For internal ports, the value will be 100 + the port in the card. Example: internal-1 -> 101 internal-4 -> 104 100=notApplicable (when Redundancy is at card level).')
sysCRdnSecSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("io13", 17), ("io14", 18), ("io15", 19), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysCRdnSecSlot.setStatus('mandatory')
if mibBuilder.loadTexts: sysCRdnSecSlot.setDescription('The slot number of the Secondary card of Redundancy matching the Primary slot.')
sysCRdnSecPort = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 3, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysCRdnSecPort.setStatus('mandatory')
if mibBuilder.loadTexts: sysCRdnSecPort.setDescription('The port number. For DXC: For external ports the convention used will be: - first two digits will be: (IO slot number+10) - last one/two digits will be the port number within the card, in odd numbers: port1 = 1 port2 = 3 port3 = 5 etc... Example: port2 of IO slot 11 will be: 213 . For internal ports the convention used will be: - first two digits will be: (IO slot number+10) - last one/two digits will be the port number within the card, in even numbers: port1 = 2 port2 = 4 port3 = 6 etc... Example: port2 of IO slot 11 will be: 214 . For MP: For external ports, the value will be as that of the port in the card. Example: external-3 -> 3 external-4 -> 4 For internal ports, the value will be 100 + the port in the card. Example: internal-1 -> 101 internal-4 -> 104 100=notApplicable (when Redundancy is at card level).')
sysCRdnMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("dualCableAIS", 2), ("yCable", 3), ("dualCableParallelTx", 4), ("backup", 5), ("singleSlotProtection", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysCRdnMode.setStatus('mandatory')
if mibBuilder.loadTexts: sysCRdnMode.setDescription('Redundancy Mode. DXC supports: yCable(3), singleSlotProtection(6) and dualCableParallelTx(4) MP supports: dualCableAIS(2), yCable(3), dualCableParallelTx(4) and backup(5). backup - will be used when a port is backup of more than one port.')
sysCRdnRecMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("auto", 2), ("manual", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysCRdnRecMode.setStatus('mandatory')
if mibBuilder.loadTexts: sysCRdnRecMode.setDescription('Recovery Mode. This object determines if after recovery of the failed card/port it will become on-line again or not: auto - automatic . In this case, the failed card/port will become on-line again after recovery, automatically. manual - In this case, the failed card/port will not become on-line again after recovery.')
sysCRdnRecTime = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 3, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysCRdnRecTime.setStatus('mandatory')
if mibBuilder.loadTexts: sysCRdnRecTime.setDescription('Redundancy Recovery Time (sec). After switching to the current online card, the next switch can be performed only after a minimum time, indicated by this object. This object is applicable only when sysCRdnRecMode=auto.')
sysCRdnHwSwFlip = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("hw", 2), ("sw", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysCRdnHwSwFlip.setStatus('mandatory')
if mibBuilder.loadTexts: sysCRdnHwSwFlip.setDescription('HW or SW decision for Redundancy Flip. This object is applicable only for sysCRdnMode=singleSlotProtection. HW - decision is by I/O card SW - decision is by CL SW.')
sysCRdnRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 3, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 6))).clone(namedValues=NamedValues(("active", 1), ("destroy", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysCRdnRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: sysCRdnRowStatus.setDescription('This parameter allows NMS to create/delete entries of this table.')
sysCRdnOnline = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 6, 3, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("primary", 2), ("secondary", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysCRdnOnline.setStatus('mandatory')
if mibBuilder.loadTexts: sysCRdnOnline.setDescription('Status - who is the Online (current) Redundancy Slot/Port. This object shows only the Online Slot/Port regarding the Redundancy. mdlSActivity or prtGenActiveStatus of the same Slot/Port may be Offline.')
sysDbaseSanityCheckCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 7, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDbaseSanityCheckCmd.setStatus('mandatory')
if mibBuilder.loadTexts: sysDbaseSanityCheckCmd.setDescription('Setting this attribute to on(3) will initiate the process of Sanity check on the TmpCnfg. Upon completion, the value will automatically change to off(2).')
sysDbaseDownloadCnfgIdxCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 7, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDbaseDownloadCnfgIdxCmd.setStatus('mandatory')
if mibBuilder.loadTexts: sysDbaseDownloadCnfgIdxCmd.setDescription('This attribute specifies the Id of the target RealCnfg to which the TmpCnfg should be transferred. Upon set command, the DACS agent will initiate the Sanity-Check process. If successful, the actual transfer will be performed. If there will be errors, the user will have to perform the command again after errors correction. The operation is valid only on configuration numbers that do not exceed sysSMaxNoOfCnfg.')
sysDbaseUploadCnfgIdxCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 7, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDbaseUploadCnfgIdxCmd.setStatus('mandatory')
if mibBuilder.loadTexts: sysDbaseUploadCnfgIdxCmd.setDescription('This attribute specifies the Id of the source Cnfg to be loaded into the TmpCnfg. Upon set operation the actual transfer will be initiated. The operation is valid only on configuration numbers that do not exceed sysSMaxNoOfCnfg.')
sysDbaseFlipTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 7, 4), )
if mibBuilder.loadTexts: sysDbaseFlipTable.setStatus('mandatory')
if mibBuilder.loadTexts: sysDbaseFlipTable.setDescription('Dbase Flip time and activation for every configuration.')
sysDbaseFlipEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 7, 4, 1), ).setIndexNames((0, "DACS-MIB", "sysDbaseFlipIdx"))
if mibBuilder.loadTexts: sysDbaseFlipEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sysDbaseFlipEntry.setDescription('')
sysDbaseFlipIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 7, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysDbaseFlipIdx.setStatus('mandatory')
if mibBuilder.loadTexts: sysDbaseFlipIdx.setDescription('This attribute indicates the Idx of the Cnfg being the target Configuration.')
sysDbaseFlipTime = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 7, 4, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDbaseFlipTime.setStatus('mandatory')
if mibBuilder.loadTexts: sysDbaseFlipTime.setDescription('This attribute indicates the time (HH:MM) when this data base will start being used by the Tmp config.')
sysDbaseFlipActivation = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 1, 7, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDbaseFlipActivation.setStatus('mandatory')
if mibBuilder.loadTexts: sysDbaseFlipActivation.setDescription('This attribute indicates if the Dbase flip will be activated at the time specified for this configuration (enable) or not (disable). No more than one flip should be enabled for the same time.')
mdlGen = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1))
mdlCl = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 2))
mdlPs = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 3))
mdlSTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 1), )
if mibBuilder.loadTexts: mdlSTable.setStatus('mandatory')
if mibBuilder.loadTexts: mdlSTable.setDescription('')
mdlSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 1, 1), ).setIndexNames((0, "DACS-MIB", "mdlSSltIdx"))
if mibBuilder.loadTexts: mdlSEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mdlSEntry.setDescription('')
mdlSSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118))).clone(namedValues=NamedValues(("psA", 1), ("psB", 2), ("clA", 3), ("clB", 4), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("io13", 17), ("io14", 18), ("io15", 19), ("kmxPsA", 101), ("kmxPsB", 102), ("kmxMlA", 103), ("kmxMlB", 104), ("kmxCl", 105), ("kmxOpt", 106), ("kmxIO1", 107), ("kmxIO2", 108), ("kmxIO3", 109), ("kmxIO4", 110), ("kmxIO5", 111), ("kmxIO6", 112), ("kmxIO7", 113), ("kmxIO8", 114), ("kmxIO9", 115), ("kmxIO10", 116), ("kmxIO11", 117), ("kmxIO12", 118)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlSSltIdx.setStatus('mandatory')
if mibBuilder.loadTexts: mdlSSltIdx.setDescription('A unique number to identify a slot position in the DACS. The Kilomux should use enumerated values starting with kmx.')
mdlSCardType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 10, 11, 20, 21, 22, 23, 24, 30, 31, 32, 33, 34, 35, 36, 37, 40, 41, 42, 43, 50, 51, 52, 53, 54, 55, 56, 57, 59, 60, 61, 70, 71, 72, 80, 81, 82, 90, 91, 92, 100, 110, 111, 112, 113, 114, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 201, 202, 203, 204, 205, 206, 207, 210, 211, 212, 213))).clone(namedValues=NamedValues(("unknown", 1), ("empty", 2), ("psAC", 10), ("psDC", 11), ("dCl", 20), ("kCl", 21), ("dcl2", 22), ("dcl2Eth", 23), ("kClEth", 24), ("dT1DSU", 30), ("dT1CSU", 31), ("dE1DSU", 32), ("dE1LTU", 33), ("dE1aDSU", 34), ("dE1aLTU", 35), ("dT1F", 36), ("dE1F", 37), ("dE1Hdsl", 40), ("dT1Hdsl", 41), ("dE1HdslS", 42), ("dT1HdslS", 43), ("kML1", 50), ("kML2", 51), ("kML3", 52), ("kML4", 53), ("kML5", 54), ("kML6", 55), ("kML7", 56), ("kML8", 57), ("kML10", 59), ("kMLF", 60), ("kML10New", 61), ("kLS1", 70), ("kLS1New", 71), ("kLS2", 72), ("kTRE", 80), ("kMBE", 81), ("kMBENew", 82), ("kai", 90), ("kdi", 91), ("kdiCH", 92), ("dHS2", 100), ("kHS1", 110), ("kHS2", 111), ("kHSU1", 112), ("kHSU2", 113), ("kHS703", 114), ("kVC1EM", 130), ("kVC1FXO", 131), ("kVC1FXS", 132), ("kVC1MEM", 133), ("kVC1MFXO", 134), ("kVC1MFXS", 135), ("kVC1MFXSW", 136), ("kVC2EM", 137), ("kVC2FXO", 138), ("kVC2FXS", 139), ("kVC2s1EM", 140), ("kVC2s1FXO", 141), ("kVC2s1FXS", 142), ("kVC3EM", 143), ("kVC3FXO", 144), ("kVC3FXS", 145), ("kVC3S0", 146), ("kVF1EM", 170), ("kVF1FXO", 171), ("kVF1FXS", 172), ("kVF3EM", 173), ("kVF3FXO", 174), ("kVF3FXS", 175), ("kVF4EM", 176), ("kVF4FXO", 177), ("kVF4FXS", 178), ("kVF4FXSW", 179), ("kVF4S0", 180), ("kVF5PbxE1", 181), ("kVF5E1PbxSlave", 182), ("kVF5PbxT1", 183), ("kVF5T1PbxSlave", 184), ("kVF5PbxE1New", 185), ("kVF5E1PbxSlaveNew", 186), ("kVF5PbxT1New", 187), ("kVF5T1PbxSlaveNew", 188), ("kVF4FXO3", 189), ("kVF4FXS3", 190), ("kVF4NS0", 191), ("kVF6E1s16", 192), ("kVF6E1s31", 193), ("kVF6T1s12", 194), ("kVF6T1s24", 195), ("kVF8EM", 196), ("kVF8FXO", 197), ("kVF8FXS", 198), ("dimV35", 201), ("dimRS422", 202), ("dimRS530", 203), ("dimHssi", 204), ("dimX21", 205), ("dim10BaseT", 206), ("dimE1", 207), ("dt3", 210), ("dt3f", 211), ("de3", 212), ("de3f", 213)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlSCardType.setStatus('mandatory')
if mibBuilder.loadTexts: mdlSCardType.setDescription("This attribute indicates the type of the card installed in the specific slot position. Only PS's are possible in the PS slots. Only CL's are possible in the CL slots. Only IO modules are possible in the IO slots. Kmux card type start with the letter k.")
mdlSHwVer = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlSHwVer.setStatus('mandatory')
if mibBuilder.loadTexts: mdlSHwVer.setDescription('This attribute indicates the Hardware version of the card installed in the specific slot position.')
mdlSSwVer = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlSSwVer.setStatus('mandatory')
if mibBuilder.loadTexts: mdlSSwVer.setDescription('This attribute indicates the Software version of the card installed in the specific slot position.')
mdlSAlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("off", 2), ("major", 3), ("minor", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlSAlarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mdlSAlarmStatus.setDescription('Indicates the current alarm state only for card level. This object will be set to: - major (3): when there is at least one active (ON) major alarm . - minor (4): when there is no active major alarm, but there is at least one active minor alarm. - off(2): when there is no active (ON) major or minor alarms (since last clear operation).')
mdlSAlarmStatusAll = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("off", 2), ("major", 3), ("minor", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlSAlarmStatusAll.setStatus('mandatory')
if mibBuilder.loadTexts: mdlSAlarmStatusAll.setDescription('Indicates the current card alarm state including the lower level: card, port. This object will be set to: - major (3): when there is at least one active (ON) major alarm . - minor (4): when there is no active major alarm, but there is at least one active minor alarm. - off(2): when there is no active (ON) major or minor alarms (since last clear operation).')
mdlSTestStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlSTestStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mdlSTestStatus.setDescription('This attribute will be on(3) when there is at least one test running on a port of the module; otherwise the value will be off(2).')
mdlSHwStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("fail", 2), ("ok", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlSHwStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mdlSHwStatus.setDescription('This attribute will be fail(2) when a HW FAIL exists on this module (discovered by periodic self test); otherwise the value will be ok(3).')
mdlSActivity = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("offline", 2), ("online", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlSActivity.setStatus('mandatory')
if mibBuilder.loadTexts: mdlSActivity.setDescription('notApplicable - when the slot is empty (no module) offline(1) - when the module is not active (redundant) online (2) - when the module is active .')
mdlSAlrClearCmd = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mdlSAlrClearCmd.setStatus('mandatory')
if mibBuilder.loadTexts: mdlSAlrClearCmd.setDescription('Setting this attribute to ON, will enforce a clear operation on the card level alarms . Upon completion, the value will automatically change to off(2).')
mdlSAlrClearAllCmd = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mdlSAlrClearAllCmd.setStatus('mandatory')
if mibBuilder.loadTexts: mdlSAlrClearAllCmd.setDescription('Setting this attribute to ON, will enforce a clear operation on card and port level alarms . Upon completion, the value will automatically change to off(2).')
mdlSAlrMaskAll = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mdlSAlrMaskAll.setStatus('mandatory')
if mibBuilder.loadTexts: mdlSAlrMaskAll.setDescription('on(3) - will cause masking of all the card level alarms. These alarms will not be sent to NMS and will not be taken into account for Alarms Status. off(2) - will unmask all card level alarms except those masked via the mdlAlrMaskTable. ')
mdlSCmd = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 1, 1, 13), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mdlSCmd.setStatus('mandatory')
if mibBuilder.loadTexts: mdlSCmd.setDescription("General object for any special command at card level. 0=NotApplicable, for cards that don't support this object. For KML.10(ISDN) card of KM-2100, the object will indicate Manual Call Command in Switch mode. It is applicable only when for KML.10, prtIsdnSwitchMode=manual. KML.10 valid values: '1' = noOp, will be used by agents that does not support this feature or object '2' = off, Set call command mode to disconnect state. Disconnects the call. '3' = on, Set call command mode to connect state. Connects the call.")
mdlCTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 2), )
if mibBuilder.loadTexts: mdlCTable.setStatus('mandatory')
if mibBuilder.loadTexts: mdlCTable.setDescription('')
mdlCEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 2, 1), ).setIndexNames((0, "DACS-MIB", "mdlCConfigIdx"), (0, "DACS-MIB", "mdlCSlotIdx"))
if mibBuilder.loadTexts: mdlCEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mdlCEntry.setDescription('')
mdlCConfigIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlCConfigIdx.setStatus('mandatory')
if mibBuilder.loadTexts: mdlCConfigIdx.setDescription('This object indicates the Configuration number (1..255) referred. Value of 255 specifies the TmpCnfg (Scratch).')
mdlCSlotIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118))).clone(namedValues=NamedValues(("psA", 1), ("psB", 2), ("clA", 3), ("clB", 4), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("io13", 17), ("io14", 18), ("io15", 19), ("kmxPsA", 101), ("kmxPsB", 102), ("kmxMlA", 103), ("kmxMlB", 104), ("kmxCl", 105), ("kmxOpt", 106), ("kmxIO1", 107), ("kmxIO2", 108), ("kmxIO3", 109), ("kmxIO4", 110), ("kmxIO5", 111), ("kmxIO6", 112), ("kmxIO7", 113), ("kmxIO8", 114), ("kmxIO9", 115), ("kmxIO10", 116), ("kmxIO11", 117), ("kmxIO12", 118)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlCSlotIdx.setStatus('mandatory')
if mibBuilder.loadTexts: mdlCSlotIdx.setDescription('This object indicates a unique number of the slot position in which the module is inserted. The Kilomux should use enumerated values starting with kmx.')
mdlCProgCardType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 10, 11, 20, 21, 22, 23, 24, 30, 31, 32, 33, 34, 35, 36, 37, 40, 41, 42, 43, 50, 51, 52, 53, 54, 55, 56, 57, 59, 60, 61, 70, 71, 72, 80, 81, 82, 90, 91, 92, 100, 110, 111, 112, 113, 114, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 201, 202, 203, 204, 205, 206, 207, 210, 211, 212, 213))).clone(namedValues=NamedValues(("unknown", 1), ("empty", 2), ("psAC", 10), ("psDC", 11), ("dCl", 20), ("kCl", 21), ("dcl2", 22), ("dcl2Eth", 23), ("kClEth", 24), ("dT1DSU", 30), ("dT1CSU", 31), ("dE1DSU", 32), ("dE1LTU", 33), ("dE1aDSU", 34), ("dE1aLTU", 35), ("dT1F", 36), ("dE1F", 37), ("dE1Hdsl", 40), ("dT1Hdsl", 41), ("dE1HdslS", 42), ("dT1HdslS", 43), ("kML1", 50), ("kML2", 51), ("kML3", 52), ("kML4", 53), ("kML5", 54), ("kML6", 55), ("kML7", 56), ("kML8", 57), ("kML10", 59), ("kMLF", 60), ("kML10New", 61), ("kLS1", 70), ("kLS1New", 71), ("kLS2", 72), ("kTRE", 80), ("kMBE", 81), ("kMBENew", 82), ("kai", 90), ("kdi", 91), ("kdiCH", 92), ("dHS2", 100), ("kHS1", 110), ("kHS2", 111), ("kHSU1", 112), ("kHSU2", 113), ("kHS703", 114), ("kVC1EM", 130), ("kVC1FXO", 131), ("kVC1FXS", 132), ("kVC1MEM", 133), ("kVC1MFXO", 134), ("kVC1MFXS", 135), ("kVC1MFXSW", 136), ("kVC2EM", 137), ("kVC2FXO", 138), ("kVC2FXS", 139), ("kVC2s1EM", 140), ("kVC2s1FXO", 141), ("kVC2s1FXS", 142), ("kVC3EM", 143), ("kVC3FXO", 144), ("kVC3FXS", 145), ("kVC3S0", 146), ("kVF1EM", 170), ("kVF1FXO", 171), ("kVF1FXS", 172), ("kVF3EM", 173), ("kVF3FXO", 174), ("kVF3FXS", 175), ("kVF4EM", 176), ("kVF4FXO", 177), ("kVF4FXS", 178), ("kVF4FXSW", 179), ("kVF4S0", 180), ("kVF5PbxE1", 181), ("kVF5E1PbxSlave", 182), ("kVF5PbxT1", 183), ("kVF5T1PbxSlave", 184), ("kVF5PbxE1New", 185), ("kVF5E1PbxSlaveNew", 186), ("kVF5PbxT1New", 187), ("kVF5T1PbxSlaveNew", 188), ("kVF4FXO3", 189), ("kVF4FXS3", 190), ("kVF4NS0", 191), ("kVF6E1s16", 192), ("kVF6E1s31", 193), ("kVF6T1s12", 194), ("kVF6T1s24", 195), ("kVF8EM", 196), ("kVF8FXO", 197), ("kVF8FXS", 198), ("dimV35", 201), ("dimRS422", 202), ("dimRS530", 203), ("dimHssi", 204), ("dimX21", 205), ("dim10BaseT", 206), ("dimE1", 207), ("dt3", 210), ("dt3f", 211), ("de3", 212), ("de3f", 213)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mdlCProgCardType.setStatus('mandatory')
if mibBuilder.loadTexts: mdlCProgCardType.setDescription('This object indicates the card type assigned to the specific slot in the common configuration. This object is identical for all the configurations (1..255). Only the TmpCnf(255) might have a different value. The write operation is valid only for the TmpCnfg entry.')
mdlCNoOfExtPrt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlCNoOfExtPrt.setStatus('mandatory')
if mibBuilder.loadTexts: mdlCNoOfExtPrt.setDescription('Number of external ports in the programmed module of the specific slot position')
mdlCNoOfIntPrt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlCNoOfIntPrt.setStatus('mandatory')
if mibBuilder.loadTexts: mdlCNoOfIntPrt.setDescription('Number of internal ports in the programmed module of the specific slot position.')
mdlAlr = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 3))
mdlAlrTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 3, 1), )
if mibBuilder.loadTexts: mdlAlrTable.setStatus('mandatory')
if mibBuilder.loadTexts: mdlAlrTable.setDescription('The list of card alarms. ')
mdlAlrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 3, 1, 1), ).setIndexNames((0, "DACS-MIB", "mdlAlrSltIdx"), (0, "DACS-MIB", "mdlAlrIdx"))
if mibBuilder.loadTexts: mdlAlrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mdlAlrEntry.setDescription('')
mdlAlrIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlAlrIdx.setStatus('mandatory')
if mibBuilder.loadTexts: mdlAlrIdx.setDescription('A unique number to identify an entry in the alarm status table. Users should use the get next function to read this table because the indexes are not consecutive')
mdlAlrSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118))).clone(namedValues=NamedValues(("psA", 1), ("psB", 2), ("clA", 3), ("clB", 4), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("io13", 17), ("io14", 18), ("io15", 19), ("kmxPsA", 101), ("kmxPsB", 102), ("kmxMlA", 103), ("kmxMlB", 104), ("kmxCl", 105), ("kmxOpt", 106), ("kmxIO1", 107), ("kmxIO2", 108), ("kmxIO3", 109), ("kmxIO4", 110), ("kmxIO5", 111), ("kmxIO6", 112), ("kmxIO7", 113), ("kmxIO8", 114), ("kmxIO9", 115), ("kmxIO10", 116), ("kmxIO11", 117), ("kmxIO12", 118)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlAlrSltIdx.setStatus('mandatory')
if mibBuilder.loadTexts: mdlAlrSltIdx.setDescription('This attribute indicates the desired slot position. The Kilomux should use enumerated values starting with kmx.')
mdlAlrCode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 3, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlAlrCode.setStatus('mandatory')
if mibBuilder.loadTexts: mdlAlrCode.setDescription('This object indicates a code related to a specific alarm description. The list of codes and their related descriptions will be sent to NMS request (for display purpose) by alrGenTable.')
mdlAlrState = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4, 5))).clone(namedValues=NamedValues(("minor", 4), ("major", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlAlrState.setStatus('mandatory')
if mibBuilder.loadTexts: mdlAlrState.setDescription('This object indicates the card alarm state.')
mdlAlarmMask = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlAlarmMask.setStatus('mandatory')
if mibBuilder.loadTexts: mdlAlarmMask.setDescription('Alarm Mask is : on/off.')
mdlAlarmInvert = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlAlarmInvert.setStatus('mandatory')
if mibBuilder.loadTexts: mdlAlarmInvert.setDescription('Alarm Invert is : on/off.')
mdlAlrMaskTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 3, 2), )
if mibBuilder.loadTexts: mdlAlrMaskTable.setStatus('mandatory')
if mibBuilder.loadTexts: mdlAlrMaskTable.setDescription('The list of card masked alarms. ')
mdlAlrMaskEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 3, 2, 1), ).setIndexNames((0, "DACS-MIB", "mdlAlrMaskSltIdx"))
if mibBuilder.loadTexts: mdlAlrMaskEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mdlAlrMaskEntry.setDescription('')
mdlAlrMaskSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 3, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118))).clone(namedValues=NamedValues(("psA", 1), ("psB", 2), ("clA", 3), ("clB", 4), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("io13", 17), ("io14", 18), ("io15", 19), ("kmxPsA", 101), ("kmxPsB", 102), ("kmxMlA", 103), ("kmxMlB", 104), ("kmxCl", 105), ("kmxOpt", 106), ("kmxIO1", 107), ("kmxIO2", 108), ("kmxIO3", 109), ("kmxIO4", 110), ("kmxIO5", 111), ("kmxIO6", 112), ("kmxIO7", 113), ("kmxIO8", 114), ("kmxIO9", 115), ("kmxIO10", 116), ("kmxIO11", 117), ("kmxIO12", 118)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlAlrMaskSltIdx.setStatus('mandatory')
if mibBuilder.loadTexts: mdlAlrMaskSltIdx.setDescription('This attribute indicates the desired slot position. The Kilomux should use enumerated values starting with kmx.')
mdlAlrMask = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 1, 3, 2, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mdlAlrMask.setStatus('mandatory')
if mibBuilder.loadTexts: mdlAlrMask.setDescription("This object is a mask that indicates which card level alarms are masked. The masked alarms (their bit is set to '1') are neither sent to the manager, nor taken into account for alarm status and LEDs. Bit no. = Alarm code The bits that do not belong to the card level will be 0. This object is applicable only when mdlSAlrMaskAll=off (otherwise all card alarms are masked). Example: When Alarm having the code 8 is masked, the value of this object will be 100 (hex).")
mdlClTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 2, 1), )
if mibBuilder.loadTexts: mdlClTable.setStatus('mandatory')
if mibBuilder.loadTexts: mdlClTable.setDescription('')
mdlClEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 2, 1, 1), ).setIndexNames((0, "DACS-MIB", "mdlClIdx"))
if mibBuilder.loadTexts: mdlClEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mdlClEntry.setDescription('')
mdlClIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4))).clone(namedValues=NamedValues(("clA", 3), ("clB", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlClIdx.setStatus('mandatory')
if mibBuilder.loadTexts: mdlClIdx.setDescription('This object indicates the Cl slot referred.')
mdlClSwchStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 2, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlClSwchStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mdlClSwchStatus.setDescription("This object indicates the status of the switches on the referred DCL card. Each switch is represented by a bit. The status is a sum of 2**n, according to the bits. There are 4 switches: bit 0 SP-PAR (LSB) '1' - Default parameters bit 1 PSWRD '1' - Password=default '0' - Password=user selected bit 2 DB-INIT '1' - DB initiated with default '0' - DB initiated with NVRAM contents bit 3 PC-SP (MSB) '1' - Management by terminal only '0' - Management by NMS Example: If SP-PAR and PSWRD bits are set ('1'), the value will be 3 (2**1 + 2**0). When the status of the switches is unknown, the value of this object will be 255.")
mdlClLastFlipDate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 2, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlClLastFlipDate.setStatus('mandatory')
if mibBuilder.loadTexts: mdlClLastFlipDate.setDescription('Date when last flip occured. The format would be as specified by the sysSDateFormat.')
mdlClLastFlipTime = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 2, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlClLastFlipTime.setStatus('mandatory')
if mibBuilder.loadTexts: mdlClLastFlipTime.setDescription('Time when last flip occured.')
mdlClLastFlipCause = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 2, 1, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlClLastFlipCause.setStatus('mandatory')
if mibBuilder.loadTexts: mdlClLastFlipCause.setDescription('The cause of last flip.')
mdlPsTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 3, 1), )
if mibBuilder.loadTexts: mdlPsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mdlPsTable.setDescription('')
mdlPsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 3, 1, 1), ).setIndexNames((0, "DACS-MIB", "mdlPsIdx"))
if mibBuilder.loadTexts: mdlPsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mdlPsEntry.setDescription('')
mdlPsIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("psA", 1), ("psB", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlPsIdx.setStatus('mandatory')
if mibBuilder.loadTexts: mdlPsIdx.setDescription('This object indicates the PS card referred.')
mdlPsStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notActive", 1), ("active", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlPsStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mdlPsStatus.setDescription('This object indicates the status of the PS card.')
mdlPsTestResult = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 2, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ok", 1), ("f12V", 2), ("f5V", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mdlPsTestResult.setStatus('mandatory')
if mibBuilder.loadTexts: mdlPsTestResult.setDescription('This object indicates the result of the PS card test. ok (1) - the test passed successfully. f12V (2) - 12V FAIL was detected f5V (3) - 5V FAIL was detected.')
prtGen = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1))
prtT1E1 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2))
prtHS = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 3))
prtSP = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 4))
prtDim = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 5))
prtI = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 6))
prtHdsl = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 7))
prtT3E3 = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 8))
prtGenParamTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 1), )
if mibBuilder.loadTexts: prtGenParamTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtGenParamTable.setDescription('')
prtGenEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 1, 1), ).setIndexNames((0, "DACS-MIB", "prtGenPrtIdx"))
if mibBuilder.loadTexts: prtGenEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtGenEntry.setDescription('')
prtGenPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtGenPrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtGenPrtIdx.setDescription('This attribute indicates a unique number to identify a port. The valid port number depends on the IO slot no., the installed card type and the port type: outside/external, inside/internal. In the Kilomux, the port index is calculated as follows: 100*Slot+Ch. The external Ch numbers are 1..10, and the internal Ch numbers are 11..20. In the DXC : - first two digits will be: (IO slot number+10) - last one/two digits will be the port number within the card in odd or even numbers, as follows: * For the outside/external ports, in odd numbers: port1 = 1 port2 = 3 port3 = 5 etc... Example: port2 of IO slot 11 will be: 213 . * The inside/internal ports, in even numbers: port1 = 2 port2 = 4 port3 = 6 etc... Example: port2 of IO slot 11 will be: 214 .')
prtGenSlt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("io13", 17), ("io14", 18), ("io15", 19), ("kmxMlA", 103), ("kmxMlB", 104), ("kmxCl", 105), ("kmxOpt", 106), ("kmxIO1", 107), ("kmxIO2", 108), ("kmxIO3", 109), ("kmxIO4", 110), ("kmxIO5", 111), ("kmxIO6", 112), ("kmxIO7", 113), ("kmxIO8", 114), ("kmxIO9", 115), ("kmxIO10", 116), ("kmxIO11", 117), ("kmxIO12", 118), ("standAlone", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtGenSlt.setStatus('mandatory')
if mibBuilder.loadTexts: prtGenSlt.setDescription('This attribute indicates a unique number to identify the slot where the card is inserted in. When the unit is stand-alone, this object is not applicable and 255 will be used. The Kilomux should use the enumerated starting with kmx.')
prtGenExtInt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("external", 2), ("internal", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtGenExtInt.setStatus('mandatory')
if mibBuilder.loadTexts: prtGenExtInt.setDescription("This attribute describes the type of the designated port. Exteral port is a port with a physical connector. Internal port might be of two types, one is a composite port which collects data of a few external ports into a common bandwidth (usually routed trough DS1 link); the other type is internal ports which get only part of external port data (usually a few DS0's). In the Kilomux-2100, the internal(3) value is used for composite channels or sub-channels of an ISDN Ch.")
prtGenIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtGenIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: prtGenIfIndex.setDescription("This attribute indicates the unique interface number assigned to the port. The specific interface of this attribute is the same as the interface identified by the value of ifindex in MIB-II.If there is no interface for the specific prtIdx, the value will be '7fffffff'h.")
prtGenActiveStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("unknown", 1), ("notUsed", 2), ("offLine", 3), ("onLine", 4), ("offLineRedundancy", 5), ("onLineRedundancy", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtGenActiveStatus.setStatus('mandatory')
if mibBuilder.loadTexts: prtGenActiveStatus.setDescription('This attribute describes the activity status of the port. unknown(1) indicates that the information is not supported. notUsed(2) indicates that the port is not connected according to the active config. offLine(3) indicates that the port is down (not working) due to any problem. onLine (4) indicates that the port is up (working) offLineRedundancy(5) indicates that the port is down because it is a redundant port. onLineRedundancy (6) indicates that this is a redundant port which is up and works as the active link.')
prtGenAlrStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("off", 2), ("major", 3), ("minor", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtGenAlrStatus.setStatus('mandatory')
if mibBuilder.loadTexts: prtGenAlrStatus.setDescription('Indicates the alarm state at port (ch) agent level. This object will be set to: - major (3): when there is at least one active (ON) major alarm . - minor (4): when there is no active major alarm, but there is at least one active minor alarm. - off(2): when there is no active (ON) major or minor alarms (since last clear operation).')
prtGenTestStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtGenTestStatus.setStatus('mandatory')
if mibBuilder.loadTexts: prtGenTestStatus.setDescription('This attribute will be on(3) when there is at least one test in progress (running) on the port; otherwise the value will be off(2).')
prtGenTestMask = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtGenTestMask.setStatus('mandatory')
if mibBuilder.loadTexts: prtGenTestMask.setDescription("This is a mask which indicates which tests from the 'prtGenTestCmd' list are allowed for the selected port. If a specific test is allowed, its respective bit will be SET in the mask : TEST BIT ----------- --- localLoop 1 remoteLoop 2 bert 3 plb 4 inband 5 prbs 8 loop2-v54 (RLB) 9 loop3-v54 (LLB) 10 Tone injection 13 Tx-plb 14 Tx-llb 15 DTE loop (HSSI) 16 HDSL-Tx-Inband 20 HDSL-Rx-Inband 21 Monitor 22 (test port) User Line Loopback 23 e.g : If the return value is 3 -> 0000000000000011 -> Bits 1 & 2 are set -> the allowed tests are : local-loop remote-loop ")
prtGenTestCmd = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 1, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtGenTestCmd.setStatus('mandatory')
if mibBuilder.loadTexts: prtGenTestCmd.setDescription('Setting this object to a value as detailed furter on (except 0) will initiate a test on the specific port, if the operation is allowed (according to TestMask). If the operation is not allowed, the mux will ignore the operation. The test/s requested will be set according to the respective bit: TEST BIT ----------- --- localLoop 1 remoteLoop 2 bert 3 plb 4 inband 5 prbs 8 loop2-v54 (RLB) 9 loop3-v54 (LLB) 10 Tone injection 13 Tx-plb 14 Tx-llb 15 DTE loop (HSSI) 16 HDSL-Tx-Inband 20 HDSL-Rx-Inband 21 Monitor 22 (test port) User Line Loopback 23 e.g : If the requested value is 3 -> 0000000000000011 -> Bits 1 & 2 are set -> the requested tests are : local-loop remote-loop Setting this object to stop (value=0 ; all bits are 0), will stop all the user requested tests running on the selected port; it will NOT stop the tests initiated by the system.')
prtGenTestRunning = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtGenTestRunning.setStatus('mandatory')
if mibBuilder.loadTexts: prtGenTestRunning.setDescription('This object indicates which tests are running currently on the selected port (initiated by user and/or by the system). If a specific test is currently running on the port, its respective bit will be SET: TEST BIT ----------- --- localLoop 1 remoteLoop 2 bert 3 plb 4 llb 5 txInband 6 rxInband 7 prbs 8 loop2-v54 (RLB) 9 loop3-v54 (LLB) 10 DDS DSU loop 11 DDS CSU loop 12 Tone injection 13 Tx-plb 14 Tx-llb 15 DTE loop (HSSI) 16 Local DTE loop (HSSI)17 Local Line loop (HSSI)18 Remote Line loop (HSSI)19 HDSL-Tx-Inband 20 HDSL-Rx-Inband 21 Monitor 22 (test port) User Line Loopback 23 Network Line Loopback 24 e.g : If the return value is 3 -> 0000000000000011 -> Bits 1 & 2 are set -> the running tests are : local-loop remote-loop llb (Bit 5) - can be initiated by system only! ')
prtGenType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 255))).clone(namedValues=NamedValues(("unknown", 1), ("t1", 2), ("e1", 3), ("hs", 4), ("t1Csu", 5), ("t1Dsu", 6), ("e1Ltu", 7), ("e1Dsu", 8), ("hdsl", 9), ("sp", 10), ("t1F", 11), ("e1F", 12), ("dim", 13), ("isdn", 14), ("t3", 15), ("e3", 16), ("t3f", 17), ("e3f", 18), ("other", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtGenType.setStatus('mandatory')
if mibBuilder.loadTexts: prtGenType.setDescription('This object describes the type of the selected port.')
prtGenInterfaceType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 1, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtGenInterfaceType.setStatus('mandatory')
if mibBuilder.loadTexts: prtGenInterfaceType.setDescription('This attribute indicates a unique HW interface type of the selected port. Examples: - for T1 cards: DSU, CSU - for E1 cards: DSU, LTU - for HS cards: v35, rs422, x21 etc...')
prtGenAlrClearCmd = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noOp", 1), ("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtGenAlrClearCmd.setStatus('mandatory')
if mibBuilder.loadTexts: prtGenAlrClearCmd.setDescription('Setting this attribute to ON, will enforce a clear operation on the port level alarms . Upon completion, the value will automatically change to off(2). noOp - will be used by agents that do not support this feature or object.')
prtGenAlrMaskAll = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noOp", 1), ("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtGenAlrMaskAll.setStatus('mandatory')
if mibBuilder.loadTexts: prtGenAlrMaskAll.setDescription('on(3) - will mask all the alarms of the selected port off(2)- will unmask all alarms of the selected port except the ones selected by the prtAlrMaskTable. noOp - will be used by agents that do not support this feature or object.')
prtGenParamStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 1, 1, 15), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtGenParamStatus.setStatus('mandatory')
if mibBuilder.loadTexts: prtGenParamStatus.setDescription("This object indicates Status of parameters specific to the selected port. - For a port that has no special status or is supported by prtSExHsfStatTable - 1 Octet: 00hex - For HS cards - 1 octet: Bit 7 (MSB)..Bit 2 = 0 (NA) Bit 0 and 1 indicates RTS control signal state: Bit 1: '1'=active ; '0'=notActive Bit 0 (LSB): '1'=unknown ; '0'=NA - For VC-6, VC-12, VC-12/6 external ports - 1 Octet : Bit 7 (MSB)..Bit 2 = 0 (NA) Bit 1: Tx Signaling '1'=On ; '0'=Off Bit 0 (LSB): Rx Signaling '1'=On ; '0'=Off - For VC-2/R2(FXS) external ports - 1 Octet : Bit - 7 6 5 4 3 2 1 0 |_| |_________| Call Call State Direction Bit 7 (MSB) and Bit 6 : Call Direction 00 - Incoming 01 - Outgoing Bit 5..Bit 0: Call State 000000 - Idle 000001 - Seized 000010 - Both-Way Conflict 000011 - Seizure Ack 000100 - Answered 000101 - Clear Backward 000110 - Clear Forward 000111 - Blocked 001000 - Fault 001001 - Fault 3 001010 - Fault 4 001011 - Fault 5 001100 - Fault 6 001101 - Fault 7 - For ML-20 external port - 3 Octets : - 1 MS Octet will represent the Real Rate used: Bit - 7 6 5 4 3 2 1 0 |___| |_______| spare Rate Valid values: 0..31, meaning 0..31x64Kbps Invalid values: 32..255. - 2 LS Octets will represent the Status of 7 Control Signals: Signal - --- CTS DSR DCD RJ TM DTR RTS Bit - 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0 Octet - 2 3 (LS) '---' will always have the value 00 Rest of the Signals (2 bits each) can have the following values: 00=NA ; 01=Unused ; 10=Off ; 11=On - For ML-H/E1, ML-H/1/E1, ML-H/S/E1 internal port - 1 Octet Bit - 7 6 5 4 3 2 1 0 |___________| spare Mode of Operation Mode of Operation: '1'=Central ; '0'=Remote - For KM2100, KVF.5 cards - indicates the status of A and B signaling for each internal channel. 1 Octet: Bit - 7 6 5 4 3 2 1 0 |_____| |_| |_| spare B A Bit 0 (LSB) and Bit 1 : A status Bit 2 and Bit 3 : B status 00 - Off 01 - On 11 - Unknown - For FCD-W, NETWORK and USER ports - 1 Octet Status of Control Signals: '1'=On ; '0'=Off or when not applicable Bit - 7 6 5 4 3 2 1 0 Bit 7 (MSB) - Signal Loss (applicable only for G.703 interface) Bit 6 - CONTROL (applicable only for X.21 interface) Bit 5 - INDICATION (applicable only for X.21 interface) Bit 4 - DSR (applicable only for V.35 interface) Bit 3 - RTS (applicable only for V.35 interface) Bit 2 - CTS (applicable only for V.35 interface) Bit 1 - DTR (applicable only for V.35 interface) Bit 0 - DCD (applicable only for V.35 interface) ")
prtGenTestDurationTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 2), )
if mibBuilder.loadTexts: prtGenTestDurationTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtGenTestDurationTable.setDescription('')
prtGenTestDurationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 2, 1), ).setIndexNames((0, "DACS-MIB", "prtGenTestPrtIdx"), (0, "DACS-MIB", "prtGenTestIdx"))
if mibBuilder.loadTexts: prtGenTestDurationEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtGenTestDurationEntry.setDescription('')
prtGenTestPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtGenTestPrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtGenTestPrtIdx.setDescription('This attribute indicates a unique number to identify a port. The valid port number depends on the IO slot no., the installed card type and the port type: outside/external, inside/internal. In the Kilomux, the port index is calculated as follows: 100*Slot+Ch. The external Ch numbers are 1..10, and the internal Ch numbers are 11..20. In the DXC : - first two digits will be: (IO slot number+10) - last one/two digits will be the port number within the card in odd or even numbers, as follows: * For the outside/external ports, in odd numbers: port1 = 1 port2 = 3 port3 = 5 etc... Example: port2 of IO slot 11 will be: 213 . * The inside/internal ports, in even numbers: port1 = 2 port2 = 4 port3 = 6 etc... Example: port2 of IO slot 11 will be: 214 .')
prtGenTestIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("localLoop", 1), ("remoteLoop", 2), ("bert", 3), ("plb", 4), ("rlb", 5), ("llb", 6), ("toneInjection", 7), ("txInband", 8), ("rxInband", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtGenTestIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtGenTestIdx.setDescription('This attribute indicates the test, the duration refers. ')
prtGenTestDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 2, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtGenTestDuration.setStatus('mandatory')
if mibBuilder.loadTexts: prtGenTestDuration.setDescription("This attribute indicates the maximum duration of executing a test on the specific port. This entry applies to the specified test . The resolution will be a minute, and the maximum duration is limited to 30 minutes . A zero value specifies no time limitation. When the test isn't active the agent initiates this object to 2 min. when the duration is needed and to 0 if it's not required.")
prtGenTsTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 3), )
if mibBuilder.loadTexts: prtGenTsTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtGenTsTable.setDescription("The write operation into the Table's Objects is valid only for the TmpCnfg entry (Scratch).")
prtGenTsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 3, 1), ).setIndexNames((0, "DACS-MIB", "prtGenTsCnfgIdx"), (0, "DACS-MIB", "prtGenTsPrtIdx"), (0, "DACS-MIB", "prtGenTsIdx"))
if mibBuilder.loadTexts: prtGenTsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtGenTsEntry.setDescription('')
prtGenTsCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtGenTsCnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtGenTsCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg(1..255) being accessed. Idx of 255 relates to the TmpCnfg. ')
prtGenTsPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtGenTsPrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtGenTsPrtIdx.setDescription('This attribute indicates a unique port number. The valid port number depends on the IO slot no., the installed card type and the port type: outside, inside, SP. In the DXC : - first two digits will be: (IO slot number+10) - last one/two digits will be the port number within the card in odd or even numbers, as follows: * For the outside/external ports, in odd numbers: port1 = 1 port2 = 3 port3 = 5 etc... Example: port2 of IO slot 11 will be: 213 . * The inside/internal ports, in even numbers: port1 = 2 port2 = 4 port3 = 6 etc... Example: port2 of IO slot 11 will be: 214 .')
prtGenTsIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtGenTsIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtGenTsIdx.setDescription('This attribute indicates a unique time slot position. The valid time slots are 1..25 for T1 Card (25=Fbit) 0..31 for E1 or HS Card . In G732S-E1 lines time slot 16 is not valid for data, it is dedicated for multiframe synchronization bits and voice signaling.')
prtGenTsType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("unknown", 1), ("voice", 2), ("data", 3), ("vcMP", 4), ("nc", 5), ("mng", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtGenTsType.setStatus('mandatory')
if mibBuilder.loadTexts: prtGenTsType.setDescription("The type of Timeslot. If the source or destination port is an HS port,'TS Type' must be 'data'. nc - means that this TimeSlot is not connected. voice, data, vcMP - also mean that this TS is connected. mng - means that this TS is dedicated to Management (not connected to another port.")
prtGenTsIConPrt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 3, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtGenTsIConPrt.setStatus('mandatory')
if mibBuilder.loadTexts: prtGenTsIConPrt.setDescription("This attribute indicates the internally (In Mux) connected port. The valid port number depends on the IO slot no., the installed card type and the port type: outside, inside, SP. * The outside ports will be the T1/E1 cards ports. The convention used will be (for DXC): - first two digits will be: (IO slot number+10) for a stand-alone unit, the IO slot will be considered 1. - last one/two digits will be the port number within the card, in odd numbers: port1 = 1 port2 = 3 port3 = 5 etc... Example: port2 of IO slot 11 will be: 213 . * The inside ports will be for example, the HS cards ports. The convention used will be (for DXC): - first two digits will be: (IO slot number+10) for a stand-alone unit, the IO slot will be considered 1. - last one/two digits will be the port number within the card, in even numbers: port1 = 2 port2 = 4 port3 = 6 etc... Example: port2 of IO slot 11 will be: 214 . * noConnection - will be indicated as 10 for DXC and FCD-E1/T1. - will be indicated as 100 for FCD-E1/I and SMODs. * Split TS (same TS is Split to several ports) - 11. All HS port's timeslots must have the same destination port.")
prtGenTsIConTs = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 3, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtGenTsIConTs.setStatus('mandatory')
if mibBuilder.loadTexts: prtGenTsIConTs.setDescription("This attribute indicates a unique time slot position. The valid time slots are 1..25 for T1 Card (25=Fbit) 0..31 for E1 (or HS) Card. In G732S-E1 lines time slot 16 is not valid for data, it is dedicated for multiframe synchronization bits and voice signaling. * For DXC: All HS port's timeslots must start with Timeslot no.1 ")
prtAlr = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 4))
prtSAlarmTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 4, 1), )
if mibBuilder.loadTexts: prtSAlarmTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtSAlarmTable.setDescription('')
prtSAlarmEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 4, 1, 1), ).setIndexNames((0, "DACS-MIB", "prtSAlarmPrtIdx"), (0, "DACS-MIB", "prtSAlarmIdx"))
if mibBuilder.loadTexts: prtSAlarmEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtSAlarmEntry.setDescription('')
prtSAlarmIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 4, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSAlarmIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtSAlarmIdx.setDescription('A unique number to identify an entry in the alarm status table. Users should use the get next function to read this table because the indexes are not consecutive.')
prtSAlarmPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 4, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSAlarmPrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtSAlarmPrtIdx.setDescription('This attribute indicates a unique number to identify a port. The valid port number depends on the IO slot no., the installed card type and the port type: outside/external, inside/internal. In the Kilomux, the port index is calculated as follows: 100*Slot+Ch. The external Ch numbers are 1..10, and the internal Ch numbers are 11..20. In the DXC : - first two digits will be: (IO slot number+10) - last one/two digits will be the port number within the card in odd or even numbers, as follows: * For the outside/external ports, in odd numbers: port1 = 1 port2 = 3 port3 = 5 etc... Example: port2 of IO slot 11 will be: 213 . * The inside/internal ports, in even numbers: port1 = 2 port2 = 4 port3 = 6 etc... Example: port2 of IO slot 11 will be: 214 .')
prtSAlarmCode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 4, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSAlarmCode.setStatus('mandatory')
if mibBuilder.loadTexts: prtSAlarmCode.setDescription('This object indicates a code related to a specific alarm description. The list of codes and their related descriptions will be sent to NMS request (for display purpose) by alrGenTable.')
prtSAlarmState = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4, 5))).clone(namedValues=NamedValues(("minor", 4), ("major", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSAlarmState.setStatus('mandatory')
if mibBuilder.loadTexts: prtSAlarmState.setDescription('This object indicates the port alarm state.')
prtSAlarmMask = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSAlarmMask.setStatus('mandatory')
if mibBuilder.loadTexts: prtSAlarmMask.setDescription('Alarm Mask is : on/off.')
prtSAlarmInvert = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 4, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSAlarmInvert.setStatus('mandatory')
if mibBuilder.loadTexts: prtSAlarmInvert.setDescription('Alarm Invert is : on/off.')
prtAlrMaskTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 4, 2), )
if mibBuilder.loadTexts: prtAlrMaskTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtAlrMaskTable.setDescription('')
prtAlrMaskEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 4, 2, 1), ).setIndexNames((0, "DACS-MIB", "prtAlrMaskPrtIdx"))
if mibBuilder.loadTexts: prtAlrMaskEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtAlrMaskEntry.setDescription('')
prtAlrMaskPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 4, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtAlrMaskPrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtAlrMaskPrtIdx.setDescription('This attribute indicates a unique number to identify a port. The valid port number depends on the IO slot no., the installed card type and the port type: outside/external, inside/internal. In the Kilomux, the port index is calculated as follows: 100*Slot+Ch. The external Ch numbers are 1..10, and the internal Ch numbers are 11..20. In the DXC : - first two digits will be: (IO slot number+10) - last one/two digits will be the port number within the card in odd or even numbers, as follows: * For the outside/external ports, in odd numbers: port1 = 1 port2 = 3 port3 = 5 etc... Example: port2 of IO slot 11 will be: 213 . * The inside/internal ports, in even numbers: port1 = 2 port2 = 4 port3 = 6 etc... Example: port2 of IO slot 11 will be: 214 .')
prtAlrMask = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 4, 2, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtAlrMask.setStatus('mandatory')
if mibBuilder.loadTexts: prtAlrMask.setDescription("This object is a mask that indicates which port level alarms are masked. The masked alarms (their bit is set to '1') are neither sent to the manager, nor taken into account for alarm status and LEDs. Bit no. = Alarm code The bits that do not belong to the port level will be 0. This object is applicable only when prtGenAlrMaskAll=off (otherwise all port alarms are masked). Example: When Alarms having the codes 31 and 40 are masked, the value of this object will be 10080000000 (hex).")
prtBertTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 5), )
if mibBuilder.loadTexts: prtBertTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtBertTable.setDescription('This table includes the BERT parameters, counters and commands. The configurable parameters: - prtBertPattern - prtBertInjectRate - prtBertTs are not Set per configuration (same for all Configurations) but start being applied by the Agent only upon successful Update/Download operation. Therefore, Set will enter the values to the Temporary Configuration of the agent, while Get will get the values of the Active Configuration.')
prtBertEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 5, 1), ).setIndexNames((0, "DACS-MIB", "prtBertPrtIdx"))
if mibBuilder.loadTexts: prtBertEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtBertEntry.setDescription('')
prtBertPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtBertPrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtBertPrtIdx.setDescription('This attribute indicates a unique number to identify a port. The valid port number depends on the IO slot no., the installed card type and the port type: outside/external, inside/internal. In the Kilomux, the port index is calculated as follows: 100*Slot+Ch. The external Ch numbers are 1..10, and the internal Ch numbers are 11..20. In the DXC : - first two digits will be: (IO slot number+10) - last one/two digits will be the port number within the card in odd or even numbers, as follows: * For the outside/external ports, in odd numbers: port1 = 1 port2 = 3 port3 = 5 etc... Example: port2 of IO slot 11 will be: 213 . * The inside/internal ports, in even numbers: port1 = 2 port2 = 4 port3 = 6 etc... Example: port2 of IO slot 11 will be: 214 . In the MP : - first two digits will be: (IO slot number+10) - last one/two digits will be according to the external port number within the card: exPrt1 -> 1 exPrt2 -> 3 exPrt3 -> 5 exPrt4 -> 7 . ')
prtBertPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 255))).clone(namedValues=NamedValues(("p2E3m1", 1), ("p2E4m1", 2), ("p2E5m1", 3), ("p2E6m1", 4), ("p2E7m1", 5), ("p511", 6), ("p2E10m1", 7), ("p2047", 8), ("p2E15m1", 9), ("p2E17m1", 10), ("p2E18m1", 11), ("p2E20m1", 12), ("qrss", 13), ("p2E21m1", 14), ("p2E22m1", 15), ("p2E23m1", 16), ("p2E25m1", 17), ("p2E28m1", 18), ("p2E29m1", 19), ("p2E31m1", 20), ("p2E32m1", 21), ("rj011", 22), ("p63", 23), ("p1M7S", 24), ("p1S7M", 25), ("alternate", 26), ("mark", 27), ("space", 28), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtBertPattern.setStatus('mandatory')
if mibBuilder.loadTexts: prtBertPattern.setDescription('This object indicates the pattern of the BERT. p2Exxm1 = 2Exx-1. pxx = pattern xx. This object is the same for all configurations. notApplicable - when this object is not supported.')
prtBertInjectRate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 255))).clone(namedValues=NamedValues(("noError", 1), ("r10Em1", 2), ("r10Em2", 3), ("r10Em3", 4), ("r10Em4", 5), ("r10Em5", 6), ("r10Em6", 7), ("r10Em7", 8), ("single", 9), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtBertInjectRate.setStatus('mandatory')
if mibBuilder.loadTexts: prtBertInjectRate.setDescription('This object indicates the error rate injection of the BERT. r10Emx = 10E-x This object is the same for all configurations. single - single error injection. notApplicable - when this object is not supported.')
prtBertInjectErrRateCmd = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 5, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtBertInjectErrRateCmd.setStatus('mandatory')
if mibBuilder.loadTexts: prtBertInjectErrRateCmd.setDescription('This object controls activation/deactivation of the Error Rate Injection during BERT.')
prtBertInjectSingleErrCmd = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 5, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtBertInjectSingleErrCmd.setStatus('mandatory')
if mibBuilder.loadTexts: prtBertInjectSingleErrCmd.setDescription('This object enables to initiate a Single Error Injection during BERT (on). Upon completion, the value will automatically change to off(2).')
prtBertRunTime = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 5, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtBertRunTime.setStatus('mandatory')
if mibBuilder.loadTexts: prtBertRunTime.setDescription('This object indicates how much time (seconds) passed since BERT started to run.')
prtBertESs = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 5, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtBertESs.setStatus('mandatory')
if mibBuilder.loadTexts: prtBertESs.setDescription('How many Errored Seconds were detected since BERT started to run. Counter for Kmux and MP.')
prtBertSyncLoss = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 5, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtBertSyncLoss.setStatus('mandatory')
if mibBuilder.loadTexts: prtBertSyncLoss.setDescription('How many times Sync Loss was detected since BERT started to run. For some products: number of seconds in which Sync Loss occured since BERT started to run. See product specification.')
prtBertErrorBits = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 5, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtBertErrorBits.setStatus('mandatory')
if mibBuilder.loadTexts: prtBertErrorBits.setDescription('How many Error Bits were detected since BERT started to run.')
prtBertClearCounters = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 5, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtBertClearCounters.setStatus('mandatory')
if mibBuilder.loadTexts: prtBertClearCounters.setDescription('Setting this object to ON, will enforce a clear operation of some BERT Counters. Upon completion, the value will automatically change to off(2).')
prtBertSyncStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 5, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("syncLoss", 2), ("sync", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtBertSyncStatus.setStatus('mandatory')
if mibBuilder.loadTexts: prtBertSyncStatus.setDescription('Sync Status while BERT runs.')
prtBertTs = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 5, 1, 12), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtBertTs.setStatus('mandatory')
if mibBuilder.loadTexts: prtBertTs.setDescription("This object indicates on which TSs of the selected port, BERT should be applied. Each Bit of the Octet represents a TS: 31 ......0 MSB LSB Bit 0 will not be used. If the bit value is '1' - BERT should be applied on this TS. For a T1 port, the valid raised bits ('1') are: 1..25. For an E1 port, the valid raised bits ('1') are: 1..31. Agents that do not support this feature will send SIZE 0.")
prtMonTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 6), )
if mibBuilder.loadTexts: prtMonTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtMonTable.setDescription("The write operation into the Table's Objects is valid only for the TmpCnfg entry (Scratch).")
prtMonEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 6, 1), ).setIndexNames((0, "DACS-MIB", "prtMonCnfgIdx"), (0, "DACS-MIB", "prtMonitoringIdx"))
if mibBuilder.loadTexts: prtMonEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtMonEntry.setDescription('')
prtMonCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtMonCnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtMonCnfgIdx.setDescription('This object indicates the Idx of the Cnfg(1..255) being accessed. Idx of 255 relates to the TmpCnfg. ')
prtMonitoringIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 6, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtMonitoringIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtMonitoringIdx.setDescription('This object indicates the Monitoring Port Index. The valid port number depends on the IO slot no., the installed card type and the port type: external, internal. * The external ports will according to the convention (for DXC): - first two digits will be: (IO slot number+10) - last one/two digits will be the port number within the card, in odd numbers: port1 = 1 port2 = 3 port3 = 5 etc... Example: port2 of IO slot 11 will be: 213 . * The internal ports will be according to the convention (for DXC): - first two digits will be: (IO slot number+10) - last one/two digits will be the port number within the card, in even numbers: port1 = 2 port2 = 4 port3 = 6 etc... Example: port2 of IO slot 11 will be: 214 .')
prtMonitoringEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtMonitoringEnable.setStatus('mandatory')
if mibBuilder.loadTexts: prtMonitoringEnable.setDescription('This object indicates if the prtMonitoringIdx is configured as a monitoring port or not. disabled = the port is NOT configured to monitor. Setting this object to this value will cause reset (to 0) of the prtMonitoringTSs and prtMonitoredTSs objects. enabled = the port IS configured to monitor.')
prtMonitoringTSs = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 6, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtMonitoringTSs.setStatus('mandatory')
if mibBuilder.loadTexts: prtMonitoringTSs.setDescription("This object indicates which TSs of the Monitoring port, the test equipment should monitor. Each Bit of the Octet represents a TS: 31 ......0 MSB LSB Bit 0 will not be used. If the bit value is '1' - this TS should be monitored. For a T1 port, the valid raised bits ('1') are: 1..24. For an E1 port, the valid raised bits ('1') are: 1..31. Default: all bits='0' Agents that do not support this feature will send SIZE 0. This object can be Set as described only if prtMonitoringEnable=enabled. ")
prtMonitoredPort = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 6, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtMonitoredPort.setStatus('mandatory')
if mibBuilder.loadTexts: prtMonitoredPort.setDescription('This object indicates the MONITORED Port Index that the Monitoring port monitors. The valid port number depends on the IO slot no., the installed card type and the port type: external, internal. * The external ports will according to the convention (for DXC): - first two digits will be: (IO slot number+10) - last one/two digits will be the port number within the card, in odd numbers: port1 = 1 port2 = 3 port3 = 5 etc... Example: port2 of IO slot 11 will be: 213 . * The internal ports will be according to the convention (for DXC): - first two digits will be: (IO slot number+10) - last one/two digits will be the port number within the card, in even numbers: port1 = 2 port2 = 4 port3 = 6 etc... Example: port2 of IO slot 11 will be: 214 . * 100 - no port monitored ')
prtMonitoredTSs = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 6, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtMonitoredTSs.setStatus('mandatory')
if mibBuilder.loadTexts: prtMonitoredTSs.setDescription("This object indicates which TSs of the Monitored port, should be monitored. Each Bit of the Octet represents a TS: 31 ......0 MSB LSB Bit 0 will not be used. If the bit value is '1' - this TS should be monitored. For a T1 port, the valid raised bits ('1') are: 1..24. For an E1 port, the valid raised bits ('1') are: 1..31. Default: all bits='0' Agents that do not support this feature will send SIZE 0. This object can be Set as described only if prtMonitoringEnable=enabled.")
prtCfgParam = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 7))
prtCfgParamTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 7, 1), )
if mibBuilder.loadTexts: prtCfgParamTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtCfgParamTable.setDescription('The write operation into the Table Objects is valid only to the TmpCnfg entry. Parameters for the channels of the KMUX Cards: KMBE/New, KVF.6 family.')
prtCfgParamEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 7, 1, 1), ).setIndexNames((0, "DACS-MIB", "prtCfgParamCnfgIdx"), (0, "DACS-MIB", "prtCfgParamIdx"))
if mibBuilder.loadTexts: prtCfgParamEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtCfgParamEntry.setDescription('')
prtCfgParamCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 7, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtCfgParamCnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtCfgParamCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg (1..100) being accessed. Idx 255 relates to the TmpCnfg.')
prtCfgParamIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 7, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtCfgParamIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtCfgParamIdx.setDescription('A unique identifier of the port (within the card when applicable). - For KM-2100: Slot*100+Ch external ports: Ch=1..10 internal ports (sub-channels): Ch=11..20. - For FCD-T1/E1: SUB=113, CH1=122, CH2=124. ')
prtCfgParamSlt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 7, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 255))).clone(namedValues=NamedValues(("kmxIO1", 107), ("kmxIO2", 108), ("kmxIO3", 109), ("kmxIO4", 110), ("kmxIO5", 111), ("kmxIO6", 112), ("kmxIO7", 113), ("kmxIO8", 114), ("kmxIO9", 115), ("kmxIO10", 116), ("kmxIO11", 117), ("kmxIO12", 118), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtCfgParamSlt.setStatus('mandatory')
if mibBuilder.loadTexts: prtCfgParamSlt.setDescription('This attribute indicates a unique number to identify the slot where the card is inserted in. In the 2104 Unit the entries kmxIO5(111)..kmxIO12(118) are not valid. notApplicable(255) - for products that do not have Slots.')
prtCfgParamOperatedMl = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 7, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 103, 104))).clone(namedValues=NamedValues(("notApplicable", 1), ("kmxMlA", 103), ("kmxMlB", 104)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtCfgParamOperatedMl.setStatus('mandatory')
if mibBuilder.loadTexts: prtCfgParamOperatedMl.setDescription('The main link for this channel. The field is relevant only for ML modes of Dual, Priority Bumping and Switched Backup.')
prtCfgParamMlAtoMlBPrio = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 7, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("low", 2), ("high", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtCfgParamMlAtoMlBPrio.setStatus('mandatory')
if mibBuilder.loadTexts: prtCfgParamMlAtoMlBPrio.setDescription('ML-A to ML-B Priority. The field is relevant only for ML modes of Priority Bumping and Switched Backup.')
prtCfgParamMlBtoMlAPrio = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 7, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("low", 2), ("high", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtCfgParamMlBtoMlAPrio.setStatus('mandatory')
if mibBuilder.loadTexts: prtCfgParamMlBtoMlAPrio.setDescription('ML-B to ML-A Priority. The field is relevant only for ML modes of Priority Bumping.')
prtCfgParamInbandLoopDetection = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 1, 7, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtCfgParamInbandLoopDetection.setStatus('mandatory')
if mibBuilder.loadTexts: prtCfgParamInbandLoopDetection.setDescription('Inband Loop Detection. The field is relevant for the following FCD-T1/E1 ports: SUB, CH1, CH2.')
prtT1E1StatTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 1), )
if mibBuilder.loadTexts: prtT1E1StatTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtT1E1StatTable.setDescription('T1/E1 port statistics table.')
prtT1E1StatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 1, 1), ).setIndexNames((0, "DACS-MIB", "prtT1E1SPrtIdx"))
if mibBuilder.loadTexts: prtT1E1StatEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtT1E1StatEntry.setDescription(' An entry in the T1/E1 port statistics table.')
prtT1E1SPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtT1E1SPrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtT1E1SPrtIdx.setDescription('This attribute indicates a unique port number. The same numbering as for prtGenPrtIdx. The valid port number depends on the IO slot no., the installed card type and the port type: outside, inside. * The outside ports will be the T1/E1 cards ports. The convention used will be (for DXC): - first two digits will be: (IO slot number+10) - last one/two digits will be the port number within the card, in odd numbers: port1 = 1 port2 = 3 port3 = 5 etc... Example: port2 of IO slot 11 will be: 213 .')
prtT1E1SSlt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 255))).clone(namedValues=NamedValues(("clA", 3), ("clB", 4), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("io13", 17), ("io14", 18), ("io15", 19), ("standAlone", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtT1E1SSlt.setStatus('mandatory')
if mibBuilder.loadTexts: prtT1E1SSlt.setDescription('This attribute indicates a unique number to identify the slot where the card is inserted in. When the unit is stand-alone, this object is not applicable and 255 will be used.')
prtT1E1OosCount = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 1, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtT1E1OosCount.setStatus('mandatory')
if mibBuilder.loadTexts: prtT1E1OosCount.setDescription('This object is applicable only for an E1 active port. It provides the number of red alarm events since the last count clearing.')
prtT1E1BpvLastMin = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 1, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtT1E1BpvLastMin.setStatus('mandatory')
if mibBuilder.loadTexts: prtT1E1BpvLastMin.setDescription('This object is applicable only for an E1 active port. It provides the number of BPV (BiPolar Violation) events detected during the last minute.')
prtT1E1BpvMax = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 1, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtT1E1BpvMax.setStatus('mandatory')
if mibBuilder.loadTexts: prtT1E1BpvMax.setDescription('This object is applicable only for an E1 active port. It provides the maximal number of BPV (BiPolar Violation) events (per minute), detected during the worst minute.')
prtT1E1CnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 2), )
if mibBuilder.loadTexts: prtT1E1CnfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtT1E1CnfgTable.setDescription('T1/E1 port configuration table.')
prtT1E1CnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 2, 1), ).setIndexNames((0, "DACS-MIB", "prtT1E1CnfgIdx"), (0, "DACS-MIB", "prtT1E1PrtIdx"))
if mibBuilder.loadTexts: prtT1E1CnfgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtT1E1CnfgEntry.setDescription(' An entry in the T1/E1 port configuration table.')
prtT1E1CnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtT1E1CnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtT1E1CnfgIdx.setDescription('This attribute indicates the Idx of the Config being accessed. Idx of 255 relates to the Temporary (Scratch) Config. ')
prtT1E1PrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtT1E1PrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtT1E1PrtIdx.setDescription('This attribute indicates a unique port number. The same numbering as for prtGenPrtIdx. The valid port number depends on the IO slot no., the installed card type and the port type: outside, inside. In the DXC : - first two digits will be: (IO slot number+10) - last one/two digits will be the port number within the card in odd or even numbers, as follows: * For the outside/external ports, in odd numbers: port1 = 1 port2 = 3 port3 = 5 etc... Example: port2 of IO slot 11 will be: 213 . * The inside/internal ports, in even numbers: port1 = 2 port2 = 4 port3 = 6 etc... Example: port2 of IO slot 11 will be: 214 . In the Kilomux, the port index is calculated as follows: 100*Slot+Ch. The external Ch numbers are 1..10, and the internal Ch numbers are 11..20.')
prtT1E1Slt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 103, 104, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 255))).clone(namedValues=NamedValues(("clA", 3), ("clB", 4), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("io13", 17), ("io14", 18), ("io15", 19), ("kmxMlA", 103), ("kmxMlB", 104), ("kmxOpt", 106), ("kmxIO1", 107), ("kmxIO2", 108), ("kmxIO3", 109), ("kmxIO4", 110), ("kmxIO5", 111), ("kmxIO6", 112), ("kmxIO7", 113), ("kmxIO8", 114), ("kmxIO9", 115), ("kmxIO10", 116), ("kmxIO11", 117), ("kmxIO12", 118), ("standAlone", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtT1E1Slt.setStatus('mandatory')
if mibBuilder.loadTexts: prtT1E1Slt.setDescription('This attribute indicates a unique number to identify the slot where the card is inserted in. When the unit is stand-alone, this object is not applicable and 255 will be used.')
prtT1E1LineType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("other", 1), ("esf", 2), ("d4", 3), ("e1", 4), ("e1Crc", 5), ("e1MF", 6), ("e1CrcMF", 7), ("unframed", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtT1E1LineType.setStatus('mandatory')
if mibBuilder.loadTexts: prtT1E1LineType.setDescription('This variable indicates the variety of T1/E1 Line implementing this circuit. The type of circuit affects the number of bits per second that the circuit can reasonably carry, as well as the interpretation of the usage and error statistics. The values, in sequence, describe: TITLE: SPECIFICATION: esf Extended SuperFrame DS1 d4 AT&T D4 format DS1 - SF e1 CCITT Recommendation G.704 (Table 4a) - G732N e1Crc CCITT Recommendation G.704 (Table 4b) - G732N with CRC e1MF G.704 (Table 4a) with TS16 multiframing enabled - G732S e1CrcMF G.704 (Table 4b) with TS16 multiframing enabled - G732S with CRC unframed T1 - applicable values: (1),(2),(3),(8) E1 - applicable values: (1),(4),(5),(6),(7),(8) ')
prtT1E1LineCode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("jbzs", 1), ("b8zs", 2), ("hdb3", 3), ("zbtsi", 4), ("ami", 5), ("other", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtT1E1LineCode.setStatus('mandatory')
if mibBuilder.loadTexts: prtT1E1LineCode.setDescription('This variable describes the variety of Zero Code Suppression used on the link, which in turn affects a number of its characteristics. jbzs=b7zs refers the Jammed Bit Zero Suppres- sion, in which the AT&T specification of at least one pulse every 8 bit periods is literal- ly implemented by forcing a pulse in bit 8 of each channel. Thus, only seven bits per chan- nel, or 1.344 Mbps, is available for data (used for T1). b8zs refers to the use of a specified pattern of normal bits and bipolar violations which are used to replace a sequence of eight zero bits (used for T1). ANSI Clear Channels may use zbtsi, or Zero Byte Time Slot Interchange. E1 links, with or without CRC, use hdb3 or ami (= TRAN). amI (=TRAN) refers to a mode wherein no zero code suppression is present and the line encoding does not solve the problem directly. In this application, the higher layer must provide data which meets or exceeds the pulse density re- quirements, such as inverting HDLC data.')
prtT1E1SignalMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("robbedBit", 2), ("bitOriented", 3), ("messageOriented", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtT1E1SignalMode.setStatus('mandatory')
if mibBuilder.loadTexts: prtT1E1SignalMode.setDescription("'none' indicates that no bits are reserved for signaling on this channel. 'robbedBit' indicates that T1 Robbed Bit Signaling is in use. 'bitOriented' indicates that E1 Channel Associated Signaling (CAS) is in use. 'messageOriented' indicates that Common Channel Signaling (CCS) is in use either on channel 16 of an E1 link or channel 24 of a T1.")
prtT1E1Fdl = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 8, 16))).clone(namedValues=NamedValues(("other", 1), ("ansi-T1-403", 2), ("att-54016", 4), ("fdl-none", 8), ("transFdl", 16)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtT1E1Fdl.setStatus('mandatory')
if mibBuilder.loadTexts: prtT1E1Fdl.setDescription("This bitmap describes the use of the facili- ties data link, and is the sum of the capabili- ties: 'other' indicates that a protocol other than one following is used. 'ansi-T1-403' refers to the FDL exchange recommended by ANSI. 'att-54016' refers to ESF FDL exchanges. 'fdl-none' indicates that the device does not use the FDL. 'transFdl' indicates transition between two ports of the same card. ")
prtT1E1FdlMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 255))).clone(namedValues=NamedValues(("other", 1), ("user", 2), ("carrier", 3), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtT1E1FdlMode.setStatus('mandatory')
if mibBuilder.loadTexts: prtT1E1FdlMode.setDescription(' Fdl Mode of the T1 selected port. notApplicable - will be used for an E1 port.')
prtT1E1Sync = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("tr62411", 2), ("ccitt", 3), ("fast", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtT1E1Sync.setStatus('mandatory')
if mibBuilder.loadTexts: prtT1E1Sync.setDescription("This object enables returning to normal operation, after the end of a main/sub link red alarm event, in reduced time. 'tr62411' - complies with AT&T TR-62411 (after 10 seconds). Applicable for both T1 and E1 interfaces. 'ccitt' - complies with CCITT standard. Applicable only for E1 interfaces. 'fast' - after 1 second.")
prtT1E1CGA = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("trans", 2), ("full", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtT1E1CGA.setStatus('mandatory')
if mibBuilder.loadTexts: prtT1E1CGA.setDescription("This object selects the method used to signal the CGA state to the other end, through the main/sub link. 'none' - non-transparent mode. When one of the links (main/sub) will be in Out Of Service state, both 'Data/Voice Oos' and 'Oos Signal' will be transmitted to the other end. 'trans' - when one of the links (main/sub) will be in Out Of Service state, 'Data/Voice Oos' will be transmitted to the other end. 'full' - fully-transparent mode. When one of the links (main/sub) will be in Out Of Service state, neither 'Data/Voice Oos' nor 'Oos Signal' will be transmitted to the other end.")
prtT1E1IdleCode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 2, 1, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtT1E1IdleCode.setStatus('mandatory')
if mibBuilder.loadTexts: prtT1E1IdleCode.setDescription('This object selects the code transmitted to fill idle (unused) time slots in the main link frame. Valid range: (0 - FF HEX) .')
prtT1E1OosSignal = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("notsupported", 2), ("forcedIdle", 3), ("forcedBusy", 4), ("busyIdle", 5), ("idleBusy", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtT1E1OosSignal.setStatus('mandatory')
if mibBuilder.loadTexts: prtT1E1OosSignal.setDescription("'idle' = '0' = on-hook, idle state 'busy' = '1' = off-hook, busy state 'forcedIdle' = SP = both A and B signaling bits are forced to '0' during out-of-service periods. 'forcedBusy' = MK = both A and B signaling bits are forced to '1' during out-of-service periods. 'busyIdle' = MK_SP = A and B bits are forced to '1' for 2.5 seconds; then they are switched to '0' until out-of-service condition disappears. 'idleBusy' = SP_MK = A and B bits are forced to '0' for 2.5 seconds; then they are switched to '1' until out-of-service condition disappears. - for T1: '0'=0 ; '1'=1 - for E1: '0'=1 ; '1'=0 ")
prtT1E1VoiceOos = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 2, 1, 13), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtT1E1VoiceOos.setStatus('mandatory')
if mibBuilder.loadTexts: prtT1E1VoiceOos.setDescription('Voice Out-Of-Service code. Valid range: (0 - FF HEX). For agents that do not support this feature, the value will always be 0.')
prtT1E1DataOos = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 2, 1, 14), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtT1E1DataOos.setStatus('mandatory')
if mibBuilder.loadTexts: prtT1E1DataOos.setDescription('Data Out-Of-Service code. Valid range: (0 - FF HEX). For agents that do not support this feature, the value will always be 0.')
prtT1E1LineLengthMask = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("unknown", 1), ("len0p133ft", 2), ("len134p266ft", 3), ("len267p399ft", 4), ("len400p533ft", 5), ("len534p655ft", 6), ("fcc68", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtT1E1LineLengthMask.setStatus('mandatory')
if mibBuilder.loadTexts: prtT1E1LineLengthMask.setDescription("This attribute is the line length mask parameter used only for T1/DSU interfaces. len400p533ft=length range: 400ft to 533ft 'fcc68' - provides compliance with the FCC 68.308 Option A output pulse mask. ")
prtT1E1TxGainMask = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notApplicable", 1), ("txGain0db", 2), ("txGain7dot5db", 3), ("txGain15db", 4), ("txGain22dot5db", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtT1E1TxGainMask.setStatus('mandatory')
if mibBuilder.loadTexts: prtT1E1TxGainMask.setDescription('This attribute is the tx gain mask parameter (dB), used only for T1/CSU interfaces.')
prtT1E1InbandMng = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 2, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("off", 2), ("fdlOrTs0", 3), ("dedicatedTs", 4), ("dedicatedPpp", 5), ("dedicatedFr", 6), ("internal", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtT1E1InbandMng.setStatus('mandatory')
if mibBuilder.loadTexts: prtT1E1InbandMng.setDescription('A unique number to identify an Inband management over the link. internal - supported by KM-2100 only. It means that the management is internal to the frame. It takes part of the ML Frame bits (instead of data).')
prtT1E1InbandMngRate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 2, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("notApplicable", 1), ("r4k", 2), ("r8k", 3), ("r12k", 4), ("r16k", 5), ("r32k", 6), ("r64k", 7), ("r20k", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtT1E1InbandMngRate.setStatus('mandatory')
if mibBuilder.loadTexts: prtT1E1InbandMngRate.setDescription('A unique number to identify the rate of the Inband management. It is required only for E1 links and is applicable only when prtExT1E1InbandMng selected is FdlOrTs0 or dedicatedTs.')
prtT1E1DedicatedTs = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 2, 1, 19), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtT1E1DedicatedTs.setStatus('mandatory')
if mibBuilder.loadTexts: prtT1E1DedicatedTs.setDescription('A unique number to identify Dedicated TS of the T1/E1 port. It is applicable only when prtExT1E1InbandMng selected is dedicatedTs. 1..24 - Dedicated TS of T1 1..31 - Dedicated TS of E1 255 - notApplicable (for agents that do not support this feature) Other values are invalid.')
prtT1E1InbandMngRoutProt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 2, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("none", 2), ("proprietary", 3), ("rip2", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtT1E1InbandMngRoutProt.setStatus('mandatory')
if mibBuilder.loadTexts: prtT1E1InbandMngRoutProt.setDescription("Inband Mng Routing Protocol of the port. When prtT1E1InbandMng is 'dedicatedPpp'-'proprietary' and 'rip2' are applicable. For other values - only 'proprietary' is applicable.")
prtT1E1LinkMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 2, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("regular", 2), ("transparent", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtT1E1LinkMode.setStatus('mandatory')
if mibBuilder.loadTexts: prtT1E1LinkMode.setDescription('regular - TSs are connected by user via TS Assignment only transparent - when a port with this Link Mode is connected to an internal T1/E1 port of a T3/E3 card, TS0, TS16 and Fbit are transparently transferred to the E3/T3 stream.')
prtT1E1Multiplier = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 2, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("br56", 2), ("br64", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtT1E1Multiplier.setStatus('mandatory')
if mibBuilder.loadTexts: prtT1E1Multiplier.setDescription('The data rate of each TS. The multiplier values can be 56 kbps or 64 kbps. For T1 only.')
prtT1E1RxGain = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 2, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("notApplicable", 1), ("rxGain12dB", 2), ("rxGain30dB", 3), ("rxGain36dB", 4), ("shortHaul", 5), ("longHaul", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtT1E1RxGain.setStatus('mandatory')
if mibBuilder.loadTexts: prtT1E1RxGain.setDescription('This attribute is the rx volume (dB).')
prtT1E1RAI = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 2, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtT1E1RAI.setStatus('mandatory')
if mibBuilder.loadTexts: prtT1E1RAI.setDescription('Remote Alarm Signal')
prtT1E1LineMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 2, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("csu", 2), ("dsu", 3), ("ltu", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtT1E1LineMode.setStatus('mandatory')
if mibBuilder.loadTexts: prtT1E1LineMode.setDescription('Interface type of the port. For T1 - csu, dsu are the valid values For E1 - dsu, ltu are the valid values')
prtT1E1TS0SaBits = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 2, 1, 26), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtT1E1TS0SaBits.setStatus('mandatory')
if mibBuilder.loadTexts: prtT1E1TS0SaBits.setDescription('This object is applicable only for E1 ports. For T1, string size will be 0. For E1, it enables user to select the use of TS0 Sa Bits 4..8, by 3 octets: The order (in hexa display): free Sa-Bit-4 Sa-Bit-5 Sa-Bit-6 Sa-Bit-7 Sa-Bit-8 |___________| |________________| |________________| MSByte LSByte Each Sa Bit will be represented by a nibble, having the following meaning: 0000 = zero 0001 = one 0010 = management 0011 = transparent the rest are reserved for future use.')
prtT1E1FdlMsgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 3), )
if mibBuilder.loadTexts: prtT1E1FdlMsgTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtT1E1FdlMsgTable.setDescription("This table is applicable for a T1 interface with 'esf' LineType or E1 interface, when CRC is enabled (LineType).")
prtT1E1FdlMsgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 3, 1), ).setIndexNames((0, "DACS-MIB", "prtT1E1FdlMsgPrtIdx"), (0, "DACS-MIB", "prtT1E1FdlMsgFdlType"))
if mibBuilder.loadTexts: prtT1E1FdlMsgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtT1E1FdlMsgEntry.setDescription('')
prtT1E1FdlMsgPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtT1E1FdlMsgPrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtT1E1FdlMsgPrtIdx.setDescription('This attribute indicates a unique port number. The same numbering as for prtGenPrtIdx. The valid port number depends on the IO slot no., the installed card type and the port type: outside, inside. * The outside ports will be the T1/E1 cards ports. The convention used will be (for DXC): - first two digits will be: (IO slot number+10) - last one/two digits will be the port number within the card, in odd numbers: port1 = 1 port2 = 3 port3 = 5 etc... Example: port2 of IO slot 11 will be: 213 .')
prtT1E1FdlMsgFdlType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("send", 1), ("receive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtT1E1FdlMsgFdlType.setStatus('mandatory')
if mibBuilder.loadTexts: prtT1E1FdlMsgFdlType.setDescription('The Fdl type reference of the Fdl message.')
prtT1E1FdlMsgSlt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("io13", 17), ("io14", 18), ("io15", 19), ("standAlone", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtT1E1FdlMsgSlt.setStatus('mandatory')
if mibBuilder.loadTexts: prtT1E1FdlMsgSlt.setDescription('This attribute indicates a unique number to identify the slot where the card is inserted in. When the unit is stand-alone, this object is not applicable and 255 will be used.')
prtT1E1FdlMsg = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 2, 3, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtT1E1FdlMsg.setStatus('mandatory')
if mibBuilder.loadTexts: prtT1E1FdlMsg.setDescription('FDL message.')
prtHSParamTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 3, 1), )
if mibBuilder.loadTexts: prtHSParamTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtHSParamTable.setDescription('')
prtHSParamEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 3, 1, 1), ).setIndexNames((0, "DACS-MIB", "prtHSCnfgIdx"), (0, "DACS-MIB", "prtHSPrtIdx"))
if mibBuilder.loadTexts: prtHSParamEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtHSParamEntry.setDescription('')
prtHSCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtHSCnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtHSCnfgIdx.setDescription('This attribute indicates the Idx of the Config being accessed. Idx of 255 relates to the Temporary (Scratch) Config. ')
prtHSPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 3, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtHSPrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtHSPrtIdx.setDescription('This attribute indicates a unique number to identify a port. The valid port number depends on the IO slot no., the installed card type and the port type: outside, inside, SP. * The inside ports will be the HS cards ports. The convention used will be (for DXC): - first two digits will be: (IO slot number+10) - last one/two digits will be the port number within the card, in even numbers: port1 = 2 port2 = 4 port3 = 6 etc... Example: port2 of IO slot 11 will be: 214 .')
prtHSSlt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("io13", 17), ("io14", 18), ("io15", 19), ("standAlone", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtHSSlt.setStatus('mandatory')
if mibBuilder.loadTexts: prtHSSlt.setDescription('This attribute indicates a unique number to identify the slot where the card is inserted in. When the unit is stand-alone, this object is not applicable and 255 will be used.')
prtHSRate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66))).clone(namedValues=NamedValues(("r0x56eq0Kbps", 1), ("r1x56eq56Kbps", 2), ("r2x56eq112Kbps", 3), ("r3x56eq168Kbps", 4), ("r4x56eq224Kbps", 5), ("r5x56eq280Kbps", 6), ("r6x56eq336Kbps", 7), ("r7x56eq392Kbps", 8), ("r8x56eq448Kbps", 9), ("r9x56eq504Kbps", 10), ("r10x56eq560Kbps", 11), ("r11x56eq616Kbps", 12), ("r12x56eq672Kbps", 13), ("r13x56eq728Kbps", 14), ("r14x56eq784Kbps", 15), ("r15x56eq840Kbps", 16), ("r16x56eq896Kbps", 17), ("r17x56eq952Kbps", 18), ("r18x56eq1008Kbps", 19), ("r19x56eq1064Kbps", 20), ("r20x56eq1120Kbps", 21), ("r21x56eq1176Kbps", 22), ("r22x56eq1232Kbps", 23), ("r23x56eq1288Kbps", 24), ("r24x56eq1344Kbps", 25), ("r25x56eq1400Kbps", 26), ("r26x56eq1456Kbps", 27), ("r27x56eq1512Kbps", 28), ("r28x56eq1568Kbps", 29), ("r29x56eq1624Kbps", 30), ("r30x56eq1680Kbps", 31), ("r31x56eq1736Kbps", 32), ("r0x64eq0Kbps", 33), ("r1x64eq64Kbps", 34), ("r2x64eq128Kbps", 35), ("r3x64eq192Kbps", 36), ("r4x64eq256Kbps", 37), ("r5x64eq320Kbps", 38), ("r6x64eq384Kbps", 39), ("r7x64eq448Kbps", 40), ("r8x64eq512Kbps", 41), ("r9x64eq576Kbps", 42), ("r10x64eq640Kbps", 43), ("r11x64eq704Kbps", 44), ("r12x64eq768Kbps", 45), ("r13x64eq832Kbps", 46), ("r14x64eq896Kbps", 47), ("r15x64eq960Kbps", 48), ("r16x64eq1024Kbps", 49), ("r17x64eq1088Kbps", 50), ("r18x64eq1152Kbps", 51), ("r19x64eq1216Kbps", 52), ("r20x64eq1280Kbps", 53), ("r21x64eq1344Kbps", 54), ("r22x64eq1408Kbps", 55), ("r23x64eq1472Kbps", 56), ("r24x64eq1536Kbps", 57), ("r25x64eq1600Kbps", 58), ("r26x64eq1664Kbps", 59), ("r27x64eq1728Kbps", 60), ("r28x64eq1792Kbps", 61), ("r29x64eq1856Kbps", 62), ("r30x64eq1920Kbps", 63), ("r31x64eq1984Kbps", 64), ("r32x64eq2048Kbps", 65), ("r32x56eq1792Kbps", 66)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtHSRate.setStatus('mandatory')
if mibBuilder.loadTexts: prtHSRate.setDescription('This object indicates the port rate (speed).')
prtHSFifoSize = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 255))).clone(namedValues=NamedValues(("auto", 1), ("b32bit", 2), ("b60bit", 3), ("b104bit", 4), ("b144bit", 5), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtHSFifoSize.setStatus('mandatory')
if mibBuilder.loadTexts: prtHSFifoSize.setDescription('This object selects the size of the user data channel buffer FIFO used in the DTE2 mode. In the other modes, buffer size is automatically set by the DACS agent. Buffer FIFO size in bits, corresponds to FIFO lengths of +/-16, +/-30, +/-52, +/-72 bits.')
prtHSClkMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 255))).clone(namedValues=NamedValues(("dce", 1), ("dte1", 2), ("dte2", 3), ("notApplicable", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtHSClkMode.setStatus('mandatory')
if mibBuilder.loadTexts: prtHSClkMode.setDescription('Clock Mode of the user data channel. dce - DACS operates as a DCE and provides transmit and receive clocks to the synchronous user DTE. dte1- DACS supplies the receive clock to the user equipment and accepts the user transmit clock. dte2- DACS requires transmit and receive clocks from the user equipment.')
prtHSCTS = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("rts", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtHSCTS.setStatus('mandatory')
if mibBuilder.loadTexts: prtHSCTS.setDescription('Selection of CTS line state in the user data channel. on - CTS continuously ON. rts - CTS line follows the RTS line.')
prtHSRtsState = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 255))).clone(namedValues=NamedValues(("off", 2), ("on", 3), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtHSRtsState.setStatus('mandatory')
if mibBuilder.loadTexts: prtHSRtsState.setDescription('RTS state of the port.')
prtHSBertTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 3, 2), )
if mibBuilder.loadTexts: prtHSBertTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtHSBertTable.setDescription('')
prtHSBertEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 3, 2, 1), ).setIndexNames((0, "DACS-MIB", "prtHSBertPrtIdx"))
if mibBuilder.loadTexts: prtHSBertEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtHSBertEntry.setDescription('')
prtHSBertPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtHSBertPrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtHSBertPrtIdx.setDescription('This attribute indicates a unique number to identify a port. The valid port number depends on the IO slot no., the installed card type and the port type: outside, inside, SP. * The inside ports will be the HS cards ports. The convention used will be (for DXC): - first two digits will be: (IO slot number+10) - last one/two digits will be the port number within the card, in even numbers: port1 = 2 port2 = 4 port3 = 6 etc... Example: port2 of IO slot 11 will be: 214 .')
prtHSBertSlt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 3, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("io13", 17), ("io14", 18), ("io15", 19), ("standAlone", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtHSBertSlt.setStatus('mandatory')
if mibBuilder.loadTexts: prtHSBertSlt.setDescription('This attribute indicates a unique number to identify the slot where the card is inserted in. When the unit is stand-alone, this object is not applicable and 255 will be used.')
prtHSBertCountClr = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtHSBertCountClr.setStatus('mandatory')
if mibBuilder.loadTexts: prtHSBertCountClr.setDescription('Setting this object (to on) initiate bert counter clear operation. Valid only when bert test is active on the specific port. (Every time a new bert test starts, the counter is automatically cleared; this command enables clearing the counter while the test is running).')
prtHSBertTestResult = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 3, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtHSBertTestResult.setStatus('mandatory')
if mibBuilder.loadTexts: prtHSBertTestResult.setDescription('This object indicates the number of Bit Error Rate indicated during the BERT test. Active only when bert test is running on the selected port.')
prtSpCnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 4, 1), )
if mibBuilder.loadTexts: prtSpCnfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtSpCnfgTable.setDescription('')
prtSpCnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 4, 1, 1), ).setIndexNames((0, "DACS-MIB", "prtSpCnfgIdx"), (0, "DACS-MIB", "prtSpPrtIdx"))
if mibBuilder.loadTexts: prtSpCnfgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtSpCnfgEntry.setDescription('All the entries at this table are identical(have the same value) at all the configurations(1..255) except at the TmpCnfg. - For products supporting more than one configuration, the write operation into the Table Objects is valid only at the TmpCnfg entry. - For products that do not support configurations, the write operation into the Table Objects will be to prtSpCnfgIdx=1.')
prtSpCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSpCnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtSpCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg(1..255) being accessed. Idx of 255 relates to the TmpCnfg.')
prtSpPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 4, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtSpPrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtSpPrtIdx.setDescription('This attribute indicates a unique port number of the SPor DP port. For DXC, it is the port in the active DCL card: - SP = 1 - NP ; DP = 2 For Kilomux, the port index is calculated as follows: 100*Slot+Ch. For FCD, PRBi, the SP port index=1.')
prtSpUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("unknown", 1), ("noUse", 2), ("nmsSlip", 3), ("nmsPpp", 4), ("muxSlip", 5), ("muxPpp", 6), ("terminal", 7), ("dialOut", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtSpUsage.setStatus('mandatory')
if mibBuilder.loadTexts: prtSpUsage.setDescription('This attribute indicates what is the usage of the port.')
prtSpRate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("auto", 1), ("s300bps", 2), ("s1200bps", 3), ("s2400bps", 4), ("s4800bps", 5), ("s9600bps", 6), ("s19200bps", 7), ("s38400bps", 8), ("s57600bps", 9), ("s115200bps", 10)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtSpRate.setStatus('mandatory')
if mibBuilder.loadTexts: prtSpRate.setDescription('This attribute indicates the operation rate (speed) of the port. auto - automatic rate selection, by the agent.')
prtSpDataBits = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dataBits7", 1), ("dataBits8", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtSpDataBits.setStatus('mandatory')
if mibBuilder.loadTexts: prtSpDataBits.setDescription('This attribute indicates the number of data bits in async frame')
prtSpParity = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 4, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("odd", 2), ("even", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtSpParity.setStatus('mandatory')
if mibBuilder.loadTexts: prtSpParity.setDescription('This attribute indicates the parity mode in async frame')
prtSpCallOutMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 4, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("none", 2), ("all", 3), ("major", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtSpCallOutMode.setStatus('mandatory')
if mibBuilder.loadTexts: prtSpCallOutMode.setDescription('This attribute indicates the call-out mode. For DXC - this object is applicable only for the DP port (2).')
prtSpInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 4, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dce", 1), ("dte", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtSpInterface.setStatus('mandatory')
if mibBuilder.loadTexts: prtSpInterface.setDescription('This attribute indicates the supervisory port interface. dce - the DACS appears as a DCE for the port. dte - the DACS operates as a DTE, for connection via modem, for the port. Port 2 - when DP, will be always dte(2). ')
prtSpCTS = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 4, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("on", 2), ("rts", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtSpCTS.setStatus('mandatory')
if mibBuilder.loadTexts: prtSpCTS.setDescription('CTS line state. This object is applicable only for port (1) = SP')
prtSpDcdDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 4, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("notApplicable", 1), ("d0", 2), ("d10", 3), ("d50", 4), ("d100", 5), ("d200", 6), ("d300", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtSpDcdDelay.setStatus('mandatory')
if mibBuilder.loadTexts: prtSpDcdDelay.setDescription('DCD delay in msec. d10 = delay of 10msec. This object is applicable only for port (1) = SP')
prtSpDsr = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 4, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("on", 2), ("dtr", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtSpDsr.setStatus('mandatory')
if mibBuilder.loadTexts: prtSpDsr.setDescription('DSR line state. This object is applicable only for port (1) = SP')
prtSpNoOfRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 4, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtSpNoOfRetries.setStatus('mandatory')
if mibBuilder.loadTexts: prtSpNoOfRetries.setDescription('For DXC - this object is applicable only for port (2) = DP. The number of dialing retries requested. Default = 0')
prtSpWaitForConnect = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 4, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("t30sec", 2), ("t45sec", 3), ("t60sec", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtSpWaitForConnect.setStatus('mandatory')
if mibBuilder.loadTexts: prtSpWaitForConnect.setDescription('For DXC - this object is applicable only for port (2) = DP. Waiting time for connect, in seconds. Default = 30 sec.')
prtSpDialMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 4, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("tone", 2), ("pulse", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtSpDialMode.setStatus('mandatory')
if mibBuilder.loadTexts: prtSpDialMode.setDescription('For DXC - this object is applicable only for port (2) = DP. Dialing mode. Default=tone')
prtSpAltNumMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 4, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtSpAltNumMode.setStatus('mandatory')
if mibBuilder.loadTexts: prtSpAltNumMode.setDescription('For DXC - this object is applicable only for port (2) = DP. It determines wether to use the alternate number or not. Default = no.')
prtSpPrimaryNum = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 4, 1, 1, 16), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtSpPrimaryNum.setStatus('mandatory')
if mibBuilder.loadTexts: prtSpPrimaryNum.setDescription('For DXC - this object is applicable only for port (2) = DP. It is the Primary dialing number. ')
prtSpAltNum = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 4, 1, 1, 17), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtSpAltNum.setStatus('mandatory')
if mibBuilder.loadTexts: prtSpAltNum.setDescription("For DXC - this object is applicable only for port (2) = DP. It is the Alternate dialing number. This number is applicable only if prtSpAltNumMode is 'yes'.")
prtSpRoutProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 4, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("none", 2), ("proprietary", 3), ("rip2", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtSpRoutProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: prtSpRoutProtocol.setDescription('This attribute indicates the routing protocol of the port. notApplicable - for DP.')
prtSpCmd = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 4, 1, 1, 19), OctetString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtSpCmd.setStatus('mandatory')
if mibBuilder.loadTexts: prtSpCmd.setDescription("SP Command. For LRS this parameter will be used for a Modem Command. Upon NMS's Get operation for devices that this parameter is notApplicable, agent will send NULL string.")
prtSpActCallOut = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 4, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("always", 2), ("linkFail", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtSpActCallOut.setStatus('mandatory')
if mibBuilder.loadTexts: prtSpActCallOut.setDescription('This object indicates when to Activate Call-Out. It is used by FCD-T1/E1. always - to activate call-out always. linkFail - to activate call-out only when Link of Inband Management fails.')
prtSpAlrRelayMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 4, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("normal", 2), ("invert", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtSpAlrRelayMode.setStatus('mandatory')
if mibBuilder.loadTexts: prtSpAlrRelayMode.setDescription('This attribute indicates the Alarm Relay Mode. notApplicable - for DP.')
prtDimCnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 5, 1), )
if mibBuilder.loadTexts: prtDimCnfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtDimCnfgTable.setDescription('')
prtDimCnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 5, 1, 1), ).setIndexNames((0, "DACS-MIB", "prtDimCnfgIdx"), (0, "DACS-MIB", "prtDimIdx"))
if mibBuilder.loadTexts: prtDimCnfgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtDimCnfgEntry.setDescription('The write operation into the Table Objects is valid only for the TmpCnfg entry (prtDimCnfgIdx=255).')
prtDimCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDimCnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtDimCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg(1..255) being accessed. Idx of 255 relates to the TmpCnfg.')
prtDimIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 5, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDimIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtDimIdx.setDescription('This attribute indicates a unique port number of the DIM card. The convention used for DXC: (IO slot number+10)*10 + 1 Example: port1 of IO slot 11 will be: 211 .')
prtDimTxMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 5, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("regularTx", 2), ("broadcast", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtDimTxMode.setStatus('mandatory')
if mibBuilder.loadTexts: prtDimTxMode.setDescription('Tx mode. regularTx - the links are connected to a similar outfit on the other side. In this mode, if a link fails, the transmitted bandwidth is decreased accordingly. broadcast - the links are connected to MORE than one similar outfit on the other side. In this mode, if a link fails, the transmitted bandwidth is not affected ')
prtDimPolarity = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 5, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("normalClk", 2), ("inverted", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtDimPolarity.setStatus('mandatory')
if mibBuilder.loadTexts: prtDimPolarity.setDescription('Polarity.')
prtDimClkMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 5, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5))).clone(namedValues=NamedValues(("extDce", 2), ("dce", 3), ("smooth", 4), ("extSmooth", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtDimClkMode.setStatus('mandatory')
if mibBuilder.loadTexts: prtDimClkMode.setDescription("Clock Mode. smooth - a clock that is not 'pulsed'(has no 'gaps'). In this mode the DXC does NOT receive back the clock signal. extSmooth - same as 'smooth' but in this mode, the DXC receives back the clock signal.")
prtDimMaxDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 5, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("t16msec", 2), ("t64msec", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtDimMaxDelay.setStatus('mandatory')
if mibBuilder.loadTexts: prtDimMaxDelay.setDescription('Max Delay permitted between the links, in msec.')
prtDimMng = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 5, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("disabled", 2), ("ts1", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtDimMng.setStatus('mandatory')
if mibBuilder.loadTexts: prtDimMng.setDescription('Use of DIM port for management. disabled - no management on DIM ts1 - 1 bit of TS1 is used for management.')
prtDimDestTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 5, 2), )
if mibBuilder.loadTexts: prtDimDestTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtDimDestTable.setDescription('')
prtDimDestEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 5, 2, 1), ).setIndexNames((0, "DACS-MIB", "prtDestCnfgIdx"), (0, "DACS-MIB", "prtDestDimIdx"), (0, "DACS-MIB", "prtDestIdx"))
if mibBuilder.loadTexts: prtDimDestEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtDimDestEntry.setDescription('The write operation is valid only for the TmpCnfg entry (prtDimDestCnfgIdx=255).')
prtDestCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 5, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDestCnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtDestCnfgIdx.setDescription('This attribute indicates the Idx of the Cnfg(1..255) being accessed. Idx of 255 relates to the TmpCnfg.')
prtDestDimIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 5, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDestDimIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtDestDimIdx.setDescription('This attribute indicates a unique port number of the DIM card. The convention used for DXC: (IO slot number+10)*10 + 1 Example: port1 of IO slot 11 will be: 211 .')
prtDestIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 5, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDestIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtDestIdx.setDescription('This attribute indicates a destination number of the DIM card. ')
prtDest = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 5, 2, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtDest.setStatus('mandatory')
if mibBuilder.loadTexts: prtDest.setDescription('Destination port,(of a T1/E1 port), that is connected to the DIM card, for the specified Destination number. 0 = No destination port. Else: For external ports: (IO Slot+10)*10 + 1 for port 1 (IO Slot+10)*10 + 3 for port 2 Example: port2 of IO slot 12 will be: 223 . For internal ports : (IO Slot+10)*10 + 2 for port 1 (IO Slot+10)*10 + 4 for port 2 (IO Slot+10)*10 + 6 for port 3 (IO Slot+10)*10 + 8 for port 4, etc...')
prtDestConnect = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 5, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("no", 2), ("yes", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtDestConnect.setStatus('mandatory')
if mibBuilder.loadTexts: prtDestConnect.setDescription('Connection Status of the specified destination number. For a specified destination port, it depends both on the status of the port and on the status of the far-end port. Since this is a RO object, same value will be received for all configurations.')
prtICnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 6, 1), )
if mibBuilder.loadTexts: prtICnfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtICnfgTable.setDescription('')
prtICnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 6, 1, 1), ).setIndexNames((0, "DACS-MIB", "prtICnfgIdx"), (0, "DACS-MIB", "prtIIdx"))
if mibBuilder.loadTexts: prtICnfgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtICnfgEntry.setDescription('')
prtICnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 6, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtICnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtICnfgIdx.setDescription('This attribute indicates the Idx of the Config being accessed. Idx of 255 relates to the Temporary (Scratch) Config. ')
prtIIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 6, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtIIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtIIdx.setDescription('This attribute indicates a unique number to identify a port. The valid port number depends on the IO slot no., the installed card type and the port type: outside, inside, SP. * The ISDN B1, B2, D channels will be inside ports. For port index, see product specification.')
prtIRate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 6, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notApplicable", 1), ("nc", 2), ("r2bit", 3), ("r4bit", 4), ("r8bit", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIRate.setStatus('mandatory')
if mibBuilder.loadTexts: prtIRate.setDescription('This object indicates the port rate in bits. Each TS contains 8 bits. Thus, 1 bit is equivalent to 8Kbps rate.')
prtIConnect = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 6, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtIConnect.setStatus('mandatory')
if mibBuilder.loadTexts: prtIConnect.setDescription('D channel connection. no - disconnected yes - connected. ')
prtHdslTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 7, 1), )
if mibBuilder.loadTexts: prtHdslTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtHdslTable.setDescription('')
prtHdslEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 7, 1, 1), ).setIndexNames((0, "DACS-MIB", "prtHdslIdx"))
if mibBuilder.loadTexts: prtHdslEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtHdslEntry.setDescription('')
prtHdslIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 7, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtHdslIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtHdslIdx.setDescription('This attribute indicates a unique number to identify a port. The valid port number depends on the IO slot no., the installed card type and the port type: outside, inside. * The HDSL ports will be external. For port index, see product specification.')
prtHdslMode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 7, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("central", 2), ("remote", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtHdslMode.setStatus('mandatory')
if mibBuilder.loadTexts: prtHdslMode.setDescription('This object indicates the HDSL mode.')
prtHdslRptrType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 7, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("none", 2), ("hrpt", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtHdslRptrType.setStatus('mandatory')
if mibBuilder.loadTexts: prtHdslRptrType.setDescription('The Repeater between Near and Far modem. none - no repeater exists between the modems hrpt - HRPT repeater exists between the modems.')
prtT3E3CnfgTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 8, 1), )
if mibBuilder.loadTexts: prtT3E3CnfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: prtT3E3CnfgTable.setDescription('T3/E3 port configuration table.')
prtT3E3CnfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 8, 1, 1), ).setIndexNames((0, "DACS-MIB", "prtT3E3CnfgIdx"), (0, "DACS-MIB", "prtT3E3PrtIdx"))
if mibBuilder.loadTexts: prtT3E3CnfgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: prtT3E3CnfgEntry.setDescription(' An entry in the T3/E3 port configuration table.')
prtT3E3CnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 8, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtT3E3CnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtT3E3CnfgIdx.setDescription('This attribute indicates the Idx of the Config being accessed. Idx of 255 relates to the Temporary (Scratch) Config. Write operations can be performed only on the Temp Config.')
prtT3E3PrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 8, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtT3E3PrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: prtT3E3PrtIdx.setDescription('This attribute indicates a unique port number. The same numbering as for prtGenPrtIdx. The valid port number depends on the IO slot no., the installed card type and the port type: outside, inside. * The external ports convention used will be (for DXC): - first two digits will be: (IO slot number+10) - last one/two digits will be the port number within the card, in odd numbers: port1 = 1 port2 = 3 port3 = 5 etc... Example: port2 of IO slot 11 will be: 213 .')
prtT3E3Slt = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 8, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 255))).clone(namedValues=NamedValues(("clA", 3), ("clB", 4), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("io13", 17), ("io14", 18), ("io15", 19), ("standAlone", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtT3E3Slt.setStatus('mandatory')
if mibBuilder.loadTexts: prtT3E3Slt.setDescription('This attribute indicates a unique number to identify the slot where the card is inserted in. When the unit is stand-alone, this object is not applicable and 255 will be used.')
prtT3E3LineLength = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 8, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("len0p450ft", 2), ("len451p900ft", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtT3E3LineLength.setStatus('mandatory')
if mibBuilder.loadTexts: prtT3E3LineLength.setDescription('This object is the length of the ds3 line in feet. It provides information for line build out circuitry if it exists and can use this object to adjust the line build out. len0p450ft = 0 - 450 feet len451p900ft = 451 - 900 feet.')
prtT3E3InbandMng = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 3, 8, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("notApplicable", 1), ("off", 2), ("cBit", 3), ("cBitTxRxMng", 4), ("cBitTx", 5), ("cBitTxMng", 6), ("m13", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtT3E3InbandMng.setStatus('mandatory')
if mibBuilder.loadTexts: prtT3E3InbandMng.setDescription('A unique number to identify the Frame Type over the link.')
cmprTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 4, 1), )
if mibBuilder.loadTexts: cmprTable.setStatus('mandatory')
if mibBuilder.loadTexts: cmprTable.setDescription('')
cmprEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 4, 1, 1), ).setIndexNames((0, "DACS-MIB", "cmprTypeIdx"), (0, "DACS-MIB", "cmprCnfgIdx"), (0, "DACS-MIB", "cmprVersion"), (0, "DACS-MIB", "cmprSltIdx"), (0, "DACS-MIB", "cmprPrtIdx"))
if mibBuilder.loadTexts: cmprEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cmprEntry.setDescription('')
cmprTypeIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 4, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmprTypeIdx.setStatus('mandatory')
if mibBuilder.loadTexts: cmprTypeIdx.setDescription('This object indicates the Type of the Compressed data referred (which table, which level, etc). The type is a code according to a convention between agent and NMS.')
cmprCnfgIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 4, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmprCnfgIdx.setStatus('mandatory')
if mibBuilder.loadTexts: cmprCnfgIdx.setDescription('This object indicates the configuration number the Compressed information relates to.')
cmprVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 4, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmprVersion.setStatus('mandatory')
if mibBuilder.loadTexts: cmprVersion.setDescription('This object indicates the version of the internal format of the Compressed data (the version of the convention used).')
cmprSltIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 255))).clone(namedValues=NamedValues(("psA", 1), ("psB", 2), ("clA", 3), ("clB", 4), ("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("io13", 17), ("io14", 18), ("io15", 19), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmprSltIdx.setStatus('mandatory')
if mibBuilder.loadTexts: cmprSltIdx.setDescription('This attribute indicates a unique number of the slot position where the card is inserted. When the unit is stand-alone or this object is not applicable, 255 will be used.')
cmprPrtIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 4, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmprPrtIdx.setStatus('mandatory')
if mibBuilder.loadTexts: cmprPrtIdx.setDescription("This object indicates a unique identifier of the port, the compressed information relates to. For DXC - according to the order in the card of cmprSltIdx: - first two digits will be: (IO slot number+10) - last one/two digits will be the port number within the card in odd or even numbers, as follows: * For the outside/external ports, in odd numbers: port1 = 1 port2 = 3 port3 = 5 etc... Example: port2 of IO slot 11 will be: 213 . * The inside/internal ports, in even numbers: port1 = 2 port2 = 4 port3 = 6 etc... Example: port2 of IO slot 11 will be: 214 . For FCD: see product's specification. If the port number is irrelevant to this parameter (if it is a system/card level alarm) the value will be 9999.")
cmprObj = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 4, 1, 1, 6), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmprObj.setStatus('mandatory')
if mibBuilder.loadTexts: cmprObj.setDescription('This object is the compressed information itself, according to a predefined format, both agent and NMS agreed about.')
mapLinkTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 4, 2), )
if mibBuilder.loadTexts: mapLinkTable.setStatus('mandatory')
if mibBuilder.loadTexts: mapLinkTable.setDescription('')
mapLinkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 4, 2, 1), ).setIndexNames((0, "DACS-MIB", "mapLinkIdx"))
if mibBuilder.loadTexts: mapLinkEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mapLinkEntry.setDescription('')
mapLinkIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 4, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mapLinkIdx.setStatus('mandatory')
if mibBuilder.loadTexts: mapLinkIdx.setDescription('A unique identifier of the link')
mapLinkSlotIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 4, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 255))).clone(namedValues=NamedValues(("io1", 5), ("io2", 6), ("io3", 7), ("io4", 8), ("io5", 9), ("io6", 10), ("io7", 11), ("io8", 12), ("io9", 13), ("io10", 14), ("io11", 15), ("io12", 16), ("io13", 17), ("io14", 18), ("io15", 19), ("standAlone", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mapLinkSlotIdx.setStatus('mandatory')
if mibBuilder.loadTexts: mapLinkSlotIdx.setDescription('This attribute indicates a unique slot position where the module is inserted.')
mapLinkPortIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 4, 2, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mapLinkPortIdx.setStatus('mandatory')
if mibBuilder.loadTexts: mapLinkPortIdx.setDescription('This attribute indicates a unique port number. The valid port number depends on the IO slot no., the installed card type and the port type: outside, inside, SP. In the DXC : - first two digits will be: (IO slot number+10) - last one/two digits will be the port number within the card in odd or even numbers, as follows: * For the outside/external ports, in odd numbers: port1 = 1 port2 = 3 port3 = 5 etc... Example: port2 of IO slot 11 will be: 213 . * The inside/internal ports, in even numbers: port1 = 2 port2 = 4 port3 = 6 etc... Example: port2 of IO slot 11 will be: 214 .')
mapLinkState = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 4, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("down", 2), ("up", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mapLinkState.setStatus('mandatory')
if mibBuilder.loadTexts: mapLinkState.setDescription('This attribute indicates the status of the link between the two muxes')
alrGenTable = MibTable((1, 3, 6, 1, 4, 1, 164, 3, 3, 4, 3), )
if mibBuilder.loadTexts: alrGenTable.setStatus('mandatory')
if mibBuilder.loadTexts: alrGenTable.setDescription('')
alrGenEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 3, 3, 4, 3, 1), ).setIndexNames((0, "DACS-MIB", "alrGenCode"))
if mibBuilder.loadTexts: alrGenEntry.setStatus('mandatory')
if mibBuilder.loadTexts: alrGenEntry.setDescription('')
alrGenCode = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 4, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alrGenCode.setStatus('mandatory')
if mibBuilder.loadTexts: alrGenCode.setDescription('This object is a unique code number, identifying a certain alarm.')
alrGenDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 4, 3, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: alrGenDescription.setStatus('mandatory')
if mibBuilder.loadTexts: alrGenDescription.setDescription('This entry is a unique text description, of the alarm corresponding to the specified code.')
alrGenLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 4, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("system", 2), ("card", 3), ("port", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: alrGenLevel.setStatus('mandatory')
if mibBuilder.loadTexts: alrGenLevel.setDescription('Alarm level.')
alrGenSlotType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 4, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notApplicable", 1), ("ps", 2), ("cl", 3), ("io", 4), ("clAndIo", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: alrGenSlotType.setStatus('mandatory')
if mibBuilder.loadTexts: alrGenSlotType.setDescription('Slot type that the alarm is relevant to. clAndIo - an alarm that is relevant for both CL and IO slots.')
alrGenSeverity = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 4, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4, 5))).clone(namedValues=NamedValues(("notApplicable", 1), ("minor", 4), ("major", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: alrGenSeverity.setStatus('mandatory')
if mibBuilder.loadTexts: alrGenSeverity.setDescription('This object enables the user to select a severity for each alarm. The severity is set per alarm code (same for all slots/ports using this code).')
alrGenDebounce = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 3, 3, 4, 3, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: alrGenDebounce.setStatus('mandatory')
if mibBuilder.loadTexts: alrGenDebounce.setDescription("Debounce time for each alarm code, in seconds. The meaning is, that an alarm will be 'declared' as ON (or OFF), only after it was actually ON/OFF the Debouncing time selected by user. 0 = default debounce selection (each alarm has a default value). 1 = minimum value of seconds for debounce. 255 = mask = the alarm will Never be reported. ")
sanityCheckTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 3, 3) + (0,1)).setObjects(("DACS-MIB", "sysSSanityCheckStatus"), ("DACS-MIB", "sysDbaseDownloadCnfgIdxCmd"))
if mibBuilder.loadTexts: sanityCheckTrap.setDescription('This trap is sent after a data base download attempt. It returns the sanity result status and the configuration no.checked.')
dacsMuxAlarmsTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 3, 3) + (0,2))
if mibBuilder.loadTexts: dacsMuxAlarmsTrap.setDescription('This trap is sent when an alarm occurs.')
mdlConnectTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 3, 3) + (0,3)).setObjects(("DACS-MIB", "mdlSCardType"), ("DACS-MIB", "mdlSActivity"))
if mibBuilder.loadTexts: mdlConnectTrap.setDescription('This trap is sent when a card is removed.')
sysAlrStatusTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 3, 3) + (0,4)).setObjects(("DACS-MIB", "sysSAlrStatusAll"), ("DACS-MIB", "sysSAlrStatus"))
if mibBuilder.loadTexts: sysAlrStatusTrap.setDescription('This trap is sent upon any change in the value of any of the variables.')
sysStatusChangedTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 3, 3) + (0,5)).setObjects(("DACS-MIB", "agnLed"))
if mibBuilder.loadTexts: sysStatusChangedTrap.setDescription('This trap is sent when Leds status is changed.')
cnfgUpdateTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 3, 3) + (0,6))
if mibBuilder.loadTexts: cnfgUpdateTrap.setDescription('This trap is sent upon change of the active Configuration DB.')
mibBuilder.exportSymbols("DACS-MIB", agnCSaveNetCnfgIdxCmd=agnCSaveNetCnfgIdxCmd, agnCFlipCnfgIdx=agnCFlipCnfgIdx, prtExHsfConnect=prtExHsfConnect, prtIn7p8VcPbxOos=prtIn7p8VcPbxOos, prtFrPlusCnfgTable=prtFrPlusCnfgTable, prtExPhPlDlciIConSlt=prtExPhPlDlciIConSlt, agnSAlrIdx=agnSAlrIdx, mdlCmprVersion=mdlCmprVersion, prtExTsSltIdx=prtExTsSltIdx, prtExPhPlTc=prtExPhPlTc, prtExPVc4DlciSltIdx=prtExPVc4DlciSltIdx, prtExPh1MlInbandMng=prtExPh1MlInbandMng, prtExPhPlClkMode=prtExPhPlClkMode, sysSRdnFlipTable=sysSRdnFlipTable, cnfgUpdateTrap=cnfgUpdateTrap, prtExVcPbxFrame=prtExVcPbxFrame, mapLinkTable=mapLinkTable, prtSupervisoryDSR=prtSupervisoryDSR, sysSEditBy=sysSEditBy, radSAHEMX=radSAHEMX, prtExLs6Cts=prtExLs6Cts, prtDimCnfgIdx=prtDimCnfgIdx, prtHsrCnfg=prtHsrCnfg, prtExClCnfgEntry=prtExClCnfgEntry, radSysEth=radSysEth, agnCmprObj=agnCmprObj, prtExPh1MlTsIConPrt=prtExPh1MlTsIConPrt, agnSActiveCnfg=agnSActiveCnfg, prtInPh1MlSegment=prtInPh1MlSegment, trapVal=trapVal, prtExPh1MlTsPrtIdx=prtExPh1MlTsPrtIdx, agnXCmprObj=agnXCmprObj, prtIn1p6VcPbxConnect=prtIn1p6VcPbxConnect, prtExHsrCnfgEntry=prtExHsrCnfgEntry, prtInMbeCnfgIdx=prtInMbeCnfgIdx, agnCNetDelay=agnCNetDelay, prtExHsiActType=prtExHsiActType, prtDestDimIdx=prtDestDimIdx, sysCRdnRecTime=sysCRdnRecTime, mdlSCardType=mdlSCardType, mdlCNoOfIntPrt=mdlCNoOfIntPrt, radETS4=radETS4, radStarSwitchATM155=radStarSwitchATM155, radMBE1=radMBE1, prtExPhPlDlciIConDlci=prtExPhPlDlciIConDlci, prtFrStatisInvIdx=prtFrStatisInvIdx, sysSRdnFlipEntry=sysSRdnFlipEntry, fileNameWithinProduct=fileNameWithinProduct, agnCnfgUpdDate=agnCnfgUpdDate, pLinkPrioNu=pLinkPrioNu, prtFrStatis=prtFrStatis, prtExPh1MlPrtIdx=prtExPh1MlPrtIdx, prtInMbeConnect=prtInMbeConnect, mdlSInstEntry=mdlSInstEntry, prtIn1p6VcPbxPabxTs=prtIn1p6VcPbxPabxTs, prtIsdnDirectoryRowStatus=prtIsdnDirectoryRowStatus, ethMode=ethMode, trapTimeSinceOccurrence=trapTimeSinceOccurrence, radTRE8=radTRE8, prtExVc2Connect=prtExVc2Connect, alrGenSlotType=alrGenSlotType, agnCClkCnfgIdx=agnCClkCnfgIdx, prtCrStatisInvIdx=prtCrStatisInvIdx, cmprMdlGen=cmprMdlGen, mdlSAlrCounter=mdlSAlrCounter, prtSExHsfInterfaceTyp=prtSExHsfInterfaceTyp, prtInTreCnfgEntry=prtInTreCnfgEntry, sysSErrIdx=sysSErrIdx, prtAgendaBehaviourCnfgIdx=prtAgendaBehaviourCnfgIdx, prtIn1p6VcPbxCnfgIdx=prtIn1p6VcPbxCnfgIdx, prtIn1p6VcPbxSltIdx=prtIn1p6VcPbxSltIdx, agnCClkSrcPrt=agnCClkSrcPrt, agnCDeleteCnfgIdxCmd=agnCDeleteCnfgIdxCmd, agnTsDirection=agnTsDirection, radAPS24=radAPS24, sysCRoutingOnEth=sysCRoutingOnEth, alarmSeverity=alarmSeverity, prtPhMlCnfgTable=prtPhMlCnfgTable, sysSClkSrc=sysSClkSrc, prtInTreConnect=prtInTreConnect, prtExLs2EnvIdx=prtExLs2EnvIdx, prtFrRxBcViol=prtFrRxBcViol, linkSelectorRevert=linkSelectorRevert, prtExLs2Connect=prtExLs2Connect, prtSAlrPrtIdx=prtSAlrPrtIdx, prtIsdnBasicRateLineTopology=prtIsdnBasicRateLineTopology, mdlCmprObj=mdlCmprObj, prtMl4Oos=prtMl4Oos, prtSActiveStatus=prtSActiveStatus, prtExPVc4Oos=prtExPVc4Oos, prtInHsiCnfgEntry=prtInHsiCnfgEntry, prtInVc3Rate=prtInVc3Rate, agnCFlipActive=agnCFlipActive, prtDimTxMode=prtDimTxMode, prtLogicalCnfgTable=prtLogicalCnfgTable, prtExHsiSltIdx=prtExHsiSltIdx, prtControlCnfg=prtControlCnfg, cmprObj=cmprObj, prtInMbeCnfgTable=prtInMbeCnfgTable, radDXC30=radDXC30, radRRFTBDAS=radRRFTBDAS, prtSInstIfIndex=prtSInstIfIndex, prtExVc3PrtIdx=prtExVc3PrtIdx, radFEB4DAS=radFEB4DAS, prtT1E1LineCode=prtT1E1LineCode, prtExVcPbxTransparent=prtExVcPbxTransparent, prtExHs4MfClkSrcPrt=prtExHs4MfClkSrcPrt, radEPR8T=radEPR8T, prtMl4Cnfg=prtMl4Cnfg, prtInPh1MlCnfgEntry=prtInPh1MlCnfgEntry, prtSAlrTable=prtSAlrTable, radWan=radWan, prtIn7p8VcPbxRate=prtIn7p8VcPbxRate, prtIsdnEndpointPrtIdx=prtIsdnEndpointPrtIdx, prtFrRxDcrdCongDeFr=prtFrRxDcrdCongDeFr, prtAlrMaskTable=prtAlrMaskTable, prtExVc3ReceiveGain=prtExVc3ReceiveGain, mdlSAlrTable=mdlSAlrTable, prtCnfgAgendaTo=prtCnfgAgendaTo, prtExPh1MlIdleCode=prtExPh1MlIdleCode, prtExMbeCnfgEntry=prtExMbeCnfgEntry, prtExLs6VEchoCanceler=prtExLs6VEchoCanceler, prtPhMlSatBuffer=prtPhMlSatBuffer, radFcdW=radFcdW, prtExLs2CnfgEntry=prtExLs2CnfgEntry, physicalConnector=physicalConnector, prtExPhPlFlowControl=prtExPhPlFlowControl, alrGenCode=alrGenCode, radMLBT=radMLBT, agnVoiceSwConfRtDigits=agnVoiceSwConfRtDigits, prtExPhPlErrorsThreshold=prtExPhPlErrorsThreshold, prtExPhPlModemPrtIdx=prtExPhPlModemPrtIdx, prtT1E1PrtIdx=prtT1E1PrtIdx, prtExPhPlPvcCreateMsg=prtExPhPlPvcCreateMsg, prtExLs6VCnfgIdx=prtExLs6VCnfgIdx, agnFlipDb=agnFlipDb, prtGenAlrMaskAll=prtGenAlrMaskAll, mapLinkSlotIdx=mapLinkSlotIdx, agnVoiceSwConfHGEntry=agnVoiceSwConfHGEntry, prtIsdnSimultaneousCall=prtIsdnSimultaneousCall, prtT1E1CnfgEntry=prtT1E1CnfgEntry, prtExHs4TsIConPrt=prtExHs4TsIConPrt, prtExVc3EchoCanceler=prtExVc3EchoCanceler, prtExVcPbxTsPrtIdx=prtExVcPbxTsPrtIdx, prtInVc3LinkTo=prtInVc3LinkTo, prtIsdnDirectoryTable=prtIsdnDirectoryTable, radAtmCsuDsu=radAtmCsuDsu, agnCNetGoCmd=agnCNetGoCmd, radHtuE1Sa=radHtuE1Sa, radAPS16=radAPS16, prtExVc2R2Delay=prtExVc2R2Delay, prtInLs2CnfgTable=prtInLs2CnfgTable, prtExVc2Oos=prtExVc2Oos, prtExPhPlHRate=prtExPhPlHRate, prtExVcPbxTsSltIdx=prtExVcPbxTsSltIdx, prtSpActCallOut=prtSpActCallOut, prtPerfSES=prtPerfSES, sysSaSwchStatus=sysSaSwchStatus, agnListDecoding=agnListDecoding, prtExPhPlProtDelayLevel=prtExPhPlProtDelayLevel, prtExPhPlFullRptPeriod=prtExPhPlFullRptPeriod, muxHub=muxHub, prtSupervisoryParity=prtSupervisoryParity, prtSAlarmPrtIdx=prtSAlarmPrtIdx, systemResetAllStatsCmd=systemResetAllStatsCmd, mdlSMaskedAlrStat=mdlSMaskedAlrStat, prtExPh1MlTdmTrunk=prtExPh1MlTdmTrunk, agnSTstStatAll=agnSTstStatAll, prtDlciRxDeFrames=prtDlciRxDeFrames, prtExVcPbxTransSignalTs=prtExVcPbxTransSignalTs, chassTotalNoOfMlSlt=chassTotalNoOfMlSlt, radHcd4Sa=radHcd4Sa, sysDclCopyDbCmd=sysDclCopyDbCmd, prtExTsSplitTable=prtExTsSplitTable, prtBertInjectSingleErrCmd=prtBertInjectSingleErrCmd, prtFrStatisTable=prtFrStatisTable, agnWanGen=agnWanGen, agnSCnfgEntry=agnSCnfgEntry, radFcdT1M=radFcdT1M, mdlSClearAlrCmd=mdlSClearAlrCmd, agnCnfgUpdMnger=agnCnfgUpdMnger, prtInTreCnfgIdx=prtInTreCnfgIdx, prtParam=prtParam, prtTestIdx=prtTestIdx, prtT1FdlMsgFdlTxRx=prtT1FdlMsgFdlTxRx, prtIsdnEndpointSpid=prtIsdnEndpointSpid, agnCLoadCnfgIdxCmd=agnCLoadCnfgIdxCmd, alarmsTrap=alarmsTrap, prtT1E1InbandMngRoutProt=prtT1E1InbandMngRoutProt, mdlSTstStatusAll=mdlSTstStatusAll, radETS4fddiSAS=radETS4fddiSAS, fileTransfer=fileTransfer, prtExVcPbxSignalOper=prtExVcPbxSignalOper, radHtuE1=radHtuE1, sysSActiveCnfg=sysSActiveCnfg, radOptimuxXLT1=radOptimuxXLT1, prtDlciCmprObj=prtDlciCmprObj, prtExVc3Rate=prtExVc3Rate, prtSpRate=prtSpRate, prtInPh1MlFlowControl=prtInPh1MlFlowControl, prtExPh1MlTsSltIdx=prtExPh1MlTsSltIdx, agnTrapValue=agnTrapValue, prtExPVc4DlciTable=prtExPVc4DlciTable, prtExHs4MfClkSrcSlt=prtExHs4MfClkSrcSlt, mdlSAlrStatus=mdlSAlrStatus, prtExClRate=prtExClRate, prtExTreCnfgEntry=prtExTreCnfgEntry, prtT1FdlMsgPrtIdx=prtT1FdlMsgPrtIdx, radSysPS=radSysPS, prtExPh1MlRedundPort=prtExPh1MlRedundPort, prtExPh1MlCnfgEntry=prtExPh1MlCnfgEntry, prtFrTxMngFrames=prtFrTxMngFrames, prtExVcPbxSltIdx=prtExVcPbxSltIdx, prtCfgParamIdx=prtCfgParamIdx, agnDlciStatus=agnDlciStatus, prtExHsrDataBits=prtExHsrDataBits, prtSExHsfStatEntry=prtSExHsfStatEntry, prtExPVc4DlciTxBc=prtExPVc4DlciTxBc, prtExPVc4DlciRxBc=prtExPVc4DlciRxBc, prtExHsrCnfgIdx=prtExHsrCnfgIdx, tftpStatusChangeTrap=tftpStatusChangeTrap, mdlCSlotIdx=mdlCSlotIdx, prtInMbeCnfgEntry=prtInMbeCnfgEntry, agnSErrListTable=agnSErrListTable, mdlSAlrIdx=mdlSAlrIdx, agnSystemDlci=agnSystemDlci, radImx6L=radImx6L, prtExPhPlLXon=prtExPhPlLXon, prtAcmCnfg=prtAcmCnfg, sysCRdnPrimeSlot=sysCRdnPrimeSlot, mdlPbxFraSignaling=mdlPbxFraSignaling, agnAlarmsCmprAlarmIdx=agnAlarmsCmprAlarmIdx, prtCrTxDataCells=prtCrTxDataCells, prtExPVc4DlciStatus=prtExPVc4DlciStatus, sysBufferAlrClearCmd=sysBufferAlrClearCmd, prtExPh1MlTsIConTs=prtExPh1MlTsIConTs, agnVoiceSwConfHGIdx=agnVoiceSwConfHGIdx, agnt=agnt, prtFrTxTotalFrames=prtFrTxTotalFrames, mdlAlrMaskSltIdx=mdlAlrMaskSltIdx, cmprEntry=cmprEntry, prtIn1p6VcPbxPrtIdx=prtIn1p6VcPbxPrtIdx, prtGenTsPrtIdx=prtGenTsPrtIdx, agnSCmprErrListEntry=agnSCmprErrListEntry, cmprTable=cmprTable, prtInLs6RemoteType=prtInLs6RemoteType, sysDbase=sysDbase, sysSAlrEntry=sysSAlrEntry, mdlSTable=mdlSTable, alrBufDescription=alrBufDescription, prtExHs4LineLen=prtExHs4LineLen, sysCRdnMode=sysCRdnMode, prtInLs6Rate=prtInLs6Rate, radSysRtr=radSysRtr)
mibBuilder.exportSymbols("DACS-MIB", prtExHsrDcdDsr=prtExHsrDcdDsr, systemPsType=systemPsType, mdlPsIdx=mdlPsIdx, prtVc2CnfgIdx=prtVc2CnfgIdx, prtInHsiConcentratedTo=prtInHsiConcentratedTo, sysCnfgTable=sysCnfgTable, agnCFlipNetEventActive=agnCFlipNetEventActive, prtExTsCnfgIdx=prtExTsCnfgIdx, prtExTreLanRate=prtExTreLanRate, sysSRdnFlipTableClearCmd=sysSRdnFlipTableClearCmd, prtExLs6VSltIdx=prtExLs6VSltIdx, prtHdslRptrType=prtHdslRptrType, prtGenTestRunning=prtGenTestRunning, agnListDecodingAcmRelayPrt=agnListDecodingAcmRelayPrt, fileTransferToSubSystems=fileTransferToSubSystems, prtMux=prtMux, radVOIP=radVOIP, systemClearTablesCmd=systemClearTablesCmd, agnListDecodingAcmRelaySlt=agnListDecodingAcmRelaySlt, radSPS12=radSPS12, radSPS2=radSPS2, mdlAlarmMask=mdlAlarmMask, prtSAlarmCode=prtSAlarmCode, prtExTsPrtIdx=prtExTsPrtIdx, prtExLs2SltIdx=prtExLs2SltIdx, sysSAlrIdx=sysSAlrIdx, radEP4FL=radEP4FL, agnMonitorModeCmd=agnMonitorModeCmd, mdlAlrState=mdlAlrState, mdlAlarmsCmprAlarmSlot=mdlAlarmsCmprAlarmSlot, radEP4TFL=radEP4TFL, prtIn1p6VcPbxRate=prtIn1p6VcPbxRate, prtGenType=prtGenType, prtExVcPbxTsMode=prtExVcPbxTsMode, prtMl4VoiceOos=prtMl4VoiceOos, radStarSwitchATM25=radStarSwitchATM25, prtHsfPrtIdx=prtHsfPrtIdx, prtExVcPbxTsEntry=prtExVcPbxTsEntry, prtGenCnfgLinkToSlot=prtGenCnfgLinkToSlot, agnSigProfileTable=agnSigProfileTable, prtExPhPlDlciPriority=prtExPhPlDlciPriority, radRingMonitor=radRingMonitor, mdlSAlrSeverity=mdlSAlrSeverity, prtInLs2PrtIdx=prtInLs2PrtIdx, prtFrTimeElapsed=prtFrTimeElapsed, prtSupervisoryDataBits=prtSupervisoryDataBits, agnDlciLPrtIdx=agnDlciLPrtIdx, prtInPh1MlSltType=prtInPh1MlSltType, prtInPh1MlRate=prtInPh1MlRate, radOptimux4E1=radOptimux4E1, prtT3E3LineLength=prtT3E3LineLength, radKM2100=radKM2100, mdlCPrgCardType=mdlCPrgCardType, prtExClParity=prtExClParity, prtExVc2Encoding=prtExVc2Encoding, prtFrRxBeViol=prtFrRxBeViol, prtExHs4CnfgTable=prtExHs4CnfgTable, sysSAlrStatus=sysSAlrStatus, agnAlarmsCmprTable=agnAlarmsCmprTable, radImx4E1=radImx4E1, prtGenCnfgPortId=prtGenCnfgPortId, agnAlarmsCmprVersion=agnAlarmsCmprVersion, sysSAlrTable=sysSAlrTable, prtSpDialMode=prtSpDialMode, prtExHsrRtsDtr=prtExHsrRtsDtr, tftpRetryTimeOut=tftpRetryTimeOut, prtHSCTS=prtHSCTS, prtCmprTable=prtCmprTable, prtPhPlCnfg=prtPhPlCnfg, agnCSaveNetFlipDbCmd=agnCSaveNetFlipDbCmd, prtPhMlConnect=prtPhMlConnect, agnDlciHIdx=agnDlciHIdx, prtGenIfIndex=prtGenIfIndex, prtHsfCnfgEntry=prtHsfCnfgEntry, prtExLs2CnfgIdx=prtExLs2CnfgIdx, mdlPsTestResult=mdlPsTestResult, radImx2=radImx2, radTinyRouter=radTinyRouter, radTMA=radTMA, prtSAlrCodeDescription=prtSAlrCodeDescription, prtExVc2TransGain=prtExVc2TransGain, systemReset=systemReset, prtInTreRate=prtInTreRate, prtCfgParamOperatedMl=prtCfgParamOperatedMl, prtCnfgAgendaFrom=prtCnfgAgendaFrom, radFTC1UDP=radFTC1UDP, prtInHsiRate=prtInHsiRate, prtMl4CnfgEntry=prtMl4CnfgEntry, prtCrTimeElapsed=prtCrTimeElapsed, sysCnfgEntry=sysCnfgEntry, prtPerfPeriodRef=prtPerfPeriodRef, prtSupervisoryInterface=prtSupervisoryInterface, prtExPVc4SltIdx=prtExPVc4SltIdx, prtSpCnfgEntry=prtSpCnfgEntry, agnDlciCnfgIdx=agnDlciCnfgIdx, prtFrTxBcViol=prtFrTxBcViol, prtExPh1MlTsExt=prtExPh1MlTsExt, prtExVcPbxTsTable=prtExVcPbxTsTable, cnfgFlipTrap=cnfgFlipTrap, agnCNetEventsBcast=agnCNetEventsBcast, agnDlciRxBe=agnDlciRxBe, mdlPbxFraTSGroupAss=mdlPbxFraTSGroupAss, prtI=prtI, prtExPhPlDlciTxBe=prtExPhPlDlciTxBe, systemPort=systemPort, prtCnfgAgendaSltIdx=prtCnfgAgendaSltIdx, prtIsdnNumOfAbstractTerm=prtIsdnNumOfAbstractTerm, agnCFlipNetEventEndTime=agnCFlipNetEventEndTime, prtInPh1MlDlciIConPrt=prtInPh1MlDlciIConPrt, prtHSRate=prtHSRate, prtFrRxDeFrames=prtFrRxDeFrames, mdlClLastFlipCause=mdlClLastFlipCause, prtDlciTxDcrdCongAllFr=prtDlciTxDcrdCongAllFr, prtPhMlDialProcess=prtPhMlDialProcess, pLinkVRate=pLinkVRate, trapEntry=trapEntry, prtDest=prtDest, prtPerfBBE=prtPerfBBE, prtTestInitiator=prtTestInitiator, prtInPh1MlDlciTxBc=prtInPh1MlDlciTxBc, radSTC2=radSTC2, agnTsSltIdx=agnTsSltIdx, prtBertSyncStatus=prtBertSyncStatus, prtExPhPlConnect=prtExPhPlConnect, prtDlciStatis=prtDlciStatis, agnHwVersion=agnHwVersion, prtExPh1MlLineType=prtExPh1MlLineType, prtInPh1MlConnect=prtInPh1MlConnect, prtExPhPlCongLevel=prtExPhPlCongLevel, agnTsCmprCnfgIdx=agnTsCmprCnfgIdx, mdlSAlrStatusAll=mdlSAlrStatusAll, prtCrTxTotalCells=prtCrTxTotalCells, prtInPh1MlPrtIdx=prtInPh1MlPrtIdx, prtSpAltNum=prtSpAltNum, prtExHsrRateAdapt=prtExHsrRateAdapt, radRRMLBT=radRRMLBT, prtInPh1MlErrorsThreshold=prtInPh1MlErrorsThreshold, radFcdT1=radFcdT1, alrBuffGen=alrBuffGen, radRADring=radRADring, mdlAlrEntry=mdlAlrEntry, prtExLs6VIfType=prtExLs6VIfType, prtPerfIdx=prtPerfIdx, alrBufTable=alrBufTable, agnVoiceSwConfRtPort=agnVoiceSwConfRtPort, prtT1E1BpvMax=prtT1E1BpvMax, radSAHTM=radSAHTM, prtExPhPlFrameSeparator=prtExPhPlFrameSeparator, cmprTypeIdx=cmprTypeIdx, prtExTsIConSlot=prtExTsIConSlot, mdlAlarmsCmprEntry=mdlAlarmsCmprEntry, prtExClUsage=prtExClUsage, prtInMbePrtIdx=prtInMbePrtIdx, radEP4T2FL=radEP4T2FL, genDacsMux=genDacsMux, agnVoiceSwConfHGConnect=agnVoiceSwConfHGConnect, sysCClkSrcPrt=sysCClkSrcPrt, prtIsdnDirectoryRemoteAddr=prtIsdnDirectoryRemoteAddr, prtExPVc4DlciEntry=prtExPVc4DlciEntry, prtExLs6CnfgTable=prtExLs6CnfgTable, agnSigProfileEntry=agnSigProfileEntry, radSAHEMU=radSAHEMU, prtExPVc4DlciValid=prtExPVc4DlciValid, prtAcmCnfgIdx=prtAcmCnfgIdx, agnSLastCnfgFlipCause=agnSLastCnfgFlipCause, mdlSAlarmStatusAll=mdlSAlarmStatusAll, prtExPhPlModemCallDelay=prtExPhPlModemCallDelay, alrGenDebounce=alrGenDebounce, prtExPh1MlConnect=prtExPh1MlConnect, chassTotalNoOfPsSlt=chassTotalNoOfPsSlt, prtExHsfCts=prtExHsfCts, prtPerformance=prtPerformance, agnTsBitIdx=agnTsBitIdx, prtDimCnfgTable=prtDimCnfgTable, prtExVc2IfSignaling=prtExVc2IfSignaling, sysBufferAlrEntry=sysBufferAlrEntry, prtIsdnDirectorySltIdx=prtIsdnDirectorySltIdx, radOpt4T1C=radOpt4T1C, prtCrStatisEntry=prtCrStatisEntry, sysSAlrClearCmd=sysSAlrClearCmd, prtExPVc4MaxRate=prtExPVc4MaxRate, radEP4TAUI=radEP4TAUI, prtT1E1FdlMsgEntry=prtT1E1FdlMsgEntry, radPrbiT3=radPrbiT3, prtExHsiLinkTo=prtExHsiLinkTo, agnCFlipEntry=agnCFlipEntry, trapTable=trapTable, agnVoiceSwConfRtDlci=agnVoiceSwConfRtDlci, agnXCmprIdx4=agnXCmprIdx4, prtSpDataBits=prtSpDataBits, alrGenSeverity=alrGenSeverity, chassTotalNoOfIoSlt=chassTotalNoOfIoSlt, agnDlciCmprDlciIdx=agnDlciCmprDlciIdx, agnDlciTable=agnDlciTable, agnSMaskedAlrStat=agnSMaskedAlrStat, agnCFlipDiscardDe=agnCFlipDiscardDe, prtMl4SltIdx=prtMl4SltIdx, radOptimuxXLE1=radOptimuxXLE1, prtSAlarmInvert=prtSAlarmInvert, prtIn7p8VcPbxCnfgTable=prtIn7p8VcPbxCnfgTable, prtT1E1Sync=prtT1E1Sync, tftpError=tftpError, radMP2104=radMP2104, prtExPVc4ExtensionNumber=prtExPVc4ExtensionNumber, sysSAlrDataUpdateCmd=sysSAlrDataUpdateCmd, prtLogicalCnfgEntry=prtLogicalCnfgEntry, sysCClkSrcIdx=sysCClkSrcIdx, prtDimMng=prtDimMng, agnSAlrStatusAll=agnSAlrStatusAll, prtCnfgAgendaDayIdx=prtCnfgAgendaDayIdx, prtSInterfaceType=prtSInterfaceType, prtHdslIdx=prtHdslIdx, prtGenCnfgTable=prtGenCnfgTable, prtExPhPlLXoff=prtExPhPlLXoff, agnCnfgAlrPort=agnCnfgAlrPort, prtSpDcdDelay=prtSpDcdDelay, prtExPVc4Connect=prtExPVc4Connect, agnSDateCmd=agnSDateCmd, ethIfEntry=ethIfEntry, prtFrPlusSltIdx=prtFrPlusSltIdx, sysDbaseFlipIdx=sysDbaseFlipIdx, prtExPh1MlInbandMngRate=prtExPh1MlInbandMngRate, prtExPh1MlLineLen=prtExPh1MlLineLen, prtExTsSplitEntry=prtExTsSplitEntry, prtSAlrInvert=prtSAlrInvert, prtExPhPlSltIdx=prtExPhPlSltIdx, prtExVcPbxConnect=prtExVcPbxConnect, portOptWaveLength=portOptWaveLength, agnDlciCmprEntry=agnDlciCmprEntry, linkSelectorCnfgTable=linkSelectorCnfgTable, prtAcmCnfgEntry=prtAcmCnfgEntry, prtAlrMaskEntry=prtAlrMaskEntry, prtICnfgIdx=prtICnfgIdx, prtExVc2CasStd=prtExVc2CasStd, radEPR4FL=radEPR4FL, cnfgPrtGen=cnfgPrtGen, agnSDateFormat=agnSDateFormat, prtExPVc4Tc=prtExPVc4Tc, prtBertESs=prtBertESs, alrBufIdx=alrBufIdx, agnCnfgAlrInvert=agnCnfgAlrInvert, prtExPh1MlRedundSlot=prtExPh1MlRedundSlot, prtCmprVersion=prtCmprVersion, sysCRdnOnline=sysCRdnOnline, mdlCNoOfExtPrt=mdlCNoOfExtPrt, prtSTstCmd=prtSTstCmd, radMBE8D=radMBE8D, agnCnfgDataEntry=agnCnfgDataEntry, prtSMaskedAlrStat=prtSMaskedAlrStat, cmprCnfgIdx=cmprCnfgIdx, prtExHsfClkPolarity=prtExHsfClkPolarity, agnSigProfile=agnSigProfile, agnSTimeCmd=agnSTimeCmd, sysBufferAlrTime=sysBufferAlrTime)
mibBuilder.exportSymbols("DACS-MIB", dacsMuxAlarmsTrap=dacsMuxAlarmsTrap, prtIsdnDirectoryRemoteSubAddr=prtIsdnDirectoryRemoteSubAddr, prtInPh1MlFrWindowSize=prtInPh1MlFrWindowSize, radRBHE=radRBHE, systemPsEntry=systemPsEntry, sysDclCopyDbIdx=sysDclCopyDbIdx, linkSelectorPLinkTable=linkSelectorPLinkTable, radPrbiE3=radPrbiE3, prtIsdnFilter=prtIsdnFilter, sysSRdnFlipCause=sysSRdnFlipCause, prtHS=prtHS, prtInMbeLinkTo=prtInMbeLinkTo, agnCmprEntry=agnCmprEntry, radAPD8=radAPD8, agnSAlrState=agnSAlrState, prtSInstPrtIdx=prtSInstPrtIdx, sysCRdnSecPort=sysCRdnSecPort, prtAcmCnfgTable=prtAcmCnfgTable, agnXCmprIdx3=agnXCmprIdx3, prtIn7p8VcPbxSignalMode=prtIn7p8VcPbxSignalMode, prtAgendaBehaviourOnOff=prtAgendaBehaviourOnOff, radTRE1=radTRE1, prtT1E1VoiceOos=prtT1E1VoiceOos, mngEntry=mngEntry, mdlWanGen=mdlWanGen, prtGenTestDurationEntry=prtGenTestDurationEntry, prtInHsiCnfgIdx=prtInHsiCnfgIdx, prtDlciTxDcrdCongDeFr=prtDlciTxDcrdCongDeFr, prtDacsMux=prtDacsMux, prtExPh1MlRxSensitivity=prtExPh1MlRxSensitivity, prtInTreCnfgTable=prtInTreCnfgTable, prtExVcPbxTsIdx=prtExVcPbxTsIdx, prtSAlarmMask=prtSAlarmMask, agnSClearAlrCmd=agnSClearAlrCmd, prtExClSltIdx=prtExClSltIdx, prtInVc3SltIdx=prtInVc3SltIdx, radHcdE1=radHcdE1, pLinkCnfgIdx=pLinkCnfgIdx, prtAgendaBehaviourPrtIdx=prtAgendaBehaviourPrtIdx, radFEB4FDX=radFEB4FDX, mngIP=mngIP, sysStatusChangedTrap=sysStatusChangedTrap, agnDlciCmprObj=agnDlciCmprObj, radFEC1UDP=radFEC1UDP, sysSRdnFlipSlot=sysSRdnFlipSlot, prtPerfTimeTag=prtPerfTimeTag, agnSigProfileRxTx=agnSigProfileRxTx, chasTotalNoOfSlt=chasTotalNoOfSlt, agnSAlrCode=agnSAlrCode, agnSErrIdx=agnSErrIdx, prtInPh1MlAssociatedExCh=prtInPh1MlAssociatedExCh, prtDlciStatisEntry=prtDlciStatisEntry, mapLinkIdx=mapLinkIdx, prtIn1p6VcPbxCnfgEntry=prtIn1p6VcPbxCnfgEntry, prtExPhPlDlciCnfgIdx=prtExPhPlDlciCnfgIdx, radSTC1=radSTC1, linkSelectorMaxIdleTime=linkSelectorMaxIdleTime, prtT1E1RAI=prtT1E1RAI, agnDlciTxBe=agnDlciTxBe, cmprSltIdx=cmprSltIdx, prtHdsl=prtHdsl, agnCClkSrcIdx=agnCClkSrcIdx, prtIn1p6VcPbxEchoCanceler=prtIn1p6VcPbxEchoCanceler, sysDclCopyDbEntry=sysDclCopyDbEntry, prtT1E1LineLengthMask=prtT1E1LineLengthMask, prtT1E1TS0SaBits=prtT1E1TS0SaBits, radFcdT1A=radFcdT1A, prtExLs2ClkMode=prtExLs2ClkMode, prtPh1MlCnfg=prtPh1MlCnfg, agnCnfgAlarm=agnCnfgAlarm, prtT1E1FdlMsgTable=prtT1E1FdlMsgTable, prtSpCnfgIdx=prtSpCnfgIdx, agnVoiceSwConfRtTable=agnVoiceSwConfRtTable, mdlSAlrEntry=mdlSAlrEntry, sysSRelayState=sysSRelayState, prtVc2SltIdx=prtVc2SltIdx, prtLogicalCnfg=prtLogicalCnfg, radRTED=radRTED, prtExPVc4DlciIConDlci=prtExPVc4DlciIConDlci, radRRMLBTF=radRRMLBTF, mdlClLastFlipDate=mdlClLastFlipDate, prtExVc3SltIdx=prtExVc3SltIdx, prtT1E1CnfgIdx=prtT1E1CnfgIdx, radMX3000=radMX3000, agnSCmprErrVersion=agnSCmprErrVersion, prtT1FdlMsgTable=prtT1FdlMsgTable, prtSInstEntry=prtSInstEntry, sysCurrentAlr=sysCurrentAlr, prtGenTestPrtIdx=prtGenTestPrtIdx, prtExPhPlDlciIdx=prtExPhPlDlciIdx, prtT1E1BpvLastMin=prtT1E1BpvLastMin, prtExPVc4WinkMaxDuration=prtExPVc4WinkMaxDuration, mdlSSltIdx=mdlSSltIdx, prtExHsrPrtIdx=prtExHsrPrtIdx, prtFrTxDcrdCongDeFr=prtFrTxDcrdCongDeFr, prtCfgParam=prtCfgParam, statPrtGen=statPrtGen, prtT1FdlMsgEntry=prtT1FdlMsgEntry, radTRERAS=radTRERAS, alrGenEntry=alrGenEntry, prtExPVc4RxGain=prtExPVc4RxGain, prtDlciTxDeFrames=prtDlciTxDeFrames, prtMl4CGA=prtMl4CGA, prtMl4Service=prtMl4Service, agnDlciCmprCnfgIdx=agnDlciCmprCnfgIdx, prtSAlrStatus=prtSAlrStatus, agnVoiceSwConfZoneId=agnVoiceSwConfZoneId, sysSAlarmMask=sysSAlarmMask, prtFrRxTotalBytes=prtFrRxTotalBytes, prtGenTsCnfgIdx=prtGenTsCnfgIdx, prtSAlrMask=prtSAlrMask, prtSAlrSltIdx=prtSAlrSltIdx, prtHSBertSlt=prtHSBertSlt, prtFrStatisEntry=prtFrStatisEntry, mapLinkPrtIdx=mapLinkPrtIdx, sysDbaseFlipActivation=sysDbaseFlipActivation, mapLinkPortIdx=mapLinkPortIdx, sysSaReadSwch=sysSaReadSwch, prtExPVc4PrtIdx=prtExPVc4PrtIdx, prtBertErrorBits=prtBertErrorBits, prtIn7p8VcPbxLinkTo=prtIn7p8VcPbxLinkTo, prtFrRxFecn=prtFrRxFecn, prtExVc2SeizeAck=prtExVc2SeizeAck, mdlPbxFramerCnfgEntry=mdlPbxFramerCnfgEntry, agnCFlipNetEventsCnfgIdx=agnCFlipNetEventsCnfgIdx, prtT1E1Slt=prtT1E1Slt, prtCrStatisTable=prtCrStatisTable, agnCFlipNetEventOSD=agnCFlipNetEventOSD, prtHSPrtIdx=prtHSPrtIdx, sysCClkSrcEntry=sysCClkSrcEntry, radAce=radAce, agnTsCmprTable=agnTsCmprTable, agnCmprTypIdx=agnCmprTypIdx, prtInPh1MlFullRptPeriod=prtInPh1MlFullRptPeriod, prtMl4CnfgIdx=prtMl4CnfgIdx, prtPhMlSltIdx=prtPhMlSltIdx, sysDclRedundancy=sysDclRedundancy, linkSelectorPLinkEntry=linkSelectorPLinkEntry, prtExHs4TsIConTs=prtExHs4TsIConTs, radMP2100F=radMP2100F, prtAlarmsCmprVersion=prtAlarmsCmprVersion, radSAH16Text=radSAH16Text, prtIsdnDirectoryLocalSubAddr=prtIsdnDirectoryLocalSubAddr, agnTsConSltIdx=agnTsConSltIdx, radAce2002=radAce2002, prtExPhPlModemMaxIdleTime=prtExPhPlModemMaxIdleTime, radSPS3=radSPS3, wanGen=wanGen, prtExPhPlModemSltIdx=prtExPhPlModemSltIdx, mdlCCnfgIdx=mdlCCnfgIdx, prtAlarmsCmprTable=prtAlarmsCmprTable, radSPS9=radSPS9, prtHsfCnfgIdx=prtHsfCnfgIdx, prtSInstSltIdx=prtSInstSltIdx, prtAlrMask=prtAlrMask, radRTEC=radRTEC, prtExVcPbxLinkTo=prtExVcPbxLinkTo, prtIsdnDirectoryRemoteAddr2=prtIsdnDirectoryRemoteAddr2, prtExHs4TsCnfgIdx=prtExHs4TsCnfgIdx, prtCfgParamMlAtoMlBPrio=prtCfgParamMlAtoMlBPrio, prtExHsrCnfgTable=prtExHsrCnfgTable, cnfgMdlGen=cnfgMdlGen, prtGenCnfgLinkToPort=prtGenCnfgLinkToPort, radMBE1D=radMBE1D, prtExLs6Connect=prtExLs6Connect, sysSDateFormat=sysSDateFormat, prtExPhPlModemTimeBtwnCalls=prtExPhPlModemTimeBtwnCalls, radFPS12=radFPS12, sysCRdnHwSwFlip=sysCRdnHwSwFlip, prtGenTsIConPrt=prtGenTsIConPrt, prtExTrePrtIdx=prtExTrePrtIdx, prtCnfgAgendaSesId=prtCnfgAgendaSesId, prtPVc4Cnfg=prtPVc4Cnfg, sysCRdnPrimePort=sysCRdnPrimePort, portIdx=portIdx, prtExHs4TsPrtIdx=prtExHs4TsPrtIdx, radAsmi450R768Sa=radAsmi450R768Sa, sysDbaseSanityCheckCmd=sysDbaseSanityCheckCmd, agnSystemTs=agnSystemTs, agnSigProfileIdx=agnSigProfileIdx, prtInLs2SltIdx=prtInLs2SltIdx, prtDimCnfgEntry=prtDimCnfgEntry, radSAH16Tint=radSAH16Tint, prtPhMlBus=prtPhMlBus, pLinkSltIdx=pLinkSltIdx, prtExPhPlCllmMsg=prtExPhPlCllmMsg, agnCnfgAlrReportType=agnCnfgAlrReportType, prtExHs4PrtIdx=prtExHs4PrtIdx, prtClCnfg=prtClCnfg, sysStatus=sysStatus, prtCnfgAgendaEntry=prtCnfgAgendaEntry, prtExHsrLlbEnable=prtExHsrLlbEnable, radImx64=radImx64, fileServerIP=fileServerIP, prtDlciTxBecn=prtDlciTxBecn, prtInPh1MlMinSeparators=prtInPh1MlMinSeparators, prtSpTable=prtSpTable, prtAlarmsCmprObj=prtAlarmsCmprObj, radRRTRE8=radRRTRE8, sysSAlrClearAllCmd=sysSAlrClearAllCmd, chassTotalNoOfClSlt=chassTotalNoOfClSlt, agnDlciTxBc=agnDlciTxBc, systemSaveAndResetAllStatsCmd=systemSaveAndResetAllStatsCmd, ethIfTable=ethIfTable, prtInPh1MlDlciTable=prtInPh1MlDlciTable, prtHSBertTable=prtHSBertTable, sysDclActiveCl=sysDclActiveCl, prtFrStatisPrtIdx=prtFrStatisPrtIdx, prtAlarmsCmprAlarmSlot=prtAlarmsCmprAlarmSlot, mdlCmprEntry=mdlCmprEntry, prtExLs6VTxGain=prtExLs6VTxGain, prtPerfSaveAndResetCmd=prtPerfSaveAndResetCmd, sysSNoOfSanityCheckErr=sysSNoOfSanityCheckErr, prtSBertTstRslt=prtSBertTstRslt, prtExPhPlDlciRxBe=prtExPhPlDlciRxBe, sysBufferAlr=sysBufferAlr, agnVoiceSwitching=agnVoiceSwitching, prtExLs6DataBits=prtExLs6DataBits, alrGenLevel=alrGenLevel, prtSAlarmEntry=prtSAlarmEntry, prtT1E1FdlMsg=prtT1E1FdlMsg, mapLinkEntry=mapLinkEntry, prtExPh1MlTsCnfgIdx=prtExPh1MlTsCnfgIdx, sysDbaseFlipTime=sysDbaseFlipTime, radWebRanger=radWebRanger, prtHdslMode=prtHdslMode, prtInLs2EnvAssign=prtInLs2EnvAssign, prtDlciRxDcrdCongDeFr=prtDlciRxDcrdCongDeFr, pLinkSlotNu=pLinkSlotNu, prtExVc2OperMode=prtExVc2OperMode, agnDlciHPrtIdx=agnDlciHPrtIdx, prtIsdnCnfgIdx=prtIsdnCnfgIdx, prtPhMlClockMode=prtPhMlClockMode, prtSupervisoryUsage=prtSupervisoryUsage, prtDlciRxDcrdCongAllFr=prtDlciRxDcrdCongAllFr, prtInPh1MlEnqPeriod=prtInPh1MlEnqPeriod, prtGenParamTable=prtGenParamTable, sanityCheckTrap=sanityCheckTrap, agnCnfgUpdTime=agnCnfgUpdTime, radFomiE3=radFomiE3, prtExLs2CnfgTable=prtExLs2CnfgTable, sysCClkCnfgIdx=sysCClkCnfgIdx, mdlCSltIdx=mdlCSltIdx, prtT1E1FdlMode=prtT1E1FdlMode, mapWanGen=mapWanGen, prtIsdnDirectoryLocalSubAddr2=prtIsdnDirectoryLocalSubAddr2, systemTiming=systemTiming, prtExPhPlDlciValid=prtExPhPlDlciValid, prtDlciCmprTable=prtDlciCmprTable, prtTestCmdAndStatus=prtTestCmdAndStatus, radFcdE1A=radFcdE1A, prtTestEntry=prtTestEntry, prtExLs6VOos=prtExLs6VOos, radFEC2UDP=radFEC2UDP)
mibBuilder.exportSymbols("DACS-MIB", mdlSMaskedAlrStatAll=mdlSMaskedAlrStatAll, prtExHs4TsSltIdx=prtExHs4TsSltIdx, radSTC2UDP=radSTC2UDP, agnSAlrCounter=agnSAlrCounter, agnCClkSrcTable=agnCClkSrcTable, sysSInvertedAlr=sysSInvertedAlr, radEPR4TFL=radEPR4TFL, agnAlarmsCmprObj=agnAlarmsCmprObj, prtExPVc4CnfgIdx=prtExPVc4CnfgIdx, prtBertTable=prtBertTable, prtSpRoutProtocol=prtSpRoutProtocol, prtDestConnect=prtDestConnect, prtFrRxMngFrames=prtFrRxMngFrames, prtExVc3Connect=prtExVc3Connect, prtMonTable=prtMonTable, prtDlciTxBeViol=prtDlciTxBeViol, sysSDateCmd=sysSDateCmd, prtCrStatisPrtIdx=prtCrStatisPrtIdx, mdlCNoOfInternPrt=mdlCNoOfInternPrt, prtInHsiConnect=prtInHsiConnect, sysDbaseUploadCnfgIdxCmd=sysDbaseUploadCnfgIdxCmd, prtIsdnDirectoryEntry=prtIsdnDirectoryEntry, prtExHsiCnfgEntry=prtExHsiCnfgEntry, systemDate=systemDate, agnXCmprTable=agnXCmprTable, prtExLs6VConnect=prtExLs6VConnect, prtExVcPbxPrtIdx=prtExVcPbxPrtIdx, prtInLs6PrtIdx=prtInLs6PrtIdx, mdlAlrIdx=mdlAlrIdx, sysCClkSrcTable=sysCClkSrcTable, prtT1E1StatEntry=prtT1E1StatEntry, prtGenCnfgEntry=prtGenCnfgEntry, agnCDefaultCnfgIdxCmd=agnCDefaultCnfgIdxCmd, prtSpNoOfRetries=prtSpNoOfRetries, prtExVc2IfType=prtExVc2IfType, prtExTreCnfgTable=prtExTreCnfgTable, agnCClkSrcEntry=agnCClkSrcEntry, prtExPh1MlLineCode=prtExPh1MlLineCode, prtExVc2TxBitCode=prtExVc2TxBitCode, tftpStatus=tftpStatus, prtIsdnEndpointTeiType=prtIsdnEndpointTeiType, radFomiT3=radFomiT3, mdlDacsMux=mdlDacsMux, prtT3E3CnfgTable=prtT3E3CnfgTable, prtLogicalPrtIdx=prtLogicalPrtIdx, prtInLs2Member=prtInLs2Member, agnCFlipNetEventDayType=agnCFlipNetEventDayType, agnXCmprIdx7=agnXCmprIdx7, prtSupervisoryRate=prtSupervisoryRate, prtLogicalRowStatus=prtLogicalRowStatus, radAce2T=radAce2T, sysSMaxNoOfCnfg=sysSMaxNoOfCnfg, prtSInstPrtType=prtSInstPrtType, prtPerfBlocksPerSec=prtPerfBlocksPerSec, prtBertSyncLoss=prtBertSyncLoss, radMP2100B=radMP2100B, prtInLs2Connect=prtInLs2Connect, prtIn1p6VcPbxCnfgTable=prtIn1p6VcPbxCnfgTable, prtSpPrtIdx=prtSpPrtIdx, prtExPh1MlTsIConSlot=prtExPh1MlTsIConSlot, prtDlciCmprVersion=prtDlciCmprVersion, prtAlr=prtAlr, agnCnfgAlrFilter=agnCnfgAlrFilter, radTrimBrg16=radTrimBrg16, prtDlciCmprEntry=prtDlciCmprEntry, prtExPh1MlRedundRecTime=prtExPh1MlRedundRecTime, prtExPhPlFrWindowSize=prtExPhPlFrWindowSize, prtSpCnfgTable=prtSpCnfgTable, prtExPh1MlClkMode=prtExPh1MlClkMode, radFddi=radFddi, prtInLs2CnfgIdx=prtInLs2CnfgIdx, prtExLs6VRxGain=prtExLs6VRxGain, prtVc2PrtIdx=prtVc2PrtIdx, agnCClkSrcMode=agnCClkSrcMode, radHtu2=radHtu2, agnDlciRoutingProtocol=agnDlciRoutingProtocol, prtLogicalCnfgIdx=prtLogicalCnfgIdx, prtAcmActiveState=prtAcmActiveState, prtExVc3CnfgEntry=prtExVc3CnfgEntry, prtExClRoutingProtocol=prtExClRoutingProtocol, radHtu2Sa=radHtu2Sa, prtExLs2PrtIdx=prtExLs2PrtIdx, prtVc2CnfgTable=prtVc2CnfgTable, agnListDecodingDefState=agnListDecodingDefState, prtIConnect=prtIConnect, linkSelectorCnfgEntry=linkSelectorCnfgEntry, ethBridgingMode=ethBridgingMode, prtSTstDuration=prtSTstDuration, prtExVc3CnfgTable=prtExVc3CnfgTable, radFcdE1M=radFcdE1M, prtExVc2MeterRate=prtExVc2MeterRate, chasTotalNoOfPsSlt=chasTotalNoOfPsSlt, mdlCTable=mdlCTable, prtDlciTxFecn=prtDlciTxFecn, agnDlciEntry=agnDlciEntry, systemPsTable=systemPsTable, prtExPVc4DlciIConSlt=prtExPVc4DlciIConSlt, prtSAlrEntry=prtSAlrEntry, radRTEM=radRTEM, prtExTreSltIdx=prtExTreSltIdx, prtExPhPlDlciTxBc=prtExPhPlDlciTxBc, prtExPh1MlSltIdx=prtExPh1MlSltIdx, prtIsdnDirectoryLocalAddr2=prtIsdnDirectoryLocalAddr2, unknown=unknown, prtExHsrParity=prtExHsrParity, mdlCmprTable=mdlCmprTable, agnCFlipNetEventsTable=agnCFlipNetEventsTable, prtExPhPlDataBits=prtExPhPlDataBits, agnSEditCnfg=agnSEditCnfg, prtCrRxTotalCells=prtCrRxTotalCells, radSEC1UDP=radSEC1UDP, agnVoiceSwConfRtIdx=agnVoiceSwConfRtIdx, prtExLs6VRate=prtExLs6VRate, mdlCmprSltIdx=mdlCmprSltIdx, prtFrPlusPrtIdx=prtFrPlusPrtIdx, prtInVc3CnfgEntry=prtInVc3CnfgEntry, rad=rad, agnCFlipNetEventSlot=agnCFlipNetEventSlot, agnDlciCmprVersion=agnDlciCmprVersion, sysSaHwVersion=sysSaHwVersion, prtT1E1OosCount=prtT1E1OosCount, prtExVc2SigProfile=prtExVc2SigProfile, prtExVcPbxGroup=prtExVcPbxGroup, prtExClDataBits=prtExClDataBits, MacAddress=MacAddress, prtTreCnfg=prtTreCnfg, agnCSanityCheckCmd=agnCSanityCheckCmd, agnSNoOfSanityCheckErr=agnSNoOfSanityCheckErr, prtExVc2CodingLaw=prtExVc2CodingLaw, radFastWay100=radFastWay100, prtExHsiCnfgIdx=prtExHsiCnfgIdx, prtInPh1MlConnectionTyp=prtInPh1MlConnectionTyp, prtMonitoringEnable=prtMonitoringEnable, agnListDecodingTable=agnListDecodingTable, prtT1E1FdlMsgSlt=prtT1E1FdlMsgSlt, mdlSAlrClearAllCmd=mdlSAlrClearAllCmd, ethIfIdx=ethIfIdx, prtDlciSltIdx=prtDlciSltIdx, prtCfgParamMlBtoMlAPrio=prtCfgParamMlBtoMlAPrio, prtCfgParamEntry=prtCfgParamEntry, agnCFlipNetEventIdx=agnCFlipNetEventIdx, prtGenExtInt=prtGenExtInt, prtExPhPlMinSeparators=prtExPhPlMinSeparators, statusChangedTrap=statusChangedTrap, prtExMbeSltIdx=prtExMbeSltIdx, sysSSanityCheckStatus=sysSSanityCheckStatus, radMX30=radMX30, prtCrRxDataCells=prtCrRxDataCells, sysSTestStatus=sysSTestStatus, chasVersion=chasVersion, prtExPhPlProtocol=prtExPhPlProtocol, prtSpUsage=prtSpUsage, prtInLs6CnfgIdx=prtInLs6CnfgIdx, agnSLastCnfgFlipTime=agnSLastCnfgFlipTime, prtCfgParamCnfgIdx=prtCfgParamCnfgIdx, prtInPh1MlDlciPrtIdx=prtInPh1MlDlciPrtIdx, radMBERAS=radMBERAS, prtPhMlCnfgEntry=prtPhMlCnfgEntry, mdlSEntry=mdlSEntry, agnChangeCnt=agnChangeCnt, radSEC1=radSEC1, agnXCmprEntry=agnXCmprEntry, sysAlrStatusTrap=sysAlrStatusTrap, prtExPh1MlTsIdx=prtExPh1MlTsIdx, prtBertPattern=prtBertPattern, prtPhMlRate=prtPhMlRate, prtFrPlusNotSegmentedPriorities=prtFrPlusNotSegmentedPriorities, mdlSClearAllAlrCmd=mdlSClearAllAlrCmd, prtInPh1MlMaxIdleTime=prtInPh1MlMaxIdleTime, prtMonCnfgIdx=prtMonCnfgIdx, prtSExHsfSltIdx=prtSExHsfSltIdx, radFcdIP=radFcdIP, mdlCl=mdlCl, radFTBSAS=radFTBSAS, mdlCPrgEntry=mdlCPrgEntry, prtExHsfOperMode=prtExHsfOperMode, agnSEntryIdx=agnSEntryIdx, prtT1E1CnfgTable=prtT1E1CnfgTable, prtT1E1Multiplier=prtT1E1Multiplier, radMP2200B=radMP2200B, prtSParamStatus=prtSParamStatus, prtExTsIConPrt=prtExTsIConPrt, sysDclCnfgIdx=sysDclCnfgIdx, prtTestTable=prtTestTable, diverseIfWanGen=diverseIfWanGen, mapLinkSltIdx=mapLinkSltIdx, prtBertPrtIdx=prtBertPrtIdx, agnListDecodingEntry=agnListDecodingEntry, prtCrStatisSltIdx=prtCrStatisSltIdx, prtT1E1InbandMngRate=prtT1E1InbandMngRate, mdlCEntry=mdlCEntry, prtIsdnCnfg=prtIsdnCnfg, agnCnfgAlrFilterWindow=agnCnfgAlrFilterWindow, radFcdE1=radFcdE1, prtInPh1MlClockEncoding=prtInPh1MlClockEncoding, mngTrapIpTable=mngTrapIpTable, prtInLs6SltIdx=prtInLs6SltIdx, prtInVc3Connect=prtInVc3Connect, agnCFlipNetEventNo=agnCFlipNetEventNo, mdlPbxFramerCnfg=mdlPbxFramerCnfg, agnVoiceSwConfRtDbId=agnVoiceSwConfRtDbId, cmprAgnGen=cmprAgnGen, mdlSAlarmStatus=mdlSAlarmStatus, agnCFlipLogicalExp=agnCFlipLogicalExp, agnTsTable=agnTsTable, prtIn7p8VcPbxPrtIdx=prtIn7p8VcPbxPrtIdx, prtExLs6CtrlSignal=prtExLs6CtrlSignal, radStkHub=radStkHub, prtInPh1MlDlciRxBc=prtInPh1MlDlciRxBc, prtT1E1OosSignal=prtT1E1OosSignal, prtSpAltNumMode=prtSpAltNumMode, prtPhMlCnfgIdx=prtPhMlCnfgIdx, prtMbeCnfg=prtMbeCnfg, radAce101=radAce101, sysSErrDescription=sysSErrDescription, prtIsdnDirectoryPrtNu=prtIsdnDirectoryPrtNu, prtHSParamEntry=prtHSParamEntry, agnCnfgIdx=agnCnfgIdx, prtInPh1MlDlciTxBe=prtInPh1MlDlciTxBe, agnTsRowStatus=agnTsRowStatus, prtLogicalSltIdx=prtLogicalSltIdx, agnTestStatus=agnTestStatus, prtT1E1DataOos=prtT1E1DataOos, prtCfgParamInbandLoopDetection=prtCfgParamInbandLoopDetection, prtIsdnCnfgEntry=prtIsdnCnfgEntry, alarmState=alarmState, prtSAlrState=prtSAlrState, prtExHs4IdleCode=prtExHs4IdleCode, chassTotalNoOfSlt=chassTotalNoOfSlt, agnCnfgAlrCode=agnCnfgAlrCode, chasTotalNoOfIoSlt=chasTotalNoOfIoSlt, prtSAlarmIdx=prtSAlarmIdx, mngID=mngID, agnSSanityCheckStatus=agnSSanityCheckStatus, prtExPVc4DlciPriority=prtExPVc4DlciPriority, sysCClkStationFreq=sysCClkStationFreq, sysConfig=sysConfig, cmprVersion=cmprVersion, statisPrtGen=statisPrtGen, radAce20E=radAce20E, agnVoiceSwConfRtData=agnVoiceSwConfRtData, prtExPhPlModemCnfgIdx=prtExPhPlModemCnfgIdx, prtIn7p8VcPbxConnect=prtIn7p8VcPbxConnect, agnListDecodingType=agnListDecodingType, agnCAgendaDayCategory=agnCAgendaDayCategory, radBridges=radBridges, prtExHs4TsIdx=prtExHs4TsIdx, prtExPh1MlMfClkSrcSlt=prtExPh1MlMfClkSrcSlt, prtSAlrCode=prtSAlrCode, agnSCmprErrListTable=agnSCmprErrListTable, sysBufferAlrCode=sysBufferAlrCode, agnStatusChangeTrap=agnStatusChangeTrap, prtSupervisoryIndex=prtSupervisoryIndex, systemDacsMux=systemDacsMux)
mibBuilder.exportSymbols("DACS-MIB", prtExPVc4EchoCanceler=prtExPVc4EchoCanceler, agnCnfgAlrTable=agnCnfgAlrTable, prtT3E3CnfgIdx=prtT3E3CnfgIdx, prtGen=prtGen, prtCmprCnfgIdx=prtCmprCnfgIdx, prtExMbeCnfgTable=prtExMbeCnfgTable, prtT3E3CnfgEntry=prtT3E3CnfgEntry, sysCRdnEntry=sysCRdnEntry, prtExPVc4PrtType=prtExPVc4PrtType, agnConfigMsg=agnConfigMsg, sysCClkSrcMode=sysCClkSrcMode, agnTsCmprSlotIdx=agnTsCmprSlotIdx, prtSAlarmState=prtSAlarmState, prtExPhPlCnfgTable=prtExPhPlCnfgTable, radFPS8c=radFPS8c, prtInTreLinkTo=prtInTreLinkTo, prtVcPbxCnfg=prtVcPbxCnfg, prtCmprObj=prtCmprObj, agnVoiceSwConfRtEntry=agnVoiceSwConfRtEntry, prtSClearAlrCmd=prtSClearAlrCmd, agnTsType=agnTsType, prtT1E1DedicatedTs=prtT1E1DedicatedTs, prtExPhPlDlciEntry=prtExPhPlDlciEntry, prtExPVc4SeizeAck=prtExPVc4SeizeAck, linkSelectorSltIdx=linkSelectorSltIdx, prtGenTestMask=prtGenTestMask, radSysTR=radSysTR, prtExHsrStopBits=prtExHsrStopBits, agnSErrDescription=agnSErrDescription, prtInPh1MlBearerCh=prtInPh1MlBearerCh, prtExVc2Sig=prtExVc2Sig, radMP2100=radMP2100, pLinkPortNu=pLinkPortNu, prtDimPolarity=prtDimPolarity, prtExPhPlDlciSltIdx=prtExPhPlDlciSltIdx, mdlCmprTypIdx=mdlCmprTypIdx, prtAcmSltIdx=prtAcmSltIdx, sysCRdnRowStatus=sysCRdnRowStatus, prtParamEntry=prtParamEntry, radFRmon=radFRmon, prtSExHsfRts=prtSExHsfRts, prtInPh1MlDlciSltIdx=prtInPh1MlDlciSltIdx, prtExPhPlDlciIConPrt=prtExPhPlDlciIConPrt, prtFrTxTotalBytes=prtFrTxTotalBytes, prtIsdnEndpointEntry=prtIsdnEndpointEntry, mngIPMask=mngIPMask, agnSMaskedAlrStatAll=agnSMaskedAlrStatAll, agnSEntryIsValid=agnSEntryIsValid, mdlPbxFraCnfgIdx=mdlPbxFraCnfgIdx, agnGlobalAlarmMask=agnGlobalAlarmMask, prtDestCnfgIdx=prtDestCnfgIdx, agnCmprVersion=agnCmprVersion, prtAgendaBehaviourEntry=prtAgendaBehaviourEntry, prtInPh1MlDlciEntry=prtInPh1MlDlciEntry, prtT1E1InbandMng=prtT1E1InbandMng, agnTrapMask=agnTrapMask, prtExPhPlCnfgIdx=prtExPhPlCnfgIdx, prtGenTsType=prtGenTsType, sysSRdnFlipCmd=sysSRdnFlipCmd, radTRE1D=radTRE1D, pLinkPrtIdx=pLinkPrtIdx, prtHSSlt=prtHSSlt, physicalConnectorTable=physicalConnectorTable, prtDlciCmprPrtIdx=prtDlciCmprPrtIdx, radFEC2=radFEC2, mdlMux=mdlMux, sysCnfgIdx=sysCnfgIdx, agnSErrListEntry=agnSErrListEntry, radEP8T=radEP8T, prtWanGen=prtWanGen, prtIsdnEndpointRowStatus=prtIsdnEndpointRowStatus, prtParamIdx=prtParamIdx, sysDbaseDownloadCnfgIdxCmd=sysDbaseDownloadCnfgIdxCmd, prtExVcPbxIdleCode=prtExVcPbxIdleCode, prtExMbePrtIdx=prtExMbePrtIdx, prtIsdnMode=prtIsdnMode, agnVoiceSwConfIdx=agnVoiceSwConfIdx, prtExPhPlModemTable=prtExPhPlModemTable, prtPerfUAS=prtPerfUAS, alrBufEntry=alrBufEntry, radGen=radGen, prtPerfEntry=prtPerfEntry, prtExPVc4CnfgEntry=prtExPVc4CnfgEntry, sysSSelfTestResult=sysSSelfTestResult, fileTransCmd=fileTransCmd, sysSAlarmInvert=sysSAlarmInvert, mdlAlrMaskTable=mdlAlrMaskTable, radAPS8=radAPS8, agnSEditBy=agnSEditBy, systemDefaultGateway=systemDefaultGateway, prtExHs4TsCnfgTable=prtExHs4TsCnfgTable, prtExHsrSltIdx=prtExHsrSltIdx, sysCMatrixMode=sysCMatrixMode, prtAlarmsCmprAlarmPort=prtAlarmsCmprAlarmPort, prtExHs4OosCode=prtExHs4OosCode, prtHSFifoSize=prtHSFifoSize, mdlSCmd=mdlSCmd, prtExLs2Rate=prtExLs2Rate, prtInPh1MlDlciIdx=prtInPh1MlDlciIdx, prtFrRxDcrdCongAllFr=prtFrRxDcrdCongAllFr, agnAlrBufCmprVersion=agnAlrBufCmprVersion, prtExPhPlDcdRts=prtExPhPlDcdRts, prtExHsrClkMode=prtExHsrClkMode, sysBufferAlrIdx=sysBufferAlrIdx, mdlAlrTable=mdlAlrTable, radSEC2=radSEC2, radAsmi450R1152=radAsmi450R1152, prtFrStatisSltIdx=prtFrStatisSltIdx, prtT1E1CGA=prtT1E1CGA, dacsMux=dacsMux, prtSpWaitForConnect=prtSpWaitForConnect, prtGenTestDurationTable=prtGenTestDurationTable, prtExLs6Rate=prtExLs6Rate, mdlAlr=mdlAlr, sysSAlrState=sysSAlrState, agnCFlipNetEventStartTime=agnCFlipNetEventStartTime, agnSAlrStatus=agnSAlrStatus, prtExHs4TsIConSlot=prtExHs4TsIConSlot, prtLs2Cnfg=prtLs2Cnfg, agnCnfgAlrStartReportOff=agnCnfgAlrStartReportOff, prtInPh1MlCcittCrc=prtInPh1MlCcittCrc, prtSAlarmTable=prtSAlarmTable, sysCRdnRecMode=sysCRdnRecMode, radHtuT1=radHtuT1, prtCnfgAgendaCnfgIdx=prtCnfgAgendaCnfgIdx, prtExLs6VCnfgTable=prtExLs6VCnfgTable, agnCmprTable=agnCmprTable, prtExPh1MlTsEntry=prtExPh1MlTsEntry, prtExVc2ReceiveGain=prtExVc2ReceiveGain, agnTsCmprPduIdx=agnTsCmprPduIdx, prtIn7p8VcPbxCnfgEntry=prtIn7p8VcPbxCnfgEntry, prtSpCTS=prtSpCTS, prtInVc3CnfgIdx=prtInVc3CnfgIdx, agnCFlipNetEventPort=agnCFlipNetEventPort, radAce2E=radAce2E, agnSMaxNoOfCnfg=agnSMaxNoOfCnfg, prtExHs4LineType=prtExHs4LineType, prtInVc3CnfgTable=prtInVc3CnfgTable, radSysFddi=radSysFddi, agnTsConPrtIdx=agnTsConPrtIdx, prtLogicalFunction=prtLogicalFunction, prtT1E1SSlt=prtT1E1SSlt, systemPsIndex1=systemPsIndex1, prtAgendaBehaviourTable=prtAgendaBehaviourTable, agnDlciHSltIdx=agnDlciHSltIdx, prtInLs2LinkTo=prtInLs2LinkTo, prtExVc3Wire=prtExVc3Wire, mdlAlarmsCmprTable=mdlAlarmsCmprTable, sysSEditCnfg=sysSEditCnfg, agnVoiceSwConfRtAction=agnVoiceSwConfRtAction, prtSpInterface=prtSpInterface, prtExVcPbxLineLength=prtExVcPbxLineLength, mdlSHwVer=mdlSHwVer, prtPhMlMfSyncSlot=prtPhMlMfSyncSlot, agnSAlrEntry=agnSAlrEntry, prtCmprTypIdx=prtCmprTypIdx, prtAgendaBehaviourSltIdx=prtAgendaBehaviourSltIdx, prtSupervisoryRoutProtocol=prtSupervisoryRoutProtocol, prtFrRxTotalFrames=prtFrRxTotalFrames, radHcdE1Sa=radHcdE1Sa, prtBertClearCounters=prtBertClearCounters, agnVoiceSwConfRtSlot=agnVoiceSwConfRtSlot, sysChas=sysChas, chasTotalNoOfClSlt=chasTotalNoOfClSlt, prtExPhPlModemStatus=prtExPhPlModemStatus, radLrs12B=radLrs12B, mdlClLastFlipTime=mdlClLastFlipTime, prtInPh1MlCongResponse=prtInPh1MlCongResponse, prtDlciIdx=prtDlciIdx, chasWanGen=chasWanGen, prtIsdnPrtIdx=prtIsdnPrtIdx, prtInMbeRate=prtInMbeRate, prtGenTsIdx=prtGenTsIdx, sysDbaseFlipEntry=sysDbaseFlipEntry, prtExPVc4AutoFaxMode=prtExPVc4AutoFaxMode, agnLed=agnLed, prtExVcPbxTsCnfgIdx=prtExVcPbxTsCnfgIdx, prtExVc3TransGain=prtExVc3TransGain, agnVoiceSwConfNoOfHops=agnVoiceSwConfNoOfHops, prtIsdnEndpointTable=prtIsdnEndpointTable, sysDbaseFlipTable=sysDbaseFlipTable, prtMonitoringTSs=prtMonitoringTSs, mdlSSwVersion=mdlSSwVersion, radMP2200F=radMP2200F, agnAlarmsCmprEntry=agnAlarmsCmprEntry, agnVoiceSwConfHGdbIdx=agnVoiceSwConfHGdbIdx, prtInPh1MlDlciRxBe=prtInPh1MlDlciRxBe, sysDclTable=sysDclTable, prtMl4SigProfile=prtMl4SigProfile, mdlPbxFraFramerSlot=mdlPbxFraFramerSlot, prtT1E1=prtT1E1, mdlAlarmsCmprObj=mdlAlarmsCmprObj, prtExVcPbxCnfgTable=prtExVcPbxCnfgTable, prtExPh1MlCnfgIdx=prtExPh1MlCnfgIdx, agnSaSwchStatus=agnSaSwchStatus, agnTsIdx=agnTsIdx, prtIsdnDirectoryCnfgIdx=prtIsdnDirectoryCnfgIdx, prtBertInjectRate=prtBertInjectRate, prtAlarmsCmprAlarmIdx=prtAlarmsCmprAlarmIdx, prtDlciTxBcViol=prtDlciTxBcViol, prtParamTable=prtParamTable, agnVoiceSwConfHGExt=agnVoiceSwConfHGExt, agnCnfgAlrEntry=agnCnfgAlrEntry, prtExPVc4DlciPrtIdx=prtExPVc4DlciPrtIdx, prtDlciPrtIdx=prtDlciPrtIdx, agnCFlipDbSanityCheckCmd=agnCFlipDbSanityCheckCmd, prtExLs6Protocol=prtExLs6Protocol, prtMl4DataOos=prtMl4DataOos, prtT3E3InbandMng=prtT3E3InbandMng, agnDlciRxBc=agnDlciRxBc, linkSelectorMinBUSession=linkSelectorMinBUSession, prtInLs6LinkTo=prtInLs6LinkTo, prtSupervisoryCTS=prtSupervisoryCTS, prtPerfES=prtPerfES, mdlSAlrMaskAll=mdlSAlrMaskAll, trapID=trapID, prtFrTxDcrdCongAllFr=prtFrTxDcrdCongAllFr, fileName=fileName, prtInPh1MlFrMngProt=prtInPh1MlFrMngProt, prtCmprPrtIdx=prtCmprPrtIdx, prtDlciCmprCnfgIdx=prtDlciCmprCnfgIdx, radImx2T1E1=radImx2T1E1, prtExHsfFifoSize=prtExHsfFifoSize, prtExPh1MlTsTable=prtExPh1MlTsTable, prtExVc2Wire=prtExVc2Wire, prtLs6Cnfg=prtLs6Cnfg, prtExTreLan=prtExTreLan, prtAlarmsCmprEntry=prtAlarmsCmprEntry, mngTrapMask=mngTrapMask, prtFrTxBeViol=prtFrTxBeViol, alrGenDescription=alrGenDescription, prtExVc2EchoCanceler=prtExVc2EchoCanceler, sysDclFlipDelay=sysDclFlipDelay, prtIsdnDirectoryTeiId=prtIsdnDirectoryTeiId, radSTC1UDP=radSTC1UDP, prtExPhPlDlciTable=prtExPhPlDlciTable, mdlPbxFraSignalVector=mdlPbxFraSignalVector, mdlClEntry=mdlClEntry, mdlClIdx=mdlClIdx, mdlSInstTable=mdlSInstTable, prtTest=prtTest, mdlSHwStatus=mdlSHwStatus, prtHSCnfgIdx=prtHSCnfgIdx, prtInHsiSltIdx=prtInHsiSltIdx, linkSelectorPrtIdx=linkSelectorPrtIdx, prtT1E1StatTable=prtT1E1StatTable, radHtuT1Sa=radHtuT1Sa, radMX300=radMX300, prtExTsIdx=prtExTsIdx, prtHsiCnfg=prtHsiCnfg, prtPhMlSyncRestore=prtPhMlSyncRestore, prtExPVc4SignalingProtocol=prtExPVc4SignalingProtocol, prtExMbeCnfgIdx=prtExMbeCnfgIdx, prtHsfSltIdx=prtHsfSltIdx)
mibBuilder.exportSymbols("DACS-MIB", prtT1E1FdlMsgFdlType=prtT1E1FdlMsgFdlType, sysBufferAlrDate=sysBufferAlrDate, agnCnfgAlrSlot=agnCnfgAlrSlot, sysHub=sysHub, prtSpCallOutMode=prtSpCallOutMode, radFEB4SAS=radFEB4SAS, agnSAlrInvert=agnSAlrInvert, prtExPhPlCnfgEntry=prtExPhPlCnfgEntry, prtExPhPlParity=prtExPhPlParity, sysBufferAlrState=sysBufferAlrState, prtExLs6VPrtIdx=prtExLs6VPrtIdx, mdlClSwchStatus=mdlClSwchStatus, sysSErrListEntry=sysSErrListEntry, prtExHsfLinkTo=prtExHsfLinkTo, prtExHsfClkMode=prtExHsfClkMode, prtGenTestDuration=prtGenTestDuration, radStarSwitch=radStarSwitch, prtExPh1MlInbandMngRoutProt=prtExPh1MlInbandMngRoutProt, prtExHsrLinkTo=prtExHsrLinkTo, prtExVcPbxTsIConSlot=prtExVcPbxTsIConSlot, agnListDecodingDescription=agnListDecodingDescription, mdlSAlrCodeDescription=mdlSAlrCodeDescription, agnLinkMapEntry=agnLinkMapEntry, radSPS6=radSPS6, radStarSwitchATM25L=radStarSwitchATM25L, prtSInstTable=prtSInstTable, mdlSActivity=mdlSActivity, sysCRdnTable=sysCRdnTable, prtInPh1MlFrameSeparator=prtInPh1MlFrameSeparator, prtT1Statis=prtT1Statis, prtExPh1MlTxGain=prtExPh1MlTxGain, agnDlciLIdx=agnDlciLIdx, prtInPh1MlDlciIConSlt=prtInPh1MlDlciIConSlt, sysSErrListTable=sysSErrListTable, prtGenCnfgIdx=prtGenCnfgIdx, mdlAlarmInvert=mdlAlarmInvert, prtExPh1MlFdlType=prtExPh1MlFdlType, mdlPs=mdlPs, mdlSTestStatus=mdlSTestStatus, sysBufferAlrSlot=sysBufferAlrSlot, prtExPh1MlRestoreTime=prtExPh1MlRestoreTime, agnTsCnfgIdx=agnTsCnfgIdx, prtIRate=prtIRate, radSysBRG=radSysBRG, mdlAlarmsCmprVersion=mdlAlarmsCmprVersion, prtExPhPlDcdRtsControlPath=prtExPhPlDcdRtsControlPath, agnIndication=agnIndication, radEPR4T2FL=radEPR4T2FL, radDXC10A=radDXC10A, mdlSHwVersion=mdlSHwVersion, mdlSAlrCode=mdlSAlrCode, radFTC2UDP=radFTC2UDP, radTrimBrg10=radTrimBrg10, prtExPVc4DlciTxBe=prtExPVc4DlciTxBe, prtExTreCnfgIdx=prtExTreCnfgIdx, prtBertInjectErrRateCmd=prtBertInjectErrRateCmd, prtSpCmd=prtSpCmd, prtExHsrConnect=prtExHsrConnect, prtT1E1LineType=prtT1E1LineType, sanityTrap=sanityTrap, prtBertCounter=prtBertCounter, agnTsConIdx=agnTsConIdx, prtT1E1LinkMode=prtT1E1LinkMode, prtExPVc4CnfgTable=prtExPVc4CnfgTable, prtExVcPbxCnfgIdx=prtExVcPbxCnfgIdx, prtCfgParamSlt=prtCfgParamSlt, prtSAlrCounter=prtSAlrCounter, systems=systems, prtICnfgEntry=prtICnfgEntry, agnCFlipNetEventsEntry=agnCFlipNetEventsEntry, prtGenInterfaceType=prtGenInterfaceType, agnCAgendaDayIdx=agnCAgendaDayIdx, prtExPhPlConnectionTyp=prtExPhPlConnectionTyp, prtExPVc4DelayStart=prtExPVc4DelayStart, mdlGen=mdlGen, prtInHsiPrtIdx=prtInHsiPrtIdx, prtExPVc4HuntGroupMb=prtExPVc4HuntGroupMb, prtT1FdlMsg=prtT1FdlMsg, prtT3E3=prtT3E3, radSPS3ScSL=radSPS3ScSL, prtCrStatis=prtCrStatis, prtExVcPbxRestoreTime=prtExVcPbxRestoreTime, mdlAlrCode=mdlAlrCode, agnCnfgAlrReportTable=agnCnfgAlrReportTable, prtFrTxBecn=prtFrTxBecn, radAce102=radAce102, agnCNetEventsBcastInterval=agnCNetEventsBcastInterval, radTokenRing=radTokenRing, prtT1FdlMsgSltIdx=prtT1FdlMsgSltIdx, agnXCmprIdx6=agnXCmprIdx6, prtExPh1MlCnfgTable=prtExPh1MlCnfgTable, sysSaSwRevision=sysSaSwRevision, agnCnfgAlrMask=agnCnfgAlrMask, prtExClCnfgTable=prtExClCnfgTable, mdlPsTable=mdlPsTable, sysCIsdnFormat=sysCIsdnFormat, prtSpDsr=prtSpDsr, mdlCPrgTable=mdlCPrgTable, prtVc3Cnfg=prtVc3Cnfg, linkSelectorMode=linkSelectorMode, agnCFlipIdx=agnCFlipIdx, radOptimuxXL16E1=radOptimuxXL16E1, prtGenCnfgPrtIdx=prtGenCnfgPrtIdx, mdlAlrMaskEntry=mdlAlrMaskEntry, prtHSBertEntry=prtHSBertEntry, radEPR4TAUI=radEPR4TAUI, prtIIdx=prtIIdx, prtT1E1IdleCode=prtT1E1IdleCode, radSPS3Sc2S=radSPS3Sc2S, agnCnfgAlrFilterReset=agnCnfgAlrFilterReset, prtExVcPbxTsIConPrt=prtExVcPbxTsIConPrt, prtInPh1MlDlciValid=prtInPh1MlDlciValid, mdlAlrMask=mdlAlrMask, prtExHsiInterface=prtExHsiInterface, mdlAlarmsCmprAlarmIdx=mdlAlarmsCmprAlarmIdx, prtExLs6SltIdx=prtExLs6SltIdx, sysSaPorts=sysSaPorts, prtExHs4CnfgIdx=prtExHs4CnfgIdx, systemParameter=systemParameter, agnCFlipNetEventISD=agnCFlipNetEventISD, agnVoiceSwConfEntry=agnVoiceSwConfEntry, prtGenCnfgSltIdx=prtGenCnfgSltIdx, sysSRdnFlipIdx=sysSRdnFlipIdx, radSPS3S=radSPS3S, mdlSAlrClearCmd=mdlSAlrClearCmd, radSysAtm=radSysAtm, statPrtMux=statPrtMux, prtIsdnDirectoryPrtIdx=prtIsdnDirectoryPrtIdx, agnAlrBufCmprEntry=agnAlrBufCmprEntry, mdlSAlrMask=mdlSAlrMask, prtGenTsIConTs=prtGenTsIConTs, prtExClStopBits=prtExClStopBits, prtT1E1SignalMode=prtT1E1SignalMode, prtExPhPlDlciPrtIdx=prtExPhPlDlciPrtIdx, prtExPVc4IfType=prtExPVc4IfType, cnfgMdlMux=cnfgMdlMux, prtExHsrCts=prtExHsrCts, prtPerfElapsedTime=prtPerfElapsedTime, agnDlciLSltIdx=agnDlciLSltIdx, prtExMbeLan=prtExMbeLan, prtExPVc4Wire=prtExPVc4Wire, agnTsPrtIdx=agnTsPrtIdx, prtSpParity=prtSpParity, agnTsCmprEntry=agnTsCmprEntry, prtExPhPlEnqPeriod=prtExPhPlEnqPeriod, prtExPhPlDlciRxBc=prtExPhPlDlciRxBc, prtBertRunTime=prtBertRunTime, prtExHsfInbandLoopback=prtExHsfInbandLoopback, agnCnfgDesc=agnCnfgDesc, radConverters=radConverters, prtExHsrRlbEnable=prtExHsrRlbEnable, agnVoiceSwConfRtRowStatus=agnVoiceSwConfRtRowStatus, prtFrPlusCnfgEntry=prtFrPlusCnfgEntry, ethIf=ethIf, agnSigProfileCnfgIdx=agnSigProfileCnfgIdx, prtGenTestCmd=prtGenTestCmd, radAmcdE1=radAmcdE1, radMP2100H=radMP2100H, prtCfgParamTable=prtCfgParamTable, prtDlciRxBeViol=prtDlciRxBeViol, prtExLs6CnfgEntry=prtExLs6CnfgEntry, cnfgPrtMux=cnfgPrtMux, radAPD2=radAPD2, prtT1E1FdlMsgPrtIdx=prtT1E1FdlMsgPrtIdx, agnCFlipTable=agnCFlipTable, mdlSInstCardType=mdlSInstCardType, prtHSBertCountClr=prtHSBertCountClr, prtHs4Cnfg=prtHs4Cnfg, mdlSInstSltIdx=mdlSInstSltIdx, prtExPh1MlIfType=prtExPh1MlIfType, prtExLs6VCnfgEntry=prtExLs6VCnfgEntry, prtExPVc4ExtensionType=prtExPVc4ExtensionType, agnCFlipNetEventType=agnCFlipNetEventType, prtExHs4CnfgEntry=prtExHs4CnfgEntry, prtExVc3CnfgIdx=prtExVc3CnfgIdx, prtT3E3Slt=prtT3E3Slt, prtInMbeSltIdx=prtInMbeSltIdx, prtDlciCmprDlciIdx=prtDlciCmprDlciIdx, prtHSParamTable=prtHSParamTable, prtIsdnEndpointCnfgIdx=prtIsdnEndpointCnfgIdx, prtCmprSltIdx=prtCmprSltIdx, mdlPsStatus=mdlPsStatus, agnLinkMapTable=agnLinkMapTable, prtIsdnEndpointSltIdx=prtIsdnEndpointSltIdx, prtExHsiConnect=prtExHsiConnect, radMP2104H=radMP2104H, prtBertEntry=prtBertEntry, prtInPh1MlCnfgTable=prtInPh1MlCnfgTable, prtExPhPlModemActivate=prtExPhPlModemActivate, mdlAlrSltIdx=mdlAlrSltIdx, sysSErrType=sysSErrType, prtExHsrRate=prtExHsrRate, prtInLs6TandemMode=prtInLs6TandemMode, mdlCmprCnfgIdx=mdlCmprCnfgIdx, prtExHs4SltIdx=prtExHs4SltIdx, prtSupervisory=prtSupervisory, agnCAgendaCnfgIdx=agnCAgendaCnfgIdx, cnfgAgnGen=cnfgAgnGen, agnSigProfileABCD=agnSigProfileABCD, prtSExHsfStatTable=prtSExHsfStatTable, agnTsEntry=agnTsEntry, prtExLs6CnfgIdx=prtExLs6CnfgIdx, prtGenParamStatus=prtGenParamStatus, prtExPh1MlRedundType=prtExPh1MlRedundType, prtInPh1MlCongLevel=prtInPh1MlCongLevel, prtExPhPlCongResponse=prtExPhPlCongResponse, prtInPh1MlCnfgIdx=prtInPh1MlCnfgIdx, radFTBDAS=radFTBDAS, statMdlGen=statMdlGen, prtGenTestStatus=prtGenTestStatus, prtFrTxFecn=prtFrTxFecn, agnCnfgDataTable=agnCnfgDataTable, agnAlrBufCmprObj=agnAlrBufCmprObj, prtExHs4RestoreT=prtExHs4RestoreT, prtInPh1MlTc=prtInPh1MlTc, systemPsIndex2=systemPsIndex2, agnCAgendaTable=agnCAgendaTable, prtGenAlrClearCmd=prtGenAlrClearCmd, flipDbChangeTrap=flipDbChangeTrap, prtIsdnCnfgTable=prtIsdnCnfgTable, prtCnfgAgendaTable=prtCnfgAgendaTable, prtIn7p8VcPbxMode=prtIn7p8VcPbxMode, agnCnfgAlrReportEntry=agnCnfgAlrReportEntry, prtInHsiCnfgTable=prtInHsiCnfgTable, prtIsdnDirectoryRemoteSubAddr2=prtIsdnDirectoryRemoteSubAddr2, radHtuE1V2=radHtuE1V2, radDXC30E=radDXC30E, radETS4fddiDAS=radETS4fddiDAS, agnCOffsetCmd=agnCOffsetCmd, prtCmprEntry=prtCmprEntry, prtExPhPlFrMngProt=prtExPhPlFrMngProt, agnSCmprErrObj=agnSCmprErrObj, radDXC8R=radDXC8R, prtExHs4OosSig=prtExHs4OosSig, prtIn7p8VcPbxSltIdx=prtIn7p8VcPbxSltIdx, radRRFTBSAS=radRRFTBSAS, agnSAlrMask=agnSAlrMask, agnSAlrCodeDescription=agnSAlrCodeDescription, prtInPh1MlDlciPriority=prtInPh1MlDlciPriority, prtHSRtsState=prtHSRtsState, prtExLs2Dcd=prtExLs2Dcd, prtFrPlusCnfg=prtFrPlusCnfg, agnDlciRowStatus=agnDlciRowStatus, radFTC1=radFTC1, prtExPVc4TxGain=prtExPVc4TxGain, prtExVcPbxLineCode=prtExVcPbxLineCode, prtFrTxDeFrames=prtFrTxDeFrames, prtInLs6CnfgTable=prtInLs6CnfgTable, prtT1E1LineMode=prtT1E1LineMode, prtSpPrimaryNum=prtSpPrimaryNum, prtIsdnSignalingProtocol=prtIsdnSignalingProtocol, agnCAgendaEntry=agnCAgendaEntry, prtExPhPlCcittCrc=prtExPhPlCcittCrc, prtStatusChangeTrap=prtStatusChangeTrap)
mibBuilder.exportSymbols("DACS-MIB", prtSpAlrRelayMode=prtSpAlrRelayMode, agnCFlipDbNo=agnCFlipDbNo, prtExLs6ClkMode=prtExLs6ClkMode, prtSAlrSeverity=prtSAlrSeverity, prtAlrMaskPrtIdx=prtAlrMaskPrtIdx, agnTsCmprPortIdx=agnTsCmprPortIdx, prtMonitoredPort=prtMonitoredPort, mdlCNoOfExternPrt=mdlCNoOfExternPrt, prtExLs6LinkToInternal=prtExLs6LinkToInternal, prtAcmAlrString=prtAcmAlrString, prtSTestMask=prtSTestMask, prtPhMlPrtIdx=prtPhMlPrtIdx, prtInLs2Group=prtInLs2Group, prtSupervisoryDcdDelay=prtSupervisoryDcdDelay, prtExHsiCnfgTable=prtExHsiCnfgTable, mdlPbxFraEnhEcho=mdlPbxFraEnhEcho, physicalConnectorEntry=physicalConnectorEntry, mdlConnectTrap=mdlConnectTrap, agnCClkSrcSlt=agnCClkSrcSlt, radAmcdT1=radAmcdT1, agnCnfgAlrStartReportOn=agnCnfgAlrStartReportOn, radImx4T1=radImx4T1, sysDclEntry=sysDclEntry, mdlSAlrSltIdx=mdlSAlrSltIdx, radSysCnvrtr=radSysCnvrtr, prtDlciCmprSltIdx=prtDlciCmprSltIdx, prtSExHsfPrtIdx=prtSExHsfPrtIdx, prtExHsfRate=prtExHsfRate, prtExVc2RxBitOutput=prtExVc2RxBitOutput, radMX3004=radMX3004, prtExVc2EandMType=prtExVc2EandMType, agnListDecodingSeverity=agnListDecodingSeverity, prtHsfCnfgTable=prtHsfCnfgTable, prtExPVc4OutPulsing=prtExPVc4OutPulsing, mdlCConfigIdx=mdlCConfigIdx, cmprPrtIdx=cmprPrtIdx, prtExPh1MlMfClkSrcPrt=prtExPh1MlMfClkSrcPrt, prtDimClkMode=prtDimClkMode, prtExPVc4VarDelay=prtExPVc4VarDelay, radTRERASa=radTRERASa, agnSClkSrc=agnSClkSrc, sysDclCopyDbTable=sysDclCopyDbTable, prtSAlrIdx=prtSAlrIdx, prtIsdnSltIdx=prtIsdnSltIdx, mdlSAlrInvert=mdlSAlrInvert, prtAcmPrtIdx=prtAcmPrtIdx, prtAcmConnect=prtAcmConnect, prtMonitoredTSs=prtMonitoredTSs, prtExPhPlDceClkSrc=prtExPhPlDceClkSrc, agnSCmprErrIdx=agnSCmprErrIdx, cmprPrtGen=cmprPrtGen, agnDlciPriority=agnDlciPriority, radLrs12F=radLrs12F, prtInVc3PrtIdx=prtInVc3PrtIdx, sysCRdnCnfgIdx=sysCRdnCnfgIdx, mapLinkStatus=mapLinkStatus, prtExPVc4DlciCnfgIdx=prtExPVc4DlciCnfgIdx, mdlPbxFraSltIdx=mdlPbxFraSltIdx, radSysStkHub=radSysStkHub, prtIsdnDirectoryLocalAddr=prtIsdnDirectoryLocalAddr, prtExLs6PrtIdx=prtExLs6PrtIdx, prtExPVc4FaxRate=prtExPVc4FaxRate, prtExClPrtIdx=prtExClPrtIdx, linkSelectorCnfgIdx=linkSelectorCnfgIdx, sysSAlrStatusAll=sysSAlrStatusAll, agnXCmprIdx5=agnXCmprIdx5, mapLinkId=mapLinkId, prtPerfTable=prtPerfTable, radFPS8=radFPS8, agnListDecodingCode=agnListDecodingCode, prtExPhPlClockEncoding=prtExPhPlClockEncoding, sysSa=sysSa, prtInPh1MlDlciStatus=prtInPh1MlDlciStatus, prtExPVc4DlciRxBe=prtExPVc4DlciRxBe, prtGenTestIdx=prtGenTestIdx, agnVoiceSwConfHGTable=agnVoiceSwConfHGTable, radHtuE1SaV2=radHtuE1SaV2, sysSRdnFlipPort=sysSRdnFlipPort, mdlSAlrState=mdlSAlrState, agnCnfgAlrFilterSet=agnCnfgAlrFilterSet, radFDX100=radFDX100, prtDim=prtDim, prtVc2CnfgEntry=prtVc2CnfgEntry, prtExHs4LineCode=prtExHs4LineCode, prtExHs4Connect=prtExHs4Connect, radSysWan=radSysWan, prtExHsrProtocol=prtExHsrProtocol, prtIsdnSwitchMode=prtIsdnSwitchMode, prtHdslEntry=prtHdslEntry, agnAlrBufCmprAlarmIdx=agnAlrBufCmprAlarmIdx, agnSClearAllAlrCmd=agnSClearAllAlrCmd, prtExPVc4HuntGroupIdx=prtExPVc4HuntGroupIdx, prtDlciStatisTable=prtDlciStatisTable, sysDcl=sysDcl, radKM2104=radKM2104, sysSRdnFlipDate=sysSRdnFlipDate, prtFrRxBecn=prtFrRxBecn, prtInLs6Connect=prtInLs6Connect, radAsmi450R768=radAsmi450R768, radOpt4E1C=radOpt4E1C, radSAH16Eint=radSAH16Eint, agnTsCmprData=agnTsCmprData, prtDimDestTable=prtDimDestTable, tftpTotalTimeOut=tftpTotalTimeOut, prtMl4CnfgTable=prtMl4CnfgTable, mdlSSwVer=mdlSSwVer, prtExVc2CallEnable=prtExVc2CallEnable, agnCSaveFlipDbCmd=agnCSaveFlipDbCmd, agnSa=agnSa, pLinkIdx=pLinkIdx, radFEC1=radFEC1, agnVoiceSwConfTable=agnVoiceSwConfTable, prtMonEntry=prtMonEntry, radRBHT=radRBHT, prtHSBertTestResult=prtHSBertTestResult, prtInLs2CnfgEntry=prtInLs2CnfgEntry, sysBufferAlrPort=sysBufferAlrPort, radOptimux4T1=radOptimux4T1, agnSAlrSeverity=agnSAlrSeverity, prtGenTsEntry=prtGenTsEntry, radMBE8=radMBE8, prtIsdnEndpointIdx=prtIsdnEndpointIdx, prtExHsrOperMode=prtExHsrOperMode, prtInPh1MlDlciCnfgIdx=prtInPh1MlDlciCnfgIdx, agnDlciSpoofing=agnDlciSpoofing, mdlPbxFraSignalMask=mdlPbxFraSignalMask, prtExPhPlLRate=prtExPhPlLRate, prtSpEntry=prtSpEntry, prtGenAlrStatus=prtGenAlrStatus, prtExPhPlDlciStatus=prtExPhPlDlciStatus, radFcdE1I=radFcdE1I, prtExPVc4CongLevel=prtExPVc4CongLevel, statAgnGen=statAgnGen, agnCmprCnfgIdx=agnCmprCnfgIdx, prtInPh1MlProtocol=prtInPh1MlProtocol, sysSRdnFlipTime=sysSRdnFlipTime, prtGenTsTable=prtGenTsTable, prtT3E3PrtIdx=prtT3E3PrtIdx, radRRTRE8D=radRRTRE8D, radSEC2UDP=radSEC2UDP, prtExHsiPrtIdx=prtExHsiPrtIdx, prtGenEntry=prtGenEntry, prtT1E1TxGainMask=prtT1E1TxGainMask, mdlClTable=mdlClTable, prtT1E1SPrtIdx=prtT1E1SPrtIdx, agnDlciCmprTable=agnDlciCmprTable, prtFrPlusCnfgIdx=prtFrPlusCnfgIdx, sysDclOnline=sysDclOnline, radAce20T=radAce20T, prtExClCnfgIdx=prtExClCnfgIdx, agnCSaveCnfgIdxCmd=agnCSaveCnfgIdxCmd, prtExLs2Cts=prtExLs2Cts, radSAH16Eext=radSAH16Eext, prtSupervisoryStopBits=prtSupervisoryStopBits, prtHSBertPrtIdx=prtHSBertPrtIdx, prtDestIdx=prtDestIdx, systemTime=systemTime, prtExPhPlModemEntry=prtExPhPlModemEntry, prtMl4PrtIdx=prtMl4PrtIdx, agnDlciFunnelEnable=agnDlciFunnelEnable, sysSAlrMask=sysSAlrMask, radRRTRE1D=radRRTRE1D, sysBufferAlrTable=sysBufferAlrTable, prtExVc2LinkTo=prtExVc2LinkTo, agnXCmprTypIdx=agnXCmprTypIdx, prtInTreSltIdx=prtInTreSltIdx, prtSBertClrCmd=prtSBertClrCmd, prtExHsiRate=prtExHsiRate, prtICnfgTable=prtICnfgTable, prtInTrePrtIdx=prtInTrePrtIdx, prtIsdnEndpointBearerCh=prtIsdnEndpointBearerCh, prtDimMaxDelay=prtDimMaxDelay, agnVoiceSwConfNodeId=agnVoiceSwConfNodeId, prtCnfgAgenda=prtCnfgAgenda, mdlPsEntry=mdlPsEntry, agnMux=agnMux, mdlPbxFraSignalMode=mdlPbxFraSignalMode, sysSTimeCmd=sysSTimeCmd, prtDimDestEntry=prtDimDestEntry, radAsmi450R1152Sa=radAsmi450R1152Sa, prtSP=prtSP, prtT1E1RxGain=prtT1E1RxGain, prtExPVc4DlciIConPrt=prtExPVc4DlciIConPrt, mapLinkState=mapLinkState, prtHSClkMode=prtHSClkMode, prtMonitoringIdx=prtMonitoringIdx, agnAlrBufCmprTable=agnAlrBufCmprTable, prtBertTs=prtBertTs, prtGenSlt=prtGenSlt, agnSpecific=agnSpecific, agnFlipDbControls=agnFlipDbControls, sysSAlrCode=sysSAlrCode, prtInLs6CnfgEntry=prtInLs6CnfgEntry, radMBERASa=radMBERASa, radFPS4=radFPS4, prtExPhPlStopBits=prtExPhPlStopBits, prtIn7p8VcPbxCnfgIdx=prtIn7p8VcPbxCnfgIdx, mdlCProgCardType=mdlCProgCardType, prtGenPrtIdx=prtGenPrtIdx, prtT1E1Fdl=prtT1E1Fdl, agnSAlrTable=agnSAlrTable, prtExPVc4WinkMinDuration=prtExPVc4WinkMinDuration, radAce2005=radAce2005, prtPhMlCAS=prtPhMlCAS, agnTsCmprVerIdx=agnTsCmprVerIdx, prtIsdnConnect=prtIsdnConnect, agnXCmprVersion=agnXCmprVersion, prtGenActiveStatus=prtGenActiveStatus, prtExVcPbxCnfgEntry=prtExVcPbxCnfgEntry, sysCRdnSecSlot=sysCRdnSecSlot, prtDimIdx=prtDimIdx, prtIsdnEndpointTeiValue=prtIsdnEndpointTeiValue, prtCnfgAgendaPrtIdx=prtCnfgAgendaPrtIdx, prtHdslTable=prtHdslTable, prtDlciRxBcViol=prtDlciRxBcViol, prtExTsBit=prtExTsBit, radTRE8D=radTRE8D, agnSCnfgTable=agnSCnfgTable, mdlPbxFramerCnfgTable=mdlPbxFramerCnfgTable, radFTC2=radFTC2, prtLogicalConnect=prtLogicalConnect, alrGenTable=alrGenTable, prtInPh1MlDlciIConDlci=prtInPh1MlDlciIConDlci, prtExHs4TsEntry=prtExHs4TsEntry, prtExPhPlPrtIdx=prtExPhPlPrtIdx, prtInVc3Oos=prtInVc3Oos, sysSAlrMaskAll=sysSAlrMaskAll)

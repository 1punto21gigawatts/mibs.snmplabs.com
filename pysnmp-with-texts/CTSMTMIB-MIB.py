#
# PySNMP MIB module CTSMTMIB-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CTSMTMIB-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:44:24 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueRangeConstraint, ConstraintsUnion, ValueSizeConstraint, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueRangeConstraint", "ConstraintsUnion", "ValueSizeConstraint", "SingleValueConstraint")
ctsmtmib, = mibBuilder.importSymbols("CTRON-MIB-NAMES", "ctsmtmib")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
MibScalar, MibTable, MibTableRow, MibTableColumn, IpAddress, TimeTicks, Integer32, Counter32, Counter64, NotificationType, ObjectIdentity, iso, MibIdentifier, ModuleIdentity, Unsigned32, Bits, Gauge32 = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "IpAddress", "TimeTicks", "Integer32", "Counter32", "Counter64", "NotificationType", "ObjectIdentity", "iso", "MibIdentifier", "ModuleIdentity", "Unsigned32", "Bits", "Gauge32")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
ctsmtmibRingTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 1), )
if mibBuilder.loadTexts: ctsmtmibRingTable.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibRingTable.setDescription('A list of fddi nodes found on the ring.')
ctsmtmibRingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 1, 1), ).setIndexNames((0, "CTSMTMIB-MIB", "ctsmtmibRingSmtIndex"), (0, "CTSMTMIB-MIB", "ctsmtmibRingMacIndex"), (0, "CTSMTMIB-MIB", "ctsmtmibRingNodeIndex"), (0, "CTSMTMIB-MIB", "ctsmtmibRingMacAddr"))
if mibBuilder.loadTexts: ctsmtmibRingEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibRingEntry.setDescription('A fddi ring entry containing information common to all stations in a token path.')
ctsmtmibRingSmtIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctsmtmibRingSmtIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibRingSmtIndex.setDescription('The value of the SMT index associated with this ring.')
ctsmtmibRingMacIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctsmtmibRingMacIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibRingMacIndex.setDescription('A unique value for each MAC within a given SMT.')
ctsmtmibRingNodeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctsmtmibRingNodeIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibRingNodeIndex.setDescription('The index of the node on the ring in reverse token flow order. It is sequential from 1 to n where n is the number of nodes on the ring at a given time.')
ctsmtmibRingMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 1, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctsmtmibRingMacAddr.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibRingMacAddr.setDescription('A canonical representation of the MAC address of the node.')
ctsmtmibRingUpStreamAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctsmtmibRingUpStreamAddr.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibRingUpStreamAddr.setDescription("This is a canonical representation of the upstream neighbor's address. The upstream neighbor is the last MAC to receive the token before this MAC. Unknown addresses should be specified as 00-00-F8-00-00-00.")
ctsmtmibRingNodeClass = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("station", 1), ("concentrator", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctsmtmibRingNodeClass.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibRingNodeClass.setDescription('Reports if the node is a station or a concentrator.')
ctsmtmibRingMacCount = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctsmtmibRingMacCount.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibRingMacCount.setDescription('The number of MACs on this FDDI node.')
ctsmtmibRingNonMasterCount = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctsmtmibRingNonMasterCount.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibRingNonMasterCount.setDescription('The sum of all A ports, B ports, and S ports on this node.')
ctsmtmibRingMasterCount = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctsmtmibRingMasterCount.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibRingMasterCount.setDescription('The number of master ports on this node.')
ctsmtmibRingTopology = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctsmtmibRingTopology.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibRingTopology.setDescription("A bit mapped representation of the current state of the node. if state: Add 2**n where n = Wrapped Node 0 Unattached Concentrator 1 A-A Twisted Ring 2 B-B Twisted Ring 3 Rooted Station 4 SRF Supported 5 where Wrapped Node: is set when the node's cf-state is Wrap-A, Wrap-B, Wrap-C, or Wrap-AB. Unattached Concentrator: is set when a concentrator has no active A, B, or S ports. A-A Twisted Ring: is set when this node's A port is connected to another A port. B-B Twisted Ring: is set when this node's B port is connected to another B port. Rooted Station: is a station with ports A, B and S, not active in tree mode. SRF Supported: This node adheres to the status reporting frame protocol.")
ctsmtmibRingDuplicate = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctsmtmibRingDuplicate.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibRingDuplicate.setDescription("A bit mapped representation of duplicate address information. if State: Add 2**n where n= My Duplicate: 0 UNA Duplicate: 1 where My Duplicate: This node determines that it's MAC address is same as the MAC address for another node on the ring. UNA Duplicate: The upstream neighbor of this node has determined that its's MAC address is same as the MAC address for another node on the ring.")
ctsmtmibMacTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 2), )
if mibBuilder.loadTexts: ctsmtmibMacTable.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibMacTable.setDescription('A list of MAC entries. The total number of entries is given by the value of ctsmtmibRingMacCount with appropriate ctsmtmibRingMacAddr.')
ctsmtmibMacEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 2, 1), ).setIndexNames((0, "CTSMTMIB-MIB", "ctsmtmibMacSmtIndex"), (0, "CTSMTMIB-MIB", "ctsmtmibMacIndex"))
if mibBuilder.loadTexts: ctsmtmibMacEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibMacEntry.setDescription('A MAC entry containing information pertaining to a given MAC.')
ctsmtmibMacSmtIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctsmtmibMacSmtIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibMacSmtIndex.setDescription('The value of the SMT Index associated with this MAC.')
ctsmtmibMacIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctsmtmibMacIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibMacIndex.setDescription('A unique value for each MAC within a given SMT.')
ctsmtmibMacNifTxCts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctsmtmibMacNifTxCts.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibMacNifTxCts.setDescription('The count of Neighborhood Information frames transmitted by the MAC.')
ctsmtmibMacNifRxCts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctsmtmibMacNifRxCts.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibMacNifRxCts.setDescription('The count of Neighborhood Information frames received by the MAC.')
ctsmtmibMacSifTxCts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctsmtmibMacSifTxCts.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibMacSifTxCts.setDescription('The count of Status Information frames transmitted by the MAC.')
ctsmtmibMacSifRxCts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctsmtmibMacSifRxCts.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibMacSifRxCts.setDescription('The count of Status Information Frames received by the MAC.')
ctsmtmibMacEcfTxCts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctsmtmibMacEcfTxCts.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibMacEcfTxCts.setDescription('The count of Echo Frames transmitted by the MAC.')
ctsmtmibMacEcfRxCts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctsmtmibMacEcfRxCts.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibMacEcfRxCts.setDescription('The count of Echo Frames received by the MAC.')
ctsmtmibMacPmfTxCts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctsmtmibMacPmfTxCts.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibMacPmfTxCts.setDescription('The count of Parameter Management Frames transmitted by the MAC.')
ctsmtmibMacPmfRxCts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctsmtmibMacPmfRxCts.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibMacPmfRxCts.setDescription('The count of Parameter Management Frames received by the MAC.')
ctsmtmibMacRdfTxCts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctsmtmibMacRdfTxCts.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibMacRdfTxCts.setDescription('The count of Request Denied Frames transmitted by the MAC.')
ctsmtmibMacRdfRxCts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctsmtmibMacRdfRxCts.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibMacRdfRxCts.setDescription('The count of Request Denied Frames received by the MAC.')
ctsmtmibMacRingOpCts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctsmtmibMacRingOpCts.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibMacRingOpCts.setDescription("The count of the number of times the ring has entered 'Ring Operational' state from the 'Ring Not Operational' state.")
ctsmtmibMacTxCts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctsmtmibMacTxCts.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibMacTxCts.setDescription('A count that should as closely as possible match the number of frames transmitted by this MAC.')
ctsmtmibMacRingMapUpdateCts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctsmtmibMacRingMapUpdateCts.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibMacRingMapUpdateCts.setDescription('The count of the number of times the ring map table has been updated.')
ctsmtmibMacAutoNegotiation = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctsmtmibMacAutoNegotiation.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibMacAutoNegotiation.setDescription('Indicates whether the station has auto-negotiation enabled or disabled.')
ctsmtmibAttachmentNumber = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctsmtmibAttachmentNumber.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibAttachmentNumber.setDescription("The total number of attachments (across all SMTs) on this network management application entity. The value for this variable must remain constant at least from one re-initialization of the entity's network management system to the next re-initialization.")
ctsmtmibAttachmentTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 4), )
if mibBuilder.loadTexts: ctsmtmibAttachmentTable.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibAttachmentTable.setDescription('A list of Attachment entries. The number of entries is given by the value of fdmimAttachmentNumber.')
ctsmtmibAttachmentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 4, 1), ).setIndexNames((0, "CTSMTMIB-MIB", "ctsmtmibAttachmentSMTIndex"), (0, "CTSMTMIB-MIB", "ctsmtmibAttachmentIndex"))
if mibBuilder.loadTexts: ctsmtmibAttachmentEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibAttachmentEntry.setDescription("An Attachment entry containing information common to a given set of Attachments. There is a natural association of Attachment resource indices to the PORT Indices. The resource index for the Attachment is equal to the associated port index for 'single-attachment' and 'concentrator' type fdmimAttachmentClasses. For 'dual-attachment' classes, the Attachment Index is the PORT Index of the A PORT of the A/B PORT pair that represents the Attachment.")
ctsmtmibAttachmentSMTIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctsmtmibAttachmentSMTIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibAttachmentSMTIndex.setDescription('The value of the SMT index associated with this Attachment.')
ctsmtmibAttachmentIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctsmtmibAttachmentIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibAttachmentIndex.setDescription('A unique value for each Attachment on a given SMT. ')
ctsmtmibAttachmentClass = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("single-attachment", 1), ("dual-attachment", 2), ("concentrator", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctsmtmibAttachmentClass.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibAttachmentClass.setDescription('The Attachment class. This represents a PORT or a pair of PORTs plus the associated optional optical bypass that are managed as a functional unit. The PORT associations are the following unit. single-attachment - S Ports dual-attachment - A/B Port pairs concentrator - M Ports ')
ctsmtmibAttachmentOpticalBypassPresent = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctsmtmibAttachmentOpticalBypassPresent.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibAttachmentOpticalBypassPresent.setDescription("The value of this is false for 'single-attachment' . Correct operation of CMT for single-attachments requires that a bypass function must not loopback the network side of the MIC, but only the node side.")
ctsmtmibAttachmentIMaxExpiration = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 4, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctsmtmibAttachmentIMaxExpiration.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibAttachmentIMaxExpiration.setDescription('I_Max (refer to ANSI SMT 9.4.4.2.1). Systems not implementing optical bypass should return a value of 0. Else the value should be returned in the granularity of 80ns.')
ctsmtmibAttachmentInsertedStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("true", 1), ("false", 2), ("unimplemented", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctsmtmibAttachmentInsertedStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibAttachmentInsertedStatus.setDescription('Indicates whether the attachment is currently inserted in the node.')
ctsmtmibAttachmentInsertPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 4, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("true", 1), ("false", 2), ("unimplemented", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctsmtmibAttachmentInsertPolicy.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibAttachmentInsertPolicy.setDescription('Indicates the Insert Policy for this Attachment.')
ctsmtmibSMTTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 5), )
if mibBuilder.loadTexts: ctsmtmibSMTTable.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibSMTTable.setDescription('Describes the dual homed status for SMT entries.')
ctsmtmibSMTEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 5, 1), ).setIndexNames((0, "CTSMTMIB-MIB", "ctsmtmibSmtIndex"))
if mibBuilder.loadTexts: ctsmtmibSMTEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibSMTEntry.setDescription('A specific dual homed SMT entry.')
ctsmtmibSMTDualHomeStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 5, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notDualHomed", 1), ("linkAorB", 2), ("linkAandB", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctsmtmibSMTDualHomeStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibSMTDualHomeStatus.setDescription('Indicates the current dual homed link status for a given SMT instance. notDualHomed(1) - This SMT is not dual homed. linkAorB(2) - Dual homed with link on A and no link link on B, or link on B and no link on A. linkAandB(3) - Dual homed with link on A and B.')
ctsmtmibSMTDualHomeWrpLEDStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('on')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctsmtmibSMTDualHomeWrpLEDStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibSMTDualHomeWrpLEDStatus.setDescription('When on, the WRAP LED will be illuminated when the node is in a dual homed configuration with link on the A, B or both A and B ports. When off, the WRAP LED will not be illuminated when the node is in a dual homed configuration with link on A and B, but will be illuminated when in a dual homed configuration with no link on A or B.')
ctsmtmibSmtIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 5, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctsmtmibSmtIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibSmtIndex.setDescription('Specifies the particular SMT entry.')
mibBuilder.exportSymbols("CTSMTMIB-MIB", ctsmtmibRingMasterCount=ctsmtmibRingMasterCount, ctsmtmibMacTable=ctsmtmibMacTable, ctsmtmibMacRdfTxCts=ctsmtmibMacRdfTxCts, ctsmtmibAttachmentSMTIndex=ctsmtmibAttachmentSMTIndex, ctsmtmibRingMacAddr=ctsmtmibRingMacAddr, ctsmtmibSMTDualHomeWrpLEDStatus=ctsmtmibSMTDualHomeWrpLEDStatus, ctsmtmibRingNodeIndex=ctsmtmibRingNodeIndex, ctsmtmibAttachmentTable=ctsmtmibAttachmentTable, ctsmtmibAttachmentEntry=ctsmtmibAttachmentEntry, ctsmtmibMacSifTxCts=ctsmtmibMacSifTxCts, ctsmtmibSMTDualHomeStatus=ctsmtmibSMTDualHomeStatus, ctsmtmibRingDuplicate=ctsmtmibRingDuplicate, ctsmtmibRingMacCount=ctsmtmibRingMacCount, ctsmtmibMacRdfRxCts=ctsmtmibMacRdfRxCts, ctsmtmibRingMacIndex=ctsmtmibRingMacIndex, ctsmtmibRingTopology=ctsmtmibRingTopology, ctsmtmibAttachmentOpticalBypassPresent=ctsmtmibAttachmentOpticalBypassPresent, ctsmtmibMacTxCts=ctsmtmibMacTxCts, ctsmtmibRingEntry=ctsmtmibRingEntry, ctsmtmibAttachmentInsertPolicy=ctsmtmibAttachmentInsertPolicy, ctsmtmibAttachmentIMaxExpiration=ctsmtmibAttachmentIMaxExpiration, ctsmtmibRingSmtIndex=ctsmtmibRingSmtIndex, ctsmtmibSMTEntry=ctsmtmibSMTEntry, ctsmtmibRingNodeClass=ctsmtmibRingNodeClass, ctsmtmibMacEntry=ctsmtmibMacEntry, ctsmtmibMacSmtIndex=ctsmtmibMacSmtIndex, ctsmtmibAttachmentInsertedStatus=ctsmtmibAttachmentInsertedStatus, ctsmtmibMacNifTxCts=ctsmtmibMacNifTxCts, ctsmtmibMacNifRxCts=ctsmtmibMacNifRxCts, ctsmtmibMacEcfTxCts=ctsmtmibMacEcfTxCts, ctsmtmibSMTTable=ctsmtmibSMTTable, ctsmtmibMacIndex=ctsmtmibMacIndex, ctsmtmibMacSifRxCts=ctsmtmibMacSifRxCts, ctsmtmibRingNonMasterCount=ctsmtmibRingNonMasterCount, ctsmtmibMacPmfTxCts=ctsmtmibMacPmfTxCts, ctsmtmibMacRingMapUpdateCts=ctsmtmibMacRingMapUpdateCts, ctsmtmibMacAutoNegotiation=ctsmtmibMacAutoNegotiation, ctsmtmibMacEcfRxCts=ctsmtmibMacEcfRxCts, ctsmtmibAttachmentIndex=ctsmtmibAttachmentIndex, ctsmtmibRingUpStreamAddr=ctsmtmibRingUpStreamAddr, ctsmtmibRingTable=ctsmtmibRingTable, ctsmtmibSmtIndex=ctsmtmibSmtIndex, ctsmtmibMacPmfRxCts=ctsmtmibMacPmfRxCts, ctsmtmibMacRingOpCts=ctsmtmibMacRingOpCts, ctsmtmibAttachmentNumber=ctsmtmibAttachmentNumber, ctsmtmibAttachmentClass=ctsmtmibAttachmentClass)

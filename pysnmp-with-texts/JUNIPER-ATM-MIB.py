#
# PySNMP MIB module JUNIPER-ATM-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/JUNIPER-ATM-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:58:53 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ConstraintsUnion, ValueSizeConstraint, ValueRangeConstraint, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "ValueSizeConstraint", "ValueRangeConstraint", "SingleValueConstraint")
atmInterfaceConfEntry, atmVclEntry, atmVplEntry = mibBuilder.importSymbols("ATM-MIB", "atmInterfaceConfEntry", "atmVclEntry", "atmVplEntry")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
InetAddressIPv6, InetAddressIPv4 = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressIPv6", "InetAddressIPv4")
jnxMibs, = mibBuilder.importSymbols("JUNIPER-SMI", "jnxMibs")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
TimeTicks, Integer32, iso, Bits, Unsigned32, Counter32, ObjectIdentity, NotificationType, Counter64, IpAddress, MibScalar, MibTable, MibTableRow, MibTableColumn, Gauge32, MibIdentifier, ModuleIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "TimeTicks", "Integer32", "iso", "Bits", "Unsigned32", "Counter32", "ObjectIdentity", "NotificationType", "Counter64", "IpAddress", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Gauge32", "MibIdentifier", "ModuleIdentity")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
jnxAtm = ModuleIdentity((1, 3, 6, 1, 4, 1, 2636, 3, 10))
jnxAtm.setRevisions(('2004-01-06 00:00', '2003-12-04 00:00', '2003-09-17 00:00', '2002-07-04 00:00', '2002-01-23 00:00', '2001-07-08 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: jnxAtm.setRevisionsDescriptions(('The following new objects were added: - jnxAtmVCOutOAMF5AISCells (jnxAtmVCTable). - jnxAtmTrunkOutOAMF4AISCells (jnxAtmTrunkTable).', "New object 'jnxAtmIfL2CircuitMode' added to jnxAtmIfTable.", "New table 'jnxAtmTrunkTable' added.", "New table 'jnxAtmVpTable' added.", 'Renamed atmTcc as atmTccVcMux. atmTccSnap encapsulation added.', 'Initial Version',))
if mibBuilder.loadTexts: jnxAtm.setLastUpdated('200312040000Z')
if mibBuilder.loadTexts: jnxAtm.setOrganization('Juniper Networks, Inc.')
if mibBuilder.loadTexts: jnxAtm.setContactInfo('Juniper Technical Assistance Center Juniper Networks, Inc. 1194 N. Mathilda Avenue Sunnyvale, CA 94089 E-mail: support@juniper.net')
if mibBuilder.loadTexts: jnxAtm.setDescription('The Juniper enterprise MIB for ATM interfaces and VCs')
class JnxAtmFlags(TextualConvention, Bits):
    description = 'Flags related to the VC or Trunk.'
    status = 'current'
    namedValues = NamedValues(("inverseArpEnabled", 0), ("ilmiEnabled", 1), ("oamEnabled", 2), ("shapingEnabled", 3), ("passiveOam", 4), ("multicast", 5), ("closed", 6), ("down", 7), ("active", 8), ("cosEnabled", 9))

jnxAtmIfTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 10, 1), )
if mibBuilder.loadTexts: jnxAtmIfTable.setStatus('current')
if mibBuilder.loadTexts: jnxAtmIfTable.setDescription('This table contains config and stats parameters, one entry per physical interface (ATM port).')
jnxAtmIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 10, 1, 1), )
atmInterfaceConfEntry.registerAugmentions(("JUNIPER-ATM-MIB", "jnxAtmIfEntry"))
jnxAtmIfEntry.setIndexNames(*atmInterfaceConfEntry.getIndexNames())
if mibBuilder.loadTexts: jnxAtmIfEntry.setStatus('current')
if mibBuilder.loadTexts: jnxAtmIfEntry.setDescription('This entry contains additional ATM interface config and stats objects, not covered in standard mibs. Each entry is an extension of atmInterfaceConfEntry defined in ATM-MIB.')
jnxAtmIfPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("oc3", 2), ("oc12", 3), ("t3", 4), ("e3", 5), ("oc48", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmIfPortType.setStatus('current')
if mibBuilder.loadTexts: jnxAtmIfPortType.setDescription('The physical port type.')
jnxAtmIfEncaps = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("atmPvc", 2), ("atmCccCellRelay", 3))).clone('atmPvc')).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmIfEncaps.setStatus('current')
if mibBuilder.loadTexts: jnxAtmIfEncaps.setDescription('ATM physical link layer encapsulation.')
jnxAtmIfLpBackInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noLoopBack", 1), ("localLoopBack", 2), ("remoteLoopBack", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmIfLpBackInfo.setStatus('current')
if mibBuilder.loadTexts: jnxAtmIfLpBackInfo.setDescription('Loop back config and type.')
jnxAtmIfScrambleEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmIfScrambleEnable.setStatus('current')
if mibBuilder.loadTexts: jnxAtmIfScrambleEnable.setDescription('Shows whether scrambling is enabled or disabled')
jnxAtmIfTxCellCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 1, 1, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmIfTxCellCount.setStatus('current')
if mibBuilder.loadTexts: jnxAtmIfTxCellCount.setDescription('The number of ATM cells transmitted by the interface. Includes Idle cells transmitted.')
jnxAtmIfRxCellCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 1, 1, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmIfRxCellCount.setStatus('current')
if mibBuilder.loadTexts: jnxAtmIfRxCellCount.setDescription('The number of ATM cells received by the interface. Excludes Idle cells received.')
jnxAtmIfTxIdleCellCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 1, 1, 7), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmIfTxIdleCellCount.setStatus('current')
if mibBuilder.loadTexts: jnxAtmIfTxIdleCellCount.setDescription('The number of idle cells sent by the port. When the ATM interface has nothing to send, it sends idle cells to fill the time slot.')
jnxAtmIfUncorrHCSErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 1, 1, 8), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmIfUncorrHCSErrs.setStatus('current')
if mibBuilder.loadTexts: jnxAtmIfUncorrHCSErrs.setDescription('The number of uncorrectable cell Header Check Sequence (HCS) Errors that occurred.')
jnxAtmIfCorrHCSErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 1, 1, 9), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmIfCorrHCSErrs.setStatus('current')
if mibBuilder.loadTexts: jnxAtmIfCorrHCSErrs.setDescription('The number of correctable cell Header Check Sequence (HCS) Errors that occurred.')
jnxAtmIfTxCellFIFOOverRuns = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 1, 1, 10), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmIfTxCellFIFOOverRuns.setStatus('current')
if mibBuilder.loadTexts: jnxAtmIfTxCellFIFOOverRuns.setDescription('The number of overruns in the Transmit FIFO.')
jnxAtmIfRxCellFIFOOverRuns = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 1, 1, 11), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmIfRxCellFIFOOverRuns.setStatus('current')
if mibBuilder.loadTexts: jnxAtmIfRxCellFIFOOverRuns.setDescription('The number of overruns in the Receive FIFO.')
jnxAtmIfRxCellFIFOUnderRuns = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 1, 1, 12), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmIfRxCellFIFOUnderRuns.setStatus('current')
if mibBuilder.loadTexts: jnxAtmIfRxCellFIFOUnderRuns.setDescription('The number of underruns in the receive FIFO.')
jnxAtmIfInInvalidVCCells = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 1, 1, 13), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmIfInInvalidVCCells.setStatus('current')
if mibBuilder.loadTexts: jnxAtmIfInInvalidVCCells.setDescription('The number of Cells that arrived for non existent VC.')
jnxAtmIfInNoBufferOAMCells = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 1, 1, 14), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmIfInNoBufferOAMCells.setStatus('current')
if mibBuilder.loadTexts: jnxAtmIfInNoBufferOAMCells.setDescription('The number of received OAM cells or raw cells dropped because no buffers were available to handle them.')
jnxAtmIfInNoBufDropPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 1, 1, 15), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmIfInNoBufDropPkts.setStatus('current')
if mibBuilder.loadTexts: jnxAtmIfInNoBufDropPkts.setDescription('The number of AAL5 packets dropped because there was no enough buffer to handle them.')
jnxAtmIfOutVCQueueDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 1, 1, 16), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmIfOutVCQueueDrops.setStatus('current')
if mibBuilder.loadTexts: jnxAtmIfOutVCQueueDrops.setDescription('The number of packets dropped because of queue limits on each VC.')
jnxAtmIfInBadCrcs = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 1, 1, 17), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmIfInBadCrcs.setStatus('current')
if mibBuilder.loadTexts: jnxAtmIfInBadCrcs.setDescription('The total number of incoming CRC errors.')
jnxAtmIfInLenErrPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 1, 1, 18), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmIfInLenErrPkts.setStatus('current')
if mibBuilder.loadTexts: jnxAtmIfInLenErrPkts.setDescription('The number of AAL5 packets dropped because their length was incorrect.')
jnxAtmIfInTimeoutPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 1, 1, 19), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmIfInTimeoutPkts.setStatus('current')
if mibBuilder.loadTexts: jnxAtmIfInTimeoutPkts.setDescription('The number of AAL5 packets dropped because of reassembly timeout.')
jnxAtmIfL2CircuitMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("notApplicable", 1), ("none", 2), ("aal5", 3), ("cell", 4), ("uniTrunk", 5), ("nniTrunk", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmIfL2CircuitMode.setStatus('current')
if mibBuilder.loadTexts: jnxAtmIfL2CircuitMode.setDescription('The layer 2 circuit mode of this Atm interface. Note, this applies only to interfaces on AtmII pics.')
jnxAtmVCTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 10, 2), )
if mibBuilder.loadTexts: jnxAtmVCTable.setStatus('current')
if mibBuilder.loadTexts: jnxAtmVCTable.setDescription('A table of all p2p/p2mp/multicast VC entries.')
jnxAtmVCEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 10, 2, 1), )
atmVclEntry.registerAugmentions(("JUNIPER-ATM-MIB", "jnxAtmVCEntry"))
jnxAtmVCEntry.setIndexNames(*atmVclEntry.getIndexNames())
if mibBuilder.loadTexts: jnxAtmVCEntry.setStatus('current')
if mibBuilder.loadTexts: jnxAtmVCEntry.setDescription("Special Cases: - No traffic Stats for multicast VCs. (0 by default). - Multipoint Destination IP Address for a p2p vc is invalid (0.0.0.0 by default). - When the encapsulation type for the logical interface (to which VC belongs) is 'atmCccCellRelay', only Generic VC Info is valid. - If OAM is disabled (indicated in jnxAtmVCFlags), then all the OAM config & F5 stats info is invalid. (zeroed by default).")
jnxAtmVCConnType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("p2p", 2), ("p2mp", 3), ("multicast", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVCConnType.setStatus('current')
if mibBuilder.loadTexts: jnxAtmVCConnType.setDescription("The type of connection. The type 'other' means vc type is unknown or is not one of the other types.")
jnxAtmVCEncapsulation = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("other", 1), ("atmCccCellRelay", 2), ("atmCccVcMux", 3), ("atmCiscoNlpid", 4), ("atmNlpid", 5), ("atmSnap", 6), ("atmVcMux", 7), ("atmTccVcMux", 8), ("atmTccSnap", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVCEncapsulation.setStatus('current')
if mibBuilder.loadTexts: jnxAtmVCEncapsulation.setDescription('The atm encapsulation type associated with the VC. atmCccCellRelay : ATM Cell Relay for CCC atmCccVcMux : ATM VC for CCC atmCiscoNlpid : Cisco-compatible ATM NLPID encapsulation atmNlpid : ATM NLPID encapsulation atmSnap : ATM LLC/SNAP encapsulation atmVcMux : ATM VC multiplexing atmTccVcMux : TCC (Translational Cross Connection) over ATM VC MUX encapsulation atmTccSnap : TCC (Translational Cross Connection) over ATM LLC/SNAP encapsulation')
jnxAtmVCMpDestIPv4Addr = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 2, 1, 3), InetAddressIPv4()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVCMpDestIPv4Addr.setStatus('current')
if mibBuilder.loadTexts: jnxAtmVCMpDestIPv4Addr.setDescription("This object is meaningful only if jnxAtmVCConnType value is 'p2mp' (point-to-multipoint). For a p2mp VC, it's the multipoint destination IPv4 address. When the VC connection type is other than p2mp OR when the multipoint destination address type is of IPv6, this object returns 0.0.0.0 by default.")
jnxAtmVCMpDestIPv6Addr = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 2, 1, 4), InetAddressIPv6()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVCMpDestIPv6Addr.setStatus('current')
if mibBuilder.loadTexts: jnxAtmVCMpDestIPv6Addr.setDescription("This object is meaningful only if jnxAtmVCConnType value is 'p2mp' (point-to-multipoint). For a p2mp VC, it's the multipoint destination IPv6 address. When the VC connection type is other than p2mp OR when the multipoint destination address type is of IPv4, this object returns all the bytes of addr filled with 0.")
jnxAtmVCFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 2, 1, 5), JnxAtmFlags()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVCFlags.setStatus('current')
if mibBuilder.loadTexts: jnxAtmVCFlags.setDescription('Flags related to the VC.')
jnxAtmVCTotalDownTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVCTotalDownTime.setStatus('current')
if mibBuilder.loadTexts: jnxAtmVCTotalDownTime.setDescription('The total VC down time in seconds ever since the system rebooted.')
jnxAtmVCInBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 2, 1, 7), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVCInBytes.setStatus('current')
if mibBuilder.loadTexts: jnxAtmVCInBytes.setDescription('The number of bytes received on the VC.')
jnxAtmVCOutBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 2, 1, 8), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVCOutBytes.setStatus('current')
if mibBuilder.loadTexts: jnxAtmVCOutBytes.setDescription('The number of bytes sent out on the VC.')
jnxAtmVCInPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 2, 1, 9), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVCInPkts.setStatus('current')
if mibBuilder.loadTexts: jnxAtmVCInPkts.setDescription('The number of packets received on the VC.')
jnxAtmVCOutPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 2, 1, 10), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVCOutPkts.setStatus('current')
if mibBuilder.loadTexts: jnxAtmVCOutPkts.setDescription('The number of packets sent out on the VC.')
jnxAtmVCTailQueuePktDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 2, 1, 11), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVCTailQueuePktDrops.setStatus('current')
if mibBuilder.loadTexts: jnxAtmVCTailQueuePktDrops.setDescription('The number of packets dropped due to bandwidth constraints. Indicates that packets were queued to send out at a rate faster than allowed.')
jnxAtmVCOAMPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 2, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVCOAMPeriod.setStatus('current')
if mibBuilder.loadTexts: jnxAtmVCOAMPeriod.setDescription('This time interval indicates how often the F5 cells are sent to know the status of the VC.')
jnxAtmVCOAMUpCellCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 2, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVCOAMUpCellCount.setStatus('current')
if mibBuilder.loadTexts: jnxAtmVCOAMUpCellCount.setDescription('The minimum number of loopback cells to be received to declare that the VC is up.')
jnxAtmVCOAMDownCellCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 2, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVCOAMDownCellCount.setStatus('current')
if mibBuilder.loadTexts: jnxAtmVCOAMDownCellCount.setDescription('The minimum number of loopback cells to be received to declare that the VC is down. This object would have zero value if OAM is not enabled. (indicated in jnxAtmVCFlags)')
jnxAtmVCInOAMF5LoopCells = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVCInOAMF5LoopCells.setStatus('current')
if mibBuilder.loadTexts: jnxAtmVCInOAMF5LoopCells.setDescription('The number of OAM F5 loopback cells received. This object would have zero value if OAM (as indicated in jnxAtmVCFlags) is not enabled.')
jnxAtmVCOutOAMF5LoopCells = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 2, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVCOutOAMF5LoopCells.setStatus('current')
if mibBuilder.loadTexts: jnxAtmVCOutOAMF5LoopCells.setDescription('The number of OAM F5 loopback cells sent. This object would have zero value if OAM (as indicated in jnxAtmVCFlags) is not enabled.')
jnxAtmVCInOAMF5RDICells = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 2, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVCInOAMF5RDICells.setStatus('current')
if mibBuilder.loadTexts: jnxAtmVCInOAMF5RDICells.setDescription('The number of OAM F5 cells received, with RDI(Remote Defect Indication) bit set. This object would have zero value if OAM (as indicated in jnxAtmVCFlags) is not enabled.')
jnxAtmVCOutOAMF5RDICells = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 2, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVCOutOAMF5RDICells.setStatus('current')
if mibBuilder.loadTexts: jnxAtmVCOutOAMF5RDICells.setDescription('The number of OAM F5 cells transmitted, with RDI(Remote Defect Indication) bit set. This object would have zero value if OAM (as indicated in jnxAtmVCFlags) is not enabled.')
jnxAtmVCInOAMF5AISCells = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 2, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVCInOAMF5AISCells.setStatus('current')
if mibBuilder.loadTexts: jnxAtmVCInOAMF5AISCells.setDescription('The number of OAM F5 cells received, with AIS(Alarm Indication Signal) bit set. This object would have zero value if OAM (as indicated in jnxAtmVCFlags) is not enabled.')
jnxAtmVCOutOAMF5AISCells = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 2, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVCOutOAMF5AISCells.setStatus('current')
if mibBuilder.loadTexts: jnxAtmVCOutOAMF5AISCells.setDescription('The number of OAM F5 cells transmitted, with AIS (Alarm Indication Signal) bit set. This object would have zero value if OAM (as indicated in jnxAtmVCFlags) is not enabled.')
jnxAtmVpTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 10, 3), )
if mibBuilder.loadTexts: jnxAtmVpTable.setStatus('current')
if mibBuilder.loadTexts: jnxAtmVpTable.setDescription('The table of ATM VPs. This table augments atmVplTable defined in standard ATM mib.')
jnxAtmVpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 10, 3, 1), )
atmVplEntry.registerAugmentions(("JUNIPER-ATM-MIB", "jnxAtmVpEntry"))
jnxAtmVpEntry.setIndexNames(*atmVplEntry.getIndexNames())
if mibBuilder.loadTexts: jnxAtmVpEntry.setStatus('current')
if mibBuilder.loadTexts: jnxAtmVpEntry.setDescription("Each entry represents config, status and statistics info related to an ATM VP configured. This entry augments the atmVplEntry defined in standard ATM mib (RFC 2515). So ifIndex and VPI are the indices to this table. Caveats: - Traffic stats are available per VP tunnel, only if shaping is configured on the VP. Object 'jnxAtmVpFlags' can be used to determine if shaping is enabled. - When no OAM is configured, OAM config and OAM stat objects' values are invalid (zero by default). Object 'jnxAtmVpFlags' contains info on whether OAM is configured or not. - For atm-1 VPs, the only valid object is jnxAtmVpFlags.")
jnxAtmVpFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 3, 1, 1), Bits().clone(namedValues=NamedValues(("active", 0), ("down", 1), ("oamEnabled", 2), ("shapingEnabled", 3), ("passiveOam", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVpFlags.setStatus('current')
if mibBuilder.loadTexts: jnxAtmVpFlags.setDescription('The flags associated with this VP.')
jnxAtmVpTotalDownTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVpTotalDownTime.setStatus('current')
if mibBuilder.loadTexts: jnxAtmVpTotalDownTime.setDescription('The total VP downtime in seconds, ever since the system rebooted.')
jnxAtmVpOamPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVpOamPeriod.setStatus('current')
if mibBuilder.loadTexts: jnxAtmVpOamPeriod.setDescription("This time interval indicates how often the OAM F4 cells are sent to determine the status of the VP. The value of this object is zero when OAM is not enabled on the VP. Object 'jnxAtmVpFlags' can be used to determine if OAM is enabled.")
jnxAtmVpOamUpCellCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 3, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVpOamUpCellCount.setStatus('current')
if mibBuilder.loadTexts: jnxAtmVpOamUpCellCount.setDescription("The minimum number of consecutive loopback cells to be received to declare that the VP is up. The value of this object is zero when OAM is not enabled on the VP. Object 'jnxAtmVpFlags' can be used to determine if OAM is enabled.")
jnxAtmVpOamDownCellCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 3, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVpOamDownCellCount.setStatus('current')
if mibBuilder.loadTexts: jnxAtmVpOamDownCellCount.setDescription("The minimum number of consecutive loopback cells to be received to declare that the VP is down. The value of this object is zero when OAM is not enabled on the VP. Object 'jnxAtmVpFlags' can be used to determine if OAM is enabled.")
jnxAtmVpInBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 3, 1, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVpInBytes.setStatus('current')
if mibBuilder.loadTexts: jnxAtmVpInBytes.setDescription('The number of bytes received on the VP.')
jnxAtmVpOutBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 3, 1, 7), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVpOutBytes.setStatus('current')
if mibBuilder.loadTexts: jnxAtmVpOutBytes.setDescription('The number of bytes sent out on the VP.')
jnxAtmVpInPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 3, 1, 8), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVpInPkts.setStatus('current')
if mibBuilder.loadTexts: jnxAtmVpInPkts.setDescription('The number of packets received on the VP.')
jnxAtmVpOutPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 3, 1, 9), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVpOutPkts.setStatus('current')
if mibBuilder.loadTexts: jnxAtmVpOutPkts.setDescription('The number of packets sent out on the VP.')
jnxAtmVpInOamF4Cells = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 3, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVpInOamF4Cells.setStatus('current')
if mibBuilder.loadTexts: jnxAtmVpInOamF4Cells.setDescription('The number of OAM F4 cells received on the VP.')
jnxAtmVpOutOamF4Cells = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 3, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVpOutOamF4Cells.setStatus('current')
if mibBuilder.loadTexts: jnxAtmVpOutOamF4Cells.setDescription('The number of OAM F4 cells transmitted on the VP.')
jnxAtmVpInOamF4LoopCells = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 3, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVpInOamF4LoopCells.setStatus('current')
if mibBuilder.loadTexts: jnxAtmVpInOamF4LoopCells.setDescription('The number of OAM F4 loopback cells received on the VP.')
jnxAtmVpOutOamF4LoopCells = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 3, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVpOutOamF4LoopCells.setStatus('current')
if mibBuilder.loadTexts: jnxAtmVpOutOamF4LoopCells.setDescription('The number of OAM F4 cells transmitted on the VP.')
jnxAtmVpInOamF4RdiCells = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 3, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVpInOamF4RdiCells.setStatus('current')
if mibBuilder.loadTexts: jnxAtmVpInOamF4RdiCells.setDescription('The number of OAM F4 RDI cells received on the VP.')
jnxAtmVpOutOamF4RdiCells = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 3, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVpOutOamF4RdiCells.setStatus('current')
if mibBuilder.loadTexts: jnxAtmVpOutOamF4RdiCells.setDescription('The number of OAM F4 RDI cells transmitted on the VP.')
jnxAtmVpInOamF4AisCells = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 3, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVpInOamF4AisCells.setStatus('current')
if mibBuilder.loadTexts: jnxAtmVpInOamF4AisCells.setDescription('The number of OAM F4 AIS cells received on the VP.')
jnxAtmTrunkTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 10, 4), )
if mibBuilder.loadTexts: jnxAtmTrunkTable.setStatus('current')
if mibBuilder.loadTexts: jnxAtmTrunkTable.setDescription('A table of all ATM Trunk entries.')
jnxAtmTrunkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 10, 4, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: jnxAtmTrunkEntry.setStatus('current')
if mibBuilder.loadTexts: jnxAtmTrunkEntry.setDescription("Special Cases: - When the encapsulation type for the logical interface (to which Trunk belongs) is 'atmCccCellRelay', only Generic Trunk Info is valid.")
jnxAtmTrunkId = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmTrunkId.setStatus('current')
if mibBuilder.loadTexts: jnxAtmTrunkId.setDescription('The identifier for this ATM Trunk.')
jnxAtmTrunkConnType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("p2p", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmTrunkConnType.setStatus('current')
if mibBuilder.loadTexts: jnxAtmTrunkConnType.setDescription("The type of connection. The type 'other' means trunk type is unknown or is not one of the other types.")
jnxAtmTrunkEncapsulation = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("atmCccCellRelay", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmTrunkEncapsulation.setStatus('current')
if mibBuilder.loadTexts: jnxAtmTrunkEncapsulation.setDescription('The atm encapsulation type associated with the VC or Trunk. atmCccCellRelay : ATM Cell Relay for CCC')
jnxAtmTrunkFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 4, 1, 4), JnxAtmFlags()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmTrunkFlags.setStatus('current')
if mibBuilder.loadTexts: jnxAtmTrunkFlags.setDescription('Flags related to the Trunk.')
jnxAtmTrunkTotalDownTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 4, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmTrunkTotalDownTime.setStatus('current')
if mibBuilder.loadTexts: jnxAtmTrunkTotalDownTime.setDescription('The total Trunk down time in seconds ever since the system rebooted.')
jnxAtmTrunkInBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 4, 1, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmTrunkInBytes.setStatus('current')
if mibBuilder.loadTexts: jnxAtmTrunkInBytes.setDescription('The number of bytes received on the Trunk.')
jnxAtmTrunkOutBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 4, 1, 7), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmTrunkOutBytes.setStatus('current')
if mibBuilder.loadTexts: jnxAtmTrunkOutBytes.setDescription('The number of bytes sent out on the Trunk.')
jnxAtmTrunkInPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 4, 1, 8), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmTrunkInPkts.setStatus('current')
if mibBuilder.loadTexts: jnxAtmTrunkInPkts.setDescription('The number of packets received on the Trunk.')
jnxAtmTrunkOutPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 4, 1, 9), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmTrunkOutPkts.setStatus('current')
if mibBuilder.loadTexts: jnxAtmTrunkOutPkts.setDescription('The number of packets sent out on the Trunk.')
jnxAtmTrunkTailQueuePktDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 4, 1, 10), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmTrunkTailQueuePktDrops.setStatus('current')
if mibBuilder.loadTexts: jnxAtmTrunkTailQueuePktDrops.setDescription('The number of packets dropped due to bandwidth constraints. Indicates that packets were queued to send out at a rate faster than allowed.')
jnxAtmTrunkInOAMF4AISCells = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 4, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmTrunkInOAMF4AISCells.setStatus('current')
if mibBuilder.loadTexts: jnxAtmTrunkInOAMF4AISCells.setDescription('The number of OAM F4 cells received, with AIS(Alarm Indication Signal) bit set.')
jnxAtmTrunkOutOAMF4AISCells = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 4, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmTrunkOutOAMF4AISCells.setStatus('current')
if mibBuilder.loadTexts: jnxAtmTrunkOutOAMF4AISCells.setDescription('The number of OAM F4 cells sent, with AIS(Alarm Indication Signal) bit set.')
mibBuilder.exportSymbols("JUNIPER-ATM-MIB", jnxAtmVCTable=jnxAtmVCTable, jnxAtmIfTxCellFIFOOverRuns=jnxAtmIfTxCellFIFOOverRuns, jnxAtmIfInBadCrcs=jnxAtmIfInBadCrcs, jnxAtmVCOAMDownCellCount=jnxAtmVCOAMDownCellCount, jnxAtmVpInPkts=jnxAtmVpInPkts, jnxAtmVCInOAMF5LoopCells=jnxAtmVCInOAMF5LoopCells, jnxAtmIfInTimeoutPkts=jnxAtmIfInTimeoutPkts, jnxAtmVCConnType=jnxAtmVCConnType, jnxAtmIfScrambleEnable=jnxAtmIfScrambleEnable, jnxAtmVCOAMPeriod=jnxAtmVCOAMPeriod, jnxAtmTrunkInPkts=jnxAtmTrunkInPkts, jnxAtmVCMpDestIPv6Addr=jnxAtmVCMpDestIPv6Addr, jnxAtmVCOutPkts=jnxAtmVCOutPkts, JnxAtmFlags=JnxAtmFlags, jnxAtmVCMpDestIPv4Addr=jnxAtmVCMpDestIPv4Addr, jnxAtmVCInBytes=jnxAtmVCInBytes, jnxAtmVpEntry=jnxAtmVpEntry, jnxAtmTrunkTable=jnxAtmTrunkTable, jnxAtmVpOutPkts=jnxAtmVpOutPkts, jnxAtmTrunkEntry=jnxAtmTrunkEntry, jnxAtmIfEncaps=jnxAtmIfEncaps, jnxAtmIfRxCellCount=jnxAtmIfRxCellCount, jnxAtmVpInOamF4LoopCells=jnxAtmVpInOamF4LoopCells, jnxAtmIfL2CircuitMode=jnxAtmIfL2CircuitMode, jnxAtmIfOutVCQueueDrops=jnxAtmIfOutVCQueueDrops, jnxAtmTrunkTotalDownTime=jnxAtmTrunkTotalDownTime, jnxAtmIfInNoBufDropPkts=jnxAtmIfInNoBufDropPkts, jnxAtmTrunkConnType=jnxAtmTrunkConnType, jnxAtmTrunkFlags=jnxAtmTrunkFlags, jnxAtmVCTailQueuePktDrops=jnxAtmVCTailQueuePktDrops, jnxAtmIfUncorrHCSErrs=jnxAtmIfUncorrHCSErrs, jnxAtmIfInNoBufferOAMCells=jnxAtmIfInNoBufferOAMCells, jnxAtmVCOutOAMF5AISCells=jnxAtmVCOutOAMF5AISCells, jnxAtmVpTotalDownTime=jnxAtmVpTotalDownTime, jnxAtmVpFlags=jnxAtmVpFlags, jnxAtmIfTxCellCount=jnxAtmIfTxCellCount, jnxAtmTrunkId=jnxAtmTrunkId, jnxAtmIfTable=jnxAtmIfTable, jnxAtmTrunkInOAMF4AISCells=jnxAtmTrunkInOAMF4AISCells, jnxAtmIfRxCellFIFOOverRuns=jnxAtmIfRxCellFIFOOverRuns, jnxAtmTrunkInBytes=jnxAtmTrunkInBytes, jnxAtmVCInOAMF5RDICells=jnxAtmVCInOAMF5RDICells, jnxAtmIfPortType=jnxAtmIfPortType, jnxAtmIfCorrHCSErrs=jnxAtmIfCorrHCSErrs, jnxAtmVCFlags=jnxAtmVCFlags, jnxAtm=jnxAtm, jnxAtmTrunkTailQueuePktDrops=jnxAtmTrunkTailQueuePktDrops, jnxAtmVpOutOamF4LoopCells=jnxAtmVpOutOamF4LoopCells, jnxAtmVpOutBytes=jnxAtmVpOutBytes, PYSNMP_MODULE_ID=jnxAtm, jnxAtmVpOamDownCellCount=jnxAtmVpOamDownCellCount, jnxAtmTrunkOutOAMF4AISCells=jnxAtmTrunkOutOAMF4AISCells, jnxAtmTrunkOutPkts=jnxAtmTrunkOutPkts, jnxAtmVpInBytes=jnxAtmVpInBytes, jnxAtmVCOAMUpCellCount=jnxAtmVCOAMUpCellCount, jnxAtmVCOutBytes=jnxAtmVCOutBytes, jnxAtmTrunkOutBytes=jnxAtmTrunkOutBytes, jnxAtmVpInOamF4RdiCells=jnxAtmVpInOamF4RdiCells, jnxAtmVCOutOAMF5RDICells=jnxAtmVCOutOAMF5RDICells, jnxAtmVCInPkts=jnxAtmVCInPkts, jnxAtmVCTotalDownTime=jnxAtmVCTotalDownTime, jnxAtmIfInLenErrPkts=jnxAtmIfInLenErrPkts, jnxAtmTrunkEncapsulation=jnxAtmTrunkEncapsulation, jnxAtmIfLpBackInfo=jnxAtmIfLpBackInfo, jnxAtmVpOutOamF4RdiCells=jnxAtmVpOutOamF4RdiCells, jnxAtmVCInOAMF5AISCells=jnxAtmVCInOAMF5AISCells, jnxAtmIfTxIdleCellCount=jnxAtmIfTxIdleCellCount, jnxAtmVpOamUpCellCount=jnxAtmVpOamUpCellCount, jnxAtmIfRxCellFIFOUnderRuns=jnxAtmIfRxCellFIFOUnderRuns, jnxAtmVpTable=jnxAtmVpTable, jnxAtmVpInOamF4AisCells=jnxAtmVpInOamF4AisCells, jnxAtmVpOutOamF4Cells=jnxAtmVpOutOamF4Cells, jnxAtmVpOamPeriod=jnxAtmVpOamPeriod, jnxAtmVCEntry=jnxAtmVCEntry, jnxAtmIfEntry=jnxAtmIfEntry, jnxAtmVCOutOAMF5LoopCells=jnxAtmVCOutOAMF5LoopCells, jnxAtmVpInOamF4Cells=jnxAtmVpInOamF4Cells, jnxAtmIfInInvalidVCCells=jnxAtmIfInInvalidVCCells, jnxAtmVCEncapsulation=jnxAtmVCEncapsulation)

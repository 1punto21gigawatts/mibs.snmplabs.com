#
# PySNMP MIB module DECHUB900-CHASSIS-MIB-V3-0 (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/DECHUB900-CHASSIS-MIB-V3-0
# Produced by pysmi-0.3.4 at Wed May  1 12:37:34 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsIntersection, SingleValueConstraint, ValueRangeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsIntersection", "SingleValueConstraint", "ValueRangeConstraint", "ConstraintsUnion")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Unsigned32, IpAddress, Counter64, NotificationType, ModuleIdentity, Counter32, MibScalar, MibTable, MibTableRow, MibTableColumn, Gauge32, TimeTicks, enterprises, MibIdentifier, Bits, iso, Integer32, ObjectIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "Unsigned32", "IpAddress", "Counter64", "NotificationType", "ModuleIdentity", "Counter32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Gauge32", "TimeTicks", "enterprises", "MibIdentifier", "Bits", "iso", "Integer32", "ObjectIdentity")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
dec = MibIdentifier((1, 3, 6, 1, 4, 1, 36))
ema = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2))
decMIBextension = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18))
decHub900 = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11))
mgmtAgent = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1))
mgmtAgentVersion1 = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1))
chassis = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1))
chasSlot = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 1))
chasEntity = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 2))
chasBackplane = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 3))
chasSegment = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 4))
chasConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 5))
chasPort = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 6))
chasPowerConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 7))
chasPowerSource = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 8))
chasPowerSink = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 9))
chasEnviron = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 10))
chasLoad = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 11))
chasLigo = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 13))
chasPatching = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 14))
chasNumSlots = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasNumSlots.setStatus('mandatory')
if mibBuilder.loadTexts: chasNumSlots.setDescription('The number of slots directly connected to this chassis. For example, a chassis implementation with 8 slots returns 8 when this object is requested.')
chasNumSlotsOccupied = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasNumSlotsOccupied.setStatus('mandatory')
if mibBuilder.loadTexts: chasNumSlotsOccupied.setDescription('The number of directly connected slots which are presently occupied.')
chasMaxExtendedSlots = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasMaxExtendedSlots.setStatus('mandatory')
if mibBuilder.loadTexts: chasMaxExtendedSlots.setDescription('The maximum number of extended slot numbers supported in this chassis mib.')
chasExtendedSlotsOccupied = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasExtendedSlotsOccupied.setStatus('mandatory')
if mibBuilder.loadTexts: chasExtendedSlotsOccupied.setDescription('The total number of extended slots presently attached.')
chasPopulationChanges = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasPopulationChanges.setStatus('mandatory')
if mibBuilder.loadTexts: chasPopulationChanges.setDescription('The total number of modules and extended modules which have been inserted and removed from the chassis. This counter is incremented: - when a module is inserted, and - when a module is removed. The goal of this object is to provide a single object which can be polled by an NMS to determine if there have been changes in the chassis population.')
chasSlotTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 1, 6), )
if mibBuilder.loadTexts: chasSlotTable.setStatus('mandatory')
if mibBuilder.loadTexts: chasSlotTable.setDescription('A table that contains information about the slots in the chassis.')
chasSlotEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 1, 6, 1), ).setIndexNames((0, "DECHUB900-CHASSIS-MIB-V3-0", "chasSlotIndex"))
if mibBuilder.loadTexts: chasSlotEntry.setStatus('mandatory')
if mibBuilder.loadTexts: chasSlotEntry.setDescription('A list of information for each slot in the chassis. Table rows may not be created or deleted with SNMP operations.')
chasSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 1, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 899999999))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: chasSlotIndex.setDescription('The number of the slot that the module occupies. Note that this index may exceed chasNumSlots if: - extended slots are present in the chassis, or - an integral component such as a management module is present in the chassis.')
chasSlotModuleType = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 1, 6, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasSlotModuleType.setStatus('mandatory')
if mibBuilder.loadTexts: chasSlotModuleType.setDescription("The sysObjectID of the module which occupies the slot. Besides sysObjectIDs, the value of this object may contain chasSlotUnknown or chasSlotBlocked. chasSlotUnknown (1.3.6.1.4.1.36.2.18.11.1.1.12.1.2) is used to describe a slot which contains a module which is for some reason 'unknown'. chasSlotBlocked (1.3.6.1.4.1.36.2.18.11.1.1.12.1.3) is used to describe a slot which is not usable because a double, triple, etc. width module prevents its use.")
chasSlotLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 1, 6, 1, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasSlotLastChange.setStatus('mandatory')
if mibBuilder.loadTexts: chasSlotLastChange.setDescription("The value of MIB-II's sysUpTime (in the agent supporting this chassis MIB) at which a module was last inserted into this slot.")
chasSlotModuleDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 1, 6, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasSlotModuleDescr.setStatus('mandatory')
if mibBuilder.loadTexts: chasSlotModuleDescr.setDescription('A textual description of the module inserted into the slot. If no description is available, this value is a zero length string. No description may be available if the module reports a chasSlotModuleAdminStaus of fatal-error.')
chasSlotModuleVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 1, 6, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasSlotModuleVersion.setStatus('mandatory')
if mibBuilder.loadTexts: chasSlotModuleVersion.setDescription("A textual description of the version/revision level for this module's hardware and firmware. If not available, this value is a zero-length string.")
chasSlotModuleSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 1, 6, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasSlotModuleSerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: chasSlotModuleSerialNumber.setDescription('The serial number of the module present in the slot. If no serial number is available for a module, this value is a zero length string.')
chasSlotModuleSize = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 1, 6, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("min", 1), ("max", 2), ("system", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasSlotModuleSize.setStatus('mandatory')
if mibBuilder.loadTexts: chasSlotModuleSize.setDescription('Indicates the size of the module. min(1) modules are decHub90 compatible modules. max(2) modules are full sized DEChub900 modules. The value system(3) is used to denote a module which is neither a min(1) or max(2) module; for example, the integral management module is a system(3) module.')
chasSlotModuleOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 1, 6, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("up", 1), ("disabled", 2), ("insufficient-power", 3), ("fatal-error", 4), ("non-fatal-error", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasSlotModuleOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: chasSlotModuleOperStatus.setDescription('Indicates the operational state of the module. up(1) indicates that the module is performing as expected. disabled(2) indicates that the module has been disabled. insufficient-power(3) indicates that the chassis lacks the power needed by the module. fatal-error(4) indicates that the module encountered an error which prevents its operation. non-fatal-error(5) indicates that the module encountered an error which may inhibit its operation, but does not prevent its operating in a diminished capacity.')
chasSlotModuleAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 1, 6, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unknown", 1), ("enabled", 2), ("disabled", 3), ("reset", 4), ("restore-to-defaults", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasSlotModuleAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: chasSlotModuleAdminStatus.setDescription('Provides the administratively desired state of the given module. A disabled module is activated by writing a value of enable(2). A slot may be de-activated by writing a value of disable(3). A disabled slot is available for subsequent activation. Writing a value of reset(4) specifies that the model initiate a reset sequence. Writing a value of restore-to-defaults(5) specifies that the module restore all of its non-volatile parameters to their factory default state and reset the module. Agent support of the writing of any of the values of this object is implementation-specific. For example, this object might be read only for slots that disabling would compromise the integrity of the chassis.')
chasSlotModuleNonFatalError = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 1, 6, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasSlotModuleNonFatalError.setStatus('mandatory')
if mibBuilder.loadTexts: chasSlotModuleNonFatalError.setDescription('A device specific non-fatal error status indication.')
chasSlotResetAll = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unknown", 1), ("resetAllModules", 2), ("resetAllModulesAndMgr", 3), ("resetAllModulesToDefaults", 4), ("resetAllModulesAndMgrToDefaults", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasSlotResetAll.setStatus('mandatory')
if mibBuilder.loadTexts: chasSlotResetAll.setDescription("This object is used to reset, restore, and test all active modules in the chassis. Modules which are managed by the DECagent90 may only be reset using the DECagent90's MIB. This object may be used to reset, restore, and test all DEChub900 modules and some DEChub90 modules which reside in the DEChub900 chassis. When read, the value 'unknown(1) is returned. Setting this object to 'resetAllModules(2)' has the same affect as setting the chasSlotModuleAdminStatus of each entry in the chasSlotTable, except the entry for the Hub manager itself, to 'reset(4)'. Setting this object to 'resetAllModulesAndMgr(3)' has the same affect as setting the chasSlotModuleAdminStatus of each entry in the chasSlotTable to 'reset(4)'. Since the Hub Manager is reset, no SNMP response is sent when this object is set to resetAllModulesAndMgr(3). Setting this object to 'resetAllModulesToDefaults(2)' has the same affect as setting the chasSlotModuleAdminStatus of each entry in the chasSlotTable, except the entry for the Hub manager itself, to 'restore-to-defaults(5)'. Setting this object to 'resetAllModulesAndMgrToDefaults(3)' has the same affect as setting the chasSlotModuleAdminStatus of each entry in the chasSlotTable to 'restore-to-defaults(5)'. Since the Hub Manager is reset, no SNMP response is sent when this object is set to resetAllModulesAndMgr(3).")
chasEntityChanges = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 2, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasEntityChanges.setStatus('mandatory')
if mibBuilder.loadTexts: chasEntityChanges.setDescription('A counter which is incremented whenever entity table entries are added or deleted, and when one of the following fields of an existing chasEntityTable is modified: o chasEntityCommunity, o chasEntityIpAddress, or o chasEntityAccessMethod Entity changes occur when the IP address or one of the community strings of a device is changed. This counter is also incremented: o when modules are inserted, o when modules are removed, and o when chasEntityCommunity, chasEntityIpAddress, or chasEntityAccessMethod of an existing entry changes. (This does not count in chasEntityOperStatus of an existing entry.)')
chasEntityTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 2, 2), )
if mibBuilder.loadTexts: chasEntityTable.setStatus('mandatory')
if mibBuilder.loadTexts: chasEntityTable.setDescription("A table containing information about the 'logical' networking devices (entity) in this chassis.")
chasEntityEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 2, 2, 1), ).setIndexNames((0, "DECHUB900-CHASSIS-MIB-V3-0", "chasEntitySlotNumber"), (0, "DECHUB900-CHASSIS-MIB-V3-0", "chasEntityIndex"))
if mibBuilder.loadTexts: chasEntityEntry.setStatus('mandatory')
if mibBuilder.loadTexts: chasEntityEntry.setDescription('Information concerning an entity in the chassis. Table rows may not be created or deleted with SNMP operations.')
chasEntityIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasEntityIndex.setStatus('mandatory')
if mibBuilder.loadTexts: chasEntityIndex.setDescription('A unique index for the table entry.')
chasEntityFunction = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32768))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasEntityFunction.setStatus('deprecated')
if mibBuilder.loadTexts: chasEntityFunction.setDescription("The generic function of the entity. The value is a sum. Starting from zero, for each type of generic function that the entity performs, 2 raised to a power is added to the sum. The powers are according to the following table: Function Power -------- ------ repeater 0 -- e.g. Ethernet repeater, -- e.g. FDDI concentrator bridge 1 router 2 terminalServer 3 agent 4 -- entity that defines chassis MIB services 5 -- e.g. MIB Walk tools manager etc mau 6 power 7 networkMonitor 8 -- e.g. RMON device other 15 -- e.g. None of the above For example, an entity performing both bridging and routing functions would have a value of 6 (2^1 + 2^2). *************************************************************** This object has been deprecated. Devices no longer have to support it. It's OID may not be reused. For devices which already support it, it may *not* be used for any purpose other than its original indended purpose described above. *************************************************************** ")
chasEntityObjectID = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 2, 2, 1, 3), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasEntityObjectID.setStatus('deprecated')
if mibBuilder.loadTexts: chasEntityObjectID.setDescription("The value of this object is analogous to the MIB-II sysObjectID object. As stated in MIB-II, `It provides an easy and unambiguous means for determining what kind of box is being managed.' *************************************************************** This object has been deprecated. Devices no longer have to support it. It's OID may not be reused. For devices which already support it, it may *not* be used for any purpose other than its original indended purpose described above. *************************************************************** ")
chasEntityDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 2, 2, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasEntityDescr.setStatus('deprecated')
if mibBuilder.loadTexts: chasEntityDescr.setDescription("A textual description of the entity. *************************************************************** This object has been deprecated. Devices no longer have to support it. It's OID may not be reused. For devices which already support it, it may *not* be used for any purpose other than its original indended purpose described above. *************************************************************** ")
chasEntityVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 2, 2, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasEntityVersion.setStatus('deprecated')
if mibBuilder.loadTexts: chasEntityVersion.setDescription("A textual description of the version/revision level for this entity's hardware, ROM, and software. *************************************************************** This object has been deprecated. Devices no longer have to support it. It's OID may not be reused. For devices which already support it, it may *not* be used for any purpose other than its original indended purpose described above. *************************************************************** ")
chasEntityAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 2, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("unknown", 1), ("enable", 2), ("disable", 3), ("reset", 4), ("programload", 5), ("test", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasEntityAdminStatus.setStatus('deprecated')
if mibBuilder.loadTexts: chasEntityAdminStatus.setDescription("This object provides the administratively desired state of the given entity. An entity is activated by writing a value of enable(2). An entity may be de-activated by writing a value of disable(3). In a disabled state, a entity exists within the chassis, but is benign. A disabled entity is available for subsequent activation. (The table entry remains, but the entity for which it refers is disabled. The entity will perform no SNMP, except the operation to this object.) Writing a value of reset(4) specifies an entity initiate a reset sequence. Writing a value of programload(5) specifies an entity initiate a program load sequence. Writing a value of test(6) specifies an entity initiate a testing sequence. Agent support of the writing of any of the values of this object is implementation-specific. For example, this object might be read-only for entities that disabling would compromise the integrity of the chassis. Or, devices which do not support downline load may reject sets to programLoad(5). *************************************************************** This object has been deprecated. Devices no longer have to support it. It's OID may not be reused. For devices which already support it, it may *not* be used for any purpose other than its original indended purpose described above. *************************************************************** ")
chasEntityOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 2, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 10))).clone(namedValues=NamedValues(("other", 1), ("invalid", 2), ("testing", 3), ("operational", 4), ("resetInProgress", 5), ("warning", 6), ("nonFatalError", 7), ("fatalError", 8), ("loading", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasEntityOperStatus.setStatus('deprecated')
if mibBuilder.loadTexts: chasEntityOperStatus.setDescription("This object provides operational status of the entity. other - A value of other(1) implies some undetermined state, possibly as a result of setting chasEntityAdminStatus to a value of disable(3). invalid - A value of invalid(2) indicates that the entity exists but the chassis manager has no direct control of the entity. testing - A value of testing(3) is in a diagnostic state. operational - A value of operational(4) implies that the entity is running with no errors or warnings. resetInProgress - State resetInProgress(5) implies equivalent of setting chasEntityAdminStatus to reset(4). warning, nonFatalError, and fatalError - The states warning(6), nonFatalError(7), fatalError(8) reflect conditions detected during operation. The entity is functioning is a diminished capacity when warning or nonFatalError are indicated. When fatalError is indicated the device may or may not be functional. loading - State loading(10) is a result of asserting programload(5) in chasEntityAdminStatus. *************************************************************** This object has been deprecated. Devices no longer have to support it. It's OID may not be reused. For devices which already support it, it may *not* be used for any purpose other than its original indended purpose described above. *************************************************************** ")
chasEntityTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 2, 2, 1, 8), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasEntityTimeStamp.setStatus('deprecated')
if mibBuilder.loadTexts: chasEntityTimeStamp.setDescription("The value of MIB-II's sysUpTime (in the agent supporting this MIB) at which this entity was last (re-)initialized. *************************************************************** This object has been deprecated. Devices no longer have to support it. It's OID may not be reused. For devices which already support it, it may *not* be used for any purpose other than its original indended purpose described above. *************************************************************** ")
chasEntityParty = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 2, 2, 1, 9), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasEntityParty.setStatus('deprecated')
if mibBuilder.loadTexts: chasEntityParty.setDescription("The SNMP Version 2 Party which provides access to the detailed management information for this entity. An entity which is not managed through SNMP Version 2 returns a zero-length object-identifier. An entity which is not managed through SNMP returns chasEntityNoParty. *************************************************************** This object has been deprecated. Devices no longer have to support it. It's OID may not be reused. For devices which already support it, it may *not* be used for any purpose other than its original indended purpose described above. *************************************************************** ")
chasEntityCommunity = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 2, 2, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasEntityCommunity.setStatus('mandatory')
if mibBuilder.loadTexts: chasEntityCommunity.setDescription('The SNMP Community which when paired with chasEntityIpAddress provides access to the detailed management information for this entity. For a entity which is not managed through access to a SNMP Community, the value of this object is the zero-length string.')
chasEntityIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 2, 2, 1, 11), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasEntityIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: chasEntityIpAddress.setDescription('The IP address which when paired with chasEntityCommunity provides access to the detailed management information for this entity. When access is via proxy, this object contains the IP address of the proxy agent. For a entity which is not managed through access through a community name, internet address pair the value of this object is 0.0.0.0.')
chasEntityComAccessRights = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 2, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("readOnly", 1), ("readWrite", 2), ("traps", 3), ("other", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasEntityComAccessRights.setStatus('mandatory')
if mibBuilder.loadTexts: chasEntityComAccessRights.setDescription('The access rights associated with the community name, internet address pair. Note: Just because a user directs a message to the community name, internet address pair does not imply that the user is authorized on that pair. Additional security mechanisms may be employed such that only messages from particular internet addresses are authorized. THIS OBJECT IS ONLY HERE FOR BACKWARDS COMPATIBILITY WITH OLDER VERSION OF HUBWATCH THAT DO NOT SUPPORT chasEntityAccessCharacteristics. THIS OBJECT SHOULD BE DEPRECATED WHEN ALL VERSIONS OF HUBWATCH, THAT ARE IN THE FIELD, ARE SUPPORTING THE NEW INTERFACE.')
chasEntityAccessMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 2, 2, 1, 13), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasEntityAccessMethod.setStatus('mandatory')
if mibBuilder.loadTexts: chasEntityAccessMethod.setDescription("This object contains methods of access for a given module. If the entity is accessed by SNMP the value of this object is a zero length string, or a host IP address used for 'security' purposes. If access to the entity is by a means other than SNMP, this object contains the protocol and address used to access the Entity. This object is an opaque type. It contains a Type-Length-Value encoding where: octet 1 Type The type of protocol address specified in the value portion of this encoding. The type has the form: dh90Module(1), mgmtSet(2), telnet(3) octet 2 Length The length of the value. This length may contain a value from 1 to 30. octet 3..Length The value, which may be up to 30 octets. The dh90Module(1) type indicates that the entity is a DEChub90 module. The eight octet value portion contains a 2 octet DEChub90 module type, followed by a 6 octet hardware address. The mgmtSet(2) type indicates that the value of this object was derived from the chasEntityAccessLoadTable. The value portion is 'opaque'. It will take on any value which was set in the corresponding entry of the chasEntityAccessLoadTable. The telnet(3) type indicates that the module is accessible via telnet. The six octet value portion contains a 4 octet IP address, and a 2 octet TCP port number. ")
chasEntitySlotNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 2, 2, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasEntitySlotNumber.setStatus('mandatory')
if mibBuilder.loadTexts: chasEntitySlotNumber.setDescription('The slot number used to communicate with this agent. For entities which occupy more than one slot this value is the lowest slot number that this entity occupies.')
chasEntitySrcIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 2, 2, 1, 15), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasEntitySrcIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: chasEntitySrcIpAddress.setDescription('This object is used to provide HOST IP ADDRESS AUTHENTICATION. Host IP address authentication can be performed two different ways, depending on whether there is a subnet mask provided in chasEntitySrcSubnetMask. If chasEntitySrcSubnetMask is not defined, then the host IP address (source IP address in the SNMP command PDU) must be equal to this object. If chasEntitySrcSubnetMask is defined, then the host IP address (source IP address in the SNMP command PDU) is ANDed with the chasEntitySrcSubnetMask, and the value must be equal to this object. If the values are equal, then that SNMP command is authorized the community access rights for the associated chasEntityCommunity, chasEntityIpAddress pair. NOTE 1: This is assuming that the community profile has been authorized. NOTE 2: Multiple source IP addresses can be defined for the same community name, internet address pair. See example at the begining of the chasEntityTable. For an entity which is not supporting host IP address authentication scheme, the value of this object is 0.0.0.0.')
chasEntitySrcSubnetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 2, 2, 1, 16), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasEntitySrcSubnetMask.setStatus('mandatory')
if mibBuilder.loadTexts: chasEntitySrcSubnetMask.setDescription('This object is used in conjunction with the chasEntitySrcIpAddress to provide HOST IP ADDRESS AUTHENTICATION. Refer to chasEntitySrcIpAddress for a description For an entity that does not support the subnet mask, this value is 0.0.0.0.')
chasEntityAccessCharacteristics = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 2, 2, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32768))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasEntityAccessCharacteristics.setStatus('mandatory')
if mibBuilder.loadTexts: chasEntityAccessCharacteristics.setDescription("This object is used to provide access characteristics pertaining to other objects in the given entity row. The characteristics are divided into categories. Each category uses a set of predefined bits to encode data. The following categories are currently supported: Category Bits -------- ---- Community Access Rights 1..4 Network Interface 5..6 UNUSED 7..15 The categories are orthogonal to each other, so it is not necessary to perform 'inter-category' bounds checking. The object value is a concatentation of encodings from each category, and can be considered a sum. The actual encoding mechanism is defined on a per category basis. Categories ========== Community Access Rights ----------------------- Community access rights are associated with the community name, internet address pair. More than one access right can be defined for a given community name, internet address pair. The encoding works as follows: Starting from zero, for each access right supported, 2 raised to a power is added to the sum. The powers are according to the following table: Type Power ---- ----- readOnly 0 readWrite 1 trap 2 other 3 For example, a community name, internet address pair with readOnly and readWrite access rights, would have a value of 3 (2^0 + 2^1). An access right of other(3) defines the entity row as non-SNMP manageable. Management information is provided in the chasEntityAccessMethod and the Network Interface (defined below). Note: Just because a user directs a message to the community name, internet address pair does not imply that the user is authorized on that pair. Additional security mechanisms may be employed such that only messages from particular internet addresses are authorized. Network Interface ----------------- The network interface is associated with the internet address and defines the route for management traffic. A network interface can be one of the following: none(0), obm(1), ibm(2), and port(3). The value is placed in the 2-bits reserved for network interfaces. Note: ibm(2) and port(3) are both in-band management. The difference is ibm(2) is a module wide ip address, and port(3) is associated with a particular port/interface.")
chasEntityAccessLoadTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 2, 3), )
if mibBuilder.loadTexts: chasEntityAccessLoadTable.setStatus('mandatory')
if mibBuilder.loadTexts: chasEntityAccessLoadTable.setDescription('A table that contain manually entered entity access information.')
chasEntityAccessLoadEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 2, 3, 1), ).setIndexNames((0, "DECHUB900-CHASSIS-MIB-V3-0", "chasEntityAccessLoadSlot"))
if mibBuilder.loadTexts: chasEntityAccessLoadEntry.setStatus('mandatory')
if mibBuilder.loadTexts: chasEntityAccessLoadEntry.setDescription('A list of information about how to access entities.')
chasEntityAccessLoadSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasEntityAccessLoadSlot.setStatus('mandatory')
if mibBuilder.loadTexts: chasEntityAccessLoadSlot.setDescription('The number of the slot in which the chasEntityAccessLoadMethod information applies.')
chasEntityAccessLoadMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 2, 3, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasEntityAccessLoadMethod.setStatus('mandatory')
if mibBuilder.loadTexts: chasEntityAccessLoadMethod.setDescription('A value which is loaded into chasEntityAccessMethod if the slot is occupied by a module for which no better information about how to access the entity exists.')
chasEntityChangeTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 2, 4), )
if mibBuilder.loadTexts: chasEntityChangeTable.setStatus('mandatory')
if mibBuilder.loadTexts: chasEntityChangeTable.setDescription('A table that contains change counters for each module in the chassis.')
chasEntityChangeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 2, 4, 1), ).setIndexNames((0, "DECHUB900-CHASSIS-MIB-V3-0", "chasEntityChangeSlot"))
if mibBuilder.loadTexts: chasEntityChangeEntry.setStatus('mandatory')
if mibBuilder.loadTexts: chasEntityChangeEntry.setDescription('Information concerning module change counters.')
chasEntityChangeSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 2, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasEntityChangeSlot.setStatus('mandatory')
if mibBuilder.loadTexts: chasEntityChangeSlot.setDescription('The slot number in which the chasEntityChangeCounter applies.')
chasEntityChangeCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 2, 4, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasEntityChangeCounter.setStatus('mandatory')
if mibBuilder.loadTexts: chasEntityChangeCounter.setDescription('A counter which is incremented whenever entity table entries, for a particular slot, are added, deleted, or changed. Adds and deletes occur when: o IP addresses are added, o IP addresses are deleted, o modules are inserted, and o modules are removed. Entity changes occur when one of the following fields of an existing chasEntityTable is modified: o chasEntityCommunity, o chasEntityIpAddress, or o chasEntityAccessMethod. (This does not count in chasEntityOperStatus of an existing entry.) NOTE: The chasEntityChanges counter is incremented when ever an instance of the chasEntityChangeCounter is incremented.')
chasBackplaneTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 3, 1), )
if mibBuilder.loadTexts: chasBackplaneTable.setStatus('mandatory')
if mibBuilder.loadTexts: chasBackplaneTable.setDescription('A table that contains information about the backplane(s) present in the chassis.')
chasBackplaneEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 3, 1, 1), ).setIndexNames((0, "DECHUB900-CHASSIS-MIB-V3-0", "chasBackplaneIndex"))
if mibBuilder.loadTexts: chasBackplaneEntry.setStatus('mandatory')
if mibBuilder.loadTexts: chasBackplaneEntry.setDescription('A list of information of the backplane(s) in the chassis.')
chasBackplaneIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasBackplaneIndex.setStatus('mandatory')
if mibBuilder.loadTexts: chasBackplaneIndex.setDescription('A unique index for the table entry.')
chasBackplaneDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 3, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasBackplaneDescr.setStatus('mandatory')
if mibBuilder.loadTexts: chasBackplaneDescr.setDescription('A textual description of the backplane.')
chasBackplaneRev = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 3, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasBackplaneRev.setStatus('mandatory')
if mibBuilder.loadTexts: chasBackplaneRev.setDescription('A textual description of the revision level of the backplane.')
chasBackplaneNumSlots = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasBackplaneNumSlots.setStatus('mandatory')
if mibBuilder.loadTexts: chasBackplaneNumSlots.setDescription('The number of slots this backplane supports.')
chasSegmentTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 4, 1), )
if mibBuilder.loadTexts: chasSegmentTable.setStatus('mandatory')
if mibBuilder.loadTexts: chasSegmentTable.setDescription("A table that contains information about the network segments contained within the chassis, and used to interconnect the chassis' logical networking devices.")
chasSegmentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 4, 1, 1), ).setIndexNames((0, "DECHUB900-CHASSIS-MIB-V3-0", "chasSegmentIndex"))
if mibBuilder.loadTexts: chasSegmentEntry.setStatus('mandatory')
if mibBuilder.loadTexts: chasSegmentEntry.setDescription('A list of information for a particular segment in the chassis.')
chasSegmentIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasSegmentIndex.setStatus('mandatory')
if mibBuilder.loadTexts: chasSegmentIndex.setDescription('A unique index for the network segment for which this entry contains information.')
chasSegmentName = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 4, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasSegmentName.setStatus('mandatory')
if mibBuilder.loadTexts: chasSegmentName.setDescription('An administratively assigned segment name.')
chasSegmentType = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("fddi", 1), ("ethernet", 2), ("tr", 3), ("atm", 4), ("async", 5), ("pebus", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasSegmentType.setStatus('mandatory')
if mibBuilder.loadTexts: chasSegmentType.setDescription("A segment's media type.")
chasSegmentSubtypeSelect = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasSegmentSubtypeSelect.setStatus('mandatory')
if mibBuilder.loadTexts: chasSegmentSubtypeSelect.setDescription('The index of specific media type a segment is selected to serve, from the chasSegSubtypeTable.')
chasSegmentEntryStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("valid", 1), ("createRequest", 2), ("underCreation", 3), ("invalid", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasSegmentEntryStatus.setStatus('mandatory')
if mibBuilder.loadTexts: chasSegmentEntryStatus.setDescription('Status of a segment table entry.')
chasSegSubtypeTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 4, 2), )
if mibBuilder.loadTexts: chasSegSubtypeTable.setStatus('mandatory')
if mibBuilder.loadTexts: chasSegSubtypeTable.setDescription('A table that contains information about the subtype of a network segment, contains additional information about the segment. The speed of a token ring may be specified, for example.')
chasSegSubtypeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 4, 2, 1), ).setIndexNames((0, "DECHUB900-CHASSIS-MIB-V3-0", "chasSegSubtypeIndex"))
if mibBuilder.loadTexts: chasSegSubtypeEntry.setStatus('mandatory')
if mibBuilder.loadTexts: chasSegSubtypeEntry.setDescription('A list of information of subtypes for segment in the chassis.')
chasSegSubtypeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 4, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasSegSubtypeIndex.setStatus('mandatory')
if mibBuilder.loadTexts: chasSegSubtypeIndex.setDescription('A unique index for the table entry.')
chasSegSubtypeFlavor = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 4, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("default", 1), ("thinwire", 2), ("imb", 3), ("imb2", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasSegSubtypeFlavor.setStatus('mandatory')
if mibBuilder.loadTexts: chasSegSubtypeFlavor.setDescription('The specific media type a segment is selected to serve.')
chasSegSubtypeSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 4, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasSegSubtypeSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: chasSegSubtypeSpeed.setDescription('The speed of the segment expressed in thousands of bits per second.')
chasSegSubtypeEntryStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 4, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("valid", 1), ("createRequest", 2), ("underCreation", 3), ("invalid", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasSegSubtypeEntryStatus.setStatus('mandatory')
if mibBuilder.loadTexts: chasSegSubtypeEntryStatus.setDescription('Status of a segment table entry.')
chasSegDefVNbusState = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 4, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasSegDefVNbusState.setStatus('mandatory')
if mibBuilder.loadTexts: chasSegDefVNbusState.setDescription('The default VNbus state. While enabled(1), a VNbus segment will be created automatically when a line card containing a VNbus port awakens, and the port will be connected to the segment. The segment will be removed when the last line card containing a VNbus port is removed. No automatic segment/connection creation/removal takes place while this is disabled(2). Enabling the default VNbus causes any unconnected VNbus ports that have not been explicitly disconnected to be connected to the VNbus segment (which will be created automatically if necessary). Disabling it has no effect on existing VNbus port connections.')
chasChassisSerialNumber = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 5, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasChassisSerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: chasChassisSerialNumber.setDescription('The serial number of the chassis. If no serial number is available, then the value of this object should be the zero length string.')
chasConnChanges = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 5, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasConnChanges.setStatus('mandatory')
if mibBuilder.loadTexts: chasConnChanges.setDescription("The number of physical changes that have occurred in the chassis backplane configuration since the agent was warm/cold started. Specifically, this object is incremented: 1) whenever chasConnEntryStatus for any object becomes 'valid', 2) whenever chasConnEntryStatus transitions from 'valid' to any other state, and 3) whenever the chasConnSegment or chasConnPort of a 'valid' chasConnEntry is modified.")
chasConnTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 5, 3), )
if mibBuilder.loadTexts: chasConnTable.setStatus('mandatory')
if mibBuilder.loadTexts: chasConnTable.setDescription("A list of Tx port to backplane connections. At cold boot, MAM initializes the table for a populated hub based on default configuration. MAM has the ownership of this table. The creation of an entry in this table by NMS causes Management Agent to set the interface status of a corresponding icomBpConnTable port to 'connected'.")
chasConnEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 5, 3, 1), ).setIndexNames((0, "DECHUB900-CHASSIS-MIB-V3-0", "chasConnIndex"))
if mibBuilder.loadTexts: chasConnEntry.setStatus('mandatory')
if mibBuilder.loadTexts: chasConnEntry.setDescription('Backplane connection definition.')
chasConnIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 5, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasConnIndex.setStatus('mandatory')
if mibBuilder.loadTexts: chasConnIndex.setDescription('Index into the table.')
chasConnSegment = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 5, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasConnSegment.setStatus('mandatory')
if mibBuilder.loadTexts: chasConnSegment.setDescription('An index value of the chasSegmentTable.')
chasConnPort = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 5, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasConnPort.setStatus('mandatory')
if mibBuilder.loadTexts: chasConnPort.setDescription('An index value of the chasPortTable.')
chasConnNextPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 5, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasConnNextPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: chasConnNextPortIndex.setDescription("A downstream neighbor's backplane port index in the chasPortTable. It is only used by ring segments. This object has the value 65535 when not using a ring segment, or no downstream neighbor exists.")
chasConnEntryStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 5, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("valid", 1), ("createRequest", 2), ("underCreation", 3), ("invalid", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasConnEntryStatus.setStatus('mandatory')
if mibBuilder.loadTexts: chasConnEntryStatus.setDescription('Status of a connection table entry.')
chasPortLastChange = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 6, 1), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasPortLastChange.setStatus('mandatory')
if mibBuilder.loadTexts: chasPortLastChange.setDescription("The value of MIB-II's sysUpTime (in the agent supporting this chassis MIB) at which a port had its chasPortOperStatus change.")
chasPortTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 6, 2), )
if mibBuilder.loadTexts: chasPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: chasPortTable.setDescription('A list of backplane ports on installed line cards. MAM initializes the table based on what is learned from the icomBpIfTables and has the ownership of this table.')
chasPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 6, 2, 1), ).setIndexNames((0, "DECHUB900-CHASSIS-MIB-V3-0", "chasPortIndex"))
if mibBuilder.loadTexts: chasPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: chasPortEntry.setDescription('Line card backplane port definition.')
chasPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 6, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: chasPortIndex.setDescription('Index into the table.')
chasPortSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 6, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasPortSlot.setStatus('mandatory')
if mibBuilder.loadTexts: chasPortSlot.setDescription('Slot ID of a line card. If a line card has more than one backplane port, same slot ID may appear multiple times in this table.')
chasPortName = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 6, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasPortName.setStatus('mandatory')
if mibBuilder.loadTexts: chasPortName.setDescription('An administratively assigned path name. A Default value will be assigned by the management agent module. Users may overwrite the default value. This object in non-volatile. The default value is based on the values of chasPortType and chasPortSubtypeSelect. Recommended defaults are: Default chasPortType chasPortSubtypeSelect ================= =============== ===================== Ethernet ethernet 0 (Nothing selected) Ethernet ethernet default Thinwire Ethernet ethernet thinwire Repeater Bus ethernet imb FDDI fddi 0 (Nothing selected) FDDI fddi default FDDI-A fddi fddiA FDDI-B fddi fddiB FDDI-M fddi fddiM FDDI-S fddi fddiS Token Ring tr 0 (Nothing selected) Token Ring tr default ATM atm 0 (Nothing selected) ATM atm default Asynchronous asynch 0 (Nothing selected) Asynchronous asynch default')
chasPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 6, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("fddi", 1), ("ethernet", 2), ("tr", 3), ("atm", 4), ("async", 5), ("pebus", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasPortType.setStatus('mandatory')
if mibBuilder.loadTexts: chasPortType.setDescription("A port's media type. Ethernet type consists of IMB and ThinWire subtypes. TrMatrix and TrDH90 are not managed by the matrix manager for BL2 (reserved types).")
chasPortSubtypeSelect = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 6, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasPortSubtypeSelect.setStatus('mandatory')
if mibBuilder.loadTexts: chasPortSubtypeSelect.setDescription('The index in chasPortSubtypeTable that has been selected for this port. The 0 value for this index is only legal as a place holder for an unconfigured port.')
chasPortOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 6, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("broken", 1), ("unconfigured", 2), ("configured", 3), ("testing", 4), ("connected", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasPortOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: chasPortOperStatus.setDescription('Status of a port.')
chasPortDescrTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 6, 3), )
if mibBuilder.loadTexts: chasPortDescrTable.setStatus('mandatory')
if mibBuilder.loadTexts: chasPortDescrTable.setDescription('A list of backplane port description for installed line cards. MAM initializes the table based on what is learned from the icomBpIfTables and has the ownership of this table.')
chasPortDescrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 6, 3, 1), ).setIndexNames((0, "DECHUB900-CHASSIS-MIB-V3-0", "chasPortDescrIndex"))
if mibBuilder.loadTexts: chasPortDescrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: chasPortDescrEntry.setDescription('Line card backplane port descriptive text.')
chasPortDescrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 6, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasPortDescrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: chasPortDescrIndex.setDescription('Index in the Port Table of the port described by this entry')
chasPortDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 6, 3, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasPortDescr.setStatus('mandatory')
if mibBuilder.loadTexts: chasPortDescr.setDescription('Text that describes the function of the port. This text is read from the line card.')
chasPortSubtypeTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 6, 4), )
if mibBuilder.loadTexts: chasPortSubtypeTable.setStatus('mandatory')
if mibBuilder.loadTexts: chasPortSubtypeTable.setDescription('A table that contains information about the subtype of a port, contains additional information about the port. The speed of a token ring port may be specified, for example.')
chasPortSubtypeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 6, 4, 1), ).setIndexNames((0, "DECHUB900-CHASSIS-MIB-V3-0", "chasPortSubtypeIndex"))
if mibBuilder.loadTexts: chasPortSubtypeEntry.setStatus('mandatory')
if mibBuilder.loadTexts: chasPortSubtypeEntry.setDescription('A list of information of subtypes for port in the port table.')
chasPortSubtypeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 6, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasPortSubtypeIndex.setStatus('mandatory')
if mibBuilder.loadTexts: chasPortSubtypeIndex.setDescription('Index into the table.')
chasPortSubtypePortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 6, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasPortSubtypePortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: chasPortSubtypePortIndex.setDescription("The index of a port in the chasPortTable that can support the specified chasPortSubtypeFlavor and chasPortSubtypeSpeed. A value of '-1' occurs in the first table row indicating a port which will not be reconnected on a hub power cycle.")
chasPortSubtypeFlavor = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 6, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("default", 1), ("thinwireEndStation", 2), ("thinwireRepeater", 3), ("imbEndStation", 4), ("imbRepeater", 5), ("fddiA", 6), ("fddiB", 7), ("fddiM", 8), ("fddiS", 9), ("thinwireFlexRepeater", 10), ("imbFlexRepeater", 11), ("imb2EndStation", 12), ("atmMaster", 13), ("atmSlave", 14), ("imb2Repeater", 15), ("imb2FlexRepeater", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasPortSubtypeFlavor.setStatus('mandatory')
if mibBuilder.loadTexts: chasPortSubtypeFlavor.setDescription("The specific media type a port is selected to support. A value of zero (0), though not allowed as an enumerated value, occurs in conjunction with the occurrance of a chasPortSubtypePortIndex of '-1' (see above).")
chasPortSubtypeSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 6, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasPortSubtypeSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: chasPortSubtypeSpeed.setDescription('The speed of the port expressed in hundreds of bits per second.')
chasPowerConfigMaxSupplies = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 7, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasPowerConfigMaxSupplies.setStatus('mandatory')
if mibBuilder.loadTexts: chasPowerConfigMaxSupplies.setDescription('The maximum number of power supplies which may be installed within this chassis.')
chasPowerConfigNumSupplies = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 7, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasPowerConfigNumSupplies.setStatus('mandatory')
if mibBuilder.loadTexts: chasPowerConfigNumSupplies.setDescription('The current number of power supplies which are installed within this chassis.')
chasPowerConfigChanges = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 7, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasPowerConfigChanges.setStatus('mandatory')
if mibBuilder.loadTexts: chasPowerConfigChanges.setDescription('A count of the total number of times a chasPowerConfigOperStatus value in the chasPowerConfigTable has changed. This does not include changes that occur when entries are created and deleted due to module insertion and deletion. This counter may not equal the sum of the chasPowerConfig- Warnings and chasPowerConfigFailures counters because modules which have undergone environmental changes could have been removed from the chassis. The purpose of this object is to provide a single object which can be polled by an NMS to determine if anything in the chasPowerConfigTable has changed.')
chasPowerConfigRedundancyState = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 7, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("redundantPowerAvailable", 1), ("redundantPowerNotAvailable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasPowerConfigRedundancyState.setStatus('mandatory')
if mibBuilder.loadTexts: chasPowerConfigRedundancyState.setDescription("This indicates whether the present configuration can continue to operate if any one of the power supplies fail or is removed. In certain configurations, the hub may need one, two or three power supply modules. The addition of an extra power supply module will allow for the failure of any one of the power supply modules. A power system such as this which allows for the failure of any one of the power supplies is referred to as a 'redundant power system'. Some redundant power systems provide standby power supplies which engages only when a primary supply fails. Unlike this type of system, the DEChub900 power system employs load sharing. Each power supply provides a portion of the power necessary to power the system. When redundant power is available in the system, the failure of one supply causes the load of the remaining supplies to increase sufficiently to make up for the failed supply.")
chasPowerConfigTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 7, 5), )
if mibBuilder.loadTexts: chasPowerConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: chasPowerConfigTable.setDescription('A list of power supply entries, one for each power supply in the chassis.')
chasPowerConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 7, 5, 1), ).setIndexNames((0, "DECHUB900-CHASSIS-MIB-V3-0", "chasPowerConfigIndex"))
if mibBuilder.loadTexts: chasPowerConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: chasPowerConfigEntry.setDescription('Values for a power supply.')
chasPowerConfigIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 7, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasPowerConfigIndex.setStatus('mandatory')
if mibBuilder.loadTexts: chasPowerConfigIndex.setDescription('An index value that uniquely identifies a power supply.')
chasPowerConfigDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 7, 5, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasPowerConfigDescr.setStatus('mandatory')
if mibBuilder.loadTexts: chasPowerConfigDescr.setDescription("A textual description of the power supply, including the vendor's name and version.")
chasPowerConfigAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 7, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("enable", 2), ("disable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasPowerConfigAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: chasPowerConfigAdminStatus.setDescription('Desired status of the power supply.')
chasPowerConfigOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 7, 5, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("unknown", 1), ("empty", 2), ("disabled", 3), ("bad", 4), ("warning", 5), ("standby", 6), ("engaged", 7), ("redundant", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasPowerConfigOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: chasPowerConfigOperStatus.setDescription('Actual status of the power supply: o unknown(1) - status not known. o empty(2) - no power supply installed in slot o disabled(3) - unable to supply power due to chasPowerConfigAdminStatus o bad(4) - unable to supply power due to failure o warning(5) - supplying power but an output or sensor is bad or warning o standby(6) - believed usable but not supplying power o engaged(7) - supplying power o redundant(8) - supplying power but not needed It is an implementation specific matter whether the agent keeps entries with status unknown(1) or empty(2) in the table.')
chasPowerConfigHealthText = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 7, 5, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasPowerConfigHealthText.setStatus('mandatory')
if mibBuilder.loadTexts: chasPowerConfigHealthText.setDescription("A textual description of the power supply's operational status. Agents may use this string to provide detailed information on current failures, including how they were detected, and/or instructions for problem resolution. The contents are agent-specific.")
chasPowerConfigWarnings = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 7, 5, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasPowerConfigWarnings.setStatus('mandatory')
if mibBuilder.loadTexts: chasPowerConfigWarnings.setDescription('The number of times chasPowerConfigOperStatus has gone to warning(5).')
chasPowerConfigFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 7, 5, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasPowerConfigFailures.setStatus('mandatory')
if mibBuilder.loadTexts: chasPowerConfigFailures.setDescription('The number of times chasPowerConfigOperStatus has become bad(4).')
chasPowerSourceTotalPowerAvailable = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 8, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasPowerSourceTotalPowerAvailable.setStatus('mandatory')
if mibBuilder.loadTexts: chasPowerSourceTotalPowerAvailable.setDescription("The total amount of power available within the chassis. This value is expressed in milli-watts. This value will not go below zero if there are unpowered modules in the chassis. This value is based on the maximum rating of the power supply. Therefore, this value will not equal the sum of the chasPowerSourceTable's chasPowerSourcePower objects. The chasPowerSourcePower object specifies power available at a specific voltage.")
chasPowerSourceTotalCurrentAvailable = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 8, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasPowerSourceTotalCurrentAvailable.setStatus('mandatory')
if mibBuilder.loadTexts: chasPowerSourceTotalCurrentAvailable.setDescription('The total amount of current available within the chassis. This value is expressed in milli-amperes. This value will not go below zero if there are unpowered modules in the chassis.')
chasPowerSourceTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 8, 3), )
if mibBuilder.loadTexts: chasPowerSourceTable.setStatus('mandatory')
if mibBuilder.loadTexts: chasPowerSourceTable.setDescription('A list of power supply source capabilities.')
chasPowerSourceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 8, 3, 1), ).setIndexNames((0, "DECHUB900-CHASSIS-MIB-V3-0", "chasPowerSourceSupplyIndex"), (0, "DECHUB900-CHASSIS-MIB-V3-0", "chasPowerSourceIndex"))
if mibBuilder.loadTexts: chasPowerSourceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: chasPowerSourceEntry.setDescription('Values for a power supply output.')
chasPowerSourceSupplyIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 8, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasPowerSourceSupplyIndex.setStatus('mandatory')
if mibBuilder.loadTexts: chasPowerSourceSupplyIndex.setDescription('An index value that identifies the power supply. This value corresponds to chasPowerConfigIndex.')
chasPowerSourceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 8, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasPowerSourceIndex.setStatus('mandatory')
if mibBuilder.loadTexts: chasPowerSourceIndex.setDescription('An index value that uniquely identifies an output for the power supply. A value of zero indicates that no power supply is installed.')
chasPowerSourceNominalVoltage = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 8, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasPowerSourceNominalVoltage.setStatus('mandatory')
if mibBuilder.loadTexts: chasPowerSourceNominalVoltage.setDescription('The nominal voltage available thru this supply. The value of this object is expressed in milli-volts.')
chasPowerSourcePower = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 8, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasPowerSourcePower.setStatus('mandatory')
if mibBuilder.loadTexts: chasPowerSourcePower.setDescription('The total power available at the nominal voltage of this supply. The value of this object is expressed is milli-watts.')
chasPowerSinkTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 9, 1), )
if mibBuilder.loadTexts: chasPowerSinkTable.setStatus('mandatory')
if mibBuilder.loadTexts: chasPowerSinkTable.setDescription('A list of slot power requirements.')
chasPowerSinkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 9, 1, 1), ).setIndexNames((0, "DECHUB900-CHASSIS-MIB-V3-0", "chasPowerSinkSlotIndex"), (0, "DECHUB900-CHASSIS-MIB-V3-0", "chasPowerSinkIndex"))
if mibBuilder.loadTexts: chasPowerSinkEntry.setStatus('mandatory')
if mibBuilder.loadTexts: chasPowerSinkEntry.setDescription("A Slot's power requirement definition.")
chasPowerSinkSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 9, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasPowerSinkSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: chasPowerSinkSlotIndex.setDescription('An index into the table which corresponds to chasSlotIndex.')
chasPowerSinkIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 9, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasPowerSinkIndex.setStatus('mandatory')
if mibBuilder.loadTexts: chasPowerSinkIndex.setDescription('An index per chasPowerSinkVoltage.')
chasPowerSinkVoltage = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 9, 1, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasPowerSinkVoltage.setStatus('mandatory')
if mibBuilder.loadTexts: chasPowerSinkVoltage.setDescription('The voltage, in milli-volts used by the power sink.')
chasPowerSinkWattage = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 9, 1, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasPowerSinkWattage.setStatus('mandatory')
if mibBuilder.loadTexts: chasPowerSinkWattage.setDescription('The amount of power, in milli-watts, needed by the power sink.')
chasPowerSinkOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 9, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("inUse", 2), ("notInUse", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasPowerSinkOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: chasPowerSinkOperStatus.setDescription('Indicates if the slot is drawing power. It is an implementation specific matter whether the agent keeps entries with status unknown(1) in the table.')
chasEnvironChanges = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 10, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasEnvironChanges.setStatus('mandatory')
if mibBuilder.loadTexts: chasEnvironChanges.setDescription('A count of the total number of changes to existing entries in the chasEnvironOperStatus have occurred. This does not include changes that occur when entries are created and deleted due to module insertion and deletion. This counter may not equal the sum of the chasEnviron- Warnings and chasEnvironFailures counters because modules which have undergone environmental changes could have been removed from the chassis. The purpose of this object is to provide a single object which can be polled by an NMS to determine if anything in the chasEnvironTable has changed.')
chasEnvironTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 10, 2), )
if mibBuilder.loadTexts: chasEnvironTable.setStatus('mandatory')
if mibBuilder.loadTexts: chasEnvironTable.setDescription('A list of environmental entries, one for each environmental sensor in the chassis.')
chasEnvironEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 10, 2, 1), ).setIndexNames((0, "DECHUB900-CHASSIS-MIB-V3-0", "chasEnvironSlotIndex"), (0, "DECHUB900-CHASSIS-MIB-V3-0", "chasEnvironSensorIndex"))
if mibBuilder.loadTexts: chasEnvironEntry.setStatus('mandatory')
if mibBuilder.loadTexts: chasEnvironEntry.setDescription('Values for an environmental sensor.')
chasEnvironSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 10, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasEnvironSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: chasEnvironSlotIndex.setDescription('An index value that uniquely identifies the slot in which the sensor is sensing stuff.')
chasEnvironSensorIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 10, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasEnvironSensorIndex.setStatus('mandatory')
if mibBuilder.loadTexts: chasEnvironSensorIndex.setDescription('An index value that uniquely identifies one of possibly many sensors within a slot.')
chasEnvironSensor = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 10, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("temperature", 2), ("fan", 3), ("humidity", 4), ("dc-power", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasEnvironSensor.setStatus('mandatory')
if mibBuilder.loadTexts: chasEnvironSensor.setDescription('The type of the sensor.')
chasEnvironAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 10, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("enable", 2), ("disable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasEnvironAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: chasEnvironAdminStatus.setDescription("The desired state of the sensor. When sensors are 'disabled' their chasEnvironWarnings and chasEnvironFailures counters do not change. Moreover, chasEnvironChanges will not change as a result of a 'disabled' sensor.")
chasEnvironOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 10, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unknown", 1), ("bad", 2), ("warning", 3), ("good", 4), ("disabled", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasEnvironOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: chasEnvironOperStatus.setDescription("Actual status indicated by the sensor. It is an implementation specific matter whether the agent keeps entries with status unknown(1) in the table. If unknown(1), counters are meaningless. If 'disabled', counters freeze.")
chasEnvironWarnings = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 10, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasEnvironWarnings.setStatus('mandatory')
if mibBuilder.loadTexts: chasEnvironWarnings.setDescription('The number of times chasEnvironStatus has gone to warning(3).')
chasEnvironFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 10, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasEnvironFailures.setStatus('mandatory')
if mibBuilder.loadTexts: chasEnvironFailures.setDescription('The number of times chasEnvironStatus has gone to bad(2).')
chasLoadTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 11, 1), )
if mibBuilder.loadTexts: chasLoadTable.setStatus('mandatory')
if mibBuilder.loadTexts: chasLoadTable.setDescription('A list of boot/load information for the slots.')
chasLoadEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 11, 1, 1), ).setIndexNames((0, "DECHUB900-CHASSIS-MIB-V3-0", "chasLoadSlotIndex"))
if mibBuilder.loadTexts: chasLoadEntry.setStatus('mandatory')
if mibBuilder.loadTexts: chasLoadEntry.setDescription('Slot boot/load information.')
chasLoadSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 11, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasLoadSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: chasLoadSlotIndex.setDescription('Slot ID of the owner of the boot information.')
chasLoadAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 11, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("start-read", 2), ("start-write", 3), ("cancel", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasLoadAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: chasLoadAdminStatus.setDescription('This object is used to control the program load process of a device. When read, the value other(1) is returned. When set to start-read(2) the device initiates a TFTP read operation to read a new program image. When set to start-write(3) the device is placed in such a state as to accept a new program image via a TFTP write operation. Once initiated, the status of the load attempt is reflected in chasLoadOperStatus. A device shall always reset upon completion of a successful load attempt. It may reset upon unsuccessful completion of the load attempt. When set to cancel(4) the device will attempt to cancel an ongoing load.')
chasLoadOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 11, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("success", 2), ("failure", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasLoadOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: chasLoadOperStatus.setDescription('The final state of the last load attempt. none(1) indicates that no load has been attempted, ever.')
chasLoadFileName = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 11, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasLoadFileName.setStatus('mandatory')
if mibBuilder.loadTexts: chasLoadFileName.setDescription('The name of the file in which to load. When the device is reading, this is the name of the file to be read. When the device is being written, this is the only name of the file in which writes will be accepted - provided the device can check the file name. If the device can not check the file name then this object is ignored. It is the duty of the NMS triggering the device to load this object. This object is non-volatile for a mam Load. The initial value of this object is a zero-lengthed string. In the case of multi-file loads (aka segmented loads) this object contains the name of the first file in which to load. It is an application specific issue as to how to get subsequent load files.')
chasLoadIpHostAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 11, 1, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasLoadIpHostAddr.setStatus('mandatory')
if mibBuilder.loadTexts: chasLoadIpHostAddr.setDescription('The IP address of the host from which to load. When the device is reading, this is the IP address of the host in which the read will be directed. When the device is being written, this is the IP address of the only host in which writes will be accepted. This object is non-volatile for slotId corresponding to the management agent module. The initial value of this object is 0.0.0.0. Sets of this object to 0.0.0.0 and 255.255.255.255 are rejected with a badValue error.')
chasLoadDevSpecific = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 11, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasLoadDevSpecific.setStatus('mandatory')
if mibBuilder.loadTexts: chasLoadDevSpecific.setDescription('A device specific parameter which may be used to indicate detailed error information about the last attempted load. A value of zero indicates that no load has been attempted, or that there is nothing interesting to report of the last load.')
chasLoadEntryStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 11, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("valid", 1), ("createRequest", 2), ("underCreation", 3), ("invalid", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasLoadEntryStatus.setStatus('mandatory')
if mibBuilder.loadTexts: chasLoadEntryStatus.setDescription('Used to create and delete rows in the load table.')
chasLigoNumEntries = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 13, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasLigoNumEntries.setStatus('mandatory')
if mibBuilder.loadTexts: chasLigoNumEntries.setDescription('The number of entries in the Ligo table.')
chasLigoTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 13, 2), )
if mibBuilder.loadTexts: chasLigoTable.setStatus('mandatory')
if mibBuilder.loadTexts: chasLigoTable.setDescription('A list of LIGOs (building blocks).')
chasLigoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 13, 2, 1), ).setIndexNames((0, "DECHUB900-CHASSIS-MIB-V3-0", "chasLigoIndex"))
if mibBuilder.loadTexts: chasLigoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: chasLigoEntry.setDescription('A LIGO entry containing objects which describe the building block.')
chasLigoIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 13, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasLigoIndex.setStatus('mandatory')
if mibBuilder.loadTexts: chasLigoIndex.setDescription('A unique value for each LIGO. The value of this object ranges between 1 and n where n is the total number of building blocks supported by the device.')
chasLigoSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 13, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasLigoSlot.setStatus('mandatory')
if mibBuilder.loadTexts: chasLigoSlot.setDescription('Slot number associated with this building block.')
chasLigoType = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 13, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("fddi", 2), ("ethernet", 3), ("atm", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasLigoType.setStatus('mandatory')
if mibBuilder.loadTexts: chasLigoType.setDescription("A building block's type.")
chasLigoSubtypeSelect = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 13, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasLigoSubtypeSelect.setStatus('mandatory')
if mibBuilder.loadTexts: chasLigoSubtypeSelect.setDescription('The chasLigoSubtypeIndex into the chasLigoSubtypeTable which describes the specific LIGO type a building block is selected to support. The value of this object must be a valid index in the chasLigoTable. A value of 0 indicates that no subtype has been selected.')
chasLigoSubtypeNumEntries = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 13, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasLigoSubtypeNumEntries.setStatus('mandatory')
if mibBuilder.loadTexts: chasLigoSubtypeNumEntries.setDescription('The number of entries in the chasLigoSubtypeTable.')
chasLigoSubtypeTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 13, 4), )
if mibBuilder.loadTexts: chasLigoSubtypeTable.setStatus('mandatory')
if mibBuilder.loadTexts: chasLigoSubtypeTable.setDescription('A list of LIGO (building blocks) subtypes.')
chasLigoSubtypeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 13, 4, 1), ).setIndexNames((0, "DECHUB900-CHASSIS-MIB-V3-0", "chasLigoSubtypeIndex"))
if mibBuilder.loadTexts: chasLigoSubtypeEntry.setStatus('mandatory')
if mibBuilder.loadTexts: chasLigoSubtypeEntry.setDescription("An entry containing objects which describe the building block's specific type.")
chasLigoSubtypeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 13, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasLigoSubtypeIndex.setStatus('mandatory')
if mibBuilder.loadTexts: chasLigoSubtypeIndex.setDescription('A unique value for each LIGO subtype.')
chasLigoSubtypeLigoIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 13, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasLigoSubtypeLigoIndex.setStatus('mandatory')
if mibBuilder.loadTexts: chasLigoSubtypeLigoIndex.setDescription('The value of the LigoIndex in the chasLigoTable that can use this subtype.')
chasLigoSubtypePortMask = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 13, 4, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasLigoSubtypePortMask.setStatus('mandatory')
if mibBuilder.loadTexts: chasLigoSubtypePortMask.setDescription('This object specifies the ports that are used by this LigoSubtype. It is a bit map of port indexes from the chasPortTable with bit 0 corresponding to port index 1. Bits set to 1 indicate the ports which are used by the LigoSubtype.')
chasLigoSubtypeLabelIndexMask = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 13, 4, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasLigoSubtypeLabelIndexMask.setStatus('mandatory')
if mibBuilder.loadTexts: chasLigoSubtypeLabelIndexMask.setDescription('This object specifies the labels that are used by this LigoSubtype. It is a bit map of if indexes from the chasLigoLabelTable with bit 0 corresponding to if index 1. Bits set to 1 indicate the labels which are used by the LigoSubtype.')
chasLigoSubtypeFlavor = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 13, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18))).clone(namedValues=NamedValues(("fddiRoot-Primary", 1), ("fddiRoot-Secondary", 2), ("fddiNonroot", 3), ("fddiTrunk-A-Primary", 4), ("fddiTrunk-A-Secondary", 5), ("fddiTrunk-B-Primary", 6), ("fddiTrunk-B-Secondary", 7), ("fddiTrunk-AB-Primary", 8), ("fddiTrunk-AB-Secondary", 9), ("fddiStump-Primary", 10), ("fddiStump-Secondary", 11), ("ethernet-front", 12), ("ethernet-back", 13), ("fddiNonroot-M", 14), ("fddiNonroot-S", 15), ("fddiNonroot-SM", 16), ("atm-front", 17), ("atm-back", 18)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasLigoSubtypeFlavor.setStatus('mandatory')
if mibBuilder.loadTexts: chasLigoSubtypeFlavor.setDescription("A building block's type.")
chasLigoSubtypePortMaskV2 = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 13, 4, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasLigoSubtypePortMaskV2.setStatus('mandatory')
if mibBuilder.loadTexts: chasLigoSubtypePortMaskV2.setDescription('This object specifies the ports that are used by this LigoSubtype. It is a bit map of port indexes from the chasPortTable with bit 0 corresponding to port index 1. This object supports twice as many ports in the hub as chasLigoSubtypePortMask. Bits set to 1 indicate the ports which are used by the LigoSubtype.')
chasLigoSubtypeLabelIndexMaskV2 = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 13, 4, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasLigoSubtypeLabelIndexMaskV2.setStatus('mandatory')
if mibBuilder.loadTexts: chasLigoSubtypeLabelIndexMaskV2.setDescription('This object specifies the labels that are used by this LigoSubtype. It is a bit map of if indexes from the chasLigoLabelTable with bit 0 corresponding to if index 1. This object supports twice as many ligos in the hub as chasLigoSubtypeLabelIndexMask. Bits set to 1 indicate the labels which are used by the LigoSubtype.')
chasLigoLabelNumEntries = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 13, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasLigoLabelNumEntries.setStatus('mandatory')
if mibBuilder.loadTexts: chasLigoLabelNumEntries.setDescription('The number of entries in the chasLigo label table.')
chasLigoLabelTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 13, 6), )
if mibBuilder.loadTexts: chasLigoLabelTable.setStatus('mandatory')
if mibBuilder.loadTexts: chasLigoLabelTable.setDescription('A list of Labels (for ports).')
chasLigoLabelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 13, 6, 1), ).setIndexNames((0, "DECHUB900-CHASSIS-MIB-V3-0", "chasLigoLabelIndex"))
if mibBuilder.loadTexts: chasLigoLabelEntry.setStatus('mandatory')
if mibBuilder.loadTexts: chasLigoLabelEntry.setDescription('An entry containing objects which describe the label of the port affected by the LIGO this module supports.')
chasLigoLabelIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 13, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasLigoLabelIndex.setStatus('mandatory')
if mibBuilder.loadTexts: chasLigoLabelIndex.setDescription('A unique value for each Label. The value of this object ranges between 1 and n where n is the total number of Labels supported by the device.')
chasLigoLabelString = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 13, 6, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasLigoLabelString.setStatus('mandatory')
if mibBuilder.loadTexts: chasLigoLabelString.setDescription('A textual description of the port number associated with a LIGO. If the device is bridge then bridge port number should be used for the ethernet and fddi. If the device is a wire concentrator then concentrator port numbers should be used.')
chasRingPatching = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 14, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chasRingPatching.setStatus('mandatory')
if mibBuilder.loadTexts: chasRingPatching.setDescription('Provides the means to enable and disable Backplane Auto Healing. When enabled, the Management Agent Module updates the chasRingMemberTable with the current backplane configuration, and takes action to repair FDDI rings and performs whatever steps are necessary for all other backplane technologies when a module is out of service. When disabled, all entries of the chasRingMember table are deleted and the Management Agent Module will not perform any Backplane Auto Healing.')
chasRingMemberTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 14, 2), )
if mibBuilder.loadTexts: chasRingMemberTable.setStatus('mandatory')
if mibBuilder.loadTexts: chasRingMemberTable.setDescription('A list of slots and their status.')
chasRingMemberEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 14, 2, 1), ).setIndexNames((0, "DECHUB900-CHASSIS-MIB-V3-0", "chasRingMemberSlot"))
if mibBuilder.loadTexts: chasRingMemberEntry.setStatus('mandatory')
if mibBuilder.loadTexts: chasRingMemberEntry.setDescription('An entry containing the objects which describe the slots and their patching status.')
chasRingMemberSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 14, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasRingMemberSlot.setStatus('mandatory')
if mibBuilder.loadTexts: chasRingMemberSlot.setDescription('The backplane slot ID for this entry. Only slots that are currently eligible for patching will appear in the table.')
chasRingMemberSegment = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 14, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasRingMemberSegment.setStatus('mandatory')
if mibBuilder.loadTexts: chasRingMemberSegment.setDescription('The FDDI network segment for which this entry contains information, from chasSegmentIndex. This object is superceded by the chasRingMemberSegmentMask, but is left here for backwards compatibility.')
chasRingMemberStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 14, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("in", 1), ("out", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasRingMemberStatus.setStatus('mandatory')
if mibBuilder.loadTexts: chasRingMemberStatus.setDescription('The current patch status of the slot. in(1) means that the linecard is an active part of the hub. out(2) means the linecard has been patched around if necessary, and is not currently attached to its backplane LAN(s).')
chasRingMemberSegmentMask = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 1, 1, 1, 14, 2, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: chasRingMemberSegmentMask.setStatus('mandatory')
if mibBuilder.loadTexts: chasRingMemberSegmentMask.setDescription('This object specifies the segments that are used by this slot module. It is a bit map of segment indexes from the chasSegmentTable with bit 0 corresponding to segment index 1. Bits set to 1 indicate the segments which are used by the slot module.')
mibBuilder.exportSymbols("DECHUB900-CHASSIS-MIB-V3-0", chasRingPatching=chasRingPatching, chasLoad=chasLoad, chasLigoLabelTable=chasLigoLabelTable, decHub900=decHub900, chasSlotModuleSerialNumber=chasSlotModuleSerialNumber, chasPowerConfigIndex=chasPowerConfigIndex, chasLigoSubtypeIndex=chasLigoSubtypeIndex, chasLigoSubtypePortMask=chasLigoSubtypePortMask, chasBackplaneIndex=chasBackplaneIndex, chasSlot=chasSlot, chasPortSubtypeTable=chasPortSubtypeTable, decMIBextension=decMIBextension, chasRingMemberSegment=chasRingMemberSegment, chasSlotLastChange=chasSlotLastChange, chasEntityChangeSlot=chasEntityChangeSlot, chasEntityAccessMethod=chasEntityAccessMethod, chasPowerSink=chasPowerSink, chasPowerSourceTotalPowerAvailable=chasPowerSourceTotalPowerAvailable, chasPowerSinkWattage=chasPowerSinkWattage, chasConnIndex=chasConnIndex, chasEnvironWarnings=chasEnvironWarnings, chasEntityIndex=chasEntityIndex, chasMaxExtendedSlots=chasMaxExtendedSlots, chasEnvironAdminStatus=chasEnvironAdminStatus, chasLoadTable=chasLoadTable, chasLigoEntry=chasLigoEntry, chasSlotModuleSize=chasSlotModuleSize, dec=dec, chasConnChanges=chasConnChanges, chasEntityVersion=chasEntityVersion, chasPortSubtypeIndex=chasPortSubtypeIndex, chasPowerSinkTable=chasPowerSinkTable, chasConnNextPortIndex=chasConnNextPortIndex, chasEntitySlotNumber=chasEntitySlotNumber, chasBackplaneNumSlots=chasBackplaneNumSlots, chasEntityChanges=chasEntityChanges, chasSegmentType=chasSegmentType, chasLigoLabelString=chasLigoLabelString, chasSegmentEntryStatus=chasSegmentEntryStatus, chasEntityAccessLoadTable=chasEntityAccessLoadTable, chasLigoSlot=chasLigoSlot, chasLigoSubtypeTable=chasLigoSubtypeTable, chasRingMemberStatus=chasRingMemberStatus, chasPowerConfig=chasPowerConfig, chasSegSubtypeSpeed=chasSegSubtypeSpeed, chasEntity=chasEntity, chasEntityChangeTable=chasEntityChangeTable, chasPowerSourceIndex=chasPowerSourceIndex, chasConnEntry=chasConnEntry, chasPortDescr=chasPortDescr, chasEntityAccessLoadSlot=chasEntityAccessLoadSlot, chasPortDescrIndex=chasPortDescrIndex, chasPowerSourceSupplyIndex=chasPowerSourceSupplyIndex, chasSegSubtypeFlavor=chasSegSubtypeFlavor, chasBackplane=chasBackplane, chasPowerConfigNumSupplies=chasPowerConfigNumSupplies, chasLigoLabelIndex=chasLigoLabelIndex, chasPortSubtypeSelect=chasPortSubtypeSelect, chasLoadEntry=chasLoadEntry, chasEnvironSlotIndex=chasEnvironSlotIndex, chasPortSubtypeSpeed=chasPortSubtypeSpeed, chasSlotModuleOperStatus=chasSlotModuleOperStatus, chasPowerSource=chasPowerSource, chasLoadIpHostAddr=chasLoadIpHostAddr, chasLigoSubtypeSelect=chasLigoSubtypeSelect, chasSegSubtypeEntryStatus=chasSegSubtypeEntryStatus, chasEnvironEntry=chasEnvironEntry, chasConnTable=chasConnTable, chasLigoLabelNumEntries=chasLigoLabelNumEntries, chasLigoSubtypeNumEntries=chasLigoSubtypeNumEntries, chasEntityFunction=chasEntityFunction, chasEnvironTable=chasEnvironTable, chasSegSubtypeTable=chasSegSubtypeTable, chasLigoNumEntries=chasLigoNumEntries, chasEntityChangeEntry=chasEntityChangeEntry, chasPortSubtypePortIndex=chasPortSubtypePortIndex, chasNumSlots=chasNumSlots, chasPowerSourceTotalCurrentAvailable=chasPowerSourceTotalCurrentAvailable, chasLigoSubtypeLabelIndexMaskV2=chasLigoSubtypeLabelIndexMaskV2, chasPowerSinkIndex=chasPowerSinkIndex, chasPopulationChanges=chasPopulationChanges, chasLoadOperStatus=chasLoadOperStatus, ema=ema, mgmtAgentVersion1=mgmtAgentVersion1, chasSlotEntry=chasSlotEntry, chasPowerSourceEntry=chasPowerSourceEntry, chasLigoSubtypePortMaskV2=chasLigoSubtypePortMaskV2, chasLoadFileName=chasLoadFileName, chasEnvironSensor=chasEnvironSensor, chasEnvironOperStatus=chasEnvironOperStatus, chasSlotModuleType=chasSlotModuleType, chasBackplaneTable=chasBackplaneTable, chasPortEntry=chasPortEntry, chasPortDescrEntry=chasPortDescrEntry, chasPowerConfigAdminStatus=chasPowerConfigAdminStatus, chasLigoSubtypeLabelIndexMask=chasLigoSubtypeLabelIndexMask, chasPortLastChange=chasPortLastChange, chasLigoSubtypeFlavor=chasLigoSubtypeFlavor, chasLigoIndex=chasLigoIndex, chasEntityOperStatus=chasEntityOperStatus, chasLigoSubtypeLigoIndex=chasLigoSubtypeLigoIndex, chasPortSlot=chasPortSlot, chasEntityChangeCounter=chasEntityChangeCounter, chasEntityParty=chasEntityParty, chasSegmentEntry=chasSegmentEntry, chasLoadSlotIndex=chasLoadSlotIndex, chasRingMemberTable=chasRingMemberTable, chasSlotTable=chasSlotTable, chasPortTable=chasPortTable, chasSlotModuleNonFatalError=chasSlotModuleNonFatalError, chasLigoSubtypeEntry=chasLigoSubtypeEntry, chasPowerConfigDescr=chasPowerConfigDescr, chasRingMemberEntry=chasRingMemberEntry, chasPortSubtypeEntry=chasPortSubtypeEntry, chasSlotModuleVersion=chasSlotModuleVersion, chasEntityTable=chasEntityTable, chasRingMemberSlot=chasRingMemberSlot, chasPowerConfigMaxSupplies=chasPowerConfigMaxSupplies, chasPowerSinkVoltage=chasPowerSinkVoltage, chasSlotModuleDescr=chasSlotModuleDescr, chasEntityDescr=chasEntityDescr, chasEntityAdminStatus=chasEntityAdminStatus, chasConnEntryStatus=chasConnEntryStatus, chasEnvironChanges=chasEnvironChanges, chasBackplaneEntry=chasBackplaneEntry, chasExtendedSlotsOccupied=chasExtendedSlotsOccupied, chasEntityAccessLoadMethod=chasEntityAccessLoadMethod, chasLigoType=chasLigoType, chasLoadDevSpecific=chasLoadDevSpecific, chasEnvironFailures=chasEnvironFailures, chasPortOperStatus=chasPortOperStatus, chasSegSubtypeIndex=chasSegSubtypeIndex, chasPowerConfigChanges=chasPowerConfigChanges, chasPowerConfigTable=chasPowerConfigTable, chasPort=chasPort, chasSegment=chasSegment, chasChassisSerialNumber=chasChassisSerialNumber, chasPowerSinkSlotIndex=chasPowerSinkSlotIndex, chasLigoTable=chasLigoTable, chasSegSubtypeEntry=chasSegSubtypeEntry, chasBackplaneDescr=chasBackplaneDescr, chasPowerSourcePower=chasPowerSourcePower, chasSlotResetAll=chasSlotResetAll, chasBackplaneRev=chasBackplaneRev, chasSegmentIndex=chasSegmentIndex, chasPortIndex=chasPortIndex, chasLigoLabelEntry=chasLigoLabelEntry, chasConnPort=chasConnPort, chasEntityObjectID=chasEntityObjectID, chasEntityComAccessRights=chasEntityComAccessRights, chasEntitySrcSubnetMask=chasEntitySrcSubnetMask, chassis=chassis, chasPowerSourceNominalVoltage=chasPowerSourceNominalVoltage, chasEntityCommunity=chasEntityCommunity, chasEntitySrcIpAddress=chasEntitySrcIpAddress, chasLoadEntryStatus=chasLoadEntryStatus, chasPowerConfigHealthText=chasPowerConfigHealthText, chasNumSlotsOccupied=chasNumSlotsOccupied, chasPortSubtypeFlavor=chasPortSubtypeFlavor, chasPatching=chasPatching, chasPowerSinkOperStatus=chasPowerSinkOperStatus, mgmtAgent=mgmtAgent, chasConnSegment=chasConnSegment, chasPortName=chasPortName, chasPortDescrTable=chasPortDescrTable, chasLigo=chasLigo, chasEnviron=chasEnviron, chasPowerConfigRedundancyState=chasPowerConfigRedundancyState, chasPowerConfigEntry=chasPowerConfigEntry, chasRingMemberSegmentMask=chasRingMemberSegmentMask, chasPowerConfigWarnings=chasPowerConfigWarnings, chasEnvironSensorIndex=chasEnvironSensorIndex, chasPowerSourceTable=chasPowerSourceTable, chasSegmentSubtypeSelect=chasSegmentSubtypeSelect, chasSegmentName=chasSegmentName, chasPowerSinkEntry=chasPowerSinkEntry, chasPowerConfigOperStatus=chasPowerConfigOperStatus, chasConfig=chasConfig, chasLoadAdminStatus=chasLoadAdminStatus, chasEntityIpAddress=chasEntityIpAddress, chasPowerConfigFailures=chasPowerConfigFailures, chasEntityEntry=chasEntityEntry, chasEntityTimeStamp=chasEntityTimeStamp, chasEntityAccessCharacteristics=chasEntityAccessCharacteristics, chasEntityAccessLoadEntry=chasEntityAccessLoadEntry, chasSegmentTable=chasSegmentTable, chasSegDefVNbusState=chasSegDefVNbusState, chasSlotModuleAdminStatus=chasSlotModuleAdminStatus, chasPortType=chasPortType, chasSlotIndex=chasSlotIndex)

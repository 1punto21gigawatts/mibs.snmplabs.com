#
# PySNMP MIB module CISCO-VISM-DSX1-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-VISM-DSX1-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:18:31 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, SingleValueConstraint, ValueRangeConstraint, ConstraintsUnion, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "SingleValueConstraint", "ValueRangeConstraint", "ConstraintsUnion", "ValueSizeConstraint")
dsx1, = mibBuilder.importSymbols("BASIS-MIB", "dsx1")
dsx1AlmGrp, = mibBuilder.importSymbols("CISCO-MGX82XX-DSX1-MIB", "dsx1AlmGrp")
ciscoWan, = mibBuilder.importSymbols("CISCOWAN-SMI", "ciscoWan")
ObjectGroup, ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "ModuleCompliance", "NotificationGroup")
MibIdentifier, Counter64, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, Bits, Integer32, TimeTicks, Unsigned32, Counter32, iso, ModuleIdentity, IpAddress, Gauge32, ObjectIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "MibIdentifier", "Counter64", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Bits", "Integer32", "TimeTicks", "Unsigned32", "Counter32", "iso", "ModuleIdentity", "IpAddress", "Gauge32", "ObjectIdentity")
DisplayString, TextualConvention, TimeStamp, TruthValue = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention", "TimeStamp", "TruthValue")
ciscoVismDsx1MIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 351, 150, 79))
ciscoVismDsx1MIB.setRevisions(('2005-09-30 00:00', '2005-01-20 00:00', '2004-04-16 00:00', '2004-03-09 00:00', '2004-02-17 00:00', '2004-02-15 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ciscoVismDsx1MIB.setRevisionsDescriptions(('Added new objects: - vismDsx1AlarmLogEnable - vismDsx1AlarmLogAdminTimer - vismDsx1AlarmLogOperTimer - vismDsx1ElectricalSignalEnable ', 'Added new object: - vismDsx1V110Enable ', 'Added new objects - dsx1TxUncontrolledSlips - dsx1RxUncontrolledSlips - dsx1TxFrameSlips - dsx1RxFrameSlips - vismDsx1TotalTxUncontrolledSlips - vismDsx1TotalTxFrameSlips - vismDsx1TotalRxUncontrolledSlips - vismDsx1TotalRxFrameSlips The above counters maintain slip statistics for the system. - vismSlipCntDiscontinuityTime ', 'Added new object - vismBearerBusyCode', 'The following MIB are deprecated prior to SMIv2 conversion, vismEcanToneDisable, vismEcanCnfNRN and vismCadenceTime. ', 'Initial version of the MIB. The content of this MIB was originally available in SMIv1 version. The MIB has been converted to SMIv2 version and descriptions of some of the objects have been modified. ',))
if mibBuilder.loadTexts: ciscoVismDsx1MIB.setLastUpdated('200509300000Z')
if mibBuilder.loadTexts: ciscoVismDsx1MIB.setOrganization('Cisco Systems, Inc.')
if mibBuilder.loadTexts: ciscoVismDsx1MIB.setContactInfo('Cisco Systems Customer Service Postal: 170 W Tasman Drive San Jose, CA 95134 USA Tel: +1 800 553-NETS E-mail: cs-wanatm@cisco.com')
if mibBuilder.loadTexts: ciscoVismDsx1MIB.setDescription('The MIB module to configure DS1/E1 interface objects in a Voice Interworking Service Module (VISM) module. This MIB is an extension to CISCO-MGX82XX-DSX1-MIB for DS1/E1 configuration in VISM. Terms used: CID: Channel Identifier CAS: Channel Associated Signaling CCS: Common Channel Signaling DTMF: Dual Tone Multi Frequency NSE: Name Signal Event NTE: Name Telephony Event PVC: Permanent Virtual Circuit ')
dsx1Vism = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 5))
dsx1VismCnfGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 5, 1))
dsx1VismStatsGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 5, 2))
dsx1VismCnfGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 5, 1, 1), )
if mibBuilder.loadTexts: dsx1VismCnfGrpTable.setStatus('current')
if mibBuilder.loadTexts: dsx1VismCnfGrpTable.setDescription('The VISM specific DS1/E1 configuration table. This table contains the additional VISM configuration information for DS1/E1. ')
dsx1VismCnfGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 5, 1, 1, 1), ).setIndexNames((0, "CISCO-VISM-DSX1-MIB", "vismLineNum"))
if mibBuilder.loadTexts: dsx1VismCnfGrpEntry.setStatus('current')
if mibBuilder.loadTexts: dsx1VismCnfGrpEntry.setDescription("An entry in the VISM Dsx1 Configuration table. An entry is created when a DS1/E1 is added. An entry is deleted when a DS1/E1 is deleted. The DS1/E1 is specify by 'lineEnable' object in CISCO-MGX82XX-DSX1-MIB. ")
vismLineNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 5, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismLineNum.setStatus('current')
if mibBuilder.loadTexts: vismLineNum.setDescription('This object identifies the DS1/E1 interface number. ')
vismEcanEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 5, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismEcanEnabled.setStatus('current')
if mibBuilder.loadTexts: vismEcanEnabled.setDescription("This object disable/enable echo cancellation. 'disable' : disable echo cancellation. 'enable' : enable echo cancellation. ")
vismEcanToneDisable = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 5, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("ignore", 1), ("g-164", 2), ("reserve", 3), ("g-165", 4))).clone('g-165')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismEcanToneDisable.setStatus('deprecated')
if mibBuilder.loadTexts: vismEcanToneDisable.setDescription("This object determines the behavior of the echo canceler in the presence of a modem. 'ignore': Ignore 2100 Hz modem answer tone. 'g-164' : G-164 mode, disable the canceler for all the tones, phase reversing or not. 'reserve': Reserved setting the value to 'reserve(3)' results in BadValue error. 'g-165': G.165 mode, disable the canceler for phase reversing tone only (V.8 modulated phase reversing tone as well as the V.fast non standard phase reversing tone). ")
vismEcanCnfNRN = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 5, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("reenableOnModemData", 1), ("reenableOnCallEnd", 2))).clone('reenableOnModemData')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismEcanCnfNRN.setStatus('deprecated')
if mibBuilder.loadTexts: vismEcanCnfNRN.setDescription("Echo canceler re-enable (NRN). This object determines when an echo canceler re-enable and begins cancellation after it has been disabled. 'reenableOnModemData': Re-enable canceler when modem data is gone (low energy). 'reenableOnCallEnd' : Re-enable canceler at end of call, This object is not applicable when vismEcanToneDisable 'ignore'. ")
vismEcanTail = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 5, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(24, 128)).clone(32)).setUnits('milliseconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismEcanTail.setStatus('current')
if mibBuilder.loadTexts: vismEcanTail.setDescription('This object identifies the maximum tail. The object should be set just higher than the worst round trip delay anticipated. Convergence times may increase for longer tails and more resource will be used. Only following discrete values are allowed: 24, 32, 48, 64, 80, 96, 112 and 128.')
vismEcanREC = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 5, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("cancelOnly", 1), ("suppressResidual", 2), ("reserved", 3), ("comfortNoise", 4))).clone('suppressResidual')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismEcanREC.setStatus('current')
if mibBuilder.loadTexts: vismEcanREC.setDescription("Residual Echo Control (REC) instructs the canceler how to treat echo remaining after cancellation. 'cancelOnly' : REC is disabled. 'suppressResidual': The residual echo is replaced with silence. 'comfortNoise' : Noise is injected in place of residual echo at the same level as the ambient noise at the near end. 'reserved' : Results in BadValue error. ")
vismCompCnfVAD = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 5, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismCompCnfVAD.setStatus('current')
if mibBuilder.loadTexts: vismCompCnfVAD.setDescription("This object identifies VAD (Voice Activity Detection). 'disable': Disable VAD on the compression DSPs. 'enable' : Enable VAD on the compression DSPs. ")
vismSignalingType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 5, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("cas", 1), ("ccs", 2), ("none", 3))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismSignalingType.setStatus('current')
if mibBuilder.loadTexts: vismSignalingType.setDescription("This object specifies the type of signaling used for the line. 'cas' : Channel Associated Signaling. 'ccs' : Common Channel Signaling. 'none' : No signaling used. This cannot be modified if endpoints are present. and if CIDs/CCS channels are associated with this line in aal2Trunking mode. Setting of this object to CAS signaling type is not allowed if any of the DS0s on this line have loop back set to RemoteLoop or if any of the DS0's has ds0InsertLocalCas enabled. RemoteLoop and ds0InsertLocalCas from CISCO-VISM-DSX0-MIB. Line signaling type cannot be changed if there are endpoints present, irrespective of mode/application. ")
vismCcsChannels = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 5, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismCcsChannels.setStatus('current')
if mibBuilder.loadTexts: vismCcsChannels.setDescription("This object describes the CCS signaling channels or DS0s (also referred to as D-channel). It is used only for lines configured as CCS signaling type. It is a bit map of the DS0s configured as D channel. A one in the bit position represents that DS0 as the D channel. In most of the applications, only one D channel per T or E span is required. However, since some applications may require multiple D channels, this is supported by providing a bit map. This attribute is set by 'addccs' CLI command. ")
vismCadenceTime = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 5, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(50, 200)).clone(100)).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: vismCadenceTime.setStatus('deprecated')
if mibBuilder.loadTexts: vismCadenceTime.setDescription('This object describes the cadence time for CAS signals. This object is applicable only for CAS backhaul applications. For trunking application it is not applicable. ')
vismTrunkConditionEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 5, 1, 1, 1, 11), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismTrunkConditionEnable.setStatus('current')
if mibBuilder.loadTexts: vismTrunkConditionEnable.setDescription('This object determines if trunk conditioning should be enabled or disabled on this line. If this object is set to true(1), VISM will do trunk conditioning on the affected DS0s on this line when it sees an alarm (AIS) on the ATM side, instead of sending AIS on the line side. If there are endpoints or CCS channels enabled on a line then setting of this object is not allowed. Trunk conditioning: VISM will transmit idle code pattern for the first 2.5 secs and then will transmit seized code which is configured in ds0IdleCode and ds0SeizedCode respectively, ds0IdleCode and ds0SeizedCode from CISCO-VISM-DSX0-MIB. This object is applicable only in trunking application. This object can be set in all applications but will be applicable in trunking application only. ')
vismDsx1CircuitIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 5, 1, 1, 1, 12), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismDsx1CircuitIdentifier.setStatus('current')
if mibBuilder.loadTexts: vismDsx1CircuitIdentifier.setDescription('This object is the identifier of a T1/E1 line. It contains alphanumeric description of a line for the purpose of better identification. ')
vismDsx1TxDigitOrder = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 5, 1, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("aniThenDnis", 1), ("dnisThenAni", 2))).clone('aniThenDnis')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismDsx1TxDigitOrder.setStatus('current')
if mibBuilder.loadTexts: vismDsx1TxDigitOrder.setDescription('When the call agent hands the ANI (Automatic Number Identification, denoting the calling party number) and the DNIS (Destination Number Identification Service, indicating the called party number) to the gateway for dialing out, the gateway (by default) dials out the ANI followed by the DNIS. This object indicates the order in which ANI and DNIs will be dialed out from this (outgoing) interface. ')
vismDsx1TonePlanRegion = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 5, 1, 1, 1, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismDsx1TonePlanRegion.setStatus('current')
if mibBuilder.loadTexts: vismDsx1TonePlanRegion.setDescription("This object specifies regional tone plan string. If the value of the object is 'NULL' then it will be considered non usable, and non 'NULL' is (usable or activated and related to an entry in the vismTonePlanTable table). This object must be compatible with the vismDsx1TonePlanVersion object below, where both objects must either be NULL or where both objects must be non NULL. The vismTonePlanTable table consists of 32 slots which are configurable (provisionable) followed by a release dependent number of slots for built-in entries which are not configurable, but loaded from values stored in the internal firmware of the release. As releases are continued, the number of built-in slots will typically increase. The total number of slots in this table consists of the sum of the 32 provisionable slots plus an unspecified number of built-in slots and the built-in number and this sum represents the size of this table. In the case where these two objects are non NULL, this object, along with the vismDsx1TonePlanVersion object below, must exactly match an entry in the vismTonePlanTable. In the case where these objects are considered to be a NULL object, its behavior and contents are described in paragraph five of this description block. The allowed range and contents of this object in the non NULL case is the same as the tonePlanRegionName object in the vismTonePlanTable. This object will thus consist of a 1 to 64 alphabetic, numeric, or underscore character string, with no embedded spaces. And this object plus the vismDsx1TonePlanVersion object below, must exactly match an existing valid entry in the vismTonePlanTable, vismTonePlanTable is specify in CISCO-WAN-VISM-TONE-PLAN-MIB. In the case where this object is NULL, this object will consist of a single space character of size one. A NULL value for this object will make the vismDsx1RingingTO, vismDsx1RingBackTO, vismDsx1BusyTO, vismDsx1ReorderTO, vismDsx1DialTO, vismDsx1StutterDialTO, vismDsx1OffHookAlertTO, and vismDsx1RemoteRingback. ")
vismDsx1TonePlanVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 5, 1, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismDsx1TonePlanVersion.setStatus('current')
if mibBuilder.loadTexts: vismDsx1TonePlanVersion.setDescription('This object will either be considered NULL (i.e. non usable) or non NULL (usable or activated and related to an entry in the vismTonePlanTable table). This object must be compatible with the vismDsx1TonePlanRegion object above, where both objects must either be NULL or where both objects must be non NULL. The vismTonePlanTable table consists of 32 slots which are configurable (provisionable) followed by a release dependent number of slots for built-in entries which are not configurable, but loaded from values stored in the internal firmware of the release. As releases are continued, the number of built-in slots will typically increase. The total number of slots in this table consists of the sum of the 32 provisionable slots plus an unspecified number of built-in slots and the built-in number and this sum represents the size of this table. In the case where these two objects are non NULL, this object, along with the vismDsx1TonePlanRegion object above, must exactly match an entry in the vismTonePlanTable. In the case where these objects are considered to be a NULL object, its behavior and contents are described in paragraph five of this description block. The allowed range and contents of this object in the non NULL case is the same as the tonePlanVersionNumber object in the vismTonePlanTable. This object will thus consist of a non zero numeric value. And this object plus the vismDsx1TonePlanRegion object above, must exactly match an existing valid entry in the vismTonePlanTable. In the case where this object is NULL, this object will consist of a zero numeric value. A NULL value for this object will make the vismDsx1RingingTO, vismDsx1RingBackTO, vismDsx1BusyTO, vismDsx1ReorderTO, vismDsx1DialTO, vismDsx1StutterDialTO, vismDsx1OffHookAlertTO, and vismDsx1RemoteRingback. ')
vismDsx1RingingTO = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 5, 1, 1, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3600)).clone(180)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismDsx1RingingTO.setStatus('current')
if mibBuilder.loadTexts: vismDsx1RingingTO.setDescription("Time in seconds for which the ringing cadence will be generated towards the basic PBX unless interrupted (e.g. by the answer from the called party or a delete connection command from the Call Agent). This is also the time for which remote inband ring back tone will be played towards the packet network. The value Zero indicates that the cadence will be generated indefinitely unless interrupted. This MIB object is not applicable unless the value of vismDsx1TonePlanRegion and vismDsx1TonePlanVersion MIB objects are not 'NULL' string. ")
vismDsx1RingBackTO = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 5, 1, 1, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3600)).clone(180)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismDsx1RingBackTO.setStatus('current')
if mibBuilder.loadTexts: vismDsx1RingBackTO.setDescription("Time in seconds for which the local ring back tone (towards the TDM) will be generated unless interrupted (e.g. by the answer from the called party or a delete connection command from the Call Agent). The value Zero indicates that the tone will be generated indefinitely unless interrupted. This MIB object is not applicable unless the value of vismDsx1TonePlanRegion and vismDsx1TonePlanVersion MIB objects are not 'NULL' string. ")
vismDsx1BusyTO = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 5, 1, 1, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3600)).clone(30)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismDsx1BusyTO.setStatus('current')
if mibBuilder.loadTexts: vismDsx1BusyTO.setDescription("Time in seconds for which the busy tone will be generated unless interrupted (e.g. by the hangup from the calling party). The value Zero indicates that the tone will be generated indefinitely unless interrupted. This MIB object is not applicable unless the value of vismDsx1TonePlanRegion and vismDsx1TonePlanVersion MIB objects are not 'NULL' string. ")
vismDsx1ReorderTO = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 5, 1, 1, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3600)).clone(30)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismDsx1ReorderTO.setStatus('current')
if mibBuilder.loadTexts: vismDsx1ReorderTO.setDescription("Time in seconds for which the reorder/fast busy tone will be generated unless interrupted (e.g. by the hangup from the calling party). The value zero indicates that the tone will be generated indefinitely unless interrupted. This MIB object is not applicable unless the value of vismDsx1TonePlanRegion and vismDsx1TonePlanVersion MIB objects are not 'NULL' string. ")
vismDsx1DialTO = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 5, 1, 1, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3600)).clone(16)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismDsx1DialTO.setStatus('current')
if mibBuilder.loadTexts: vismDsx1DialTO.setDescription("Time in seconds for which the dial tone will be generated unless interrupted (e.g. by the first DTMF digit from the calling party). The value Zero indicates that the tone will be generated indefinitely unless interrupted. This MIB object is not applicable unless the value of vismDsx1TonePlanRegion and vismDsx1TonePlanVersion MIB objects are not 'NULL' string. ")
vismDsx1StutterDialTO = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 5, 1, 1, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3600)).clone(16)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismDsx1StutterDialTO.setStatus('current')
if mibBuilder.loadTexts: vismDsx1StutterDialTO.setDescription("Time in seconds for which the stutter dial tone/confirmation dial tone will be generated unless interrupted (e.g. by the first DTMF digit from the calling party). The value Zero indicates that the tone will be generated indefinitely unless interrupted. This MIB object is not applicable unless the value of vismDsx1TonePlanRegion and vismDsx1TonePlanVersion MIB objects are not 'NULL' string. ")
vismDsx1OffHookAlertTO = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 5, 1, 1, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3600)).clone(5)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismDsx1OffHookAlertTO.setStatus('current')
if mibBuilder.loadTexts: vismDsx1OffHookAlertTO.setDescription("Time in seconds for which the off-hook alert tone will be generated unless interrupted (e.g. caller hangup). The value Zero indicates that the tone will be generated indefinitely unless interrupted. This MIB object is not applicable unless the value of vismDsx1TonePlanRegion and vismDsx1TonePlanVersion MIB objects are not 'NULL' string. ")
vismDsx1RemoteRingback = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 5, 1, 1, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("proxy", 1), ("inband", 2))).clone('proxy')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismDsx1RemoteRingback.setStatus('current')
if mibBuilder.loadTexts: vismDsx1RemoteRingback.setDescription("This object specifies the remote ring back method on endpoints on this DS1/E1. This object can have the following values: 'proxy(1)': This gateway sends the appropriate packet (NSE, NTE, or AAL-2 Type 3) for ring back to the originating gateway which in turn generates the ringback tone towards the TDM network. 'inband(2)': This gateway will generate the inband ringback tone towards the originating gateway over the packet network and the originating gateway plays it. This MIB object is not applicable unless the value of vismDsx1TonePlanRegion and vismDsx1TonePlanVersion MIB objects are not 'NULL' string. ")
vismDsx1MidcallTpart = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 5, 1, 1, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 10000)).clone(16)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismDsx1MidcallTpart.setStatus('current')
if mibBuilder.loadTexts: vismDsx1MidcallTpart.setDescription('This object represents the partial dial timing in seconds and is used along with a digit map as the inter-digit timer. This object is used for both CAS and non CAS endpoints when doing mid call DTMF digit reporting. The timer is not started until the first digit is entered, and the timer is restarted after each new digit is entered until either a digit map match or mismatch occurs. ')
vismDsx1MidcallTcrit = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 5, 1, 1, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000)).clone(4)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismDsx1MidcallTcrit.setStatus('current')
if mibBuilder.loadTexts: vismDsx1MidcallTcrit.setDescription('This object represents the critical timing in seconds. If used along with a digit map, the timer is started when the last digit is received i.e when no more digits are required for a digit map match. After this timer expires, the digit map match is assumed to be complete. If used without a digit map, the timer is started immediately and cancelled (but not restarted) as soon as a digit is entered. This object is used for both CAS and non CAS endpoints when doing mid call DTMF digit reporting. ')
vismDsx1Sa4Byte = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 5, 1, 1, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismDsx1Sa4Byte.setStatus('current')
if mibBuilder.loadTexts: vismDsx1Sa4Byte.setDescription('This is a spare bit on T1/E1 Framer reserved for international standardization. ')
vismDsx1Sa5Byte = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 5, 1, 1, 1, 27), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismDsx1Sa5Byte.setStatus('current')
if mibBuilder.loadTexts: vismDsx1Sa5Byte.setDescription('This is a spare bit on T1/E1 Framer reserved for international standardization. ')
vismDsx1Sa6Byte = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 5, 1, 1, 1, 28), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismDsx1Sa6Byte.setStatus('current')
if mibBuilder.loadTexts: vismDsx1Sa6Byte.setDescription('This is a spare bit on T1/E1 Framer reserved for international standardization. ')
vismDsx1Sa7Byte = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 5, 1, 1, 1, 29), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismDsx1Sa7Byte.setStatus('current')
if mibBuilder.loadTexts: vismDsx1Sa7Byte.setDescription('This is a spare bit on T1/E1 Framer reserved for international standardization. ')
vismDsx1Sa8Byte = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 5, 1, 1, 1, 30), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismDsx1Sa8Byte.setStatus('current')
if mibBuilder.loadTexts: vismDsx1Sa8Byte.setDescription('This is a spare bit on T1/E1 Framer reserved for international standardization. ')
vismDsx1State = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 5, 1, 1, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("invalid", 1), ("is", 2), ("oos", 3), ("poos", 4), ("coos", 5), ("inactive", 6))).clone('inactive')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismDsx1State.setStatus('current')
if mibBuilder.loadTexts: vismDsx1State.setDescription('This object will allow the line administrative state (in service and out of service) to be persistent. invalid (1) : invalid state. is (2) : in service oos (3) : out of service poos (4) : pending out of service coos (5) : command out of service inactive(6) : inactive ')
vismDsx1AdminStateControl = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 5, 1, 1, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("inService", 1), ("forcefulOutOfService", 2), ("gracefulOutOfService", 3), ("inactive", 4))).clone('inactive')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismDsx1AdminStateControl.setStatus('current')
if mibBuilder.loadTexts: vismDsx1AdminStateControl.setDescription("This control object is used to change the service state of the line from 'is' to 'coos' or from 'coos' to 'is'. The resulting service state of the line is represented by vismDsx1State. 'inService': Transition vismDsx1State to 'is'(in service). In the course, the MG's MGCs may get notified of this transition, e.g. in the case of MGCP through emission of RSIPs to registered call agents according to policy. 'forcefulOutOfService': Take the line out-of-service forcefully. This releases any resources at the line. In the course, the MGCs may get notified of this transition, e.g. in the case of MGCP through emission of RSIPs to registered call agents according to policy. 'gracefulOutOfService': Take the line out-of-service gracefully. If there are no resources existing, vismDsx1State transitions to coos immediately. If resources exist, vismDsx1State transitions to poos thus initiating a graceful shutdown. In the course, the MG's MGCs may get notified of this transition, e.g. in the case of MGCP through emission of RSIPs to registered call agents according to policy. 'inactive': Indicates the vismDsx1State is in inactive state. ")
vismBearerBusyCode = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 5, 1, 1, 1, 33), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismBearerBusyCode.setStatus('current')
if mibBuilder.loadTexts: vismBearerBusyCode.setDescription("This object is used when vismTrunkConditionEnable is enabled on a line. It is a configurable busy pattern sent out on the 'Bearer' on the channels, which are receiving remote ATM channel ID (CID) alarms. If this object is not set, it assumes a default value of 255 for E1 and 127 for T1.")
vismDsx1V110Enable = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 5, 1, 1, 1, 34), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismDsx1V110Enable.setStatus('current')
if mibBuilder.loadTexts: vismDsx1V110Enable.setDescription("This object specifies whether V.110 detection on the line is enabled or disabled. If the value of this object is 'true', V.110 detection on the line is enabled. If the value of this object is 'false', V.110 detection on the line is disabled. The vismSignalingType object must be set to ccs when enabling V.110 detection.")
vismDsx1AlarmLogEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 5, 1, 1, 1, 35), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismDsx1AlarmLogEnable.setStatus('current')
if mibBuilder.loadTexts: vismDsx1AlarmLogEnable.setDescription('This object specifies whether detailed alarm logging on the DS1 is enabled or disabled. If this object is true, detailed alarm logging for the DS1 will be enabled. If this object is false, detailed alarm logging for the DS1 will be disabled. When this object is enabled, vismDsx1AlarmLogAdminTimer will indicate the time configured in minutes for which this object will continue to remain enabled. While, vismDsx1AlarmLogOperTimer will indicate the time in minutes remaining for the alarm logging to continue to remain enabled. Alarm logging can be disabled before the time specified in vismDsx1AlarmLogAdminTimer runs out. If alarm logging is disabled before the timer runs out, then on re-enabling the logging, the vismDsx1AlarmLogAdminTimer will need to be reconfigured as well.')
vismDsx1AlarmLogAdminTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 5, 1, 1, 1, 36), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)).clone(7200)).setUnits('minutes').setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismDsx1AlarmLogAdminTimer.setStatus('current')
if mibBuilder.loadTexts: vismDsx1AlarmLogAdminTimer.setDescription('This object specifies the time for which the detailed alarm logging for the DS1 will remain active. The value in this object can be set and is valid only if vismDsx1AlarmLogEnable for this DS1 is set to true. If this object is set to 0, it indicates that the alarm logging will remain active forever. Once set, this object can be overwritten as long as vismDsx1AlarmLogEnable is true. If this is done, the vismDsx1AlarmLogAdminTimer will be refreshed to take the new value set in this object.')
vismDsx1AlarmLogOperTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 5, 1, 1, 1, 37), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setUnits('minutes').setMaxAccess("readonly")
if mibBuilder.loadTexts: vismDsx1AlarmLogOperTimer.setStatus('current')
if mibBuilder.loadTexts: vismDsx1AlarmLogOperTimer.setDescription('This object specifies the time remaining in minutes for which the detailed alarm logging will remain active on the DS1. When this value becomes 0, it indicates that the DS1 has run through the time specified in vismDsx1AlarmLogOperTimer. This will cause the vismDsx1AlarmLogEnable to be set to false. If vismDsx1AlarmLogAdminTimer is overwritten with a new value, this object will also be set to reflect the new value.')
vismDsx1ElectricalSignalEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 5, 1, 1, 1, 38), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismDsx1ElectricalSignalEnable.setStatus('current')
if mibBuilder.loadTexts: vismDsx1ElectricalSignalEnable.setDescription("This object specifies whether electrical signal on the line is enabled or disabled. If the value of this object is 'true', electrical signal on the line is enabled. If the value of this object is 'false', electrical signal on the line is disabled.")
dsx1VismStatsGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 5, 2, 1), )
if mibBuilder.loadTexts: dsx1VismStatsGrpTable.setStatus('current')
if mibBuilder.loadTexts: dsx1VismStatsGrpTable.setDescription('The VISM specific DS1/E1 statistics table. This table contains the additional VISM statistics information for DS1/E1. ')
dsx1VismStatsGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 5, 2, 1, 1), )
dsx1VismCnfGrpEntry.registerAugmentions(("CISCO-VISM-DSX1-MIB", "dsx1VismStatsGrpEntry"))
dsx1VismStatsGrpEntry.setIndexNames(*dsx1VismCnfGrpEntry.getIndexNames())
if mibBuilder.loadTexts: dsx1VismStatsGrpEntry.setStatus('current')
if mibBuilder.loadTexts: dsx1VismStatsGrpEntry.setDescription('An entry in the VISM Dsx1 Statistics table. This entry augments the corresponding entry in the dsx1VismCnfGrpTable. ')
vismDsx1TotalTxUncontrolledSlips = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 5, 2, 1, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismDsx1TotalTxUncontrolledSlips.setStatus('current')
if mibBuilder.loadTexts: vismDsx1TotalTxUncontrolledSlips.setDescription('The number of accumulative uncontrolled slips in the transmit direction.')
vismDsx1TotalTxFrameSlips = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 5, 2, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismDsx1TotalTxFrameSlips.setStatus('current')
if mibBuilder.loadTexts: vismDsx1TotalTxFrameSlips.setDescription('The number of accumulative frame slips in the transmit direction.')
vismDsx1TotalRxUncontrolledSlips = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 5, 2, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismDsx1TotalRxUncontrolledSlips.setStatus('current')
if mibBuilder.loadTexts: vismDsx1TotalRxUncontrolledSlips.setDescription('The number of accumulative uncontrolled slips in the receive direction.')
vismDsx1TotalRxFrameSlips = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 5, 2, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismDsx1TotalRxFrameSlips.setStatus('current')
if mibBuilder.loadTexts: vismDsx1TotalRxFrameSlips.setDescription('The number of accumulative frame slips in the receive direction.')
vismSlipCntDiscontinuityTime = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 5, 2, 1, 1, 5), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismSlipCntDiscontinuityTime.setStatus('current')
if mibBuilder.loadTexts: vismSlipCntDiscontinuityTime.setDescription('This object will represent the timestamp since sysUpTime when the statistics in this interval were discontinued. If this has the default value then it indicates that the statistics in this interval have not been discontinued.')
dsx1AlmHistoryTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 1, 3, 2), )
if mibBuilder.loadTexts: dsx1AlmHistoryTable.setStatus('current')
if mibBuilder.loadTexts: dsx1AlmHistoryTable.setDescription('The TDM line interface alarm history table.')
dsx1AlmHistoryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 1, 3, 2, 1), ).setIndexNames((0, "CISCO-VISM-DSX1-MIB", "almlineNumber"), (0, "CISCO-VISM-DSX1-MIB", "almIntervalNumber"))
if mibBuilder.loadTexts: dsx1AlmHistoryEntry.setStatus('current')
if mibBuilder.loadTexts: dsx1AlmHistoryEntry.setDescription('An entry in the DS1/E1 Alarm History table.')
almlineNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 1, 3, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: almlineNumber.setStatus('current')
if mibBuilder.loadTexts: almlineNumber.setDescription('This object is the identifier of a DS1/E1 Interface on a managed device. ')
almIntervalNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 1, 3, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 96))).setMaxAccess("readonly")
if mibBuilder.loadTexts: almIntervalNumber.setStatus('current')
if mibBuilder.loadTexts: almIntervalNumber.setDescription('This is the alarm interval number which associates with time interval alarms occurred. ')
lCV = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 1, 3, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lCV.setStatus('current')
if mibBuilder.loadTexts: lCV.setDescription('The accumulated number of Line code violations encountered on the DS1 interface. ')
lES = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 1, 3, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lES.setStatus('current')
if mibBuilder.loadTexts: lES.setDescription('The accumulated number of Line code violations Errored Seconds encountered on the DS1 interface. ')
lSES = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 1, 3, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lSES.setStatus('current')
if mibBuilder.loadTexts: lSES.setDescription('The accumulated number of LCV (Line Code Violations) Severely Errored Seconds encountered on the DS1 interface. ')
cRC = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 1, 3, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cRC.setStatus('current')
if mibBuilder.loadTexts: cRC.setDescription('The accumulated number of P Bit code violations encountered on the DS1 interface. ')
cRCES = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 1, 3, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cRCES.setStatus('current')
if mibBuilder.loadTexts: cRCES.setDescription('The accumulated number of PVC Errored Seconds encountered on the DS1 interface. ')
cRCSES = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 1, 3, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cRCSES.setStatus('current')
if mibBuilder.loadTexts: cRCSES.setDescription('The accumulated number of P Bit code violations Severely Errored Seconds encountered on the DS1 interface. ')
sEFS = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 1, 3, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sEFS.setStatus('current')
if mibBuilder.loadTexts: sEFS.setDescription('The accumulated number of Severely Errored Framing Seconds encountered on the DS1 interface. ')
aISS = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 1, 3, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aISS.setStatus('current')
if mibBuilder.loadTexts: aISS.setDescription('The accumulated number of AIS Severely Errored Seconds encountered on the DS1 interface. ')
uAS = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 1, 3, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: uAS.setStatus('current')
if mibBuilder.loadTexts: uAS.setDescription('The accumulated number of Unavailable Seconds encountered on the DS1 interface. ')
percentErrorFreeSecs = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 1, 3, 2, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: percentErrorFreeSecs.setStatus('current')
if mibBuilder.loadTexts: percentErrorFreeSecs.setDescription('The accumulated the percentage of LCV (Line Code Violation) Error Free Seconds. ')
rcvLOSCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 1, 3, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvLOSCnt.setStatus('current')
if mibBuilder.loadTexts: rcvLOSCnt.setDescription('The accumulated number of LOS (Loss of Signal) detected with or without integrating to LOS alarm on the DS1 interface. ')
rcvOOFCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 1, 3, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvOOFCnt.setStatus('current')
if mibBuilder.loadTexts: rcvOOFCnt.setDescription('The accumulated number of OOF (Out of Frame) detected with or without integrating to OOF alarm on the DS1 interface. ')
rcvRAICnt = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 1, 3, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvRAICnt.setStatus('current')
if mibBuilder.loadTexts: rcvRAICnt.setDescription('The accumulated number of Yellow Alarms detected with or without integrating to RAI alarm on the DS1 interface. ')
rcvFECnt = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 1, 3, 2, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvFECnt.setStatus('current')
if mibBuilder.loadTexts: rcvFECnt.setDescription('The accumulated number of Framing Pattern Errors encountered on a DS1/E1 interface. ')
dsx1AlmClrButton = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 1, 3, 2, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noaction", 1), ("clear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dsx1AlmClrButton.setStatus('current')
if mibBuilder.loadTexts: dsx1AlmClrButton.setDescription('This variable is used to clear all the alarms for the line/interval. ')
dsx1TxUncontrolledSlips = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 1, 3, 2, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1TxUncontrolledSlips.setStatus('current')
if mibBuilder.loadTexts: dsx1TxUncontrolledSlips.setDescription('This counter counts the number of uncontrolled slips in the transmit direction during this interval. ')
dsx1RxUncontrolledSlips = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 1, 3, 2, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1RxUncontrolledSlips.setStatus('current')
if mibBuilder.loadTexts: dsx1RxUncontrolledSlips.setDescription('This counter counts the number of uncontrolled slips in the receive direction during this interval. ')
dsx1TxFrameSlips = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 1, 3, 2, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1TxFrameSlips.setStatus('current')
if mibBuilder.loadTexts: dsx1TxFrameSlips.setDescription('This counter counts the number of frame slips in the transmit direction during this interval. ')
dsx1RxFrameSlips = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 3, 1, 3, 2, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1RxFrameSlips.setStatus('current')
if mibBuilder.loadTexts: dsx1RxFrameSlips.setDescription('This counter counts the number of frame slips in the receive direction during this interval. ')
cvDsx1MIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 150, 79, 2))
cvDsx1MIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 150, 79, 2, 1))
cvDsx1MIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 150, 79, 2, 2))
cvDsx1Compliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 351, 150, 79, 2, 2, 1)).setObjects(("CISCO-VISM-DSX1-MIB", "cvDsx1ConfGroup"), ("CISCO-VISM-DSX1-MIB", "cvDsx1AlmHistoryGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cvDsx1Compliance = cvDsx1Compliance.setStatus('deprecated')
if mibBuilder.loadTexts: cvDsx1Compliance.setDescription('The compliance statement for objects related to VISM DS1/E1 MIB. ')
cvDsx1ComplianceRev1 = ModuleCompliance((1, 3, 6, 1, 4, 1, 351, 150, 79, 2, 2, 2)).setObjects(("CISCO-VISM-DSX1-MIB", "cvDsx1ConfGroupRev1"), ("CISCO-VISM-DSX1-MIB", "cvDsx1AlmHistoryGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cvDsx1ComplianceRev1 = cvDsx1ComplianceRev1.setStatus('deprecated')
if mibBuilder.loadTexts: cvDsx1ComplianceRev1.setDescription('The compliance statement for objects related to VISM DS1/E1 MIB. ')
cvDsx1ComplianceRev2 = ModuleCompliance((1, 3, 6, 1, 4, 1, 351, 150, 79, 2, 2, 3)).setObjects(("CISCO-VISM-DSX1-MIB", "cvDsx1ConfGroupRev2"), ("CISCO-VISM-DSX1-MIB", "cvDsx1AlmHistoryGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cvDsx1ComplianceRev2 = cvDsx1ComplianceRev2.setStatus('deprecated')
if mibBuilder.loadTexts: cvDsx1ComplianceRev2.setDescription('The compliance statement for objects related to VISM DS1/E1 MIB. ')
cvDsx1ComplianceRev3 = ModuleCompliance((1, 3, 6, 1, 4, 1, 351, 150, 79, 2, 2, 4)).setObjects(("CISCO-VISM-DSX1-MIB", "cvDsx1ConfGroupRev2"), ("CISCO-VISM-DSX1-MIB", "cvDsx1AlmHistoryGroupRev1"), ("CISCO-VISM-DSX1-MIB", "cvDsx1StatsGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cvDsx1ComplianceRev3 = cvDsx1ComplianceRev3.setStatus('deprecated')
if mibBuilder.loadTexts: cvDsx1ComplianceRev3.setDescription('The compliance statement for objects related to VISM DS1/E1 MIB. ')
cvDsx1ComplianceRev4 = ModuleCompliance((1, 3, 6, 1, 4, 1, 351, 150, 79, 2, 2, 5)).setObjects(("CISCO-VISM-DSX1-MIB", "cvDsx1ConfGroupRev2"), ("CISCO-VISM-DSX1-MIB", "cvDsx1AlmHistoryGroupRev1"), ("CISCO-VISM-DSX1-MIB", "cvDsx1StatsGroup"), ("CISCO-VISM-DSX1-MIB", "cvDsx1ConfGroupSup1"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cvDsx1ComplianceRev4 = cvDsx1ComplianceRev4.setStatus('deprecated')
if mibBuilder.loadTexts: cvDsx1ComplianceRev4.setDescription('The compliance statement for objects related to VISM DS1/E1 MIB. ')
cvDsx1ComplianceRev5 = ModuleCompliance((1, 3, 6, 1, 4, 1, 351, 150, 79, 2, 2, 6)).setObjects(("CISCO-VISM-DSX1-MIB", "cvDsx1ConfGroupRev2"), ("CISCO-VISM-DSX1-MIB", "cvDsx1AlmHistoryGroupRev1"), ("CISCO-VISM-DSX1-MIB", "cvDsx1StatsGroup"), ("CISCO-VISM-DSX1-MIB", "cvDsx1ConfGroupSup1"), ("CISCO-VISM-DSX1-MIB", "cvDsx1AlarmLogGroup"), ("CISCO-VISM-DSX1-MIB", "cvDsx1ElecSigGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cvDsx1ComplianceRev5 = cvDsx1ComplianceRev5.setStatus('current')
if mibBuilder.loadTexts: cvDsx1ComplianceRev5.setDescription('The compliance statement for objects related to VISM DS1/E1 MIB. ')
cvDsx1ConfGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 79, 2, 1, 1)).setObjects(("CISCO-VISM-DSX1-MIB", "vismLineNum"), ("CISCO-VISM-DSX1-MIB", "vismEcanEnabled"), ("CISCO-VISM-DSX1-MIB", "vismEcanToneDisable"), ("CISCO-VISM-DSX1-MIB", "vismEcanCnfNRN"), ("CISCO-VISM-DSX1-MIB", "vismEcanTail"), ("CISCO-VISM-DSX1-MIB", "vismEcanREC"), ("CISCO-VISM-DSX1-MIB", "vismCompCnfVAD"), ("CISCO-VISM-DSX1-MIB", "vismSignalingType"), ("CISCO-VISM-DSX1-MIB", "vismCcsChannels"), ("CISCO-VISM-DSX1-MIB", "vismCadenceTime"), ("CISCO-VISM-DSX1-MIB", "vismTrunkConditionEnable"), ("CISCO-VISM-DSX1-MIB", "vismDsx1CircuitIdentifier"), ("CISCO-VISM-DSX1-MIB", "vismDsx1TxDigitOrder"), ("CISCO-VISM-DSX1-MIB", "vismDsx1TonePlanRegion"), ("CISCO-VISM-DSX1-MIB", "vismDsx1TonePlanVersion"), ("CISCO-VISM-DSX1-MIB", "vismDsx1RingingTO"), ("CISCO-VISM-DSX1-MIB", "vismDsx1RingBackTO"), ("CISCO-VISM-DSX1-MIB", "vismDsx1BusyTO"), ("CISCO-VISM-DSX1-MIB", "vismDsx1ReorderTO"), ("CISCO-VISM-DSX1-MIB", "vismDsx1DialTO"), ("CISCO-VISM-DSX1-MIB", "vismDsx1StutterDialTO"), ("CISCO-VISM-DSX1-MIB", "vismDsx1OffHookAlertTO"), ("CISCO-VISM-DSX1-MIB", "vismDsx1RemoteRingback"), ("CISCO-VISM-DSX1-MIB", "vismDsx1MidcallTpart"), ("CISCO-VISM-DSX1-MIB", "vismDsx1MidcallTcrit"), ("CISCO-VISM-DSX1-MIB", "vismDsx1Sa4Byte"), ("CISCO-VISM-DSX1-MIB", "vismDsx1Sa5Byte"), ("CISCO-VISM-DSX1-MIB", "vismDsx1Sa6Byte"), ("CISCO-VISM-DSX1-MIB", "vismDsx1Sa7Byte"), ("CISCO-VISM-DSX1-MIB", "vismDsx1Sa8Byte"), ("CISCO-VISM-DSX1-MIB", "vismDsx1State"), ("CISCO-VISM-DSX1-MIB", "vismDsx1AdminStateControl"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cvDsx1ConfGroup = cvDsx1ConfGroup.setStatus('deprecated')
if mibBuilder.loadTexts: cvDsx1ConfGroup.setDescription('The collection of objects used for DS1/E1 interfaces. ')
cvDsx1AlmHistoryGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 79, 2, 1, 2)).setObjects(("CISCO-VISM-DSX1-MIB", "almlineNumber"), ("CISCO-VISM-DSX1-MIB", "almIntervalNumber"), ("CISCO-VISM-DSX1-MIB", "lCV"), ("CISCO-VISM-DSX1-MIB", "lES"), ("CISCO-VISM-DSX1-MIB", "lSES"), ("CISCO-VISM-DSX1-MIB", "cRC"), ("CISCO-VISM-DSX1-MIB", "cRCES"), ("CISCO-VISM-DSX1-MIB", "cRCSES"), ("CISCO-VISM-DSX1-MIB", "sEFS"), ("CISCO-VISM-DSX1-MIB", "aISS"), ("CISCO-VISM-DSX1-MIB", "uAS"), ("CISCO-VISM-DSX1-MIB", "percentErrorFreeSecs"), ("CISCO-VISM-DSX1-MIB", "rcvLOSCnt"), ("CISCO-VISM-DSX1-MIB", "rcvOOFCnt"), ("CISCO-VISM-DSX1-MIB", "rcvRAICnt"), ("CISCO-VISM-DSX1-MIB", "rcvFECnt"), ("CISCO-VISM-DSX1-MIB", "dsx1AlmClrButton"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cvDsx1AlmHistoryGroup = cvDsx1AlmHistoryGroup.setStatus('deprecated')
if mibBuilder.loadTexts: cvDsx1AlmHistoryGroup.setDescription('The collection of objects related to DS1/E1 alarm history. ')
cvDsx1ConfGroupRev1 = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 79, 2, 1, 3)).setObjects(("CISCO-VISM-DSX1-MIB", "vismLineNum"), ("CISCO-VISM-DSX1-MIB", "vismEcanEnabled"), ("CISCO-VISM-DSX1-MIB", "vismEcanTail"), ("CISCO-VISM-DSX1-MIB", "vismEcanREC"), ("CISCO-VISM-DSX1-MIB", "vismCompCnfVAD"), ("CISCO-VISM-DSX1-MIB", "vismSignalingType"), ("CISCO-VISM-DSX1-MIB", "vismCcsChannels"), ("CISCO-VISM-DSX1-MIB", "vismTrunkConditionEnable"), ("CISCO-VISM-DSX1-MIB", "vismDsx1CircuitIdentifier"), ("CISCO-VISM-DSX1-MIB", "vismDsx1TxDigitOrder"), ("CISCO-VISM-DSX1-MIB", "vismDsx1TonePlanRegion"), ("CISCO-VISM-DSX1-MIB", "vismDsx1TonePlanVersion"), ("CISCO-VISM-DSX1-MIB", "vismDsx1RingingTO"), ("CISCO-VISM-DSX1-MIB", "vismDsx1RingBackTO"), ("CISCO-VISM-DSX1-MIB", "vismDsx1BusyTO"), ("CISCO-VISM-DSX1-MIB", "vismDsx1ReorderTO"), ("CISCO-VISM-DSX1-MIB", "vismDsx1DialTO"), ("CISCO-VISM-DSX1-MIB", "vismDsx1StutterDialTO"), ("CISCO-VISM-DSX1-MIB", "vismDsx1OffHookAlertTO"), ("CISCO-VISM-DSX1-MIB", "vismDsx1RemoteRingback"), ("CISCO-VISM-DSX1-MIB", "vismDsx1MidcallTpart"), ("CISCO-VISM-DSX1-MIB", "vismDsx1MidcallTcrit"), ("CISCO-VISM-DSX1-MIB", "vismDsx1Sa4Byte"), ("CISCO-VISM-DSX1-MIB", "vismDsx1Sa5Byte"), ("CISCO-VISM-DSX1-MIB", "vismDsx1Sa6Byte"), ("CISCO-VISM-DSX1-MIB", "vismDsx1Sa7Byte"), ("CISCO-VISM-DSX1-MIB", "vismDsx1Sa8Byte"), ("CISCO-VISM-DSX1-MIB", "vismDsx1State"), ("CISCO-VISM-DSX1-MIB", "vismDsx1AdminStateControl"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cvDsx1ConfGroupRev1 = cvDsx1ConfGroupRev1.setStatus('deprecated')
if mibBuilder.loadTexts: cvDsx1ConfGroupRev1.setDescription('The collection of objects related to DS1/E1 in VISM ')
cvDsx1ConfGroupRev2 = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 79, 2, 1, 4)).setObjects(("CISCO-VISM-DSX1-MIB", "vismLineNum"), ("CISCO-VISM-DSX1-MIB", "vismEcanEnabled"), ("CISCO-VISM-DSX1-MIB", "vismEcanTail"), ("CISCO-VISM-DSX1-MIB", "vismEcanREC"), ("CISCO-VISM-DSX1-MIB", "vismCompCnfVAD"), ("CISCO-VISM-DSX1-MIB", "vismSignalingType"), ("CISCO-VISM-DSX1-MIB", "vismCcsChannels"), ("CISCO-VISM-DSX1-MIB", "vismTrunkConditionEnable"), ("CISCO-VISM-DSX1-MIB", "vismDsx1CircuitIdentifier"), ("CISCO-VISM-DSX1-MIB", "vismDsx1TxDigitOrder"), ("CISCO-VISM-DSX1-MIB", "vismDsx1TonePlanRegion"), ("CISCO-VISM-DSX1-MIB", "vismDsx1TonePlanVersion"), ("CISCO-VISM-DSX1-MIB", "vismDsx1RingingTO"), ("CISCO-VISM-DSX1-MIB", "vismDsx1RingBackTO"), ("CISCO-VISM-DSX1-MIB", "vismDsx1BusyTO"), ("CISCO-VISM-DSX1-MIB", "vismDsx1ReorderTO"), ("CISCO-VISM-DSX1-MIB", "vismDsx1DialTO"), ("CISCO-VISM-DSX1-MIB", "vismDsx1StutterDialTO"), ("CISCO-VISM-DSX1-MIB", "vismDsx1OffHookAlertTO"), ("CISCO-VISM-DSX1-MIB", "vismDsx1RemoteRingback"), ("CISCO-VISM-DSX1-MIB", "vismDsx1MidcallTpart"), ("CISCO-VISM-DSX1-MIB", "vismDsx1MidcallTcrit"), ("CISCO-VISM-DSX1-MIB", "vismDsx1Sa4Byte"), ("CISCO-VISM-DSX1-MIB", "vismDsx1Sa5Byte"), ("CISCO-VISM-DSX1-MIB", "vismDsx1Sa6Byte"), ("CISCO-VISM-DSX1-MIB", "vismDsx1Sa7Byte"), ("CISCO-VISM-DSX1-MIB", "vismDsx1Sa8Byte"), ("CISCO-VISM-DSX1-MIB", "vismDsx1State"), ("CISCO-VISM-DSX1-MIB", "vismDsx1AdminStateControl"), ("CISCO-VISM-DSX1-MIB", "vismBearerBusyCode"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cvDsx1ConfGroupRev2 = cvDsx1ConfGroupRev2.setStatus('current')
if mibBuilder.loadTexts: cvDsx1ConfGroupRev2.setDescription('The collection of objects related to DS1/E1 in VISM ')
cvDsx1AlmHistoryGroupRev1 = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 79, 2, 1, 5)).setObjects(("CISCO-VISM-DSX1-MIB", "almlineNumber"), ("CISCO-VISM-DSX1-MIB", "almIntervalNumber"), ("CISCO-VISM-DSX1-MIB", "lCV"), ("CISCO-VISM-DSX1-MIB", "lES"), ("CISCO-VISM-DSX1-MIB", "lSES"), ("CISCO-VISM-DSX1-MIB", "cRC"), ("CISCO-VISM-DSX1-MIB", "cRCES"), ("CISCO-VISM-DSX1-MIB", "cRCSES"), ("CISCO-VISM-DSX1-MIB", "sEFS"), ("CISCO-VISM-DSX1-MIB", "aISS"), ("CISCO-VISM-DSX1-MIB", "uAS"), ("CISCO-VISM-DSX1-MIB", "percentErrorFreeSecs"), ("CISCO-VISM-DSX1-MIB", "rcvLOSCnt"), ("CISCO-VISM-DSX1-MIB", "rcvOOFCnt"), ("CISCO-VISM-DSX1-MIB", "rcvRAICnt"), ("CISCO-VISM-DSX1-MIB", "rcvFECnt"), ("CISCO-VISM-DSX1-MIB", "dsx1AlmClrButton"), ("CISCO-VISM-DSX1-MIB", "dsx1TxUncontrolledSlips"), ("CISCO-VISM-DSX1-MIB", "dsx1TxFrameSlips"), ("CISCO-VISM-DSX1-MIB", "dsx1RxUncontrolledSlips"), ("CISCO-VISM-DSX1-MIB", "dsx1RxFrameSlips"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cvDsx1AlmHistoryGroupRev1 = cvDsx1AlmHistoryGroupRev1.setStatus('current')
if mibBuilder.loadTexts: cvDsx1AlmHistoryGroupRev1.setDescription('The collection of objects related to DS1/E1 alarm history. ')
cvDsx1StatsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 79, 2, 1, 6)).setObjects(("CISCO-VISM-DSX1-MIB", "vismDsx1TotalTxUncontrolledSlips"), ("CISCO-VISM-DSX1-MIB", "vismDsx1TotalTxFrameSlips"), ("CISCO-VISM-DSX1-MIB", "vismDsx1TotalRxUncontrolledSlips"), ("CISCO-VISM-DSX1-MIB", "vismDsx1TotalRxFrameSlips"), ("CISCO-VISM-DSX1-MIB", "vismSlipCntDiscontinuityTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cvDsx1StatsGroup = cvDsx1StatsGroup.setStatus('current')
if mibBuilder.loadTexts: cvDsx1StatsGroup.setDescription('The collection of objects related to DS1/E1 in VISM ')
cvDsx1ConfGroupSup1 = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 79, 2, 1, 7)).setObjects(("CISCO-VISM-DSX1-MIB", "vismDsx1V110Enable"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cvDsx1ConfGroupSup1 = cvDsx1ConfGroupSup1.setStatus('current')
if mibBuilder.loadTexts: cvDsx1ConfGroupSup1.setDescription('The collection of objects related to DS1/E1 in VISM ')
cvDsx1AlarmLogGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 79, 2, 1, 8)).setObjects(("CISCO-VISM-DSX1-MIB", "vismDsx1AlarmLogEnable"), ("CISCO-VISM-DSX1-MIB", "vismDsx1AlarmLogAdminTimer"), ("CISCO-VISM-DSX1-MIB", "vismDsx1AlarmLogOperTimer"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cvDsx1AlarmLogGroup = cvDsx1AlarmLogGroup.setStatus('current')
if mibBuilder.loadTexts: cvDsx1AlarmLogGroup.setDescription('The collection of objects related to DS1/E1 in VISM. ')
cvDsx1ElecSigGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 79, 2, 1, 9)).setObjects(("CISCO-VISM-DSX1-MIB", "vismDsx1ElectricalSignalEnable"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cvDsx1ElecSigGroup = cvDsx1ElecSigGroup.setStatus('current')
if mibBuilder.loadTexts: cvDsx1ElecSigGroup.setDescription('The collection of objects related to DS1/E1 electrical signals in VISM. ')
mibBuilder.exportSymbols("CISCO-VISM-DSX1-MIB", vismLineNum=vismLineNum, cvDsx1MIBGroups=cvDsx1MIBGroups, dsx1VismStatsGrpTable=dsx1VismStatsGrpTable, dsx1Vism=dsx1Vism, cvDsx1ElecSigGroup=cvDsx1ElecSigGroup, rcvFECnt=rcvFECnt, vismDsx1TonePlanVersion=vismDsx1TonePlanVersion, cvDsx1ComplianceRev5=cvDsx1ComplianceRev5, vismDsx1V110Enable=vismDsx1V110Enable, vismDsx1CircuitIdentifier=vismDsx1CircuitIdentifier, vismDsx1TotalRxFrameSlips=vismDsx1TotalRxFrameSlips, dsx1TxFrameSlips=dsx1TxFrameSlips, vismCompCnfVAD=vismCompCnfVAD, vismDsx1BusyTO=vismDsx1BusyTO, rcvOOFCnt=rcvOOFCnt, vismDsx1TotalTxFrameSlips=vismDsx1TotalTxFrameSlips, vismDsx1DialTO=vismDsx1DialTO, cRC=cRC, cvDsx1ConfGroupRev2=cvDsx1ConfGroupRev2, vismEcanTail=vismEcanTail, vismDsx1ElectricalSignalEnable=vismDsx1ElectricalSignalEnable, vismDsx1Sa4Byte=vismDsx1Sa4Byte, almlineNumber=almlineNumber, lSES=lSES, dsx1AlmHistoryEntry=dsx1AlmHistoryEntry, vismDsx1Sa7Byte=vismDsx1Sa7Byte, percentErrorFreeSecs=percentErrorFreeSecs, vismTrunkConditionEnable=vismTrunkConditionEnable, vismDsx1MidcallTcrit=vismDsx1MidcallTcrit, cvDsx1ComplianceRev1=cvDsx1ComplianceRev1, rcvLOSCnt=rcvLOSCnt, vismDsx1RingBackTO=vismDsx1RingBackTO, vismSignalingType=vismSignalingType, cvDsx1ComplianceRev3=cvDsx1ComplianceRev3, almIntervalNumber=almIntervalNumber, sEFS=sEFS, vismDsx1ReorderTO=vismDsx1ReorderTO, lES=lES, cvDsx1ComplianceRev4=cvDsx1ComplianceRev4, vismDsx1StutterDialTO=vismDsx1StutterDialTO, aISS=aISS, dsx1VismCnfGrpTable=dsx1VismCnfGrpTable, vismDsx1MidcallTpart=vismDsx1MidcallTpart, vismBearerBusyCode=vismBearerBusyCode, vismSlipCntDiscontinuityTime=vismSlipCntDiscontinuityTime, cvDsx1MIBCompliances=cvDsx1MIBCompliances, dsx1VismCnfGrpEntry=dsx1VismCnfGrpEntry, cRCSES=cRCSES, dsx1VismStatsGrpEntry=dsx1VismStatsGrpEntry, ciscoVismDsx1MIB=ciscoVismDsx1MIB, cvDsx1AlmHistoryGroupRev1=cvDsx1AlmHistoryGroupRev1, dsx1RxFrameSlips=dsx1RxFrameSlips, vismCcsChannels=vismCcsChannels, vismDsx1AlarmLogEnable=vismDsx1AlarmLogEnable, dsx1AlmClrButton=dsx1AlmClrButton, cvDsx1AlmHistoryGroup=cvDsx1AlmHistoryGroup, vismEcanEnabled=vismEcanEnabled, vismDsx1TonePlanRegion=vismDsx1TonePlanRegion, cvDsx1ComplianceRev2=cvDsx1ComplianceRev2, cvDsx1StatsGroup=cvDsx1StatsGroup, vismEcanToneDisable=vismEcanToneDisable, vismDsx1Sa5Byte=vismDsx1Sa5Byte, dsx1RxUncontrolledSlips=dsx1RxUncontrolledSlips, vismDsx1TxDigitOrder=vismDsx1TxDigitOrder, cvDsx1AlarmLogGroup=cvDsx1AlarmLogGroup, cvDsx1ConfGroupRev1=cvDsx1ConfGroupRev1, vismDsx1Sa6Byte=vismDsx1Sa6Byte, uAS=uAS, vismDsx1Sa8Byte=vismDsx1Sa8Byte, cRCES=cRCES, vismEcanCnfNRN=vismEcanCnfNRN, vismDsx1RemoteRingback=vismDsx1RemoteRingback, vismDsx1AdminStateControl=vismDsx1AdminStateControl, PYSNMP_MODULE_ID=ciscoVismDsx1MIB, dsx1TxUncontrolledSlips=dsx1TxUncontrolledSlips, vismDsx1State=vismDsx1State, cvDsx1MIBConformance=cvDsx1MIBConformance, vismDsx1RingingTO=vismDsx1RingingTO, vismDsx1AlarmLogAdminTimer=vismDsx1AlarmLogAdminTimer, vismDsx1TotalRxUncontrolledSlips=vismDsx1TotalRxUncontrolledSlips, dsx1VismStatsGrp=dsx1VismStatsGrp, dsx1VismCnfGrp=dsx1VismCnfGrp, cvDsx1ConfGroup=cvDsx1ConfGroup, cvDsx1Compliance=cvDsx1Compliance, cvDsx1ConfGroupSup1=cvDsx1ConfGroupSup1, vismDsx1AlarmLogOperTimer=vismDsx1AlarmLogOperTimer, lCV=lCV, vismCadenceTime=vismCadenceTime, vismDsx1TotalTxUncontrolledSlips=vismDsx1TotalTxUncontrolledSlips, dsx1AlmHistoryTable=dsx1AlmHistoryTable, vismEcanREC=vismEcanREC, vismDsx1OffHookAlertTO=vismDsx1OffHookAlertTO, rcvRAICnt=rcvRAICnt)

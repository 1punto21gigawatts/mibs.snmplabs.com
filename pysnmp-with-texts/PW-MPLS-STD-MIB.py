#
# PySNMP MIB module PW-MPLS-STD-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/PW-MPLS-STD-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:42:51 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ValueRangeConstraint, ConstraintsIntersection, SingleValueConstraint, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ValueRangeConstraint", "ConstraintsIntersection", "SingleValueConstraint", "ValueSizeConstraint")
InterfaceIndexOrZero, = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero")
MplsIndexType, = mibBuilder.importSymbols("MPLS-LSR-STD-MIB", "MplsIndexType")
MplsTunnelIndex, MplsLdpIdentifier, MplsTunnelInstanceIndex, MplsLsrIdentifier = mibBuilder.importSymbols("MPLS-TC-STD-MIB", "MplsTunnelIndex", "MplsLdpIdentifier", "MplsTunnelInstanceIndex", "MplsLsrIdentifier")
pwIndex, = mibBuilder.importSymbols("PW-STD-MIB", "pwIndex")
PwIndexType, = mibBuilder.importSymbols("PW-TC-STD-MIB", "PwIndexType")
NotificationGroup, ObjectGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ObjectGroup", "ModuleCompliance")
Counter64, IpAddress, ObjectIdentity, NotificationType, Unsigned32, Bits, Counter32, iso, Integer32, TimeTicks, Gauge32, ModuleIdentity, MibIdentifier, mib_2, MibScalar, MibTable, MibTableRow, MibTableColumn = mibBuilder.importSymbols("SNMPv2-SMI", "Counter64", "IpAddress", "ObjectIdentity", "NotificationType", "Unsigned32", "Bits", "Counter32", "iso", "Integer32", "TimeTicks", "Gauge32", "ModuleIdentity", "MibIdentifier", "mib-2", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn")
TextualConvention, DisplayString, StorageType = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString", "StorageType")
pwMplsStdMIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 181))
pwMplsStdMIB.setRevisions(('2009-06-12 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: pwMplsStdMIB.setRevisionsDescriptions(('First published as RFC 5602. ',))
if mibBuilder.loadTexts: pwMplsStdMIB.setLastUpdated('200906120000Z')
if mibBuilder.loadTexts: pwMplsStdMIB.setOrganization('Pseudowire Emulation Edge-to-Edge (PWE3) Working Group.')
if mibBuilder.loadTexts: pwMplsStdMIB.setContactInfo(' David Zelig, Editor Email: davidz@corrigent.com Thomas D. Nadeau, Editor Email: tom.nadeau@bt.com The PWE3 Working Group (email distribution pwe3@ietf.org, http://www.ietf.org/html.charters/pwe3-charter.html) ')
if mibBuilder.loadTexts: pwMplsStdMIB.setDescription("This MIB module complements the PW-STD-MIB module for PW operation over MPLS. Copyright (c) 2009 IETF Trust and the persons identified as authors of the code. All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. - Neither the name of Internet Society, IETF or IETF Trust, nor the names of specific contributors, may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. This version of this MIB module is part of RFC 5602; see the RFC itself for full legal notices. ")
pwMplsNotifications = MibIdentifier((1, 3, 6, 1, 2, 1, 181, 0))
pwMplsObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 181, 1))
pwMplsConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 181, 2))
pwMplsTable = MibTable((1, 3, 6, 1, 2, 1, 181, 1, 1), )
if mibBuilder.loadTexts: pwMplsTable.setStatus('current')
if mibBuilder.loadTexts: pwMplsTable.setDescription('This table controls MPLS-specific parameters when the PW is going to be carried over MPLS PSN.')
pwMplsEntry = MibTableRow((1, 3, 6, 1, 2, 1, 181, 1, 1, 1), ).setIndexNames((0, "PW-STD-MIB", "pwIndex"))
if mibBuilder.loadTexts: pwMplsEntry.setStatus('current')
if mibBuilder.loadTexts: pwMplsEntry.setDescription('A row in this table represents parameters specific to MPLS PSN for a pseudowire (PW). The row is created automatically by the local agent if the pwPsnType is mpls(1). It is indexed by pwIndex, which uniquely identifies a singular PW. Manual entries in this table SHOULD be preserved after a reboot, and the agent MUST ensure the integrity of those entries. If the set of entries of a specific row were found to be nonconsistent after reboot, the PW pwOperStatus MUST be declared as down(2). Any read-write object in this table MAY be changed at any time; however, change of some objects (for example, pwMplsMplsType) during PW forwarding state MAY cause traffic disruption.')
pwMplsMplsType = MibTableColumn((1, 3, 6, 1, 2, 1, 181, 1, 1, 1, 1), Bits().clone(namedValues=NamedValues(("mplsTe", 0), ("mplsNonTe", 1), ("pwOnly", 2))).clone(namedValues=NamedValues(("mplsNonTe", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pwMplsMplsType.setStatus('current')
if mibBuilder.loadTexts: pwMplsMplsType.setDescription('This object is set by the operator to indicate the outer tunnel types, if existing. mplsTe(0) is used if the outer tunnel is set up by MPLS-TE, and mplsNonTe(1) is used if the outer tunnel is set up by LDP or manually. A combination of mplsTe(0) and mplsNonTe(1) MAY exist. pwOnly(2) is used if there is no outer tunnel label, i.e., in static provisioning without an MPLS tunnel. pwOnly(2) cannot be combined with mplsNonTe(1) or mplsTe(0). An implementation that can identify automatically that the peer node is directly connected MAY support the bit pwOnly(2) as read-only. ')
pwMplsExpBitsMode = MibTableColumn((1, 3, 6, 1, 2, 1, 181, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("outerTunnel", 1), ("specifiedValue", 2), ("serviceDependant", 3))).clone('outerTunnel')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pwMplsExpBitsMode.setStatus('current')
if mibBuilder.loadTexts: pwMplsExpBitsMode.setDescription('This object is set by the operator to determine the PW shim label EXP bits. The value of outerTunnel(1) is used where there is an outer tunnel -- pwMplsMplsType equals to mplsTe(0) or mplsNonTe(1). Note that in this case, there is no need to mark the PW label with the EXP bits, since the PW label is not visible to the intermediate nodes. If there is no outer tunnel, specifiedValue(2) SHOULD be used to indicate that the value is specified by pwMplsExpBits. Setting serviceDependant(3) indicates that the EXP bits are set based on a rule that is implementation specific.')
pwMplsExpBits = MibTableColumn((1, 3, 6, 1, 2, 1, 181, 1, 1, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pwMplsExpBits.setStatus('current')
if mibBuilder.loadTexts: pwMplsExpBits.setDescription('This object is set by the operator if pwMplsExpBitsMode is set to specifiedValue(2) to indicate the MPLS EXP bits to be used on the PW shim label. Otherwise, it SHOULD be set to zero.')
pwMplsTtl = MibTableColumn((1, 3, 6, 1, 2, 1, 181, 1, 1, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pwMplsTtl.setStatus('current')
if mibBuilder.loadTexts: pwMplsTtl.setDescription('This object is set by the operator to indicate the PW TTL value to be used on the PW shim label.')
pwMplsLocalLdpID = MibTableColumn((1, 3, 6, 1, 2, 1, 181, 1, 1, 1, 5), MplsLdpIdentifier()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pwMplsLocalLdpID.setReference("'LDP specifications', RFC 3036, section 2.2.2.")
if mibBuilder.loadTexts: pwMplsLocalLdpID.setStatus('current')
if mibBuilder.loadTexts: pwMplsLocalLdpID.setDescription('The LDP identifier of the LDP entity that creates this PW in the local node. As the PW labels are always set from the per-platform label space, the last two octets in the LDP ID MUST always both be zeros.')
pwMplsLocalLdpEntityIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 181, 1, 1, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pwMplsLocalLdpEntityIndex.setStatus('current')
if mibBuilder.loadTexts: pwMplsLocalLdpEntityIndex.setDescription('The local node LDP Entity Index of the LDP entity creating this PW.')
pwMplsPeerLdpID = MibTableColumn((1, 3, 6, 1, 2, 1, 181, 1, 1, 1, 7), MplsLdpIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwMplsPeerLdpID.setStatus('current')
if mibBuilder.loadTexts: pwMplsPeerLdpID.setDescription('The peer LDP identifier of the LDP session. This object SHOULD return the value zero if LDP is not used or if the value is not yet known.')
pwMplsStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 181, 1, 1, 1, 8), StorageType().clone('nonVolatile')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pwMplsStorageType.setStatus('current')
if mibBuilder.loadTexts: pwMplsStorageType.setDescription('This variable indicates the storage type for this row.')
pwMplsOutboundTable = MibTable((1, 3, 6, 1, 2, 1, 181, 1, 2), )
if mibBuilder.loadTexts: pwMplsOutboundTable.setStatus('current')
if mibBuilder.loadTexts: pwMplsOutboundTable.setDescription('This table reports and configures the current outbound MPLS tunnels (i.e., toward the PSN) or the physical interface in the case of a PW label only that carries the PW traffic. It also reports the current outer tunnel and LSP that forward the PW traffic.')
pwMplsOutboundEntry = MibTableRow((1, 3, 6, 1, 2, 1, 181, 1, 2, 1), )
pwMplsEntry.registerAugmentions(("PW-MPLS-STD-MIB", "pwMplsOutboundEntry"))
pwMplsOutboundEntry.setIndexNames(*pwMplsEntry.getIndexNames())
if mibBuilder.loadTexts: pwMplsOutboundEntry.setStatus('current')
if mibBuilder.loadTexts: pwMplsOutboundEntry.setDescription('A row in this table configures the outer tunnel used for carrying the PW traffic toward the PSN. In the case of PW label only, it configures the interface that will carry the PW traffic. An entry in this table augments the pwMplsEntry, and is created automatically when the corresponding row has been created by the agent in the pwMplsEntry. This table points to the appropriate MPLS MIB module: In the MPLS-TE case, the three objects relevant to the indexing of a TE tunnel head-end (as used in the MPLS-TE-STD-MIB) are to be configured, and the tunnel instance indicates the LSP that is currently in use for forwarding the traffic. In the case of signaled non-TE MPLS (an outer tunnel label assigned by LDP), the table points to the XC entry in the LSR-STD-MIB. If the non-TE MPLS tunnel is manually configured, the operator configures the XC pointer to this tunnel. In the case of PW label only (no outer tunnel), the ifIndex of the port to carry the PW is configured here. It is possible to associate a PW to one TE tunnel head-end and a non-TE tunnel together. An indication in this table will report the currently active one. In addition, in the TE case, the table reports the active tunnel instance (i.e., the specific LSP in use). Any read-write object in this table MAY be changed at any time; however, change of some objects (for example, MPLS-TE indexes) during PW forwarding state MAY cause traffic disruption.')
pwMplsOutboundLsrXcIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 181, 1, 2, 1, 1), MplsIndexType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pwMplsOutboundLsrXcIndex.setStatus('current')
if mibBuilder.loadTexts: pwMplsOutboundLsrXcIndex.setDescription('This object is applicable if the pwMplsMplsType mplsNonTe(1) bit is set, and MUST return a value of zero otherwise. If the outer tunnel is signaled, the object is read-only and indicates the XC index in the MPLS-LSR-STD-MIB of the outer tunnel toward the peer. Otherwise (tunnel is set up manually), the operator defines the XC index of the manually created outer tunnel through this object. ')
pwMplsOutboundTunnelIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 181, 1, 2, 1, 2), MplsTunnelIndex()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pwMplsOutboundTunnelIndex.setStatus('current')
if mibBuilder.loadTexts: pwMplsOutboundTunnelIndex.setDescription('This object is applicable if the pwMplsMplsType mplsTe(0) bit is set, and MUST return a value of zero otherwise. It is part of the set of indexes for the outbound tunnel. The operator sets this object to represent the desired tunnel head-end toward the peer for carrying the PW traffic. ')
pwMplsOutboundTunnelInstance = MibTableColumn((1, 3, 6, 1, 2, 1, 181, 1, 2, 1, 3), MplsTunnelInstanceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwMplsOutboundTunnelInstance.setStatus('current')
if mibBuilder.loadTexts: pwMplsOutboundTunnelInstance.setDescription('This object is applicable if the pwMplsMplsType mplsTe(0) bit is set, and MUST return a value of zero otherwise. It indicates the actual tunnel instance that is currently active and carrying the PW traffic. It SHOULD return the value zero if the information from the MPLS-TE application is not yet known. ')
pwMplsOutboundTunnelLclLSR = MibTableColumn((1, 3, 6, 1, 2, 1, 181, 1, 2, 1, 4), MplsLsrIdentifier()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pwMplsOutboundTunnelLclLSR.setStatus('current')
if mibBuilder.loadTexts: pwMplsOutboundTunnelLclLSR.setDescription('This object is applicable if the pwMplsMplsType mplsTe(0) bit is set, and MUST return a value of all zeros otherwise. It is part of the set of indexes for the outbound tunnel. The operator sets this object to represent the desired tunnel head-end toward the peer for carrying the PW traffic. ')
pwMplsOutboundTunnelPeerLSR = MibTableColumn((1, 3, 6, 1, 2, 1, 181, 1, 2, 1, 5), MplsLsrIdentifier()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pwMplsOutboundTunnelPeerLSR.setStatus('current')
if mibBuilder.loadTexts: pwMplsOutboundTunnelPeerLSR.setDescription('This object is applicable if the pwMplsMplsType mplsTe(0) bit is set, and MUST return a value of zero otherwise. It is part of the set of indexes for the outbound tunnel. Note that in most cases, it equals to pwPeerAddr. ')
pwMplsOutboundIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 181, 1, 2, 1, 6), InterfaceIndexOrZero()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pwMplsOutboundIfIndex.setStatus('current')
if mibBuilder.loadTexts: pwMplsOutboundIfIndex.setDescription('This object is applicable if the pwMplsMplsType pwOnly(0) bit is set, and MUST return a value of zero otherwise. The operator configures the ifIndex of the outbound port in this case. ')
pwMplsOutboundTunnelTypeInUse = MibTableColumn((1, 3, 6, 1, 2, 1, 181, 1, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notYetKnown", 1), ("mplsTe", 2), ("mplsNonTe", 3), ("pwOnly", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwMplsOutboundTunnelTypeInUse.setStatus('current')
if mibBuilder.loadTexts: pwMplsOutboundTunnelTypeInUse.setDescription('This object indicates the current tunnel that is carrying the PW traffic. The value of notYetKnown(1) should be used if the agent is currently unable to determine which tunnel or interface is carrying the PW, for example, because both tunnels are in operational status down. ')
pwMplsInboundTable = MibTable((1, 3, 6, 1, 2, 1, 181, 1, 3), )
if mibBuilder.loadTexts: pwMplsInboundTable.setStatus('current')
if mibBuilder.loadTexts: pwMplsInboundTable.setDescription('This table indicates the PW LDP XC entry in the MPLS-LSR-STD-MIB for signaled PWs. ')
pwMplsInboundEntry = MibTableRow((1, 3, 6, 1, 2, 1, 181, 1, 3, 1), ).setIndexNames((0, "PW-STD-MIB", "pwIndex"))
if mibBuilder.loadTexts: pwMplsInboundEntry.setStatus('current')
if mibBuilder.loadTexts: pwMplsInboundEntry.setDescription('A row in this table is created by the agent for each signaled PW, and shows the XC index related to the PW signaling in the inbound direction in the MPLS-LSR-STD-MIB that controls and display the information for all the LDP signaling processes in the local node. ')
pwMplsInboundXcIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 181, 1, 3, 1, 1), MplsIndexType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwMplsInboundXcIndex.setStatus('current')
if mibBuilder.loadTexts: pwMplsInboundXcIndex.setDescription('The XC index representing this PW in the inbound direction. It MUST return the value zero if the information is not yet known.')
pwMplsNonTeMappingTable = MibTable((1, 3, 6, 1, 2, 1, 181, 1, 4), )
if mibBuilder.loadTexts: pwMplsNonTeMappingTable.setStatus('current')
if mibBuilder.loadTexts: pwMplsNonTeMappingTable.setDescription('This table indicates the PW association to the outbound tunnel in non-TE applications, maps the PW to its (inbound) XC entry, and indicates the PW-to-physical interface mapping for a PW without an outer tunnel. ')
pwMplsNonTeMappingEntry = MibTableRow((1, 3, 6, 1, 2, 1, 181, 1, 4, 1), ).setIndexNames((0, "PW-MPLS-STD-MIB", "pwMplsNonTeMappingDirection"), (0, "PW-MPLS-STD-MIB", "pwMplsNonTeMappingXcIndex"), (0, "PW-MPLS-STD-MIB", "pwMplsNonTeMappingIfIndex"), (0, "PW-MPLS-STD-MIB", "pwMplsNonTeMappingPwIndex"))
if mibBuilder.loadTexts: pwMplsNonTeMappingEntry.setStatus('current')
if mibBuilder.loadTexts: pwMplsNonTeMappingEntry.setDescription('A row in this table displays the association between the PW and - its non-TE MPLS outbound outer tunnel, - its XC entry in the MPLS-LSR-STD-MIB, or - its physical interface if there is no outer tunnel (PW label only) and manual configuration. Rows are created in this table by the agent depending on the setting of pwMplsMplsType: - If the pwMplsMplsType mplsNonTe(1) bit is set, the agent creates a row for the outbound direction (pwMplsNonTeMappingDirection set to psnBound(1)). The pwMplsNonTeMappingXcIndex holds the XC index in the MPLS-LSR-STD-MIB of the PSN-bound outer tunnel. pwMplsNonTeMappingIfIndex MUST be zero for this row. - If the pwMplsMplsType pwOnly(2) bit is set, the agent creates a row for the outbound direction (pwMplsNonTeMappingDirection set to psnBound(1)). The pwMplsNonTeMappingIfIndex holds the ifIndex of the physical port this PW will use in the outbound direction. pwMplsNonTeMappingXcIndex MUST be zero for this row. - If the PW has been set up by a signaling protocol (i.e., pwOwner equal pwIdFecSignaling(2) or genFecSignaling(3)), the agent creates a row for the inbound direction (pwMplsNonTeMappingDirection set to fromPsn(2)). The pwMplsNonTeMappingXcIndex holds the XC index in the MPLS-LSR-STD-MIB of the PW LDP-generated XC entry. pwMplsNonTeMappingIfIndex MUST be zero for this row. An application can use this table to quickly retrieve the PW carried over specific non-TE MPLS outer tunnel or physical interface. ')
pwMplsNonTeMappingDirection = MibTableColumn((1, 3, 6, 1, 2, 1, 181, 1, 4, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("psnBound", 1), ("fromPsn", 2))))
if mibBuilder.loadTexts: pwMplsNonTeMappingDirection.setStatus('current')
if mibBuilder.loadTexts: pwMplsNonTeMappingDirection.setDescription('Index for the conceptual XC row identifying the tunnel-to-PW mappings, indicating the direction of the packet flow for this entry. psnBound(1) indicates that the entry is related to packets toward the PSN. fromPsn(2) indicates that the entry is related to packets coming from the PSN. ')
pwMplsNonTeMappingXcIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 181, 1, 4, 1, 2), MplsIndexType())
if mibBuilder.loadTexts: pwMplsNonTeMappingXcIndex.setStatus('current')
if mibBuilder.loadTexts: pwMplsNonTeMappingXcIndex.setDescription('See the description clause of pwMplsNonTeMappingEntry for the usage guidelines of this object.')
pwMplsNonTeMappingIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 181, 1, 4, 1, 3), InterfaceIndexOrZero())
if mibBuilder.loadTexts: pwMplsNonTeMappingIfIndex.setStatus('current')
if mibBuilder.loadTexts: pwMplsNonTeMappingIfIndex.setDescription('See the description clause of pwMplsNonTeMappingEntry for the usage guidelines of this object.')
pwMplsNonTeMappingPwIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 181, 1, 4, 1, 4), PwIndexType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwMplsNonTeMappingPwIndex.setStatus('current')
if mibBuilder.loadTexts: pwMplsNonTeMappingPwIndex.setDescription('The value that represents the PW in the pwTable.')
pwMplsTeMappingTable = MibTable((1, 3, 6, 1, 2, 1, 181, 1, 5), )
if mibBuilder.loadTexts: pwMplsTeMappingTable.setStatus('current')
if mibBuilder.loadTexts: pwMplsTeMappingTable.setDescription('This table reports the PW association to the outbound MPLS tunnel for MPLS-TE applications.')
pwMplsTeMappingEntry = MibTableRow((1, 3, 6, 1, 2, 1, 181, 1, 5, 1), ).setIndexNames((0, "PW-MPLS-STD-MIB", "pwMplsTeMappingTunnelIndex"), (0, "PW-MPLS-STD-MIB", "pwMplsTeMappingTunnelInstance"), (0, "PW-MPLS-STD-MIB", "pwMplsTeMappingTunnelPeerLsrID"), (0, "PW-MPLS-STD-MIB", "pwMplsTeMappingTunnelLocalLsrID"), (0, "PW-MPLS-STD-MIB", "pwMplsTeMappingPwIndex"))
if mibBuilder.loadTexts: pwMplsTeMappingEntry.setStatus('current')
if mibBuilder.loadTexts: pwMplsTeMappingEntry.setDescription('A row in this table represents the association between a PW and its MPLS-TE outer (head-end) tunnel. An application can use this table to quickly retrieve the list of the PWs that are configured on a specific MPLS-TE outer tunnel. The pwMplsTeMappingTunnelInstance reports the actual LSP out of the tunnel head-end that is currently forwarding the traffic. The table is indexed by the head-end indexes of a TE tunnel and the PW index. ')
pwMplsTeMappingTunnelIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 181, 1, 5, 1, 1), MplsTunnelIndex())
if mibBuilder.loadTexts: pwMplsTeMappingTunnelIndex.setStatus('current')
if mibBuilder.loadTexts: pwMplsTeMappingTunnelIndex.setDescription('Primary index for the conceptual row identifying the MPLS-TE tunnel that is carrying the PW traffic.')
pwMplsTeMappingTunnelInstance = MibTableColumn((1, 3, 6, 1, 2, 1, 181, 1, 5, 1, 2), MplsTunnelInstanceIndex())
if mibBuilder.loadTexts: pwMplsTeMappingTunnelInstance.setStatus('current')
if mibBuilder.loadTexts: pwMplsTeMappingTunnelInstance.setDescription('This object identifies the MPLS-TE LSP that is carrying the PW traffic. It MUST return the value zero if the information of the specific LSP is not yet known. Note that based on the recommendation in the MPLS-TC-STD-MIB, instance index 0 should refer to the configured tunnel interface.')
pwMplsTeMappingTunnelPeerLsrID = MibTableColumn((1, 3, 6, 1, 2, 1, 181, 1, 5, 1, 3), MplsLsrIdentifier())
if mibBuilder.loadTexts: pwMplsTeMappingTunnelPeerLsrID.setStatus('current')
if mibBuilder.loadTexts: pwMplsTeMappingTunnelPeerLsrID.setDescription('This object identifies the peer LSR when the outer tunnel is MPLS-TE.')
pwMplsTeMappingTunnelLocalLsrID = MibTableColumn((1, 3, 6, 1, 2, 1, 181, 1, 5, 1, 4), MplsLsrIdentifier())
if mibBuilder.loadTexts: pwMplsTeMappingTunnelLocalLsrID.setStatus('current')
if mibBuilder.loadTexts: pwMplsTeMappingTunnelLocalLsrID.setDescription('This object identifies the local LSR.')
pwMplsTeMappingPwIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 181, 1, 5, 1, 5), PwIndexType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwMplsTeMappingPwIndex.setStatus('current')
if mibBuilder.loadTexts: pwMplsTeMappingPwIndex.setDescription('This object returns the value that represents the PW in the pwTable.')
pwMplsGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 181, 2, 1))
pwMplsCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 181, 2, 2))
pwMplsModuleFullCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 181, 2, 2, 1)).setObjects(("PW-MPLS-STD-MIB", "pwMplsGroup"), ("PW-MPLS-STD-MIB", "pwMplsOutboundMainGroup"), ("PW-MPLS-STD-MIB", "pwMplsInboundGroup"), ("PW-MPLS-STD-MIB", "pwMplsMappingGroup"), ("PW-MPLS-STD-MIB", "pwMplsOutboundTeGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pwMplsModuleFullCompliance = pwMplsModuleFullCompliance.setStatus('current')
if mibBuilder.loadTexts: pwMplsModuleFullCompliance.setDescription('The compliance statement for agents that provide full support for the PW-MPLS-STD-MIB module. Such devices can then be monitored and also be configured using this MIB module.')
pwMplsModuleReadOnlyCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 181, 2, 2, 2)).setObjects(("PW-MPLS-STD-MIB", "pwMplsGroup"), ("PW-MPLS-STD-MIB", "pwMplsOutboundMainGroup"), ("PW-MPLS-STD-MIB", "pwMplsInboundGroup"), ("PW-MPLS-STD-MIB", "pwMplsMappingGroup"), ("PW-MPLS-STD-MIB", "pwMplsOutboundTeGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pwMplsModuleReadOnlyCompliance = pwMplsModuleReadOnlyCompliance.setStatus('current')
if mibBuilder.loadTexts: pwMplsModuleReadOnlyCompliance.setDescription('The compliance statement for agents that provide read- only support for the PW-MPLS-STD-MIB module. Such devices can then be monitored but cannot be configured using this MIB module.')
pwMplsGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 181, 2, 1, 1)).setObjects(("PW-MPLS-STD-MIB", "pwMplsMplsType"), ("PW-MPLS-STD-MIB", "pwMplsExpBitsMode"), ("PW-MPLS-STD-MIB", "pwMplsExpBits"), ("PW-MPLS-STD-MIB", "pwMplsTtl"), ("PW-MPLS-STD-MIB", "pwMplsLocalLdpID"), ("PW-MPLS-STD-MIB", "pwMplsLocalLdpEntityIndex"), ("PW-MPLS-STD-MIB", "pwMplsPeerLdpID"), ("PW-MPLS-STD-MIB", "pwMplsStorageType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pwMplsGroup = pwMplsGroup.setStatus('current')
if mibBuilder.loadTexts: pwMplsGroup.setDescription('Collection of objects needed for PW over MPLS PSN configuration.')
pwMplsOutboundMainGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 181, 2, 1, 2)).setObjects(("PW-MPLS-STD-MIB", "pwMplsOutboundLsrXcIndex"), ("PW-MPLS-STD-MIB", "pwMplsOutboundIfIndex"), ("PW-MPLS-STD-MIB", "pwMplsOutboundTunnelTypeInUse"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pwMplsOutboundMainGroup = pwMplsOutboundMainGroup.setStatus('current')
if mibBuilder.loadTexts: pwMplsOutboundMainGroup.setDescription('Collection of objects needed for outbound association of PW and MPLS tunnel.')
pwMplsOutboundTeGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 181, 2, 1, 3)).setObjects(("PW-MPLS-STD-MIB", "pwMplsOutboundTunnelIndex"), ("PW-MPLS-STD-MIB", "pwMplsOutboundTunnelInstance"), ("PW-MPLS-STD-MIB", "pwMplsOutboundTunnelLclLSR"), ("PW-MPLS-STD-MIB", "pwMplsOutboundTunnelPeerLSR"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pwMplsOutboundTeGroup = pwMplsOutboundTeGroup.setStatus('current')
if mibBuilder.loadTexts: pwMplsOutboundTeGroup.setDescription('Collection of objects needed for outbound association of PW and MPLS-TE tunnel.')
pwMplsInboundGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 181, 2, 1, 4)).setObjects(("PW-MPLS-STD-MIB", "pwMplsInboundXcIndex"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pwMplsInboundGroup = pwMplsInboundGroup.setStatus('current')
if mibBuilder.loadTexts: pwMplsInboundGroup.setDescription('Collection of objects needed for inbound PW presentation. This group MUST be supported if PW signaling through LDP is used.')
pwMplsMappingGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 181, 2, 1, 5)).setObjects(("PW-MPLS-STD-MIB", "pwMplsNonTeMappingPwIndex"), ("PW-MPLS-STD-MIB", "pwMplsTeMappingPwIndex"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pwMplsMappingGroup = pwMplsMappingGroup.setStatus('current')
if mibBuilder.loadTexts: pwMplsMappingGroup.setDescription('Collection of objects needed for mapping association of PW and MPLS tunnel.')
mibBuilder.exportSymbols("PW-MPLS-STD-MIB", pwMplsStdMIB=pwMplsStdMIB, pwMplsInboundEntry=pwMplsInboundEntry, pwMplsTeMappingTunnelPeerLsrID=pwMplsTeMappingTunnelPeerLsrID, pwMplsOutboundTunnelPeerLSR=pwMplsOutboundTunnelPeerLSR, pwMplsNotifications=pwMplsNotifications, pwMplsLocalLdpEntityIndex=pwMplsLocalLdpEntityIndex, pwMplsOutboundMainGroup=pwMplsOutboundMainGroup, pwMplsInboundXcIndex=pwMplsInboundXcIndex, pwMplsInboundGroup=pwMplsInboundGroup, pwMplsOutboundTunnelLclLSR=pwMplsOutboundTunnelLclLSR, pwMplsExpBitsMode=pwMplsExpBitsMode, pwMplsOutboundLsrXcIndex=pwMplsOutboundLsrXcIndex, pwMplsTtl=pwMplsTtl, pwMplsExpBits=pwMplsExpBits, pwMplsNonTeMappingXcIndex=pwMplsNonTeMappingXcIndex, pwMplsGroup=pwMplsGroup, PYSNMP_MODULE_ID=pwMplsStdMIB, pwMplsStorageType=pwMplsStorageType, pwMplsLocalLdpID=pwMplsLocalLdpID, pwMplsNonTeMappingDirection=pwMplsNonTeMappingDirection, pwMplsTable=pwMplsTable, pwMplsConformance=pwMplsConformance, pwMplsOutboundTunnelTypeInUse=pwMplsOutboundTunnelTypeInUse, pwMplsOutboundTeGroup=pwMplsOutboundTeGroup, pwMplsMappingGroup=pwMplsMappingGroup, pwMplsPeerLdpID=pwMplsPeerLdpID, pwMplsInboundTable=pwMplsInboundTable, pwMplsNonTeMappingTable=pwMplsNonTeMappingTable, pwMplsNonTeMappingPwIndex=pwMplsNonTeMappingPwIndex, pwMplsModuleReadOnlyCompliance=pwMplsModuleReadOnlyCompliance, pwMplsNonTeMappingIfIndex=pwMplsNonTeMappingIfIndex, pwMplsEntry=pwMplsEntry, pwMplsOutboundIfIndex=pwMplsOutboundIfIndex, pwMplsOutboundTunnelInstance=pwMplsOutboundTunnelInstance, pwMplsOutboundEntry=pwMplsOutboundEntry, pwMplsOutboundTunnelIndex=pwMplsOutboundTunnelIndex, pwMplsTeMappingEntry=pwMplsTeMappingEntry, pwMplsTeMappingTunnelIndex=pwMplsTeMappingTunnelIndex, pwMplsTeMappingPwIndex=pwMplsTeMappingPwIndex, pwMplsGroups=pwMplsGroups, pwMplsTeMappingTunnelLocalLsrID=pwMplsTeMappingTunnelLocalLsrID, pwMplsTeMappingTunnelInstance=pwMplsTeMappingTunnelInstance, pwMplsObjects=pwMplsObjects, pwMplsNonTeMappingEntry=pwMplsNonTeMappingEntry, pwMplsOutboundTable=pwMplsOutboundTable, pwMplsModuleFullCompliance=pwMplsModuleFullCompliance, pwMplsTeMappingTable=pwMplsTeMappingTable, pwMplsMplsType=pwMplsMplsType, pwMplsCompliances=pwMplsCompliances)

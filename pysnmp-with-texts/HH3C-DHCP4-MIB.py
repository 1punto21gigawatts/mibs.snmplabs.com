#
# PySNMP MIB module HH3C-DHCP4-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/HH3C-DHCP4-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:25:54 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, SingleValueConstraint, ConstraintsIntersection, ValueRangeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsIntersection", "ValueRangeConstraint", "ConstraintsUnion")
hh3cCommon, = mibBuilder.importSymbols("HH3C-OID-MIB", "hh3cCommon")
InterfaceIndexOrZero, ifIndex = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero", "ifIndex")
InetAddressIPv4, = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressIPv4")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
iso, Unsigned32, NotificationType, Counter64, MibScalar, MibTable, MibTableRow, MibTableColumn, Gauge32, MibIdentifier, IpAddress, Counter32, ObjectIdentity, ModuleIdentity, Integer32, Bits, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "iso", "Unsigned32", "NotificationType", "Counter64", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Gauge32", "MibIdentifier", "IpAddress", "Counter32", "ObjectIdentity", "ModuleIdentity", "Integer32", "Bits", "TimeTicks")
TruthValue, MacAddress, RowStatus, TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TruthValue", "MacAddress", "RowStatus", "TextualConvention", "DisplayString")
hh3cDhcp4 = ModuleIdentity((1, 3, 6, 1, 4, 1, 25506, 2, 122))
hh3cDhcp4.setRevisions(('2013-04-24 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: hh3cDhcp4.setRevisionsDescriptions(('The private MIB file includes the DHCPv4 server and relay profile.',))
if mibBuilder.loadTexts: hh3cDhcp4.setLastUpdated('201304240000Z')
if mibBuilder.loadTexts: hh3cDhcp4.setOrganization('Hangzhou H3C Technologies Co., Ltd.')
if mibBuilder.loadTexts: hh3cDhcp4.setContactInfo('Platform Team H3C Technologies Co., Ltd. Hai-Dian District Beijing P.R. China http://www.h3c.com Zip: 100085')
if mibBuilder.loadTexts: hh3cDhcp4.setDescription('DHCPv4 MIB')
hh3cDhcpServer2ScalarObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 122, 1))
hh3cDhcpServer2ConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 122, 1, 1))
hh3cDhcpServer2Enabled = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 122, 1, 1, 1), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDhcpServer2Enabled.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2Enabled.setDescription("If the value of this object is 'true', the DHCP service is enabled.")
hh3cDhcpServer2AlwaysBroadcast = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 122, 1, 1, 2), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDhcpServer2AlwaysBroadcast.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2AlwaysBroadcast.setDescription("When the value of this object is set to 'true', the DHCP server always uses broadcast to reply the client.")
hh3cDhcpServer2IgnoreBootp = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 122, 1, 1, 3), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDhcpServer2IgnoreBootp.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2IgnoreBootp.setDescription("When the value of this object is set to 'true', the DHCP server ignores BOOTP requests.")
hh3cDhcpServer2BootpReplyRfc1048 = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 122, 1, 1, 4), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDhcpServer2BootpReplyRfc1048.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2BootpReplyRfc1048.setDescription("When the value of this object is set to 'true', the DHCP server use RFC 1048 format to reply to BOOTP requests.")
hh3cDhcpServer2Opt82Enabled = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 122, 1, 1, 5), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDhcpServer2Opt82Enabled.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2Opt82Enabled.setDescription("When the value of this object is set to 'true', the DHCP server handles DHCP option 82.")
hh3cDhcpServer2PingNumber = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 122, 1, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 10)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDhcpServer2PingNumber.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PingNumber.setDescription('The number of ping packets sent out.')
hh3cDhcpServer2PingTimeout = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 122, 1, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000)).clone(500)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDhcpServer2PingTimeout.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PingTimeout.setDescription('The delay for the reply of a ping packet in milliseconds.')
hh3cDhcpServer2StatGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 122, 1, 2))
hh3cDhcpServer2BadNum = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 122, 1, 2, 1), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDhcpServer2BadNum.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2BadNum.setDescription('The total number of the bad packets received.')
hh3cDhcpServer2BootpRequestNum = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 122, 1, 2, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDhcpServer2BootpRequestNum.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2BootpRequestNum.setDescription('The total number of the BOOTREQUEST packets received.')
hh3cDhcpServer2DiscoverNum = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 122, 1, 2, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDhcpServer2DiscoverNum.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2DiscoverNum.setDescription('The total number of the DHCPDISCOVER packets received from the DHCP clients.')
hh3cDhcpServer2RequestNum = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 122, 1, 2, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDhcpServer2RequestNum.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2RequestNum.setDescription('The total number of the DHCPREQUEST packets received from the DHCP clients.')
hh3cDhcpServer2DeclineNum = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 122, 1, 2, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDhcpServer2DeclineNum.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2DeclineNum.setDescription('The total number of the DHCPDECLINE packets received from the DHCP clients.')
hh3cDhcpServer2ReleaseNum = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 122, 1, 2, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDhcpServer2ReleaseNum.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2ReleaseNum.setDescription('The total number of the DHCPRELEASE packets received from the DHCP clients.')
hh3cDhcpServer2InformNum = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 122, 1, 2, 7), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDhcpServer2InformNum.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2InformNum.setDescription('The total number of the DHCPINFORM packets received from the DHCP clients.')
hh3cDhcpServer2BootpReplyNum = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 122, 1, 2, 8), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDhcpServer2BootpReplyNum.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2BootpReplyNum.setDescription('The total number of the BOOTREPLY packets sent by the DHCP server.')
hh3cDhcpServer2OfferNum = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 122, 1, 2, 9), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDhcpServer2OfferNum.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2OfferNum.setDescription('The total number of the DHCPOFFER packets sent by the DHCP server.')
hh3cDhcpServer2AckNum = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 122, 1, 2, 10), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDhcpServer2AckNum.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2AckNum.setDescription('The total number of the DHCPACK packets sent by the DHCP server.')
hh3cDhcpServer2NakNum = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 122, 1, 2, 11), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDhcpServer2NakNum.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2NakNum.setDescription('The total number of the DHCPNAK packets sent by the DHCP server.')
hh3cDhcpServer2TotalPoolUsage = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 122, 1, 2, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDhcpServer2TotalPoolUsage.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2TotalPoolUsage.setDescription('The percentage of IP addresses in use of all DHCP server pools.')
hh3cDhcpServer2PoolNumber = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 122, 1, 2, 13), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDhcpServer2PoolNumber.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PoolNumber.setDescription('The total number of DHCP server pools.')
hh3cDhcpServer2ConflictNum = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 122, 1, 2, 14), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDhcpServer2ConflictNum.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2ConflictNum.setDescription('The total number of conflict IP in all DHCP server pools.')
hh3cDhcpServer2AutoBindNum = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 122, 1, 2, 15), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDhcpServer2AutoBindNum.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2AutoBindNum.setDescription('The total number of auto binding IP in DHCP server pools.')
hh3cDhcpServer2ManualBindNum = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 122, 1, 2, 16), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDhcpServer2ManualBindNum.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2ManualBindNum.setDescription('The total number of manual binding IP in DHCP server pools.')
hh3cDhcpServer2ExpiredBindNum = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 122, 1, 2, 17), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDhcpServer2ExpiredBindNum.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2ExpiredBindNum.setDescription('The total number of expired binding IP in DHCP server pools.')
hh3cDhcpServer2Tables = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2))
hh3cDhcpServer2PoolTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 1), )
if mibBuilder.loadTexts: hh3cDhcpServer2PoolTable.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PoolTable.setDescription('A table containing DHCP server pool configurations.')
hh3cDhcpServer2PoolEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 1, 1), ).setIndexNames((0, "HH3C-DHCP4-MIB", "hh3cDhcpServer2PoolIndex"))
if mibBuilder.loadTexts: hh3cDhcpServer2PoolEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PoolEntry.setDescription('An entry containing DHCP server pool configurations.')
hh3cDhcpServer2PoolIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 1, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: hh3cDhcpServer2PoolIndex.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PoolIndex.setDescription('DHCP server pool index.')
hh3cDhcpServer2PoolName = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 63))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2PoolName.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PoolName.setDescription('DHCP server pool name. Once this object is created, the value of this object cannot be modified.')
hh3cDhcpServer2PoolVpnName = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2PoolVpnName.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PoolVpnName.setDescription('Name of the VPN instance that the DHCP pool binds to. The value of a zero-length string means the public network. Once this object is created, the value of this object cannot be modified.')
hh3cDhcpServer2PoolNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 1, 1, 4), InetAddressIPv4()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2PoolNetwork.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PoolNetwork.setDescription('Network address of the primary subnet in a DHCP pool. If the value of this object is set to 0.0.0.0, hh3cDhcpServer2PoolNetworkMask is set with 0.0.0.0 automatically.')
hh3cDhcpServer2PoolNetworkMask = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 1, 1, 5), InetAddressIPv4()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2PoolNetworkMask.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PoolNetworkMask.setDescription('Network mask of the primary subnet in a DHCP pool. The SET operation to this object ought to be with the SET of hh3cDhcpServer2PoolNetwork together, and any SET operation alone to this object will be regarded as an invalid operation.')
hh3cDhcpServer2PoolStartAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 1, 1, 6), InetAddressIPv4()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2PoolStartAddr.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PoolStartAddr.setDescription('Start IP of an address range of the DHCP pool. If the value of this object is set to 0.0.0.0, hh3cDhcpServer2PoolEndAddr is set with 0.0.0.0 automatically. Otherwise hh3cDhcpServer2PoolEndAddr must be set with an IP address NOT smaller than the value of this object.')
hh3cDhcpServer2PoolEndAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 1, 1, 7), InetAddressIPv4()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2PoolEndAddr.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PoolEndAddr.setDescription('End IP of an address range of the DHCP pool, The SET operation to this object ought to be with the SET of hh3cDhcpServer2PoolStartAddr together, and any SET operation alone to this object will be regarded as an invalid operation.')
hh3cDhcpServer2PoolLeaseDay = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 365)).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2PoolLeaseDay.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PoolLeaseDay.setDescription('Number of days of the lease. The SET operation to this object ought to be with the SET of hh3cDhcpServer2PoolLeaseHour, hh3cDhcpServer2PoolLeaseMinute, hh3cDhcpServer2PoolLeaseSecond together, and any SET operation alone to any of these objects will be regarded as an invalid operation. These objects cannot be set with 0 simultaneously.')
hh3cDhcpServer2PoolLeaseHour = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 23))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2PoolLeaseHour.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PoolLeaseHour.setDescription('Number of hours of the lease.')
hh3cDhcpServer2PoolLeaseMinute = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 59))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2PoolLeaseMinute.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PoolLeaseMinute.setDescription('Number of minutes of the lease.')
hh3cDhcpServer2PoolLeaseSecond = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 59))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2PoolLeaseSecond.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PoolLeaseSecond.setDescription('Number of seconds of the lease.')
hh3cDhcpServer2PoolLeaseUnlimit = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 1, 1, 12), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2PoolLeaseUnlimit.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PoolLeaseUnlimit.setDescription('A flag denoting whether the lease time of a DHCP pool is unlimited.')
hh3cDhcpServer2PoolLeaseTime = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 1, 1, 13), TimeTicks()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2PoolLeaseTime.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PoolLeaseTime.setDescription('The lease time of a DHCP pool in number of timeticks. The value of this object cannot be set to 0 and must be set to 4294967295 or a multiple of 100. If the object is set with 4294967295, the lease time of a DHCP pool is unlimited.')
hh3cDhcpServer2PoolDomainName = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 1, 1, 14), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 50))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2PoolDomainName.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PoolDomainName.setDescription('Domain name for DHCP clients. If the object is set with a zero-length string, the configuration of the domain name is removed.')
hh3cDhcpServer2PoolGatewayIP = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 1, 1, 15), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 127))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2PoolGatewayIP.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PoolGatewayIP.setDescription('Gateway IP addresses for DHCP clients. IP addresses are space separated and the leading or trailing space will be trimmed. Since at most 8 gateway addresses can be configured for a pool, a string is defined to get or configure 8 IP at a time. If the object is set with a zero-length string, the configuration of the gateway address is removed.')
hh3cDhcpServer2PoolDNSIP = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 1, 1, 16), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 127))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2PoolDNSIP.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PoolDNSIP.setDescription('DNS server IP addresses for DHCP clients. IP addresses are space separated and the leading or trailing space will be trimmed. Since at most 8 DNS server addresses can be configured for a pool, a string is defined to get or configure 8 IP at a time. If the object is set with a zero-length string, the configuration of the DNS address is removed.')
hh3cDhcpServer2PoolPrimaryDNSIP = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 1, 1, 17), InetAddressIPv4()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2PoolPrimaryDNSIP.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PoolPrimaryDNSIP.setDescription('The primary DNS server IP address to be assigned to the client.')
hh3cDhcpServer2PoolSecondDNSIP = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 1, 1, 18), InetAddressIPv4()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2PoolSecondDNSIP.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PoolSecondDNSIP.setDescription('The secondary DNS server IP address to be assigned to the client.')
hh3cDhcpServer2PoolNetbiosType = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 4, 8))).clone(namedValues=NamedValues(("null", 0), ("bnode", 1), ("pnode", 2), ("mnode", 4), ("hnode", 8))).clone('null')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2PoolNetbiosType.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PoolNetbiosType.setDescription('NetBios node type for DHCP clients.')
hh3cDhcpServer2PoolNbnsIP = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 1, 1, 20), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 127))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2PoolNbnsIP.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PoolNbnsIP.setDescription('NetBios server IP addresses for DHCP clients. IP addresses are space separated and the leading or trailing space will be trimmed. Since at most 8 NetBios server addresses can be configured for a pool, a string is defined to get or configure 8 IP at a time. If the object is set with a zero-length string, the configuration of the NBNS address is removed.')
hh3cDhcpServer2PoolBootFileName = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 1, 1, 21), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2PoolBootFileName.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PoolBootFileName.setDescription('Boot file name for DHCP clients. If the object is set with a zero-length string, the configuration of the boot file name is removed.')
hh3cDhcpServer2PoolBimsIP = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 1, 1, 22), InetAddressIPv4()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2PoolBimsIP.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PoolBimsIP.setDescription('BIMS server IP address. If the object is set with 0.0.0.0, hh3cDhcpServer2PoolBimsPort is set with 0 and hh3cDhcpServer2PoolBimsKeyStr is set with a zero-length string automatically. Otherwise hh3cDhcpServer2PoolBimsPort and hh3cDhcpServer2PoolBimsKeyStr must be set at the same time while hh3cDhcpServer2PoolBimsKeyStr must be set with a non-zero length string.')
hh3cDhcpServer2PoolBimsPort = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 1, 1, 23), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65534))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2PoolBimsPort.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PoolBimsPort.setDescription('BIMS server port number. The SET operation to this object ought to be with the SET operation of hh3cDhcpServer2PoolBimsIP and hh3cDhcpServer2PoolBimsKeyStr together, and any SET operation alone to this object will be regarded as an invalid operation.')
hh3cDhcpServer2PoolBimsKeyStr = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 1, 1, 24), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2PoolBimsKeyStr.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PoolBimsKeyStr.setDescription('BIMS server key string. The SET operation to this object ought to be with the SET of hh3cDhcpServer2PoolBimsIP and hh3cDhcpServer2PoolBimsPort together, and any SET operation alone to this object will be regarded as an invalid operation.')
hh3cDhcpServer2PoolNextServer = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 1, 1, 25), InetAddressIPv4()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2PoolNextServer.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PoolNextServer.setDescription('Next DHCP server IP address for DHCP clients. If the object is set with 0.0.0.0, the configuration of the next server address is removed.')
hh3cDhcpServer2PoolTftpDomName = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 1, 1, 26), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2PoolTftpDomName.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PoolTftpDomName.setDescription('TFTP server domain name for DHCP clients. If the object is set with a zero-length string, the configuration of the TFTP domain name is removed.')
hh3cDhcpServer2PoolTftpIP = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 1, 1, 27), InetAddressIPv4()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2PoolTftpIP.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PoolTftpIP.setDescription('TFTP server IP address for DHCP clients. If the object is set with 0.0.0.0, the configuration of the TFTP server address is removed.')
hh3cDhcpServer2PoolVoiceAsIP = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 1, 1, 28), InetAddressIPv4()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2PoolVoiceAsIP.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PoolVoiceAsIP.setDescription('Voice backup server IP address for DHCP clients. If the object is set with 0.0.0.0, the configuration of voice backup server IP address is removed.')
hh3cDhcpServer2PoolVoiceFailIP = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 1, 1, 29), InetAddressIPv4()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2PoolVoiceFailIP.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PoolVoiceFailIP.setDescription('Voice failover IP address for DHCP clients. If the object is set with 0.0.0.0, hh3cDhcpServer2PoolVoiceFailStr is set with a zero-length string automatically. Otherwise hh3cDhcpServer2PoolVoiceFailStr must be set with a non-zero length string at the same time.')
hh3cDhcpServer2PoolVoiceFailStr = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 1, 1, 30), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 39))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2PoolVoiceFailStr.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PoolVoiceFailStr.setDescription("Voice failover dialer string for DHCP clients. The characters in the string must be '0' ~ '9',or '*'. The SET operation to this object ought to be with the SET operation of hh3cDhcpServer2PoolVoiceFailIP together, and any SET operation alone to this object will be regarded as an invalid operation.")
hh3cDhcpServer2PoolVoiceNCPIP = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 1, 1, 31), InetAddressIPv4()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2PoolVoiceNCPIP.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PoolVoiceNCPIP.setDescription('Voice network calling processing IP address for DHCP clients. If the object is set with 0.0.0.0, the configuration of voice network calling processing IP address is removed.')
hh3cDhcpServer2PoolVoiceVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 1, 1, 32), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(2, 4094), ValueRangeConstraint(65535, 65535), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2PoolVoiceVlanId.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PoolVoiceVlanId.setDescription("Voice VLAN ID for DHCP clients. If the value of this object is set to 65535, hh3cDhcpServer2PoolVoiceVlanEnbl is set with 'false' automatically. Otherwise hh3cDhcpServer2PoolVoiceVlanEnbl must also be set.")
hh3cDhcpServer2PoolVoiceVlanEnbl = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 1, 1, 33), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2PoolVoiceVlanEnbl.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PoolVoiceVlanEnbl.setDescription('Enable status of the specified voice VLAN for DHCP clients. The SET operation to this object ought to be with the SET operation of hh3cDhcpServer2PoolVoiceVlanId together, and any SET operation alone to this object will be regarded as an invalid operation.')
hh3cDhcpServer2PoolRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 1, 1, 34), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2PoolRowStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PoolRowStatus.setDescription('RowStatus. Three actions are used: active, createAndGo, destroy.')
hh3cDhcpServer2PoolVerifyClass = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 1, 1, 35), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2PoolVerifyClass.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PoolVerifyClass.setDescription("Enable the user class verification. When the value of this object is set to 'true', the DHCP server processes packets from DHCP clients in the defined user classes. The user class verification does not apply to packets from DHCP clients with static bindings.")
hh3cDhcpServer2IfApplyPoolTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 2), )
if mibBuilder.loadTexts: hh3cDhcpServer2IfApplyPoolTable.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2IfApplyPoolTable.setDescription('A table for applying a DHCP pool on interfaces.')
hh3cDhcpServer2IfApplyPoolEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: hh3cDhcpServer2IfApplyPoolEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2IfApplyPoolEntry.setDescription('An entry for applying a DHCP pool on the interface.')
hh3cDhcpServer2IfApplyPoolName = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 2, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDhcpServer2IfApplyPoolName.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2IfApplyPoolName.setDescription('The name of the DHCP pool that apply to the interface. If the object is set with a zero-length string, the configuration will be deleted.')
hh3cDhcpServer2PoolSecNwTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 3), )
if mibBuilder.loadTexts: hh3cDhcpServer2PoolSecNwTable.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PoolSecNwTable.setDescription('A table containing the secondary network configuration of DHCP pools.')
hh3cDhcpServer2PoolSecNwEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 3, 1), ).setIndexNames((0, "HH3C-DHCP4-MIB", "hh3cDhcpServer2PoolIndex"), (0, "HH3C-DHCP4-MIB", "hh3cDhcpServer2PoolSecNw"), (0, "HH3C-DHCP4-MIB", "hh3cDhcpServer2PoolSecNwMask"))
if mibBuilder.loadTexts: hh3cDhcpServer2PoolSecNwEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PoolSecNwEntry.setDescription('An entry containing the objects for configuring the secondary network for DHCP pools.')
hh3cDhcpServer2PoolSecNw = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 3, 1, 1), InetAddressIPv4())
if mibBuilder.loadTexts: hh3cDhcpServer2PoolSecNw.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PoolSecNw.setDescription('Network address of the secondary subnets in a DHCP pool.')
hh3cDhcpServer2PoolSecNwMask = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 3, 1, 2), InetAddressIPv4())
if mibBuilder.loadTexts: hh3cDhcpServer2PoolSecNwMask.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PoolSecNwMask.setDescription('Network mask of the secondary subnets in a DHCP pool.')
hh3cDhcpServer2PoolSecNwGwIP = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 3, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 127))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2PoolSecNwGwIP.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PoolSecNwGwIP.setDescription('Gateway IP addresses of the secondary subnets in a DHCP pool. IP addresses are space separated and the leading or trailing space will be trimmed. Since at most 8 gateway addresses can be configured for a secondary network, a string is defined to get or configure 8 IP at a time. If the object is set with a zero-length string, the configuration of the gateway address is removed.')
hh3cDhcpServer2PoolSecNwStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 3, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2PoolSecNwStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PoolSecNwStatus.setDescription('RowStatus. Three actions are used: active, createAndGo, destroy.')
hh3cDhcpServer2PoolClassTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 4), )
if mibBuilder.loadTexts: hh3cDhcpServer2PoolClassTable.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PoolClassTable.setDescription('A table containing address range of the DHCP server pool for user classes.')
hh3cDhcpServer2PoolClassEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 4, 1), ).setIndexNames((0, "HH3C-DHCP4-MIB", "hh3cDhcpServer2PoolIndex"), (0, "HH3C-DHCP4-MIB", "hh3cDhcpServer2PoolClassName"))
if mibBuilder.loadTexts: hh3cDhcpServer2PoolClassEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PoolClassEntry.setDescription('An entry containing address range of DHCP pools for user classes.')
hh3cDhcpServer2PoolClassName = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 4, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 63)))
if mibBuilder.loadTexts: hh3cDhcpServer2PoolClassName.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PoolClassName.setDescription('User class name.')
hh3cDhcpServer2PoolClassStart = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 4, 1, 2), InetAddressIPv4()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2PoolClassStart.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PoolClassStart.setDescription('Start address of an address range for a DHCP user class. The SET operation to this object ought to be with the SET operation of hh3cDhcpServer2PoolClassEnd together, and any SET operation alone to this object will be regarded as an invalid operation.')
hh3cDhcpServer2PoolClassEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 4, 1, 3), InetAddressIPv4()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2PoolClassEnd.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PoolClassEnd.setDescription('End address of an address range for a DHCP user class. The SET operation to this object ought to be with the SET of hh3cDhcpServer2PoolClassStart together, and any SET operation alone to this object will be regarded as an invalid operation. This object must be set with an IP address NOT smaller than the value of hh3cDhcpServer2PoolClassStart.')
hh3cDhcpServer2PoolClassStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 4, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2PoolClassStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PoolClassStatus.setDescription("RowStatus. Three actions are used: active, createAndGo, destroy. If the value of this object is set to 'createAndGo', hh3cDhcpServer2PoolClassStart and hh3cDhcpServer2PoolClassEnd must also be set.")
hh3cDhcpServer2PoolStaticTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 5), )
if mibBuilder.loadTexts: hh3cDhcpServer2PoolStaticTable.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PoolStaticTable.setDescription('A table containing the static binding configurations in DHCP pools.')
hh3cDhcpServer2PoolStaticEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 5, 1), ).setIndexNames((0, "HH3C-DHCP4-MIB", "hh3cDhcpServer2PoolIndex"), (0, "HH3C-DHCP4-MIB", "hh3cDhcpServer2PoolStaticIP"))
if mibBuilder.loadTexts: hh3cDhcpServer2PoolStaticEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PoolStaticEntry.setDescription('An entry containing the objects for configuring the static binding in DHCP pools.')
hh3cDhcpServer2PoolStaticIP = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 5, 1, 1), InetAddressIPv4())
if mibBuilder.loadTexts: hh3cDhcpServer2PoolStaticIP.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PoolStaticIP.setDescription('Ip address of a static binding in a DHCP pool.')
hh3cDhcpServer2PoolStaticMask = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 5, 1, 2), InetAddressIPv4()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2PoolStaticMask.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PoolStaticMask.setDescription('Network mask of a static binding in a DHCP pool.')
hh3cDhcpServer2PoolStaticCID = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 5, 1, 3), OctetString().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(4, 254), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2PoolStaticCID.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PoolStaticCID.setDescription('Client identifier of a DHCP client that the IP address binds to. The structure of the OCTET STRING is H-H-H... while H indicates 4 hexadecimal characters except that the last H indicates 2 or 4 hexadecimal characters.')
hh3cDhcpServer2PoolStaticHAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 5, 1, 4), OctetString().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(4, 39), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2PoolStaticHAddr.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PoolStaticHAddr.setDescription('Hardware address of a DHCP client that the IP address binds to. The structure of the OCTET STRING is H-H-H... while H indicates 4 hexadecimal characters except that the last H indicates 2 or 4 hexadecimal characters.')
hh3cDhcpServer2PoolStaticHType = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 5, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("default", 1), ("ethernet", 2), ("tokenRing", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2PoolStaticHType.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PoolStaticHType.setDescription("Hardware type of a DHCP client that the IP address binds to. The SET operation to this object ought to be with the SET operation of hh3cDhcpServer2PoolStaticHAddr, and any SET operation alone to this object will be regarded as an invalid operation. 'default' indicates that the hardware type is unknown. If the value of hh3cDhcpServer2PoolStaticCID is set to a non-zero length string, the object is set with 'default' automatically. Otherwise it cannot be set with 'default'. 'ethernet' indicates that the hardware type is ethernet. If the value of hh3cDhcpServer2PoolStaticHAddr is set with a non-zero length string, the default value of this object is 'ethernet'. 'tokenRing' indicates that the hardware type is token-ring.")
hh3cDhcpServer2PoolStaticStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 5, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2PoolStaticStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PoolStaticStatus.setDescription("RowStatus. Three actions are used: active, createAndGo, destroy. If the value of this object is set to 'createAndGo', hh3cDhcpServer2PoolStaticCID or (hh3cDhcpServer2PoolStaticHardAddr and hh3cDhcpServer2PoolStaticHardType) must also be set.")
hh3cDhcpServer2PoolOptionTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 6), )
if mibBuilder.loadTexts: hh3cDhcpServer2PoolOptionTable.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PoolOptionTable.setDescription('A table for configuring user-defined options for DHCP pools.')
hh3cDhcpServer2PoolOptionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 6, 1), ).setIndexNames((0, "HH3C-DHCP4-MIB", "hh3cDhcpServer2PoolIndex"), (0, "HH3C-DHCP4-MIB", "hh3cDhcpServer2PoolOptCode"))
if mibBuilder.loadTexts: hh3cDhcpServer2PoolOptionEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PoolOptionEntry.setDescription('An entry containing the objects for configuring user-defined options for DHCP pools.')
hh3cDhcpServer2PoolOptCode = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 254)))
if mibBuilder.loadTexts: hh3cDhcpServer2PoolOptCode.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PoolOptCode.setDescription('Option code.')
hh3cDhcpServer2PoolOptType = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ascii", 1), ("hex", 2), ("ip", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2PoolOptType.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PoolOptType.setDescription("Option type. 'ascii' means using the ascii string that is defined by hh3cDhcpServer2PoolOptAscii to fill in the option. 'hex' means using the hex string that is defined by hh3cDhcpServer2PoolOptHexStr to fill in the option. 'ip' means using the IP string that is defined by hh3cDhcpServer2PoolOptIPStr to fill in the option.")
hh3cDhcpServer2PoolOptAscii = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 6, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2PoolOptAscii.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PoolOptAscii.setDescription("Ascii string of an option. If hh3cDhcpServer2PoolOptType is set with 'ascii', this object must be set with a non-zero length string.")
hh3cDhcpServer2PoolOptHexStr = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 6, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 510))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2PoolOptHexStr.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PoolOptHexStr.setDescription("Hex string of an option. The length of the string must be even. If hh3cDhcpServer2PoolOptType is set with 'hex', this object must be set with a non-zero length string.")
hh3cDhcpServer2PoolOptIPStr = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 6, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 127))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2PoolOptIPStr.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PoolOptIPStr.setDescription("IP string of an option. IP addresses are space separated and the leading or trailing space will be trimmed. 1 to 8 IP addresses can be configured simultaneously. If hh3cDhcpServer2PoolOptType is set with 'ip', this object must be set with a non-zero length string that must contain at least one IP address.")
hh3cDhcpServer2PoolOptRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 6, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2PoolOptRowStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PoolOptRowStatus.setDescription("RowStatus. Three actions are used: active, createAndGo, destroy. If the value of this object is set to 'createAndGo', hh3cDhcpServer2PoolOptType must also be set.")
hh3cDhcpServer2PoolForbidTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 7), )
if mibBuilder.loadTexts: hh3cDhcpServer2PoolForbidTable.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PoolForbidTable.setDescription('A table for configuring forbidden IP for a DHCP server pool.')
hh3cDhcpServer2PoolForbidEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 7, 1), ).setIndexNames((0, "HH3C-DHCP4-MIB", "hh3cDhcpServer2PoolIndex"), (0, "HH3C-DHCP4-MIB", "hh3cDhcpServer2PoolForbidIP"))
if mibBuilder.loadTexts: hh3cDhcpServer2PoolForbidEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PoolForbidEntry.setDescription('An entry for configuring forbidden IP for a DHCP server pool.')
hh3cDhcpServer2PoolForbidIP = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 7, 1, 1), InetAddressIPv4())
if mibBuilder.loadTexts: hh3cDhcpServer2PoolForbidIP.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PoolForbidIP.setDescription('Forbidden IP of the DHCP pool.')
hh3cDhcpServer2PoolForbidStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 7, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2PoolForbidStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2PoolForbidStatus.setDescription('RowStatus. Three actions are used: active, createAndGo, destroy.')
hh3cDhcpServer2ClassTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 8), )
if mibBuilder.loadTexts: hh3cDhcpServer2ClassTable.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2ClassTable.setDescription('A table for configuring user class to DHCP server.')
hh3cDhcpServer2ClassEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 8, 1), ).setIndexNames((0, "HH3C-DHCP4-MIB", "hh3cDhcpServer2ClassName"))
if mibBuilder.loadTexts: hh3cDhcpServer2ClassEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2ClassEntry.setDescription('An entry for configuring user class to DHCP server.')
hh3cDhcpServer2ClassName = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 8, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 63)))
if mibBuilder.loadTexts: hh3cDhcpServer2ClassName.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2ClassName.setDescription('DHCP user class name.')
hh3cDhcpServer2ClassRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 8, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2ClassRowStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2ClassRowStatus.setDescription('RowStatus. Three actions are used: active, createAndGo, destroy.')
hh3cDhcpServer2RuleTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 9), )
if mibBuilder.loadTexts: hh3cDhcpServer2RuleTable.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2RuleTable.setDescription('A table for configuring option rules used to match DHCP users.')
hh3cDhcpServer2RuleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 9, 1), ).setIndexNames((0, "HH3C-DHCP4-MIB", "hh3cDhcpServer2ClassName"), (0, "HH3C-DHCP4-MIB", "hh3cDhcpServer2RuleNumber"))
if mibBuilder.loadTexts: hh3cDhcpServer2RuleEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2RuleEntry.setDescription('An entry for configuring option rules used to match DHCP users.')
hh3cDhcpServer2RuleNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 9, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)))
if mibBuilder.loadTexts: hh3cDhcpServer2RuleNumber.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2RuleNumber.setDescription('Rule number.')
hh3cDhcpServer2RuleOptCode = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 9, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 254))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2RuleOptCode.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2RuleOptCode.setDescription('Option code.')
hh3cDhcpServer2RuleOptHexStr = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 9, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 510))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2RuleOptHexStr.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2RuleOptHexStr.setDescription('Hex string of an option. The length of the string must be even.')
hh3cDhcpServer2RuleOptMask = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 9, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 510))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2RuleOptMask.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2RuleOptMask.setDescription('The mask used to match options. The length of this object must be same with that of hh3cDhcpServer2RuleOptHexStr. The SET operation of this object must be with the SET operation of hh3cDhcpServer2RuleOptHexStr.')
hh3cDhcpServer2RuleOptOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 9, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 254))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2RuleOptOffset.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2RuleOptOffset.setDescription('The option offset used to match users. The SET operation of this object must be with the SET operation of hh3cDhcpServer2RuleOptHexStr, hh3cDhcpServer2RuleOptLength.')
hh3cDhcpServer2RuleOptLength = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 9, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2RuleOptLength.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2RuleOptLength.setDescription('The option length used to match user options. The SET operation of this object must be with the SET operation of hh3cDhcpServer2RuleOptOffset.')
hh3cDhcpServer2RuleRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 9, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2RuleRowStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2RuleRowStatus.setDescription("RowStatus. Three actions are used: active, createAndGo, destroy. If the value of this object is set to 'createAndGo', hh3cDhcpServer2RuleOptCode must also be set.")
hh3cDhcpServer2ForbidTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 10), )
if mibBuilder.loadTexts: hh3cDhcpServer2ForbidTable.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2ForbidTable.setDescription('A table for configuring forbidden IP range to DHCP server.')
hh3cDhcpServer2ForbidEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 10, 1), ).setIndexNames((0, "HH3C-DHCP4-MIB", "hh3cDhcpServer2ForbidVpnName"), (0, "HH3C-DHCP4-MIB", "hh3cDhcpServer2ForbidStart"), (0, "HH3C-DHCP4-MIB", "hh3cDhcpServer2ForbidEnd"))
if mibBuilder.loadTexts: hh3cDhcpServer2ForbidEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2ForbidEntry.setDescription('An entry for configuring forbidden IP range to DHCP server.')
hh3cDhcpServer2ForbidVpnName = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 10, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 31)))
if mibBuilder.loadTexts: hh3cDhcpServer2ForbidVpnName.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2ForbidVpnName.setDescription('Name of the VPN instance that the forbidden IP range binds to. If the value of this object is 0x1, the network that the forbidden IP range belongs to is the public network.')
hh3cDhcpServer2ForbidStart = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 10, 1, 2), InetAddressIPv4())
if mibBuilder.loadTexts: hh3cDhcpServer2ForbidStart.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2ForbidStart.setDescription('Start IP of forbidden IP range.')
hh3cDhcpServer2ForbidEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 10, 1, 3), InetAddressIPv4())
if mibBuilder.loadTexts: hh3cDhcpServer2ForbidEnd.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2ForbidEnd.setDescription('End IP of forbidden IP range.')
hh3cDhcpServer2ForbidRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 10, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2ForbidRowStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2ForbidRowStatus.setDescription('RowStatus. Three actions are used: active, createAndGo, destroy.')
hh3cDhcpServer2FreeTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 11), )
if mibBuilder.loadTexts: hh3cDhcpServer2FreeTable.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2FreeTable.setDescription('A table for displaying free IP range for DHCP server.')
hh3cDhcpServer2FreeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 11, 1), ).setIndexNames((0, "HH3C-DHCP4-MIB", "hh3cDhcpServer2PoolIndex"), (0, "HH3C-DHCP4-MIB", "hh3cDhcpServer2FreeStart"))
if mibBuilder.loadTexts: hh3cDhcpServer2FreeEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2FreeEntry.setDescription('An entry for displaying free IP range for DHCP server.')
hh3cDhcpServer2FreeStart = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 11, 1, 1), InetAddressIPv4())
if mibBuilder.loadTexts: hh3cDhcpServer2FreeStart.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2FreeStart.setDescription('Start IP of free IP range.')
hh3cDhcpServer2FreeEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 11, 1, 2), InetAddressIPv4()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDhcpServer2FreeEnd.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2FreeEnd.setDescription('End IP of free IP range.')
hh3cDhcpServer2ConflictTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 12), )
if mibBuilder.loadTexts: hh3cDhcpServer2ConflictTable.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2ConflictTable.setDescription('A table for displaying the information of conflict IP for DHCP server.')
hh3cDhcpServer2ConflictEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 12, 1), ).setIndexNames((0, "HH3C-DHCP4-MIB", "hh3cDhcpServer2PoolIndex"), (0, "HH3C-DHCP4-MIB", "hh3cDhcpServer2ConflictIP"))
if mibBuilder.loadTexts: hh3cDhcpServer2ConflictEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2ConflictEntry.setDescription('An entry for displaying the information of conflict IP for DHCP server.')
hh3cDhcpServer2ConflictIP = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 12, 1, 1), InetAddressIPv4())
if mibBuilder.loadTexts: hh3cDhcpServer2ConflictIP.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2ConflictIP.setDescription('Conflict IP.')
hh3cDhcpServer2ConflictType = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("detectByServer", 1), ("detectByClient", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDhcpServer2ConflictType.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2ConflictType.setDescription("Type of the detection of conflict IP. 'detectByServer' denotes that the conflict is detected by DHCP server. 'detectByClient' denotes that the conflict is detected by DHCP client.")
hh3cDhcpServer2ConflictTime = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 12, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 19))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDhcpServer2ConflictTime.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2ConflictTime.setDescription('Time when the conflict is detected. The structure of the OCTET STRING is month/day/year hour:munite:second (MM/DD/YYYY hh:mm:ss).')
hh3cDhcpServer2ConflictRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 12, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2ConflictRowStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2ConflictRowStatus.setDescription('RowStatus. Only destroy action is allow to use.')
hh3cDhcpServer2ExpiredTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 13), )
if mibBuilder.loadTexts: hh3cDhcpServer2ExpiredTable.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2ExpiredTable.setDescription('A table for displaying the information of expired IP for DHCP Server pools. ')
hh3cDhcpServer2ExpiredEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 13, 1), ).setIndexNames((0, "HH3C-DHCP4-MIB", "hh3cDhcpServer2PoolIndex"), (0, "HH3C-DHCP4-MIB", "hh3cDhcpServer2ExpiredIP"))
if mibBuilder.loadTexts: hh3cDhcpServer2ExpiredEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2ExpiredEntry.setDescription('An entry of objects for displaying information of expired IP for DHCP server pools.')
hh3cDhcpServer2ExpiredIP = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 13, 1, 1), InetAddressIPv4())
if mibBuilder.loadTexts: hh3cDhcpServer2ExpiredIP.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2ExpiredIP.setDescription('Expired IP address.')
hh3cDhcpServer2ExpiredClientId = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 13, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 254))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDhcpServer2ExpiredClientId.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2ExpiredClientId.setDescription('Client identifier or hardware address.')
hh3cDhcpServer2ExpiredTime = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 13, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 19))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDhcpServer2ExpiredTime.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2ExpiredTime.setDescription('Expired time. The structure of the OCTET STRING is month/day/year hour:munite:second (MM/DD/YYYY hh:mm:ss).')
hh3cDhcpServer2ExpiredRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 13, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2ExpiredRowStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2ExpiredRowStatus.setDescription('RowStatus. Only destroy action is allow to use.')
hh3cDhcpServer2IPInUseTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 14), )
if mibBuilder.loadTexts: hh3cDhcpServer2IPInUseTable.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2IPInUseTable.setDescription('A table for displaying the information of IP in use for DHCP Server pools. ')
hh3cDhcpServer2IPInUseEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 14, 1), ).setIndexNames((0, "HH3C-DHCP4-MIB", "hh3cDhcpServer2PoolIndex"), (0, "HH3C-DHCP4-MIB", "hh3cDhcpServer2IPInUseIP"))
if mibBuilder.loadTexts: hh3cDhcpServer2IPInUseEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2IPInUseEntry.setDescription('An entry of objects for displaying information of IP in use for DHCP server pools.')
hh3cDhcpServer2IPInUseIP = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 14, 1, 1), InetAddressIPv4())
if mibBuilder.loadTexts: hh3cDhcpServer2IPInUseIP.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2IPInUseIP.setDescription('Ip address in use.')
hh3cDhcpServer2IPInUseClientId = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 14, 1, 2), OctetString().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(4, 254), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDhcpServer2IPInUseClientId.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2IPInUseClientId.setDescription('Client identifier.')
hh3cDhcpServer2IPInUseHardAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 14, 1, 3), OctetString().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(4, 39), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDhcpServer2IPInUseHardAddr.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2IPInUseHardAddr.setDescription('Hardware address.')
hh3cDhcpServer2IPInUseHardType = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 14, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("default", 1), ("ethernet", 2), ("tokenRing", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDhcpServer2IPInUseHardType.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2IPInUseHardType.setDescription('Hardware address type.')
hh3cDhcpServer2IPInUseVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 14, 1, 5), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(1, 4094), ValueRangeConstraint(65535, 65535), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDhcpServer2IPInUseVlanId.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2IPInUseVlanId.setDescription("User's VLAN ID. 65535 means that a client doesn't have VLAN ID or have an invalid VLAN ID.")
hh3cDhcpServer2IPInUseEndLease = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 14, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 19))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDhcpServer2IPInUseEndLease.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2IPInUseEndLease.setDescription('End time of lease. The structure of the OCTET STRING is month/day/year hour:munite:second (MM/DD/YYYY hh:mm:ss).')
hh3cDhcpServer2IPInUseType = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 14, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("staticUnallocated", 1), ("staticOffered", 2), ("staticCommitted", 3), ("autoOffered", 4), ("autoCommitted", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDhcpServer2IPInUseType.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2IPInUseType.setDescription('Type of binding.')
hh3cDhcpServer2IPInUseIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 14, 1, 8), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDhcpServer2IPInUseIfIndex.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2IPInUseIfIndex.setDescription('Interface index information. If the value of this object is zero, the interface is unknown.')
hh3cDhcpServer2IPInUseRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 14, 1, 9), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2IPInUseRowStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2IPInUseRowStatus.setDescription('RowStatus. Only destroy action is allow to use.')
hh3cDhcpServer2DefOptGrpTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 15), )
if mibBuilder.loadTexts: hh3cDhcpServer2DefOptGrpTable.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2DefOptGrpTable.setDescription('A table containing option group of the DHCP server pool for user classes.')
hh3cDhcpServer2DefOptGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 15, 1), ).setIndexNames((0, "HH3C-DHCP4-MIB", "hh3cDhcpServer2PoolIndex"), (0, "HH3C-DHCP4-MIB", "hh3cDhcpServer2DefOptGrpClass"))
if mibBuilder.loadTexts: hh3cDhcpServer2DefOptGrpEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2DefOptGrpEntry.setDescription('An entry containing option group of DHCP pools for user classes.')
hh3cDhcpServer2DefOptGrpClass = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 15, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 63)))
if mibBuilder.loadTexts: hh3cDhcpServer2DefOptGrpClass.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2DefOptGrpClass.setDescription('User class name.')
hh3cDhcpServer2DefOptGrpId = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 15, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32768))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2DefOptGrpId.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2DefOptGrpId.setDescription('The option group ID.')
hh3cDhcpServer2DefOptGrpStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 15, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2DefOptGrpStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2DefOptGrpStatus.setDescription("RowStatus. Three actions are used: active, createAndGo, destroy. If the value of this object is set to 'createAndGo', hh3cDhcpServer2DefOptGrpId must also be set.")
hh3cDhcpServer2ValidClassTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 16), )
if mibBuilder.loadTexts: hh3cDhcpServer2ValidClassTable.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2ValidClassTable.setDescription('A table containing valid user classes for DHCP server pool.')
hh3cDhcpServer2ValidClassEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 16, 1), ).setIndexNames((0, "HH3C-DHCP4-MIB", "hh3cDhcpServer2PoolIndex"), (0, "HH3C-DHCP4-MIB", "hh3cDhcpServer2ValidClassName"))
if mibBuilder.loadTexts: hh3cDhcpServer2ValidClassEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2ValidClassEntry.setDescription('An entry containing valid user classes for DHCP server pool.')
hh3cDhcpServer2ValidClassName = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 16, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 63)))
if mibBuilder.loadTexts: hh3cDhcpServer2ValidClassName.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2ValidClassName.setDescription('User class name.')
hh3cDhcpServer2ValidClassStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 16, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2ValidClassStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2ValidClassStatus.setDescription('RowStatus. Three actions are used: active, createAndGo, destroy.')
hh3cDhcpServer2RuleHwAddrTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 17), )
if mibBuilder.loadTexts: hh3cDhcpServer2RuleHwAddrTable.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2RuleHwAddrTable.setDescription('A table for configuring hardware address rules used to match DHCP users.')
hh3cDhcpServer2RuleHwAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 17, 1), ).setIndexNames((0, "HH3C-DHCP4-MIB", "hh3cDhcpServer2ClassName"), (0, "HH3C-DHCP4-MIB", "hh3cDhcpServer2RuleHwAddrNumber"))
if mibBuilder.loadTexts: hh3cDhcpServer2RuleHwAddrEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2RuleHwAddrEntry.setDescription('An entry for configuring hardware address rules used to match DHCP users.')
hh3cDhcpServer2RuleHwAddrNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 17, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)))
if mibBuilder.loadTexts: hh3cDhcpServer2RuleHwAddrNumber.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2RuleHwAddrNumber.setDescription('Rule number.')
hh3cDhcpServer2RuleHwAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 17, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 39))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2RuleHwAddress.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2RuleHwAddress.setDescription('Hardware address for a rule. The structure of the OCTET STRING is H-H-H... while H indicates 4 hexadecimal characters except that the last H indicates 2 or 4 hexadecimal characters. The SET operation to this object ought to be with the SET operation of hh3cDhcpServer2RuleHwAddrMask together, and any SET operation alone to this object will be regarded as an invalid operation.')
hh3cDhcpServer2RuleHwAddrMask = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 17, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 39))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2RuleHwAddrMask.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2RuleHwAddrMask.setDescription('Mask of hardware address for a rule. The structure of the OCTET STRING is the same with hh3cDhcpServer2RuleHwAddress. The SET operation to this object ought to be with the SET operation of hh3cDhcpServer2RuleHwAddress together, and any SET operation alone to this object will be regarded as an invalid operation.')
hh3cDhcpServer2RuleHwAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 17, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2RuleHwAddrType.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2RuleHwAddrType.setDescription('Hardware type for a rule. The codes of all hardware types see ARP section in RFC 1700. The SET operation alone to this object will be regarded as an invalid operation.')
hh3cDhcpServer2RuleHwAddrStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 17, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2RuleHwAddrStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2RuleHwAddrStatus.setDescription("RowStatus. Three actions are used: active, createAndGo, destroy. If the value of this object is set to 'createAndGo', hh3cDhcpServer2RuleHwAddrAddress and hh3cDhcpServer2RuleHwAddrMask must also be set.")
hh3cDhcpServer2OptionGroupTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 18), )
if mibBuilder.loadTexts: hh3cDhcpServer2OptionGroupTable.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2OptionGroupTable.setDescription('A table for creating DHCP server option groups.')
hh3cDhcpServer2OptionGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 18, 1), ).setIndexNames((0, "HH3C-DHCP4-MIB", "hh3cDhcpServer2OptionGroupId"))
if mibBuilder.loadTexts: hh3cDhcpServer2OptionGroupEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2OptionGroupEntry.setDescription('An entry containing objects for creating or deleting an option group.')
hh3cDhcpServer2OptionGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 18, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32768)))
if mibBuilder.loadTexts: hh3cDhcpServer2OptionGroupId.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2OptionGroupId.setDescription('The option group ID.')
hh3cDhcpServer2OptionGroupStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 18, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2OptionGroupStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2OptionGroupStatus.setDescription('RowStatus. Three actions are used: active, createAndGo, destroy.')
hh3cDhcpServer2OptionTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 19), )
if mibBuilder.loadTexts: hh3cDhcpServer2OptionTable.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2OptionTable.setDescription('A table for configuring options in an option group.')
hh3cDhcpServer2OptionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 19, 1), ).setIndexNames((0, "HH3C-DHCP4-MIB", "hh3cDhcpServer2OptionGroupId"), (0, "HH3C-DHCP4-MIB", "hh3cDhcpServer2OptionCode"))
if mibBuilder.loadTexts: hh3cDhcpServer2OptionEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2OptionEntry.setDescription('An entry containing objects for configuring an option in an option group.')
hh3cDhcpServer2OptionCode = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 19, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 254)))
if mibBuilder.loadTexts: hh3cDhcpServer2OptionCode.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2OptionCode.setDescription('Option code.')
hh3cDhcpServer2OptionType = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 19, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ascii", 1), ("hex", 2), ("ip", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2OptionType.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2OptionType.setDescription("Option type. 'ascii' means using the ascii string that is defined by hh3cDhcpServer2OptionAscii to fill in the option. 'hex' means using the hex string that is defined by hh3cDhcpServer2OptionHexStr to fill in the option. 'ip' means using the IP string that is defined by hh3cDhcpServer2OptionIPStr to fill in the option.")
hh3cDhcpServer2OptionAscii = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 19, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2OptionAscii.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2OptionAscii.setDescription("Ascii string of an option. If hh3cDhcpServer2OptionType is set with 'ascii', this object must be set with a non-zero length string.")
hh3cDhcpServer2OptionHexStr = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 19, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 510))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2OptionHexStr.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2OptionHexStr.setDescription("Hex string of an option. The length of the string must be even. If hh3cDhcpServer2OptionType is set with 'hex', this object must be set with a non-zero length string.")
hh3cDhcpServer2OptionIPStr = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 19, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 127))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2OptionIPStr.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2OptionIPStr.setDescription("IP string of an option. IP addresses are space separated and the leading or trailing space will be trimmed. 1 to 8 IP addresses can be configured simultaneously. If hh3cDhcpServer2OptionType is set with 'ip', this object must be set with a non-zero length string that must contain at least one IP address.")
hh3cDhcpServer2OptionRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 2, 19, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpServer2OptionRowStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpServer2OptionRowStatus.setDescription("RowStatus. Three actions are used: active, createAndGo, destroy. If the value of this object is set to 'createAndGo', hh3cDhcpServer2OptionType must also be set.")
hh3cDhcpRelay2ScalarObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 122, 3))
hh3cDhcpRelay2ConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 122, 3, 1))
hh3cDhcpRelay2UserInfoRecord = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 122, 3, 1, 1), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDhcpRelay2UserInfoRecord.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpRelay2UserInfoRecord.setDescription("If the value is 'true', user information will be recorded.")
hh3cDhcpRelay2UserInfoRefresh = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 122, 3, 1, 2), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDhcpRelay2UserInfoRefresh.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpRelay2UserInfoRefresh.setDescription("If the value is 'true', user information will be refreshed on timer.")
hh3cDhcpRelay2UserInfoFlushTime = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 122, 3, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 120))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDhcpRelay2UserInfoFlushTime.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpRelay2UserInfoFlushTime.setDescription('User information refresh interval in seconds. If the value of the object is set to 0, the interval is calculated automatically by the number of user information entries.')
hh3cDhcpRelay2ReleaseAddr = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 122, 3, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 47))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDhcpRelay2ReleaseAddr.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpRelay2ReleaseAddr.setDescription('User address to be released. The structure of the OCTET STRING is IP address:VPN name. If the VPN instance name is NOT specified, the IP address is in public network.')
hh3cDhcpRelay2StatisticsGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 122, 3, 2))
hh3cDhcpRelay2RxClientNum = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 122, 3, 2, 1), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDhcpRelay2RxClientNum.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpRelay2RxClientNum.setDescription('The total number of the packets received from DHCP clients by DHCP relay.')
hh3cDhcpRelay2TxClientNum = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 122, 3, 2, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDhcpRelay2TxClientNum.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpRelay2TxClientNum.setDescription('The total number of the packets transmitted to DHCP clients by DHCP relay.')
hh3cDhcpRelay2RxServerNum = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 122, 3, 2, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDhcpRelay2RxServerNum.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpRelay2RxServerNum.setDescription('The total number of the packets received from DHCP Servers by DHCP relay.')
hh3cDhcpRelay2TxServerNum = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 122, 3, 2, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDhcpRelay2TxServerNum.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpRelay2TxServerNum.setDescription('The total number of the packets transmitted to DHCP Servers by DHCP relay.')
hh3cDhcpRelay2BadNum = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 122, 3, 2, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDhcpRelay2BadNum.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpRelay2BadNum.setDescription('The total number of the bad packets received.')
hh3cDhcpRelay2BootpRequestNum = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 122, 3, 2, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDhcpRelay2BootpRequestNum.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpRelay2BootpRequestNum.setDescription('The total number of the BOOTREQUEST packets handled by DHCP relay.')
hh3cDhcpRelay2DiscoverNum = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 122, 3, 2, 7), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDhcpRelay2DiscoverNum.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpRelay2DiscoverNum.setDescription('The total number of the DHCPDISCOVER packets handled by DHCP relay.')
hh3cDhcpRelay2RequestNum = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 122, 3, 2, 8), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDhcpRelay2RequestNum.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpRelay2RequestNum.setDescription('The total number of the DHCPREQUEST packets handled by DHCP relay.')
hh3cDhcpRelay2DeclineNum = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 122, 3, 2, 9), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDhcpRelay2DeclineNum.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpRelay2DeclineNum.setDescription('The total number of the DHCPDECLINE packets handled by DHCP relay.')
hh3cDhcpRelay2ReleaseNum = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 122, 3, 2, 10), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDhcpRelay2ReleaseNum.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpRelay2ReleaseNum.setDescription('The total number of the DHCPRELEASE packets handled by DHCP relay.')
hh3cDhcpRelay2InformNum = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 122, 3, 2, 11), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDhcpRelay2InformNum.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpRelay2InformNum.setDescription('The total number of the DHCPINFORM packets handled by DHCP relay.')
hh3cDhcpRelay2BootpReplyNum = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 122, 3, 2, 12), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDhcpRelay2BootpReplyNum.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpRelay2BootpReplyNum.setDescription('The total number of the BOOTREPLY packets handled by DHCP relay.')
hh3cDhcpRelay2OfferNum = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 122, 3, 2, 13), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDhcpRelay2OfferNum.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpRelay2OfferNum.setDescription('The total number of the DHCPOFFER packets handled by DHCP relay.')
hh3cDhcpRelay2AckNum = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 122, 3, 2, 14), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDhcpRelay2AckNum.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpRelay2AckNum.setDescription('The total number of the DHCPACK packets handled by DHCP relay.')
hh3cDhcpRelay2NakNum = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 122, 3, 2, 15), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDhcpRelay2NakNum.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpRelay2NakNum.setDescription('The total number of the DHCPNAK packets handled by DHCP relay.')
hh3cDhcpRelay2Tables = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 122, 4))
hh3cDhcpRelay2IfConfigTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 122, 4, 1), )
if mibBuilder.loadTexts: hh3cDhcpRelay2IfConfigTable.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpRelay2IfConfigTable.setDescription('A table for configuring relay functions for interfaces.')
hh3cDhcpRelay2IfConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 122, 4, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: hh3cDhcpRelay2IfConfigEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpRelay2IfConfigEntry.setDescription('An entry for configuring relay functions for an interface.')
hh3cDhcpRelay2IfSelectRelay = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 4, 1, 1, 1), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDhcpRelay2IfSelectRelay.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpRelay2IfSelectRelay.setDescription("If the value is 'true', the DHCP relay function would be enabled on this interface.")
hh3cDhcpRelay2IfCheckMac = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 4, 1, 1, 2), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDhcpRelay2IfCheckMac.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpRelay2IfCheckMac.setDescription("If the value is 'true', the function of checking MAC address of packets received from the interface would be enabled.")
hh3cDhcpRelay2IfOpt82Enable = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 4, 1, 1, 3), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDhcpRelay2IfOpt82Enable.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpRelay2IfOpt82Enable.setDescription("If DHCP relay supports option 82 functions, the value is 'true'. If DHCP relay does NOT support option 82 functions, the value is 'false'.")
hh3cDhcpRelay2IfOpt82Strategy = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("drop", 1), ("keep", 2), ("replace", 3))).clone('replace')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDhcpRelay2IfOpt82Strategy.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpRelay2IfOpt82Strategy.setDescription("The strategies of DHCP relay handling option 82. 'drop' indicates DHCP relay discarding the request packet including option 82. 'keep' indicates DHCP relay accepting the request packet without any change of the option 82. 'replace' indicates DHCP relay accepting the request packet on condition that it generates a new option 82 to replace the original one.")
hh3cDhcpRelay2IfOpt82CIDMode = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("normal", 1), ("verbose", 2), ("userDefine", 3))).clone('normal')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDhcpRelay2IfOpt82CIDMode.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpRelay2IfOpt82CIDMode.setDescription("The mode of the circuit ID suboption of DHCP option 82. 'normal' is the standard mode. 'verbose' is the detailed mode. 'userDefine' is the user-defined mode. If the value of this object is set to 'userDefine', hh3cDhcpRelay2IfOpt82CIDStr must also be set.")
hh3cDhcpRelay2IfOpt82CIDNodeType = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 4, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("invalid", 1), ("mac", 2), ("sysname", 3), ("userDefine", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDhcpRelay2IfOpt82CIDNodeType.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpRelay2IfOpt82CIDNodeType.setDescription("Type of access node identifier that is used to fill in the circuit ID suboption of option 82 when the value of hh3cDhcpRelay2IfOpt82CIDMode is set to 'verbose'. The SET operation of this object must be with the SET operation of hh3cDhcpRelay2IfOpt82CIDMode. 'invalid' indicates that the node identifier is NOT used to fill in the circuit ID suboption of option 82. If the value of hh3cDhcpRelay2IfOpt82CIDMode is NOT 'verbose', the value of this object is set to 'invalid' automatically. Otherwise the value of this object cannot be set to 'invalid'. 'mac' indicates that the node identifier is filled in with the MAC of DHCP relay input interface. If the value of hh3cDhcpRelay2IfOpt82CIDMode is set to 'verbose', the default value of this object is 'mac'. 'sysname' indicates that the node identifier is filled in with the sysname of the DHCP relay device. 'userDefine' indicates that the node identifier is filled in with the string defined by the object of hh3cDhcpRelay2IfOpt82CIDNodeStr. If the value is set to 'userDefine', the value of hh3cDhcpRelay2IfOpt82CIDNodeStr must be set to a non-zero length string simultaneously.")
hh3cDhcpRelay2IfOpt82CIDNodeStr = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 4, 1, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 50))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDhcpRelay2IfOpt82CIDNodeStr.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpRelay2IfOpt82CIDNodeStr.setDescription("The string defined by user to fill in the node identifier in the verbose mode. If the value of hh3cDhcpRelay2IfOpt82CIDMode is NOT 'verbose', or the value of hh3cDhcpRelay2IfOpt82CIDNodeType is NOT 'userDefine', it is set with a zero-length string automatically. Otherwise it must be set with a non-zero length string. The SET operation of this object must be with the SET operation of hh3cDhcpRelay2IfOpt82CIDMode and hh3cDhcpRelay2IfOpt82CIDNodeType.")
hh3cDhcpRelay2IfOpt82CIDStr = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 4, 1, 1, 8), OctetString().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(3, 63), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDhcpRelay2IfOpt82CIDStr.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpRelay2IfOpt82CIDStr.setDescription("The string defined by user to fill in the circuit ID suboption of option 82 in the user-define mode. If the value of hh3cDhcpRelay2IfOpt82CIDMode is NOT 'userDefine', it is set to a zero-length string automatically. Otherwise it must be set with a non-zero length string. The SET operation of this object must be with the SET operation of hh3cDhcpRelay2IfOpt82CIDMode.")
hh3cDhcpRelay2IfOpt82CIDFormat = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 4, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("hex", 1), ("ascii", 2), ("undefine", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDhcpRelay2IfOpt82CIDFormat.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpRelay2IfOpt82CIDFormat.setDescription("The format of the circuit ID suboption of DHCP option 82. 'hex' is the hex format. 'ascii' is the ascii format. 'undefine' is the undefine format. If the value of hh3cDhcpRelay2IfOpt82CIDMode is 'normal', the value of this object is set to 'hex' automatically and cannot be set to 'undefine'. If the value of hh3cDhcpRelay2IfOpt82CIDMode is 'verbose', the default value of this object is 'undefine'. If the value of hh3cDhcpRelay2IfOpt82CIDMode is 'userDefine', the value of this object is set to 'ascii' automatically and cannot be set to other value. The SET operation of this object must be with the SET operation of hh3cDhcpRelay2IfOpt82CIDMode.")
hh3cDhcpRelay2IfOpt82RIDMode = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 4, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("normal", 1), ("sysname", 2), ("userDefine", 3))).clone('normal')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDhcpRelay2IfOpt82RIDMode.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpRelay2IfOpt82RIDMode.setDescription("The mode of the remote ID suboption of DHCP option 82. 'normal' is the standard mode. 'sysname' is the sysname mode. 'userDefine' is the user-defined mode. If the value of this object is set to 'userDefine', hh3cDhcpRelay2IfOpt82RIDStr must also be set.")
hh3cDhcpRelay2IfOpt82RIDStr = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 4, 1, 1, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDhcpRelay2IfOpt82RIDStr.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpRelay2IfOpt82RIDStr.setDescription("The string defined by user to fill in the remote ID in the user-defined mode. If the value of hh3cDhcpRelay2IfOpt82RIDMode is NOT 'userDefine', it is set to a zero-length string automatically. Otherwise it must be set with a non-zero length string. The SET operation of this object must be with the SET operation of hh3cDhcpRelay2IfOpt82RIDMode.")
hh3cDhcpRelay2IfOpt82RIDFormat = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 4, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("hex", 1), ("ascii", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDhcpRelay2IfOpt82RIDFormat.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpRelay2IfOpt82RIDFormat.setDescription("The format of the remote ID suboption of DHCP option 82. 'hex' is the hex format. 'ascii' is the ascii format. If the value of hh3cDhcpRelay2IfOpt82RIDMode is 'sysname' or 'userDefine', this object is set with 'ascii' automatically and cannot be set with other value. If the value of hh3cDhcpRelay2IfOpt82RIDMode is 'normal', the default value of this object is 'hex'. The SET operation of this object must be with the SET operation of hh3cDhcpRelay2IfOpt82RIDMode.")
hh3cDhcpRelay2SrvAddrTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 122, 4, 2), )
if mibBuilder.loadTexts: hh3cDhcpRelay2SrvAddrTable.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpRelay2SrvAddrTable.setDescription('A table for configuring a DHCP server address on the interface.')
hh3cDhcpRelay2SrvAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 122, 4, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "HH3C-DHCP4-MIB", "hh3cDhcpRelay2SrvAddrIP"))
if mibBuilder.loadTexts: hh3cDhcpRelay2SrvAddrEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpRelay2SrvAddrEntry.setDescription('An entry for configuring a DHCP server address on the interface.')
hh3cDhcpRelay2SrvAddrIP = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 4, 2, 1, 1), InetAddressIPv4())
if mibBuilder.loadTexts: hh3cDhcpRelay2SrvAddrIP.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpRelay2SrvAddrIP.setDescription('Ip address of DHCP server.')
hh3cDhcpRelay2SrvAddrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 4, 2, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpRelay2SrvAddrRowStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpRelay2SrvAddrRowStatus.setDescription('Operation status of this table entry. Three actions are used: active, createAndGo, destroy.')
hh3cDhcpRelay2UserInfoTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 122, 4, 3), )
if mibBuilder.loadTexts: hh3cDhcpRelay2UserInfoTable.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpRelay2UserInfoTable.setDescription('A table containing the user information of DHCP client.')
hh3cDhcpRelay2UserInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 122, 4, 3, 1), ).setIndexNames((0, "HH3C-DHCP4-MIB", "hh3cDhcpRelay2UserInfoVpnIndex"), (0, "HH3C-DHCP4-MIB", "hh3cDhcpRelay2UserInfoIpAddr"))
if mibBuilder.loadTexts: hh3cDhcpRelay2UserInfoEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpRelay2UserInfoEntry.setDescription('An entry containing the user information of DHCP client.')
hh3cDhcpRelay2UserInfoVpnIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 4, 3, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65534)))
if mibBuilder.loadTexts: hh3cDhcpRelay2UserInfoVpnIndex.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpRelay2UserInfoVpnIndex.setDescription('VPN index of the DHCP client.')
hh3cDhcpRelay2UserInfoIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 4, 3, 1, 2), InetAddressIPv4())
if mibBuilder.loadTexts: hh3cDhcpRelay2UserInfoIpAddr.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpRelay2UserInfoIpAddr.setDescription("DHCP client's IP address.")
hh3cDhcpRelay2UserInfoMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 4, 3, 1, 3), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDhcpRelay2UserInfoMacAddr.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpRelay2UserInfoMacAddr.setDescription("DHCP client's MAC address.")
hh3cDhcpRelay2UserInfoIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 4, 3, 1, 4), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDhcpRelay2UserInfoIfIndex.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpRelay2UserInfoIfIndex.setDescription('The index of the interface that DHCP client adhered to. 0 means that no interface information is recorded in the user information entry.')
hh3cDhcpRelay2UserInfoRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 122, 4, 3, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpRelay2UserInfoRowStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpRelay2UserInfoRowStatus.setDescription('Operation status of this table entry. Only destroy action is allow to use.')
mibBuilder.exportSymbols("HH3C-DHCP4-MIB", hh3cDhcpServer2AlwaysBroadcast=hh3cDhcpServer2AlwaysBroadcast, hh3cDhcpServer2BootpReplyRfc1048=hh3cDhcpServer2BootpReplyRfc1048, hh3cDhcpServer2RuleRowStatus=hh3cDhcpServer2RuleRowStatus, hh3cDhcpServer2PoolVoiceFailIP=hh3cDhcpServer2PoolVoiceFailIP, hh3cDhcpServer2IPInUseType=hh3cDhcpServer2IPInUseType, hh3cDhcpRelay2IfOpt82RIDMode=hh3cDhcpRelay2IfOpt82RIDMode, hh3cDhcpServer2PoolClassTable=hh3cDhcpServer2PoolClassTable, hh3cDhcpServer2ForbidEntry=hh3cDhcpServer2ForbidEntry, hh3cDhcpRelay2ReleaseAddr=hh3cDhcpRelay2ReleaseAddr, hh3cDhcpServer2PoolLeaseTime=hh3cDhcpServer2PoolLeaseTime, hh3cDhcpServer2PoolBootFileName=hh3cDhcpServer2PoolBootFileName, hh3cDhcpServer2PoolForbidIP=hh3cDhcpServer2PoolForbidIP, hh3cDhcpRelay2ScalarObjects=hh3cDhcpRelay2ScalarObjects, hh3cDhcpServer2PoolPrimaryDNSIP=hh3cDhcpServer2PoolPrimaryDNSIP, hh3cDhcpServer2ClassTable=hh3cDhcpServer2ClassTable, hh3cDhcpServer2ValidClassStatus=hh3cDhcpServer2ValidClassStatus, hh3cDhcpServer2ManualBindNum=hh3cDhcpServer2ManualBindNum, hh3cDhcpServer2FreeTable=hh3cDhcpServer2FreeTable, hh3cDhcpServer2PoolEndAddr=hh3cDhcpServer2PoolEndAddr, hh3cDhcpServer2PoolName=hh3cDhcpServer2PoolName, hh3cDhcpServer2Enabled=hh3cDhcpServer2Enabled, hh3cDhcpServer2BootpReplyNum=hh3cDhcpServer2BootpReplyNum, hh3cDhcpServer2AckNum=hh3cDhcpServer2AckNum, hh3cDhcpServer2PoolStaticTable=hh3cDhcpServer2PoolStaticTable, hh3cDhcpServer2ForbidRowStatus=hh3cDhcpServer2ForbidRowStatus, hh3cDhcpServer2DefOptGrpEntry=hh3cDhcpServer2DefOptGrpEntry, hh3cDhcpRelay2UserInfoFlushTime=hh3cDhcpRelay2UserInfoFlushTime, hh3cDhcpRelay2BootpReplyNum=hh3cDhcpRelay2BootpReplyNum, hh3cDhcpRelay2InformNum=hh3cDhcpRelay2InformNum, hh3cDhcpServer2IPInUseIfIndex=hh3cDhcpServer2IPInUseIfIndex, hh3cDhcpServer2PoolOptCode=hh3cDhcpServer2PoolOptCode, hh3cDhcpServer2PoolDomainName=hh3cDhcpServer2PoolDomainName, hh3cDhcpRelay2IfConfigTable=hh3cDhcpRelay2IfConfigTable, hh3cDhcpServer2PoolStaticIP=hh3cDhcpServer2PoolStaticIP, hh3cDhcpServer2RuleOptLength=hh3cDhcpServer2RuleOptLength, hh3cDhcpRelay2IfOpt82CIDStr=hh3cDhcpRelay2IfOpt82CIDStr, hh3cDhcpRelay2BootpRequestNum=hh3cDhcpRelay2BootpRequestNum, hh3cDhcp4=hh3cDhcp4, hh3cDhcpServer2TotalPoolUsage=hh3cDhcpServer2TotalPoolUsage, hh3cDhcpServer2OptionCode=hh3cDhcpServer2OptionCode, hh3cDhcpServer2DefOptGrpStatus=hh3cDhcpServer2DefOptGrpStatus, hh3cDhcpServer2IPInUseVlanId=hh3cDhcpServer2IPInUseVlanId, hh3cDhcpServer2RuleHwAddrEntry=hh3cDhcpServer2RuleHwAddrEntry, hh3cDhcpServer2RuleNumber=hh3cDhcpServer2RuleNumber, hh3cDhcpServer2PoolLeaseSecond=hh3cDhcpServer2PoolLeaseSecond, hh3cDhcpServer2ValidClassTable=hh3cDhcpServer2ValidClassTable, hh3cDhcpRelay2ConfigGroup=hh3cDhcpRelay2ConfigGroup, hh3cDhcpRelay2RxClientNum=hh3cDhcpRelay2RxClientNum, hh3cDhcpServer2RuleOptMask=hh3cDhcpServer2RuleOptMask, hh3cDhcpServer2PoolForbidEntry=hh3cDhcpServer2PoolForbidEntry, hh3cDhcpRelay2TxServerNum=hh3cDhcpRelay2TxServerNum, hh3cDhcpRelay2UserInfoMacAddr=hh3cDhcpRelay2UserInfoMacAddr, hh3cDhcpServer2IPInUseClientId=hh3cDhcpServer2IPInUseClientId, hh3cDhcpServer2PoolLeaseDay=hh3cDhcpServer2PoolLeaseDay, hh3cDhcpServer2PoolSecNwStatus=hh3cDhcpServer2PoolSecNwStatus, hh3cDhcpServer2PoolVoiceVlanId=hh3cDhcpServer2PoolVoiceVlanId, hh3cDhcpServer2IfApplyPoolEntry=hh3cDhcpServer2IfApplyPoolEntry, hh3cDhcpServer2ExpiredRowStatus=hh3cDhcpServer2ExpiredRowStatus, hh3cDhcpServer2PoolTable=hh3cDhcpServer2PoolTable, hh3cDhcpServer2ConflictEntry=hh3cDhcpServer2ConflictEntry, hh3cDhcpServer2OptionType=hh3cDhcpServer2OptionType, hh3cDhcpServer2ExpiredTable=hh3cDhcpServer2ExpiredTable, hh3cDhcpServer2RuleOptOffset=hh3cDhcpServer2RuleOptOffset, hh3cDhcpServer2PoolBimsIP=hh3cDhcpServer2PoolBimsIP, hh3cDhcpServer2PoolEntry=hh3cDhcpServer2PoolEntry, hh3cDhcpServer2IPInUseHardType=hh3cDhcpServer2IPInUseHardType, hh3cDhcpServer2ExpiredBindNum=hh3cDhcpServer2ExpiredBindNum, hh3cDhcpServer2OptionGroupEntry=hh3cDhcpServer2OptionGroupEntry, hh3cDhcpRelay2IfOpt82CIDNodeStr=hh3cDhcpRelay2IfOpt82CIDNodeStr, hh3cDhcpServer2PoolOptType=hh3cDhcpServer2PoolOptType, hh3cDhcpServer2PoolLeaseMinute=hh3cDhcpServer2PoolLeaseMinute, hh3cDhcpServer2ConflictTable=hh3cDhcpServer2ConflictTable, hh3cDhcpServer2PoolVoiceAsIP=hh3cDhcpServer2PoolVoiceAsIP, hh3cDhcpServer2IfApplyPoolTable=hh3cDhcpServer2IfApplyPoolTable, hh3cDhcpRelay2UserInfoVpnIndex=hh3cDhcpRelay2UserInfoVpnIndex, hh3cDhcpServer2PoolSecNwEntry=hh3cDhcpServer2PoolSecNwEntry, hh3cDhcpServer2ForbidEnd=hh3cDhcpServer2ForbidEnd, hh3cDhcpServer2ForbidStart=hh3cDhcpServer2ForbidStart, hh3cDhcpServer2PoolStaticEntry=hh3cDhcpServer2PoolStaticEntry, hh3cDhcpServer2PingTimeout=hh3cDhcpServer2PingTimeout, hh3cDhcpServer2PoolStartAddr=hh3cDhcpServer2PoolStartAddr, hh3cDhcpServer2ClassRowStatus=hh3cDhcpServer2ClassRowStatus, PYSNMP_MODULE_ID=hh3cDhcp4, hh3cDhcpRelay2UserInfoIpAddr=hh3cDhcpRelay2UserInfoIpAddr, hh3cDhcpServer2RuleHwAddrMask=hh3cDhcpServer2RuleHwAddrMask, hh3cDhcpRelay2UserInfoRowStatus=hh3cDhcpRelay2UserInfoRowStatus, hh3cDhcpServer2DeclineNum=hh3cDhcpServer2DeclineNum, hh3cDhcpRelay2IfOpt82Enable=hh3cDhcpRelay2IfOpt82Enable, hh3cDhcpServer2OptionIPStr=hh3cDhcpServer2OptionIPStr, hh3cDhcpServer2ExpiredTime=hh3cDhcpServer2ExpiredTime, hh3cDhcpRelay2IfOpt82CIDMode=hh3cDhcpRelay2IfOpt82CIDMode, hh3cDhcpServer2PoolGatewayIP=hh3cDhcpServer2PoolGatewayIP, hh3cDhcpServer2PoolStaticCID=hh3cDhcpServer2PoolStaticCID, hh3cDhcpServer2IPInUseRowStatus=hh3cDhcpServer2IPInUseRowStatus, hh3cDhcpRelay2IfOpt82CIDNodeType=hh3cDhcpRelay2IfOpt82CIDNodeType, hh3cDhcpServer2PoolOptIPStr=hh3cDhcpServer2PoolOptIPStr, hh3cDhcpServer2PoolClassName=hh3cDhcpServer2PoolClassName, hh3cDhcpServer2PoolOptHexStr=hh3cDhcpServer2PoolOptHexStr, hh3cDhcpServer2Opt82Enabled=hh3cDhcpServer2Opt82Enabled, hh3cDhcpServer2PoolOptionEntry=hh3cDhcpServer2PoolOptionEntry, hh3cDhcpRelay2IfOpt82RIDFormat=hh3cDhcpRelay2IfOpt82RIDFormat, hh3cDhcpServer2PoolVoiceVlanEnbl=hh3cDhcpServer2PoolVoiceVlanEnbl, hh3cDhcpServer2ScalarObjects=hh3cDhcpServer2ScalarObjects, hh3cDhcpServer2IPInUseHardAddr=hh3cDhcpServer2IPInUseHardAddr, hh3cDhcpRelay2SrvAddrRowStatus=hh3cDhcpRelay2SrvAddrRowStatus, hh3cDhcpServer2InformNum=hh3cDhcpServer2InformNum, hh3cDhcpServer2ValidClassEntry=hh3cDhcpServer2ValidClassEntry, hh3cDhcpRelay2StatisticsGroup=hh3cDhcpRelay2StatisticsGroup, hh3cDhcpServer2PoolClassStatus=hh3cDhcpServer2PoolClassStatus, hh3cDhcpServer2PoolRowStatus=hh3cDhcpServer2PoolRowStatus, hh3cDhcpServer2RuleEntry=hh3cDhcpServer2RuleEntry, hh3cDhcpServer2ConflictIP=hh3cDhcpServer2ConflictIP, hh3cDhcpRelay2SrvAddrTable=hh3cDhcpRelay2SrvAddrTable, hh3cDhcpServer2PoolClassEnd=hh3cDhcpServer2PoolClassEnd, hh3cDhcpServer2FreeStart=hh3cDhcpServer2FreeStart, hh3cDhcpServer2ValidClassName=hh3cDhcpServer2ValidClassName, hh3cDhcpServer2RuleHwAddrType=hh3cDhcpServer2RuleHwAddrType, hh3cDhcpServer2PoolVpnName=hh3cDhcpServer2PoolVpnName, hh3cDhcpServer2StatGroup=hh3cDhcpServer2StatGroup, hh3cDhcpServer2PoolVerifyClass=hh3cDhcpServer2PoolVerifyClass, hh3cDhcpServer2PoolBimsKeyStr=hh3cDhcpServer2PoolBimsKeyStr, hh3cDhcpServer2RuleOptCode=hh3cDhcpServer2RuleOptCode, hh3cDhcpRelay2NakNum=hh3cDhcpRelay2NakNum, hh3cDhcpServer2DefOptGrpClass=hh3cDhcpServer2DefOptGrpClass, hh3cDhcpRelay2RequestNum=hh3cDhcpRelay2RequestNum, hh3cDhcpServer2PoolNbnsIP=hh3cDhcpServer2PoolNbnsIP, hh3cDhcpServer2IPInUseIP=hh3cDhcpServer2IPInUseIP, hh3cDhcpServer2OptionHexStr=hh3cDhcpServer2OptionHexStr, hh3cDhcpServer2PoolStaticMask=hh3cDhcpServer2PoolStaticMask, hh3cDhcpServer2PoolSecNw=hh3cDhcpServer2PoolSecNw, hh3cDhcpServer2ClassName=hh3cDhcpServer2ClassName, hh3cDhcpServer2PoolClassEntry=hh3cDhcpServer2PoolClassEntry, hh3cDhcpServer2OptionGroupStatus=hh3cDhcpServer2OptionGroupStatus, hh3cDhcpRelay2RxServerNum=hh3cDhcpRelay2RxServerNum, hh3cDhcpServer2PoolDNSIP=hh3cDhcpServer2PoolDNSIP, hh3cDhcpServer2PoolLeaseUnlimit=hh3cDhcpServer2PoolLeaseUnlimit, hh3cDhcpServer2IfApplyPoolName=hh3cDhcpServer2IfApplyPoolName, hh3cDhcpServer2ClassEntry=hh3cDhcpServer2ClassEntry, hh3cDhcpServer2ExpiredClientId=hh3cDhcpServer2ExpiredClientId, hh3cDhcpServer2OptionRowStatus=hh3cDhcpServer2OptionRowStatus, hh3cDhcpServer2OptionTable=hh3cDhcpServer2OptionTable, hh3cDhcpRelay2DeclineNum=hh3cDhcpRelay2DeclineNum, hh3cDhcpRelay2AckNum=hh3cDhcpRelay2AckNum, hh3cDhcpServer2FreeEntry=hh3cDhcpServer2FreeEntry, hh3cDhcpServer2OptionAscii=hh3cDhcpServer2OptionAscii, hh3cDhcpRelay2IfCheckMac=hh3cDhcpRelay2IfCheckMac, hh3cDhcpServer2RuleHwAddrStatus=hh3cDhcpServer2RuleHwAddrStatus, hh3cDhcpServer2PoolVoiceFailStr=hh3cDhcpServer2PoolVoiceFailStr, hh3cDhcpRelay2DiscoverNum=hh3cDhcpRelay2DiscoverNum, hh3cDhcpServer2PoolOptionTable=hh3cDhcpServer2PoolOptionTable, hh3cDhcpServer2OptionGroupTable=hh3cDhcpServer2OptionGroupTable, hh3cDhcpServer2PoolSecNwMask=hh3cDhcpServer2PoolSecNwMask, hh3cDhcpServer2PoolForbidTable=hh3cDhcpServer2PoolForbidTable, hh3cDhcpRelay2OfferNum=hh3cDhcpRelay2OfferNum, hh3cDhcpServer2ConflictTime=hh3cDhcpServer2ConflictTime, hh3cDhcpServer2ExpiredEntry=hh3cDhcpServer2ExpiredEntry, hh3cDhcpServer2DefOptGrpTable=hh3cDhcpServer2DefOptGrpTable, hh3cDhcpServer2PoolIndex=hh3cDhcpServer2PoolIndex, hh3cDhcpRelay2IfSelectRelay=hh3cDhcpRelay2IfSelectRelay, hh3cDhcpServer2PoolNetbiosType=hh3cDhcpServer2PoolNetbiosType, hh3cDhcpServer2ConflictNum=hh3cDhcpServer2ConflictNum, hh3cDhcpServer2PoolForbidStatus=hh3cDhcpServer2PoolForbidStatus, hh3cDhcpServer2PoolBimsPort=hh3cDhcpServer2PoolBimsPort, hh3cDhcpServer2OptionEntry=hh3cDhcpServer2OptionEntry, hh3cDhcpServer2PoolSecNwTable=hh3cDhcpServer2PoolSecNwTable, hh3cDhcpRelay2IfOpt82RIDStr=hh3cDhcpRelay2IfOpt82RIDStr, hh3cDhcpServer2Tables=hh3cDhcpServer2Tables, hh3cDhcpRelay2ReleaseNum=hh3cDhcpRelay2ReleaseNum, hh3cDhcpRelay2UserInfoTable=hh3cDhcpRelay2UserInfoTable, hh3cDhcpServer2PoolOptAscii=hh3cDhcpServer2PoolOptAscii, hh3cDhcpRelay2UserInfoRefresh=hh3cDhcpRelay2UserInfoRefresh, hh3cDhcpServer2PoolSecondDNSIP=hh3cDhcpServer2PoolSecondDNSIP, hh3cDhcpServer2ForbidVpnName=hh3cDhcpServer2ForbidVpnName, hh3cDhcpServer2ExpiredIP=hh3cDhcpServer2ExpiredIP, hh3cDhcpServer2PoolStaticHType=hh3cDhcpServer2PoolStaticHType, hh3cDhcpRelay2UserInfoRecord=hh3cDhcpRelay2UserInfoRecord, hh3cDhcpRelay2UserInfoEntry=hh3cDhcpRelay2UserInfoEntry, hh3cDhcpServer2NakNum=hh3cDhcpServer2NakNum, hh3cDhcpServer2PoolNextServer=hh3cDhcpServer2PoolNextServer, hh3cDhcpServer2OptionGroupId=hh3cDhcpServer2OptionGroupId, hh3cDhcpServer2RuleHwAddrTable=hh3cDhcpServer2RuleHwAddrTable, hh3cDhcpServer2PoolNetworkMask=hh3cDhcpServer2PoolNetworkMask, hh3cDhcpServer2PoolTftpDomName=hh3cDhcpServer2PoolTftpDomName, hh3cDhcpServer2PoolOptRowStatus=hh3cDhcpServer2PoolOptRowStatus, hh3cDhcpServer2RequestNum=hh3cDhcpServer2RequestNum, hh3cDhcpServer2DefOptGrpId=hh3cDhcpServer2DefOptGrpId, hh3cDhcpServer2ConflictType=hh3cDhcpServer2ConflictType, hh3cDhcpRelay2TxClientNum=hh3cDhcpRelay2TxClientNum, hh3cDhcpServer2FreeEnd=hh3cDhcpServer2FreeEnd, hh3cDhcpServer2PoolLeaseHour=hh3cDhcpServer2PoolLeaseHour, hh3cDhcpServer2IPInUseEndLease=hh3cDhcpServer2IPInUseEndLease, hh3cDhcpServer2ReleaseNum=hh3cDhcpServer2ReleaseNum, hh3cDhcpServer2IgnoreBootp=hh3cDhcpServer2IgnoreBootp, hh3cDhcpServer2PoolVoiceNCPIP=hh3cDhcpServer2PoolVoiceNCPIP, hh3cDhcpServer2PoolClassStart=hh3cDhcpServer2PoolClassStart, hh3cDhcpRelay2UserInfoIfIndex=hh3cDhcpRelay2UserInfoIfIndex, hh3cDhcpServer2PoolNumber=hh3cDhcpServer2PoolNumber, hh3cDhcpServer2AutoBindNum=hh3cDhcpServer2AutoBindNum, hh3cDhcpServer2RuleHwAddress=hh3cDhcpServer2RuleHwAddress, hh3cDhcpRelay2IfOpt82CIDFormat=hh3cDhcpRelay2IfOpt82CIDFormat, hh3cDhcpServer2RuleTable=hh3cDhcpServer2RuleTable, hh3cDhcpServer2PoolSecNwGwIP=hh3cDhcpServer2PoolSecNwGwIP, hh3cDhcpServer2ConfigGroup=hh3cDhcpServer2ConfigGroup, hh3cDhcpServer2PoolNetwork=hh3cDhcpServer2PoolNetwork, hh3cDhcpServer2BootpRequestNum=hh3cDhcpServer2BootpRequestNum, hh3cDhcpServer2IPInUseEntry=hh3cDhcpServer2IPInUseEntry, hh3cDhcpRelay2Tables=hh3cDhcpRelay2Tables, hh3cDhcpRelay2BadNum=hh3cDhcpRelay2BadNum, hh3cDhcpServer2RuleOptHexStr=hh3cDhcpServer2RuleOptHexStr, hh3cDhcpServer2DiscoverNum=hh3cDhcpServer2DiscoverNum, hh3cDhcpRelay2SrvAddrIP=hh3cDhcpRelay2SrvAddrIP, hh3cDhcpServer2PoolStaticHAddr=hh3cDhcpServer2PoolStaticHAddr, hh3cDhcpServer2OfferNum=hh3cDhcpServer2OfferNum, hh3cDhcpServer2PoolStaticStatus=hh3cDhcpServer2PoolStaticStatus, hh3cDhcpServer2ForbidTable=hh3cDhcpServer2ForbidTable, hh3cDhcpServer2ConflictRowStatus=hh3cDhcpServer2ConflictRowStatus, hh3cDhcpRelay2IfConfigEntry=hh3cDhcpRelay2IfConfigEntry, hh3cDhcpServer2PingNumber=hh3cDhcpServer2PingNumber, hh3cDhcpServer2PoolTftpIP=hh3cDhcpServer2PoolTftpIP, hh3cDhcpRelay2IfOpt82Strategy=hh3cDhcpRelay2IfOpt82Strategy, hh3cDhcpServer2RuleHwAddrNumber=hh3cDhcpServer2RuleHwAddrNumber, hh3cDhcpRelay2SrvAddrEntry=hh3cDhcpRelay2SrvAddrEntry, hh3cDhcpServer2IPInUseTable=hh3cDhcpServer2IPInUseTable, hh3cDhcpServer2BadNum=hh3cDhcpServer2BadNum)

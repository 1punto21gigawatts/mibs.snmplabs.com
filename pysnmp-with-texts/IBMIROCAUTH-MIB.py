#
# PySNMP MIB module IBMIROCAUTH-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/IBMIROCAUTH-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:51:38 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueRangeConstraint, ValueSizeConstraint, SingleValueConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueRangeConstraint", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsUnion")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
ModuleIdentity, MibIdentifier, iso, Counter64, enterprises, NotificationType, ObjectIdentity, TimeTicks, Gauge32, MibScalar, MibTable, MibTableRow, MibTableColumn, IpAddress, NotificationType, Counter32, Bits, Integer32, Unsigned32 = mibBuilder.importSymbols("SNMPv2-SMI", "ModuleIdentity", "MibIdentifier", "iso", "Counter64", "enterprises", "NotificationType", "ObjectIdentity", "TimeTicks", "Gauge32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "IpAddress", "NotificationType", "Counter32", "Bits", "Integer32", "Unsigned32")
PhysAddress, TextualConvention, DisplayString, TruthValue, TestAndIncr, AutonomousType, RowStatus = mibBuilder.importSymbols("SNMPv2-TC", "PhysAddress", "TextualConvention", "DisplayString", "TruthValue", "TestAndIncr", "AutonomousType", "RowStatus")
ibmIROCconfigAuth = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 119, 7, 2))
ibm = MibIdentifier((1, 3, 6, 1, 4, 1, 2))
ibmProd = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6))
ibm2210 = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 72))
ibmIROC = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 119))
ibmIROCconfig = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 119, 7))
ibmAuthTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 119, 7, 2, 0))
ibmAuthMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 119, 7, 2, 1))
ibmAuthDomains = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 119, 7, 2, 2))
ibmAuthConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 119, 7, 2, 3))
ibmAuthGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 119, 7, 2, 1, 1))
authCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 119, 7, 2, 3, 1))
authGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 119, 7, 2, 3, 2))
class RowDefinition(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 3, 4, 5, 6))
    namedValues = NamedValues(("active", 1), ("notReady", 3), ("createAndGo", 4), ("createAndWait", 5), ("destroy", 6))

class Enabled(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1))
    namedValues = NamedValues(("disabled", 0), ("enabled", 1))

class DateAndTime2(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 11)

class SecureOctetString(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 65535)

class SecureDisplayString(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 65535)

class SecureRowDefinition(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 65535)

authUserProfileTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 119, 7, 2, 1, 2), )
if mibBuilder.loadTexts: authUserProfileTable.setStatus('mandatory')
if mibBuilder.loadTexts: authUserProfileTable.setDescription('Table of named profiles. Used to collect information about tunnel profiles and user, e.g., PPP, related information.')
authUserProfileEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 119, 7, 2, 1, 2, 1), ).setIndexNames((1, "IBMIROCAUTH-MIB", "authUserProfileName"))
if mibBuilder.loadTexts: authUserProfileEntry.setStatus('mandatory')
if mibBuilder.loadTexts: authUserProfileEntry.setDescription('Each entry is a separate profile with associated attributes.')
authUserProfileName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 7, 2, 1, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 64)))
if mibBuilder.loadTexts: authUserProfileName.setStatus('mandatory')
if mibBuilder.loadTexts: authUserProfileName.setDescription('For ppp user, it is the name of the user. For tunnel connection definition, it is the host name of the remote tunnel end point.')
authUserProfileRowDefinition = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 7, 2, 1, 2, 1, 2), SecureRowDefinition()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: authUserProfileRowDefinition.setStatus('mandatory')
if mibBuilder.loadTexts: authUserProfileRowDefinition.setDescription('The status of the row.')
authUserProfilePassword = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 7, 2, 1, 2, 1, 3), SecureDisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: authUserProfilePassword.setStatus('mandatory')
if mibBuilder.loadTexts: authUserProfilePassword.setDescription('The password for this user. It is used for PPP and SNMP users but not tunnel profiles.')
authUserProfileType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 7, 2, 1, 2, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1).clone(hexValue="20")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: authUserProfileType.setStatus('mandatory')
if mibBuilder.loadTexts: authUserProfileType.setDescription("The profile type. '80'H represents login. '40'H represents tunnel, and '20'H represents ppp, '10'H represents snmp. It is implementation choice to restrict to one type per entry (i.e., can't be combination of these types) or not support certain types of users.")
authUserProfileMaxConnectTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 7, 2, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: authUserProfileMaxConnectTime.setStatus('mandatory')
if mibBuilder.loadTexts: authUserProfileMaxConnectTime.setDescription('The max connection allowed per connection. A value of zero is using the interface default, and negative one (-1) indicates no limits.')
authUserProfileCallbackType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 7, 2, 1, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("disabled", 0), ("roaming", 1), ("required", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: authUserProfileCallbackType.setStatus('mandatory')
if mibBuilder.loadTexts: authUserProfileCallbackType.setDescription('The type of callback.')
authUserProfileCallbackNum = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 7, 2, 1, 2, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: authUserProfileCallbackNum.setStatus('mandatory')
if mibBuilder.loadTexts: authUserProfileCallbackNum.setDescription('The dial back phone number when callback type is required. An octet string of length zero indicates the dial back phone number is not set.')
authUserProfileDialout = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 7, 2, 1, 2, 1, 8), Enabled().clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: authUserProfileDialout.setStatus('mandatory')
if mibBuilder.loadTexts: authUserProfileDialout.setDescription('A user on the network may be requesting permission to use dialout function. This flag attached to the user profile determines whether the user is able to dialout.')
authUserProfileEncryptionKey = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 7, 2, 1, 2, 1, 9), SecureOctetString().clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: authUserProfileEncryptionKey.setStatus('mandatory')
if mibBuilder.loadTexts: authUserProfileEncryptionKey.setDescription('The encryption key. An octet string of length zero indicates the encryption key is not set. The key is used when ECP is negotiated for this user.')
authUserProfileStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 7, 2, 1, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("locked", 3))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: authUserProfileStatus.setStatus('mandatory')
if mibBuilder.loadTexts: authUserProfileStatus.setDescription("The status of the user profile entry. By setting the value to 'enabled' from a non-enabled status will reset the following statistics: authUserProfileGLoginsAttempts, authUserProfileLoginAttempts, authUserProfileLoginFails, authUserProfileLoginLock.")
authUserProfileExpirationDate = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 7, 2, 1, 2, 1, 11), DateAndTime2().clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: authUserProfileExpirationDate.setStatus('mandatory')
if mibBuilder.loadTexts: authUserProfileExpirationDate.setDescription('The date and time when the password will be expired. That is, the user will no longer be allowed to dial in after this time. A value of zero length indicates no expiration.')
authUserProfileGLoginAllowed = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 7, 2, 1, 2, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: authUserProfileGLoginAllowed.setStatus('mandatory')
if mibBuilder.loadTexts: authUserProfileGLoginAllowed.setDescription('Number of grace logins is allowed after expiration Some local maximum may apply.')
authUserProfileGLoginsAttempts = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 7, 2, 1, 2, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: authUserProfileGLoginsAttempts.setStatus('mandatory')
if mibBuilder.loadTexts: authUserProfileGLoginsAttempts.setDescription('Number of grace login attempted is attempted after the expiration of this user profile. Some local maximum may apply.')
authUserProfileLoginAttempts = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 7, 2, 1, 2, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: authUserProfileLoginAttempts.setStatus('mandatory')
if mibBuilder.loadTexts: authUserProfileLoginAttempts.setDescription('Total number of login attempted, sucessfully or not.')
authUserProfileLoginFails = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 7, 2, 1, 2, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: authUserProfileLoginFails.setStatus('mandatory')
if mibBuilder.loadTexts: authUserProfileLoginFails.setDescription('Total number of login failed.')
authUserProfileLoginLock = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 7, 2, 1, 2, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: authUserProfileLoginLock.setStatus('mandatory')
if mibBuilder.loadTexts: authUserProfileLoginLock.setDescription('Number of consecutive failed logins attempted. The number is reset to zero after a successful login.')
authUserProfileIpType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 7, 2, 1, 2, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 3, 4))).clone(namedValues=NamedValues(("disabled", 0), ("single", 1), ("networkDials", 3), ("singleDials", 4))).clone('single')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: authUserProfileIpType.setStatus('mandatory')
if mibBuilder.loadTexts: authUserProfileIpType.setDescription('The Ip network type of Dials.')
authUserProfileIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 7, 2, 1, 2, 1, 18), IpAddress().clone('0.0.0.0')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: authUserProfileIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: authUserProfileIpAddr.setDescription('IP address for this user.')
authUserProfileIpMask = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 7, 2, 1, 2, 1, 19), IpAddress().clone('255.255.255.255')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: authUserProfileIpMask.setStatus('mandatory')
if mibBuilder.loadTexts: authUserProfileIpMask.setDescription('IP mask for this user.')
authUserProfileHostName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 7, 2, 1, 2, 1, 20), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: authUserProfileHostName.setStatus('mandatory')
if mibBuilder.loadTexts: authUserProfileHostName.setDescription('The host name for this user.')
authUserProfileSharedSecurity = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 7, 2, 1, 2, 1, 21), SecureDisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: authUserProfileSharedSecurity.setStatus('mandatory')
if mibBuilder.loadTexts: authUserProfileSharedSecurity.setDescription('The shared security between two L2TP Peers.')
authUserProfileTunneled = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 7, 2, 1, 2, 1, 22), Enabled().clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: authUserProfileTunneled.setStatus('mandatory')
if mibBuilder.loadTexts: authUserProfileTunneled.setDescription('The value of enabled means this PPP user profile is a tunneled user.')
authUserProfileTunnelType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 7, 2, 1, 2, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3))).clone(namedValues=NamedValues(("l2tp", 3))).clone('l2tp')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: authUserProfileTunnelType.setStatus('mandatory')
if mibBuilder.loadTexts: authUserProfileTunnelType.setDescription('Tunneling Protocol.')
authUserProfileTunnelMediumType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 7, 2, 1, 2, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("ip", 1))).clone('ip')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: authUserProfileTunnelMediumType.setStatus('mandatory')
if mibBuilder.loadTexts: authUserProfileTunnelMediumType.setDescription('Tunneling Medium.')
authUserProfileTunnelServer = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 7, 2, 1, 2, 1, 25), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: authUserProfileTunnelServer.setStatus('mandatory')
if mibBuilder.loadTexts: authUserProfileTunnelServer.setDescription('Tunnel-Server endpoint address. For IP protocol, it is the server IP address in dotted notation.')
authUserProfileVcEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 7, 2, 1, 2, 1, 26), Enabled().clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: authUserProfileVcEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: authUserProfileVcEnabled.setDescription('The value of enabled means this PPP user profile is a virtual connection user.')
authUserProfileVcMaxSuspendTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 7, 2, 1, 2, 1, 27), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2147483647)).clone(-1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: authUserProfileVcMaxSuspendTime.setStatus('mandatory')
if mibBuilder.loadTexts: authUserProfileVcMaxSuspendTime.setDescription('The maximum amount of time (in hours) that the device will allow a virtual connection in suspend mode. After that, the device will remove the all states of the virtual connection. A value of -1 means use the box default value, 0 means no limits. It is device choice to provide reasonable minimum and maximum suspend time values.')
authUserProfileVcIdleTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 7, 2, 1, 2, 1, 28), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2147483647)).clone(-1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: authUserProfileVcIdleTime.setStatus('mandatory')
if mibBuilder.loadTexts: authUserProfileVcIdleTime.setDescription('The device will instruct the dial-in station to suspend the real connection after the inactivity for this amount of time. A value of -1 means use the box default value, 0 means no limits. It is device choice to support 0, and provide reasonable minimum and maximum idle time values.')
authUserProfileGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 119, 7, 2, 3, 2, 1))
authUserProfileCompliance = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 119, 7, 2, 3, 1, 1))
mibBuilder.exportSymbols("IBMIROCAUTH-MIB", ibmAuthDomains=ibmAuthDomains, RowDefinition=RowDefinition, authUserProfileCallbackType=authUserProfileCallbackType, authUserProfileName=authUserProfileName, authUserProfileStatus=authUserProfileStatus, authUserProfileCallbackNum=authUserProfileCallbackNum, ibmProd=ibmProd, authUserProfileGLoginAllowed=authUserProfileGLoginAllowed, authUserProfileVcEnabled=authUserProfileVcEnabled, authUserProfileMaxConnectTime=authUserProfileMaxConnectTime, authUserProfileEncryptionKey=authUserProfileEncryptionKey, authUserProfileExpirationDate=authUserProfileExpirationDate, ibm2210=ibm2210, SecureOctetString=SecureOctetString, authUserProfileTunnelMediumType=authUserProfileTunnelMediumType, authUserProfileCompliance=authUserProfileCompliance, ibmAuthConformance=ibmAuthConformance, authUserProfileIpMask=authUserProfileIpMask, authUserProfileType=authUserProfileType, ibmIROC=ibmIROC, authUserProfileGroup=authUserProfileGroup, authUserProfileEntry=authUserProfileEntry, authUserProfileRowDefinition=authUserProfileRowDefinition, authUserProfileIpAddr=authUserProfileIpAddr, authCompliances=authCompliances, authUserProfileSharedSecurity=authUserProfileSharedSecurity, authUserProfileLoginAttempts=authUserProfileLoginAttempts, authUserProfileLoginFails=authUserProfileLoginFails, authUserProfileTable=authUserProfileTable, ibmAuthTraps=ibmAuthTraps, authUserProfileDialout=authUserProfileDialout, authUserProfileTunneled=authUserProfileTunneled, authUserProfileGLoginsAttempts=authUserProfileGLoginsAttempts, authUserProfileHostName=authUserProfileHostName, authUserProfileTunnelServer=authUserProfileTunnelServer, authUserProfileLoginLock=authUserProfileLoginLock, SecureDisplayString=SecureDisplayString, authUserProfileIpType=authUserProfileIpType, Enabled=Enabled, authUserProfileVcIdleTime=authUserProfileVcIdleTime, authGroups=authGroups, authUserProfileTunnelType=authUserProfileTunnelType, authUserProfileVcMaxSuspendTime=authUserProfileVcMaxSuspendTime, ibmAuthMIB=ibmAuthMIB, SecureRowDefinition=SecureRowDefinition, ibmIROCconfig=ibmIROCconfig, ibmIROCconfigAuth=ibmIROCconfigAuth, ibmAuthGeneral=ibmAuthGeneral, authUserProfilePassword=authUserProfilePassword, DateAndTime2=DateAndTime2, ibm=ibm)

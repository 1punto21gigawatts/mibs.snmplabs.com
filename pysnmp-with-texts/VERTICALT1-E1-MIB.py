#
# PySNMP MIB module VERTICALT1-E1-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/VERTICALT1-E1-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:34:08 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ValueRangeConstraint, SingleValueConstraint, ValueSizeConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ValueRangeConstraint", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsIntersection")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Unsigned32, ModuleIdentity, IpAddress, Counter64, MibIdentifier, NotificationType, Bits, iso, Counter32, ObjectIdentity, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, enterprises, Gauge32, TimeTicks, Integer32 = mibBuilder.importSymbols("SNMPv2-SMI", "Unsigned32", "ModuleIdentity", "IpAddress", "Counter64", "MibIdentifier", "NotificationType", "Bits", "iso", "Counter32", "ObjectIdentity", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "enterprises", "Gauge32", "TimeTicks", "Integer32")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
vertical = MibIdentifier((1, 3, 6, 1, 4, 1, 2338))
vds1 = MibIdentifier((1, 3, 6, 1, 4, 1, 2338, 3))
vdsx1CardTable = MibTable((1, 3, 6, 1, 4, 1, 2338, 3, 1), )
if mibBuilder.loadTexts: vdsx1CardTable.setStatus('mandatory')
if mibBuilder.loadTexts: vdsx1CardTable.setDescription('The Vertical DS1 Configuration table extension.')
vdsx1CardEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2338, 3, 1, 1), ).setIndexNames((0, "VERTICALT1-E1-MIB", "vdsx1cardSlotNumber"))
if mibBuilder.loadTexts: vdsx1CardEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vdsx1CardEntry.setDescription('An entry in the Vertical Card Configuration table (an extension to the rfc1406 Configuration table.')
vdsx1cardSlotNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 14))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vdsx1cardSlotNumber.setStatus('mandatory')
if mibBuilder.loadTexts: vdsx1cardSlotNumber.setDescription('Physical slot in the system in which the card is installed.')
vdsx1cardType = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 4, 100))).clone(namedValues=NamedValues(("cardTYPE-DUAL-T1", 1), ("cardTYPE-8-CHANNEL-CO-POTS", 3), ("cardTYPE-BRIDGE1", 4), ("cardTYPE-NOT-CONFIGURED", 100)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vdsx1cardType.setStatus('mandatory')
if mibBuilder.loadTexts: vdsx1cardType.setDescription("The Vertical's card Type. The following types are defined: cardTYPE-DUAL-T1 = 1, cardTYPE-8-CHANNEL-CO-POTS = 3, cardTYPE-BRIDGE1 = 4, cardTYPE-NOT-CONFIGURED = 100 ")
vdsx1cardDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vdsx1cardDescr.setStatus('mandatory')
if mibBuilder.loadTexts: vdsx1cardDescr.setDescription('Vertical card identification number.')
vdsx1cardRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vdsx1cardRevision.setStatus('mandatory')
if mibBuilder.loadTexts: vdsx1cardRevision.setDescription('Vertical card revision level.')
vdsx1cardDriverVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vdsx1cardDriverVersion.setStatus('mandatory')
if mibBuilder.loadTexts: vdsx1cardDriverVersion.setDescription('Vertical card driver version.')
vdsx1cardIOPortAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vdsx1cardIOPortAddress.setStatus('mandatory')
if mibBuilder.loadTexts: vdsx1cardIOPortAddress.setDescription('The ISA bus base address for this Card.')
vdsx1cardErrorLED = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vdsx1cardErrorLED.setStatus('mandatory')
if mibBuilder.loadTexts: vdsx1cardErrorLED.setDescription('All Vertical cards have an ERROR LED and a READY LED. The combined values of these LEDs are as follows - ERRORLed READYLed VALUE OPERATIONAL DEFINITION OFF OFF (0 0) Invalid state ON OFF (1 0) Just after power up. This state remains until card is ready to service io. ON ON (1 1) Statue during software initialization OFF ON (0 1) The normal operational state of the card.')
vdsx1cardReadyLED = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vdsx1cardReadyLED.setStatus('mandatory')
if mibBuilder.loadTexts: vdsx1cardReadyLED.setDescription('All Vertical cards have a READY LED and an ERROR LED. The combined values of these LEDs are as follows - ERRORLed READYLed OPERATIONAL DEFINITION OFF OFF invalid state ON OFF Just after power up. This state remains until card is ready to service io. ON ON Statue during software initialization OFF ON The normal operational state of the card.')
vdsx1TrunkTable = MibTable((1, 3, 6, 1, 4, 1, 2338, 3, 2), )
if mibBuilder.loadTexts: vdsx1TrunkTable.setStatus('mandatory')
if mibBuilder.loadTexts: vdsx1TrunkTable.setDescription('The DS1 Trunk table extensions for Vertical Networks Instant Office.')
vdsx1TrunkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2338, 3, 2, 1), ).setIndexNames((0, "VERTICALT1-E1-MIB", "vdsx1TrunkIfIndex"))
if mibBuilder.loadTexts: vdsx1TrunkEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vdsx1TrunkEntry.setDescription('An entry in the Vertical DS1 Trunk table ')
vdsx1TrunkIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 3, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vdsx1TrunkIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vdsx1TrunkIfIndex.setDescription('The interface Index for this trunk. The value for this object is equal to the value of dsx1IfIndex from the Interfaces table of DS1/E1 (RFC 1406). Which also correlates to the IfIndex found in MIB-II.')
vdsx1TrunkIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 3, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vdsx1TrunkIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vdsx1TrunkIndex.setDescription('This object is the index into the number of trunks associated with the card defined in the card group.')
vdsx1TrunkIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 3, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vdsx1TrunkIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: vdsx1TrunkIdentifier.setDescription('This value for this object is equal to the value of dsx1CircuitIdentifier from the Configuration table of DS1/E1 (RFC 1406). This is a vendor specific field used to help identify each specific interface for diagnostic purposes.')
vdsx1TrunkSlotNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 3, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vdsx1TrunkSlotNumber.setStatus('mandatory')
if mibBuilder.loadTexts: vdsx1TrunkSlotNumber.setDescription('The value for this object is the logical number of the slot in which the card containing this trunk is located, (vdsx1cardSlotNumber).')
vdsx1TrunkDeviceNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 3, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vdsx1TrunkDeviceNumber.setStatus('mandatory')
if mibBuilder.loadTexts: vdsx1TrunkDeviceNumber.setDescription('The value for this object is the logical device number of this trunk within its slot. This number may be used to identify this device in the registry.')
vdsx1TrunkInterrupt = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 3, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vdsx1TrunkInterrupt.setStatus('mandatory')
if mibBuilder.loadTexts: vdsx1TrunkInterrupt.setDescription('Interrupt Request level for this card/trunk. Note: all trunks in the same card have the same IRQ. ')
vdsx1TrunkEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 3, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 100))).clone(namedValues=NamedValues(("vdsx1TrunkActivated", 1), ("vdsx1TrunkNotConfigured", 2), ("vdsx1TrunkDeactivated", 100)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vdsx1TrunkEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: vdsx1TrunkEnabled.setDescription('Setting this variable to Deactivated will disable this particular trunk. ')
vdsx1TrunkMasterPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 3, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 100))).clone(namedValues=NamedValues(("primary", 1), ("firstAlternate", 2), ("secondAlternate", 3), ("notUsed", 100)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vdsx1TrunkMasterPriority.setStatus('mandatory')
if mibBuilder.loadTexts: vdsx1TrunkMasterPriority.setDescription('Designates the priority for selecting which trunk is to drive the MVIP SEC8K clock, i.e. which trunk drives the master timing system. This value must be diffrent for each Trunk in the system.Valid values mean: notUsed (100)=> never choose this trunk as clock master primary (1)=> choose this trunk as first choice firstAlternate (2)=> choose this trunk as second choice secondAlternate (3)=> choose this trunk as third choice')
vdsx1TrunkStream = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 3, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vdsx1TrunkStream.setStatus('mandatory')
if mibBuilder.loadTexts: vdsx1TrunkStream.setDescription('The MVIP Stream assigned to the Trunk.')
vdsx1TrunkStartingChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 3, 2, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 24))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vdsx1TrunkStartingChannel.setStatus('mandatory')
if mibBuilder.loadTexts: vdsx1TrunkStartingChannel.setDescription('The starting MVIP channel within the MVIP Stream. If CardType is DTM or WAN1, this value is 0; if CardType is CO-POTS, this value is 16 or 24.')
vdsx1TrunkType = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 3, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 7, 100))).clone(namedValues=NamedValues(("dev-t1CAS", 1), ("dev-t1CCS", 2), ("dev-coPots", 7), ("dev-undef", 100)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vdsx1TrunkType.setStatus('mandatory')
if mibBuilder.loadTexts: vdsx1TrunkType.setDescription('Specifies the TrunkType for this trunk. Defines E1 vs T1 as well as Common Channel Signalling (CCS) vs. Channel Associated Signalling (CAS). Valid values are : dev-undef, // 100 : undefined dev-t1CAS, // 1 : T1 Channel Associated Signaling dev-t1CCS, // 2 : T1 Common Channel Signaling : with D channel dev-coPots, // 7 : CO Pots (analog)')
vdsx1TrunkIsdnSignalingProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 3, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 5, 6, 7, 10, 263))).clone(namedValues=NamedValues(("other", 1), ("ess4", 5), ("ess5", 6), ("dms100", 7), ("ni2", 10), ("dms100s100", 263)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vdsx1TrunkIsdnSignalingProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: vdsx1TrunkIsdnSignalingProtocol.setDescription('Defines the switch type for the Isdn protocol stack. The following are all the possible types: other(1), none of the following ess4(5), U.S.A. / AT&T 4ESS ess5(6), U.S.A. / AT&T 5ESS dms100(7), U.S.A. / Northern Telecom DMS100 ni2(10), U.S.A. / National ISDN 2 (BRI, PRI) dms100s100 (263) NT DMS-100 switch / S-100')
vdsx1TrunkLineCoding = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 3, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 5, 6))).clone(namedValues=NamedValues(("b8zs", 2), ("ami", 5), ("other", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vdsx1TrunkLineCoding.setStatus('mandatory')
if mibBuilder.loadTexts: vdsx1TrunkLineCoding.setDescription('Line Coding, i.e. the zero code suppression used for this Trunk. Valid values are: b8ZS (2) -> use of a specified pattern of normal bits and bipolar violations which are used to replace a sequence of eight zero bits. aMI (5) -> a mode wherein no zero code suppression is present other (6) -> none of the codes described above, or Not Applicable, whichever is appropriate Presently, T1 trunk can be either b8zs (2) or ami (5). E1 trunk must be hdb3 (3).')
vdsx1TrunkFraming = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 3, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("esf", 2), ("d4", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vdsx1TrunkFraming.setStatus('mandatory')
if mibBuilder.loadTexts: vdsx1TrunkFraming.setDescription('Defines framing for Trunk. T1 trunk can be either esf (2) or d4 (3). E1 trunk can be either e1-crc (5) or e1-mf (6). In cases where Framing is not applicable, value 1 (other) would be displayed.')
vdsx1TrunkDChannelSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 3, 2, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 18))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vdsx1TrunkDChannelSlot.setStatus('mandatory')
if mibBuilder.loadTexts: vdsx1TrunkDChannelSlot.setDescription('Slot number of trunk whose DChannel controls the B channels of this trunk. ')
vdsx1TrunkDChannelDevice = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 3, 2, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 9))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vdsx1TrunkDChannelDevice.setStatus('mandatory')
if mibBuilder.loadTexts: vdsx1TrunkDChannelDevice.setDescription('Specifies the device number of the trunk whose D channel controls the B channels of this trunk. ')
vdsx1TrunkNumberOfChannels = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 3, 2, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 24))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vdsx1TrunkNumberOfChannels.setStatus('mandatory')
if mibBuilder.loadTexts: vdsx1TrunkNumberOfChannels.setDescription('Maximum number of channels to be initialized for this trunk - 0..24 for T1, 0..31 for E1, 0..8 for COPots.')
vdsx1TrunkLineBuildOut = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 3, 2, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 100))).clone(namedValues=NamedValues(("buildOut-minus15dB", 1), ("buildOut-0dB", 2), ("buildOut-minus7point5dB", 3), ("notApplicable", 100)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vdsx1TrunkLineBuildOut.setStatus('mandatory')
if mibBuilder.loadTexts: vdsx1TrunkLineBuildOut.setDescription('Defines the line build out option. The following are applicable values : buildOut-minus15dB , i.e. -15 dB (1), buildOut-0dB , i.e. 0 dB (2), buildOut-minus7point5dB , i.e. -7.5 db (3) .')
vdsx1TrunkLoopback = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 3, 2, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("vdsx1NoLoop", 1), ("vdsx1PayloadLoop", 2), ("vdsx1LineLoop", 3), ("vdsx1OtherLoop", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vdsx1TrunkLoopback.setStatus('mandatory')
if mibBuilder.loadTexts: vdsx1TrunkLoopback.setDescription("This variable represents the loopback confi- guration of the DS1 interface. Agents support- ing read/write access should return badValue in response to a requested loopback state that the interface does not support. The values mean: vdsx1NoLoop Not in the loopback state. A device that is not capable of performing a loopback on the interface shall always return this as it's value. vdsx1PayloadLoop The received signal at this interface is looped through the device. Typically the received signal is looped back for re- transmission after it has passed through the device's framing function. vdsx1LineLoop The received signal at this interface does not go through the device (minimum pene- tration) but is looped back out. vdsx1OtherLoop Loopbacks that are not defined here.")
vdsx1TrunkRedLED = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 3, 2, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vdsx1TrunkRedLED.setStatus('mandatory')
if mibBuilder.loadTexts: vdsx1TrunkRedLED.setDescription(' Specifies the RED LED status of the trunk OFF = 0, ON = 1.')
vdsx1TrunkYellowLED = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 3, 2, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vdsx1TrunkYellowLED.setStatus('mandatory')
if mibBuilder.loadTexts: vdsx1TrunkYellowLED.setDescription(' Specifies the YELLOW LED status of the trunk OFF = 0, ON = 1.')
vdsx1TrunkChangePending = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 3, 2, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vdsx1TrunkChangePending.setStatus('mandatory')
if mibBuilder.loadTexts: vdsx1TrunkChangePending.setDescription('Indicates that a change to the device values have been made to the registry. The intepretation of the values are : 1 => change made to the registry, but not incorporated in the device yet 0 => the device changes the value to 0 from 1, after it incorporates the value from registry.')
vdsx1ChannelTable = MibTable((1, 3, 6, 1, 4, 1, 2338, 3, 9), )
if mibBuilder.loadTexts: vdsx1ChannelTable.setStatus('mandatory')
if mibBuilder.loadTexts: vdsx1ChannelTable.setDescription('Channel entries for each of the channels associated with each trunk defined in the trunk table.')
vdsx1ChannelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2338, 3, 9, 1), ).setIndexNames((0, "VERTICALT1-E1-MIB", "vdsx1TrunkIfIndex"), (0, "VERTICALT1-E1-MIB", "vdsx1channelIndex"))
if mibBuilder.loadTexts: vdsx1ChannelEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vdsx1ChannelEntry.setDescription('Each entry is one channel in a T1/E1 trunk.')
vdsx1channelIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 3, 9, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vdsx1channelIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vdsx1channelIndex.setDescription('This is the logical channel number of the channel within its trunk. For T1 it is between 1 and 24 for E1 it is between 1 and 32. ')
vdsx1channelTrunkIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 3, 9, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vdsx1channelTrunkIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vdsx1channelTrunkIndex.setDescription('This is the index of the trunk (relative to its card) to which this channel belongs.')
vdsx1channelSlotNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 3, 9, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vdsx1channelSlotNumber.setStatus('mandatory')
if mibBuilder.loadTexts: vdsx1channelSlotNumber.setDescription('The value for this object is the logical number of the slot in which the card (and trunk) containing is located (vdsx1cardSlotNumber)..')
vdsx1channelTrunkDeviceNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 3, 9, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vdsx1channelTrunkDeviceNumber.setStatus('mandatory')
if mibBuilder.loadTexts: vdsx1channelTrunkDeviceNumber.setDescription('The value for this object is the logical device number of the trunk containing this channel within its slot, ie vdsx1TrunkDeviceNumber ')
vdsx1channelEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 3, 9, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 100))).clone(namedValues=NamedValues(("vdsx1channelActivated", 1), ("vdsx1channelNotConfigured", 2), ("vdsx1channelDeactivated", 100)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vdsx1channelEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: vdsx1channelEnabled.setDescription('Setting this variable to Deactivated will disable this particular channel. Valid values are : vdsx1channelDeactivated (100) vdsx1channelActivated (1) vdsx1channelNotConfigured (2)')
vdsx1channelType = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 3, 9, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 5, 6, 7, 8, 9, 11, 12, 13, 14, 100))).clone(namedValues=NamedValues(("vdsx1channelTypeWink", 2), ("vdsx1channelTypeGS", 5), ("vdsx1channelTypeClear", 6), ("vdsx1channelTypeAnalogImm", 7), ("vdsx1channelTypeBChan", 8), ("vdsx1channelTypeDChan", 9), ("vdsx1channelTypeAnalogDt", 11), ("vdsx1channelTypeAnalogGs", 12), ("vdsx1channelTypeDDS", 13), ("vdsx1channelTypeAnalogDID", 14), ("vdsx1channelTypeUnknown", 100)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vdsx1channelType.setStatus('mandatory')
if mibBuilder.loadTexts: vdsx1channelType.setDescription('Channel type, vdsx1channelTypeUnknown : Unknown type vdsx1channelTypeWink : E&M (Ear and Mouth) start vdsx1channelTypeGS : Ground Start Digital trunk. vdsx1channelTypeClear : Nailed up clear channel, for data vdsx1channelTypeAnalogImm: Analog Trunk, Immediate start vdsx1channelTypeBChan: PRI B channel on T1 or E1 vdsx1channelTypeDChan: PRI D channel on T1 or E1 vdsx1channelTypeAnalogDt: Analog channel, dialtone start vdsx1channelTypeAnalogGs: Analog channel, ground start vdsx1channelTypeDDS: DDS channel (56K or 64K) vdsx1channelTypeAnalogDID: Analog channel, DID wink')
vdsx1channelState = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 3, 9, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("channelStateOOS", 1), ("channelStateIdle", 2), ("channelStateInCall", 3), ("channelStateOutCall", 4), ("channelStateOffline", 5), ("channelStateOther", 6), ("channelStateData", 7), ("channelStateError", 8), ("channelStateFeRinging", 9), ("channelStateNeRinging", 10), ("channelStateDigitSend", 11), ("channelStateDigitRcv", 12), ("channelStateIncallEst", 13), ("channelStateOutcallEst", 14), ("channelStateIncallClear", 15), ("channelStateOutcallClear", 16)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vdsx1channelState.setStatus('mandatory')
if mibBuilder.loadTexts: vdsx1channelState.setDescription(' The Call State of this particular channel. Valid values are : Out of Service (channelStateOOS - 1), Idle (channelStateIdle - 2), InBound Call (channelStateInCall - 3), OutBound Call (channelStateOutCall - 4), Off line (channelStateOffline - 5), Other state (channelStateOther - 6), Data (channelStateData - 7), Error (channelStateError - 8), Ringing Far End (channelStateFeRinging - 9), Incoming Ringing (channelStateNeRinging - 10), Sending Digits (channelStateDigitSend - 11), Receiving Digits (channelStateDigitRcv - 12), Incall Established (channelStateIncallEst - 13), Outcall Established (channelStateOutcallEst - 14), Incall Clearing (channelStateIncallClear - 15), Outcall Clearing (channelStateOutcallClear - 16).')
vdsx1channelCallerID = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 3, 9, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vdsx1channelCallerID.setStatus('mandatory')
if mibBuilder.loadTexts: vdsx1channelCallerID.setDescription(' The callerID of an incoming caller, if available. If the callerID is not available, then it will have a length of zero')
vdsx1channelExternalAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 3, 9, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vdsx1channelExternalAddress.setStatus('mandatory')
if mibBuilder.loadTexts: vdsx1channelExternalAddress.setDescription(' The far end number of a connected call on this channel.If the number is not available, then it will have a length of zero.')
vdsx1channelExternalSubAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 3, 9, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vdsx1channelExternalSubAddress.setStatus('mandatory')
if mibBuilder.loadTexts: vdsx1channelExternalSubAddress.setDescription(' The far end sub address of a connected call on this channel.If this is not available, then it will have a length of zero')
vdsx1channelLocalAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 3, 9, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vdsx1channelLocalAddress.setStatus('mandatory')
if mibBuilder.loadTexts: vdsx1channelLocalAddress.setDescription(' The local number of a connected call on this channel.If the number is not available, then it will have a length of zero')
vdsx1channelLocalSubAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 3, 9, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vdsx1channelLocalSubAddress.setStatus('mandatory')
if mibBuilder.loadTexts: vdsx1channelLocalSubAddress.setDescription(' The local sub address of a connected call on this channel.If the number is not available, then it will have a length of zero')
vdsx1channelChangePending = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 3, 9, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vdsx1channelChangePending.setStatus('mandatory')
if mibBuilder.loadTexts: vdsx1channelChangePending.setDescription('Indicates that a change to the channel values have been made to the registry. The intepretation of the values are : 1 => change made to the registry, but not incorporated in the device yet 0 => the device changes the value to 0 from 1, after it incorporates the value from registry.')
vdsx1TrunkRedClear = NotificationType((1, 3, 6, 1, 4, 1, 2338) + (0,1)).setObjects(("VERTICALT1-E1-MIB", "vdsx1TrunkIdentifier"), ("VERTICALT1-E1-MIB", "vdsx1cardSlotNumber"), ("VERTICALT1-E1-MIB", "vdsx1TrunkDeviceNumber"), ("VERTICALT1-E1-MIB", "vdsx1TrunkIndex"))
if mibBuilder.loadTexts: vdsx1TrunkRedClear.setDescription(' This notification is sent when the specific trunk RED alarm condition clears. ')
vdsx1TrunkRed = NotificationType((1, 3, 6, 1, 4, 1, 2338) + (0,2)).setObjects(("VERTICALT1-E1-MIB", "vdsx1TrunkIdentifier"), ("VERTICALT1-E1-MIB", "vdsx1cardSlotNumber"), ("VERTICALT1-E1-MIB", "vdsx1TrunkDeviceNumber"), ("VERTICALT1-E1-MIB", "vdsx1TrunkIndex"))
if mibBuilder.loadTexts: vdsx1TrunkRed.setDescription(' This notification is sent when the specific trunk goes into the RED alarm situation. Red alarm condition signifies LOS (Loss of Signal) failure, i.e. the receiver sees no positive or negative pulses')
vdsx1TrunkYellowClear = NotificationType((1, 3, 6, 1, 4, 1, 2338) + (0,3)).setObjects(("VERTICALT1-E1-MIB", "vdsx1TrunkIdentifier"), ("VERTICALT1-E1-MIB", "vdsx1cardSlotNumber"), ("VERTICALT1-E1-MIB", "vdsx1TrunkDeviceNumber"), ("VERTICALT1-E1-MIB", "vdsx1TrunkIndex"))
if mibBuilder.loadTexts: vdsx1TrunkYellowClear.setDescription(' This notification is sent when the specific trunk YELLOW alarm condition clears. ')
vdsx1TrunkYellow = NotificationType((1, 3, 6, 1, 4, 1, 2338) + (0,4)).setObjects(("VERTICALT1-E1-MIB", "vdsx1TrunkIdentifier"), ("VERTICALT1-E1-MIB", "vdsx1cardSlotNumber"), ("VERTICALT1-E1-MIB", "vdsx1TrunkDeviceNumber"), ("VERTICALT1-E1-MIB", "vdsx1TrunkIndex"))
if mibBuilder.loadTexts: vdsx1TrunkYellow.setDescription(' This notification is sent when the specific trunk goes into the YELLOW alarm situation. Yellow alarm condition signifies a LOF (Loss of Frame) condition, i.e. the receiver does not see the expected framing pattern.')
vdsx1TrunkBlueClear = NotificationType((1, 3, 6, 1, 4, 1, 2338) + (0,5)).setObjects(("VERTICALT1-E1-MIB", "vdsx1TrunkIdentifier"), ("VERTICALT1-E1-MIB", "vdsx1cardSlotNumber"), ("VERTICALT1-E1-MIB", "vdsx1TrunkDeviceNumber"), ("VERTICALT1-E1-MIB", "vdsx1TrunkIndex"))
if mibBuilder.loadTexts: vdsx1TrunkBlueClear.setDescription(' This notification is sent when the specific trunk BLUE alarm condition clears. ')
vdsx1TrunkBlue = NotificationType((1, 3, 6, 1, 4, 1, 2338) + (0,6)).setObjects(("VERTICALT1-E1-MIB", "vdsx1TrunkIdentifier"), ("VERTICALT1-E1-MIB", "vdsx1cardSlotNumber"), ("VERTICALT1-E1-MIB", "vdsx1TrunkDeviceNumber"), ("VERTICALT1-E1-MIB", "vdsx1TrunkIndex"))
if mibBuilder.loadTexts: vdsx1TrunkBlue.setDescription(" This notification is sent when the specific trunk goes into the BLUE alarm situation. Blue alarm conditions occurs when the source goes into AIS (Alarm indication Signal) state. This means that the source has a problem that prevents it from sending its normal, framed payload. Instead, it sends an unframed stream of 1's.")
vdsx1TrunkReconfigComplete = NotificationType((1, 3, 6, 1, 4, 1, 2338) + (0,7)).setObjects(("VERTICALT1-E1-MIB", "vdsx1TrunkIdentifier"), ("VERTICALT1-E1-MIB", "vdsx1cardSlotNumber"), ("VERTICALT1-E1-MIB", "vdsx1TrunkDeviceNumber"), ("VERTICALT1-E1-MIB", "vdsx1TrunkIndex"))
if mibBuilder.loadTexts: vdsx1TrunkReconfigComplete.setDescription(" This notification is sent when the specific trunk successfully reads and incorporates the values from the registry. This is typically done in response to a SET command on any of the Trunk's (or its channel's) read-write parameters")
vdsx1TrunkReconfigError = NotificationType((1, 3, 6, 1, 4, 1, 2338) + (0,8)).setObjects(("VERTICALT1-E1-MIB", "vdsx1TrunkIdentifier"), ("VERTICALT1-E1-MIB", "vdsx1cardSlotNumber"), ("VERTICALT1-E1-MIB", "vdsx1TrunkDeviceNumber"), ("VERTICALT1-E1-MIB", "vdsx1TrunkIndex"))
if mibBuilder.loadTexts: vdsx1TrunkReconfigError.setDescription(" This notification is sent when the specific trunk fails to incorporate the values read from the registry. Typically, the trunk tries to re-read the registry values in response to a SET command on any of the Trunk's (or its channel's) read-write parameters")
vdsx1TrunkLoopbackPayloadOn = NotificationType((1, 3, 6, 1, 4, 1, 2338) + (0,43)).setObjects(("VERTICALT1-E1-MIB", "vdsx1TrunkIdentifier"), ("VERTICALT1-E1-MIB", "vdsx1cardSlotNumber"), ("VERTICALT1-E1-MIB", "vdsx1TrunkDeviceNumber"), ("VERTICALT1-E1-MIB", "vdsx1TrunkIndex"))
if mibBuilder.loadTexts: vdsx1TrunkLoopbackPayloadOn.setDescription(" This notification is sent when the specific trunk enters a payload loopback state. Payload loopback means that the received signal at this interface is looped through the device. Typically the received signal is looped back for re- transmission after it has passed through the device's framing function")
vdsx1TrunkLoopbackPayloadOff = NotificationType((1, 3, 6, 1, 4, 1, 2338) + (0,44)).setObjects(("VERTICALT1-E1-MIB", "vdsx1TrunkIdentifier"), ("VERTICALT1-E1-MIB", "vdsx1cardSlotNumber"), ("VERTICALT1-E1-MIB", "vdsx1TrunkDeviceNumber"), ("VERTICALT1-E1-MIB", "vdsx1TrunkIndex"))
if mibBuilder.loadTexts: vdsx1TrunkLoopbackPayloadOff.setDescription(' This notification is sent when the specific trunk moves from a payload loopback state to a non loopback state.')
vdsx1TrunkLoopbackLineOn = NotificationType((1, 3, 6, 1, 4, 1, 2338) + (0,45)).setObjects(("VERTICALT1-E1-MIB", "vdsx1TrunkIdentifier"), ("VERTICALT1-E1-MIB", "vdsx1cardSlotNumber"), ("VERTICALT1-E1-MIB", "vdsx1TrunkDeviceNumber"), ("VERTICALT1-E1-MIB", "vdsx1TrunkIndex"))
if mibBuilder.loadTexts: vdsx1TrunkLoopbackLineOn.setDescription(' This notification is sent when the specific trunk enters a line loopback state. Under this state the received signal at this interface does not go through the device (minimum penetration) but is looped back out.')
vdsx1TrunkLoopbackLineOff = NotificationType((1, 3, 6, 1, 4, 1, 2338) + (0,46)).setObjects(("VERTICALT1-E1-MIB", "vdsx1TrunkIdentifier"), ("VERTICALT1-E1-MIB", "vdsx1cardSlotNumber"), ("VERTICALT1-E1-MIB", "vdsx1TrunkDeviceNumber"), ("VERTICALT1-E1-MIB", "vdsx1TrunkIndex"))
if mibBuilder.loadTexts: vdsx1TrunkLoopbackLineOff.setDescription(' This notification is sent when the specific trunk goes out of a Line Looped state')
mibBuilder.exportSymbols("VERTICALT1-E1-MIB", vdsx1channelSlotNumber=vdsx1channelSlotNumber, vdsx1TrunkTable=vdsx1TrunkTable, vdsx1channelLocalSubAddress=vdsx1channelLocalSubAddress, vdsx1TrunkYellowClear=vdsx1TrunkYellowClear, vdsx1channelType=vdsx1channelType, vdsx1channelExternalSubAddress=vdsx1channelExternalSubAddress, vdsx1cardType=vdsx1cardType, vdsx1TrunkInterrupt=vdsx1TrunkInterrupt, vdsx1TrunkLoopbackPayloadOff=vdsx1TrunkLoopbackPayloadOff, vdsx1ChannelEntry=vdsx1ChannelEntry, vdsx1channelCallerID=vdsx1channelCallerID, vdsx1CardEntry=vdsx1CardEntry, vdsx1channelIndex=vdsx1channelIndex, vdsx1channelState=vdsx1channelState, vdsx1cardIOPortAddress=vdsx1cardIOPortAddress, vdsx1channelChangePending=vdsx1channelChangePending, vdsx1channelTrunkDeviceNumber=vdsx1channelTrunkDeviceNumber, vdsx1cardRevision=vdsx1cardRevision, vdsx1TrunkStartingChannel=vdsx1TrunkStartingChannel, vdsx1TrunkDChannelSlot=vdsx1TrunkDChannelSlot, vdsx1TrunkStream=vdsx1TrunkStream, vdsx1TrunkBlue=vdsx1TrunkBlue, vdsx1TrunkBlueClear=vdsx1TrunkBlueClear, vdsx1TrunkFraming=vdsx1TrunkFraming, vdsx1TrunkLineBuildOut=vdsx1TrunkLineBuildOut, vdsx1TrunkRedClear=vdsx1TrunkRedClear, vdsx1TrunkLoopbackLineOff=vdsx1TrunkLoopbackLineOff, vdsx1cardDriverVersion=vdsx1cardDriverVersion, vdsx1TrunkIsdnSignalingProtocol=vdsx1TrunkIsdnSignalingProtocol, vdsx1TrunkDChannelDevice=vdsx1TrunkDChannelDevice, vdsx1TrunkDeviceNumber=vdsx1TrunkDeviceNumber, vdsx1TrunkIndex=vdsx1TrunkIndex, vdsx1TrunkRedLED=vdsx1TrunkRedLED, vdsx1channelLocalAddress=vdsx1channelLocalAddress, vdsx1TrunkRed=vdsx1TrunkRed, vdsx1TrunkLoopbackPayloadOn=vdsx1TrunkLoopbackPayloadOn, vdsx1cardReadyLED=vdsx1cardReadyLED, vdsx1TrunkEnabled=vdsx1TrunkEnabled, vdsx1TrunkLoopback=vdsx1TrunkLoopback, vdsx1TrunkSlotNumber=vdsx1TrunkSlotNumber, vdsx1TrunkType=vdsx1TrunkType, vds1=vds1, vdsx1TrunkLineCoding=vdsx1TrunkLineCoding, vdsx1TrunkNumberOfChannels=vdsx1TrunkNumberOfChannels, vdsx1cardDescr=vdsx1cardDescr, vdsx1TrunkMasterPriority=vdsx1TrunkMasterPriority, vertical=vertical, vdsx1ChannelTable=vdsx1ChannelTable, vdsx1channelTrunkIndex=vdsx1channelTrunkIndex, vdsx1TrunkReconfigError=vdsx1TrunkReconfigError, vdsx1TrunkYellowLED=vdsx1TrunkYellowLED, vdsx1TrunkReconfigComplete=vdsx1TrunkReconfigComplete, vdsx1cardErrorLED=vdsx1cardErrorLED, vdsx1TrunkYellow=vdsx1TrunkYellow, vdsx1CardTable=vdsx1CardTable, vdsx1TrunkIfIndex=vdsx1TrunkIfIndex, vdsx1channelExternalAddress=vdsx1channelExternalAddress, vdsx1channelEnabled=vdsx1channelEnabled, vdsx1TrunkChangePending=vdsx1TrunkChangePending, vdsx1TrunkEntry=vdsx1TrunkEntry, vdsx1TrunkIdentifier=vdsx1TrunkIdentifier, vdsx1TrunkLoopbackLineOn=vdsx1TrunkLoopbackLineOn, vdsx1cardSlotNumber=vdsx1cardSlotNumber)

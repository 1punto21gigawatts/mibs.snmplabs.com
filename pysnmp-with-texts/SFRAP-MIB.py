#
# PySNMP MIB module SFRAP-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/SFRAP-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:01:55 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, SingleValueConstraint, ConstraintsIntersection, ConstraintsUnion, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsIntersection", "ConstraintsUnion", "ValueSizeConstraint")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
MibScalar, MibTable, MibTableRow, MibTableColumn, Counter32, NotificationType, ObjectIdentity, IpAddress, iso, Gauge32, ModuleIdentity, internet, NotificationType, Bits, Counter64, MibIdentifier, Integer32, TimeTicks, Unsigned32 = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter32", "NotificationType", "ObjectIdentity", "IpAddress", "iso", "Gauge32", "ModuleIdentity", "internet", "NotificationType", "Bits", "Counter64", "MibIdentifier", "Integer32", "TimeTicks", "Unsigned32")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
private = MibIdentifier((1, 3, 6, 1, 4))
enterprises = MibIdentifier((1, 3, 6, 1, 4, 1))
sync = MibIdentifier((1, 3, 6, 1, 4, 1, 485))
sfrap = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 7))
sfrapSystem = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 7, 1))
sfrapSysTable = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 7, 1, 1))
sfrapSysType = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapSysType.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapSysType.setDescription('A textual description of the system model identifier. for example: SYNC-sfrap')
sfrapSysSoftRev = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapSysSoftRev.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapSysSoftRev.setDescription('Displays the Software Revision of the application code installed in this node.')
sfrapSysHardRev = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapSysHardRev.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapSysHardRev.setDescription('Displays the Hardware Revision of the node.')
sfrapSysNumToDteInstalled = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapSysNumToDteInstalled.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapSysNumToDteInstalled.setDescription('The number of channels (TO-DTE) that are installed.')
sfrapSysNumToDceInstalled = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapSysNumToDceInstalled.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapSysNumToDceInstalled.setDescription('The number of channels (TO-DCE) that are installed.')
sfrapSysNumMaintInstalled = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapSysNumMaintInstalled.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapSysNumMaintInstalled.setDescription('The number of Maintenance ports that are installed.')
sfrapSysName = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 1, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapSysName.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapSysName.setDescription('The user supplied name of the node. This object does not affect operation, but may be useful for network management.')
sfrapSysSerialNo = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 1, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapSysSerialNo.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapSysSerialNo.setDescription('The serial number of the board.')
sfrapSysResetNode = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(321))).clone(namedValues=NamedValues(("reset-node", 321)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: sfrapSysResetNode.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapSysResetNode.setDescription('Command to reset the node. NODE WILL BE OFF-LINE AND USER DATA WILL BE INTERRUPTED FOR APPROXIMATELY 15 SECONDS. ')
sfrapSysAmtMemoryInstalled = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapSysAmtMemoryInstalled.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapSysAmtMemoryInstalled.setDescription('The amount of memory (RAM) installed (in megabytes).')
sfrapSysLocation = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 1, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapSysLocation.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapSysLocation.setDescription('The user supplied location of the node. This object does not affect operation, but may be useful for network management.')
sfrapSysContact = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 1, 1, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapSysContact.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapSysContact.setDescription('The user supplied contact information for the node. This object does not affect operation, but may be useful for network management.')
sfrapSysPrompt = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 1, 1, 15), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapSysPrompt.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapSysPrompt.setDescription('Configurable Command Line Interface (CLI) prompt. CLI is the User Interface protocol used for directly attached VT100 terminal access as well as Remote access via Telnet.')
sfrapSysBootRev = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 1, 1, 16), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapSysBootRev.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapSysBootRev.setDescription('Displays the Software Revision of the Bootstrapping code installed in this node.')
sfrapSysFeatureTable = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 7, 1, 2))
sfrapSysSLIPSupported = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 1, 2, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapSysSLIPSupported.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapSysSLIPSupported.setDescription('Shows whether the unit has SLIP (Serial Line IP) capability. SLIP is a method for out-of-band management that connects through the asynchronous terminal port.')
sfrapSysPPPSupported = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 1, 2, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapSysPPPSupported.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapSysPPPSupported.setDescription('Shows whether the unit has PPP (Point to Point protocol) capability. PPP is a method for out-of-band management that connects through the asynchronous terminal port.')
sfrapSysRDOSupported = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 1, 2, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapSysRDOSupported.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapSysRDOSupported.setDescription('Shows whether the unit has Remote Dial Out capability.')
sfrapSysETHSupported = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 1, 2, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapSysETHSupported.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapSysETHSupported.setDescription('Shows whether the unit has Ethernet capability.')
sfrapSysTKRSupported = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 1, 2, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapSysTKRSupported.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapSysTKRSupported.setDescription('Shows whether the unit has Token Ring capability.')
sfrapSysExtTimSupported = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 1, 2, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapSysExtTimSupported.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapSysExtTimSupported.setDescription('Shows whether the unit has External Timing capability. This is the ability to derive WAN timing from the DTE port.')
sfrapSysBRISupported = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 1, 2, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapSysBRISupported.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapSysBRISupported.setDescription('Shows whether the unit has BRI (ISDN Basic Rate) capability.')
sfrapSysSelDTESupported = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 1, 2, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapSysSelDTESupported.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapSysSelDTESupported.setDescription('Shows whether the unit has a Selectable DTE interface. This being the ability to select amongst various electrical interface formats (V.35, RS449, RS232, etc.) via software.')
sfrapSysMLSupported = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 1, 2, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapSysMLSupported.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapSysMLSupported.setDescription('Shows whether the unit supports MLs (out-of-band management links).')
sfrapSysNumDlcisSupported = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 1, 2, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapSysNumDlcisSupported.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapSysNumDlcisSupported.setDescription('Shows how many DLCIs can be monitored for frame-based statistics. The unit will pass an unlimited number of DLCIs but will only collect statistics on this number (first come first served).')
sfrapSysLTFNumDlcis = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 1, 2, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapSysLTFNumDlcis.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapSysLTFNumDlcis.setDescription('Shows how many DLCIs can be specified in the Long Term Statistics Filter.')
sfrapSysLTFNumProtocols = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 1, 2, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapSysLTFNumProtocols.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapSysLTFNumProtocols.setDescription('Shows how many protocols can be specified in the Long Term Statistics Filter.')
sfrapSysNumUserProtocols = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 1, 2, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapSysNumUserProtocols.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapSysNumUserProtocols.setDescription('Shows how many protocols can be defined by the user. The user configures TCP/UDP ports which can be monitored as protocols. They are available for short term or long term statistics monitoring.')
sfrapSysNumSnmpMgrs = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 1, 2, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapSysNumSnmpMgrs.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapSysNumSnmpMgrs.setDescription('Shows how many SNMP managers can be programmed in the table sfrapCfgSnmpMngrTable. These managers are sent TRAPs if configured to do so.')
sfrapSysNumDlciNames = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 1, 2, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapSysNumDlciNames.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapSysNumDlciNames.setDescription('Shows how many DLCI names can be defined by the user in the table sfrapCfgFrPerfDlciNamesTable.')
sfrapSysHighSpeedSupported = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 1, 2, 16), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapSysHighSpeedSupported.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapSysHighSpeedSupported.setDescription('Shows whether the unit is in high speed mode.')
sfrapConfiguration = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 7, 2))
sfrapCfgMgmtTable = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 7, 2, 1))
sfrapCfgIpTable = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 7, 2, 1, 1))
sfrapCfgIpMyIP = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 1, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgIpMyIP.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgIpMyIP.setDescription('The IP address for this node. This address will be unique to the IP network and is required for in-band or out-of-band ip and SNMP management.')
sfrapCfgIpPeerIP = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 1, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgIpPeerIP.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgIpPeerIP.setDescription('This parameter is not used internally by the unit. It is intended to identify either the device directly connected to the SLIP port or, in Frame Relay applications, the address of the primary network management station. This should always be non-zero.')
sfrapCfgIpMask = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 1, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgIpMask.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgIpMask.setDescription('The IP Subnet Mask (eg 255.255.255.0). This parameter should be consisent with the IP subnet address setting of the external internetworking equipment (router/frad).')
sfrapCfgIpMaxMTU = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgIpMaxMTU.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgIpMaxMTU.setDescription('The Maximum Transmission Unit is the size of the largest IP packet supported (including header). This value should be set to the lowest value supported by any equipment in the transmission path. For Frame Relay management the typical value is 1500. For SLIP management the typical value is 1006.')
sfrapCfgIpChannel = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("slip-port", 2), ("in-band-dlci", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapCfgIpChannel.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgIpChannel.setDescription('This is the method by which IP traffic is being carried. Either via the SLIP port or a DLCI. This is how your InBand Managenent scheme is set up.')
sfrapCfgIpTelnetEnable = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable-telnet", 1), ("disable-telnet", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgIpTelnetEnable.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgIpTelnetEnable.setDescription('Enables/Disables the telnet feature. Valid values are enable-telnet (1) and disable-telnet (2).')
sfrapCfgIpTelnetAutoLogOut = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 5, 10, 30, 60))).clone(namedValues=NamedValues(("autologout-at-15-minutes", 1), ("disable-autologout", 2), ("autologout-at-3-minutes", 3), ("autologout-at-5-minutes", 5), ("autologout-at-10-minutes", 10), ("autologout-at-30-minutes", 30), ("autologout-at-60-minutes", 60)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgIpTelnetAutoLogOut.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgIpTelnetAutoLogOut.setDescription('If Telnet Auto logout is enabled the unit will automatically disconnect from a Telnet session after a period of inactivity (absence of key strokes from remote terminal). (2) disables this feature (1) auto logout after 15 minutes inactivity (3) auto logout after 3 minutes inactivity (5) auto logout after 5 minutes inactivity (10) auto logout after 10 minutes inactivity (30) auto logout after 30 minutes inactivity (60) auto logout after 60 minutes inactivity')
sfrapCfgTftpTable = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 7, 2, 1, 2))
sfrapCfgTftpInitiate = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 1, 2, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: sfrapCfgTftpInitiate.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgTftpInitiate.setDescription('Setting this object to a value that matches the TFTP Password will command the unit to attempt a TFTP file transfer. A TFTP profile including host ip address, dlci value, interface, and file name must first be configured.')
sfrapCfgTftpIpAddress = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 1, 2, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgTftpIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgTftpIpAddress.setDescription('The IP address of the TFTP host with which the unit will attempt to establish a TFTP session when initiated.')
sfrapCfgTftpFilename = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 1, 2, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgTftpFilename.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgTftpFilename.setDescription('The name of the file located on the TFTP host that will be transferred to the unit. Typically this is a product-specific software image that will be programmed into unit FLASH. The unit provides several levels of checking to verify the validity and integrity of this file. Note - depending upon the host, this file name may be case sensitive.')
sfrapCfgTftpInterface = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 1, 2, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("to-dte-interface", 1), ("to-dce-interface", 2), ("slip-interface", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgTftpInterface.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgTftpInterface.setDescription('The physical interface out which the TFTP host is located. This parameter is only required for Piggyback and Bi-directional in-band frame relay managed applications. With Local and Remote in-band and SLIP-based applications the interface is known and Sets to this will be ignored.')
sfrapCfgTftpDlci = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 1, 2, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 63487))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgTftpDlci.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgTftpDlci.setDescription('The local DLCI value on which the TFTP host can be reached. This DLCI should be active prior to initiating the TFTP session. This parameter is only required for Piggyback in-band frame relay managed applications. With Private management (Local, Remote or Bi-directional in-band applications) the DLCI is known and will be reported here (Sets will be ignored). In SLIP-based applications the DLCI value is not applicable and a value of -1 is reported (Sets will be ignored).')
sfrapCfgTftpStatus = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 1, 2, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("inactive", 1), ("requested", 2), ("transferring", 3), ("programming", 4), ("transfer-aborted", 5), ("host-no-reply", 6), ("file-not-found", 7), ("invalid-file", 8), ("corrupt-file", 9), ("successful", 10)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgTftpStatus.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgTftpStatus.setDescription('The status of current or most recent TFTP operation. (1) TFTP inactive, sets to this value will abort the session (2) TFTP requested (3) TFTP transferring (4) TFTP programming FLASH - unit will reset (5) TFTP fail: session aborted by user or error condition (6) TFTP fail: host no reply - verify TFTP profile and host (7) TFTP fail: file not found - verify file name and location (8) TFTP fail: invalid file - file rejected by unit as inappropriate (9) TFTP fail: corrupt file - session terminated due to checksum error (10) TFTP transfer successful and file has been verified')
sfrapCfgTftpNumBytes = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 1, 2, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapCfgTftpNumBytes.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgTftpNumBytes.setDescription("The number of Bytes from the ROM image that have been TFTP'd to the unit")
sfrapCfgSnmpTable = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 7, 2, 1, 3))
sfrapCfgSnmpFrTrap = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 1, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgSnmpFrTrap.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgSnmpFrTrap.setDescription('Controls whether or not the Frame Relay DLCI status change traps are issued. These traps are sfrapDLCIActiveTrap and sfrapDLCIInactiveTrap. When sfrapCfgSnmpFrTrap is enabled (1), a trap will be sent each time an individual DLCI changes status between active and inactive. When sfrapCfgSnmpFrTrap is disabled (2), the traps are not sent.')
sfrapCfgSnmpTrapMuting = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 1, 3, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10080))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgSnmpTrapMuting.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgSnmpTrapMuting.setDescription('Controls whether Traps are Sent or Muted. If traps are Muted then a single trap (#75) will be periodically issued by the unit at the programmed frequency. If Muting is Disabled then the full set of Trap events are reported accordingly. (0) Disable Trap Muting (30-10080) Trap Muting frequency in minutes.')
sfrapCfgSnmpUtilTrapEnable = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 1, 3, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgSnmpUtilTrapEnable.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgSnmpUtilTrapEnable.setDescription('Enables or disables the sending of per-DLCI utilization traps. (1) enable utilization traps (2) disable utilization traps')
sfrapCfgSnmpMgrClearN = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 1, 3, 7), Integer32()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: sfrapCfgSnmpMgrClearN.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgSnmpMgrClearN.setDescription(' Deletes the number of entries in the sfrapCfgSnmpMgrTable indicated by the value. If the value is a positive number the entries will be deleted starting from the first entry. If the value is negative the entries will be deleted starting from the last entry. ')
sfrapCfgSnmpMgrTable = MibTable((1, 3, 6, 1, 4, 1, 485, 7, 2, 1, 3, 2), )
if mibBuilder.loadTexts: sfrapCfgSnmpMgrTable.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgSnmpMgrTable.setDescription("The table of SNMP manager profiles to which traps are sent. In all managed modes an SNMP trap mangager's ip address is required as a minimum. Additionally for Piggyback managed units the DLCI and interface must also be configured appropriately. For Local, Remote and SLIP-based management, the DLCI and interface are implied and need not be configured as part of this profile.")
sfrapCfgSnmpMgrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 7, 2, 1, 3, 2, 1), ).setIndexNames((0, "SFRAP-MIB", "sfrapCfgSnmpMgrIndex"))
if mibBuilder.loadTexts: sfrapCfgSnmpMgrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgSnmpMgrEntry.setDescription("The IP address of a SNMP manager to receive this node's TRAPs.")
sfrapCfgSnmpMgrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 2, 1, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapCfgSnmpMgrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgSnmpMgrIndex.setDescription('The index to the list of SNMP managers receiving TRAPs.')
sfrapCfgSnmpMgrIP = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 2, 1, 3, 2, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgSnmpMgrIP.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgSnmpMgrIP.setDescription("The IP address of a SNMP manager to receive this node's TRAPs. Setting this value to 0.0.0.0 will disable the issuance of traps to the indexed manager.")
sfrapCfgSnmpMgrInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 2, 1, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("to-dte-interface", 1), ("to-dce-interface", 2), ("slip-interface", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgSnmpMgrInterface.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgSnmpMgrInterface.setDescription('The interface out which the indexed trap manager can be reached. This entry is required in Piggyback and Bi-directional in-band managed applications. In Local, Remote and SLIP-based applications, the interface is known and this parameter is ignored. (1) Traps sent out DTE interface for this manager (2) Traps sent out WAN interface for this manager (3) Traps sent out SLIP interface (async maint port) When the node is configured for SLIP, a GET on this MIB object will return slip-interface(3) and a SET of this MIB object to slip-interface(3) is allowed but unnecessary. When the node is not configured for SLIP, this MIB object can be SET to dte-interface(1) or to dce-interface(2); slip-interface(3) would be rejected.')
sfrapCfgSnmpMgrDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 2, 1, 3, 2, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgSnmpMgrDlci.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgSnmpMgrDlci.setDescription('The DLCI out which the indexed trap manager can be reached. This entry is required in Piggyback in-band managed applications. In Private in-band applications the DLCI is known and Sets to this parameter will be ignored. In SLIP mode the DLCI is not applicable, Sets will be ignored and a -1 will be returned as the DLCI value.')
sfrapCfgCommTable = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 7, 2, 1, 4))
sfrapCfgCommMode = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 1, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("vt100", 1), ("slip", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgCommMode.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgCommMode.setDescription("The protocol running on the Maintenance/Comm port (console). Setting this to SLIP mode will automatically disable in-band management if it's enabled. (1) VT100 for directly attached async terminal (2) SLIP - Serial Line IP out-of-band management")
sfrapCfgCommBaud = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 1, 4, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 4, 5, 6))).clone(namedValues=NamedValues(("baud-2400", 2), ("baud-9600", 4), ("baud-19200", 5), ("baud-38400", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgCommBaud.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgCommBaud.setDescription('Asynchronous baud rate for the Maintenance/Comm port (Console). This must be configured to match either the VT100 compatible terminal or the SLIP Terminal Server depending upon the Comm port mode. (2) baud-2400 (4) baud-9600 (5) baud-19200 (6) baud-38400')
sfrapCfgCommDataBits = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 1, 4, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("databits-7", 1), ("databits-8", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgCommDataBits.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgCommDataBits.setDescription('Asynchronous data format for the Maintenance/Comm port (Console). This must be configured to match either the VT100 compatible terminal or the SLIP Terminal Server depending upon the Comm port mode. (1) 7 databits per character (2) 8 databits per character')
sfrapCfgCommStopBits = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 1, 4, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("stopbits-1", 1), ("stopbits-1-5", 2), ("stopbits-2", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgCommStopBits.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgCommStopBits.setDescription('Asynchronous intercharacter protocol for the Maintenance/Comm port (Console). This must be configured to match either the VT100 compatible terminal or the SLIP Terminal Server depending upon the Comm port mode. (1) 1 stopbit (2) 1.5 stopbits (3) 3 stopbits')
sfrapCfgCommParity = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 1, 4, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("no-parity", 1), ("odd-parity", 2), ("even-parity", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgCommParity.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgCommParity.setDescription('Asynchronous parity checking protocol for the Maintenance/Comm port (Console). This must be configured to match either the VT100 compatible terminal or the SLIP Terminal Server depending upon the Comm port mode. (1) no parity (2) odd-parity (3) even-parity')
sfrapCfgCommFlowCtrl = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 1, 4, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("no-flow-control", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgCommFlowCtrl.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgCommFlowCtrl.setDescription('Flow Control for this Communication port. Values are off-flow-control (1).')
sfrapCfgFrDLCITable = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 7, 2, 1, 5))
sfrapCfgFrDLCIMode = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 1, 5, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("inactive", 1), ("local-to-dte", 2), ("remote-to-dce", 3), ("bidirectional", 4), ("piggyback", 5), ("fixedDCE", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgFrDLCIMode.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgFrDLCIMode.setDescription('In-band Frame Relay management mode. A variety of options exist which are differentiated by how PVCs can be provisioned to manage the unit and the resulting impact to the logical processing of Link Management Protocol messages (LMI spoofing and sourcing). The unit is designed to support these management modes even in non-provisioned or failed frame relay networks. This setting also has implications upon how networking protocols such as ARP and InARP are handled by the unit. (1) inactive: in-band management is not enabled (2) local DLCI mode: in-band managed using a private dedicated DLCI accessible via the TO-DTE only. A DLCI value is configured which, through LMI spoofing, will only be visible to the DTE equipment and need not be provisioned on the WAN. All traffic on this DLCI will be terminated by the unit. (3) remote DLCI mode: in-band managed using a private dedicated DLCI accessible via the WAN port only. A DLCI value is configured which, through LMI spoofing, will only be visible from the WAN side and will not be seen by any DTE equipment. All traffic on this DLCI will be terminated by the unit. (4) bidirectional mode: in-band managed using a private dedicated DLCI accessible through either port. A DLCI value is configured which is expected to be fully provisioned in the frame relay network but dedicated to the management function of this particular unit. All traffic on this DLCI will be terminated by the unit. (5) piggyback mode: in-band managed using any DLCI on any interface. A DLCI value is defined that becomes the default DLCI that will be maintained by the unit during network or LMI failure conditions. The unit will terminate and respond accordingly to management and networking data while transparently passing on user data. (6) fixed DCE mode: special mode of operation to support frame relay applications that do not include a switch (frame relay DCE). The unit will independently respond to LMI requests on each interface and will provision the configured DLCI to each Frame Relay DTE device. Except for this, the unit behaves like piggyback.')
sfrapCfgFrDLCIValue = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 1, 5, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 63487))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgFrDLCIValue.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgFrDLCIValue.setDescription('If in-band management is being used this DLCI value should be defined. In all modes of in-band management with the LMI Sourcing feature enabled the unit may provision this DLCI during LMI failure to facilitate management access. In Private modes (Local, Remote, and Bidirectional) this is the dedicated DLCI for management data and address resolution protocols - all other traffic on this DLCI will be discarded. In Piggyback mode this DLCI is treated like all others except during LMI failure sourcing when it may be provisioned by the unit. In Piggyback mode if InARP is enabled on a single DLCI then this value defines that DLCI.')
sfrapCfgFrDLCIEncap = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 1, 5, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("rfc1490", 1), ("rfc1490snap", 2), ("auto", 3), ("cisco", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgFrDLCIEncap.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgFrDLCIEncap.setDescription('This is the protocol used for enacapsulating and formatting ip data for Frame Relay transmission. This setting is specific to management data to and from the unit. (1) RFC1490 - per IETF standard with Network Level Protocol ID (NLPID) set for IP encapsulation. (2) RFC1490 SNAP/IP - per IETF standard with NLPID set for Sub-Network Access Protocol (SNAP). (3) auto - adjusts to either of these encapsulation techniques as required. (4) Cisco - proprietary encapsulation (4-byte header).')
sfrapCfgFrDLCIMgmtDE = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 1, 5, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no-DE-bit-0", 1), ("yes-DE-bit-1", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgFrDLCIMgmtDE.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgFrDLCIMgmtDE.setDescription('Provides user control over the state of the Frame Relay Discard Eligibility bit of all management frames generated by the unit. Frames marked DE=1 are more likely to be dropped in a congested Frame Relay network than those that are DE=0. Heavily congested circumstances can cause both to be dropped. Additionally, frames marked DE=0 may get re-marked to DE=1 by intervening equipment. (1) DE bit cleared to 0: frame is not discard eligible (2) DE bit set to 1: frame is discard eligible')
sfrapCfgAppTable = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 7, 2, 2))
sfrapCfgAppCircuitId = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 2, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgAppCircuitId.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgAppCircuitId.setDescription('Alphanumeric circuit identifier may be provided by the service provider for reference or assigned arbitrarily per user requirements.')
sfrapCfgAppType = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dedicated", 1), ("frame-relay", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgAppType.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgAppType.setDescription('This unit provides many features specifically adapted to Frame Relay transmission links; this includes diagnostic utilities, statistical analysis, protocol trends, quality of service reporting, and in-band SNMP management. If the unit will be operating in a Frame Relay network the Application Type must be set to Frame Relay to enable these features. To operate in a non-Frame Relay network or to bypass this feature set the unit may be placed in Dedicated mode and will emulate a more familiar DSU/CSU. Note - changing this value will automatically change the Application Format setting and vice versa. (1) dedicated: protocol-independent transparent DSU/CSU (2) Frame Relay: Frame and protocol aware DSU/CSU')
sfrapCfgAppFormat = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 2, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("cbo", 1), ("hdlc", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgAppFormat.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgAppFormat.setDescription('Refer to Application Type. Frame Relay is based upon HDLC framing. To operate in a Frame Relay application the Format must be set for HDLC. To operate in a protocol-independent application the Format must be set for Constant Bit Operation (CBO). Note - changing this value will automatically change the Application Type setting and vice versa (1) CBO: protocol-independent transparent DSU/CSU (2) HDLC: Frame and protocol aware DSU/CSU')
sfrapCfgAppLpbkTimeout = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 2, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1440))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgAppLpbkTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgAppLpbkTimeout.setDescription('The length of time a service-impacting loopback or diagnostic utility may run before automatically returning to normal operation. This setting will override any alternatively timed tests (such as VBERT). (0) Loopbak Timeout Disabled (1-1440) Loopback Timeout')
sfrapCfgAppTxClkmode = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 2, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("normal-timing", 1), ("invert-TO-DCE", 2), ("invert-TO-DTE", 3), ("invert-timing", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgAppTxClkmode.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgAppTxClkmode.setDescription('This MIB object is being obsoleted. The mode in which the TO-DTE and TO-DCE Transmit clocks are set to. The transmit clocks can either be normal or inverted. Here are the choices: 1:Normal-timing both TO-DTE & TO-DCE are set normal 2:Invert-TO-DCE the TO-DCE clock is inverted 3:Invert-TO-DTE the TO-DTE clock is inverted 4:Invert-timing both TO-DTE & TO-DCE are inverted.')
sfrapCfgAppTxtiming = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 2, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("loop-1", 1), ("loop-2", 2), ("source-tt", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgAppTxtiming.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgAppTxtiming.setDescription('Serial Transmit Timing mode. Loop-1 (1) uses the clock returned from the TO-DTE (TT/TCE) to sample tx data, Loop-2 (2) uses the clock (ST/TC) generated by the node to sample tx data. Sourced-tt (3) occurs when the unit is configured for Loop-1 and the clock returned from the TO-DTE (TT/TCE)is not present. The unit will use the (ST/TC) to sample tx data.')
sfrapCfgAppOperationMode = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 2, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("tap", 1), ("inband", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgAppOperationMode.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgAppOperationMode.setDescription('Describes the Operational Mode of the SFRAP: (1) cut-through used to place unit in cut-thru (2) inband used to place unit in inband.')
sfrapCfgAppCutthruTimeout = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 2, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1440))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgAppCutthruTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgAppCutthruTimeout.setDescription('The amount of time Cuthtru mode may run before timing out and automatically terminating. The timeout is in minutes and a value of 0 means no timeout.')
sfrapCfgAppPerfBuffLimit = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 2, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 512))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgAppPerfBuffLimit.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgAppPerfBuffLimit.setDescription('This value controls the throttling mechanism used to determine the optimum level of statistical processing versus manageability of the unit. The lower the value (1 - 128), the unit becomes more responsive to management commands during very heavy utilization at the possible expense of statistical accuracy. The larger the value (129 - 512), the more accurate the SFRAP performs statistical analysis of the frames but management may seem slow or unresponsive during periods of very heavy link utilization. NOTE: A value of 0 disables statistical processing entirely.')
sfrapCfgDteTable = MibTable((1, 3, 6, 1, 4, 1, 485, 7, 2, 4), )
if mibBuilder.loadTexts: sfrapCfgDteTable.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgDteTable.setDescription('The table of DTE port configurations.')
sfrapCfgDteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 7, 2, 4, 1), ).setIndexNames((0, "SFRAP-MIB", "sfrapCfgDteIndex"))
if mibBuilder.loadTexts: sfrapCfgDteEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgDteEntry.setDescription('A configuration entry for a DTE port.')
sfrapCfgDteIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 2, 4, 1, 99), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("to-dte", 1), ("to-dce", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapCfgDteIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgDteIndex.setDescription('Selects which DTE port.')
sfrapCfgDteIntfType = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 2, 4, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5))).clone(namedValues=NamedValues(("intf-v35", 3), ("intf-rs449", 4), ("intf-x21", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapCfgDteIntfType.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgDteIntfType.setDescription('Gets the electrical interface for the DTE port.')
sfrapCfgDteTxClockMode = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 2, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clock-normal", 1), ("clock-invert", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgDteTxClockMode.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgDteTxClockMode.setDescription('This selection controls how the unit internally latches the transmit data from the DTE. Normal will sample data with the rising edge of the selected TX Clock, Invert will sample data with the falling edge of the selected TX Clock. The TX Clock is selected using CfgDteTiming. This clock invertion is most useful when loop-2 timing is used - particularly at higher rates and with long cable runs. Only in rare circumstances will clock-invert be used with loop-1 timing. If the DTE Interface TX statistics are indicating excessive crc errors or aborts then changing this setting may have some benefit. (1) normal (2) invert')
sfrapCfgDteRxClockMode = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 2, 4, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("clock-normal", 1), ("clock-invert", 2), ("clock-auto", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgDteRxClockMode.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgDteRxClockMode.setDescription('Clock-normal samples data with the rising edge of the selected rx clock, clock-invert samples data with the falling edge of the selected rx clock,auto-sense forces hardware automated clock selection. The rx clock is selected using CfgDteTiming. This clock invertion is most useful when loop-2 timing is used. Only in rare circumstances will clock-invert (2) be used with loop-1 timing. (3)Auto-sense can only be used on the TO-DTE interface. Auto-sense automatically determines what kind of clocking to use on the TO-DTE interface. THIS OBJECT IS OBSOLETE ON THE TO-DCE INTERFACE')
sfrapCfgDteRtsC = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 2, 4, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("signal-assumed-active", 1), ("signal-monitored", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgDteRtsC.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgDteRtsC.setDescription("Controls the reporting of the status of the To-DTE port's Request to Send (RTS) and Control (C) control signals, specifically the generation of traps in response to control signal state changes. If Signal Assumed Active, the unit will ignore the actual status and always report this signal Active. If Signal Monitored, the unit will reflect the status as driven by the To-DTE; as such, Traps will be generated due to change of state (these may be useful for a network manager's assessment of interface status. (1) Signal Assumed Active (2) Signal Monitored")
sfrapCfgFrTable = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 7, 2, 5))
sfrapCfgFrAddrLen = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 5, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("twobytes", 1), ("threebytes", 2), ("fourbytes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgFrAddrLen.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgFrAddrLen.setDescription('Defines the size of the DLCI address field of the Frame Relay header. This setting must correspond to the Frame Relay transmission format; typically Two bytes. (1) two byte DLCI address field (2) three byte DLCI address field (3) four byte DLCI address field')
sfrapCfgFrCrcMode = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 5, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("discard", 1), ("passthru", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgFrCrcMode.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgFrCrcMode.setDescription('This defines the manner in which the unit handles HDLC protocol errors (crc errors) in a Frame Relay application. If Discard is selected the unit will respond to an errored frame by aborting the frame if transmission has begun; or simply discarding it if transmission has not begun. If Passthru is selected the unit will transmit the entire frame but will place an incorrect crc in it to preserve the error indication. (1) discard (2) passthru')
sfrapCfgFrLmiType = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 5, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("annexd", 1), ("annexa", 2), ("type1", 3), ("autosense", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgFrLmiType.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgFrLmiType.setDescription('The LMI type used in a Frame Relay application. This setting must match the attached Frame Relay device configuration. Annex-A and Annex-D use DLCI 0, and Type 1 uses DLCI 1023. Type 1 is alternatively referred to as Cisco, Group of four, or simply LMI. Annex-D may be referred to as ANSI T1.617. Annex-A may be referred to as ITU or CCITT Q.933. Auto-sense will either use the most recently detected LMI type or, in the absence of any LMI, will attempt to instigate LMI communications using each protocol. (1) Annnex-A: conforms to ITU (CCITT) Q.933 annex A (2) Annnex-D: conforms to ANSI T1.617 annex D (3) Type 1: conforms to the original LMI as developed by the Group of Four (4) Auto-sense: unit will attempt to detect and synchronize to the LMI type of the attached equipment.')
sfrapCfgFrLmiInactivityTimeout = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 5, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgFrLmiInactivityTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgFrLmiInactivityTimeout.setDescription('Timer used by the unit to determine that an attached device is not participating in the LMI protocol and that the unit should attempt to source LMI. This timer also controls the length of time that the LMI sourcing state machine remains in a particular state as it attempts to locate an LMI peer. (0) LMI Sourcing disabled (2-255) LMI Inactivity timeout')
sfrapCfgFrLmiKeepaliveTimeout = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 5, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgFrLmiKeepaliveTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgFrLmiKeepaliveTimeout.setDescription('Timer used by the unit to determine the frequency at which Status Enquiries are issued during LMI sourcing states where the unit is emulating a Frame Relay DTE device. (2-255) length of time between sending enquiries (in seconds)')
sfrapCfgFrAddrResMode = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 5, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("inactive", 1), ("arp", 2), ("inarp", 3), ("both", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgFrAddrResMode.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgFrAddrResMode.setDescription('Enable ARP (2), INARP (3), both (4), or neither (1).')
sfrapCfgFrAddrResDlcis = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 5, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("single", 1), ("multiple", 2), ("todcemulti", 3), ("todtemulti", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgFrAddrResDlcis.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgFrAddrResDlcis.setDescription('Address Resolution Dlcis determines which dlcis are used for address resolution. The choices include using the configured management dlci only (1), all dlcis (2), all dlcis on the To-DCE port (3) or all dlcis on the To-DTE port (4). In the last two cases, the management dlci is used on the other port. Multiple DLCI support only applies to piggyback mode; in other management modes, only the configured management dlci is used.')
sfrapCfgFrAddrResInarpTimer = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 5, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 86400))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgFrAddrResInarpTimer.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgFrAddrResInarpTimer.setDescription('The frequency of INARP requests in seconds from 5 seconds to 86400 seconds (24 hours).')
sfrapCfgFrLmiFullStatus = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 5, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3600))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgFrLmiFullStatus.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgFrLmiFullStatus.setDescription("Timer used by the unit to determine if an LMI Full Status Report is missing. In the absence of a Full Status report for the duration defined by this timer, the unit will declared all DLCI's status INACTIVE and begin logging down time. Data passage is not interfered with. (0) Full Status Timer is disabled (20-3600) Full Status Report Timeout in seconds.")
sfrapCfgVnipTable = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 7, 2, 6))
sfrapCfgVnipMode = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 6, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("inactive", 1), ("to-dte", 2), ("to-dce", 3), ("both", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgVnipMode.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgVnipMode.setDescription("This setting configures the unit for VNIP topology support on a per-interface basis. Establishing a VNIP topology is a fundamental prerequisite to applying the VNIP feature set which includes PVC-based delay measurement, diagnostics, and congestion monitoring. With VNIP enabled on an interface the unit will attempt to locate VNIP peers out that port. As peers are discovered and logged the unit will report the topology it has learned on its opposite interface. If VNIP is inactive on one interface it will not engage in any VNIP dialog; however it will continue to listen for topology messages on the inactive interface and will reflect these messages out the opposite interface if VNIP is enabled. With VNIP inactive on both interfaces the unit will transparently pass all VNIP messages. The topology database includes ip addresses, DLCI values, and the number of VNIP hops in between. (1) Topology Inactive: VNIP messages pass through unit (2) Topology Enabled on TO-DTE only: unit logs VNIP peers seen out the TO-DTE interface. Unit listens for topology reports from the WAN but doesn't generate any towards the WAN. Will report learned WAN topology towards the TO-DTE. (3) Topology Enabled on WAN only: unit logs VNIP peers seen out the WAN interface. Unit listens for topology reports from the TO-DTE but doesn't generate any towards the TO-DTE. Will report learned TO-DTE topology towards the WAN. (4) Topolgy Enabled on Both TO-DTE and WAN: Unit logs VNIP peers seen out both interfaces and generates TO-DTE topolgy reports towards the WAN and vice versa.")
sfrapCfgVnipInitTimer = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 6, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 86400))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgVnipInitTimer.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgVnipInitTimer.setDescription('VNIP peer to peer communications are initiated following the detection of a VNIP Hello message. The unit will periodically issue this message out interfaces that have VNIP enabled until a Hello response is received. Following the reception of the Hello response, the unit will stop issuing Hello messahges on that DLCI/interface and generate periodic topology reports at the VNIP Keep Alive frequency. The unit will generate periodic Hello messages, at the InitTimer frequency if no Hello responses are ever detected or a topology message not been detected within the time period defined by the VNIP Inactivity timer. (5-86400) VNIP Hello frequency (in seconds)')
sfrapCfgVnipTxTimer = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 6, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 86400))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgVnipTxTimer.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgVnipTxTimer.setDescription('The frequency of hello messages sent to neighbor(s) in seconds from 5 seconds to 86400 seconds (24 hours).')
sfrapCfgVnipRxTimer = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 6, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 86400))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgVnipRxTimer.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgVnipRxTimer.setDescription('The timeout on receiving a hello message from a neighbor in seconds from 5 seconds to 86400 seconds (24 hours).')
sfrapCfgVnipTransitDelayFrequency = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 6, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(15, 86400))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgVnipTransitDelayFrequency.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgVnipTransitDelayFrequency.setDescription('Transit Delay measurements may be enabled between any DLCI peers that have been logged through the topology protocol. Delay messages are issued at this frequency and results are recorded. Transit delay measures the round-trip network delay between two VNIP peers (internal unit latencies are not part of the measurement). Traps may be optionally generated if a delay threshold is exceeded. (15-86400): Transit Delay message frequency (in seconds)')
sfrapCfgTransitDelayTable = MibTable((1, 3, 6, 1, 4, 1, 485, 7, 2, 6, 20), )
if mibBuilder.loadTexts: sfrapCfgTransitDelayTable.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgTransitDelayTable.setDescription("The table defining the transit delay measurement profile for each of the learned VNIP peers. As peers are located and logged into the topology database, a default transit delay profile is assumed. The default is to enable transit delay to all hops located out the interface. A DLCI's transit delay profile cannot be modified unless the DLCI has been discovered through the VNIP topology protocol.")
sfrapCfgTransitDelayEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 7, 2, 6, 20, 1), ).setIndexNames((0, "SFRAP-MIB", "sfrapCfgTransitDelayInterface"), (0, "SFRAP-MIB", "sfrapCfgTransitDelayDlciValue"))
if mibBuilder.loadTexts: sfrapCfgTransitDelayEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgTransitDelayEntry.setDescription("A VNIP Transit Delay configuration entry for a particular DLCI on a particular interface. A DLCI's transit delay profile cannot be modified unless the DLCI has been discovered through the VNIP topology protocol")
sfrapCfgTransitDelayInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 2, 6, 20, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("to-dte-interface", 1), ("to-dce-interface", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgTransitDelayInterface.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgTransitDelayInterface.setDescription('The interface being configured for VNIP Transit Delay, either to-dte-interface (1) or to-dce-interface (2). This table is indexed by {interface,dlci}.')
sfrapCfgTransitDelayDlciValue = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 2, 6, 20, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgTransitDelayDlciValue.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgTransitDelayDlciValue.setDescription('This is the DLCI being configured for VNIP Transit Delay. If topology is enabled, each interface will contain a database of VNIP peers organized by DLCI value and Number of Hops.')
sfrapCfgTransitDelayNumHops = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 2, 6, 20, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgTransitDelayNumHops.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgTransitDelayNumHops.setDescription('VNIP topolgy may include multiple units on a given DLCI/interface. The topology logs the number of intermediate VNIP peers between units (Hops). This setting determines which peers on a DLCI are participating in delay measurements. (0) All hops (1-254) individually addressable delay measurement between any two peers. (255) Furthest hop only')
sfrapCfgTransitDelayRcvSummaryCancel = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 2, 6, 20, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable-rsc", 1), ("disable-rsc", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgTransitDelayRcvSummaryCancel.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgTransitDelayRcvSummaryCancel.setDescription("Controls the Receive Summary Cancellation feature of VNIP Transit Delay on this interface/DLCI. Every Transit Delay measurement exchange includes a follow-up message from the initiator with the delay results. If RSC is enabled, a unit will log results based upon this summary message and will not issue its next scheduled delay measurement. With RSC disabled, the unit will not use the summary message and will always issue its regularly scheduled message based on the delay frequency timer. The purpose of this feature is to reduce traffic introduced by VNIP. In a typical peer-to-peer transit delay measurement where both ends are concurrently conducting transit delay measurements it's recommended that one end have RSC enabled and one end disabled.")
sfrapCfgTransitDelayThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 2, 6, 20, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 86400000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgTransitDelayThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgTransitDelayThreshold.setDescription('Specifies a transit delay threshold for this DLCI/interface. When the transit delay exceeds the threshold, a TRAP is sent. The threshold may be set from one millisecond to 24 hours. A value of 0 will prevent a TRAP from being sent. (0): Transit delay threshold trap disabled for this DLCI/interface (1-86400000): delay threshhold. Any delay measurements exceeding this result will generate a trap.')
sfrapCfgTDDeleteTable = MibTable((1, 3, 6, 1, 4, 1, 485, 7, 2, 6, 21), )
if mibBuilder.loadTexts: sfrapCfgTDDeleteTable.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgTDDeleteTable.setDescription('The table allows the user to disable transit delay measurements for a specific DLCI on a particular interface.')
sfrapCfgTDDeleteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 7, 2, 6, 21, 1), ).setIndexNames((0, "SFRAP-MIB", "sfrapCfgTDDeleteInterface"))
if mibBuilder.loadTexts: sfrapCfgTDDeleteEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgTDDeleteEntry.setDescription('Disables VNIP Transit Delay for a particular interface and DLCI.')
sfrapCfgTDDeleteInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 2, 6, 21, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("to-dte-interface", 1), ("to-dce-interface", 2))))
if mibBuilder.loadTexts: sfrapCfgTDDeleteInterface.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgTDDeleteInterface.setDescription('Transit delay can be disabled for a given DLCI on either interface. This indexes the interface. Setting this index and the associated DLCI index will disable transit delay on that combination.')
sfrapCfgTDDeleteDlciValue = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 2, 6, 21, 1, 2), Integer32()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: sfrapCfgTDDeleteDlciValue.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgTDDeleteDlciValue.setDescription('The DLCI chosen to be deleted from the specified interface-side of the VNIP Transit Delay configuration table. This table is indexed by {interface}. To delete an entry in the sfrapCfgTransitDelayTable, specify the interface as the index and set the dlci.')
sfrapCfgTransitDelayTableClear = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 6, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("clear-table", 1)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: sfrapCfgTransitDelayTableClear.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgTransitDelayTableClear.setDescription('The sfrapCfgTransitDelayTable is cleared. (1) clear the table ')
sfrapCfgFrPerf = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 7, 2, 7))
sfrapCfgFrPerfDlciNamesTable = MibTable((1, 3, 6, 1, 4, 1, 485, 7, 2, 7, 1), )
if mibBuilder.loadTexts: sfrapCfgFrPerfDlciNamesTable.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgFrPerfDlciNamesTable.setDescription('This table allows the user to configure DLCI specific parameters such as Names, CIR, and EIR. Additionally, any DLCIs configured with these parameters will be added into the Short Term statistics database next time its cleared.')
sfrapCfgFrPerfDlciNamesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 7, 2, 7, 1, 1), ).setIndexNames((0, "SFRAP-MIB", "sfrapCfgFrPerfDlciNamesDlciValue"))
if mibBuilder.loadTexts: sfrapCfgFrPerfDlciNamesEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgFrPerfDlciNamesEntry.setDescription('A table entry indexed by DLCI, containing a DLCI, a DLCI name, a CIR, and how the CIR value was obtained.')
sfrapCfgFrPerfDlciNamesDlciValue = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 2, 7, 1, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgFrPerfDlciNamesDlciValue.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgFrPerfDlciNamesDlciValue.setDescription("A DLCI selected for customized configuration and to be added to short term statistics collection (if it wasn't already there).")
sfrapCfgFrPerfDlciNamesDlciName = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 2, 7, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgFrPerfDlciNamesDlciName.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgFrPerfDlciNamesDlciName.setDescription('A user-specifiable name for an individual DLCI.')
sfrapCfgFrPerfDlciNamesCirValue = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 2, 7, 1, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgFrPerfDlciNamesCirValue.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgFrPerfDlciNamesCirValue.setDescription('The CIR value for an individual DLCI. This value is used in the calculation utilization as a percentage of CIR. If the CIR is reported in the LMI message then the reported value will override this configured entry. In the absence of LMI CIR and a configured CIR, the unit will assume that teh CIR is the DTE Line Rate.')
sfrapCfgFrPerfDlciNamesCirType = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 2, 7, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("cir-acquired-from-lmi", 1), ("cir-configured-by-user", 2), ("cir-is-datarate", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapCfgFrPerfDlciNamesCirType.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgFrPerfDlciNamesCirType.setDescription('The source of the CIR value for this DLCI. If CIR for a DLCI is part of the LMI message then this LMI supplied CIR will override any defined CIR. If CIR is not part of LMI and has not been explicitly defined by the user it will default to the TO-DTE Line Rate. (1) CIR reported in LMI Full Status message (2) CIR configured by user (3) CIR defaulted to TO-DTE Line Rate')
sfrapCfgFrPerfDlciNamesUtilThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 2, 7, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgFrPerfDlciNamesUtilThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgFrPerfDlciNamesUtilThreshold.setDescription("The threshold for generating a utilization threshold trap as a percentage of the CIR. If the utilization percentage is above this threshold for more than sfrapCfgFrPerfDlciUtilThreshold number of sfrapCfgFrPerfTimersSTInterval's a sfrapPvc(Rx/Tx)UtilizationExceeded trap will be issued. If the If the utilization percentage falls below this threshold for more than sfrapCfgFrPerfDlciUtilThreshold number of sfrapCfgFrPerfTimersSTInterval's a sfrapPvc(Rx/Tx)UtilizationExceeded trap will be issued.")
sfrapCfgFrPerfDlciNamesEirValue = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 2, 7, 1, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgFrPerfDlciNamesEirValue.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgFrPerfDlciNamesEirValue.setDescription('The EIR value for an individual DLCI. In the absence of a configured EIR, the unit will assume that the EIR is the DTE Line Rate.')
sfrapCfgFrPerfDlciNamesDelete = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 7, 2), Integer32()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: sfrapCfgFrPerfDlciNamesDelete.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgFrPerfDlciNamesDelete.setDescription('Setting this object with a specific DLCI value will remove the DLCI form the DLCI-specific parameters database.')
sfrapCfgFrPerfTimers = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 7, 2, 7, 3))
sfrapCfgFrPerfTimersSTInterval = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 7, 3, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(3, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgFrPerfTimersSTInterval.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgFrPerfTimersSTInterval.setDescription('The interval in seconds to collect short term statistics before moving the current counts into the previous counts and starting current from zeros. The range is 3 to 60 seconds.')
sfrapCfgFrPerfTimersLTInterval = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 7, 3, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(4, 3600))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgFrPerfTimersLTInterval.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgFrPerfTimersLTInterval.setDescription('Long term statistics maintain 96 contiguous intervals of configurable protocol per DLCI statistics. This value is the window size of each interval. Adjusting this value will change the overall length of time that the 96 intervals will span. (4-3600): long term statsistics collection interval')
sfrapCfgFrPerfUserProtocolsTable = MibTable((1, 3, 6, 1, 4, 1, 485, 7, 2, 7, 4), )
if mibBuilder.loadTexts: sfrapCfgFrPerfUserProtocolsTable.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgFrPerfUserProtocolsTable.setDescription('This table allows the user to select TCP/UDP ports for statistics collection. Tx and Rx byte counts will collected on the specified ports. These ports are selectable as protocols in the long term statistics filter and are displayed with the other protocols in the short term statistics.')
sfrapCfgFrPerfUserProtocolsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 7, 2, 7, 4, 1), ).setIndexNames((0, "SFRAP-MIB", "sfrapCfgFrPerfUserProtocolsIndex"))
if mibBuilder.loadTexts: sfrapCfgFrPerfUserProtocolsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgFrPerfUserProtocolsEntry.setDescription('An index and TCP/UDP port number pair.')
sfrapCfgFrPerfUserProtocolsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 2, 7, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapCfgFrPerfUserProtocolsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgFrPerfUserProtocolsIndex.setDescription('An index. Beginning with index 1, the range is defined in SysNumUserProtocols')
sfrapCfgFrPerfUserProtocolsPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 2, 7, 4, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgFrPerfUserProtocolsPortNum.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgFrPerfUserProtocolsPortNum.setDescription('Tx and Rx byte counts will be collected on the user-specifiable TCP/UDP port number. (0) port not defined (1-65535): IP TCP/UDP protocol port number.')
sfrapCfgFrPerfLTDlciFilterTable = MibTable((1, 3, 6, 1, 4, 1, 485, 7, 2, 7, 5), )
if mibBuilder.loadTexts: sfrapCfgFrPerfLTDlciFilterTable.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgFrPerfLTDlciFilterTable.setDescription('Long term statistics can only be collected on a limited number of DLCIs. The value of SysLTFNumDlcis defines the maximum number of DLCIs that can be included in the Long Term Statistics. Once one or more DLCIs are added to Long Term Stats, the user may assign a set of protocols that will be monitored across all of the Long Term DLCIs.')
sfrapCfgFrPerfLTDlciFilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 7, 2, 7, 5, 1), ).setIndexNames((0, "SFRAP-MIB", "sfrapCfgFrPerfLTDlciFilterIndex"))
if mibBuilder.loadTexts: sfrapCfgFrPerfLTDlciFilterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgFrPerfLTDlciFilterEntry.setDescription('An index and DLCI number pair.')
sfrapCfgFrPerfLTDlciFilterIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 2, 7, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapCfgFrPerfLTDlciFilterIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgFrPerfLTDlciFilterIndex.setDescription('An index. Beginning with index 1, the maximum is defined by the value of SysLTFNumDlcis.')
sfrapCfgFrPerfLTDlciFilterDlciNum = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 2, 7, 5, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgFrPerfLTDlciFilterDlciNum.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgFrPerfLTDlciFilterDlciNum.setDescription('Setting a DLCI value here will add that DLCI into the Long term statistics database (associated with its index) and it will be monitored for the protocol activity defined in the Long Term Protocol filter.')
sfrapCfgFrPerfLTProtocolFilterTable = MibTable((1, 3, 6, 1, 4, 1, 485, 7, 2, 7, 6), )
if mibBuilder.loadTexts: sfrapCfgFrPerfLTProtocolFilterTable.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgFrPerfLTProtocolFilterTable.setDescription('Long term statistics can only be collected on a limited number of protocols. The maximum number of Long Term Protoocls are defined by SysLTFNumProtocols. This table allows the user to configure those protocols.')
sfrapCfgFrPerfLTProtocolFilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 7, 2, 7, 6, 1), ).setIndexNames((0, "SFRAP-MIB", "sfrapCfgFrPerfLTProtocolFilterIndex"))
if mibBuilder.loadTexts: sfrapCfgFrPerfLTProtocolFilterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgFrPerfLTProtocolFilterEntry.setDescription('An index and protocol pair.')
sfrapCfgFrPerfLTProtocolFilterIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 2, 7, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapCfgFrPerfLTProtocolFilterIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgFrPerfLTProtocolFilterIndex.setDescription('An index. Beginning with index 1, the maximum is defined by the value of SysLTFNumProtocols.')
sfrapCfgFrPerfLTProtocolFilterProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 2, 7, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 13, 14, 15, 16, 21, 22, 29, 30, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, -1))).clone(namedValues=NamedValues(("ip-tx-bc", 1), ("ip-rx-bc", 2), ("tcp-ip-tx-bc", 3), ("tcp-ip-rx-bc", 4), ("ftp-tcp-ip-tx-bc", 5), ("ftp-tcp-ip-rx-bc", 6), ("telnet-tcp-ip-tx-bc", 7), ("telnet-tcp-ip-rx-bc", 8), ("smtp-tcp-ip-tx-bc", 9), ("smtp-tcp-ip-rx-bc", 10), ("http-tcp-ip-tx-bc", 13), ("http-tcp-ip-rx-bc", 14), ("netbios-ssn-tcp-ip-tx-bc", 15), ("netbios-ssn-tcp-ip-rx-bc", 16), ("udp-ip-tx-bc", 21), ("udp-ip-rx-bc", 22), ("tftp-udp-ip-tx-bc", 29), ("tftp-udp-ip-rx-bc", 30), ("netbios-dgm-udp-ip-tx-bc", 33), ("netbios-dgm-udp-ip-rx-bc", 34), ("snmp-udp-ip-tx-bc", 35), ("snmp-udp-ip-rx-bc", 36), ("snmptrap-udp-ip-tx-bc", 37), ("snmptrap-udp-ip-rx-bc", 38), ("rip-udp-ip-tx-bc", 39), ("rip-udp-ip-rx-bc", 40), ("icmp-ip-tx-bc", 41), ("icmp-ip-rx-bc", 42), ("echorep-icmp-ip-tx-bc", 43), ("echorep-icmp-ip-rx-bc", 44), ("dest-unr-icmp-ip-tx-bc", 45), ("dest-unr-icmp-ip-rx-bc", 46), ("src-quench-icmp-ip-tx-bc", 47), ("src-quench-icmp-ip-rx-bc", 48), ("redirect-icmp-ip-tx-bc", 49), ("redirect-icmp-ip-rx-bc", 50), ("echoreq-icmp-ip-tx-bc", 51), ("echoreq-icmp-ip-rx-bc", 52), ("time-excd-icmp-ip-tx-bc", 53), ("time-excd-icmp-ip-rx-bc", 54), ("param-prob-icmp-ip-tx-bc", 55), ("param-prob-icmp-ip-rx-bc", 56), ("timestamp-req-icmp-ip-tx-bc", 57), ("timestamp-req-icmp-ip-rx-bc", 58), ("timestamp-rep-icmp-ip-tx-bc", 59), ("timestamp-rep-icmp-ip-rx-bc", 60), ("addr-mask-req-icmp-ip-tx-bc", 61), ("addr-mask-req-icmp-ip-rx-bc", 62), ("addr-mask-rep-icmp-ip-tx-bc", 63), ("addr-mask-rep-icmp-ip-rx-bc", 64), ("pkt-too-big-icmp-ip-tx-bc", 65), ("pkt-too-big-icmp-ip-rx-bc", 66), ("gp-mem-query-icmp-ip-tx-bc", 67), ("gp-mem-query-icmp-ip-rx-bc", 68), ("gp-mem-report-icmp-ip-tx-bc", 69), ("gp-mem-report-icmp-ip-rx-bc", 70), ("gp-mem-reduct-icmp-ip-tx-bc", 71), ("gp-mem-reduct-icmp-ip-rx-bc", 72), ("ospf-ip-tx-bc", 73), ("ospf-ip-rx-bc", 74), ("other-ip-tx-bc", 75), ("other-ip-rx-bc", 76), ("ipx-tx-bc", 77), ("ipx-rx-bc", 78), ("spx-ipx-tx-bc", 79), ("spx-ipx-rx-bc", 80), ("ncp-ipx-tx-bc", 81), ("ncp-ipx-rx-bc", 82), ("sap-ipx-tx-bc", 83), ("sap-ipx-rx-bc", 84), ("rip-ipx-tx-bc", 85), ("rip-ipx-rx-bc", 86), ("netbios-ipx-tx-bc", 87), ("netbios-ipx-rx-bc", 88), ("other-ipx-tx-bc", 89), ("other-ipx-rx-bc", 90), ("arp-tx-bc", 91), ("arp-rx-bc", 92), ("arp-req-tx-bc", 93), ("arp-req-rx-bc", 94), ("arp-rep-tx-bc", 95), ("arp-rep-rx-bc", 96), ("rarp-req-tx-bc", 97), ("rarp-req-rx-bc", 98), ("rarp-rep-tx-bc", 99), ("rarp-rep-rx-bc", 100), ("inarp-req-tx-bc", 101), ("inarp-req-rx-bc", 102), ("inarp-rep-tx-bc", 103), ("inarp-rep-rx-bc", 104), ("sna-tx-bc", 105), ("sna-rx-bc", 106), ("sna-subarea-tx-bc", 107), ("sna-subarea-rx-bc", 108), ("sna-periph-tx-bc", 109), ("sna-periph-rx-bc", 110), ("sna-appn-tx-bc", 111), ("sna-appn-rx-bc", 112), ("sna-netbios-tx-bc", 113), ("sna-netbios-rx-bc", 114), ("cisco-tx-bc", 115), ("cisco-rx-bc", 116), ("other-tx-bc", 117), ("other-rx-bc", 118), ("user-defined-1-tx-bc", 119), ("user-defined-1-rx-bc", 120), ("user-defined-2-tx-bc", 121), ("user-defined-2-rx-bc", 122), ("user-defined-3-tx-bc", 123), ("user-defined-3-rx-bc", 124), ("user-defined-4-tx-bc", 125), ("user-defined-4-rx-bc", 126), ("thru-byte-tx-bc", 127), ("thru-byte-rx-bc", 128), ("thru-frame-tx-c", 129), ("thru-frame-rx-c", 130), ("thru-fecn-tx-c", 131), ("thru-fecn-rx-c", 132), ("thru-becn-tx-c", 133), ("thru-becn-rx-c", 134), ("thru-de-tx-c", 135), ("thru-de-rx-c", 136), ("cir-percent-range1-tx-bc", 137), ("cir-percent-range1-rx-bc", 138), ("cir-percent-range2-tx-bc", 139), ("cir-percent-range2-rx-bc", 140), ("cir-percent-range3-tx-bc", 141), ("cir-percent-range3-rx-bc", 142), ("cir-percent-range4-tx-bc", 143), ("cir-percent-range4-rx-bc", 144), ("cir-percent-range5-tx-bc", 145), ("cir-percent-range5-rx-bc", 146), ("cir-percent-range6-tx-bc", 147), ("cir-percent-range6-rx-bc", 148), ("cir-percent-range7-tx-bc", 149), ("cir-percent-range7-rx-bc", 150), ("cir-percent-range8-tx-bc", 151), ("cir-percent-range8-rx-bc", 152), ("lmi-tx-bc", 153), ("lmi-rx-bc", 154), ("lmi-livo-enq-tx-bc", 155), ("lmi-livo-enq-rx-bc", 156), ("lmi-livo-stat-tx-bc", 157), ("lmi-livo-stat-rx-bc", 158), ("lmi-full-enq-tx-bc", 159), ("lmi-full-enq-rx-bc", 160), ("lmi-full-stat-tx-bc", 161), ("lmi-full-stat-rx-bc", 162), ("lmi-other-tx-bc", 163), ("lmi-other-rx-bc", 164), ("total-uptime", 165), ("total-downtime", 166), ("igrp-tx-bc", 167), ("igrp-rx-bc", 168), ("vnip-tx-bc", 169), ("vnip-rx-bc", 170), ("annex-g-tx-bc", 171), ("annex-g-rx-bc", 172), ("delete-entry", -1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgFrPerfLTProtocolFilterProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgFrPerfLTProtocolFilterProtocol.setDescription('Long term statistics will be collected on the user-specifiable protocol. Setting a -1 remove the indexed protocol from the filter.')
sfrapCfgFrPerfDlciDefaultUtilThreshold = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 7, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgFrPerfDlciDefaultUtilThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgFrPerfDlciDefaultUtilThreshold.setDescription('The default threshold for generating a utilization threshold trap as a percentage of the CIR. This value is used for sfrapCfgFrPerfDlciNamesUtilThreshold when a DLCI is first discovered. ')
sfrapCfgFrPerfDlciUtilDuration = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 7, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgFrPerfDlciUtilDuration.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgFrPerfDlciUtilDuration.setDescription("The number of Short Term Intervals that a DLCI's utilization as a percentage of CIR must be above or below the value of sfrapCfgFrPerfDlciUtilThreshold before a sfrapPvc(Rx/Tx)UtilizationExceededTrap or sfrapPvc(Rx/Tx)UtilizationClearedTrap is issued. ")
sfrapCfgFrPerfDlciNamesTableClear = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 7, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clear-table", 1), ("clear-table-keep-stats", 2)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: sfrapCfgFrPerfDlciNamesTableClear.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgFrPerfDlciNamesTableClear.setDescription("Clears the smperCfgFrPerfDlciNamesTable (1) clear the table or (2) clear the table but don't remove the dlcis from the short term statistics.")
sfrapCfgFrPerfUserProtocolsTableClear = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 7, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("clear-table", 1)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: sfrapCfgFrPerfUserProtocolsTableClear.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgFrPerfUserProtocolsTableClear.setDescription(' Clears the sfrapCfgFrPerfUserProtocolsTable (1) clear the table ')
sfrapCfgFrPerfLTDlciFilterTableClear = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 7, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("clear-table", 1)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: sfrapCfgFrPerfLTDlciFilterTableClear.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgFrPerfLTDlciFilterTableClear.setDescription(' Clears the sfrapCfgFrPerfLTDlciFilterTable (1) clear the table ')
sfrapCfgFrPerfLTProtocolFilterTableClear = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 7, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("clear-table", 1)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: sfrapCfgFrPerfLTProtocolFilterTableClear.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgFrPerfLTProtocolFilterTableClear.setDescription(' Clears the sfrapCfgFrPerfLTProtocolFilterTable (1) clear the table ')
sfrapCfgFrPerfUnprovDlcisDelete = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 7, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("delete-unprov", 1)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: sfrapCfgFrPerfUnprovDlcisDelete.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgFrPerfUnprovDlcisDelete.setDescription('Delete all unprovisioned and Not-In-LMI dlcis (1) delete all unprovisioned ')
sfrapCfgSecurityTable = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 7, 2, 8))
sfrapCfgTelnetCliPassword = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 8, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgTelnetCliPassword.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgTelnetCliPassword.setDescription('The password needed to start a CLI (Command Line Interface) session using either a terminal connected to the unit or Telnet.')
sfrapCfgTftpPassword = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 8, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgTftpPassword.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgTftpPassword.setDescription('The password needed to initiate a TFTP download.')
sfrapCfgCliPassword = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 8, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgCliPassword.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgCliPassword.setDescription('OBSOLETE: The Telnet and CLI passwords are one and the same. Use the above sfrapCfgTelnetCliLcdPassword to log into the CLI (Command Line Interface).')
sfrapCfgGetCommunityString = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 8, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgGetCommunityString.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgGetCommunityString.setDescription('The community string for doing SNMP GETs. The unit will respond to GETs that use either this string or the SET community string. All others will be rejected and a trap will be generated. String is case sensitive.')
sfrapCfgSetCommunityString = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 8, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgSetCommunityString.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgSetCommunityString.setDescription('The community string for doing SNMP SETs. The unit will reject SETs with any other coimmunity string and will generate a trap. String is case sensitive.')
sfrapCfgLock = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 600))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: sfrapCfgLock.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgLock.setDescription('Request to start configuration download and lock out any other means of configuring the unit. The integer passed in represents the time out period in seconds between sets. A set to this object will fail if the unit is already in a configuration locked state.')
sfrapCfgLockID = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 13), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapCfgLockID.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgLockID.setDescription('Returns the IP Address of the management station currently in control of configuration. A unit that is not in a configuration locked state will return 0.0.0.0')
sfrapCfgID = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapCfgID.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgID.setDescription('A read of this object returns the Current Configuration ID string. A write sets the Configuration ID string. The string contains a starting character to indicate the last configuration source C = Envisage N = CLI/TELNET L = LCD S= other SNMP management station and a unique 7 integer value to differentiate configurations between common sources. A value of *STARTUP indicates the configuration has been defaulted. A write will only be accepted from the management station that has successfully obtained the configuration lock')
sfrapCfgStatus = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("in-progress", 1), ("success", 2), ("datarate-density-conflict", 3), ("bandwidth-allocation-error", 4), ("general-error", 5), ("timeout", 6), ("aborted-by-user", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapCfgStatus.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgStatus.setDescription('The status of a configuration install is reported here. On startup, a status of success will be reported. (1) The configuration has been locked and an update or unlock command has not been received. (2) An update command has been received and the configuration has been validated as consistent; . (3) An update command has been received but the DTE port datarate is not compatible with the density. (4) An update command has been received but the number of channels to be allocated will not fit in the available channels. (5) An update command has been received but there is an error in the configuration that is not a datarate-density-conflict or bandwidth-allocation-error. (6) The time between consecutive set requests exceeded the timeout sent with the sfrapCfgLock command. (7) The user sent a sfrapCfgUnlock command before a sfrapCfgUpdate command. This usually means that one of the sets in the configuration failed. ')
sfrapCfgUnlock = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("un-lock", 1)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: sfrapCfgUnlock.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgUnlock.setDescription('The management station sets this variable to complete the configuration install process. Un-lock (1) notifies the agent to remove the lock on configuring the unit without updating the configuration.')
sfrapCfgUpdate = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 2, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("update", 1)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: sfrapCfgUpdate.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgUpdate.setDescription('The management station sets this variable to complete the configuration install process. Update (1) notifies the agent to start the update process within the unit.')
sfrapDiagnostics = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 7, 3))
sfrapDiagUnitTable = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 7, 3, 1))
sfrapDiagUnitLocLoop = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable-loopback-mode", 1), ("disable-loopback-mode", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapDiagUnitLocLoop.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapDiagUnitLocLoop.setDescription('Controls a bi-directional unit loopback. Data is received from either interface, processed, and transmitted back towards the same interface. When configured for Frame Relay operation the unit will preserve the LMI path and maintain managed access during this loopback. In Frame Relay mode, only valid HDLC frames are looped back (pseudorandom test patterns will be dropped). (1) enable unit loopback (2) disable unit loopback')
sfrapDiagUnitReset = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("reset-unit", 1)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: sfrapDiagUnitReset.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapDiagUnitReset.setDescription('Enables the operator to remotely reset the unit. Using this command will cause the unit to terminate all its connections and drop data.')
sfrapDiagUnitTimeRemaining = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 3, 1, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapDiagUnitTimeRemaining.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapDiagUnitTimeRemaining.setDescription('The remaining time on the active loopback before the loopback times out. The time is in hundredths of seconds (TimeTicks).')
sfrapDiagUnitCutThru = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable-cutthru-mode", 1), ("disable-cutthru-mode", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapDiagUnitCutThru.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapDiagUnitCutThru.setDescription('Enables the operator to control and examine the UNIT Cut Through mode. This diagnostic occurs on the TO-DTE and TO-DCE transmit and receive logic. The unit will transmit To-DTE data onto the TO-DCE port without any intervention by the processor. If the CutThruTimeout is greater than 0, then the cut-thru diagnostic will time out after that interval (in minutes). (same as Tap Mode operation - see CfgAppOperationMode).')
sfrapDiagUnitCutThruTimeRemaining = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 3, 1, 5), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapDiagUnitCutThruTimeRemaining.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapDiagUnitCutThruTimeRemaining.setDescription('The remaining time on the active loopback before the loopback times out. The time is in hundredths of seconds (TimeTicks).')
sfrapDiagDteTable = MibTable((1, 3, 6, 1, 4, 1, 485, 7, 3, 3), )
if mibBuilder.loadTexts: sfrapDiagDteTable.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapDiagDteTable.setDescription('The table of DTE port diagnostics.')
sfrapDiagDteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 7, 3, 3, 1), ).setIndexNames((0, "SFRAP-MIB", "sfrapDiagDteIndex"))
if mibBuilder.loadTexts: sfrapDiagDteEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapDiagDteEntry.setDescription('An diagnostic entry for a DTE port.')
sfrapDiagDteIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 3, 3, 1, 99), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("to-dte", 1), ("to-dce", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapDiagDteIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapDiagDteIndex.setDescription('Selects which DTE port.')
sfrapDiagDteLclLpbk = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 3, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable-loopback-mode", 1), ("disable-loopback-mode", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapDiagDteLclLpbk.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapDiagDteLclLpbk.setDescription('Controls the DTE loopback state. This is a bi-directional loopback state where both the DTE and WAN ports are placed in line loopback. All data received on each interface is sent back out the respective interface regardless of format or content. In Frame Relay applications the unit will not preserve the LMI path during this diagnostic and in-band management will not operate. (1) enable payload loopback (2) disable payload loopback')
sfrapDiagDteTimeRemaining = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 3, 3, 1, 13), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapDiagDteTimeRemaining.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapDiagDteTimeRemaining.setDescription('The remaining time on the active loopback before the loopback times out and disables itself. The time is in hundredths of seconds (TimeTicks).')
sfrapDiagVnipTable = MibTable((1, 3, 6, 1, 4, 1, 485, 7, 3, 6), )
if mibBuilder.loadTexts: sfrapDiagVnipTable.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapDiagVnipTable.setDescription(' Table of Diagnostics performed with the VNIP protocol')
sfrapDiagVnipEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 7, 3, 6, 1), ).setIndexNames((0, "SFRAP-MIB", "sfrapDiagVnipInterface"), (0, "SFRAP-MIB", "sfrapDiagVnipIndex"))
if mibBuilder.loadTexts: sfrapDiagVnipEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapDiagVnipEntry.setDescription('VNIP VLOOP and VBERT diagnostic profile. Initiating these tests require an established and stable VNIP topology on an interface. Once the topology is in place, the user can execute a PVC-based diagnostic between this unit and any indexed entry in the topology table. The index into the topology table for a particular interface is required.')
sfrapDiagVnipInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 3, 6, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dte-interface", 1), ("t1-interface", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapDiagVnipInterface.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapDiagVnipInterface.setDescription('The interface out which a PVC-based VNIP diagnostic will be run. This must be an interface with a valid and stable VNIP topology for a VNIP Diagnostic.')
sfrapDiagVnipIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 3, 6, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapDiagVnipIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapDiagVnipIndex.setDescription('The index to the external VNIP peer as presented by the VNIP topology database for the given interface. Refer to VnipTopologyTable to determine the index of the remote peer.')
sfrapDiagVnipDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 3, 6, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapDiagVnipDlci.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapDiagVnipDlci.setDescription('This is the DLCI value for the given interface/index combination. This comes from the VniptTopologyTable.')
sfrapDiagVnipIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 3, 6, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapDiagVnipIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapDiagVnipIpAddr.setDescription('This is the ip address for the given interface/index combination. This comes from the VniptTopologyTable.')
sfrapDiagVLOOP = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 3, 6, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("start-test", 1), ("stop-test", 2)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: sfrapDiagVLOOP.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapDiagVLOOP.setDescription('Controls execution of the Vnip Logical Loopback (VLOOP) test. VLOOP is designed as an intrusive test and customer data on the DLCI-under-test will be discarded. The VLOOP test includes a timed VBERT test and is run using the profile configured within this table. (1) start VLOOP test (2) stop VLOOP test (override VBERT test duration)')
sfrapDiagVBERT = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 3, 6, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("start", 1), ("stop", 2)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: sfrapDiagVBERT.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapDiagVBERT.setDescription('Controls execution of the Vnip Virtual Bit Eror Rate (VBERT) test. VBERT is designed to be a non-intrusive test and will attempt to statistically multiplex VBERT test data and customer data on the DLCI-under-test. However, VBERT data is given priority over customer data when the selected VBERT volume causes internal congestion. The test is run using the profile configured within this table. (1) start test (2) stop test (override VBERT test duration)')
sfrapDiagVBERTRate = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 3, 6, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(8000, 2048000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapDiagVBERTRate.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapDiagVBERTRate.setDescription('Specifies the throughput bit rate applied by VBERT or VLOOP to the DLCI-under-test. For TO-DTE Rates or configured CIR up to 64K the maximum VBERT rate is either the TO-DTE data rate or 110% of CIR (which ever is less). For TO-DTE Rates or configured CIR greater than 64K, the maximum VBERT rate is 75% of the TO-DTE data rate or 110% of CIR (which ever is less). Note that selecting rates that approach line rate will impact neighboring PVCs. (8000-1152000): VBERT/VLOOP data rate (in bits per second).')
sfrapDiagVBERTSize = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 3, 6, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(64, 128, 256, 512, 1024, 2048))).clone(namedValues=NamedValues(("pkt-size-64", 64), ("pkt-size-128", 128), ("pkt-size-256", 256), ("pkt-size-512", 512), ("pkt-size-1024", 1024), ("pkt-size-2048", 2048)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapDiagVBERTSize.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapDiagVBERTSize.setDescription('Specifies the size of framed data that will be used during the VBERT test, measures in Bytes. (64) 64-byte frames (128) 128-byte frames (256) 256-byte frames (512) 512-byte frames (1024) 1024-byte frames (2048) 2048-byte frames')
sfrapDiagVBERTPktPercent = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 3, 6, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 25, 50, 75, 100))).clone(namedValues=NamedValues(("zero-percent", 0), ("twentyFive-percent", 25), ("fifty-percent", 50), ("seventyFive-percent", 75), ("oneHundred-percent", 100)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapDiagVBERTPktPercent.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapDiagVBERTPktPercent.setDescription('Specifies percentage of VBERT packets that will have the Frame Relay Discard Eligibility bit set. Frames with this bit set may be more likley to get dropped in a congested network. (0) 0% of the test frames are marked discard eligible (25) 25% of the test frames are marked discard eligible (50) 50% of the test frames are marked discard eligible (75) 75% of the test frames are marked discard eligible (100) 100% of the test frames are marked discard eligible')
sfrapDiagVBERTTestPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 3, 6, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 1440))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapDiagVBERTTestPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapDiagVBERTTestPeriod.setDescription("Specifies the duration of a VBERT test. Note that VBERT is subjected to the unit's Loopback Timer and will be terminated by whichever timer expires first. (10-1440): VBERT time duration in seconds")
sfrapDiagTxClockDetect = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 3, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("initiate-clock-detect", 1), ("terminate-clock-detect", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfrapDiagTxClockDetect.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapDiagTxClockDetect.setDescription('Enables the operator to activate clock detection on the TO-DCE Transmit clock. Clock detection can be stopped by issuing the terminate command.')
sfrapStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 7, 4))
sfrapStatusLedTable = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 7, 4, 4))
sfrapStatusLedOpStatusLED = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 4, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("greenLED-high-speed-mode", 1), ("blinkgreenLED-low-speed-mode", 2), ("yellowLED-test-mode", 3), ("redLED-alarm-mode", 4), ("blinkredLED-cut-through-mode", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapStatusLedOpStatusLED.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapStatusLedOpStatusLED.setDescription('Status of the Operation Mode LED.')
sfrapStatusLedToDTETxLED = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 4, 4, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("offLED-inactive", 1), ("greenLED-tx-data-receiving", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapStatusLedToDTETxLED.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapStatusLedToDTETxLED.setDescription('Status of the TO-DTE TxD LED.')
sfrapStatusLedToDTERxLED = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 4, 4, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("offLED-inactive", 1), ("greenLED-rx-data-receiving", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapStatusLedToDTERxLED.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapStatusLedToDTERxLED.setDescription('Status of the TO-DTE RxD LED.')
sfrapStatusLedRtsLED = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 4, 4, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("greenLED-rts-active", 1), ("offLED-rts-inactive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapStatusLedRtsLED.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapStatusLedRtsLED.setDescription('Status of the RTS Signal LED.')
sfrapStatusLedCtsLED = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 4, 4, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("greenLED-cts-active", 1), ("offLED-cts-inactive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapStatusLedCtsLED.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapStatusLedCtsLED.setDescription('Status of the CTS Signal LED.')
sfrapStatusLedDsrLED = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 4, 4, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("greenLED-dsr-active", 1), ("offLED-dsr-inactive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapStatusLedDsrLED.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapStatusLedDsrLED.setDescription('Status of the DSR Signal LED.')
sfrapStatusLedDcdLED = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 4, 4, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("greenLED-dcd-active", 1), ("offLED-dcd-inactive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapStatusLedDcdLED.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapStatusLedDcdLED.setDescription('Status of the DCD Signal LED.')
sfrapStatusLedToDCETxLED = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 4, 4, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("offLED-inactive", 1), ("greenLED-tx-data-receiving", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapStatusLedToDCETxLED.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapStatusLedToDCETxLED.setDescription('Status of the TO-DCE TxD LED.')
sfrapStatusLedToDCERxLED = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 4, 4, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("offLED-inactive", 1), ("greenLED-rx-data-receiving", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapStatusLedToDCERxLED.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapStatusLedToDCERxLED.setDescription('Status of the TO-DCE RxD LED.')
sfrapStatusLedLmiErrLED = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 4, 4, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("offLED-lmi-active-state", 1), ("yellowLED-lmi-error-state", 2), ("blinkyellowLED-lmi-source-state", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapStatusLedLmiErrLED.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapStatusLedLmiErrLED.setDescription('Status of the LMI Error LED.')
sfrapStatusLedFrmActLED = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 4, 4, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("greenLED-frm-active", 1), ("offLED-frm-inactive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapStatusLedFrmActLED.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapStatusLedFrmActLED.setDescription('Status of the Frame Activity LED.')
sfrapStatusLedCtrlLED = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 4, 4, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yellowLED-ctrl-active", 1), ("offLED-ctrl-inactive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapStatusLedCtrlLED.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapStatusLedCtrlLED.setDescription('Status of the X.21 Control Signal LED. Only applicable when in X.21.')
sfrapStatusLedIndLED = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 4, 4, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yellowLED-ind-active", 1), ("offLED-ind-inactive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapStatusLedIndLED.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapStatusLedIndLED.setDescription('Status of the X.21 Indication Signal LED. Only applicable when in X.21.')
sfrapStatusAllLEDs = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 4, 4, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapStatusAllLEDs.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapStatusAllLEDs.setDescription("Status of all ten SFRAP LEDs, encoded in a string. 'F' off '5' green '0' yellow 'A' red '7' blinking green and off '3' blinking yellow and off 'B' blinking red and off '4' blinking green and yellow '6' blinking green and red '8' blinking yellow and red Positionally, the 13 letters are SFRAP Op Mode, TO-DCE Rx, TO-DCE Tx, RTS, CTS, DCD, DSR, LMI Error, Frame Activity, Ctrl, Ind, TO-DTE Rx, TO-DTE Tx.")
sfrapStatusDipswitchTable = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 7, 4, 10))
sfrapStatusDipswitchCutthru = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 4, 10, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("switch-up", 1), ("switch-down", 2), ("na", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapStatusDipswitchCutthru.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapStatusDipswitchCutthru.setDescription('Status of the Operation Mode LED.')
sfrapStatusDipswitchToDteLpbk = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 4, 10, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("switch-up", 1), ("switch-down", 2), ("na", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapStatusDipswitchToDteLpbk.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapStatusDipswitchToDteLpbk.setDescription('Status of the TO-DTE TxD LED.')
sfrapStatusDipswitchToDceLpbk = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 4, 10, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("switch-up", 1), ("switch-down", 2), ("na", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapStatusDipswitchToDceLpbk.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapStatusDipswitchToDceLpbk.setDescription('Status of the TO-DTE RxD LED.')
sfrapStatusDipswitchUnused = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 4, 10, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("switch-up", 1), ("switch-down", 2), ("na", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapStatusDipswitchUnused.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapStatusDipswitchUnused.setDescription('Status of the RTS Signal LED.')
sfrapStatusDipswitchIntfMode1 = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 4, 10, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("switch-up", 1), ("switch-down", 2), ("na", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapStatusDipswitchIntfMode1.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapStatusDipswitchIntfMode1.setDescription('Status of the RTS Signal LED.')
sfrapStatusDipswitchIntfMode2 = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 4, 10, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("switch-up", 1), ("switch-down", 2), ("na", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapStatusDipswitchIntfMode2.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapStatusDipswitchIntfMode2.setDescription('Status of the RTS Signal LED.')
sfrapStatusDteTable = MibTable((1, 3, 6, 1, 4, 1, 485, 7, 4, 7), )
if mibBuilder.loadTexts: sfrapStatusDteTable.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapStatusDteTable.setDescription('The table of DTE port statuses.')
sfrapStatusDteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 7, 4, 7, 1), ).setIndexNames((0, "SFRAP-MIB", "sfrapStatusDteIndex"))
if mibBuilder.loadTexts: sfrapStatusDteEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapStatusDteEntry.setDescription('An status entry for a DTE port.')
sfrapStatusDteIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 4, 7, 1, 99), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("to-dte", 1), ("to-dce", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapStatusDteIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapStatusDteIndex.setDescription('Selects which DTE port.')
sfrapStatusDteMode = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 4, 7, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("no-connections", 1), ("active", 2), ("test", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapStatusDteMode.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapStatusDteMode.setDescription('Status of the port. no-connections (1) indicates the port has no connections. Active (2) indicates connections and data mode. Test (3) indicates connections and diagnostic state for that port.')
sfrapStatusDteRts = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 4, 7, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("na", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapStatusDteRts.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapStatusDteRts.setDescription('Status of the RTS signal on the port: on (1) and off (2).')
sfrapStatusDteDtr = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 4, 7, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("na", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapStatusDteDtr.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapStatusDteDtr.setDescription('Status of the DTR signal on the port: on (1) and off (2).')
sfrapStatusDteDcd = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 4, 7, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("na", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapStatusDteDcd.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapStatusDteDcd.setDescription('Whether the DCD signal on the port is on (1) or off (2).')
sfrapStatusDteDsr = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 4, 7, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("na", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapStatusDteDsr.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapStatusDteDsr.setDescription('Whether the DSR signal on the port is on (1) or off (2).')
sfrapStatusDteCts = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 4, 7, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("na", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapStatusDteCts.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapStatusDteCts.setDescription('Whether the CTS signal on the port is on (1) or off (2).')
sfrapStatusDteSendtiming = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 4, 7, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("present", 1), ("not-present", 2), ("na", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapStatusDteSendtiming.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapStatusDteSendtiming.setDescription('Whether Send Timing is (1)present or (2)not-present on the interface.')
sfrapStatusDteRxtiming = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 4, 7, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("present", 1), ("not-present", 2), ("na", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapStatusDteRxtiming.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapStatusDteRxtiming.setDescription('Whether Receive Timing is (1)present or (2)not-present on the interface.')
sfrapStatusDteTermtiming = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 4, 7, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("present", 1), ("not-present", 2), ("na", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapStatusDteTermtiming.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapStatusDteTermtiming.setDescription('Whether Terminal Timing is (1)present or (2)not-present on the interface.')
sfrapStatusDteCtrl = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 4, 7, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("na", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapStatusDteCtrl.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapStatusDteCtrl.setDescription('The status of the Control lead when using X.21')
sfrapStatusDteInd = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 4, 7, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("na", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapStatusDteInd.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapStatusDteInd.setDescription('The status of the Indication lead when using X.21')
sfrapVnipTopologyTable = MibTable((1, 3, 6, 1, 4, 1, 485, 7, 4, 2), )
if mibBuilder.loadTexts: sfrapVnipTopologyTable.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapVnipTopologyTable.setDescription('Topology of peers discovered via VNIP, organized by the interface (DATA1 or DATA2) from which they were discovered and an entry number or index. The topology is of limited size per interface.')
sfrapVnipTopologyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 7, 4, 2, 1), ).setIndexNames((0, "SFRAP-MIB", "sfrapVnipTopologyInterface"), (0, "SFRAP-MIB", "sfrapVnipTopologyIndex"))
if mibBuilder.loadTexts: sfrapVnipTopologyEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapVnipTopologyEntry.setDescription('The DLCI, IP address, and number of hops for a particular node, discovered via VNIP off of an interface (DATA1 or DATA2). The entry may also have transit delay measurements for the particular node.')
sfrapVnipTopologyInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 4, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("data1-interface", 1), ("data2-interface", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapVnipTopologyInterface.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapVnipTopologyInterface.setDescription('The interface off of which the peer was discovered. Topology is discovered by sending VNIP messages out each interface. Nodes discovered via a particular interface are kept in a list associated with that interface.')
sfrapVnipTopologyIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 4, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapVnipTopologyIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapVnipTopologyIndex.setDescription('The number of this discovered peer in the list of nodes for this interface. For each interface, the nodes are numbered 1 through n.')
sfrapVnipTopologyDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 4, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapVnipTopologyDlci.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapVnipTopologyDlci.setDescription('The DLCI of the discovered neighboring peer. This may be different from the local DLCI.')
sfrapVnipTopologyIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 4, 2, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapVnipTopologyIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapVnipTopologyIpAddr.setDescription('The IP address for the discovered peer.')
sfrapVnipTopologyNumHops = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 4, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapVnipTopologyNumHops.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapVnipTopologyNumHops.setDescription('The discovered peer is this number of hops away.')
sfrapVnipTopologyLocalDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 4, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapVnipTopologyLocalDlci.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapVnipTopologyLocalDlci.setDescription('The DLCI of this node over which the remote peer was discovered.')
sfrapVnipTopoTDNumSamples = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 4, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapVnipTopoTDNumSamples.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapVnipTopoTDNumSamples.setDescription('The number of transit delay samples collected.')
sfrapVnipTopoTDAvgDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 4, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapVnipTopoTDAvgDelay.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapVnipTopoTDAvgDelay.setDescription('The average transit delay between this node and the remote peer.')
sfrapVnipTopoTDMaxDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 4, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapVnipTopoTDMaxDelay.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapVnipTopoTDMaxDelay.setDescription('The maximum transit delay between this node and the remote peer.')
sfrapVnipTopoTDMinDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 4, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapVnipTopoTDMinDelay.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapVnipTopoTDMinDelay.setDescription('The minimum transit delay between this node and the remote peer.')
sfrapVnipTopoTDLastDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 4, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapVnipTopoTDLastDelay.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapVnipTopoTDLastDelay.setDescription('The most recent transit delay measured between this node and the remote peer.')
sfrapVnipTopoVLOOPStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 4, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("loopback-enable", 1), ("loopback-disable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapVnipTopoVLOOPStatus.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapVnipTopoVLOOPStatus.setDescription('This selection displays the status of the VNIP Loopback This loopback is initiated by the remote node, causing this node to loop data back to the remote node.')
sfrapVnipTopoVBERTStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 4, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("off", 1), ("testing", 2), ("test-failed", 3), ("test-completed", 4), ("in-test", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapVnipTopoVBERTStatus.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapVnipTopoVBERTStatus.setDescription('Displays the current status of the VBERT test, values are off(1): no test has run or the entry has been cleared, testing(2): the entry is generating VBERT packets, in-test(5): the entry is on the receiving end of VBERT packets test-completed(4): a test has run and is finished results are complete test-failed(3): the request for a test on this entry failed')
sfrapVnipTopoVBertTxDESetFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 4, 2, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapVnipTopoVBertTxDESetFrames.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapVnipTopoVBertTxDESetFrames.setDescription('Displays the number of Frames transmitted during VBERT Test that had the Discard Eligibility indicator bit set.')
sfrapVnipTopoVBertRxDESetFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 4, 2, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapVnipTopoVBertRxDESetFrames.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapVnipTopoVBertRxDESetFrames.setDescription('Displays the number of Frames received during VBERT Test that had the Discard Eligibility indicator bit set.')
sfrapVnipTopoVBertTxDEClrFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 4, 2, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapVnipTopoVBertTxDEClrFrames.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapVnipTopoVBertTxDEClrFrames.setDescription('Displays the number of Frames transmitted during VBERT Test that had the Discard Eligibility indicator bit cleared.')
sfrapVnipTopoVBertRxDEClrFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 4, 2, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapVnipTopoVBertRxDEClrFrames.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapVnipTopoVBertRxDEClrFrames.setDescription('Displays the number of Frames received during VBERT Test that had the Discard Eligibility indicator bit cleared.')
sfrapVnipTopoVBertTransitDelayMax = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 4, 2, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapVnipTopoVBertTransitDelayMax.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapVnipTopoVBertTransitDelayMax.setDescription('The maximum transit delay between this node and the remote peer during the VBERT test.')
sfrapVnipTopoVBertTransitDelayAvg = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 4, 2, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapVnipTopoVBertTransitDelayAvg.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapVnipTopoVBertTransitDelayAvg.setDescription('The average transit delay between this node and the remote peer during the VBERT test.')
sfrapVnipTopoVBertTimeElapse = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 4, 2, 1, 23), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapVnipTopoVBertTimeElapse.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapVnipTopoVBertTimeElapse.setDescription('Elapsed time since VBERT test was started or cleared.')
sfrapVnipTopoVBertPerUtilCIR = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 4, 2, 1, 24), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapVnipTopoVBertPerUtilCIR.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapVnipTopoVBertPerUtilCIR.setDescription(' The calculated percent of CIR utilization during a VBERT test, this value is only valid after a test is complete not during.')
sfrapVnipTopoVBertPerUtilEIR = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 4, 2, 1, 25), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapVnipTopoVBertPerUtilEIR.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapVnipTopoVBertPerUtilEIR.setDescription(' The calculated percent of EIR utilization during a VBERT test, this value is only valid after a test is complete not during.')
sfrapVnipTransitDelayClear = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 4, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("clear-transit-delay", 1)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: sfrapVnipTransitDelayClear.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapVnipTransitDelayClear.setDescription('Allows the user to clear all the VNIP Transit Delay data collected in the VNIP topology database.')
sfrapLmiSourcing = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 4, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("initializing", 1), ("passthrough", 2), ("user-to-dte", 3), ("user-to-dce", 4), ("ntwk-to-dte", 5), ("ntwk-to-dce", 6), ("disabled", 7), ("both-ports", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapLmiSourcing.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapLmiSourcing.setDescription('What type of LMI sourcing is being done: initializing (1), passthrough (2), emulating a user device on the To-DTE (3), emulating a user device on the To-DCE (4), emulating a network device on the To-DTE (5), emulating a network device on the To-DCE (6), disabled (7), or emulating a switch by responding to both ports (8).')
sfrapVBertClear = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 4, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("clear-vbert", 1)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: sfrapVBertClear.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapVBertClear.setDescription('Allows the user to clear all the VBERT data collected in the VNIP topology database as long as the entry is not in a test status.')
sfrapStatusMgmtTable = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 7, 4, 3))
sfrapStatusMgmtChannel = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 4, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("slip", 2), ("private-dlci", 3), ("piggyback-dlci", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapStatusMgmtChannel.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapStatusMgmtChannel.setDescription("This is the method in which the unit is configured for SNMP management access. (1) None: SNMP management disabled (2) SLIP: out-of-band management via asynchronous Serial Line IP (3) Private DLCI: in-band management using a private DLCI that is dedicated solely to this unit's management. (4) Piggyback DLCI: in-band management using any DLCI optionally multiplexing both management and user data.")
sfrapStatusMgmtInterface = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 4, 3, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("comm", 1), ("local-to-dte", 2), ("remote-to-dce", 3), ("local-and-remote", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapStatusMgmtInterface.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapStatusMgmtInterface.setDescription('This is the port(s) on which the management traffic will appear. (1) Async Maintenance(Comm)/Console port - SLIP mode (2) Local TO-DTE interface: unit is configured for Private Local DLCI mode (3) Remote WAN Interface: unit is confiogured for Private Remote DLCI mode (4) TO-DTE and WAN Interfaces: unit is configured for either Piggyback Bidirectional mode.')
sfrapStatusMgmtInterfaceStatus = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 4, 3, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2), ("alarm", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapStatusMgmtInterfaceStatus.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapStatusMgmtInterfaceStatus.setDescription('This is the status of the port(s) on which the management traffic will appear. (1) Active: port or DLCI is configured and status is okay (2) Inactive: port or DLCI is declared out of service (3) Alarm: port or DLCI is experiencing an alarm condition that may interefere with management access ')
sfrapStatusMgmtDefaultDLCINo = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 4, 3, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapStatusMgmtDefaultDLCINo.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapStatusMgmtDefaultDLCINo.setDescription('This is the DLCI for the PVC that is defined for the Management port. All traffic using this DLCI in the Frame Replay packet will be destined for the InBand Management task.')
sfrapStatusMgmtDefaultDLCIStatus = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 4, 3, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("na", 1), ("dlci-active", 2), ("dlci-inactive", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapStatusMgmtDefaultDLCIStatus.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapStatusMgmtDefaultDLCIStatus.setDescription('This is the status of the default management DLCI. (1) not applicable: SLIP mode or management is disabled (2) DLCI Active: default DLCI is active in the LMI full status response. (3) DLCI Inactive: default DLCI is not active in the LMI full status response.')
sfrapStatusClockRate = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 4, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapStatusClockRate.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapStatusClockRate.setDescription('This is the value in Kbps of the Receive Clock Frequency, for both the TO-DTE and TO-DCE ports.')
sfrapStatusToDteRxClockMode = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 4, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("clock-normal", 1), ("clock-invert", 2), ("clock-auto-normal", 3), ("clock-auto-invert", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapStatusToDteRxClockMode.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapStatusToDteRxClockMode.setDescription('The status of the Receive clocking mode.')
sfrapStatusLmiAutosense = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 4, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("disabled", 1), ("searching", 2), ("learned-annex-d", 3), ("learned-annex-a", 4), ("learned-type1", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapStatusLmiAutosense.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapStatusLmiAutosense.setDescription("This indicates the current status of LMI Auto Sensing if it's enabled. (1) Disabled: LMI is configured as Type 1, Annex-D, or Annex-A (2) Searching: unit is attempting to determine the LMI type of the attached equipment by issuing LMI messages of each LMI type and searching for responses. (3) Learned Annex-D: unit has successfully detected Annex-D LMI (ANSI T1.617 Annex D) (4) Learned Annex-A: unit has successfully detected Annex-A LMI (ITU/CCITT Q.933 Annex A) (5) Learned Type 1: unit has successfully detected Type 1 LMI (Cisco, Group of four, LMI)")
sfrapStatusTxClockDetect = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 4, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("inactive", 1), ("initiate", 2), ("trying-cut-thru", 3), ("failed-cut-thru", 4), ("trying-inband-norm", 5), ("success-inband-norm", 6), ("failed-inband-norm", 7), ("trying-inband-invert", 8), ("success-inband-invert", 9), ("failed-inband", 10), ("terminate", 11)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapStatusTxClockDetect.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapStatusTxClockDetect.setDescription('This selection displays the status of the TO-DCE transmit clock auto detection process. (1)inactive - The Auto Detect option was not selected. (2)initiate - The Auto Detect option was selected and is initializing. (3)trying-cut-thru - The Auto Detect option is trying to verify the integrity of the TO-DCE transmit clock mode selected in Cut Through mode (4)failed-cut-thru - This mechanism has detected that the LMI integrity check has failed. (5)trying-inband-normal - The Auto Detection mechanism has set the TO-DCE Tx clock to normal timing and is performing the link integrity check, to determine if this selection is correct (6)success-inband-norm - The Auto Detection mechanism has determined that the TO-DCE Tx clock timing is successful in normal mode. (7)trying-inband-invert - The Auto Detection mechanism has determined that the TO-DCE clock mode failed using normal timing, now it has inverted the clock. (8)success-inband-invert - The mechanism has decided that the TO-DCE Tx clock needs to be inverted. (9)failed-in-band - Neither Normal or Invert timing was successful. (10)terminated - The Auto Detection mechanism has been terminated.')
sfrapPerformance = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 7, 5))
sfrapPerfMgmtIp = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 7, 5, 2))
sfrapPerfMgmtIpIFStatsTable = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 7, 5, 2, 1))
sfrapPerfMgmtIpIFInOctets = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 5, 2, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfMgmtIpIFInOctets.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfMgmtIpIFInOctets.setDescription('The count of all octets received. Same as ifInOctets in mib-2.')
sfrapPerfMgmtIpIFInErrors = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 5, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfMgmtIpIFInErrors.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfMgmtIpIFInErrors.setDescription('The count of packets received that could not be delivered because of errors. Same as ifInErrors in mib-2.')
sfrapPerfMgmtIpIFOutOctets = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 5, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfMgmtIpIFOutOctets.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfMgmtIpIFOutOctets.setDescription('The count of all octets transmitted. Same as ifOutOctets in mib-2.')
sfrapPerfMgmtIpIFOperStatus = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 5, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfMgmtIpIFOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfMgmtIpIFOperStatus.setDescription('The current operational state. Same as ifOperStatus in mib-2.')
sfrapPerfMgmtIpIPStatsTable = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 7, 5, 2, 2))
sfrapPerfMgmtIpIPInRcv = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 5, 2, 2, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfMgmtIpIPInRcv.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfMgmtIpIPInRcv.setDescription('The count of all datagrams received. Same as ipInReceives in mib-2.')
sfrapPerfMgmtIpIPInHdrErr = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 5, 2, 2, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfMgmtIpIPInHdrErr.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfMgmtIpIPInHdrErr.setDescription('The count of datagrams received that were discarded because of errors in their IP headers. Same as ipInHdrErrors in mib-2.')
sfrapPerfMgmtIpIPInAddrErr = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 5, 2, 2, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfMgmtIpIPInAddrErr.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfMgmtIpIPInAddrErr.setDescription('The count of datagrams received that were discarded because unexpected or invalid IP addresses in their IP headers. Same as ipInAddrErrors in mib-2.')
sfrapPerfMgmtIpIPInProtUnk = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 5, 2, 2, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfMgmtIpIPInProtUnk.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfMgmtIpIPInProtUnk.setDescription('The count of datagrams received that were discarded because of unsupported protocols. Same as ipInUnknownProtos in mib-2.')
sfrapPerfMgmtIpIPInDscrd = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 5, 2, 2, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfMgmtIpIPInDscrd.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfMgmtIpIPInDscrd.setDescription('The count of datagrams received that were discarded for reasons other than a problem with the datagram. Same as ipInDiscards in mib-2.')
sfrapPerfMgmtIpIPInDlvrs = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 5, 2, 2, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfMgmtIpIPInDlvrs.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfMgmtIpIPInDlvrs.setDescription('The count of datagrams received that were delivered to IP client-protocols. Same as ipInDelivers in mib-2.')
sfrapPerfMgmtIpIPOutRqst = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 5, 2, 2, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfMgmtIpIPOutRqst.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfMgmtIpIPOutRqst.setDescription('The count of all outgoing datagrams originating in this node. Same as ipOutRequests in mib-2.')
sfrapPerfMgmtIpIPOutDscrd = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 5, 2, 2, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfMgmtIpIPOutDscrd.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfMgmtIpIPOutDscrd.setDescription('The count of outgoing datagrams that were discarded for reasons other than a problem with the datagram. Same as ipOutDiscards in mib-2.')
sfrapPerfMgmtIpIPOutNoRt = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 5, 2, 2, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfMgmtIpIPOutNoRt.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfMgmtIpIPOutNoRt.setDescription('The count of outgoing datagrams that were discarded because no route could be found for transmission. Same as ipOutNoRoutes in mib-2.')
sfrapPerfMgmtIpICMPStatsTable = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 7, 5, 2, 3))
sfrapPerfMgmtIpICMPInMsgs = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 5, 2, 3, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfMgmtIpICMPInMsgs.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfMgmtIpICMPInMsgs.setDescription('The count of all ICMP messages received. Same as icmpInMsgs in mib-2.')
sfrapPerfMgmtIpICMPInErrors = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 5, 2, 3, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfMgmtIpICMPInErrors.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfMgmtIpICMPInErrors.setDescription('The count of ICMP messages received with errors. Same as icmpInErrors in mib-2.')
sfrapPerfMgmtIpICMPInDestUnreachs = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 5, 2, 3, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfMgmtIpICMPInDestUnreachs.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfMgmtIpICMPInDestUnreachs.setDescription('The count of ICMP Destination Unreachable messages received. Same as icmpInDestUnreachs in mib-2.')
sfrapPerfMgmtIpICMPInTimeExcds = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 5, 2, 3, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfMgmtIpICMPInTimeExcds.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfMgmtIpICMPInTimeExcds.setDescription('The count of ICMP Time Exceeded messages received. Same as icmpInTimeExcds in mib-2.')
sfrapPerfMgmtIpICMPInParmProbs = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 5, 2, 3, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfMgmtIpICMPInParmProbs.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfMgmtIpICMPInParmProbs.setDescription('The count of ICMP Parameter Problem messages received. Same as icmpInParmProbs in mib-2.')
sfrapPerfMgmtIpICMPInRedirects = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 5, 2, 3, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfMgmtIpICMPInRedirects.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfMgmtIpICMPInRedirects.setDescription('The count of ICMP Redirect messages received. Same as icmpInRedirects in mib-2.')
sfrapPerfMgmtIpICMPInEchos = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 5, 2, 3, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfMgmtIpICMPInEchos.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfMgmtIpICMPInEchos.setDescription('The count of ICMP Echo messages received. Same as icmpInEchos in mib-2.')
sfrapPerfMgmtIpICMPInEchoReps = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 5, 2, 3, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfMgmtIpICMPInEchoReps.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfMgmtIpICMPInEchoReps.setDescription('The count of ICMP Echo Reply messages received. Same as icmpInEchoReps in mib-2.')
sfrapPerfMgmtIpICMPOutMsgs = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 5, 2, 3, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfMgmtIpICMPOutMsgs.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfMgmtIpICMPOutMsgs.setDescription('The count of all outgoing ICMP messages originating in this node. Same as icmpOutMsgs in mib-2.')
sfrapPerfMgmtIpICMPOutErrors = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 5, 2, 3, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfMgmtIpICMPOutErrors.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfMgmtIpICMPOutErrors.setDescription('The count of outgoing ICMP messages not transmitted due problems found by the ICMP layer. which this entity did Same as icmpOutErrors in mib-2.')
sfrapPerfMgmtIpICMPOutDestUnreachs = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 5, 2, 3, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfMgmtIpICMPOutDestUnreachs.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfMgmtIpICMPOutDestUnreachs.setDescription('The count of outgoing ICMP Destination Unreachable messages. Same as icmpOutDestUnreachs in mib-2.')
sfrapPerfMgmtIpICMPOutParmProbs = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 5, 2, 3, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfMgmtIpICMPOutParmProbs.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfMgmtIpICMPOutParmProbs.setDescription('The count of outgoing ICMP Parameter Problem messages. Same as icmpOutParmProbs in mib-2.')
sfrapPerfMgmtIpICMPOutRedirects = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 5, 2, 3, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfMgmtIpICMPOutRedirects.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfMgmtIpICMPOutRedirects.setDescription('The count of outgoing ICMP Redirect messages. Same as icmpOutRedirects in mib-2.')
sfrapPerfMgmtIpICMPOutEchos = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 5, 2, 3, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfMgmtIpICMPOutEchos.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfMgmtIpICMPOutEchos.setDescription('The count of outgoing ICMP Echo messages. Same as icmpOutEchos in mib-2.')
sfrapPerfMgmtIpICMPOutEchoReps = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 5, 2, 3, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfMgmtIpICMPOutEchoReps.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfMgmtIpICMPOutEchoReps.setDescription('The count of outgoing ICMP Echo Reply messages. Same as icmpOutEchoReps in mib-2.')
sfrapPerfMgmtIpUDPStatsTable = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 7, 5, 2, 4))
sfrapPerfMgmtIpUDPInDatagrams = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 5, 2, 4, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfMgmtIpUDPInDatagrams.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfMgmtIpUDPInDatagrams.setDescription('The count of all UDP datagrams received that are addressed as management frames for this unit. Same as udpInDatagrams in mib-2.')
sfrapPerfMgmtIpUDPOutDatagrams = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 5, 2, 4, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfMgmtIpUDPOutDatagrams.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfMgmtIpUDPOutDatagrams.setDescription('The count of all UDP datagrams generated by this unit. Same as udpOutDatagrams in mib-2.')
sfrapPerfMgmtIpUDPNoPorts = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 5, 2, 4, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfMgmtIpUDPNoPorts.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfMgmtIpUDPNoPorts.setDescription('The count of all UDP datagrams received that are addressed as management frames for this unit with no application at the destination port. Same as udpNoPorts in mib-2.')
sfrapPerfMgmtIpTCPStatsTable = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 7, 5, 2, 5))
sfrapPerfMgmtIpTCPActiveOpens = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 5, 2, 5, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfMgmtIpTCPActiveOpens.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfMgmtIpTCPActiveOpens.setDescription('The count of the times TCP connections specific to this unit have made a direct state transition from CLOSED to SYN-SENT. Same as tcpActiveOpens in mib-2.')
sfrapPerfMgmtIpTCPPassiveOpens = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 5, 2, 5, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfMgmtIpTCPPassiveOpens.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfMgmtIpTCPPassiveOpens.setDescription('The count of the times TCP connections specific to this unit have made a direct state transition from CLOSED to SYN-RCVD. Same as tcpPassiveOpens in mib-2.')
sfrapPerfMgmtIpTCPAttemptFails = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 5, 2, 5, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfMgmtIpTCPAttemptFails.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfMgmtIpTCPAttemptFails.setDescription('The count of the times TCP connections specific to this unit have made a direct state transition from SYN-SENT or SYN-RCVD to CLOSED state, plus the count of the times TCP connections have made a direct state transition from SYN-RCVD to LISTEN. Same as tcpAttemptFails in mib-2.')
sfrapPerfMgmtIpTCPCurrEstab = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 5, 2, 5, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfMgmtIpTCPCurrEstab.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfMgmtIpTCPCurrEstab.setDescription('The count of the TCP connections specific to this unit in state ESTABLISHED or CLOSE-WAIT. Same as tcpCurrEstab in mib-2.')
sfrapPerfMgmtIpTCPInSegs = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 5, 2, 5, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfMgmtIpTCPInSegs.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfMgmtIpTCPInSegs.setDescription('The count of all the segments received that are addressed as management frames for this unit. Same as tcpInSegs in mib-2.')
sfrapPerfMgmtIpTCPOutSegs = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 5, 2, 5, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfMgmtIpTCPOutSegs.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfMgmtIpTCPOutSegs.setDescription('The count of all the segments generated from this unit. Same as tcpOutSegs in mib-2.')
sfrapPerfThruput = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 7, 5, 3))
class Index(Integer32):
    pass

sfrapPerfThruputPerIntfTable = MibTable((1, 3, 6, 1, 4, 1, 485, 7, 5, 3, 1), )
if mibBuilder.loadTexts: sfrapPerfThruputPerIntfTable.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfThruputPerIntfTable.setDescription('The throughput per interface table. These values are accumulated across all DLCIs.')
sfrapPerfThruputPerIntfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 7, 5, 3, 1, 1), ).setIndexNames((0, "SFRAP-MIB", "sfrapPerfThruputPerIntfIndex"))
if mibBuilder.loadTexts: sfrapPerfThruputPerIntfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfThruputPerIntfEntry.setDescription('An entry in the throughput per interface table.')
sfrapPerfThruputPerIntfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("to-dte", 1), ("to-dce", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfThruputPerIntfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfThruputPerIntfIndex.setDescription('Interface for which the statistics apply. (1) TO-DTE interface (2) TO-DCE interface')
sfrapPerfThruputPerIntfRxByteCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 3, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfThruputPerIntfRxByteCnt.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfThruputPerIntfRxByteCnt.setDescription('The number of framed bytes that have been received on this interface.')
sfrapPerfThruputPerIntfTxByteCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 3, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfThruputPerIntfTxByteCnt.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfThruputPerIntfTxByteCnt.setDescription('The number of framed bytes that have been transmitted on this interface.')
sfrapPerfThruputPerIntfRxFrameCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 3, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfThruputPerIntfRxFrameCnt.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfThruputPerIntfRxFrameCnt.setDescription('The number of frames that have been received on this interface.')
sfrapPerfThruputPerIntfTxFrameCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 3, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfThruputPerIntfTxFrameCnt.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfThruputPerIntfTxFrameCnt.setDescription('The number of frames that have been transmitted on this interface.')
sfrapPerfThruputPerIntfRxCrcErrCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 3, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfThruputPerIntfRxCrcErrCnt.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfThruputPerIntfRxCrcErrCnt.setDescription('The number of frames with CRC errors received on this interface.')
sfrapPerfThruputPerIntfRxAbortCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 3, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfThruputPerIntfRxAbortCnt.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfThruputPerIntfRxAbortCnt.setDescription('The number of aborted frames received on this interface.')
sfrapPerfThruputPerIntfRxBpvCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 3, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfThruputPerIntfRxBpvCnt.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfThruputPerIntfRxBpvCnt.setDescription('The number of BPV errors received on this interface.')
sfrapPerfThruputPerDlciTable = MibTable((1, 3, 6, 1, 4, 1, 485, 7, 5, 3, 2), )
if mibBuilder.loadTexts: sfrapPerfThruputPerDlciTable.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfThruputPerDlciTable.setDescription('Layer 2 statistics on a per-DLCI basis. Transmit direction is from TO-DTE to WAN and receive direction is from the WAN towards the TO-DTE.')
sfrapPerfThruputPerDlciEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 7, 5, 3, 2, 1), ).setIndexNames((0, "SFRAP-MIB", "sfrapPerfThruputPerDlciIndex"), (0, "SFRAP-MIB", "sfrapPerfThruputPerDlciValue"))
if mibBuilder.loadTexts: sfrapPerfThruputPerDlciEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfThruputPerDlciEntry.setDescription('The Statistics for a particular Data Link Connection Management Interface (DLCI).')
sfrapPerfThruputPerDlciIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 3, 2, 1, 1), Index()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfThruputPerDlciIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfThruputPerDlciIndex.setDescription('This value must be in the range 1-3. Other than that, this value is ignored as all three will return the same result.')
sfrapPerfThruputPerDlciValue = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 3, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfThruputPerDlciValue.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfThruputPerDlciValue.setDescription('The DLCI value in which the Statistics are associated.')
sfrapPerfThruputPerDlciCreateTime = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 3, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfThruputPerDlciCreateTime.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfThruputPerDlciCreateTime.setDescription('The amount of time elapsed since this DLCI was first detected through traffic sensing or in an LMI message (in seconds).')
sfrapPerfThruputPerDlciChangeTime = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 3, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfThruputPerDlciChangeTime.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfThruputPerDlciChangeTime.setDescription('The amount of elapsed time since this DLCI last changed state from active to inactive or vice versa (in seconds).')
sfrapPerfThruputPerDlciRxByte = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 3, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfThruputPerDlciRxByte.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfThruputPerDlciRxByte.setDescription('The number of bytes that have been received from the WAN towards the DTE on this DLCI. This count will include any frames that are terminated by the unit and do not pass through to the opposite interface (management and networking data).')
sfrapPerfThruputPerDlciTxByte = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 3, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfThruputPerDlciTxByte.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfThruputPerDlciTxByte.setDescription('The number of bytes that have been transmitted from the TO-DTE towards the WAN on this DLCI. This count will include any frames that are terminated by the unit and do not pass through to the opposite interface (management and networking data).')
sfrapPerfThruputPerDlciRxFrame = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 3, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfThruputPerDlciRxFrame.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfThruputPerDlciRxFrame.setDescription('The number of frames that have been received from the WAN towards to the DTE on this DLCI. This count will include any frames that are terminated by the unit and do not pass through to the opposite interface (management and networking data).')
sfrapPerfThruputPerDlciTxFrame = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 3, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfThruputPerDlciTxFrame.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfThruputPerDlciTxFrame.setDescription('The number of frames that have been transmitted from the TO-DTE towards the WAN on this DLCI. This count will include any frames that are terminated by the unit and do not pass through to the opposite interface (management and networking data).')
sfrapPerfThruputPerDlciRxFecn = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 3, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfThruputPerDlciRxFecn.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfThruputPerDlciRxFecn.setDescription('The number of frames received from the WAN towards the TO-DTE that have had the Forward Explict Congestion Notification (FECN) bit set on this DLCI. This count will include any frames that are terminated by the unit and do not pass through to the opposite interface (management and networking data).')
sfrapPerfThruputPerDlciRxBecn = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 3, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfThruputPerDlciRxBecn.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfThruputPerDlciRxBecn.setDescription('The number of frames received from the WAN towards the TO-DTE that have had the Backward Explict Congestion Notification (BECN) bit set on this DLCI. This count will include any frames that are terminated by the unit and do not pass through to the opposite interface (management and networking data).')
sfrapPerfThruputPerDlciRxDe = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 3, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfThruputPerDlciRxDe.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfThruputPerDlciRxDe.setDescription('The number of frames received from the WAN towards the TO-DTE that have had the Discard Eligibility (DE) bit set on this DLCI. This count will include any frames that are terminated by the unit and do not pass through to the opposite interface (management and networking data).')
sfrapPerfThruputPerDlciTxDe = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 3, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfThruputPerDlciTxDe.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfThruputPerDlciTxDe.setDescription('The number of frames transmit towards the WAN from the TO-DTE that have had the Discard Eligibility (DE) bit set on this DLCI. This count will include any frames that are terminated by the unit and do not pass through to the opposite interface (management and networking data).')
sfrapPerfThruputPerDlciRxThruput = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 3, 2, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfThruputPerDlciRxThruput.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfThruputPerDlciRxThruput.setDescription('The number of bits/sec received from the WAN on this DLCI. This count will include any frames that are terminated by the unit and do not pass through to the opposite interface (management and networking data).')
sfrapPerfThruputPerDlciTxThruput = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 3, 2, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfThruputPerDlciTxThruput.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfThruputPerDlciTxThruput.setDescription('The number of bits/sec transmit to the WAN on this DLCI. This count will include any frames that are terminated by the unit and do not pass through to the opposite interface (management and networking data).')
sfrapPerfThruputPerDlciCIR = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 3, 2, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfThruputPerDlciCIR.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfThruputPerDlciCIR.setDescription('The Committed Information Rate (CIR) for this DLCI. This can come form one of three sources: From the LMI Full Status Response, configured by the user, or the DTE line rate (default).')
sfrapPerfThruputPerDlciCirType = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 3, 2, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("cir-acquired-from-lmi", 1), ("cir-configured-by-user", 2), ("cir-is-dte-datarate", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfThruputPerDlciCirType.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfThruputPerDlciCirType.setDescription('The source of the CIR value for this DLCI. (1) CIR acquired from LMI message. Will override user configured CIR. This feature is not supported by all Frame Relay DCE (switches). (2) CIR configured by user. (3) CIR is DTE Line Rate. Default if CIR is not set by one of the other methods.')
sfrapPerfThruputPerDlciUptime = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 3, 2, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfThruputPerDlciUptime.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfThruputPerDlciUptime.setDescription('The total amount of time that the DLCI has been up as reported by the LMI Full Status Response (in seconds).')
sfrapPerfThruputPerDlciDowntime = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 3, 2, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfThruputPerDlciDowntime.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfThruputPerDlciDowntime.setDescription("The total amount of time that the DLCI has been declared down (in seconds). A DLCI is Down if it's explicitly declared Inactive through LMI or if it's missing from the LMI Full Status message or if there is no Full Status message at all.")
sfrapPerfThruputPerDlciPvcState = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 3, 2, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("pvc-active", 1), ("pvc-inactive", 2), ("pvc-unprovisioned", 3), ("pvc-not-in-lmi", 4), ("pvc-lmi-timeout", 5), ("pvc-undetermined", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfThruputPerDlciPvcState.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfThruputPerDlciPvcState.setDescription('The current state of the DLCI: (1) DLCI marked active in last full status LMI (2) DLCI in last full status LMI but not marked active (3) DLCI has never been seen in a full status LMI (4) DLCI was seen at least once in a full status LMI but was not in the last full status LMI (5) the full status LMI has timed out; all previously active or inactive DLCIs are changed to this state (6) DLCI was detected in the traffic stream and a full status LMI has not been received so the state cannot be determined yet. ')
sfrapPerfThruputPerDlciOutageCount = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 3, 2, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfThruputPerDlciOutageCount.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfThruputPerDlciOutageCount.setDescription('The number of times the smperPerfThruputPerDlciPvcState transitions from pvc-active or pvc-undetermined to one of the other (inactive) states. ')
sfrapPerfThruputPerDlciAvailability = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 3, 2, 1, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfThruputPerDlciAvailability.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfThruputPerDlciAvailability.setDescription('The measure of the percentage time the DLCI is available: UpTime/CreateTime or zero if CreateTime = 0. (in 1/1000 per cent; i.e. availability = 1000 converts to 1%). ')
sfrapPerfThruputPerDlciMTBSO = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 3, 2, 1, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfThruputPerDlciMTBSO.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfThruputPerDlciMTBSO.setDescription('Mean Time Between Service Outages: UpTime/OutageCount or zero if OutageCount = 0 (in seconds). ')
sfrapPerfThruputPerDlciMTTSR = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 3, 2, 1, 23), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfThruputPerDlciMTTSR.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfThruputPerDlciMTTSR.setDescription('Mean Time to ServiceRestoral: DownTime/OutageCount or zero if OutageCount = 0 (in seconds). ')
sfrapPerfThruputPerDlciEncapType = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 3, 2, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("encap-na", 1), ("encap-1490", 2), ("encap-cisco", 3), ("encap-annex-g", 4), ("encap-other", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfThruputPerDlciEncapType.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfThruputPerDlciEncapType.setDescription('The encapsulation protocol seen in the last frame analyzed on this DLCI: (1) DLCI is the LMI DLCI or no frames have been analyzed (2) The encapsulation is per rfc1490 (3) The encapsulation is per Cisco proprietary (4) The encapsulation is per Annex-G (X.25 over frame relay) (5) The encapsulation is not one of the above. ')
sfrapPerfThruputPerDlciRxUtilizationStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 3, 2, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("clear", 1), ("over-threshold", 2), ("alarm", 3), ("alarm-under-threshold", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfThruputPerDlciRxUtilizationStatus.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfThruputPerDlciRxUtilizationStatus.setDescription('The status of the per-DLCI utilization alarm in the receive direction. (1) there is no alarm condition; utilization is under the configured CIR percentage threshold; if traps are enabled and the alarm had been previously triggered, a utilization alarm clear trap will be sent. (2) the utilization has been over the configured CIR percentage threshold for less than the configured duration. (3) the utilization has been over the configured CIR percentage threshold for more than the configured duration; if traps are enabled a utilization exceeded trap will be sent. (4) the utilization has been under the configured CIR percentage threshold for less than the configured duration. ')
sfrapPerfThruputPerDlciTxUtilizationStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 3, 2, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("clear", 1), ("over-threshold", 2), ("alarm", 3), ("alarm-under-threshold", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfThruputPerDlciTxUtilizationStatus.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfThruputPerDlciTxUtilizationStatus.setDescription('The status of the per-DLCI utilization alarm in the transmit direction. (1) there is no alarm condition; utilization is under the configured CIR percentage threshold; if traps are enabled and the alarm had been previously triggered, a utilization alarm clear trap will be sent. (2) the utilization has been over the configured CIR percentage threshold for less than the configured duration. (3) the utilization has been over the configured CIR percentage threshold for more than the configured duration; if traps are enabled a utilization exceeded trap will be sent. (4) the utilization has been under the configured CIR percentage threshold for less than the configured duration. ')
sfrapPerfThruputPerDlciEIR = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 3, 2, 1, 27), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfThruputPerDlciEIR.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfThruputPerDlciEIR.setDescription('The Excess Information Rate. This is defined to be the maximum rate traffic is (supposed to be) allowed to burst to.')
sfrapPerfThruputCommands = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 7, 5, 3, 3))
sfrapPerfThruputCmdClearToDteStats = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 5, 3, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("clear-statistics", 1)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: sfrapPerfThruputCmdClearToDteStats.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfThruputCmdClearToDteStats.setDescription('Allows the user to zero out all the interface statistics in the TO-DTE portion of the ThruputPerIntf statistics table. (1) Clear TO-DTE interface statistics command.')
sfrapPerfThruputCmdClearToDceStats = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 5, 3, 3, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("clear-statistics", 1)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: sfrapPerfThruputCmdClearToDceStats.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfThruputCmdClearToDceStats.setDescription('Allows the user to zero out all the interface statistics in the WAN portion of the ThruputPerIntf statistics table. (1) Clear WAN interface statistics command.')
sfrapPerfThruputCmdClearAllIntfStats = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 5, 3, 3, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("clear-statistics", 1)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: sfrapPerfThruputCmdClearAllIntfStats.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfThruputCmdClearAllIntfStats.setDescription('Allows the user to zero out all the statistics in the ThruputPerIntf statistics table.')
sfrapPerfThruputCmdClearDlciStats = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 5, 3, 3, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("clear-statistics", 1)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: sfrapPerfThruputCmdClearDlciStats.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfThruputCmdClearDlciStats.setDescription('Allows the user to zero out all the per-DLCI statistics in the ThruputPerDlci statistics table and the the short term statistics tables. (1) Clear layer 2 per-DLCI statistics command.')
sfrapPerfThruputCmdClearAllStats = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 5, 3, 3, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("clear-statistics", 1)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: sfrapPerfThruputCmdClearAllStats.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfThruputCmdClearAllStats.setDescription('Allows the user to zero out all the statistics in the ThruputPerIntf and ThruputPerDlci statistics tables and in the short term statistics tables. (1) Clear all interface and layer 2 per-DLCI statistics.')
sfrapPerfThruputCmdRemoveStsDlci = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 5, 3, 3, 6), Integer32()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: sfrapPerfThruputCmdRemoveStsDlci.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfThruputCmdRemoveStsDlci.setDescription('Allows the user to remove a Dlci from the short term statistics tables.')
sfrapPerfThruputCmdReplaceDlciTable = MibTable((1, 3, 6, 1, 4, 1, 485, 7, 5, 3, 3, 7), )
if mibBuilder.loadTexts: sfrapPerfThruputCmdReplaceDlciTable.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfThruputCmdReplaceDlciTable.setDescription('Allows the user to replace one DLCI in the short-term statistics table with another one.')
sfrapPerfThruputCmdReplaceDlciEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 7, 5, 3, 3, 7, 1), ).setIndexNames((0, "SFRAP-MIB", "sfrapPerfThruputCmdReplaceDlciValue"))
if mibBuilder.loadTexts: sfrapPerfThruputCmdReplaceDlciEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfThruputCmdReplaceDlciEntry.setDescription('Allows the user to replace one DLCI in the short-term statistics table with another one.')
sfrapPerfThruputCmdReplaceDlciValue = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 3, 3, 7, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfThruputCmdReplaceDlciValue.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfThruputCmdReplaceDlciValue.setDescription('A Dlci that is in the short-term stats table. Index by this Dlci value to identify the statistics entry to be replaced.')
sfrapPerfThruputCmdReplaceDlciNewValue = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 3, 3, 7, 1, 2), Integer32()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: sfrapPerfThruputCmdReplaceDlciNewValue.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfThruputCmdReplaceDlciNewValue.setDescription('A Dlci that is to replace another in the short-term stats table. Index by this Dlci value to identify the statistics entry to do the replacing.')
sfrapPerfThruputCmdAvailabilityStsDlciReset = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 5, 3, 3, 8), Integer32()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: sfrapPerfThruputCmdAvailabilityStsDlciReset.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfThruputCmdAvailabilityStsDlciReset.setDescription('Allows the user to reset the availability statistics of an individual Dlci within the short-term stats table.')
sfrapPerfThruputCmdAvailabilityStsDlciResetAll = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 5, 3, 3, 9), Integer32()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: sfrapPerfThruputCmdAvailabilityStsDlciResetAll.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfThruputCmdAvailabilityStsDlciResetAll.setDescription("Allows the user to reset the availability statistics of all Dlci's within the short-term stats table.")
sfrapPerfThruputCmdCountsStsDlciReset = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 5, 3, 3, 10), Integer32()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: sfrapPerfThruputCmdCountsStsDlciReset.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfThruputCmdCountsStsDlciReset.setDescription('Allows the user to reset the count statistics of an individual Dlci within the short-term stats table.')
sfrapPerfThruputCmdCountsStsDlciResetAll = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 5, 3, 3, 11), Integer32()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: sfrapPerfThruputCmdCountsStsDlciResetAll.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfThruputCmdCountsStsDlciResetAll.setDescription("Allows the user to reset the count statistics of all Dlci's within the short-term stats table.")
sfrapPerfThruputCmdAllStsDlciReset = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 5, 3, 3, 12), Integer32()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: sfrapPerfThruputCmdAllStsDlciReset.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfThruputCmdAllStsDlciReset.setDescription('Allows the user to reset both the count and availability statistics of an individual Dlci within the short-term stats table.')
sfrapPerfThruputCmdAllStsDlciResetAll = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 5, 3, 3, 13), Integer32()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: sfrapPerfThruputCmdAllStsDlciResetAll.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfThruputCmdAllStsDlciResetAll.setDescription("Allows the user to reset both the count and the availability statistics of all Dlci's within the short-term stats table.")
sfrapPerfNetworkShortTerm = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 7, 5, 4))
sfrapPerfNetwProtoPerDlciTable = MibTable((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 1), )
if mibBuilder.loadTexts: sfrapPerfNetwProtoPerDlciTable.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfNetwProtoPerDlciTable.setDescription('The Short Term Statistics on the Network Layer protocol for each DLCI. These are protocol-based per-DLCI statistics. The Short Term model maintains three intervals: current, previous, and cumulative totals. Interval duration is defined by the Short Term Timer (CfgFrPerfTimersSTInterval).')
sfrapPerfNetwProtoPerDlciEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 1, 1), ).setIndexNames((0, "SFRAP-MIB", "sfrapPerfNetwProtoPerDlciInterval"), (0, "SFRAP-MIB", "sfrapPerfNetwProtoPerDlciValue"))
if mibBuilder.loadTexts: sfrapPerfNetwProtoPerDlciEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfNetwProtoPerDlciEntry.setDescription('The Network Layer Short Term Statistics for a particular DLCI. This table organizes statistics by high-layer network protocol.')
sfrapPerfNetwProtoPerDlciInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("current-interval", 1), ("previous-interval", 2), ("cumulative-counts", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfNetwProtoPerDlciInterval.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfNetwProtoPerDlciInterval.setDescription('The Short Term statistics model maintains three intervals: current, previous, and cumulative totals. Interval duration is defined by the Short Term Timer (CfgFrPerfTimersSTInterval). (1) Currently active short term interval (2) Previously completed short term interval (3) Cumulative total since last cleared.')
sfrapPerfNetwProtoPerDlciValue = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfNetwProtoPerDlciValue.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfNetwProtoPerDlciValue.setDescription('The DLCI value with which the Statistics are associated.')
sfrapPerfNetwProtoPerDlciRxTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfNetwProtoPerDlciRxTotal.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfNetwProtoPerDlciRxTotal.setDescription('The total number of received Network Layer bytes that have been counted on this DLCI.')
sfrapPerfNetwProtoPerDlciTxTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfNetwProtoPerDlciTxTotal.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfNetwProtoPerDlciTxTotal.setDescription('The total number of transmitted Network Layer bytes that have been counted on this DLCI.')
sfrapPerfNetwProtoPerDlciRxIp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfNetwProtoPerDlciRxIp.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfNetwProtoPerDlciRxIp.setDescription('The number of received IP bytes that have been counted on this DLCI.')
sfrapPerfNetwProtoPerDlciTxIp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfNetwProtoPerDlciTxIp.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfNetwProtoPerDlciTxIp.setDescription('The number of transmitted IP bytes that have been counted on this DLCI.')
sfrapPerfNetwProtoPerDlciRxIpx = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfNetwProtoPerDlciRxIpx.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfNetwProtoPerDlciRxIpx.setDescription('The number of received IPX bytes that have been counted on this DLCI.')
sfrapPerfNetwProtoPerDlciTxIpx = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfNetwProtoPerDlciTxIpx.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfNetwProtoPerDlciTxIpx.setDescription('The number of transmitted IPX bytes that have been counted on this DLCI.')
sfrapPerfNetwProtoPerDlciRxSna = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfNetwProtoPerDlciRxSna.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfNetwProtoPerDlciRxSna.setDescription('The number of received SNA bytes that have been counted on this DLCI.')
sfrapPerfNetwProtoPerDlciTxSna = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfNetwProtoPerDlciTxSna.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfNetwProtoPerDlciTxSna.setDescription('The number of transmitted SNA bytes that have been counted on this DLCI.')
sfrapPerfNetwProtoPerDlciRxArp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfNetwProtoPerDlciRxArp.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfNetwProtoPerDlciRxArp.setDescription('The number of received ARP bytes that have been counted on this DLCI.')
sfrapPerfNetwProtoPerDlciTxArp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfNetwProtoPerDlciTxArp.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfNetwProtoPerDlciTxArp.setDescription('The number of transmitted ARP bytes that have been counted on this DLCI.')
sfrapPerfNetwProtoPerDlciRxCisco = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfNetwProtoPerDlciRxCisco.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfNetwProtoPerDlciRxCisco.setDescription('The number of received Cisco protocol bytes that have been counted on this DLCI.')
sfrapPerfNetwProtoPerDlciTxCisco = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfNetwProtoPerDlciTxCisco.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfNetwProtoPerDlciTxCisco.setDescription('The number of transmitted Cisco protocol bytes that have been counted on this DLCI.')
sfrapPerfNetwProtoPerDlciRxOther = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfNetwProtoPerDlciRxOther.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfNetwProtoPerDlciRxOther.setDescription('The number of received bytes on this DLCI from protocols that are not counted elsewhere in this table.')
sfrapPerfNetwProtoPerDlciTxOther = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfNetwProtoPerDlciTxOther.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfNetwProtoPerDlciTxOther.setDescription('The number of transmitted bytes on this DLCI from protocols that are not counted elsewhere in this table.')
sfrapPerfNetwProtoPerDlciRxVnip = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfNetwProtoPerDlciRxVnip.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfNetwProtoPerDlciRxVnip.setDescription('The number of received VNIP protocol bytes that have been counted on this DLCI.')
sfrapPerfNetwProtoPerDlciTxVnip = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfNetwProtoPerDlciTxVnip.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfNetwProtoPerDlciTxVnip.setDescription('The number of transmitted VNIP protocol bytes that have been counted on this DLCI.')
sfrapPerfNetwProtoPerDlciRxAnnexG = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfNetwProtoPerDlciRxAnnexG.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfNetwProtoPerDlciRxAnnexG.setDescription('The number of received Annex G protocol bytes that have been counted on this DLCI.')
sfrapPerfNetwProtoPerDlciTxAnnexG = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfNetwProtoPerDlciTxAnnexG.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfNetwProtoPerDlciTxAnnexG.setDescription('The number of transmitted Annex G protocol bytes that have been counted on this DLCI.')
sfrapPerfNetwProtoTotalTable = MibTable((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 2), )
if mibBuilder.loadTexts: sfrapPerfNetwProtoTotalTable.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfNetwProtoTotalTable.setDescription('The Short Term Statistics on Network Layer protocols summed across all DLCIs.')
sfrapPerfNetwProtoTotalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 2, 1), ).setIndexNames((0, "SFRAP-MIB", "sfrapPerfNetwProtoTotalInterval"))
if mibBuilder.loadTexts: sfrapPerfNetwProtoTotalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfNetwProtoTotalEntry.setDescription('The Network Layer Short Term Statistics for a particular DLCI.')
sfrapPerfNetwProtoTotalInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("current-interval", 1), ("previous-interval", 2), ("cumulative-counts", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfNetwProtoTotalInterval.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfNetwProtoTotalInterval.setDescription('The Short Term statistics model maintains three intervals: current, previous, and cumulative totals. Interval duration is defined by the Short Term Timer (CfgFrPerfTimersSTInterval). (1) Currently active short term interval (2) Previously completed short term interval (3) Cumulative total since last cleared.')
sfrapPerfNetwProtoTotalRxTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfNetwProtoTotalRxTotal.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfNetwProtoTotalRxTotal.setDescription('The total number of received Network Layer bytes that have been counted across all DLCIs.')
sfrapPerfNetwProtoTotalTxTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfNetwProtoTotalTxTotal.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfNetwProtoTotalTxTotal.setDescription('The total number of transmitted Network Layer bytes that have been counted across all DLCIs.')
sfrapPerfNetwProtoTotalRxIp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfNetwProtoTotalRxIp.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfNetwProtoTotalRxIp.setDescription('The number of received IP bytes that have been counted across all DLCIs.')
sfrapPerfNetwProtoTotalTxIp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfNetwProtoTotalTxIp.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfNetwProtoTotalTxIp.setDescription('The number of transmitted IP bytes that have been counted across all DLCIs.')
sfrapPerfNetwProtoTotalRxIpx = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfNetwProtoTotalRxIpx.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfNetwProtoTotalRxIpx.setDescription('The number of received IPX bytes that have been counted across all DLCIs.')
sfrapPerfNetwProtoTotalTxIpx = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfNetwProtoTotalTxIpx.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfNetwProtoTotalTxIpx.setDescription('The number of transmitted IPX bytes that have been counted across all DLCIs.')
sfrapPerfNetwProtoTotalRxSna = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfNetwProtoTotalRxSna.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfNetwProtoTotalRxSna.setDescription('The number of received SNA bytes that have been counted across all DLCIs.')
sfrapPerfNetwProtoTotalTxSna = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfNetwProtoTotalTxSna.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfNetwProtoTotalTxSna.setDescription('The number of transmitted SNA bytes that have been counted across all DLCIs.')
sfrapPerfNetwProtoTotalRxArp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfNetwProtoTotalRxArp.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfNetwProtoTotalRxArp.setDescription('The number of received ARP bytes that have been counted across all DLCIs.')
sfrapPerfNetwProtoTotalTxArp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfNetwProtoTotalTxArp.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfNetwProtoTotalTxArp.setDescription('The number of transmitted ARP bytes that have been counted across all DLCIs.')
sfrapPerfNetwProtoTotalRxCisco = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfNetwProtoTotalRxCisco.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfNetwProtoTotalRxCisco.setDescription('The number of received Cisco protocol bytes that have been counted across all DLCIs.')
sfrapPerfNetwProtoTotalTxCisco = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfNetwProtoTotalTxCisco.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfNetwProtoTotalTxCisco.setDescription('The number of transmitted Cisco protocol bytes that have been counted across all DLCIs.')
sfrapPerfNetwProtoTotalRxOther = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfNetwProtoTotalRxOther.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfNetwProtoTotalRxOther.setDescription('The number of received bytes across all DLCIs from protocols that are not counted elsewhere in this table.')
sfrapPerfNetwProtoTotalTxOther = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 2, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfNetwProtoTotalTxOther.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfNetwProtoTotalTxOther.setDescription('The number of transmitted bytes across all DLCIs from protocols that are not counted elsewhere in this table.')
sfrapPerfNetwProtoTotalRxVnip = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 2, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfNetwProtoTotalRxVnip.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfNetwProtoTotalRxVnip.setDescription('The number of received VNIP protocol bytes that have been counted across all DLCIs.')
sfrapPerfNetwProtoTotalTxVnip = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 2, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfNetwProtoTotalTxVnip.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfNetwProtoTotalTxVnip.setDescription('The number of transmitted VNIP protocol bytes that have been counted across all DLCIs.')
sfrapPerfNetwProtoTotalRxAnnexG = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 2, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfNetwProtoTotalRxAnnexG.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfNetwProtoTotalRxAnnexG.setDescription('The number of received Annex G protocol bytes that have been counted across all DLCIs.')
sfrapPerfNetwProtoTotalTxAnnexG = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 2, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfNetwProtoTotalTxAnnexG.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfNetwProtoTotalTxAnnexG.setDescription('The number of transmitted Annex G protocol bytes that have been counted across all DLCIs.')
sfrapPerfIpPerDlciTable = MibTable((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 3), )
if mibBuilder.loadTexts: sfrapPerfIpPerDlciTable.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIpPerDlciTable.setDescription('The Short Term Statistics on the IP protocol for each DLCI.')
sfrapPerfIpPerDlciEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 3, 1), ).setIndexNames((0, "SFRAP-MIB", "sfrapPerfIpPerDlciInterval"), (0, "SFRAP-MIB", "sfrapPerfIpPerDlciValue"))
if mibBuilder.loadTexts: sfrapPerfIpPerDlciEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIpPerDlciEntry.setDescription('The IP Short Term Statistics for a particular DLCI.')
sfrapPerfIpPerDlciInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("current-interval", 1), ("previous-interval", 2), ("cumulative-counts", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIpPerDlciInterval.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIpPerDlciInterval.setDescription('The Short Term statistics model maintains three intervals: current, previous, and cumulative totals. Interval duration is defined by the Short Term Timer (CfgFrPerfTimersSTInterval). (1) Currently active short term interval (2) Previously completed short term interval (3) Cumulative total since last cleared.')
sfrapPerfIpPerDlciValue = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIpPerDlciValue.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIpPerDlciValue.setDescription('The DLCI value with which the Statistics are associated.')
sfrapPerfIpPerDlciRxTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 3, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIpPerDlciRxTotal.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIpPerDlciRxTotal.setDescription('The total number of received IP bytes that have been counted on this DLCI.')
sfrapPerfIpPerDlciTxTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIpPerDlciTxTotal.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIpPerDlciTxTotal.setDescription('The total number of transmitted IP bytes that have been counted on this DLCI.')
sfrapPerfIpPerDlciRxTcp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIpPerDlciRxTcp.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIpPerDlciRxTcp.setDescription('The number of received TCP over IP bytes that have been counted on this DLCI.')
sfrapPerfIpPerDlciTxTcp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIpPerDlciTxTcp.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIpPerDlciTxTcp.setDescription('The number of transmitted TCP over IP bytes that have been counted on this DLCI.')
sfrapPerfIpPerDlciRxUdp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIpPerDlciRxUdp.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIpPerDlciRxUdp.setDescription('The number of received UDP over IP bytes that have been counted on this DLCI.')
sfrapPerfIpPerDlciTxUdp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 3, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIpPerDlciTxUdp.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIpPerDlciTxUdp.setDescription('The number of transmitted UDP over IP bytes that have been counted on this DLCI.')
sfrapPerfIpPerDlciRxIcmp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 3, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIpPerDlciRxIcmp.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIpPerDlciRxIcmp.setDescription('The number of received ICMP over IP bytes that have been counted on this DLCI.')
sfrapPerfIpPerDlciTxIcmp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 3, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIpPerDlciTxIcmp.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIpPerDlciTxIcmp.setDescription('The number of transmitted ICMP over IP bytes that have been counted on this DLCI.')
sfrapPerfIpPerDlciRxOther = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 3, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIpPerDlciRxOther.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIpPerDlciRxOther.setDescription('The number of received bytes on this DLCI from protocols over IP that are not counted elsewhere in this table.')
sfrapPerfIpPerDlciTxOther = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 3, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIpPerDlciTxOther.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIpPerDlciTxOther.setDescription('The number of transmitted bytes on this DLCI from protocols over IP that are not counted elsewhere in this table.')
sfrapPerfIpPerDlciRxIgrp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 3, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIpPerDlciRxIgrp.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIpPerDlciRxIgrp.setDescription('The number of received IGRP over IP bytes that have been counted on this DLCI.')
sfrapPerfIpPerDlciTxIgrp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 3, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIpPerDlciTxIgrp.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIpPerDlciTxIgrp.setDescription('The number of transmitted IGRP over IP bytes that have been counted on this DLCI.')
sfrapPerfIpTotalTable = MibTable((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 4), )
if mibBuilder.loadTexts: sfrapPerfIpTotalTable.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIpTotalTable.setDescription('The Short Term Statistics on the IP protocol across all DLCIs.')
sfrapPerfIpTotalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 4, 1), ).setIndexNames((0, "SFRAP-MIB", "sfrapPerfIpTotalInterval"))
if mibBuilder.loadTexts: sfrapPerfIpTotalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIpTotalEntry.setDescription('The IP Short Term Statistics across all DLCIs.')
sfrapPerfIpTotalInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 4, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("current-interval", 1), ("previous-interval", 2), ("cumulative-counts", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIpTotalInterval.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIpTotalInterval.setDescription('The Short Term statistics model maintains three intervals: current, previous, and cumulative totals. Interval duration is defined by the Short Term Timer (CfgFrPerfTimersSTInterval). (1) Currently active short term interval (2) Previously completed short term interval (3) Cumulative total since last cleared.')
sfrapPerfIpTotalRxTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 4, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIpTotalRxTotal.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIpTotalRxTotal.setDescription('The total number of received IP bytes that have been counted across all DLCIs.')
sfrapPerfIpTotalTxTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIpTotalTxTotal.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIpTotalTxTotal.setDescription('The total number of transmitted IP bytes that have been counted across all DLCIs.')
sfrapPerfIpTotalRxTcp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 4, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIpTotalRxTcp.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIpTotalRxTcp.setDescription('The number of received TCP over IP bytes that have been counted across all DLCIs.')
sfrapPerfIpTotalTxTcp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 4, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIpTotalTxTcp.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIpTotalTxTcp.setDescription('The number of transmitted TCP over IP bytes that have been counted across all DLCIs.')
sfrapPerfIpTotalRxUdp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 4, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIpTotalRxUdp.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIpTotalRxUdp.setDescription('The number of received UDP over IP bytes that have been counted across all DLCIs.')
sfrapPerfIpTotalTxUdp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 4, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIpTotalTxUdp.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIpTotalTxUdp.setDescription('The number of transmitted UDP over IP bytes that have been counted across all DLCIs.')
sfrapPerfIpTotalRxIcmp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 4, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIpTotalRxIcmp.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIpTotalRxIcmp.setDescription('The number of received ICMP over IP bytes that have been counted across all DLCIs.')
sfrapPerfIpTotalTxIcmp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 4, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIpTotalTxIcmp.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIpTotalTxIcmp.setDescription('The number of transmitted ICMP over IP bytes that have been counted across all DLCIs.')
sfrapPerfIpTotalRxOther = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 4, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIpTotalRxOther.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIpTotalRxOther.setDescription('The number of received bytes across all DLCIs from protocols over IP that are not counted elsewhere in this table.')
sfrapPerfIpTotalTxOther = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 4, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIpTotalTxOther.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIpTotalTxOther.setDescription('The number of transmitted bytes across all DLCIs. from protocols over IP that are not counted elsewhere in this table.')
sfrapPerfIpTotalRxIgrp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 4, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIpTotalRxIgrp.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIpTotalRxIgrp.setDescription('The number of received IGRP over IP bytes that have been counted across all DLCIs.')
sfrapPerfIpTotalTxIgrp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 4, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIpTotalTxIgrp.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIpTotalTxIgrp.setDescription('The number of transmitted IGRP over IP bytes that have been counted across all DLCIs.')
sfrapPerfIcmpPerDlciTable = MibTable((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 5), )
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciTable.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciTable.setDescription('Short Term Statistics on the ICMP protocol for each DLCI.')
sfrapPerfIcmpPerDlciEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 5, 1), ).setIndexNames((0, "SFRAP-MIB", "sfrapPerfIcmpPerDlciInterval"), (0, "SFRAP-MIB", "sfrapPerfIcmpPerDlciValue"))
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciEntry.setDescription('The ICMP Short Term Statistics for a particular DLCI.')
sfrapPerfIcmpPerDlciInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 5, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("current-interval", 1), ("previous-interval", 2), ("cumulative-counts", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciInterval.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciInterval.setDescription('The Short Term statistics model maintains three intervals: current, previous, and cumulative totals. Interval duration is defined by the Short Term Timer (CfgFrPerfTimersSTInterval). (1) Currently active short term interval (2) Previously completed short term interval (3) Cumulative total since last cleared.')
sfrapPerfIcmpPerDlciValue = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 5, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciValue.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciValue.setDescription('The DLCI value in which the Statistics are associated.')
sfrapPerfIcmpPerDlciRxTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 5, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciRxTotal.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciRxTotal.setDescription('The total number of ICMP bytes that have been counted on this DLCI.')
sfrapPerfIcmpPerDlciTxTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 5, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciTxTotal.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciTxTotal.setDescription('The total number of ICMP bytes that have been counted on this DLCI.')
sfrapPerfIcmpPerDlciRxEchoRep = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 5, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciRxEchoRep.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciRxEchoRep.setDescription('The number of bytes in ICMP ECHO replies that have been counted on this DLCI.')
sfrapPerfIcmpPerDlciTxEchoRep = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 5, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciTxEchoRep.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciTxEchoRep.setDescription('The number of bytes in ICMP ECHO replies that have been counted on this DLCI.')
sfrapPerfIcmpPerDlciRxDestUnr = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 5, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciRxDestUnr.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciRxDestUnr.setDescription('The number of bytes in ICMP destination unreachables that have been counted on this DLCI.')
sfrapPerfIcmpPerDlciTxDestUnr = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 5, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciTxDestUnr.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciTxDestUnr.setDescription('The number of bytes in ICMP destination unreachables that have been counted on this DLCI.')
sfrapPerfIcmpPerDlciRxSrcQuench = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 5, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciRxSrcQuench.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciRxSrcQuench.setDescription('The number of bytes in ICMP source quenches that have been counted on this DLCI.')
sfrapPerfIcmpPerDlciTxSrcQuench = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 5, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciTxSrcQuench.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciTxSrcQuench.setDescription('The number of bytes in ICMP source quenches that have been counted on this DLCI.')
sfrapPerfIcmpPerDlciRxRedirect = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 5, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciRxRedirect.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciRxRedirect.setDescription('The number of bytes in ICMP redirects that have been counted on this DLCI.')
sfrapPerfIcmpPerDlciTxRedirect = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 5, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciTxRedirect.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciTxRedirect.setDescription('The number of bytes in ICMP redirects that have been counted on this DLCI.')
sfrapPerfIcmpPerDlciRxEchoReq = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 5, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciRxEchoReq.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciRxEchoReq.setDescription('The number of bytes in ICMP ECHO requests that have been counted on this DLCI.')
sfrapPerfIcmpPerDlciTxEchoReq = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 5, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciTxEchoReq.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciTxEchoReq.setDescription('The number of bytes in ICMP ECHO requests that have been counted on this DLCI.')
sfrapPerfIcmpPerDlciRxTimeExcd = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 5, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciRxTimeExcd.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciRxTimeExcd.setDescription('The number of bytes in ICMP time exceededs that have been counted on this DLCI.')
sfrapPerfIcmpPerDlciTxTimeExcd = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 5, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciTxTimeExcd.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciTxTimeExcd.setDescription('The number of bytes in ICMP time exceededs that have been counted on this DLCI.')
sfrapPerfIcmpPerDlciRxParamProb = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 5, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciRxParamProb.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciRxParamProb.setDescription('The number of bytes in ICMP parameter problems that have been counted on this DLCI.')
sfrapPerfIcmpPerDlciTxParamProb = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 5, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciTxParamProb.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciTxParamProb.setDescription('The number of bytes in ICMP parameter problems that have been counted on this DLCI.')
sfrapPerfIcmpPerDlciRxTimestpReq = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 5, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciRxTimestpReq.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciRxTimestpReq.setDescription('The number of bytes in ICMP timestamp requests that have been counted on this DLCI.')
sfrapPerfIcmpPerDlciTxTimestpReq = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 5, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciTxTimestpReq.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciTxTimestpReq.setDescription('The number of bytes in ICMP timestamp requests that have been counted on this DLCI.')
sfrapPerfIcmpPerDlciRxTimestpRep = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 5, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciRxTimestpRep.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciRxTimestpRep.setDescription('The number of bytes in ICMP timestamp replies that have been counted on this DLCI.')
sfrapPerfIcmpPerDlciTxTimestpRep = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 5, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciTxTimestpRep.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciTxTimestpRep.setDescription('The number of bytes in ICMP timestamp replies that have been counted on this DLCI.')
sfrapPerfIcmpPerDlciRxAddrMaskReq = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 5, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciRxAddrMaskReq.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciRxAddrMaskReq.setDescription('The number of bytes in ICMP address mask requests that have been counted on this DLCI.')
sfrapPerfIcmpPerDlciTxAddrMaskReq = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 5, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciTxAddrMaskReq.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciTxAddrMaskReq.setDescription('The number of bytes in ICMP address mask requests that have been counted on this DLCI.')
sfrapPerfIcmpPerDlciRxAddrMaskRep = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 5, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciRxAddrMaskRep.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciRxAddrMaskRep.setDescription('The number of bytes in ICMP address mask replies that have been counted on this DLCI.')
sfrapPerfIcmpPerDlciTxAddrMaskRep = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 5, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciTxAddrMaskRep.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciTxAddrMaskRep.setDescription('The number of bytes in ICMP address mask replies that have been counted on this DLCI.')
sfrapPerfIcmpPerDlciRxPktTooBig = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 5, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciRxPktTooBig.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciRxPktTooBig.setDescription('The number of bytes in ICMP packet too bigs that have been counted on this DLCI.')
sfrapPerfIcmpPerDlciTxPktTooBig = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 5, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciTxPktTooBig.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciTxPktTooBig.setDescription('The number of bytes in ICMP packet too bigs that have been counted on this DLCI.')
sfrapPerfIcmpPerDlciRxGmQuery = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 5, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciRxGmQuery.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciRxGmQuery.setDescription('The number of bytes in ICMP group membership queries that have been counted on this DLCI.')
sfrapPerfIcmpPerDlciTxGmQuery = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 5, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciTxGmQuery.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciTxGmQuery.setDescription('The number of bytes in ICMP group membership queries that have been counted on this DLCI.')
sfrapPerfIcmpPerDlciRxGmReport = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 5, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciRxGmReport.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciRxGmReport.setDescription('The number of bytes in ICMP group membership reports that have been counted on this DLCI.')
sfrapPerfIcmpPerDlciTxGmReport = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 5, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciTxGmReport.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciTxGmReport.setDescription('The number of bytes in ICMP group membership reports that have been counted on this DLCI.')
sfrapPerfIcmpPerDlciRxGmReduct = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 5, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciRxGmReduct.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciRxGmReduct.setDescription('The number of bytes in ICMP group membership reductions that have been counted on this DLCI.')
sfrapPerfIcmpPerDlciTxGmReduct = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 5, 1, 34), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciTxGmReduct.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIcmpPerDlciTxGmReduct.setDescription('The number of bytes in ICMP group membership reductions that have been counted on this DLCI.')
sfrapPerfIcmpTotalTable = MibTable((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 6), )
if mibBuilder.loadTexts: sfrapPerfIcmpTotalTable.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIcmpTotalTable.setDescription('Short Term Statistics on the ICMP protocol across all DLCIs.')
sfrapPerfIcmpTotalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 6, 1), ).setIndexNames((0, "SFRAP-MIB", "sfrapPerfIcmpTotalInterval"))
if mibBuilder.loadTexts: sfrapPerfIcmpTotalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIcmpTotalEntry.setDescription('The ICMP Short Term Statistics for a particular DLCI.')
sfrapPerfIcmpTotalInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 6, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("current-interval", 1), ("previous-interval", 2), ("cumulative-counts", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIcmpTotalInterval.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIcmpTotalInterval.setDescription('The Short Term statistics model maintains three intervals: current, previous, and cumulative totals. Interval duration is defined by the Short Term Timer (CfgFrPerfTimersSTInterval). (1) Currently active short term interval (2) Previously completed short term interval (3) Cumulative total since last cleared.')
sfrapPerfIcmpTotalRxTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 6, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIcmpTotalRxTotal.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIcmpTotalRxTotal.setDescription('The total number of ICMP bytes that have been counted across all DLCIs.')
sfrapPerfIcmpTotalTxTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 6, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIcmpTotalTxTotal.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIcmpTotalTxTotal.setDescription('The total number of ICMP bytes that have been counted across all DLCIs.')
sfrapPerfIcmpTotalRxEchoRep = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 6, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIcmpTotalRxEchoRep.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIcmpTotalRxEchoRep.setDescription('The number of bytes in ICMP ECHO repies that have been counted across all DLCIs.')
sfrapPerfIcmpTotalTxEchoRep = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 6, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIcmpTotalTxEchoRep.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIcmpTotalTxEchoRep.setDescription('The number of bytes in ICMP ECHO repies that have been counted across all DLCIs.')
sfrapPerfIcmpTotalRxDestUnr = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 6, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIcmpTotalRxDestUnr.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIcmpTotalRxDestUnr.setDescription('The number of bytes in ICMP destination unreachables that have been counted across all DLCIs.')
sfrapPerfIcmpTotalTxDestUnr = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 6, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIcmpTotalTxDestUnr.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIcmpTotalTxDestUnr.setDescription('The number of bytes in ICMP destination unreachables that have been counted across all DLCIs.')
sfrapPerfIcmpTotalRxSrcQuench = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 6, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIcmpTotalRxSrcQuench.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIcmpTotalRxSrcQuench.setDescription('The number of bytes in ICMP source quenches that have been counted across all DLCIs.')
sfrapPerfIcmpTotalTxSrcQuench = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 6, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIcmpTotalTxSrcQuench.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIcmpTotalTxSrcQuench.setDescription('The number of bytes in ICMP source quenches that have been counte across all DLCIs.')
sfrapPerfIcmpTotalRxRedirect = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 6, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIcmpTotalRxRedirect.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIcmpTotalRxRedirect.setDescription('The number of bytes in ICMP redirects that have been counte across all DLCIs.')
sfrapPerfIcmpTotalTxRedirect = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 6, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIcmpTotalTxRedirect.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIcmpTotalTxRedirect.setDescription('The number of bytes in ICMP redirects that have been counte across all DLCIs.')
sfrapPerfIcmpTotalRxEchoReq = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 6, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIcmpTotalRxEchoReq.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIcmpTotalRxEchoReq.setDescription('The number of bytes in ICMP ECHO requests that have been counted across all DLCIs.')
sfrapPerfIcmpTotalTxEchoReq = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 6, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIcmpTotalTxEchoReq.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIcmpTotalTxEchoReq.setDescription('The number of bytes in ICMP ECHO requests that have been counte across all DLCIs.')
sfrapPerfIcmpTotalRxTimeExcd = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 6, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIcmpTotalRxTimeExcd.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIcmpTotalRxTimeExcd.setDescription('The number of bytes in ICMP time exceededs that have been counted across all DLCIs.')
sfrapPerfIcmpTotalTxTimeExcd = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 6, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIcmpTotalTxTimeExcd.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIcmpTotalTxTimeExcd.setDescription('The number of bytes in ICMP time exceededs that have been counted across all DLCIs.')
sfrapPerfIcmpTotalRxParamProb = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 6, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIcmpTotalRxParamProb.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIcmpTotalRxParamProb.setDescription('The number of bytes in ICMP parameter problems that have been counted across all DLCIs.')
sfrapPerfIcmpTotalTxParamProb = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 6, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIcmpTotalTxParamProb.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIcmpTotalTxParamProb.setDescription('The number of bytes in ICMP parameter problems that have been counted across all DLCIs.')
sfrapPerfIcmpTotalRxTimestpReq = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 6, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIcmpTotalRxTimestpReq.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIcmpTotalRxTimestpReq.setDescription('The number of bytes in ICMP timestamp requests that have been counted across all DLCIs.')
sfrapPerfIcmpTotalTxTimestpReq = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 6, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIcmpTotalTxTimestpReq.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIcmpTotalTxTimestpReq.setDescription('The number of bytes in ICMP timestamp requests that have been counted across all DLCIs.')
sfrapPerfIcmpTotalRxTimestpRep = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 6, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIcmpTotalRxTimestpRep.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIcmpTotalRxTimestpRep.setDescription('The number of bytes in ICMP timestamp replies that have been counted across all DLCIs.')
sfrapPerfIcmpTotalTxTimestpRep = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 6, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIcmpTotalTxTimestpRep.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIcmpTotalTxTimestpRep.setDescription('The number of bytes in ICMP timestamp replies that have been counted across all DLCIs.')
sfrapPerfIcmpTotalRxAddrMaskReq = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 6, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIcmpTotalRxAddrMaskReq.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIcmpTotalRxAddrMaskReq.setDescription('The number of bytes in ICMP address mask requests that have been counted across all DLCIs.')
sfrapPerfIcmpTotalTxAddrMaskReq = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 6, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIcmpTotalTxAddrMaskReq.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIcmpTotalTxAddrMaskReq.setDescription('The number of bytes in ICMP address mask requests that have been counted across all DLCIs.')
sfrapPerfIcmpTotalRxAddrMaskRep = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 6, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIcmpTotalRxAddrMaskRep.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIcmpTotalRxAddrMaskRep.setDescription('The number of bytes in ICMP address mask replies that have been counted across all DLCIs.')
sfrapPerfIcmpTotalTxAddrMaskRep = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 6, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIcmpTotalTxAddrMaskRep.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIcmpTotalTxAddrMaskRep.setDescription('The number of bytes in ICMP address mask replies that have been counted across all DLCIs.')
sfrapPerfIcmpTotalRxPktTooBig = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 6, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIcmpTotalRxPktTooBig.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIcmpTotalRxPktTooBig.setDescription('The number of bytes in ICMP packet too bigs that have been counted across all DLCIs.')
sfrapPerfIcmpTotalTxPktTooBig = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 6, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIcmpTotalTxPktTooBig.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIcmpTotalTxPktTooBig.setDescription('The number of bytes in ICMP packet too bigs that have been counted across all DLCIs.')
sfrapPerfIcmpTotalRxGmQuery = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 6, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIcmpTotalRxGmQuery.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIcmpTotalRxGmQuery.setDescription('The number of bytes in ICMP group membership queries that have been counted across all DLCIs.')
sfrapPerfIcmpTotalTxGmQuery = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 6, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIcmpTotalTxGmQuery.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIcmpTotalTxGmQuery.setDescription('The number of bytes in ICMP group membership queries that have been counte across all DLCIs.')
sfrapPerfIcmpTotalRxGmReport = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 6, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIcmpTotalRxGmReport.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIcmpTotalRxGmReport.setDescription('The number of bytes in ICMP group membership reports that have been counted across all DLCIs.')
sfrapPerfIcmpTotalTxGmReport = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 6, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIcmpTotalTxGmReport.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIcmpTotalTxGmReport.setDescription('The number of bytes in ICMP group membership reports that have been counted across all DLCIs.')
sfrapPerfIcmpTotalRxGmReduct = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 6, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIcmpTotalRxGmReduct.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIcmpTotalRxGmReduct.setDescription('The number of bytes in ICMP group membership reductions that have been counted across all DLCIs.')
sfrapPerfIcmpTotalTxGmReduct = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 6, 1, 34), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIcmpTotalTxGmReduct.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIcmpTotalTxGmReduct.setDescription('The number of bytes in ICMP group membership reductions that have been counted across all DLCIs.')
sfrapPerfApplicationPerDlciTable = MibTable((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 7), )
if mibBuilder.loadTexts: sfrapPerfApplicationPerDlciTable.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfApplicationPerDlciTable.setDescription('The Short Term Statistics on the Application protocol for each DLCI.')
sfrapPerfApplicationPerDlciEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 7, 1), ).setIndexNames((0, "SFRAP-MIB", "sfrapPerfApplicationPerDlciInterval"), (0, "SFRAP-MIB", "sfrapPerfApplicationPerDlciValue"))
if mibBuilder.loadTexts: sfrapPerfApplicationPerDlciEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfApplicationPerDlciEntry.setDescription('The Application Short Term Statistics for a particular DLCI.')
sfrapPerfApplicationPerDlciInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 7, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("current-interval", 1), ("previous-interval", 2), ("cumulative-counts", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfApplicationPerDlciInterval.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfApplicationPerDlciInterval.setDescription('The Short Term statistics model maintains three intervals: current, previous, and cumulative totals. Interval duration is defined by the Short Term Timer (CfgFrPerfTimersSTInterval). (1) Currently active short term interval (2) Previously completed short term interval (3) Cumulative total since last cleared.')
sfrapPerfApplicationPerDlciValue = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 7, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfApplicationPerDlciValue.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfApplicationPerDlciValue.setDescription('The DLCI value with which the Statistics are associated.')
sfrapPerfApplicationPerDlciRxSnmp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 7, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfApplicationPerDlciRxSnmp.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfApplicationPerDlciRxSnmp.setDescription('The number of received SNMP bytes that have been counted on this DLCI.')
sfrapPerfApplicationPerDlciTxSnmp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 7, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfApplicationPerDlciTxSnmp.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfApplicationPerDlciTxSnmp.setDescription('The number of transmitted SNMP bytes that have been counted on this DLCI.')
sfrapPerfApplicationPerDlciRxSnmpTrap = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 7, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfApplicationPerDlciRxSnmpTrap.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfApplicationPerDlciRxSnmpTrap.setDescription('The number of received SNMP TRAP bytes that have been counted on this DLCI.')
sfrapPerfApplicationPerDlciTxSnmpTrap = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 7, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfApplicationPerDlciTxSnmpTrap.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfApplicationPerDlciTxSnmpTrap.setDescription('The number of transmitted SNMP TRAP bytes that have been counted on this DLCI.')
sfrapPerfApplicationPerDlciRxHttp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 7, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfApplicationPerDlciRxHttp.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfApplicationPerDlciRxHttp.setDescription('The number of received HTTP bytes that have been counted on this DLCI.')
sfrapPerfApplicationPerDlciTxHttp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 7, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfApplicationPerDlciTxHttp.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfApplicationPerDlciTxHttp.setDescription('The number of transmitted HTTP bytes that have been counted on this DLCI.')
sfrapPerfApplicationPerDlciRxTelnet = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 7, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfApplicationPerDlciRxTelnet.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfApplicationPerDlciRxTelnet.setDescription('The number of received Telnet bytes that have been counted on this DLCI.')
sfrapPerfApplicationPerDlciTxTelnet = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 7, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfApplicationPerDlciTxTelnet.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfApplicationPerDlciTxTelnet.setDescription('The number of transmitted Telnet bytes that have been counted on this DLCI.')
sfrapPerfApplicationPerDlciRxSmtp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 7, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfApplicationPerDlciRxSmtp.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfApplicationPerDlciRxSmtp.setDescription('The number of received SMTP bytes that have been counted on this DLCI.')
sfrapPerfApplicationPerDlciTxSmtp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 7, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfApplicationPerDlciTxSmtp.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfApplicationPerDlciTxSmtp.setDescription('The number of transmitted SMTP bytes that have been counted on this DLCI.')
sfrapPerfApplicationPerDlciRxFtp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 7, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfApplicationPerDlciRxFtp.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfApplicationPerDlciRxFtp.setDescription('The number of received FTP bytes that have been counted on this DLCI.')
sfrapPerfApplicationPerDlciTxFtp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 7, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfApplicationPerDlciTxFtp.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfApplicationPerDlciTxFtp.setDescription('The number of transmitted FTP bytes that have been counted on this DLCI.')
sfrapPerfApplicationPerDlciRxTftp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 7, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfApplicationPerDlciRxTftp.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfApplicationPerDlciRxTftp.setDescription('The number of received TFTP bytes that have been counted on this DLCI.')
sfrapPerfApplicationPerDlciTxTftp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 7, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfApplicationPerDlciTxTftp.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfApplicationPerDlciTxTftp.setDescription('The number of transmitted TFTP bytes that have been counted on this DLCI.')
sfrapPerfApplicationPerDlciRxCustom1 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 7, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfApplicationPerDlciRxCustom1.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfApplicationPerDlciRxCustom1.setDescription('The number of received bytes of User Defined Protocol #1 that have been counted on this DLCI.')
sfrapPerfApplicationPerDlciTxCustom1 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 7, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfApplicationPerDlciTxCustom1.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfApplicationPerDlciTxCustom1.setDescription('The number of transmitted bytes of User Defined Protocol #1 that have been counted on this DLCI.')
sfrapPerfApplicationPerDlciRxCustom2 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 7, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfApplicationPerDlciRxCustom2.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfApplicationPerDlciRxCustom2.setDescription('The number of received bytes of User Defined Protocol #2 that have been counted on this DLCI.')
sfrapPerfApplicationPerDlciTxCustom2 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 7, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfApplicationPerDlciTxCustom2.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfApplicationPerDlciTxCustom2.setDescription('The number of transmitted bytes of User Defined Protocol #2 that have been counted on this DLCI.')
sfrapPerfApplicationPerDlciRxCustom3 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 7, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfApplicationPerDlciRxCustom3.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfApplicationPerDlciRxCustom3.setDescription('The number of received bytes of User Defined Protocol #3 that have been counted on this DLCI.')
sfrapPerfApplicationPerDlciTxCustom3 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 7, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfApplicationPerDlciTxCustom3.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfApplicationPerDlciTxCustom3.setDescription('The number of transmitted bytes of User Defined Protocol #3 that have been counted on this DLCI.')
sfrapPerfApplicationPerDlciRxCustom4 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 7, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfApplicationPerDlciRxCustom4.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfApplicationPerDlciRxCustom4.setDescription('The number of received bytes of User Defined Protocol #4 that have been counted on this DLCI.')
sfrapPerfApplicationPerDlciTxCustom4 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 7, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfApplicationPerDlciTxCustom4.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfApplicationPerDlciTxCustom4.setDescription('The number of transmitted bytes of User Defined Protocol #4 that have been counted on this DLCI.')
sfrapPerfApplicationTotalTable = MibTable((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 8), )
if mibBuilder.loadTexts: sfrapPerfApplicationTotalTable.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfApplicationTotalTable.setDescription('The Short Term Statistics on the Application protocol across all DLCIs.')
sfrapPerfApplicationTotalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 8, 1), ).setIndexNames((0, "SFRAP-MIB", "sfrapPerfApplicationTotalInterval"))
if mibBuilder.loadTexts: sfrapPerfApplicationTotalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfApplicationTotalEntry.setDescription('The Application Short Term Statistics for a particular DLCI.')
sfrapPerfApplicationTotalInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 8, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("current-interval", 1), ("previous-interval", 2), ("cumulative-counts", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfApplicationTotalInterval.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfApplicationTotalInterval.setDescription('The Short Term statistics model maintains three intervals: current, previous, and cumulative totals. Interval duration is defined by the Short Term Timer (CfgFrPerfTimersSTInterval). (1) Currently active short term interval (2) Previously completed short term interval (3) Cumulative total since last cleared.')
sfrapPerfApplicationTotalRxSnmp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 8, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfApplicationTotalRxSnmp.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfApplicationTotalRxSnmp.setDescription('The number of received SNMP bytes that have been counted across all DLCIs.')
sfrapPerfApplicationTotalTxSnmp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 8, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfApplicationTotalTxSnmp.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfApplicationTotalTxSnmp.setDescription('The number of transmitted SNMP bytes that have been counted across all DLCIs.')
sfrapPerfApplicationTotalRxSnmpTrap = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 8, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfApplicationTotalRxSnmpTrap.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfApplicationTotalRxSnmpTrap.setDescription('The number of received SNMP TRAP bytes that have been counted across all DLCIs.')
sfrapPerfApplicationTotalTxSnmpTrap = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 8, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfApplicationTotalTxSnmpTrap.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfApplicationTotalTxSnmpTrap.setDescription('The number of transmitted SNMP TRAP bytes that have been counted across all DLCIs.')
sfrapPerfApplicationTotalRxHttp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 8, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfApplicationTotalRxHttp.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfApplicationTotalRxHttp.setDescription('The number of received HTTP bytes that have been counted across all DLCIs.')
sfrapPerfApplicationTotalTxHttp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 8, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfApplicationTotalTxHttp.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfApplicationTotalTxHttp.setDescription('The number of transmitted HTTP bytes that have been counted across all DLCIs.')
sfrapPerfApplicationTotalRxTelnet = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 8, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfApplicationTotalRxTelnet.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfApplicationTotalRxTelnet.setDescription('The number of received Telnet bytes that have been counted across all DLCIs.')
sfrapPerfApplicationTotalTxTelnet = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 8, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfApplicationTotalTxTelnet.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfApplicationTotalTxTelnet.setDescription('The number of transmitted Telnet bytes that have been counted across all DLCIs.')
sfrapPerfApplicationTotalRxSmtp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 8, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfApplicationTotalRxSmtp.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfApplicationTotalRxSmtp.setDescription('The number of received SMTP bytes that have been counted across all DLCIs.')
sfrapPerfApplicationTotalTxSmtp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 8, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfApplicationTotalTxSmtp.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfApplicationTotalTxSmtp.setDescription('The number of transmitted SMTP bytes that have been counted across all DLCIs.')
sfrapPerfApplicationTotalRxFtp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 8, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfApplicationTotalRxFtp.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfApplicationTotalRxFtp.setDescription('The number of received FTP bytes that have been counted across all DLCIs.')
sfrapPerfApplicationTotalTxFtp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 8, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfApplicationTotalTxFtp.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfApplicationTotalTxFtp.setDescription('The number of transmitted FTP bytes that have been counted across all DLCIs.')
sfrapPerfApplicationTotalRxTftp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 8, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfApplicationTotalRxTftp.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfApplicationTotalRxTftp.setDescription('The number of received TFTP bytes that have been counted across all DLCIs.')
sfrapPerfApplicationTotalTxTftp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 8, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfApplicationTotalTxTftp.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfApplicationTotalTxTftp.setDescription('The number of transmitted TFTP bytes that have been counted across all DLCIs.')
sfrapPerfApplicationTotalRxCustom1 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 8, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfApplicationTotalRxCustom1.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfApplicationTotalRxCustom1.setDescription('The number of received bytes of User Defined Protocol #1 that have been counted across all DLCIs.')
sfrapPerfApplicationTotalTxCustom1 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 8, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfApplicationTotalTxCustom1.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfApplicationTotalTxCustom1.setDescription('The number of transmitted bytes of User Defined Protocol #1 that have been counted across all DLCIs.')
sfrapPerfApplicationTotalRxCustom2 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 8, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfApplicationTotalRxCustom2.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfApplicationTotalRxCustom2.setDescription('The number of received bytes of User Defined Protocol #2 that have been counted across all DLCIs.')
sfrapPerfApplicationTotalTxCustom2 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 8, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfApplicationTotalTxCustom2.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfApplicationTotalTxCustom2.setDescription('The number of transmitted bytes of User Defined Protocol #2 that have been counted across all DLCIs.')
sfrapPerfApplicationTotalRxCustom3 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 8, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfApplicationTotalRxCustom3.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfApplicationTotalRxCustom3.setDescription('The number of received bytes of User Defined Protocol #3 that have been counted across all DLCIs.')
sfrapPerfApplicationTotalTxCustom3 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 8, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfApplicationTotalTxCustom3.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfApplicationTotalTxCustom3.setDescription('The number of transmitted bytes of User Defined Protocol #3 that have been counted across all DLCIs.')
sfrapPerfApplicationTotalRxCustom4 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 8, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfApplicationTotalRxCustom4.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfApplicationTotalRxCustom4.setDescription('The number of received bytes of User Defined Protocol #4 that have been counted across all DLCIs.')
sfrapPerfApplicationTotalTxCustom4 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 8, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfApplicationTotalTxCustom4.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfApplicationTotalTxCustom4.setDescription('The number of transmitted bytes of User Defined Protocol #4 that have been counted across all DLCIs.')
sfrapPerfRoutingPerDlciTable = MibTable((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 9), )
if mibBuilder.loadTexts: sfrapPerfRoutingPerDlciTable.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfRoutingPerDlciTable.setDescription('The Short Term Statistics on the Routing protocol for each DLCI.')
sfrapPerfRoutingPerDlciEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 9, 1), ).setIndexNames((0, "SFRAP-MIB", "sfrapPerfRoutingPerDlciInterval"), (0, "SFRAP-MIB", "sfrapPerfRoutingPerDlciValue"))
if mibBuilder.loadTexts: sfrapPerfRoutingPerDlciEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfRoutingPerDlciEntry.setDescription('The Routing Short Term Statistics for a particular DLCI.')
sfrapPerfRoutingPerDlciInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 9, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("current-interval", 1), ("previous-interval", 2), ("cumulative-counts", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfRoutingPerDlciInterval.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfRoutingPerDlciInterval.setDescription('The Short Term statistics model maintains three intervals: current, previous, and cumulative totals. Interval duration is defined by the Short Term Timer (CfgFrPerfTimersSTInterval). (1) Currently active short term interval (2) Previously completed short term interval (3) Cumulative total since last cleared.')
sfrapPerfRoutingPerDlciValue = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 9, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfRoutingPerDlciValue.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfRoutingPerDlciValue.setDescription('The DLCI value with which the Statistics are associated.')
sfrapPerfRoutingPerDlciRxOspf = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 9, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfRoutingPerDlciRxOspf.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfRoutingPerDlciRxOspf.setDescription('The number of received OSPF bytes that have been counted on this DLCI.')
sfrapPerfRoutingPerDlciTxOspf = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 9, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfRoutingPerDlciTxOspf.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfRoutingPerDlciTxOspf.setDescription('The number of transmitted OSPF bytes that have been counted on this DLCI.')
sfrapPerfRoutingPerDlciRxRip = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 9, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfRoutingPerDlciRxRip.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfRoutingPerDlciRxRip.setDescription('The number of received RIP bytes that have been counted on this DLCI.')
sfrapPerfRoutingPerDlciTxRip = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 9, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfRoutingPerDlciTxRip.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfRoutingPerDlciTxRip.setDescription('The number of transmitted RIP bytes that have been counted on this DLCI.')
sfrapPerfRoutingPerDlciRxNetbios = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 9, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfRoutingPerDlciRxNetbios.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfRoutingPerDlciRxNetbios.setDescription('The number of received Netbios bytes that have been counted on this DLCI.')
sfrapPerfRoutingPerDlciTxNetbios = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 9, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfRoutingPerDlciTxNetbios.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfRoutingPerDlciTxNetbios.setDescription('The number of transmitted Netbios bytes that have been counted on this DLCI.')
sfrapPerfRoutingTotalTable = MibTable((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 10), )
if mibBuilder.loadTexts: sfrapPerfRoutingTotalTable.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfRoutingTotalTable.setDescription('The Short Term Statistics on the Routing protocol across all DLCIs.')
sfrapPerfRoutingTotalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 10, 1), ).setIndexNames((0, "SFRAP-MIB", "sfrapPerfRoutingTotalInterval"))
if mibBuilder.loadTexts: sfrapPerfRoutingTotalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfRoutingTotalEntry.setDescription('The Routing Short Term Statistics for a particular DLCI.')
sfrapPerfRoutingTotalInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("current-interval", 1), ("previous-interval", 2), ("cumulative-counts", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfRoutingTotalInterval.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfRoutingTotalInterval.setDescription('The Short Term statistics model maintains three intervals: current, previous, and cumulative totals. Interval duration is defined by the Short Term Timer (CfgFrPerfTimersSTInterval). (1) Currently active short term interval (2) Previously completed short term interval (3) Cumulative total since last cleared.')
sfrapPerfRoutingTotalRxOspf = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 10, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfRoutingTotalRxOspf.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfRoutingTotalRxOspf.setDescription('The number of received OSPF bytes that have been counted across all DLCIs.')
sfrapPerfRoutingTotalTxOspf = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 10, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfRoutingTotalTxOspf.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfRoutingTotalTxOspf.setDescription('The number of transmitted OSPF bytes that have been counted across all DLCIs.')
sfrapPerfRoutingTotalRxRip = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 10, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfRoutingTotalRxRip.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfRoutingTotalRxRip.setDescription('The number of received RIP bytes that have been counted across all DLCIs.')
sfrapPerfRoutingTotalTxRip = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 10, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfRoutingTotalTxRip.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfRoutingTotalTxRip.setDescription('The number of transmitted RIP bytes that have been counted across all DLCIs.')
sfrapPerfRoutingTotalRxNetbios = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 10, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfRoutingTotalRxNetbios.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfRoutingTotalRxNetbios.setDescription('The number of received Netbios bytes that have been counted across all DLCIs.')
sfrapPerfRoutingTotalTxNetbios = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 10, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfRoutingTotalTxNetbios.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfRoutingTotalTxNetbios.setDescription('The number of transmitted Netbios bytes that have been counted across all DLCIs.')
sfrapPerfIpxPerDlciTable = MibTable((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 11), )
if mibBuilder.loadTexts: sfrapPerfIpxPerDlciTable.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIpxPerDlciTable.setDescription('Short Term Statistics on the IPX protocol for each DLCI.')
sfrapPerfIpxPerDlciEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 11, 1), ).setIndexNames((0, "SFRAP-MIB", "sfrapPerfIpxPerDlciInterval"), (0, "SFRAP-MIB", "sfrapPerfIpxPerDlciValue"))
if mibBuilder.loadTexts: sfrapPerfIpxPerDlciEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIpxPerDlciEntry.setDescription('The IPX Short Term Statistics for a particular DLCI.')
sfrapPerfIpxPerDlciInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("current-interval", 1), ("previous-interval", 2), ("cumulative-counts", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIpxPerDlciInterval.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIpxPerDlciInterval.setDescription('The Short Term statistics model maintains three intervals: current, previous, and cumulative totals. Interval duration is defined by the Short Term Timer (CfgFrPerfTimersSTInterval). (1) Currently active short term interval (2) Previously completed short term interval (3) Cumulative total since last cleared.')
sfrapPerfIpxPerDlciValue = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 11, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIpxPerDlciValue.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIpxPerDlciValue.setDescription('The DLCI value in which the Statistics are associated.')
sfrapPerfIpxPerDlciRxTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 11, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIpxPerDlciRxTotal.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIpxPerDlciRxTotal.setDescription('The total number of IPX bytes that have been counted on this DLCI.')
sfrapPerfIpxPerDlciTxTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 11, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIpxPerDlciTxTotal.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIpxPerDlciTxTotal.setDescription('The total number of IPX bytes that have been counted on this DLCI.')
sfrapPerfIpxPerDlciRxSpx = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 11, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIpxPerDlciRxSpx.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIpxPerDlciRxSpx.setDescription('The number of SPX over IPX bytes that have been counted on this DLCI.')
sfrapPerfIpxPerDlciTxSpx = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 11, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIpxPerDlciTxSpx.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIpxPerDlciTxSpx.setDescription('The number of SPX over IPX bytes that have been counted on this DLCI.')
sfrapPerfIpxPerDlciRxNcp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 11, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIpxPerDlciRxNcp.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIpxPerDlciRxNcp.setDescription('The number of NCP over IPX bytes that have been counted on this DLCI.')
sfrapPerfIpxPerDlciTxNcp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 11, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIpxPerDlciTxNcp.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIpxPerDlciTxNcp.setDescription('The number of NCP over IPX bytes that have been counted on this DLCI.')
sfrapPerfIpxPerDlciRxSap = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 11, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIpxPerDlciRxSap.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIpxPerDlciRxSap.setDescription('The number of SAP over IPX bytes that have been counted on this DLCI.')
sfrapPerfIpxPerDlciTxSap = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 11, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIpxPerDlciTxSap.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIpxPerDlciTxSap.setDescription('The number of SAP over IPX bytes that have been counted on this DLCI.')
sfrapPerfIpxPerDlciRxRip = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 11, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIpxPerDlciRxRip.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIpxPerDlciRxRip.setDescription('The number of RIP over IPX bytes that have been counted on this DLCI.')
sfrapPerfIpxPerDlciTxRip = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 11, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIpxPerDlciTxRip.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIpxPerDlciTxRip.setDescription('The number of RIP over IPX bytes that have been counted on this DLCI.')
sfrapPerfIpxPerDlciRxNetbios = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 11, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIpxPerDlciRxNetbios.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIpxPerDlciRxNetbios.setDescription('The number of NETBIOS over IPX bytes that have been counted on this DLCI.')
sfrapPerfIpxPerDlciTxNetbios = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 11, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIpxPerDlciTxNetbios.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIpxPerDlciTxNetbios.setDescription('The number of NETBIOS over IPX bytes that have been counted on this DLCI.')
sfrapPerfIpxPerDlciRxOther = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 11, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIpxPerDlciRxOther.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIpxPerDlciRxOther.setDescription('The number of received bytes on this DLCI from protocols over IPX that are not counted elsewhere in this table.')
sfrapPerfIpxPerDlciTxOther = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 11, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIpxPerDlciTxOther.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIpxPerDlciTxOther.setDescription('The number of transmitted bytes on this DLCI from protocols over IPX that are not counted elsewhere in this table.')
sfrapPerfIpxTotalTable = MibTable((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 12), )
if mibBuilder.loadTexts: sfrapPerfIpxTotalTable.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIpxTotalTable.setDescription('Short Term Statistics on the IPX protocol across all DLCIs.')
sfrapPerfIpxTotalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 12, 1), ).setIndexNames((0, "SFRAP-MIB", "sfrapPerfIpxTotalInterval"))
if mibBuilder.loadTexts: sfrapPerfIpxTotalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIpxTotalEntry.setDescription('The IPX Short Term Statistics for a particular DLCI.')
sfrapPerfIpxTotalInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("current-interval", 1), ("previous-interval", 2), ("cumulative-counts", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIpxTotalInterval.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIpxTotalInterval.setDescription('The Short Term statistics model maintains three intervals: current, previous, and cumulative totals. Interval duration is defined by the Short Term Timer (CfgFrPerfTimersSTInterval). (1) Currently active short term interval (2) Previously completed short term interval (3) Cumulative total since last cleared.')
sfrapPerfIpxTotalRxTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 12, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIpxTotalRxTotal.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIpxTotalRxTotal.setDescription('The total number of IPX bytes that have been counted across all DLCIs.')
sfrapPerfIpxTotalTxTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 12, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIpxTotalTxTotal.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIpxTotalTxTotal.setDescription('The total number of IPX bytes that have been counted across all DLCIs.')
sfrapPerfIpxTotalRxSpx = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 12, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIpxTotalRxSpx.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIpxTotalRxSpx.setDescription('The number of SPX over IPX bytes that have been counted across all DLCIs.')
sfrapPerfIpxTotalTxSpx = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 12, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIpxTotalTxSpx.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIpxTotalTxSpx.setDescription('The number of SPX over IPX bytes that have been counted across all DLCIs.')
sfrapPerfIpxTotalRxNcp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 12, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIpxTotalRxNcp.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIpxTotalRxNcp.setDescription('The number of NCP over IPX bytes that have been counted across all DLCIs.')
sfrapPerfIpxTotalTxNcp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 12, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIpxTotalTxNcp.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIpxTotalTxNcp.setDescription('The number of NCP over IPX bytes that have been counted across all DLCIs.')
sfrapPerfIpxTotalRxSap = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 12, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIpxTotalRxSap.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIpxTotalRxSap.setDescription('The number of SAP over IPX bytes that have been counted across all DLCIs.')
sfrapPerfIpxTotalTxSap = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 12, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIpxTotalTxSap.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIpxTotalTxSap.setDescription('The number of SAP over IPX bytes that have been counted across all DLCIs.')
sfrapPerfIpxTotalRxRip = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 12, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIpxTotalRxRip.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIpxTotalRxRip.setDescription('The number of RIP over IPX bytes that have been counted across all DLCIs.')
sfrapPerfIpxTotalTxRip = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 12, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIpxTotalTxRip.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIpxTotalTxRip.setDescription('The number of RIP over IPX bytes that have been counted across all DLCIs.')
sfrapPerfIpxTotalRxNetbios = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 12, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIpxTotalRxNetbios.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIpxTotalRxNetbios.setDescription('The number of NETBIOS over IPX bytes that have been counted across all DLCIs.')
sfrapPerfIpxTotalTxNetbios = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 12, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIpxTotalTxNetbios.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIpxTotalTxNetbios.setDescription('The number of NETBIOS over IPX bytes that have been counted across all DLCIs.')
sfrapPerfIpxTotalRxOther = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 12, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIpxTotalRxOther.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIpxTotalRxOther.setDescription('The number of received bytes across all DLCIs from protocols over IPX that are not counted elsewhere in this table.')
sfrapPerfIpxTotalTxOther = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 12, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfIpxTotalTxOther.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfIpxTotalTxOther.setDescription('The number of transmitted bytes across all DLCIs from protocols over IPX that are not counted elsewhere in this table.')
sfrapPerfSnaPerDlciTable = MibTable((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 13), )
if mibBuilder.loadTexts: sfrapPerfSnaPerDlciTable.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfSnaPerDlciTable.setDescription('Short Term Statistics on the SNA protocol for each DLCI.')
sfrapPerfSnaPerDlciEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 13, 1), ).setIndexNames((0, "SFRAP-MIB", "sfrapPerfSnaPerDlciInterval"), (0, "SFRAP-MIB", "sfrapPerfSnaPerDlciValue"))
if mibBuilder.loadTexts: sfrapPerfSnaPerDlciEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfSnaPerDlciEntry.setDescription('The SNA Short Term Statistics for a particular DLCI.')
sfrapPerfSnaPerDlciInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("current-interval", 1), ("previous-interval", 2), ("cumulative-counts", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfSnaPerDlciInterval.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfSnaPerDlciInterval.setDescription('The Short Term statistics model maintains three intervals: current, previous, and cumulative totals. Interval duration is defined by the Short Term Timer (CfgFrPerfTimersSTInterval). (1) Currently active short term interval (2) Previously completed short term interval (3) Cumulative total since last cleared.')
sfrapPerfSnaPerDlciValue = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 13, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfSnaPerDlciValue.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfSnaPerDlciValue.setDescription('The DLCI value in which the Statistics are associated.')
sfrapPerfSnaPerDlciRxTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 13, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfSnaPerDlciRxTotal.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfSnaPerDlciRxTotal.setDescription('The total number of SNA bytes that have been counted on this DLCI.')
sfrapPerfSnaPerDlciTxTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 13, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfSnaPerDlciTxTotal.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfSnaPerDlciTxTotal.setDescription('The total number of SNA bytes that have been counted on this DLCI.')
sfrapPerfSnaPerDlciRxSubarea = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 13, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfSnaPerDlciRxSubarea.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfSnaPerDlciRxSubarea.setDescription('The number of SNA Subarea bytes that have been counted on this DLCI.')
sfrapPerfSnaPerDlciTxSubarea = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 13, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfSnaPerDlciTxSubarea.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfSnaPerDlciTxSubarea.setDescription('The number of SNA Subarea bytes that have been counted on this DLCI.')
sfrapPerfSnaPerDlciRxPeriph = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 13, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfSnaPerDlciRxPeriph.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfSnaPerDlciRxPeriph.setDescription('The number of SNA Periph bytes that have been counted on this DLCI.')
sfrapPerfSnaPerDlciTxPeriph = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 13, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfSnaPerDlciTxPeriph.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfSnaPerDlciTxPeriph.setDescription('The number of SNA Periph bytes that have been counted on this DLCI.')
sfrapPerfSnaPerDlciRxAppn = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 13, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfSnaPerDlciRxAppn.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfSnaPerDlciRxAppn.setDescription('The number of SNA Appn bytes that have been counted on this DLCI.')
sfrapPerfSnaPerDlciTxAppn = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 13, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfSnaPerDlciTxAppn.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfSnaPerDlciTxAppn.setDescription('The number of SNA Appn bytes that have been counted on this DLCI.')
sfrapPerfSnaPerDlciRxNetbios = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 13, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfSnaPerDlciRxNetbios.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfSnaPerDlciRxNetbios.setDescription('The number of SNA Netbios bytes that have been counted on this DLCI.')
sfrapPerfSnaPerDlciTxNetbios = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 13, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfSnaPerDlciTxNetbios.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfSnaPerDlciTxNetbios.setDescription('The number of SNA Netbios bytes that have been counted on this DLCI.')
sfrapPerfSnaPerDlciRxOther = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 13, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfSnaPerDlciRxOther.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfSnaPerDlciRxOther.setDescription('The number of received bytes on this DLCI from protocols over SNA that are not counted elsewhere in this table.')
sfrapPerfSnaPerDlciTxOther = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 13, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfSnaPerDlciTxOther.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfSnaPerDlciTxOther.setDescription('The number of transmitted bytes on this DLCI from protocols over SNA that are not counted elsewhere in this table.')
sfrapPerfSnaTotalTable = MibTable((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 14), )
if mibBuilder.loadTexts: sfrapPerfSnaTotalTable.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfSnaTotalTable.setDescription('Short Term Statistics on the SNA protocol across all DLCIs.')
sfrapPerfSnaTotalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 14, 1), ).setIndexNames((0, "SFRAP-MIB", "sfrapPerfSnaTotalInterval"))
if mibBuilder.loadTexts: sfrapPerfSnaTotalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfSnaTotalEntry.setDescription('The SNA Short Term Statistics for a particular DLCI.')
sfrapPerfSnaTotalInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("current-interval", 1), ("previous-interval", 2), ("cumulative-counts", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfSnaTotalInterval.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfSnaTotalInterval.setDescription('The Short Term statistics model maintains three intervals: current, previous, and cumulative totals. Interval duration is defined by the Short Term Timer (CfgFrPerfTimersSTInterval). (1) Currently active short term interval (2) Previously completed short term interval (3) Cumulative total since last cleared.')
sfrapPerfSnaTotalRxTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 14, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfSnaTotalRxTotal.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfSnaTotalRxTotal.setDescription('The total number of SNA bytes that have been counted across all DLCIs.')
sfrapPerfSnaTotalTxTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 14, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfSnaTotalTxTotal.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfSnaTotalTxTotal.setDescription('The total number of SNA bytes that have been counted across all DLCIs.')
sfrapPerfSnaTotalRxSubarea = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 14, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfSnaTotalRxSubarea.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfSnaTotalRxSubarea.setDescription('The number of SNA Subarea bytes that have been counted across all DLCIs.')
sfrapPerfSnaTotalTxSubarea = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 14, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfSnaTotalTxSubarea.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfSnaTotalTxSubarea.setDescription('The number of SNA Subarea bytes that have been counted across all DLCIs.')
sfrapPerfSnaTotalRxPeriph = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 14, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfSnaTotalRxPeriph.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfSnaTotalRxPeriph.setDescription('The number of SNA Periph bytes that have been counted across all DLCIs.')
sfrapPerfSnaTotalTxPeriph = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 14, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfSnaTotalTxPeriph.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfSnaTotalTxPeriph.setDescription('The number of SNA Periph bytes that have been counted across all DLCIs.')
sfrapPerfSnaTotalRxAppn = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 14, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfSnaTotalRxAppn.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfSnaTotalRxAppn.setDescription('The number of SNA Appn bytes that have been counted across all DLCIs.')
sfrapPerfSnaTotalTxAppn = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 14, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfSnaTotalTxAppn.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfSnaTotalTxAppn.setDescription('The number of SNA Appn bytes that have been counted across all DLCIs.')
sfrapPerfSnaTotalRxNetbios = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 14, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfSnaTotalRxNetbios.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfSnaTotalRxNetbios.setDescription('The number of SNA Netbios bytes that have been counted across all DLCIs.')
sfrapPerfSnaTotalTxNetbios = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 14, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfSnaTotalTxNetbios.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfSnaTotalTxNetbios.setDescription('The number of SNA Netbios bytes that have been counted across all DLCIs.')
sfrapPerfSnaTotalRxOther = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 14, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfSnaTotalRxOther.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfSnaTotalRxOther.setDescription('The number of received bytes across all DLCIs from protocols over SNA that are not counted elsewhere in this table.')
sfrapPerfSnaTotalTxOther = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 14, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfSnaTotalTxOther.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfSnaTotalTxOther.setDescription('The number of transmitted bytes across all DLCIs from protocols over SNA that are not counted elsewhere in this table.')
sfrapPerfArpPerDlciTable = MibTable((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 15), )
if mibBuilder.loadTexts: sfrapPerfArpPerDlciTable.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfArpPerDlciTable.setDescription('Short Term Statistics on the ARP protocol for each DLCI.')
sfrapPerfArpPerDlciEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 15, 1), ).setIndexNames((0, "SFRAP-MIB", "sfrapPerfArpPerDlciInterval"), (0, "SFRAP-MIB", "sfrapPerfArpPerDlciValue"))
if mibBuilder.loadTexts: sfrapPerfArpPerDlciEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfArpPerDlciEntry.setDescription('The ARP Short Term Statistics for a particular DLCI.')
sfrapPerfArpPerDlciInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 15, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("current-interval", 1), ("previous-interval", 2), ("cumulative-counts", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfArpPerDlciInterval.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfArpPerDlciInterval.setDescription('The Short Term statistics model maintains three intervals: current, previous, and cumulative totals. Interval duration is defined by the Short Term Timer (CfgFrPerfTimersSTInterval). (1) Currently active short term interval (2) Previously completed short term interval (3) Cumulative total since last cleared.')
sfrapPerfArpPerDlciValue = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 15, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfArpPerDlciValue.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfArpPerDlciValue.setDescription('The DLCI value in which the Statistics are associated.')
sfrapPerfArpPerDlciRxTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 15, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfArpPerDlciRxTotal.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfArpPerDlciRxTotal.setDescription('The total number of ARP bytes that have been counted on this DLCI.')
sfrapPerfArpPerDlciTxTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 15, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfArpPerDlciTxTotal.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfArpPerDlciTxTotal.setDescription('The total number of ARP bytes that have been counted on this DLCI.')
sfrapPerfArpPerDlciRxArpReq = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 15, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfArpPerDlciRxArpReq.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfArpPerDlciRxArpReq.setDescription('The number of ARP request bytes that have been counted on this DLCI.')
sfrapPerfArpPerDlciTxArpReq = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 15, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfArpPerDlciTxArpReq.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfArpPerDlciTxArpReq.setDescription('The number of ARP request bytes that have been counted on this DLCI.')
sfrapPerfArpPerDlciRxArpRep = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 15, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfArpPerDlciRxArpRep.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfArpPerDlciRxArpRep.setDescription('The number of ARP reply bytes that have been counted on this DLCI.')
sfrapPerfArpPerDlciTxArpRep = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 15, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfArpPerDlciTxArpRep.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfArpPerDlciTxArpRep.setDescription('The number of ARP reply bytes that have been counted on this DLCI.')
sfrapPerfArpPerDlciRxRarpReq = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 15, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfArpPerDlciRxRarpReq.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfArpPerDlciRxRarpReq.setDescription('The number of RARP request bytes that have been counted on this DLCI.')
sfrapPerfArpPerDlciTxRarpReq = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 15, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfArpPerDlciTxRarpReq.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfArpPerDlciTxRarpReq.setDescription('The number of RARP request bytes that have been counted on this DLCI.')
sfrapPerfArpPerDlciRxRarpRep = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 15, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfArpPerDlciRxRarpRep.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfArpPerDlciRxRarpRep.setDescription('The number of RARP reply bytes that have been counted on this DLCI.')
sfrapPerfArpPerDlciTxRarpRep = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 15, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfArpPerDlciTxRarpRep.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfArpPerDlciTxRarpRep.setDescription('The number of RARP reply bytes that have been counted on this DLCI.')
sfrapPerfArpPerDlciRxInarpReq = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 15, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfArpPerDlciRxInarpReq.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfArpPerDlciRxInarpReq.setDescription('The number of INARP request bytes that have been counted on this DLCI.')
sfrapPerfArpPerDlciTxInarpReq = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 15, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfArpPerDlciTxInarpReq.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfArpPerDlciTxInarpReq.setDescription('The number of INARP request bytes that have been counted on this DLCI.')
sfrapPerfArpPerDlciRxInarpRep = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 15, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfArpPerDlciRxInarpRep.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfArpPerDlciRxInarpRep.setDescription('The number of INARP reply bytes that have been counted on this DLCI.')
sfrapPerfArpPerDlciTxInarpRep = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 15, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfArpPerDlciTxInarpRep.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfArpPerDlciTxInarpRep.setDescription('The number of INARP reply bytes that have been counted on this DLCI.')
sfrapPerfArpPerDlciRxOther = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 15, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfArpPerDlciRxOther.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfArpPerDlciRxOther.setDescription('The number of received bytes on this DLCI from ARP message types that are not counted elsewhere in this table.')
sfrapPerfArpPerDlciTxOther = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 15, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfArpPerDlciTxOther.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfArpPerDlciTxOther.setDescription('The number of transmitted bytes on this DLCI from ARP message types that are not counted elsewhere in this table.')
sfrapPerfArpTotalTable = MibTable((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 16), )
if mibBuilder.loadTexts: sfrapPerfArpTotalTable.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfArpTotalTable.setDescription('Short Term Statistics on the ARP protocol across all DLCIs.')
sfrapPerfArpTotalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 16, 1), ).setIndexNames((0, "SFRAP-MIB", "sfrapPerfArpTotalInterval"))
if mibBuilder.loadTexts: sfrapPerfArpTotalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfArpTotalEntry.setDescription('The ARP Short Term Statistics for a particular DLCI.')
sfrapPerfArpTotalInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 16, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("current-interval", 1), ("previous-interval", 2), ("cumulative-counts", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfArpTotalInterval.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfArpTotalInterval.setDescription('The Short Term statistics model maintains three intervals: current, previous, and cumulative totals. Interval duration is defined by the Short Term Timer (CfgFrPerfTimersSTInterval). (1) Currently active short term interval (2) Previously completed short term interval (3) Cumulative total since last cleared.')
sfrapPerfArpTotalRxTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 16, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfArpTotalRxTotal.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfArpTotalRxTotal.setDescription('The total number of ARP bytes that have been counted across all DLCIs.')
sfrapPerfArpTotalTxTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 16, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfArpTotalTxTotal.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfArpTotalTxTotal.setDescription('The total number of ARP bytes that have been counted across all DLCIs.')
sfrapPerfArpTotalRxArpReq = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 16, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfArpTotalRxArpReq.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfArpTotalRxArpReq.setDescription('The number of ARP request bytes that have been counted across all DLCIs.')
sfrapPerfArpTotalTxArpReq = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 16, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfArpTotalTxArpReq.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfArpTotalTxArpReq.setDescription('The number of ARP request bytes that have been counted across all DLCIs.')
sfrapPerfArpTotalRxArpRep = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 16, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfArpTotalRxArpRep.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfArpTotalRxArpRep.setDescription('The number of ARP reply bytes that have been counted across all DLCIs.')
sfrapPerfArpTotalTxArpRep = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 16, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfArpTotalTxArpRep.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfArpTotalTxArpRep.setDescription('The number of ARP reply bytes that have been counted across all DLCIs.')
sfrapPerfArpTotalRxRarpReq = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 16, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfArpTotalRxRarpReq.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfArpTotalRxRarpReq.setDescription('The number of RARP request bytes that have been counted across all DLCIs.')
sfrapPerfArpTotalTxRarpReq = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 16, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfArpTotalTxRarpReq.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfArpTotalTxRarpReq.setDescription('The number of RARP request bytes that have been counted across all DLCIs.')
sfrapPerfArpTotalRxRarpRep = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 16, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfArpTotalRxRarpRep.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfArpTotalRxRarpRep.setDescription('The number of RARP reply bytes that have been counted across all DLCIs.')
sfrapPerfArpTotalTxRarpRep = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 16, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfArpTotalTxRarpRep.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfArpTotalTxRarpRep.setDescription('The number of RARP reply bytes that have been counted across all DLCIs.')
sfrapPerfArpTotalRxInarpReq = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 16, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfArpTotalRxInarpReq.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfArpTotalRxInarpReq.setDescription('The number of INARP request bytes that have been counted across all DLCIs.')
sfrapPerfArpTotalTxInarpReq = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 16, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfArpTotalTxInarpReq.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfArpTotalTxInarpReq.setDescription('The number of INARP request bytes that have been counted across all DLCIs.')
sfrapPerfArpTotalRxInarpRep = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 16, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfArpTotalRxInarpRep.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfArpTotalRxInarpRep.setDescription('The number of INARP reply bytes that have been counted across all DLCIs.')
sfrapPerfArpTotalTxInarpRep = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 16, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfArpTotalTxInarpRep.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfArpTotalTxInarpRep.setDescription('The number of INARP reply bytes that have been counted across all DLCIs.')
sfrapPerfArpTotalRxOther = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 16, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfArpTotalRxOther.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfArpTotalRxOther.setDescription('The number of received bytes across all DLCIs from ARP message types that are not counted elsewhere in this table.')
sfrapPerfArpTotalTxOther = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 16, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfArpTotalTxOther.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfArpTotalTxOther.setDescription('The number of transmitted bytes across all DLCIs from ARP message types that are not counted elsewhere in this table.')
sfrapPerfLmiPerDlciTable = MibTable((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 17), )
if mibBuilder.loadTexts: sfrapPerfLmiPerDlciTable.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfLmiPerDlciTable.setDescription('Short Term Statistics on LMI protocol for each DLCI.')
sfrapPerfLmiPerDlciEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 17, 1), ).setIndexNames((0, "SFRAP-MIB", "sfrapPerfLmiPerDlciInterval"), (0, "SFRAP-MIB", "sfrapPerfLmiPerDlciValue"))
if mibBuilder.loadTexts: sfrapPerfLmiPerDlciEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfLmiPerDlciEntry.setDescription('The LMI Short Term Statistics for a particular DLCI.')
sfrapPerfLmiPerDlciInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 17, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("current-interval", 1), ("previous-interval", 2), ("cumulative-counts", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfLmiPerDlciInterval.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfLmiPerDlciInterval.setDescription('The Short Term statistics model maintains three intervals: current, previous, and cumulative totals. Interval duration is defined by the Short Term Timer (CfgFrPerfTimersSTInterval). (1) Currently active short term interval (2) Previously completed short term interval (3) Cumulative total since last cleared.')
sfrapPerfLmiPerDlciValue = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 17, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfLmiPerDlciValue.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfLmiPerDlciValue.setDescription('The DLCI value with which the Statistics are associated.')
sfrapPerfLmiPerDlciRxTotalByteCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 17, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfLmiPerDlciRxTotalByteCnt.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfLmiPerDlciRxTotalByteCnt.setDescription('The total number of received LMI bytes counted on this DLCI.')
sfrapPerfLmiPerDlciTxTotalByteCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 17, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfLmiPerDlciTxTotalByteCnt.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfLmiPerDlciTxTotalByteCnt.setDescription('The total number of transmitted LMI bytes counted on this DLCI.')
sfrapPerfLmiPerDlciRxLivoEnqByteCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 17, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfLmiPerDlciRxLivoEnqByteCnt.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfLmiPerDlciRxLivoEnqByteCnt.setDescription('The number of bytes received in Link Integrity Verification Only (LIVO) enquiries on this DLCI.')
sfrapPerfLmiPerDlciTxLivoEnqByteCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 17, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfLmiPerDlciTxLivoEnqByteCnt.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfLmiPerDlciTxLivoEnqByteCnt.setDescription('The number of bytes transmitted in Link Integrity Verification Only (LIVO) enquiries on this DLCI.')
sfrapPerfLmiPerDlciRxLivoStatByteCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 17, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfLmiPerDlciRxLivoStatByteCnt.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfLmiPerDlciRxLivoStatByteCnt.setDescription('The number of bytes received in Link Integrity Verification Only (LIVO) statuses on this DLCI.')
sfrapPerfLmiPerDlciTxLivoStatByteCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 17, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfLmiPerDlciTxLivoStatByteCnt.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfLmiPerDlciTxLivoStatByteCnt.setDescription('The number of bytes transmitted in Link Integrity Verification Only (LIVO) statuses on this DLCI.')
sfrapPerfLmiPerDlciRxFullEnqByteCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 17, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfLmiPerDlciRxFullEnqByteCnt.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfLmiPerDlciRxFullEnqByteCnt.setDescription('The number of bytes received in Full Status enquiries on this DLCI.')
sfrapPerfLmiPerDlciTxFullEnqByteCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 17, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfLmiPerDlciTxFullEnqByteCnt.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfLmiPerDlciTxFullEnqByteCnt.setDescription('The number of bytes transmitted in Full Status enquiries on this DLCI.')
sfrapPerfLmiPerDlciRxFullStatByteCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 17, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfLmiPerDlciRxFullStatByteCnt.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfLmiPerDlciRxFullStatByteCnt.setDescription('The number of bytes received in Full Status messages on this DLCI.')
sfrapPerfLmiPerDlciTxFullStatByteCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 17, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfLmiPerDlciTxFullStatByteCnt.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfLmiPerDlciTxFullStatByteCnt.setDescription('The number of bytes transmitted in Full Status messages on this DLCI.')
sfrapPerfLmiPerDlciRxOtherByteCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 17, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfLmiPerDlciRxOtherByteCnt.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfLmiPerDlciRxOtherByteCnt.setDescription('The number of received bytes on this DLCI from LMI protocols that are not counted elsewhere (other than Total) in this table.')
sfrapPerfLmiPerDlciTxOtherByteCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 17, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfLmiPerDlciTxOtherByteCnt.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfLmiPerDlciTxOtherByteCnt.setDescription('The number of transmitted bytes on this DLCI from LMI protocols that are not counted elsewhere (other than Total) in this table.')
sfrapPerfLmiTotalTable = MibTable((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 18), )
if mibBuilder.loadTexts: sfrapPerfLmiTotalTable.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfLmiTotalTable.setDescription('Short Term Statistics on LMI protocol across all DLCIs.')
sfrapPerfLmiTotalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 18, 1), ).setIndexNames((0, "SFRAP-MIB", "sfrapPerfLmiTotalInterval"))
if mibBuilder.loadTexts: sfrapPerfLmiTotalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfLmiTotalEntry.setDescription('The LMI Short Term Statistics across all DLCIs.')
sfrapPerfLmiTotalInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 18, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("current-interval", 1), ("previous-interval", 2), ("cumulative-counts", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfLmiTotalInterval.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfLmiTotalInterval.setDescription('The Short Term statistics model maintains three intervals: current, previous, and cumulative totals. Interval duration is defined by the Short Term Timer (CfgFrPerfTimersSTInterval). (1) Currently active short term interval (2) Previously completed short term interval (3) Cumulative total since last cleared.')
sfrapPerfLmiTotalDlciValue = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 18, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfLmiTotalDlciValue.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfLmiTotalDlciValue.setDescription('OBSOLETE.')
sfrapPerfLmiTotalRxTotalByteCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 18, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfLmiTotalRxTotalByteCnt.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfLmiTotalRxTotalByteCnt.setDescription('The total number of received LMI bytes counted across all DLCIs.')
sfrapPerfLmiTotalTxTotalByteCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 18, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfLmiTotalTxTotalByteCnt.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfLmiTotalTxTotalByteCnt.setDescription('The total number of transmitted LMI bytes counted across all DLCIs.')
sfrapPerfLmiTotalRxLivoEnqByteCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 18, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfLmiTotalRxLivoEnqByteCnt.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfLmiTotalRxLivoEnqByteCnt.setDescription('The number of bytes received in Link Integrity Verification Only (LIVO) enquiries across all DLCIs.')
sfrapPerfLmiTotalTxLivoEnqByteCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 18, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfLmiTotalTxLivoEnqByteCnt.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfLmiTotalTxLivoEnqByteCnt.setDescription('The number of bytes transmitted in Link Integrity Verification Only (LIVO) enquiries across all DLCIs.')
sfrapPerfLmiTotalRxLivoStatByteCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 18, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfLmiTotalRxLivoStatByteCnt.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfLmiTotalRxLivoStatByteCnt.setDescription('The number of bytes received in Link Integrity Verification Only (LIVO) enquiries across all DLCIs.')
sfrapPerfLmiTotalTxLivoStatByteCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 18, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfLmiTotalTxLivoStatByteCnt.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfLmiTotalTxLivoStatByteCnt.setDescription('The number of bytes transmitted in Link Integrity Verification Only (LIVO) enquiries across all DLCIs.')
sfrapPerfLmiTotalRxFullEnqByteCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 18, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfLmiTotalRxFullEnqByteCnt.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfLmiTotalRxFullEnqByteCnt.setDescription('The number of bytes received in Full Status enquiries across all DLCIs.')
sfrapPerfLmiTotalTxFullEnqByteCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 18, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfLmiTotalTxFullEnqByteCnt.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfLmiTotalTxFullEnqByteCnt.setDescription('The number of bytes transmitted in Full Status enquiries across all DLCIs.')
sfrapPerfLmiTotalRxFullStatByteCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 18, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfLmiTotalRxFullStatByteCnt.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfLmiTotalRxFullStatByteCnt.setDescription('The number of bytes received in Full Status messages across all DLCIs.')
sfrapPerfLmiTotalTxFullStatByteCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 18, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfLmiTotalTxFullStatByteCnt.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfLmiTotalTxFullStatByteCnt.setDescription('The number of bytes transmitted in Full Status messages across all DLCIs.')
sfrapPerfLmiTotalRxOtherByteCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 18, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfLmiTotalRxOtherByteCnt.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfLmiTotalRxOtherByteCnt.setDescription('The number of received bytes across all DLCIs from LMI protocols that are not counted elsewhere (other than Total) in this table.')
sfrapPerfLmiTotalTxOtherByteCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 4, 18, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfLmiTotalTxOtherByteCnt.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfLmiTotalTxOtherByteCnt.setDescription('The number of transmitted bytes across all DLCIs from LMI protocols that are not counted elsewhere (other than Total) in this table.')
sfrapPerfNetworkLongTerm = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 7, 5, 5))
sfrapPerfNetwLongTermTable = MibTable((1, 3, 6, 1, 4, 1, 485, 7, 5, 5, 1), )
if mibBuilder.loadTexts: sfrapPerfNetwLongTermTable.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfNetwLongTermTable.setDescription('Long Term Statistics by DLCI, protocol, and interval. LT statistics are collected on a configurable set of DLCIs and protocols. There are 96 intervals maintained each with a duration defined by the Long Term Timer. Interval 96 is the current window and Interval 1 is furthest back in time (96xLT Timer seconds ago).')
sfrapPerfNetwLongTermEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 7, 5, 5, 1, 1), ).setIndexNames((0, "SFRAP-MIB", "sfrapPerfNetwLongTermDlci"), (0, "SFRAP-MIB", "sfrapPerfNetwLongTermProtocol"), (0, "SFRAP-MIB", "sfrapPerfNetwLongTermInterval"))
if mibBuilder.loadTexts: sfrapPerfNetwLongTermEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfNetwLongTermEntry.setDescription('The Long Term Statistic for a particular DLCI, protocol and interval.')
sfrapPerfNetwLongTermDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 5, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfNetwLongTermDlci.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfNetwLongTermDlci.setDescription('The DLCI monitored for the statistics. The Long Term DLCI filter must first be configured (CfgFrPerfLTDlciFilterEntry).')
sfrapPerfNetwLongTermProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 13, 14, 15, 16, 21, 22, 29, 30, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172))).clone(namedValues=NamedValues(("ip-tx-bc", 1), ("ip-rx-bc", 2), ("tcp-ip-tx-bc", 3), ("tcp-ip-rx-bc", 4), ("ftp-tcp-ip-tx-bc", 5), ("ftp-tcp-ip-rx-bc", 6), ("telnet-tcp-ip-tx-bc", 7), ("telnet-tcp-ip-rx-bc", 8), ("smtp-tcp-ip-tx-bc", 9), ("smtp-tcp-ip-rx-bc", 10), ("http-tcp-ip-tx-bc", 13), ("http-tcp-ip-rx-bc", 14), ("netbios-ssn-tcp-ip-tx-bc", 15), ("netbios-ssn-tcp-ip-rx-bc", 16), ("udp-ip-tx-bc", 21), ("udp-ip-rx-bc", 22), ("tftp-udp-ip-tx-bc", 29), ("tftp-udp-ip-rx-bc", 30), ("netbios-dgm-udp-ip-tx-bc", 33), ("netbios-dgm-udp-ip-rx-bc", 34), ("snmp-udp-ip-tx-bc", 35), ("snmp-udp-ip-rx-bc", 36), ("snmptrap-udp-ip-tx-bc", 37), ("snmptrap-udp-ip-rx-bc", 38), ("rip-udp-ip-tx-bc", 39), ("rip-udp-ip-rx-bc", 40), ("icmp-ip-tx-bc", 41), ("icmp-ip-rx-bc", 42), ("echorep-icmp-ip-tx-bc", 43), ("echorep-icmp-ip-rx-bc", 44), ("dest-unr-icmp-ip-tx-bc", 45), ("dest-unr-icmp-ip-rx-bc", 46), ("src-quench-icmp-ip-tx-bc", 47), ("src-quench-icmp-ip-rx-bc", 48), ("redirect-icmp-ip-tx-bc", 49), ("redirect-icmp-ip-rx-bc", 50), ("echoreq-icmp-ip-tx-bc", 51), ("echoreq-icmp-ip-rx-bc", 52), ("time-excd-icmp-ip-tx-bc", 53), ("time-excd-icmp-ip-rx-bc", 54), ("param-prob-icmp-ip-tx-bc", 55), ("param-prob-icmp-ip-rx-bc", 56), ("timestamp-req-icmp-ip-tx-bc", 57), ("timestamp-req-icmp-ip-rx-bc", 58), ("timestamp-rep-icmp-ip-tx-bc", 59), ("timestamp-rep-icmp-ip-rx-bc", 60), ("addr-mask-req-icmp-ip-tx-bc", 61), ("addr-mask-req-icmp-ip-rx-bc", 62), ("addr-mask-rep-icmp-ip-tx-bc", 63), ("addr-mask-rep-icmp-ip-rx-bc", 64), ("pkt-too-big-icmp-ip-tx-bc", 65), ("pkt-too-big-icmp-ip-rx-bc", 66), ("gp-mem-query-icmp-ip-tx-bc", 67), ("gp-mem-query-icmp-ip-rx-bc", 68), ("gp-mem-report-icmp-ip-tx-bc", 69), ("gp-mem-report-icmp-ip-rx-bc", 70), ("gp-mem-reduct-icmp-ip-tx-bc", 71), ("gp-mem-reduct-icmp-ip-rx-bc", 72), ("ospf-ip-tx-bc", 73), ("ospf-ip-rx-bc", 74), ("other-ip-tx-bc", 75), ("other-ip-rx-bc", 76), ("ipx-tx-bc", 77), ("ipx-rx-bc", 78), ("spx-ipx-tx-bc", 79), ("spx-ipx-rx-bc", 80), ("ncp-ipx-tx-bc", 81), ("ncp-ipx-rx-bc", 82), ("sap-ipx-tx-bc", 83), ("sap-ipx-rx-bc", 84), ("rip-ipx-tx-bc", 85), ("rip-ipx-rx-bc", 86), ("netbios-ipx-tx-bc", 87), ("netbios-ipx-rx-bc", 88), ("other-ipx-tx-bc", 89), ("other-ipx-rx-bc", 90), ("arp-tx-bc", 91), ("arp-rx-bc", 92), ("arp-req-tx-bc", 93), ("arp-req-rx-bc", 94), ("arp-rep-tx-bc", 95), ("arp-rep-rx-bc", 96), ("rarp-req-tx-bc", 97), ("rarp-req-rx-bc", 98), ("rarp-rep-tx-bc", 99), ("rarp-rep-rx-bc", 100), ("inarp-req-tx-bc", 101), ("inarp-req-rx-bc", 102), ("inarp-rep-tx-bc", 103), ("inarp-rep-rx-bc", 104), ("sna-tx-bc", 105), ("sna-rx-bc", 106), ("sna-subarea-tx-bc", 107), ("sna-subarea-rx-bc", 108), ("sna-periph-tx-bc", 109), ("sna-periph-rx-bc", 110), ("sna-appn-tx-bc", 111), ("sna-appn-rx-bc", 112), ("sna-netbios-tx-bc", 113), ("sna-netbios-rx-bc", 114), ("cisco-tx-bc", 115), ("cisco-rx-bc", 116), ("other-tx-bc", 117), ("other-rx-bc", 118), ("user-defined-1-tx-bc", 119), ("user-defined-1-rx-bc", 120), ("user-defined-2-tx-bc", 121), ("user-defined-2-rx-bc", 122), ("user-defined-3-tx-bc", 123), ("user-defined-3-rx-bc", 124), ("user-defined-4-tx-bc", 125), ("user-defined-4-rx-bc", 126), ("thru-byte-tx-bc", 127), ("thru-byte-rx-bc", 128), ("thru-frame-tx-c", 129), ("thru-frame-rx-c", 130), ("thru-fecn-tx-c", 131), ("thru-fecn-rx-c", 132), ("thru-becn-tx-c", 133), ("thru-becn-rx-c", 134), ("thru-de-tx-c", 135), ("thru-de-rx-c", 136), ("cir-percent-range1-tx-bc", 137), ("cir-percent-range1-rx-bc", 138), ("cir-percent-range2-tx-bc", 139), ("cir-percent-range2-rx-bc", 140), ("cir-percent-range3-tx-bc", 141), ("cir-percent-range3-rx-bc", 142), ("cir-percent-range4-tx-bc", 143), ("cir-percent-range4-rx-bc", 144), ("cir-percent-range5-tx-bc", 145), ("cir-percent-range5-rx-bc", 146), ("cir-percent-range6-tx-bc", 147), ("cir-percent-range6-rx-bc", 148), ("cir-percent-range7-tx-bc", 149), ("cir-percent-range7-rx-bc", 150), ("cir-percent-range8-tx-bc", 151), ("cir-percent-range8-rx-bc", 152), ("lmi-tx-bc", 153), ("lmi-rx-bc", 154), ("lmi-livo-enq-tx-bc", 155), ("lmi-livo-enq-rx-bc", 156), ("lmi-livo-stat-tx-bc", 157), ("lmi-livo-stat-rx-bc", 158), ("lmi-full-enq-tx-bc", 159), ("lmi-full-enq-rx-bc", 160), ("lmi-full-stat-tx-bc", 161), ("lmi-full-stat-rx-bc", 162), ("lmi-other-tx-bc", 163), ("lmi-other-rx-bc", 164), ("total-uptime", 165), ("total-downtime", 166), ("igrp-tx-bc", 167), ("igrp-rx-bc", 168), ("vnip-tx-bc", 169), ("vnip-rx-bc", 170), ("annex-g-tx-bc", 171), ("annex-g-rx-bc", 172)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfNetwLongTermProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfNetwLongTermProtocol.setDescription('The type of protocol monitored for the statistics.')
sfrapPerfNetwLongTermInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 5, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfNetwLongTermInterval.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfNetwLongTermInterval.setDescription('The time interval in which the value was collected. Long Term statistis are maintained for 96 intervals with the interval duration defined by (CfgFrPerfTimersLTInterval).')
sfrapPerfNetwLongTermValue = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 5, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfNetwLongTermValue.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfNetwLongTermValue.setDescription('The statistic collected for the given DLCI and protocol and within the given time interval.')
sfrapPerfNetwLongTermAltTable = MibTable((1, 3, 6, 1, 4, 1, 485, 7, 5, 5, 2), )
if mibBuilder.loadTexts: sfrapPerfNetwLongTermAltTable.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfNetwLongTermAltTable.setDescription('This is an alternative method to access the database of long term statistics. The statistics are indexed by DLCI and protocol and are returned in an OCTETSTRING.')
sfrapPerfNetwLongTermAltEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 7, 5, 5, 2, 1), ).setIndexNames((0, "SFRAP-MIB", "sfrapPerfNetwLongTermAltDlci"), (0, "SFRAP-MIB", "sfrapPerfNetwLongTermAltProtocol"))
if mibBuilder.loadTexts: sfrapPerfNetwLongTermAltEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfNetwLongTermAltEntry.setDescription('The Long Term Statistic for a particular DLCI and protocol.')
sfrapPerfNetwLongTermAltDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 5, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfNetwLongTermAltDlci.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfNetwLongTermAltDlci.setDescription('The DLCI monitored for the statistics.')
sfrapPerfNetwLongTermAltProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 5, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 13, 14, 15, 16, 21, 22, 29, 30, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172))).clone(namedValues=NamedValues(("ip-tx-bc", 1), ("ip-rx-bc", 2), ("tcp-ip-tx-bc", 3), ("tcp-ip-rx-bc", 4), ("ftp-tcp-ip-tx-bc", 5), ("ftp-tcp-ip-rx-bc", 6), ("telnet-tcp-ip-tx-bc", 7), ("telnet-tcp-ip-rx-bc", 8), ("smtp-tcp-ip-tx-bc", 9), ("smtp-tcp-ip-rx-bc", 10), ("http-tcp-ip-tx-bc", 13), ("http-tcp-ip-rx-bc", 14), ("netbios-ssn-tcp-ip-tx-bc", 15), ("netbios-ssn-tcp-ip-rx-bc", 16), ("udp-ip-tx-bc", 21), ("udp-ip-rx-bc", 22), ("tftp-udp-ip-tx-bc", 29), ("tftp-udp-ip-rx-bc", 30), ("netbios-dgm-udp-ip-tx-bc", 33), ("netbios-dgm-udp-ip-rx-bc", 34), ("snmp-udp-ip-tx-bc", 35), ("snmp-udp-ip-rx-bc", 36), ("snmptrap-udp-ip-tx-bc", 37), ("snmptrap-udp-ip-rx-bc", 38), ("rip-udp-ip-tx-bc", 39), ("rip-udp-ip-rx-bc", 40), ("icmp-ip-tx-bc", 41), ("icmp-ip-rx-bc", 42), ("echorep-icmp-ip-tx-bc", 43), ("echorep-icmp-ip-rx-bc", 44), ("dest-unr-icmp-ip-tx-bc", 45), ("dest-unr-icmp-ip-rx-bc", 46), ("src-quench-icmp-ip-tx-bc", 47), ("src-quench-icmp-ip-rx-bc", 48), ("redirect-icmp-ip-tx-bc", 49), ("redirect-icmp-ip-rx-bc", 50), ("echoreq-icmp-ip-tx-bc", 51), ("echoreq-icmp-ip-rx-bc", 52), ("time-excd-icmp-ip-tx-bc", 53), ("time-excd-icmp-ip-rx-bc", 54), ("param-prob-icmp-ip-tx-bc", 55), ("param-prob-icmp-ip-rx-bc", 56), ("timestamp-req-icmp-ip-tx-bc", 57), ("timestamp-req-icmp-ip-rx-bc", 58), ("timestamp-rep-icmp-ip-tx-bc", 59), ("timestamp-rep-icmp-ip-rx-bc", 60), ("addr-mask-req-icmp-ip-tx-bc", 61), ("addr-mask-req-icmp-ip-rx-bc", 62), ("addr-mask-rep-icmp-ip-tx-bc", 63), ("addr-mask-rep-icmp-ip-rx-bc", 64), ("pkt-too-big-icmp-ip-tx-bc", 65), ("pkt-too-big-icmp-ip-rx-bc", 66), ("gp-mem-query-icmp-ip-tx-bc", 67), ("gp-mem-query-icmp-ip-rx-bc", 68), ("gp-mem-report-icmp-ip-tx-bc", 69), ("gp-mem-report-icmp-ip-rx-bc", 70), ("gp-mem-reduct-icmp-ip-tx-bc", 71), ("gp-mem-reduct-icmp-ip-rx-bc", 72), ("ospf-ip-tx-bc", 73), ("ospf-ip-rx-bc", 74), ("other-ip-tx-bc", 75), ("other-ip-rx-bc", 76), ("ipx-tx-bc", 77), ("ipx-rx-bc", 78), ("spx-ipx-tx-bc", 79), ("spx-ipx-rx-bc", 80), ("ncp-ipx-tx-bc", 81), ("ncp-ipx-rx-bc", 82), ("sap-ipx-tx-bc", 83), ("sap-ipx-rx-bc", 84), ("rip-ipx-tx-bc", 85), ("rip-ipx-rx-bc", 86), ("netbios-ipx-tx-bc", 87), ("netbios-ipx-rx-bc", 88), ("other-ipx-tx-bc", 89), ("other-ipx-rx-bc", 90), ("arp-tx-bc", 91), ("arp-rx-bc", 92), ("arp-req-tx-bc", 93), ("arp-req-rx-bc", 94), ("arp-rep-tx-bc", 95), ("arp-rep-rx-bc", 96), ("rarp-req-tx-bc", 97), ("rarp-req-rx-bc", 98), ("rarp-rep-tx-bc", 99), ("rarp-rep-rx-bc", 100), ("inarp-req-tx-bc", 101), ("inarp-req-rx-bc", 102), ("inarp-rep-tx-bc", 103), ("inarp-rep-rx-bc", 104), ("sna-tx-bc", 105), ("sna-rx-bc", 106), ("sna-subarea-tx-bc", 107), ("sna-subarea-rx-bc", 108), ("sna-periph-tx-bc", 109), ("sna-periph-rx-bc", 110), ("sna-appn-tx-bc", 111), ("sna-appn-rx-bc", 112), ("sna-netbios-tx-bc", 113), ("sna-netbios-rx-bc", 114), ("cisco-tx-bc", 115), ("cisco-rx-bc", 116), ("other-tx-bc", 117), ("other-rx-bc", 118), ("user-defined-1-tx-bc", 119), ("user-defined-1-rx-bc", 120), ("user-defined-2-tx-bc", 121), ("user-defined-2-rx-bc", 122), ("user-defined-3-tx-bc", 123), ("user-defined-3-rx-bc", 124), ("user-defined-4-tx-bc", 125), ("user-defined-4-rx-bc", 126), ("thru-byte-tx-bc", 127), ("thru-byte-rx-bc", 128), ("thru-frame-tx-c", 129), ("thru-frame-rx-c", 130), ("thru-fecn-tx-c", 131), ("thru-fecn-rx-c", 132), ("thru-becn-tx-c", 133), ("thru-becn-rx-c", 134), ("thru-de-tx-c", 135), ("thru-de-rx-c", 136), ("cir-percent-range1-tx-bc", 137), ("cir-percent-range1-rx-bc", 138), ("cir-percent-range2-tx-bc", 139), ("cir-percent-range2-rx-bc", 140), ("cir-percent-range3-tx-bc", 141), ("cir-percent-range3-rx-bc", 142), ("cir-percent-range4-tx-bc", 143), ("cir-percent-range4-rx-bc", 144), ("cir-percent-range5-tx-bc", 145), ("cir-percent-range5-rx-bc", 146), ("cir-percent-range6-tx-bc", 147), ("cir-percent-range6-rx-bc", 148), ("cir-percent-range7-tx-bc", 149), ("cir-percent-range7-rx-bc", 150), ("cir-percent-range8-tx-bc", 151), ("cir-percent-range8-rx-bc", 152), ("lmi-tx-bc", 153), ("lmi-rx-bc", 154), ("lmi-livo-enq-tx-bc", 155), ("lmi-livo-enq-rx-bc", 156), ("lmi-livo-stat-tx-bc", 157), ("lmi-livo-stat-rx-bc", 158), ("lmi-full-enq-tx-bc", 159), ("lmi-full-enq-rx-bc", 160), ("lmi-full-stat-tx-bc", 161), ("lmi-full-stat-rx-bc", 162), ("lmi-other-tx-bc", 163), ("lmi-other-rx-bc", 164), ("total-uptime", 165), ("total-downtime", 166), ("igrp-tx-bc", 167), ("igrp-rx-bc", 168), ("vnip-tx-bc", 169), ("vnip-rx-bc", 170), ("annex-g-tx-bc", 171), ("annex-g-rx-bc", 172)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfNetwLongTermAltProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfNetwLongTermAltProtocol.setDescription('The protocol monitored for the statistics.')
sfrapPerfNetwLongTermAltArray = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 5, 2, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfNetwLongTermAltArray.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfNetwLongTermAltArray.setDescription('The statistic collected for the given DLCI and protocol.')
sfrapPerfNetworkLongTermCommands = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 7, 5, 5, 3))
sfrapPerfNetworkLongTermCmdClear = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 5, 5, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("clear-statistics", 1)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: sfrapPerfNetworkLongTermCmdClear.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfNetworkLongTermCmdClear.setDescription('Allows the user to zero out all the statistics in the long term statistics tables. (1) Clear all Long Term statistics')
sfrapPerfCirPercentUtilization = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 7, 5, 6))
sfrapPerfCirPercentUtilizationTable = MibTable((1, 3, 6, 1, 4, 1, 485, 7, 5, 6, 1), )
if mibBuilder.loadTexts: sfrapPerfCirPercentUtilizationTable.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfCirPercentUtilizationTable.setDescription('Short Term Statistics on the percentage of CIR used on each DLCI. Each short term statistics interval, the count of bytes transmitted and received is used to calculate the percentage of CIR used. The byte count is then added to the appropriate bucket for the CIR percentage range.')
sfrapPerfCirPercentUtilizationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 7, 5, 6, 1, 1), ).setIndexNames((0, "SFRAP-MIB", "sfrapPerfCirPercentUtilizationInterval"), (0, "SFRAP-MIB", "sfrapPerfCirPercentUtilizationDlciValue"))
if mibBuilder.loadTexts: sfrapPerfCirPercentUtilizationEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfCirPercentUtilizationEntry.setDescription('The CIR Percentage Statistics for a particular DLCI. These calculations are done at the completion of each Short Term interval.')
sfrapPerfCirPercentUtilizationInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 6, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("current-interval", 1), ("previous-interval", 2), ("cumulative-counts", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfCirPercentUtilizationInterval.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfCirPercentUtilizationInterval.setDescription('The Short Term statistics model maintains three intervals: current, previous, and cumulative totals. Interval duration is defined by the Short Term Timer (CfgFrPerfTimersSTInterval). (1) Currently active short term interval (2) Previously completed short term interval (3) Cumulative total since last cleared.')
sfrapPerfCirPercentUtilizationDlciValue = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 6, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfCirPercentUtilizationDlciValue.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfCirPercentUtilizationDlciValue.setDescription('The DLCI value with which the Statistics are associated.')
sfrapPerfCirRxPercentUtilizationRange1 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 6, 1, 1, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfCirRxPercentUtilizationRange1.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfCirRxPercentUtilizationRange1.setDescription('The number of short-term intervals during which rx data throughput on this DLCI compared to CIR was in range 1 (0% of CIR).')
sfrapPerfCirRxPercentUtilizationRange2 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 6, 1, 1, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfCirRxPercentUtilizationRange2.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfCirRxPercentUtilizationRange2.setDescription('The number of short-term intervals during which rx data throughput on this DLCI compared to CIR was in range 2 (1-10% of CIR).')
sfrapPerfCirRxPercentUtilizationRange3 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 6, 1, 1, 23), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfCirRxPercentUtilizationRange3.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfCirRxPercentUtilizationRange3.setDescription('The number of short-term intervals during which rx data throughput on this DLCI compared to CIR was in range 3 (11-20% of CIR).')
sfrapPerfCirRxPercentUtilizationRange4 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 6, 1, 1, 24), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfCirRxPercentUtilizationRange4.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfCirRxPercentUtilizationRange4.setDescription('The number of short-term intervals during which rx data throughput on this DLCI compared to CIR was in range 4 (21-50% of CIR).')
sfrapPerfCirRxPercentUtilizationRange5 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 6, 1, 1, 25), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfCirRxPercentUtilizationRange5.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfCirRxPercentUtilizationRange5.setDescription('The number of short-term intervals during which rx data throughput on this DLCI compared to CIR was in range 5 (51-80% of CIR).')
sfrapPerfCirRxPercentUtilizationRange6 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 6, 1, 1, 26), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfCirRxPercentUtilizationRange6.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfCirRxPercentUtilizationRange6.setDescription('The number of short-term intervals during which rx data throughput on this DLCI compared to CIR was in range 6 (81-100% of CIR).')
sfrapPerfCirRxPercentUtilizationRange7 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 6, 1, 1, 27), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfCirRxPercentUtilizationRange7.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfCirRxPercentUtilizationRange7.setDescription('The number of short-term intervals during which rx data throughput on this DLCI compared to CIR was in range 7 (101-150% of CIR).')
sfrapPerfCirRxPercentUtilizationRange8 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 6, 1, 1, 28), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfCirRxPercentUtilizationRange8.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfCirRxPercentUtilizationRange8.setDescription('The number of short-term intervals during which rx data throughput on this DLCI compared to CIR was in range 8 (> 150% of CIR).')
sfrapPerfCirTxPercentUtilizationRange1 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 6, 1, 1, 41), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfCirTxPercentUtilizationRange1.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfCirTxPercentUtilizationRange1.setDescription('The number of short-term intervals during which tx data throughput on this DLCI compared to CIR was in range 1 (0% of CIR).')
sfrapPerfCirTxPercentUtilizationRange2 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 6, 1, 1, 42), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfCirTxPercentUtilizationRange2.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfCirTxPercentUtilizationRange2.setDescription('The number of short-term intervals during which tx data throughput on this DLCI compared to CIR was in range 2 (1-10% of CIR).')
sfrapPerfCirTxPercentUtilizationRange3 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 6, 1, 1, 43), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfCirTxPercentUtilizationRange3.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfCirTxPercentUtilizationRange3.setDescription('The number of short-term intervals during which tx data throughput on this DLCI compared to CIR was in range 3 (11-20% of CIR).')
sfrapPerfCirTxPercentUtilizationRange4 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 6, 1, 1, 44), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfCirTxPercentUtilizationRange4.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfCirTxPercentUtilizationRange4.setDescription('The number of short-term intervals during which tx data throughput on this DLCI compared to CIR was in range 4 (21-50% of CIR).')
sfrapPerfCirTxPercentUtilizationRange5 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 6, 1, 1, 45), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfCirTxPercentUtilizationRange5.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfCirTxPercentUtilizationRange5.setDescription('The number of short-term intervals during which tx data throughput on this DLCI compared to CIR was in range 5 (51-80% of CIR).')
sfrapPerfCirTxPercentUtilizationRange6 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 6, 1, 1, 46), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfCirTxPercentUtilizationRange6.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfCirTxPercentUtilizationRange6.setDescription('The number of short-term intervals during which tx data throughput on this DLCI compared to CIR was in range 6 (81-100% o0f CIR).')
sfrapPerfCirTxPercentUtilizationRange7 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 6, 1, 1, 47), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfCirTxPercentUtilizationRange7.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfCirTxPercentUtilizationRange7.setDescription('The number of short-term intervals during which tx data throughput on this DLCI compared to CIR was in range 7 (101-150% of CIR).')
sfrapPerfCirTxPercentUtilizationRange8 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 6, 1, 1, 48), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfCirTxPercentUtilizationRange8.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfCirTxPercentUtilizationRange8.setDescription('The number of short-term intervals during which tx data throughput on this DLCI compared to CIR was in range 8 (> 150% of CIR).')
sfrapPerfCurrentPerDlciUtilizationTable = MibTable((1, 3, 6, 1, 4, 1, 485, 7, 5, 6, 2), )
if mibBuilder.loadTexts: sfrapPerfCurrentPerDlciUtilizationTable.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfCurrentPerDlciUtilizationTable.setDescription('The current measurement of utilization as a percentage of CIR on each DLCI. Each short term statistics interval, the count of bytes transmitted and received is used to calculate the percentage of CIR used.')
sfrapPerfCurrentPerDlciUtilizationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 7, 5, 6, 2, 1), ).setIndexNames((0, "SFRAP-MIB", "sfrapPerfCurrentPerDlciUtilizationDlciValue"))
if mibBuilder.loadTexts: sfrapPerfCurrentPerDlciUtilizationEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfCurrentPerDlciUtilizationEntry.setDescription('The utilization statistics for a particular DLCI.')
sfrapPerfCurrentPerDlciUtilizationDlciValue = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 6, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfCurrentPerDlciUtilizationDlciValue.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfCurrentPerDlciUtilizationDlciValue.setDescription('The DLCI value with which the Statistics are associated.')
sfrapPerfCurrentPerDlciRxUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 6, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfCurrentPerDlciRxUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfCurrentPerDlciRxUtilization.setDescription('The receive direction utilization as a percentage of CIR.')
sfrapPerfCurrentPerDlciTxUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 6, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfCurrentPerDlciTxUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfCurrentPerDlciTxUtilization.setDescription('The transmit direction utilization as a percentage of CIR.')
sfrapPerfCurrentPerDlciAggregateUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 5, 6, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfCurrentPerDlciAggregateUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfCurrentPerDlciAggregateUtilization.setDescription('The aggregate utilization, the average of the receive and transmit utilization as a percentage of CIR.')
sfrapPerfCurrentUnitUtilization = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 7, 5, 6, 3))
sfrapPerfCurrentDteUtilization = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 5, 6, 3, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfCurrentDteUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfCurrentDteUtilization.setDescription('The DTE interface utilization as a percentage of line rate.')
sfrapPerfCurrentWanUtilization = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 5, 6, 3, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfCurrentWanUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfCurrentWanUtilization.setDescription('The WAN interface utilization as a percentage of line rate.')
sfrapPerfCurrentAggregateUtilization = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 5, 6, 3, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfCurrentAggregateUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfCurrentAggregateUtilization.setDescription('The aggregate utilization of the unit, the average of the DTE and WAN interface utilizations as a percentage of line rate.')
sfrapPerfFRStatsCollectionStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 7, 5, 7))
sfrapPerfFRStatsCollection = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 5, 7, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("not-collecting-stats", 1), ("collecting-stats", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPerfFRStatsCollection.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPerfFRStatsCollection.setDescription("Tells the GUI whether or not the Frame Relay Performance statistics are valid or not. This is a SFRAP Low Speed option, if the user's network bandwidth has exceeded the Low Speed boundary, then it is set to not-collecting-stats (1) all other cases it is set to collecting-stats (2).")
sfrapEventTrapLog = MibIdentifier((1, 3, 6, 1, 4, 1, 485, 7, 10))
sfrapEventTrapLogTable = MibTable((1, 3, 6, 1, 4, 1, 485, 7, 10, 1), )
if mibBuilder.loadTexts: sfrapEventTrapLogTable.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapEventTrapLogTable.setDescription('This table contains the Event/Trap log. The entries are indexed by sequence number.')
sfrapEventTrapLogEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 7, 10, 1, 1), ).setIndexNames((0, "SFRAP-MIB", "sfrapEventTrapLogSeqNum"))
if mibBuilder.loadTexts: sfrapEventTrapLogEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapEventTrapLogEntry.setDescription('The event record for a particular event.')
sfrapEventTrapLogSeqNum = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 10, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapEventTrapLogSeqNum.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapEventTrapLogSeqNum.setDescription('The sequence number associated with an event record.')
sfrapEventTrapLogGenericEvent = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 10, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapEventTrapLogGenericEvent.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapEventTrapLogGenericEvent.setDescription('The SNMP generic trap or event number.')
sfrapEventTrapLogSpecificEvent = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 10, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapEventTrapLogSpecificEvent.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapEventTrapLogSpecificEvent.setDescription('The SNMP specific trap or event sub-identifier number.')
sfrapEventTrapLogTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 10, 1, 1, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapEventTrapLogTimeStamp.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapEventTrapLogTimeStamp.setDescription('The SNMP trap timestamp.')
sfrapEventTrapLogVarBind1 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 10, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapEventTrapLogVarBind1.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapEventTrapLogVarBind1.setDescription('Variable Binding 1 for this SNMP Trap event.')
sfrapEventTrapLogVarBind2 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 10, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapEventTrapLogVarBind2.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapEventTrapLogVarBind2.setDescription('Variable Binding 2 for this SNMP Trap event.')
sfrapEventTrapLogVarBind3 = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 10, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapEventTrapLogVarBind3.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapEventTrapLogVarBind3.setDescription('Variable Binding 3 for this SNMP Trap event.')
sfrapEventLogAltTable = MibTable((1, 3, 6, 1, 4, 1, 485, 7, 10, 2), )
if mibBuilder.loadTexts: sfrapEventLogAltTable.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapEventLogAltTable.setDescription("This is an alternative method to access the database of the Event/Trap Log. The database is indexed by Sequence Number and Event/Trap log's are returned in an OCTETSTRING.")
sfrapEventLogAltEntry = MibTableRow((1, 3, 6, 1, 4, 1, 485, 7, 10, 2, 1), ).setIndexNames((0, "SFRAP-MIB", "sfrapEventLogAltSeqNum"))
if mibBuilder.loadTexts: sfrapEventLogAltEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapEventLogAltEntry.setDescription('The Event/Trap Log for a particular sequence number.')
sfrapEventLogAltSeqNum = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 10, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapEventLogAltSeqNum.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapEventLogAltSeqNum.setDescription('The Sequence Number monitored for the Event Log')
sfrapEventLogAltArray = MibTableColumn((1, 3, 6, 1, 4, 1, 485, 7, 10, 2, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapEventLogAltArray.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapEventLogAltArray.setDescription('The Event / Trap log for the given sequence number.')
sfrapEventLogCurrentSeqNum = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 10, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapEventLogCurrentSeqNum.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapEventLogCurrentSeqNum.setDescription('The current index into the Event Log Table.')
sfrapEventLogFreeze = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 10, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("freeze", 1), ("un-freeze", 2)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: sfrapEventLogFreeze.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapEventLogFreeze.setDescription('This freezes the Event/Trap Log. freeze(1) will prevent Events / Traps from being entered into the database, un-freeze(2) will allow Events / Traps to be logged into the database. An event will be logged indicating a set of this entry')
sfrapEventLogClear = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 10, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("clear", 1)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: sfrapEventLogClear.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapEventLogClear.setDescription('This clears the Event/Trap Log.')
sfrapAlarmType = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 14, 15, 16, 17, 18, 19, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 75, 76, 80, 81, 82, 83, 84, 85, 86, 90, 91, 92, 93, 94, 95, 96, 97, 100, 101, 102, 103, 138, 139, 140, 141, 142, 257, 258, 259, 260, 261, 262, 263, 264, 265))).clone(namedValues=NamedValues(("bad-config-in-set", 1), ("config-local-update", 2), ("local-unit-loopback-enabled", 14), ("local-unit-loopback-disabled", 15), ("local-unit-loopback-failure", 16), ("local-dte-loopback-enabled", 17), ("local-dte-loopback-disabled", 18), ("local-dte-loopback-failure", 19), ("dlci-active", 47), ("dlci-inactive", 48), ("dlci-td-threshold", 49), ("lmi-sourcing-change-passthru", 50), ("lmi-sourcing-change-user-dte", 51), ("lmi-sourcing-change-net-dte", 52), ("lmi-sourcing-change-user-net", 53), ("lmi-sourcing-change-net-net", 54), ("dte-signal-rts-on", 55), ("dte-signal-rts-off", 56), ("dte-signal-dtr-on", 57), ("dte-signal-dtr-off", 58), ("lmi-non-incr-seq-num-dte", 59), ("lmi-non-incr-seq-num-net", 60), ("lmi-seq-num-mismatch-dte", 61), ("lmi-seq-num-mismatch-net", 62), ("trap-muting-active", 75), ("trap-muting-inactive", 76), ("low-speed-exceeded", 80), ("low-speed-resumed", 81), ("op-mode-cutthru-enabled", 82), ("op-mode-cutthru-disabled", 83), ("local-dte2-loopback-enabled", 84), ("local-dte2-loopback-disabled", 85), ("local-dte2-loopback-failure", 86), ("vloop-loop-up", 90), ("vloop-loop-down", 91), ("vloop-up-via-remote", 92), ("vloop-down-via-remote", 93), ("vloop-failed", 94), ("vbert-started", 95), ("vbert-stopped", 96), ("vbert-request-failed", 97), ("dte-signal-control-on", 100), ("dte-signal-control-off", 101), ("dte-signal-indicate-on", 102), ("dte-signal-indicate-off", 103), ("pvc-rx-utilization-exceeded", 138), ("pvc-tx-utilization-exceeded", 139), ("pvc-rx-utilization-cleared", 140), ("pvc-tx-utilization-cleared", 141), ("config-install-success", 142), ("tftp-requested", 257), ("tftp-transferring", 258), ("tftp-programming", 259), ("tftp-aborted", 260), ("tftp-success", 261), ("tftp-host-unreachable", 262), ("tftp-no-file", 263), ("tftp-invalid-file", 264), ("tftp-corrupt-file", 265)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapAlarmType.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapAlarmType.setDescription('The alarm type of the most recent TRAP generated.')
sfrapDLCINum = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapDLCINum.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapDLCINum.setDescription('The DLCI number for the most recent DLCI TRAP generated.')
sfrapInterface = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("to-dte", 1), ("to-dce", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapInterface.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapInterface.setDescription('The interface most recently reported in a TRAP.')
sfrapIpAddress = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 9), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapIpAddress.setDescription('The IP address most recently reported in a TRAP.')
sfrapPercentUtilization = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapPercentUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapPercentUtilization.setDescription('The percent utilization for a DLCI most recently reported in a TRAP.')
sfrapUtilizationThreshold = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapUtilizationThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapUtilizationThreshold.setDescription('The percent utilization threshold for a DLCI most recently reported in a TRAP.')
sfrapCfgLockIpAddress = MibScalar((1, 3, 6, 1, 4, 1, 485, 7, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfrapCfgLockIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: sfrapCfgLockIpAddress.setDescription('The IP address of the management station locking the configuration most recently reported in a TRAP.')
sfrapTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 7) + (0,0)).setObjects(("SFRAP-MIB", "sfrapAlarmType"))
if mibBuilder.loadTexts: sfrapTrap.setDescription('A sfrapTrap trap signifies that the sending node had its `sfrapAlarmType` variable modified.')
sfrapBadConfigTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 7) + (0,1)).setObjects(("SFRAP-MIB", "sfrapAlarmType"))
if mibBuilder.loadTexts: sfrapBadConfigTrap.setDescription('Unit has received a configuration update request through SNMP but the request was rejected due to an incorrect or inappropriate parameter.')
sfrapLocalConfigTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 7) + (0,2)).setObjects(("SFRAP-MIB", "sfrapAlarmType"))
if mibBuilder.loadTexts: sfrapLocalConfigTrap.setDescription('Unit configuration has been updated locally (console port or front panel keypad) or remotely (telnet).')
sfrapLocalUnitLoopbackEnabledTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 7) + (0,14)).setObjects(("SFRAP-MIB", "sfrapAlarmType"))
if mibBuilder.loadTexts: sfrapLocalUnitLoopbackEnabledTrap.setDescription('Unit is in a bidirectional unit loopback. Data is received from either interface, processed, and transmitted back towards the same interface. When configured for Frame Relay operation the unit will preserve the LMI path during this loopback. In Frame Relay mode, only valid frames are looped back (pseudorandom test patterns will be dropped).')
sfrapLocalUnitLoopbackDisabledTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 7) + (0,15)).setObjects(("SFRAP-MIB", "sfrapAlarmType"))
if mibBuilder.loadTexts: sfrapLocalUnitLoopbackDisabledTrap.setDescription('Bidirectional unit loopback path is removed.')
sfrapLocalUnitLoopbackFailedTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 7) + (0,16)).setObjects(("SFRAP-MIB", "sfrapAlarmType"))
if mibBuilder.loadTexts: sfrapLocalUnitLoopbackFailedTrap.setDescription('Bidirectional unit loopback request has been rejected by the unit. Typically, this is due to the presence of another loopback condition.')
sfrapLocalToDteLoopbackEnabledTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 7) + (0,17)).setObjects(("SFRAP-MIB", "sfrapAlarmType"))
if mibBuilder.loadTexts: sfrapLocalToDteLoopbackEnabledTrap.setDescription('Unit is in a bidirectional TO-DTE loopback. All data received at the TO-DTE interface is looped back regardless of format or content (line loopback). When configured for Frame Relay operation the unit will not preserve the LMI path during this loopback. Data received from the TO-DCE is processed and transmitted back out the TO-DCE. In Frame Relay mode, on the TO-DCE interface, only valid frames are looped back (pseudorandom test patterns will be dropped).')
sfrapLocalToDteLoopbackDisabledTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 7) + (0,18)).setObjects(("SFRAP-MIB", "sfrapAlarmType"))
if mibBuilder.loadTexts: sfrapLocalToDteLoopbackDisabledTrap.setDescription('Bidirectional TO-DTE loopback path is removed.')
sfrapLocalToDteLoopbackFailedTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 7) + (0,19)).setObjects(("SFRAP-MIB", "sfrapAlarmType"))
if mibBuilder.loadTexts: sfrapLocalToDteLoopbackFailedTrap.setDescription('Bidirectional TO-DTE loopback request has been rejected by the unit. Typically, this is due to the presence of another loopback condition.')
sfrapDLCIActiveTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 7) + (0,47)).setObjects(("SFRAP-MIB", "sfrapAlarmType"), ("SFRAP-MIB", "sfrapDLCINum"))
if mibBuilder.loadTexts: sfrapDLCIActiveTrap.setDescription('Unit is reporting this DLCI as active and provisioned. An active DLCI is one that is explictly declared ACTIVE in an LMI Full Status Response (typically coming from a frame relay switch).')
sfrapDLCIInactiveTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 7) + (0,48)).setObjects(("SFRAP-MIB", "sfrapAlarmType"), ("SFRAP-MIB", "sfrapDLCINum"))
if mibBuilder.loadTexts: sfrapDLCIInactiveTrap.setDescription("Unit is reporting this DLCI as inactive. An inactive DLCI is determined inactive one of two ways: it is either explictly declared inactive in an LMI Full Status Response (typically coming from a frame relay switch) or a Full Status Response is not seen causing a Full Status Timer expiry. Having the unit's full status timer too low could result in the unit falsely declaring DLCIs inactive (then active again). This does not interfere with any data activity on the DLCI but could result in excessive traps.")
sfrapDLCITDThresholdTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 7) + (0,49)).setObjects(("SFRAP-MIB", "sfrapAlarmType"), ("SFRAP-MIB", "sfrapDLCINum"), ("SFRAP-MIB", "sfrapIpAddress"))
if mibBuilder.loadTexts: sfrapDLCITDThresholdTrap.setDescription('VNIP has measured a round-trip transit delay on this PVC to this peer which exceeds the user-defined threshold.')
sfrapLmiSourcingChangePassthruTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 7) + (0,50)).setObjects(("SFRAP-MIB", "sfrapAlarmType"))
if mibBuilder.loadTexts: sfrapLmiSourcingChangePassthruTrap.setDescription('Unit is not sourcing any LMI messages. If this state persists then LMI is up and the proper handshaking is occurring independent of the unit. This may also be a transient state if the unit is in an LMI hunt mode. If this trap occurs repeatedly, separated by other LMI sourcing states, the unit is not seeing any of the expected LMI messages from either interface. Check LMI type, connectivity, and configuration of associated equipment.')
sfrapLmiSourcingChangeUserToDteTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 7) + (0,51)).setObjects(("SFRAP-MIB", "sfrapAlarmType"))
if mibBuilder.loadTexts: sfrapLmiSourcingChangeUserToDteTrap.setDescription('Unit is acting as a source of LMI Status Requests (Link Integrity Verification, Keep Alive). If this state persists then the equipment attached to the TO-DTE interface is configured as a Frame Relay DCE but a companion Frame Relay DTE device is not seen out the TO-DCE. This could also be a transient state if the unit is in an LMI hunt mode. If this trap occurs repeatedly, separated by other LMI sourcing states, the unit is not seeing any of the expected LMI messages from either interface. Check LMI type, connectivity, and configuration of associated equipment.')
sfrapLmiSourcingChangeNetToDteTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 7) + (0,52)).setObjects(("SFRAP-MIB", "sfrapAlarmType"))
if mibBuilder.loadTexts: sfrapLmiSourcingChangeNetToDteTrap.setDescription('Unit is acting as a source of LMI Status Responses (Link Intergrity Verification, Keep Alive). If this state persists then the equpiment attached to the TO-DTE interface is configured as a Frame Relay DTE but a companion Frame Relay DCE device is not seen out the TO-DCE. This could also be a transient state if the unit is in an LMI hunt mode. If this trap occurs repeatedly, separated by other LMI sourcing states, the unit is not seeing any of the expected LMI messages from either interface. Check LMI type, connectivity, and configuration of external equipment.')
sfrapLmiSourcingChangeUserToDceTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 7) + (0,53)).setObjects(("SFRAP-MIB", "sfrapAlarmType"))
if mibBuilder.loadTexts: sfrapLmiSourcingChangeUserToDceTrap.setDescription('Unit is acting as a source of LMI Status Requests (Link Integrity Verification, Keep Alive). If this state persists then the equipment attached to the TO-DCE interface is configured as a Frame Relay DCE but a companion Frame Relay DTE device is not seen out the TO-DTE interface. This could also be a transient state if the unit is in an LMI hunt mode. If this trap occurs repeatedly, separated by other LMI sourcing states, the unit is not seeing any of the expected LMI messages from either interface. Check LMI type, connectivity, and configuration of associated equipment.')
sfrapLmiSourcingChangeNetToDceTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 7) + (0,54)).setObjects(("SFRAP-MIB", "sfrapAlarmType"))
if mibBuilder.loadTexts: sfrapLmiSourcingChangeNetToDceTrap.setDescription('Unit is acting as a source of LMI Status Responses (Link Integrity Verification, Keep Alive). If this state persists then the equipment attached to the TO-DCE interface is configured as a Frame Relay DTE but a companion Frame Relay DCE device is not seen out the TO-DTE interface. This could also be a transient state if the unit is in an LMI hunt mode. If this trap occurs repeatedly, separated by other LMI sourcing states, the unit is not seeing any of the expected LMI messages from either interface. Check LMI type, connectivity, and configuration of associated equipment.')
sfrapDteSignalRtsOnTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 7) + (0,55)).setObjects(("SFRAP-MIB", "sfrapAlarmType"))
if mibBuilder.loadTexts: sfrapDteSignalRtsOnTrap.setDescription("Unit's DTE Request to Send (RTS) interface control signal is now active (on). This signal is presented by the external DTE device. Unit may be configured to ignore the state of this signal or to require it for data transmission.")
sfrapDteSignalRtsOffTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 7) + (0,56)).setObjects(("SFRAP-MIB", "sfrapAlarmType"))
if mibBuilder.loadTexts: sfrapDteSignalRtsOffTrap.setDescription("Unit's DTE Request to Send (RTS) interface control signal is now inactive (off). This signal is presented by the external DTE device. Unit may be configured to ignore the state of this signal or to require it for data transmission.")
sfrapDteSignalDtrOnTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 7) + (0,57)).setObjects(("SFRAP-MIB", "sfrapAlarmType"))
if mibBuilder.loadTexts: sfrapDteSignalDtrOnTrap.setDescription("Unit's DTE Data Terminal Ready (DTR) interface control signal is now active (on). This signal is presented by the external DTE device. The unit may be configured to ignore the state of this signal or to require it for data transmission.")
sfrapDteSignalDtrOffTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 7) + (0,58)).setObjects(("SFRAP-MIB", "sfrapAlarmType"))
if mibBuilder.loadTexts: sfrapDteSignalDtrOffTrap.setDescription("Unit's DTE Data Terminal Ready (DTR) interface control signal is now inactive (off). This signal is presented by the external DTE device. Unit may be configured to ignore the state of this signal or to require it for data transmission.")
sfrapNonIncrLmiSeqNumToDteTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 7) + (0,59)).setObjects(("SFRAP-MIB", "sfrapAlarmType"))
if mibBuilder.loadTexts: sfrapNonIncrLmiSeqNumToDteTrap.setDescription("Unit has detected a non-incrementing LMI sequence number from the TO-DTE. A Status Enquiry or Status Response message has been seen at the TO-DTE interface. The Link Integrity information element's Send Sequence Number was not incremented or was incremented more than once since the last Send Sequence Number seen from the TO-DTE interface.")
sfrapNonIncrLmiSeqNumToDceTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 7) + (0,60)).setObjects(("SFRAP-MIB", "sfrapAlarmType"))
if mibBuilder.loadTexts: sfrapNonIncrLmiSeqNumToDceTrap.setDescription("Unit has detected a non-incrementing LMI sequence number from the TO-DCE. A Status Enquiry or Status Response message has been seen at the TO-DCE interface. The Link Integrity information element's Send Sequence Number was not incremented or was incremented more than once since the last Send Sequence Number seen from the TO-DCE interface.")
sfrapLmiSeqNumMismatchToDteTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 7) + (0,61)).setObjects(("SFRAP-MIB", "sfrapAlarmType"))
if mibBuilder.loadTexts: sfrapLmiSeqNumMismatchToDteTrap.setDescription("Unit has detetcted an LMI sequence number mismatch from the TO-DTE. A Status Enquiry or Status Response message has been seen at the TO-DTE interface. The Link Inetgrity information element's Receive Sequence Number was not the most recent Send Sequence number sent from the TO-DCE interface. ")
sfrapLmiSeqNumMismatchToDceTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 7) + (0,62)).setObjects(("SFRAP-MIB", "sfrapAlarmType"))
if mibBuilder.loadTexts: sfrapLmiSeqNumMismatchToDceTrap.setDescription("Unit has detetcted an LMI sequence number mismatch from the TO-DCE. A Status Enquiry or Status Response message has been seen at the TO-DCE interface. The Link Inetgrity information element's Receive Sequence Number was not the most recent Send Sequence number sent from the TO-DTE interface.")
sfrapTrapMutingActive = NotificationType((1, 3, 6, 1, 4, 1, 485, 7) + (0,75)).setObjects(("SFRAP-MIB", "sfrapAlarmType"))
if mibBuilder.loadTexts: sfrapTrapMutingActive.setDescription('Trap generation is muted.')
sfrapTrapMutingInactive = NotificationType((1, 3, 6, 1, 4, 1, 485, 7) + (0,76)).setObjects(("SFRAP-MIB", "sfrapAlarmType"))
if mibBuilder.loadTexts: sfrapTrapMutingInactive.setDescription('Trap generation is re-enabled (muting disabled).')
sfrapLowSpeedExceededTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 7) + (0,80)).setObjects(("SFRAP-MIB", "sfrapAlarmType"))
if mibBuilder.loadTexts: sfrapLowSpeedExceededTrap.setDescription('The bandwidth has exceeded the maximum bandwidth for the Low Speed SFRAP. Throttle your network bandwidth.')
sfrapLowSpeedResumedTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 7) + (0,81)).setObjects(("SFRAP-MIB", "sfrapAlarmType"))
if mibBuilder.loadTexts: sfrapLowSpeedResumedTrap.setDescription('The bandwidth has is now under the maximum bandwidth for the Low Speed SFRAP. Frame Relay processing will resume.')
sfrapOpModeCutThruEnabledTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 7) + (0,82)).setObjects(("SFRAP-MIB", "sfrapAlarmType"))
if mibBuilder.loadTexts: sfrapOpModeCutThruEnabledTrap.setDescription('The Unit has been put into Cut Through mode via the diagnostic. The unit is now operating as if it were in Tap mode. The processor is NOT transmitting data.')
sfrapOpModeCutThruDisabledTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 7) + (0,83)).setObjects(("SFRAP-MIB", "sfrapAlarmType"))
if mibBuilder.loadTexts: sfrapOpModeCutThruDisabledTrap.setDescription('The Unit has now resumed normal operation based upon the configured operation mode,Tap or Inband.')
sfrapLocalDte2LoopbackEnabledTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 7) + (0,84)).setObjects(("SFRAP-MIB", "sfrapAlarmType"))
if mibBuilder.loadTexts: sfrapLocalDte2LoopbackEnabledTrap.setDescription('Local TO-DCE loopback enabled.')
sfrapLocalDte2LoopbackDisabledTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 7) + (0,85)).setObjects(("SFRAP-MIB", "sfrapAlarmType"))
if mibBuilder.loadTexts: sfrapLocalDte2LoopbackDisabledTrap.setDescription('Local TO-DCE loopback disabled.')
sfrapLocalDte2LoopbackFailedTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 7) + (0,86)).setObjects(("SFRAP-MIB", "sfrapAlarmType"))
if mibBuilder.loadTexts: sfrapLocalDte2LoopbackFailedTrap.setDescription('Unable to do a local TO-DCE loopback.')
sfrapVloopUp = NotificationType((1, 3, 6, 1, 4, 1, 485, 7) + (0,90)).setObjects(("SFRAP-MIB", "sfrapAlarmType"), ("SFRAP-MIB", "sfrapDLCINum"), ("SFRAP-MIB", "sfrapInterface"))
if mibBuilder.loadTexts: sfrapVloopUp.setDescription('A Vnip PVC loopback (VLOOP) request has been sent to a remote device on this DLCI out this interface. The remote unit should respond by looping all data received on this PVC back towards the unit that initiated this request. A PVC running VLOOP will not be running any user data.')
sfrapVloopDown = NotificationType((1, 3, 6, 1, 4, 1, 485, 7) + (0,91)).setObjects(("SFRAP-MIB", "sfrapAlarmType"), ("SFRAP-MIB", "sfrapDLCINum"), ("SFRAP-MIB", "sfrapInterface"))
if mibBuilder.loadTexts: sfrapVloopDown.setDescription('A Vnip PVC loopback (VLOOP) disable request has been sent to a remote device on this DLCI out this interface. The remote unit should respond by tearing down the logical loop on this DLCI.')
sfrapVloopUpViaRemote = NotificationType((1, 3, 6, 1, 4, 1, 485, 7) + (0,92)).setObjects(("SFRAP-MIB", "sfrapAlarmType"), ("SFRAP-MIB", "sfrapDLCINum"), ("SFRAP-MIB", "sfrapInterface"))
if mibBuilder.loadTexts: sfrapVloopUpViaRemote.setDescription('A Vnip PVC loopback (VLOOP) request has been received from a remote device on this DLCI on this interface. The unit will respond by looping all data received on this PVC back out the interface towards the unit that initiated the request.')
sfrapVloopDownViaRemote = NotificationType((1, 3, 6, 1, 4, 1, 485, 7) + (0,93)).setObjects(("SFRAP-MIB", "sfrapAlarmType"), ("SFRAP-MIB", "sfrapDLCINum"), ("SFRAP-MIB", "sfrapInterface"))
if mibBuilder.loadTexts: sfrapVloopDownViaRemote.setDescription('A request to disable a Vnip PVC loopback (VLOOP) on this unit with the indicated DLCI and Interface has been received. Usually this disable request is from the remote device that requested the VLOOP, however the request may also be due to a local event such as expiration of a locally configured loopback timeout. The unit will respond by tearing down the logical loop on this DLCI.')
sfrapVloopRequestFailed = NotificationType((1, 3, 6, 1, 4, 1, 485, 7) + (0,94)).setObjects(("SFRAP-MIB", "sfrapAlarmType"), ("SFRAP-MIB", "sfrapDLCINum"), ("SFRAP-MIB", "sfrapInterface"))
if mibBuilder.loadTexts: sfrapVloopRequestFailed.setDescription('The request for a PVC loopback (VLOOP) has been rejected or did not complete.')
sfrapVbertStarted = NotificationType((1, 3, 6, 1, 4, 1, 485, 7) + (0,95)).setObjects(("SFRAP-MIB", "sfrapAlarmType"), ("SFRAP-MIB", "sfrapDLCINum"), ("SFRAP-MIB", "sfrapInterface"))
if mibBuilder.loadTexts: sfrapVbertStarted.setDescription('A Vnip PVC error rate test (VBERT) has been started on this DLCI out this interface to a remote device. The VBERT test data will be statistically multiplexed in with user data, management data, and networking data. The destination peer will echo this test data back to the source producing a full-duplex volume-based timed test.')
sfrapVbertStopped = NotificationType((1, 3, 6, 1, 4, 1, 485, 7) + (0,96)).setObjects(("SFRAP-MIB", "sfrapAlarmType"), ("SFRAP-MIB", "sfrapDLCINum"), ("SFRAP-MIB", "sfrapInterface"))
if mibBuilder.loadTexts: sfrapVbertStopped.setDescription('A Vnip PVC BERT (VBERT) has been stopped on this DLCI on this interface to a remote device.')
sfrapVbertRequestFailed = NotificationType((1, 3, 6, 1, 4, 1, 485, 7) + (0,97)).setObjects(("SFRAP-MIB", "sfrapAlarmType"), ("SFRAP-MIB", "sfrapDLCINum"), ("SFRAP-MIB", "sfrapInterface"))
if mibBuilder.loadTexts: sfrapVbertRequestFailed.setDescription('The request for a PVC BERT (VBERT) on this DLCI on this interface has been rejected.')
sfrapDteSignalControlOnTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 7) + (0,100)).setObjects(("SFRAP-MIB", "sfrapAlarmType"))
if mibBuilder.loadTexts: sfrapDteSignalControlOnTrap.setDescription("Unit's X.21 Control (C) DTE control signal is now active (on). This signal is presented by the external DTE device.")
sfrapDteSignalControlOffTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 7) + (0,101)).setObjects(("SFRAP-MIB", "sfrapAlarmType"))
if mibBuilder.loadTexts: sfrapDteSignalControlOffTrap.setDescription("Unit's X.21 Control (C) DTE control signal is now inactive (off). This signal is presented by the external DTE device.")
sfrapDteSignalIndicateOnTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 7) + (0,102)).setObjects(("SFRAP-MIB", "sfrapAlarmType"))
if mibBuilder.loadTexts: sfrapDteSignalIndicateOnTrap.setDescription("Unit's X.21 Indicate (I) DTE control signal is now active (on). This signal is presented by the external DTE device.")
sfrapDteSignalIndicateOffTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 7) + (0,103)).setObjects(("SFRAP-MIB", "sfrapAlarmType"))
if mibBuilder.loadTexts: sfrapDteSignalIndicateOffTrap.setDescription("Unit's X.21 Indicate (I) DTE control signal is now inactive (off). This signal is presented by the external DTE device.")
sfrapPvcRxUtilizationExceededTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 7) + (0,138)).setObjects(("SFRAP-MIB", "sfrapAlarmType"), ("SFRAP-MIB", "sfrapDLCINum"), ("SFRAP-MIB", "sfrapPercentUtilization"), ("SFRAP-MIB", "sfrapUtilizationThreshold"))
if mibBuilder.loadTexts: sfrapPvcRxUtilizationExceededTrap.setDescription('Percent utilization threshold was exceeded for the defined number of Short Term Intervals in the reception direction on this DLCI. ')
sfrapPvcTxUtilizationExceededTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 7) + (0,139)).setObjects(("SFRAP-MIB", "sfrapAlarmType"), ("SFRAP-MIB", "sfrapDLCINum"), ("SFRAP-MIB", "sfrapPercentUtilization"), ("SFRAP-MIB", "sfrapUtilizationThreshold"))
if mibBuilder.loadTexts: sfrapPvcTxUtilizationExceededTrap.setDescription('Percent utilization threshold was exceeded for the defined number of Short Term Intervals in the transmission direction on this DLCI. ')
sfrapPvcRxUtilizationClearedTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 7) + (0,140)).setObjects(("SFRAP-MIB", "sfrapAlarmType"), ("SFRAP-MIB", "sfrapDLCINum"), ("SFRAP-MIB", "sfrapPercentUtilization"), ("SFRAP-MIB", "sfrapUtilizationThreshold"))
if mibBuilder.loadTexts: sfrapPvcRxUtilizationClearedTrap.setDescription('Percent utilization was below the threshold for the defined number of Short Term Intervals in the reception direction on this DLCI. ')
sfrapPvcTxUtilizationClearedTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 7) + (0,141)).setObjects(("SFRAP-MIB", "sfrapAlarmType"), ("SFRAP-MIB", "sfrapDLCINum"), ("SFRAP-MIB", "sfrapPercentUtilization"), ("SFRAP-MIB", "sfrapUtilizationThreshold"))
if mibBuilder.loadTexts: sfrapPvcTxUtilizationClearedTrap.setDescription('Percent utilization was below the threshold for the defined number of Short Term Intervals in the transmission direction on this DLCI. ')
sfrapConfigInstallSuccess = NotificationType((1, 3, 6, 1, 4, 1, 485, 7) + (0,142)).setObjects(("SFRAP-MIB", "sfrapAlarmType"), ("SFRAP-MIB", "sfrapCfgLockIpAddress"))
if mibBuilder.loadTexts: sfrapConfigInstallSuccess.setDescription('The configuration install process has successfully completed. ')
sfrapTftpRequestedTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 7) + (0,257)).setObjects(("SFRAP-MIB", "sfrapAlarmType"))
if mibBuilder.loadTexts: sfrapTftpRequestedTrap.setDescription("Unit has received a TFTP download request. TFTP is the preferred method for upgrading a unit's software image.")
sfrapTftpTransferringTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 7) + (0,258)).setObjects(("SFRAP-MIB", "sfrapAlarmType"))
if mibBuilder.loadTexts: sfrapTftpTransferringTrap.setDescription('Unit has established a TFTP session, found the file, and begun the transfer. The file must still be qualified as appropriate for this unit.')
sfrapTftpProgrammingTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 7) + (0,259)).setObjects(("SFRAP-MIB", "sfrapAlarmType"))
if mibBuilder.loadTexts: sfrapTftpProgrammingTrap.setDescription('Unit has completed the TFTP transfer of a new software image which will next be programmed into non-volatile flash memory.')
sfrapTftpAbortedTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 7) + (0,260)).setObjects(("SFRAP-MIB", "sfrapAlarmType"))
if mibBuilder.loadTexts: sfrapTftpAbortedTrap.setDescription("Unit's TFTP session was established but the transfer was aborted by user intervention or an unrecoverable TFTP protocol error.")
sfrapTftpSuccessTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 7) + (0,261)).setObjects(("SFRAP-MIB", "sfrapAlarmType"))
if mibBuilder.loadTexts: sfrapTftpSuccessTrap.setDescription("Unit's TFTP download completed successfully. Flash devices will be programmed with a new image. Unit will stop passing data during the programming phase (less than a minute) and, upon completion, will reset and return to full operation using the new image.")
sfrapTftpHostUnreachableTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 7) + (0,262)).setObjects(("SFRAP-MIB", "sfrapAlarmType"))
if mibBuilder.loadTexts: sfrapTftpHostUnreachableTrap.setDescription('Unit could not establish a TFTP session with the designated server. Verify that the correct TFTP ip address, TFTP DLCI and TFTP interface are configured on the unit and also verify the TFTP server confguration.')
sfrapTftpNoFileTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 7) + (0,263)).setObjects(("SFRAP-MIB", "sfrapAlarmType"))
if mibBuilder.loadTexts: sfrapTftpNoFileTrap.setDescription('Unit could not locate the designated file on the TFTP server. Verify the correct TFTP filename is configured on the unit and verify the location of this file on the server (file name may be case sensitive).')
sfrapTftpInvalidFileTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 7) + (0,264)).setObjects(("SFRAP-MIB", "sfrapAlarmType"))
if mibBuilder.loadTexts: sfrapTftpInvalidFileTrap.setDescription('Unit had established a TFTP session and began transfer of the designated file. The unit aborted the transfer after determining that the specified file is not appropriate for this product (failed header verification).')
sfrapTftpCorruptFileTrap = NotificationType((1, 3, 6, 1, 4, 1, 485, 7) + (0,265)).setObjects(("SFRAP-MIB", "sfrapAlarmType"))
if mibBuilder.loadTexts: sfrapTftpCorruptFileTrap.setDescription('Unit transferred the designated file but aborted the operation due to a checksum error within the downloaded s-record file.')
mibBuilder.exportSymbols("SFRAP-MIB", sfrapPerfArpPerDlciRxOther=sfrapPerfArpPerDlciRxOther, sfrapSysFeatureTable=sfrapSysFeatureTable, sfrapDiagVnipEntry=sfrapDiagVnipEntry, sfrapPerfThruputPerIntfRxFrameCnt=sfrapPerfThruputPerIntfRxFrameCnt, sfrapPerfMgmtIpTCPCurrEstab=sfrapPerfMgmtIpTCPCurrEstab, sfrapPerfArpTotalRxInarpRep=sfrapPerfArpTotalRxInarpRep, sfrapStatusDteEntry=sfrapStatusDteEntry, sfrapPerfNetwProtoTotalTxCisco=sfrapPerfNetwProtoTotalTxCisco, sfrapPerfApplicationTotalRxFtp=sfrapPerfApplicationTotalRxFtp, sfrapPerfArpPerDlciRxInarpRep=sfrapPerfArpPerDlciRxInarpRep, sfrapPerfCurrentPerDlciAggregateUtilization=sfrapPerfCurrentPerDlciAggregateUtilization, sfrapSysNumToDteInstalled=sfrapSysNumToDteInstalled, sfrapPerfArpTotalRxArpRep=sfrapPerfArpTotalRxArpRep, sfrapPerfThruputCmdReplaceDlciNewValue=sfrapPerfThruputCmdReplaceDlciNewValue, sfrapDLCINum=sfrapDLCINum, sfrapSysLocation=sfrapSysLocation, sfrapOpModeCutThruDisabledTrap=sfrapOpModeCutThruDisabledTrap, sfrapPerfNetwProtoTotalRxSna=sfrapPerfNetwProtoTotalRxSna, sfrapPerfNetwProtoPerDlciTxIp=sfrapPerfNetwProtoPerDlciTxIp, sfrapPerfMgmtIpICMPInTimeExcds=sfrapPerfMgmtIpICMPInTimeExcds, sfrapPerfIcmpTotalTxTimestpRep=sfrapPerfIcmpTotalTxTimestpRep, sfrapPerfApplicationPerDlciRxCustom4=sfrapPerfApplicationPerDlciRxCustom4, sfrapPerfThruputPerDlciCreateTime=sfrapPerfThruputPerDlciCreateTime, sfrapPerfMgmtIpTCPInSegs=sfrapPerfMgmtIpTCPInSegs, sfrapEventLogAltSeqNum=sfrapEventLogAltSeqNum, sfrapPerfApplicationPerDlciTxHttp=sfrapPerfApplicationPerDlciTxHttp, sfrapVbertStopped=sfrapVbertStopped, sfrapPerfNetwProtoTotalTxArp=sfrapPerfNetwProtoTotalTxArp, sfrapPerfNetworkLongTermCmdClear=sfrapPerfNetworkLongTermCmdClear, sfrapPerfSnaTotalTxAppn=sfrapPerfSnaTotalTxAppn, sfrapLocalToDteLoopbackEnabledTrap=sfrapLocalToDteLoopbackEnabledTrap, sfrapCfgVnipTransitDelayFrequency=sfrapCfgVnipTransitDelayFrequency, sfrapPerfThruput=sfrapPerfThruput, sfrapCfgDteTable=sfrapCfgDteTable, sfrapPerfRoutingTotalRxOspf=sfrapPerfRoutingTotalRxOspf, sfrapVloopRequestFailed=sfrapVloopRequestFailed, sfrapPerfThruputPerDlciRxThruput=sfrapPerfThruputPerDlciRxThruput, sfrapPerfIpTotalTxOther=sfrapPerfIpTotalTxOther, sfrapPerfThruputCmdAvailabilityStsDlciReset=sfrapPerfThruputCmdAvailabilityStsDlciReset, sfrapPerfLmiPerDlciTxFullStatByteCnt=sfrapPerfLmiPerDlciTxFullStatByteCnt, sfrapPerfIpPerDlciRxUdp=sfrapPerfIpPerDlciRxUdp, sfrapVnipTopologyTable=sfrapVnipTopologyTable, sfrapCfgTftpStatus=sfrapCfgTftpStatus, sfrapPerfCirRxPercentUtilizationRange3=sfrapPerfCirRxPercentUtilizationRange3, sfrapPerfIpxTotalRxRip=sfrapPerfIpxTotalRxRip, sfrapPerfArpPerDlciInterval=sfrapPerfArpPerDlciInterval, sfrapPerfIcmpPerDlciTxGmReduct=sfrapPerfIcmpPerDlciTxGmReduct, sfrapCfgFrLmiInactivityTimeout=sfrapCfgFrLmiInactivityTimeout, sfrapPerfIpPerDlciTable=sfrapPerfIpPerDlciTable, sfrapStatusMgmtInterfaceStatus=sfrapStatusMgmtInterfaceStatus, sfrapCfgFrDLCIMgmtDE=sfrapCfgFrDLCIMgmtDE, sfrapCfgFrPerfLTProtocolFilterProtocol=sfrapCfgFrPerfLTProtocolFilterProtocol, sfrapPerfThruputPerDlciRxBecn=sfrapPerfThruputPerDlciRxBecn, sfrapPerfNetwProtoPerDlciTxVnip=sfrapPerfNetwProtoPerDlciTxVnip, sfrapPerfIpTotalTxUdp=sfrapPerfIpTotalTxUdp, sfrapPerfIpTotalRxIcmp=sfrapPerfIpTotalRxIcmp, sfrapStatusDipswitchToDteLpbk=sfrapStatusDipswitchToDteLpbk, sfrapPerfMgmtIpTCPOutSegs=sfrapPerfMgmtIpTCPOutSegs, sfrapPerfIpPerDlciTxTotal=sfrapPerfIpPerDlciTxTotal, sfrapPerfIcmpTotalTxGmReduct=sfrapPerfIcmpTotalTxGmReduct, sfrapPerfArpTotalRxOther=sfrapPerfArpTotalRxOther, sfrapPerfMgmtIpICMPOutDestUnreachs=sfrapPerfMgmtIpICMPOutDestUnreachs, sfrapPerfIpxPerDlciTxTotal=sfrapPerfIpxPerDlciTxTotal, sfrapStatusDteInd=sfrapStatusDteInd, sfrapPerfThruputPerDlciRxDe=sfrapPerfThruputPerDlciRxDe, sfrapPerfLmiTotalTable=sfrapPerfLmiTotalTable, sfrapPerfIcmpTotalRxRedirect=sfrapPerfIcmpTotalRxRedirect, sfrapPerfThruputPerDlciMTTSR=sfrapPerfThruputPerDlciMTTSR, sfrapPerfMgmtIpIPOutNoRt=sfrapPerfMgmtIpIPOutNoRt, sfrapCfgSnmpMgrDlci=sfrapCfgSnmpMgrDlci, sfrap=sfrap, sfrapPerfMgmtIpICMPStatsTable=sfrapPerfMgmtIpICMPStatsTable, sfrapPerfApplicationPerDlciValue=sfrapPerfApplicationPerDlciValue, sfrapPerfArpTotalRxRarpRep=sfrapPerfArpTotalRxRarpRep, sfrapPerfCirTxPercentUtilizationRange7=sfrapPerfCirTxPercentUtilizationRange7, sfrapCfgTftpFilename=sfrapCfgTftpFilename, sfrapPerfLmiPerDlciEntry=sfrapPerfLmiPerDlciEntry, sfrapPerfApplicationPerDlciTxCustom2=sfrapPerfApplicationPerDlciTxCustom2, sfrapPerfApplicationTotalInterval=sfrapPerfApplicationTotalInterval, sfrapPerfLmiPerDlciTxTotalByteCnt=sfrapPerfLmiPerDlciTxTotalByteCnt, sfrapPerfNetworkLongTerm=sfrapPerfNetworkLongTerm, sfrapPerfCirTxPercentUtilizationRange8=sfrapPerfCirTxPercentUtilizationRange8, sfrapCfgFrDLCIValue=sfrapCfgFrDLCIValue, sfrapPerfIcmpTotalTxEchoRep=sfrapPerfIcmpTotalTxEchoRep, sfrapPerfArpTotalTxArpRep=sfrapPerfArpTotalTxArpRep, sfrapPerfCirPercentUtilization=sfrapPerfCirPercentUtilization, sfrapStatus=sfrapStatus, sfrapEventTrapLog=sfrapEventTrapLog, sfrapPerfIpPerDlciTxIcmp=sfrapPerfIpPerDlciTxIcmp, sfrapPerfNetwProtoPerDlciTxIpx=sfrapPerfNetwProtoPerDlciTxIpx, sfrapEventTrapLogTable=sfrapEventTrapLogTable, sfrapPerfIpTotalRxIgrp=sfrapPerfIpTotalRxIgrp, sfrapPerfApplicationPerDlciRxSmtp=sfrapPerfApplicationPerDlciRxSmtp, sfrapPerfMgmtIpTCPPassiveOpens=sfrapPerfMgmtIpTCPPassiveOpens, sfrapPerfApplicationTotalRxSnmpTrap=sfrapPerfApplicationTotalRxSnmpTrap, sfrapPerfThruputPerDlciCIR=sfrapPerfThruputPerDlciCIR, sfrapSysSelDTESupported=sfrapSysSelDTESupported, sfrapSysHighSpeedSupported=sfrapSysHighSpeedSupported, sfrapCfgSecurityTable=sfrapCfgSecurityTable, sfrapPerfIpxPerDlciRxNetbios=sfrapPerfIpxPerDlciRxNetbios, sfrapCfgTDDeleteInterface=sfrapCfgTDDeleteInterface, sfrapPerfIpTotalRxTcp=sfrapPerfIpTotalRxTcp, sfrapPerfIpTotalTable=sfrapPerfIpTotalTable, sfrapLocalToDteLoopbackFailedTrap=sfrapLocalToDteLoopbackFailedTrap, sfrapPerfNetwProtoTotalEntry=sfrapPerfNetwProtoTotalEntry, sfrapPerfIcmpTotalRxGmReport=sfrapPerfIcmpTotalRxGmReport, sfrapPerfIcmpTotalRxAddrMaskReq=sfrapPerfIcmpTotalRxAddrMaskReq, sfrapPerfSnaTotalInterval=sfrapPerfSnaTotalInterval, sfrapEventLogAltTable=sfrapEventLogAltTable, sfrapInterface=sfrapInterface, sfrapPerfLmiPerDlciInterval=sfrapPerfLmiPerDlciInterval, sfrapPerfNetwProtoPerDlciValue=sfrapPerfNetwProtoPerDlciValue, sfrapPerfThruputPerDlciIndex=sfrapPerfThruputPerDlciIndex, sfrapPerfIpPerDlciRxTcp=sfrapPerfIpPerDlciRxTcp, sfrapPerfIcmpTotalRxDestUnr=sfrapPerfIcmpTotalRxDestUnr, sfrapPerfSnaTotalTxPeriph=sfrapPerfSnaTotalTxPeriph, sfrapIpAddress=sfrapIpAddress, sfrapCfgFrPerfDlciNamesEntry=sfrapCfgFrPerfDlciNamesEntry, sfrapPerfApplicationTotalTxCustom1=sfrapPerfApplicationTotalTxCustom1, sfrapPerfIpxPerDlciRxRip=sfrapPerfIpxPerDlciRxRip, sfrapPerfCurrentUnitUtilization=sfrapPerfCurrentUnitUtilization, sfrapDiagDteTimeRemaining=sfrapDiagDteTimeRemaining, sfrapEventTrapLogVarBind3=sfrapEventTrapLogVarBind3, sfrapPerfNetwProtoPerDlciRxCisco=sfrapPerfNetwProtoPerDlciRxCisco, sfrapPerfIpPerDlciTxOther=sfrapPerfIpPerDlciTxOther, sfrapPerfIpxPerDlciTxSpx=sfrapPerfIpxPerDlciTxSpx, sfrapPerfThruputCmdClearAllStats=sfrapPerfThruputCmdClearAllStats, sfrapPerfNetwProtoPerDlciRxIpx=sfrapPerfNetwProtoPerDlciRxIpx, sfrapPerfApplicationPerDlciRxTftp=sfrapPerfApplicationPerDlciRxTftp, sfrapPerfIcmpPerDlciRxTotal=sfrapPerfIcmpPerDlciRxTotal, sfrapCfgFrAddrResInarpTimer=sfrapCfgFrAddrResInarpTimer, sfrapCfgTransitDelayRcvSummaryCancel=sfrapCfgTransitDelayRcvSummaryCancel, sfrapPerfNetwProtoPerDlciTable=sfrapPerfNetwProtoPerDlciTable, sfrapCfgFrPerfTimers=sfrapCfgFrPerfTimers, sfrapVnipTopologyDlci=sfrapVnipTopologyDlci, sfrapVnipTopoVBertTransitDelayAvg=sfrapVnipTopoVBertTransitDelayAvg, sfrapPerfNetwProtoPerDlciRxVnip=sfrapPerfNetwProtoPerDlciRxVnip, sfrapPerfMgmtIpIPInHdrErr=sfrapPerfMgmtIpIPInHdrErr, sfrapPerfArpTotalTxRarpReq=sfrapPerfArpTotalTxRarpReq, sfrapPerfRoutingTotalTxNetbios=sfrapPerfRoutingTotalTxNetbios, sfrapCfgSetCommunityString=sfrapCfgSetCommunityString, sfrapStatusMgmtTable=sfrapStatusMgmtTable, sfrapPerfIcmpTotalRxGmQuery=sfrapPerfIcmpTotalRxGmQuery, sfrapSysNumDlcisSupported=sfrapSysNumDlcisSupported, sfrapEventTrapLogEntry=sfrapEventTrapLogEntry, sfrapPerfArpPerDlciRxArpReq=sfrapPerfArpPerDlciRxArpReq, sfrapPerfThruputCmdReplaceDlciEntry=sfrapPerfThruputCmdReplaceDlciEntry, sfrapDLCITDThresholdTrap=sfrapDLCITDThresholdTrap, sfrapPerfIpPerDlciValue=sfrapPerfIpPerDlciValue, sfrapPerfIcmpPerDlciTxParamProb=sfrapPerfIcmpPerDlciTxParamProb, sfrapPerfApplicationTotalRxCustom1=sfrapPerfApplicationTotalRxCustom1, sfrapPerfIpTotalInterval=sfrapPerfIpTotalInterval, sfrapPerfMgmtIpIPOutRqst=sfrapPerfMgmtIpIPOutRqst, sfrapVnipTopoVBertTxDEClrFrames=sfrapVnipTopoVBertTxDEClrFrames, sfrapPerfIpxPerDlciTxNcp=sfrapPerfIpxPerDlciTxNcp, sfrapPerfMgmtIpUDPNoPorts=sfrapPerfMgmtIpUDPNoPorts, sfrapPerfApplicationPerDlciTxCustom1=sfrapPerfApplicationPerDlciTxCustom1, sfrapPerfIcmpPerDlciTxRedirect=sfrapPerfIcmpPerDlciTxRedirect, sfrapLmiSourcing=sfrapLmiSourcing, sfrapPerfThruputPerDlciUptime=sfrapPerfThruputPerDlciUptime, sfrapSysNumUserProtocols=sfrapSysNumUserProtocols, sfrapPerfArpTotalTxOther=sfrapPerfArpTotalTxOther, sfrapPerfCurrentPerDlciUtilizationDlciValue=sfrapPerfCurrentPerDlciUtilizationDlciValue, sfrapLocalDte2LoopbackEnabledTrap=sfrapLocalDte2LoopbackEnabledTrap, sfrapCfgTransitDelayTable=sfrapCfgTransitDelayTable, sfrapPerfIpPerDlciRxIcmp=sfrapPerfIpPerDlciRxIcmp, sfrapDiagVBERT=sfrapDiagVBERT, sfrapLmiSeqNumMismatchToDteTrap=sfrapLmiSeqNumMismatchToDteTrap, sfrapPerfApplicationPerDlciTxCustom4=sfrapPerfApplicationPerDlciTxCustom4, sfrapPerfSnaTotalTxOther=sfrapPerfSnaTotalTxOther, sfrapPerfCirRxPercentUtilizationRange6=sfrapPerfCirRxPercentUtilizationRange6, sfrapStatusDteDcd=sfrapStatusDteDcd, sfrapPerfIpxPerDlciRxNcp=sfrapPerfIpxPerDlciRxNcp, sfrapPerfIpxTotalRxSpx=sfrapPerfIpxTotalRxSpx, sfrapStatusMgmtChannel=sfrapStatusMgmtChannel, sfrapCfgTransitDelayInterface=sfrapCfgTransitDelayInterface, sfrapPerfMgmtIp=sfrapPerfMgmtIp, sfrapCfgFrPerfTimersSTInterval=sfrapCfgFrPerfTimersSTInterval, sfrapPerfIcmpTotalRxSrcQuench=sfrapPerfIcmpTotalRxSrcQuench, sfrapPerfSnaPerDlciTxAppn=sfrapPerfSnaPerDlciTxAppn, sfrapPerfCurrentPerDlciRxUtilization=sfrapPerfCurrentPerDlciRxUtilization, sfrapPerfIpxTotalRxNetbios=sfrapPerfIpxTotalRxNetbios, sfrapStatusLedDsrLED=sfrapStatusLedDsrLED, sfrapPerfMgmtIpIPInAddrErr=sfrapPerfMgmtIpIPInAddrErr, sfrapPerfThruputPerIntfRxCrcErrCnt=sfrapPerfThruputPerIntfRxCrcErrCnt, sfrapStatusDipswitchToDceLpbk=sfrapStatusDipswitchToDceLpbk, sfrapPerfMgmtIpIFInErrors=sfrapPerfMgmtIpIFInErrors, sfrapPerfFRStatsCollectionStatus=sfrapPerfFRStatsCollectionStatus, sfrapPerfMgmtIpTCPAttemptFails=sfrapPerfMgmtIpTCPAttemptFails, sfrapDiagDteEntry=sfrapDiagDteEntry, sfrapTrapMutingInactive=sfrapTrapMutingInactive, sfrapPerfNetwProtoPerDlciRxIp=sfrapPerfNetwProtoPerDlciRxIp, sfrapPerfMgmtIpICMPInParmProbs=sfrapPerfMgmtIpICMPInParmProbs, sfrapPerfApplicationPerDlciRxHttp=sfrapPerfApplicationPerDlciRxHttp, sfrapSysContact=sfrapSysContact, sfrapPerfIcmpPerDlciTxTimeExcd=sfrapPerfIcmpPerDlciTxTimeExcd, sfrapLocalDte2LoopbackDisabledTrap=sfrapLocalDte2LoopbackDisabledTrap, sfrapPerfCurrentPerDlciUtilizationEntry=sfrapPerfCurrentPerDlciUtilizationEntry, sfrapStatusDteCtrl=sfrapStatusDteCtrl, sfrapPerfIcmpPerDlciTxTimestpRep=sfrapPerfIcmpPerDlciTxTimestpRep, sfrapPerfApplicationPerDlciRxSnmp=sfrapPerfApplicationPerDlciRxSnmp, sfrapCfgSnmpMgrEntry=sfrapCfgSnmpMgrEntry, sfrapCfgFrPerfLTDlciFilterTableClear=sfrapCfgFrPerfLTDlciFilterTableClear, sfrapPerfIcmpTotalRxEchoReq=sfrapPerfIcmpTotalRxEchoReq, sfrapCfgSnmpFrTrap=sfrapCfgSnmpFrTrap, sfrapPerfIcmpTotalRxPktTooBig=sfrapPerfIcmpTotalRxPktTooBig, sfrapCfgFrPerfUserProtocolsEntry=sfrapCfgFrPerfUserProtocolsEntry, sfrapDiagnostics=sfrapDiagnostics, sfrapPerfIcmpTotalInterval=sfrapPerfIcmpTotalInterval, sfrapPerfNetwProtoPerDlciRxOther=sfrapPerfNetwProtoPerDlciRxOther, sfrapPerfArpPerDlciValue=sfrapPerfArpPerDlciValue, sfrapPerfSnaTotalTxNetbios=sfrapPerfSnaTotalTxNetbios, sfrapPerfIcmpPerDlciTxTotal=sfrapPerfIcmpPerDlciTxTotal, sfrapEventTrapLogVarBind2=sfrapEventTrapLogVarBind2, sfrapPerfIpxPerDlciRxOther=sfrapPerfIpxPerDlciRxOther, sfrapPerfMgmtIpTCPActiveOpens=sfrapPerfMgmtIpTCPActiveOpens, sfrapPerfNetwProtoPerDlciRxAnnexG=sfrapPerfNetwProtoPerDlciRxAnnexG, sfrapPerfArpPerDlciRxRarpRep=sfrapPerfArpPerDlciRxRarpRep, sfrapPerfMgmtIpIFStatsTable=sfrapPerfMgmtIpIFStatsTable, sfrapLocalToDteLoopbackDisabledTrap=sfrapLocalToDteLoopbackDisabledTrap, sfrapVnipTopoVBertPerUtilEIR=sfrapVnipTopoVBertPerUtilEIR, sfrapStatusDteRts=sfrapStatusDteRts, sfrapVbertStarted=sfrapVbertStarted, sfrapPerfLmiTotalDlciValue=sfrapPerfLmiTotalDlciValue, sfrapStatusDipswitchIntfMode2=sfrapStatusDipswitchIntfMode2, sfrapPerfApplicationTotalTxCustom4=sfrapPerfApplicationTotalTxCustom4, sfrapCfgFrAddrResDlcis=sfrapCfgFrAddrResDlcis, sfrapPerfSnaPerDlciRxOther=sfrapPerfSnaPerDlciRxOther, sfrapSysSerialNo=sfrapSysSerialNo, sfrapStatusDteSendtiming=sfrapStatusDteSendtiming, sfrapDteSignalRtsOnTrap=sfrapDteSignalRtsOnTrap, sfrapPerfSnaTotalRxNetbios=sfrapPerfSnaTotalRxNetbios, sfrapTftpSuccessTrap=sfrapTftpSuccessTrap, sfrapCfgFrPerfDlciNamesCirValue=sfrapCfgFrPerfDlciNamesCirValue, sfrapPerfArpTotalTxInarpReq=sfrapPerfArpTotalTxInarpReq, sfrapTftpCorruptFileTrap=sfrapTftpCorruptFileTrap, sfrapPerfIpTotalRxUdp=sfrapPerfIpTotalRxUdp, sfrapPerfApplicationPerDlciRxCustom2=sfrapPerfApplicationPerDlciRxCustom2, sfrapStatusDipswitchTable=sfrapStatusDipswitchTable, sfrapPerfNetworkShortTerm=sfrapPerfNetworkShortTerm, sfrapPerfMgmtIpICMPOutEchoReps=sfrapPerfMgmtIpICMPOutEchoReps, sfrapPerfCirRxPercentUtilizationRange5=sfrapPerfCirRxPercentUtilizationRange5, sfrapPerfMgmtIpIPInDlvrs=sfrapPerfMgmtIpIPInDlvrs, sfrapPerfMgmtIpICMPOutParmProbs=sfrapPerfMgmtIpICMPOutParmProbs, sfrapPerfMgmtIpIFOutOctets=sfrapPerfMgmtIpIFOutOctets, sfrapDiagUnitCutThru=sfrapDiagUnitCutThru, sfrapPerfApplicationPerDlciTxSnmp=sfrapPerfApplicationPerDlciTxSnmp, sfrapPerfSnaTotalRxPeriph=sfrapPerfSnaTotalRxPeriph, sfrapLmiSeqNumMismatchToDceTrap=sfrapLmiSeqNumMismatchToDceTrap, sfrapCfgCliPassword=sfrapCfgCliPassword, sfrapStatusDteCts=sfrapStatusDteCts, sfrapPerfMgmtIpTCPStatsTable=sfrapPerfMgmtIpTCPStatsTable, sfrapPerfApplicationPerDlciTxFtp=sfrapPerfApplicationPerDlciTxFtp, sfrapPerfArpTotalTable=sfrapPerfArpTotalTable)
mibBuilder.exportSymbols("SFRAP-MIB", sfrapTftpNoFileTrap=sfrapTftpNoFileTrap, sfrapSysResetNode=sfrapSysResetNode, sfrapCfgSnmpUtilTrapEnable=sfrapCfgSnmpUtilTrapEnable, sfrapPerfIcmpTotalTable=sfrapPerfIcmpTotalTable, sfrapPerfLmiPerDlciTxLivoEnqByteCnt=sfrapPerfLmiPerDlciTxLivoEnqByteCnt, sfrapPerfMgmtIpUDPStatsTable=sfrapPerfMgmtIpUDPStatsTable, sfrapEventTrapLogGenericEvent=sfrapEventTrapLogGenericEvent, sfrapCfgFrPerfLTProtocolFilterTableClear=sfrapCfgFrPerfLTProtocolFilterTableClear, sfrapPerfRoutingTotalTxOspf=sfrapPerfRoutingTotalTxOspf, sfrapPerfArpPerDlciTxOther=sfrapPerfArpPerDlciTxOther, sfrapCfgVnipTable=sfrapCfgVnipTable, sfrapPerfIcmpTotalTxRedirect=sfrapPerfIcmpTotalTxRedirect, sfrapStatusLedFrmActLED=sfrapStatusLedFrmActLED, sfrapPerfIpxTotalTxSpx=sfrapPerfIpxTotalTxSpx, sfrapSysNumSnmpMgrs=sfrapSysNumSnmpMgrs, sfrapPerfMgmtIpICMPInEchoReps=sfrapPerfMgmtIpICMPInEchoReps, sfrapPerfIpxTotalTxNetbios=sfrapPerfIpxTotalTxNetbios, sfrapSysSLIPSupported=sfrapSysSLIPSupported, sfrapPerfCurrentPerDlciUtilizationTable=sfrapPerfCurrentPerDlciUtilizationTable, sfrapPerfIpxTotalEntry=sfrapPerfIpxTotalEntry, sfrapCfgAppFormat=sfrapCfgAppFormat, sfrapCfgFrLmiType=sfrapCfgFrLmiType, sfrapPerfArpPerDlciEntry=sfrapPerfArpPerDlciEntry, sfrapDteSignalDtrOnTrap=sfrapDteSignalDtrOnTrap, sfrapCfgVnipTxTimer=sfrapCfgVnipTxTimer, sfrapPerfIpPerDlciInterval=sfrapPerfIpPerDlciInterval, sfrapSysExtTimSupported=sfrapSysExtTimSupported, sfrapPerfNetwProtoTotalTxAnnexG=sfrapPerfNetwProtoTotalTxAnnexG, sfrapPerfLmiTotalInterval=sfrapPerfLmiTotalInterval, sfrapStatusLedRtsLED=sfrapStatusLedRtsLED, sfrapPerfSnaTotalEntry=sfrapPerfSnaTotalEntry, sfrapPerfCirTxPercentUtilizationRange3=sfrapPerfCirTxPercentUtilizationRange3, sfrapStatusLedToDTERxLED=sfrapStatusLedToDTERxLED, sfrapPerfNetwProtoTotalInterval=sfrapPerfNetwProtoTotalInterval, sfrapCfgTransitDelayTableClear=sfrapCfgTransitDelayTableClear, sfrapPerfIcmpPerDlciRxDestUnr=sfrapPerfIcmpPerDlciRxDestUnr, sfrapPerfApplicationTotalEntry=sfrapPerfApplicationTotalEntry, sfrapSysBRISupported=sfrapSysBRISupported, sfrapPerfCirTxPercentUtilizationRange1=sfrapPerfCirTxPercentUtilizationRange1, sfrapCfgTransitDelayEntry=sfrapCfgTransitDelayEntry, sfrapPerfSnaTotalRxSubarea=sfrapPerfSnaTotalRxSubarea, sfrapTrapMutingActive=sfrapTrapMutingActive, sfrapPerfIcmpTotalRxTotal=sfrapPerfIcmpTotalRxTotal, sfrapPerfIpxPerDlciTxSap=sfrapPerfIpxPerDlciTxSap, sfrapPerfLmiPerDlciRxFullEnqByteCnt=sfrapPerfLmiPerDlciRxFullEnqByteCnt, sfrapPerfLmiTotalRxTotalByteCnt=sfrapPerfLmiTotalRxTotalByteCnt, sfrapCfgTDDeleteDlciValue=sfrapCfgTDDeleteDlciValue, sfrapCfgCommStopBits=sfrapCfgCommStopBits, sfrapPerfIcmpPerDlciTxAddrMaskReq=sfrapPerfIcmpPerDlciTxAddrMaskReq, sfrapPerfApplicationPerDlciTxTelnet=sfrapPerfApplicationPerDlciTxTelnet, sfrapPerfIcmpPerDlciRxGmReduct=sfrapPerfIcmpPerDlciRxGmReduct, sfrapSysAmtMemoryInstalled=sfrapSysAmtMemoryInstalled, sfrapSysNumDlciNames=sfrapSysNumDlciNames, sfrapCfgFrPerf=sfrapCfgFrPerf, sfrapPerfIcmpPerDlciTxSrcQuench=sfrapPerfIcmpPerDlciTxSrcQuench, sfrapCfgFrPerfUserProtocolsIndex=sfrapCfgFrPerfUserProtocolsIndex, sfrapPerfIpxPerDlciRxTotal=sfrapPerfIpxPerDlciRxTotal, sfrapStatusDipswitchUnused=sfrapStatusDipswitchUnused, sfrapStatusLedOpStatusLED=sfrapStatusLedOpStatusLED, sfrapSysPPPSupported=sfrapSysPPPSupported, sfrapStatusDipswitchIntfMode1=sfrapStatusDipswitchIntfMode1, sfrapPerfThruputPerDlciTxThruput=sfrapPerfThruputPerDlciTxThruput, sfrapPerfThruputPerIntfRxByteCnt=sfrapPerfThruputPerIntfRxByteCnt, sfrapPerfThruputPerDlciDowntime=sfrapPerfThruputPerDlciDowntime, sfrapPerfApplicationTotalRxSmtp=sfrapPerfApplicationTotalRxSmtp, sfrapPerfNetworkLongTermCommands=sfrapPerfNetworkLongTermCommands, sfrapCfgLock=sfrapCfgLock, sfrapPerfNetwProtoTotalRxAnnexG=sfrapPerfNetwProtoTotalRxAnnexG, sfrapDiagVnipInterface=sfrapDiagVnipInterface, sfrapStatusLedToDTETxLED=sfrapStatusLedToDTETxLED, sfrapPerfMgmtIpUDPOutDatagrams=sfrapPerfMgmtIpUDPOutDatagrams, sfrapPerfIcmpTotalTxGmReport=sfrapPerfIcmpTotalTxGmReport, sfrapPerfRoutingPerDlciTxNetbios=sfrapPerfRoutingPerDlciTxNetbios, sfrapPerfNetwProtoPerDlciTxCisco=sfrapPerfNetwProtoPerDlciTxCisco, sfrapPerfLmiPerDlciTxFullEnqByteCnt=sfrapPerfLmiPerDlciTxFullEnqByteCnt, sfrapTftpRequestedTrap=sfrapTftpRequestedTrap, sfrapCfgVnipInitTimer=sfrapCfgVnipInitTimer, sfrapCfgFrPerfDlciUtilDuration=sfrapCfgFrPerfDlciUtilDuration, sfrapPerfApplicationTotalTxFtp=sfrapPerfApplicationTotalTxFtp, sfrapPerfCirPercentUtilizationInterval=sfrapPerfCirPercentUtilizationInterval, sfrapPerfThruputCmdReplaceDlciTable=sfrapPerfThruputCmdReplaceDlciTable, sfrapPerfApplicationTotalTxCustom3=sfrapPerfApplicationTotalTxCustom3, sfrapPerfIcmpPerDlciTxGmReport=sfrapPerfIcmpPerDlciTxGmReport, sfrapPerfNetwProtoPerDlciTxAnnexG=sfrapPerfNetwProtoPerDlciTxAnnexG, sfrapCfgTftpIpAddress=sfrapCfgTftpIpAddress, sfrapPerfApplicationTotalRxTelnet=sfrapPerfApplicationTotalRxTelnet, sfrapPerfMgmtIpICMPOutErrors=sfrapPerfMgmtIpICMPOutErrors, sfrapPerfNetwProtoPerDlciTxTotal=sfrapPerfNetwProtoPerDlciTxTotal, sfrapPerfIpPerDlciRxOther=sfrapPerfIpPerDlciRxOther, sfrapPerfIcmpPerDlciRxEchoRep=sfrapPerfIcmpPerDlciRxEchoRep, sfrapPerfIpxPerDlciRxSap=sfrapPerfIpxPerDlciRxSap, sfrapPerfIcmpPerDlciTxDestUnr=sfrapPerfIcmpPerDlciTxDestUnr, sfrapCfgTftpInitiate=sfrapCfgTftpInitiate, sfrapPerfNetwProtoTotalTxTotal=sfrapPerfNetwProtoTotalTxTotal, sfrapCfgFrLmiKeepaliveTimeout=sfrapCfgFrLmiKeepaliveTimeout, sfrapPerfThruputCmdAllStsDlciReset=sfrapPerfThruputCmdAllStsDlciReset, sfrapPerfNetwLongTermTable=sfrapPerfNetwLongTermTable, sfrapCfgLockIpAddress=sfrapCfgLockIpAddress, sfrapVloopUpViaRemote=sfrapVloopUpViaRemote, sfrapPerfThruputPerDlciTxDe=sfrapPerfThruputPerDlciTxDe, sfrapPerfCirRxPercentUtilizationRange4=sfrapPerfCirRxPercentUtilizationRange4, sfrapEventLogClear=sfrapEventLogClear, sfrapPerfIcmpTotalTxTimeExcd=sfrapPerfIcmpTotalTxTimeExcd, sfrapCfgMgmtTable=sfrapCfgMgmtTable, sfrapSysPrompt=sfrapSysPrompt, sfrapPerfApplicationTotalTxSnmpTrap=sfrapPerfApplicationTotalTxSnmpTrap, sfrapPerfNetwProtoPerDlciRxArp=sfrapPerfNetwProtoPerDlciRxArp, sfrapPerfNetwProtoPerDlciTxOther=sfrapPerfNetwProtoPerDlciTxOther, sfrapVnipTopoVBertRxDESetFrames=sfrapVnipTopoVBertRxDESetFrames, sfrapPerfIpxTotalTxNcp=sfrapPerfIpxTotalTxNcp, sfrapCfgCommMode=sfrapCfgCommMode, sfrapPerfIcmpPerDlciRxGmReport=sfrapPerfIcmpPerDlciRxGmReport, sfrapPerfMgmtIpICMPOutRedirects=sfrapPerfMgmtIpICMPOutRedirects, sfrapPerfRoutingPerDlciInterval=sfrapPerfRoutingPerDlciInterval, sfrapPerfIcmpTotalRxAddrMaskRep=sfrapPerfIcmpTotalRxAddrMaskRep, sfrapPerfIpxPerDlciEntry=sfrapPerfIpxPerDlciEntry, sfrapOpModeCutThruEnabledTrap=sfrapOpModeCutThruEnabledTrap, sfrapPerfRoutingPerDlciEntry=sfrapPerfRoutingPerDlciEntry, sfrapSysHardRev=sfrapSysHardRev, sfrapPerfThruputPerDlciEntry=sfrapPerfThruputPerDlciEntry, sfrapPerfArpTotalRxInarpReq=sfrapPerfArpTotalRxInarpReq, sfrapLmiSourcingChangeNetToDceTrap=sfrapLmiSourcingChangeNetToDceTrap, sfrapVBertClear=sfrapVBertClear, sfrapStatusClockRate=sfrapStatusClockRate, sfrapPerfSnaPerDlciTxSubarea=sfrapPerfSnaPerDlciTxSubarea, sfrapDteSignalRtsOffTrap=sfrapDteSignalRtsOffTrap, sfrapCfgIpTelnetAutoLogOut=sfrapCfgIpTelnetAutoLogOut, sfrapSysLTFNumDlcis=sfrapSysLTFNumDlcis, sfrapPerfIpxTotalTxTotal=sfrapPerfIpxTotalTxTotal, sfrapCfgFrAddrResMode=sfrapCfgFrAddrResMode, sfrapPercentUtilization=sfrapPercentUtilization, sfrapPerfApplicationTotalRxCustom4=sfrapPerfApplicationTotalRxCustom4, sfrapDteSignalIndicateOffTrap=sfrapDteSignalIndicateOffTrap, sfrapStatusMgmtDefaultDLCINo=sfrapStatusMgmtDefaultDLCINo, sfrapCfgAppPerfBuffLimit=sfrapCfgAppPerfBuffLimit, sfrapPerfNetwProtoTotalRxTotal=sfrapPerfNetwProtoTotalRxTotal, sfrapPerfNetwProtoTotalRxCisco=sfrapPerfNetwProtoTotalRxCisco, sfrapPerfArpPerDlciTxRarpReq=sfrapPerfArpPerDlciTxRarpReq, sfrapPerfIpxPerDlciValue=sfrapPerfIpxPerDlciValue, sfrapPerfArpTotalRxTotal=sfrapPerfArpTotalRxTotal, sfrapPerfNetwLongTermValue=sfrapPerfNetwLongTermValue, sfrapPerfIcmpPerDlciRxTimestpRep=sfrapPerfIcmpPerDlciRxTimestpRep, sfrapPerfNetwLongTermProtocol=sfrapPerfNetwLongTermProtocol, sfrapPerfIpxTotalInterval=sfrapPerfIpxTotalInterval, sfrapPerfNetwProtoTotalTxIpx=sfrapPerfNetwProtoTotalTxIpx, enterprises=enterprises, sfrapCfgFrPerfDlciNamesUtilThreshold=sfrapCfgFrPerfDlciNamesUtilThreshold, sfrapPerfThruputPerDlciRxFecn=sfrapPerfThruputPerDlciRxFecn, sfrapCfgFrTable=sfrapCfgFrTable, sfrapPerfNetwLongTermAltEntry=sfrapPerfNetwLongTermAltEntry, sfrapCfgFrPerfLTDlciFilterIndex=sfrapCfgFrPerfLTDlciFilterIndex, sfrapPerfIcmpTotalTxPktTooBig=sfrapPerfIcmpTotalTxPktTooBig, sfrapEventLogAltArray=sfrapEventLogAltArray, sfrapVnipTopologyIpAddr=sfrapVnipTopologyIpAddr, sfrapCfgCommParity=sfrapCfgCommParity, sfrapCfgAppType=sfrapCfgAppType, sfrapPerfIpxTotalTxRip=sfrapPerfIpxTotalTxRip, sfrapVnipTopologyIndex=sfrapVnipTopologyIndex, sfrapCfgSnmpMgrInterface=sfrapCfgSnmpMgrInterface, sfrapCfgDteTxClockMode=sfrapCfgDteTxClockMode, sfrapPerfArpPerDlciTxArpRep=sfrapPerfArpPerDlciTxArpRep, sfrapStatusDteTermtiming=sfrapStatusDteTermtiming, sfrapPerfCurrentDteUtilization=sfrapPerfCurrentDteUtilization, sfrapPerfThruputCmdAvailabilityStsDlciResetAll=sfrapPerfThruputCmdAvailabilityStsDlciResetAll, sfrapNonIncrLmiSeqNumToDteTrap=sfrapNonIncrLmiSeqNumToDteTrap, sfrapDiagVBERTSize=sfrapDiagVBERTSize, sfrapLocalDte2LoopbackFailedTrap=sfrapLocalDte2LoopbackFailedTrap, sfrapDiagUnitTable=sfrapDiagUnitTable, sfrapPerfThruputCmdCountsStsDlciResetAll=sfrapPerfThruputCmdCountsStsDlciResetAll, sfrapPerfIcmpPerDlciTxEchoReq=sfrapPerfIcmpPerDlciTxEchoReq, sfrapPerfApplicationPerDlciRxCustom3=sfrapPerfApplicationPerDlciRxCustom3, sfrapPerfSnaPerDlciRxTotal=sfrapPerfSnaPerDlciRxTotal, sfrapCfgSnmpTable=sfrapCfgSnmpTable, sfrapVnipTopoVBertRxDEClrFrames=sfrapVnipTopoVBertRxDEClrFrames, sfrapPerfThruputPerDlciRxUtilizationStatus=sfrapPerfThruputPerDlciRxUtilizationStatus, sfrapPerfLmiPerDlciTxOtherByteCnt=sfrapPerfLmiPerDlciTxOtherByteCnt, sfrapPerfThruputPerDlciEIR=sfrapPerfThruputPerDlciEIR, sfrapPerfLmiPerDlciRxTotalByteCnt=sfrapPerfLmiPerDlciRxTotalByteCnt, sfrapEventTrapLogTimeStamp=sfrapEventTrapLogTimeStamp, sfrapPerfNetwProtoTotalRxArp=sfrapPerfNetwProtoTotalRxArp, sfrapPerfCirTxPercentUtilizationRange2=sfrapPerfCirTxPercentUtilizationRange2, sfrapCfgTransitDelayThreshold=sfrapCfgTransitDelayThreshold, sfrapDteSignalIndicateOnTrap=sfrapDteSignalIndicateOnTrap, sfrapPerfThruputPerIntfEntry=sfrapPerfThruputPerIntfEntry, sfrapPerfNetwLongTermDlci=sfrapPerfNetwLongTermDlci, sfrapPerfApplicationTotalTxHttp=sfrapPerfApplicationTotalTxHttp, sfrapPerfArpPerDlciRxTotal=sfrapPerfArpPerDlciRxTotal, sfrapPerfSnaPerDlciTxTotal=sfrapPerfSnaPerDlciTxTotal, sfrapPerfCurrentPerDlciTxUtilization=sfrapPerfCurrentPerDlciTxUtilization, sfrapPerfArpTotalTxArpReq=sfrapPerfArpTotalTxArpReq, sfrapPvcTxUtilizationClearedTrap=sfrapPvcTxUtilizationClearedTrap, sfrapCfgCommTable=sfrapCfgCommTable, sfrapPerfThruputPerDlciCirType=sfrapPerfThruputPerDlciCirType, sfrapPerfIpxTotalRxOther=sfrapPerfIpxTotalRxOther, sfrapPerfArpTotalEntry=sfrapPerfArpTotalEntry, sfrapVloopUp=sfrapVloopUp, sfrapPerfLmiTotalRxFullEnqByteCnt=sfrapPerfLmiTotalRxFullEnqByteCnt, sfrapPerfApplicationPerDlciRxTelnet=sfrapPerfApplicationPerDlciRxTelnet, sfrapPerfCirPercentUtilizationTable=sfrapPerfCirPercentUtilizationTable, sfrapPerfRoutingTotalTable=sfrapPerfRoutingTotalTable, sfrapPerfNetwProtoTotalTable=sfrapPerfNetwProtoTotalTable, sfrapLowSpeedExceededTrap=sfrapLowSpeedExceededTrap, sfrapStatusToDteRxClockMode=sfrapStatusToDteRxClockMode, sfrapPerfApplicationTotalRxHttp=sfrapPerfApplicationTotalRxHttp, sfrapCfgAppCutthruTimeout=sfrapCfgAppCutthruTimeout, sfrapPerfSnaPerDlciTable=sfrapPerfSnaPerDlciTable, sfrapStatusLmiAutosense=sfrapStatusLmiAutosense, sfrapVloopDown=sfrapVloopDown, sfrapPerfArpPerDlciTxArpReq=sfrapPerfArpPerDlciTxArpReq, sfrapPerfApplicationPerDlciInterval=sfrapPerfApplicationPerDlciInterval, sfrapCfgFrPerfUserProtocolsPortNum=sfrapCfgFrPerfUserProtocolsPortNum, sfrapCfgIpMyIP=sfrapCfgIpMyIP, sfrapPerformance=sfrapPerformance, sfrapCfgFrPerfDlciDefaultUtilThreshold=sfrapCfgFrPerfDlciDefaultUtilThreshold, sfrapPerfMgmtIpIPInDscrd=sfrapPerfMgmtIpIPInDscrd, sfrapSysNumToDceInstalled=sfrapSysNumToDceInstalled, sfrapStatusLedToDCETxLED=sfrapStatusLedToDCETxLED, sfrapVnipTopoVLOOPStatus=sfrapVnipTopoVLOOPStatus, sfrapCfgAppTxtiming=sfrapCfgAppTxtiming, sfrapPerfArpTotalTxInarpRep=sfrapPerfArpTotalTxInarpRep, sfrapPerfCirRxPercentUtilizationRange7=sfrapPerfCirRxPercentUtilizationRange7, sfrapDiagVBERTTestPeriod=sfrapDiagVBERTTestPeriod, sfrapCfgIpMaxMTU=sfrapCfgIpMaxMTU, sfrapPerfRoutingPerDlciTable=sfrapPerfRoutingPerDlciTable, sfrapPerfSnaPerDlciRxPeriph=sfrapPerfSnaPerDlciRxPeriph, sfrapPerfArpPerDlciTxInarpRep=sfrapPerfArpPerDlciTxInarpRep, sfrapPerfArpTotalRxArpReq=sfrapPerfArpTotalRxArpReq, sfrapCfgTDDeleteTable=sfrapCfgTDDeleteTable, sfrapCfgIpPeerIP=sfrapCfgIpPeerIP, sfrapCfgFrPerfTimersLTInterval=sfrapCfgFrPerfTimersLTInterval, sfrapCfgFrPerfLTProtocolFilterTable=sfrapCfgFrPerfLTProtocolFilterTable, sfrapSysNumMaintInstalled=sfrapSysNumMaintInstalled, sfrapVnipTopoVBertTxDESetFrames=sfrapVnipTopoVBertTxDESetFrames, sfrapPerfThruputPerDlciChangeTime=sfrapPerfThruputPerDlciChangeTime, sfrapPerfIpxPerDlciTxNetbios=sfrapPerfIpxPerDlciTxNetbios, sfrapPerfNetwLongTermEntry=sfrapPerfNetwLongTermEntry, sfrapPerfMgmtIpIPInRcv=sfrapPerfMgmtIpIPInRcv, sfrapPerfIpPerDlciRxTotal=sfrapPerfIpPerDlciRxTotal, sfrapPerfThruputPerDlciTxFrame=sfrapPerfThruputPerDlciTxFrame, sfrapPerfSnaTotalTable=sfrapPerfSnaTotalTable, sfrapPerfLmiTotalTxOtherByteCnt=sfrapPerfLmiTotalTxOtherByteCnt, sfrapTftpHostUnreachableTrap=sfrapTftpHostUnreachableTrap, sfrapCfgVnipRxTimer=sfrapCfgVnipRxTimer, sfrapStatusLedCtrlLED=sfrapStatusLedCtrlLED, sfrapCfgSnmpMgrIP=sfrapCfgSnmpMgrIP, sfrapPerfCurrentAggregateUtilization=sfrapPerfCurrentAggregateUtilization, sfrapPerfArpPerDlciTxTotal=sfrapPerfArpPerDlciTxTotal, sfrapPerfIcmpTotalRxEchoRep=sfrapPerfIcmpTotalRxEchoRep, sfrapCfgFrPerfUserProtocolsTableClear=sfrapCfgFrPerfUserProtocolsTableClear, sfrapVnipTopologyInterface=sfrapVnipTopologyInterface, sfrapStatusLedCtsLED=sfrapStatusLedCtsLED, sfrapPerfIcmpTotalTxDestUnr=sfrapPerfIcmpTotalTxDestUnr, sfrapSysMLSupported=sfrapSysMLSupported, sfrapCfgSnmpMgrTable=sfrapCfgSnmpMgrTable)
mibBuilder.exportSymbols("SFRAP-MIB", sfrapCfgTftpDlci=sfrapCfgTftpDlci, sfrapDiagTxClockDetect=sfrapDiagTxClockDetect, sfrapPerfApplicationTotalTxTftp=sfrapPerfApplicationTotalTxTftp, sfrapPerfCurrentWanUtilization=sfrapPerfCurrentWanUtilization, sfrapPerfIcmpPerDlciTable=sfrapPerfIcmpPerDlciTable, sfrapDiagVnipTable=sfrapDiagVnipTable, sfrapEventTrapLogSeqNum=sfrapEventTrapLogSeqNum, sfrapDLCIInactiveTrap=sfrapDLCIInactiveTrap, sfrapPerfApplicationTotalRxCustom3=sfrapPerfApplicationTotalRxCustom3, sfrapVnipTopoVBertTimeElapse=sfrapVnipTopoVBertTimeElapse, sfrapPerfThruputCmdReplaceDlciValue=sfrapPerfThruputCmdReplaceDlciValue, sfrapPerfCirRxPercentUtilizationRange8=sfrapPerfCirRxPercentUtilizationRange8, sfrapTftpTransferringTrap=sfrapTftpTransferringTrap, sfrapPerfThruputCmdRemoveStsDlci=sfrapPerfThruputCmdRemoveStsDlci, sfrapVnipTopologyNumHops=sfrapVnipTopologyNumHops, sfrapPerfIcmpPerDlciRxParamProb=sfrapPerfIcmpPerDlciRxParamProb, sfrapSysETHSupported=sfrapSysETHSupported, sfrapPerfIcmpTotalTxGmQuery=sfrapPerfIcmpTotalTxGmQuery, sfrapCfgTftpNumBytes=sfrapCfgTftpNumBytes, sfrapCfgTftpInterface=sfrapCfgTftpInterface, sfrapPerfIcmpTotalTxSrcQuench=sfrapPerfIcmpTotalTxSrcQuench, sfrapPerfMgmtIpICMPOutEchos=sfrapPerfMgmtIpICMPOutEchos, private=private, sfrapPerfThruputCmdClearToDceStats=sfrapPerfThruputCmdClearToDceStats, sfrapDiagUnitLocLoop=sfrapDiagUnitLocLoop, sfrapDiagUnitTimeRemaining=sfrapDiagUnitTimeRemaining, sfrapPerfIcmpTotalTxTimestpReq=sfrapPerfIcmpTotalTxTimestpReq, sfrapPerfLmiTotalRxLivoEnqByteCnt=sfrapPerfLmiTotalRxLivoEnqByteCnt, sfrapPerfLmiTotalTxLivoStatByteCnt=sfrapPerfLmiTotalTxLivoStatByteCnt, sfrapPerfIcmpTotalTxAddrMaskRep=sfrapPerfIcmpTotalTxAddrMaskRep, sfrapPerfIpxPerDlciRxSpx=sfrapPerfIpxPerDlciRxSpx, sfrapPerfIcmpTotalTxEchoReq=sfrapPerfIcmpTotalTxEchoReq, sfrapPerfIcmpTotalRxTimestpReq=sfrapPerfIcmpTotalRxTimestpReq, sfrapPerfIpxTotalRxTotal=sfrapPerfIpxTotalRxTotal, sfrapPerfIcmpPerDlciTxTimestpReq=sfrapPerfIcmpPerDlciTxTimestpReq, sfrapStatusDteDtr=sfrapStatusDteDtr, sfrapVnipTopoTDAvgDelay=sfrapVnipTopoTDAvgDelay, sfrapPerfNetwProtoTotalRxVnip=sfrapPerfNetwProtoTotalRxVnip, sfrapPerfArpTotalRxRarpReq=sfrapPerfArpTotalRxRarpReq, sfrapPerfApplicationPerDlciTxSnmpTrap=sfrapPerfApplicationPerDlciTxSnmpTrap, sfrapCfgFrPerfDlciNamesTable=sfrapCfgFrPerfDlciNamesTable, sfrapPerfIcmpTotalEntry=sfrapPerfIcmpTotalEntry, sfrapPerfIpxTotalRxSap=sfrapPerfIpxTotalRxSap, sfrapPerfApplicationTotalTxSmtp=sfrapPerfApplicationTotalTxSmtp, sfrapPvcRxUtilizationClearedTrap=sfrapPvcRxUtilizationClearedTrap, sfrapCfgTransitDelayDlciValue=sfrapCfgTransitDelayDlciValue, sfrapPerfThruputPerDlciTxUtilizationStatus=sfrapPerfThruputPerDlciTxUtilizationStatus, sfrapCfgFrLmiFullStatus=sfrapCfgFrLmiFullStatus, sfrapVnipTopoTDMaxDelay=sfrapVnipTopoTDMaxDelay, sfrapUtilizationThreshold=sfrapUtilizationThreshold, sfrapPerfNetwLongTermAltDlci=sfrapPerfNetwLongTermAltDlci, sfrapPerfCirPercentUtilizationDlciValue=sfrapPerfCirPercentUtilizationDlciValue, sfrapStatusLedLmiErrLED=sfrapStatusLedLmiErrLED, sfrapLmiSourcingChangePassthruTrap=sfrapLmiSourcingChangePassthruTrap, sfrapPerfApplicationTotalRxSnmp=sfrapPerfApplicationTotalRxSnmp, sfrapPerfCirRxPercentUtilizationRange1=sfrapPerfCirRxPercentUtilizationRange1, sfrapCfgStatus=sfrapCfgStatus, sfrapPerfNetwProtoPerDlciRxTotal=sfrapPerfNetwProtoPerDlciRxTotal, sfrapPerfSnaPerDlciTxOther=sfrapPerfSnaPerDlciTxOther, sfrapPerfIpTotalRxOther=sfrapPerfIpTotalRxOther, sfrapPerfApplicationTotalTable=sfrapPerfApplicationTotalTable, sfrapPerfIcmpPerDlciTxGmQuery=sfrapPerfIcmpPerDlciTxGmQuery, sfrapCfgUpdate=sfrapCfgUpdate, sfrapPerfLmiPerDlciTable=sfrapPerfLmiPerDlciTable, sfrapPerfArpPerDlciRxInarpReq=sfrapPerfArpPerDlciRxInarpReq, sfrapVloopDownViaRemote=sfrapVloopDownViaRemote, sfrapPerfNetwProtoTotalRxOther=sfrapPerfNetwProtoTotalRxOther, sfrapTrap=sfrapTrap, sfrapCfgAppCircuitId=sfrapCfgAppCircuitId, sfrapStatusDteRxtiming=sfrapStatusDteRxtiming, sfrapPerfRoutingPerDlciRxRip=sfrapPerfRoutingPerDlciRxRip, sfrapVnipTopoTDLastDelay=sfrapVnipTopoTDLastDelay, sfrapVnipTopoVBERTStatus=sfrapVnipTopoVBERTStatus, sfrapPerfRoutingTotalTxRip=sfrapPerfRoutingTotalTxRip, sfrapCfgVnipMode=sfrapCfgVnipMode, sfrapPerfCirRxPercentUtilizationRange2=sfrapPerfCirRxPercentUtilizationRange2, sync=sync, sfrapPerfMgmtIpIPOutDscrd=sfrapPerfMgmtIpIPOutDscrd, sfrapSysBootRev=sfrapSysBootRev, sfrapPerfThruputPerIntfRxAbortCnt=sfrapPerfThruputPerIntfRxAbortCnt, sfrapPerfArpPerDlciRxArpRep=sfrapPerfArpPerDlciRxArpRep, sfrapCfgFrPerfDlciNamesDelete=sfrapCfgFrPerfDlciNamesDelete, sfrapPerfIpPerDlciTxUdp=sfrapPerfIpPerDlciTxUdp, sfrapPerfIpTotalEntry=sfrapPerfIpTotalEntry, sfrapEventTrapLogSpecificEvent=sfrapEventTrapLogSpecificEvent, sfrapPerfArpPerDlciRxRarpReq=sfrapPerfArpPerDlciRxRarpReq, sfrapPerfThruputPerDlciRxFrame=sfrapPerfThruputPerDlciRxFrame, sfrapPerfNetwProtoPerDlciTxArp=sfrapPerfNetwProtoPerDlciTxArp, sfrapSysType=sfrapSysType, sfrapVnipTopoTDMinDelay=sfrapVnipTopoTDMinDelay, sfrapPerfNetwProtoTotalRxIpx=sfrapPerfNetwProtoTotalRxIpx, sfrapPerfIcmpPerDlciInterval=sfrapPerfIcmpPerDlciInterval, sfrapPerfNetwLongTermAltArray=sfrapPerfNetwLongTermAltArray, sfrapLocalUnitLoopbackDisabledTrap=sfrapLocalUnitLoopbackDisabledTrap, sfrapPerfIcmpPerDlciTxPktTooBig=sfrapPerfIcmpPerDlciTxPktTooBig, sfrapPerfRoutingPerDlciRxNetbios=sfrapPerfRoutingPerDlciRxNetbios, sfrapPerfCirPercentUtilizationEntry=sfrapPerfCirPercentUtilizationEntry, sfrapDiagUnitReset=sfrapDiagUnitReset, sfrapCfgTelnetCliPassword=sfrapCfgTelnetCliPassword, sfrapPerfIcmpTotalTxAddrMaskReq=sfrapPerfIcmpTotalTxAddrMaskReq, sfrapPerfThruputPerIntfTxFrameCnt=sfrapPerfThruputPerIntfTxFrameCnt, sfrapPerfIcmpTotalRxGmReduct=sfrapPerfIcmpTotalRxGmReduct, sfrapCfgFrPerfDlciNamesCirType=sfrapCfgFrPerfDlciNamesCirType, sfrapCfgSnmpMgrClearN=sfrapCfgSnmpMgrClearN, sfrapPerfIpxPerDlciTable=sfrapPerfIpxPerDlciTable, sfrapPerfIcmpTotalTxParamProb=sfrapPerfIcmpTotalTxParamProb, sfrapCfgFrAddrLen=sfrapCfgFrAddrLen, sfrapPerfLmiTotalTxFullStatByteCnt=sfrapPerfLmiTotalTxFullStatByteCnt, sfrapDiagVLOOP=sfrapDiagVLOOP, sfrapCfgFrPerfLTDlciFilterEntry=sfrapCfgFrPerfLTDlciFilterEntry, sfrapPerfIcmpPerDlciTxEchoRep=sfrapPerfIcmpPerDlciTxEchoRep, sfrapPerfLmiTotalEntry=sfrapPerfLmiTotalEntry, sfrapEventTrapLogVarBind1=sfrapEventTrapLogVarBind1, sfrapPerfIpxTotalRxNcp=sfrapPerfIpxTotalRxNcp, sfrapPerfIcmpPerDlciRxAddrMaskRep=sfrapPerfIcmpPerDlciRxAddrMaskRep, sfrapTftpInvalidFileTrap=sfrapTftpInvalidFileTrap, sfrapPerfNetwProtoTotalTxSna=sfrapPerfNetwProtoTotalTxSna, sfrapLocalUnitLoopbackFailedTrap=sfrapLocalUnitLoopbackFailedTrap, sfrapPerfArpPerDlciTxInarpReq=sfrapPerfArpPerDlciTxInarpReq, sfrapDteSignalControlOnTrap=sfrapDteSignalControlOnTrap, sfrapCfgIpChannel=sfrapCfgIpChannel, sfrapPerfApplicationPerDlciTxTftp=sfrapPerfApplicationPerDlciTxTftp, sfrapPerfThruputPerDlciTxByte=sfrapPerfThruputPerDlciTxByte, sfrapPerfIcmpPerDlciRxEchoReq=sfrapPerfIcmpPerDlciRxEchoReq, sfrapPerfArpTotalTxRarpRep=sfrapPerfArpTotalTxRarpRep, sfrapCfgFrPerfDlciNamesEirValue=sfrapCfgFrPerfDlciNamesEirValue, sfrapPerfIcmpTotalRxTimeExcd=sfrapPerfIcmpTotalRxTimeExcd, sfrapCfgDteEntry=sfrapCfgDteEntry, sfrapPerfLmiPerDlciRxLivoStatByteCnt=sfrapPerfLmiPerDlciRxLivoStatByteCnt, sfrapPerfMgmtIpIFInOctets=sfrapPerfMgmtIpIFInOctets, sfrapPerfLmiPerDlciRxOtherByteCnt=sfrapPerfLmiPerDlciRxOtherByteCnt, sfrapVnipTopoTDNumSamples=sfrapVnipTopoTDNumSamples, sfrapDLCIActiveTrap=sfrapDLCIActiveTrap, sfrapCfgFrDLCITable=sfrapCfgFrDLCITable, sfrapVnipTopoVBertPerUtilCIR=sfrapVnipTopoVBertPerUtilCIR, sfrapLocalUnitLoopbackEnabledTrap=sfrapLocalUnitLoopbackEnabledTrap, sfrapLowSpeedResumedTrap=sfrapLowSpeedResumedTrap, sfrapPerfCirTxPercentUtilizationRange5=sfrapPerfCirTxPercentUtilizationRange5, sfrapCfgIpMask=sfrapCfgIpMask, sfrapPerfFRStatsCollection=sfrapPerfFRStatsCollection, sfrapSysRDOSupported=sfrapSysRDOSupported, sfrapPerfLmiTotalRxOtherByteCnt=sfrapPerfLmiTotalRxOtherByteCnt, sfrapDiagDteTable=sfrapDiagDteTable, sfrapPerfNetwProtoPerDlciTxSna=sfrapPerfNetwProtoPerDlciTxSna, sfrapPerfIpPerDlciTxIgrp=sfrapPerfIpPerDlciTxIgrp, sfrapCfgAppOperationMode=sfrapCfgAppOperationMode, sfrapPerfMgmtIpICMPInEchos=sfrapPerfMgmtIpICMPInEchos, sfrapPerfThruputPerIntfTxByteCnt=sfrapPerfThruputPerIntfTxByteCnt, sfrapPerfIpxPerDlciInterval=sfrapPerfIpxPerDlciInterval, sfrapCfgTDDeleteEntry=sfrapCfgTDDeleteEntry, sfrapPerfIpxTotalTable=sfrapPerfIpxTotalTable, sfrapEventLogAltEntry=sfrapEventLogAltEntry, sfrapPerfApplicationPerDlciTxCustom3=sfrapPerfApplicationPerDlciTxCustom3, sfrapNonIncrLmiSeqNumToDceTrap=sfrapNonIncrLmiSeqNumToDceTrap, sfrapCfgLockID=sfrapCfgLockID, sfrapVbertRequestFailed=sfrapVbertRequestFailed, sfrapPerfSnaTotalRxTotal=sfrapPerfSnaTotalRxTotal, sfrapPerfIpTotalTxTcp=sfrapPerfIpTotalTxTcp, sfrapPvcRxUtilizationExceededTrap=sfrapPvcRxUtilizationExceededTrap, sfrapCfgGetCommunityString=sfrapCfgGetCommunityString, sfrapPerfRoutingPerDlciTxRip=sfrapPerfRoutingPerDlciTxRip, sfrapPerfSnaTotalTxSubarea=sfrapPerfSnaTotalTxSubarea, sfrapDiagVnipDlci=sfrapDiagVnipDlci, sfrapPerfRoutingTotalEntry=sfrapPerfRoutingTotalEntry, sfrapSysTable=sfrapSysTable, sfrapCfgCommDataBits=sfrapCfgCommDataBits, sfrapPerfSnaTotalRxOther=sfrapPerfSnaTotalRxOther, sfrapCfgFrPerfLTDlciFilterDlciNum=sfrapCfgFrPerfLTDlciFilterDlciNum, sfrapPerfThruputCmdAllStsDlciResetAll=sfrapPerfThruputCmdAllStsDlciResetAll, sfrapDiagVBERTRate=sfrapDiagVBERTRate, sfrapPerfLmiPerDlciRxLivoEnqByteCnt=sfrapPerfLmiPerDlciRxLivoEnqByteCnt, sfrapConfigInstallSuccess=sfrapConfigInstallSuccess, sfrapSysSoftRev=sfrapSysSoftRev, sfrapPerfIcmpPerDlciTxAddrMaskRep=sfrapPerfIcmpPerDlciTxAddrMaskRep, sfrapPerfNetwLongTermAltTable=sfrapPerfNetwLongTermAltTable, sfrapCfgAppTxClkmode=sfrapCfgAppTxClkmode, sfrapPerfRoutingTotalInterval=sfrapPerfRoutingTotalInterval, sfrapPerfMgmtIpIPInProtUnk=sfrapPerfMgmtIpIPInProtUnk, sfrapPerfNetwProtoTotalTxIp=sfrapPerfNetwProtoTotalTxIp, sfrapPerfIcmpPerDlciRxAddrMaskReq=sfrapPerfIcmpPerDlciRxAddrMaskReq, sfrapPerfArpPerDlciTable=sfrapPerfArpPerDlciTable, sfrapLocalConfigTrap=sfrapLocalConfigTrap, sfrapPerfSnaPerDlciRxNetbios=sfrapPerfSnaPerDlciRxNetbios, sfrapCfgAppLpbkTimeout=sfrapCfgAppLpbkTimeout, sfrapCfgFrPerfDlciNamesDlciName=sfrapCfgFrPerfDlciNamesDlciName, sfrapPerfIcmpPerDlciValue=sfrapPerfIcmpPerDlciValue, sfrapPerfApplicationPerDlciRxFtp=sfrapPerfApplicationPerDlciRxFtp, sfrapPerfArpTotalInterval=sfrapPerfArpTotalInterval, sfrapCfgTransitDelayNumHops=sfrapCfgTransitDelayNumHops, sfrapPerfNetwProtoPerDlciInterval=sfrapPerfNetwProtoPerDlciInterval, sfrapPerfIpTotalTxIcmp=sfrapPerfIpTotalTxIcmp, sfrapPerfLmiPerDlciValue=sfrapPerfLmiPerDlciValue, sfrapDiagVnipIpAddr=sfrapDiagVnipIpAddr, sfrapPerfMgmtIpICMPInDestUnreachs=sfrapPerfMgmtIpICMPInDestUnreachs, sfrapPerfIpPerDlciRxIgrp=sfrapPerfIpPerDlciRxIgrp, sfrapPerfIcmpTotalRxTimestpRep=sfrapPerfIcmpTotalRxTimestpRep, sfrapPerfSnaPerDlciTxPeriph=sfrapPerfSnaPerDlciTxPeriph, sfrapPerfLmiTotalRxFullStatByteCnt=sfrapPerfLmiTotalRxFullStatByteCnt, sfrapDteSignalDtrOffTrap=sfrapDteSignalDtrOffTrap, sfrapEventLogFreeze=sfrapEventLogFreeze, sfrapPerfIcmpTotalRxParamProb=sfrapPerfIcmpTotalRxParamProb, sfrapPerfMgmtIpIFOperStatus=sfrapPerfMgmtIpIFOperStatus, sfrapDiagDteLclLpbk=sfrapDiagDteLclLpbk, sfrapCfgSnmpMgrIndex=sfrapCfgSnmpMgrIndex, sfrapPerfArpPerDlciTxRarpRep=sfrapPerfArpPerDlciTxRarpRep, sfrapStatusDteIndex=sfrapStatusDteIndex, sfrapDiagDteIndex=sfrapDiagDteIndex, sfrapPerfNetwProtoPerDlciEntry=sfrapPerfNetwProtoPerDlciEntry, sfrapVnipTopologyEntry=sfrapVnipTopologyEntry, sfrapPerfThruputCmdCountsStsDlciReset=sfrapPerfThruputCmdCountsStsDlciReset, sfrapPerfThruputPerDlciTable=sfrapPerfThruputPerDlciTable, sfrapLmiSourcingChangeNetToDteTrap=sfrapLmiSourcingChangeNetToDteTrap, sfrapPerfMgmtIpICMPInRedirects=sfrapPerfMgmtIpICMPInRedirects, sfrapPerfIpxPerDlciTxOther=sfrapPerfIpxPerDlciTxOther, sfrapPerfLmiTotalTxFullEnqByteCnt=sfrapPerfLmiTotalTxFullEnqByteCnt, sfrapPvcTxUtilizationExceededTrap=sfrapPvcTxUtilizationExceededTrap, sfrapCfgDteIndex=sfrapCfgDteIndex, sfrapCfgFrPerfLTProtocolFilterEntry=sfrapCfgFrPerfLTProtocolFilterEntry, sfrapPerfThruputPerDlciRxByte=sfrapPerfThruputPerDlciRxByte, sfrapPerfApplicationPerDlciTable=sfrapPerfApplicationPerDlciTable, sfrapPerfSnaTotalTxTotal=sfrapPerfSnaTotalTxTotal, sfrapPerfMgmtIpICMPOutMsgs=sfrapPerfMgmtIpICMPOutMsgs, sfrapPerfRoutingTotalRxRip=sfrapPerfRoutingTotalRxRip, sfrapPerfLmiTotalTxTotalByteCnt=sfrapPerfLmiTotalTxTotalByteCnt, sfrapPerfIcmpPerDlciRxGmQuery=sfrapPerfIcmpPerDlciRxGmQuery, sfrapPerfMgmtIpICMPInMsgs=sfrapPerfMgmtIpICMPInMsgs, sfrapPerfIcmpPerDlciRxRedirect=sfrapPerfIcmpPerDlciRxRedirect, sfrapPerfApplicationPerDlciEntry=sfrapPerfApplicationPerDlciEntry, sfrapPerfIpTotalTxTotal=sfrapPerfIpTotalTxTotal, sfrapPerfRoutingPerDlciRxOspf=sfrapPerfRoutingPerDlciRxOspf, sfrapTftpProgrammingTrap=sfrapTftpProgrammingTrap, sfrapPerfCirTxPercentUtilizationRange4=sfrapPerfCirTxPercentUtilizationRange4, sfrapStatusDteTable=sfrapStatusDteTable, sfrapCfgTftpPassword=sfrapCfgTftpPassword, sfrapStatusLedToDCERxLED=sfrapStatusLedToDCERxLED, sfrapPerfIcmpPerDlciRxTimeExcd=sfrapPerfIcmpPerDlciRxTimeExcd, sfrapPerfIcmpPerDlciRxPktTooBig=sfrapPerfIcmpPerDlciRxPktTooBig, sfrapPerfThruputPerDlciPvcState=sfrapPerfThruputPerDlciPvcState, sfrapVnipTopoVBertTransitDelayMax=sfrapVnipTopoVBertTransitDelayMax, sfrapPerfMgmtIpIPStatsTable=sfrapPerfMgmtIpIPStatsTable, sfrapPerfThruputPerDlciValue=sfrapPerfThruputPerDlciValue, sfrapPerfThruputCommands=sfrapPerfThruputCommands, sfrapPerfThruputPerDlciAvailability=sfrapPerfThruputPerDlciAvailability, sfrapPerfSnaPerDlciRxSubarea=sfrapPerfSnaPerDlciRxSubarea, sfrapCfgFrPerfLTDlciFilterTable=sfrapCfgFrPerfLTDlciFilterTable, sfrapPerfApplicationPerDlciTxSmtp=sfrapPerfApplicationPerDlciTxSmtp, sfrapDiagVBERTPktPercent=sfrapDiagVBERTPktPercent, sfrapPerfIpTotalRxTotal=sfrapPerfIpTotalRxTotal, sfrapPerfApplicationTotalRxCustom2=sfrapPerfApplicationTotalRxCustom2, sfrapStatusDipswitchCutthru=sfrapStatusDipswitchCutthru, sfrapPerfLmiTotalRxLivoStatByteCnt=sfrapPerfLmiTotalRxLivoStatByteCnt, sfrapPerfMgmtIpICMPInErrors=sfrapPerfMgmtIpICMPInErrors, sfrapCfgTftpTable=sfrapCfgTftpTable, sfrapPerfSnaPerDlciEntry=sfrapPerfSnaPerDlciEntry)
mibBuilder.exportSymbols("SFRAP-MIB", sfrapPerfLmiTotalTxLivoEnqByteCnt=sfrapPerfLmiTotalTxLivoEnqByteCnt, sfrapPerfIcmpPerDlciRxTimestpReq=sfrapPerfIcmpPerDlciRxTimestpReq, sfrapStatusDteDsr=sfrapStatusDteDsr, sfrapSysName=sfrapSysName, sfrapCfgDteRtsC=sfrapCfgDteRtsC, sfrapPerfApplicationTotalTxCustom2=sfrapPerfApplicationTotalTxCustom2, sfrapCfgFrCrcMode=sfrapCfgFrCrcMode, sfrapLmiSourcingChangeUserToDteTrap=sfrapLmiSourcingChangeUserToDteTrap, sfrapPerfThruputPerDlciMTBSO=sfrapPerfThruputPerDlciMTBSO, sfrapCfgDteRxClockMode=sfrapCfgDteRxClockMode, sfrapCfgIpTable=sfrapCfgIpTable, sfrapBadConfigTrap=sfrapBadConfigTrap, sfrapSysLTFNumProtocols=sfrapSysLTFNumProtocols, sfrapVnipTopologyLocalDlci=sfrapVnipTopologyLocalDlci, sfrapPerfApplicationTotalTxTelnet=sfrapPerfApplicationTotalTxTelnet, sfrapPerfMgmtIpUDPInDatagrams=sfrapPerfMgmtIpUDPInDatagrams, sfrapCfgFrPerfDlciNamesTableClear=sfrapCfgFrPerfDlciNamesTableClear, sfrapStatusDteMode=sfrapStatusDteMode, sfrapPerfApplicationTotalTxSnmp=sfrapPerfApplicationTotalTxSnmp, sfrapPerfIcmpPerDlciEntry=sfrapPerfIcmpPerDlciEntry, sfrapPerfRoutingPerDlciValue=sfrapPerfRoutingPerDlciValue, sfrapPerfIpPerDlciEntry=sfrapPerfIpPerDlciEntry, sfrapCfgID=sfrapCfgID, sfrapCfgFrPerfUnprovDlcisDelete=sfrapCfgFrPerfUnprovDlcisDelete, sfrapPerfSnaPerDlciValue=sfrapPerfSnaPerDlciValue, sfrapPerfLmiPerDlciTxLivoStatByteCnt=sfrapPerfLmiPerDlciTxLivoStatByteCnt, sfrapEventLogCurrentSeqNum=sfrapEventLogCurrentSeqNum, sfrapCfgAppTable=sfrapCfgAppTable, sfrapCfgFrPerfUserProtocolsTable=sfrapCfgFrPerfUserProtocolsTable, sfrapDteSignalControlOffTrap=sfrapDteSignalControlOffTrap, sfrapPerfIpxTotalTxSap=sfrapPerfIpxTotalTxSap, sfrapPerfThruputPerIntfIndex=sfrapPerfThruputPerIntfIndex, sfrapPerfApplicationPerDlciRxSnmpTrap=sfrapPerfApplicationPerDlciRxSnmpTrap, sfrapDiagUnitCutThruTimeRemaining=sfrapDiagUnitCutThruTimeRemaining, sfrapPerfLmiPerDlciRxFullStatByteCnt=sfrapPerfLmiPerDlciRxFullStatByteCnt, sfrapPerfIcmpPerDlciRxSrcQuench=sfrapPerfIcmpPerDlciRxSrcQuench, sfrapCfgUnlock=sfrapCfgUnlock, sfrapStatusLedIndLED=sfrapStatusLedIndLED, sfrapPerfSnaTotalRxAppn=sfrapPerfSnaTotalRxAppn, sfrapPerfThruputCmdClearToDteStats=sfrapPerfThruputCmdClearToDteStats, sfrapConfiguration=sfrapConfiguration, sfrapCfgCommFlowCtrl=sfrapCfgCommFlowCtrl, sfrapPerfNetwProtoTotalTxOther=sfrapPerfNetwProtoTotalTxOther, sfrapStatusMgmtDefaultDLCIStatus=sfrapStatusMgmtDefaultDLCIStatus, sfrapPerfIpPerDlciTxTcp=sfrapPerfIpPerDlciTxTcp, sfrapPerfIpxPerDlciTxRip=sfrapPerfIpxPerDlciTxRip, sfrapPerfIpxTotalTxOther=sfrapPerfIpxTotalTxOther, Index=Index, sfrapPerfThruputPerDlciEncapType=sfrapPerfThruputPerDlciEncapType, sfrapPerfRoutingPerDlciTxOspf=sfrapPerfRoutingPerDlciTxOspf, sfrapPerfThruputPerIntfRxBpvCnt=sfrapPerfThruputPerIntfRxBpvCnt, sfrapCfgCommBaud=sfrapCfgCommBaud, sfrapStatusLedTable=sfrapStatusLedTable, sfrapLmiSourcingChangeUserToDceTrap=sfrapLmiSourcingChangeUserToDceTrap, sfrapPerfSnaPerDlciTxNetbios=sfrapPerfSnaPerDlciTxNetbios, sfrapPerfCirTxPercentUtilizationRange6=sfrapPerfCirTxPercentUtilizationRange6, sfrapPerfIcmpTotalTxTotal=sfrapPerfIcmpTotalTxTotal, sfrapStatusMgmtInterface=sfrapStatusMgmtInterface, sfrapPerfIpTotalTxIgrp=sfrapPerfIpTotalTxIgrp, sfrapPerfThruputPerDlciOutageCount=sfrapPerfThruputPerDlciOutageCount, sfrapStatusAllLEDs=sfrapStatusAllLEDs, sfrapSysTKRSupported=sfrapSysTKRSupported, sfrapPerfNetwLongTermInterval=sfrapPerfNetwLongTermInterval, sfrapPerfRoutingTotalRxNetbios=sfrapPerfRoutingTotalRxNetbios, sfrapPerfApplicationTotalRxTftp=sfrapPerfApplicationTotalRxTftp, sfrapSystem=sfrapSystem, sfrapPerfNetwLongTermAltProtocol=sfrapPerfNetwLongTermAltProtocol, sfrapPerfSnaPerDlciRxAppn=sfrapPerfSnaPerDlciRxAppn, sfrapTftpAbortedTrap=sfrapTftpAbortedTrap, sfrapCfgDteIntfType=sfrapCfgDteIntfType, sfrapAlarmType=sfrapAlarmType, sfrapPerfThruputCmdClearDlciStats=sfrapPerfThruputCmdClearDlciStats, sfrapStatusLedDcdLED=sfrapStatusLedDcdLED, sfrapPerfNetwProtoPerDlciRxSna=sfrapPerfNetwProtoPerDlciRxSna, sfrapStatusTxClockDetect=sfrapStatusTxClockDetect, sfrapVnipTransitDelayClear=sfrapVnipTransitDelayClear, sfrapPerfNetwProtoTotalTxVnip=sfrapPerfNetwProtoTotalTxVnip, sfrapPerfArpTotalTxTotal=sfrapPerfArpTotalTxTotal, sfrapCfgFrDLCIMode=sfrapCfgFrDLCIMode, sfrapPerfThruputPerIntfTable=sfrapPerfThruputPerIntfTable, sfrapPerfSnaPerDlciInterval=sfrapPerfSnaPerDlciInterval, sfrapCfgFrDLCIEncap=sfrapCfgFrDLCIEncap, sfrapCfgIpTelnetEnable=sfrapCfgIpTelnetEnable, sfrapCfgFrPerfDlciNamesDlciValue=sfrapCfgFrPerfDlciNamesDlciValue, sfrapPerfNetwProtoTotalRxIp=sfrapPerfNetwProtoTotalRxIp, sfrapDiagVnipIndex=sfrapDiagVnipIndex, sfrapPerfThruputCmdClearAllIntfStats=sfrapPerfThruputCmdClearAllIntfStats, sfrapPerfApplicationPerDlciRxCustom1=sfrapPerfApplicationPerDlciRxCustom1, sfrapCfgSnmpTrapMuting=sfrapCfgSnmpTrapMuting, sfrapCfgFrPerfLTProtocolFilterIndex=sfrapCfgFrPerfLTProtocolFilterIndex)

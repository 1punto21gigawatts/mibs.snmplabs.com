#
# PySNMP MIB module APPLIC-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/APPLIC-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:24:08 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueRangeConstraint, SingleValueConstraint, ConstraintsUnion, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsUnion", "ValueSizeConstraint")
lannet, = mibBuilder.importSymbols("GEN-MIB", "lannet")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
historyControlIndex, = mibBuilder.importSymbols("RMON-MIB", "historyControlIndex")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
ModuleIdentity, Counter32, Integer32, TimeTicks, Bits, Unsigned32, MibScalar, MibTable, MibTableRow, MibTableColumn, ObjectIdentity, MibIdentifier, iso, Counter64, IpAddress, Gauge32, NotificationType = mibBuilder.importSymbols("SNMPv2-SMI", "ModuleIdentity", "Counter32", "Integer32", "TimeTicks", "Bits", "Unsigned32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ObjectIdentity", "MibIdentifier", "iso", "Counter64", "IpAddress", "Gauge32", "NotificationType")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
lntLanSwitch = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 19))
lntTopology = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 23))
smon = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 30))
lse = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 19, 1))
lhs = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 19, 2))
lsMonitor = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 19, 3))
lst = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 19, 4))
lsVNChange = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 19, 6))
vnsPacket = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 19, 7))
lseGroupTable = MibTable((1, 3, 6, 1, 4, 1, 81, 19, 1, 1), )
if mibBuilder.loadTexts: lseGroupTable.setStatus('mandatory')
if mibBuilder.loadTexts: lseGroupTable.setDescription('')
lseGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 19, 1, 1, 1), ).setIndexNames((0, "APPLIC-MIB", "lseGroupId"))
if mibBuilder.loadTexts: lseGroupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lseGroupEntry.setDescription('')
lseGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lseGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: lseGroupId.setDescription('Slot number in which the group is installed.')
lseGroupFastOpen = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseGroupFastOpen.setStatus('mandatory')
if mibBuilder.loadTexts: lseGroupFastOpen.setDescription('Setting the value of this attribute to ON activates the port for short idle time when code violation was detected.')
lseGroup10MSqlt = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseGroup10MSqlt.setStatus('mandatory')
if mibBuilder.loadTexts: lseGroup10MSqlt.setDescription('Setting the value of this attribute to ON activates the mechanism of detection preamble of 10Mhz.')
lseGroupSmartSqlt = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseGroupSmartSqlt.setStatus('deprecated')
if mibBuilder.loadTexts: lseGroupSmartSqlt.setDescription('Control the mechnism of the input sensitivity of the port.')
lseGroupCParameter = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseGroupCParameter.setStatus('mandatory')
if mibBuilder.loadTexts: lseGroupCParameter.setDescription('Defines the number of consecutive collisions the port waits before it ceases transmitting of 512 bits time toward the station.')
lseGroupIPGJamLength = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 124))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseGroupIPGJamLength.setStatus('mandatory')
if mibBuilder.loadTexts: lseGroupIPGJamLength.setDescription('Defines the IPG jam length in Ethernet bit time (100nS) start at 16 bit time in steps of 16, to 112 bit time. For LFE-100, (Fast Ethernet bit time (10nS)) values are from 48 bit times (480nano-seconds) in step of 4, to 124 (1240nano-seconds). Any number between the defined values will take to nearest smaller value.')
lseGroupJamLength = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(8, 120))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseGroupJamLength.setStatus('mandatory')
if mibBuilder.loadTexts: lseGroupJamLength.setDescription('Defines the Jam Length in time starting from 8 (800micro-seconds) to 120 (12mili-seconds). Each step of 8 is equal 800micro-seconds. For LFE-100, values are from 8 (80micro-seconds) to 32 (320micro-seconds), each step of 8 is equal 800micro-seconds. Any number between the defined values will take to nearest smaller value.')
lseGroupDataBlinderLength = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 124))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseGroupDataBlinderLength.setStatus('mandatory')
if mibBuilder.loadTexts: lseGroupDataBlinderLength.setDescription('Defines the Data Blinder Length in Ethernet bit time (100nS) start at 16 bit time in steps of 16 to 112 bit time. For LFE-100, (Fast Ethernet bit time (10nS)) values are from 0 bit times in step of 4, to 124 (1240nano-seconds). Any number between the defined values will take to nearest smaller value.')
lseGroupIPGDataLength = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 124))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseGroupIPGDataLength.setStatus('mandatory')
if mibBuilder.loadTexts: lseGroupIPGDataLength.setDescription('Defines the IPG (Inter Packet Gap) length in Ethernet bit time (100nS) starting at 16 bit time in steps of 16 to 112 bit time. For LFE-100, (Fast Ethernet bit time (10nS)) values are from 48 bit times (480nano-seconds) in step of 4, to 124 (1240 nano-seconds). Any number between the defined values will take to nearest smaller value.')
lseGroupActiveMonitor = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lseGroupActiveMonitor.setStatus('mandatory')
if mibBuilder.loadTexts: lseGroupActiveMonitor.setDescription('This attribute defines the module which is the high-speed bus active monitor.')
lseGroupBackbone12 = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseGroupBackbone12.setStatus('mandatory')
if mibBuilder.loadTexts: lseGroupBackbone12.setDescription('Port 1 and 2 in the board perform as Backbone link. lse208 - upper cluster is RX only and lower cluster is TX only. lse404 - upper port is Rx only and second port is Tx only. Two remains port are performed as regular foirl interfaces. lse808 - the first port is RX from line only, the second - TX to line only, the rest are in regular10BaseT mode.')
lseGroupSetDefaults = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseGroupSetDefaults.setStatus('mandatory')
if mibBuilder.loadTexts: lseGroupSetDefaults.setDescription('Set all hardware parameters to their default values. This item will always return a value of off(2), since it acts like a toggle switch.')
lseGroupBackbone34 = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseGroupBackbone34.setStatus('mandatory')
if mibBuilder.loadTexts: lseGroupBackbone34.setDescription('Port 3 and 4 in the board performed as Backbone link. lse404 - Third port is Rx only and forth port is Tx only. Two remaining ports performed as regular foirl interfaces.')
lseGroupBackboneRedun12 = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseGroupBackboneRedun12.setStatus('mandatory')
if mibBuilder.loadTexts: lseGroupBackboneRedun12.setDescription('Value on(1) of this attribute defines a redundancy (backup) relationship between Backbone port 1 and backbone port 2 on a LANswiltch module.')
lseGroupBackoffFromJam = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseGroupBackoffFromJam.setStatus('mandatory')
if mibBuilder.loadTexts: lseGroupBackoffFromJam.setDescription('Value on(1) of this attribute defines non-consecutive jam after a collision has occured in LANswitch modules.')
lseGroupCAMClear = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseGroupCAMClear.setStatus('mandatory')
if mibBuilder.loadTexts: lseGroupCAMClear.setDescription('Value on(1) of this attribute causes the LANSwitch module to clear the CAM tables.')
lseGroupJamPrevent = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseGroupJamPrevent.setStatus('mandatory')
if mibBuilder.loadTexts: lseGroupJamPrevent.setDescription('Jam prevent flag. Functionaly, Jam prevent is a back-pressure into the line direction. There are two modes of opration: 1) automatic - the sensor gets the items status from HW 2) manual - the sensor gets the items status from user.')
lseGroupNormOpCl = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("open", 1), ("closed", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseGroupNormOpCl.setStatus('mandatory')
if mibBuilder.loadTexts: lseGroupNormOpCl.setDescription("Normaly Open/Close flag. When open(1) state is set, the sensor should activate a delay mechanism for the module to operate at Normaly-Closed mode for 30 seconds in order to enable the port's CAM to learn the current segmentation")
lseGroupNormOpDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 1, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 600000)).clone(30)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseGroupNormOpDelay.setStatus('mandatory')
if mibBuilder.loadTexts: lseGroupNormOpDelay.setDescription('When sets to a value greater than 0 (zero) and the MIB item lseGroupNormOpCl is equal to closed(2), this item define the time delay that the module will remain in normally open mode before it will move to normaly close mode. This will be activated after the user will reset the module. The value is in seconds.')
lseGroupAutoPartitionEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("notSupported", 255))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseGroupAutoPartitionEnable.setStatus('mandatory')
if mibBuilder.loadTexts: lseGroupAutoPartitionEnable.setDescription(' Enables autopartition mechanism support in the group level for each port of the group.')
lseGroupWorkState = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 255))).clone(namedValues=NamedValues(("run", 1), ("boot", 2), ("runAndBoot", 3), ("none", 4), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lseGroupWorkState.setStatus('mandatory')
if mibBuilder.loadTexts: lseGroupWorkState.setDescription('One of the possible states of the module: this item indicates if the module is runing or booting. The value runAndBoot(3) indicates a serious software problem.')
lseGroupBITResult = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 1, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("ok", 1), ("faulty", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lseGroupBITResult.setStatus('mandatory')
if mibBuilder.loadTexts: lseGroupBITResult.setDescription("The Bit Indication Test in state 'faulty' indicates a problem. The agent should send a fault trap in this case.")
lseGroupAssignSlots = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 1, 1, 23), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseGroupAssignSlots.setStatus('mandatory')
if mibBuilder.loadTexts: lseGroupAssignSlots.setDescription("In a multi-backbone configuration within a single HUB, this item enables to assign backbone module with specific slot numbers. Only packets from these slots should be handled by the backbone module, Packets from other slots are ignored. The 16-bit string represents the slots in the hub, a Bit per slot. Bit 0 (LSB) corresponds to slot 1, Bit 15 (MSB) corresponds to slot 16. A Bit set to '1' indicates that the corresponding slot is assigned to this backbone module. A clear Bit '0', indicates that the corresponding slot is ignored by this module. Todate, only the LEB200 module supports this capability. The string is expressed in Hex. Default value is FF, i.e., all slots are assigned to module.")
lseGroupHSBMonStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 1, 1, 24), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lseGroupHSBMonStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lseGroupHSBMonStatus.setDescription("This is a bit-masked attribute which displays events which may cause HSB Reset. When a bit is '1', the relevant evet may cause HSB Reset. When a bit is '0', the relevant evet will not cause HSB Reset. The following are the events: LSB D0 - Too many packets were discarded from a queue. D1 - One of the Tx buffers to HSB is full for more than a default period. D2 - Token has not been available for more than a default period. D3 - RX Buffer full in one of the ports. D4 -'1' HSB Reset has been occured , '0'- HSB reset hadn't occured since last time this MIB has been read. D5 - '0' - the ram of the relevant port is O.K. (the port is decode in D6-D7) , '1' The ram is not O.K. D6- D7 Decode the relevant port that It's ram is not O.K 00 - Port no'0 01 - Port no' 1 10 - Port no' 2 11 - Port no' 3.")
lseGroupEnableHSBReset = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 1, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseGroupEnableHSBReset.setStatus('mandatory')
if mibBuilder.loadTexts: lseGroupEnableHSBReset.setDescription('This item enables/disables the HSB Reset mechanism in the module.')
lseIntPort = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 19, 1, 2))
lseIntPortTable = MibTable((1, 3, 6, 1, 4, 1, 81, 19, 1, 2, 1), )
if mibBuilder.loadTexts: lseIntPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortTable.setDescription('')
lseIntPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 19, 1, 2, 1, 1), ).setIndexNames((0, "APPLIC-MIB", "lseIntPortGroupId"), (0, "APPLIC-MIB", "lseIntPortId"))
if mibBuilder.loadTexts: lseIntPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortEntry.setDescription('An entry in the table, containing data about a single internal LanSwitch bank.')
lseIntPortGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lseIntPortGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortGroupId.setDescription('Id of the group to which the port belongs.')
lseIntPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lseIntPortId.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortId.setDescription('Number of LanSwitch port in the board.')
lseIntPortIOMode = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseIntPortIOMode.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortIOMode.setDescription('on(1) activates IO mode in which all packets on the high-speed bus that were not captured by any regular port are captured by the I/O port.')
lseIntPortResetSwitchCAM = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseIntPortResetSwitchCAM.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortResetSwitchCAM.setDescription('Acting like toggle switch thus always returns off(2) on read. When set to on(1), causes the reset of the LANswitch CAM (addresses) memory.')
lseIntPortVideoPacket = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseIntPortVideoPacket.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortVideoPacket.setDescription('When set to on(1), all Tx packets toward the high-speed bus to video type packets.')
lseIntPortPriorityStateMachine = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseIntPortPriorityStateMachine.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortPriorityStateMachine.setDescription('Setting the value of this attribute to on(1) activates the priority mechanism.')
lseIntPortActiveBroadcastPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseIntPortActiveBroadcastPriority.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortActiveBroadcastPriority.setDescription('Setting the value of this attribute to on(1) activates the active broadcast mode in priority mechanism.')
lseIntPortPriorityLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 255))).clone(namedValues=NamedValues(("broadcast", 1), ("multicast", 2), ("video", 3), ("regular", 4), ("default", 5), ("mngrTerminal", 6), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseIntPortPriorityLevel.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortPriorityLevel.setDescription('This attribute defines the priority levels of Tx packets toward the high-speed bus. The highest priority is broadcast(1).')
lseIntPortSuperPriorityEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseIntPortSuperPriorityEnable.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortSuperPriorityEnable.setDescription(' When limited space is left in Tx buffer, only the highest priority packets are accepted. This in turn can create a situation in which one port tries to send a packet and never gets its chance to be accepted. In order to prevent it the destination port counts the successive number of tries of the low priority port, and when a certain (8) number is reached, it accepts the packet anyhow. The value on(1) defines the retry parameter for the priority level mechanism.')
lseIntPortRoutingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 255))).clone(namedValues=NamedValues(("generic", 1), ("net", 2), ("dst-port", 3), ("allPackets", 4), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseIntPortRoutingMode.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortRoutingMode.setDescription("generic(1) - examines all the packets that are not members of any virtual network. net(2) - examines only the packets that have the port's network number. allPackets(4) - examine all packets regardless of their routing mode.")
lseIntPortGlobal = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 2, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseIntPortGlobal.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortGlobal.setDescription('Setting the global mode to on(1) sets the port in a network routing mode that examines all packets that are not members of all virtual networks.')
lseIntPortLearnIOCAM = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 2, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseIntPortLearnIOCAM.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortLearnIOCAM.setDescription('Setting this parameter to on(1) enables an I/O port to learn incoming MAC addresses received in its port and store them in its CAM. Packets with destination address that match the CAM addresses are not transferred to the high speed bus.')
lseIntPortSecurity = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 2, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseIntPortSecurity.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortSecurity.setDescription('Setting the value of this attribute to on(1) activates the security mode.')
lseIntPortIgnoreBusy = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 2, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseIntPortIgnoreBusy.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortIgnoreBusy.setDescription('Setting the value of this attribute to on(1) activates the ignore busy mode. The busy signal toward the high-speed bus is not activated even though the TX buffer is full.')
lseIntPortRetryPriorityLevel1 = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 2, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseIntPortRetryPriorityLevel1.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortRetryPriorityLevel1.setDescription('The port increases the priority level of the high-speed bus packets after the defined number (0..31) trials.')
lseIntPortRetryPriorityLevel2 = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 2, 1, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseIntPortRetryPriorityLevel2.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortRetryPriorityLevel2.setDescription('The port increases the priority level of the high-speed bus packets after the defined number (0..255) trials.')
lseIntPortRetryPriorityLevel3 = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 2, 1, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseIntPortRetryPriorityLevel3.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortRetryPriorityLevel3.setDescription('The port increases the priority level of the high-speed bus packets after the defined number (0..255) trials.')
lseIntPortIgnoreProtocolType = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 2, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("ignore", 1), ("not-ignore", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseIntPortIgnoreProtocolType.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortIgnoreProtocolType.setDescription('Any packet regardless of the protocol type is received from the high-speed bus.')
lseIntPortCompanyMAC = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 2, 1, 1, 19), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseIntPortCompanyMAC.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortCompanyMAC.setDescription('The attribute defines the first three bytes of the MAC address of the video host server.')
lseIntPortTxSafetyZone = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 2, 1, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 510))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseIntPortTxSafetyZone.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortTxSafetyZone.setDescription('Defines the Tx Safety Zone in bits.')
lseIntPortRxSafetyZone = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 2, 1, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 510))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseIntPortRxSafetyZone.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortRxSafetyZone.setDescription('Defines the Rx Safety Zone in bits.')
lseIntPortTxBurstLength = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 2, 1, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 510))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseIntPortTxBurstLength.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortTxBurstLength.setDescription('Defines the TX Burst Length in bits.')
lseIntPortSecurityIntruder = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 2, 1, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lseIntPortSecurityIntruder.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortSecurityIntruder.setDescription('The value on(1) of this attribute reflects a security violation occurrence.')
lseIntPortJabber = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 2, 1, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lseIntPortJabber.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortJabber.setDescription('Value on(1) of this attribute reflects that jabber was transmitted to the port by the high-speed bus.')
lseIntPortCAM = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 2, 1, 1, 25), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 112))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseIntPortCAM.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortCAM.setDescription('112 bytes of MAC addresses. Each contains one byte of the port number and six bytes of the MAC address. This enables to send 16 MAC Addresses ( 16*7=112 bytes)')
lseIntPortVideoStateMachine = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 2, 1, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseIntPortVideoStateMachine.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortVideoStateMachine.setDescription('Setting the value of this attribute to on(1) activates the video state machine mode. Received packets are filtered by demand from the station.')
lseIntPortTransmitWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 2, 1, 1, 27), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseIntPortTransmitWeight.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortTransmitWeight.setDescription('Defines the Transmit Weight of the frames for the current LANswitch port toward the high - speed bus.')
lseIntPortSuperPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 2, 1, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseIntPortSuperPriority.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortSuperPriority.setDescription('Setting the value of this attribute to on(1) activates the retry priority functions.')
lseIntPortAlignment = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 2, 1, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lseIntPortAlignment.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortAlignment.setDescription('The number of alignment errors observed on a specified port.')
lseIntPortRxReject = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 2, 1, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lseIntPortRxReject.setStatus('obsolete')
if mibBuilder.loadTexts: lseIntPortRxReject.setDescription('The number of Rx buffer full observed on a specified port, from the line toward the High-speed bus.')
lseIntPortTxReject = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 2, 1, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lseIntPortTxReject.setStatus('obsolete')
if mibBuilder.loadTexts: lseIntPortTxReject.setDescription('The number of Tx buffer full observed on a specified port, from the line toward the High-speed bus.')
lseIntPortRxEmpty0 = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 2, 1, 1, 32), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseIntPortRxEmpty0.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortRxEmpty0.setDescription('Define the highest threshold to receive packets from the HSB. This parameter is relevant when the receive buffer is full. When the buffer reached this threshold, all packets will be rejected. Version 7.0')
lseIntPortRxEmpty1 = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 2, 1, 1, 33), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseIntPortRxEmpty1.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortRxEmpty1.setDescription('Define the middle threshold to receive packets from the HSB. This parameter is relevant when the receive buffer is almost full. When the buffer reached this threshold, the only packets that the port will receive will be those with the highest priority (1) who were already written in the priority machine. All other packets will be rejected. The space between empty1 to empty0 is reserved to packets with the highest priority (1) who were already written in the priority machine. Version 7.0 ')
lseIntPortRxEmpty2 = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 2, 1, 1, 34), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseIntPortRxEmpty2.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortRxEmpty2.setDescription('Define the lowest threshold to receive packets from the HSB. This parameter is relevant when the receive buffer is almost full. When the buffer reached this threshold, the only packets that the port will receive will be those with at least middle priority (2) who were already written in the priority machine. All other packets will be rejected. The space between empty2 to empty1 is reserved to packets with at least middle priority (2) who were already written in the priority machine. When the buffer did not reached this lowest priority, no packet will be rejected for empty space. Version 7.0 ')
lseIntPortSuperNetNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 2, 1, 1, 35), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 14))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseIntPortSuperNetNumber.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortSuperNetNumber.setDescription('If the internal port supports SuperNet mode, the user have to define the supernet number. Default value is 0. Change of this number when the internal port is Generic, Global or Global SuperNet must be blocked by the sensor.')
lseIntPortGlobalSuperNet = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 2, 1, 1, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseIntPortGlobalSuperNet.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortGlobalSuperNet.setDescription('An internal port that is part of all SuperNets is set to Global SuperNet routing. The SuperNet number is 15 in this case. ')
lseIntPortMACAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 2, 1, 1, 37), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lseIntPortMACAddress.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortMACAddress.setDescription(' The MAC address of the port, if it has. If not, an octet string of length 0. ')
lseIntPortIgnoreRoutingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 2, 1, 1, 38), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("ignore", 1), ("notIgnore", 2), ("notSupported", 255))).clone('notIgnore')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseIntPortIgnoreRoutingMode.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortIgnoreRoutingMode.setDescription(" When this parameter is 'ignore', the LANSwitch port monitors all packets without paying attention to the virtual net assignment.")
lseIntPortCAMLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 2, 1, 1, 39), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lseIntPortCAMLastChange.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortCAMLastChange.setDescription('This attribute contains the value of sysUpTime at the time any change occured to the content of the specific CAM.')
lseIntPortCopiedPort = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 2, 1, 1, 40), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseIntPortCopiedPort.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortCopiedPort.setDescription('The port monitored on the LANswitch bus by the LSE-PM module. The value of this item is: 32*(S-1)+P, where S is the slot number in the hub and P the port within the slot (1.. 32). When the value of this item is 0, the Copy Port function is disabled and the port is in Host Filter mode. For modules that do not support this functionality, this item will have the value 65,535.')
lseIntPortBroadcastBehavior = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 2, 1, 1, 41), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 255))).clone(namedValues=NamedValues(("normal", 1), ("selective", 2), ("receiveAll", 3), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseIntPortBroadcastBehavior.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortBroadcastBehavior.setDescription('This item relates only to LSE-PM modules. The value of this item defines the method by which the module treats broadcast and multicast packets.')
lseIntPortFilteringMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 2, 1, 1, 42), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 255))).clone(namedValues=NamedValues(("source", 1), ("destination", 2), ("sourceOrDestination", 3), ("group", 4), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseIntPortFilteringMethod.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortFilteringMethod.setDescription('This item is relevant only to the LSE-PM module. The value of this item defines the filtering method used to capture packets from the Cellenium bus to the Ethernet connection.')
lseIntPortSetFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 2, 1, 1, 43), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 452))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseIntPortSetFilter.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortSetFilter.setDescription("This item is relevant only to the LSE-PM module. The item is used to add new addresses to the module's filtering table. The string is a sequence of MAC addresses, 6 bytes each. When the item is set, each address in the list is added to the filtering table, and related packets are then captured. This item always returns an empty string in response to get requests.")
lseIntPortRemoveFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 2, 1, 1, 44), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 452))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseIntPortRemoveFilter.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortRemoveFilter.setDescription("This item is relevant only to the LSE-PM module. The item is used to remove existing addresses from the module's filtering table. The string is a sequence of MAC addresses, 6 bytes each. When the item is set, all addresses in the list are removed from the filtering table, and the module stops capturing related packets .")
lseIntPortClearFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 2, 1, 1, 45), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("idle", 1), ("clear", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseIntPortClearFilter.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortClearFilter.setDescription("This item is relevant only to the LSE-PM module. The item acts as a toggle switch: when its value is set to clear(2), the contents of the module's filtering tables are cleared. This item always returns an empty string in response to get requests.")
lseIntPortMonitorMissedEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 2, 1, 1, 46), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lseIntPortMonitorMissedEvents.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortMonitorMissedEvents.setDescription("This item is relevant only to LSE-PM modules. The value of the counter is the number of packets that were not captured by the port as a result of overload on the Ethernet line, though the port's filter was configured to capture these packets.")
lseIntPortMACAdd = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 19, 1, 2, 2))
lseIntPortMACAddTable = MibTable((1, 3, 6, 1, 4, 1, 81, 19, 1, 2, 2, 1), )
if mibBuilder.loadTexts: lseIntPortMACAddTable.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortMACAddTable.setDescription('')
lseIntPortMACAddEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 19, 1, 2, 2, 1, 1), ).setIndexNames((0, "APPLIC-MIB", "lseIntPortMACAddGroupId"), (0, "APPLIC-MIB", "lseIntPortMACAddPortId"), (0, "APPLIC-MIB", "lseIntPortMACAddLAId"))
if mibBuilder.loadTexts: lseIntPortMACAddEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortMACAddEntry.setDescription('An entry in the table containing data about a single internal switch port.')
lseIntPortMACAddGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 2, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lseIntPortMACAddGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortMACAddGroupId.setDescription('Id of the group to which the port belongs.')
lseIntPortMACAddPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 2, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lseIntPortMACAddPortId.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortMACAddPortId.setDescription('The LANswitch port number in the board.')
lseIntPortMACAddLAId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 2, 2, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lseIntPortMACAddLAId.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortMACAddLAId.setDescription('The lower 2 bytes of the Last MAC Address on the previous list. Use the 0 value to start from the beginning of the list.')
lseIntPortMACAddList = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 2, 2, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 452))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lseIntPortMACAddList.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortMACAddList.setDescription('This item contains MAC address (source addresses) of the port. Each MAC address is 6 bytes long. The list is started with the MAC address that follows the lseIntPortMACAddLAId.')
lseIntPortFilter = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 19, 1, 2, 3))
lseIntPortFilterTable = MibTable((1, 3, 6, 1, 4, 1, 81, 19, 1, 2, 3, 1), )
if mibBuilder.loadTexts: lseIntPortFilterTable.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortFilterTable.setDescription('')
lseIntPortFilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 19, 1, 2, 3, 1, 1), ).setIndexNames((0, "APPLIC-MIB", "lseIntPortFilterGroupId"), (0, "APPLIC-MIB", "lseIntPortFilterPortId"), (0, "APPLIC-MIB", "lseIntPortFilterLAId"))
if mibBuilder.loadTexts: lseIntPortFilterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortFilterEntry.setDescription("This table is supported only for the LSE-PM module. The table reports the contents of the port's filtering mechanism.")
lseIntPortFilterGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 2, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lseIntPortFilterGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortFilterGroupId.setDescription('This item is relevant only for the LSE-PM module. The item defines the group to which the port belongs (i.e., the module number).')
lseIntPortFilterPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 2, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lseIntPortFilterPortId.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortFilterPortId.setDescription('This item is relevant only for the LSE-PM module. The item defines the number of the LANswitch port in the board.')
lseIntPortFilterLAId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 2, 3, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lseIntPortFilterLAId.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortFilterLAId.setDescription('This item is relevant only for the LSE-PM module. The item contains the lower 2 bytes of the Last MAC Address on the previous list. Use the 0 value to start from the beginning of the list.')
lseIntPortFilterList = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 2, 3, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 452))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lseIntPortFilterList.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortFilterList.setDescription('This item is relevant only for the LSE-PM module. The item contains the MAC addresses in the filter. Each MAC address is 6 bytes long. The list is started with the MAC address that follows the lseIntPortFilterLAId.')
lsePort = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 19, 1, 3))
lsePortTable = MibTable((1, 3, 6, 1, 4, 1, 81, 19, 1, 3, 1), )
if mibBuilder.loadTexts: lsePortTable.setStatus('mandatory')
if mibBuilder.loadTexts: lsePortTable.setDescription('')
lsePortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 19, 1, 3, 1, 1), ).setIndexNames((0, "APPLIC-MIB", "lsePortGroupId"), (0, "APPLIC-MIB", "lsePortId"))
if mibBuilder.loadTexts: lsePortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lsePortEntry.setDescription('An entry in the table containing data about a single external switch port.')
lsePortGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsePortGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: lsePortGroupId.setDescription('Id of the group to which the port belongs.')
lsePortId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsePortId.setStatus('mandatory')
if mibBuilder.loadTexts: lsePortId.setDescription('Number of LanSwitch port in the board.')
lsePortPolarity = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lsePortPolarity.setStatus('mandatory')
if mibBuilder.loadTexts: lsePortPolarity.setDescription('Setting the value of this attribute to ON activates the automatic port polarity detection mode.')
lsePortBackboneStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 1, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("ok", 1), ("fault", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lsePortBackboneStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lsePortBackboneStatus.setDescription('It is the status of a single port that associated with a particular Backbone port. It is utilized by the Agent in the Soft Redundancy algorithm between Backbone ports in LANswitch environment')
lhsGroupTable = MibTable((1, 3, 6, 1, 4, 1, 81, 19, 2, 1), )
if mibBuilder.loadTexts: lhsGroupTable.setStatus('mandatory')
if mibBuilder.loadTexts: lhsGroupTable.setDescription('Table with group-related parameters.')
lhsGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 19, 2, 1, 1), ).setIndexNames((0, "APPLIC-MIB", "lhsGroupId"))
if mibBuilder.loadTexts: lhsGroupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lhsGroupEntry.setDescription('Entry in the table.')
lhsGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lhsGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: lhsGroupId.setDescription('Unique slot identifier in which the module is located.')
lhsGroupMainSWVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lhsGroupMainSWVersion.setStatus('mandatory')
if mibBuilder.loadTexts: lhsGroupMainSWVersion.setDescription('Software version of the main CPU.')
lhsGroupProtocolType = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 255))).clone(namedValues=NamedValues(("other", 1), ("ethernet", 2), ("tokenring", 3), ("ethernet-tokenring", 4), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lhsGroupProtocolType.setStatus('mandatory')
if mibBuilder.loadTexts: lhsGroupProtocolType.setDescription('This attribute set the protocol type in which the LHB is collecting from the high-speed bus.')
lhsPortTable = MibTable((1, 3, 6, 1, 4, 1, 81, 19, 2, 2), )
if mibBuilder.loadTexts: lhsPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: lhsPortTable.setDescription('Table with port-related parameters.')
lhsPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 19, 2, 2, 1), ).setIndexNames((0, "APPLIC-MIB", "lhsPortGroupId"), (0, "APPLIC-MIB", "lhsPortId"))
if mibBuilder.loadTexts: lhsPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lhsPortEntry.setDescription('Entry in the table.')
lhsPortGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lhsPortGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: lhsPortGroupId.setDescription('Slot index in which the module is located.')
lhsPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 2, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lhsPortId.setStatus('mandatory')
if mibBuilder.loadTexts: lhsPortId.setDescription('Port number to which the data is related.')
lhsTxUCast = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 2, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lhsTxUCast.setStatus('mandatory')
if mibBuilder.loadTexts: lhsTxUCast.setDescription(' Number of unicast packets transmitted.')
lhsTxBCast = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 2, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lhsTxBCast.setStatus('mandatory')
if mibBuilder.loadTexts: lhsTxBCast.setDescription(' Number of broadcast packets transmitted.')
lhsTxMCast = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 2, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lhsTxMCast.setStatus('mandatory')
if mibBuilder.loadTexts: lhsTxMCast.setDescription(' Number of multicast packets transmitted.')
lhsTxUrunErr = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 2, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lhsTxUrunErr.setStatus('mandatory')
if mibBuilder.loadTexts: lhsTxUrunErr.setDescription(' Number of transmit packet underruns.')
lhsTxParErr = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 2, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lhsTxParErr.setStatus('mandatory')
if mibBuilder.loadTexts: lhsTxParErr.setDescription(' Number of transmit packet parity errors.')
lhsRxUCast = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 2, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lhsRxUCast.setStatus('mandatory')
if mibBuilder.loadTexts: lhsRxUCast.setDescription(' Number of unicast packets received.')
lhsRxBCast = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 2, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lhsRxBCast.setStatus('mandatory')
if mibBuilder.loadTexts: lhsRxBCast.setDescription(' Number of broadcast packets received.')
lhsRxMCast = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 2, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lhsRxMCast.setStatus('mandatory')
if mibBuilder.loadTexts: lhsRxMCast.setDescription(' Number of multicast packets received.')
lhsRxOrunErr = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 2, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lhsRxOrunErr.setStatus('mandatory')
if mibBuilder.loadTexts: lhsRxOrunErr.setDescription(' Number of receive overrun errors.')
lhsRxParErr = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 2, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lhsRxParErr.setStatus('mandatory')
if mibBuilder.loadTexts: lhsRxParErr.setDescription(' Number of receive parity errors.')
lhsRxRscErr = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 2, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lhsRxRscErr.setStatus('mandatory')
if mibBuilder.loadTexts: lhsRxRscErr.setDescription(' Number of receive resource errors. ')
lhsRxBadTypeErr = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 2, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lhsRxBadTypeErr.setStatus('mandatory')
if mibBuilder.loadTexts: lhsRxBadTypeErr.setDescription(' Number of bad frame type packets received.')
lhsLinkStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 2, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("ok", 1), ("linkFailure", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lhsLinkStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lhsLinkStatus.setDescription('This attribute describes the status of the optical link as detected by the sensor software.')
lsMonitorResourceAllocation = MibScalar((1, 3, 6, 1, 4, 1, 81, 19, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("hostStats", 2), ("portExtendedStats", 3), ("hostMatrix", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsMonitorResourceAllocation.setStatus('mandatory')
if mibBuilder.loadTexts: lsMonitorResourceAllocation.setDescription('This item reports for which of the listed monitoring activity CPU resources are being allocated at this time. Activities that are not in the above list are allocated resources at all times.')
lsBusStats = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 19, 3, 2))
lsBusStatsDropEvents = MibScalar((1, 3, 6, 1, 4, 1, 81, 19, 3, 2, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsBusStatsDropEvents.setStatus('mandatory')
if mibBuilder.loadTexts: lsBusStatsDropEvents.setDescription('The total number of events in which packets were dropped by the probe due to lack of resources. Note that this number is not necessarily the number of packets dropped; it is just the number of times this condition has been detected.')
lsBusStatsPkts = MibScalar((1, 3, 6, 1, 4, 1, 81, 19, 3, 2, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsBusStatsPkts.setStatus('mandatory')
if mibBuilder.loadTexts: lsBusStatsPkts.setDescription('The total number of packets (including error packets) received on the LANswitch bus.')
lsBusStatsOctets = MibScalar((1, 3, 6, 1, 4, 1, 81, 19, 3, 2, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsBusStatsOctets.setStatus('mandatory')
if mibBuilder.loadTexts: lsBusStatsOctets.setDescription('The total number of octets of data (including those in bad packets) received on the LANswitch bus (excluding framing bits but including FCS octets).')
lsBusStatsUtilization = MibScalar((1, 3, 6, 1, 4, 1, 81, 19, 3, 2, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsBusStatsUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: lsBusStatsUtilization.setDescription('The utilization of the LANswitch bus, expressed in percents of the maximum possible LANswitch traffic.')
lsBusStatsEthBroadcastPkts = MibScalar((1, 3, 6, 1, 4, 1, 81, 19, 3, 2, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsBusStatsEthBroadcastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: lsBusStatsEthBroadcastPkts.setDescription('The total number of good Ethernet packets received that were directed to the broadcast address.')
lsBusStatsMulticastPkts = MibScalar((1, 3, 6, 1, 4, 1, 81, 19, 3, 2, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsBusStatsMulticastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: lsBusStatsMulticastPkts.setDescription('The total number of good packets received that were directed to a multicast address. Note that this number does not include packets directed to the broadcast address.')
lsBusStatsGoodEthPkts = MibScalar((1, 3, 6, 1, 4, 1, 81, 19, 3, 2, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsBusStatsGoodEthPkts.setStatus('mandatory')
if mibBuilder.loadTexts: lsBusStatsGoodEthPkts.setDescription('The total number of good Ethernet packets received on the LANswitch bus.')
lsBusStatsGoodEthOctets = MibScalar((1, 3, 6, 1, 4, 1, 81, 19, 3, 2, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsBusStatsGoodEthOctets.setStatus('mandatory')
if mibBuilder.loadTexts: lsBusStatsGoodEthOctets.setDescription('The total number of octets that were received on the LANswitch bus in good Ethernet packets (excluding framing bits but including FCS octets).')
lsBusStatsBadEthPkts = MibScalar((1, 3, 6, 1, 4, 1, 81, 19, 3, 2, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsBusStatsBadEthPkts.setStatus('mandatory')
if mibBuilder.loadTexts: lsBusStatsBadEthPkts.setDescription('The total number of bad Ethernet packets received on the LANswitch bus.')
lsBusStatsBadEthOctets = MibScalar((1, 3, 6, 1, 4, 1, 81, 19, 3, 2, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsBusStatsBadEthOctets.setStatus('mandatory')
if mibBuilder.loadTexts: lsBusStatsBadEthOctets.setDescription('The total number of octets that were received on the LANswitch bus in bad Ethernet packets (excluding framing bits but including FCS octets).')
lsBusStatsNonEthPkts = MibScalar((1, 3, 6, 1, 4, 1, 81, 19, 3, 2, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsBusStatsNonEthPkts.setStatus('mandatory')
if mibBuilder.loadTexts: lsBusStatsNonEthPkts.setDescription('The total number of packets received on the LANswitch bus in non Ethernet packets.')
lsBusStatsNonEthOctets = MibScalar((1, 3, 6, 1, 4, 1, 81, 19, 3, 2, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsBusStatsNonEthOctets.setStatus('mandatory')
if mibBuilder.loadTexts: lsBusStatsNonEthOctets.setDescription('The total number of octets that were received on the LANswitch bus in non Ethernet packets (excluding framing bits but including FCS octets).')
lsBusStatsPriorityTable = MibTable((1, 3, 6, 1, 4, 1, 81, 19, 3, 2, 13), )
if mibBuilder.loadTexts: lsBusStatsPriorityTable.setStatus('mandatory')
if mibBuilder.loadTexts: lsBusStatsPriorityTable.setDescription('A list of priority count entries.')
lsBusStatsPriorityEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 19, 3, 2, 13, 1), ).setIndexNames((0, "APPLIC-MIB", "lsBusStatsPriorityIndex"))
if mibBuilder.loadTexts: lsBusStatsPriorityEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lsBusStatsPriorityEntry.setDescription('A list of statistics related to a specific priority level on the LANswitch bus.')
lsBusStatsPriorityIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 3, 2, 13, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsBusStatsPriorityIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lsBusStatsPriorityIndex.setDescription('The priority for which this entry reports statistics .')
lsBusStatsPriorityPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 3, 2, 13, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsBusStatsPriorityPkts.setStatus('mandatory')
if mibBuilder.loadTexts: lsBusStatsPriorityPkts.setDescription('The total number of packets (including error packets) received on the LANswitch bus whose priority is that defined for this entry.')
lsBusStatsPriorityOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 3, 2, 13, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsBusStatsPriorityOctets.setStatus('mandatory')
if mibBuilder.loadTexts: lsBusStatsPriorityOctets.setDescription('The total number of octets (including error packets) received on the LANswitch bus whose packets have the priority defined for this entry.')
lsBusStatsVirtualNetList = MibScalar((1, 3, 6, 1, 4, 1, 81, 19, 3, 2, 14), OctetString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsBusStatsVirtualNetList.setStatus('mandatory')
if mibBuilder.loadTexts: lsBusStatsVirtualNetList.setDescription('A bitmap defining the status of the virtual nets in the Virtual NetTable. The first bit is for Virtual Net 0 and so on. For existing virtual nets the bit is 1, otherwise 0.')
lsBusStatsVirtualNetTable = MibTable((1, 3, 6, 1, 4, 1, 81, 19, 3, 2, 15), )
if mibBuilder.loadTexts: lsBusStatsVirtualNetTable.setStatus('mandatory')
if mibBuilder.loadTexts: lsBusStatsVirtualNetTable.setDescription('A list of virtual net statistics.')
lsBusStatsVirtualNetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 19, 3, 2, 15, 1), ).setIndexNames((0, "APPLIC-MIB", "lsBusStatsVirtualNet"))
if mibBuilder.loadTexts: lsBusStatsVirtualNetEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lsBusStatsVirtualNetEntry.setDescription('A list of staistics related to a specific virtual net which exists on the LANswitch bus.')
lsBusStatsVirtualNet = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 3, 2, 15, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsBusStatsVirtualNet.setStatus('mandatory')
if mibBuilder.loadTexts: lsBusStatsVirtualNet.setDescription('The virtual net for which this entry reports statistics .')
lsBusStatsVirtualNetPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 3, 2, 15, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsBusStatsVirtualNetPackets.setStatus('mandatory')
if mibBuilder.loadTexts: lsBusStatsVirtualNetPackets.setDescription('The number of good packets that were transmitted to this virtual net by ports in this hub.')
lsBusStatsVirtualNetOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 3, 2, 15, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsBusStatsVirtualNetOctets.setStatus('mandatory')
if mibBuilder.loadTexts: lsBusStatsVirtualNetOctets.setDescription('The number of octets in good packets that were transmitted to this virtual net by ports in this hub.')
lsPortStats = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 19, 3, 3))
lsPortControlTable = MibTable((1, 3, 6, 1, 4, 1, 81, 19, 3, 3, 1), )
if mibBuilder.loadTexts: lsPortControlTable.setStatus('mandatory')
if mibBuilder.loadTexts: lsPortControlTable.setDescription('A list of port control entries.')
lsPortControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 19, 3, 3, 1, 1), ).setIndexNames((0, "APPLIC-MIB", "lsPortControlIndex"))
if mibBuilder.loadTexts: lsPortControlEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lsPortControlEntry.setDescription('A list of parameters that set up the collection of extended statistics related to LANswitch ports. Data is collected in the lsPortExtendedStatsTable.')
lsPortControlIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 3, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsPortControlIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lsPortControlIndex.setDescription('An index that uniquely identifies an entry in the lsPortControlTable. Each such entry defines a function that monitors ports and places statistics about them in the portTable on behalf of this lsPortControlEntry.')
lsPortControlDataSource = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 3, 3, 1, 1, 2), ObjectIdentifier()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lsPortControlDataSource.setStatus('mandatory')
if mibBuilder.loadTexts: lsPortControlDataSource.setDescription('This object identifies the source of the data for this instance of the port function. The statistics in this group reflect all packets on the LANswitch bus that are trasferred by the lsPortFilterTable. This object may not be modified if the associated lsPortControlStatus object is equal to valid(1).')
lsPortControlTableSize = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 3, 3, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsPortControlTableSize.setStatus('mandatory')
if mibBuilder.loadTexts: lsPortControlTableSize.setDescription('The number of ports for which SW counters are collected by the agent. This number is limited to 5.')
lsPortControlLastDeleteTime = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 3, 3, 1, 1, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsPortControlLastDeleteTime.setStatus('mandatory')
if mibBuilder.loadTexts: lsPortControlLastDeleteTime.setDescription('The value of sysUpTime when the last entry was deleted from the portion of the portTable associated with this lsPortControlEntry. If no deletions have occurred, this value shall be zero.')
lsPortControlOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 3, 3, 1, 1, 5), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lsPortControlOwner.setStatus('mandatory')
if mibBuilder.loadTexts: lsPortControlOwner.setDescription('The entity that configured this entry and is therefore using the resources assigned to it.')
lsPortControlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 3, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("valid", 1), ("createRequest", 2), ("underCreation", 3), ("invalid", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lsPortControlStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lsPortControlStatus.setDescription('The status of this lsPortControl entry. If this object is not equal to valid(1), all associated entries in the lsPortTable, shall be deleted by the agent.')
lsPortFilterTable = MibTable((1, 3, 6, 1, 4, 1, 81, 19, 3, 3, 2), )
if mibBuilder.loadTexts: lsPortFilterTable.setStatus('mandatory')
if mibBuilder.loadTexts: lsPortFilterTable.setDescription('A list of LANswitch ports to be monitored on the high-speed bus. The OID of this table is a legitimate value for the lsPortControlDataSource. When this OID is a source for the host table, a port in the table has the same meaning as an instruction to the agent to collect statistics for all the hosts connected to that port. The maximum size of this table is 5 entries')
lsPortFilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 19, 3, 3, 2, 1), ).setIndexNames((0, "APPLIC-MIB", "lsPortFilter"))
if mibBuilder.loadTexts: lsPortFilterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lsPortFilterEntry.setDescription('An entry in the filter table.')
lsPortFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 3, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsPortFilter.setStatus('mandatory')
if mibBuilder.loadTexts: lsPortFilter.setDescription('The port monitored on the LANswitch bus. The value of this item is: (16*S-1)+P, where S is the slot number in the hub (1..16) and P the port within the slot (1..N).')
lsPortFilterStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 3, 3, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lsPortFilterStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lsPortFilterStatus.setDescription('The status of this lsPortFilter entry. When the status is valid, the port defined in the corresponding lsPortFilter is a part of the filter.')
lsPortFilterTableClear = MibScalar((1, 3, 6, 1, 4, 1, 81, 19, 3, 3, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("idle", 1), ("clear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lsPortFilterTableClear.setStatus('mandatory')
if mibBuilder.loadTexts: lsPortFilterTableClear.setDescription('Setting the value of this item to clear(2) causes the agent to clear all entries in the PortFilterTable.')
lsPortTable = MibTable((1, 3, 6, 1, 4, 1, 81, 19, 3, 3, 4), )
if mibBuilder.loadTexts: lsPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: lsPortTable.setDescription('A list of port entries. Each entry contains statistical data pertaining to a single port. An entry is maintained at all times for each of the LANswitch ports that exist in the hub. This table is not controlled by the lsPortControlTable.')
lsPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 19, 3, 3, 4, 1), ).setIndexNames((0, "APPLIC-MIB", "lsPortNumber"))
if mibBuilder.loadTexts: lsPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lsPortEntry.setDescription('A collection of statistics for a particular LANswitch port.')
lsPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 3, 3, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsPortNumber.setStatus('mandatory')
if mibBuilder.loadTexts: lsPortNumber.setDescription('The monitored port. The value of this item is: 16*(S-1)+P, where S is the slot number in the hub (1..16) and P the port within the slot (1..N).')
lsPortInPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 3, 3, 4, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsPortInPkts.setStatus('mandatory')
if mibBuilder.loadTexts: lsPortInPkts.setDescription('The number of good packets transmitted through this port into the LANswitch bus .')
lsPortInFCSErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 3, 3, 4, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsPortInFCSErrors.setStatus('mandatory')
if mibBuilder.loadTexts: lsPortInFCSErrors.setDescription('The number of packets with FCS errors transmitted through this port into the LANswitch bus .')
lsPortInTooLongPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 3, 3, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsPortInTooLongPkts.setStatus('mandatory')
if mibBuilder.loadTexts: lsPortInTooLongPkts.setDescription('The number of packets longer than 1518 bytes transmitted through this port into the LANswitch bus .')
lsPortInOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 3, 3, 4, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsPortInOctets.setStatus('mandatory')
if mibBuilder.loadTexts: lsPortInOctets.setDescription('The number of octets in good packets (excluding framing bits but including FCS octets) transmitted through this port into the LANswitch bus .')
lsPortInTotalErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 3, 3, 4, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsPortInTotalErrors.setStatus('mandatory')
if mibBuilder.loadTexts: lsPortInTotalErrors.setDescription('This item is a summation of all errors on this port. It contains the total hardware errors related to a specific port.')
lsPortInCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 3, 3, 4, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsPortInCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: lsPortInCollisions.setDescription('This counter is incremented by one for any CarrierEvent signal on the port for which the CollisionEvent signal on this port is also asserted.')
lsPortExtendedReportingList = MibScalar((1, 3, 6, 1, 4, 1, 81, 19, 3, 3, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsPortExtendedReportingList.setStatus('mandatory')
if mibBuilder.loadTexts: lsPortExtendedReportingList.setDescription('A list of all ports in the hub for which Extended statistics are currently reported. 16 bits in the bitmap are allocated for each slot in the hub. The MSB is for port 1 of slot 1, and the LSB is for port 16 of slot 16. The bit representing ports for which extended statistics are now reported has the value of 1, otherwise 0.')
lsPortExtendedStatsTable = MibTable((1, 3, 6, 1, 4, 1, 81, 19, 3, 3, 6), )
if mibBuilder.loadTexts: lsPortExtendedStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: lsPortExtendedStatsTable.setDescription('A list of port entries.')
lsPortExtendedStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 19, 3, 3, 6, 1), ).setIndexNames((0, "APPLIC-MIB", "lsPortExtendedStatsNumber"))
if mibBuilder.loadTexts: lsPortExtendedStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lsPortExtendedStatsEntry.setDescription('A collection of statistics for a particular LANswitch port.')
lsPortExtendedStatsNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 3, 3, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsPortExtendedStatsNumber.setStatus('mandatory')
if mibBuilder.loadTexts: lsPortExtendedStatsNumber.setDescription('The monitored port.The value of this item is: 16*(S-1)+P, where S is the slot number in the hub (1..16) and P the port within the slot (1..N).')
lsPortCreationOrder = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 3, 3, 6, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsPortCreationOrder.setStatus('mandatory')
if mibBuilder.loadTexts: lsPortCreationOrder.setDescription("An index that defines the relative ordering of the discovery time of ports captured for a particular lsPortControlEntry. This index shall be between 1 and N, where N is the value of the associated lsPortControlTableSize. The ordering of the indexes is based on the order of each entry's insertion into the table, in which entries added earlier have a lower index value than entries added later. It is important to note that the order for a particular entry may change as an (earlier) entry is deleted from the table. Because this order may change, management stations should make use of the lsPortControlLastDeleteTime variable in the lsPortControlEntry associated with the relevant portion of the lsPortTable. By observing this variable, the management station may detect the circumstances where a previous association between a value of lsPortCreationOrder and a lsPortEntry may no longer hold.")
lsPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 3, 3, 6, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lsPortIndex.setDescription('The set of collected port statistics of which this entry is a part. The set of ports identified by a particular value of this index is associated with the lsPortControlEntry as identified by the same value of lsPortControlIndex.')
lsPortOutPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 3, 3, 6, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsPortOutPkts.setStatus('mandatory')
if mibBuilder.loadTexts: lsPortOutPkts.setDescription('The number of packets without errors transmitted from the LANswitch bus to this port.')
lsPortInBroadcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 3, 3, 6, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsPortInBroadcastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: lsPortInBroadcastPkts.setDescription('The number of good Ethernet packets directed towards the broadcast address that were transmitted to the LANswitch bus through this port.')
lsPortInMulticastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 3, 3, 6, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsPortInMulticastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: lsPortInMulticastPkts.setDescription('The number of good Ethernet packets directed to a multicast address that were transmitted to the LANswitch bus through this port.')
lsHostFilterTable = MibTable((1, 3, 6, 1, 4, 1, 81, 19, 3, 4), )
if mibBuilder.loadTexts: lsHostFilterTable.setStatus('mandatory')
if mibBuilder.loadTexts: lsHostFilterTable.setDescription('A list of hosts to be monitored on the high-speed bus by the RMON MIB hosts group. The OID of this table is a legitimate value for the hostControlDataSource. The size of the table is limited to 200 entries.')
lsHostFilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 19, 3, 4, 1), ).setIndexNames((0, "APPLIC-MIB", "lsHostFilterAddress"))
if mibBuilder.loadTexts: lsHostFilterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lsHostFilterEntry.setDescription('An entry in the filter table.')
lsHostFilterAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 3, 4, 1, 1), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsHostFilterAddress.setStatus('mandatory')
if mibBuilder.loadTexts: lsHostFilterAddress.setDescription('The MAC address of a host monitored on the high-speed bus.')
lsHostFilterStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 3, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lsHostFilterStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lsHostFilterStatus.setDescription('The status of this lsHostFilter entry. When the status is valid, the host defined in the corresponding lsHostFilter is a part of the filter.')
lsHostFilterTableClear = MibScalar((1, 3, 6, 1, 4, 1, 81, 19, 3, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("idle", 1), ("clear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lsHostFilterTableClear.setStatus('mandatory')
if mibBuilder.loadTexts: lsHostFilterTableClear.setDescription('Setting the value of this item to clear(2) causes the agent to clear all entries in the HostFilterTable.')
lsHostPortFilterTable = MibTable((1, 3, 6, 1, 4, 1, 81, 19, 3, 6), )
if mibBuilder.loadTexts: lsHostPortFilterTable.setStatus('mandatory')
if mibBuilder.loadTexts: lsHostPortFilterTable.setDescription('A list of ports to be monitored on the high-speed bus. The OID of this table is a legitimate value for the hostControlDataSource. When this OID is a source for the host table, a port in the table has the same meaning as an instruction to the agent to collect statistics for all the hosts connected to that port. The size of this table is limited to 5 entries.')
lsHostPortFilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 19, 3, 6, 1), ).setIndexNames((0, "APPLIC-MIB", "lsHostPortFilter"))
if mibBuilder.loadTexts: lsHostPortFilterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lsHostPortFilterEntry.setDescription('An entry in the filter table.')
lsHostPortFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 3, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsHostPortFilter.setStatus('mandatory')
if mibBuilder.loadTexts: lsHostPortFilter.setDescription('The port monitored on the LANswitch bus. The value of this item is: 16*(S-1)+P, where S is the slot number in the hub (1..16) and P the port within the slot (1..N).')
lsHostPortFilterStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 3, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lsHostPortFilterStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lsHostPortFilterStatus.setDescription('The status of this lsHostPortFilter entry. When the status is valid, the hosts defined by the corresponding lsHostPortFilter are a part of the filter.')
lsHostPortFilterTableClear = MibScalar((1, 3, 6, 1, 4, 1, 81, 19, 3, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("idle", 1), ("clear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lsHostPortFilterTableClear.setStatus('mandatory')
if mibBuilder.loadTexts: lsHostPortFilterTableClear.setDescription('Setting the value of this item to clear(2) causes the agent to clear all entries in the HostPortFilterTable.')
lsMatrixFilterTable = MibTable((1, 3, 6, 1, 4, 1, 81, 19, 3, 8), )
if mibBuilder.loadTexts: lsMatrixFilterTable.setStatus('mandatory')
if mibBuilder.loadTexts: lsMatrixFilterTable.setDescription('A list of hosts to be monitored on the high-speed bus by the RMON MIB matrix group. The OID of this table is a legitimate value for the hostControlDataSource. The size of the table is limited to 200 entries.')
lsMatrixFilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 19, 3, 8, 1), ).setIndexNames((0, "APPLIC-MIB", "lsMatrixFilterAddress"))
if mibBuilder.loadTexts: lsMatrixFilterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lsMatrixFilterEntry.setDescription('An entry in the filter table.')
lsMatrixFilterAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 3, 8, 1, 1), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsMatrixFilterAddress.setStatus('mandatory')
if mibBuilder.loadTexts: lsMatrixFilterAddress.setDescription('The MAC address of a host monitored on the high-speed bus.')
lsMatrixFilterStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 3, 8, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lsMatrixFilterStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lsMatrixFilterStatus.setDescription('The status of this lsMatrixFilter entry. When the status is valid, the hosts defined by the corresponding lsMatrixFilter are a part of the filter.')
lsMatrixFilterTableClear = MibScalar((1, 3, 6, 1, 4, 1, 81, 19, 3, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("idle", 1), ("clear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lsMatrixFilterTableClear.setStatus('mandatory')
if mibBuilder.loadTexts: lsMatrixFilterTableClear.setDescription('Setting the value of this item to clear(2) causes the agent to clear all entries in the MatrixFilterTable.')
lsHostTimePortCorrTable = MibTable((1, 3, 6, 1, 4, 1, 81, 19, 3, 10), )
if mibBuilder.loadTexts: lsHostTimePortCorrTable.setStatus('mandatory')
if mibBuilder.loadTexts: lsHostTimePortCorrTable.setDescription('An addition to the RMON MIBs hostTimeTable. This table contains a list of MAC addresses that were monitored on the high-speed bus and the switch ports to which they are connected. The index of this table is the same as for the standard RMON hostTimeTable. Indexes are hostTimeCreationOrder and hostTimeIndex. The MAC address is stored in hostTimeAddress. The port to which the MAC address is connected hostTimePortConnection.')
lsHostTimePortCorrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 19, 3, 10, 1), ).setIndexNames((0, "APPLIC-MIB", "hostTimeIndex"), (0, "APPLIC-MIB", "hostTimeCreationOrder"))
if mibBuilder.loadTexts: lsHostTimePortCorrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lsHostTimePortCorrEntry.setDescription('An entry in the MAC to port correlation table.')
hostTimeAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 3, 10, 1, 1), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostTimeAddress.setStatus('mandatory')
if mibBuilder.loadTexts: hostTimeAddress.setDescription('The physical address of this host.')
hostTimeCreationOrder = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 3, 10, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostTimeCreationOrder.setStatus('mandatory')
if mibBuilder.loadTexts: hostTimeCreationOrder.setDescription("An index that uniquely identifies an entry in the hostTime table among those entries associated with the same hostControlEntry. This index shall be between 1 and N, where N is the value of the associated hostControlTableSize. The ordering of the indexes is based on the order of each entry's insertion into the table, in which entries added earlier have a lower index value than entries added later. Thus the management station has the ability to learn of new entries added to this table without downloading the entire table. It is important to note that the index for a particular entry may change as an (earlier) entry is deleted from the table. Because this order may change, management stations should make use of the hostControlLastDeleteTime variable in the hostControlEntry associated with the relevant portion of the hostTimeTable. By observing this variable, the management station may detect the circumstances where a download of the table may have missed entries, and where a previous association between a value of hostTimeCreationOrder and a hostTimeEntry may no longer hold.")
hostTimeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 3, 10, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostTimeIndex.setStatus('mandatory')
if mibBuilder.loadTexts: hostTimeIndex.setDescription('The set of collected host statistics of which this entry is a part. The set of hosts identified by a particular value of this index is associated with the hostControlEntry as identified by the same value of hostControlIndex.')
hostTimePortConnection = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 3, 10, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostTimePortConnection.setStatus('mandatory')
if mibBuilder.loadTexts: hostTimePortConnection.setDescription('The switch port to which this hostTimeAddress is connected. The coding of the port number varies for different hubs and packplanes. For the LANSwitch HSB the value of this item is: The value of this item is: 32*(S-1)+P, where S is the slot number in the hub and P the LANswitch port within the slot (1.. 32). For hosts whose port connection is not identified by the agent, the value of this item will be 65,535 ')
lsHistoryTable = MibTable((1, 3, 6, 1, 4, 1, 81, 19, 3, 11), )
if mibBuilder.loadTexts: lsHistoryTable.setStatus('mandatory')
if mibBuilder.loadTexts: lsHistoryTable.setDescription('A list of High Speed Bus history entries.')
lsHistoryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 19, 3, 11, 1), ).setIndexNames((0, "APPLIC-MIB", "lsHistoryIndex"), (0, "APPLIC-MIB", "lsHistorySampleIndex"))
if mibBuilder.loadTexts: lsHistoryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lsHistoryEntry.setDescription('An historical sample of LANswitch statistics on a HSB. This sample is associated with the historyControlEntry which set up the parameters for a regular collection of these samples. ')
lsHistoryIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 3, 11, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsHistoryIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lsHistoryIndex.setDescription('The history of which this entry is a part. The history identified by a particular value of this index is the same history as identified by the same value of historyControlIndex.')
lsHistorySampleIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 3, 11, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsHistorySampleIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lsHistorySampleIndex.setDescription('An index that uniquely identifies the particular sample this entry represents among all samples associated with the same lshistoryControlEntry. This index starts at 1 and increases by one as each new sample is taken.')
lsHistoryIntervalTime = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 3, 11, 1, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsHistoryIntervalTime.setStatus('mandatory')
if mibBuilder.loadTexts: lsHistoryIntervalTime.setDescription('The value of sysUpTime when this bucket was sampled .')
lsHistoryStatsDropEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 3, 11, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsHistoryStatsDropEvents.setStatus('mandatory')
if mibBuilder.loadTexts: lsHistoryStatsDropEvents.setDescription('The total number of events in which packets were dropped by the probe due to lack of resources. Note that this number is not necessarily the number of packets dropped; it is just the number of times this condition has been detected.')
lsHistoryStatsPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 3, 11, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsHistoryStatsPkts.setStatus('mandatory')
if mibBuilder.loadTexts: lsHistoryStatsPkts.setDescription('The total number of packets (including error packets) received on the LANswitch bus.')
lsHistoryStatsOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 3, 11, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsHistoryStatsOctets.setStatus('mandatory')
if mibBuilder.loadTexts: lsHistoryStatsOctets.setDescription('The total number of octets of data (including those in bad packets) received on the LANswitch bus (excluding framing bits but including FCS octets).')
lsHistoryStatsEthBroadcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 3, 11, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsHistoryStatsEthBroadcastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: lsHistoryStatsEthBroadcastPkts.setDescription('The total number of good Ethernet packets received that were directed to the broadcast address.')
lsHistoryStatsEthMulticastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 3, 11, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsHistoryStatsEthMulticastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: lsHistoryStatsEthMulticastPkts.setDescription('The total number of good packets received that were directed to a multicast address. Note that this number does not include packets directed to the broadcast address.')
lsHistoryStatsGoodEthPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 3, 11, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsHistoryStatsGoodEthPkts.setStatus('mandatory')
if mibBuilder.loadTexts: lsHistoryStatsGoodEthPkts.setDescription('The total number of good Ethernet packets received on the LANswitch bus.')
lsHistoryStatsGoodEthOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 3, 11, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsHistoryStatsGoodEthOctets.setStatus('mandatory')
if mibBuilder.loadTexts: lsHistoryStatsGoodEthOctets.setDescription('The total number of octets that were received on the LANswitch bus in good Ethernet packets (excluding framing bits but including FCS octets).')
lsHistoryStatsBadEthPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 3, 11, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsHistoryStatsBadEthPkts.setStatus('mandatory')
if mibBuilder.loadTexts: lsHistoryStatsBadEthPkts.setDescription('The total number of bad Ethernet packets received on the LANswitch bus.')
lsHistoryStatsBadEthOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 3, 11, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsHistoryStatsBadEthOctets.setStatus('mandatory')
if mibBuilder.loadTexts: lsHistoryStatsBadEthOctets.setDescription('The total number of octets that were received on the LANswitch bus in bad Ethernet packets (excluding framing bits but including FCS octets).')
lsHistoryStatsNonEthPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 3, 11, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsHistoryStatsNonEthPkts.setStatus('mandatory')
if mibBuilder.loadTexts: lsHistoryStatsNonEthPkts.setDescription('The total number of packets received on the LANswitch bus in non Ethernet packets.')
lsHistoryStatsNonEthOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 3, 11, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsHistoryStatsNonEthOctets.setStatus('mandatory')
if mibBuilder.loadTexts: lsHistoryStatsNonEthOctets.setDescription('The total number of octets that were received on the LANswitch bus in non Ethernet packets (excluding framing bits but including FCS octets).')
lsHistoryStatsPriority1Pkts = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 3, 11, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsHistoryStatsPriority1Pkts.setStatus('mandatory')
if mibBuilder.loadTexts: lsHistoryStatsPriority1Pkts.setDescription('The total number of packets (including error packets) received on the LANswitch bus whose priority is that defined for this entry.')
lsHistoryStatsPriority1Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 3, 11, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsHistoryStatsPriority1Octets.setStatus('mandatory')
if mibBuilder.loadTexts: lsHistoryStatsPriority1Octets.setDescription('The total number of octets (including error packets) received on the LANswitch bus whose packets have the priority defined for this entry.')
lsHistoryStatsPriority2Pkts = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 3, 11, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsHistoryStatsPriority2Pkts.setStatus('mandatory')
if mibBuilder.loadTexts: lsHistoryStatsPriority2Pkts.setDescription('The total number of packets (including error packets) received on the LANswitch bus whose priority is that defined for this entry.')
lsHistoryStatsPriority2Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 3, 11, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsHistoryStatsPriority2Octets.setStatus('mandatory')
if mibBuilder.loadTexts: lsHistoryStatsPriority2Octets.setDescription('The total number of octets (including error packets) received on the LANswitch bus whose packets have the priority defined for this entry.')
lsHistoryStatsPriority3Pkts = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 3, 11, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsHistoryStatsPriority3Pkts.setStatus('mandatory')
if mibBuilder.loadTexts: lsHistoryStatsPriority3Pkts.setDescription('The total number of packets (including error packets) received on the LANswitch bus whose priority is that defined for this entry.')
lsHistoryStatsPriority3Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 3, 11, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsHistoryStatsPriority3Octets.setStatus('mandatory')
if mibBuilder.loadTexts: lsHistoryStatsPriority3Octets.setDescription('The total number of octets (including error packets) received on the LANswitch bus whose packets have the priority defined for this entry.')
lsHistoryStatsPriority4Pkts = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 3, 11, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsHistoryStatsPriority4Pkts.setStatus('mandatory')
if mibBuilder.loadTexts: lsHistoryStatsPriority4Pkts.setDescription('The total number of packets (including error packets) received on the LANswitch bus whose priority is that defined for this entry.')
lsHistoryStatsPriority4Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 3, 11, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsHistoryStatsPriority4Octets.setStatus('mandatory')
if mibBuilder.loadTexts: lsHistoryStatsPriority4Octets.setDescription('The total number of octets (including error packets) received on the LANswitch bus whose packets have the priority defined for this entry.')
lsHistoryBusUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 3, 11, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsHistoryBusUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: lsHistoryBusUtilization.setDescription('The utilization of the LANswitch bus, expressed in percents of the maximum LANswitch traffic possible.')
lstIntPort = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 19, 4, 1))
lstIntPortTable = MibTable((1, 3, 6, 1, 4, 1, 81, 19, 4, 1, 1), )
if mibBuilder.loadTexts: lstIntPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: lstIntPortTable.setDescription('')
lstIntPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 19, 4, 1, 1, 1), ).setIndexNames((0, "APPLIC-MIB", "lstIntPortGroupId"), (0, "APPLIC-MIB", "lstIntPortId"))
if mibBuilder.loadTexts: lstIntPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lstIntPortEntry.setDescription('An entry in the table, containing data about a LANswitch port of LANswitch Token-Ring modules.')
lstIntPortGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 4, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lstIntPortGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: lstIntPortGroupId.setDescription('Id of the group to which the switch port belongs.')
lstIntPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 4, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lstIntPortId.setStatus('mandatory')
if mibBuilder.loadTexts: lstIntPortId.setDescription('Switch port Id in module')
lstIntPortSidebandMode = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 4, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lstIntPortSidebandMode.setStatus('mandatory')
if mibBuilder.loadTexts: lstIntPortSidebandMode.setDescription('Enable Sideband mode on internal port. In this mode, MAC level management of all rings can be done.')
lstIntPortTotalOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 4, 1, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lstIntPortTotalOctets.setStatus('mandatory')
if mibBuilder.loadTexts: lstIntPortTotalOctets.setDescription('Total number of octets circling in the ring. It is the sum of local octets, in octets and out octets.')
lstIntPortTotalTraffic = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 4, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lstIntPortTotalTraffic.setStatus('mandatory')
if mibBuilder.loadTexts: lstIntPortTotalTraffic.setDescription('Total traffic in ring as part of the maximum possible utilization, 4Mbps or 16Mbps, expressed in percents. It is the sum of local traffic, in traffic and out traffic.')
lstIntPortLocalOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 4, 1, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lstIntPortLocalOctets.setStatus('mandatory')
if mibBuilder.loadTexts: lstIntPortLocalOctets.setDescription('Number of octets local to the ring. The local traffic includes only traffic between stations on the local ring.')
lstIntPortLocalTraffic = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 4, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lstIntPortLocalTraffic.setStatus('mandatory')
if mibBuilder.loadTexts: lstIntPortLocalTraffic.setDescription('Local traffic in ring as part of the maximum possible utilization, 4Mbps or 16Mbps, expressed in percents. The local traffic includes only traffic between stations on the local ring.')
lstIntPortInOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 4, 1, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lstIntPortInOctets.setStatus('mandatory')
if mibBuilder.loadTexts: lstIntPortInOctets.setDescription('Number of octets passing in to the HSB from the ring. The In traffic includes only traffic going from stations on the local ring to stations on other rings.')
lstIntPortInTraffic = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 4, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lstIntPortInTraffic.setStatus('mandatory')
if mibBuilder.loadTexts: lstIntPortInTraffic.setDescription('In traffic to the HSB from the ring as part of the maximum possible utilization, 4Mbps or 16Mbps, expressed in percents. The In traffic includes only traffic going from stations on the local ring to stations on other rings.')
lstIntPortOutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 4, 1, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lstIntPortOutOctets.setStatus('mandatory')
if mibBuilder.loadTexts: lstIntPortOutOctets.setDescription('Number of octets passing out from the HSB to the ring. The Out traffic includes only traffic going to stations on the local ring from stations on other rings.')
lstIntPortOutTraffic = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 4, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lstIntPortOutTraffic.setStatus('mandatory')
if mibBuilder.loadTexts: lstIntPortOutTraffic.setDescription('Out traffic from the HSB to the ring as part of the maximum possible utilization, 4Mbps or 16Mbps, expressed in percents. The Out traffic includes only traffic going to stations on the local ring from stations on other rings.')
lstIntPortTotalFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 4, 1, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lstIntPortTotalFrames.setStatus('mandatory')
if mibBuilder.loadTexts: lstIntPortTotalFrames.setDescription('Total number of frames in the ring.')
lstIntPortLostFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 4, 1, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lstIntPortLostFrames.setStatus('mandatory')
if mibBuilder.loadTexts: lstIntPortLostFrames.setDescription('Number of lost frames because of Back Pressure.')
lstIntPortClaimFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 4, 1, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lstIntPortClaimFrames.setStatus('mandatory')
if mibBuilder.loadTexts: lstIntPortClaimFrames.setDescription('Number of Claim-Token frames in the ring.')
lstIntPortPurgeFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 4, 1, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lstIntPortPurgeFrames.setStatus('mandatory')
if mibBuilder.loadTexts: lstIntPortPurgeFrames.setDescription('Number of Ring-Purge frames in the ring.')
lstIntPortNormallyCloseOpen = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 4, 1, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("normallyClose", 1), ("normallyOpen", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lstIntPortNormallyCloseOpen.setStatus('mandatory')
if mibBuilder.loadTexts: lstIntPortNormallyCloseOpen.setDescription("Defines the IO mode of the switch port: normally close or normally open. When the port is in 'normallyOpen' mode, all packets enter the port regardless to CAM content.")
lstIntPortSlicingEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 4, 1, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lstIntPortSlicingEnable.setStatus('mandatory')
if mibBuilder.loadTexts: lstIntPortSlicingEnable.setDescription("Packet slicing mechanism for decreasing the delay of packets transmission in the HSB. Value 'on' enables the slicing mechanism.")
lstIntPortSliceLength = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 4, 1, 1, 1, 20), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lstIntPortSliceLength.setStatus('mandatory')
if mibBuilder.loadTexts: lstIntPortSliceLength.setDescription("The slice length in bytes. It determines the delay of packet's transmission through the HSB.")
lstIntPortUNAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 4, 1, 1, 1, 21), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lstIntPortUNAddr.setStatus('mandatory')
if mibBuilder.loadTexts: lstIntPortUNAddr.setDescription('MAC address of the Upstream Neighbor of the line interface.')
lstIntPortMACAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 4, 1, 1, 1, 22), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lstIntPortMACAddress.setStatus('mandatory')
if mibBuilder.loadTexts: lstIntPortMACAddress.setDescription('MAC address of the line interface.')
lstIntPortSMPTransmitEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 4, 1, 1, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lstIntPortSMPTransmitEnable.setStatus('mandatory')
if mibBuilder.loadTexts: lstIntPortSMPTransmitEnable.setDescription('Enable SMP MAC frame transmission by line interface during single-station situation.')
lstIntPortIPGLength = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 4, 1, 1, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lstIntPortIPGLength.setStatus('mandatory')
if mibBuilder.loadTexts: lstIntPortIPGLength.setDescription('Number of bytes interval between frames transmission of the line interface to the ring.')
lstIntPortBPDummyWindow = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 4, 1, 1, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lstIntPortBPDummyWindow.setStatus('mandatory')
if mibBuilder.loadTexts: lstIntPortBPDummyWindow.setDescription('The time (in 0.25ms) between Dummy frames sendings during Back Pressure situation of the line interface.')
lstIntPortBPTokenWindow = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 4, 1, 1, 1, 26), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lstIntPortBPTokenWindow.setStatus('mandatory')
if mibBuilder.loadTexts: lstIntPortBPTokenWindow.setDescription('The time (in 0.25ms) until Token release during Back Pressure situation of the line interface.')
lstIntPortTransmitWindow = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 4, 1, 1, 1, 27), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lstIntPortTransmitWindow.setStatus('mandatory')
if mibBuilder.loadTexts: lstIntPortTransmitWindow.setDescription('The time (in 0.25ms) of line interface transmission until Token release.')
lstIntPortBlockingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 4, 1, 1, 1, 28), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lstIntPortBlockingPriority.setStatus('mandatory')
if mibBuilder.loadTexts: lstIntPortBlockingPriority.setDescription('The priority of the line interface during Back Pressure situation.')
lstIntPortNormalPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 4, 1, 1, 1, 29), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lstIntPortNormalPriority.setStatus('mandatory')
if mibBuilder.loadTexts: lstIntPortNormalPriority.setDescription('The priority of the line interface for HSB packets transmission into the ring.')
lstIntPortDummyMV = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 4, 1, 1, 1, 30), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lstIntPortDummyMV.setStatus('mandatory')
if mibBuilder.loadTexts: lstIntPortDummyMV.setDescription('Content of MV (Major Vector) field in Dummy frame during Back Pressure of line interface.')
lstIntPortTxConsecutiveBusiesThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 4, 1, 1, 1, 31), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lstIntPortTxConsecutiveBusiesThresh.setStatus('mandatory')
if mibBuilder.loadTexts: lstIntPortTxConsecutiveBusiesThresh.setDescription('The threshold of the number of consecutive busies counter.')
lstIntPortTxBufFullThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 4, 1, 1, 1, 32), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lstIntPortTxBufFullThresh.setStatus('mandatory')
if mibBuilder.loadTexts: lstIntPortTxBufFullThresh.setDescription('Threshold indicator for frames buffer full.')
lstIntPortRxEmpty0 = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 4, 1, 1, 1, 33), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lstIntPortRxEmpty0.setStatus('mandatory')
if mibBuilder.loadTexts: lstIntPortRxEmpty0.setDescription('Upper threshold pointer of Rx buffer. Determines the degree of buffer overflow and back pressure efficiency.')
lstIntPortRxEmpty1 = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 4, 1, 1, 1, 34), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lstIntPortRxEmpty1.setStatus('mandatory')
if mibBuilder.loadTexts: lstIntPortRxEmpty1.setDescription('Middle threshold pointer of Rx buffer. Determines the degree of buffer overflow and back pressure efficiency..')
lstIntPortRxEmpty2 = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 4, 1, 1, 1, 35), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lstIntPortRxEmpty2.setStatus('mandatory')
if mibBuilder.loadTexts: lstIntPortRxEmpty2.setDescription('Lower threshold pointer of Rx buffer. Determines the degree of buffer overflow and back pressure efficiency.')
lstIntPortRxFull = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 4, 1, 1, 1, 36), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lstIntPortRxFull.setStatus('mandatory')
if mibBuilder.loadTexts: lstIntPortRxFull.setDescription('Rx full threshold pointer. Determines the degree of buffer overflow and back pressure efficiency.')
lstIntPortBPEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 4, 1, 1, 1, 37), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lstIntPortBPEnable.setStatus('mandatory')
if mibBuilder.loadTexts: lstIntPortBPEnable.setDescription('Enable/disable the Back Pressure mechanism.')
lstIntPortRouteSideband = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 4, 1, 1, 1, 38), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lstIntPortRouteSideband.setStatus('mandatory')
if mibBuilder.loadTexts: lstIntPortRouteSideband.setDescription("Set the internal port ability to get from the HSB sideband packets. The value 'on' enables the routing of sideband packet from the HSB into the internal port.")
lseWANTable = MibTable((1, 3, 6, 1, 4, 1, 81, 19, 5), )
if mibBuilder.loadTexts: lseWANTable.setStatus('mandatory')
if mibBuilder.loadTexts: lseWANTable.setDescription('LAN Switch WAN data table. Implementation of this table is mandatory for all LANswitch modules with WAN ports.')
lseWANEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 19, 5, 1), ).setIndexNames((0, "APPLIC-MIB", "lseWANGroupId"), (0, "APPLIC-MIB", "lseWANPortId"))
if mibBuilder.loadTexts: lseWANEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lseWANEntry.setDescription('Entry in the table.')
lseWANGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lseWANGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: lseWANGroupId.setDescription('Slot number in which the module is located.')
lseWANPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 5, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lseWANPortId.setStatus('mandatory')
if mibBuilder.loadTexts: lseWANPortId.setDescription('WAN port index.')
lseWANConnection = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("connected", 1), ("disconnected", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lseWANConnection.setStatus('mandatory')
if mibBuilder.loadTexts: lseWANConnection.setDescription('WAN connection status.')
lsVNChangeMACAddress = MibScalar((1, 3, 6, 1, 4, 1, 81, 19, 6, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsVNChangeMACAddress.setStatus('mandatory')
if mibBuilder.loadTexts: lsVNChangeMACAddress.setDescription('MAC Address that was detected with at a switch port and its mapping to a Virtual Network does not fit with the third layer address.')
lsVNChangeDetected = MibScalar((1, 3, 6, 1, 4, 1, 81, 19, 6, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsVNChangeDetected.setStatus('mandatory')
if mibBuilder.loadTexts: lsVNChangeDetected.setDescription('Virtual Network number detected at the switch port when a VN change is reported.')
lsVNChangeExpected = MibScalar((1, 3, 6, 1, 4, 1, 81, 19, 6, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsVNChangeExpected.setStatus('mandatory')
if mibBuilder.loadTexts: lsVNChangeExpected.setDescription('Virtual Network number detected at the switch port when a VN change is reported.')
lsVNChangeGroup = MibScalar((1, 3, 6, 1, 4, 1, 81, 19, 6, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsVNChangeGroup.setStatus('mandatory')
if mibBuilder.loadTexts: lsVNChangeGroup.setDescription('The slot number of the card where the Vitual Network change was detected.')
lsVNChangePort = MibScalar((1, 3, 6, 1, 4, 1, 81, 19, 6, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsVNChangePort.setStatus('mandatory')
if mibBuilder.loadTexts: lsVNChangePort.setDescription('The port number where the Vitual Network change was detected.')
vnsPacketTable = MibTable((1, 3, 6, 1, 4, 1, 81, 19, 7, 1), )
if mibBuilder.loadTexts: vnsPacketTable.setStatus('mandatory')
if mibBuilder.loadTexts: vnsPacketTable.setDescription('VNS packets data table. Implementation of this table is mandatory for 3LS (3rd layer switch) module.')
vnsPacketEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 19, 7, 1, 1), ).setIndexNames((0, "APPLIC-MIB", "vnsPacketMACAddress"))
if mibBuilder.loadTexts: vnsPacketEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vnsPacketEntry.setDescription('Entry in the table.')
vnsPacketMACAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 7, 1, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: vnsPacketMACAddress.setStatus('mandatory')
if mibBuilder.loadTexts: vnsPacketMACAddress.setDescription('The Mac Address of the sending station.')
vnsPacketProtocolTypeMask = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 7, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: vnsPacketProtocolTypeMask.setStatus('mandatory')
if mibBuilder.loadTexts: vnsPacketProtocolTypeMask.setDescription("This is a mask of the exising protocols. Bit(0)='1' when IP protocol exist and '0' otherwise, Bit(1)='1' when IPX protocol exist and '0' otherwise, all other bits are '0' for the moment.")
vnsPacketIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 7, 1, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vnsPacketIPAddress.setStatus('mandatory')
if mibBuilder.loadTexts: vnsPacketIPAddress.setDescription("The IP address of the packet's sending station. In case the typeaddress is not IP this field will be 0.0.0.0.")
vnsPacketIPNetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 7, 1, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vnsPacketIPNetMask.setStatus('mandatory')
if mibBuilder.loadTexts: vnsPacketIPNetMask.setDescription('The IP Address Mask from the IP Interface Table.')
vnsPacketIPXnetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 7, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: vnsPacketIPXnetwork.setStatus('mandatory')
if mibBuilder.loadTexts: vnsPacketIPXnetwork.setDescription("The IPX NetWork Address of the packet's sending station. In case that the typeaddress is not IPX this field will be 0.0.0.0.")
vnsPacketStationType = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 7, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 255))).clone(namedValues=NamedValues(("unknown", 1), ("client", 2), ("server", 3), ("notSupported", 255))).clone('notSupported')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vnsPacketStationType.setStatus('mandatory')
if mibBuilder.loadTexts: vnsPacketStationType.setDescription('The Station Type indicates from where comes the packets in the case of the IPX protocol.')
vnsPacketPortGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 7, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vnsPacketPortGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: vnsPacketPortGroupId.setDescription('Index which identifies the group inside the chassis for which this entry contains information. It equals with the slot number.')
vnsPacketPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 7, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vnsPacketPortId.setStatus('mandatory')
if mibBuilder.loadTexts: vnsPacketPortId.setDescription('Index which identifies the port inside the group for which this entry contains information. It equals with the port number.')
vnsPacketBackbonePort = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 7, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 255))).clone(namedValues=NamedValues(("unknown", 1), ("backbone", 2), ("noBackbone", 3), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vnsPacketBackbonePort.setStatus('mandatory')
if mibBuilder.loadTexts: vnsPacketBackbonePort.setDescription('The value 2 indicates that the port source of the packet is a backbone port.')
vnsPacketExpectedVLAN = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 7, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vnsPacketExpectedVLAN.setStatus('mandatory')
if mibBuilder.loadTexts: vnsPacketExpectedVLAN.setDescription("The value of this item is the VLAN number that the packet had to have according to it's address.")
vnsPacketDetectedVLAN = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 7, 1, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vnsPacketDetectedVLAN.setStatus('mandatory')
if mibBuilder.loadTexts: vnsPacketDetectedVLAN.setDescription('The value of this item is the detected VLAN number of the arrived packet.')
vnsPacketBoxAgentIP = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 19, 7, 1, 1, 12), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vnsPacketBoxAgentIP.setStatus('mandatory')
if mibBuilder.loadTexts: vnsPacketBoxAgentIP.setDescription("The IP Address of the Hub's BoxAgent where the 3LS (3rd layer switch) module exist.")
topDiscovery = MibScalar((1, 3, 6, 1, 4, 1, 81, 23, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 255))).clone(namedValues=NamedValues(("idle", 1), ("topoMessages", 2), ("macFind", 3), ("swBackboneMsgMonitor", 4), ("notSupported", 255))).clone('idle')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: topDiscovery.setStatus('mandatory')
if mibBuilder.loadTexts: topDiscovery.setDescription("The value of this item defines the activity status of the agent's discovery algorithm. When its value is set to topoMessages(2), the agent searches for the topology messages (interhub and bridge messages). When the value is macFind(3), the agent searches for the MAC addresses defined in the item ethTopMACFindList. The results of the search are then reported in ethTopMACResultTable. When the value is swBackboneMsgMonitor(4), the agent monitors messages with specific destination address. The result of monitoring is reported in ethTopMessageResultEntry. The value of this item cannot be changed from one state to another without being first changed to idle(1). This item is timed by TopDiscoveryTimeOut (return back to idle(1)).")
topDiscoveryTimeOut = MibScalar((1, 3, 6, 1, 4, 1, 81, 23, 2), Integer32().clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: topDiscoveryTimeOut.setStatus('mandatory')
if mibBuilder.loadTexts: topDiscoveryTimeOut.setDescription("The value of this item defines the maximal time (in seconds) that an agent can remain in the non-idle toplogy discovery mode. When the agent is set to the topology mode (TopDiscovery=topoDiscovery(2) or macFind(3)) the counter is started. If the manager doesn't return the agent back to normal operation mode within the timeOut, the agent will automatically return to normal operation (TopDiscovery=idle(1)) and stop searching for the special messages. The value of this item can be changed only when TopDiscovery=idle(1).")
ethTop = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 23, 3))
ethTopDiscoveryTx = MibScalar((1, 3, 6, 1, 4, 1, 81, 23, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("idle", 1), ("txInterhubMsg", 2), ("txBridgeMsg", 3), ("txAckMsg", 4))).clone('idle')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethTopDiscoveryTx.setStatus('mandatory')
if mibBuilder.loadTexts: ethTopDiscoveryTx.setDescription('This item is a switch that activates the inter-agent topology messages. txInterhubMsg(2) - the agent transmits interhub discovery messages. txBridgeMsg(3) - the agent transmits bridge discovery messages. txAckMsg(4) - the agent transmits acknowledgment messages.')
ethTopClearMessageResult = MibScalar((1, 3, 6, 1, 4, 1, 81, 23, 3, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("idle", 1), ("clear", 2))).clone('idle')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethTopClearMessageResult.setStatus('mandatory')
if mibBuilder.loadTexts: ethTopClearMessageResult.setDescription("When this item is set to clear(2), the agent sets the values of all ethTopMessageResult items to '0'. When finished the 'clear' process the Agent sets the variable to idle(1).")
ethTopNumOfMessageResults = MibScalar((1, 3, 6, 1, 4, 1, 81, 23, 3, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethTopNumOfMessageResults.setStatus('mandatory')
if mibBuilder.loadTexts: ethTopNumOfMessageResults.setDescription('This item contains the number of messages currently stored in the ethTopMessageResultTable.')
ethTopMessageResultTable = MibTable((1, 3, 6, 1, 4, 1, 81, 23, 3, 4), )
if mibBuilder.loadTexts: ethTopMessageResultTable.setStatus('mandatory')
if mibBuilder.loadTexts: ethTopMessageResultTable.setDescription('A table that contains 3 items with the results of the topology messages received by the agent.')
ethTopMessageResultEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 23, 3, 4, 1), ).setIndexNames((0, "APPLIC-MIB", "ethTopMessageResultId"))
if mibBuilder.loadTexts: ethTopMessageResultEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ethTopMessageResultEntry.setDescription('An entry in the table, containing part of the received data.')
ethTopMessageResultId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 23, 3, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethTopMessageResultId.setStatus('mandatory')
if mibBuilder.loadTexts: ethTopMessageResultId.setDescription("The table's index. Can assume the values 1,2, or 3.")
ethTopMessageResult = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 23, 3, 4, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 440))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethTopMessageResult.setStatus('mandatory')
if mibBuilder.loadTexts: ethTopMessageResult.setDescription('A row in the Topology Messages result table. Each row contains up to 44 elements.')
ethTopMACFindList = MibScalar((1, 3, 6, 1, 4, 1, 81, 23, 3, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 36))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethTopMACFindList.setStatus('mandatory')
if mibBuilder.loadTexts: ethTopMACFindList.setDescription('Up to 6 MAC addresses to be searched for by the Agent.')
ethTopMACFindResultTable = MibTable((1, 3, 6, 1, 4, 1, 81, 23, 3, 6), )
if mibBuilder.loadTexts: ethTopMACFindResultTable.setStatus('mandatory')
if mibBuilder.loadTexts: ethTopMACFindResultTable.setDescription("A table that contains 4 rows with the results of the MACFind process. Each row contains the results for one of the hub's buses. The number of items supported is equal to the number of buses supported by the agent.")
ethTopMACFindResultEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 23, 3, 6, 1), ).setIndexNames((0, "APPLIC-MIB", "ethTopMACFindBus"))
if mibBuilder.loadTexts: ethTopMACFindResultEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ethTopMACFindResultEntry.setDescription('An entry in the table, containing one LSA item.')
ethTopMACFindBus = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 23, 3, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethTopMACFindBus.setStatus('mandatory')
if mibBuilder.loadTexts: ethTopMACFindBus.setDescription('The bus for which the results are reported.')
ethTopMACFindResult = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 23, 3, 6, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 48))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethTopMACFindResult.setStatus('mandatory')
if mibBuilder.loadTexts: ethTopMACFindResult.setDescription("The results of the search for the requested MAC addresses fo the relevant bus. The format is: MAC (6 bytes), slot (1 byte), port (1 byte). If the Agent doesn't find a MAC's correlation, the slot and port will be '0'.")
ethTopLSATable = MibTable((1, 3, 6, 1, 4, 1, 81, 23, 3, 7), )
if mibBuilder.loadTexts: ethTopLSATable.setStatus('mandatory')
if mibBuilder.loadTexts: ethTopLSATable.setDescription("A table that contains 8 rows with the last source addresses found on the hub's ports. Each row in the table reports the last source addresses for specific slots in the hub: #1: modules 1,2,17,18; #5: modules 9,10,25, 26; #2: modules 3,4,19,20; #6: modules 11,12,27, 28; #3: modules 5,6,21,22; #7: modules 13,14,29,30; #4: modules 7,8,23,24; #8: modules 15,16,31,32; The data in the items appears by the slot order defined above. All 8 items exist even if some of them are empty.")
ethTopLSAEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 23, 3, 7, 1), ).setIndexNames((0, "APPLIC-MIB", "ethTopLSAId"))
if mibBuilder.loadTexts: ethTopLSAEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ethTopLSAEntry.setDescription('An entry in the table, containing one LSA item.')
ethTopLSAId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 23, 3, 7, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethTopLSAId.setStatus('mandatory')
if mibBuilder.loadTexts: ethTopLSAId.setDescription("The table's index. Assumes values 1,2,3,...,8.")
ethTopLSA = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 23, 3, 7, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(384, 384)).setFixedLength(384)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethTopLSA.setStatus('mandatory')
if mibBuilder.loadTexts: ethTopLSA.setDescription("This item contains the last source addresses for modules in related slots. For each port the data is: slot (one byte), port (one byte), address (6 bytes). For none existing ports the LSA will be 0. The first bit (MSB) of the slot byte defines the user status: '0' - single user; '1' - multi user.")
ethTopAddressTable = MibTable((1, 3, 6, 1, 4, 1, 81, 23, 3, 8), )
if mibBuilder.loadTexts: ethTopAddressTable.setStatus('mandatory')
if mibBuilder.loadTexts: ethTopAddressTable.setDescription('A table that contains the MAC addresses used by the agent for the topology messages.')
ethTopAddressEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 23, 3, 8, 1), ).setIndexNames((0, "APPLIC-MIB", "ethTopBus"))
if mibBuilder.loadTexts: ethTopAddressEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ethTopAddressEntry.setDescription('An entry in the topology address table. The number of entries is equal to the number of Ethernet buses supported by the agent.')
ethTopBus = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 23, 3, 8, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethTopBus.setStatus('mandatory')
if mibBuilder.loadTexts: ethTopBus.setDescription('The bus for which this address is defined.')
ethTopAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 23, 3, 8, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethTopAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ethTopAddress.setDescription('The MAC address used by the agent for the topology discovery process on the related bus.')
ethTopHSBMonitor = MibScalar((1, 3, 6, 1, 4, 1, 81, 23, 3, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("idle", 1), ("startMonitor", 2), ("notSupported", 255))).clone('idle')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethTopHSBMonitor.setStatus('mandatory')
if mibBuilder.loadTexts: ethTopHSBMonitor.setDescription('This item ask for monitoring the LANSwitch bus by the NMA-RS. startMonitor(2) value, is used to start monitor the LANSwitch bus collect the lsHostTimePortCorrTable. ')
alarms = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 30, 1))
alarmMonitorStatusTable = MibTable((1, 3, 6, 1, 4, 1, 81, 30, 1, 1), )
if mibBuilder.loadTexts: alarmMonitorStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: alarmMonitorStatusTable.setDescription('A list of alarms status for Alarm entries.')
alarmMonitorStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 30, 1, 1, 1), ).setIndexNames((0, "APPLIC-MIB", "alarmMonitorStatusIndex"))
if mibBuilder.loadTexts: alarmMonitorStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: alarmMonitorStatusEntry.setDescription('Each entry contains an index (appropriate to specific alarmIndex item) and the alarmed status of this alarm entry ')
alarmMonitorStatusIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: alarmMonitorStatusIndex.setStatus('mandatory')
if mibBuilder.loadTexts: alarmMonitorStatusIndex.setDescription('An index that uniquely identifies an entry in the alarmMonitorStatusTable. This index is the same as the appropriate alarm Table.')
alarmMonitorStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("alarmState", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: alarmMonitorStatus.setStatus('mandatory')
if mibBuilder.loadTexts: alarmMonitorStatus.setDescription("The alarms' status for the appropriate alarm table 1 - ok 2 - alarmState.")
alarmUtilitiesCommand = MibScalar((1, 3, 6, 1, 4, 1, 81, 30, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("idle", 1), ("clearAll", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: alarmUtilitiesCommand.setStatus('mandatory')
if mibBuilder.loadTexts: alarmUtilitiesCommand.setDescription('The alarms command can be one of the follows: 1 - idle - idle state. 2 - clearAll - clear all alarms and events in the Agent tables. 254 - failed - If the Agent does not succeed to perform the command, the alarmUtilitiesCommand will be changed to failed, to indicate the fail of performing the last Command.')
portHistory = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 30, 3))
portHistoryExtendedControlTable = MibTable((1, 3, 6, 1, 4, 1, 81, 30, 3, 1), )
if mibBuilder.loadTexts: portHistoryExtendedControlTable.setStatus('mandatory')
if mibBuilder.loadTexts: portHistoryExtendedControlTable.setDescription('A list of extended history control entries.')
portHistoryExtendedControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 30, 3, 1, 1), ).setIndexNames((0, "RMON-MIB", "historyControlIndex"))
if mibBuilder.loadTexts: portHistoryExtendedControlEntry.setStatus('mandatory')
if mibBuilder.loadTexts: portHistoryExtendedControlEntry.setDescription('A list of extended parameters that set up a periodic sampling of statistics. ')
portHistoryExtendedControlCreateTime = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 3, 1, 1, 1), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portHistoryExtendedControlCreateTime.setStatus('mandatory')
if mibBuilder.loadTexts: portHistoryExtendedControlCreateTime.setDescription('The value of sysUpTime at the creation of the control row and start of the history collection index with the same value of the historyControlIndex.')
portHistoryExtendedControlLastBucketIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 3, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portHistoryExtendedControlLastBucketIndex.setStatus('mandatory')
if mibBuilder.loadTexts: portHistoryExtendedControlLastBucketIndex.setDescription('The index of the last bucket that was stored to the history table.')
portHistoryExtendedControlNumberOfBuckets = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portHistoryExtendedControlNumberOfBuckets.setStatus('mandatory')
if mibBuilder.loadTexts: portHistoryExtendedControlNumberOfBuckets.setDescription(' The number of buckets stored in the probe.')
portHistoryExtendedControlName = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 3, 1, 1, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portHistoryExtendedControlName.setStatus('mandatory')
if mibBuilder.loadTexts: portHistoryExtendedControlName.setDescription(' The name of the this history collection.')
lsPortHistoryTable = MibTable((1, 3, 6, 1, 4, 1, 81, 30, 3, 2), )
if mibBuilder.loadTexts: lsPortHistoryTable.setStatus('mandatory')
if mibBuilder.loadTexts: lsPortHistoryTable.setDescription('A list of LANswitch port history entries.')
lsPortHistoryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 30, 3, 2, 1), ).setIndexNames((0, "APPLIC-MIB", "lsPortHistoryIndex"), (0, "APPLIC-MIB", "lsPortHistorySampleIndex"), (0, "APPLIC-MIB", "lsPortNumber"))
if mibBuilder.loadTexts: lsPortHistoryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lsPortHistoryEntry.setDescription('An historical sample of port switch statistics with the historyControlEntry, which set up the parameters for a regular collection of these samples. ')
lsPortHistoryIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 3, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsPortHistoryIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lsPortHistoryIndex.setDescription('The history of which this entry is a part. The history identified by a particular value of this index is the same history as identified by the same value of historyControlIndex.')
lsPortHistorySampleIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 3, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsPortHistorySampleIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lsPortHistorySampleIndex.setDescription('An index that uniquely identifies the particular sample, this entry represents among all samples associated with the same lshistoryControlEntry. This index starts at 1 and increases by one as each new sample is taken.')
lsPortHistoryIntervalTime = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 3, 2, 1, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsPortHistoryIntervalTime.setStatus('mandatory')
if mibBuilder.loadTexts: lsPortHistoryIntervalTime.setDescription('The value of sysUpTime at the start of the interval over which this sample was measured.')
lsPortHistoryBoxConfiguration = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 3, 2, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsPortHistoryBoxConfiguration.setStatus('mandatory')
if mibBuilder.loadTexts: lsPortHistoryBoxConfiguration.setDescription(' Octet String build by concatenating the genGroupType of the maximum 16 modules in the LANSwitch box. By reading this variable a management application can draw a list of the LANSwitch modules and ports configuration relevant for the application. ')
lsPortHistoryPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 3, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsPortHistoryPkts.setStatus('mandatory')
if mibBuilder.loadTexts: lsPortHistoryPkts.setDescription('The total number of good packets received on the port.')
lsPortHistoryCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 3, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsPortHistoryCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: lsPortHistoryCollisions.setDescription(' The best estimate of the total number of collisions on this port during this sampling interval.')
lsPortHistoryTotalErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 3, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsPortHistoryTotalErrors.setStatus('mandatory')
if mibBuilder.loadTexts: lsPortHistoryTotalErrors.setDescription('The total number of errors detected by the switching hardware on this port, including FCS errors and too long packets.')
scPortHistoryTable = MibTable((1, 3, 6, 1, 4, 1, 81, 30, 3, 3), )
if mibBuilder.loadTexts: scPortHistoryTable.setStatus('mandatory')
if mibBuilder.loadTexts: scPortHistoryTable.setDescription('A list of Xswitch port history entries.')
scPortHistoryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 30, 3, 3, 1), ).setIndexNames((0, "APPLIC-MIB", "scPortHistoryIndex"), (0, "APPLIC-MIB", "scPortHistorySampleIndex"), (0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: scPortHistoryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: scPortHistoryEntry.setDescription('An historical sample of port switch statistics with the historyControlEntry, which set up the parameters for a regular collection of these samples. ')
scPortHistoryIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 3, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: scPortHistoryIndex.setStatus('mandatory')
if mibBuilder.loadTexts: scPortHistoryIndex.setDescription('The history of which this entry is a part. The history identified by a particular value of this index is the same history as identified by the same value of historyControlIndex.')
scPortHistorySampleIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 3, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: scPortHistorySampleIndex.setStatus('mandatory')
if mibBuilder.loadTexts: scPortHistorySampleIndex.setDescription('An index that uniquely identifies the particular sample, this entry represents among all samples associated with the same scHistoryControlEntry. This index starts at 1 and increases by one as each new sample is taken.')
scPortHistoryIntervalTime = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 3, 3, 1, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: scPortHistoryIntervalTime.setStatus('mandatory')
if mibBuilder.loadTexts: scPortHistoryIntervalTime.setDescription('The value of sysUpTime at the start of the interval over which this sample was measured.')
scPortHistoryBoxConfiguration = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 3, 3, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: scPortHistoryBoxConfiguration.setStatus('mandatory')
if mibBuilder.loadTexts: scPortHistoryBoxConfiguration.setDescription(' Octet String build by concatenating the genGroupType of the maximum 14 modules in the Meritage box or 4 boxes in the Visage stack. By reading this variable a management application can draw a list of the modules (boxes) and ports configuration relevant for the application. ')
scPortHistoryGoodPktsRec = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 3, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: scPortHistoryGoodPktsRec.setStatus('mandatory')
if mibBuilder.loadTexts: scPortHistoryGoodPktsRec.setDescription('The total number of good packets received by the port.')
scPortHistoryGoodNonUnicastPktsRec = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 3, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: scPortHistoryGoodNonUnicastPktsRec.setStatus('mandatory')
if mibBuilder.loadTexts: scPortHistoryGoodNonUnicastPktsRec.setDescription('The total number of good packets received that were directed to multicat or broadcast address.')
scPortHistoryCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 3, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: scPortHistoryCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: scPortHistoryCollisions.setDescription('The best estimate of the total number of collisions on the Ethernet segment connected to the port.')
scPortHistoryBadPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 3, 3, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: scPortHistoryBadPkts.setStatus('mandatory')
if mibBuilder.loadTexts: scPortHistoryBadPkts.setDescription('The total number of bad packets filtered by the port. This item is the summation of: scEthPortCRCAlignErrors, scEthPortOversizePkts, scEthPortFragments and scEthPortJabber. ')
scPortHistoryGoodPktsSent = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 3, 3, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: scPortHistoryGoodPktsSent.setStatus('mandatory')
if mibBuilder.loadTexts: scPortHistoryGoodPktsSent.setDescription('The total number of good packets sent by the port.')
portHistoryMemoryAvailability = MibScalar((1, 3, 6, 1, 4, 1, 81, 30, 3, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 255))).clone(namedValues=NamedValues(("standard", 1), ("limited1", 2), ("limited2", 3), ("notSupported", 255))).clone('standard')).setMaxAccess("readonly")
if mibBuilder.loadTexts: portHistoryMemoryAvailability.setStatus('mandatory')
if mibBuilder.loadTexts: portHistoryMemoryAvailability.setDescription('This item reflect the status of available Port History. standard(1) value, is used when there are no memory limitations. limited1(2) value, is used when the limitation is 3 MB. limited1(3) value, is used when the limitation is 2 MB.')
mibBuilder.exportSymbols("APPLIC-MIB", lstIntPortSMPTransmitEnable=lstIntPortSMPTransmitEnable, lstIntPortIPGLength=lstIntPortIPGLength, lsPortHistoryCollisions=lsPortHistoryCollisions, lseWANPortId=lseWANPortId, lsBusStatsPriorityOctets=lsBusStatsPriorityOctets, lseGroupSmartSqlt=lseGroupSmartSqlt, lsBusStatsVirtualNetOctets=lsBusStatsVirtualNetOctets, ethTopMACFindBus=ethTopMACFindBus, lhsTxUCast=lhsTxUCast, hostTimeCreationOrder=hostTimeCreationOrder, lseWANConnection=lseWANConnection, scPortHistoryEntry=scPortHistoryEntry, lsPortControlDataSource=lsPortControlDataSource, topDiscoveryTimeOut=topDiscoveryTimeOut, lseGroup10MSqlt=lseGroup10MSqlt, vnsPacketProtocolTypeMask=vnsPacketProtocolTypeMask, lseIntPortRetryPriorityLevel1=lseIntPortRetryPriorityLevel1, lseGroupDataBlinderLength=lseGroupDataBlinderLength, lseIntPortRoutingMode=lseIntPortRoutingMode, lstIntPortRxEmpty2=lstIntPortRxEmpty2, lsHistoryStatsPriority1Octets=lsHistoryStatsPriority1Octets, lstIntPortPurgeFrames=lstIntPortPurgeFrames, lsPortInOctets=lsPortInOctets, lstIntPortId=lstIntPortId, ethTopMACFindResult=ethTopMACFindResult, lseGroupBITResult=lseGroupBITResult, lseIntPortTransmitWeight=lseIntPortTransmitWeight, lsHistoryStatsPriority3Octets=lsHistoryStatsPriority3Octets, lsPortOutPkts=lsPortOutPkts, lsPortFilterEntry=lsPortFilterEntry, lsPortFilterStatus=lsPortFilterStatus, lseIntPortId=lseIntPortId, lseWANTable=lseWANTable, lsHostFilterAddress=lsHostFilterAddress, ethTopMACFindResultEntry=ethTopMACFindResultEntry, lseGroupCParameter=lseGroupCParameter, lsHostFilterEntry=lsHostFilterEntry, lsHostPortFilter=lsHostPortFilter, vnsPacket=vnsPacket, lseIntPortCopiedPort=lseIntPortCopiedPort, portHistoryExtendedControlNumberOfBuckets=portHistoryExtendedControlNumberOfBuckets, lsVNChangeMACAddress=lsVNChangeMACAddress, lntTopology=lntTopology, lhsGroupId=lhsGroupId, lseIntPortClearFilter=lseIntPortClearFilter, hostTimePortConnection=hostTimePortConnection, lseIntPortGlobalSuperNet=lseIntPortGlobalSuperNet, lsPortHistoryPkts=lsPortHistoryPkts, lseIntPortBroadcastBehavior=lseIntPortBroadcastBehavior, lseIntPortMACAdd=lseIntPortMACAdd, lsBusStatsEthBroadcastPkts=lsBusStatsEthBroadcastPkts, hostTimeIndex=hostTimeIndex, lhsTxBCast=lhsTxBCast, portHistoryExtendedControlName=portHistoryExtendedControlName, lseIntPortTable=lseIntPortTable, lsHistoryStatsGoodEthPkts=lsHistoryStatsGoodEthPkts, ethTopClearMessageResult=ethTopClearMessageResult, scPortHistoryBadPkts=scPortHistoryBadPkts, lseIntPortTxSafetyZone=lseIntPortTxSafetyZone, lsePortGroupId=lsePortGroupId, lsBusStatsPriorityTable=lsBusStatsPriorityTable, lsePortEntry=lsePortEntry, lsPortCreationOrder=lsPortCreationOrder, lseIntPortSuperPriorityEnable=lseIntPortSuperPriorityEnable, ethTopAddress=ethTopAddress, lseGroupIPGJamLength=lseGroupIPGJamLength, lstIntPortNormalPriority=lstIntPortNormalPriority, lstIntPortTxConsecutiveBusiesThresh=lstIntPortTxConsecutiveBusiesThresh, lseIntPortRetryPriorityLevel3=lseIntPortRetryPriorityLevel3, lsHistoryStatsNonEthOctets=lsHistoryStatsNonEthOctets, lseIntPortMACAddPortId=lseIntPortMACAddPortId, lsHistoryStatsNonEthPkts=lsHistoryStatsNonEthPkts, lsPortInMulticastPkts=lsPortInMulticastPkts, lstIntPortTable=lstIntPortTable, lsPortStats=lsPortStats, lstIntPortNormallyCloseOpen=lstIntPortNormallyCloseOpen, lsPortExtendedStatsTable=lsPortExtendedStatsTable, ethTopMessageResultId=ethTopMessageResultId, lhsPortEntry=lhsPortEntry, lsPortFilterTable=lsPortFilterTable, lseIntPortVideoPacket=lseIntPortVideoPacket, lseGroupTable=lseGroupTable, lseGroupEnableHSBReset=lseGroupEnableHSBReset, lsBusStatsPriorityIndex=lsBusStatsPriorityIndex, lsMonitorResourceAllocation=lsMonitorResourceAllocation, lseIntPortRxEmpty0=lseIntPortRxEmpty0, lstIntPortLocalOctets=lstIntPortLocalOctets, lseIntPortRemoveFilter=lseIntPortRemoveFilter, alarmMonitorStatusEntry=alarmMonitorStatusEntry, lsBusStatsVirtualNet=lsBusStatsVirtualNet, ethTopBus=ethTopBus, lsBusStatsOctets=lsBusStatsOctets, vnsPacketPortGroupId=vnsPacketPortGroupId, lseIntPortMonitorMissedEvents=lseIntPortMonitorMissedEvents, portHistoryExtendedControlTable=portHistoryExtendedControlTable, vnsPacketIPXnetwork=vnsPacketIPXnetwork, lsHistoryBusUtilization=lsHistoryBusUtilization, lseGroupNormOpDelay=lseGroupNormOpDelay, lseGroupBackboneRedun12=lseGroupBackboneRedun12, lstIntPortMACAddress=lstIntPortMACAddress, lsMatrixFilterTableClear=lsMatrixFilterTableClear, alarms=alarms, vnsPacketMACAddress=vnsPacketMACAddress, lsMonitor=lsMonitor, lsHistoryStatsPriority4Octets=lsHistoryStatsPriority4Octets, alarmMonitorStatus=alarmMonitorStatus, lstIntPortOutOctets=lstIntPortOutOctets, vnsPacketStationType=vnsPacketStationType, lseGroupJamLength=lseGroupJamLength, lstIntPortGroupId=lstIntPortGroupId, lseIntPort=lseIntPort, lsBusStatsVirtualNetEntry=lsBusStatsVirtualNetEntry, portHistoryExtendedControlCreateTime=portHistoryExtendedControlCreateTime, lseIntPortLearnIOCAM=lseIntPortLearnIOCAM, lsPortFilter=lsPortFilter, lseIntPortSuperPriority=lseIntPortSuperPriority, vnsPacketTable=vnsPacketTable, lseIntPortMACAddGroupId=lseIntPortMACAddGroupId, smon=smon, lseIntPortIgnoreProtocolType=lseIntPortIgnoreProtocolType, lseIntPortSuperNetNumber=lseIntPortSuperNetNumber, ethTopMessageResultEntry=ethTopMessageResultEntry, lsBusStatsBadEthPkts=lsBusStatsBadEthPkts, ethTopAddressEntry=ethTopAddressEntry, vnsPacketEntry=vnsPacketEntry, lsHostTimePortCorrTable=lsHostTimePortCorrTable, vnsPacketIPAddress=vnsPacketIPAddress, lseGroupActiveMonitor=lseGroupActiveMonitor, lhsRxOrunErr=lhsRxOrunErr, lseIntPortJabber=lseIntPortJabber, lstIntPortSlicingEnable=lstIntPortSlicingEnable, lhsTxParErr=lhsTxParErr, vnsPacketExpectedVLAN=vnsPacketExpectedVLAN, lsBusStats=lsBusStats, lseGroupHSBMonStatus=lseGroupHSBMonStatus, lsHostPortFilterEntry=lsHostPortFilterEntry, portHistoryMemoryAvailability=portHistoryMemoryAvailability, lsBusStatsVirtualNetPackets=lsBusStatsVirtualNetPackets, vnsPacketDetectedVLAN=vnsPacketDetectedVLAN, lntLanSwitch=lntLanSwitch, lsPortExtendedStatsEntry=lsPortExtendedStatsEntry, lsHistoryStatsEthMulticastPkts=lsHistoryStatsEthMulticastPkts, lseIntPortMACAddEntry=lseIntPortMACAddEntry, lseIntPortRxReject=lseIntPortRxReject, lstIntPortOutTraffic=lstIntPortOutTraffic, lseIntPortCAMLastChange=lseIntPortCAMLastChange, lsBusStatsDropEvents=lsBusStatsDropEvents, lsHistoryStatsPriority1Pkts=lsHistoryStatsPriority1Pkts, lseIntPortMACAddTable=lseIntPortMACAddTable, alarmMonitorStatusTable=alarmMonitorStatusTable, lsPortHistoryIntervalTime=lsPortHistoryIntervalTime, lsBusStatsGoodEthPkts=lsBusStatsGoodEthPkts, lstIntPort=lstIntPort, lseIntPortSecurityIntruder=lseIntPortSecurityIntruder, lhsTxUrunErr=lhsTxUrunErr, lsPortInPkts=lsPortInPkts, ethTopLSATable=ethTopLSATable, lseIntPortVideoStateMachine=lseIntPortVideoStateMachine, lsPortHistorySampleIndex=lsPortHistorySampleIndex, lsBusStatsMulticastPkts=lsBusStatsMulticastPkts, lsHistoryStatsPriority4Pkts=lsHistoryStatsPriority4Pkts, lseGroupWorkState=lseGroupWorkState, scPortHistoryIndex=scPortHistoryIndex, portHistoryExtendedControlLastBucketIndex=portHistoryExtendedControlLastBucketIndex, lseIntPortMACAddList=lseIntPortMACAddList, lseIntPortFilterEntry=lseIntPortFilterEntry, lsHostFilterTableClear=lsHostFilterTableClear, lstIntPortInTraffic=lstIntPortInTraffic, ethTopHSBMonitor=ethTopHSBMonitor, lhsRxBadTypeErr=lhsRxBadTypeErr, lsMatrixFilterTable=lsMatrixFilterTable, lseIntPortEntry=lseIntPortEntry, lsBusStatsGoodEthOctets=lsBusStatsGoodEthOctets, lseIntPortCAM=lseIntPortCAM, lseIntPortMACAddLAId=lseIntPortMACAddLAId, scPortHistoryGoodPktsRec=scPortHistoryGoodPktsRec, lsPortHistoryEntry=lsPortHistoryEntry, scPortHistorySampleIndex=scPortHistorySampleIndex, lstIntPortLostFrames=lstIntPortLostFrames, lsPortHistoryTable=lsPortHistoryTable, lsBusStatsVirtualNetTable=lsBusStatsVirtualNetTable, lsBusStatsBadEthOctets=lsBusStatsBadEthOctets, lsHistoryStatsBadEthOctets=lsHistoryStatsBadEthOctets, lsPortEntry=lsPortEntry, lsHistoryTable=lsHistoryTable, lseGroupAssignSlots=lseGroupAssignSlots, lseGroupCAMClear=lseGroupCAMClear, lsVNChangeGroup=lsVNChangeGroup, lstIntPortBPEnable=lstIntPortBPEnable, lstIntPortBPTokenWindow=lstIntPortBPTokenWindow, lsHistoryStatsPkts=lsHistoryStatsPkts, lsBusStatsPriorityPkts=lsBusStatsPriorityPkts, lsePortTable=lsePortTable, lsPortHistoryIndex=lsPortHistoryIndex, lsPortControlLastDeleteTime=lsPortControlLastDeleteTime, lstIntPortInOctets=lstIntPortInOctets, lseGroupNormOpCl=lseGroupNormOpCl, lhsGroupEntry=lhsGroupEntry, lsePort=lsePort, lsBusStatsUtilization=lsBusStatsUtilization, alarmUtilitiesCommand=alarmUtilitiesCommand, lstIntPortRxEmpty0=lstIntPortRxEmpty0, ethTopDiscoveryTx=ethTopDiscoveryTx, lseIntPortFilterTable=lseIntPortFilterTable, lseIntPortMACAddress=lseIntPortMACAddress, lsVNChange=lsVNChange, lsPortNumber=lsPortNumber, lhsRxUCast=lhsRxUCast, lsHostTimePortCorrEntry=lsHostTimePortCorrEntry, lsPortControlTable=lsPortControlTable, lhsRxRscErr=lhsRxRscErr, lsHistoryStatsPriority2Octets=lsHistoryStatsPriority2Octets, lseIntPortGlobal=lseIntPortGlobal, lseIntPortFilterGroupId=lseIntPortFilterGroupId, lseIntPortFilteringMethod=lseIntPortFilteringMethod, lstIntPortTotalTraffic=lstIntPortTotalTraffic, lseGroupId=lseGroupId, lhsGroupProtocolType=lhsGroupProtocolType, lsHistoryStatsDropEvents=lsHistoryStatsDropEvents, lsHistoryStatsEthBroadcastPkts=lsHistoryStatsEthBroadcastPkts, lhsPortGroupId=lhsPortGroupId, lsPortInTooLongPkts=lsPortInTooLongPkts, lstIntPortSliceLength=lstIntPortSliceLength, lseGroupBackbone12=lseGroupBackbone12, lsPortInCollisions=lsPortInCollisions, lsHostFilterTable=lsHostFilterTable, ethTopMessageResult=ethTopMessageResult, lsPortControlTableSize=lsPortControlTableSize, lsBusStatsPkts=lsBusStatsPkts, lsHistoryStatsPriority2Pkts=lsHistoryStatsPriority2Pkts, lstIntPortTransmitWindow=lstIntPortTransmitWindow, vnsPacketPortId=vnsPacketPortId, lstIntPortRxFull=lstIntPortRxFull, lhsRxParErr=lhsRxParErr, lseGroupIPGDataLength=lseGroupIPGDataLength, lsPortInFCSErrors=lsPortInFCSErrors, lseIntPortPriorityStateMachine=lseIntPortPriorityStateMachine, ethTopLSA=ethTopLSA, lseGroupEntry=lseGroupEntry, lseIntPortSecurity=lseIntPortSecurity, lstIntPortLocalTraffic=lstIntPortLocalTraffic, lsPortInBroadcastPkts=lsPortInBroadcastPkts, lseWANGroupId=lseWANGroupId, lhsTxMCast=lhsTxMCast, lsHostPortFilterTable=lsHostPortFilterTable, scPortHistoryCollisions=scPortHistoryCollisions, lsHistoryIndex=lsHistoryIndex, lse=lse, lsHistorySampleIndex=lsHistorySampleIndex, lstIntPortTotalOctets=lstIntPortTotalOctets, vnsPacketBackbonePort=vnsPacketBackbonePort, lsBusStatsPriorityEntry=lsBusStatsPriorityEntry, lsMatrixFilterEntry=lsMatrixFilterEntry, vnsPacketIPNetMask=vnsPacketIPNetMask)
mibBuilder.exportSymbols("APPLIC-MIB", lsHistoryStatsBadEthPkts=lsHistoryStatsBadEthPkts, lsPortInTotalErrors=lsPortInTotalErrors, lst=lst, scPortHistoryTable=scPortHistoryTable, lseIntPortCompanyMAC=lseIntPortCompanyMAC, ethTopLSAId=ethTopLSAId, lsMatrixFilterStatus=lsMatrixFilterStatus, ethTopAddressTable=ethTopAddressTable, scPortHistoryBoxConfiguration=scPortHistoryBoxConfiguration, lsPortExtendedStatsNumber=lsPortExtendedStatsNumber, lsHistoryIntervalTime=lsHistoryIntervalTime, lseIntPortIgnoreRoutingMode=lseIntPortIgnoreRoutingMode, lsVNChangeDetected=lsVNChangeDetected, lseIntPortAlignment=lseIntPortAlignment, lseGroupAutoPartitionEnable=lseGroupAutoPartitionEnable, lseGroupJamPrevent=lseGroupJamPrevent, hostTimeAddress=hostTimeAddress, lseIntPortPriorityLevel=lseIntPortPriorityLevel, topDiscovery=topDiscovery, portHistoryExtendedControlEntry=portHistoryExtendedControlEntry, lsHistoryStatsGoodEthOctets=lsHistoryStatsGoodEthOctets, lstIntPortUNAddr=lstIntPortUNAddr, lsePortBackboneStatus=lsePortBackboneStatus, lstIntPortDummyMV=lstIntPortDummyMV, lsPortHistoryTotalErrors=lsPortHistoryTotalErrors, lseGroupBackoffFromJam=lseGroupBackoffFromJam, lseIntPortRxEmpty1=lseIntPortRxEmpty1, portHistory=portHistory, lsPortHistoryBoxConfiguration=lsPortHistoryBoxConfiguration, lsHistoryEntry=lsHistoryEntry, scPortHistoryGoodPktsSent=scPortHistoryGoodPktsSent, lsBusStatsVirtualNetList=lsBusStatsVirtualNetList, lseIntPortSetFilter=lseIntPortSetFilter, lhsPortTable=lhsPortTable, lseIntPortFilter=lseIntPortFilter, lstIntPortRxEmpty1=lstIntPortRxEmpty1, lstIntPortClaimFrames=lstIntPortClaimFrames, lseIntPortFilterPortId=lseIntPortFilterPortId, lseIntPortIOMode=lseIntPortIOMode, lhsRxBCast=lhsRxBCast, lsHostPortFilterStatus=lsHostPortFilterStatus, lsBusStatsNonEthPkts=lsBusStatsNonEthPkts, lseIntPortRetryPriorityLevel2=lseIntPortRetryPriorityLevel2, lstIntPortBlockingPriority=lstIntPortBlockingPriority, lseIntPortRxEmpty2=lseIntPortRxEmpty2, lseIntPortFilterLAId=lseIntPortFilterLAId, lsHistoryStatsOctets=lsHistoryStatsOctets, ethTopNumOfMessageResults=ethTopNumOfMessageResults, lseGroupFastOpen=lseGroupFastOpen, scPortHistoryIntervalTime=scPortHistoryIntervalTime, lsPortControlEntry=lsPortControlEntry, lseWANEntry=lseWANEntry, lstIntPortRouteSideband=lstIntPortRouteSideband, lsPortControlStatus=lsPortControlStatus, lseIntPortFilterList=lseIntPortFilterList, lsPortFilterTableClear=lsPortFilterTableClear, lhsLinkStatus=lhsLinkStatus, lsVNChangeExpected=lsVNChangeExpected, lsPortTable=lsPortTable, ethTopMACFindList=ethTopMACFindList, scPortHistoryGoodNonUnicastPktsRec=scPortHistoryGoodNonUnicastPktsRec, lseIntPortGroupId=lseIntPortGroupId, lseIntPortIgnoreBusy=lseIntPortIgnoreBusy, lseIntPortTxBurstLength=lseIntPortTxBurstLength, lhs=lhs, ethTopMACFindResultTable=ethTopMACFindResultTable, ethTop=ethTop, lseGroupSetDefaults=lseGroupSetDefaults, lsBusStatsNonEthOctets=lsBusStatsNonEthOctets, lstIntPortSidebandMode=lstIntPortSidebandMode, lsMatrixFilterAddress=lsMatrixFilterAddress, lseGroupBackbone34=lseGroupBackbone34, lsVNChangePort=lsVNChangePort, lhsGroupTable=lhsGroupTable, vnsPacketBoxAgentIP=vnsPacketBoxAgentIP, lsePortId=lsePortId, lsPortControlIndex=lsPortControlIndex, lsePortPolarity=lsePortPolarity, lsPortIndex=lsPortIndex, lsPortExtendedReportingList=lsPortExtendedReportingList, lstIntPortEntry=lstIntPortEntry, lseIntPortRxSafetyZone=lseIntPortRxSafetyZone, lsHostFilterStatus=lsHostFilterStatus, lhsGroupMainSWVersion=lhsGroupMainSWVersion, ethTopMessageResultTable=ethTopMessageResultTable, lstIntPortBPDummyWindow=lstIntPortBPDummyWindow, lhsRxMCast=lhsRxMCast, lseIntPortTxReject=lseIntPortTxReject, lseIntPortActiveBroadcastPriority=lseIntPortActiveBroadcastPriority, ethTopLSAEntry=ethTopLSAEntry, lsPortControlOwner=lsPortControlOwner, lseIntPortResetSwitchCAM=lseIntPortResetSwitchCAM, lsHostPortFilterTableClear=lsHostPortFilterTableClear, lstIntPortTotalFrames=lstIntPortTotalFrames, alarmMonitorStatusIndex=alarmMonitorStatusIndex, lhsPortId=lhsPortId, lstIntPortTxBufFullThresh=lstIntPortTxBufFullThresh, lsHistoryStatsPriority3Pkts=lsHistoryStatsPriority3Pkts)

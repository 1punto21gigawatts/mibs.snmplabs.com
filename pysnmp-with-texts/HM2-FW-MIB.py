#
# PySNMP MIB module HM2-FW-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/HM2-FW-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:31:27 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, SingleValueConstraint, ConstraintsIntersection, ValueSizeConstraint, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "SingleValueConstraint", "ConstraintsIntersection", "ValueSizeConstraint", "ValueRangeConstraint")
HmActionValue, hm2ConfigurationMibs, HmTimeSeconds1970, HmEnabledStatus = mibBuilder.importSymbols("HM2-TC-MIB", "HmActionValue", "hm2ConfigurationMibs", "HmTimeSeconds1970", "HmEnabledStatus")
InterfaceIndex, = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ObjectGroup, ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "ModuleCompliance", "NotificationGroup")
Gauge32, MibIdentifier, Counter32, IpAddress, MibScalar, MibTable, MibTableRow, MibTableColumn, NotificationType, ObjectIdentity, Bits, Counter64, Integer32, TimeTicks, iso, ModuleIdentity, Unsigned32 = mibBuilder.importSymbols("SNMPv2-SMI", "Gauge32", "MibIdentifier", "Counter32", "IpAddress", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "NotificationType", "ObjectIdentity", "Bits", "Counter64", "Integer32", "TimeTicks", "iso", "ModuleIdentity", "Unsigned32")
RowStatus, TruthValue, DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "RowStatus", "TruthValue", "DisplayString", "TextualConvention")
hm2FwMib = ModuleIdentity((1, 3, 6, 1, 4, 1, 248, 11, 79))
hm2FwMib.setRevisions(('2011-09-13 00:00', '2011-07-01 00:00', '2011-06-14 00:00', '2011-05-31 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: hm2FwMib.setRevisionsDescriptions(('- Modified Interface Mapping Table for L3 and DynFw - Use HmActionValue instead of TruthValue ', '- Modifications to address representation ', '- Restructured IF mapping tables - Added variable for pending actions', 'Initial version.',))
if mibBuilder.loadTexts: hm2FwMib.setLastUpdated('201109130000Z')
if mibBuilder.loadTexts: hm2FwMib.setOrganization('Hirschmann Automation and Control GmbH')
if mibBuilder.loadTexts: hm2FwMib.setContactInfo('Postal: Stuttgarter Str. 45-51 72654 Neckartenzlingen Germany Phone: +49 - 7127 -14 -0 E-mail: hac.support@belden.com')
if mibBuilder.loadTexts: hm2FwMib.setDescription('SNMP interface for Hirschmann Firewall modules. Copyright (C) ')
hm2FwNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 79, 0))
hm2FwObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 79, 1))
hm2FwConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 79, 2))
hm2FwGeneralSettings = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 1))
hm2DynFw = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 2))
hm2L3Fw = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 3))
hm2FwLearningMode = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 4))
hm2DynFwMaxRules = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DynFwMaxRules.setStatus('current')
if mibBuilder.loadTexts: hm2DynFwMaxRules.setDescription('Maximum number of allowed rules for dynamic firewalling.')
hm2L3MaxRules = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2L3MaxRules.setStatus('current')
if mibBuilder.loadTexts: hm2L3MaxRules.setDescription('Maximum number of allowed rules for L3 firewalling.')
hm2ResetStatistics = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 1, 3), HmActionValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2ResetStatistics.setStatus('current')
if mibBuilder.loadTexts: hm2ResetStatistics.setDescription('Setting this value to action(2) will reset the statistics of the whole firewall module. It will be set to noop(1) automatically after reset.')
hm2FlushTables = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 1, 4), HmActionValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2FlushTables.setStatus('current')
if mibBuilder.loadTexts: hm2FlushTables.setDescription('Setting this value to action(2) will flush all connection tracking states. It will be set to noop(1) automatically after table flush.')
hm2DefaultPolicy = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("accept", 1), ("drop", 2), ("reject", 3))).clone('accept')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2DefaultPolicy.setStatus('current')
if mibBuilder.loadTexts: hm2DefaultPolicy.setDescription('The default policy for forwarding packets: o accept(1): Packets matching this rule are accepted and will be forwarded o drop(2): Packets matching this rule will be silently discarded o reject(3): Packets matching this rule will be dropped and the originator gets informed by an ICMP message')
hm2ConnTrackValidateCheckSum = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 1, 6), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2ConnTrackValidateCheckSum.setStatus('current')
if mibBuilder.loadTexts: hm2ConnTrackValidateCheckSum.setDescription('This value describes, whether the Firewall connection tracking in the Linux kernel shall validate the protocol checksums. Disable this validation (false) improves routing throughput.')
hm2DynFwRuleAppliedTrap = NotificationType((1, 3, 6, 1, 4, 1, 248, 11, 79, 0, 1)).setObjects(("HM2-FW-MIB", "hm2DynFwRuleIndex"))
if mibBuilder.loadTexts: hm2DynFwRuleAppliedTrap.setStatus('current')
if mibBuilder.loadTexts: hm2DynFwRuleAppliedTrap.setDescription('A rule of the dynamic firewall was applied. The rule is identified by the given rule index of the rule table.')
hm2DynFwRuleAppliedAndLoggedTrap = NotificationType((1, 3, 6, 1, 4, 1, 248, 11, 79, 0, 2)).setObjects(("HM2-FW-MIB", "hm2DynFwRuleIndex"))
if mibBuilder.loadTexts: hm2DynFwRuleAppliedAndLoggedTrap.setStatus('current')
if mibBuilder.loadTexts: hm2DynFwRuleAppliedAndLoggedTrap.setDescription('A rule of the dynamic firewall was applied and logged according to the current logging mechanism. The rule is identified by the given rule index of the rule table.')
hm2DynFwRuleObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 2, 1))
hm2DynFwRuleCount = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DynFwRuleCount.setStatus('current')
if mibBuilder.loadTexts: hm2DynFwRuleCount.setDescription('Number of current dynamic firewalls rules')
hm2DynFwIfMappingRuleCount = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DynFwIfMappingRuleCount.setStatus('current')
if mibBuilder.loadTexts: hm2DynFwIfMappingRuleCount.setDescription('Number of current DynFw IF mapping entries.')
hm2DynFwRulePendingActions = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 2, 1, 3), TruthValue().clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DynFwRulePendingActions.setStatus('current')
if mibBuilder.loadTexts: hm2DynFwRulePendingActions.setDescription('This value describes, whether the DynFW rule table was modified but not yet written to the firewall implementation (set to true). After writing all modifications to the firewall, the value switches automatically back to false.')
hm2DynFwCommitPendingActions = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 2, 1, 4), HmActionValue().clone('noop')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2DynFwCommitPendingActions.setStatus('current')
if mibBuilder.loadTexts: hm2DynFwCommitPendingActions.setDescription('Setting this value to action(2) writes not yet committed changes to the firewall (DynFW and Interface Mapping Table). After writing all modifications, the value switches automatically back to noop(1).')
hm2DynFwRuleTables = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 2, 2))
hm2DynFwRuleTable = MibTable((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 2, 2, 1), )
if mibBuilder.loadTexts: hm2DynFwRuleTable.setStatus('current')
if mibBuilder.loadTexts: hm2DynFwRuleTable.setDescription('The list of rules for this dynamic firewall')
hm2DynFwRuleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 2, 2, 1, 1), ).setIndexNames((0, "HM2-FW-MIB", "hm2DynFwRuleIndex"))
if mibBuilder.loadTexts: hm2DynFwRuleEntry.setStatus('current')
if mibBuilder.loadTexts: hm2DynFwRuleEntry.setDescription('Dynamic firewall rule entry.')
hm2DynFwRuleIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 2, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 512))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hm2DynFwRuleIndex.setStatus('current')
if mibBuilder.loadTexts: hm2DynFwRuleIndex.setDescription('Rule index of this dynamic firewall rule')
hm2DynFwSourceAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 2, 2, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 20)).clone('any')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2DynFwSourceAddress.setStatus('current')
if mibBuilder.loadTexts: hm2DynFwSourceAddress.setDescription("The source address of the packet to filter. Allowed formats are: - keyword 'any' - single address ('10.0.0.1') - CIDR address range ('10.0.0.0/8') - netobject ('$name') ")
hm2DynFwSourcePort = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 2, 2, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 50)).clone('any')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2DynFwSourcePort.setStatus('current')
if mibBuilder.loadTexts: hm2DynFwSourcePort.setDescription("The source port of the packet to filter. Allowed formats are: - keyword 'any' - single port ('10') - port range with first and last port separated by hyphen ('10-15') - comma separated list of ports ('1235,25,123') - combination of the points above ('10,25-30,125,1993') The number of named ports (1 for each individual port, 2 for port ranges) must not exceed 15. ")
hm2DynFwTargetAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 2, 2, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 20)).clone('any')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2DynFwTargetAddress.setStatus('current')
if mibBuilder.loadTexts: hm2DynFwTargetAddress.setDescription("The destination address of the packet to filter. Allowed formats are: - keyword 'any' - single address ('10.0.0.1') - CIDR address range ('10.0.0.0/8') - netobject ('$name') ")
hm2DynFwTargetPort = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 2, 2, 1, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 50)).clone('any')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2DynFwTargetPort.setStatus('current')
if mibBuilder.loadTexts: hm2DynFwTargetPort.setDescription("The destination port of the packet to filter. Allowed formats are: - keyword 'any' - single port ('10') - port range with first and last port separated by hyphen ('10-15') - comma separated list of ports ('1235,25,123') - combination of the points above ('10,25-30,125,1993') The number of named ports (1 for each individual port, 2 for port ranges) must not exceed 15. ")
hm2DynFwProto = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 2, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("icmp", 1), ("igmp", 2), ("ipip", 3), ("tcp", 4), ("udp", 5), ("esp", 6), ("ah", 7), ("icmpv6", 8), ("any", 9))).clone('any')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2DynFwProto.setStatus('current')
if mibBuilder.loadTexts: hm2DynFwProto.setDescription('The IP protocol (RFC 791) for protocol-independent filtering. The following values are currently supported: o icmp(1): internet control message protocol (RFC 792) o igmp(2): internet group management protocol o ipip(3): IP in IP tunnelling (RFC 1853) o tcp(4): transmission control protocol (RFC 793) o udp(5): user datagram protocol (RFC 768) o esp(6): IPsec encapsulated security payload (RFC 2406) o ah(7): IPsec authentication header (RFC 2402) o icmpv6(8): internet control message protocol for IPv6 o any(9): apply to all protocols')
hm2DynFwRuleParams = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 2, 2, 1, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 50))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2DynFwRuleParams.setStatus('current')
if mibBuilder.loadTexts: hm2DynFwRuleParams.setDescription('Additional parameters to this rule as string. A parameter has the syntax: <param>=<val> Parameters are separated by a comma. If more than one value is given for a parameter, values are separated by a |-sign Following paramters are defined based on the different protocols: o icmp: type=<ICMP type> (specify ICMP type to filter) code=<ICMP code> (specify ICMP code to filter) o tcp: frag=<true/false> (apply to fragments) flags=<SYN/ACK/FIN> (apply to packets with give flags o udp/tcp: state=<new/rel/est> (apply to packets according current state of connection> o general: mac=<MAC> (specify source MAC address for this rule) ')
hm2DynFwAction = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 2, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("accept", 1), ("drop", 2), ("reject", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2DynFwAction.setStatus('current')
if mibBuilder.loadTexts: hm2DynFwAction.setDescription('The action of the corresponding rule: o accept(1): Packets matching this rule are accepted and will be forwarded o drop(2): Packets matching this rule will be silently discarded o reject(3): Packets matching this rule will be dropped and the originator gets informed by an ICMP message')
hm2DynFwLog = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 2, 2, 1, 1, 9), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2DynFwLog.setStatus('current')
if mibBuilder.loadTexts: hm2DynFwLog.setDescription('Set to true if application of this rule shall be logged')
hm2DynFwTrap = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 2, 2, 1, 1, 10), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2DynFwTrap.setStatus('current')
if mibBuilder.loadTexts: hm2DynFwTrap.setDescription('Set to true if application of this rule shall send a trap.')
hm2DynFwRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 2, 2, 1, 1, 11), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2DynFwRowStatus.setStatus('current')
if mibBuilder.loadTexts: hm2DynFwRowStatus.setDescription('This is a standard row status value: - active(1): The rule is active. Note that until committed, the rule will not be applied. - notInService(2): The rule is inactive because of user action. - notReady(3): The rule is inactive because of agent action. - createAndGo(4): Create the rule with default parameters activated. - createAndWait(5): Create the rule inactive. - destroy(6): Delete the rule. You cannot delete a rule with interface mappings to it.')
hm2DynFwDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 2, 2, 1, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2DynFwDescription.setStatus('current')
if mibBuilder.loadTexts: hm2DynFwDescription.setDescription('User defined textual description related to this rule.')
hm2DynFwRuleIfMappingTable = MibTable((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 2, 2, 2), )
if mibBuilder.loadTexts: hm2DynFwRuleIfMappingTable.setStatus('current')
if mibBuilder.loadTexts: hm2DynFwRuleIfMappingTable.setDescription('Table for mapping L3 rules to interfaces')
hm2DynFwRuleIfMappingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 2, 2, 2, 1), ).setIndexNames((0, "HM2-FW-MIB", "hm2DynFwIfmInterface"), (0, "HM2-FW-MIB", "hm2DynFwIfmDirection"), (0, "HM2-FW-MIB", "hm2DynFwIfmRuleIndex"))
if mibBuilder.loadTexts: hm2DynFwRuleIfMappingEntry.setStatus('current')
if mibBuilder.loadTexts: hm2DynFwRuleIfMappingEntry.setDescription('Entry in rule interface mapping table')
hm2DynFwIfmRuleIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 2, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2048)))
if mibBuilder.loadTexts: hm2DynFwIfmRuleIndex.setStatus('current')
if mibBuilder.loadTexts: hm2DynFwIfmRuleIndex.setDescription('The index of the DynFw rule this mapping entry is assigned to. The DynFw rule must exist before creation of mapping entry.')
hm2DynFwIfmDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 2, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ingress", 1), ("egress", 2), ("both", 3))))
if mibBuilder.loadTexts: hm2DynFwIfmDirection.setStatus('current')
if mibBuilder.loadTexts: hm2DynFwIfmDirection.setDescription('Meanings: - ingress(1): Apply this rule to packets arriving on this interface - egress(2): Apply this rule to packets leaving from this interface - both(3): Apply this rule to packets coming in and going out on this interface. If an ingress and an egress interface are given, this is taken to mean that the rule shall apply to packets arriving on the ingress interface AND to be leaving on the egress interface. A rule without ingress interface matches on all packets going out to the egress interface given, and vice versa.')
hm2DynFwIfmPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 2, 2, 2, 1, 3), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2DynFwIfmPriority.setStatus('current')
if mibBuilder.loadTexts: hm2DynFwIfmPriority.setDescription("The priority is the sorting key for rules in to this interface. They don't need to be unique, but no clear order can be assumed among rules with the same priority. Priorities are processed in ascending order (0 highest priority).")
hm2DynFwIfmInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 2, 2, 2, 1, 4), InterfaceIndex())
if mibBuilder.loadTexts: hm2DynFwIfmInterface.setStatus('current')
if mibBuilder.loadTexts: hm2DynFwIfmInterface.setDescription('The interface this mapping entry is applied to. This has to be either an hm2AgentSwitchIpInterfaceIfIndex or an hm2AgentSwitchIpVlanIfIndex. Note that for physical interfaces this only works if the corresponding hm2AgentSwitchIpInterfaceRoutingMode is set to enable.')
hm2DynFwIfmRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 2, 2, 2, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2DynFwIfmRowStatus.setStatus('current')
if mibBuilder.loadTexts: hm2DynFwIfmRowStatus.setDescription('The RowStatus value for this entry with the usual meanings: - active(1): The interface mapping is in place - notInService(2): The interface mapping is not in place because the user said so - notReady(3): The interface mapping is not in place because the agent said so - createAndGo(4): Create this mapping with the default priority and activate it. - createAndWait(5): Create this mapping deactivated. - destroy(6): Destroy this interface mapping.')
hm2DynFwStats = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 2, 4))
hm2DynFwGeneralStats = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 2, 4, 1))
hm2DynFwStatsTtPck = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 2, 4, 1, 1), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DynFwStatsTtPck.setStatus('current')
if mibBuilder.loadTexts: hm2DynFwStatsTtPck.setDescription('Total number of packets processed by the dynamic firewall')
hm2DynFwStatsTtPckSize = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 2, 4, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DynFwStatsTtPckSize.setStatus('current')
if mibBuilder.loadTexts: hm2DynFwStatsTtPckSize.setDescription('Total number of bytes processed by the dynamic firewall')
hm2DynFwStatsTtPckDenDrop = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 2, 4, 1, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DynFwStatsTtPckDenDrop.setStatus('current')
if mibBuilder.loadTexts: hm2DynFwStatsTtPckDenDrop.setDescription('Total number of packets dropped or denied by the dynamic firewall')
hm2DynFwStatsTtPckAccepted = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 2, 4, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DynFwStatsTtPckAccepted.setStatus('current')
if mibBuilder.loadTexts: hm2DynFwStatsTtPckAccepted.setDescription('Total number of packets accepted by the dynamic firewall')
hm2DynFwStatsTables = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 2, 4, 2))
hm2DynFwStatsRuleTable = MibTable((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 2, 4, 2, 1), )
if mibBuilder.loadTexts: hm2DynFwStatsRuleTable.setStatus('current')
if mibBuilder.loadTexts: hm2DynFwStatsRuleTable.setDescription('Table of per-rule statistics of the dynamic firewall')
hm2DynFwStatsRuleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 2, 4, 2, 1, 1), ).setIndexNames((0, "HM2-FW-MIB", "hm2DynFwRuleIndex"))
if mibBuilder.loadTexts: hm2DynFwStatsRuleEntry.setStatus('current')
if mibBuilder.loadTexts: hm2DynFwStatsRuleEntry.setDescription('Statistics table entry for the dynamic firewall')
hm2DynFwStatsPacketCount = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 2, 4, 2, 1, 1, 1), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DynFwStatsPacketCount.setStatus('current')
if mibBuilder.loadTexts: hm2DynFwStatsPacketCount.setDescription('Number of packets matched by this rule')
hm2DynFwStatsPacketSize = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 2, 4, 2, 1, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DynFwStatsPacketSize.setStatus('current')
if mibBuilder.loadTexts: hm2DynFwStatsPacketSize.setDescription('Number of bytes processed by this rule')
hm2DynFwStatsLastApplied = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 2, 4, 2, 1, 1, 3), HmTimeSeconds1970()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DynFwStatsLastApplied.setStatus('current')
if mibBuilder.loadTexts: hm2DynFwStatsLastApplied.setDescription('Local system time (hm2SystemLocalTime) when the rule was applied the last time')
hm2L3RuleAppliedTrap = NotificationType((1, 3, 6, 1, 4, 1, 248, 11, 79, 0, 3)).setObjects(("HM2-FW-MIB", "hm2L3RuleIndex"))
if mibBuilder.loadTexts: hm2L3RuleAppliedTrap.setStatus('current')
if mibBuilder.loadTexts: hm2L3RuleAppliedTrap.setDescription('A rule of the L3 firewall was applied. The rule is identified by the given rule index of the rule table.')
hm2L3RuleAppliedAndLoggedTrap = NotificationType((1, 3, 6, 1, 4, 1, 248, 11, 79, 0, 4)).setObjects(("HM2-FW-MIB", "hm2L3RuleIndex"))
if mibBuilder.loadTexts: hm2L3RuleAppliedAndLoggedTrap.setStatus('current')
if mibBuilder.loadTexts: hm2L3RuleAppliedAndLoggedTrap.setDescription('A rule of the L3 firewall was applied and logged according the current logging mechanism. The rule is identified by the given rule index of the rule table.')
hm2L3RuleObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 3, 1))
hm2L3RuleCount = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2L3RuleCount.setStatus('current')
if mibBuilder.loadTexts: hm2L3RuleCount.setDescription('Number of current L3 rules')
hm2L3IfMappingRuleCount = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2L3IfMappingRuleCount.setStatus('current')
if mibBuilder.loadTexts: hm2L3IfMappingRuleCount.setDescription('Number of current L3 IF mapping entries.')
hm2L3RulePendingActions = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 3, 1, 3), TruthValue().clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2L3RulePendingActions.setStatus('current')
if mibBuilder.loadTexts: hm2L3RulePendingActions.setDescription('This value describes, whether the L3 rule table was modified but not yet written to the firewall implementation (set to true). After writing all modifications to the firewall, the value switches automatically back to false.')
hm2L3CommitPendingActions = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 3, 1, 4), HmActionValue().clone('noop')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2L3CommitPendingActions.setStatus('current')
if mibBuilder.loadTexts: hm2L3CommitPendingActions.setDescription('Setting this value to action(2) writes not yet committed changes to the firewall (L3 and Interface Mapping Table). After writing all modifications, the value switches automatically back to noop(1).')
hm2L3RuleTables = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 3, 2))
hm2L3RuleTable = MibTable((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 3, 2, 1), )
if mibBuilder.loadTexts: hm2L3RuleTable.setStatus('current')
if mibBuilder.loadTexts: hm2L3RuleTable.setDescription('The list of L3 rules for this firewall')
hm2L3RuleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 3, 2, 1, 1), ).setIndexNames((0, "HM2-FW-MIB", "hm2L3RuleIndex"))
if mibBuilder.loadTexts: hm2L3RuleEntry.setStatus('current')
if mibBuilder.loadTexts: hm2L3RuleEntry.setDescription('L3 rule entry.')
hm2L3RuleIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 3, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2048))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hm2L3RuleIndex.setStatus('current')
if mibBuilder.loadTexts: hm2L3RuleIndex.setDescription('Rule index of this L3 rule')
hm2L3SourceAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 3, 2, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 20)).clone('any')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2L3SourceAddress.setStatus('current')
if mibBuilder.loadTexts: hm2L3SourceAddress.setDescription("The source address of the packet to filter. Allowed formats are: - keyword 'any' - single address ('10.0.0.1') - CIDR address range ('10.0.0.0/8') - netobject ('$name') - a prepending '!' selects the complement set ")
hm2L3SourcePort = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 3, 2, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 50)).clone('any')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2L3SourcePort.setStatus('current')
if mibBuilder.loadTexts: hm2L3SourcePort.setDescription("The source port of the packet to reroute. Allowed formats are: - keyword 'any' - single port ('10') - port range with first and last port separated by hyphen ('10-15') - comma separated list of ports ('1235,25,123') - combination of the points above ('10,25-30,125,1993') The number of named ports (1 for each individual port, 2 for port ranges) must not exceed 15. ")
hm2L3TargetAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 3, 2, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 20)).clone('any')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2L3TargetAddress.setStatus('current')
if mibBuilder.loadTexts: hm2L3TargetAddress.setDescription("The destination address of the packet to filter. Allowed formats are: - keyword 'any' - single address ('10.0.0.1') - CIDR address range ('10.0.0.0/8') - netobject ('$name') ")
hm2L3TargetPort = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 3, 2, 1, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 50)).clone('any')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2L3TargetPort.setStatus('current')
if mibBuilder.loadTexts: hm2L3TargetPort.setDescription("The destination port of the packet to. Allowed formats are: - keyword 'any' - single port ('10') - port range with first and last port separated by hyphen ('10-15') - comma separated list of ports ('1235,25,123') - combination of the points above ('10,25-30,125,1993') The number of named ports (1 for each individual port, 2 for port ranges) must not exceed 15. ")
hm2L3Proto = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 3, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("icmp", 1), ("igmp", 2), ("ipip", 3), ("tcp", 4), ("udp", 5), ("esp", 6), ("ah", 7), ("icmpv6", 8), ("any", 9))).clone('any')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2L3Proto.setStatus('current')
if mibBuilder.loadTexts: hm2L3Proto.setDescription('The IP protocol (RFC 791) for protocol-independent filtering. The following values are currently supported: o icmp(1): internet control message protocol (RFC 792) o igmp(2): internet group management protocol o ipip(3): IP in IP tunnelling (RFC 1853) o tcp(4): transmission control protocol (RFC 793) o udp(5): user datagram protocol (RFC 768) o esp(6): IPsec encapsulated security payload (RFC 2406) o ah(7): IPsec authentication header (RFC 2402) o icmpv6(8): internet control message protocol for IPv6 o any(9): apply to all protocols')
hm2L3RuleParams = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 3, 2, 1, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 50))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2L3RuleParams.setStatus('current')
if mibBuilder.loadTexts: hm2L3RuleParams.setDescription('Additional parameters to this rule as string. A parameter has the syntax: <param>=<val> Parameters are separated by a comma. If more than one value is given for a parameter, values are separated by a |-sign (pipe). Following parameters are defined based on the different protocols: o icmp: type=<ICMP type> (specify ICMP type to filter) code=<ICMP code> (specify ICMP code to filter) o tcp: flags=<SYN/ACK/FIN> (apply to packets with given flags) o general: state=<new/rel/est> (apply to packets according to current state of connection>) mac=<MAC> (specify source MAC address for this rule) frag=<true/false> (apply to fragments) ')
hm2L3Action = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 3, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("accept", 1), ("drop", 2), ("reject", 3), ("enforce-modbus", 4), ("enforce-opc", 5)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2L3Action.setStatus('current')
if mibBuilder.loadTexts: hm2L3Action.setDescription('The action of the corresponding rule: o accept(1): Packets matching this rule are accepted and will be forwarded o drop(2): Packets matching this rule will be silently discarded o reject(3): Packets matching this rule will be dropped and the originator gets informed by an ICMP message o enforce-modbus(4): Packets matching this rule are enforced by modbus enforcer and will be forwarded or discarded. The selected protocol should be tcp or udp o enforce-opc(5): Packets matching this rule are enforced by opc enforcer and will be forwarded or discarded. The selected protocol should be tcp')
hm2L3Log = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 3, 2, 1, 1, 9), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2L3Log.setStatus('current')
if mibBuilder.loadTexts: hm2L3Log.setDescription('Set to true if application of this rule shall be logged')
hm2L3Trap = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 3, 2, 1, 1, 10), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2L3Trap.setStatus('current')
if mibBuilder.loadTexts: hm2L3Trap.setDescription('Set to true if application of this rule shall send a trap.')
hm2L3RowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 3, 2, 1, 1, 11), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2L3RowStatus.setStatus('current')
if mibBuilder.loadTexts: hm2L3RowStatus.setDescription('This is a standard row status value: - active(1): The rule is active. Note that until committed, the rule will not be applied. You cannot activate the rule if an enforcer mappings to an inactive profile. - notInService(2): The rule is inactive because of user action. - notReady(3): The rule is inactive because of agent action. - createAndGo(4): Create the rule with default parameters activated. - createAndWait(5): Create the rule inactive. - destroy(6): Delete the rule. You cannot delete a rule with interface mappings to it.')
hm2L3Description = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 3, 2, 1, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2L3Description.setStatus('current')
if mibBuilder.loadTexts: hm2L3Description.setDescription('User defined textual description related to this rule.')
hm2DPIProfileIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 3, 2, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2DPIProfileIndex.setStatus('current')
if mibBuilder.loadTexts: hm2DPIProfileIndex.setDescription('The index of the DPI profile this rule is assigned to depending on enforcer action. Value 0 no DPI profile this rule is assigned to. You cannot assign the rule to an inactive profile if an active enforcer will mapping to it.')
hm2L3RuleIfMappingTable = MibTable((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 3, 2, 2), )
if mibBuilder.loadTexts: hm2L3RuleIfMappingTable.setStatus('current')
if mibBuilder.loadTexts: hm2L3RuleIfMappingTable.setDescription('Table for mapping L3 rules to interfaces')
hm2L3RuleIfMappingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 3, 2, 2, 1), ).setIndexNames((0, "HM2-FW-MIB", "hm2L3IfmInterface"), (0, "HM2-FW-MIB", "hm2L3IfmDirection"), (0, "HM2-FW-MIB", "hm2L3IfmRuleIndex"))
if mibBuilder.loadTexts: hm2L3RuleIfMappingEntry.setStatus('current')
if mibBuilder.loadTexts: hm2L3RuleIfMappingEntry.setDescription('Entry in rule interface mapping table')
hm2L3IfmRuleIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 3, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2048)))
if mibBuilder.loadTexts: hm2L3IfmRuleIndex.setStatus('current')
if mibBuilder.loadTexts: hm2L3IfmRuleIndex.setDescription('The index of the L3 rule this mapping entry is assigned to. The rule must exist before the mapping entry can be created.')
hm2L3IfmDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 3, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ingress", 1), ("egress", 2), ("both", 3))))
if mibBuilder.loadTexts: hm2L3IfmDirection.setStatus('current')
if mibBuilder.loadTexts: hm2L3IfmDirection.setDescription('Meanings: - ingress(1): Apply this rule to packets arriving on this interface - egress(2): Apply this rule to packets leaving from this interface - both(3): Apply this rule to packets coming in and going out on this interface. If an ingress and an egress interface are given, this is taken to mean that the rule shall apply to packets arriving on the ingress interface AND to-be leaving on the egress interface. A rule without ingress interface matches on all packets going out to the egress interface given, and vice versa.')
hm2L3IfmPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 3, 2, 2, 1, 3), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2L3IfmPriority.setStatus('current')
if mibBuilder.loadTexts: hm2L3IfmPriority.setDescription("The priority is the sorting key for rules in to this interface. They don't need to be unique, but no clear order can be assumed among rules with the same priority. Priorities are processed in ascending order (0 highest priority.")
hm2L3IfmInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 3, 2, 2, 1, 4), InterfaceIndex())
if mibBuilder.loadTexts: hm2L3IfmInterface.setStatus('current')
if mibBuilder.loadTexts: hm2L3IfmInterface.setDescription('The interface this mapping entry is assigned to. This has to be either an hm2AgentSwitchIpInterfaceIfIndex or an hm2AgentSwitchIpVlanIfIndex. Note that for physical interfaces this only works if the corresponding hm2AgentSwitchIpInterfaceRoutingMode is set to enable.')
hm2L3IfmRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 3, 2, 2, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2L3IfmRowStatus.setStatus('current')
if mibBuilder.loadTexts: hm2L3IfmRowStatus.setDescription('The RowStatus value for this entry with the usual meanings: - active(1): The interface mapping is in place - notInService(2): The interface mapping is not in place because the user said so - notReady(3): The interface mapping is not in place because the agent said so - createAndGo(4): Create this mapping with the default priority and activate it. - createAndWait(5): Create this mapping deactivated. - destroy(6): Destroy this interface mapping.')
hm2L3Stats = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 3, 4))
hm2L3GeneralStats = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 3, 4, 1))
hm2L3StatsTotalPck = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 3, 4, 1, 1), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2L3StatsTotalPck.setStatus('current')
if mibBuilder.loadTexts: hm2L3StatsTotalPck.setDescription('Total number of packets processed by the L3 firewall')
hm2L3StatsTotalPckSize = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 3, 4, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2L3StatsTotalPckSize.setStatus('current')
if mibBuilder.loadTexts: hm2L3StatsTotalPckSize.setDescription('Total number of bytes processed by the L3 firewall')
hm2L3StatsTotalPckDenDrop = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 3, 4, 1, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2L3StatsTotalPckDenDrop.setStatus('current')
if mibBuilder.loadTexts: hm2L3StatsTotalPckDenDrop.setDescription('Total number of packets dropped or denied by the L3 firewall')
hm2L3StatsTotalPckAccepted = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 3, 4, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2L3StatsTotalPckAccepted.setStatus('current')
if mibBuilder.loadTexts: hm2L3StatsTotalPckAccepted.setDescription('Total number of packets accepted by the L3 firewall')
hm2L3StatsTables = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 3, 4, 2))
hm2L3StatsRuleTable = MibTable((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 3, 4, 2, 1), )
if mibBuilder.loadTexts: hm2L3StatsRuleTable.setStatus('current')
if mibBuilder.loadTexts: hm2L3StatsRuleTable.setDescription('Table of per-rule statistics of the L3 firewall')
hm2L3StatsRuleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 3, 4, 2, 1, 1), ).setIndexNames((0, "HM2-FW-MIB", "hm2L3RuleIndex"))
if mibBuilder.loadTexts: hm2L3StatsRuleEntry.setStatus('current')
if mibBuilder.loadTexts: hm2L3StatsRuleEntry.setDescription('Statistics table entry for the L3 firewall')
hm2L3StatsPacketCount = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 3, 4, 2, 1, 1, 1), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2L3StatsPacketCount.setStatus('current')
if mibBuilder.loadTexts: hm2L3StatsPacketCount.setDescription('Number of packets matched by this rule')
hm2L3StatsPacketSize = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 3, 4, 2, 1, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2L3StatsPacketSize.setStatus('current')
if mibBuilder.loadTexts: hm2L3StatsPacketSize.setDescription('Number of bytes processed by this rule')
hm2L3StatsLastApplied = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 3, 4, 2, 1, 1, 3), HmTimeSeconds1970()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2L3StatsLastApplied.setStatus('current')
if mibBuilder.loadTexts: hm2L3StatsLastApplied.setDescription('Time of last application of the rule in seconds since the Unix epoch.')
hm2DPIProfileModbusObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 3, 11))
hm2DPIProfileModbusPendingActions = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 3, 11, 1), TruthValue().clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DPIProfileModbusPendingActions.setStatus('current')
if mibBuilder.loadTexts: hm2DPIProfileModbusPendingActions.setDescription('This value describes, whether the DPI MODBUS profile table was modified but not yet written to the enforcer implementation (set to true). After writing all modifications to the enforcer, the value switches automatically back to false.')
hm2DPIProfileModbusCommitPendingActions = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 3, 11, 2), HmActionValue().clone('noop')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2DPIProfileModbusCommitPendingActions.setStatus('current')
if mibBuilder.loadTexts: hm2DPIProfileModbusCommitPendingActions.setDescription('Setting this value to action(2) writes not yet committed changes to the enforcer (DPI MODBUS Profile Table). After writing all modifications, the value switches automatically back to noop(1).')
hm2DPIProfileOpcObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 3, 12))
hm2DPIProfileOpcPendingActions = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 3, 12, 1), TruthValue().clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DPIProfileOpcPendingActions.setStatus('current')
if mibBuilder.loadTexts: hm2DPIProfileOpcPendingActions.setDescription('This value describes, whether the L3 OPC profile table was modified but not yet written to the enforcer implementation (set to true). After writing all modifications to the enforcer, the value switches automatically back to false.')
hm2DPIProfileOpcCommitPendingActions = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 3, 12, 2), HmActionValue().clone('noop')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2DPIProfileOpcCommitPendingActions.setStatus('current')
if mibBuilder.loadTexts: hm2DPIProfileOpcCommitPendingActions.setDescription('Setting this value to action(2) writes not yet committed changes to the enforcer (DPI OPC Profile Table). After writing all modifications, the value switches automatically back to noop(1).')
hm2DPIProfileTables = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 3, 21))
hm2DPIProfileModbusTable = MibTable((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 3, 21, 1), )
if mibBuilder.loadTexts: hm2DPIProfileModbusTable.setStatus('current')
if mibBuilder.loadTexts: hm2DPIProfileModbusTable.setDescription('The list of DPI MODBUS profiles for this enforcer')
hm2DPIProfileModbusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 3, 21, 1, 1), ).setIndexNames((0, "HM2-FW-MIB", "hm2DPIProfileModbusIndex"))
if mibBuilder.loadTexts: hm2DPIProfileModbusEntry.setStatus('current')
if mibBuilder.loadTexts: hm2DPIProfileModbusEntry.setDescription('DPI MODBUS profile entry.')
hm2DPIProfileModbusIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 3, 21, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hm2DPIProfileModbusIndex.setStatus('current')
if mibBuilder.loadTexts: hm2DPIProfileModbusIndex.setDescription('Profile index of this DPI MODBUS profile')
hm2DPIProfileModbusDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 3, 21, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32)).clone('modbus')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2DPIProfileModbusDescription.setStatus('current')
if mibBuilder.loadTexts: hm2DPIProfileModbusDescription.setDescription('User defined textual description related to this profile.')
hm2DPIProfileModbusFunctionType = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 3, 21, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("readonly", 1), ("readwrite", 2), ("programming", 3), ("all", 4), ("advanced", 5))).clone('readonly')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2DPIProfileModbusFunctionType.setStatus('current')
if mibBuilder.loadTexts: hm2DPIProfileModbusFunctionType.setDescription('The function types of the corresponding function codes: o readonly(1): Selects read only function codes for the function code list. o readwrite(2): Selects read write function codes for the function code list. o programming(3): Selects programming function codes for the function code list. o all(4): Selects all possible function codes for the function code list. Any function code will be allowed. o advanced(5): Keeps the function code list from the previous selection and makes it editable by the user.')
hm2DPIProfileModbusFunctionCodeList = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 3, 21, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 1400)).clone('1,2,3,4,7,11,12,17,20,24')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2DPIProfileModbusFunctionCodeList.setStatus('current')
if mibBuilder.loadTexts: hm2DPIProfileModbusFunctionCodeList.setDescription('The function codes for this enforcer as string. A function code has the syntax: <val> Function codes are separated by a comma. If more than one value is given for a function code, values are separated by a | -sign (pipe). Following function codes are defined: <1..255>|<0-65535>|<0-65535> (apply to packets with given function codes <1..255>, address range <0-65535>, address range <0-65535>) 1|<0-65535> (apply to packets with given function code read coils, coil address range <0-65535>) 2|<0-65535> (apply to packets with given function code read discrete inputs, input address range <0-65535>) 3|<0-65535> (apply to packets with given function code read holding registers, register address range <0-65535>) 4|<0-65535> (apply to packets with given function code read input registers, register address range <0-65535>) 5|<0-65535> (apply to packets with given function code write single coil, coil address range <0-65535>) 6|<0-65535> (apply to packets with given function code write single register, register address range <0-65535>) 7 (apply to packets with given function code read exception status) 8 (apply to packets with given function code diagnostic) 11 (apply to packets with given function code get com event counter) 12 (apply to packets with given function code get comm event log) 13 (apply to packets with given function code program (584/984)) 14 (apply to packets with given function code poll (584/984)) 15|<0-65535> (apply to packets with given function code write multiple coils, coil address range <0-65535>) 16|<0-65535> (apply to packets with given function code write multiple registers, register address range <0-65535>) 17 (apply to packets with given function code report slave id) 20 (apply to packets with given function code read file record) 21 (apply to packets with given function code write file record) 22|<0-65535> (apply to packets with given function code mask write register, register address range <0-65535>) 23|<0-65535>|<0-65535> (apply to packets with given function code read/write multiple registers, read address range <0-65535>, write address range <0-65535>) 24|<0-65535> (apply to packets with given function code read fifo queue, pointer address range <0-65535>) 40 (apply to packets with given function code program (concept)) 42 (apply to packets with given function code concept symbol table) 43 (apply to packets with given function code encapsulated interface transport) 48 (apply to packets with given function code advantech co. ltd. - management functions) 66 (apply to packets with given function code scan data inc. - expanded read holding registers) 67 (apply to packets with given function code scan data inc. - expanded write holding registers) 90 (apply to packets with given function code unity programming/ofs) 100 (apply to packets with given function code scattered register read) 125 (apply to packets with given function code schneider electric - firmware replacement) 126 (apply to packets with given function code schneider electric - program)')
hm2DPIProfileModbusUnitIdentifierList = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 3, 21, 1, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 1400)).clone('none')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2DPIProfileModbusUnitIdentifierList.setStatus('current')
if mibBuilder.loadTexts: hm2DPIProfileModbusUnitIdentifierList.setDescription("Unit identifiers for this enforcer as string. A unit identifier has the syntax: <val> To specify no options, the value 'none' must be given. Unit identifiers are separated by a comma. Following unit identifiers are defined: <0..255> (apply to packets for which a unit identifier is set)")
hm2DPIProfileModbusSanityCheck = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 3, 21, 1, 1, 6), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2DPIProfileModbusSanityCheck.setStatus('current')
if mibBuilder.loadTexts: hm2DPIProfileModbusSanityCheck.setDescription('Set to true if apply to packets for which a sanity check including format and specification shall be done')
hm2DPIProfileModbusException = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 3, 21, 1, 1, 7), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2DPIProfileModbusException.setStatus('current')
if mibBuilder.loadTexts: hm2DPIProfileModbusException.setDescription('Set to true if apply to packets for which a device exception message shall be sent')
hm2DPIProfileModbusReset = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 3, 21, 1, 1, 8), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2DPIProfileModbusReset.setStatus('current')
if mibBuilder.loadTexts: hm2DPIProfileModbusReset.setDescription('Set to true if apply to packets for which a reset connection message shall be sent')
hm2DPIProfileModbusRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 3, 21, 1, 1, 9), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2DPIProfileModbusRowStatus.setStatus('current')
if mibBuilder.loadTexts: hm2DPIProfileModbusRowStatus.setDescription('This is a standard row status value: - active(1): The profile is active. You cannot modify it. - notInService(2): The profile is inactive because of user action. You cannot inactivate the profile if an active enforcer mappings to it. - notReady(3): The profile is inactive because of agent action. - createAndGo(4): Create the profile with default parameters activated. - createAndWait(5): Create the profile inactive. - destroy(6): Delete the profile. You cannot delete the active profile or if an enforcer mappings to it.')
hm2DPIProfileOpcTable = MibTable((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 3, 21, 2), )
if mibBuilder.loadTexts: hm2DPIProfileOpcTable.setStatus('current')
if mibBuilder.loadTexts: hm2DPIProfileOpcTable.setDescription('The list of DPI OPC profiles for this enforcer')
hm2DPIProfileOpcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 3, 21, 2, 1), ).setIndexNames((0, "HM2-FW-MIB", "hm2DPIProfileOpcIndex"))
if mibBuilder.loadTexts: hm2DPIProfileOpcEntry.setStatus('current')
if mibBuilder.loadTexts: hm2DPIProfileOpcEntry.setDescription('DPI OPC profile entry.')
hm2DPIProfileOpcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 3, 21, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hm2DPIProfileOpcIndex.setStatus('current')
if mibBuilder.loadTexts: hm2DPIProfileOpcIndex.setDescription('Profile index of this DPI OPC profile')
hm2DPIProfileOpcDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 3, 21, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32)).clone('opc')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2DPIProfileOpcDescription.setStatus('current')
if mibBuilder.loadTexts: hm2DPIProfileOpcDescription.setDescription('User defined textual description related to this profile.')
hm2DPIProfileOpcSanityCheck = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 3, 21, 2, 1, 3), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2DPIProfileOpcSanityCheck.setStatus('current')
if mibBuilder.loadTexts: hm2DPIProfileOpcSanityCheck.setDescription('Set to true if apply to packets for which a sanity check including format and specification shall be done')
hm2DPIProfileOpcFragmentCheck = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 3, 21, 2, 1, 4), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2DPIProfileOpcFragmentCheck.setStatus('current')
if mibBuilder.loadTexts: hm2DPIProfileOpcFragmentCheck.setDescription('Set to true if apply to packets for which a fragment check shall be done')
hm2DPIProfileOpcTimeoutConnect = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 3, 21, 2, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 60)).clone(5)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2DPIProfileOpcTimeoutConnect.setStatus('current')
if mibBuilder.loadTexts: hm2DPIProfileOpcTimeoutConnect.setDescription('Set to nonzero if apply to packets for which a timeout at connect in seconds shall be done. Value 0 disables this match criteria.')
hm2DPIProfileOpcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 3, 21, 2, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2DPIProfileOpcRowStatus.setStatus('current')
if mibBuilder.loadTexts: hm2DPIProfileOpcRowStatus.setDescription('This is a standard row status value: - active(1): The profile is active. You cannot modify it. - notInService(2): The profile is inactive because of user action. You cannot inactivate the profile if an active enforcer mappings to it. - notReady(3): The profile is inactive because of agent action. - createAndGo(4): Create the profile with default parameters activated. - createAndWait(5): Create the profile inactive. - destroy(6): Delete the profile. You cannot delete the active profile or if an enforcer mappings to it.')
hm2FLMObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 4, 1))
hm2FLMAdminState = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 4, 1, 1), HmEnabledStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2FLMAdminState.setStatus('current')
if mibBuilder.loadTexts: hm2FLMAdminState.setDescription('Enable or disable the Firewall Learning Mode.')
hm2FLMAction = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 1), ("start", 2), ("stop", 3), ("continue", 4), ("clear", 5))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2FLMAction.setStatus('current')
if mibBuilder.loadTexts: hm2FLMAction.setDescription('Actions to control the Firewall Learning Mode.')
hm2FLMAppState = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("off", 1), ("stopped-data-notpresent", 2), ("stopped-data-present", 3), ("learning", 4), ("pending", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2FLMAppState.setStatus('current')
if mibBuilder.loadTexts: hm2FLMAppState.setDescription('State of running FLM Application.')
hm2FLMAppInfoEnum = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 1), ("normal", 2), ("low-memory", 3), ("out-of-memory", 4), ("connection-drop", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2FLMAppInfoEnum.setStatus('current')
if mibBuilder.loadTexts: hm2FLMAppInfoEnum.setDescription('Memory status of FLM Application.')
hm2FLMAppInfoString = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 4, 1, 5), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2FLMAppInfoString.setStatus('current')
if mibBuilder.loadTexts: hm2FLMAppInfoString.setDescription('Special status message.')
hm2FLML3Entries = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 4, 1, 6), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2FLML3Entries.setStatus('current')
if mibBuilder.loadTexts: hm2FLML3Entries.setDescription('Number of Layer 3 entries in the connection table.')
hm2FLMFreeMem = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 4, 1, 7), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2FLMFreeMem.setStatus('current')
if mibBuilder.loadTexts: hm2FLMFreeMem.setDescription('Free memory(%) for learning data.')
hm2FLMMaxEntries = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 4, 1, 8), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2FLMMaxEntries.setStatus('current')
if mibBuilder.loadTexts: hm2FLMMaxEntries.setDescription('Number of maximum interface entries that can be selected.')
hm2FLMTables = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 4, 2))
hm2FLMInterfaceTable = MibTable((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 4, 2, 1), )
if mibBuilder.loadTexts: hm2FLMInterfaceTable.setStatus('current')
if mibBuilder.loadTexts: hm2FLMInterfaceTable.setDescription('The list of interfaces selected for Firewall Learning Mode.')
hm2FLMInterfaceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 4, 2, 1, 1), ).setIndexNames((0, "HM2-FW-MIB", "hm2FLMInterfaceIndex"))
if mibBuilder.loadTexts: hm2FLMInterfaceEntry.setStatus('current')
if mibBuilder.loadTexts: hm2FLMInterfaceEntry.setDescription('Interface selected for Firewall Learning Mode.')
hm2FLMInterfaceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 4, 2, 1, 1, 1), InterfaceIndex()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2FLMInterfaceIndex.setStatus('current')
if mibBuilder.loadTexts: hm2FLMInterfaceIndex.setDescription('Interface index of the entry.')
hm2FLMInterfaceRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 79, 1, 4, 2, 1, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2FLMInterfaceRowStatus.setStatus('current')
if mibBuilder.loadTexts: hm2FLMInterfaceRowStatus.setDescription('This is a standard row status value: - active(1): The interface is active. - notInService(2): The interface is inactive because routing was disabled. - notReady(3): The interface is inactive because of agent action. - createAndGo(4): Create the interface with default parameters activated. - createAndWait(5): Create the interface inactive. - destroy(6): Delete the interface.')
hm2FwCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 79, 2, 1))
hm2FwGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 79, 2, 2))
hm2FwCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 248, 11, 79, 2, 1, 1)).setObjects(("HM2-FW-MIB", "hm2FwGeneralGroup"), ("HM2-FW-MIB", "hm2FwNotificationsGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hm2FwCompliance = hm2FwCompliance.setStatus('current')
if mibBuilder.loadTexts: hm2FwCompliance.setDescription('The compliance statement for an SNMP entity which implements the Hirschmann firewall MIB.')
hm2FwGeneralGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 248, 11, 79, 2, 2, 1)).setObjects(("HM2-FW-MIB", "hm2DynFwMaxRules"), ("HM2-FW-MIB", "hm2L3MaxRules"), ("HM2-FW-MIB", "hm2ResetStatistics"), ("HM2-FW-MIB", "hm2FlushTables"), ("HM2-FW-MIB", "hm2DefaultPolicy"), ("HM2-FW-MIB", "hm2DynFwRuleCount"), ("HM2-FW-MIB", "hm2DynFwIfMappingRuleCount"), ("HM2-FW-MIB", "hm2DynFwRulePendingActions"), ("HM2-FW-MIB", "hm2DynFwCommitPendingActions"), ("HM2-FW-MIB", "hm2DynFwRuleIndex"), ("HM2-FW-MIB", "hm2DynFwSourceAddress"), ("HM2-FW-MIB", "hm2DynFwSourcePort"), ("HM2-FW-MIB", "hm2DynFwTargetAddress"), ("HM2-FW-MIB", "hm2DynFwTargetPort"), ("HM2-FW-MIB", "hm2DynFwProto"), ("HM2-FW-MIB", "hm2DynFwRuleParams"), ("HM2-FW-MIB", "hm2DynFwAction"), ("HM2-FW-MIB", "hm2DynFwLog"), ("HM2-FW-MIB", "hm2DynFwTrap"), ("HM2-FW-MIB", "hm2DynFwDescription"), ("HM2-FW-MIB", "hm2DynFwRowStatus"), ("HM2-FW-MIB", "hm2DynFwIfmPriority"), ("HM2-FW-MIB", "hm2DynFwIfmRowStatus"), ("HM2-FW-MIB", "hm2DynFwStatsPacketCount"), ("HM2-FW-MIB", "hm2DynFwStatsPacketSize"), ("HM2-FW-MIB", "hm2DynFwStatsLastApplied"), ("HM2-FW-MIB", "hm2DynFwStatsTtPck"), ("HM2-FW-MIB", "hm2DynFwStatsTtPckSize"), ("HM2-FW-MIB", "hm2DynFwStatsTtPckDenDrop"), ("HM2-FW-MIB", "hm2DynFwStatsTtPckAccepted"), ("HM2-FW-MIB", "hm2L3RuleCount"), ("HM2-FW-MIB", "hm2L3IfMappingRuleCount"), ("HM2-FW-MIB", "hm2L3RulePendingActions"), ("HM2-FW-MIB", "hm2L3CommitPendingActions"), ("HM2-FW-MIB", "hm2L3RuleIndex"), ("HM2-FW-MIB", "hm2L3SourceAddress"), ("HM2-FW-MIB", "hm2L3SourcePort"), ("HM2-FW-MIB", "hm2L3TargetAddress"), ("HM2-FW-MIB", "hm2L3TargetPort"), ("HM2-FW-MIB", "hm2L3Proto"), ("HM2-FW-MIB", "hm2L3Action"), ("HM2-FW-MIB", "hm2L3RuleParams"), ("HM2-FW-MIB", "hm2L3Log"), ("HM2-FW-MIB", "hm2L3Trap"), ("HM2-FW-MIB", "hm2L3Description"), ("HM2-FW-MIB", "hm2L3RowStatus"), ("HM2-FW-MIB", "hm2DPIProfileIndex"), ("HM2-FW-MIB", "hm2L3IfmPriority"), ("HM2-FW-MIB", "hm2L3IfmRowStatus"), ("HM2-FW-MIB", "hm2L3StatsPacketCount"), ("HM2-FW-MIB", "hm2L3StatsPacketSize"), ("HM2-FW-MIB", "hm2L3StatsLastApplied"), ("HM2-FW-MIB", "hm2L3StatsTotalPck"), ("HM2-FW-MIB", "hm2L3StatsTotalPckSize"), ("HM2-FW-MIB", "hm2L3StatsTotalPckDenDrop"), ("HM2-FW-MIB", "hm2L3StatsTotalPckAccepted"), ("HM2-FW-MIB", "hm2DPIProfileModbusPendingActions"), ("HM2-FW-MIB", "hm2DPIProfileModbusCommitPendingActions"), ("HM2-FW-MIB", "hm2DPIProfileModbusIndex"), ("HM2-FW-MIB", "hm2DPIProfileModbusDescription"), ("HM2-FW-MIB", "hm2DPIProfileModbusFunctionType"), ("HM2-FW-MIB", "hm2DPIProfileModbusFunctionCodeList"), ("HM2-FW-MIB", "hm2DPIProfileModbusUnitIdentifierList"), ("HM2-FW-MIB", "hm2DPIProfileModbusSanityCheck"), ("HM2-FW-MIB", "hm2DPIProfileModbusException"), ("HM2-FW-MIB", "hm2DPIProfileModbusReset"), ("HM2-FW-MIB", "hm2DPIProfileModbusRowStatus"), ("HM2-FW-MIB", "hm2DPIProfileOpcPendingActions"), ("HM2-FW-MIB", "hm2DPIProfileOpcCommitPendingActions"), ("HM2-FW-MIB", "hm2DPIProfileOpcIndex"), ("HM2-FW-MIB", "hm2DPIProfileOpcDescription"), ("HM2-FW-MIB", "hm2DPIProfileOpcSanityCheck"), ("HM2-FW-MIB", "hm2DPIProfileOpcFragmentCheck"), ("HM2-FW-MIB", "hm2DPIProfileOpcTimeoutConnect"), ("HM2-FW-MIB", "hm2DPIProfileOpcRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hm2FwGeneralGroup = hm2FwGeneralGroup.setStatus('current')
if mibBuilder.loadTexts: hm2FwGeneralGroup.setDescription('A collection of all Hirschmann objects provided by the firewall module.')
hm2FwNotificationsGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 248, 11, 79, 2, 2, 2)).setObjects(("HM2-FW-MIB", "hm2DynFwRuleAppliedTrap"), ("HM2-FW-MIB", "hm2DynFwRuleAppliedAndLoggedTrap"), ("HM2-FW-MIB", "hm2L3RuleAppliedTrap"), ("HM2-FW-MIB", "hm2L3RuleAppliedAndLoggedTrap"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hm2FwNotificationsGroup = hm2FwNotificationsGroup.setStatus('current')
if mibBuilder.loadTexts: hm2FwNotificationsGroup.setDescription('A collection of all Hirschmann notifications provided by the firewall module.')
mibBuilder.exportSymbols("HM2-FW-MIB", hm2L3RulePendingActions=hm2L3RulePendingActions, hm2DPIProfileOpcCommitPendingActions=hm2DPIProfileOpcCommitPendingActions, hm2DPIProfileModbusSanityCheck=hm2DPIProfileModbusSanityCheck, hm2DynFw=hm2DynFw, hm2FwGeneralGroup=hm2FwGeneralGroup, hm2L3GeneralStats=hm2L3GeneralStats, hm2DPIProfileModbusFunctionCodeList=hm2DPIProfileModbusFunctionCodeList, hm2DPIProfileOpcPendingActions=hm2DPIProfileOpcPendingActions, hm2DynFwMaxRules=hm2DynFwMaxRules, hm2L3RuleObjects=hm2L3RuleObjects, hm2FwGroups=hm2FwGroups, hm2DynFwRuleCount=hm2DynFwRuleCount, PYSNMP_MODULE_ID=hm2FwMib, hm2L3Log=hm2L3Log, hm2DynFwCommitPendingActions=hm2DynFwCommitPendingActions, hm2L3RuleIndex=hm2L3RuleIndex, hm2FlushTables=hm2FlushTables, hm2DynFwIfMappingRuleCount=hm2DynFwIfMappingRuleCount, hm2DPIProfileOpcTimeoutConnect=hm2DPIProfileOpcTimeoutConnect, hm2FLMAdminState=hm2FLMAdminState, hm2FLMObjects=hm2FLMObjects, hm2L3RuleTables=hm2L3RuleTables, hm2DPIProfileTables=hm2DPIProfileTables, hm2DynFwIfmPriority=hm2DynFwIfmPriority, hm2L3SourcePort=hm2L3SourcePort, hm2L3IfMappingRuleCount=hm2L3IfMappingRuleCount, hm2L3StatsTotalPckDenDrop=hm2L3StatsTotalPckDenDrop, hm2DynFwIfmRuleIndex=hm2DynFwIfmRuleIndex, hm2FwMib=hm2FwMib, hm2L3Action=hm2L3Action, hm2DynFwLog=hm2DynFwLog, hm2DynFwProto=hm2DynFwProto, hm2DynFwTrap=hm2DynFwTrap, hm2L3RuleAppliedTrap=hm2L3RuleAppliedTrap, hm2DynFwDescription=hm2DynFwDescription, hm2DPIProfileModbusTable=hm2DPIProfileModbusTable, hm2DynFwRuleEntry=hm2DynFwRuleEntry, hm2FwObjects=hm2FwObjects, hm2L3StatsRuleTable=hm2L3StatsRuleTable, hm2DynFwTargetAddress=hm2DynFwTargetAddress, hm2L3Stats=hm2L3Stats, hm2DynFwRuleIndex=hm2DynFwRuleIndex, hm2DynFwStatsTtPck=hm2DynFwStatsTtPck, hm2DPIProfileModbusDescription=hm2DPIProfileModbusDescription, hm2FwCompliances=hm2FwCompliances, hm2L3StatsLastApplied=hm2L3StatsLastApplied, hm2L3IfmDirection=hm2L3IfmDirection, hm2DPIProfileModbusException=hm2DPIProfileModbusException, hm2DynFwRuleTable=hm2DynFwRuleTable, hm2DPIProfileModbusIndex=hm2DPIProfileModbusIndex, hm2DPIProfileOpcTable=hm2DPIProfileOpcTable, hm2L3SourceAddress=hm2L3SourceAddress, hm2FLMAppInfoString=hm2FLMAppInfoString, hm2L3RuleIfMappingEntry=hm2L3RuleIfMappingEntry, hm2FwGeneralSettings=hm2FwGeneralSettings, hm2DPIProfileModbusReset=hm2DPIProfileModbusReset, hm2DynFwStatsRuleEntry=hm2DynFwStatsRuleEntry, hm2L3StatsTables=hm2L3StatsTables, hm2DPIProfileModbusEntry=hm2DPIProfileModbusEntry, hm2FwNotificationsGroup=hm2FwNotificationsGroup, hm2FwNotifications=hm2FwNotifications, hm2L3StatsTotalPck=hm2L3StatsTotalPck, hm2FLMFreeMem=hm2FLMFreeMem, hm2DynFwStatsTtPckSize=hm2DynFwStatsTtPckSize, hm2L3MaxRules=hm2L3MaxRules, hm2FLMInterfaceTable=hm2FLMInterfaceTable, hm2L3IfmInterface=hm2L3IfmInterface, hm2DynFwStatsTables=hm2DynFwStatsTables, hm2FLMInterfaceRowStatus=hm2FLMInterfaceRowStatus, hm2DynFwStatsTtPckDenDrop=hm2DynFwStatsTtPckDenDrop, hm2FLMAppState=hm2FLMAppState, hm2DPIProfileOpcRowStatus=hm2DPIProfileOpcRowStatus, hm2L3CommitPendingActions=hm2L3CommitPendingActions, hm2L3IfmRowStatus=hm2L3IfmRowStatus, hm2DPIProfileModbusPendingActions=hm2DPIProfileModbusPendingActions, hm2L3Description=hm2L3Description, hm2FLML3Entries=hm2FLML3Entries, hm2DynFwRuleAppliedAndLoggedTrap=hm2DynFwRuleAppliedAndLoggedTrap, hm2DynFwSourcePort=hm2DynFwSourcePort, hm2DynFwGeneralStats=hm2DynFwGeneralStats, hm2L3Proto=hm2L3Proto, hm2DPIProfileModbusUnitIdentifierList=hm2DPIProfileModbusUnitIdentifierList, hm2DynFwStatsTtPckAccepted=hm2DynFwStatsTtPckAccepted, hm2DynFwRuleAppliedTrap=hm2DynFwRuleAppliedTrap, hm2L3StatsTotalPckAccepted=hm2L3StatsTotalPckAccepted, hm2FLMMaxEntries=hm2FLMMaxEntries, hm2DPIProfileOpcEntry=hm2DPIProfileOpcEntry, hm2L3StatsRuleEntry=hm2L3StatsRuleEntry, hm2DPIProfileOpcIndex=hm2DPIProfileOpcIndex, hm2DefaultPolicy=hm2DefaultPolicy, hm2FwLearningMode=hm2FwLearningMode, hm2L3RuleAppliedAndLoggedTrap=hm2L3RuleAppliedAndLoggedTrap, hm2L3StatsPacketCount=hm2L3StatsPacketCount, hm2DynFwRuleObjects=hm2DynFwRuleObjects, hm2DynFwStatsLastApplied=hm2DynFwStatsLastApplied, hm2DynFwIfmInterface=hm2DynFwIfmInterface, hm2DynFwRuleParams=hm2DynFwRuleParams, hm2DPIProfileModbusFunctionType=hm2DPIProfileModbusFunctionType, hm2DynFwStatsPacketCount=hm2DynFwStatsPacketCount, hm2L3TargetPort=hm2L3TargetPort, hm2DynFwIfmRowStatus=hm2DynFwIfmRowStatus, hm2L3RuleCount=hm2L3RuleCount, hm2DPIProfileIndex=hm2DPIProfileIndex, hm2L3TargetAddress=hm2L3TargetAddress, hm2DynFwAction=hm2DynFwAction, hm2DynFwIfmDirection=hm2DynFwIfmDirection, hm2DPIProfileModbusRowStatus=hm2DPIProfileModbusRowStatus, hm2FLMInterfaceEntry=hm2FLMInterfaceEntry, hm2DynFwTargetPort=hm2DynFwTargetPort, hm2DynFwSourceAddress=hm2DynFwSourceAddress, hm2L3Fw=hm2L3Fw, hm2DPIProfileModbusObjects=hm2DPIProfileModbusObjects, hm2DynFwStatsRuleTable=hm2DynFwStatsRuleTable, hm2FLMAction=hm2FLMAction, hm2DPIProfileOpcFragmentCheck=hm2DPIProfileOpcFragmentCheck, hm2DynFwRuleTables=hm2DynFwRuleTables, hm2FLMAppInfoEnum=hm2FLMAppInfoEnum, hm2FLMInterfaceIndex=hm2FLMInterfaceIndex, hm2L3RuleEntry=hm2L3RuleEntry, hm2L3Trap=hm2L3Trap, hm2L3RuleParams=hm2L3RuleParams, hm2ConnTrackValidateCheckSum=hm2ConnTrackValidateCheckSum, hm2DynFwRuleIfMappingEntry=hm2DynFwRuleIfMappingEntry, hm2DynFwRulePendingActions=hm2DynFwRulePendingActions, hm2DPIProfileOpcSanityCheck=hm2DPIProfileOpcSanityCheck, hm2ResetStatistics=hm2ResetStatistics, hm2DynFwRowStatus=hm2DynFwRowStatus, hm2L3RowStatus=hm2L3RowStatus, hm2L3StatsTotalPckSize=hm2L3StatsTotalPckSize, hm2DynFwStatsPacketSize=hm2DynFwStatsPacketSize, hm2DynFwStats=hm2DynFwStats, hm2FLMTables=hm2FLMTables, hm2FwCompliance=hm2FwCompliance, hm2FwConformance=hm2FwConformance, hm2L3RuleTable=hm2L3RuleTable, hm2L3StatsPacketSize=hm2L3StatsPacketSize, hm2L3RuleIfMappingTable=hm2L3RuleIfMappingTable, hm2L3IfmPriority=hm2L3IfmPriority, hm2L3IfmRuleIndex=hm2L3IfmRuleIndex, hm2DPIProfileOpcObjects=hm2DPIProfileOpcObjects, hm2DPIProfileModbusCommitPendingActions=hm2DPIProfileModbusCommitPendingActions, hm2DynFwRuleIfMappingTable=hm2DynFwRuleIfMappingTable, hm2DPIProfileOpcDescription=hm2DPIProfileOpcDescription)

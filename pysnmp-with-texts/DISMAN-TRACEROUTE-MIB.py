#
# PySNMP MIB module DISMAN-TRACEROUTE-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/DISMAN-TRACEROUTE-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:47:19 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ValueRangeConstraint, SingleValueConstraint, ConstraintsIntersection, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsIntersection", "ConstraintsUnion")
OperationResponseStatus, = mibBuilder.importSymbols("DISMAN-PING-MIB", "OperationResponseStatus")
InterfaceIndexOrZero, = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero")
InetAddressType, InetAddress = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressType", "InetAddress")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ObjectGroup, ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "ModuleCompliance", "NotificationGroup")
Bits, TimeTicks, ObjectIdentity, MibIdentifier, NotificationType, IpAddress, Unsigned32, Gauge32, Counter64, mib_2, Counter32, MibScalar, MibTable, MibTableRow, MibTableColumn, Integer32, iso, ModuleIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "TimeTicks", "ObjectIdentity", "MibIdentifier", "NotificationType", "IpAddress", "Unsigned32", "Gauge32", "Counter64", "mib-2", "Counter32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Integer32", "iso", "ModuleIdentity")
StorageType, TextualConvention, TruthValue, DisplayString, RowStatus, DateAndTime = mibBuilder.importSymbols("SNMPv2-TC", "StorageType", "TextualConvention", "TruthValue", "DisplayString", "RowStatus", "DateAndTime")
traceRouteMIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 81))
traceRouteMIB.setRevisions(('2006-06-13 00:00', '2000-09-21 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: traceRouteMIB.setRevisionsDescriptions(("Updated version, published as RFC 4560. - Correctly considered IPv6 in DESCRIPTION clause of object traceRouteCtlDataSize - Replaced references to RFC 2575 by RFC 3415 - Replaced references to RFC 2571 by RFC 3411 - Replaced references to RFC 2851 by RFC 4001 - Clarified DESCRIPTION clause of object traceRouteResultsLastGoodPath - Changed range of object traceRouteCtlInitialTtl from (0..255) to (1..255) - Extended DESCRIPTION clause of traceRouteResultsTable describing re-initialization of entries - Changed SYNTAX of traceRouteResultsTestAttempts and traceRouteResultsTestSuccesses from Unsigned32 to Gauge32 - Changed status of traceRouteCompliance to deprecated - Added traceRouteFullCompliance and traceRouteMinimumCompliance - Changed status of traceRouteGroup and traceRouteTimeStampGroup to deprecated - Added traceRouteMinimumGroup, traceRouteCtlRowStatusGroup, and traceRouteHistoryGroup - Changed DEFVAL of object traceRouteCtlTargetAddressType from { ipv4 } to { unknown } - Changed DEFVAL of object traceRouteCtlDescr from { '00'H } to { ''H } - Added DEFVAL for object traceRouteCtlTrapGeneration of DEFVAL { { } }", 'Initial version, published as RFC 2925.',))
if mibBuilder.loadTexts: traceRouteMIB.setLastUpdated('200606130000Z')
if mibBuilder.loadTexts: traceRouteMIB.setOrganization('IETF Distributed Management Working Group')
if mibBuilder.loadTexts: traceRouteMIB.setContactInfo('Juergen Quittek NEC Europe Ltd. Network Laboratories Kurfuersten-Anlage 36 69115 Heidelberg Germany Phone: +49 6221 4342-115 Email: quittek@netlab.nec.de')
if mibBuilder.loadTexts: traceRouteMIB.setDescription('The Traceroute MIB (DISMAN-TRACEROUTE-MIB) provides access to the traceroute capability at a remote host. Copyright (C) The Internet Society (2006). This version of this MIB module is part of RFC 4560; see the RFC itself for full legal notices.')
traceRouteNotifications = MibIdentifier((1, 3, 6, 1, 2, 1, 81, 0))
traceRouteObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 81, 1))
traceRouteConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 81, 2))
traceRouteImplementationTypeDomains = MibIdentifier((1, 3, 6, 1, 2, 1, 81, 3))
traceRouteUsingUdpProbes = ObjectIdentity((1, 3, 6, 1, 2, 1, 81, 3, 1))
if mibBuilder.loadTexts: traceRouteUsingUdpProbes.setStatus('current')
if mibBuilder.loadTexts: traceRouteUsingUdpProbes.setDescription('Indicates that an implementation is using UDP probes to perform the traceroute operation.')
traceRouteMaxConcurrentRequests = MibScalar((1, 3, 6, 1, 2, 1, 81, 1, 1), Unsigned32().clone(10)).setUnits('requests').setMaxAccess("readwrite")
if mibBuilder.loadTexts: traceRouteMaxConcurrentRequests.setStatus('current')
if mibBuilder.loadTexts: traceRouteMaxConcurrentRequests.setDescription('The maximum number of concurrent active traceroute requests that are allowed within an agent implementation. A value of 0 for this object implies that there is no limit for the number of concurrent active requests in effect. The limit applies only to new requests being activated. When a new value is set, the agent will continue processing all the requests already active, even if their number exceeds the limit just imposed.')
traceRouteCtlTable = MibTable((1, 3, 6, 1, 2, 1, 81, 1, 2), )
if mibBuilder.loadTexts: traceRouteCtlTable.setStatus('current')
if mibBuilder.loadTexts: traceRouteCtlTable.setDescription('Defines the Remote Operations Traceroute Control Table for providing the capability of invoking traceroute from a remote host. The results of traceroute operations can be stored in the traceRouteResultsTable, traceRouteProbeHistoryTable, and the traceRouteHopsTable.')
traceRouteCtlEntry = MibTableRow((1, 3, 6, 1, 2, 1, 81, 1, 2, 1), ).setIndexNames((0, "DISMAN-TRACEROUTE-MIB", "traceRouteCtlOwnerIndex"), (0, "DISMAN-TRACEROUTE-MIB", "traceRouteCtlTestName"))
if mibBuilder.loadTexts: traceRouteCtlEntry.setStatus('current')
if mibBuilder.loadTexts: traceRouteCtlEntry.setDescription('Defines an entry in the traceRouteCtlTable. The first index element, traceRouteCtlOwnerIndex, is of type SnmpAdminString, a textual convention that allows for use of the SNMPv3 View-Based Access Control Model (RFC 3415, VACM) and that allows a management application to identify its entries. The second index, traceRouteCtlTestName (also an SnmpAdminString), enables the same management application to have multiple requests outstanding.')
traceRouteCtlOwnerIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 81, 1, 2, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32)))
if mibBuilder.loadTexts: traceRouteCtlOwnerIndex.setStatus('current')
if mibBuilder.loadTexts: traceRouteCtlOwnerIndex.setDescription("To facilitate the provisioning of access control by a security administrator using the View-Based Access Control Model (RFC 3415, VACM) for tables in which multiple users may need to create or modify entries independently, the initial index is used as an 'owner index'. Such an initial index has a syntax of SnmpAdminString and can thus be trivially mapped to a securityName or groupName defined in VACM, in accordance with a security policy. When used in conjunction with such a security policy, all entries in the table belonging to a particular user (or group) will have the same value for this initial index. For a given user's entries in a particular table, the object identifiers for the information in these entries will have the same subidentifiers (except for the 'column' subidentifier) up to the end of the encoded owner index. To configure VACM to permit access to this portion of the table, one would create vacmViewTreeFamilyTable entries with the value of vacmViewTreeFamilySubtree including the owner index portion, and vacmViewTreeFamilyMask 'wildcarding' the column subidentifier. More elaborate configurations are possible.")
traceRouteCtlTestName = MibTableColumn((1, 3, 6, 1, 2, 1, 81, 1, 2, 1, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32)))
if mibBuilder.loadTexts: traceRouteCtlTestName.setStatus('current')
if mibBuilder.loadTexts: traceRouteCtlTestName.setDescription('The name of a traceroute test. This is locally unique, within the scope of a traceRouteCtlOwnerIndex.')
traceRouteCtlTargetAddressType = MibTableColumn((1, 3, 6, 1, 2, 1, 81, 1, 2, 1, 3), InetAddressType().clone('unknown')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: traceRouteCtlTargetAddressType.setStatus('current')
if mibBuilder.loadTexts: traceRouteCtlTargetAddressType.setDescription('Specifies the type of host address to be used on the traceroute request at the remote host.')
traceRouteCtlTargetAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 81, 1, 2, 1, 4), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: traceRouteCtlTargetAddress.setStatus('current')
if mibBuilder.loadTexts: traceRouteCtlTargetAddress.setDescription('Specifies the host address used on the traceroute request at the remote host. The host address type can be determined by examining the value of the corresponding traceRouteCtlTargetAddressType. A value for this object MUST be set prior to transitioning its corresponding traceRouteCtlEntry to active(1) via traceRouteCtlRowStatus.')
traceRouteCtlByPassRouteTable = MibTableColumn((1, 3, 6, 1, 2, 1, 81, 1, 2, 1, 5), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: traceRouteCtlByPassRouteTable.setStatus('current')
if mibBuilder.loadTexts: traceRouteCtlByPassRouteTable.setDescription('The purpose of this object is to enable optional bypassing the route table. If enabled, the remote host will bypass the normal routing tables and send directly to a host on an attached network. If the host is not on a directly attached network, an error is returned. This option can be used to perform the traceroute operation to a local host through an interface that has no route defined (e.g., after the interface was dropped by the routing daemon at the host).')
traceRouteCtlDataSize = MibTableColumn((1, 3, 6, 1, 2, 1, 81, 1, 2, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65507))).setUnits('octets').setMaxAccess("readcreate")
if mibBuilder.loadTexts: traceRouteCtlDataSize.setStatus('current')
if mibBuilder.loadTexts: traceRouteCtlDataSize.setDescription('Specifies the size of the data portion of a traceroute request, in octets. If the RECOMMENDED traceroute method (UDP datagrams as probes) is used, then the value contained in this object MUST be applied. If another traceroute method is used for which the specified size is not appropriate, then the implementation SHOULD use whatever size (appropriate to the method) is closest to the specified size. The maximum value for this object was computed by subtracting the smallest possible IP header size of 20 octets (IPv4 header with no options) and the UDP header size of 8 octets from the maximum IP packet size. An IP packet has a maximum size of 65535 octets (excluding IPv6 Jumbograms).')
traceRouteCtlTimeOut = MibTableColumn((1, 3, 6, 1, 2, 1, 81, 1, 2, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 60)).clone(3)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: traceRouteCtlTimeOut.setStatus('current')
if mibBuilder.loadTexts: traceRouteCtlTimeOut.setDescription('Specifies the time-out value, in seconds, for a traceroute request.')
traceRouteCtlProbesPerHop = MibTableColumn((1, 3, 6, 1, 2, 1, 81, 1, 2, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)).clone(3)).setUnits('probes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: traceRouteCtlProbesPerHop.setStatus('current')
if mibBuilder.loadTexts: traceRouteCtlProbesPerHop.setDescription('Specifies the number of times to reissue a traceroute request with the same time-to-live (TTL) value.')
traceRouteCtlPort = MibTableColumn((1, 3, 6, 1, 2, 1, 81, 1, 2, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(33434)).setUnits('UDP Port').setMaxAccess("readcreate")
if mibBuilder.loadTexts: traceRouteCtlPort.setStatus('current')
if mibBuilder.loadTexts: traceRouteCtlPort.setDescription('Specifies the (initial) UDP port to send the traceroute request to. A port needs to be specified that is not in use at the destination (target) host. The default value for this object is the IANA assigned port, 33434, for the traceroute function.')
traceRouteCtlMaxTtl = MibTableColumn((1, 3, 6, 1, 2, 1, 81, 1, 2, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(30)).setUnits('time-to-live value').setMaxAccess("readcreate")
if mibBuilder.loadTexts: traceRouteCtlMaxTtl.setStatus('current')
if mibBuilder.loadTexts: traceRouteCtlMaxTtl.setDescription('Specifies the maximum time-to-live value.')
traceRouteCtlDSField = MibTableColumn((1, 3, 6, 1, 2, 1, 81, 1, 2, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: traceRouteCtlDSField.setReference('Refer to RFC 1812 for the definition of the IPv4 TOS octet and to RFC 2460 for the definition of the IPv6 Traffic Class octet. Refer to RFC 2474 and RFC 3260 for the definition of the Differentiated Services Field.')
if mibBuilder.loadTexts: traceRouteCtlDSField.setStatus('current')
if mibBuilder.loadTexts: traceRouteCtlDSField.setDescription('Specifies the value to store in the Type of Service (TOS) octet in the IPv4 header or in the Traffic Class octet in the IPv6 header, respectively, of the IP packet used to encapsulate the traceroute probe. The octet to be set in the IP header contains the Differentiated Services (DS) Field in the six most significant bits. This option can be used to determine what effect an explicit DS Field setting has on a traceroute response. Not all values are legal or meaningful. A value of 0 means that the function represented by this option is not supported. DS Field usage is often not supported by IP implementations, and not all values are supported. Refer to RFC 2474 and RFC 3260 for guidance on usage of this field.')
traceRouteCtlSourceAddressType = MibTableColumn((1, 3, 6, 1, 2, 1, 81, 1, 2, 1, 12), InetAddressType().clone('unknown')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: traceRouteCtlSourceAddressType.setStatus('current')
if mibBuilder.loadTexts: traceRouteCtlSourceAddressType.setDescription('Specifies the type of the source address, traceRouteCtlSourceAddress, to be used at a remote host when a traceroute operation is performed.')
traceRouteCtlSourceAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 81, 1, 2, 1, 13), InetAddress().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: traceRouteCtlSourceAddress.setStatus('current')
if mibBuilder.loadTexts: traceRouteCtlSourceAddress.setDescription("Use the specified IP address (which must be given as an IP number, not a hostname) as the source address in outgoing probe packets. On hosts with more than one IP address, this option can be used to select the address to be used. If the IP address is not one of this machine's interface addresses, an error is returned, and nothing is sent. A zero-length octet string value for this object disables source address specification. The address type (InetAddressType) that relates to this object is specified by the corresponding value of traceRouteCtlSourceAddressType.")
traceRouteCtlIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 81, 1, 2, 1, 14), InterfaceIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: traceRouteCtlIfIndex.setStatus('current')
if mibBuilder.loadTexts: traceRouteCtlIfIndex.setDescription("Setting this object to an interface's ifIndex prior to starting a remote traceroute operation directs the traceroute probes to be transmitted over the specified interface. A value of zero for this object implies that this option is not enabled.")
traceRouteCtlMiscOptions = MibTableColumn((1, 3, 6, 1, 2, 1, 81, 1, 2, 1, 15), SnmpAdminString().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: traceRouteCtlMiscOptions.setStatus('current')
if mibBuilder.loadTexts: traceRouteCtlMiscOptions.setDescription('Enables an application to specify implementation-dependent options.')
traceRouteCtlMaxFailures = MibTableColumn((1, 3, 6, 1, 2, 1, 81, 1, 2, 1, 16), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(5)).setUnits('timeouts').setMaxAccess("readcreate")
if mibBuilder.loadTexts: traceRouteCtlMaxFailures.setStatus('current')
if mibBuilder.loadTexts: traceRouteCtlMaxFailures.setDescription('The value of this object indicates the maximum number of consecutive timeouts allowed before a remote traceroute request is terminated. A value of either 255 (maximum hop count/possible TTL value) or 0 indicates that the function of terminating a remote traceroute request when a specific number of consecutive timeouts are detected is disabled.')
traceRouteCtlDontFragment = MibTableColumn((1, 3, 6, 1, 2, 1, 81, 1, 2, 1, 17), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: traceRouteCtlDontFragment.setStatus('current')
if mibBuilder.loadTexts: traceRouteCtlDontFragment.setDescription("This object enables setting of the don't fragment flag (DF) in the IP header for a probe. Use of this object enables a manual PATH MTU test is performed.")
traceRouteCtlInitialTtl = MibTableColumn((1, 3, 6, 1, 2, 1, 81, 1, 2, 1, 18), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: traceRouteCtlInitialTtl.setStatus('current')
if mibBuilder.loadTexts: traceRouteCtlInitialTtl.setDescription('The value of this object specifies the initial TTL value to use. This enables bypassing the initial (often well known) portion of a path.')
traceRouteCtlFrequency = MibTableColumn((1, 3, 6, 1, 2, 1, 81, 1, 2, 1, 19), Unsigned32()).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: traceRouteCtlFrequency.setStatus('current')
if mibBuilder.loadTexts: traceRouteCtlFrequency.setDescription('The number of seconds to wait before repeating a traceroute test, as defined by the value of the various objects in the corresponding row. After a single test is completed the number of seconds as defined by the value of traceRouteCtlFrequency MUST elapse before the next traceroute test is started. A value of 0 for this object implies that the test as defined by the corresponding entry will not be repeated.')
traceRouteCtlStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 81, 1, 2, 1, 20), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: traceRouteCtlStorageType.setStatus('current')
if mibBuilder.loadTexts: traceRouteCtlStorageType.setDescription("The storage type for this conceptual row. Conceptual rows having the value 'permanent' need not allow write-access to any columnar objects in the row.")
traceRouteCtlAdminStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 81, 1, 2, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: traceRouteCtlAdminStatus.setStatus('current')
if mibBuilder.loadTexts: traceRouteCtlAdminStatus.setDescription('Reflects the desired state that an traceRouteCtlEntry should be in: enabled(1) - Attempt to activate the test as defined by this traceRouteCtlEntry. disabled(2) - Deactivate the test as defined by this traceRouteCtlEntry. Refer to the corresponding traceRouteResultsOperStatus to determine the operational state of the test defined by this entry.')
traceRouteCtlDescr = MibTableColumn((1, 3, 6, 1, 2, 1, 81, 1, 2, 1, 22), SnmpAdminString().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: traceRouteCtlDescr.setStatus('current')
if mibBuilder.loadTexts: traceRouteCtlDescr.setDescription('The purpose of this object is to provide a descriptive name of the remote traceroute test.')
traceRouteCtlMaxRows = MibTableColumn((1, 3, 6, 1, 2, 1, 81, 1, 2, 1, 23), Unsigned32().clone(50)).setUnits('rows').setMaxAccess("readcreate")
if mibBuilder.loadTexts: traceRouteCtlMaxRows.setStatus('current')
if mibBuilder.loadTexts: traceRouteCtlMaxRows.setDescription('The maximum number of corresponding entries allowed in the traceRouteProbeHistoryTable. An implementation of this MIB will remove the oldest corresponding entry in the traceRouteProbeHistoryTable to allow the addition of an new entry once the number of corresponding rows in the traceRouteProbeHistoryTable reaches this value. Old entries are not removed when a new test is started. Entries are added to the traceRouteProbeHistoryTable until traceRouteCtlMaxRows is reached before entries begin to be removed. A value of 0 for this object disables creation of traceRouteProbeHistoryTable entries.')
traceRouteCtlTrapGeneration = MibTableColumn((1, 3, 6, 1, 2, 1, 81, 1, 2, 1, 24), Bits().clone(namedValues=NamedValues(("pathChange", 0), ("testFailure", 1), ("testCompletion", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: traceRouteCtlTrapGeneration.setStatus('current')
if mibBuilder.loadTexts: traceRouteCtlTrapGeneration.setDescription("The value of this object determines when and whether to generate a notification for this entry: pathChange(0) - Generate a traceRoutePathChange notification when the current path varies from a previously determined path. testFailure(1) - Generate a traceRouteTestFailed notification when the full path to a target can't be determined. testCompletion(2) - Generate a traceRouteTestCompleted notification when the path to a target has been determined. The value of this object defaults to an empty set, indicating that none of the above options has been selected.")
traceRouteCtlCreateHopsEntries = MibTableColumn((1, 3, 6, 1, 2, 1, 81, 1, 2, 1, 25), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: traceRouteCtlCreateHopsEntries.setStatus('current')
if mibBuilder.loadTexts: traceRouteCtlCreateHopsEntries.setDescription('The current path for a traceroute test is kept in the traceRouteHopsTable on a per-hop basis when the value of this object is true(1).')
traceRouteCtlType = MibTableColumn((1, 3, 6, 1, 2, 1, 81, 1, 2, 1, 26), ObjectIdentifier().clone((1, 3, 6, 1, 2, 1, 81, 3, 1))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: traceRouteCtlType.setStatus('current')
if mibBuilder.loadTexts: traceRouteCtlType.setDescription('The value of this object is used either to report or to select the implementation method to be used for performing a traceroute operation. The value of this object may be selected from traceRouteImplementationTypeDomains. Additional implementation types should be allocated as required by implementers of the DISMAN-TRACEROUTE-MIB under their enterprise specific registration point, not beneath traceRouteImplementationTypeDomains.')
traceRouteCtlRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 81, 1, 2, 1, 27), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: traceRouteCtlRowStatus.setReference("See definition of RowStatus in RFC 2579, 'Textual Conventions for SMIv2.'")
if mibBuilder.loadTexts: traceRouteCtlRowStatus.setStatus('current')
if mibBuilder.loadTexts: traceRouteCtlRowStatus.setDescription("This object allows entries to be created and deleted in the traceRouteCtlTable. Deletion of an entry in this table results in a deletion of all corresponding (same traceRouteCtlOwnerIndex and traceRouteCtlTestName index values) traceRouteResultsTable, traceRouteProbeHistoryTable, and traceRouteHopsTable entries. A value MUST be specified for traceRouteCtlTargetAddress prior to acceptance of a transition to active(1) state. When a value for pingCtlTargetAddress is set, the value of object pingCtlRowStatus changes from notReady(3) to notInService(2). Activation of a remote traceroute operation is controlled via traceRouteCtlAdminStatus, and not by transitioning of this object's value to active(1). Transitions in and out of active(1) state are not allowed while an entry's traceRouteResultsOperStatus is active(1), with the exception that deletion of an entry in this table by setting its RowStatus object to destroy(6) will stop an active traceroute operation. The operational state of an traceroute operation can be determined by examination of the corresponding traceRouteResultsOperStatus object.")
traceRouteResultsTable = MibTable((1, 3, 6, 1, 2, 1, 81, 1, 3), )
if mibBuilder.loadTexts: traceRouteResultsTable.setStatus('current')
if mibBuilder.loadTexts: traceRouteResultsTable.setDescription('Defines the Remote Operations Traceroute Results Table for keeping track of the status of a traceRouteCtlEntry. An entry is added to the traceRouteResultsTable when an traceRouteCtlEntry is started by successful transition of its traceRouteCtlAdminStatus object to enabled(1). If the object traceRouteCtlAdminStatus already has the value enabled(1), and if the corresponding traceRouteResultsOperStatus object has the value completed(3), then successfully writing enabled(1) to the object traceRouteCtlAdminStatus re-initializes the already existing entry in the traceRouteResultsTable. The values of objects in the re-initialized entry are the same as the values of objects in a new entry would be. An entry is removed from the traceRouteResultsTable when its corresponding traceRouteCtlEntry is deleted.')
traceRouteResultsEntry = MibTableRow((1, 3, 6, 1, 2, 1, 81, 1, 3, 1), ).setIndexNames((0, "DISMAN-TRACEROUTE-MIB", "traceRouteCtlOwnerIndex"), (0, "DISMAN-TRACEROUTE-MIB", "traceRouteCtlTestName"))
if mibBuilder.loadTexts: traceRouteResultsEntry.setStatus('current')
if mibBuilder.loadTexts: traceRouteResultsEntry.setDescription('Defines an entry in the traceRouteResultsTable. The traceRouteResultsTable has the same indexing as the traceRouteCtlTable so that a traceRouteResultsEntry corresponds to the traceRouteCtlEntry that caused it to be created.')
traceRouteResultsOperStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 81, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("completed", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: traceRouteResultsOperStatus.setStatus('current')
if mibBuilder.loadTexts: traceRouteResultsOperStatus.setDescription('Reflects the operational state of an traceRouteCtlEntry: enabled(1) - Test is active. disabled(2) - Test has stopped. completed(3) - Test is completed.')
traceRouteResultsCurHopCount = MibTableColumn((1, 3, 6, 1, 2, 1, 81, 1, 3, 1, 2), Gauge32()).setUnits('hops').setMaxAccess("readonly")
if mibBuilder.loadTexts: traceRouteResultsCurHopCount.setStatus('current')
if mibBuilder.loadTexts: traceRouteResultsCurHopCount.setDescription('Reflects the current TTL value (from 1 to 255) for a remote traceroute operation. Maximum TTL value is determined by traceRouteCtlMaxTtl.')
traceRouteResultsCurProbeCount = MibTableColumn((1, 3, 6, 1, 2, 1, 81, 1, 3, 1, 3), Gauge32()).setUnits('probes').setMaxAccess("readonly")
if mibBuilder.loadTexts: traceRouteResultsCurProbeCount.setStatus('current')
if mibBuilder.loadTexts: traceRouteResultsCurProbeCount.setDescription('Reflects the current probe count (1..10) for a remote traceroute operation. The maximum probe count is determined by traceRouteCtlProbesPerHop.')
traceRouteResultsIpTgtAddrType = MibTableColumn((1, 3, 6, 1, 2, 1, 81, 1, 3, 1, 4), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: traceRouteResultsIpTgtAddrType.setStatus('current')
if mibBuilder.loadTexts: traceRouteResultsIpTgtAddrType.setDescription('This object indicates the type of address stored in the corresponding traceRouteResultsIpTgtAddr object.')
traceRouteResultsIpTgtAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 81, 1, 3, 1, 5), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: traceRouteResultsIpTgtAddr.setStatus('current')
if mibBuilder.loadTexts: traceRouteResultsIpTgtAddr.setDescription('This object reports the IP address associated with a traceRouteCtlTargetAddress value when the destination address is specified as a DNS name. The value of this object should be a zero-length octet string when a DNS name is not specified or when a specified DNS name fails to resolve.')
traceRouteResultsTestAttempts = MibTableColumn((1, 3, 6, 1, 2, 1, 81, 1, 3, 1, 6), Gauge32()).setUnits('tests').setMaxAccess("readonly")
if mibBuilder.loadTexts: traceRouteResultsTestAttempts.setStatus('current')
if mibBuilder.loadTexts: traceRouteResultsTestAttempts.setDescription('The current number of attempts to determine a path to a target. The value of this object MUST be started at 0.')
traceRouteResultsTestSuccesses = MibTableColumn((1, 3, 6, 1, 2, 1, 81, 1, 3, 1, 7), Gauge32()).setUnits('tests').setMaxAccess("readonly")
if mibBuilder.loadTexts: traceRouteResultsTestSuccesses.setStatus('current')
if mibBuilder.loadTexts: traceRouteResultsTestSuccesses.setDescription('The current number of attempts to determine a path to a target that have succeeded. The value of this object MUST be reported as 0 when no attempts have succeeded.')
traceRouteResultsLastGoodPath = MibTableColumn((1, 3, 6, 1, 2, 1, 81, 1, 3, 1, 8), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: traceRouteResultsLastGoodPath.setStatus('current')
if mibBuilder.loadTexts: traceRouteResultsLastGoodPath.setDescription('The date and time when the last complete path was determined. A path is complete if responses were received or timeout occurred for each hop on the path; i.e., for each TTL value from the value of the corresponding traceRouteCtlInitialTtl object up to the end of the path or (if no reply from the target IP address was received) up to the value of the corresponding traceRouteCtlMaxTtl object.')
traceRouteProbeHistoryTable = MibTable((1, 3, 6, 1, 2, 1, 81, 1, 4), )
if mibBuilder.loadTexts: traceRouteProbeHistoryTable.setStatus('current')
if mibBuilder.loadTexts: traceRouteProbeHistoryTable.setDescription('Defines the Remote Operations Traceroute Results Table for storing the results of a traceroute operation. An implementation of this MIB will remove the oldest entry in the traceRouteProbeHistoryTable of the corresponding entry in the traceRouteCtlTable to allow the addition of a new entry once the number of rows in the traceRouteProbeHistoryTable reaches the value specified by traceRouteCtlMaxRows for the corresponding entry in the traceRouteCtlTable.')
traceRouteProbeHistoryEntry = MibTableRow((1, 3, 6, 1, 2, 1, 81, 1, 4, 1), ).setIndexNames((0, "DISMAN-TRACEROUTE-MIB", "traceRouteCtlOwnerIndex"), (0, "DISMAN-TRACEROUTE-MIB", "traceRouteCtlTestName"), (0, "DISMAN-TRACEROUTE-MIB", "traceRouteProbeHistoryIndex"), (0, "DISMAN-TRACEROUTE-MIB", "traceRouteProbeHistoryHopIndex"), (0, "DISMAN-TRACEROUTE-MIB", "traceRouteProbeHistoryProbeIndex"))
if mibBuilder.loadTexts: traceRouteProbeHistoryEntry.setStatus('current')
if mibBuilder.loadTexts: traceRouteProbeHistoryEntry.setDescription('Defines a table for storing the results of a traceroute operation. Entries in this table are limited by the value of the corresponding traceRouteCtlMaxRows object. The first two index elements identify the traceRouteCtlEntry that a traceRouteProbeHistoryEntry belongs to. The third index element selects a single traceroute operation result. The fourth and fifth indexes select the hop and the probe for a particular traceroute operation.')
traceRouteProbeHistoryIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 81, 1, 4, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: traceRouteProbeHistoryIndex.setStatus('current')
if mibBuilder.loadTexts: traceRouteProbeHistoryIndex.setDescription("An entry in this table is created when the result of a traceroute probe is determined. The initial 2 instance identifier index values identify the traceRouteCtlEntry that a probe result (traceRouteProbeHistoryEntry) belongs to. An entry is removed from this table when its corresponding traceRouteCtlEntry is deleted. An implementation MUST start assigning traceRouteProbeHistoryIndex values at 1 and wrap after exceeding the maximum possible value, as defined by the limit of this object ('ffffffff'h).")
traceRouteProbeHistoryHopIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 81, 1, 4, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)))
if mibBuilder.loadTexts: traceRouteProbeHistoryHopIndex.setStatus('current')
if mibBuilder.loadTexts: traceRouteProbeHistoryHopIndex.setDescription("Indicates which hop in a traceroute path the probe's results are for. The value of this object is initially determined by the value of traceRouteCtlInitialTtl.")
traceRouteProbeHistoryProbeIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 81, 1, 4, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)))
if mibBuilder.loadTexts: traceRouteProbeHistoryProbeIndex.setStatus('current')
if mibBuilder.loadTexts: traceRouteProbeHistoryProbeIndex.setDescription('Indicates the index of a probe for a particular hop in a traceroute path. The number of probes per hop is determined by the value of the corresponding traceRouteCtlProbesPerHop object.')
traceRouteProbeHistoryHAddrType = MibTableColumn((1, 3, 6, 1, 2, 1, 81, 1, 4, 1, 4), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: traceRouteProbeHistoryHAddrType.setStatus('current')
if mibBuilder.loadTexts: traceRouteProbeHistoryHAddrType.setDescription('This objects indicates the type of address stored in the corresponding traceRouteProbeHistoryHAddr object.')
traceRouteProbeHistoryHAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 81, 1, 4, 1, 5), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: traceRouteProbeHistoryHAddr.setStatus('current')
if mibBuilder.loadTexts: traceRouteProbeHistoryHAddr.setDescription("The address of a hop in a traceroute path. This object is not allowed to be a DNS name. The value of the corresponding object, traceRouteProbeHistoryHAddrType, indicates this object's IP address type.")
traceRouteProbeHistoryResponse = MibTableColumn((1, 3, 6, 1, 2, 1, 81, 1, 4, 1, 6), Unsigned32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: traceRouteProbeHistoryResponse.setStatus('current')
if mibBuilder.loadTexts: traceRouteProbeHistoryResponse.setDescription('The amount of time measured in milliseconds from when a probe was sent to when its response was received or when it timed out. The value of this object is reported as 0 when it is not possible to transmit a probe.')
traceRouteProbeHistoryStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 81, 1, 4, 1, 7), OperationResponseStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: traceRouteProbeHistoryStatus.setStatus('current')
if mibBuilder.loadTexts: traceRouteProbeHistoryStatus.setDescription('The result of a traceroute operation made by a remote host for a particular probe.')
traceRouteProbeHistoryLastRC = MibTableColumn((1, 3, 6, 1, 2, 1, 81, 1, 4, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: traceRouteProbeHistoryLastRC.setStatus('current')
if mibBuilder.loadTexts: traceRouteProbeHistoryLastRC.setDescription("The last implementation-method-specific reply code received. Traceroute is usually implemented by transmitting a series of probe packets with increasing time-to-live values. A probe packet is a UDP datagram encapsulated into an IP packet. Each hop in a path to the target (destination) host rejects the probe packets (probe's TTL too small, ICMP reply) until either the maximum TTL is exceeded or the target host is received.")
traceRouteProbeHistoryTime = MibTableColumn((1, 3, 6, 1, 2, 1, 81, 1, 4, 1, 9), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: traceRouteProbeHistoryTime.setStatus('current')
if mibBuilder.loadTexts: traceRouteProbeHistoryTime.setDescription("Timestamp for when this probe's results were determined.")
traceRouteHopsTable = MibTable((1, 3, 6, 1, 2, 1, 81, 1, 5), )
if mibBuilder.loadTexts: traceRouteHopsTable.setStatus('current')
if mibBuilder.loadTexts: traceRouteHopsTable.setDescription('Defines the Remote Operations Traceroute Hop Table for keeping track of the results of traceroute tests on a per-hop basis.')
traceRouteHopsEntry = MibTableRow((1, 3, 6, 1, 2, 1, 81, 1, 5, 1), ).setIndexNames((0, "DISMAN-TRACEROUTE-MIB", "traceRouteCtlOwnerIndex"), (0, "DISMAN-TRACEROUTE-MIB", "traceRouteCtlTestName"), (0, "DISMAN-TRACEROUTE-MIB", "traceRouteHopsHopIndex"))
if mibBuilder.loadTexts: traceRouteHopsEntry.setStatus('current')
if mibBuilder.loadTexts: traceRouteHopsEntry.setDescription('Defines an entry in the traceRouteHopsTable. The first two index elements identify the traceRouteCtlEntry that a traceRouteHopsEntry belongs to. The third index element, traceRouteHopsHopIndex, selects a hop in a traceroute path.')
traceRouteHopsHopIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 81, 1, 5, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: traceRouteHopsHopIndex.setStatus('current')
if mibBuilder.loadTexts: traceRouteHopsHopIndex.setDescription("Specifies the hop index for a traceroute hop. Values for this object with respect to the same traceRouteCtlOwnerIndex and traceRouteCtlTestName MUST start at 1 and be given increasing values for subsequent hops. The value of traceRouteHopsHopIndex is not necessarily the number of the hop on the traced path. The traceRouteHopsTable keeps the current traceroute path per traceRouteCtlEntry if enabled by setting the corresponding traceRouteCtlCreateHopsEntries to true(1). All hops (traceRouteHopsTable entries) in a traceroute path MUST be updated at the same time when a traceroute operation is completed. Care needs to be applied when a path either changes or can't be determined. The initial portion of the path, up to the first hop change, MUST retain the same traceRouteHopsHopIndex values. The remaining portion of the path SHOULD be assigned new traceRouteHopsHopIndex values.")
traceRouteHopsIpTgtAddressType = MibTableColumn((1, 3, 6, 1, 2, 1, 81, 1, 5, 1, 2), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: traceRouteHopsIpTgtAddressType.setStatus('current')
if mibBuilder.loadTexts: traceRouteHopsIpTgtAddressType.setDescription('This object indicates the type of address stored in the corresponding traceRouteHopsIpTgtAddress object.')
traceRouteHopsIpTgtAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 81, 1, 5, 1, 3), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: traceRouteHopsIpTgtAddress.setStatus('current')
if mibBuilder.loadTexts: traceRouteHopsIpTgtAddress.setDescription('This object reports the IP address associated with the hop. A value for this object should be reported as a numeric IP address, not as a DNS name. The address type (InetAddressType) that relates to this object is specified by the corresponding value of pingCtlSourceAddressType.')
traceRouteHopsMinRtt = MibTableColumn((1, 3, 6, 1, 2, 1, 81, 1, 5, 1, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: traceRouteHopsMinRtt.setStatus('current')
if mibBuilder.loadTexts: traceRouteHopsMinRtt.setDescription('The minimum traceroute round-trip-time (RTT) received for this hop. A value of 0 for this object implies that no RTT has been received.')
traceRouteHopsMaxRtt = MibTableColumn((1, 3, 6, 1, 2, 1, 81, 1, 5, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: traceRouteHopsMaxRtt.setStatus('current')
if mibBuilder.loadTexts: traceRouteHopsMaxRtt.setDescription('The maximum traceroute round-trip-time (RTT) received for this hop. A value of 0 for this object implies that no RTT has been received.')
traceRouteHopsAverageRtt = MibTableColumn((1, 3, 6, 1, 2, 1, 81, 1, 5, 1, 6), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: traceRouteHopsAverageRtt.setStatus('current')
if mibBuilder.loadTexts: traceRouteHopsAverageRtt.setDescription('The current average traceroute round-trip-time (RTT) for this hop.')
traceRouteHopsRttSumOfSquares = MibTableColumn((1, 3, 6, 1, 2, 1, 81, 1, 5, 1, 7), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: traceRouteHopsRttSumOfSquares.setStatus('current')
if mibBuilder.loadTexts: traceRouteHopsRttSumOfSquares.setDescription('This object contains the sum of the squares of all round-trip-times received for this hop. Its purpose is to enable standard deviation calculation.')
traceRouteHopsSentProbes = MibTableColumn((1, 3, 6, 1, 2, 1, 81, 1, 5, 1, 8), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: traceRouteHopsSentProbes.setStatus('current')
if mibBuilder.loadTexts: traceRouteHopsSentProbes.setDescription('The value of this object reflects the number of probes sent for this hop during this traceroute test. The value of this object should start at 0.')
traceRouteHopsProbeResponses = MibTableColumn((1, 3, 6, 1, 2, 1, 81, 1, 5, 1, 9), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: traceRouteHopsProbeResponses.setStatus('current')
if mibBuilder.loadTexts: traceRouteHopsProbeResponses.setDescription('Number of responses received for this hop during this traceroute test. This value of this object should start at 0.')
traceRouteHopsLastGoodProbe = MibTableColumn((1, 3, 6, 1, 2, 1, 81, 1, 5, 1, 10), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: traceRouteHopsLastGoodProbe.setStatus('current')
if mibBuilder.loadTexts: traceRouteHopsLastGoodProbe.setDescription('Date and time at which the last response was received for a probe for this hop during this traceroute test.')
traceRoutePathChange = NotificationType((1, 3, 6, 1, 2, 1, 81, 0, 1)).setObjects(("DISMAN-TRACEROUTE-MIB", "traceRouteCtlTargetAddressType"), ("DISMAN-TRACEROUTE-MIB", "traceRouteCtlTargetAddress"), ("DISMAN-TRACEROUTE-MIB", "traceRouteResultsIpTgtAddrType"), ("DISMAN-TRACEROUTE-MIB", "traceRouteResultsIpTgtAddr"))
if mibBuilder.loadTexts: traceRoutePathChange.setStatus('current')
if mibBuilder.loadTexts: traceRoutePathChange.setDescription('The path to a target has changed.')
traceRouteTestFailed = NotificationType((1, 3, 6, 1, 2, 1, 81, 0, 2)).setObjects(("DISMAN-TRACEROUTE-MIB", "traceRouteCtlTargetAddressType"), ("DISMAN-TRACEROUTE-MIB", "traceRouteCtlTargetAddress"), ("DISMAN-TRACEROUTE-MIB", "traceRouteResultsIpTgtAddrType"), ("DISMAN-TRACEROUTE-MIB", "traceRouteResultsIpTgtAddr"))
if mibBuilder.loadTexts: traceRouteTestFailed.setStatus('current')
if mibBuilder.loadTexts: traceRouteTestFailed.setDescription('Could not determine the path to a target.')
traceRouteTestCompleted = NotificationType((1, 3, 6, 1, 2, 1, 81, 0, 3)).setObjects(("DISMAN-TRACEROUTE-MIB", "traceRouteCtlTargetAddressType"), ("DISMAN-TRACEROUTE-MIB", "traceRouteCtlTargetAddress"), ("DISMAN-TRACEROUTE-MIB", "traceRouteResultsIpTgtAddrType"), ("DISMAN-TRACEROUTE-MIB", "traceRouteResultsIpTgtAddr"))
if mibBuilder.loadTexts: traceRouteTestCompleted.setStatus('current')
if mibBuilder.loadTexts: traceRouteTestCompleted.setDescription('The path to a target has just been determined.')
traceRouteCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 81, 2, 1))
traceRouteGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 81, 2, 2))
traceRouteFullCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 81, 2, 1, 2)).setObjects(("DISMAN-TRACEROUTE-MIB", "traceRouteMinimumGroup"), ("DISMAN-TRACEROUTE-MIB", "traceRouteCtlRowStatusGroup"), ("DISMAN-TRACEROUTE-MIB", "traceRouteHistoryGroup"), ("DISMAN-TRACEROUTE-MIB", "traceRouteHopsTableGroup"), ("DISMAN-TRACEROUTE-MIB", "traceRouteNotificationsGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    traceRouteFullCompliance = traceRouteFullCompliance.setStatus('current')
if mibBuilder.loadTexts: traceRouteFullCompliance.setDescription('The compliance statement for SNMP entities that fully implement the DISMAN-TRACEROUTE-MIB.')
traceRouteMinimumCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 81, 2, 1, 3)).setObjects(("DISMAN-TRACEROUTE-MIB", "traceRouteMinimumGroup"), ("DISMAN-TRACEROUTE-MIB", "traceRouteCtlRowStatusGroup"), ("DISMAN-TRACEROUTE-MIB", "traceRouteHistoryGroup"), ("DISMAN-TRACEROUTE-MIB", "traceRouteHopsTableGroup"), ("DISMAN-TRACEROUTE-MIB", "traceRouteNotificationsGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    traceRouteMinimumCompliance = traceRouteMinimumCompliance.setStatus('current')
if mibBuilder.loadTexts: traceRouteMinimumCompliance.setDescription('The minimum compliance statement for SNMP entities which implement the minimal subset of the DISMAN-TRACEROUTE-MIB. Implementors might choose this subset for small devices with limited resources.')
traceRouteCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 81, 2, 1, 1)).setObjects(("DISMAN-TRACEROUTE-MIB", "traceRouteGroup"), ("DISMAN-TRACEROUTE-MIB", "traceRouteTimeStampGroup"), ("DISMAN-TRACEROUTE-MIB", "traceRouteNotificationsGroup"), ("DISMAN-TRACEROUTE-MIB", "traceRouteHopsTableGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    traceRouteCompliance = traceRouteCompliance.setStatus('deprecated')
if mibBuilder.loadTexts: traceRouteCompliance.setDescription('The compliance statement for the DISMAN-TRACEROUTE-MIB. This compliance statement has been deprecated because the traceRouteGroup and the traceRouteTimeStampGroup have been split and deprecated. The traceRouteFullCompliance is semantically identical to the deprecated traceRouteCompliance statement.')
traceRouteMinimumGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 81, 2, 2, 5)).setObjects(("DISMAN-TRACEROUTE-MIB", "traceRouteMaxConcurrentRequests"), ("DISMAN-TRACEROUTE-MIB", "traceRouteCtlTargetAddressType"), ("DISMAN-TRACEROUTE-MIB", "traceRouteCtlTargetAddress"), ("DISMAN-TRACEROUTE-MIB", "traceRouteCtlByPassRouteTable"), ("DISMAN-TRACEROUTE-MIB", "traceRouteCtlDataSize"), ("DISMAN-TRACEROUTE-MIB", "traceRouteCtlTimeOut"), ("DISMAN-TRACEROUTE-MIB", "traceRouteCtlProbesPerHop"), ("DISMAN-TRACEROUTE-MIB", "traceRouteCtlPort"), ("DISMAN-TRACEROUTE-MIB", "traceRouteCtlMaxTtl"), ("DISMAN-TRACEROUTE-MIB", "traceRouteCtlDSField"), ("DISMAN-TRACEROUTE-MIB", "traceRouteCtlSourceAddressType"), ("DISMAN-TRACEROUTE-MIB", "traceRouteCtlSourceAddress"), ("DISMAN-TRACEROUTE-MIB", "traceRouteCtlIfIndex"), ("DISMAN-TRACEROUTE-MIB", "traceRouteCtlMiscOptions"), ("DISMAN-TRACEROUTE-MIB", "traceRouteCtlMaxFailures"), ("DISMAN-TRACEROUTE-MIB", "traceRouteCtlDontFragment"), ("DISMAN-TRACEROUTE-MIB", "traceRouteCtlInitialTtl"), ("DISMAN-TRACEROUTE-MIB", "traceRouteCtlFrequency"), ("DISMAN-TRACEROUTE-MIB", "traceRouteCtlStorageType"), ("DISMAN-TRACEROUTE-MIB", "traceRouteCtlAdminStatus"), ("DISMAN-TRACEROUTE-MIB", "traceRouteCtlMaxRows"), ("DISMAN-TRACEROUTE-MIB", "traceRouteCtlTrapGeneration"), ("DISMAN-TRACEROUTE-MIB", "traceRouteCtlDescr"), ("DISMAN-TRACEROUTE-MIB", "traceRouteCtlCreateHopsEntries"), ("DISMAN-TRACEROUTE-MIB", "traceRouteCtlType"), ("DISMAN-TRACEROUTE-MIB", "traceRouteResultsOperStatus"), ("DISMAN-TRACEROUTE-MIB", "traceRouteResultsCurHopCount"), ("DISMAN-TRACEROUTE-MIB", "traceRouteResultsCurProbeCount"), ("DISMAN-TRACEROUTE-MIB", "traceRouteResultsIpTgtAddrType"), ("DISMAN-TRACEROUTE-MIB", "traceRouteResultsIpTgtAddr"), ("DISMAN-TRACEROUTE-MIB", "traceRouteResultsTestAttempts"), ("DISMAN-TRACEROUTE-MIB", "traceRouteResultsTestSuccesses"), ("DISMAN-TRACEROUTE-MIB", "traceRouteResultsLastGoodPath"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    traceRouteMinimumGroup = traceRouteMinimumGroup.setStatus('current')
if mibBuilder.loadTexts: traceRouteMinimumGroup.setDescription('The group of objects that constitute the remote traceroute operation.')
traceRouteCtlRowStatusGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 81, 2, 2, 6)).setObjects(("DISMAN-TRACEROUTE-MIB", "traceRouteCtlRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    traceRouteCtlRowStatusGroup = traceRouteCtlRowStatusGroup.setStatus('current')
if mibBuilder.loadTexts: traceRouteCtlRowStatusGroup.setDescription('The RowStatus object of the traceRouteCtlTable.')
traceRouteHistoryGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 81, 2, 2, 7)).setObjects(("DISMAN-TRACEROUTE-MIB", "traceRouteProbeHistoryHAddrType"), ("DISMAN-TRACEROUTE-MIB", "traceRouteProbeHistoryHAddr"), ("DISMAN-TRACEROUTE-MIB", "traceRouteProbeHistoryResponse"), ("DISMAN-TRACEROUTE-MIB", "traceRouteProbeHistoryStatus"), ("DISMAN-TRACEROUTE-MIB", "traceRouteProbeHistoryLastRC"), ("DISMAN-TRACEROUTE-MIB", "traceRouteProbeHistoryTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    traceRouteHistoryGroup = traceRouteHistoryGroup.setStatus('current')
if mibBuilder.loadTexts: traceRouteHistoryGroup.setDescription('The group of objects that constitute the history capability.')
traceRouteNotificationsGroup = NotificationGroup((1, 3, 6, 1, 2, 1, 81, 2, 2, 3)).setObjects(("DISMAN-TRACEROUTE-MIB", "traceRoutePathChange"), ("DISMAN-TRACEROUTE-MIB", "traceRouteTestFailed"), ("DISMAN-TRACEROUTE-MIB", "traceRouteTestCompleted"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    traceRouteNotificationsGroup = traceRouteNotificationsGroup.setStatus('current')
if mibBuilder.loadTexts: traceRouteNotificationsGroup.setDescription('The notifications that are required to be supported by implementations of this MIB.')
traceRouteHopsTableGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 81, 2, 2, 4)).setObjects(("DISMAN-TRACEROUTE-MIB", "traceRouteHopsIpTgtAddressType"), ("DISMAN-TRACEROUTE-MIB", "traceRouteHopsIpTgtAddress"), ("DISMAN-TRACEROUTE-MIB", "traceRouteHopsMinRtt"), ("DISMAN-TRACEROUTE-MIB", "traceRouteHopsMaxRtt"), ("DISMAN-TRACEROUTE-MIB", "traceRouteHopsAverageRtt"), ("DISMAN-TRACEROUTE-MIB", "traceRouteHopsRttSumOfSquares"), ("DISMAN-TRACEROUTE-MIB", "traceRouteHopsSentProbes"), ("DISMAN-TRACEROUTE-MIB", "traceRouteHopsProbeResponses"), ("DISMAN-TRACEROUTE-MIB", "traceRouteHopsLastGoodProbe"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    traceRouteHopsTableGroup = traceRouteHopsTableGroup.setStatus('current')
if mibBuilder.loadTexts: traceRouteHopsTableGroup.setDescription('The group of objects that constitute the traceRouteHopsTable.')
traceRouteGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 81, 2, 2, 1)).setObjects(("DISMAN-TRACEROUTE-MIB", "traceRouteMaxConcurrentRequests"), ("DISMAN-TRACEROUTE-MIB", "traceRouteCtlTargetAddressType"), ("DISMAN-TRACEROUTE-MIB", "traceRouteCtlTargetAddress"), ("DISMAN-TRACEROUTE-MIB", "traceRouteCtlByPassRouteTable"), ("DISMAN-TRACEROUTE-MIB", "traceRouteCtlDataSize"), ("DISMAN-TRACEROUTE-MIB", "traceRouteCtlTimeOut"), ("DISMAN-TRACEROUTE-MIB", "traceRouteCtlProbesPerHop"), ("DISMAN-TRACEROUTE-MIB", "traceRouteCtlPort"), ("DISMAN-TRACEROUTE-MIB", "traceRouteCtlMaxTtl"), ("DISMAN-TRACEROUTE-MIB", "traceRouteCtlDSField"), ("DISMAN-TRACEROUTE-MIB", "traceRouteCtlSourceAddressType"), ("DISMAN-TRACEROUTE-MIB", "traceRouteCtlSourceAddress"), ("DISMAN-TRACEROUTE-MIB", "traceRouteCtlIfIndex"), ("DISMAN-TRACEROUTE-MIB", "traceRouteCtlMiscOptions"), ("DISMAN-TRACEROUTE-MIB", "traceRouteCtlMaxFailures"), ("DISMAN-TRACEROUTE-MIB", "traceRouteCtlDontFragment"), ("DISMAN-TRACEROUTE-MIB", "traceRouteCtlInitialTtl"), ("DISMAN-TRACEROUTE-MIB", "traceRouteCtlFrequency"), ("DISMAN-TRACEROUTE-MIB", "traceRouteCtlStorageType"), ("DISMAN-TRACEROUTE-MIB", "traceRouteCtlAdminStatus"), ("DISMAN-TRACEROUTE-MIB", "traceRouteCtlMaxRows"), ("DISMAN-TRACEROUTE-MIB", "traceRouteCtlTrapGeneration"), ("DISMAN-TRACEROUTE-MIB", "traceRouteCtlDescr"), ("DISMAN-TRACEROUTE-MIB", "traceRouteCtlCreateHopsEntries"), ("DISMAN-TRACEROUTE-MIB", "traceRouteCtlType"), ("DISMAN-TRACEROUTE-MIB", "traceRouteCtlRowStatus"), ("DISMAN-TRACEROUTE-MIB", "traceRouteResultsOperStatus"), ("DISMAN-TRACEROUTE-MIB", "traceRouteResultsCurHopCount"), ("DISMAN-TRACEROUTE-MIB", "traceRouteResultsCurProbeCount"), ("DISMAN-TRACEROUTE-MIB", "traceRouteResultsIpTgtAddrType"), ("DISMAN-TRACEROUTE-MIB", "traceRouteResultsIpTgtAddr"), ("DISMAN-TRACEROUTE-MIB", "traceRouteResultsTestAttempts"), ("DISMAN-TRACEROUTE-MIB", "traceRouteResultsTestSuccesses"), ("DISMAN-TRACEROUTE-MIB", "traceRouteProbeHistoryHAddrType"), ("DISMAN-TRACEROUTE-MIB", "traceRouteProbeHistoryHAddr"), ("DISMAN-TRACEROUTE-MIB", "traceRouteProbeHistoryResponse"), ("DISMAN-TRACEROUTE-MIB", "traceRouteProbeHistoryStatus"), ("DISMAN-TRACEROUTE-MIB", "traceRouteProbeHistoryLastRC"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    traceRouteGroup = traceRouteGroup.setStatus('deprecated')
if mibBuilder.loadTexts: traceRouteGroup.setDescription('The group of objects that constitute the remote traceroute operation.')
traceRouteTimeStampGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 81, 2, 2, 2)).setObjects(("DISMAN-TRACEROUTE-MIB", "traceRouteResultsLastGoodPath"), ("DISMAN-TRACEROUTE-MIB", "traceRouteProbeHistoryTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    traceRouteTimeStampGroup = traceRouteTimeStampGroup.setStatus('deprecated')
if mibBuilder.loadTexts: traceRouteTimeStampGroup.setDescription('The group of DateAndTime objects.')
mibBuilder.exportSymbols("DISMAN-TRACEROUTE-MIB", traceRouteGroup=traceRouteGroup, traceRouteHopsHopIndex=traceRouteHopsHopIndex, traceRouteGroups=traceRouteGroups, traceRouteResultsIpTgtAddr=traceRouteResultsIpTgtAddr, traceRouteCtlOwnerIndex=traceRouteCtlOwnerIndex, traceRouteResultsTable=traceRouteResultsTable, traceRouteTestCompleted=traceRouteTestCompleted, traceRouteNotificationsGroup=traceRouteNotificationsGroup, PYSNMP_MODULE_ID=traceRouteMIB, traceRoutePathChange=traceRoutePathChange, traceRouteResultsIpTgtAddrType=traceRouteResultsIpTgtAddrType, traceRouteCtlStorageType=traceRouteCtlStorageType, traceRouteCtlIfIndex=traceRouteCtlIfIndex, traceRouteProbeHistoryResponse=traceRouteProbeHistoryResponse, traceRouteCtlTimeOut=traceRouteCtlTimeOut, traceRouteProbeHistoryIndex=traceRouteProbeHistoryIndex, traceRouteHopsLastGoodProbe=traceRouteHopsLastGoodProbe, traceRouteHopsTableGroup=traceRouteHopsTableGroup, traceRouteHopsSentProbes=traceRouteHopsSentProbes, traceRouteCtlTestName=traceRouteCtlTestName, traceRouteCtlEntry=traceRouteCtlEntry, traceRouteCtlMiscOptions=traceRouteCtlMiscOptions, traceRouteCtlDontFragment=traceRouteCtlDontFragment, traceRouteCtlDSField=traceRouteCtlDSField, traceRouteCtlProbesPerHop=traceRouteCtlProbesPerHop, traceRouteObjects=traceRouteObjects, traceRouteHopsRttSumOfSquares=traceRouteHopsRttSumOfSquares, traceRouteHistoryGroup=traceRouteHistoryGroup, traceRouteCtlTargetAddressType=traceRouteCtlTargetAddressType, traceRouteHopsMinRtt=traceRouteHopsMinRtt, traceRouteHopsIpTgtAddress=traceRouteHopsIpTgtAddress, traceRouteMIB=traceRouteMIB, traceRouteCtlRowStatusGroup=traceRouteCtlRowStatusGroup, traceRouteCtlDescr=traceRouteCtlDescr, traceRouteProbeHistoryTable=traceRouteProbeHistoryTable, traceRouteCtlTable=traceRouteCtlTable, traceRouteMinimumGroup=traceRouteMinimumGroup, traceRouteHopsIpTgtAddressType=traceRouteHopsIpTgtAddressType, traceRouteResultsCurProbeCount=traceRouteResultsCurProbeCount, traceRouteNotifications=traceRouteNotifications, traceRouteProbeHistoryLastRC=traceRouteProbeHistoryLastRC, traceRouteProbeHistoryHAddrType=traceRouteProbeHistoryHAddrType, traceRouteUsingUdpProbes=traceRouteUsingUdpProbes, traceRouteHopsMaxRtt=traceRouteHopsMaxRtt, traceRouteCtlMaxRows=traceRouteCtlMaxRows, traceRouteHopsTable=traceRouteHopsTable, traceRouteCtlTargetAddress=traceRouteCtlTargetAddress, traceRouteResultsTestSuccesses=traceRouteResultsTestSuccesses, traceRouteCtlAdminStatus=traceRouteCtlAdminStatus, traceRouteCompliance=traceRouteCompliance, traceRouteCtlMaxFailures=traceRouteCtlMaxFailures, traceRouteResultsCurHopCount=traceRouteResultsCurHopCount, traceRouteMaxConcurrentRequests=traceRouteMaxConcurrentRequests, traceRouteCompliances=traceRouteCompliances, traceRouteCtlSourceAddress=traceRouteCtlSourceAddress, traceRouteTestFailed=traceRouteTestFailed, traceRouteCtlMaxTtl=traceRouteCtlMaxTtl, traceRouteCtlInitialTtl=traceRouteCtlInitialTtl, traceRouteCtlTrapGeneration=traceRouteCtlTrapGeneration, traceRouteProbeHistoryTime=traceRouteProbeHistoryTime, traceRouteHopsAverageRtt=traceRouteHopsAverageRtt, traceRouteCtlType=traceRouteCtlType, traceRouteProbeHistoryProbeIndex=traceRouteProbeHistoryProbeIndex, traceRouteCtlRowStatus=traceRouteCtlRowStatus, traceRouteTimeStampGroup=traceRouteTimeStampGroup, traceRouteProbeHistoryHopIndex=traceRouteProbeHistoryHopIndex, traceRouteCtlByPassRouteTable=traceRouteCtlByPassRouteTable, traceRouteResultsOperStatus=traceRouteResultsOperStatus, traceRouteConformance=traceRouteConformance, traceRouteProbeHistoryEntry=traceRouteProbeHistoryEntry, traceRouteHopsProbeResponses=traceRouteHopsProbeResponses, traceRouteCtlPort=traceRouteCtlPort, traceRouteCtlDataSize=traceRouteCtlDataSize, traceRouteCtlCreateHopsEntries=traceRouteCtlCreateHopsEntries, traceRouteCtlFrequency=traceRouteCtlFrequency, traceRouteMinimumCompliance=traceRouteMinimumCompliance, traceRouteResultsEntry=traceRouteResultsEntry, traceRouteResultsTestAttempts=traceRouteResultsTestAttempts, traceRouteImplementationTypeDomains=traceRouteImplementationTypeDomains, traceRouteResultsLastGoodPath=traceRouteResultsLastGoodPath, traceRouteProbeHistoryHAddr=traceRouteProbeHistoryHAddr, traceRouteFullCompliance=traceRouteFullCompliance, traceRouteHopsEntry=traceRouteHopsEntry, traceRouteProbeHistoryStatus=traceRouteProbeHistoryStatus, traceRouteCtlSourceAddressType=traceRouteCtlSourceAddressType)

#
# PySNMP MIB module CISCO-CABLE-QOS-MONITOR-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-CABLE-QOS-MONITOR-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:51:56 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsIntersection, ValueRangeConstraint, SingleValueConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsIntersection", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsUnion")
ciscoMgmt, = mibBuilder.importSymbols("CISCO-SMI", "ciscoMgmt")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
ObjectGroup, ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "ModuleCompliance", "NotificationGroup")
MibScalar, MibTable, MibTableRow, MibTableColumn, Gauge32, Counter32, ObjectIdentity, Bits, ModuleIdentity, Unsigned32, IpAddress, iso, TimeTicks, Counter64, MibIdentifier, Integer32, NotificationType = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Gauge32", "Counter32", "ObjectIdentity", "Bits", "ModuleIdentity", "Unsigned32", "IpAddress", "iso", "TimeTicks", "Counter64", "MibIdentifier", "Integer32", "NotificationType")
TextualConvention, DisplayString, RowStatus, TruthValue, DateAndTime, MacAddress = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString", "RowStatus", "TruthValue", "DateAndTime", "MacAddress")
ciscoCableQosMonitorMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 9, 341))
ciscoCableQosMonitorMIB.setRevisions(('2004-02-20 00:00', '2003-04-03 00:00', '2003-03-04 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ciscoCableQosMonitorMIB.setRevisionsDescriptions(('Added objects in ccqmCmtsEnforceRuleTable to support DOCSIS1.1, DOCSIS2.0 modems and peak/off-peak monitoring. The objects are: ccqmCmtsEnfRuleAvgRate, ccqmCmtsEnfRuleDocsVer, ccqmCmtsEnfRuleRegSerClassName, ccqmCmtsEnfRuleEnfSerClassName, ccqmCmtsEnfRuleMonType, ccqmCmtsEnfRuleFirstPeakTime, ccqmCmtsEnfRuleFirstDuration, ccqmCmtsEnfRuleFirstAvgRate, ccqmCmtsEnfRuleSecondPeakTime, ccqmCmtsEnfRuleSecondDuration, ccqmCmtsEnfRuleSecondAvgRate, ccqmCmtsEnfRuleOffPeakDuration, ccqmCmtsEnfRuleOffPeakAvgRate Added ccqmCmtsIfBwUtilTable to provide thresholds for downstream/upstream bandwidth utilization. Removed ccqmCmtsEnfRuleByteCount which was obsoleted.', 'Changed ranges of few objects.', 'Initial version of this MIB module.',))
if mibBuilder.loadTexts: ciscoCableQosMonitorMIB.setLastUpdated('200402200000Z')
if mibBuilder.loadTexts: ciscoCableQosMonitorMIB.setOrganization('Cisco Systems, Inc.')
if mibBuilder.loadTexts: ciscoCableQosMonitorMIB.setContactInfo(' Cisco Systems Customer Service Postal: Cisco Systems 170 West Tasman Drive San Jose, CA 95134 U.S.A. Phone: +1 800 553-NETS E-mail: cs-ubr@cisco.com')
if mibBuilder.loadTexts: ciscoCableQosMonitorMIB.setDescription('This is the MIB module for subscriber QoS monitoring for DOCSIS-compliant Cable Modem Termination Systems (CMTS). Several subscriber behavior can be monitored: 1. When the subscriber requests for more resources than as defined by its QoS parameter set. In this case, though requested for more rate-limiting happens in the CMTS, hence, the subscriber will get only as much resources as defined by its registered QoS parameter set. In this mib, QoS parameter set refers to QoS profiles for 1.0 modems and refer to service class names for 1.1 and 2.0 modems. 2. When the subscriber continuously utilizes the resources to the upper limit or very near to the upper limit as defined by its QoS parameter set. 3. When the subscriber sometimes or never utilizes the resources as defined by the upper limit of the QoS parameter set. In the first two cases, we need to monitor the subscribers as upstream/downstream is a shared medium, and if all subscribers start consuming resources as per their peak rate, or a percentage of it, CMTS will be hard pressed for resources. So, even though such subscribers are using resources within the limits as defined by their QoS parameter set, from the CMTS point of view, they are over consuming. Through out this MIB, we refer to this behavior of subscribers as over consumption of resources and such subscribers will be the violating subscribers. The subscriber QoS Monitoring is a software feature provided on the CMTS so that the CMTS may identify such subscribers who over consume resources based on their QoS parameter set, report them to a management entity, and automatically mitigate the problem where possible. This is done by penalizing the violating subscribers by changing their QoS parameter set to enforced QoS parameter set. The MIB allows to create enforce rules which are used to determine the over consumption of resources. The enforce rule contains monitoring and enforced QoS parameter set. The subscribers who over consume their bandwidth are flagged and NMS notified of all such violations. The MIB also provides a unified view of all over-consuming subscribers.')
class CCQMRuleDirection(TextualConvention, Integer32):
    description = "The CCQMRuleDirection is used to indicate the direction to which the enforce rule applies to. It has the following defined values: - 'upstream', is used for an enforce rule in the direction from subscriber to CMTS - 'downstream', is used for an enforce rule in the direction from CMTS to the subscriber. - 'bidirection', which can mean neither upstream or downstream but a combined enforce rule. "
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("upstream", 1), ("downstream", 2), ("bidirection", 3))

ciscoCableQosMonitorMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 341, 1))
ccqmEnforceRuleObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 341, 1, 1))
ccqmRuleViolateObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 341, 1, 2))
ccqmRuleIfBwUtilObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 341, 1, 3))
ccqmCmtsEnforceRuleTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 341, 1, 1, 1), )
if mibBuilder.loadTexts: ccqmCmtsEnforceRuleTable.setStatus('current')
if mibBuilder.loadTexts: ccqmCmtsEnforceRuleTable.setDescription('This table contains the attributes of the QoS enforce rules present on the CMTS. These enforce rules define the criteria for identifying subscribers who over consume resources. This could be as simple as bytes transmitted over the last monitoring duration and checked at a rate equal to the sample rate. In the sliding window concept used, the monitoring duration is the size of the window. This window slides by an amount that is equal to the sample rate. At every sample rate the bytes transmitted in the time equal to a monitoring duration is checked. If this is found to be larger than the threshold limit which is calculated by multiplying the defined average rate by the monitoring duration per monitoring duration, the subscriber is flagged as over consuming. Else the monitoring will continue. For example let the monitoring duration be 360 minutes and sample rate be 30 minutes. If the average rate is 2kbits/sec then every 30 minutes we check if the bytes transmitted in the last 360 minutes exceeded 5.4Mbytes bytes. If so, the subscriber is over consuming. The enforce rule has a one to one mapping to QoS profiles in case of DOCSIS1.0 (and DOCSIS1.0+ modems) and to service class names in case of DOCSIS1.1 and DOCSIS2.0 modems. It defines the registered QoS parameter set and an enforced QoS parameter set be applied if found to be violating the registered QoS parameter set. The enforce rule also defines a penalty period for which the enforced QoS parameter set will be applied. The registered QoS parameter set will be restored when the penalty period expires. The monitoring can be of two types: 1) Legacy/Basic monitoring: There is only one threshold and one monitoring-duration and the monitoring-duration can be more than one day and within a day there is no distinction among hours as peak or offpeak hours. An example would be: monitoring duration : 2 days Average rate : 2kbits/sec 2) Peak-offPeak monitoring: A maximum of two peak durations can be defined with in a day and the remaining hours are treated as off-peak and the monitoring will happen during these offpeak hours if the offpeak duration and threhold are defined. The monitoring-duration and threshold for all three, first peak, second peak and offpeak can be different. Here, the monitoring duration for any of the peaks or offpeak cannot be more than a day. An example when both peaks and offpeak are defined is: First peak: monitoring duration: Between 6am to 9am i.e., 3hours Average rate : 2kbits/sec Second peak: monitoring duration: Between 6pm to 10pm i.e., 4hrs Average rate : 3kbits/sec Off peak: Remaining hours in the day i.e., 12 midnight to 6:00am, 9am to 6pm and 10pm to 12mignight. monitoring duration: 2 hours Average rate : 1kbits/sec.')
ccqmCmtsEnforceRuleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 341, 1, 1, 1, 1), ).setIndexNames((0, "CISCO-CABLE-QOS-MONITOR-MIB", "ccqmCmtsEnfRuleName"))
if mibBuilder.loadTexts: ccqmCmtsEnforceRuleEntry.setStatus('current')
if mibBuilder.loadTexts: ccqmCmtsEnforceRuleEntry.setDescription('A set of attributes of a enforce rule on the CMTS. One entry exists for each QoS enforce rule. It is indexed by ccqmCmtsEnfRuleName as each enforce rule is associated with a unique name. The user can define the legacy/basic monitoring as: Suppose, the duration is 2 hours and the average rate is 2kbits/sec, so the following object would be need to set: ccqmCmtsEnfRuleMonType = 1 (Basic) ccqmCmtsEnfRuleMonDuration = 120 (minutes) ccqmCmtsEnfRuleAvgRate = 2 (kbits/sec) Consider the example of setting the following peak-offpeak monitoring: First peak time: Morning 6:00am to 9:00am. Average rate is 2kbits/sec. Second peak time: Evening 6:00pm to 10:00pm. Average rate is 3kbits/sec. Offpeak time: The remaining time i.e., 12:00 midnight to 6:00am and from 9:00am to 6:00pm and 10:00pm to 12:00 midnight would constitute the offpeak time. Let us assume the monitoring-duration is 2 hours and the average rate is 1kbits/sec. And so the relevant objects would look like: ccqmCmtsEnfRuleMonType = 2 (peakOffPeak) ccqmCmtsEnfRuleFirstPeakTime = 6 (0600 hours) ccqmCmtsEnfRuleFirstDuration = 180 min (3 hours) ccqmCmtsEnfRuleFirstAvgRate = 2 (kbits/sec) ccqmCmtsEnfRuleSecondPeakTime = 18 (1800 hours) ccqmCmtsEnfRuleSecondDuration = 240 min (4 hours) ccqmCmtsEnfRuleSecondAvgRate = 3 (kbits/sec) ccqmCmtsEnfRuleOffPeakDuration = 160 min (2 hours) ccqmCmtsEnfRuleOffPeakAvgRate = 1 (kbits/sec).')
ccqmCmtsEnfRuleName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 341, 1, 1, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 15)))
if mibBuilder.loadTexts: ccqmCmtsEnfRuleName.setStatus('current')
if mibBuilder.loadTexts: ccqmCmtsEnfRuleName.setDescription('The name of the enforce rule.')
ccqmCmtsEnfRuleRegQoS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 341, 1, 1, 1, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16383))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ccqmCmtsEnfRuleRegQoS.setReference('docsIfQosProfIndex from draft-ietf-ipcdn-docs-rfmibv2-05.txt')
if mibBuilder.loadTexts: ccqmCmtsEnfRuleRegQoS.setStatus('current')
if mibBuilder.loadTexts: ccqmCmtsEnfRuleRegQoS.setDescription('This object represents a pointer to the object describing the quality of service attributes associated with the registered service of the subscriber. For DOCSIS1.0 (DOCSIS1.0+) subscribers it is the index in the docsIfQosProfileTable. If no associated entry in docsIfQosProfileTable exists, this object returns a value of zero. Similarly this object can be set to 0 to indicate no entry in the docsIfQosProfileTable associated with this QoS profile. This object is applicable for DOCSIS1.0 (and DOCSIS1.0+) modems and it can be set only when ccqmCmtsEnfRuleDocsVer is set to docsis10(2). This object cannot be changed when ccqmCmtsEnfRuleRowStatus is active(1).')
ccqmCmtsEnfRuleEnfQos = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 341, 1, 1, 1, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16383))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ccqmCmtsEnfRuleEnfQos.setReference('docsIfQosProfIndex from draft-ietf-ipcdn-docs-rfmibv2-05.txt')
if mibBuilder.loadTexts: ccqmCmtsEnfRuleEnfQos.setStatus('current')
if mibBuilder.loadTexts: ccqmCmtsEnfRuleEnfQos.setDescription('This object represents a pointer to the object describing the quality of service attributes associated with the registered service of the subscriber. For DOCSIS1.0 (and DOCSIS1.0+) subscribers it is the index in the docsIfQosProfileTable. If no associated entry in docsIfQosProfileTable exists, this object returns a value of zero. Similarly this object can be set to 0 to indicate no entry in the docsIfQosProfileTable associated with this QoS profile. This object is applicable for DOCSIS1.0 (and DOCSIS1.0+) modems and it can be set only when ccqmCmtsEnfRuleDocsVer is set to docsis10(2). This object cannot be changed when ccqmCmtsEnfRuleRowStatus is active(1).')
ccqmCmtsEnfRuleMonDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 341, 1, 1, 1, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(10, 44640)).clone(360)).setUnits('minutes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: ccqmCmtsEnfRuleMonDuration.setStatus('current')
if mibBuilder.loadTexts: ccqmCmtsEnfRuleMonDuration.setDescription('This object represents the duration for which subscribers would be monitored to determine if they were over consuming resources. This object can be set only when ccqmCmtsEnfRuleMonType is set to basic(1). If peak-offpeak monitoring is enabled i.e., ccqmCmtsEnfRuleMonType and is set to peakOffPeak (2) this object when polled would return the duration value valid at that time of the day and 0 if no monitoring is taking place at that time. Both ccqmCmtsEnfRuleMonDuration and ccqmCmtsEnfRuleAvgRate need to be set before legacy/basic monitoring can be started. This object cannot be changed when ccqmCmtsEnfRuleRowStatus is active(1).')
ccqmCmtsEnfRuleSampleRate = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 341, 1, 1, 1, 1, 5), Unsigned32()).setUnits('minutes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: ccqmCmtsEnfRuleSampleRate.setStatus('current')
if mibBuilder.loadTexts: ccqmCmtsEnfRuleSampleRate.setDescription('This object represents the interval at which a decision would be made to check if the subscriber over consumed his resources based on the subscriber usage in the past duration. Since the duration can range between 10 minutes to 30 days hence the range of sample rate would change accordingly too. Some empirical calculations for the same are: The maximum memory to be used per line card for STM is 10 MBytes. The maximum number of modems that can be supported is 6000 per line card. Now, per sample memory consumption is 8 bytes hence approximately, the maximum number of samples that can be allowed are 10 * 10 ^ 6 / (6 * 10 ^ 3 * 2 * 8) ~ 100 Hence, given the duration the sample rate would be calculated as duration / 100 = sample rate only if the duration happens to be more than 1440. For cases when the duration is less than 1440, the sample rate range would be between 10 to 30. This object cannot be changed when ccqmCmtsEnfRuleRowStatus is active(1).')
ccqmCmtsEnfRulePenaltyPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 341, 1, 1, 1, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 10080)).clone(10080)).setUnits('minutes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: ccqmCmtsEnfRulePenaltyPeriod.setStatus('current')
if mibBuilder.loadTexts: ccqmCmtsEnfRulePenaltyPeriod.setDescription('This object represents the period in which the enforced QoS parameter set will be in effect from the time of detection. When the time as defined by this object expires, the registered QoS parameter set would be restored. This object cannot be changed when ccqmCmtsEnfRuleRowStatus is active(1).')
ccqmCmtsEnfRuleByteCount = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 341, 1, 1, 1, 1, 7), Unsigned32()).setUnits('1000 bytes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: ccqmCmtsEnfRuleByteCount.setStatus('obsolete')
if mibBuilder.loadTexts: ccqmCmtsEnfRuleByteCount.setDescription('The number of kbytes that the subscriber can transmit in the monitoring duration as indicated by ccqmCmtsEnfRuleMonDuration before being flagged as over consuming. This object cannot be changed when ccqmCmtsEnfRuleRowStatus is active(1).')
ccqmCmtsEnfRuleDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 341, 1, 1, 1, 1, 8), CCQMRuleDirection()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ccqmCmtsEnfRuleDirection.setStatus('current')
if mibBuilder.loadTexts: ccqmCmtsEnfRuleDirection.setDescription('Specifies if the average rate specified by ccqmCmtsEnfRuleAvgRate is for the upstream/downstream direction. Setting to bidirection(3) is not permitted. This object cannot be changed when ccqmCmtsEnfRuleRowStatus is active(1).')
ccqmCmtsEnfRuleAutoEnforce = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 341, 1, 1, 1, 1, 9), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ccqmCmtsEnfRuleAutoEnforce.setStatus('current')
if mibBuilder.loadTexts: ccqmCmtsEnfRuleAutoEnforce.setDescription('If the ccqmCmtsEnfRuleAutoEnforce is TRUE, the enforced QoS parameter set as specified by ccqmCmtsEnfRuleEnfQos for DOCSIS1.0 (and DOCSIS1.0+) modems or ccqmCmtsEnfRuleEnfSerClassName for DOCSIS1.1 and DOCSIS2.0 modems will be automatically enforced when an over consuming subscriber is detected. Otherwise the change should be done manually. This object cannot be changed when ccqmCmtsEnfRuleRowStatus is active(1).')
ccqmCmtsEnfRuleRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 341, 1, 1, 1, 1, 10), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ccqmCmtsEnfRuleRowStatus.setStatus('current')
if mibBuilder.loadTexts: ccqmCmtsEnfRuleRowStatus.setDescription('The object controls and reflects the status of rows in this table. All row status values are supported. The status of the row needs to be changed from active(1) to notInService(2) in cases when any of the enforce rule objects need to be changed. If there is any monitoring associated with this enforce rule ongoing at this time, it as well as all the statistics collected over the sample rate and monitoring duration will be cleared when the row status is changed from active(1) to notInService(2). The monitoring will start again only when the row status is changed to active(1).')
ccqmCmtsEnfRuleAvgRate = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 341, 1, 1, 1, 1, 11), Unsigned32()).setUnits('kbits/sec').setMaxAccess("readcreate")
if mibBuilder.loadTexts: ccqmCmtsEnfRuleAvgRate.setStatus('current')
if mibBuilder.loadTexts: ccqmCmtsEnfRuleAvgRate.setDescription('This object defines the rate at which the subscriber is allowed to consume for the monitoring duration. So, if this rate is defined to be 2kbits/sec and the monitoring duration is set to be 120 minutes, then every sample period the subscribers consumption in the last monitoring duration would be compared against 1.8Mbytes. This object can be set only when ccqmCmtsEnfRuleMonType is set to basic(1) else when polled it will return the rate valid at that time of the day and 0 if no monitoring is taking place at that time.')
ccqmCmtsEnfRuleDocsVer = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 341, 1, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("others", 1), ("docsis10", 2))).clone('docsis10')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ccqmCmtsEnfRuleDocsVer.setStatus('current')
if mibBuilder.loadTexts: ccqmCmtsEnfRuleDocsVer.setDescription('This defines the DOCSIS version of the modems that the enforce rule would be applicable to. If it is set to docsis10(2) then only ccqmCmtsEnfRuleRegQoS and ccqmCmtsEnfRuleEnfQoS can be set and if previously ccqmCmtsEnfRuleRegSerClassName and ccqmCmtsEnfRuleEnfSerClassName were set, they will be reset to NULL and if it set to others(1) then only ccqmCmtsEnfRuleRegSerClassName and ccqmCmtsEnfRuleEnfSerClassName can be set and if previously ccqmCmtsEnfRuleRegQoS and ccqmCmtsEnfRuleEnfQoS were set they will be reset to 0.')
ccqmCmtsEnfRuleRegSerClassName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 341, 1, 1, 1, 1, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 16))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ccqmCmtsEnfRuleRegSerClassName.setStatus('current')
if mibBuilder.loadTexts: ccqmCmtsEnfRuleRegSerClassName.setDescription('This object represents a pointer to the object describing the quality of service attributes associated with the registered service of the subscriber. For DOCSIS1.1 and DOCSIS2.0 subscribers it is same as docsQosParamSetServiceClassName in docsQosParamSetTable. This object is applicable for DOCSIS1.1 and DOCSIS2.0 modems and it can be set only when ccqmCmtsEnfRuleDocsVer is set to others(1). This object cannot be changed when ccqmCmtsEnfRuleRowStatus is active(1).')
ccqmCmtsEnfRuleEnfSerClassName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 341, 1, 1, 1, 1, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 16))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ccqmCmtsEnfRuleEnfSerClassName.setStatus('current')
if mibBuilder.loadTexts: ccqmCmtsEnfRuleEnfSerClassName.setDescription('This object represents a pointer to the object describing the quality of service attributes associated with the registered service of the subscriber. For DOCSIS1.1 and DOCSIS2.0 subscribers it is same as docsQosParamSetServiceClassName in docsQosParamSetTable. This object is applicable only for DOCSIS1.1 modems and DOCSIS2.0 and it can be set only when ccqmCmtsEnfRuleDocsVer is set to others(1). This object cannot be changed when ccqmCmtsEnfRuleRowStatus is active(1).')
ccqmCmtsEnfRuleMonType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 341, 1, 1, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("basic", 1), ("peakOffPeak", 2))).clone('basic')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ccqmCmtsEnfRuleMonType.setStatus('current')
if mibBuilder.loadTexts: ccqmCmtsEnfRuleMonType.setDescription('This object defines the monitoring type. If it is set to basic(1), then ccqmCmtsEnfRuleMonDuration and ccqmCmtsEnfRuleAvgRate are used to define the monitoring and if the peak-offpeak objects were set before, they will all be reset to 0 and if the user sets this object to peakOffPeak(2) the peak-offpeak objects are used to define the monitoring and ccqmCmtsEnfRuleMonDuration and ccqmCmtsEnfRuleAvgRate, if set before, will be reset to 0.')
ccqmCmtsEnfRuleFirstPeakTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 341, 1, 1, 1, 1, 16), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 23))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ccqmCmtsEnfRuleFirstPeakTime.setStatus('current')
if mibBuilder.loadTexts: ccqmCmtsEnfRuleFirstPeakTime.setDescription("The user can define two peak times and the remaining hours will be treated as offpeak and the monitoring will happen for these offpeak hours if ccqmCmtsEnfRuleOffPeakDuration and ccqmCmtsEnfRuleOffPeakAvgRate are defined. The first peak parameters are defined using ccqmCmtsEnfRuleFirstPeakTime, ccqmCmtsEnfRuleFirstDuration and ccqmCmtsEnfRuleFirstAvgRate objects while the second peak parameters can be defined using ccqmCmtsEnfRuleSecondPeakTime, ccqmCmtsEnfRuleSecondDuration and ccqmCmtsEnfRuleSecondAvgRate. Each peak time has an associated average rate and a duration for which that average rate holds good. Defining the first peak is mandatory, though defining the second peak and offpeak is not mandatory. Both these peak times should be defined such that they don't overlap and the first peak time has to be an earlier time than the second peak time. User would need to use 24 hour clock for setting this. This object cannot be changed when ccqmCmtsEnfRuleRowStatus is active(1).")
ccqmCmtsEnfRuleFirstDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 341, 1, 1, 1, 1, 17), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(60, 1440))).setUnits('minutes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: ccqmCmtsEnfRuleFirstDuration.setStatus('current')
if mibBuilder.loadTexts: ccqmCmtsEnfRuleFirstDuration.setDescription('This object defines the duration for which the first peak time would be applicable. When ccqmCmtsEnfRuleMonDuration is polled during first peak, it will return this value. The ccqmCmtsEnfRuleFirstPeakTime has to be defined before defining this object else it will be taken to start from 0. This object cannot be changed when ccqmCmtsEnfRuleRowStatus is active(1).')
ccqmCmtsEnfRuleFirstAvgRate = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 341, 1, 1, 1, 1, 18), Unsigned32()).setUnits('kbits/sec').setMaxAccess("readcreate")
if mibBuilder.loadTexts: ccqmCmtsEnfRuleFirstAvgRate.setStatus('current')
if mibBuilder.loadTexts: ccqmCmtsEnfRuleFirstAvgRate.setDescription('This object defines the rate at which the subscriber is allowed to consume during the first peak duration. The ccqmCmtsEnfRuleFirstDuration has to be defined before defining this value. This object cannot be changed when ccqmCmtsEnfRuleRowStatus is active(1).')
ccqmCmtsEnfRuleSecondPeakTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 341, 1, 1, 1, 1, 19), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 23))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ccqmCmtsEnfRuleSecondPeakTime.setStatus('current')
if mibBuilder.loadTexts: ccqmCmtsEnfRuleSecondPeakTime.setDescription("The user can define two peak times in a day. The second peak is defined using ccqmCmtsEnfRuleSecondPeakTime, ccqmCmtsEnfRuleSecondDuration and ccqmCmtsEnfRuleSecondThreshold objects while the first peak is defined using ccqmCmtsEnfRuleFirstPeakTime, ccqmCmtsEnfRuleFirstDuration and ccqmCmtsEnfRuleFirstDuration. For the remaining hours in the day, the off-peak monitoring would happen if both ccqmCmtsEnfRuleOffPeakDuration and ccqmCmtsEnfRuleOffPeakThreshold are defined. Defining the first peak is mandatory, though defining the second peak and offpeak is not mandatory. Both these peak times should be defined such that they don't overlap and the first peak time has to be an earlier time than the second peak time. ccqmCmtsEnfRuleSecondDuration can be set to 0 to indicate that the second peak monitoring no longer needs to be performed. The first peak has to be defined before defining the second peak time. User would need to use 24 hour clock for setting this. This object cannot be changed when ccqmCmtsEnfRuleRowStatus is active(1).")
ccqmCmtsEnfRuleSecondDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 341, 1, 1, 1, 1, 20), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1380))).setUnits('minutes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: ccqmCmtsEnfRuleSecondDuration.setStatus('current')
if mibBuilder.loadTexts: ccqmCmtsEnfRuleSecondDuration.setDescription('This object defines the duration for which the second peak time would be applicable. When ccqmCmtsEnfRuleMonDuration is polled during second peak, it will return this value. It can be set to 0 to indicate that the second peak monitoring no longer needs to be performed. The ccqmCmtsEnfRuleSecondPeakTime has to be defined before defining this object. This object cannot be changed when ccqmCmtsEnfRuleRowStatus is active(1).')
ccqmCmtsEnfRuleSecondAvgRate = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 341, 1, 1, 1, 1, 21), Unsigned32()).setUnits('kbits/sec').setMaxAccess("readcreate")
if mibBuilder.loadTexts: ccqmCmtsEnfRuleSecondAvgRate.setStatus('current')
if mibBuilder.loadTexts: ccqmCmtsEnfRuleSecondAvgRate.setDescription('This object defines the rate at which the subscriber is allowed to consume during the second peak duration. The ccqmCmtsEnfRuleSecondDuration has to be defined before defining this value. This object cannot be changed when ccqmCmtsEnfRuleRowStatus is active(1).')
ccqmCmtsEnfRuleOffPeakDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 341, 1, 1, 1, 1, 22), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1380))).setUnits('minutes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: ccqmCmtsEnfRuleOffPeakDuration.setStatus('current')
if mibBuilder.loadTexts: ccqmCmtsEnfRuleOffPeakDuration.setDescription('This object defines the monitoring-duration that would be applicable for the offpeak times of the day. The off peak times are the times during the day when none of the first peak and second peak times are defined. If this object is set, when ccqmCmtsEnfRuleMonDuration is polled during offpeak times, it would return this value. Since only defining the first peak is mandatory, and defining second peak and off peak are optional the monitoring combinations during the day could be: 1) Only first peak 2) First peak and second peak 3) First peak and off peak 4) All three i.e., first peak, second peak and off peak. It can be set to 0 to indicate that the offpeak monitoring no longer needs to be performed. The first peak parameters have to be defined before defining this object. This object cannot be changed when ccqmCmtsEnfRuleRowStatus is active(1).')
ccqmCmtsEnfRuleOffPeakAvgRate = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 341, 1, 1, 1, 1, 23), Unsigned32()).setUnits('kbits/sec').setMaxAccess("readcreate")
if mibBuilder.loadTexts: ccqmCmtsEnfRuleOffPeakAvgRate.setStatus('current')
if mibBuilder.loadTexts: ccqmCmtsEnfRuleOffPeakAvgRate.setDescription('This object defines the rate at which the subscriber is allowed to consume during the off-peak duration. The ccqmCmtsEnfRuleOffPeakDuration has to be defined before defining this value. This object cannot be changed when ccqmCmtsEnfRuleRowStatus is active(1).')
ccqmEnfRuleViolateTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 341, 1, 2, 2), )
if mibBuilder.loadTexts: ccqmEnfRuleViolateTable.setStatus('current')
if mibBuilder.loadTexts: ccqmEnfRuleViolateTable.setDescription('This table contains information of the subscribers who violated their enforce rule over the monitoring duration. In the sliding window concept used, the monitoring duration is the size of the window. This window slides by an amount that is equal to the sample rate. At every sample rate the bytes transmitted in the time equal to a monitoring duration is checked. If this is found to be larger than the defined byte count limit per monitoring duration, the subscriber is flagged as over consuming or to have violated his enforce rule. This table has entries for each of these violating subscribers. In case the violating subscriber has a enforced QoS parameter set, the QoS parameter set for such subscribers will be changed to the enforced QoS parameter set for the penalty time. When the penalty time expires, the subscriber gets his registered QoS parameter set restored and will no longer appear in this table but will be monitored. ')
ccqmEnfRuleViolateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 341, 1, 2, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "CISCO-CABLE-QOS-MONITOR-MIB", "ccqmEnfRuleViolateID"))
if mibBuilder.loadTexts: ccqmEnfRuleViolateEntry.setStatus('current')
if mibBuilder.loadTexts: ccqmEnfRuleViolateEntry.setDescription('A set of attributes of a subscriber who violated his enforce rule in the monitoring period. An entry in this table exists for each subscriber who over-consumed resources based on his configured QoS parameter set. However those subscribers who have an enforced QoS parameter set associated with their enforce rule, will be removed from this table once their penalty time expires. An entry in this table can exist for ifEntry with an ifType of docsCableMaclayer(127).')
ccqmEnfRuleViolateID = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 341, 1, 2, 2, 1, 1), Unsigned32())
if mibBuilder.loadTexts: ccqmEnfRuleViolateID.setStatus('current')
if mibBuilder.loadTexts: ccqmEnfRuleViolateID.setDescription('An index assigned to the service flow by the CMTS. This represents an internal service flow ID.')
ccqmEnfRuleViolateMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 341, 1, 2, 2, 1, 2), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccqmEnfRuleViolateMacAddr.setStatus('current')
if mibBuilder.loadTexts: ccqmEnfRuleViolateMacAddr.setDescription('MAC address of this subscriber. If the subscriber has multiple MAC addresses, this is the MAC address associated with the Cable interface.')
ccqmEnfRuleViolateRuleName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 341, 1, 2, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccqmEnfRuleViolateRuleName.setStatus('current')
if mibBuilder.loadTexts: ccqmEnfRuleViolateRuleName.setDescription('A pointer to the enforce rule associated with this subscriber. It provides for referencing the enforce rule to determine the QoS monitoring parameters. This is same as ccqmCmtsEnfRuleName for the corresponding enforce rule in ccqmCmtsEnforceRuleTable.')
ccqmEnfRuleViolateByteCount = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 341, 1, 2, 2, 1, 4), Unsigned32()).setUnits('kbytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: ccqmEnfRuleViolateByteCount.setStatus('current')
if mibBuilder.loadTexts: ccqmEnfRuleViolateByteCount.setDescription('The total kbytes consumed by the subscriber in the monitoring duration as specified in the corresponding enforce rule object ccqmCmtsEnfRuleMonDuration. If the monitoring is restarted due to change in enforce rule or any other circumstance this count will be reset.')
ccqmEnfRuleViolateLastDetectTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 341, 1, 2, 2, 1, 5), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccqmEnfRuleViolateLastDetectTime.setStatus('current')
if mibBuilder.loadTexts: ccqmEnfRuleViolateLastDetectTime.setDescription('The time at which the subscriber was found to have violated his enforce rule and the time from which the enforced QoS parameter set, if any, was in effect. ')
ccqmEnfRuleViolatePenaltyExpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 341, 1, 2, 2, 1, 6), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccqmEnfRuleViolatePenaltyExpTime.setStatus('current')
if mibBuilder.loadTexts: ccqmEnfRuleViolatePenaltyExpTime.setDescription('The time when the original QoS parameter set will be restored for this violating subscriber. If there was no enforced QoS parameter set configured for this subscriber this object returns 0.')
ccqmCmtsIfBwUtilTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 341, 1, 3, 1), )
if mibBuilder.loadTexts: ccqmCmtsIfBwUtilTable.setStatus('current')
if mibBuilder.loadTexts: ccqmCmtsIfBwUtilTable.setDescription('This table contains the attributes which define the bandwidth utilization thresholds for the upstream and downstream interfaces and when the load on these interfaces exceeds the upper threshold, the monitoring of the associated modems service flows starts, and it stops when the interface utilization drops below the lower threshold. For the monitoring to start, there should be appropriate enforce-rules defined. In case no thresholds are defined, by default the monitoring of modems would take place if the appropriate enforce-rules are present.')
ccqmCmtsIfBwUtilEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 341, 1, 3, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: ccqmCmtsIfBwUtilEntry.setStatus('current')
if mibBuilder.loadTexts: ccqmCmtsIfBwUtilEntry.setDescription('A set of attributes to provide additional level of control for monitoring modems. It is indexed by the ifIndex of upstream/downstream interface, thus, only docsCableDownstreamInterface(128) and docsCableUpstreamInterface(129) are allowed to be configured.')
ccqmCmtsIfBwUtilUpThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 341, 1, 3, 1, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 99)).clone(80)).setUnits('percent').setMaxAccess("readcreate")
if mibBuilder.loadTexts: ccqmCmtsIfBwUtilUpThreshold.setStatus('current')
if mibBuilder.loadTexts: ccqmCmtsIfBwUtilUpThreshold.setDescription("This object defines the upper threshold for the interface bandwidth utilization and when interface bandwidth utilization exceeds this threshold, monitoring of the appropriate modem's service flow will start if there is an asociated enforce-rule present. This object can't be set to a value lower than ccqmCmtsIfBwUtilLoThreshold.")
ccqmCmtsIfBwUtilLoThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 341, 1, 3, 1, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 99)).clone(40)).setUnits('percent').setMaxAccess("readcreate")
if mibBuilder.loadTexts: ccqmCmtsIfBwUtilLoThreshold.setStatus('current')
if mibBuilder.loadTexts: ccqmCmtsIfBwUtilLoThreshold.setDescription("This object defines the lower threshold for the interface bandwidth utilization and when interface bandwidth utilization drops below this threshold, the monitoring of the appropriate modem's service flow will stop. This object can't be set to a value higher than ccqmCmtsIfBwUtilUpThreshold.")
ccqmCmtsIfBwUtilRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 341, 1, 3, 1, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ccqmCmtsIfBwUtilRowStatus.setStatus('current')
if mibBuilder.loadTexts: ccqmCmtsIfBwUtilRowStatus.setDescription('The object controls and reflects the status of rows in this table. create-and-wait is not supported. The objects can be changed even when the row status is active(1).')
ccqmEnfRuleViolateNotifEnable = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 341, 1, 2, 3), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccqmEnfRuleViolateNotifEnable.setStatus('current')
if mibBuilder.loadTexts: ccqmEnfRuleViolateNotifEnable.setDescription('An indication of whether the ccqmEnfRuleViolateNotification is enabled or disabled.')
ccqmMIBNotificationsPrefix = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 341, 2))
ccqmMIBNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 341, 2, 0))
ccqmEnfRuleViolateNotification = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 341, 2, 0, 1)).setObjects(("CISCO-CABLE-QOS-MONITOR-MIB", "ccqmEnfRuleViolateMacAddr"), ("CISCO-CABLE-QOS-MONITOR-MIB", "ccqmEnfRuleViolateRuleName"), ("CISCO-CABLE-QOS-MONITOR-MIB", "ccqmEnfRuleViolatePenaltyExpTime"), ("CISCO-CABLE-QOS-MONITOR-MIB", "ccqmEnfRuleViolateByteCount"))
if mibBuilder.loadTexts: ccqmEnfRuleViolateNotification.setStatus('current')
if mibBuilder.loadTexts: ccqmEnfRuleViolateNotification.setDescription('A notification that is sent when the subscriber if found to have violated his enforce rule. This indicates that this subscriber was found to be over consuming resources. If the enforce rule associated with this subscriber has a enforced QoS parameter set configured, the trap also indicates that the QoS parameter set of this subscriber are changed to the enforced QoS parameter set. ')
ccqmMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 341, 3))
ccqmMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 341, 3, 1))
ccqmMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 341, 3, 2))
ccqmCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 341, 3, 1, 1)).setObjects(("CISCO-CABLE-QOS-MONITOR-MIB", "ccqmEnfRuleGroup"), ("CISCO-CABLE-QOS-MONITOR-MIB", "ccqmEnfRuleViolateGroup"), ("CISCO-CABLE-QOS-MONITOR-MIB", "ccqmEnfRuleViolateNotifGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ccqmCompliance = ccqmCompliance.setStatus('obsolete')
if mibBuilder.loadTexts: ccqmCompliance.setDescription('The compliance statement for CMTS devices that implement the Qos Monitoring feature. ')
ccqmComplianceRev1 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 341, 3, 1, 2)).setObjects(("CISCO-CABLE-QOS-MONITOR-MIB", "ccqmEnfRuleGroupRev1"), ("CISCO-CABLE-QOS-MONITOR-MIB", "ccqmEnfRuleViolateGroup"), ("CISCO-CABLE-QOS-MONITOR-MIB", "ccqmCmtsRuleIfBwUtilGroup"), ("CISCO-CABLE-QOS-MONITOR-MIB", "ccqmEnfRuleViolateNotifGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ccqmComplianceRev1 = ccqmComplianceRev1.setStatus('current')
if mibBuilder.loadTexts: ccqmComplianceRev1.setDescription('The compliance statement for CMTS devices that implement the Qos Monitoring feature. ')
ccqmEnfRuleGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 341, 3, 2, 1)).setObjects(("CISCO-CABLE-QOS-MONITOR-MIB", "ccqmCmtsEnfRuleRegQoS"), ("CISCO-CABLE-QOS-MONITOR-MIB", "ccqmCmtsEnfRuleEnfQos"), ("CISCO-CABLE-QOS-MONITOR-MIB", "ccqmCmtsEnfRuleMonDuration"), ("CISCO-CABLE-QOS-MONITOR-MIB", "ccqmCmtsEnfRuleSampleRate"), ("CISCO-CABLE-QOS-MONITOR-MIB", "ccqmCmtsEnfRulePenaltyPeriod"), ("CISCO-CABLE-QOS-MONITOR-MIB", "ccqmCmtsEnfRuleByteCount"), ("CISCO-CABLE-QOS-MONITOR-MIB", "ccqmCmtsEnfRuleDirection"), ("CISCO-CABLE-QOS-MONITOR-MIB", "ccqmCmtsEnfRuleAutoEnforce"), ("CISCO-CABLE-QOS-MONITOR-MIB", "ccqmCmtsEnfRuleRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ccqmEnfRuleGroup = ccqmEnfRuleGroup.setStatus('obsolete')
if mibBuilder.loadTexts: ccqmEnfRuleGroup.setDescription('Group of objects implemented in CMTS providing enforce rule and QoS monitoring information. ')
ccqmEnfRuleViolateGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 341, 3, 2, 2)).setObjects(("CISCO-CABLE-QOS-MONITOR-MIB", "ccqmEnfRuleViolateRuleName"), ("CISCO-CABLE-QOS-MONITOR-MIB", "ccqmEnfRuleViolateMacAddr"), ("CISCO-CABLE-QOS-MONITOR-MIB", "ccqmEnfRuleViolateByteCount"), ("CISCO-CABLE-QOS-MONITOR-MIB", "ccqmEnfRuleViolateLastDetectTime"), ("CISCO-CABLE-QOS-MONITOR-MIB", "ccqmEnfRuleViolatePenaltyExpTime"), ("CISCO-CABLE-QOS-MONITOR-MIB", "ccqmEnfRuleViolateNotifEnable"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ccqmEnfRuleViolateGroup = ccqmEnfRuleViolateGroup.setStatus('current')
if mibBuilder.loadTexts: ccqmEnfRuleViolateGroup.setDescription('Group of objects implemented in CMTS providing information of enforce rule violations. ')
ccqmEnfRuleViolateNotifGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 9, 9, 341, 3, 2, 3)).setObjects(("CISCO-CABLE-QOS-MONITOR-MIB", "ccqmEnfRuleViolateNotification"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ccqmEnfRuleViolateNotifGroup = ccqmEnfRuleViolateNotifGroup.setStatus('current')
if mibBuilder.loadTexts: ccqmEnfRuleViolateNotifGroup.setDescription('The notification which a CISCO-CABLE-QOS-MONITOR-MIB is required to implement.')
ccqmEnfRuleGroupRev1 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 341, 3, 2, 4)).setObjects(("CISCO-CABLE-QOS-MONITOR-MIB", "ccqmCmtsEnfRuleRegQoS"), ("CISCO-CABLE-QOS-MONITOR-MIB", "ccqmCmtsEnfRuleEnfQos"), ("CISCO-CABLE-QOS-MONITOR-MIB", "ccqmCmtsEnfRuleMonDuration"), ("CISCO-CABLE-QOS-MONITOR-MIB", "ccqmCmtsEnfRuleSampleRate"), ("CISCO-CABLE-QOS-MONITOR-MIB", "ccqmCmtsEnfRulePenaltyPeriod"), ("CISCO-CABLE-QOS-MONITOR-MIB", "ccqmCmtsEnfRuleDirection"), ("CISCO-CABLE-QOS-MONITOR-MIB", "ccqmCmtsEnfRuleAutoEnforce"), ("CISCO-CABLE-QOS-MONITOR-MIB", "ccqmCmtsEnfRuleRowStatus"), ("CISCO-CABLE-QOS-MONITOR-MIB", "ccqmCmtsEnfRuleAvgRate"), ("CISCO-CABLE-QOS-MONITOR-MIB", "ccqmCmtsEnfRuleDocsVer"), ("CISCO-CABLE-QOS-MONITOR-MIB", "ccqmCmtsEnfRuleRegSerClassName"), ("CISCO-CABLE-QOS-MONITOR-MIB", "ccqmCmtsEnfRuleEnfSerClassName"), ("CISCO-CABLE-QOS-MONITOR-MIB", "ccqmCmtsEnfRuleMonType"), ("CISCO-CABLE-QOS-MONITOR-MIB", "ccqmCmtsEnfRuleFirstPeakTime"), ("CISCO-CABLE-QOS-MONITOR-MIB", "ccqmCmtsEnfRuleFirstDuration"), ("CISCO-CABLE-QOS-MONITOR-MIB", "ccqmCmtsEnfRuleFirstAvgRate"), ("CISCO-CABLE-QOS-MONITOR-MIB", "ccqmCmtsEnfRuleSecondPeakTime"), ("CISCO-CABLE-QOS-MONITOR-MIB", "ccqmCmtsEnfRuleSecondDuration"), ("CISCO-CABLE-QOS-MONITOR-MIB", "ccqmCmtsEnfRuleSecondAvgRate"), ("CISCO-CABLE-QOS-MONITOR-MIB", "ccqmCmtsEnfRuleOffPeakDuration"), ("CISCO-CABLE-QOS-MONITOR-MIB", "ccqmCmtsEnfRuleOffPeakAvgRate"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ccqmEnfRuleGroupRev1 = ccqmEnfRuleGroupRev1.setStatus('current')
if mibBuilder.loadTexts: ccqmEnfRuleGroupRev1.setDescription('Group of objects implemented in CMTS providing enforce rule and QoS monitoring information. ')
ccqmCmtsRuleIfBwUtilGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 341, 3, 2, 5)).setObjects(("CISCO-CABLE-QOS-MONITOR-MIB", "ccqmCmtsIfBwUtilUpThreshold"), ("CISCO-CABLE-QOS-MONITOR-MIB", "ccqmCmtsIfBwUtilLoThreshold"), ("CISCO-CABLE-QOS-MONITOR-MIB", "ccqmCmtsIfBwUtilRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ccqmCmtsRuleIfBwUtilGroup = ccqmCmtsRuleIfBwUtilGroup.setStatus('current')
if mibBuilder.loadTexts: ccqmCmtsRuleIfBwUtilGroup.setDescription('Group of objects implemented in CMTS providing information of interface utilization thresholds. ')
mibBuilder.exportSymbols("CISCO-CABLE-QOS-MONITOR-MIB", ccqmEnforceRuleObjects=ccqmEnforceRuleObjects, ccqmMIBCompliances=ccqmMIBCompliances, ccqmCmtsEnfRuleRowStatus=ccqmCmtsEnfRuleRowStatus, ccqmRuleViolateObjects=ccqmRuleViolateObjects, ccqmCmtsEnforceRuleTable=ccqmCmtsEnforceRuleTable, ccqmCmtsEnfRuleDocsVer=ccqmCmtsEnfRuleDocsVer, ccqmCmtsEnfRuleOffPeakDuration=ccqmCmtsEnfRuleOffPeakDuration, ccqmCmtsRuleIfBwUtilGroup=ccqmCmtsRuleIfBwUtilGroup, CCQMRuleDirection=CCQMRuleDirection, ccqmEnfRuleViolateNotifEnable=ccqmEnfRuleViolateNotifEnable, ccqmMIBGroups=ccqmMIBGroups, ciscoCableQosMonitorMIBObjects=ciscoCableQosMonitorMIBObjects, ccqmCmtsEnfRuleEnfSerClassName=ccqmCmtsEnfRuleEnfSerClassName, ccqmEnfRuleViolateByteCount=ccqmEnfRuleViolateByteCount, ccqmCmtsEnfRuleFirstPeakTime=ccqmCmtsEnfRuleFirstPeakTime, ccqmCmtsEnfRuleName=ccqmCmtsEnfRuleName, ccqmEnfRuleViolateNotifGroup=ccqmEnfRuleViolateNotifGroup, ccqmCmtsIfBwUtilRowStatus=ccqmCmtsIfBwUtilRowStatus, ccqmCmtsEnfRuleSecondDuration=ccqmCmtsEnfRuleSecondDuration, ccqmCmtsEnfRuleSecondPeakTime=ccqmCmtsEnfRuleSecondPeakTime, ccqmEnfRuleViolateMacAddr=ccqmEnfRuleViolateMacAddr, ccqmCmtsEnfRuleMonType=ccqmCmtsEnfRuleMonType, ccqmCmtsEnfRuleByteCount=ccqmCmtsEnfRuleByteCount, ccqmCmtsEnfRuleRegSerClassName=ccqmCmtsEnfRuleRegSerClassName, ccqmEnfRuleViolatePenaltyExpTime=ccqmEnfRuleViolatePenaltyExpTime, ccqmMIBConformance=ccqmMIBConformance, ccqmEnfRuleViolateEntry=ccqmEnfRuleViolateEntry, ccqmCmtsEnforceRuleEntry=ccqmCmtsEnforceRuleEntry, ccqmCmtsEnfRuleEnfQos=ccqmCmtsEnfRuleEnfQos, ccqmCompliance=ccqmCompliance, ccqmEnfRuleGroupRev1=ccqmEnfRuleGroupRev1, PYSNMP_MODULE_ID=ciscoCableQosMonitorMIB, ccqmCmtsIfBwUtilEntry=ccqmCmtsIfBwUtilEntry, ccqmCmtsEnfRuleFirstDuration=ccqmCmtsEnfRuleFirstDuration, ccqmComplianceRev1=ccqmComplianceRev1, ccqmEnfRuleViolateID=ccqmEnfRuleViolateID, ccqmCmtsIfBwUtilLoThreshold=ccqmCmtsIfBwUtilLoThreshold, ccqmCmtsEnfRuleFirstAvgRate=ccqmCmtsEnfRuleFirstAvgRate, ccqmEnfRuleViolateGroup=ccqmEnfRuleViolateGroup, ccqmMIBNotificationsPrefix=ccqmMIBNotificationsPrefix, ccqmEnfRuleViolateRuleName=ccqmEnfRuleViolateRuleName, ccqmMIBNotifications=ccqmMIBNotifications, ccqmCmtsEnfRuleMonDuration=ccqmCmtsEnfRuleMonDuration, ccqmEnfRuleViolateTable=ccqmEnfRuleViolateTable, ccqmCmtsIfBwUtilUpThreshold=ccqmCmtsIfBwUtilUpThreshold, ccqmCmtsEnfRuleSampleRate=ccqmCmtsEnfRuleSampleRate, ccqmCmtsEnfRuleAvgRate=ccqmCmtsEnfRuleAvgRate, ccqmCmtsEnfRuleRegQoS=ccqmCmtsEnfRuleRegQoS, ccqmCmtsEnfRuleOffPeakAvgRate=ccqmCmtsEnfRuleOffPeakAvgRate, ccqmRuleIfBwUtilObjects=ccqmRuleIfBwUtilObjects, ccqmCmtsEnfRuleAutoEnforce=ccqmCmtsEnfRuleAutoEnforce, ciscoCableQosMonitorMIB=ciscoCableQosMonitorMIB, ccqmCmtsIfBwUtilTable=ccqmCmtsIfBwUtilTable, ccqmEnfRuleViolateLastDetectTime=ccqmEnfRuleViolateLastDetectTime, ccqmCmtsEnfRuleSecondAvgRate=ccqmCmtsEnfRuleSecondAvgRate, ccqmEnfRuleViolateNotification=ccqmEnfRuleViolateNotification, ccqmCmtsEnfRulePenaltyPeriod=ccqmCmtsEnfRulePenaltyPeriod, ccqmCmtsEnfRuleDirection=ccqmCmtsEnfRuleDirection, ccqmEnfRuleGroup=ccqmEnfRuleGroup)

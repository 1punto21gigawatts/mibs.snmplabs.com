#
# PySNMP MIB module HP-ICF-GENERIC-RPTR (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/HP-ICF-GENERIC-RPTR
# Produced by pysmi-0.3.4 at Wed May  1 13:34:02 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsIntersection, ValueSizeConstraint, ValueRangeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsIntersection", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsUnion")
icfHub, hpicfGenericRepeater, hpicfObjectModules, hpicfGenRptrTrapsPrefix = mibBuilder.importSymbols("HP-ICF-OID", "icfHub", "hpicfGenericRepeater", "hpicfObjectModules", "hpicfGenRptrTrapsPrefix")
ModuleCompliance, NotificationGroup, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup", "ObjectGroup")
MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, Unsigned32, ObjectIdentity, NotificationType, MibIdentifier, Bits, Gauge32, iso, Integer32, ModuleIdentity, IpAddress, Counter64, Counter32 = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "Unsigned32", "ObjectIdentity", "NotificationType", "MibIdentifier", "Bits", "Gauge32", "iso", "Integer32", "ModuleIdentity", "IpAddress", "Counter64", "Counter32")
TimeStamp, DisplayString, TextualConvention, MacAddress, RowStatus = mibBuilder.importSymbols("SNMPv2-TC", "TimeStamp", "DisplayString", "TextualConvention", "MacAddress", "RowStatus")
hpicfGenRptrMib = ModuleIdentity((1, 3, 6, 1, 4, 1, 11, 2, 14, 10, 2, 8))
hpicfGenRptrMib.setRevisions(('2009-10-26 12:03', '2003-06-09 22:37', '2000-11-03 07:17', '1998-07-23 01:03', '1997-03-06 03:37', '1996-09-10 02:28', '1995-10-23 23:47', '1995-01-18 00:00', '1993-07-09 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: hpicfGenRptrMib.setRevisionsDescriptions(('Deprecate hpSecPtAddressLimit, create and add hpSecPtAddressLimit2 to HpSecurePortEntry and hpicfSecPtGroup3.', 'Added learnLimitedContinuous mode to hpSecPtLearnMode.', 'Deprecate hpSecPtPreventEavesdrop. Update division name.', 'Added the hpicfGenRptrBridgeGroup. Updated compliances.', 'Added the hpicfGenRptrSwitchConfigGroup. Added NOTIFICATION-GROUP information.', 'Split this MIB module from the former monolithic hp-icf MIB. Added the hpicfGenRptrInfoGroup, the hpicfGenRptrBkpLinkGroup, and the hpicfGenRptrPortMappingGroup.', 'Version of MIB module that added support for the HPJ2413A and HPJ2415A 100VG hubs, and the HPJ2414B agent module. Added the hpicfGenRptrSecPtGroup.', 'Version of MIB module that added support for the HPJ2410A 100VG repeater and the HPJ2414A agent module. Added the hpicfGenRptrBasicGroup.', 'Initial version of this MIB module. Released with the HPJ2355A hub.',))
if mibBuilder.loadTexts: hpicfGenRptrMib.setLastUpdated('200910261203Z')
if mibBuilder.loadTexts: hpicfGenRptrMib.setOrganization('HP Networking')
if mibBuilder.loadTexts: hpicfGenRptrMib.setContactInfo('Hewlett Packard Company 8000 Foothills Blvd. Roseville, CA 95747')
if mibBuilder.loadTexts: hpicfGenRptrMib.setDescription('This MIB module contains object definitions that are common to all repeater devices in the HP Integrated Communication Facility product line.')
hpGRpBasic = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 4, 1))
hpGRpBasicGlobal = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 4, 1, 1))
hpGRpSelfHealEnable = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpGRpSelfHealEnable.setStatus('current')
if mibBuilder.loadTexts: hpGRpSelfHealEnable.setDescription('This flag controls whether or not the device will send self healing packets. Self healing packets are normally sent once per second by the agent when no other traffic is present. When there is no traffic present on a network, there is no way to detect cabling problems (or the repair of cabling problems) and status LEDs are not always correct. Enabling this flag allows the agent to detect cabling problems on an idle network. This flag can be disabled if self healing packets are not wanted. On the 100BaseVG-AnyLAN SNMP/Bridge card, these packets are addressed to a unique unused unicast station address which has been reserved by HP for this purpose. On 802.3 repeaters, these packets are self addressed. On an 802.3 repeater, this flag MUST be enabled when using the Robust Port Healing feature. Without Robust Port Healing either a good transmit or a good receive will reconnect an autopartitioned port. With Robust Port Healing the criteria is more restrictive and only a good transmit will heal a segmented port. If all ports are segmented, the repeater will not repeat anything until the agent transmits a self healing packet and reconnects the autopartitioned ports.')
hpGRpRepeaterTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 4, 1, 1, 2), )
if mibBuilder.loadTexts: hpGRpRepeaterTable.setStatus('current')
if mibBuilder.loadTexts: hpGRpRepeaterTable.setDescription('A table containing generic information about the current logical repeaters in this managed system.')
hpGRpRepeaterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 4, 1, 1, 2, 1), ).setIndexNames((0, "HP-ICF-GENERIC-RPTR", "hpGRpRepeaterIndex"))
if mibBuilder.loadTexts: hpGRpRepeaterEntry.setStatus('current')
if mibBuilder.loadTexts: hpGRpRepeaterEntry.setDescription('An entry in the table, containing information about a single logical repeater.')
hpGRpRepeaterIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 4, 1, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: hpGRpRepeaterIndex.setStatus('current')
if mibBuilder.loadTexts: hpGRpRepeaterIndex.setDescription("This object uniquely identifies the logical repeater in the managed system for which this entry contains information. This object will have the same value as the corresponding 'repeater index' object in the media-specific repeater MIB for this repeater. Note that it will also have the same value as the instance of the Entity MIB's entLogicalIndex for the entry in the entLogicalTable that represents this repeater.")
hpGRpRepeaterIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 4, 1, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpGRpRepeaterIfIndex.setStatus('current')
if mibBuilder.loadTexts: hpGRpRepeaterIfIndex.setDescription('The interface on the agent that is used to transmit and receive packets through this repeater. The ifEntry identified by this value is the same entry identified by the same value of the ifIndex object. The value zero indicates that the agent has no interface through which it can send and receive packets on this repeater.')
hpGRpRepeaterName = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 4, 1, 1, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpGRpRepeaterName.setStatus('current')
if mibBuilder.loadTexts: hpGRpRepeaterName.setDescription('A friendly name for this repeater. Management applications can use this to configure a user friendly name for this logical repeater.')
hpGRpRepeaterVlanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 4, 1, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpGRpRepeaterVlanIndex.setStatus('current')
if mibBuilder.loadTexts: hpGRpRepeaterVlanIndex.setDescription("The virtual LAN that this repeater is on. Note that setting this object does not affect the operation of the repeater in any way. It is a 'notepad' for management applications to allow them to record which VLAN on a connected switch this logical repeater is connected to.")
hubSecurity = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 10))
hubSecurePortTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 10, 1), )
if mibBuilder.loadTexts: hubSecurePortTable.setStatus('current')
if mibBuilder.loadTexts: hubSecurePortTable.setDescription('Table containing security configuration for each port.')
hubSecurePortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 10, 1, 1), ).setIndexNames((0, "HP-ICF-GENERIC-RPTR", "hubSecPtGroupIndex"), (0, "HP-ICF-GENERIC-RPTR", "hubSecPtPortIndex"))
if mibBuilder.loadTexts: hubSecurePortEntry.setStatus('current')
if mibBuilder.loadTexts: hubSecurePortEntry.setDescription('An entry in the hubSecurePortTable, containing the security configuration for a single port.')
hubSecPtGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 10, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubSecPtGroupIndex.setStatus('current')
if mibBuilder.loadTexts: hubSecPtGroupIndex.setDescription('This object identifies the group containing the port for which this entry contains security configuration information.')
hubSecPtPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 10, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubSecPtPortIndex.setStatus('current')
if mibBuilder.loadTexts: hubSecPtPortIndex.setDescription('This object identifies the port within the group for which this entry contains security configuration information.')
hubSecPtSecurityAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 10, 1, 1, 3), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hubSecPtSecurityAddress.setStatus('current')
if mibBuilder.loadTexts: hubSecPtSecurityAddress.setDescription('The desired authorized MAC address for this port. This can be either a regular station address to configure a specific address, or it can be one of the following special values to specify the address learning method: FFFF-FFFF-FFFE: learnOnce. First source MAC address heard on this port becomes the authorized address. Setting this value initiates learning of a new authorized address. When a new authorized address is learned, it will be stored in nonvolatile memory. This variable will return learnOnceConditionally to a GET operation after it has been set to this value. FFFF-FFFF-FFFD: learnOnceConditionally. This option will initiate learning of a new authorized address only if the previous hubSecPtSecurityAddress was set to a specific address or learnContinuous. No action will be performed if the previous value was already learnOnceConditionally. FFFF-FFFF-FFFC: learnContinuous. Any address heard becomes the new authorized address. When a new address is learned, it may cause an alarm, but it does not store anything in nonvolatile memory.')
hubSecPtAuthorizedAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 10, 1, 1, 4), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubSecPtAuthorizedAddress.setStatus('current')
if mibBuilder.loadTexts: hubSecPtAuthorizedAddress.setDescription('The MAC address of the station authorized to be on this port. This address could either have been configured by specifying a regular station address for hubSecPtSecurityAddress, or it could have been learned by the agent if hubSecPtSecurityAddress was set to one of the special values listed above. Once the agent has learned an authorized address, it will be saved across powerfails, unless the agent was configured for learnContinuous mode.')
hubSecPtPreventEavesdrop = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 10, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hubSecPtPreventEavesdrop.setStatus('current')
if mibBuilder.loadTexts: hubSecPtPreventEavesdrop.setDescription('If enabled, unicast packets not addressed to the authorized address for this port will be scrambled.')
hubSecPtAlarmEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 10, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hubSecPtAlarmEnable.setStatus('current')
if mibBuilder.loadTexts: hubSecPtAlarmEnable.setDescription('If enabled, the agent will generate an intrusionTrap if a packet is received on this port with a source MAC address that is different from the hubSecPtAuthorizedAddress for this port.')
hubSecPtIntrusionFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 10, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("intrusion", 1), ("noIntrusion", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hubSecPtIntrusionFlag.setStatus('current')
if mibBuilder.loadTexts: hubSecPtIntrusionFlag.setDescription('This flag indicates if an intrusion has occurred on this port. The Security LED on the hub will blink if any instance of this flag has the value intrusion. Setting this flag to noIntrusion will turn off the Security LED if no other ports have this flag set to intrusion. An intrusion will only cause an alarm and an intrusion log entry if this flag is equal to noIntrusion.')
hubIntruderLogTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 10, 2), )
if mibBuilder.loadTexts: hubIntruderLogTable.setStatus('current')
if mibBuilder.loadTexts: hubIntruderLogTable.setDescription('This table contains a record of the twenty most recent port security violations. The first entry in the table is the oldest.')
hubIntruderLogEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 10, 2, 1), ).setIndexNames((0, "HP-ICF-GENERIC-RPTR", "hubIntruderIndex"))
if mibBuilder.loadTexts: hubIntruderLogEntry.setStatus('current')
if mibBuilder.loadTexts: hubIntruderLogEntry.setDescription('A row in the hubIntruderLogTable containing information about a single port security violation.')
hubIntruderIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 10, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubIntruderIndex.setStatus('current')
if mibBuilder.loadTexts: hubIntruderIndex.setDescription('The index of this entry in the intruder log table. Index 1 will always contain the oldest entry. If the table is full when a new intrusion occurs, the new entry becomes index 20, and all earlier entries are shifted down by one entry, removing the old index 1.')
hubIntruderGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 10, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubIntruderGroup.setStatus('current')
if mibBuilder.loadTexts: hubIntruderGroup.setDescription('This object identifies the group containing the port on which this intrusion occurred.')
hubIntruderPort = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 10, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubIntruderPort.setStatus('current')
if mibBuilder.loadTexts: hubIntruderPort.setDescription('This object identifies the port within the group on which this intrusion occurred. A port number of zero indicates that this entry is unused and the values for the other variables in this entry are undefined.')
hubIntruderAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 10, 2, 1, 4), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubIntruderAddress.setStatus('current')
if mibBuilder.loadTexts: hubIntruderAddress.setDescription('This object contains the source MAC address of the intruder.')
hubIntruderTime = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 10, 2, 1, 5), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubIntruderTime.setStatus('current')
if mibBuilder.loadTexts: hubIntruderTime.setDescription('The value of sysUpTime when the intrusion occurred. This will be zero if the agent has been reset since the intruder was detected, since sysUpTime could be misinterpreted in that case.')
hubIntruderType = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 10, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("address", 1), ("training", 2), ("both", 3), ("none", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubIntruderType.setStatus('current')
if mibBuilder.loadTexts: hubIntruderType.setDescription("This object identifies the type of violation that occured: address, training, or both. The hubIntruderTrainingViolation object will indicate additional information, if any, on the type of training violation. This object will be equal to 'none' if this log entry is unused. Note that the values 'training' and 'both' are only valid for 802.12 ports.")
hubIntruderTrainingViolation = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 10, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noViolation", 1), ("promiscuousViolation", 2), ("repeaterViolation", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hubIntruderTrainingViolation.setStatus('current')
if mibBuilder.loadTexts: hubIntruderTrainingViolation.setDescription("This object indicates the type of training violation. Note that for 802.3 ports, this object will always be equal to 'noViolation'. This object will be equal to 'noViolation' if this log entry is unused.")
hpSecurePortTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 10, 3), )
if mibBuilder.loadTexts: hpSecurePortTable.setStatus('current')
if mibBuilder.loadTexts: hpSecurePortTable.setDescription('Table containing security configuration for each port, where security for multiple MAC addresses per port is desired (e.g., switch systems).')
hpSecurePortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 10, 3, 1), ).setIndexNames((0, "HP-ICF-GENERIC-RPTR", "hpSecPtGroupIndex"), (0, "HP-ICF-GENERIC-RPTR", "hpSecPtPortIndex"))
if mibBuilder.loadTexts: hpSecurePortEntry.setStatus('current')
if mibBuilder.loadTexts: hpSecurePortEntry.setDescription('An entry in the hpSecurePortTable, containing the security configuration for a single port.')
hpSecPtGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 10, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: hpSecPtGroupIndex.setStatus('current')
if mibBuilder.loadTexts: hpSecPtGroupIndex.setDescription('This object identifies the group containing the port for which this entry contains security configuration information. On repeater systems, this can be used to identify a specific repeater within a managed stack of repeaters. On switch systems, stacked or unstacked, this value is always one.')
hpSecPtPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 10, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: hpSecPtPortIndex.setStatus('current')
if mibBuilder.loadTexts: hpSecPtPortIndex.setDescription('This object identifies the port within the group for which this entry contains security configuration information. On a switch system, this index corresponds to the ifIndex of the port.')
hpSecPtAddressLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 10, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpSecPtAddressLimit.setStatus('deprecated')
if mibBuilder.loadTexts: hpSecPtAddressLimit.setDescription('This object identifies the maximum number of MAC addresses learned on this port when the hpSecPtLearnMode is set to learnFirstN or learnFirstNConditionally. Changing the limit while in these modes clears any addresses for this port in the hpSecureAuthAddrTable. This limit does not apply when the learn mode is set to configureSpecific. This object will return the default value of 1 when hpSecPtAddressLimit2 is greater than 32.')
hpSecPtLearnMode = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 10, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("learnContinuous", 1), ("learnFirstN", 2), ("learnFirstNConditionally", 3), ("configureSpecific", 4), ("learn8021xAuthorized", 5), ("learnLimitedContinuous", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpSecPtLearnMode.setStatus('current')
if mibBuilder.loadTexts: hpSecPtLearnMode.setDescription('This object identifies the learning mode of the port. The modes are as follows: LearnContinuous. The port can learn all new MAC addresses. When a new address is learned, it is stored in a manner such that it can be retrieved from the hpSecureAuthAddrTable. Changing the mode to this value clears any existing addresses for this port in the hpSecureAuthAddrTable. learnFirstN. First N source MAC addresses heard on this port become the authorized addresses. N is configured in hpSecPtAddressLimit. Setting this value initiates learning of up to N new authorized addresses. When a new authorized address is learned, it will be stored in the hpSecureAuthAddrTable. When the table has reached its limit N for this port, any new source MAC addresses received on the port constitutes an intrusion. See hpSecPtAlarmEnable for possible responses to the intrusion. This variable will return learnFirstNConditionally to a GET operation after it has been set to this value. learnFirstNConditionally. This option will initiate learning of up to N new authorized addresses only if the previous hpSecPtLearnMode was not set to learnFirstN or learnFirstN- Conditionally. N is configured in hpSecPtAddressLimit. configureSpecific. The port will not learn any addresses. Rather, specific authorized MAC addresses for this port are explicitly configured via the hpSecureCfgAddrTable. These addresses are also stored in the hpSecureAuthAddrTable. Any source MAC address received on this port other than those configured, constitutes an intrusion. See hpSecPtAlarmEnable for possible responses. learn8021xAuthorized. The port will learn only MAC address of a client authorized by 802.1X authenticator. learnLimitedContinuous. First N source MAC addresses heard on this port become the authorized addresses. N is specified by the hpSecPtAddressLimit object. When a new authorized address is learned, it will be stored in the hpSecureAuthAddrTable. When the table has reached its limit N for this port, any new source MAC addresses received on the port constitutes an intrusion. See hpSecPtAlarmEnable for possible responses. The authorized addresses in this mode will age out of the system, therefore the list of authorized addresses can be dynamic over time.')
hpSecPtPreventEavesdrop = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 10, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpSecPtPreventEavesdrop.setStatus('deprecated')
if mibBuilder.loadTexts: hpSecPtPreventEavesdrop.setDescription('If enabled on a switch, outbound unknown unicast packets will not be forwarded out this port. If enabled on a repeater, outbound unknown unicast packets for this port will be scrambled.')
hpSecPtAlarmEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 10, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disable", 1), ("sendTrap", 2), ("sendTrapAndDisablePort", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpSecPtAlarmEnable.setStatus('current')
if mibBuilder.loadTexts: hpSecPtAlarmEnable.setDescription('This object identifies the action taken when an intrusion occurs. See hpSecPtLearnMode for what constitutes an intrusion. disable. No trap is sent and the port remains enabled. SendTrap. If the hpSecPtIntrusionFlag is set to noIntrusion, the agent will generate an intrusionTrap. SendTrapAndDisablePort. If the hpSecPtIntru- sionFlag is set to noIntrusion, the agent generate an intrusionTrap and disable the port. This value does not apply to repeaters.')
hpSecPtIntrusionFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 10, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("intrusion", 1), ("noIntrusion", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpSecPtIntrusionFlag.setStatus('current')
if mibBuilder.loadTexts: hpSecPtIntrusionFlag.setDescription('This flag indicates if an intrusion has occured on this port. Security-related LED(s) on the device will blink if any instance of this flag has the value intrusion. Setting this flag to noIntrusion will turn off the appropriate LED(s). An intrusion will only cause an alarm and an intrusion log entry if this flag is equal to noIntrusion. On a switch, packets causing intrusions will be not be forwarded.')
hpSecPtAddressLimit2 = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 10, 3, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpSecPtAddressLimit2.setStatus('current')
if mibBuilder.loadTexts: hpSecPtAddressLimit2.setDescription('This object identifies the maximum number of MAC addresses learned on this port when the hpSecPtLearnMode is set to learnFirstN or learnFirstNConditionally. The current maximum limit is 64. Changing the limit while in these modes clears any addresses for this port in the hpSecureAuthAddrTable. This limit does apply when the learn mode is set to configureSpecific.')
hpSecureCfgAddrTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 10, 4), )
if mibBuilder.loadTexts: hpSecureCfgAddrTable.setStatus('current')
if mibBuilder.loadTexts: hpSecureCfgAddrTable.setDescription('Table containing multiple configured authorized addresses per port. Facilitates security for ports whose hpSecPtLearnMode is set to configureSpecific.')
hpSecureCfgAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 10, 4, 1), ).setIndexNames((0, "HP-ICF-GENERIC-RPTR", "hpSecCfgAddrGroupIndex"), (0, "HP-ICF-GENERIC-RPTR", "hpSecCfgAddrPortIndex"), (0, "HP-ICF-GENERIC-RPTR", "hpSecCfgAddress"))
if mibBuilder.loadTexts: hpSecureCfgAddrEntry.setStatus('current')
if mibBuilder.loadTexts: hpSecureCfgAddrEntry.setDescription('An entry in the hpSecureCfgAddrTable, containing the configured authorized address for a single port. Entries are stored in nonvolatile memory when either the hpSecPtrLearnMode for the port is changed to configureSpecific, or a new entry is configured while hpSecPtrLearnMode for the port is currently set to configureSpecific.')
hpSecCfgAddrGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 10, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: hpSecCfgAddrGroupIndex.setStatus('current')
if mibBuilder.loadTexts: hpSecCfgAddrGroupIndex.setDescription('This object identifies the group containing the port for which this entry contains the configured authorized address. On repeater systems, this can be used to identify a specific repeater within a managed stack of repeaters. On switch systems, stacked or unstacked, this value is always one.')
hpSecCfgAddrPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 10, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: hpSecCfgAddrPortIndex.setStatus('current')
if mibBuilder.loadTexts: hpSecCfgAddrPortIndex.setDescription('This object identifies the port within the group for which this entry contains the configured authorized address. On a switch, this index corresponds to the ifIndex of the port.')
hpSecCfgAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 10, 4, 1, 3), MacAddress())
if mibBuilder.loadTexts: hpSecCfgAddress.setStatus('current')
if mibBuilder.loadTexts: hpSecCfgAddress.setDescription('A specific authorized MAC address for this port configured by a management station.')
hpSecCfgStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 10, 4, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hpSecCfgStatus.setStatus('current')
if mibBuilder.loadTexts: hpSecCfgStatus.setDescription('The row status of a hpSecureCfgAddrEntry.')
hpSecureAuthAddrTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 10, 5), )
if mibBuilder.loadTexts: hpSecureAuthAddrTable.setStatus('current')
if mibBuilder.loadTexts: hpSecureAuthAddrTable.setDescription("Table containing the authorized addresses for each port. An authorized address is an address learned while the hpSecPtLearnMode for the port is set to learnContinuous, learnFirstN, learnLimitedContinuous, or learnFirstNConditionally; or an address in the hpSecureCfgAddrTable when the hpSecPtLearnMode for the port is set to configureSpecific. On a switch, for ports whose hpSecPtLearnMode is set to learnContinuous or learnLimitedContinuous, this table may return MAC address information based on the switch's 802.1d forwarding database.")
hpSecureAuthAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 10, 5, 1), ).setIndexNames((0, "HP-ICF-GENERIC-RPTR", "hpSecAuthAddrGroupIndex"), (0, "HP-ICF-GENERIC-RPTR", "hpSecAuthAddrPortIndex"), (0, "HP-ICF-GENERIC-RPTR", "hpSecAuthAddress"))
if mibBuilder.loadTexts: hpSecureAuthAddrEntry.setStatus('current')
if mibBuilder.loadTexts: hpSecureAuthAddrEntry.setDescription("An entry in the hpSecureAuthAddrTable, containing the authorized address for a single port. Entries are stored in nonvolatile memory except when the port's hpSecPtLearnMode is set to learnContinuous or learnLimitedContinuous.")
hpSecAuthAddrGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 10, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: hpSecAuthAddrGroupIndex.setStatus('current')
if mibBuilder.loadTexts: hpSecAuthAddrGroupIndex.setDescription('This object identifies the group containing the port for which this entry contains authorized address information. On repeater systems, this can be used to identify a specific repeater within a managed stack of repeaters. On switch systems, stacked or unstacked, this value is always one.')
hpSecAuthAddrPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 10, 5, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: hpSecAuthAddrPortIndex.setStatus('current')
if mibBuilder.loadTexts: hpSecAuthAddrPortIndex.setDescription('This object identifies the port within the group for which this entry contains authorized address information. On a switch, this index corresponds to ifIndex of the port.')
hpSecAuthAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 2, 10, 5, 1, 3), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpSecAuthAddress.setStatus('current')
if mibBuilder.loadTexts: hpSecAuthAddress.setDescription("The MAC address of the station authorized to be on this port. See hpSecureAuthAddrTable for the definition of 'authorized address'.")
hpicfGRpBackupLinks = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 4, 2))
hpicfBackupLinkNextIndex = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 4, 2, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpicfBackupLinkNextIndex.setStatus('current')
if mibBuilder.loadTexts: hpicfBackupLinkNextIndex.setDescription("A currently unassigned value of hpicfBackupLinkIndex. The value 0 indicates that no unassigned values are available. In order to cause a non-zero value of this object to be assigned for use as the hpicfBackupLinkIndex of a future backup link configuration, it must be successfully modified by a set operation. When modified by a set operation, the new value must precisely match the value presently held by the object. If not, the management protocol set operation will fail. Immediately after the completion of a successful set operation, the agent must modify the value of this object. The algorithm for modifying the value is implementation-dependent, and may use a subset of values within the legal range. However, the agent must guarantee that the new value is not assigned to any in-use value of hpicfBackupLinkIndex. A management station creates a new backup link using this algorithm: - issue a management protocol retrieval operation to obtain the value of hpicfBackupLinkNextIndex; if the retrieved value is zero, a new backup link cannot be created at this time; - issue a management protocol set operation for hpicfBackupLinkNextIndex, supplying the same value as obtained in the previous step; - if the set operation succeeds, use the supplied value as the hpicfBackupLinkIndex of the new backup link; if the set operation fails, go back to the first step and obtain a new value for hpicfBackupLinkNextIndex; - issue a management protocol set operation to create an instance of the hpicfBackupLinkStatus object setting its value to 'createAndGo' or 'createAndWait' (as specified in the description of the RowStatus textual convention). Note that the set of hpicfBackupLinkNextIndex and the instance of hpicfBackupLinkStatus may occur in the same set operation if desired.")
hpicfBackupLinkTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 4, 2, 2), )
if mibBuilder.loadTexts: hpicfBackupLinkTable.setStatus('current')
if mibBuilder.loadTexts: hpicfBackupLinkTable.setDescription("A table of backup link configuration entries. For a given backup link, the agent will periodically send a test packet to the device at the specified address. If no response is received after a configured number of test packets are sent, the agent will enable the backup port and disable the primary port, and will stop sending periodic test packets. After the agent has switched to the backup link, the primary port will need to explicitly be re-enabled via management action in order to return to using the primary port. At any time, a management station can examine the associated instance of the hpicfBackupLinkState object to determine if the backup port is currently in use. The backup link algorithm enables and disables the backup port by modifying the instance of the rptrPortAdminStatus object corresponding to that port. After the backup port has been enabled by the backup link algorithm, if the primary port is subsequently enabled via management action, the backup port will be turned off and the periodic test packets will resume. When a row of this table is activated, the backup port will be disabled, the primary port will be enabled, and the periodic test packets will be sent. The time between test packets is configurable using the associated instance of the hpicfBackupLinkTestTime object. The number of failures needed to switch to the backup port is configurable using the associated instance of the hpicfBackupLinkConsecFailures object. The backup link function can be disabled by setting the relevant instance of the hpicfBackupLinkStatus object to either 'notInService' or 'destroy'. Note that the primary port for a backup link must be mapped to a repeater segment that the agent is capable of transmitting through. In addition, a given port cannot be used in more than one active backup link at the same time.")
hpicfBackupLinkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 4, 2, 2, 1), ).setIndexNames((0, "HP-ICF-GENERIC-RPTR", "hpicfBackupLinkIndex"))
if mibBuilder.loadTexts: hpicfBackupLinkEntry.setStatus('current')
if mibBuilder.loadTexts: hpicfBackupLinkEntry.setDescription('A row in the table, containing information about a single backup link.')
hpicfBackupLinkIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 4, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: hpicfBackupLinkIndex.setStatus('current')
if mibBuilder.loadTexts: hpicfBackupLinkIndex.setDescription('The value of this object uniquely identifies this backup link.')
hpicfBackupLinkPrimaryGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 4, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hpicfBackupLinkPrimaryGroup.setStatus('current')
if mibBuilder.loadTexts: hpicfBackupLinkPrimaryGroup.setDescription('The group containing the primary port for this backup link.')
hpicfBackupLinkPrimaryPort = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 4, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hpicfBackupLinkPrimaryPort.setStatus('current')
if mibBuilder.loadTexts: hpicfBackupLinkPrimaryPort.setDescription('The port number within the group of the primary port for this backup link.')
hpicfBackupLinkBackupGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 4, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hpicfBackupLinkBackupGroup.setStatus('current')
if mibBuilder.loadTexts: hpicfBackupLinkBackupGroup.setDescription('The group containing the backup port for this backup link.')
hpicfBackupLinkBackupPort = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 4, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hpicfBackupLinkBackupPort.setStatus('current')
if mibBuilder.loadTexts: hpicfBackupLinkBackupPort.setDescription('The port number within the group of the backup port for this backup link.')
hpicfBackupLinkAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 4, 2, 2, 1, 6), MacAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hpicfBackupLinkAddress.setStatus('current')
if mibBuilder.loadTexts: hpicfBackupLinkAddress.setDescription('The MAC address of the device to which periodic test packets are sent in order to determine if the primary link is operational.')
hpicfBackupLinkTestTime = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 4, 2, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15)).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hpicfBackupLinkTestTime.setStatus('current')
if mibBuilder.loadTexts: hpicfBackupLinkTestTime.setDescription('The frequency, in seconds, between sending periodic test packets. The test packet response timeout is fixed at 500ms.')
hpicfBackupLinkConsecFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 4, 2, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)).clone(2)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hpicfBackupLinkConsecFailures.setStatus('current')
if mibBuilder.loadTexts: hpicfBackupLinkConsecFailures.setDescription('The number of consecutive test packet failures which will cause the agent to switch to the backup port (i.e., backup port turned on, primary port turned off). A value of one is generally not recommended and will cause the backup link to be enabled upon the first failure.')
hpicfBackupLinkState = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 4, 2, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notActive", 1), ("usingPrimary", 2), ("usingBackup", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfBackupLinkState.setStatus('current')
if mibBuilder.loadTexts: hpicfBackupLinkState.setDescription('The current state of this backup link. One of the following values: notActive - backup link not running because this row has not yet been made active usingPrimary - backup link is running and using the primary port usingBackup - backup link test has failed; the primary port has been disabled and the backup port has been enabled')
hpicfBackupLinkFailEventIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 4, 2, 2, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hpicfBackupLinkFailEventIndex.setStatus('current')
if mibBuilder.loadTexts: hpicfBackupLinkFailEventIndex.setDescription("The index of the eventEntry in the RMON MIB that will be triggered whenever the value of hpicfBackupLinkState changes from 'usingPrimary' to 'usingBackup'. The eventEntry identified by a particular value of this index is the same as identified by the same value of the eventIndex object. If there is no corresponding entry in the eventTable, then no association exists. In particular, if this value is zero, no associated event will be generated, as zero is not a valid event index.")
hpicfBackupLinkStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 4, 2, 2, 1, 11), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hpicfBackupLinkStatus.setStatus('current')
if mibBuilder.loadTexts: hpicfBackupLinkStatus.setDescription("The status of this entry. This object may not be set to 'active' unless the corresponding instance of hpicfBackupLinkAddress has been set to a valid unicast address, the corresponding instances of hpicfBackupLinkPrimaryGroup, hpicfBackupLinkPrimaryPort, hpicfBackupLinkBackupGroup, and hpicfBackupLinkBackupPort have been configured to refer to two existing ports and that those ports are not used in any other active backup link configuration, and the primary port is mapped to a repeater segment which the agent is capable of transmitting through.")
hpGRpPortMapping = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 4, 3))
hpGRpPMSegmentTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 4, 3, 1), )
if mibBuilder.loadTexts: hpGRpPMSegmentTable.setStatus('current')
if mibBuilder.loadTexts: hpGRpPMSegmentTable.setDescription('A table for configuring segment-to-repeater mapping for repeater segments in this managed system.')
hpGRpPMSegmentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 4, 3, 1, 1), ).setIndexNames((0, "HP-ICF-GENERIC-RPTR", "hpGRpPMSegmentIndex"))
if mibBuilder.loadTexts: hpGRpPMSegmentEntry.setStatus('current')
if mibBuilder.loadTexts: hpGRpPMSegmentEntry.setDescription('An entry in the table, containing mapping information about a single repeater segment.')
hpGRpPMSegmentIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 4, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: hpGRpPMSegmentIndex.setStatus('current')
if mibBuilder.loadTexts: hpGRpPMSegmentIndex.setDescription("The value of an instance of this object uniquely identifies a physical repeater segment in this managed system. The value of an instance of this object will be equal to the instance of the Entity MIB's entPhysicalIndex for the entry in the entPhysicalTable that represents this segment.")
hpGRpPMCurrentRptrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 4, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpGRpPMCurrentRptrIndex.setStatus('current')
if mibBuilder.loadTexts: hpGRpPMCurrentRptrIndex.setDescription('The index of the repeater that this segment is currently connected to. Changing this value has the effect of moving all ports on this segment to a different repeater. The hpGRpPMSegAllowedRptrTable should be consulted to determine which repeaters this segment can be connected to.')
hpGRpPMSegAllowedRptrTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 4, 3, 2), )
if mibBuilder.loadTexts: hpGRpPMSegAllowedRptrTable.setStatus('current')
if mibBuilder.loadTexts: hpGRpPMSegAllowedRptrTable.setDescription('This table is used to inform a management application about which repeaters a physical segment is able to be connected to. There is one row in this table for each allowable segment-to-repeater connection.')
hpGRpPMSegAllowedRptrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 4, 3, 2, 1), ).setIndexNames((0, "HP-ICF-GENERIC-RPTR", "hpGRpPMSegmentIndex"), (0, "HP-ICF-GENERIC-RPTR", "hpGRpPMSegAllowedRptrIndex"))
if mibBuilder.loadTexts: hpGRpPMSegAllowedRptrEntry.setStatus('current')
if mibBuilder.loadTexts: hpGRpPMSegAllowedRptrEntry.setDescription('A row in the table, containing a single allowable segment-to-repeater connection. The presence of a row indicates that the segment identified by hpGRpPMSegmentIndex can be mapped to the repeater identified by hpGRpPMSegAllowedRptrIndex.')
hpGRpPMSegAllowedRptrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 4, 3, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpGRpPMSegAllowedRptrIndex.setStatus('current')
if mibBuilder.loadTexts: hpGRpPMSegAllowedRptrIndex.setDescription('The repeater index that identifies a repeater that this segment is able to be connected to.')
hpGRpPMPortTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 4, 3, 3), )
if mibBuilder.loadTexts: hpGRpPMPortTable.setStatus('current')
if mibBuilder.loadTexts: hpGRpPMPortTable.setDescription('A table for configuring port-to-repeater mapping for repeater ports in this managed system.')
hpGRpPMPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 4, 3, 3, 1), ).setIndexNames((0, "HP-ICF-GENERIC-RPTR", "hpGRpPMPortGroupIndex"), (0, "HP-ICF-GENERIC-RPTR", "hpGRpPMPortIndex"))
if mibBuilder.loadTexts: hpGRpPMPortEntry.setStatus('current')
if mibBuilder.loadTexts: hpGRpPMPortEntry.setDescription('An entry in the table, containing mapping information about a single repeater port.')
hpGRpPMPortGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 4, 3, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: hpGRpPMPortGroupIndex.setStatus('current')
if mibBuilder.loadTexts: hpGRpPMPortGroupIndex.setDescription('The group containing the port for which this entry contains mapping information.')
hpGRpPMPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 4, 3, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: hpGRpPMPortIndex.setStatus('current')
if mibBuilder.loadTexts: hpGRpPMPortIndex.setDescription('The port within the group for which this entry contains mapping information.')
hpGRpPMPortEntPhysicalIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 4, 3, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpGRpPMPortEntPhysicalIndex.setStatus('current')
if mibBuilder.loadTexts: hpGRpPMPortEntPhysicalIndex.setDescription("This object indicates which entry in the Entity MIB's entPhysicalTable represents this port. The entPhysicalEntry identified by this value is the same entry identified by the same value of the entPhysicalIndex object.")
hpGRpPMPortCurrentRptrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 4, 3, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpGRpPMPortCurrentRptrIndex.setStatus('current')
if mibBuilder.loadTexts: hpGRpPMPortCurrentRptrIndex.setDescription('The index of the repeater that this port is currently mapped to. Changing this value has the effect of moving this port to a different repeater. The hpGRpPMPortAllowedRptrTable should be consulted to determine which repeaters this port can be mapped to. A value of zero indicates that this port is currently not a member of any repeater.')
hpGRpPMPortAllowedRptrTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 4, 3, 4), )
if mibBuilder.loadTexts: hpGRpPMPortAllowedRptrTable.setStatus('current')
if mibBuilder.loadTexts: hpGRpPMPortAllowedRptrTable.setDescription('This table is used to inform a management application about which repeaters a logical port is able to be mapped to. There is one row in this table for each allowable port to repeater mapping.')
hpGRpPMPortAllowedRptrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 4, 3, 4, 1), ).setIndexNames((0, "HP-ICF-GENERIC-RPTR", "hpGRpPMPortGroupIndex"), (0, "HP-ICF-GENERIC-RPTR", "hpGRpPMPortIndex"), (0, "HP-ICF-GENERIC-RPTR", "hpGRpPMPortAllowedRptrIndex"))
if mibBuilder.loadTexts: hpGRpPMPortAllowedRptrEntry.setStatus('current')
if mibBuilder.loadTexts: hpGRpPMPortAllowedRptrEntry.setDescription('A row in the table, containing a single allowable port to repeater mapping. The presence of a row indicates that the port identified by hpGRpPMPortGroupIndex, hpGRpPMPortIndex can be mapped to the repeater identified by hpGRpPMPortAllowedRptrIndex.')
hpGRpPMPortAllowedRptrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 4, 3, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpGRpPMPortAllowedRptrIndex.setStatus('current')
if mibBuilder.loadTexts: hpGRpPMPortAllowedRptrIndex.setDescription('The repeater index that identifies a repeater that this port is able to be mapped to.')
hpGRpLoadBalancing = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 4, 4))
hpGRpPortMapAutoConfigEnable = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 4, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpGRpPortMapAutoConfigEnable.setStatus('current')
if mibBuilder.loadTexts: hpGRpPortMapAutoConfigEnable.setDescription("If this object has the value 'enabled', when a switch is discovered in the stack, the repeater ports will be evenly distributed across the repeater segments if they had not previously been assigned to segments (in other words, if they are in their default state). If this object has the value 'disabled', this automatic distribution of ports will not occur.")
hpGRpLoadBalanceNow = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 4, 4, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("cantUndo", 1), ("balancing", 2), ("completed", 3), ("undoLast", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpGRpLoadBalanceNow.setStatus('current')
if mibBuilder.loadTexts: hpGRpLoadBalanceNow.setDescription("Setting this object to 'balancing' will cause the agent to distribute ports in the stack across the repeater segments, attempting to balance the traffic load on each segment. When the agent has finished the load balancing, it will set the value of this object to 'completed'. Setting this object to 'undoLast' will cause the agent to return all of the ports to the segment they were on before the last load balancing. This object will have the value of 'cantUndo' if there has been no load balancing since the last agent reset or if the last load balancing has already been undone. This object can only be set to 'undoLast' when its current value is 'completed'.")
hpGRpLastLoadBalanceTime = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 4, 4, 3), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpGRpLastLoadBalanceTime.setStatus('current')
if mibBuilder.loadTexts: hpGRpLastLoadBalanceTime.setDescription("This object contains the value of sysUpTime for the last time the hpGRPLoadBalanceNow object was set to 'balancing'. If load balancing has not been performed since the last agent reset, this object will have the value 0.")
hpicfGRpSwitchConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 4, 5))
hpicfGRpSwitchTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 4, 5, 1), )
if mibBuilder.loadTexts: hpicfGRpSwitchTable.setStatus('current')
if mibBuilder.loadTexts: hpicfGRpSwitchTable.setDescription('A table of switches, both internal and external, connected to ports in this repeater system. Typically, internal switches are added by the agent and cannot be removed by a management operation. External switches may be added or removed by management operations using the hpicfGRpSwitchStatus object.')
hpicfGRpSwitchEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 4, 5, 1, 1), ).setIndexNames((0, "HP-ICF-GENERIC-RPTR", "hpicfGRpSwitchIndex"))
if mibBuilder.loadTexts: hpicfGRpSwitchEntry.setStatus('current')
if mibBuilder.loadTexts: hpicfGRpSwitchEntry.setDescription('An entry in the table, representing a single attached switch.')
hpicfGRpSwitchIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 4, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 31)))
if mibBuilder.loadTexts: hpicfGRpSwitchIndex.setStatus('current')
if mibBuilder.loadTexts: hpicfGRpSwitchIndex.setDescription('An index used to uniquely identify this switch.')
hpicfGRpSwitchType = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 4, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("internal", 1), ("external", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfGRpSwitchType.setStatus('current')
if mibBuilder.loadTexts: hpicfGRpSwitchType.setDescription("This object indicates whether this switch is an internal switch card or a switch external to the repeater system. This object will always be equal to 'external' for rows that are created using hpicfGRpSwitchStatus. For internal switches, the type of internal switch can be determined by examining the relevant instance of the entPhysicalType object.")
hpicfGRpSwitchEntPhysicalIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 4, 5, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfGRpSwitchEntPhysicalIndex.setStatus('current')
if mibBuilder.loadTexts: hpicfGRpSwitchEntPhysicalIndex.setDescription('For an internal switch, this object is the index in the entPhysicalTable for the internal switch card. For an external switch, the value of this object will be zero.')
hpicfGRpSwitchLinkCount = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 4, 5, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hpicfGRpSwitchLinkCount.setStatus('current')
if mibBuilder.loadTexts: hpicfGRpSwitchLinkCount.setDescription("The number of links from this switch's ports to repeater ports in this repeater system. For internal switches, this object cannot be modified by a network management operation. For an external switch, when this object is set, a number of rows will be added to the hpicfGRpSwitchLinkTable equal to the value of this object. The values of hpicfGRpSwitchLinkIndex will be numbered from 1 to the value of this object. An instance of this object may not be modified if the corresponding instance of the hpicfGRpSwitchStatus object would be equal to 'active' both before and after the modification attempt.")
hpicfGRpSwitchStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 4, 5, 1, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hpicfGRpSwitchStatus.setStatus('current')
if mibBuilder.loadTexts: hpicfGRpSwitchStatus.setDescription("The status of this hpicfGRpSwitchEntry. An entry may not exist in the active state unless the associated instance of the hpicfGRpSwitchLinkCount has been set to a non-zero value, and all associated instances of the hpicfGRpSwitchLinkRptrGroup and hpicfGRpSwitchLinkRptrPort objects have been set to non-zero values. If this object is set to 'destroy', all associated entries in the hpicfGRpSwitchLinkTable shall be deleted.")
hpicfGRpSwitchLinkTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 4, 5, 2), )
if mibBuilder.loadTexts: hpicfGRpSwitchLinkTable.setStatus('current')
if mibBuilder.loadTexts: hpicfGRpSwitchLinkTable.setDescription('A table of links to switch ports for both internal and external switches that are connected to repeater ports in this repeater system.')
hpicfGRpSwitchLinkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 4, 5, 2, 1), ).setIndexNames((0, "HP-ICF-GENERIC-RPTR", "hpicfGRpSwitchIndex"), (0, "HP-ICF-GENERIC-RPTR", "hpicfGRpSwitchLinkIndex"))
if mibBuilder.loadTexts: hpicfGRpSwitchLinkEntry.setStatus('current')
if mibBuilder.loadTexts: hpicfGRpSwitchLinkEntry.setDescription('An entry in the table, representing a single link to a switch port.')
hpicfGRpSwitchLinkIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 4, 5, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)))
if mibBuilder.loadTexts: hpicfGRpSwitchLinkIndex.setStatus('current')
if mibBuilder.loadTexts: hpicfGRpSwitchLinkIndex.setDescription('An identifier that uniquely identifies this switch link among all of the links associated with this switch. The values of this object are numbered consecutively from 1 to the value of the instance of the hpicfGRpSwitchLinkCount associated with this switch.')
hpicfGRpSwitchLinkRptrGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 4, 5, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpicfGRpSwitchLinkRptrGroup.setStatus('current')
if mibBuilder.loadTexts: hpicfGRpSwitchLinkRptrGroup.setDescription("The group containing the repeater port to which this switch link is attached. For internal switches, this object may not be modified by a network management operation. For external switches, an instance of this object will be created with the value of zero. It must be modified to a non-zero value corresponding to a known repeater group index before the instance of the hpicfGRpSwitchStatus object associated with this switch can be set to 'active'. An instance of this object may not be modified if the instance of the hpicfGRpSwitchStatus object associated with this switch would be equal to 'active' both before and after the modification attempt.")
hpicfGRpSwitchLinkRptrPort = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 4, 5, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpicfGRpSwitchLinkRptrPort.setStatus('current')
if mibBuilder.loadTexts: hpicfGRpSwitchLinkRptrPort.setDescription("The repeater port within the group to which this switch link is attached. For internal switches, this object may not be modified by a network management operation. For external switches, an instance of this object will be created with the value of zero. It must be modified to a non-zero value corresponding to a known repeater port index before the instance of the hpicfGRpSwitchStatus object associated with this switch can be set to 'active'. An instance of this object may not be modified if the instance of the hpicfGRpSwitchStatus object associated with this switch would be equal to 'active' both before and after the modification attempt.")
hpicfGRpSwitchLinkState = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 4, 5, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("redundant", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpicfGRpSwitchLinkState.setStatus('current')
if mibBuilder.loadTexts: hpicfGRpSwitchLinkState.setDescription("This object indicates whether this switch link is enabled ('active') or disabled ('redundant') due to one of the following: - There are more links to this switch than there are repeater segments. - The agent detected a switching loop. - The link is intended as a backup connection for other links on this switch. There can only be one active link to the switch from each repeater segment, otherwise you will have a switching loop. Therefore, if more than one switch link is connected to repeater ports on the same repeater segment, only one of them may have the value 'active'. All of the others must have the value 'redundant.")
hpicfGRpCurrentPrimarySwitch = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 4, 5, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfGRpCurrentPrimarySwitch.setStatus('current')
if mibBuilder.loadTexts: hpicfGRpCurrentPrimarySwitch.setDescription('The hpicfGRpSwitchIndex of the switch that is currently the primary switch for this stack. The automatic port-to-segment distribution feature will make decisions based on which switch is the primary switch. A value of 0 indicates that there are no internal switches in the system, and no external switches have been configured.')
hpicfGRpDesiredPrimarySwitch = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 4, 5, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpicfGRpDesiredPrimarySwitch.setStatus('current')
if mibBuilder.loadTexts: hpicfGRpDesiredPrimarySwitch.setDescription('The hpicfGRpSwitchIndex of the switch that the network administrator wants to be the primary switch for this stack. If the value of this object is zero, the agent will select the primary switch. Note that the agent may choose to use a different switch as the primary switch if it is unable to locate the switch identified by this object.')
hpicfGRpBridge = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 4, 6))
hpGRpBridgeAdminStatus = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 4, 6, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpGRpBridgeAdminStatus.setStatus('current')
if mibBuilder.loadTexts: hpGRpBridgeAdminStatus.setDescription('')
hpicfIntrusionTrap = NotificationType((1, 3, 6, 1, 4, 1, 11, 2, 14, 12, 4, 0, 1)).setObjects(("HP-ICF-GENERIC-RPTR", "hubIntruderGroup"), ("HP-ICF-GENERIC-RPTR", "hubIntruderPort"), ("HP-ICF-GENERIC-RPTR", "hubIntruderAddress"), ("HP-ICF-GENERIC-RPTR", "hubIntruderType"), ("HP-ICF-GENERIC-RPTR", "hubIntruderTrainingViolation"))
if mibBuilder.loadTexts: hpicfIntrusionTrap.setStatus('current')
if mibBuilder.loadTexts: hpicfIntrusionTrap.setDescription("The hpicfIntrusionTrap signifies that a port security violation has been detected on a port which has the hubSecPtAlarmEnable flag set to 'enabled'. or hpSecPtrIntrusionResponse set to 'SendTrap' or 'SendTrapAndDisablePort'. hubIntruderGroup identifies the group containing the port on which this intrusion occurred. hubIntruderPort identifies the port within the group on which this intrusion occurred. hubIntruderAddress contains the souce MAC address of the intruder. hubIntruderType identifies the type of violation that occured: address, training, or both. If the violation is of type 'training', the hubIntruderTrainingViolation object will indicate additional information on the type of violation.")
hpicfBackupLinkTrap = NotificationType((1, 3, 6, 1, 4, 1, 11, 2, 14, 12, 4, 0, 2)).setObjects(("HP-ICF-GENERIC-RPTR", "hpicfBackupLinkState"))
if mibBuilder.loadTexts: hpicfBackupLinkTrap.setStatus('current')
if mibBuilder.loadTexts: hpicfBackupLinkTrap.setDescription('The hpicfBackupLinkTrap signifies that the primary link for a backup link configuration has failed, and the agent has switched over to using the backup link. The instance of the hpicfBackupLinkState for the backup link configuration that experienced the primary link failure is included in the trap.')
hpicfGenRptrConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 10, 2, 8, 1))
hpicfGenRptrCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 10, 2, 8, 1, 1))
hpicfGenRptrGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 10, 2, 8, 1, 2))
hpicfHubSecurityCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 11, 2, 14, 10, 2, 8, 1, 1, 1)).setObjects(("HP-ICF-GENERIC-RPTR", "hpicfHubSecurityGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpicfHubSecurityCompliance = hpicfHubSecurityCompliance.setStatus('deprecated')
if mibBuilder.loadTexts: hpicfHubSecurityCompliance.setDescription('********* THIS COMPLIANCE IS DEPRECATED ********* The compliance statement for agents implementing per-port security in a single-repeater 802.3 repeater system.')
hpicfGenRptrBasicCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 11, 2, 14, 10, 2, 8, 1, 1, 2)).setObjects(("HP-ICF-GENERIC-RPTR", "hpicfGenRptrBasicGroup"), ("HP-ICF-GENERIC-RPTR", "hpicfGenRptrSecPtGroup"), ("HP-ICF-GENERIC-RPTR", "hpicfGenRptrSecNotifyGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpicfGenRptrBasicCompliance = hpicfGenRptrBasicCompliance.setStatus('deprecated')
if mibBuilder.loadTexts: hpicfGenRptrBasicCompliance.setDescription('********* THIS COMPLIANCE IS DEPRECATED ********* The compliance statement for agents implementing management for a single repeater.')
hpicfGenRptrSecurityCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 11, 2, 14, 10, 2, 8, 1, 1, 3)).setObjects(("HP-ICF-GENERIC-RPTR", "hpicfGenRptrSecPtGroup"), ("HP-ICF-GENERIC-RPTR", "hpicfGenRptrSecNotifyGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpicfGenRptrSecurityCompliance = hpicfGenRptrSecurityCompliance.setStatus('deprecated')
if mibBuilder.loadTexts: hpicfGenRptrSecurityCompliance.setDescription('********* THIS COMPLIANCE IS DEPRECATED ********* The compliance statement for AdvanceStack 100VG slaves implementing security.')
hpicfGenRptrCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 11, 2, 14, 10, 2, 8, 1, 1, 4)).setObjects(("HP-ICF-GENERIC-RPTR", "hpicfGenRptrBasicGroup"), ("HP-ICF-GENERIC-RPTR", "hpicfGenRptrInfoGroup"), ("HP-ICF-GENERIC-RPTR", "hpicfGenRptrSecPtGroup"), ("HP-ICF-GENERIC-RPTR", "hpicfGenRptrSecNotifyGroup"), ("HP-ICF-GENERIC-RPTR", "hpicfGenRptrBkpLinkGroup"), ("HP-ICF-GENERIC-RPTR", "hpicfGenRptrBkpLinkNotifyGroup"), ("HP-ICF-GENERIC-RPTR", "hpicfGenRptrPortMappingGroup"), ("HP-ICF-GENERIC-RPTR", "hpicfGenRptrLoadBalanceGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpicfGenRptrCompliance = hpicfGenRptrCompliance.setStatus('deprecated')
if mibBuilder.loadTexts: hpicfGenRptrCompliance.setDescription('********* THIS COMPLIANCE IS DEPRECATED ********* The compliance statement for HP managed repeater systems.')
hpicfGenRptrCompliance2 = ModuleCompliance((1, 3, 6, 1, 4, 1, 11, 2, 14, 10, 2, 8, 1, 1, 5)).setObjects(("HP-ICF-GENERIC-RPTR", "hpicfGenRptrBasicGroup"), ("HP-ICF-GENERIC-RPTR", "hpicfGenRptrInfoGroup"), ("HP-ICF-GENERIC-RPTR", "hpicfGenRptrSecPtGroup"), ("HP-ICF-GENERIC-RPTR", "hpicfGenRptrSecNotifyGroup"), ("HP-ICF-GENERIC-RPTR", "hpicfGenRptrBkpLinkGroup"), ("HP-ICF-GENERIC-RPTR", "hpicfGenRptrBkpLinkNotifyGroup"), ("HP-ICF-GENERIC-RPTR", "hpicfGenRptrPortMappingGroup"), ("HP-ICF-GENERIC-RPTR", "hpicfGenRptrLoadBalanceGroup"), ("HP-ICF-GENERIC-RPTR", "hpicfGenRptrSwitchConfigGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpicfGenRptrCompliance2 = hpicfGenRptrCompliance2.setStatus('current')
if mibBuilder.loadTexts: hpicfGenRptrCompliance2.setDescription('The compliance statement for HP managed repeater systems.')
hpicfGenRptrCompliance3 = ModuleCompliance((1, 3, 6, 1, 4, 1, 11, 2, 14, 10, 2, 8, 1, 1, 6)).setObjects(("HP-ICF-GENERIC-RPTR", "hpicfGenRptrBasicGroup"), ("HP-ICF-GENERIC-RPTR", "hpicfGenRptrInfoGroup"), ("HP-ICF-GENERIC-RPTR", "hpicfGenRptrSecPtGroup"), ("HP-ICF-GENERIC-RPTR", "hpicfSecPtGroup"), ("HP-ICF-GENERIC-RPTR", "hpicfGenRptrSecNotifyGroup"), ("HP-ICF-GENERIC-RPTR", "hpicfGenRptrBkpLinkGroup"), ("HP-ICF-GENERIC-RPTR", "hpicfGenRptrBkpLinkNotifyGroup"), ("HP-ICF-GENERIC-RPTR", "hpicfGenRptrPortMappingGroup"), ("HP-ICF-GENERIC-RPTR", "hpicfGenRptrLoadBalanceGroup"), ("HP-ICF-GENERIC-RPTR", "hpicfGenRptrSwitchConfigGroup"), ("HP-ICF-GENERIC-RPTR", "hpicfGenRptrBridgeGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpicfGenRptrCompliance3 = hpicfGenRptrCompliance3.setStatus('current')
if mibBuilder.loadTexts: hpicfGenRptrCompliance3.setDescription('The compliance statement for HP managed repeater systems.')
hpicfGenRptrMultiSecOnlyCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 11, 2, 14, 10, 2, 8, 1, 1, 7)).setObjects(("HP-ICF-GENERIC-RPTR", "hpicfSecPtGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpicfGenRptrMultiSecOnlyCompliance = hpicfGenRptrMultiSecOnlyCompliance.setStatus('deprecated')
if mibBuilder.loadTexts: hpicfGenRptrMultiSecOnlyCompliance.setDescription('********* THIS COMPLIANCE IS DEPRECATED ********* The compliance statement for non-repeater devices that implement per-port security with multiple authorized address per port.')
hpicfGenRptrMultiSecOnlyCompliance2 = ModuleCompliance((1, 3, 6, 1, 4, 1, 11, 2, 14, 10, 2, 8, 1, 1, 8)).setObjects(("HP-ICF-GENERIC-RPTR", "hpicfSecPtGroup2"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpicfGenRptrMultiSecOnlyCompliance2 = hpicfGenRptrMultiSecOnlyCompliance2.setStatus('deprecated')
if mibBuilder.loadTexts: hpicfGenRptrMultiSecOnlyCompliance2.setDescription('********* THIS COMPLIANCE IS DEPRECATED ********* The updated compliance statement for non-repeater devices that implement per-port security with multiple authorized address per port.')
hpicfGenRptrMultiSecOnlyCompliance3 = ModuleCompliance((1, 3, 6, 1, 4, 1, 11, 2, 14, 10, 2, 8, 1, 1, 9)).setObjects(("HP-ICF-GENERIC-RPTR", "hpicfSecPtGroup3"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpicfGenRptrMultiSecOnlyCompliance3 = hpicfGenRptrMultiSecOnlyCompliance3.setStatus('current')
if mibBuilder.loadTexts: hpicfGenRptrMultiSecOnlyCompliance3.setDescription('The updated compliance statement for non-repeater devices that implement per-port security with multiple authorized address per port.')
hpicfHubSecurityGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 11, 2, 14, 10, 2, 8, 1, 2, 1)).setObjects(("HP-ICF-GENERIC-RPTR", "hubSecPtGroupIndex"), ("HP-ICF-GENERIC-RPTR", "hubSecPtPortIndex"), ("HP-ICF-GENERIC-RPTR", "hubSecPtSecurityAddress"), ("HP-ICF-GENERIC-RPTR", "hubSecPtAuthorizedAddress"), ("HP-ICF-GENERIC-RPTR", "hubSecPtPreventEavesdrop"), ("HP-ICF-GENERIC-RPTR", "hubSecPtAlarmEnable"), ("HP-ICF-GENERIC-RPTR", "hubSecPtIntrusionFlag"), ("HP-ICF-GENERIC-RPTR", "hubIntruderIndex"), ("HP-ICF-GENERIC-RPTR", "hubIntruderGroup"), ("HP-ICF-GENERIC-RPTR", "hubIntruderPort"), ("HP-ICF-GENERIC-RPTR", "hubIntruderAddress"), ("HP-ICF-GENERIC-RPTR", "hubIntruderTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpicfHubSecurityGroup = hpicfHubSecurityGroup.setStatus('deprecated')
if mibBuilder.loadTexts: hpicfHubSecurityGroup.setDescription('********* THIS GROUP IS DEPRECATED ********* A collection of objects for managing per-port security violations for a managed 802.3 repeater system.')
hpicfGenRptrBasicGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 11, 2, 14, 10, 2, 8, 1, 2, 2)).setObjects(("HP-ICF-GENERIC-RPTR", "hpGRpSelfHealEnable"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpicfGenRptrBasicGroup = hpicfGenRptrBasicGroup.setStatus('current')
if mibBuilder.loadTexts: hpicfGenRptrBasicGroup.setDescription('A collection of objects for basic configuration of a system containing repeaters.')
hpicfGenRptrSecPtGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 11, 2, 14, 10, 2, 8, 1, 2, 3)).setObjects(("HP-ICF-GENERIC-RPTR", "hubSecPtGroupIndex"), ("HP-ICF-GENERIC-RPTR", "hubSecPtPortIndex"), ("HP-ICF-GENERIC-RPTR", "hubSecPtSecurityAddress"), ("HP-ICF-GENERIC-RPTR", "hubSecPtAuthorizedAddress"), ("HP-ICF-GENERIC-RPTR", "hubSecPtPreventEavesdrop"), ("HP-ICF-GENERIC-RPTR", "hubSecPtAlarmEnable"), ("HP-ICF-GENERIC-RPTR", "hubSecPtIntrusionFlag"), ("HP-ICF-GENERIC-RPTR", "hubIntruderIndex"), ("HP-ICF-GENERIC-RPTR", "hubIntruderGroup"), ("HP-ICF-GENERIC-RPTR", "hubIntruderPort"), ("HP-ICF-GENERIC-RPTR", "hubIntruderAddress"), ("HP-ICF-GENERIC-RPTR", "hubIntruderTime"), ("HP-ICF-GENERIC-RPTR", "hubIntruderType"), ("HP-ICF-GENERIC-RPTR", "hubIntruderTrainingViolation"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpicfGenRptrSecPtGroup = hpicfGenRptrSecPtGroup.setStatus('current')
if mibBuilder.loadTexts: hpicfGenRptrSecPtGroup.setDescription('A collection of objects for managing per-port security in a managed repeater system.')
hpicfGenRptrInfoGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 11, 2, 14, 10, 2, 8, 1, 2, 4)).setObjects(("HP-ICF-GENERIC-RPTR", "hpGRpRepeaterIfIndex"), ("HP-ICF-GENERIC-RPTR", "hpGRpRepeaterName"), ("HP-ICF-GENERIC-RPTR", "hpGRpRepeaterVlanIndex"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpicfGenRptrInfoGroup = hpicfGenRptrInfoGroup.setStatus('current')
if mibBuilder.loadTexts: hpicfGenRptrInfoGroup.setDescription('A collection of objects providing information about logical repeaters in a system.')
hpicfGenRptrBkpLinkGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 11, 2, 14, 10, 2, 8, 1, 2, 5)).setObjects(("HP-ICF-GENERIC-RPTR", "hpicfBackupLinkNextIndex"), ("HP-ICF-GENERIC-RPTR", "hpicfBackupLinkPrimaryGroup"), ("HP-ICF-GENERIC-RPTR", "hpicfBackupLinkPrimaryPort"), ("HP-ICF-GENERIC-RPTR", "hpicfBackupLinkBackupGroup"), ("HP-ICF-GENERIC-RPTR", "hpicfBackupLinkBackupPort"), ("HP-ICF-GENERIC-RPTR", "hpicfBackupLinkAddress"), ("HP-ICF-GENERIC-RPTR", "hpicfBackupLinkTestTime"), ("HP-ICF-GENERIC-RPTR", "hpicfBackupLinkConsecFailures"), ("HP-ICF-GENERIC-RPTR", "hpicfBackupLinkState"), ("HP-ICF-GENERIC-RPTR", "hpicfBackupLinkFailEventIndex"), ("HP-ICF-GENERIC-RPTR", "hpicfBackupLinkStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpicfGenRptrBkpLinkGroup = hpicfGenRptrBkpLinkGroup.setStatus('current')
if mibBuilder.loadTexts: hpicfGenRptrBkpLinkGroup.setDescription('A collection of objects for configuring backup links in a managed repeater system.')
hpicfGenRptrPortMappingGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 11, 2, 14, 10, 2, 8, 1, 2, 6)).setObjects(("HP-ICF-GENERIC-RPTR", "hpGRpPMCurrentRptrIndex"), ("HP-ICF-GENERIC-RPTR", "hpGRpPMSegAllowedRptrIndex"), ("HP-ICF-GENERIC-RPTR", "hpGRpPMPortEntPhysicalIndex"), ("HP-ICF-GENERIC-RPTR", "hpGRpPMPortCurrentRptrIndex"), ("HP-ICF-GENERIC-RPTR", "hpGRpPMPortAllowedRptrIndex"), ("HP-ICF-GENERIC-RPTR", "hpGRpPortMapAutoConfigEnable"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpicfGenRptrPortMappingGroup = hpicfGenRptrPortMappingGroup.setStatus('current')
if mibBuilder.loadTexts: hpicfGenRptrPortMappingGroup.setDescription('A collection of objects for mapping repeater segments and repeater ports to logical repeaters.')
hpicfGenRptrLoadBalanceGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 11, 2, 14, 10, 2, 8, 1, 2, 7)).setObjects(("HP-ICF-GENERIC-RPTR", "hpGRpLoadBalanceNow"), ("HP-ICF-GENERIC-RPTR", "hpGRpLastLoadBalanceTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpicfGenRptrLoadBalanceGroup = hpicfGenRptrLoadBalanceGroup.setStatus('current')
if mibBuilder.loadTexts: hpicfGenRptrLoadBalanceGroup.setDescription('A collection of objects for managing segment load balancing on multisegment repeaters with internal switches.')
hpicfGenRptrSwitchConfigGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 11, 2, 14, 10, 2, 8, 1, 2, 8)).setObjects(("HP-ICF-GENERIC-RPTR", "hpicfGRpSwitchType"), ("HP-ICF-GENERIC-RPTR", "hpicfGRpSwitchEntPhysicalIndex"), ("HP-ICF-GENERIC-RPTR", "hpicfGRpSwitchLinkCount"), ("HP-ICF-GENERIC-RPTR", "hpicfGRpSwitchStatus"), ("HP-ICF-GENERIC-RPTR", "hpicfGRpSwitchLinkRptrGroup"), ("HP-ICF-GENERIC-RPTR", "hpicfGRpSwitchLinkRptrPort"), ("HP-ICF-GENERIC-RPTR", "hpicfGRpSwitchLinkState"), ("HP-ICF-GENERIC-RPTR", "hpicfGRpCurrentPrimarySwitch"), ("HP-ICF-GENERIC-RPTR", "hpicfGRpDesiredPrimarySwitch"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpicfGenRptrSwitchConfigGroup = hpicfGenRptrSwitchConfigGroup.setStatus('current')
if mibBuilder.loadTexts: hpicfGenRptrSwitchConfigGroup.setDescription('A collection of Objects for configuring internal and external switches for switching between repeater segments in a repeater system.')
hpicfGenRptrSecNotifyGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 11, 2, 14, 10, 2, 8, 1, 2, 9)).setObjects(("HP-ICF-GENERIC-RPTR", "hpicfIntrusionTrap"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpicfGenRptrSecNotifyGroup = hpicfGenRptrSecNotifyGroup.setStatus('current')
if mibBuilder.loadTexts: hpicfGenRptrSecNotifyGroup.setDescription('A collection of notifications used to indicate per-port security violations.')
hpicfGenRptrBkpLinkNotifyGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 11, 2, 14, 10, 2, 8, 1, 2, 10)).setObjects(("HP-ICF-GENERIC-RPTR", "hpicfBackupLinkTrap"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpicfGenRptrBkpLinkNotifyGroup = hpicfGenRptrBkpLinkNotifyGroup.setStatus('current')
if mibBuilder.loadTexts: hpicfGenRptrBkpLinkNotifyGroup.setDescription('A collection of notifications used to indicate state changes on a backup link.')
hpicfSecPtGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 11, 2, 14, 10, 2, 8, 1, 2, 11)).setObjects(("HP-ICF-GENERIC-RPTR", "hpSecPtAddressLimit"), ("HP-ICF-GENERIC-RPTR", "hpSecPtLearnMode"), ("HP-ICF-GENERIC-RPTR", "hpSecPtPreventEavesdrop"), ("HP-ICF-GENERIC-RPTR", "hpSecPtAlarmEnable"), ("HP-ICF-GENERIC-RPTR", "hpSecPtIntrusionFlag"), ("HP-ICF-GENERIC-RPTR", "hpSecCfgStatus"), ("HP-ICF-GENERIC-RPTR", "hpSecAuthAddress"), ("HP-ICF-GENERIC-RPTR", "hubIntruderIndex"), ("HP-ICF-GENERIC-RPTR", "hubIntruderGroup"), ("HP-ICF-GENERIC-RPTR", "hubIntruderPort"), ("HP-ICF-GENERIC-RPTR", "hubIntruderAddress"), ("HP-ICF-GENERIC-RPTR", "hubIntruderTime"), ("HP-ICF-GENERIC-RPTR", "hubIntruderType"), ("HP-ICF-GENERIC-RPTR", "hubIntruderTrainingViolation"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpicfSecPtGroup = hpicfSecPtGroup.setStatus('deprecated')
if mibBuilder.loadTexts: hpicfSecPtGroup.setDescription('********* THIS GROUP IS DEPRECATED ********* A collection of objects for managing per-port security in a managed repeater or switch system.')
hpicfGenRptrBridgeGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 11, 2, 14, 10, 2, 8, 1, 2, 12)).setObjects(("HP-ICF-GENERIC-RPTR", "hpGRpBridgeAdminStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpicfGenRptrBridgeGroup = hpicfGenRptrBridgeGroup.setStatus('current')
if mibBuilder.loadTexts: hpicfGenRptrBridgeGroup.setDescription('A collection of objects for basic configuration of repeater system containing internal bridging.')
hpicfSecPtGroup2 = ObjectGroup((1, 3, 6, 1, 4, 1, 11, 2, 14, 10, 2, 8, 1, 2, 13)).setObjects(("HP-ICF-GENERIC-RPTR", "hpSecPtAddressLimit"), ("HP-ICF-GENERIC-RPTR", "hpSecPtLearnMode"), ("HP-ICF-GENERIC-RPTR", "hpSecPtAlarmEnable"), ("HP-ICF-GENERIC-RPTR", "hpSecPtIntrusionFlag"), ("HP-ICF-GENERIC-RPTR", "hpSecCfgStatus"), ("HP-ICF-GENERIC-RPTR", "hpSecAuthAddress"), ("HP-ICF-GENERIC-RPTR", "hubIntruderIndex"), ("HP-ICF-GENERIC-RPTR", "hubIntruderGroup"), ("HP-ICF-GENERIC-RPTR", "hubIntruderPort"), ("HP-ICF-GENERIC-RPTR", "hubIntruderAddress"), ("HP-ICF-GENERIC-RPTR", "hubIntruderTime"), ("HP-ICF-GENERIC-RPTR", "hubIntruderType"), ("HP-ICF-GENERIC-RPTR", "hubIntruderTrainingViolation"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpicfSecPtGroup2 = hpicfSecPtGroup2.setStatus('deprecated')
if mibBuilder.loadTexts: hpicfSecPtGroup2.setDescription('********* THIS GROUP IS DEPRECATED ********* A collection of objects for managing per-port security in a managed repeater or switch system.')
hpicfSecPtGroup3 = ObjectGroup((1, 3, 6, 1, 4, 1, 11, 2, 14, 10, 2, 8, 1, 2, 14)).setObjects(("HP-ICF-GENERIC-RPTR", "hpSecPtAddressLimit"), ("HP-ICF-GENERIC-RPTR", "hpSecPtLearnMode"), ("HP-ICF-GENERIC-RPTR", "hpSecPtAlarmEnable"), ("HP-ICF-GENERIC-RPTR", "hpSecPtIntrusionFlag"), ("HP-ICF-GENERIC-RPTR", "hpSecCfgStatus"), ("HP-ICF-GENERIC-RPTR", "hpSecAuthAddress"), ("HP-ICF-GENERIC-RPTR", "hubIntruderIndex"), ("HP-ICF-GENERIC-RPTR", "hubIntruderGroup"), ("HP-ICF-GENERIC-RPTR", "hubIntruderPort"), ("HP-ICF-GENERIC-RPTR", "hubIntruderAddress"), ("HP-ICF-GENERIC-RPTR", "hubIntruderTime"), ("HP-ICF-GENERIC-RPTR", "hubIntruderType"), ("HP-ICF-GENERIC-RPTR", "hubIntruderTrainingViolation"), ("HP-ICF-GENERIC-RPTR", "hpSecPtAddressLimit2"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpicfSecPtGroup3 = hpicfSecPtGroup3.setStatus('current')
if mibBuilder.loadTexts: hpicfSecPtGroup3.setDescription('A collection of objects for managing per-port security in a managed repeater or switch system.')
mibBuilder.exportSymbols("HP-ICF-GENERIC-RPTR", hpSecPtAddressLimit2=hpSecPtAddressLimit2, hpicfBackupLinkTestTime=hpicfBackupLinkTestTime, hpicfIntrusionTrap=hpicfIntrusionTrap, hpicfBackupLinkFailEventIndex=hpicfBackupLinkFailEventIndex, hubSecurity=hubSecurity, hpicfGRpBackupLinks=hpicfGRpBackupLinks, hpGRpPMSegAllowedRptrIndex=hpGRpPMSegAllowedRptrIndex, hubIntruderLogEntry=hubIntruderLogEntry, hpSecCfgStatus=hpSecCfgStatus, hpSecurePortEntry=hpSecurePortEntry, hpicfGenRptrCompliance=hpicfGenRptrCompliance, hpSecureAuthAddrEntry=hpSecureAuthAddrEntry, hpGRpBasicGlobal=hpGRpBasicGlobal, hpicfGenRptrGroups=hpicfGenRptrGroups, hpGRpPMPortTable=hpGRpPMPortTable, hpicfSecPtGroup3=hpicfSecPtGroup3, hpicfGRpCurrentPrimarySwitch=hpicfGRpCurrentPrimarySwitch, hpSecureCfgAddrTable=hpSecureCfgAddrTable, hubIntruderTrainingViolation=hubIntruderTrainingViolation, hpGRpSelfHealEnable=hpGRpSelfHealEnable, hubSecPtPortIndex=hubSecPtPortIndex, hpGRpPMSegmentIndex=hpGRpPMSegmentIndex, hpGRpPMSegAllowedRptrEntry=hpGRpPMSegAllowedRptrEntry, hpSecurePortTable=hpSecurePortTable, hpicfGRpSwitchIndex=hpicfGRpSwitchIndex, hpGRpPMPortEntPhysicalIndex=hpGRpPMPortEntPhysicalIndex, hpicfGRpDesiredPrimarySwitch=hpicfGRpDesiredPrimarySwitch, hpSecAuthAddrGroupIndex=hpSecAuthAddrGroupIndex, hpGRpPMPortGroupIndex=hpGRpPMPortGroupIndex, hubSecurePortTable=hubSecurePortTable, hubIntruderIndex=hubIntruderIndex, hpicfGenRptrMultiSecOnlyCompliance=hpicfGenRptrMultiSecOnlyCompliance, hpGRpPMSegmentTable=hpGRpPMSegmentTable, hpSecPtAddressLimit=hpSecPtAddressLimit, hpicfBackupLinkConsecFailures=hpicfBackupLinkConsecFailures, hpGRpPortMapping=hpGRpPortMapping, hpSecCfgAddress=hpSecCfgAddress, hpGRpBridgeAdminStatus=hpGRpBridgeAdminStatus, hpSecPtAlarmEnable=hpSecPtAlarmEnable, hpicfBackupLinkNextIndex=hpicfBackupLinkNextIndex, hpicfGRpSwitchLinkRptrGroup=hpicfGRpSwitchLinkRptrGroup, hpicfGRpSwitchLinkRptrPort=hpicfGRpSwitchLinkRptrPort, hpGRpBasic=hpGRpBasic, hpGRpRepeaterIndex=hpGRpRepeaterIndex, hpicfBackupLinkPrimaryGroup=hpicfBackupLinkPrimaryGroup, hpicfGRpSwitchEntPhysicalIndex=hpicfGRpSwitchEntPhysicalIndex, hpicfBackupLinkTable=hpicfBackupLinkTable, hpGRpRepeaterIfIndex=hpGRpRepeaterIfIndex, hpicfGenRptrSecurityCompliance=hpicfGenRptrSecurityCompliance, hpGRpRepeaterEntry=hpGRpRepeaterEntry, hpicfGenRptrBkpLinkNotifyGroup=hpicfGenRptrBkpLinkNotifyGroup, hubSecPtAlarmEnable=hubSecPtAlarmEnable, hubIntruderAddress=hubIntruderAddress, hpSecPtPortIndex=hpSecPtPortIndex, hpGRpPMCurrentRptrIndex=hpGRpPMCurrentRptrIndex, hpGRpPMPortCurrentRptrIndex=hpGRpPMPortCurrentRptrIndex, hpicfSecPtGroup2=hpicfSecPtGroup2, hpicfGenRptrBasicCompliance=hpicfGenRptrBasicCompliance, hpicfGenRptrSecNotifyGroup=hpicfGenRptrSecNotifyGroup, hubIntruderLogTable=hubIntruderLogTable, hubIntruderPort=hubIntruderPort, hubIntruderType=hubIntruderType, hpicfBackupLinkAddress=hpicfBackupLinkAddress, hpicfGRpSwitchLinkIndex=hpicfGRpSwitchLinkIndex, hpicfGenRptrLoadBalanceGroup=hpicfGenRptrLoadBalanceGroup, hpicfBackupLinkIndex=hpicfBackupLinkIndex, hubSecPtGroupIndex=hubSecPtGroupIndex, hpSecPtPreventEavesdrop=hpSecPtPreventEavesdrop, hpicfBackupLinkBackupGroup=hpicfBackupLinkBackupGroup, hpSecAuthAddrPortIndex=hpSecAuthAddrPortIndex, hpicfBackupLinkStatus=hpicfBackupLinkStatus, hpicfGRpSwitchLinkEntry=hpicfGRpSwitchLinkEntry, hpicfBackupLinkPrimaryPort=hpicfBackupLinkPrimaryPort, hpicfGenRptrSwitchConfigGroup=hpicfGenRptrSwitchConfigGroup, hubSecPtSecurityAddress=hubSecPtSecurityAddress, hpSecPtLearnMode=hpSecPtLearnMode, hubIntruderTime=hubIntruderTime, hpicfGRpSwitchEntry=hpicfGRpSwitchEntry, hpicfGRpSwitchStatus=hpicfGRpSwitchStatus, hpicfHubSecurityGroup=hpicfHubSecurityGroup, hubSecurePortEntry=hubSecurePortEntry, hpicfBackupLinkEntry=hpicfBackupLinkEntry, hpGRpLoadBalancing=hpGRpLoadBalancing, hpSecCfgAddrGroupIndex=hpSecCfgAddrGroupIndex, hpicfGRpSwitchTable=hpicfGRpSwitchTable, hpicfBackupLinkState=hpicfBackupLinkState, hpicfSecPtGroup=hpicfSecPtGroup, hpicfGRpSwitchLinkCount=hpicfGRpSwitchLinkCount, hubSecPtAuthorizedAddress=hubSecPtAuthorizedAddress, hpGRpLoadBalanceNow=hpGRpLoadBalanceNow, hpGRpPortMapAutoConfigEnable=hpGRpPortMapAutoConfigEnable, hpicfGRpBridge=hpicfGRpBridge, hpSecureCfgAddrEntry=hpSecureCfgAddrEntry, hpicfGenRptrInfoGroup=hpicfGenRptrInfoGroup, hpicfGenRptrBridgeGroup=hpicfGenRptrBridgeGroup, hpicfGenRptrMultiSecOnlyCompliance2=hpicfGenRptrMultiSecOnlyCompliance2, hpicfGenRptrCompliance2=hpicfGenRptrCompliance2, hpicfGenRptrMultiSecOnlyCompliance3=hpicfGenRptrMultiSecOnlyCompliance3, hpicfGenRptrSecPtGroup=hpicfGenRptrSecPtGroup, hpicfBackupLinkTrap=hpicfBackupLinkTrap, hpGRpPMPortEntry=hpGRpPMPortEntry, hpGRpPMPortAllowedRptrEntry=hpGRpPMPortAllowedRptrEntry, hpGRpRepeaterTable=hpGRpRepeaterTable, hpGRpPMSegmentEntry=hpGRpPMSegmentEntry, hpicfGenRptrConformance=hpicfGenRptrConformance, hpicfGenRptrPortMappingGroup=hpicfGenRptrPortMappingGroup, hpSecPtIntrusionFlag=hpSecPtIntrusionFlag, hpicfGRpSwitchLinkTable=hpicfGRpSwitchLinkTable, hpGRpPMPortIndex=hpGRpPMPortIndex, hpGRpPMPortAllowedRptrTable=hpGRpPMPortAllowedRptrTable, hubSecPtIntrusionFlag=hubSecPtIntrusionFlag, hpSecPtGroupIndex=hpSecPtGroupIndex, hpicfHubSecurityCompliance=hpicfHubSecurityCompliance, hubIntruderGroup=hubIntruderGroup, hpicfGenRptrCompliance3=hpicfGenRptrCompliance3, hpGRpRepeaterName=hpGRpRepeaterName, hpGRpPMPortAllowedRptrIndex=hpGRpPMPortAllowedRptrIndex, hpGRpRepeaterVlanIndex=hpGRpRepeaterVlanIndex, hpicfGenRptrMib=hpicfGenRptrMib, hubSecPtPreventEavesdrop=hubSecPtPreventEavesdrop, hpGRpLastLoadBalanceTime=hpGRpLastLoadBalanceTime, hpSecCfgAddrPortIndex=hpSecCfgAddrPortIndex, hpicfGRpSwitchType=hpicfGRpSwitchType, hpicfGRpSwitchConfig=hpicfGRpSwitchConfig, hpSecAuthAddress=hpSecAuthAddress, hpicfGenRptrBkpLinkGroup=hpicfGenRptrBkpLinkGroup, hpicfGenRptrCompliances=hpicfGenRptrCompliances, PYSNMP_MODULE_ID=hpicfGenRptrMib, hpicfBackupLinkBackupPort=hpicfBackupLinkBackupPort, hpicfGRpSwitchLinkState=hpicfGRpSwitchLinkState, hpGRpPMSegAllowedRptrTable=hpGRpPMSegAllowedRptrTable, hpicfGenRptrBasicGroup=hpicfGenRptrBasicGroup, hpSecureAuthAddrTable=hpSecureAuthAddrTable)

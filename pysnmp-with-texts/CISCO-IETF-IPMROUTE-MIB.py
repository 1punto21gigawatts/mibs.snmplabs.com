#
# PySNMP MIB module CISCO-IETF-IPMROUTE-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-IETF-IPMROUTE-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:00:23 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ConstraintsUnion, ValueRangeConstraint, SingleValueConstraint, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "ValueRangeConstraint", "SingleValueConstraint", "ValueSizeConstraint")
ciscoExperiment, = mibBuilder.importSymbols("CISCO-SMI", "ciscoExperiment")
IANAipRouteProtocol, IANAipMRouteProtocol = mibBuilder.importSymbols("IANA-RTPROTO-MIB", "IANAipRouteProtocol", "IANAipMRouteProtocol")
InterfaceIndexOrZero, InterfaceIndex = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero", "InterfaceIndex")
InetAddressPrefixLength, InetVersion, InetAddressType, InetAddress = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressPrefixLength", "InetVersion", "InetAddressType", "InetAddress")
LanguageTag, = mibBuilder.importSymbols("IPMROUTE-STD-MIB", "LanguageTag")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ModuleCompliance, NotificationGroup, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup", "ObjectGroup")
Counter32, Gauge32, Counter64, NotificationType, Unsigned32, ModuleIdentity, IpAddress, iso, Integer32, MibScalar, MibTable, MibTableRow, MibTableColumn, ObjectIdentity, MibIdentifier, TimeTicks, Bits = mibBuilder.importSymbols("SNMPv2-SMI", "Counter32", "Gauge32", "Counter64", "NotificationType", "Unsigned32", "ModuleIdentity", "IpAddress", "iso", "Integer32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ObjectIdentity", "MibIdentifier", "TimeTicks", "Bits")
RowStatus, TextualConvention, TruthValue, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "RowStatus", "TextualConvention", "TruthValue", "DisplayString")
ciscoIetfIpMRouteMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 10, 117))
ciscoIetfIpMRouteMIB.setRevisions(('2006-08-24 00:00', '2004-12-02 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ciscoIetfIpMRouteMIB.setRevisionsDescriptions(('Added cIpMRouteInterfaceHCInMPkts, cIpMRouteInterfaceHCOutMPkts, cIpMRouteMIBHCInterfaceGroupSup1, and cIpMRouteMIBComplianceRev1.', 'Initial version of this MIB module',))
if mibBuilder.loadTexts: ciscoIetfIpMRouteMIB.setLastUpdated('200608240000Z')
if mibBuilder.loadTexts: ciscoIetfIpMRouteMIB.setOrganization('Cisco Systems, Inc.')
if mibBuilder.loadTexts: ciscoIetfIpMRouteMIB.setContactInfo('Cisco Systems Customer Service Postal: 170 W Tasman Drive San Jose, CA 95134 Tel: +1 800 553-NETS E-mail: cs-ipmulticast@cisco.com ')
if mibBuilder.loadTexts: ciscoIetfIpMRouteMIB.setDescription('Address family independent MIB module for management IP Multicast routing, but independent of the specific multicast routing protocol in use. This MIB module is based on RFC 2932 with additional MIB objects to make it a address family independent MIB. This Cisco MIB was created due to non availability of RFC or an Internet Draft which can provide address family independent MIB for IP Multicast Routing. This MIB may later be deprecated with a stable RFC or an Internet Draft This MIB module contains two scalars and five tables. The tables are: (1) The IP Multicast Route Table containing multicast routing information for IP datagrams sent by particular sources to the IP multicast groups known to a router. (2) The IP Multicast Routing Next Hop Table containing information on the next-hops for the routing IP multicast datagrams. Each entry is one of a list of next-hops on outgoing interfaces for particular sources sending to a particular multicast group address. (3) The IP Multicast Routing Interface Table containing multicast routing information specific to interfaces. (4) The IP Multicast Scope Boundary Table containing the boundaries configured for multicast scopes. (5) The IP Multicast Scope Name Table containing human-readable names of multicast scope. ')
cIpMRouteMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 117, 1))
cIpMRoute = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 117, 1, 1))
cIpMRouteEnable = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 117, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cIpMRouteEnable.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteEnable.setDescription('The enabled status of IP Multicast routing on this router.')
cIpMRouteEntryCount = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 117, 1, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cIpMRouteEntryCount.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteEntryCount.setDescription('The number of rows in the cIpMRouteTable. This can be used to monitor the multicast routing table size.')
cIpMRouteTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 117, 1, 1, 2), )
if mibBuilder.loadTexts: cIpMRouteTable.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteTable.setDescription('The (conceptual) table containing multicast routing information for IP datagrams sent by particular sources to the IP multicast groups known to this router.')
cIpMRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 117, 1, 1, 2, 1), ).setIndexNames((0, "CISCO-IETF-IPMROUTE-MIB", "cIpMRouteAddrType"), (0, "CISCO-IETF-IPMROUTE-MIB", "cIpMRouteGroup"), (0, "CISCO-IETF-IPMROUTE-MIB", "cIpMRouteSource"), (0, "CISCO-IETF-IPMROUTE-MIB", "cIpMRouteSourceMask"))
if mibBuilder.loadTexts: cIpMRouteEntry.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteEntry.setDescription('An entry (conceptual row) containing the multicast routing information for IP datagrams from a particular source and addressed to a particular IP multicast group address. Discontinuities in counters in this entry can be detected by observing the value of cIpMRouteUpTime.')
cIpMRouteAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 117, 1, 1, 2, 1, 1), InetAddressType())
if mibBuilder.loadTexts: cIpMRouteAddrType.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteAddrType.setDescription('The type of InetAddress for the IP multicast group address for which this entry contains multicast routing information.')
cIpMRouteGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 117, 1, 1, 2, 1, 2), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(4, 4), ValueSizeConstraint(16, 16), ValueSizeConstraint(20, 20), )))
if mibBuilder.loadTexts: cIpMRouteGroup.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteGroup.setDescription('The IP multicast group address for which this entry contains multicast routing information.')
cIpMRouteSource = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 117, 1, 1, 2, 1, 3), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(4, 4), ValueSizeConstraint(16, 16), ValueSizeConstraint(20, 20), )))
if mibBuilder.loadTexts: cIpMRouteSource.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteSource.setDescription('The network address which when combined with the corresponding value of cIpMRouteSourceMask identifies the sources for which this entry contains multicast routing information. The address of 0:: indicates shared-tree entry.')
cIpMRouteSourceMask = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 117, 1, 1, 2, 1, 4), InetAddressPrefixLength())
if mibBuilder.loadTexts: cIpMRouteSourceMask.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteSourceMask.setDescription('The network mask which when combined with the corresponding value of cIpMRouteSource identifies the sources for which this entry contains multicast routing information.')
cIpMRouteUpstreamNeighbor = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 117, 1, 1, 2, 1, 5), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(4, 4), ValueSizeConstraint(16, 16), ValueSizeConstraint(20, 20), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cIpMRouteUpstreamNeighbor.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteUpstreamNeighbor.setDescription('The address of the upstream neighbor (e.g., RPF neighbor) from which IP datagrams from these sources to this multicast address are received, or 0:: if the upstream neighbor is unknown.')
cIpMRouteInIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 117, 1, 1, 2, 1, 6), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cIpMRouteInIfIndex.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteInIfIndex.setDescription('The value of ifIndex for the interface on which IP datagrams sent by these sources to this multicast address are received (i.e., RPF Interface).')
cIpMRouteUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 117, 1, 1, 2, 1, 7), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cIpMRouteUpTime.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteUpTime.setDescription('The time since the multicast routing information represented by this entry was learned by the router.')
cIpMRouteExpiryTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 117, 1, 1, 2, 1, 8), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cIpMRouteExpiryTime.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteExpiryTime.setDescription('The minimum amount of time remaining before this entry will be aged out. The value 0 indicates that the entry is not subject to aging.')
cIpMRoutePkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 117, 1, 1, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cIpMRoutePkts.setStatus('current')
if mibBuilder.loadTexts: cIpMRoutePkts.setDescription('The number of packets which this router has received from these sources and addressed to this multicast group address.')
cIpMRouteDifferentInIfPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 117, 1, 1, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cIpMRouteDifferentInIfPackets.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteDifferentInIfPackets.setDescription('The number of packets which this router has received from these sources and addressed to this multicast group address, which were dropped because they were not received on the interface indicated by cIpMRouteInIfIndex.')
cIpMRouteOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 117, 1, 1, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cIpMRouteOctets.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteOctets.setDescription('The number of octets contained in IP datagrams which were received from these sources and addressed to this multicast group address, and which were forwarded by this router.')
cIpMRouteProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 117, 1, 1, 2, 1, 12), IANAipMRouteProtocol()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cIpMRouteProtocol.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteProtocol.setDescription('The multicast routing protocol via which this multicast forwarding entry was learned.')
cIpMRouteRtProto = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 117, 1, 1, 2, 1, 13), IANAipRouteProtocol()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cIpMRouteRtProto.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteRtProto.setDescription('The routing mechanism via which the route used to find the upstream or parent interface for this multicast forwarding entry was learned. Inclusion of values for routing protocols is not intended to imply that those protocols need be supported.')
cIpMRouteRtAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 117, 1, 1, 2, 1, 14), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(4, 4), ValueSizeConstraint(16, 16), ValueSizeConstraint(20, 20), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cIpMRouteRtAddress.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteRtAddress.setDescription('The address portion of the route used to find the upstream or parent interface for this multicast forwarding entry.')
cIpMRouteRtMask = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 117, 1, 1, 2, 1, 15), InetAddressPrefixLength()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cIpMRouteRtMask.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteRtMask.setDescription('The mask associated with the route used to find the upstream or parent interface for this multicast forwarding entry.')
cIpMRouteRtType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 117, 1, 1, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("unicast", 1), ("multicast", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cIpMRouteRtType.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteRtType.setDescription('The reason the given route was placed in the (logical) multicast Routing Information Base (RIB). A value of unicast means that the route would normally be placed only in the unicast RIB, but was placed in the multicast RIB (instead or in addition) due to local configuration, such as when running PIM over RIP. A value of multicast means that the route was explicitly added to the multicast RIB by the routing protocol, such as Multiprotocol BGP or DVMRP.')
cIpMRouteHCOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 117, 1, 1, 2, 1, 17), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cIpMRouteHCOctets.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteHCOctets.setDescription('The number of octets contained in IP datagrams which were received from these sources and addressed to this multicast group address, and which were forwarded by this router. This object is a 64-bit version of cIpMRouteOctets.')
cIpMRouteNextHopTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 117, 1, 1, 3), )
if mibBuilder.loadTexts: cIpMRouteNextHopTable.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteNextHopTable.setDescription('The (conceptual) table containing information on the next- hops on outgoing interfaces for routing IP multicast datagrams. Each entry is one of a list of next-hops on outgoing interfaces for particular sources sending to a particular multicast group address.')
cIpMRouteNextHopEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 117, 1, 1, 3, 1), ).setIndexNames((0, "CISCO-IETF-IPMROUTE-MIB", "cIpMRouteNextHopAddrType"), (0, "CISCO-IETF-IPMROUTE-MIB", "cIpMRouteNextHopGroup"), (0, "CISCO-IETF-IPMROUTE-MIB", "cIpMRouteNextHopSource"), (0, "CISCO-IETF-IPMROUTE-MIB", "cIpMRouteNextHopSourceMask"), (0, "CISCO-IETF-IPMROUTE-MIB", "cIpMRouteNextHopIfIndex"), (0, "CISCO-IETF-IPMROUTE-MIB", "cIpMRouteNextHopAddress"))
if mibBuilder.loadTexts: cIpMRouteNextHopEntry.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteNextHopEntry.setDescription('An entry (conceptual row) in the list of next-hops on outgoing interfaces to which IP multicast datagrams from particular sources to a IP multicast group address are routed. Discontinuities in counters in this entry can be detected by observing the value of cIpMRouteUpTime.')
cIpMRouteNextHopAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 117, 1, 1, 3, 1, 1), InetAddressType())
if mibBuilder.loadTexts: cIpMRouteNextHopAddrType.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteNextHopAddrType.setDescription('The type of InetAddress representing the IP multicast group.')
cIpMRouteNextHopGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 117, 1, 1, 3, 1, 2), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(4, 4), ValueSizeConstraint(16, 16), ValueSizeConstraint(20, 20), )))
if mibBuilder.loadTexts: cIpMRouteNextHopGroup.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteNextHopGroup.setDescription('The IP multicast group for which this entry specifies a next-hop on an outgoing interface.')
cIpMRouteNextHopSource = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 117, 1, 1, 3, 1, 3), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(4, 4), ValueSizeConstraint(16, 16), ValueSizeConstraint(20, 20), )))
if mibBuilder.loadTexts: cIpMRouteNextHopSource.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteNextHopSource.setDescription('The network address which when combined with the corresponding value of cIpMRouteNextHopSourceMask identifies the sources for which this entry specifies a next-hop on an outgoing interface.')
cIpMRouteNextHopSourceMask = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 117, 1, 1, 3, 1, 4), InetAddressPrefixLength())
if mibBuilder.loadTexts: cIpMRouteNextHopSourceMask.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteNextHopSourceMask.setDescription('The network mask which when combined with the corresponding value of cIpMRouteNextHopSource identifies the sources for which this entry specifies a next-hop on an outgoing interface.')
cIpMRouteNextHopIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 117, 1, 1, 3, 1, 5), InterfaceIndex())
if mibBuilder.loadTexts: cIpMRouteNextHopIfIndex.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteNextHopIfIndex.setDescription('The ifIndex value of the interface for the outgoing interface for this next-hop.')
cIpMRouteNextHopAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 117, 1, 1, 3, 1, 6), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(4, 4), ValueSizeConstraint(16, 16), ValueSizeConstraint(20, 20), )))
if mibBuilder.loadTexts: cIpMRouteNextHopAddress.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteNextHopAddress.setDescription('The address of the next-hop specific to this entry. For most interfaces, this is identical to cIpMRouteNextHopGroup. NBMA interfaces, however, may have multiple next-hop addresses out a single outgoing interface.')
cIpMRouteNextHopState = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 117, 1, 1, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("pruned", 1), ("forwarding", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cIpMRouteNextHopState.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteNextHopState.setDescription("An indication of whether the outgoing interface and next- hop represented by this entry is currently being used to forward IP datagrams. The value 'forwarding' indicates it is currently being used; the value 'pruned' indicates it is not.")
cIpMRouteNextHopUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 117, 1, 1, 3, 1, 8), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cIpMRouteNextHopUpTime.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteNextHopUpTime.setDescription('The time since the multicast routing information represented by this entry was learned by the router.')
cIpMRouteNextHopExpiryTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 117, 1, 1, 3, 1, 9), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cIpMRouteNextHopExpiryTime.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteNextHopExpiryTime.setDescription('The minimum amount of time remaining before this entry will be aged out. If cIpMRouteNextHopState is pruned(1), the remaining time until the prune expires and the state reverts to forwarding(2). Otherwise, the remaining time until this entry is removed from the table. The time remaining may be copied from cIpMRouteExpiryTime if the protocol in use for this entry does not specify next-hop timers. The value 0 indicates that the entry is not subject to aging.')
cIpMRouteNextHopClosestHops = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 117, 1, 1, 3, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cIpMRouteNextHopClosestHops.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteNextHopClosestHops.setDescription('The minimum number of hops between this router and any member of this IP multicast group reached via this next-hop on this outgoing interface. Any IP multicast datagrams for the group which have a TTL less than this number of hops will not be forwarded to this next-hop.')
cIpMRouteNextHopProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 117, 1, 1, 3, 1, 11), IANAipMRouteProtocol()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cIpMRouteNextHopProtocol.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteNextHopProtocol.setDescription('The routing mechanism via which this next-hop was learned.')
cIpMRouteNextHopPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 117, 1, 1, 3, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cIpMRouteNextHopPkts.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteNextHopPkts.setDescription('The number of packets which have been forwarded using this route.')
cIpMRouteInterfaceTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 117, 1, 1, 4), )
if mibBuilder.loadTexts: cIpMRouteInterfaceTable.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteInterfaceTable.setDescription('The (conceptual) table containing multicast routing information specific to interfaces.')
cIpMRouteInterfaceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 117, 1, 1, 4, 1), ).setIndexNames((0, "CISCO-IETF-IPMROUTE-MIB", "cIpMRouteInterfaceIfIndex"), (0, "CISCO-IETF-IPMROUTE-MIB", "cIpMRouteInterfaceIPVersion"))
if mibBuilder.loadTexts: cIpMRouteInterfaceEntry.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteInterfaceEntry.setDescription('An entry (conceptual row) containing the multicast routing information for a particular interface.')
cIpMRouteInterfaceIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 117, 1, 1, 4, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: cIpMRouteInterfaceIfIndex.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteInterfaceIfIndex.setDescription('The ifIndex value of the interface for which this entry contains information.')
cIpMRouteInterfaceIPVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 117, 1, 1, 4, 1, 2), InetVersion())
if mibBuilder.loadTexts: cIpMRouteInterfaceIPVersion.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteInterfaceIPVersion.setDescription('The IP version of this row.')
cIpMRouteInterfaceTtl = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 117, 1, 1, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cIpMRouteInterfaceTtl.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteInterfaceTtl.setDescription('The datagram TTL threshold for the interface. Any IP multicast datagrams with a TTL less than this threshold will not be forwarded out the interface. The default value of 0 means all multicast packets are forwarded out the interface.')
cIpMRouteInterfaceProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 117, 1, 1, 4, 1, 4), IANAipMRouteProtocol()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cIpMRouteInterfaceProtocol.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteInterfaceProtocol.setDescription('The routing protocol running on this interface.')
cIpMRouteInterfaceRateLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 117, 1, 1, 4, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 429496295))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cIpMRouteInterfaceRateLimit.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteInterfaceRateLimit.setDescription('The rate-limit, in kilobits per second, of forwarded multicast traffic on the interface. A rate-limit of 0 indicates that no rate limiting is done.')
cIpMRouteInterfaceInMcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 117, 1, 1, 4, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cIpMRouteInterfaceInMcastPkts.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteInterfaceInMcastPkts.setDescription('The number of multicast packets that have arrived on the interfaces. This object is similar to ifInPkts in the Interfaces MIB, except that only multicast packets are counted.')
cIpMRouteInterfaceOutMcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 117, 1, 1, 4, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cIpMRouteInterfaceOutMcastPkts.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteInterfaceOutMcastPkts.setDescription('The number of multicast packets that have been sent on the interface.')
cIpMRouteInterfaceInMcastOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 117, 1, 1, 4, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cIpMRouteInterfaceInMcastOctets.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteInterfaceInMcastOctets.setDescription('The number of octets of multicast packets that have arrived on the interface, including framing characters. This object is similar to ifInOctets in the Interfaces MIB, except that only multicast packets are counted.')
cIpMRouteInterfaceOutMcastOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 117, 1, 1, 4, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cIpMRouteInterfaceOutMcastOctets.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteInterfaceOutMcastOctets.setDescription('The number of octets of multicast packets that have been sent on the interface.')
cIpMRouteInterfaceHCInMOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 117, 1, 1, 4, 1, 10), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cIpMRouteInterfaceHCInMOctets.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteInterfaceHCInMOctets.setDescription('The number of octets of multicast packets that have arrived on the interface, including framing characters. This object is a 64-bit version of cIpMRouteInterfaceInMcastOctets. It is similar to ifHCInOctets in the Interfaces MIB, except that only multicast packets are counted.')
cIpMRouteInterfaceHCOutMOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 117, 1, 1, 4, 1, 11), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cIpMRouteInterfaceHCOutMOctets.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteInterfaceHCOutMOctets.setDescription('The number of octets of multicast packets that have been sent on the interface. This object is a 64-bit version of cIpMRouteInterfaceOutMcastOctets.')
cIpMRouteInterfaceHCInMPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 117, 1, 1, 4, 1, 12), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cIpMRouteInterfaceHCInMPkts.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteInterfaceHCInMPkts.setDescription('The number of multicast packets that have arrived on the interfaces. This object is a 64-bit version of cIpMRouteInterfaceInMcastPkts. This object is similar to ifInPkts in the Interfaces MIB, except that only multicast packets are counted.')
cIpMRouteInterfaceHCOutMPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 117, 1, 1, 4, 1, 13), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cIpMRouteInterfaceHCOutMPkts.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteInterfaceHCOutMPkts.setDescription('The number of multicast packets that have been sent on the interface. This object is a 64-bit version of cIpMRouteInterfaceOutMcastPkts.')
cIpMRouteBoundaryTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 117, 1, 1, 5), )
if mibBuilder.loadTexts: cIpMRouteBoundaryTable.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteBoundaryTable.setDescription("The (conceptual) table listing the router's scoped multicast address boundaries.")
cIpMRouteBoundaryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 117, 1, 1, 5, 1), ).setIndexNames((0, "CISCO-IETF-IPMROUTE-MIB", "cIpMRouteBoundaryScopeId"), (0, "CISCO-IETF-IPMROUTE-MIB", "cIpMRouteBoundaryIfIndex"), (0, "CISCO-IETF-IPMROUTE-MIB", "cIpMRouteBoundaryAddressType"), (0, "CISCO-IETF-IPMROUTE-MIB", "cIpMRouteBoundaryAddress"), (0, "CISCO-IETF-IPMROUTE-MIB", "cIpMRouteBoundaryAddressMask"))
if mibBuilder.loadTexts: cIpMRouteBoundaryEntry.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteBoundaryEntry.setDescription('An entry (conceptual row) in the cIpMRouteBoundaryTable representing a scoped boundary.')
cIpMRouteBoundaryScopeId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 117, 1, 1, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)))
if mibBuilder.loadTexts: cIpMRouteBoundaryScopeId.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteBoundaryScopeId.setDescription('The scope value in the Group address to which this boundary applies. Packets with a destination address in the address/mask range associated with this scope will not be forwarded out the interface associated with the cIpMRouteBondaryIfIndex. This object is valid only for IPv6 and should take on only values 3-15. In IPv4, the value must be set to zero.')
cIpMRouteBoundaryIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 117, 1, 1, 5, 1, 2), InterfaceIndex())
if mibBuilder.loadTexts: cIpMRouteBoundaryIfIndex.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteBoundaryIfIndex.setDescription('The IfIndex value for the interface to which this boundary applies. Packets with a destination address in the associated address/mask range will not be forwarded out this interface.')
cIpMRouteBoundaryAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 117, 1, 1, 5, 1, 3), InetAddressType())
if mibBuilder.loadTexts: cIpMRouteBoundaryAddressType.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteBoundaryAddressType.setDescription('The type of InetAddress representing the cIpMRouteBoundaryAddress.')
cIpMRouteBoundaryAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 117, 1, 1, 5, 1, 4), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(4, 4), ValueSizeConstraint(16, 16), ValueSizeConstraint(20, 20), )))
if mibBuilder.loadTexts: cIpMRouteBoundaryAddress.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteBoundaryAddress.setDescription('The group address which when combined with the corresponding value of cIpMRouteBoundaryAddressMask identifies the group range for which the scoped boundary exists.')
cIpMRouteBoundaryAddressMask = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 117, 1, 1, 5, 1, 5), InetAddressPrefixLength())
if mibBuilder.loadTexts: cIpMRouteBoundaryAddressMask.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteBoundaryAddressMask.setDescription('The group address mask which when combined with the corresponding value of cIpMRouteBoundaryAddress identifies the group range for which the scoped boundary exists.')
cIpMRouteBoundaryNameString = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 117, 1, 1, 5, 1, 6), SnmpAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cIpMRouteBoundaryNameString.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteBoundaryNameString.setDescription('The textual name associated with the multicast scope. The value of this object should be suitable for displaying to end-users, such as when allocating a multicast address in this scope.')
cIpMRouteBoundaryStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 117, 1, 1, 5, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cIpMRouteBoundaryStatus.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteBoundaryStatus.setDescription('The status of this row, by which new entries may be created, or old entries deleted from this table.')
cIpMRouteScopeNameTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 117, 1, 1, 6), )
if mibBuilder.loadTexts: cIpMRouteScopeNameTable.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteScopeNameTable.setDescription('The (conceptual) table listing the multicast scope names.')
cIpMRouteScopeNameEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 117, 1, 1, 6, 1), ).setIndexNames((0, "CISCO-IETF-IPMROUTE-MIB", "cIpMRouteScopeNameAddressType"), (0, "CISCO-IETF-IPMROUTE-MIB", "cIpMRouteScopeNameAddress"), (0, "CISCO-IETF-IPMROUTE-MIB", "cIpMRouteScopeNameAddressMask"), (1, "CISCO-IETF-IPMROUTE-MIB", "cIpMRouteScopeNameLanguage"))
if mibBuilder.loadTexts: cIpMRouteScopeNameEntry.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteScopeNameEntry.setDescription('An entry (conceptual row) in the cIpMRouteScopeNameTable representing a multicast scope name.')
cIpMRouteScopeNameAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 117, 1, 1, 6, 1, 1), InetAddressType())
if mibBuilder.loadTexts: cIpMRouteScopeNameAddressType.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteScopeNameAddressType.setDescription('The type of InetAddress representing cIpMRouteScopeNameAddress.')
cIpMRouteScopeNameAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 117, 1, 1, 6, 1, 2), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(4, 4), ValueSizeConstraint(16, 16), ValueSizeConstraint(20, 20), )))
if mibBuilder.loadTexts: cIpMRouteScopeNameAddress.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteScopeNameAddress.setDescription('The group address which when combined with the corresponding value of cIpMRouteScopeNameAddressMask identifies the group range associated with the multicast scope.')
cIpMRouteScopeNameAddressMask = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 117, 1, 1, 6, 1, 3), InetAddressPrefixLength())
if mibBuilder.loadTexts: cIpMRouteScopeNameAddressMask.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteScopeNameAddressMask.setDescription('The group address mask which when combined with the corresponding value of cIpMRouteScopeNameAddress identifies the group range associated with the multicast scope.')
cIpMRouteScopeNameLanguage = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 117, 1, 1, 6, 1, 4), LanguageTag())
if mibBuilder.loadTexts: cIpMRouteScopeNameLanguage.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteScopeNameLanguage.setDescription('The RFC 1766-style language tag associated with the scope name.')
cIpMRouteScopeNameString = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 117, 1, 1, 6, 1, 5), SnmpAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cIpMRouteScopeNameString.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteScopeNameString.setDescription('The textual name associated with the multicast scope. The value of this object should be suitable for displaying to end-users, such as when allocating a multicast address in this scope.')
cIpMRouteScopeNameDefault = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 117, 1, 1, 6, 1, 6), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cIpMRouteScopeNameDefault.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteScopeNameDefault.setDescription('If true, indicates a preference that the name in the following language should be used by applications if no name is available in a desired language.')
cIpMRouteScopeNameStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 117, 1, 1, 6, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cIpMRouteScopeNameStatus.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteScopeNameStatus.setDescription('The status of this row, by which new entries may be created, or old entries deleted from this table.')
cIpMRouteMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 117, 2))
cIpMRouteMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 117, 2, 1))
cIpMRouteMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 117, 2, 2))
cIpMRouteMIBCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 10, 117, 2, 1, 1)).setObjects(("CISCO-IETF-IPMROUTE-MIB", "cIpMRouteMIBBasicGroup"), ("CISCO-IETF-IPMROUTE-MIB", "cIpMRouteMIBRouteGroup"), ("CISCO-IETF-IPMROUTE-MIB", "cIpMRouteMIBBoundaryGroup"), ("CISCO-IETF-IPMROUTE-MIB", "cIpMRouteMIBHCInterfaceGroup"), ("CISCO-IETF-IPMROUTE-MIB", "cIpMRouteMIBHopCountGroup"), ("CISCO-IETF-IPMROUTE-MIB", "cIpMRouteMIBPktsOutGroup"), ("CISCO-IETF-IPMROUTE-MIB", "cIpMRouteMIBPktsGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cIpMRouteMIBCompliance = cIpMRouteMIBCompliance.setStatus('deprecated')
if mibBuilder.loadTexts: cIpMRouteMIBCompliance.setDescription('The compliance statement for the IP Multicast Routing MIB.')
cIpMRouteMIBComplianceRev1 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 10, 117, 2, 1, 2)).setObjects(("CISCO-IETF-IPMROUTE-MIB", "cIpMRouteMIBBasicGroup"), ("CISCO-IETF-IPMROUTE-MIB", "cIpMRouteMIBRouteGroup"), ("CISCO-IETF-IPMROUTE-MIB", "cIpMRouteMIBBoundaryGroup"), ("CISCO-IETF-IPMROUTE-MIB", "cIpMRouteMIBHCInterfaceGroup"), ("CISCO-IETF-IPMROUTE-MIB", "cIpMRouteMIBHopCountGroup"), ("CISCO-IETF-IPMROUTE-MIB", "cIpMRouteMIBPktsOutGroup"), ("CISCO-IETF-IPMROUTE-MIB", "cIpMRouteMIBPktsGroup"), ("CISCO-IETF-IPMROUTE-MIB", "cIpMRouteMIBHCInterfaceGroupSup1"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cIpMRouteMIBComplianceRev1 = cIpMRouteMIBComplianceRev1.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteMIBComplianceRev1.setDescription('The compliance statement for the IP Multicast Routing MIB.')
cIpMRouteMIBBasicGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 117, 2, 2, 1)).setObjects(("CISCO-IETF-IPMROUTE-MIB", "cIpMRouteEnable"), ("CISCO-IETF-IPMROUTE-MIB", "cIpMRouteEntryCount"), ("CISCO-IETF-IPMROUTE-MIB", "cIpMRouteUpstreamNeighbor"), ("CISCO-IETF-IPMROUTE-MIB", "cIpMRouteInIfIndex"), ("CISCO-IETF-IPMROUTE-MIB", "cIpMRouteUpTime"), ("CISCO-IETF-IPMROUTE-MIB", "cIpMRouteExpiryTime"), ("CISCO-IETF-IPMROUTE-MIB", "cIpMRouteNextHopState"), ("CISCO-IETF-IPMROUTE-MIB", "cIpMRouteNextHopUpTime"), ("CISCO-IETF-IPMROUTE-MIB", "cIpMRouteNextHopExpiryTime"), ("CISCO-IETF-IPMROUTE-MIB", "cIpMRouteNextHopProtocol"), ("CISCO-IETF-IPMROUTE-MIB", "cIpMRouteInterfaceTtl"), ("CISCO-IETF-IPMROUTE-MIB", "cIpMRouteInterfaceProtocol"), ("CISCO-IETF-IPMROUTE-MIB", "cIpMRouteInterfaceRateLimit"), ("CISCO-IETF-IPMROUTE-MIB", "cIpMRouteInterfaceInMcastPkts"), ("CISCO-IETF-IPMROUTE-MIB", "cIpMRouteInterfaceOutMcastPkts"), ("CISCO-IETF-IPMROUTE-MIB", "cIpMRouteInterfaceInMcastOctets"), ("CISCO-IETF-IPMROUTE-MIB", "cIpMRouteInterfaceOutMcastOctets"), ("CISCO-IETF-IPMROUTE-MIB", "cIpMRouteProtocol"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cIpMRouteMIBBasicGroup = cIpMRouteMIBBasicGroup.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteMIBBasicGroup.setDescription('A collection of objects to support basic management of IP Multicast routing.')
cIpMRouteMIBHopCountGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 117, 2, 2, 2)).setObjects(("CISCO-IETF-IPMROUTE-MIB", "cIpMRouteNextHopClosestHops"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cIpMRouteMIBHopCountGroup = cIpMRouteMIBHopCountGroup.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteMIBHopCountGroup.setDescription('A collection of objects to support management of the use of hop counts in IP Multicast routing.')
cIpMRouteMIBBoundaryGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 117, 2, 2, 3)).setObjects(("CISCO-IETF-IPMROUTE-MIB", "cIpMRouteBoundaryStatus"), ("CISCO-IETF-IPMROUTE-MIB", "cIpMRouteScopeNameString"), ("CISCO-IETF-IPMROUTE-MIB", "cIpMRouteScopeNameDefault"), ("CISCO-IETF-IPMROUTE-MIB", "cIpMRouteScopeNameStatus"), ("CISCO-IETF-IPMROUTE-MIB", "cIpMRouteBoundaryNameString"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cIpMRouteMIBBoundaryGroup = cIpMRouteMIBBoundaryGroup.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteMIBBoundaryGroup.setDescription('A collection of objects to support management of scoped multicast address boundaries.')
cIpMRouteMIBPktsOutGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 117, 2, 2, 4)).setObjects(("CISCO-IETF-IPMROUTE-MIB", "cIpMRouteNextHopPkts"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cIpMRouteMIBPktsOutGroup = cIpMRouteMIBPktsOutGroup.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteMIBPktsOutGroup.setDescription('A collection of objects to support management of packet counters for each outgoing interface entry of a route.')
cIpMRouteMIBHCInterfaceGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 117, 2, 2, 5)).setObjects(("CISCO-IETF-IPMROUTE-MIB", "cIpMRouteInterfaceHCInMOctets"), ("CISCO-IETF-IPMROUTE-MIB", "cIpMRouteInterfaceHCOutMOctets"), ("CISCO-IETF-IPMROUTE-MIB", "cIpMRouteHCOctets"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cIpMRouteMIBHCInterfaceGroup = cIpMRouteMIBHCInterfaceGroup.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteMIBHCInterfaceGroup.setDescription('A collection of objects providing information specific to high speed (greater than 20,000,000 bits/second) network interfaces.')
cIpMRouteMIBRouteGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 117, 2, 2, 6)).setObjects(("CISCO-IETF-IPMROUTE-MIB", "cIpMRouteRtProto"), ("CISCO-IETF-IPMROUTE-MIB", "cIpMRouteRtAddress"), ("CISCO-IETF-IPMROUTE-MIB", "cIpMRouteRtMask"), ("CISCO-IETF-IPMROUTE-MIB", "cIpMRouteRtType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cIpMRouteMIBRouteGroup = cIpMRouteMIBRouteGroup.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteMIBRouteGroup.setDescription('A collection of objects providing information on the relationship between multicast routing information, and the IP Forwarding Table.')
cIpMRouteMIBPktsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 117, 2, 2, 7)).setObjects(("CISCO-IETF-IPMROUTE-MIB", "cIpMRoutePkts"), ("CISCO-IETF-IPMROUTE-MIB", "cIpMRouteDifferentInIfPackets"), ("CISCO-IETF-IPMROUTE-MIB", "cIpMRouteOctets"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cIpMRouteMIBPktsGroup = cIpMRouteMIBPktsGroup.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteMIBPktsGroup.setDescription('A collection of objects to support management of packet counters for each forwarding entry.')
cIpMRouteMIBHCInterfaceGroupSup1 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 117, 2, 2, 8)).setObjects(("CISCO-IETF-IPMROUTE-MIB", "cIpMRouteInterfaceHCInMPkts"), ("CISCO-IETF-IPMROUTE-MIB", "cIpMRouteInterfaceHCOutMPkts"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cIpMRouteMIBHCInterfaceGroupSup1 = cIpMRouteMIBHCInterfaceGroupSup1.setStatus('current')
if mibBuilder.loadTexts: cIpMRouteMIBHCInterfaceGroupSup1.setDescription('A collection of objects providing information specific to high speed (greater than 20,000,000 bits/second) network interfaces.')
mibBuilder.exportSymbols("CISCO-IETF-IPMROUTE-MIB", cIpMRouteSource=cIpMRouteSource, cIpMRouteSourceMask=cIpMRouteSourceMask, cIpMRouteNextHopState=cIpMRouteNextHopState, cIpMRouteMIBCompliance=cIpMRouteMIBCompliance, cIpMRouteInterfaceIfIndex=cIpMRouteInterfaceIfIndex, cIpMRouteInterfaceRateLimit=cIpMRouteInterfaceRateLimit, cIpMRouteMIBBasicGroup=cIpMRouteMIBBasicGroup, cIpMRouteGroup=cIpMRouteGroup, cIpMRouteInterfaceTable=cIpMRouteInterfaceTable, cIpMRouteNextHopEntry=cIpMRouteNextHopEntry, cIpMRouteBoundaryNameString=cIpMRouteBoundaryNameString, cIpMRouteRtAddress=cIpMRouteRtAddress, cIpMRouteInterfaceHCOutMOctets=cIpMRouteInterfaceHCOutMOctets, cIpMRouteBoundaryAddressMask=cIpMRouteBoundaryAddressMask, cIpMRouteNextHopClosestHops=cIpMRouteNextHopClosestHops, cIpMRouteMIBPktsOutGroup=cIpMRouteMIBPktsOutGroup, cIpMRouteScopeNameEntry=cIpMRouteScopeNameEntry, cIpMRouteUpstreamNeighbor=cIpMRouteUpstreamNeighbor, cIpMRouteNextHopTable=cIpMRouteNextHopTable, cIpMRouteNextHopAddrType=cIpMRouteNextHopAddrType, cIpMRouteNextHopProtocol=cIpMRouteNextHopProtocol, cIpMRouteMIBGroups=cIpMRouteMIBGroups, cIpMRouteNextHopPkts=cIpMRouteNextHopPkts, cIpMRouteUpTime=cIpMRouteUpTime, cIpMRouteInterfaceHCOutMPkts=cIpMRouteInterfaceHCOutMPkts, cIpMRouteHCOctets=cIpMRouteHCOctets, cIpMRouteProtocol=cIpMRouteProtocol, cIpMRouteMIBObjects=cIpMRouteMIBObjects, cIpMRouteEntry=cIpMRouteEntry, cIpMRouteInterfaceHCInMPkts=cIpMRouteInterfaceHCInMPkts, cIpMRouteRtMask=cIpMRouteRtMask, cIpMRouteInterfaceInMcastPkts=cIpMRouteInterfaceInMcastPkts, cIpMRouteScopeNameTable=cIpMRouteScopeNameTable, cIpMRouteMIBPktsGroup=cIpMRouteMIBPktsGroup, cIpMRouteRtProto=cIpMRouteRtProto, cIpMRouteNextHopExpiryTime=cIpMRouteNextHopExpiryTime, cIpMRouteInterfaceOutMcastOctets=cIpMRouteInterfaceOutMcastOctets, cIpMRouteBoundaryAddressType=cIpMRouteBoundaryAddressType, cIpMRouteNextHopSource=cIpMRouteNextHopSource, cIpMRouteScopeNameString=cIpMRouteScopeNameString, cIpMRouteMIBHCInterfaceGroupSup1=cIpMRouteMIBHCInterfaceGroupSup1, cIpMRouteMIBHCInterfaceGroup=cIpMRouteMIBHCInterfaceGroup, cIpMRouteInterfaceIPVersion=cIpMRouteInterfaceIPVersion, cIpMRouteDifferentInIfPackets=cIpMRouteDifferentInIfPackets, cIpMRouteMIBRouteGroup=cIpMRouteMIBRouteGroup, cIpMRouteTable=cIpMRouteTable, cIpMRouteNextHopAddress=cIpMRouteNextHopAddress, ciscoIetfIpMRouteMIB=ciscoIetfIpMRouteMIB, cIpMRouteExpiryTime=cIpMRouteExpiryTime, cIpMRouteNextHopIfIndex=cIpMRouteNextHopIfIndex, cIpMRouteScopeNameDefault=cIpMRouteScopeNameDefault, cIpMRouteNextHopSourceMask=cIpMRouteNextHopSourceMask, cIpMRouteMIBConformance=cIpMRouteMIBConformance, cIpMRouteInterfaceInMcastOctets=cIpMRouteInterfaceInMcastOctets, cIpMRouteMIBHopCountGroup=cIpMRouteMIBHopCountGroup, cIpMRouteInIfIndex=cIpMRouteInIfIndex, cIpMRouteEntryCount=cIpMRouteEntryCount, cIpMRouteInterfaceEntry=cIpMRouteInterfaceEntry, cIpMRouteBoundaryScopeId=cIpMRouteBoundaryScopeId, cIpMRouteScopeNameAddressMask=cIpMRouteScopeNameAddressMask, cIpMRouteMIBComplianceRev1=cIpMRouteMIBComplianceRev1, cIpMRouteInterfaceProtocol=cIpMRouteInterfaceProtocol, cIpMRouteInterfaceOutMcastPkts=cIpMRouteInterfaceOutMcastPkts, cIpMRouteScopeNameLanguage=cIpMRouteScopeNameLanguage, cIpMRouteEnable=cIpMRouteEnable, cIpMRouteNextHopUpTime=cIpMRouteNextHopUpTime, cIpMRouteScopeNameAddress=cIpMRouteScopeNameAddress, PYSNMP_MODULE_ID=ciscoIetfIpMRouteMIB, cIpMRouteBoundaryStatus=cIpMRouteBoundaryStatus, cIpMRouteNextHopGroup=cIpMRouteNextHopGroup, cIpMRouteInterfaceTtl=cIpMRouteInterfaceTtl, cIpMRouteBoundaryIfIndex=cIpMRouteBoundaryIfIndex, cIpMRouteMIBBoundaryGroup=cIpMRouteMIBBoundaryGroup, cIpMRouteBoundaryAddress=cIpMRouteBoundaryAddress, cIpMRouteInterfaceHCInMOctets=cIpMRouteInterfaceHCInMOctets, cIpMRouteBoundaryTable=cIpMRouteBoundaryTable, cIpMRouteScopeNameStatus=cIpMRouteScopeNameStatus, cIpMRouteOctets=cIpMRouteOctets, cIpMRoutePkts=cIpMRoutePkts, cIpMRouteBoundaryEntry=cIpMRouteBoundaryEntry, cIpMRouteScopeNameAddressType=cIpMRouteScopeNameAddressType, cIpMRouteMIBCompliances=cIpMRouteMIBCompliances, cIpMRoute=cIpMRoute, cIpMRouteRtType=cIpMRouteRtType, cIpMRouteAddrType=cIpMRouteAddrType)

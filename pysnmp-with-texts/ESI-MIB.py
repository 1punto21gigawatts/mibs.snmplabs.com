#
# PySNMP MIB module ESI-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/ESI-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:06:33 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ConstraintsIntersection, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ConstraintsIntersection", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
MibIdentifier, Bits, TimeTicks, MibScalar, MibTable, MibTableRow, MibTableColumn, IpAddress, Integer32, ObjectIdentity, Unsigned32, iso, enterprises, Counter32, ModuleIdentity, Counter64, NotificationType, Gauge32, NotificationType = mibBuilder.importSymbols("SNMPv2-SMI", "MibIdentifier", "Bits", "TimeTicks", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "IpAddress", "Integer32", "ObjectIdentity", "Unsigned32", "iso", "enterprises", "Counter32", "ModuleIdentity", "Counter64", "NotificationType", "Gauge32", "NotificationType")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
esi = MibIdentifier((1, 3, 6, 1, 4, 1, 683))
general = MibIdentifier((1, 3, 6, 1, 4, 1, 683, 1))
commands = MibIdentifier((1, 3, 6, 1, 4, 1, 683, 2))
esiSNMP = MibIdentifier((1, 3, 6, 1, 4, 1, 683, 3))
esiSNMPCommands = MibIdentifier((1, 3, 6, 1, 4, 1, 683, 3, 2))
driver = MibIdentifier((1, 3, 6, 1, 4, 1, 683, 4))
tokenRing = MibIdentifier((1, 3, 6, 1, 4, 1, 683, 5))
printServers = MibIdentifier((1, 3, 6, 1, 4, 1, 683, 6))
psGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 683, 6, 1))
psOutput = MibIdentifier((1, 3, 6, 1, 4, 1, 683, 6, 2))
psProtocols = MibIdentifier((1, 3, 6, 1, 4, 1, 683, 6, 3))
genProtocols = MibIdentifier((1, 3, 6, 1, 4, 1, 683, 1, 15))
outputCommands = MibIdentifier((1, 3, 6, 1, 4, 1, 683, 6, 2, 2))
outputConfigure = MibIdentifier((1, 3, 6, 1, 4, 1, 683, 6, 2, 3))
outputJobLog = MibIdentifier((1, 3, 6, 1, 4, 1, 683, 6, 2, 6))
trCommands = MibIdentifier((1, 3, 6, 1, 4, 1, 683, 5, 2))
trConfigure = MibIdentifier((1, 3, 6, 1, 4, 1, 683, 5, 3))
tcpip = MibIdentifier((1, 3, 6, 1, 4, 1, 683, 6, 3, 1))
netware = MibIdentifier((1, 3, 6, 1, 4, 1, 683, 6, 3, 2))
vines = MibIdentifier((1, 3, 6, 1, 4, 1, 683, 6, 3, 3))
lanManager = MibIdentifier((1, 3, 6, 1, 4, 1, 683, 6, 3, 4))
eTalk = MibIdentifier((1, 3, 6, 1, 4, 1, 683, 6, 3, 5))
tcpipCommands = MibIdentifier((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 3))
tcpipConfigure = MibIdentifier((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 4))
tcpipStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 5))
nwCommands = MibIdentifier((1, 3, 6, 1, 4, 1, 683, 6, 3, 2, 3))
nwConfigure = MibIdentifier((1, 3, 6, 1, 4, 1, 683, 6, 3, 2, 4))
nwStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 683, 6, 3, 2, 5))
bvCommands = MibIdentifier((1, 3, 6, 1, 4, 1, 683, 6, 3, 3, 3))
bvConfigure = MibIdentifier((1, 3, 6, 1, 4, 1, 683, 6, 3, 3, 4))
bvStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 683, 6, 3, 3, 5))
eTalkCommands = MibIdentifier((1, 3, 6, 1, 4, 1, 683, 6, 3, 5, 3))
eTalkConfigure = MibIdentifier((1, 3, 6, 1, 4, 1, 683, 6, 3, 5, 4))
eTalkStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 683, 6, 3, 5, 5))
genGroupVersion = MibScalar((1, 3, 6, 1, 4, 1, 683, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: genGroupVersion.setStatus('mandatory')
if mibBuilder.loadTexts: genGroupVersion.setDescription('The version for the general group.')
genMIBVersion = MibScalar((1, 3, 6, 1, 4, 1, 683, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: genMIBVersion.setStatus('mandatory')
if mibBuilder.loadTexts: genMIBVersion.setDescription('The version of the MIB.')
genProductName = MibScalar((1, 3, 6, 1, 4, 1, 683, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: genProductName.setStatus('mandatory')
if mibBuilder.loadTexts: genProductName.setDescription('A textual description of the device.')
genProductNumber = MibScalar((1, 3, 6, 1, 4, 1, 683, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 5))).setMaxAccess("readonly")
if mibBuilder.loadTexts: genProductNumber.setStatus('mandatory')
if mibBuilder.loadTexts: genProductNumber.setDescription('The product number of the device.')
genSerialNumber = MibScalar((1, 3, 6, 1, 4, 1, 683, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: genSerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: genSerialNumber.setDescription('The serial number of the device.')
genHWAddress = MibScalar((1, 3, 6, 1, 4, 1, 683, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: genHWAddress.setStatus('mandatory')
if mibBuilder.loadTexts: genHWAddress.setDescription("The device's hardware address.")
genCableType = MibScalar((1, 3, 6, 1, 4, 1, 683, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("tenbase2", 1), ("tenbaseT", 2), ("aui", 3), ("utp", 4), ("stp", 5), ("fiber100fx", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: genCableType.setStatus('mandatory')
if mibBuilder.loadTexts: genCableType.setDescription('Indicates the network cable type connected to the device.')
genDateCode = MibScalar((1, 3, 6, 1, 4, 1, 683, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: genDateCode.setStatus('mandatory')
if mibBuilder.loadTexts: genDateCode.setDescription("The device's datecode.")
genVersion = MibScalar((1, 3, 6, 1, 4, 1, 683, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: genVersion.setStatus('mandatory')
if mibBuilder.loadTexts: genVersion.setDescription('A string indicating the version of the firmware.')
genConfigurationDirty = MibScalar((1, 3, 6, 1, 4, 1, 683, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: genConfigurationDirty.setStatus('mandatory')
if mibBuilder.loadTexts: genConfigurationDirty.setDescription("A variable's value has been changed which will require that the device be reset or power cycled before it will take effect. Set cmdReset to take this action. A list of critical variables that will cause genConfigurationDirty to be set follows: snmpGetCommunityName, snmpSetCommunityName, trPriority, trEarlyTokenRelease, trPacketSize, trRouting, trLocallyAdminAddr, psJetAdminEnabled, outputType, outputHandshake, tcpipEnabled, tcpipIPAddress, tcpipDefaultGateway, tcpipSubnetMask, tcpipUsingNetProtocols, tcpipBootProtocolsEnabled, tcpipRawPortNumber, tcpipMLPTCPPort, tcpipMLPPort, nwEnabled, nwSetFrameFormat, nwMode, nwPrintServerName, nwPrintServerPassword, nwQueueScanTime, nwFileServerName, nwPortPrinterNumber, nwPortFontDownload, nwPortPCLQueue, nwPortPSQueue, nwPortFormsOn, nwPortNotification, bvEnabled, bvSetSequencedRouting, bvLoginName, bvLoginPassword, bvPrintServiceName, bvPrintServiceRouting, lmEnabled, eTalkEnabled")
genCompanyName = MibScalar((1, 3, 6, 1, 4, 1, 683, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: genCompanyName.setStatus('mandatory')
if mibBuilder.loadTexts: genCompanyName.setDescription('A string indicating the manufacturer of the device.')
genCompanyLoc = MibScalar((1, 3, 6, 1, 4, 1, 683, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: genCompanyLoc.setStatus('mandatory')
if mibBuilder.loadTexts: genCompanyLoc.setDescription('A string indicating the location of the manufacturer of the device.')
genCompanyPhone = MibScalar((1, 3, 6, 1, 4, 1, 683, 1, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: genCompanyPhone.setStatus('mandatory')
if mibBuilder.loadTexts: genCompanyPhone.setDescription('A string indicating the phone number of the manufacturer of the device.')
genCompanyTechSupport = MibScalar((1, 3, 6, 1, 4, 1, 683, 1, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: genCompanyTechSupport.setStatus('mandatory')
if mibBuilder.loadTexts: genCompanyTechSupport.setDescription('A string indicating the technical support information for the device.')
genNumProtocols = MibScalar((1, 3, 6, 1, 4, 1, 683, 1, 15, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: genNumProtocols.setStatus('mandatory')
if mibBuilder.loadTexts: genNumProtocols.setDescription('The number of network protocols supported on the device.')
genProtocolTable = MibTable((1, 3, 6, 1, 4, 1, 683, 1, 15, 2), )
if mibBuilder.loadTexts: genProtocolTable.setStatus('mandatory')
if mibBuilder.loadTexts: genProtocolTable.setDescription('A list of network protocols. The number of entries is given by the value of genNumProtocols.')
genProtocolEntry = MibTableRow((1, 3, 6, 1, 4, 1, 683, 1, 15, 2, 1), ).setIndexNames((0, "ESI-MIB", "genProtocolIndex"))
if mibBuilder.loadTexts: genProtocolEntry.setStatus('mandatory')
if mibBuilder.loadTexts: genProtocolEntry.setDescription('A network protocol supported on the device.')
genProtocolIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 1, 15, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: genProtocolIndex.setStatus('mandatory')
if mibBuilder.loadTexts: genProtocolIndex.setDescription("A unique value for each network protocol. Its value ranges between 1 and the value of genNumProtocols. The value for each protocol must remain constant at least from one re-initialization of the entity's network management system to the next re-initialization.")
genProtocolDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 1, 15, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: genProtocolDescr.setStatus('mandatory')
if mibBuilder.loadTexts: genProtocolDescr.setDescription('A textual string describing the network protocol.')
genProtocolID = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 1, 15, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("tcp-ip", 1), ("netware", 2), ("vines", 3), ("lanmanger", 4), ("ethertalk", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: genProtocolID.setStatus('mandatory')
if mibBuilder.loadTexts: genProtocolID.setDescription('A unique identification number for the network protocol.')
genSysUpTimeString = MibScalar((1, 3, 6, 1, 4, 1, 683, 1, 16), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 35))).setMaxAccess("readonly")
if mibBuilder.loadTexts: genSysUpTimeString.setStatus('mandatory')
if mibBuilder.loadTexts: genSysUpTimeString.setDescription('A string indicating the system up time for the device.')
cmdGroupVersion = MibScalar((1, 3, 6, 1, 4, 1, 683, 2, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmdGroupVersion.setStatus('mandatory')
if mibBuilder.loadTexts: cmdGroupVersion.setDescription('The version for the commands group.')
cmdReset = MibScalar((1, 3, 6, 1, 4, 1, 683, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmdReset.setStatus('optional')
if mibBuilder.loadTexts: cmdReset.setDescription('A value of 2 will reset the device. The following list of variables will also cause the device to reset itself. cmdRestoreDefaults, snmpRestoreDefaults, trRestoreDefaults, outputRestoreDefaults, tcpipRestoreDefaults, tcpipFirmwareUpgrade, nwRestoreDefaults, nwFirmwareUpgrade, bvRestoreDefaults, bvFirmwareUpgrade, eTalkRestoreDefaults')
cmdPrintConfig = MibScalar((1, 3, 6, 1, 4, 1, 683, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmdPrintConfig.setStatus('optional')
if mibBuilder.loadTexts: cmdPrintConfig.setDescription('A value of 2 will cause the device to print a configuration page.')
cmdRestoreDefaults = MibScalar((1, 3, 6, 1, 4, 1, 683, 2, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmdRestoreDefaults.setStatus('optional')
if mibBuilder.loadTexts: cmdRestoreDefaults.setDescription('A value of 2 will restore all parameters on the device to factory defaults, as well as reset the device.')
snmpGroupVersion = MibScalar((1, 3, 6, 1, 4, 1, 683, 3, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpGroupVersion.setStatus('mandatory')
if mibBuilder.loadTexts: snmpGroupVersion.setDescription('The version for the snmp group.')
snmpRestoreDefaults = MibScalar((1, 3, 6, 1, 4, 1, 683, 3, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpRestoreDefaults.setStatus('optional')
if mibBuilder.loadTexts: snmpRestoreDefaults.setDescription('A value of 2 will restore all SNMP parameters on the device to factory defaults, as well as reset the device.')
snmpGetCommunityName = MibScalar((1, 3, 6, 1, 4, 1, 683, 3, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpGetCommunityName.setStatus('optional')
if mibBuilder.loadTexts: snmpGetCommunityName.setDescription('Get community name for the managed node. In order for changes to this variable to take effect, the print server must be reset. See cmdReset to do this.')
snmpSetCommunityName = MibScalar((1, 3, 6, 1, 4, 1, 683, 3, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpSetCommunityName.setStatus('optional')
if mibBuilder.loadTexts: snmpSetCommunityName.setDescription('Set community name for the managed node. This value cannot be read, just set. In order for changes to this variable to take effect, the print server must be reset. See cmdReset to do this.')
snmpTrapCommunityName = MibScalar((1, 3, 6, 1, 4, 1, 683, 3, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpTrapCommunityName.setStatus('optional')
if mibBuilder.loadTexts: snmpTrapCommunityName.setDescription('Trap community name for the managed node.')
driverGroupVersion = MibScalar((1, 3, 6, 1, 4, 1, 683, 4, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: driverGroupVersion.setStatus('mandatory')
if mibBuilder.loadTexts: driverGroupVersion.setDescription('The version for the driver group.')
driverRXPackets = MibScalar((1, 3, 6, 1, 4, 1, 683, 4, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: driverRXPackets.setStatus('mandatory')
if mibBuilder.loadTexts: driverRXPackets.setDescription('The number of packets received.')
driverTXPackets = MibScalar((1, 3, 6, 1, 4, 1, 683, 4, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: driverTXPackets.setStatus('mandatory')
if mibBuilder.loadTexts: driverTXPackets.setDescription('The number of packets transmitted.')
driverRXPacketsUnavailable = MibScalar((1, 3, 6, 1, 4, 1, 683, 4, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: driverRXPacketsUnavailable.setStatus('mandatory')
if mibBuilder.loadTexts: driverRXPacketsUnavailable.setDescription('The number of inbound packets which were chosen to be discarded even though no errors had been detected to prevent their being deliverable to a higher-layer protocol due to a lack of buffer space.')
driverRXPacketErrors = MibScalar((1, 3, 6, 1, 4, 1, 683, 4, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: driverRXPacketErrors.setStatus('mandatory')
if mibBuilder.loadTexts: driverRXPacketErrors.setDescription('The number of inbound packets that contained errors preventing them from being deliverable to a higher-layer protocol.')
driverTXPacketErrors = MibScalar((1, 3, 6, 1, 4, 1, 683, 4, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: driverTXPacketErrors.setStatus('mandatory')
if mibBuilder.loadTexts: driverTXPacketErrors.setDescription('The number of outbound packets that could not be transmitted because of errors.')
driverTXPacketRetries = MibScalar((1, 3, 6, 1, 4, 1, 683, 4, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: driverTXPacketRetries.setStatus('mandatory')
if mibBuilder.loadTexts: driverTXPacketRetries.setDescription('The number of retransmitted packets.')
driverChecksumErrors = MibScalar((1, 3, 6, 1, 4, 1, 683, 4, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: driverChecksumErrors.setStatus('mandatory')
if mibBuilder.loadTexts: driverChecksumErrors.setDescription('The number of packets containing checksum errors received.')
trGroupVersion = MibScalar((1, 3, 6, 1, 4, 1, 683, 5, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trGroupVersion.setStatus('mandatory')
if mibBuilder.loadTexts: trGroupVersion.setDescription('The version for the tokenRing group.')
trRestoreDefaults = MibScalar((1, 3, 6, 1, 4, 1, 683, 5, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trRestoreDefaults.setStatus('optional')
if mibBuilder.loadTexts: trRestoreDefaults.setDescription('A value of 2 will restore all token-ring parameters on the device to factory defaults, as well as reset the device.')
trPriority = MibScalar((1, 3, 6, 1, 4, 1, 683, 5, 3, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 6))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trPriority.setStatus('optional')
if mibBuilder.loadTexts: trPriority.setDescription('The token which is passed around the ring until a station needs it can be assigned a priority from 0 to 6. Priority 0 is the lowest and 6 is the highest. The priority of the device can be increased to improve performance. However, the performance of file servers and crucial stations could be affected. In order for changes to this variable to take effect, the device must be reset. See cmdReset to do this.')
trEarlyTokenRelease = MibScalar((1, 3, 6, 1, 4, 1, 683, 5, 3, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trEarlyTokenRelease.setStatus('optional')
if mibBuilder.loadTexts: trEarlyTokenRelease.setDescription('Early token release allows the device to release the token immediately after transmitting data but only on 16 Mbps systems. This feature enhances ring performance. In order for changes to this variable to take effect, the device must be reset. See cmdReset to do this.')
trPacketSize = MibScalar((1, 3, 6, 1, 4, 1, 683, 5, 3, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("one-k", 1), ("two-k", 2), ("four-k", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trPacketSize.setStatus('optional')
if mibBuilder.loadTexts: trPacketSize.setDescription('You should only change the packet size if you are using a driver for your Token Ring adapter which allows packet sizes greater than One_K. In order for changes to this variable to take effect, the device must be reset. See cmdReset to do this.')
trRouting = MibScalar((1, 3, 6, 1, 4, 1, 683, 5, 3, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("off", 1), ("all-None", 2), ("single-All", 3), ("single-None", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trRouting.setStatus('optional')
if mibBuilder.loadTexts: trRouting.setDescription('Set this variable to change the source routing configuration on the device. Off: No source routing. All, None: All-routes broadcast, nonbroadcast return. The frame will be transmitted on every route within the network resulting in multiple copies on a given ring. Single, All: Single-route broadcast, all routes broadcast return. The frame will be transmitted across the designated bridges, which will result in the frame appearing only once on each ring. The response frame is on all routes broadcast to the originator. Single, None: Single-route broadcast, nonbroadcast return. The frame will be transmitted across designated bridges, which will result in the frame appearing only once each ring. In order for changes to this variable to take effect, the device must be reset. See cmdReset to do this.')
trLocallyAdminAddr = MibScalar((1, 3, 6, 1, 4, 1, 683, 5, 3, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trLocallyAdminAddr.setStatus('optional')
if mibBuilder.loadTexts: trLocallyAdminAddr.setDescription('This is the locally administered node address for the device. Valid values are 000000000000 and between 400000000000 and 7FFFFFFFFFFF. A value of 000000000000 indicates that a locally administered address is not in use.')
psGroupVersion = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: psGroupVersion.setStatus('mandatory')
if mibBuilder.loadTexts: psGroupVersion.setDescription('The version for the psGeneral group.')
psJetAdminEnabled = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: psJetAdminEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: psJetAdminEnabled.setDescription('Indicates whether or not the JetAdmin support is enabled on the print server. In order for changes to this variable to take effect, the print server must be reset. See cmdReset to do this.')
psVerifyConfiguration = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("getvalue", 0), ("serial-configuration", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: psVerifyConfiguration.setStatus('optional')
if mibBuilder.loadTexts: psVerifyConfiguration.setDescription('This variable is used to force the print server to verify valid configuration settings. Setting the variable to the appropriate enumeration will cause the print server to verify the settings for that enumeration. If the settings are valid, the result of the set will be OK. If the settings are not valid, the result will be BadValue. Gets on this variable will always return 0. 1 - Indicates whether or not the current serial configuration is valid. Valid configurations - If the serial port is set in bidirectional mode, the baud rate must be less than 115200 and the handshaking must be set to hardware handshaking. 2 - Not used yet. ')
outputGroupVersion = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 2, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: outputGroupVersion.setStatus('mandatory')
if mibBuilder.loadTexts: outputGroupVersion.setDescription('The version for the output group.')
outputRestoreDefaults = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 2, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: outputRestoreDefaults.setStatus('mandatory')
if mibBuilder.loadTexts: outputRestoreDefaults.setDescription('A value of 2 will restore all output parameters on the print server to factory defaults, as well as reset the print server.')
outputCommandsTable = MibTable((1, 3, 6, 1, 4, 1, 683, 6, 2, 2, 2), )
if mibBuilder.loadTexts: outputCommandsTable.setStatus('mandatory')
if mibBuilder.loadTexts: outputCommandsTable.setDescription('A list of physical output ports. The number of entries is given by the value of outputNumPorts.')
outputCommandsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 683, 6, 2, 2, 2, 1), ).setIndexNames((0, "ESI-MIB", "outputIndex"))
if mibBuilder.loadTexts: outputCommandsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: outputCommandsEntry.setDescription('A physical output port on the print server.')
outputCancelCurrentJob = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 2, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: outputCancelCurrentJob.setStatus('optional')
if mibBuilder.loadTexts: outputCancelCurrentJob.setDescription('A value of 2 will cancel the job currently printing on that port.')
outputNumPorts = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 2, 3, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: outputNumPorts.setStatus('mandatory')
if mibBuilder.loadTexts: outputNumPorts.setDescription('The number of physical output ports on the print server.')
outputTable = MibTable((1, 3, 6, 1, 4, 1, 683, 6, 2, 3, 2), )
if mibBuilder.loadTexts: outputTable.setStatus('mandatory')
if mibBuilder.loadTexts: outputTable.setDescription('A list of physical output ports. The number of entries is given by the value of outputNumPorts.')
outputEntry = MibTableRow((1, 3, 6, 1, 4, 1, 683, 6, 2, 3, 2, 1), ).setIndexNames((0, "ESI-MIB", "outputIndex"))
if mibBuilder.loadTexts: outputEntry.setStatus('mandatory')
if mibBuilder.loadTexts: outputEntry.setDescription('A physical output port on the print server.')
outputIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 2, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: outputIndex.setStatus('mandatory')
if mibBuilder.loadTexts: outputIndex.setDescription("A unique value for each physical output port. Its value ranges between 1 and the value of outputNumPorts. The value for each protocol must remain constant at least from one re-initialization of the entity's network management system to the next re-initialization.")
outputName = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 2, 3, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: outputName.setStatus('mandatory')
if mibBuilder.loadTexts: outputName.setDescription('A textual description of the output port.')
outputStatusString = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 2, 3, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: outputStatusString.setStatus('mandatory')
if mibBuilder.loadTexts: outputStatusString.setDescription('A string indicating the status of the physical output port.')
outputStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 2, 3, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on-Line", 1), ("off-Line", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: outputStatus.setStatus('mandatory')
if mibBuilder.loadTexts: outputStatus.setDescription('Indicates status of the printer. Get outputExtendedStatus for further information.')
outputExtendedStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 2, 3, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 15))).clone(namedValues=NamedValues(("none", 1), ("no-Printer-Attached", 2), ("toner-Low", 3), ("paper-Out", 4), ("paper-Jam", 5), ("door-Open", 6), ("printer-Error", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: outputExtendedStatus.setStatus('mandatory')
if mibBuilder.loadTexts: outputExtendedStatus.setDescription('Indicates printer status to be used in conjunction with outputStatus.')
outputPrinter = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 2, 3, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("hp-III", 1), ("hp-IIISi", 2), ("ibm", 3), ("no-Specific-Printer", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: outputPrinter.setStatus('optional')
if mibBuilder.loadTexts: outputPrinter.setDescription('The type of printer the output port is attached to. Even if the group is supported, this variable may not be supported.')
outputLanguageSwitching = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 2, 3, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("off", 1), ("pcl", 2), ("postScript", 3), ("als", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: outputLanguageSwitching.setStatus('optional')
if mibBuilder.loadTexts: outputLanguageSwitching.setDescription('Indicates the language switching option for the physical port. Even if the group is supported, this variable may not be supported.')
outputConfigLanguage = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 2, 3, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("text", 1), ("pcl", 2), ("postScript", 3), ("off", 4), ("epl-zpl", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: outputConfigLanguage.setStatus('mandatory')
if mibBuilder.loadTexts: outputConfigLanguage.setDescription('Indicates the language that configuration pages will be printed in. If set to off, a config sheet will not be printed on this port.')
outputPCLString = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 2, 3, 2, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(127, 127)).setFixedLength(127)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: outputPCLString.setStatus('optional')
if mibBuilder.loadTexts: outputPCLString.setDescription('This string will be sent out the physical port if (1) outputLanguageSwitching is set to PCL or outputLanguageSwitching is set to Auto and the job is determined to be PCL, and (2) outputPrinter is set to No_Specific_Printer. Even if the group is supported, this variable may not be supported.')
outputPSString = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 2, 3, 2, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(127, 127)).setFixedLength(127)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: outputPSString.setStatus('optional')
if mibBuilder.loadTexts: outputPSString.setDescription('This string will be sent out the physical port if (1) outputLanguageSwitching is set to PostScript or outputLanguageSwitching is set to Auto and the job is determined to be PostScript, and (2) outputPrinter is set to No_Specific_Printer. Even if the group is supported, this variable may not be supported.')
outputCascaded = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 2, 3, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: outputCascaded.setStatus('optional')
if mibBuilder.loadTexts: outputCascaded.setDescription("A value of 2 indicates that the physical output port is connected to an Extended System's printer sharing device. Even if the group is supported, this variable may not be supported.")
outputSetting = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 2, 3, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(32758, 32759, 32760, 32761, 32762, 32763, 32764, 32765, 32766, 32767))).clone(namedValues=NamedValues(("serial-infrared", 32758), ("serial-bidirectional", 32759), ("serial-unidirectional", 32760), ("serial-input", 32761), ("parallel-compatibility-no-bidi", 32762), ("ieee-1284-std-nibble-mode", 32763), ("z-Link", 32764), ("internal", 32765), ("ieee-1284-ecp-or-fast-nibble-mode", 32766), ("extendedLink", 32767)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: outputSetting.setStatus('mandatory')
if mibBuilder.loadTexts: outputSetting.setDescription('Indicates the type (and optionally speed) for the physical output port. Setting this variable to physical connections (such as Parallel) will result in an error. In order for changes to this variable to take effect, the print server must be reset. See cmdReset to do this.')
outputOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 2, 3, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("no-Owner", 1), ("tcpip", 2), ("netware", 3), ("vines", 4), ("lanManager", 5), ("etherTalk", 6), ("config-Page", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: outputOwner.setStatus('mandatory')
if mibBuilder.loadTexts: outputOwner.setDescription('Indicates which protocol or task currently is printing on the port.')
outputBIDIStatusEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 2, 3, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: outputBIDIStatusEnabled.setStatus('optional')
if mibBuilder.loadTexts: outputBIDIStatusEnabled.setDescription('A value of 2 indicates that the BIDI status system is enabled.')
outputPrinterModel = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 2, 3, 2, 1, 15), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 60))).setMaxAccess("readonly")
if mibBuilder.loadTexts: outputPrinterModel.setStatus('optional')
if mibBuilder.loadTexts: outputPrinterModel.setDescription('A string indicating the printer model attached to the output port.')
outputPrinterDisplay = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 2, 3, 2, 1, 16), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: outputPrinterDisplay.setStatus('optional')
if mibBuilder.loadTexts: outputPrinterDisplay.setDescription('A string indicating the message on the attached printer front panel.')
outputCapabilities = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 2, 3, 2, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 8, 16, 32, 64, 128, 256, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 1073741824))).clone(namedValues=NamedValues(("serial-Uni-Baud-9600", 1), ("serial-Uni-Baud-19200", 2), ("serial-Uni-Baud-38400", 4), ("serial-Uni-Baud-57600", 8), ("serial-Uni-Baud-115200", 16), ("serial-bidi-Baud-9600", 32), ("serial-bidi-Baud-19200", 64), ("serial-bidi-Baud-38400", 128), ("serial-bidi-Baud-57600", 256), ("zpl-epl-capable", 262144), ("serial-irin", 524288), ("serial-in", 1048576), ("serial-config-settings", 2097152), ("parallel-compatibility-no-bidi", 4194304), ("ieee-1284-std-nibble-mode", 8388608), ("z-link", 16777216), ("bidirectional", 33554432), ("serial-Software-Handshake", 67108864), ("serial-Output", 134217728), ("extendedLink", 268435456), ("internal", 536870912), ("ieee-1284-ecp-or-fast-nibble-mode", 1073741824)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: outputCapabilities.setStatus('mandatory')
if mibBuilder.loadTexts: outputCapabilities.setDescription('This field is implemented as a BIT mask. If the bit is set then the port is capable of functioning in this mode. Bit Property --- ------------------------ 0 Serial Unidirectional Baud 9600 1 Serial Unidirectional Baud 19200 2 Serial Unidirectional Baud 38400 3 Serial Unidirectional Baud 57600 4 Serial Unidirectional Baud 115200 5 Serial Bidirectional Baud 9600 6 Serial Bidirectional Baud 19200 7 Serial Bidirectional Baud 38400 8 Serial Bidirectional Baud 57600 19 Infrared Input on serial port 20 Serial Input 21 Serial Configuration Settings 22 Parallel Compatibility Mode (no bidi) 23 IEEE 1284 Standard Nibble Mode 24 ZLink 25 Bidirectional Support (PJL status) 26 Serial Software Handshaking 27 Serial Output 28 Extended Link Technology 29 Printer Internal (MIO) 30 IEEE 1284 ECP or Fast Nibble Mode')
outputHandshake = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 2, 3, 2, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("not-Supported", 1), ("hardware-Software", 2), ("hardware", 3), ("software", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: outputHandshake.setStatus('optional')
if mibBuilder.loadTexts: outputHandshake.setDescription("If the port in serial mode operation this indicates the handshaking method being used. Setting this value to 'not- supported' will result in an error. Setting this value on non serial capable ports will result in an error. In order for changes to this variable to take effect, the print server must be reset. See cmdReset to do this.")
outputDataBits = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 2, 3, 2, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(7, 8, 255))).clone(namedValues=NamedValues(("seven-bits", 7), ("eight-bits", 8), ("not-Supported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: outputDataBits.setStatus('optional')
if mibBuilder.loadTexts: outputDataBits.setDescription("If the port in serial mode operation this indicates the number of data bits being used. Setting this value to 'not- supported' will result in an error. Setting this value on non serial capable ports will result in an error. In order for changes to this variable to take effect, the print server must be reset. See cmdReset to do this.")
outputStopBits = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 2, 3, 2, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("one-bit", 1), ("two-bits", 2), ("not-Supported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: outputStopBits.setStatus('optional')
if mibBuilder.loadTexts: outputStopBits.setDescription("If the port in serial mode operation this indicates the number of stop bits being used. Setting this value to 'not- supported' will result in an error. Setting this value on non serial capable ports will result in an error. In order for changes to this variable to take effect, the print server must be reset. See cmdReset to do this.")
outputParity = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 2, 3, 2, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 255))).clone(namedValues=NamedValues(("none", 1), ("odd", 2), ("even", 3), ("not-Supported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: outputParity.setStatus('optional')
if mibBuilder.loadTexts: outputParity.setDescription("If the port in serial mode operation this indicates the parity checking method being used. Setting this value to 'not- supported' will result in an error. Setting this value on non serial capable ports will result in an error. In order for changes to this variable to take effect, the print server must be reset. See cmdReset to do this.")
outputBaudRate = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 2, 3, 2, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("unidirectional-9600", 1), ("unidirectional-19200", 2), ("unidirectional-38400", 3), ("unidirectional-57600", 4), ("unidirectional-115200", 5), ("bidirectional-9600", 6), ("bidirectional-19200", 7), ("bidirectional-38400", 8), ("bidirectional-57600", 9)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: outputBaudRate.setStatus('optional')
if mibBuilder.loadTexts: outputBaudRate.setDescription('If the port in serial mode operation this indicates the baud rate being used. Setting this value on non serial capable ports will result in an error. In order for changes to this variable to take effect, the print server must be reset. See cmdReset to do this.')
outputProtocolManager = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 2, 3, 2, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("protocol-none", 0), ("protocol-compatibility", 1), ("protocol-1284-4", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: outputProtocolManager.setStatus('optional')
if mibBuilder.loadTexts: outputProtocolManager.setDescription(' Indicates the type of output protocol manager being used on the port. Protocol-none means either there is no printer attached or the print server has not yet determined which output managers are supported on the printer. Protocol-compatibility means the printer does not support any of the protocol managers supported by the print server. Protocol-1284-4 means the output is using the 1284.4 logical port protocol manager. ')
outputDisplayMask = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 2, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: outputDisplayMask.setStatus('mandatory')
if mibBuilder.loadTexts: outputDisplayMask.setDescription('Bit mask describing what should be displayed by the utilities bit Description --- ----------- 0 outputCancelCurrentJob (Includes all CancelCurrentJob info) 1 outputName 2 outputStatusString 3 outputStatus 4 outputExtendedStatus 5 outputPrinter 6 outputLanguageSwitching 7 outputConfigLanguage 8 outputString (Includes outputPCLString and outputPSString) 9 outputCascaded 10 outputSetting 11 outputOwner 12 outputBIDIStatusEnabled 13 outputPrinterModel 14 outputPrinterDisplay 15 outputHandshake 16 outputJobLog (includes all job logging) 17 outputSerialConfig')
outputAvailableTrapsMask = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 2, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: outputAvailableTrapsMask.setStatus('mandatory')
if mibBuilder.loadTexts: outputAvailableTrapsMask.setDescription('Bit mask describing what output printer traps are available bit Description --- ----------- 0 online 1 offline 2 printer attached 3 toner low 4 paper out 5 paper jam 6 door open 7 printer error')
outputNumLogEntries = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 2, 6, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: outputNumLogEntries.setStatus('mandatory')
if mibBuilder.loadTexts: outputNumLogEntries.setDescription('The number of job log entries per output port.')
outputJobLogTable = MibTable((1, 3, 6, 1, 4, 1, 683, 6, 2, 6, 2), )
if mibBuilder.loadTexts: outputJobLogTable.setStatus('mandatory')
if mibBuilder.loadTexts: outputJobLogTable.setDescription('A 2 dimensional list of Job log entries indexed by the output port number and the log entry index (1 through outputNumJobLogEntries). The number of entries per output port is given by the value of outputNumJobLogEntries.')
outputJobLogEntry = MibTableRow((1, 3, 6, 1, 4, 1, 683, 6, 2, 6, 2, 1), ).setIndexNames((0, "ESI-MIB", "outputIndex"))
if mibBuilder.loadTexts: outputJobLogEntry.setStatus('mandatory')
if mibBuilder.loadTexts: outputJobLogEntry.setDescription('A Job log entry.')
outputJobLogInformation = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 2, 6, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: outputJobLogInformation.setStatus('mandatory')
if mibBuilder.loadTexts: outputJobLogInformation.setDescription('A textual description of print job information. The protocol, source, and file size are always included. Other information such as File Server, Queue, File Name, etc will be included if available.')
outputJobLogTime = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 2, 6, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 50))).setMaxAccess("readonly")
if mibBuilder.loadTexts: outputJobLogTime.setStatus('mandatory')
if mibBuilder.loadTexts: outputJobLogTime.setDescription('A string indicating the elasped time since the last job was printed. Reported in form X hours X minutes X seconds.')
outputTotalJobTable = MibTable((1, 3, 6, 1, 4, 1, 683, 6, 2, 6, 3), )
if mibBuilder.loadTexts: outputTotalJobTable.setStatus('mandatory')
if mibBuilder.loadTexts: outputTotalJobTable.setDescription('Table showing the total number of jobs printed for each port.')
outputTotalJobEntry = MibTableRow((1, 3, 6, 1, 4, 1, 683, 6, 2, 6, 3, 1), ).setIndexNames((0, "ESI-MIB", "outputTotalJobIndex"))
if mibBuilder.loadTexts: outputTotalJobEntry.setStatus('mandatory')
if mibBuilder.loadTexts: outputTotalJobEntry.setDescription('An entry in the outputTotalJobTable.')
outputTotalJobIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 2, 6, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: outputTotalJobIndex.setStatus('mandatory')
if mibBuilder.loadTexts: outputTotalJobIndex.setDescription('A unique value for entry in the outputTotalJobTable. Its value ranges between 1 and the value of numPorts.')
outputTotalJobsLogged = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 2, 6, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: outputTotalJobsLogged.setStatus('mandatory')
if mibBuilder.loadTexts: outputTotalJobsLogged.setDescription('The total number of jobs printed by the port since the print server was powered on. ')
tcpipGroupVersion = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpipGroupVersion.setStatus('mandatory')
if mibBuilder.loadTexts: tcpipGroupVersion.setDescription('The version for the tcpip group.')
tcpipEnabled = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tcpipEnabled.setStatus('optional')
if mibBuilder.loadTexts: tcpipEnabled.setDescription('Indicates whether or not the tcpip protocol stack is enabled on the print server. In order for changes to this variable to take effect, the print server must be reset. See cmdReset to do this.')
tcpipRestoreDefaults = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tcpipRestoreDefaults.setStatus('optional')
if mibBuilder.loadTexts: tcpipRestoreDefaults.setDescription('A value of 2 will restore all tcpip parameters on the print server to factory defaults, as well as reset the print server.')
tcpipFirmwareUpgrade = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 3, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tcpipFirmwareUpgrade.setStatus('optional')
if mibBuilder.loadTexts: tcpipFirmwareUpgrade.setDescription('A value of 2 will put the print server into firmware upgrade mode waiting to receive a firmware upgrade file via tftp.')
tcpipIPAddress = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 4, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tcpipIPAddress.setStatus('optional')
if mibBuilder.loadTexts: tcpipIPAddress.setDescription('The Internet Address. In order for changes to this variable to take effect, the print server must be reset. See cmdReset to do this.')
tcpipDefaultGateway = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 4, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tcpipDefaultGateway.setStatus('optional')
if mibBuilder.loadTexts: tcpipDefaultGateway.setDescription('The default gateway for the print server. In order for changes to this variable to take effect, the print server must be reset. See cmdReset to do this.')
tcpipSubnetMask = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 4, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tcpipSubnetMask.setStatus('optional')
if mibBuilder.loadTexts: tcpipSubnetMask.setDescription('The subnet mask for the print server. In order for changes to this variable to take effect, the print server must be reset. See cmdReset to do this.')
tcpipUsingNetProtocols = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 4, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tcpipUsingNetProtocols.setStatus('optional')
if mibBuilder.loadTexts: tcpipUsingNetProtocols.setDescription('A value of 2 indicates that the print server is using a combination of RARP, BOOTP, default IP address, or gleaning to determine its IP address. See tcpipBootProtocolsEnabled to determine which boot protocols are enabled. If the value of tcpipUsingNetProtocols is 1, the IP address is stored permanently in flash memory. In order for changes to this variable to take effect, the print server must be reset. See cmdReset to do this.')
tcpipBootProtocolsEnabled = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 4, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tcpipBootProtocolsEnabled.setStatus('optional')
if mibBuilder.loadTexts: tcpipBootProtocolsEnabled.setDescription("This is the 16 bit mask which determines which boot protocols will be used to determine the print server's IP address. BIT Boot Protocol Enabled --- -------------------------- 0 RARP 1 BootP 2 DHCP 3 Gleaning 4 Default Address Enabled (If no address after 2 minutes timeout and go to 198.102.102.254) A value of 31 indicates that all boot protocols are enabled. These protocols will only be used if tcpipUsingNetProtocols is set to 2. In order for changes to this variable to take effect, the print server must be reset. See cmdReset to do this.")
tcpipIPAddressSource = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 4, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("permanent", 1), ("default", 2), ("rarp", 3), ("bootp", 4), ("dhcp", 5), ("glean", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpipIPAddressSource.setStatus('optional')
if mibBuilder.loadTexts: tcpipIPAddressSource.setDescription('This variable indicates how the IP address for the print server was determined.')
tcpipIPAddressServerAddress = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 4, 7), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpipIPAddressServerAddress.setStatus('optional')
if mibBuilder.loadTexts: tcpipIPAddressServerAddress.setDescription('This variable indicates the source of the IP address if a boot protocol was used. This value will be 0.0.0.0 if no boot server was used.')
tcpipTimeoutChecking = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 4, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tcpipTimeoutChecking.setStatus('optional')
if mibBuilder.loadTexts: tcpipTimeoutChecking.setDescription('A value of 2 indicates that a packet timeout will be active on all tcp connections. If a packet has not been received from the connection within this timeout the connection will be reset. To set this timeout, see tcpipTimeoutCheckingValue')
tcpipNumTraps = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 4, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpipNumTraps.setStatus('mandatory')
if mibBuilder.loadTexts: tcpipNumTraps.setDescription('The number of UDP trap destinations.')
tcpipTrapTable = MibTable((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 4, 10), )
if mibBuilder.loadTexts: tcpipTrapTable.setStatus('mandatory')
if mibBuilder.loadTexts: tcpipTrapTable.setDescription('A list of UDP trap definitions. The number of entries is given by the value of tcpipNumTraps.')
tcpipTrapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 4, 10, 1), ).setIndexNames((0, "ESI-MIB", "tcpipTrapIndex"))
if mibBuilder.loadTexts: tcpipTrapEntry.setStatus('mandatory')
if mibBuilder.loadTexts: tcpipTrapEntry.setDescription('An entry in the tcpipTrapTable.')
tcpipTrapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 4, 10, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpipTrapIndex.setStatus('mandatory')
if mibBuilder.loadTexts: tcpipTrapIndex.setDescription('A unique value for entry in the tcpipTrapTable. Its value ranges between 1 and the value of tcpipNumTraps.')
tcpipTrapDestination = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 4, 10, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tcpipTrapDestination.setStatus('optional')
if mibBuilder.loadTexts: tcpipTrapDestination.setDescription('This is the IP address that traps are sent to. A value of 0.0.0.0 will disable traps over UDP.')
tcpipProtocolTrapMask = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 4, 10, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tcpipProtocolTrapMask.setStatus('optional')
if mibBuilder.loadTexts: tcpipProtocolTrapMask.setDescription('This is the 16 bit mask which determines which protocol specific traps will be sent out via UDP. Currently no protocol specific traps are supported.')
tcpipPrinterTrapMask = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 4, 10, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tcpipPrinterTrapMask.setStatus('optional')
if mibBuilder.loadTexts: tcpipPrinterTrapMask.setDescription('This is the 16 bit mask which determines which printer specific traps will be sent out via UDP. A value of 65535 indicates that all printer specific traps should be reported via UDP. BIT CONDITION --- -------------------------- 0 On-line (Condition cleared) 1 Off-line 2 No printer attached 3 Toner Low 4 Paper Out 5 Paper Jam 6 Door Open 15 Printer Error')
tcpipOutputTrapMask = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 4, 10, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tcpipOutputTrapMask.setStatus('optional')
if mibBuilder.loadTexts: tcpipOutputTrapMask.setDescription('This is the 16 bit mask which determines which physical output ports will be checked when generating printer specific traps to be sent out via UDP. A value of 65535 indicates that all physical output ports will generate traps. BIT CONDITION --- -------------------------- 0 Port 1 1 Port 2 2 Port 3 3 Port 4 ... ...')
tcpipBanners = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 4, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tcpipBanners.setStatus('optional')
if mibBuilder.loadTexts: tcpipBanners.setDescription('A value of 2 indicates that banners will be printed with tcpip jobs. Even if the group is supported, this variable may not be supported.')
tcpipWinsAddress = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 4, 12), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tcpipWinsAddress.setStatus('optional')
if mibBuilder.loadTexts: tcpipWinsAddress.setDescription('The IP address of the WINS server. The print server will register its sysName to this WINS server.')
tcpipWinsAddressSource = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 4, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dhcp", 1), ("permanent", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tcpipWinsAddressSource.setStatus('optional')
if mibBuilder.loadTexts: tcpipWinsAddressSource.setDescription('The source of the WINS server address. If set to dhcp, the print server will use the WINS address supplied with dhcp. If it is set to permanent, it will use the WINS address stored in flash.')
tcpipConfigPassword = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 4, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(5, 24))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tcpipConfigPassword.setStatus('optional')
if mibBuilder.loadTexts: tcpipConfigPassword.setDescription('The print server html/telnet configuration password. This value cannot be read, just set.')
tcpipTimeoutCheckingValue = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 4, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tcpipTimeoutCheckingValue.setStatus('optional')
if mibBuilder.loadTexts: tcpipTimeoutCheckingValue.setDescription('The TCP connection timeout in seconds. A value of 0 has the same effect as disabling timeout checking.')
tcpipArpInterval = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 4, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tcpipArpInterval.setStatus('optional')
if mibBuilder.loadTexts: tcpipArpInterval.setDescription('The ARP interval in minutes. The print server will ARP itself once when this timer expires. Set to 0 to disable.')
tcpipRawPortNumber = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 4, 17), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tcpipRawPortNumber.setStatus('optional')
if mibBuilder.loadTexts: tcpipRawPortNumber.setDescription('The raw TCP port number the print server will listen for print jobs on. On multiple port devices, additional ports will sequentially follow this port number. The default port is 9100. Setting this value to a TCP port that is in use by another TCP application will return an error. In order for changes to this variable to take effect, the print server must be reset. See cmdReset to do this.')
tcpipNumSecurity = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 4, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpipNumSecurity.setStatus('mandatory')
if mibBuilder.loadTexts: tcpipNumSecurity.setDescription('The number of secure IP address ranges.')
tcpipSecurityTable = MibTable((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 4, 19), )
if mibBuilder.loadTexts: tcpipSecurityTable.setStatus('mandatory')
if mibBuilder.loadTexts: tcpipSecurityTable.setDescription('A list of secure IP address ranges. This adds security for both printing and admin rights. AdminEnabled: When the admin enabled field is set to yes for a secure address range, the print server may only be configured via IP from IP address within that range. If the admin field is not set for any address ranges, the print server will accept admin commands from any IP address which has the valid community names and/or passwords. PortMask: When there is a port mask set for a secure IP address range, the print server will only accept TCP/IP print jobs from hosts that are in the secure address range. If there are no ranges with a port mask set, the print server will accept TCP/IP print jobs from any host. The number of entries is given by the value of tcpipNumSecurity.')
tcpipSecurityEntry = MibTableRow((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 4, 19, 1), ).setIndexNames((0, "ESI-MIB", "tcpipSecurityIndex"))
if mibBuilder.loadTexts: tcpipSecurityEntry.setStatus('mandatory')
if mibBuilder.loadTexts: tcpipSecurityEntry.setDescription('An entry in the tcpipSecurityTable.')
tcpipSecurityIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 4, 19, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpipSecurityIndex.setStatus('mandatory')
if mibBuilder.loadTexts: tcpipSecurityIndex.setDescription('A unique value for entry in the tcpipSecurityTable. Its value ranges between 1 and the value of tcpipNumSecurity.')
tcpipSecureStartIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 4, 19, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tcpipSecureStartIPAddress.setStatus('optional')
if mibBuilder.loadTexts: tcpipSecureStartIPAddress.setDescription('This is the starting IP address for the secure IP address range. A value of 0.0.0.0 for both tcpipStartIPAddress and tcpipEndIPAddress will disable the address range.')
tcpipSecureEndIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 4, 19, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tcpipSecureEndIPAddress.setStatus('optional')
if mibBuilder.loadTexts: tcpipSecureEndIPAddress.setDescription('This is the ending IP address for the secure IP address range. A value of 0.0.0.0 for both tcpipStartIPAddress and tcpipEndIPAddress will disable the address range.')
tcpipSecurePrinterMask = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 4, 19, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tcpipSecurePrinterMask.setStatus('optional')
if mibBuilder.loadTexts: tcpipSecurePrinterMask.setDescription('This is the 8 bit mask which determines which physical output ports this range of IP addresses can print to. A value of 127 indicates that the range of IP addresses can print to any of the output ports. This value can not be configured until a valid start and end address range have been configured. BIT CONDITION --- -------------------------- 0 Port 1 1 Port 2 2 Port 3 3 Port 4 ... ... 8 Reserved, must be set to 0.')
tcpipSecureAdminEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 4, 19, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tcpipSecureAdminEnabled.setStatus('optional')
if mibBuilder.loadTexts: tcpipSecureAdminEnabled.setDescription(' This allows an advanced level of admin security for IP. Setting this will restrict which IP addresses can configure the print server. The correct community names and passwords are still required if this is used, it just adds another level of security. Indicates whether or not admin rights are enabled for this range of IP addresses. If no range of addresses has this enabled, then any IP address can configure the print server if it has the correct community names and/or passwords. If this field is set to yes for any range of addresses, the print server will only be configurable via IP from that range of addresses. This value can not be configured until a valid start and end address range have been configured.')
tcpipLowBandwidth = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 4, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tcpipLowBandwidth.setStatus('optional')
if mibBuilder.loadTexts: tcpipLowBandwidth.setDescription('A value of 2 will optimize the TCP stack for low bandwidth networks. A value of 1 will optimize the TCP stack for high bandwidth networks.')
tcpipNumLogicalPrinters = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 4, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpipNumLogicalPrinters.setStatus('mandatory')
if mibBuilder.loadTexts: tcpipNumLogicalPrinters.setDescription('The number of available logical printers.')
tcpipMLPTable = MibTable((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 4, 22), )
if mibBuilder.loadTexts: tcpipMLPTable.setStatus('mandatory')
if mibBuilder.loadTexts: tcpipMLPTable.setDescription('A table of the available logical printers. The number of entries is given by the value of tcpipNumLogicalPrinters.')
tcpipMLPEntry = MibTableRow((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 4, 22, 1), ).setIndexNames((0, "ESI-MIB", "tcpipMLPIndex"))
if mibBuilder.loadTexts: tcpipMLPEntry.setStatus('mandatory')
if mibBuilder.loadTexts: tcpipMLPEntry.setDescription('An entry in the tcpipMLPTable.')
tcpipMLPIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 4, 22, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpipMLPIndex.setStatus('optional')
if mibBuilder.loadTexts: tcpipMLPIndex.setDescription('A unique value for entry in the tcpipMLPTable. Its value ranges between 1 and the value of tcpipNumLogicalPrinters.')
tcpipMLPName = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 4, 22, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tcpipMLPName.setStatus('optional')
if mibBuilder.loadTexts: tcpipMLPName.setDescription('Contains the name of the logical printer. This name is also the LPR remote queue name associated with the logical printer.')
tcpipMLPPort = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 4, 22, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tcpipMLPPort.setStatus('optional')
if mibBuilder.loadTexts: tcpipMLPPort.setDescription('The number of the physical output port associated with the logical printer. In order for changes to this variable to take effect, the print server must be reset. See cmdReset to do this.')
tcpipMLPTCPPort = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 4, 22, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tcpipMLPTCPPort.setStatus('optional')
if mibBuilder.loadTexts: tcpipMLPTCPPort.setDescription('The TCP port associated with the logical printer. Any print data sent to this TCP port will be processed through this logical printer entry. In order for changes to this variable to take effect, the print server must be reset. See cmdReset to do this.')
tcpipMLPPreString = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 4, 22, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tcpipMLPPreString.setStatus('optional')
if mibBuilder.loadTexts: tcpipMLPPreString.setDescription("This contains any data that should be sent down to the printer at the beginning of jobs sent to this logical printer. To enter non-printable ascii characters in the string, enclose the decimal value inside of <>. For example, to enter an ESC-E the string would be '<27>E'.")
tcpipMLPPostString = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 4, 22, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tcpipMLPPostString.setStatus('optional')
if mibBuilder.loadTexts: tcpipMLPPostString.setDescription("This contains any data that should be sent down to the printer at the end of jobs sent to this logical printer. To enter non-printable ascii characters in the string, enclose the decimal value inside of <>. For example, to enter an ESC-E the string would be '<27>E'.")
tcpipMLPDeleteBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 4, 22, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tcpipMLPDeleteBytes.setStatus('optional')
if mibBuilder.loadTexts: tcpipMLPDeleteBytes.setDescription('The number of bytes that will be deleted from the beginning of jobs sent to this logical printer.')
tcpipSmtpServerAddr = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 4, 23), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tcpipSmtpServerAddr.setStatus('optional')
if mibBuilder.loadTexts: tcpipSmtpServerAddr.setDescription('The IP address of the e-mail server which will be used to send e-mail notification of printer status conditions. This address must contain the valid IP address of an e-mail server before any of the contents of the SmtpTable are used.')
tcpipNumSmtpDestinations = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 4, 24), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpipNumSmtpDestinations.setStatus('mandatory')
if mibBuilder.loadTexts: tcpipNumSmtpDestinations.setDescription('The number of configurable e-mail destinations to receive printer status conditions. ')
tcpipSmtpTable = MibTable((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 4, 25), )
if mibBuilder.loadTexts: tcpipSmtpTable.setStatus('mandatory')
if mibBuilder.loadTexts: tcpipSmtpTable.setDescription('A list of SMTP e-mail addresses and printer status conditions to send e-mails for. The number of entries is given by the value of tcpipNumSmtpDestinations.')
tcpipSmtpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 4, 25, 1), ).setIndexNames((0, "ESI-MIB", "tcpipSmtpIndex"))
if mibBuilder.loadTexts: tcpipSmtpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: tcpipSmtpEntry.setDescription('An entry in the tcpipSmtpTable.')
tcpipSmtpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 4, 25, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpipSmtpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: tcpipSmtpIndex.setDescription('A unique value for entry in the tcpipSmtpTable. Its value ranges between 1 and the value of tcpipNumSmtpDestinations.')
tcpipSmtpEmailAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 4, 25, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(64, 64)).setFixedLength(64)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tcpipSmtpEmailAddr.setStatus('optional')
if mibBuilder.loadTexts: tcpipSmtpEmailAddr.setDescription('This is the e-mail address that printer status conditions are sent to. If this string is empty the status conditions will not be sent.')
tcpipSmtpProtocolMask = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 4, 25, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tcpipSmtpProtocolMask.setStatus('optional')
if mibBuilder.loadTexts: tcpipSmtpProtocolMask.setDescription('This is the 16 bit mask which determines which protocol specific conditions will be sent out via e-mail. Currently no protocol specific conditions are supported.')
tcpipSmtpPrinterMask = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 4, 25, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tcpipSmtpPrinterMask.setStatus('optional')
if mibBuilder.loadTexts: tcpipSmtpPrinterMask.setDescription('This is the 16 bit mask which determines which printer specific conditions will be sent out via e-mail. A value of 65535 indicates that all printer specific conditions should be reported via e-mail. BIT CONDITION --- -------------------------- 0 On-line (Condition cleared) 1 Off-line 2 No printer attached 3 Toner Low 4 Paper Out 5 Paper Jam 6 Door Open 15 Printer Error')
tcpipSmtpOutputMask = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 4, 25, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tcpipSmtpOutputMask.setStatus('optional')
if mibBuilder.loadTexts: tcpipSmtpOutputMask.setDescription('This is the 16 bit mask which determines which physical output ports will be checked when generating printer specific conditions to be sent out via e-mail. A value of 65535 indicates that all physical output ports will generate e-mails upon a change in status. BIT CONDITION --- -------------------------- 0 Port 1 1 Port 2 2 Port 3 3 Port 4 ... ...')
tcpipWebAdminName = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 4, 26), OctetString().subtype(subtypeSpec=ValueSizeConstraint(25, 25)).setFixedLength(25)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tcpipWebAdminName.setStatus('optional')
if mibBuilder.loadTexts: tcpipWebAdminName.setDescription('This is the admin name used by web configuration for login.')
tcpipWebAdminPassword = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 4, 27), OctetString().subtype(subtypeSpec=ValueSizeConstraint(25, 25)).setFixedLength(25)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tcpipWebAdminPassword.setStatus('optional')
if mibBuilder.loadTexts: tcpipWebAdminPassword.setDescription('This is the admin password used by web configuration for login.')
tcpipWebUserName = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 4, 28), OctetString().subtype(subtypeSpec=ValueSizeConstraint(25, 25)).setFixedLength(25)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tcpipWebUserName.setStatus('optional')
if mibBuilder.loadTexts: tcpipWebUserName.setDescription('This is the user name used by web configuration for login. Not currently used. ')
tcpipWebUserPassword = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 4, 29), OctetString().subtype(subtypeSpec=ValueSizeConstraint(25, 25)).setFixedLength(25)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tcpipWebUserPassword.setStatus('optional')
if mibBuilder.loadTexts: tcpipWebUserPassword.setDescription('This is the user password used by web configuration for login. Not currently used.')
tcpipWebHtttpPort = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 4, 30), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tcpipWebHtttpPort.setStatus('optional')
if mibBuilder.loadTexts: tcpipWebHtttpPort.setDescription('The port number used to communicate over http. Must be between 0 and 65535. It must not be the same as any other port used. Other ports used are 20, 21, 23, 515, & raw port numbers (9100, 9101, ... if at default)')
tcpipWebFaqURL = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 4, 31), OctetString().subtype(subtypeSpec=ValueSizeConstraint(64, 64)).setFixedLength(64)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tcpipWebFaqURL.setStatus('optional')
if mibBuilder.loadTexts: tcpipWebFaqURL.setDescription('This is the URL for FAQ at the ESI (or other OEM) website.')
tcpipWebUpdateURL = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 4, 32), OctetString().subtype(subtypeSpec=ValueSizeConstraint(64, 64)).setFixedLength(64)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tcpipWebUpdateURL.setStatus('optional')
if mibBuilder.loadTexts: tcpipWebUpdateURL.setDescription('This is the URL for finding firmware updates at the ESI (or other OEM) website.')
tcpipWebCustomLinkName = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 4, 33), OctetString().subtype(subtypeSpec=ValueSizeConstraint(25, 25)).setFixedLength(25)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tcpipWebCustomLinkName.setStatus('optional')
if mibBuilder.loadTexts: tcpipWebCustomLinkName.setDescription('This is the name assigned to the custom link defined by the user.')
tcpipWebCustomLinkURL = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 4, 34), OctetString().subtype(subtypeSpec=ValueSizeConstraint(64, 64)).setFixedLength(64)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tcpipWebCustomLinkURL.setStatus('optional')
if mibBuilder.loadTexts: tcpipWebCustomLinkURL.setDescription('This is the URL for a custom link specified by the user.')
tcpipPOP3ServerAddress = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 4, 35), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tcpipPOP3ServerAddress.setStatus('optional')
if mibBuilder.loadTexts: tcpipPOP3ServerAddress.setDescription('The IP address of the POP3 server from which email will be retrieved. This address must contain the valid IP address of a POP3 server before any attempts to retrieve email will be made.')
tcpipPOP3PollInterval = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 4, 36), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tcpipPOP3PollInterval.setStatus('mandatory')
if mibBuilder.loadTexts: tcpipPOP3PollInterval.setDescription('The number of seconds between attempts to retrieve mail from the POP3 server. ')
tcpipPOP3UserName = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 4, 37), OctetString().subtype(subtypeSpec=ValueSizeConstraint(64, 64)).setFixedLength(64)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tcpipPOP3UserName.setStatus('optional')
if mibBuilder.loadTexts: tcpipPOP3UserName.setDescription("This is the user name for the print server's email account on the POP3 server.")
tcpipPOP3Password = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 4, 38), OctetString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tcpipPOP3Password.setStatus('optional')
if mibBuilder.loadTexts: tcpipPOP3Password.setDescription("This is the password for the print server's email account on the POP3 server.")
tcpipDomainName = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 4, 39), OctetString().subtype(subtypeSpec=ValueSizeConstraint(64, 64)).setFixedLength(64)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tcpipDomainName.setStatus('optional')
if mibBuilder.loadTexts: tcpipDomainName.setDescription('This is the Domain name used by POP3 and SMTP.')
tcpipError = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 5, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpipError.setStatus('optional')
if mibBuilder.loadTexts: tcpipError.setDescription('Contains any tcpip specific error information.')
tcpipDisplayMask = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpipDisplayMask.setStatus('mandatory')
if mibBuilder.loadTexts: tcpipDisplayMask.setDescription('Bit mask describing what should be displayed by the utilities bit Description --- ----------- 0 tcpipAddress (Includes tcpipDefaultGateway and tcpipSubnetMask) 1 tcpipUsingNetProtocols (Includes tcpipBootProtocolsEnabled, tcpipAddressSource, tcpipAddressServerAddress) 2 tcpipTimeoutChecking 3 tcpipTraps (Includes all trap info) 4 tcpipBanners 5 tcpipSecurity (Includes all security info) 6 tcpipWinsAddress (Includes tcpipWinsAddressSource) 7 tcpipConfigPassword 8 tcpipTimeoutCheckingValue 9 tcpipArpInterval 10 tcpipRawPortNumber 11 tcpipError 12 tcpipLowBandwidth 13 tcpipMLP (Includes all logical printer settings)')
nwGroupVersion = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 2, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwGroupVersion.setStatus('mandatory')
if mibBuilder.loadTexts: nwGroupVersion.setDescription('The version for the netware group.')
nwEnabled = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwEnabled.setStatus('optional')
if mibBuilder.loadTexts: nwEnabled.setDescription('Indicates whether or not the NetWare protocol stack is enabled on the print server. In order for changes to this variable to take effect, the print server must be reset. See cmdReset to do this.')
nwRestoreDefaults = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 2, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwRestoreDefaults.setStatus('optional')
if mibBuilder.loadTexts: nwRestoreDefaults.setDescription('A value of 2 will restore all NetWare parameters on the print server to factory defaults, as well as reset the print server.')
nwFirmwareUpgrade = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 2, 3, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwFirmwareUpgrade.setStatus('optional')
if mibBuilder.loadTexts: nwFirmwareUpgrade.setDescription('A value of 2 will put the print server into firmware upgrade mode.')
nwFrameFormat = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 2, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("unknown", 1), ("ethernet-II", 2), ("ethernet-802-3", 3), ("ethernet-802-2", 4), ("ethernet-Snap", 5), ("token-Ring", 6), ("token-Ring-Snap", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwFrameFormat.setStatus('optional')
if mibBuilder.loadTexts: nwFrameFormat.setDescription('Indicates the frame format that the print server is using. See nwSetFrameFormat to determine which frame frame format the print server is configured for.')
nwSetFrameFormat = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 2, 4, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("auto-Sense", 1), ("forced-Ethernet-II", 2), ("forced-Ethernet-802-3", 3), ("forced-Ethernet-802-2", 4), ("forced-Ethernet-Snap", 5), ("forced-Token-Ring", 6), ("forced-Token-Ring-Snap", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwSetFrameFormat.setStatus('optional')
if mibBuilder.loadTexts: nwSetFrameFormat.setDescription('Indicates the frame format that the print server is using. Setting this value to 1 (Auto_Sense) indicates that automatic frame format sensing will be used. In order for changes to this variable to take effect, the print server must be reset. See cmdReset to do this.')
nwMode = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 2, 4, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("pserver", 2), ("rprinter", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwMode.setStatus('optional')
if mibBuilder.loadTexts: nwMode.setDescription('Mode the print server is running in. In order for changes to this variable to take effect, the print server must be reset. See cmdReset to do this.')
nwPrintServerName = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 2, 4, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 47))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwPrintServerName.setStatus('optional')
if mibBuilder.loadTexts: nwPrintServerName.setDescription('Contains print server name. In order for changes to this variable to take effect, the print server must be reset. See cmdReset to do this.')
nwPrintServerPassword = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 2, 4, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 9))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwPrintServerPassword.setStatus('optional')
if mibBuilder.loadTexts: nwPrintServerPassword.setDescription('The print server password. This value cannot be read, just set. In order for changes to this variable to take effect, the print server must be reset. See cmdReset to do this.')
nwQueueScanTime = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 2, 4, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwQueueScanTime.setStatus('optional')
if mibBuilder.loadTexts: nwQueueScanTime.setDescription('Determines how often, in tenths of a second that the print server will scan the queues for jobs. In order for changes to this variable to take effect, the print server must be reset. See cmdReset to do this.')
nwNetworkNumber = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 2, 4, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwNetworkNumber.setStatus('optional')
if mibBuilder.loadTexts: nwNetworkNumber.setDescription("The print server's network number.")
nwMaxFileServers = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 2, 4, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwMaxFileServers.setStatus('optional')
if mibBuilder.loadTexts: nwMaxFileServers.setDescription('The print server maximum number of file servers which it can be attached to at once.')
nwFileServerTable = MibTable((1, 3, 6, 1, 4, 1, 683, 6, 3, 2, 4, 9), )
if mibBuilder.loadTexts: nwFileServerTable.setStatus('optional')
if mibBuilder.loadTexts: nwFileServerTable.setDescription('A table of file servers to service.')
nwFileServerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 683, 6, 3, 2, 4, 9, 1), ).setIndexNames((0, "ESI-MIB", "nwFileServerIndex"))
if mibBuilder.loadTexts: nwFileServerEntry.setStatus('optional')
if mibBuilder.loadTexts: nwFileServerEntry.setDescription('A file server for the print server to service.')
nwFileServerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 3, 2, 4, 9, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwFileServerIndex.setStatus('optional')
if mibBuilder.loadTexts: nwFileServerIndex.setDescription("A unique value for each file server. Its value ranges between 1 and the value of nwMaxFileServers. The value for each server must remain constant at least from one re-initialization of the entity's network management system to the next re-initialization. The first entry in the table is the default file server.")
nwFileServerName = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 3, 2, 4, 9, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 47))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwFileServerName.setStatus('optional')
if mibBuilder.loadTexts: nwFileServerName.setDescription('The file server name. This name will be NULL if there is no file server to be serviced. Only the default file server (the first entry in the table) can be set. In order for changes to this variable to take effect, the print server must be reset. See cmdReset to do this.')
nwFileServerConnectionStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 3, 2, 4, 9, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 258, 261, 276, 512, 515, 768, 769, 32767))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("startupInProgress", 3), ("serverReattaching", 4), ("serverNeverAttached", 5), ("pse-UNKNOWN-FILE-SERVER", 258), ("pse-NO-RESPONSE", 261), ("pse-CANT-LOGIN", 276), ("pse-NO-SUCH-QUEUE", 512), ("pse-UNABLE-TO-ATTACH-TO-QUEUE", 515), ("bad-CONNECTION", 768), ("bad-SERVICE-CONNECTION", 769), ("other", 32767)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwFileServerConnectionStatus.setStatus('optional')
if mibBuilder.loadTexts: nwFileServerConnectionStatus.setDescription('The value describes the status of the connection between the file server and the print server.')
nwPortTable = MibTable((1, 3, 6, 1, 4, 1, 683, 6, 3, 2, 4, 10), )
if mibBuilder.loadTexts: nwPortTable.setStatus('optional')
if mibBuilder.loadTexts: nwPortTable.setDescription('A table of NetWare port specific information.')
nwPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 683, 6, 3, 2, 4, 10, 1), ).setIndexNames((0, "ESI-MIB", "nwPortIndex"))
if mibBuilder.loadTexts: nwPortEntry.setStatus('optional')
if mibBuilder.loadTexts: nwPortEntry.setDescription('An entry of NetWare port specific information.')
nwPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 3, 2, 4, 10, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwPortIndex.setStatus('optional')
if mibBuilder.loadTexts: nwPortIndex.setDescription("A unique value for each physical output port. Its value ranges between 1 and the value of outputNumPorts. The value for each port must remain constant at least from one re-initialization of the entity's network management system to the next re-initialization.")
nwPortStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 3, 2, 4, 10, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwPortStatus.setStatus('optional')
if mibBuilder.loadTexts: nwPortStatus.setDescription('A string indicating the NetWare specific status of the physical output port.')
nwPortPrinterNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 3, 2, 4, 10, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwPortPrinterNumber.setStatus('optional')
if mibBuilder.loadTexts: nwPortPrinterNumber.setDescription('Indicates the printer number for the print server to use when running in RPRinter mode. A value of 255 indicates that the port is unconfigured for RPRinter mode. In order for changes to this variable to take effect, the print server must be reset. See cmdReset to do this.')
nwPortFontDownload = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 3, 2, 4, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disabled", 1), ("enabled-No-Power-Sense", 2), ("enabled-Power-Sense", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwPortFontDownload.setStatus('optional')
if mibBuilder.loadTexts: nwPortFontDownload.setDescription('This variable controls the font downloading feature of the print server. Disabled - Do not download fonts. Enabled, without Printer Sense - Only download fonts after the print server has been reset or power cycled. Enabled, with Printer Sense - Download fonts after the print server has been reset or power-cycled, or after the printer has been power-cycled. This option is only available on certain print servers. In order for changes to this variable to take effect, the print server must be reset. See cmdReset to do this.')
nwPortPCLQueue = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 3, 2, 4, 10, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 47))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwPortPCLQueue.setStatus('optional')
if mibBuilder.loadTexts: nwPortPCLQueue.setDescription('A string indicating the name of the queue containing the PCL fonts to download when font downloading is enabled. In order for changes to this variable to take effect, the print server must be reset. See cmdReset to do this.')
nwPortPSQueue = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 3, 2, 4, 10, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 47))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwPortPSQueue.setStatus('optional')
if mibBuilder.loadTexts: nwPortPSQueue.setDescription('A string indicating the name of the queue containing the PS fonts to download when font downloading is enabled. In order for changes to this variable to take effect, the print server must be reset. See cmdReset to do this.')
nwPortFormsOn = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 3, 2, 4, 10, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwPortFormsOn.setStatus('optional')
if mibBuilder.loadTexts: nwPortFormsOn.setDescription('A value of 2 will enable forms checking. In order for changes to this variable to take effect, the print server must be reset. See cmdReset to do this.')
nwPortFormNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 3, 2, 4, 10, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwPortFormNumber.setStatus('optional')
if mibBuilder.loadTexts: nwPortFormNumber.setDescription('Indicates the form number to check jobs against when nwPortFormsOn is enabled.')
nwPortNotification = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 3, 2, 4, 10, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwPortNotification.setStatus('optional')
if mibBuilder.loadTexts: nwPortNotification.setDescription('A value of 2 will enable job notification.')
nwNumTraps = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 2, 4, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwNumTraps.setStatus('mandatory')
if mibBuilder.loadTexts: nwNumTraps.setDescription('The number of IPX trap destinations.')
nwTrapTable = MibTable((1, 3, 6, 1, 4, 1, 683, 6, 3, 2, 4, 12), )
if mibBuilder.loadTexts: nwTrapTable.setStatus('mandatory')
if mibBuilder.loadTexts: nwTrapTable.setDescription('A list of IPX trap definitions. The number of entries is given by the value of nwNumTraps.')
nwTrapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 683, 6, 3, 2, 4, 12, 1), ).setIndexNames((0, "ESI-MIB", "nwTrapIndex"))
if mibBuilder.loadTexts: nwTrapEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nwTrapEntry.setDescription('An entry in the nwTrapTable.')
nwTrapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 3, 2, 4, 12, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwTrapIndex.setStatus('mandatory')
if mibBuilder.loadTexts: nwTrapIndex.setDescription('A unique value for entry in the nwTrapTable. Its value ranges between 1 and the value of nwNumTraps.')
nwTrapDestination = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 3, 2, 4, 12, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwTrapDestination.setStatus('optional')
if mibBuilder.loadTexts: nwTrapDestination.setDescription('This is the network address that IPX traps are sent to. A value of 00 00 00 00 00 00 in conjunction with a nwTrapDestinationNet of 00 00 00 00 will disable traps over IPX.')
nwTrapDestinationNet = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 3, 2, 4, 12, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwTrapDestinationNet.setStatus('mandatory')
if mibBuilder.loadTexts: nwTrapDestinationNet.setDescription('This is the network number that IPX traps are sent to. A value of 00 00 00 00 in conjunction with a nwTrapDestination of 00 00 00 00 00 00 will disable traps over IPX.')
nwProtocolTrapMask = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 3, 2, 4, 12, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwProtocolTrapMask.setStatus('optional')
if mibBuilder.loadTexts: nwProtocolTrapMask.setDescription('This is the 16 bit mask which determines which protocol specific traps will be sent out via IPX. Currently no protocol specific traps are supported.')
nwPrinterTrapMask = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 3, 2, 4, 12, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwPrinterTrapMask.setStatus('optional')
if mibBuilder.loadTexts: nwPrinterTrapMask.setDescription('This is the 16 bit mask which determines which printer specific traps will be sent out via IPX. A value of 65535 indicates that all printer specific traps should be reported via IPX. BIT CONDITION --- -------------------------- 0 On-line (Condition cleared) 1 Off-line 2 No printer attached 3 Toner Low 4 Paper Out 5 Paper Jam 6 Door Open 15 Printer Error')
nwOutputTrapMask = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 3, 2, 4, 12, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwOutputTrapMask.setStatus('optional')
if mibBuilder.loadTexts: nwOutputTrapMask.setDescription('This is the 16 bit mask which determines which physical output ports will be checked when generating printer specific traps to be sent out via IPX. A value of 65535 indicates that all physical output ports will generate traps. BIT CONDITION --- -------------------------- 0 Port 1 1 Port 2 2 Port 3 3 Port 4 ... ...')
nwNDSPrintServerName = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 2, 4, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 512))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwNDSPrintServerName.setStatus('optional')
if mibBuilder.loadTexts: nwNDSPrintServerName.setDescription('Directory Services object used by the print server to connect to the NDS tree. This string contains the entire canonicalized name. NOTE: This variable must be stored in Unicode.')
nwNDSPreferredDSTree = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 2, 4, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 47))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwNDSPreferredDSTree.setStatus('optional')
if mibBuilder.loadTexts: nwNDSPreferredDSTree.setDescription('Directory Services tree to which the NDS print server initially connects.')
nwNDSPreferredDSFileServer = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 2, 4, 15), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 47))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwNDSPreferredDSFileServer.setStatus('optional')
if mibBuilder.loadTexts: nwNDSPreferredDSFileServer.setDescription('The NetWare server to which the NDS print server initially makes a bindery connection.')
nwNDSPacketCheckSumEnabled = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 2, 4, 16), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwNDSPacketCheckSumEnabled.setStatus('optional')
if mibBuilder.loadTexts: nwNDSPacketCheckSumEnabled.setDescription('Compute the checksum for packets. 1 = disabled 2 = enabled')
nwNDSPacketSignatureLevel = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 2, 4, 17), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwNDSPacketSignatureLevel.setStatus('optional')
if mibBuilder.loadTexts: nwNDSPacketSignatureLevel.setDescription('Packet signature is a security method to prevent packet forging. 1 = disabled 2 = enabled 3 = preferred 4 = required')
nwAvailablePrintModes = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 2, 4, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAvailablePrintModes.setStatus('optional')
if mibBuilder.loadTexts: nwAvailablePrintModes.setDescription('Reports which NetWare print modes are available. BIT CONDITION --- -------------------------- 0 PServer 1 RPrinter 2 NDS 3 SPX Direct 4 JetAdmin ')
nwDirectPrintEnabled = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 2, 4, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwDirectPrintEnabled.setStatus('optional')
if mibBuilder.loadTexts: nwDirectPrintEnabled.setDescription('Indicates whether or not direct mode ipx/spx printing is enabled.')
nwJAConfig = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 2, 4, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwJAConfig.setStatus('optional')
if mibBuilder.loadTexts: nwJAConfig.setDescription('Indicates whether or not JetAdmin was used to configure the netware settings.')
nwDisableSAP = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 2, 4, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwDisableSAP.setStatus('optional')
if mibBuilder.loadTexts: nwDisableSAP.setDescription('Indicates whether or not SAPs are enabled.')
nwError = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 2, 5, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 160))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwError.setStatus('optional')
if mibBuilder.loadTexts: nwError.setDescription('Contains any NetWare specific error information.')
nwDisplayMask = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 2, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwDisplayMask.setStatus('mandatory')
if mibBuilder.loadTexts: nwDisplayMask.setDescription('Bit mask describing what should be displayed by the utilities bit Description --- ----------- 0 nwFrameFormat 1 nwJetAdmin 2 nwFileServer (Includes all file server info) 3 nwMode 4 nwPrintServerName 5 nwPrintServerPassword 6 nwQueueScanTime 7 nwNetworkNumber 8 nwPortStatus 9 nwPortPrinterNumber 10 nwPortFontDownload (Includes nwPortPCLQueue and nwPortPSQueue) 11 nwPortFormsOn (Includes nwPortFormsNumber) 12 nwPortNotification 13 nwTraps (Includes all trap info) 14 nwNDSPrintServerName 15 nwNDSPreferredDSTree 16 nwNDSPreferredDSFileServer 17 nwNDSPacketCheckSumEnabled 18 nwNDSPacketSignatureLevel 19 nwDirectPrintEnabled 20 nwError 21 nwSapDisable')
bvGroupVersion = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 3, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bvGroupVersion.setStatus('mandatory')
if mibBuilder.loadTexts: bvGroupVersion.setDescription('The version for the vines group.')
bvEnabled = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 3, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bvEnabled.setStatus('optional')
if mibBuilder.loadTexts: bvEnabled.setDescription('Indicates whether or not the Banyan VINES protocol stack is enabled on the print server.')
bvRestoreDefaults = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 3, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bvRestoreDefaults.setStatus('optional')
if mibBuilder.loadTexts: bvRestoreDefaults.setDescription('A value of 2 will restore all VINES parameters on the print server to factory defaults, as well as reset the device.')
bvFirmwareUpgrade = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 3, 3, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bvFirmwareUpgrade.setStatus('optional')
if mibBuilder.loadTexts: bvFirmwareUpgrade.setDescription('A value of 2 will put the print server into firmware upgrade mode.')
bvSetSequenceRouting = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 3, 3, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("automatic-Routing", 1), ("force-Sequenced-Routing", 2), ("force-Non-Sequenced-Routing", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bvSetSequenceRouting.setStatus('optional')
if mibBuilder.loadTexts: bvSetSequenceRouting.setDescription('Sets the VINES Routing selection. Automatic - Utilizes Sequenced Routing if available, otherwise uses Non-Sequenced Routing. Force-Sequenced - Will only use Sequenced Routing. Force-Non-Sequenced - Will only use Non-Sequenced Routing In order for changes to this variable to take effect, the print server must be reset. See cmdReset to do this. WARNING - Sequential Routing requires a VINES 5.5 or greater server on the same subnet.')
bvDisableVPMan = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 3, 3, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bvDisableVPMan.setStatus('optional')
if mibBuilder.loadTexts: bvDisableVPMan.setDescription('A value of 2 will disable VPMan access to the print server for one minute.')
bvLoginName = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 3, 4, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(5, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bvLoginName.setStatus('optional')
if mibBuilder.loadTexts: bvLoginName.setDescription('The StreetTalk name the device will use to login with. This value will be ESIxxxxxxxx where xxxxxxx is the Serial number of the device if it is unconfigured. In order for changes to this variable to take effect, the print server must be reset. See cmdReset to do this.')
bvLoginPassword = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 3, 4, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bvLoginPassword.setStatus('optional')
if mibBuilder.loadTexts: bvLoginPassword.setDescription('The password for the login name, bvLoginName. This value cannot be read, just set. In order for changes to this variable to take effect, the print server must be reset. See cmdReset to do this.')
bvNumberPrintServices = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 3, 4, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bvNumberPrintServices.setStatus('optional')
if mibBuilder.loadTexts: bvNumberPrintServices.setDescription('The number of Print Services this device supports.')
bvPrintServiceTable = MibTable((1, 3, 6, 1, 4, 1, 683, 6, 3, 3, 4, 4), )
if mibBuilder.loadTexts: bvPrintServiceTable.setStatus('optional')
if mibBuilder.loadTexts: bvPrintServiceTable.setDescription('Table of Print Services for this device.')
bvPrintServiceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 683, 6, 3, 3, 4, 4, 1), ).setIndexNames((0, "ESI-MIB", "bvPrintServiceIndex"))
if mibBuilder.loadTexts: bvPrintServiceEntry.setStatus('optional')
if mibBuilder.loadTexts: bvPrintServiceEntry.setDescription('Print Services Table entry.')
bvPrintServiceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 3, 3, 4, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bvPrintServiceIndex.setStatus('optional')
if mibBuilder.loadTexts: bvPrintServiceIndex.setDescription('A unique value for each print service.')
bvPrintServiceName = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 3, 3, 4, 4, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bvPrintServiceName.setStatus('optional')
if mibBuilder.loadTexts: bvPrintServiceName.setDescription('The StreetTalk Name for this Print Service. In order for changes to this variable to take effect, the print server must be reset. See cmdReset to do this.')
bvPrintServiceRouting = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 3, 3, 4, 4, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bvPrintServiceRouting.setStatus('optional')
if mibBuilder.loadTexts: bvPrintServiceRouting.setDescription('The output port that the print service will print to. This value will range from 0 to the number of output ports, see outputNumPorts. In order for changes to this variable to take effect, the print server must be reset. See cmdReset to do this.')
bvPnicDescription = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 3, 4, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bvPnicDescription.setStatus('optional')
if mibBuilder.loadTexts: bvPnicDescription.setDescription('Contains the VINES PNIC description.')
bvError = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 3, 5, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 48))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bvError.setStatus('optional')
if mibBuilder.loadTexts: bvError.setDescription('Contains any VINES specific error information.')
bvRouting = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 3, 5, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 32766, 32767))).clone(namedValues=NamedValues(("sequenced-Routing", 1), ("non-Sequenced-Routing", 2), ("unknown-Routing", 32766), ("protocol-Disabled", 32767)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bvRouting.setStatus('optional')
if mibBuilder.loadTexts: bvRouting.setDescription('The current VINES Routing being used by the device.')
bvNumPrintServices = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 3, 5, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bvNumPrintServices.setStatus('optional')
if mibBuilder.loadTexts: bvNumPrintServices.setDescription('The number of Print Services this device supports.')
bvPrintServiceStatusTable = MibTable((1, 3, 6, 1, 4, 1, 683, 6, 3, 3, 5, 4), )
if mibBuilder.loadTexts: bvPrintServiceStatusTable.setStatus('optional')
if mibBuilder.loadTexts: bvPrintServiceStatusTable.setDescription("Table of Print Service Status Entry's.")
bvPrintServiceStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 683, 6, 3, 3, 5, 4, 1), ).setIndexNames((0, "ESI-MIB", "bvPSStatusIndex"))
if mibBuilder.loadTexts: bvPrintServiceStatusEntry.setStatus('optional')
if mibBuilder.loadTexts: bvPrintServiceStatusEntry.setDescription('Print Service Status Entry.')
bvPSStatusIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 3, 3, 5, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bvPSStatusIndex.setStatus('optional')
if mibBuilder.loadTexts: bvPSStatusIndex.setDescription('A unique value for each status entry.')
bvPSName = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 3, 3, 5, 4, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bvPSName.setStatus('optional')
if mibBuilder.loadTexts: bvPSName.setDescription('The StreetTalk Name for this Print Service.')
bvPSStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 3, 3, 5, 4, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 48))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bvPSStatus.setStatus('optional')
if mibBuilder.loadTexts: bvPSStatus.setDescription('Print Service Status.')
bvPSDestination = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 3, 3, 5, 4, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bvPSDestination.setStatus('optional')
if mibBuilder.loadTexts: bvPSDestination.setDescription('Port Destination for this print service.')
bvPrinterStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 3, 3, 5, 4, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bvPrinterStatus.setStatus('optional')
if mibBuilder.loadTexts: bvPrinterStatus.setDescription('Printer status for this Print Service.')
bvJobActive = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 3, 3, 5, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bvJobActive.setStatus('optional')
if mibBuilder.loadTexts: bvJobActive.setDescription('Whether there is a VINES job active for this print service.')
bvJobSource = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 3, 3, 5, 4, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bvJobSource.setStatus('optional')
if mibBuilder.loadTexts: bvJobSource.setDescription('The active print jobs source.')
bvJobTitle = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 3, 3, 5, 4, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bvJobTitle.setStatus('optional')
if mibBuilder.loadTexts: bvJobTitle.setDescription('The title of the active print job.')
bvJobSize = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 3, 3, 5, 4, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 9))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bvJobSize.setStatus('optional')
if mibBuilder.loadTexts: bvJobSize.setDescription('The size of the active print job.')
bvJobNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 3, 3, 5, 4, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bvJobNumber.setStatus('optional')
if mibBuilder.loadTexts: bvJobNumber.setDescription('The VINES job number of the active print job.')
lmGroupVersion = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 4, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lmGroupVersion.setStatus('mandatory')
if mibBuilder.loadTexts: lmGroupVersion.setDescription('The version for the lanManger group.')
lmEnabled = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 4, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lmEnabled.setStatus('optional')
if mibBuilder.loadTexts: lmEnabled.setDescription('Indicates whether or not the Lan Manager protocol stack is enabled on the print server. In order for changes to this variable to take effect, the print server must be reset. See cmdReset to do this.')
eTalkGroupVersion = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 5, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eTalkGroupVersion.setStatus('mandatory')
if mibBuilder.loadTexts: eTalkGroupVersion.setDescription('The version for the eTalk group.')
eTalkEnabled = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 5, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eTalkEnabled.setStatus('optional')
if mibBuilder.loadTexts: eTalkEnabled.setDescription('Indicates whether or not the EtherTalk protocol stack is enabled on the print server. In order for changes to this variable to take effect, the print server must be reset. See cmdReset to do this.')
eTalkRestoreDefaults = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 5, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eTalkRestoreDefaults.setStatus('optional')
if mibBuilder.loadTexts: eTalkRestoreDefaults.setDescription('A value of 2 will restore all EtherTalk parameters on the print server to factory defaults, as well as reset the print server.')
eTalkNetwork = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 5, 4, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: eTalkNetwork.setStatus('optional')
if mibBuilder.loadTexts: eTalkNetwork.setDescription('Indicates the EtherTalk network number that the print server is currently using.')
eTalkNode = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 5, 4, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: eTalkNode.setStatus('optional')
if mibBuilder.loadTexts: eTalkNode.setDescription('Indicates the EtherTalk node number that the print server is currently using.')
eTalkNumPorts = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 5, 4, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eTalkNumPorts.setStatus('optional')
if mibBuilder.loadTexts: eTalkNumPorts.setDescription('Indicates the number of physical output ports that are EtherTalk compatible.')
eTalkPortTable = MibTable((1, 3, 6, 1, 4, 1, 683, 6, 3, 5, 4, 4), )
if mibBuilder.loadTexts: eTalkPortTable.setStatus('optional')
if mibBuilder.loadTexts: eTalkPortTable.setDescription('A table of EtherTalk specific port configuration information.')
eTalkPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 683, 6, 3, 5, 4, 4, 1), ).setIndexNames((0, "ESI-MIB", "eTalkPortIndex"))
if mibBuilder.loadTexts: eTalkPortEntry.setStatus('optional')
if mibBuilder.loadTexts: eTalkPortEntry.setDescription('An entry of EtherTalk port specific information.')
eTalkPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 3, 5, 4, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eTalkPortIndex.setStatus('optional')
if mibBuilder.loadTexts: eTalkPortIndex.setDescription("A unique value for each physical output port which is compatible with EtherTalk. Its value ranges between 1 and the value of eTalkNumPorts. The value for each port must remain constant at least from one re-initialization of the entity's network management system to the next re-initialization.")
eTalkPortEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 3, 5, 4, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eTalkPortEnable.setStatus('optional')
if mibBuilder.loadTexts: eTalkPortEnable.setDescription('Indicates whether or not the physical output port is enabled to print via EtherTalk and will show up in the Chooser.')
eTalkName = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 3, 5, 4, 4, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eTalkName.setStatus('optional')
if mibBuilder.loadTexts: eTalkName.setDescription('This is the EtherTalk name for the print server.')
eTalkActiveName = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 3, 5, 4, 4, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: eTalkActiveName.setStatus('optional')
if mibBuilder.loadTexts: eTalkActiveName.setDescription('This is the EtherTalk name for the print server that is currently being used.')
eTalkType1 = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 3, 5, 4, 4, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eTalkType1.setStatus('optional')
if mibBuilder.loadTexts: eTalkType1.setDescription('Indicates the first EtherTalk type. This type is mandatory.')
eTalkType2 = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 3, 5, 4, 4, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eTalkType2.setStatus('optional')
if mibBuilder.loadTexts: eTalkType2.setDescription('Indicates the second EtherTalk type. This type is optional. Setting this name to NULL will disable it.')
eTalkZone = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 3, 5, 4, 4, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eTalkZone.setStatus('optional')
if mibBuilder.loadTexts: eTalkZone.setDescription('Indicates the EtherTalk zone. This must be defined on the router.')
eTalkActiveZone = MibTableColumn((1, 3, 6, 1, 4, 1, 683, 6, 3, 5, 4, 4, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: eTalkActiveZone.setStatus('optional')
if mibBuilder.loadTexts: eTalkActiveZone.setDescription('Indicates the EtherTalk zone that is currently being used. This must be defined on the router.')
eTalkError = MibScalar((1, 3, 6, 1, 4, 1, 683, 6, 3, 5, 5, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: eTalkError.setStatus('optional')
if mibBuilder.loadTexts: eTalkError.setDescription('Shows any errors for the EtherTalk protocol.')
trapPrinterOnline = NotificationType((1, 3, 6, 1, 4, 1, 683, 6) + (0,1)).setObjects(("ESI-MIB", "outputIndex"))
if mibBuilder.loadTexts: trapPrinterOnline.setDescription('The printer is on-line. This trap will be sent out after a printer error condition has been cleared.')
trapPrinterOffline = NotificationType((1, 3, 6, 1, 4, 1, 683, 6) + (0,2)).setObjects(("ESI-MIB", "outputIndex"))
if mibBuilder.loadTexts: trapPrinterOffline.setDescription('The printer is off-line.')
trapNoPrinterAttached = NotificationType((1, 3, 6, 1, 4, 1, 683, 6) + (0,3)).setObjects(("ESI-MIB", "outputIndex"))
if mibBuilder.loadTexts: trapNoPrinterAttached.setDescription('No printer is attached to the output port.')
trapPrinterTonerLow = NotificationType((1, 3, 6, 1, 4, 1, 683, 6) + (0,4)).setObjects(("ESI-MIB", "outputIndex"))
if mibBuilder.loadTexts: trapPrinterTonerLow.setDescription('The printer toner is low.')
trapPrinterPaperOut = NotificationType((1, 3, 6, 1, 4, 1, 683, 6) + (0,5)).setObjects(("ESI-MIB", "outputIndex"))
if mibBuilder.loadTexts: trapPrinterPaperOut.setDescription('The printer is out of paper.')
trapPrinterPaperJam = NotificationType((1, 3, 6, 1, 4, 1, 683, 6) + (0,6)).setObjects(("ESI-MIB", "outputIndex"))
if mibBuilder.loadTexts: trapPrinterPaperJam.setDescription('The printer has a paper jam.')
trapPrinterDoorOpen = NotificationType((1, 3, 6, 1, 4, 1, 683, 6) + (0,7)).setObjects(("ESI-MIB", "outputIndex"))
if mibBuilder.loadTexts: trapPrinterDoorOpen.setDescription('The printer door is open.')
trapPrinterError = NotificationType((1, 3, 6, 1, 4, 1, 683, 6) + (0,16)).setObjects(("ESI-MIB", "outputIndex"))
if mibBuilder.loadTexts: trapPrinterError.setDescription('General printer error.')
mibBuilder.exportSymbols("ESI-MIB", eTalkNode=eTalkNode, bvPrintServiceRouting=bvPrintServiceRouting, nwPortNotification=nwPortNotification, outputDisplayMask=outputDisplayMask, tcpipBootProtocolsEnabled=tcpipBootProtocolsEnabled, bvStatus=bvStatus, nwNDSPreferredDSFileServer=nwNDSPreferredDSFileServer, bvGroupVersion=bvGroupVersion, nwMaxFileServers=nwMaxFileServers, bvEnabled=bvEnabled, trCommands=trCommands, tcpipSecureStartIPAddress=tcpipSecureStartIPAddress, nwTrapDestination=nwTrapDestination, trapPrinterOffline=trapPrinterOffline, tcpipError=tcpipError, driverRXPacketErrors=driverRXPacketErrors, lmGroupVersion=lmGroupVersion, general=general, genVersion=genVersion, outputNumLogEntries=outputNumLogEntries, driverTXPacketRetries=driverTXPacketRetries, tcpipNumSecurity=tcpipNumSecurity, genProtocolIndex=genProtocolIndex, cmdRestoreDefaults=cmdRestoreDefaults, eTalkName=eTalkName, tcpipIPAddressSource=tcpipIPAddressSource, esiSNMP=esiSNMP, tcpipSmtpEmailAddr=tcpipSmtpEmailAddr, nwQueueScanTime=nwQueueScanTime, trapPrinterPaperJam=trapPrinterPaperJam, nwPortTable=nwPortTable, tcpipSmtpPrinterMask=tcpipSmtpPrinterMask, tcpipWinsAddress=tcpipWinsAddress, nwGroupVersion=nwGroupVersion, nwEnabled=nwEnabled, nwMode=nwMode, genCableType=genCableType, outputHandshake=outputHandshake, tcpipPOP3ServerAddress=tcpipPOP3ServerAddress, nwConfigure=nwConfigure, outputJobLogTable=outputJobLogTable, nwStatus=nwStatus, bvJobActive=bvJobActive, eTalkActiveZone=eTalkActiveZone, eTalkZone=eTalkZone, nwFileServerTable=nwFileServerTable, eTalkPortEntry=eTalkPortEntry, trRestoreDefaults=trRestoreDefaults, outputEntry=outputEntry, snmpTrapCommunityName=snmpTrapCommunityName, outputExtendedStatus=outputExtendedStatus, tcpipWebUpdateURL=tcpipWebUpdateURL, eTalkError=eTalkError, outputTable=outputTable, outputBIDIStatusEnabled=outputBIDIStatusEnabled, tcpipOutputTrapMask=tcpipOutputTrapMask, tcpipMLPPort=tcpipMLPPort, eTalkEnabled=eTalkEnabled, eTalkRestoreDefaults=eTalkRestoreDefaults, trRouting=trRouting, outputCommandsEntry=outputCommandsEntry, tcpipSecurityEntry=tcpipSecurityEntry, tcpipPOP3PollInterval=tcpipPOP3PollInterval, nwDisplayMask=nwDisplayMask, cmdGroupVersion=cmdGroupVersion, trapPrinterPaperOut=trapPrinterPaperOut, psOutput=psOutput, nwOutputTrapMask=nwOutputTrapMask, lanManager=lanManager, nwTrapIndex=nwTrapIndex, tcpip=tcpip, bvPnicDescription=bvPnicDescription, outputCommands=outputCommands, tcpipSubnetMask=tcpipSubnetMask, tcpipWinsAddressSource=tcpipWinsAddressSource, tcpipWebAdminName=tcpipWebAdminName, genProtocolTable=genProtocolTable, driverTXPacketErrors=driverTXPacketErrors, bvPrinterStatus=bvPrinterStatus, tcpipTrapEntry=tcpipTrapEntry, tcpipTrapDestination=tcpipTrapDestination, eTalkPortIndex=eTalkPortIndex, outputTotalJobsLogged=outputTotalJobsLogged, outputNumPorts=outputNumPorts, bvLoginName=bvLoginName, vines=vines, trConfigure=trConfigure, tcpipSmtpProtocolMask=tcpipSmtpProtocolMask, lmEnabled=lmEnabled, psGroupVersion=psGroupVersion, tcpipSecurePrinterMask=tcpipSecurePrinterMask, tcpipDomainName=tcpipDomainName, trapNoPrinterAttached=trapNoPrinterAttached, outputPCLString=outputPCLString, outputCommandsTable=outputCommandsTable, nwNDSPacketSignatureLevel=nwNDSPacketSignatureLevel, bvJobSize=bvJobSize, tcpipWebUserPassword=tcpipWebUserPassword, eTalkConfigure=eTalkConfigure, bvConfigure=bvConfigure, tcpipNumLogicalPrinters=tcpipNumLogicalPrinters, outputDataBits=outputDataBits, nwSetFrameFormat=nwSetFrameFormat, outputIndex=outputIndex, eTalkStatus=eTalkStatus, outputProtocolManager=outputProtocolManager, nwJAConfig=nwJAConfig, tokenRing=tokenRing, tcpipNumTraps=tcpipNumTraps, psJetAdminEnabled=psJetAdminEnabled, tcpipMLPIndex=tcpipMLPIndex, genCompanyLoc=genCompanyLoc, nwTrapDestinationNet=nwTrapDestinationNet, nwPortFormsOn=nwPortFormsOn, genSysUpTimeString=genSysUpTimeString, tcpipMLPPostString=tcpipMLPPostString, tcpipSecurityIndex=tcpipSecurityIndex, tcpipWebHtttpPort=tcpipWebHtttpPort, tcpipPrinterTrapMask=tcpipPrinterTrapMask, nwPortPrinterNumber=nwPortPrinterNumber, nwTrapTable=nwTrapTable, bvSetSequenceRouting=bvSetSequenceRouting, bvLoginPassword=bvLoginPassword, genProtocolID=genProtocolID, eTalkGroupVersion=eTalkGroupVersion, outputBaudRate=outputBaudRate, tcpipWebAdminPassword=tcpipWebAdminPassword, outputStatus=outputStatus, outputPrinterModel=outputPrinterModel, outputParity=outputParity, trGroupVersion=trGroupVersion, genProductNumber=genProductNumber, outputTotalJobIndex=outputTotalJobIndex, outputPSString=outputPSString, nwPortIndex=nwPortIndex, trapPrinterError=trapPrinterError, nwNDSPacketCheckSumEnabled=nwNDSPacketCheckSumEnabled, nwPortFontDownload=nwPortFontDownload, genCompanyName=genCompanyName, cmdPrintConfig=cmdPrintConfig, outputCascaded=outputCascaded, outputConfigure=outputConfigure, bvPSName=bvPSName, outputStopBits=outputStopBits, outputTotalJobEntry=outputTotalJobEntry, tcpipSmtpIndex=tcpipSmtpIndex, nwPrinterTrapMask=nwPrinterTrapMask, tcpipWebFaqURL=tcpipWebFaqURL, outputCapabilities=outputCapabilities, printServers=printServers, outputCancelCurrentJob=outputCancelCurrentJob, driver=driver, tcpipRawPortNumber=tcpipRawPortNumber, tcpipWebUserName=tcpipWebUserName, nwNDSPreferredDSTree=nwNDSPreferredDSTree, tcpipMLPDeleteBytes=tcpipMLPDeleteBytes, tcpipTrapIndex=tcpipTrapIndex, tcpipEnabled=tcpipEnabled, tcpipSmtpEntry=tcpipSmtpEntry, psProtocols=psProtocols, driverRXPacketsUnavailable=driverRXPacketsUnavailable, tcpipMLPTable=tcpipMLPTable, nwDisableSAP=nwDisableSAP, bvPrintServiceStatusEntry=bvPrintServiceStatusEntry, esi=esi, genMIBVersion=genMIBVersion, tcpipWebCustomLinkName=tcpipWebCustomLinkName, eTalkPortTable=eTalkPortTable, bvNumPrintServices=bvNumPrintServices, tcpipSecurityTable=tcpipSecurityTable, nwPrintServerName=nwPrintServerName, eTalkType1=eTalkType1, tcpipPOP3Password=tcpipPOP3Password, nwNumTraps=nwNumTraps, outputJobLog=outputJobLog, tcpipDefaultGateway=tcpipDefaultGateway, nwTrapEntry=nwTrapEntry, netware=netware, tcpipMLPEntry=tcpipMLPEntry, genProtocolEntry=genProtocolEntry, trPriority=trPriority, bvPrintServiceStatusTable=bvPrintServiceStatusTable, snmpRestoreDefaults=snmpRestoreDefaults, tcpipConfigPassword=tcpipConfigPassword, nwPortEntry=nwPortEntry, tcpipCommands=tcpipCommands, driverRXPackets=driverRXPackets, tcpipLowBandwidth=tcpipLowBandwidth, bvPSDestination=bvPSDestination, nwDirectPrintEnabled=nwDirectPrintEnabled, tcpipRestoreDefaults=tcpipRestoreDefaults, tcpipGroupVersion=tcpipGroupVersion, tcpipSecureAdminEnabled=tcpipSecureAdminEnabled, outputGroupVersion=outputGroupVersion, tcpipTimeoutChecking=tcpipTimeoutChecking, trapPrinterDoorOpen=trapPrinterDoorOpen, tcpipTimeoutCheckingValue=tcpipTimeoutCheckingValue, nwFileServerName=nwFileServerName, tcpipMLPPreString=tcpipMLPPreString, outputJobLogInformation=outputJobLogInformation, snmpGroupVersion=snmpGroupVersion, tcpipSecureEndIPAddress=tcpipSecureEndIPAddress, nwPortPCLQueue=nwPortPCLQueue, tcpipIPAddress=tcpipIPAddress, bvPSStatus=bvPSStatus, genProtocolDescr=genProtocolDescr, outputAvailableTrapsMask=outputAvailableTrapsMask, driverTXPackets=driverTXPackets, nwFileServerIndex=nwFileServerIndex, nwPortStatus=nwPortStatus, outputConfigLanguage=outputConfigLanguage, tcpipTrapTable=tcpipTrapTable, trapPrinterOnline=trapPrinterOnline, nwFileServerConnectionStatus=nwFileServerConnectionStatus, eTalkNetwork=eTalkNetwork, trEarlyTokenRelease=trEarlyTokenRelease, nwPortPSQueue=nwPortPSQueue, eTalkCommands=eTalkCommands, genDateCode=genDateCode, bvJobTitle=bvJobTitle, genConfigurationDirty=genConfigurationDirty, psVerifyConfiguration=psVerifyConfiguration, tcpipUsingNetProtocols=tcpipUsingNetProtocols, tcpipStatus=tcpipStatus, psGeneral=psGeneral, genNumProtocols=genNumProtocols, bvRouting=bvRouting, bvCommands=bvCommands, driverGroupVersion=driverGroupVersion, genGroupVersion=genGroupVersion, cmdReset=cmdReset, tcpipArpInterval=tcpipArpInterval, nwNetworkNumber=nwNetworkNumber, bvNumberPrintServices=bvNumberPrintServices, bvJobSource=bvJobSource, tcpipWebCustomLinkURL=tcpipWebCustomLinkURL, nwCommands=nwCommands, nwAvailablePrintModes=nwAvailablePrintModes, tcpipFirmwareUpgrade=tcpipFirmwareUpgrade, eTalkNumPorts=eTalkNumPorts, tcpipIPAddressServerAddress=tcpipIPAddressServerAddress, bvPrintServiceIndex=bvPrintServiceIndex, genHWAddress=genHWAddress, genCompanyPhone=genCompanyPhone, bvPrintServiceEntry=bvPrintServiceEntry, eTalkType2=eTalkType2, tcpipMLPName=tcpipMLPName, bvRestoreDefaults=bvRestoreDefaults, tcpipBanners=tcpipBanners, tcpipPOP3UserName=tcpipPOP3UserName, genSerialNumber=genSerialNumber, bvError=bvError, outputLanguageSwitching=outputLanguageSwitching, bvPrintServiceName=bvPrintServiceName)
mibBuilder.exportSymbols("ESI-MIB", tcpipDisplayMask=tcpipDisplayMask, nwProtocolTrapMask=nwProtocolTrapMask, nwPrintServerPassword=nwPrintServerPassword, bvFirmwareUpgrade=bvFirmwareUpgrade, bvJobNumber=bvJobNumber, outputJobLogEntry=outputJobLogEntry, outputJobLogTime=outputJobLogTime, nwNDSPrintServerName=nwNDSPrintServerName, tcpipMLPTCPPort=tcpipMLPTCPPort, trapPrinterTonerLow=trapPrinterTonerLow, driverChecksumErrors=driverChecksumErrors, trLocallyAdminAddr=trLocallyAdminAddr, tcpipConfigure=tcpipConfigure, nwRestoreDefaults=nwRestoreDefaults, bvPSStatusIndex=bvPSStatusIndex, tcpipNumSmtpDestinations=tcpipNumSmtpDestinations, outputName=outputName, outputStatusString=outputStatusString, tcpipProtocolTrapMask=tcpipProtocolTrapMask, genProductName=genProductName, bvPrintServiceTable=bvPrintServiceTable, eTalk=eTalk, eTalkActiveName=eTalkActiveName, outputPrinterDisplay=outputPrinterDisplay, commands=commands, genProtocols=genProtocols, nwFirmwareUpgrade=nwFirmwareUpgrade, tcpipSmtpServerAddr=tcpipSmtpServerAddr, outputRestoreDefaults=outputRestoreDefaults, outputSetting=outputSetting, outputOwner=outputOwner, nwFrameFormat=nwFrameFormat, nwError=nwError, nwPortFormNumber=nwPortFormNumber, genCompanyTechSupport=genCompanyTechSupport, nwFileServerEntry=nwFileServerEntry, bvDisableVPMan=bvDisableVPMan, eTalkPortEnable=eTalkPortEnable, esiSNMPCommands=esiSNMPCommands, snmpGetCommunityName=snmpGetCommunityName, tcpipSmtpOutputMask=tcpipSmtpOutputMask, trPacketSize=trPacketSize, outputTotalJobTable=outputTotalJobTable, tcpipSmtpTable=tcpipSmtpTable, outputPrinter=outputPrinter, snmpSetCommunityName=snmpSetCommunityName)

#
# PySNMP MIB module CISCO-IETF-PW-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-IETF-PW-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:00:49 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, SingleValueConstraint, ValueRangeConstraint, ConstraintsUnion, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "SingleValueConstraint", "ValueRangeConstraint", "ConstraintsUnion", "ConstraintsIntersection")
CpwVcIndexType, CpwOperStatus, CpwVcIDType, CpwVcType, CpwGroupID = mibBuilder.importSymbols("CISCO-IETF-PW-TC-MIB", "CpwVcIndexType", "CpwOperStatus", "CpwVcIDType", "CpwVcType", "CpwGroupID")
ciscoExperiment, = mibBuilder.importSymbols("CISCO-SMI", "ciscoExperiment")
InetAddressType, InetAddress = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressType", "InetAddress")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
NotificationGroup, ObjectGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ObjectGroup", "ModuleCompliance")
MibIdentifier, Integer32, experimental, IpAddress, ObjectIdentity, Gauge32, Counter64, NotificationType, Unsigned32, ModuleIdentity, TimeTicks, Bits, MibScalar, MibTable, MibTableRow, MibTableColumn, iso, Counter32 = mibBuilder.importSymbols("SNMPv2-SMI", "MibIdentifier", "Integer32", "experimental", "IpAddress", "ObjectIdentity", "Gauge32", "Counter64", "NotificationType", "Unsigned32", "ModuleIdentity", "TimeTicks", "Bits", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "iso", "Counter32")
TruthValue, TextualConvention, TimeStamp, RowStatus, StorageType, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TruthValue", "TextualConvention", "TimeStamp", "RowStatus", "StorageType", "DisplayString")
cpwVcMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 10, 106))
cpwVcMIB.setRevisions(('2004-03-17 12:00', '2003-02-26 12:00', '2002-05-26 12:00', '2002-01-30 12:00', '2001-11-07 12:00', '2001-07-11 12:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: cpwVcMIB.setRevisionsDescriptions(('1) Added notifications group: -cpwVcUpDownNotifEnable -cpwVcNotifRate -cpwVcDown -cpwVcUp 2) Added CANA OID value ciscoExperiment.106 3) updated based on MIB police comments -replaced un-cisco-ized variable names w/ cisco-ized names in descriptions (e.g. pwVcxxx replaced w/ cpwVcxxx) ', 'Made Cisco proprietary based on the PW-MIB.my file extracted from draft-ietf-pwe3-pw-mib-00.txt ', 'Moved to draft-ietf-00 status. Changes from previous draft: 1) Change name of pwVcPriority to pwVcSetUpPriority and added pwVcHoldingPriority. 2) Add pwVcIdMappingTable and pwVcPeersMappingTable to help ordered query of the MIB tables for EMS applications. 3) Clarification to work in progress objects. 4) Editorial and typos in descriptions. 5) Added pwVcPerfTotalDiscontinuityTime and pwVcPerfIntervalTimeElapsed. 6) Remove 32 bit counters. ', ' Changes from -01 draft: 1) Inbound and outbound clarification and name changes. 2) Removing pwVcPeerIpv4Addr and pwVcPeerIpv6Addr, replacing them with pwVcPeerAddr and adding type for address type selection. 3) Adding type for VC OperStatus. 4) Adding pwVcTimeElapsed and pwVcValidIntervals. ', "Changes from -00 draft: 1) Remove VcInstance from tables indexes in order to simplify the MIB. 2) Removing APS 1+1 table. 3) Changing hdlcCisco to hdlc in pwVcType. 4) Add description of VC label at pending PW signaling stage. 5) Add interval valid object in interval performance tables. 6) Remove VC APS notification. 7) Change 'conservative'/'liberal' to 'strict'/'loose'. 8) Add objects for interface MTU, use of control word, interface string. 9) Ordering of objects based on functionality. 10) Update operation of pwVcOperStatus. ", 'draft-00 version',))
if mibBuilder.loadTexts: cpwVcMIB.setLastUpdated('200403171200Z')
if mibBuilder.loadTexts: cpwVcMIB.setOrganization('Cisco Systems, Inc.')
if mibBuilder.loadTexts: cpwVcMIB.setContactInfo(' Thomas D. Nadeau Postal: Cisco Systems, Inc. 250 Apollo Drive Chelmsford, MA 01824 Tel: +1-978-497-3051 Email: tnadeau@cisco.com MPLS MIB Development Team Postal: Cisco Systems, Inc. 250 Apollo Drive Chelmsford, MA 01924 Tel: +1-978-497-3989 Email: ch-mpls-mib-dev@cisco.com ')
if mibBuilder.loadTexts: cpwVcMIB.setDescription("This MIB contains managed object definitions for Pseudo Wire operation as in: Pate, P., et al, <draft-ietf-pwe3- framework>, Xiao, X., et al, <draft-ietf-pwe3- requirements>, Martini, L., et al, <draft-martini- l2circuit-trans-mpls>, and Martini, L., et al, <draft-martini-l2circuit-encap-mpls>. The indexes for this MIB are also used to index the PSN- specific tables and the VC-specific tables. The VC Type dictates which VC-specific MIB to use. For example, a 'cep' VC Type requires the use the configuration and status tables within the CEP-MIB. This MIB enable the use of any underlying packet switched network (PSN). Specific tables for the MPLS PSN is currently defined in a separate CISCO-IETF-PW-MPLS-MIB. Tables to support other PSNs (IP, L2TP for example) will be added to this MIB in future revisions. At the time of publication of this version, there are no PWE3 WG documents for all features and objects in this MIB, and the MIB is therefore subject to change based on the WG progress.")
cpwVcObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 106, 1))
cpwVcNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 106, 2))
cpwVcConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 106, 3))
cpwVcIndexNext = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpwVcIndexNext.setStatus('current')
if mibBuilder.loadTexts: cpwVcIndexNext.setDescription('This object contains an appropriate value to be used for cpwVcIndex when creating entries in the cpwVcTable. The value 0 indicates that no unassigned entries are available. To obtain the value of cpwVcIndex for a new entry in the cpwVcTable, the manager issues a management protocol retrieval operation to obtain the current value of cpwVcIndex. After each retrieval operation, the agent should modify the value to reflect the next unassigned index. After a manager retrieves a value the agent will determine through its local policy when this index value will be made available for reuse.')
cpwVcTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 2), )
if mibBuilder.loadTexts: cpwVcTable.setStatus('current')
if mibBuilder.loadTexts: cpwVcTable.setDescription('This table specifies information for connecting various emulated services to various tunnel type.')
cpwVcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 2, 1), ).setIndexNames((0, "CISCO-IETF-PW-MIB", "cpwVcIndex"))
if mibBuilder.loadTexts: cpwVcEntry.setStatus('current')
if mibBuilder.loadTexts: cpwVcEntry.setDescription('A row in this table represents an emulated virtual connection (VC) across a packet network. It is indexed by cpwVcIndex, which uniquely identifying a singular connection. ')
cpwVcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 2, 1, 1), CpwVcIndexType())
if mibBuilder.loadTexts: cpwVcIndex.setStatus('current')
if mibBuilder.loadTexts: cpwVcIndex.setDescription('Index for the conceptual row identifying a VC within this PW Emulation VC table.')
cpwVcType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 2, 1, 2), CpwVcType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpwVcType.setStatus('current')
if mibBuilder.loadTexts: cpwVcType.setDescription('This value indicate the service to be carried over this VC. Note: the exact set of VC types is yet to be worked out by the WG. ')
cpwVcOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("manual", 1), ("maintenanceProtocol", 2), ("other", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpwVcOwner.setStatus('current')
if mibBuilder.loadTexts: cpwVcOwner.setDescription("Set by the operator to indicate the protocol responsible for establishing this VC. Value 'manual' is used in all cases where no maintenance protocol (PW signaling) is used to set-up the VC, i.e. require configuration of entries in the VC tables including VC labels, etc. The value 'maintenanceProtocol' is used in case of standard signaling of the VC for the specific PSN, for example LDP for MPLS PSN as specified in <draft- draft-martini- l2circuit-trans-mpls> or L2TP control protocol. Value 'other' is used for other types of signaling.")
cpwVcPsnType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("mpls", 1), ("l2tp", 2), ("ip", 3), ("mplsOverIp", 4), ("gre", 5), ("other", 6)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpwVcPsnType.setStatus('current')
if mibBuilder.loadTexts: cpwVcPsnType.setDescription('Set by the operator to indicate the PSN type on which this VC will be carried. Based on this object, the relevant PSN table entries are created in the in the PSN specific MIB modules. For example, if mpls(1) is defined, the agent create an entry in cpwVcMplsTable, which further define the MPLS PSN configuration. Note: the exact set of PSN types is yet to be worked out by the WG. ')
cpwVcSetUpPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpwVcSetUpPriority.setStatus('current')
if mibBuilder.loadTexts: cpwVcSetUpPriority.setDescription("This object define the relative set-up priority of the VC in a lowest-to-highest fashion, where 0 is the highest priority. VCs with the same priority are treated with equal priority. Dropped VC will be set 'dormant' (as indicated in cpwVcOperStatus). This value is significant if there are competing resources between VCs and the implementation support this feature. If not supported or not relevant, the value of zero MUST be used.")
cpwVcHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpwVcHoldingPriority.setStatus('current')
if mibBuilder.loadTexts: cpwVcHoldingPriority.setDescription("This object define the relative holding priority of the VC in a lowest-to-highest fashion, where 0 is the highest priority. VCs with the same priority are treated with equal priority. Dropped VC will be set 'dormant' (as indicated in cpwVcOperStatus). This value is significant if there are competing resources between VCs and the implementation support this feature. If not supported or not relevant, the value of zero MUST be used.")
cpwVcInboundMode = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("loose", 1), ("strict", 2))).clone('loose')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpwVcInboundMode.setStatus('current')
if mibBuilder.loadTexts: cpwVcInboundMode.setDescription('This object is used to enable greater security for implementation that use per platform VC label space. In strict mode, packets coming from the PSN are accepted only from tunnels that are associated to the same VC via the inbound tunnel table in the case of MPLS, or as identified by the source IP address in case of L2TP or IP PSN. The entries in the inbound tunnel table are either explicitly configured or implicitly known by the maintenance protocol used for VC set-up. If such association is not known, not configured or not desired, loose mode should be configured, and the node should accept the packet based on the VC label only regardless of the outer tunnel used to carry the VC.')
cpwVcPeerAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 2, 1, 8), InetAddressType().clone('ipv4')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpwVcPeerAddrType.setStatus('current')
if mibBuilder.loadTexts: cpwVcPeerAddrType.setDescription("Denotes the address type of the peer node maintenance protocol (signaling) address if PW maintenance protocol is used for the VC creation. It should be set to 'unknown' if PE/PW maintenance protocol is not used, i.e. cpwVcOwner is set to 'manual'. ")
cpwVcPeerAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 2, 1, 9), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpwVcPeerAddr.setStatus('current')
if mibBuilder.loadTexts: cpwVcPeerAddr.setDescription('This object contains the value of of the peer node address of the PW/PE maintenance protocol entity. This object should contain a value of 0 if not relevant (manual configuration of the VC).')
cpwVcID = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 2, 1, 10), CpwVcIDType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpwVcID.setReference('Martini, et al, <draft-martini-l2circuit-trans-mpls>. and So, et al, <draft-so-pwe3-ethernet>. Note: as specified in l2circuit-trans: It is REQUIRED to assign the same VC ID, and VC type for a given circuit in both directions.')
if mibBuilder.loadTexts: cpwVcID.setStatus('current')
if mibBuilder.loadTexts: cpwVcID.setDescription("Used in the outgoing VC ID field within the 'Virtual Circuit FEC Element' when LDP signaling is used or PW ID AVP for L2TP.")
cpwVcLocalGroupID = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 2, 1, 11), CpwGroupID()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpwVcLocalGroupID.setReference('Martini, et al, <draft-martini-l2circuit-trans-mpls> and So, et al, <draft-so-pwe3-ethernet.txt>.')
if mibBuilder.loadTexts: cpwVcLocalGroupID.setStatus('current')
if mibBuilder.loadTexts: cpwVcLocalGroupID.setDescription('Used in the Group ID field sent to the peer PWES within the maintenance protocol used for VC setup, zero if not used.')
cpwVcControlWord = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 2, 1, 12), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpwVcControlWord.setReference('Martini, et al, <draft-martini-l2circuit-trans-mpls>')
if mibBuilder.loadTexts: cpwVcControlWord.setStatus('current')
if mibBuilder.loadTexts: cpwVcControlWord.setDescription('Define if the control word will be sent with each packet by the local node.')
cpwVcLocalIfMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 2, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpwVcLocalIfMtu.setReference('Martini, et al, <draft-martini-l2circuit-trans-mpls> and So, et al, <draft-so-pwe3-ethernet>.')
if mibBuilder.loadTexts: cpwVcLocalIfMtu.setStatus('current')
if mibBuilder.loadTexts: cpwVcLocalIfMtu.setDescription('If not equal zero, the optional IfMtu object in the maintenance protocol will be sent with this value, representing the locally supported MTU size over the interface (or the virtual interface) associated with the VC.')
cpwVcLocalIfString = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 2, 1, 14), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpwVcLocalIfString.setReference('Martini, et al, <draft-martini-l2circuit-trans-mpls> and So, et al, <draft-so-pwe3-ethernet.txt>.')
if mibBuilder.loadTexts: cpwVcLocalIfString.setStatus('current')
if mibBuilder.loadTexts: cpwVcLocalIfString.setDescription("Each VC is associated to an interface (or a virtual interface) in the ifTable of the node as part of the service configuration. This object defines if the maintenance protocol will send the interface's name as appears on the ifTable in the name object as part of the maintenance protocol. If set to false, the optional element will not be sent.")
cpwVcRemoteGroupID = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 2, 1, 15), CpwGroupID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpwVcRemoteGroupID.setReference('Martini, et al, <draft-martini-l2circuit-trans-mpls> and So, et al, <draft-so-pwe3-ethernet.txt>.')
if mibBuilder.loadTexts: cpwVcRemoteGroupID.setStatus('current')
if mibBuilder.loadTexts: cpwVcRemoteGroupID.setDescription('Obtained from the Group ID field as received via the maintenance protocol used for VC setup, zero if not used. Value of 0xFFFF shall be used if the object is yet to be defined by the VC maintenance protocol.')
cpwVcRemoteControlWord = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noControlWord", 1), ("withControlWord", 2), ("notYetKnown", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpwVcRemoteControlWord.setReference('Martini, et al, <draft-martini-l2circuit-trans-mpls> and So, et al, <draft-so-pwe3-ethernet.txt>.')
if mibBuilder.loadTexts: cpwVcRemoteControlWord.setStatus('current')
if mibBuilder.loadTexts: cpwVcRemoteControlWord.setDescription("If maintenance protocol is used for VC establishment, this parameter indicates the received status of the control word usage, i.e. if packets will be received with control word or not. The value of 'notYetKnown' is used while the maintenance protocol has not yet received the indication from the remote node. In manual configuration of the VC this parameters indicate to the local node what is the expected encapsulation for the received packets. ")
cpwVcRemoteIfMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 2, 1, 17), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpwVcRemoteIfMtu.setReference('Martini, et al, <draft-martini-l2circuit-trans-mpls> and So, et al, <draft-so-pwe3-ethernet.txt>.')
if mibBuilder.loadTexts: cpwVcRemoteIfMtu.setStatus('current')
if mibBuilder.loadTexts: cpwVcRemoteIfMtu.setDescription('The remote interface MTU as (optionally) received from the remote node via the maintenance protocol. Should be zero if this parameter is not available or not used.')
cpwVcRemoteIfString = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 2, 1, 18), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpwVcRemoteIfString.setReference('Martini, et al, <draft-martini-l2circuit-trans-mpls> and So, et al, <draft-so-pwe3-ethernet>.')
if mibBuilder.loadTexts: cpwVcRemoteIfString.setStatus('current')
if mibBuilder.loadTexts: cpwVcRemoteIfString.setDescription('Indicate the interface description string as received by the maintenance protocol, MUST be NULL string if not applicable or not known yet.')
cpwVcOutboundVcLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 2, 1, 19), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpwVcOutboundVcLabel.setReference('Martini, et al, <draft-martini-l2circuit-trans-mpls> Townsley, et al, <draft-ietf-l2tpext-l2tp-base.txt>')
if mibBuilder.loadTexts: cpwVcOutboundVcLabel.setStatus('current')
if mibBuilder.loadTexts: cpwVcOutboundVcLabel.setDescription("The VC label used in the outbound direction (i.e. toward the PSN). It may be set up manually if owner is 'manual' or automatically otherwise. Examples: For MPLS PSN, it represents the 20 bits of VC tag, for L2TP it represent the 32 bits Session ID. If the label is not yet known (signaling in process), the object should return a value of 0xFFFF.")
cpwVcInboundVcLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 2, 1, 20), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpwVcInboundVcLabel.setReference('Martini, et al, <draft-martini-l2circuit-trans-mpls> Townsley, et al, <draft-ietf-l2tpext-l2tp-base.txt>')
if mibBuilder.loadTexts: cpwVcInboundVcLabel.setStatus('current')
if mibBuilder.loadTexts: cpwVcInboundVcLabel.setDescription("The VC label used in the inbound direction (i.e. packets received from the PSN. It may be set up manually if owner is 'manual' or automatically otherwise. Examples: For MPLS PSN, it represents the 20 bits of VC tag, for L2TP it represent the 32 bits Session ID. If the label is not yet known (signaling in process), the object should return a value of 0xFFFF.")
cpwVcName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 2, 1, 21), SnmpAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpwVcName.setStatus('current')
if mibBuilder.loadTexts: cpwVcName.setDescription('The canonical name assigned to the VC.')
cpwVcDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 2, 1, 22), SnmpAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpwVcDescr.setStatus('current')
if mibBuilder.loadTexts: cpwVcDescr.setDescription('A textual string containing information about the VC. If there is no description this object contains a zero length string.')
cpwVcCreateTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 2, 1, 23), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpwVcCreateTime.setStatus('current')
if mibBuilder.loadTexts: cpwVcCreateTime.setDescription('System time when this VC was created.')
cpwVcUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 2, 1, 24), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpwVcUpTime.setStatus('current')
if mibBuilder.loadTexts: cpwVcUpTime.setDescription("Number of consecutive ticks this VC has been 'up' in both directions together (i.e. 'up' is observed in cpwVcOperStatus.)")
cpwVcAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 2, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpwVcAdminStatus.setStatus('current')
if mibBuilder.loadTexts: cpwVcAdminStatus.setDescription('The desired operational status of this VC.')
cpwVcOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 2, 1, 26), CpwOperStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpwVcOperStatus.setStatus('current')
if mibBuilder.loadTexts: cpwVcOperStatus.setDescription("Indicates the actual combined operational status of this VC. It is 'up' if both cpwVcInboundOperStatus and cpwVcOutboundOperStatus are in 'up' state. For all other values, if the VCs in both directions are of the same value it reflects that value, otherwise it is set to the most severe status out of the two statuses. The order of severance from most severe to less severe is: unknown, notPresent, down, lowerLayerDown, dormant, testing, up. The operator may consult the per direction OperStatus for fault isolation per direction.")
cpwVcInboundOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 2, 1, 27), CpwOperStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpwVcInboundOperStatus.setStatus('current')
if mibBuilder.loadTexts: cpwVcInboundOperStatus.setDescription("Indicates the actual operational status of this VC in the inbound direction. - down: if PW signaling has not yet finished, or indications available at the service level indicate that the VC is not passing packets. - testing: if AdminStatus at the VC level is set to test. - dormant: The VC is not available because of the required resources are occupied VC with higher priority VCs . - notPresent: Some component is missing to accomplish the set up of the VC. - lowerLayerDown: The underlying PSN is not in OperStatus 'up'. ")
cpwVcOutboundOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 2, 1, 28), CpwOperStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpwVcOutboundOperStatus.setStatus('current')
if mibBuilder.loadTexts: cpwVcOutboundOperStatus.setDescription("Indicates the actual operational status of this VC in the outbound direction - down: if PW signaling has not yet finished, or indications available at the service level indicate that the VC is not passing packets. - testing: if AdminStatus at the VC level is set to test. - dormant: The VC is not available because of the required resources are occupied VC with higher priority VCs . - notPresent: Some component is missing to accomplish the set up of the VC. - lowerLayerDown: The underlying PSN is not in OperStatus 'up'. ")
cpwVcTimeElapsed = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 2, 1, 29), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 900))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpwVcTimeElapsed.setStatus('current')
if mibBuilder.loadTexts: cpwVcTimeElapsed.setDescription("The number of seconds, including partial seconds, that have elapsed since the beginning of the current measurement period. If, for some reason, such as an adjustment in the system's time-of-day clock, the current interval exceeds the maximum value, the agent will return the maximum value.")
cpwVcValidIntervals = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 2, 1, 30), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 96))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpwVcValidIntervals.setStatus('current')
if mibBuilder.loadTexts: cpwVcValidIntervals.setDescription('The number of previous 15-minute intervals for which data was collected. An agent with PW capability must be capable of supporting at least n intervals. The minimum value of n is 4, The default of n is 32 and the maximum value of n is 96. The value will be <n> unless the measurement was (re-) started within the last (<n>*15) minutes, in which case the value will be the number of complete 15 minute intervals for which the agent has at least some data. In certain cases (e.g., in the case where the agent is a proxy) it is possible that some intervals are unavailable. In this case, this interval is the maximum interval number for which data is available. ')
cpwVcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 2, 1, 31), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpwVcRowStatus.setStatus('current')
if mibBuilder.loadTexts: cpwVcRowStatus.setDescription('For creating, modifying, and deleting this row.')
cpwVcStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 2, 1, 32), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpwVcStorageType.setStatus('current')
if mibBuilder.loadTexts: cpwVcStorageType.setDescription('This variable indicates the storage type for this object.')
cpwVcPerfCurrentTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 3), )
if mibBuilder.loadTexts: cpwVcPerfCurrentTable.setStatus('current')
if mibBuilder.loadTexts: cpwVcPerfCurrentTable.setDescription('This table provides per-VC performance information for the current interval.')
cpwVcPerfCurrentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 3, 1), ).setIndexNames((0, "CISCO-IETF-PW-MIB", "cpwVcIndex"))
if mibBuilder.loadTexts: cpwVcPerfCurrentEntry.setStatus('current')
if mibBuilder.loadTexts: cpwVcPerfCurrentEntry.setDescription('An entry in this table is created by the agent for every VC.')
cpwVcPerfCurrentInHCPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 3, 1, 1), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpwVcPerfCurrentInHCPackets.setStatus('current')
if mibBuilder.loadTexts: cpwVcPerfCurrentInHCPackets.setDescription('High capacity counter for number of packets received by the VC (from the PSN) in the current 15 minute interval.')
cpwVcPerfCurrentInHCBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 3, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpwVcPerfCurrentInHCBytes.setStatus('current')
if mibBuilder.loadTexts: cpwVcPerfCurrentInHCBytes.setDescription('High capacity counter for number of bytes received by the VC (from the PSN) in the current 15 minute interval.')
cpwVcPerfCurrentOutHCPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 3, 1, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpwVcPerfCurrentOutHCPackets.setStatus('current')
if mibBuilder.loadTexts: cpwVcPerfCurrentOutHCPackets.setDescription('High capacity counter for number of packets forwarded by the VC (to the PSN) in the current 15 minute interval.')
cpwVcPerfCurrentOutHCBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 3, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpwVcPerfCurrentOutHCBytes.setStatus('current')
if mibBuilder.loadTexts: cpwVcPerfCurrentOutHCBytes.setDescription('High capacity counter for number of bytes forwarded by the VC (to the PSN) in the current 15 minute interval.')
cpwVcPerfIntervalTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 4), )
if mibBuilder.loadTexts: cpwVcPerfIntervalTable.setStatus('current')
if mibBuilder.loadTexts: cpwVcPerfIntervalTable.setDescription('This table provides per-VC performance information for each interval.')
cpwVcPerfIntervalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 4, 1), ).setIndexNames((0, "CISCO-IETF-PW-MIB", "cpwVcIndex"), (0, "CISCO-IETF-PW-MIB", "cpwVcPerfIntervalNumber"))
if mibBuilder.loadTexts: cpwVcPerfIntervalEntry.setStatus('current')
if mibBuilder.loadTexts: cpwVcPerfIntervalEntry.setDescription('An entry in this table is created agent for every VC.')
cpwVcPerfIntervalNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 96)))
if mibBuilder.loadTexts: cpwVcPerfIntervalNumber.setReference("Tesink, K. 'Definitions of Managed Objects for the SONET/SDH Interface Type', RFC 2558")
if mibBuilder.loadTexts: cpwVcPerfIntervalNumber.setStatus('current')
if mibBuilder.loadTexts: cpwVcPerfIntervalNumber.setDescription('A number N, between 1 and 96, which identifies the interval for which the set of statistics is available. The interval identified by 1 is the most recently completed 15 minute interval, and the interval identified by N is the interval immediately preceding the one identified by N-1. The minimum range of N is 1 through 4. The default range is 1 to 32. The maximum range of N is 1 through 96. ')
cpwVcPerfIntervalValidData = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 4, 1, 2), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpwVcPerfIntervalValidData.setStatus('current')
if mibBuilder.loadTexts: cpwVcPerfIntervalValidData.setDescription('This variable indicates if the data for this interval is valid.')
cpwVcPerfIntervalTimeElapsed = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 4, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpwVcPerfIntervalTimeElapsed.setStatus('current')
if mibBuilder.loadTexts: cpwVcPerfIntervalTimeElapsed.setDescription("The duration of a particular interval in seconds. Adjustments in the system's time-of-day clock, may cause the interval to be greater or less than the normal value. Therefore this actual interval value is provided.")
cpwVcPerfIntervalInHCPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 4, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpwVcPerfIntervalInHCPackets.setStatus('current')
if mibBuilder.loadTexts: cpwVcPerfIntervalInHCPackets.setDescription('High capacity counter for number of packets received by the VC (from the PSN) in a particular 15-minute interval.')
cpwVcPerfIntervalInHCBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 4, 1, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpwVcPerfIntervalInHCBytes.setStatus('current')
if mibBuilder.loadTexts: cpwVcPerfIntervalInHCBytes.setDescription('High capacity counter for number of bytes received by the VC (from the PSN) in a particular 15-minute interval.')
cpwVcPerfIntervalOutHCPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 4, 1, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpwVcPerfIntervalOutHCPackets.setStatus('current')
if mibBuilder.loadTexts: cpwVcPerfIntervalOutHCPackets.setDescription('High capacity counter for number of packets forwarded by the VC (to the PSN) in a particular 15-minute interval.')
cpwVcPerfIntervalOutHCBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 4, 1, 7), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpwVcPerfIntervalOutHCBytes.setStatus('current')
if mibBuilder.loadTexts: cpwVcPerfIntervalOutHCBytes.setDescription('High capacity counter for number of bytes forwarded by the VC (to the PSN) in a particular 15-minute interval.')
cpwVcPerfTotalTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 5), )
if mibBuilder.loadTexts: cpwVcPerfTotalTable.setStatus('current')
if mibBuilder.loadTexts: cpwVcPerfTotalTable.setDescription('This table provides per-VC Performance information from VC start time.')
cpwVcPerfTotalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 5, 1), ).setIndexNames((0, "CISCO-IETF-PW-MIB", "cpwVcIndex"))
if mibBuilder.loadTexts: cpwVcPerfTotalEntry.setStatus('current')
if mibBuilder.loadTexts: cpwVcPerfTotalEntry.setDescription('An entry in this table is created agent for every VC.')
cpwVcPerfTotalInHCPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 5, 1, 1), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpwVcPerfTotalInHCPackets.setStatus('current')
if mibBuilder.loadTexts: cpwVcPerfTotalInHCPackets.setDescription('High capacity counter for number of packets received by the VC (from the PSN).')
cpwVcPerfTotalInHCBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 5, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpwVcPerfTotalInHCBytes.setStatus('current')
if mibBuilder.loadTexts: cpwVcPerfTotalInHCBytes.setDescription('High capacity counter for number of bytes received by the VC (from the PSN).')
cpwVcPerfTotalOutHCPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 5, 1, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpwVcPerfTotalOutHCPackets.setStatus('current')
if mibBuilder.loadTexts: cpwVcPerfTotalOutHCPackets.setDescription('High capacity counter for number of packets forwarded by the VC (to the PSN).')
cpwVcPerfTotalOutHCBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 5, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpwVcPerfTotalOutHCBytes.setStatus('current')
if mibBuilder.loadTexts: cpwVcPerfTotalOutHCBytes.setDescription('High capacity counter for number of bytes forwarded by the VC (to the PSN).')
cpwVcPerfTotalDiscontinuityTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 5, 1, 5), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpwVcPerfTotalDiscontinuityTime.setStatus('current')
if mibBuilder.loadTexts: cpwVcPerfTotalDiscontinuityTime.setDescription('The value of sysUpTime on the most recent occasion at which any one or more of this row Counter32 or Counter64 suffered a discontinuity. If no such discontinuities have occurred since the last re- initialization of the local management subsystem, then this object contains a zero value.')
cpwVcPerfTotalErrorPackets = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpwVcPerfTotalErrorPackets.setStatus('current')
if mibBuilder.loadTexts: cpwVcPerfTotalErrorPackets.setDescription('Counter for number of error at VC level processing, for example packets received with unknown VC label.')
cpwVcIdMappingTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 7), )
if mibBuilder.loadTexts: cpwVcIdMappingTable.setStatus('current')
if mibBuilder.loadTexts: cpwVcIdMappingTable.setDescription('This table provides reverse mapping of the existing VCs based on vc type and VC ID ordering. This table is typically useful for EMS ordered query of existing VCs.')
cpwVcIdMappingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 7, 1), ).setIndexNames((0, "CISCO-IETF-PW-MIB", "cpwVcIdMappingVcType"), (0, "CISCO-IETF-PW-MIB", "cpwVcIdMappingVcID"), (0, "CISCO-IETF-PW-MIB", "cpwVcIdMappingPeerAddrType"), (0, "CISCO-IETF-PW-MIB", "cpwVcIdMappingPeerAddr"), (0, "CISCO-IETF-PW-MIB", "cpwVcIdMappingVcIndex"))
if mibBuilder.loadTexts: cpwVcIdMappingEntry.setStatus('current')
if mibBuilder.loadTexts: cpwVcIdMappingEntry.setDescription('An entry in this table is created by the agent for every VC configured by the cpwVcTable.')
cpwVcIdMappingVcType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 7, 1, 1), CpwVcType())
if mibBuilder.loadTexts: cpwVcIdMappingVcType.setStatus('current')
if mibBuilder.loadTexts: cpwVcIdMappingVcType.setDescription('The VC type (indicate the service) of this VC.')
cpwVcIdMappingVcID = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 7, 1, 2), CpwVcIDType())
if mibBuilder.loadTexts: cpwVcIdMappingVcID.setStatus('current')
if mibBuilder.loadTexts: cpwVcIdMappingVcID.setDescription('The VC ID of this VC. Zero if the VC is configured manually.')
cpwVcIdMappingPeerAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 7, 1, 3), InetAddressType())
if mibBuilder.loadTexts: cpwVcIdMappingPeerAddrType.setStatus('current')
if mibBuilder.loadTexts: cpwVcIdMappingPeerAddrType.setDescription('IP address type of the peer node.')
cpwVcIdMappingPeerAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 7, 1, 4), InetAddress())
if mibBuilder.loadTexts: cpwVcIdMappingPeerAddr.setStatus('current')
if mibBuilder.loadTexts: cpwVcIdMappingPeerAddr.setDescription('IP address type of the peer node.')
cpwVcIdMappingVcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 7, 1, 5), CpwVcIndexType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpwVcIdMappingVcIndex.setStatus('current')
if mibBuilder.loadTexts: cpwVcIdMappingVcIndex.setDescription('The value that represent the VC in the cpwVcTable.')
cpwVcPeerMappingTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 8), )
if mibBuilder.loadTexts: cpwVcPeerMappingTable.setStatus('current')
if mibBuilder.loadTexts: cpwVcPeerMappingTable.setDescription('This table provides reverse mapping of the existing VCs based on vc type and VC ID ordering. This table is typically useful for EMS ordered query of existing VCs.')
cpwVcPeerMappingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 8, 1), ).setIndexNames((0, "CISCO-IETF-PW-MIB", "cpwVcPeerMappingPeerAddrType"), (0, "CISCO-IETF-PW-MIB", "cpwVcPeerMappingPeerAddr"), (0, "CISCO-IETF-PW-MIB", "cpwVcPeerMappingVcType"), (0, "CISCO-IETF-PW-MIB", "cpwVcPeerMappingVcID"), (0, "CISCO-IETF-PW-MIB", "cpwVcPeerMappingVcIndex"))
if mibBuilder.loadTexts: cpwVcPeerMappingEntry.setStatus('current')
if mibBuilder.loadTexts: cpwVcPeerMappingEntry.setDescription('An entry in this table is created by the agent for every VC configured in cpwVcTable.')
cpwVcPeerMappingPeerAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 8, 1, 1), InetAddressType())
if mibBuilder.loadTexts: cpwVcPeerMappingPeerAddrType.setStatus('current')
if mibBuilder.loadTexts: cpwVcPeerMappingPeerAddrType.setDescription('IP address type of the peer node.')
cpwVcPeerMappingPeerAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 8, 1, 2), InetAddress())
if mibBuilder.loadTexts: cpwVcPeerMappingPeerAddr.setStatus('current')
if mibBuilder.loadTexts: cpwVcPeerMappingPeerAddr.setDescription('IP address type of the peer node.')
cpwVcPeerMappingVcType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 8, 1, 3), CpwVcType())
if mibBuilder.loadTexts: cpwVcPeerMappingVcType.setStatus('current')
if mibBuilder.loadTexts: cpwVcPeerMappingVcType.setDescription('The VC type (indicate the service) of this VC.')
cpwVcPeerMappingVcID = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 8, 1, 4), CpwVcIDType())
if mibBuilder.loadTexts: cpwVcPeerMappingVcID.setStatus('current')
if mibBuilder.loadTexts: cpwVcPeerMappingVcID.setDescription('The VC ID of this VC. Zero if the VC is configured manually.')
cpwVcPeerMappingVcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 8, 1, 5), CpwVcIndexType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpwVcPeerMappingVcIndex.setStatus('current')
if mibBuilder.loadTexts: cpwVcPeerMappingVcIndex.setDescription('The value that represent the VC in the cpwVcTable.')
cpwVcUpDownNotifEnable = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 9), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpwVcUpDownNotifEnable.setReference('See also RFC3413 for explanation that notifications are under the ultimate control of the MIB modules in this document.')
if mibBuilder.loadTexts: cpwVcUpDownNotifEnable.setStatus('current')
if mibBuilder.loadTexts: cpwVcUpDownNotifEnable.setDescription('If this object is set to true(1), then it enables the emission of cpwVcUp and cpwVcDown notifications; otherwise these notifications are not emitted.')
cpwVcNotifRate = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 106, 1, 10), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpwVcNotifRate.setStatus('current')
if mibBuilder.loadTexts: cpwVcNotifRate.setDescription('This object defines the maximum number of PW VC notifications that can be emitted from the device per second.')
cpwVcDown = NotificationType((1, 3, 6, 1, 4, 1, 9, 10, 106, 2, 1)).setObjects(("CISCO-IETF-PW-MIB", "cpwVcOperStatus"), ("CISCO-IETF-PW-MIB", "cpwVcOperStatus"))
if mibBuilder.loadTexts: cpwVcDown.setStatus('current')
if mibBuilder.loadTexts: cpwVcDown.setDescription('This notification is generated when the cpwVcOperStatus object for one or more contiguous entries in cpwVcTable are about to enter the down(2) state from some other state. The included values of cpwVcOperStatus MUST all be set equal to this down(2) state. The two instances of cpwVcOperStatus in this notification indicate the range of indexes that are affected. Note that all the indexes of the two ends of the range can be derived from the instance identifiers of these two objects. For cases where a contiguous range of cross-connects have transitioned into the down(2) state at roughly the same time, the device SHOULD issue a single notification for each range of contiguous indexes in an effort to minimize the emission of a large number of notifications. If a notification has to be issued for just a single cross-connect entry, then the instance identifier (and values) of the two cpwVcOperStatus objects MUST be identical.')
cpwVcUp = NotificationType((1, 3, 6, 1, 4, 1, 9, 10, 106, 2, 2)).setObjects(("CISCO-IETF-PW-MIB", "cpwVcOperStatus"), ("CISCO-IETF-PW-MIB", "cpwVcOperStatus"))
if mibBuilder.loadTexts: cpwVcUp.setStatus('current')
if mibBuilder.loadTexts: cpwVcUp.setDescription('This notification is generated when the cpwVcOperStatus object for one or more contiguous entries in cpwVcTable are about to enter the up(1) state from some other state. The included values of cpwVcOperStatus MUST both be set equal to this new state (i.e: up(1)). The two instances of cpwVcOperStatus in this notification indicate the range of indexes that are affected. Note that all the indexes of the two ends of the range can be derived from the instance identifiers of these two objects. For cases where a contiguous range of cross-connects have transitioned into the up(1) state at roughly the same time, the device SHOULD issue a single notification for each range of contiguous indexes in an effort to minimize the emission of a large number of notifications. If a notification has to be issued for just a single cross-connect entry, then the instance identifier (and values) of the two cpwVcOperStatus objects MUST be the identical.')
cpwVcGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 106, 3, 1))
cpwVcCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 106, 3, 2))
cpwModuleCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 10, 106, 3, 2, 1)).setObjects(("CISCO-IETF-PW-MIB", "cpwVcGroup"), ("CISCO-IETF-PW-MIB", "cpwVcPeformanceGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cpwModuleCompliance = cpwModuleCompliance.setStatus('current')
if mibBuilder.loadTexts: cpwModuleCompliance.setDescription('The compliance statement for agent that support PW operation.')
cpwVcGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 106, 3, 1, 1)).setObjects(("CISCO-IETF-PW-MIB", "cpwVcIndexNext"), ("CISCO-IETF-PW-MIB", "cpwVcType"), ("CISCO-IETF-PW-MIB", "cpwVcOwner"), ("CISCO-IETF-PW-MIB", "cpwVcPsnType"), ("CISCO-IETF-PW-MIB", "cpwVcSetUpPriority"), ("CISCO-IETF-PW-MIB", "cpwVcHoldingPriority"), ("CISCO-IETF-PW-MIB", "cpwVcInboundMode"), ("CISCO-IETF-PW-MIB", "cpwVcPeerAddrType"), ("CISCO-IETF-PW-MIB", "cpwVcPeerAddr"), ("CISCO-IETF-PW-MIB", "cpwVcID"), ("CISCO-IETF-PW-MIB", "cpwVcLocalGroupID"), ("CISCO-IETF-PW-MIB", "cpwVcControlWord"), ("CISCO-IETF-PW-MIB", "cpwVcLocalIfMtu"), ("CISCO-IETF-PW-MIB", "cpwVcLocalIfString"), ("CISCO-IETF-PW-MIB", "cpwVcRemoteGroupID"), ("CISCO-IETF-PW-MIB", "cpwVcRemoteControlWord"), ("CISCO-IETF-PW-MIB", "cpwVcRemoteIfMtu"), ("CISCO-IETF-PW-MIB", "cpwVcRemoteIfString"), ("CISCO-IETF-PW-MIB", "cpwVcOutboundVcLabel"), ("CISCO-IETF-PW-MIB", "cpwVcInboundVcLabel"), ("CISCO-IETF-PW-MIB", "cpwVcName"), ("CISCO-IETF-PW-MIB", "cpwVcDescr"), ("CISCO-IETF-PW-MIB", "cpwVcCreateTime"), ("CISCO-IETF-PW-MIB", "cpwVcUpTime"), ("CISCO-IETF-PW-MIB", "cpwVcAdminStatus"), ("CISCO-IETF-PW-MIB", "cpwVcOperStatus"), ("CISCO-IETF-PW-MIB", "cpwVcOutboundOperStatus"), ("CISCO-IETF-PW-MIB", "cpwVcInboundOperStatus"), ("CISCO-IETF-PW-MIB", "cpwVcTimeElapsed"), ("CISCO-IETF-PW-MIB", "cpwVcValidIntervals"), ("CISCO-IETF-PW-MIB", "cpwVcRowStatus"), ("CISCO-IETF-PW-MIB", "cpwVcStorageType"), ("CISCO-IETF-PW-MIB", "cpwVcUpDownNotifEnable"), ("CISCO-IETF-PW-MIB", "cpwVcNotifRate"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cpwVcGroup = cpwVcGroup.setStatus('current')
if mibBuilder.loadTexts: cpwVcGroup.setDescription('Collection of objects needed for PW VC configuration.')
cpwVcPeformanceGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 106, 3, 1, 2)).setObjects(("CISCO-IETF-PW-MIB", "cpwVcPerfCurrentInHCPackets"), ("CISCO-IETF-PW-MIB", "cpwVcPerfCurrentInHCBytes"), ("CISCO-IETF-PW-MIB", "cpwVcPerfCurrentOutHCPackets"), ("CISCO-IETF-PW-MIB", "cpwVcPerfCurrentOutHCBytes"), ("CISCO-IETF-PW-MIB", "cpwVcPerfIntervalValidData"), ("CISCO-IETF-PW-MIB", "cpwVcPerfIntervalTimeElapsed"), ("CISCO-IETF-PW-MIB", "cpwVcPerfIntervalInHCPackets"), ("CISCO-IETF-PW-MIB", "cpwVcPerfIntervalInHCBytes"), ("CISCO-IETF-PW-MIB", "cpwVcPerfIntervalOutHCPackets"), ("CISCO-IETF-PW-MIB", "cpwVcPerfIntervalOutHCBytes"), ("CISCO-IETF-PW-MIB", "cpwVcPerfTotalInHCPackets"), ("CISCO-IETF-PW-MIB", "cpwVcPerfTotalInHCBytes"), ("CISCO-IETF-PW-MIB", "cpwVcPerfTotalOutHCPackets"), ("CISCO-IETF-PW-MIB", "cpwVcPerfTotalOutHCBytes"), ("CISCO-IETF-PW-MIB", "cpwVcPerfTotalDiscontinuityTime"), ("CISCO-IETF-PW-MIB", "cpwVcPerfTotalErrorPackets"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cpwVcPeformanceGroup = cpwVcPeformanceGroup.setStatus('current')
if mibBuilder.loadTexts: cpwVcPeformanceGroup.setDescription('Collection of objects needed for PW VC performance.')
cpwVcMappingTablesGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 106, 3, 1, 3)).setObjects(("CISCO-IETF-PW-MIB", "cpwVcIdMappingVcIndex"), ("CISCO-IETF-PW-MIB", "cpwVcPeerMappingVcIndex"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cpwVcMappingTablesGroup = cpwVcMappingTablesGroup.setStatus('current')
if mibBuilder.loadTexts: cpwVcMappingTablesGroup.setDescription('Collection of objects contained in the reverse mapping tables.')
cpwVcNotificationsGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 9, 10, 106, 3, 1, 4)).setObjects(("CISCO-IETF-PW-MIB", "cpwVcUp"), ("CISCO-IETF-PW-MIB", "cpwVcDown"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cpwVcNotificationsGroup = cpwVcNotificationsGroup.setStatus('current')
if mibBuilder.loadTexts: cpwVcNotificationsGroup.setDescription('Set of notifications implemented in this module. None is mandatory.')
mibBuilder.exportSymbols("CISCO-IETF-PW-MIB", cpwVcPerfTotalTable=cpwVcPerfTotalTable, cpwVcEntry=cpwVcEntry, cpwVcUpDownNotifEnable=cpwVcUpDownNotifEnable, cpwVcIndex=cpwVcIndex, cpwVcID=cpwVcID, cpwVcRemoteIfMtu=cpwVcRemoteIfMtu, cpwVcRemoteIfString=cpwVcRemoteIfString, cpwVcPerfCurrentOutHCPackets=cpwVcPerfCurrentOutHCPackets, cpwVcIdMappingTable=cpwVcIdMappingTable, cpwVcIdMappingVcIndex=cpwVcIdMappingVcIndex, cpwVcNotifRate=cpwVcNotifRate, cpwVcPerfTotalErrorPackets=cpwVcPerfTotalErrorPackets, cpwVcRemoteGroupID=cpwVcRemoteGroupID, cpwVcPerfIntervalNumber=cpwVcPerfIntervalNumber, cpwVcGroup=cpwVcGroup, cpwVcTable=cpwVcTable, cpwVcType=cpwVcType, cpwVcPerfTotalInHCPackets=cpwVcPerfTotalInHCPackets, cpwVcPerfTotalInHCBytes=cpwVcPerfTotalInHCBytes, cpwVcPerfIntervalTimeElapsed=cpwVcPerfIntervalTimeElapsed, cpwVcCreateTime=cpwVcCreateTime, cpwVcUpTime=cpwVcUpTime, cpwVcStorageType=cpwVcStorageType, cpwVcName=cpwVcName, cpwVcLocalIfString=cpwVcLocalIfString, cpwVcPerfTotalOutHCBytes=cpwVcPerfTotalOutHCBytes, cpwVcIndexNext=cpwVcIndexNext, cpwVcInboundVcLabel=cpwVcInboundVcLabel, cpwVcPerfTotalEntry=cpwVcPerfTotalEntry, cpwVcPeerAddrType=cpwVcPeerAddrType, cpwVcDescr=cpwVcDescr, cpwVcPerfIntervalOutHCPackets=cpwVcPerfIntervalOutHCPackets, cpwVcDown=cpwVcDown, cpwVcPerfCurrentInHCBytes=cpwVcPerfCurrentInHCBytes, cpwVcCompliances=cpwVcCompliances, cpwVcInboundMode=cpwVcInboundMode, cpwVcPerfCurrentInHCPackets=cpwVcPerfCurrentInHCPackets, cpwVcPeerMappingVcID=cpwVcPeerMappingVcID, cpwVcPerfTotalOutHCPackets=cpwVcPerfTotalOutHCPackets, cpwVcPeerMappingTable=cpwVcPeerMappingTable, cpwVcTimeElapsed=cpwVcTimeElapsed, cpwVcIdMappingEntry=cpwVcIdMappingEntry, cpwVcLocalIfMtu=cpwVcLocalIfMtu, cpwVcPsnType=cpwVcPsnType, cpwVcIdMappingPeerAddr=cpwVcIdMappingPeerAddr, cpwModuleCompliance=cpwModuleCompliance, cpwVcValidIntervals=cpwVcValidIntervals, cpwVcMIB=cpwVcMIB, cpwVcPerfCurrentOutHCBytes=cpwVcPerfCurrentOutHCBytes, cpwVcObjects=cpwVcObjects, cpwVcPeformanceGroup=cpwVcPeformanceGroup, cpwVcOutboundVcLabel=cpwVcOutboundVcLabel, cpwVcHoldingPriority=cpwVcHoldingPriority, cpwVcPerfIntervalValidData=cpwVcPerfIntervalValidData, cpwVcPeerMappingPeerAddrType=cpwVcPeerMappingPeerAddrType, cpwVcSetUpPriority=cpwVcSetUpPriority, cpwVcNotificationsGroup=cpwVcNotificationsGroup, cpwVcNotifications=cpwVcNotifications, cpwVcIdMappingVcID=cpwVcIdMappingVcID, cpwVcRowStatus=cpwVcRowStatus, cpwVcIdMappingPeerAddrType=cpwVcIdMappingPeerAddrType, cpwVcInboundOperStatus=cpwVcInboundOperStatus, cpwVcPeerMappingPeerAddr=cpwVcPeerMappingPeerAddr, cpwVcIdMappingVcType=cpwVcIdMappingVcType, cpwVcControlWord=cpwVcControlWord, cpwVcPerfCurrentEntry=cpwVcPerfCurrentEntry, cpwVcPeerAddr=cpwVcPeerAddr, cpwVcMappingTablesGroup=cpwVcMappingTablesGroup, PYSNMP_MODULE_ID=cpwVcMIB, cpwVcOwner=cpwVcOwner, cpwVcPerfIntervalEntry=cpwVcPerfIntervalEntry, cpwVcPeerMappingVcIndex=cpwVcPeerMappingVcIndex, cpwVcPerfIntervalInHCPackets=cpwVcPerfIntervalInHCPackets, cpwVcGroups=cpwVcGroups, cpwVcConformance=cpwVcConformance, cpwVcOperStatus=cpwVcOperStatus, cpwVcRemoteControlWord=cpwVcRemoteControlWord, cpwVcPerfTotalDiscontinuityTime=cpwVcPerfTotalDiscontinuityTime, cpwVcPerfIntervalOutHCBytes=cpwVcPerfIntervalOutHCBytes, cpwVcLocalGroupID=cpwVcLocalGroupID, cpwVcAdminStatus=cpwVcAdminStatus, cpwVcOutboundOperStatus=cpwVcOutboundOperStatus, cpwVcPerfIntervalInHCBytes=cpwVcPerfIntervalInHCBytes, cpwVcPerfIntervalTable=cpwVcPerfIntervalTable, cpwVcPeerMappingVcType=cpwVcPeerMappingVcType, cpwVcUp=cpwVcUp, cpwVcPerfCurrentTable=cpwVcPerfCurrentTable, cpwVcPeerMappingEntry=cpwVcPeerMappingEntry)

#
# PySNMP MIB module XYLAN-ATM-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/XYLAN-ATM-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:44:48 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueRangeConstraint, ValueSizeConstraint, ConstraintsUnion, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueRangeConstraint", "ValueSizeConstraint", "ConstraintsUnion", "SingleValueConstraint")
MacAddress, = mibBuilder.importSymbols("BRIDGE-MIB", "MacAddress")
LecDataFrameSize, lecIndex = mibBuilder.importSymbols("LAN-EMULATION-CLIENT-MIB", "LecDataFrameSize", "lecIndex")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
ObjectIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, ModuleIdentity, IpAddress, MibIdentifier, Bits, Counter64, Gauge32, Counter32, Integer32, iso, NotificationType, Unsigned32, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "ObjectIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ModuleIdentity", "IpAddress", "MibIdentifier", "Bits", "Counter64", "Gauge32", "Counter32", "Integer32", "iso", "NotificationType", "Unsigned32", "TimeTicks")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
xylanAtmArch, = mibBuilder.importSymbols("XYLAN-BASE-MIB", "xylanAtmArch")
class AtmAdminStatCodes(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("disable", 1), ("enable", 2), ("delete", 3), ("create", 4))

class AtmOperStatCodes(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("other", 1), ("inService", 2), ("outOfService", 3), ("loopBack", 4))

class AtmServiceOperStatCodes(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("disable", 1), ("enabling", 2), ("enabled", 3), ("unknown", 4))

class AtmConnectionOperStatCodes(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))
    namedValues = NamedValues(("unknown", 1), ("end2EndUp", 2), ("end2EndDown", 3), ("localUpEnd2EndUnknown", 4), ("localDown", 5))

class AtmTransmissionTypes(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))
    namedValues = NamedValues(("unknown", 1), ("sonetSTS3c", 2), ("ds3", 3), ("atm4b5b", 4), ("atm8b10b", 5), ("e3", 6), ("sonetSTS12c", 7))

class AtmMediaTypes(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))
    namedValues = NamedValues(("unknown", 1), ("coaxCable", 2), ("singleMode", 3), ("multiMode", 4), ("stp", 5), ("utp", 6))

class AtmTrafficDescrTypes(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))
    namedValues = NamedValues(("none", 1), ("peakrate", 2), ("noClpNoScr", 3), ("clpNoTaggingNoScr", 4), ("clpTaggingNoScr", 5), ("noClpScr", 6), ("clpNoTaggingScr", 7), ("clpTaggingScr", 8))

class XylanAtmLaneAddress(DisplayString):
    pass

class VpiInteger(Integer32):
    pass

class VciInteger(Integer32):
    pass

class LecState(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))
    namedValues = NamedValues(("initialState", 1), ("lecsConnect", 2), ("configure", 3), ("join", 4), ("initialRegistration", 5), ("busConnect", 6), ("operational", 7))

class LecDataFrameFormat(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("unspecified", 1), ("aflane8023", 2), ("aflane8025", 3))

class LeArpTableEntryType(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))
    namedValues = NamedValues(("other", 1), ("learnedViaControl", 2), ("learnedViaData", 3), ("staticVolatile", 4), ("staticNonVolatile", 5))

class LeArpType(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("other", 1), ("arpRdType", 2), ("arpEsiType", 3))

atmxPortGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 4, 1))
atmxServiceGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 4, 2))
atmxLayerStatsGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 4, 3))
atmxVccStatsGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 4, 4))
atmxVccGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 4, 5))
atmxAddressGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 4, 6))
atmxArpGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 4, 7))
atmxLaneGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 4, 8))
atmxCIPstatsGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 4, 9))
atmxSahiBWGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 4, 11))
atmxLsmGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 4, 13))
atmx1483ScaleGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 2, 4, 12))
atmxPortTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 4, 1, 1), )
if mibBuilder.loadTexts: atmxPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmxPortTable.setDescription("A table of port layer status and parameter information for the UNI's physical interface.")
atmxPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 4, 1, 1, 1), ).setIndexNames((0, "XYLAN-ATM-MIB", "atmxPortSlotIndex"), (0, "XYLAN-ATM-MIB", "atmxPortPortIndex"))
if mibBuilder.loadTexts: atmxPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmxPortEntry.setDescription('An entry in the table, containing information about the physical layer of a UNI interface.')
atmxPortSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 9))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxPortSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmxPortSlotIndex.setDescription('A unique value which identifies this hsm board slot.')
atmxPortPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxPortPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmxPortPortIndex.setDescription('A unique value which identifies this atm submodule port.')
atmxPortDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 1, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxPortDescription.setStatus('mandatory')
if mibBuilder.loadTexts: atmxPortDescription.setDescription('A description for this atm port.')
atmxPortConnectionType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("pvc", 1), ("svc", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxPortConnectionType.setStatus('mandatory')
if mibBuilder.loadTexts: atmxPortConnectionType.setDescription('The connection type of this board.')
atmxPortTransmissionType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 1, 1, 1, 5), AtmTransmissionTypes()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxPortTransmissionType.setStatus('mandatory')
if mibBuilder.loadTexts: atmxPortTransmissionType.setDescription('The transmission type of this port. For example, for a port using the Sonet STS-3c physical layer at 155.52 Mbs, this object would have the Object Identifier value: atmxSonetSTS3c.')
atmxPortMediaType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 1, 1, 1, 6), AtmMediaTypes()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxPortMediaType.setStatus('mandatory')
if mibBuilder.loadTexts: atmxPortMediaType.setDescription('The type of media being used on this port. For example for a port using coaxial cable, the object would have the Object Identifier value: atmxMediaCoaxCable.')
atmxPortOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 1, 1, 1, 7), AtmOperStatCodes()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxPortOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmxPortOperStatus.setDescription('The operational state (i.e., actual) of this port. The ILMI should not alarm on a physical interface for when the value of this object is outOfService(3). This capability is useful if the equipment is to be disconnected, or for troubleshooting purposes. A value of loopBack(4) indicates that a local loopback is in place.')
atmxPortUniType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("public", 1), ("private", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxPortUniType.setStatus('mandatory')
if mibBuilder.loadTexts: atmxPortUniType.setDescription('The type of the ATM UNI, either public or private.')
atmxPortMaxVCCs = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxPortMaxVCCs.setStatus('mandatory')
if mibBuilder.loadTexts: atmxPortMaxVCCs.setDescription('The maximum number of VCCs supported on this UNI.')
atmxPortMaxVciBits = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxPortMaxVciBits.setStatus('mandatory')
if mibBuilder.loadTexts: atmxPortMaxVciBits.setDescription('The number of active VCI bits on this interface.')
atmxPortTxSegmentSize = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2048, 131072))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxPortTxSegmentSize.setStatus('mandatory')
if mibBuilder.loadTexts: atmxPortTxSegmentSize.setDescription('The transmit segment size on this UNI. The nearest power of two less than or equal to this value will be used internally. The max memory is 512K, therefore the maximum number of channels will be 512K/internal tx seg size.')
atmxPortRxSegmentSize = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2048, 131072))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxPortRxSegmentSize.setStatus('mandatory')
if mibBuilder.loadTexts: atmxPortRxSegmentSize.setDescription('The receive segment size on this UNI. The nearest power of two less than or equal to this value will be used internally. The max memory is 512K, therefore the maximum number of channels will be 512K/internal rx seg size.')
atmxPortTxBufferSize = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 1, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1800, 131072))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxPortTxBufferSize.setStatus('mandatory')
if mibBuilder.loadTexts: atmxPortTxBufferSize.setDescription('The transmit buffer size on this UNI. The buffer size must be less than or equal to the segment size and should be greater than or equal to the maximum frame size.')
atmxPortRxBufferSize = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 1, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1800, 131072))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxPortRxBufferSize.setStatus('mandatory')
if mibBuilder.loadTexts: atmxPortRxBufferSize.setDescription('The receive buffer size on this UNI. The buffer size must be less than or equal to the segment size and should be greater than or equal to the maximum frame size.')
atmxPortUniPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 1, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxPortUniPortIndex.setStatus('deprecated')
if mibBuilder.loadTexts: atmxPortUniPortIndex.setDescription('This object should not be implemented except as required for backward compatibility with version 2.0 of the UNI specification. This object provide a port index link to the UNI MIB')
atmxPortAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 1, 1, 1, 16), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxPortAddress.setStatus('mandatory')
if mibBuilder.loadTexts: atmxPortAddress.setDescription('This object should not be implemented except as required for backward compatibility with version 2.0 of the UNI specification. The Address Group, as defined as part of the separate Address Registration MIB should be used instead.')
atmxPortSignalingVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 1, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ver30", 1), ("ver31", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxPortSignalingVersion.setStatus('mandatory')
if mibBuilder.loadTexts: atmxPortSignalingVersion.setDescription('Version of the ATM forum UNI Signaling.')
atmxPortSignalingVci = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 1, 1, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxPortSignalingVci.setStatus('mandatory')
if mibBuilder.loadTexts: atmxPortSignalingVci.setDescription('Signaling Vci.')
atmxPortILMIVci = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 1, 1, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxPortILMIVci.setStatus('mandatory')
if mibBuilder.loadTexts: atmxPortILMIVci.setDescription('ILMI Vci.')
atmxPortEnableILMI = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 1, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxPortEnableILMI.setStatus('mandatory')
if mibBuilder.loadTexts: atmxPortEnableILMI.setDescription('ILMI Enable.')
atmxPortPlScramble = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 1, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxPortPlScramble.setStatus('mandatory')
if mibBuilder.loadTexts: atmxPortPlScramble.setDescription('Payload Scrambling Enable.')
atmxPortTimingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 1, 1, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("loop", 1), ("local", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxPortTimingMode.setStatus('mandatory')
if mibBuilder.loadTexts: atmxPortTimingMode.setDescription('Timing mode to use. Use local timing or loop timing. ')
atmxPortProtocolType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 1, 1, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("sonet", 1), ("sdh", 2), ("notApplicable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxPortProtocolType.setStatus('mandatory')
if mibBuilder.loadTexts: atmxPortProtocolType.setDescription('Physical layer protocol type. ')
atmxPortLoopbackConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 1, 1, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxPortLoopbackConfig.setStatus('mandatory')
if mibBuilder.loadTexts: atmxPortLoopbackConfig.setDescription('Loopback config. for this physical layer. 1 = NoLoop, 2 = DiagLoop, 3 = LineLoop, 4 = CellLoop, 5 = PayloadLoop ')
atmxPortSSCOPstatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 1, 1, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxPortSSCOPstatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmxPortSSCOPstatus.setDescription('SSCOP status of this physical layer. ')
atmxPortILMIstatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 1, 1, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxPortILMIstatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmxPortILMIstatus.setDescription('ILMI status of this physical layer. ')
atmxServiceTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 4, 2, 1), )
if mibBuilder.loadTexts: atmxServiceTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmxServiceTable.setDescription('A table of ATM services status and parameter information.')
atmxServiceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 4, 2, 1, 1), ).setIndexNames((0, "XYLAN-ATM-MIB", "atmxServiceSlotIndex"), (0, "XYLAN-ATM-MIB", "atmxServicePortIndex"), (0, "XYLAN-ATM-MIB", "atmxServiceNumber"))
if mibBuilder.loadTexts: atmxServiceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmxServiceEntry.setDescription('An entry in the table, containing information about the ATM services.')
atmxServiceSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 9))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxServiceSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmxServiceSlotIndex.setDescription('A unique value which identifies this hsm board slot.')
atmxServicePortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxServicePortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmxServicePortIndex.setDescription('A unique value which identifies this atm submodule port.')
atmxServiceNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 256))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxServiceNumber.setStatus('mandatory')
if mibBuilder.loadTexts: atmxServiceNumber.setDescription('The unique service number for this particular slot/port.')
atmxServiceDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 2, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxServiceDescription.setStatus('mandatory')
if mibBuilder.loadTexts: atmxServiceDescription.setDescription('A description for this atm service.')
atmxServiceType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("lanEmulation", 1), ("scaling1483", 2), ("trunking", 4), ("classicalIP", 5), ("ptopBridging", 6), ("vlanCluster", 7), ("laneServiceModule", 8), ("mpoaClient", 9)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxServiceType.setStatus('mandatory')
if mibBuilder.loadTexts: atmxServiceType.setDescription('The service type. For 1483 Scaling Service, create it only with 1 group and 1 vc thru this atmxServiceGroup. Adding Other group-to-vc mapping should utilize the atmx1483ScaleGroup.')
atmxServiceConnectionType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("pvc", 1), ("svc", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxServiceConnectionType.setStatus('mandatory')
if mibBuilder.loadTexts: atmxServiceConnectionType.setDescription('The connection type of this board.')
atmxServiceOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 2, 1, 1, 7), AtmServiceOperStatCodes()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxServiceOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmxServiceOperStatus.setDescription('The service operational status.')
atmxServiceAdmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 2, 1, 1, 8), AtmAdminStatCodes()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxServiceAdmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmxServiceAdmStatus.setDescription('The service adminstration status.')
atmxServiceEncapsType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("private", 1), ("rfc1483", 2), ("none", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxServiceEncapsType.setStatus('mandatory')
if mibBuilder.loadTexts: atmxServiceEncapsType.setDescription('The service encapsulation type. This object is applicable only to PTOP service.')
atmxServiceArpRequestServer = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxServiceArpRequestServer.setStatus('mandatory')
if mibBuilder.loadTexts: atmxServiceArpRequestServer.setDescription('The Arp request server. 0 = not applicable, 1 = Non arp server, 2 = arp server.')
atmxServiceConnections = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 2, 1, 1, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 512))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxServiceConnections.setStatus('mandatory')
if mibBuilder.loadTexts: atmxServiceConnections.setDescription('The connections for this service. Interpret this as a 16 bit field per connection: Trunking 1, PTOP Bridging 1, Classical IP 1..255. For Vlan cluster, this object is interpreted as a 32 bit field where each 32 bit represent the vci value of the Data Direct vcc and the Multicast In vcc. Each vcc take up 16 bits. There can be up to 32 pairs of Data Direct vcc and Mulitcast In vcc. For 1483 Scaling Service, create it only with 1 group and 1 vc thru this atmxServiceGroup. Adding Other group-to-vc mapping should utilize the atmx1483ScaleGroup.')
atmxServiceAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 2, 1, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxServiceAddress.setStatus('mandatory')
if mibBuilder.loadTexts: atmxServiceAddress.setDescription('The unique service address.')
atmxServiceAddresses = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 2, 1, 1, 13), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 512))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxServiceAddresses.setStatus('mandatory')
if mibBuilder.loadTexts: atmxServiceAddresses.setDescription('The addresses for this service. Interpret this as a 16 bit field per address: Trunking 1, PTOP Bridging 1, Classical IP 1..255.')
atmxServiceVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 2, 1, 1, 14), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxServiceVlan.setStatus('mandatory')
if mibBuilder.loadTexts: atmxServiceVlan.setDescription('The Vlans for this service. Interpret this as a 16 bit field per vlan: Trunking 1-32, PTOP Bridging 1, Classical IP 1. For Vlan Cluster, it will depend on the encapsulation type selected. If RFC 1483, only 1 vlan while Xylan ATM trunking up to 32 vlans are allowed. For 1483 Scaling Service, create it only with 1 group and 1 vc thru this atmxServiceGroup. Adding Other group-to-vc mapping should utilize the atmx1483ScaleGroup.')
atmxServiceSEL = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 2, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxServiceSEL.setStatus('mandatory')
if mibBuilder.loadTexts: atmxServiceSEL.setDescription('The SEL for the ATM address of this service.')
atmxServiceLaneCfgTblIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 2, 1, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxServiceLaneCfgTblIdx.setStatus('mandatory')
if mibBuilder.loadTexts: atmxServiceLaneCfgTblIdx.setDescription('Index to the LAN Emulation Configuration Table. This index is only used when the Service type is ATM LAN Emulation. For other service type this should be set to zero (0).')
atmxServiceMulticastOutVcc = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 2, 1, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1023))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxServiceMulticastOutVcc.setStatus('mandatory')
if mibBuilder.loadTexts: atmxServiceMulticastOutVcc.setDescription('The Multicast Out VCC for this Vlan Cluster (X-LANE) service. This is only applicable to service type Vlan Cluster. For other ATM services, this object will return a zero (0). For Vlan Cluster service if a zero (0) is returned means no Multicast out is specified.')
atmxServiceNumVclMembers = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 2, 1, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxServiceNumVclMembers.setStatus('mandatory')
if mibBuilder.loadTexts: atmxServiceNumVclMembers.setDescription('The number of other Vlan cluster members defined and have a data direct VCC associated with the connection. This object is valid only for Vlan cluster services. Zero (0) will be returned for other ATM services.')
atmxServiceVclEncapType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 2, 1, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxServiceVclEncapType.setStatus('mandatory')
if mibBuilder.loadTexts: atmxServiceVclEncapType.setDescription('The Encapsulation type for the Vlan Cluster service. 1 = RFC 1483 encapsulation. 2 = Xylan ATM trunking. 3 = not applicable. This object is only valid for Vlan cluster services. All other ATM services will return a value of 3. If the encapsulation type is RFC 1483, only one (1) vlan as defined in atmxServiceVlan can be associated with this service. If encapsulation type is Xylan ATM trunking more than 1 vlan can be assocated with this service.')
atmxServiceSahiBwgNum = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 2, 1, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxServiceSahiBwgNum.setStatus('mandatory')
if mibBuilder.loadTexts: atmxServiceSahiBwgNum.setDescription("The bwg num for sahi based hsm's. The user can set the pcr, scr, mbs using the bwg table and chose the desired bwg num for this service ensuring that this service obtains the desired bandwidth")
atmxLayerStatsTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 4, 3, 1), )
if mibBuilder.loadTexts: atmxLayerStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmxLayerStatsTable.setDescription('A table of ATM layer statistics information.')
atmxLayerStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 4, 3, 1, 1), ).setIndexNames((0, "XYLAN-ATM-MIB", "atmxLayerStatsSlotIndex"), (0, "XYLAN-ATM-MIB", "atmxLayerStatsPortIndex"))
if mibBuilder.loadTexts: atmxLayerStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmxLayerStatsEntry.setDescription('An entry in the table, containing information about the ATM layer statistics.')
atmxLayerStatsSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 9))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxLayerStatsSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmxLayerStatsSlotIndex.setDescription('A unique value which identifies this hsm board slot.')
atmxLayerStatsPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxLayerStatsPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmxLayerStatsPortIndex.setDescription('A unique value which identifies this atm submodule port.')
atmxLayerStatsTxSDUs = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 3, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxLayerStatsTxSDUs.setStatus('mandatory')
if mibBuilder.loadTexts: atmxLayerStatsTxSDUs.setDescription("The total number of successfully transmitted SDU's on the physical port.")
atmxLayerStatsTxCells = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 3, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxLayerStatsTxCells.setStatus('mandatory')
if mibBuilder.loadTexts: atmxLayerStatsTxCells.setDescription('The total number of successfully transmitted cells.')
atmxLayerStatsTxOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 3, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxLayerStatsTxOctets.setStatus('mandatory')
if mibBuilder.loadTexts: atmxLayerStatsTxOctets.setDescription('The total number of successfully transmitted octets.')
atmxLayerStatsRxSDUs = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 3, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxLayerStatsRxSDUs.setStatus('mandatory')
if mibBuilder.loadTexts: atmxLayerStatsRxSDUs.setDescription("The total number of successfully received SDU's.")
atmxLayerStatsRxCells = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 3, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxLayerStatsRxCells.setStatus('mandatory')
if mibBuilder.loadTexts: atmxLayerStatsRxCells.setDescription('The total number of successfully received cells.')
atmxLayerStatsRxOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 3, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxLayerStatsRxOctets.setStatus('mandatory')
if mibBuilder.loadTexts: atmxLayerStatsRxOctets.setDescription('The total number of successfully received octets.')
atmxLayerStatsTxSDUDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 3, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxLayerStatsTxSDUDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: atmxLayerStatsTxSDUDiscards.setDescription('The total number of transmit SDUs that are discarded.')
atmxLayerStatsTxSDUErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 3, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxLayerStatsTxSDUErrors.setStatus('mandatory')
if mibBuilder.loadTexts: atmxLayerStatsTxSDUErrors.setDescription('The total number of transmit SDU with errors.')
atmxLayerStatsTxSDUNoBuffers = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 3, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxLayerStatsTxSDUNoBuffers.setStatus('mandatory')
if mibBuilder.loadTexts: atmxLayerStatsTxSDUNoBuffers.setDescription("The number of transmitted SDU's with no buffers available on the physical port.")
atmxLayerStatsTxCellDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 3, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxLayerStatsTxCellDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: atmxLayerStatsTxCellDiscards.setDescription('The total number of transmit cells that are dicscarded.')
atmxLayerStatsTxCellErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 3, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxLayerStatsTxCellErrors.setStatus('mandatory')
if mibBuilder.loadTexts: atmxLayerStatsTxCellErrors.setDescription('The total number of transmit cell with errors.')
atmxLayerStatsTxCellNoBuffers = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 3, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxLayerStatsTxCellNoBuffers.setStatus('mandatory')
if mibBuilder.loadTexts: atmxLayerStatsTxCellNoBuffers.setDescription('The total number of transmit cell with no buffers available.')
atmxLayerStatsRxSDUDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 3, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxLayerStatsRxSDUDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: atmxLayerStatsRxSDUDiscards.setDescription("The total number of receive SDU's that are discarded.")
atmxLayerStatsRxSDUErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 3, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxLayerStatsRxSDUErrors.setStatus('mandatory')
if mibBuilder.loadTexts: atmxLayerStatsRxSDUErrors.setDescription("The total number of receive SDU's with errors.")
atmxLayerStatsRxSDUInvalidSz = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 3, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxLayerStatsRxSDUInvalidSz.setStatus('mandatory')
if mibBuilder.loadTexts: atmxLayerStatsRxSDUInvalidSz.setDescription("The total number of receive SDU's with invalid size")
atmxLayerStatsRxSDUNoBuffers = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 3, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxLayerStatsRxSDUNoBuffers.setStatus('mandatory')
if mibBuilder.loadTexts: atmxLayerStatsRxSDUNoBuffers.setDescription("The total number of receive SDU's with no buffers")
atmxLayerStatsRxSDUTrash = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 3, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxLayerStatsRxSDUTrash.setStatus('mandatory')
if mibBuilder.loadTexts: atmxLayerStatsRxSDUTrash.setDescription("The total number of receive trash SDU's")
atmxLayerStatsRxSDUCrcErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 3, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxLayerStatsRxSDUCrcErrors.setStatus('mandatory')
if mibBuilder.loadTexts: atmxLayerStatsRxSDUCrcErrors.setDescription("The total number of receive SDU's with crc errors")
atmxLayerStatsRxCellDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 3, 1, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxLayerStatsRxCellDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: atmxLayerStatsRxCellDiscards.setDescription('The total number of receive cells that are discarded.')
atmxLayerStatsRxCellErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 3, 1, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxLayerStatsRxCellErrors.setStatus('mandatory')
if mibBuilder.loadTexts: atmxLayerStatsRxCellErrors.setDescription('The total number of recieve cell with errors')
atmxLayerStatsRxCellNoBuffers = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 3, 1, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxLayerStatsRxCellNoBuffers.setStatus('mandatory')
if mibBuilder.loadTexts: atmxLayerStatsRxCellNoBuffers.setDescription('The total number of receive cell with no buffers')
atmxLayerStatsRxCellTrash = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 3, 1, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxLayerStatsRxCellTrash.setStatus('mandatory')
if mibBuilder.loadTexts: atmxLayerStatsRxCellTrash.setDescription('The total number of recieve trash cells.')
atmxLayerStatsRxCellCrcErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 3, 1, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxLayerStatsRxCellCrcErrors.setStatus('mandatory')
if mibBuilder.loadTexts: atmxLayerStatsRxCellCrcErrors.setDescription('The total number of receive cells with crc errors.')
atmxVccStatsTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 4, 4, 1), )
if mibBuilder.loadTexts: atmxVccStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccStatsTable.setDescription('A table of ATM virtual channel connection statistics information.')
atmxVccStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 4, 4, 1, 1), ).setIndexNames((0, "XYLAN-ATM-MIB", "atmxVccStatsSlotIndex"), (0, "XYLAN-ATM-MIB", "atmxVccStatsPortIndex"), (0, "XYLAN-ATM-MIB", "atmxVccStatsVci"))
if mibBuilder.loadTexts: atmxVccStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccStatsEntry.setDescription('An entry in the table, containing information about the ATM virtual channel connection statistics.')
atmxVccStatsSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 9))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVccStatsSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccStatsSlotIndex.setDescription('A unique value which identifies this hsm board slot.')
atmxVccStatsPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVccStatsPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccStatsPortIndex.setDescription('A unique value which identifies this atm submodule port.')
atmxVccStatsVci = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVccStatsVci.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccStatsVci.setDescription('A unique value which identifies this atm port.')
atmxVccStatsTxSDUs = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 4, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVccStatsTxSDUs.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccStatsTxSDUs.setDescription("The total number of transmitted SDU's on this virtual channel.")
atmxVccStatsTxCells = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 4, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVccStatsTxCells.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccStatsTxCells.setDescription('The total number of transmitted cells on this virtual channel.')
atmxVccStatsTxOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 4, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVccStatsTxOctets.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccStatsTxOctets.setDescription('The total number of transmitted octets on this virtual channel.')
atmxVccStatsRxSDUs = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 4, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVccStatsRxSDUs.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccStatsRxSDUs.setDescription("The total number of received SDU's on this virtual channel.")
atmxVccStatsRxCells = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 4, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVccStatsRxCells.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccStatsRxCells.setDescription('The total number of received cells on this virtual channel.')
atmxVccStatsRxOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 4, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVccStatsRxOctets.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccStatsRxOctets.setDescription('The total number of received octets on this virtual channel.')
atmxVccStatsTxSDUDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 4, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVccStatsTxSDUDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccStatsTxSDUDiscards.setDescription('The total number of transmit SDU discards on this virtual channel.')
atmxVccStatsTxSDUErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 4, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVccStatsTxSDUErrors.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccStatsTxSDUErrors.setDescription('The total number of transmit SDU errors on this virtual channel.')
atmxVccStatsTxSDUNoBuffers = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 4, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVccStatsTxSDUNoBuffers.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccStatsTxSDUNoBuffers.setDescription("The number of transmit SDU's with no buffers on this virtual channel.")
atmxVccStatsTxCellDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 4, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVccStatsTxCellDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccStatsTxCellDiscards.setDescription('The total number of transmit cells that are dicscarded on this virtual channel.')
atmxVccStatsTxCellErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 4, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVccStatsTxCellErrors.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccStatsTxCellErrors.setDescription('The total number of transmit cell with errors on this virtual channel.')
atmxVccStatsTxCellNoBuffers = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 4, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVccStatsTxCellNoBuffers.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccStatsTxCellNoBuffers.setDescription('The total number of transmit cell with no buffers on this virtual channel.')
atmxVccStatsRxSDUDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 4, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVccStatsRxSDUDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccStatsRxSDUDiscards.setDescription("The total number of receive SDU's discarded on this virtual channel.")
atmxVccStatsRxSDUErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 4, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVccStatsRxSDUErrors.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccStatsRxSDUErrors.setDescription("The total number of receive SDU's with errors on this virtual channel.")
atmxVccStatsRxSDUInvalidSz = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 4, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVccStatsRxSDUInvalidSz.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccStatsRxSDUInvalidSz.setDescription("The total number of received SDU's with invalid size on this virtual channel.")
atmxVccStatsRxSDUNoBuffers = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 4, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVccStatsRxSDUNoBuffers.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccStatsRxSDUNoBuffers.setDescription("The total number of receive SDU's with no buffers on this virtual channel.")
atmxVccStatsRxSDUTrash = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 4, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVccStatsRxSDUTrash.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccStatsRxSDUTrash.setDescription("The total number of receive trash SDU's on this virtual channel.")
atmxVccStatsRxSDUCrcErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 4, 1, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVccStatsRxSDUCrcErrors.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccStatsRxSDUCrcErrors.setDescription("The total number of receive SDU's crc errors on this virtual channel.")
atmxVccStatsRxCellDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 4, 1, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVccStatsRxCellDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccStatsRxCellDiscards.setDescription('The total number of receive cells discarded on this virtual channel.')
atmxVccStatsRxCellErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 4, 1, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVccStatsRxCellErrors.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccStatsRxCellErrors.setDescription('The total number of recieve cell with errors on this virtual channel.')
atmxVccStatsRxCellNoBuffers = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 4, 1, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVccStatsRxCellNoBuffers.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccStatsRxCellNoBuffers.setDescription('The total number of receive cells with no buffers on this virtual channel.')
atmxVccStatsRxCellTrash = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 4, 1, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVccStatsRxCellTrash.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccStatsRxCellTrash.setDescription('The total number of recieve trash cells on this virtual channel.')
atmxVccStatsRxCellCrcErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 4, 1, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVccStatsRxCellCrcErrors.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccStatsRxCellCrcErrors.setDescription('The total number of receive cells with crc errors on this virtual channel.')
atmxVccTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 4, 5, 1), )
if mibBuilder.loadTexts: atmxVccTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccTable.setDescription('A table of ATM virtual channel connections status and parameter information.')
atmxVccEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 4, 5, 1, 1), ).setIndexNames((0, "XYLAN-ATM-MIB", "atmxVccSlotIndex"), (0, "XYLAN-ATM-MIB", "atmxVccPortIndex"), (0, "XYLAN-ATM-MIB", "atmxVccVci"))
if mibBuilder.loadTexts: atmxVccEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccEntry.setDescription('An entry in the table, containing information about the ATM virtual channel connections.')
atmxVccSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 9))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxVccSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccSlotIndex.setDescription('A unique value which identifies this hsm board slot.')
atmxVccPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxVccPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccPortIndex.setDescription('A unique value which identifies this atm submodule port.')
atmxVccVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 5, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVccVpi.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccVpi.setDescription('The virtual path identifier associated with this virtual connection.')
atmxVccVci = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 5, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1023))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxVccVci.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccVci.setDescription('The virtual channel identifier associated with the virtual connection.')
atmxVccDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 5, 1, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxVccDescription.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccDescription.setDescription('A description for this virtual connection.')
atmxVccConnType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 5, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("vcc", 1), ("vpc", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxVccConnType.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccConnType.setDescription('The virtual connection type.')
atmxVccCircuitType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 5, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("pvc", 1), ("svc", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxVccCircuitType.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccCircuitType.setDescription('The virtual connection circuit type.')
atmxVccOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 5, 1, 1, 8), AtmConnectionOperStatCodes()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVccOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccOperStatus.setDescription('The actual operational status of the VCC A value of end2endUp(2) or end2endDown(3) would be used if end-to-end status is known. If only local status information is available, a value of localUpEnd2endUnknown(4) or localDown(5) would be used.')
atmxVccUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 5, 1, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVccUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccUpTime.setDescription('The virtual channel connection up time for this connection.')
atmxVccDownTime = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 5, 1, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVccDownTime.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccDownTime.setDescription('The virtual channel connection down time for this connection.')
atmxVccTransmitMaxFrameSize = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 5, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 353208))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxVccTransmitMaxFrameSize.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccTransmitMaxFrameSize.setDescription('The virtual channel connection maximum transmit frame size for this connection.')
atmxVccReceiveMaxFrameSize = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 5, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(64, 32678))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxVccReceiveMaxFrameSize.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccReceiveMaxFrameSize.setDescription('The virtual channel connection maximum receive frame size for this connection.')
atmxVccRequestedTransmitTrafficDescriptor = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 5, 1, 1, 13), AtmTrafficDescrTypes()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxVccRequestedTransmitTrafficDescriptor.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccRequestedTransmitTrafficDescriptor.setDescription('The virtual channel connection traffic descriptor for this connection.')
atmxVccRequestedTransmitTrafficDescriptorParam1 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 5, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 353208))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxVccRequestedTransmitTrafficDescriptorParam1.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccRequestedTransmitTrafficDescriptorParam1.setDescription('The virtual channel connection traffic parameter 1 for this connection.')
atmxVccRequestedTransmitTrafficDescriptorParam2 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 5, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 353208))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxVccRequestedTransmitTrafficDescriptorParam2.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccRequestedTransmitTrafficDescriptorParam2.setDescription('The virtual channel connection traffic parameter 2 for this connection.')
atmxVccRequestedTransmitTrafficDescriptorParam3 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 5, 1, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 353208))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxVccRequestedTransmitTrafficDescriptorParam3.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccRequestedTransmitTrafficDescriptorParam3.setDescription('The virtual channel connection traffic parameter 3 for this connection.')
atmxVccRequestedTransmitTrafficQoSClass = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 5, 1, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxVccRequestedTransmitTrafficQoSClass.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccRequestedTransmitTrafficQoSClass.setDescription('The virtual channel connection QOS Class for this connection.')
atmxVccRequestedTransmitTrafficBestEffort = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 5, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxVccRequestedTransmitTrafficBestEffort.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccRequestedTransmitTrafficBestEffort.setDescription('The virtual channel connection best effort value for this connection.')
atmxVccRequestedReceiveTrafficDescriptor = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 5, 1, 1, 19), AtmTrafficDescrTypes()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxVccRequestedReceiveTrafficDescriptor.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccRequestedReceiveTrafficDescriptor.setDescription('The virtual channel connection traffic descriptor for this connection.')
atmxVccRequestedReceiveTrafficDescriptorParam1 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 5, 1, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 353208))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxVccRequestedReceiveTrafficDescriptorParam1.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccRequestedReceiveTrafficDescriptorParam1.setDescription('The virtual channel connection traffic parameter 1 for this connection.')
atmxVccRequestedReceiveTrafficDescriptorParam2 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 5, 1, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 353208))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxVccRequestedReceiveTrafficDescriptorParam2.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccRequestedReceiveTrafficDescriptorParam2.setDescription('The virtual channel connection traffic parameter 2 for this connection.')
atmxVccRequestedReceiveTrafficDescriptorParam3 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 5, 1, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 353208))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxVccRequestedReceiveTrafficDescriptorParam3.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccRequestedReceiveTrafficDescriptorParam3.setDescription('The virtual channel connection traffic parameter 3 for this connection.')
atmxVccRequestedReceiveTrafficQoSClass = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 5, 1, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxVccRequestedReceiveTrafficQoSClass.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccRequestedReceiveTrafficQoSClass.setDescription('The virtual channel connection traffic QOS Class for this connection.')
atmxVccRequestedReceiveTrafficBestEffort = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 5, 1, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxVccRequestedReceiveTrafficBestEffort.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccRequestedReceiveTrafficBestEffort.setDescription('The virtual channel connection best effort value for this connection.')
atmxVccAcceptableTransmitTrafficDescriptor = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 5, 1, 1, 25), AtmTrafficDescrTypes()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxVccAcceptableTransmitTrafficDescriptor.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccAcceptableTransmitTrafficDescriptor.setDescription('The virtual channel connection traffic descriptor for this connection.')
atmxVccAcceptableTransmitTrafficDescriptorParam1 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 5, 1, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 353208))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxVccAcceptableTransmitTrafficDescriptorParam1.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccAcceptableTransmitTrafficDescriptorParam1.setDescription('The virtual channel connection traffic parameter 1 for this connection.')
atmxVccAcceptableTransmitTrafficDescriptorParam2 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 5, 1, 1, 27), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 353208))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxVccAcceptableTransmitTrafficDescriptorParam2.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccAcceptableTransmitTrafficDescriptorParam2.setDescription('The virtual channel connection traffic parameter 2 for this connection.')
atmxVccAcceptableTransmitTrafficDescriptorParam3 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 5, 1, 1, 28), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 353208))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxVccAcceptableTransmitTrafficDescriptorParam3.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccAcceptableTransmitTrafficDescriptorParam3.setDescription('The virtual channel connection traffic parameter 3 for this connection.')
atmxVccAcceptableTransmitTrafficQoSClass = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 5, 1, 1, 29), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxVccAcceptableTransmitTrafficQoSClass.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccAcceptableTransmitTrafficQoSClass.setDescription('The virtual channel connection QOS Class for this connection.')
atmxVccAcceptableTransmitTrafficBestEffort = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 5, 1, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxVccAcceptableTransmitTrafficBestEffort.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccAcceptableTransmitTrafficBestEffort.setDescription('The virtual channel connection best effort value for this connection.')
atmxVccAcceptableReceiveTrafficDescriptor = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 5, 1, 1, 31), AtmTrafficDescrTypes()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxVccAcceptableReceiveTrafficDescriptor.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccAcceptableReceiveTrafficDescriptor.setDescription('The virtual channel connection traffic descriptor for this connection.')
atmxVccAcceptableReceiveTrafficDescriptorParam1 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 5, 1, 1, 32), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 353208))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxVccAcceptableReceiveTrafficDescriptorParam1.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccAcceptableReceiveTrafficDescriptorParam1.setDescription('The virtual channel connection traffic parameter 1 for this connection.')
atmxVccAcceptableReceiveTrafficDescriptorParam2 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 5, 1, 1, 33), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 353208))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxVccAcceptableReceiveTrafficDescriptorParam2.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccAcceptableReceiveTrafficDescriptorParam2.setDescription('The virtual channel connection traffic parameter 2 for this connection.')
atmxVccAcceptableReceiveTrafficDescriptorParam3 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 5, 1, 1, 34), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 353208))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxVccAcceptableReceiveTrafficDescriptorParam3.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccAcceptableReceiveTrafficDescriptorParam3.setDescription('The virtual channel connection traffic parameter 3 for this connection.')
atmxVccAcceptableReceiveTrafficQoSClass = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 5, 1, 1, 35), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxVccAcceptableReceiveTrafficQoSClass.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccAcceptableReceiveTrafficQoSClass.setDescription('The virtual channel connection traffic QOS Class for this connection.')
atmxVccAcceptableReceiveTrafficBestEffort = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 5, 1, 1, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxVccAcceptableReceiveTrafficBestEffort.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccAcceptableReceiveTrafficBestEffort.setDescription('The virtual channel connection best effort value for this connection.')
atmxVccActualTransmitTrafficDescriptor = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 5, 1, 1, 37), AtmTrafficDescrTypes()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVccActualTransmitTrafficDescriptor.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccActualTransmitTrafficDescriptor.setDescription('The virtual channel connection traffic descriptor for this connection.')
atmxVccActualTransmitTrafficDescriptorParam1 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 5, 1, 1, 38), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 353208))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVccActualTransmitTrafficDescriptorParam1.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccActualTransmitTrafficDescriptorParam1.setDescription('The virtual channel connection traffic parameter 1 for this connection.')
atmxVccActualTransmitTrafficDescriptorParam2 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 5, 1, 1, 39), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 353208))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVccActualTransmitTrafficDescriptorParam2.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccActualTransmitTrafficDescriptorParam2.setDescription('The virtual channel connection traffic parameter 2 for this connection.')
atmxVccActualTransmitTrafficDescriptorParam3 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 5, 1, 1, 40), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 353208))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVccActualTransmitTrafficDescriptorParam3.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccActualTransmitTrafficDescriptorParam3.setDescription('The virtual channel connection traffic parameter 3 for this connection.')
atmxVccActualTransmitTrafficQoSClass = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 5, 1, 1, 41), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVccActualTransmitTrafficQoSClass.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccActualTransmitTrafficQoSClass.setDescription('The virtual channel connection QOS Class for this connection.')
atmxVccActualTransmitTrafficBestEffort = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 5, 1, 1, 42), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVccActualTransmitTrafficBestEffort.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccActualTransmitTrafficBestEffort.setDescription('The virtual channel connection best effort value for this connection.')
atmxVccActualReceiveTrafficDescriptor = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 5, 1, 1, 43), AtmTrafficDescrTypes()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVccActualReceiveTrafficDescriptor.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccActualReceiveTrafficDescriptor.setDescription('The virtual channel connection traffic descriptor for this connection.')
atmxVccActualReceiveTrafficDescriptorParam1 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 5, 1, 1, 44), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 353208))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVccActualReceiveTrafficDescriptorParam1.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccActualReceiveTrafficDescriptorParam1.setDescription('The virtual channel connection traffic parameter 1 for this connection.')
atmxVccActualReceiveTrafficDescriptorParam2 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 5, 1, 1, 45), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 353208))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVccActualReceiveTrafficDescriptorParam2.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccActualReceiveTrafficDescriptorParam2.setDescription('The virtual channel connection traffic parameter 2 for this connection.')
atmxVccActualReceiveTrafficDescriptorParam3 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 5, 1, 1, 46), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 353208))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVccActualReceiveTrafficDescriptorParam3.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccActualReceiveTrafficDescriptorParam3.setDescription('The virtual channel connection traffic parameter 3 for this connection.')
atmxVccActualReceiveTrafficQoSClass = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 5, 1, 1, 47), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVccActualReceiveTrafficQoSClass.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccActualReceiveTrafficQoSClass.setDescription('The virtual channel connection traffic QOS Class for this connection.')
atmxVccActualReceiveTrafficBestEffort = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 5, 1, 1, 48), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVccActualReceiveTrafficBestEffort.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccActualReceiveTrafficBestEffort.setDescription('The virtual channel connection best effort value for this connection.')
atmxVccAdmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 5, 1, 1, 49), AtmAdminStatCodes()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxVccAdmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccAdmStatus.setDescription('The vcc adminstration status - used to delete a vcc.')
atmxVccServiceUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 5, 1, 1, 50), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVccServiceUsed.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccServiceUsed.setDescription('The service number in which this vcc connection is used.')
atmxVccConnectionUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 5, 1, 1, 51), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxVccConnectionUsed.setStatus('mandatory')
if mibBuilder.loadTexts: atmxVccConnectionUsed.setDescription('Connection being used or not being used, currently not implemented.')
atmxAddressTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 4, 6, 1), )
if mibBuilder.loadTexts: atmxAddressTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmxAddressTable.setDescription('A table of ATM virtual address status and parameter information.')
atmxAddressEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 4, 6, 1, 1), ).setIndexNames((0, "XYLAN-ATM-MIB", "atmxAddressIndex"))
if mibBuilder.loadTexts: atmxAddressEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmxAddressEntry.setDescription('An entry in the table, containing information about the ATM virtual address.')
atmxAddressIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 6, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1023))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxAddressIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmxAddressIndex.setDescription('A unique value which identifies this address index.')
atmxAddressAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 6, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxAddressAtmAddress.setStatus('mandatory')
if mibBuilder.loadTexts: atmxAddressAtmAddress.setDescription('A unique value which identifies this address.')
atmxAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 6, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("arpServer", 1), ("nonArpServer", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxAddressType.setStatus('mandatory')
if mibBuilder.loadTexts: atmxAddressType.setDescription('The address type.')
atmxAddressVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 6, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxAddressVpi.setStatus('mandatory')
if mibBuilder.loadTexts: atmxAddressVpi.setDescription('The virtual path identifier associated with this address.')
atmxAddressVci = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 6, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1023))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxAddressVci.setStatus('mandatory')
if mibBuilder.loadTexts: atmxAddressVci.setDescription('The virtual channel identifier associated with this address.')
atmxAddressDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 6, 1, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxAddressDescription.setStatus('mandatory')
if mibBuilder.loadTexts: atmxAddressDescription.setDescription('A description for this address.')
atmxAddressTransmitMaxSDU = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 6, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(8, 32678))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxAddressTransmitMaxSDU.setStatus('mandatory')
if mibBuilder.loadTexts: atmxAddressTransmitMaxSDU.setDescription('The address maximum transmit SDU size in bytes for this SVC.')
atmxAddressReceiveMaxSDU = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 6, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(8, 32678))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxAddressReceiveMaxSDU.setStatus('mandatory')
if mibBuilder.loadTexts: atmxAddressReceiveMaxSDU.setDescription('The address maximun receive SDU size in bytes for this SVC.')
atmxAddressRequestedTransmitTrafficDescriptor = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 6, 1, 1, 9), AtmTrafficDescrTypes()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxAddressRequestedTransmitTrafficDescriptor.setStatus('mandatory')
if mibBuilder.loadTexts: atmxAddressRequestedTransmitTrafficDescriptor.setDescription('The address traffic descriptor for this SVC.')
atmxAddressRequestedTransmitTrafficDescriptorParam1 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 6, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 353208))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxAddressRequestedTransmitTrafficDescriptorParam1.setStatus('mandatory')
if mibBuilder.loadTexts: atmxAddressRequestedTransmitTrafficDescriptorParam1.setDescription('The address transmit parameter 1 cell rate in cells/second for this SVC.')
atmxAddressRequestedTransmitTrafficDescriptorParam2 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 6, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 353208))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxAddressRequestedTransmitTrafficDescriptorParam2.setStatus('mandatory')
if mibBuilder.loadTexts: atmxAddressRequestedTransmitTrafficDescriptorParam2.setDescription('The address transmit parameter 2 cell rate in cells/second for this SVC.')
atmxAddressRequestedTransmitTrafficDescriptorParam3 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 6, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 353208))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxAddressRequestedTransmitTrafficDescriptorParam3.setStatus('mandatory')
if mibBuilder.loadTexts: atmxAddressRequestedTransmitTrafficDescriptorParam3.setDescription('The address transmit parameter 3 cell rate in cells for this SVC.')
atmxAddressRequestedTransmitTrafficQoSClass = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 6, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxAddressRequestedTransmitTrafficQoSClass.setStatus('mandatory')
if mibBuilder.loadTexts: atmxAddressRequestedTransmitTrafficQoSClass.setDescription('The address transmit traffic QOS Class for this SVC.')
atmxAddressRequestedTransmitTrafficBestEffort = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 6, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxAddressRequestedTransmitTrafficBestEffort.setStatus('mandatory')
if mibBuilder.loadTexts: atmxAddressRequestedTransmitTrafficBestEffort.setDescription('The address transmit traffic best effort value for this SVC.')
atmxAddressRequestedReceiveTrafficDescriptor = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 6, 1, 1, 15), AtmTrafficDescrTypes()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxAddressRequestedReceiveTrafficDescriptor.setStatus('mandatory')
if mibBuilder.loadTexts: atmxAddressRequestedReceiveTrafficDescriptor.setDescription('The address receive traffic descriptor for this SVC.')
atmxAddressRequestedReceiveTrafficDescriptorParam1 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 6, 1, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 353208))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxAddressRequestedReceiveTrafficDescriptorParam1.setStatus('mandatory')
if mibBuilder.loadTexts: atmxAddressRequestedReceiveTrafficDescriptorParam1.setDescription('The address receive parameter 1 cell rate in cells/second for this SVC.')
atmxAddressRequestedReceiveTrafficDescriptorParam2 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 6, 1, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 353208))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxAddressRequestedReceiveTrafficDescriptorParam2.setStatus('mandatory')
if mibBuilder.loadTexts: atmxAddressRequestedReceiveTrafficDescriptorParam2.setDescription('The address receive parameter 2 cell rate in cells/second for this SVC.')
atmxAddressRequestedReceiveTrafficDescriptorParam3 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 6, 1, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 353208))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxAddressRequestedReceiveTrafficDescriptorParam3.setStatus('mandatory')
if mibBuilder.loadTexts: atmxAddressRequestedReceiveTrafficDescriptorParam3.setDescription('The address receive parameter 2 cell rate in cells for this SVC.')
atmxAddressRequestedReceiveTrafficQoSClass = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 6, 1, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxAddressRequestedReceiveTrafficQoSClass.setStatus('mandatory')
if mibBuilder.loadTexts: atmxAddressRequestedReceiveTrafficQoSClass.setDescription('The address receive traffic QOS Class for this SVC.')
atmxAddressRequestedReceiveTrafficBestEffort = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 6, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxAddressRequestedReceiveTrafficBestEffort.setStatus('mandatory')
if mibBuilder.loadTexts: atmxAddressRequestedReceiveTrafficBestEffort.setDescription('The address receive traffic best effort value for this SVC.')
atmxAddressAcceptableTransmitTrafficDescriptor = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 6, 1, 1, 21), AtmTrafficDescrTypes()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxAddressAcceptableTransmitTrafficDescriptor.setStatus('mandatory')
if mibBuilder.loadTexts: atmxAddressAcceptableTransmitTrafficDescriptor.setDescription('The address traffic descriptor for this SVC.')
atmxAddressAcceptableTransmitTrafficDescriptorParam1 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 6, 1, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 353208))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxAddressAcceptableTransmitTrafficDescriptorParam1.setStatus('mandatory')
if mibBuilder.loadTexts: atmxAddressAcceptableTransmitTrafficDescriptorParam1.setDescription('The address transmit parameter 1 cell rate in cells/second for this SVC.')
atmxAddressAcceptableTransmitTrafficDescriptorParam2 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 6, 1, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 353208))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxAddressAcceptableTransmitTrafficDescriptorParam2.setStatus('mandatory')
if mibBuilder.loadTexts: atmxAddressAcceptableTransmitTrafficDescriptorParam2.setDescription('The address transmit parameter 2 cell rate in cells/second for this SVC.')
atmxAddressAcceptableTransmitTrafficDescriptorParam3 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 6, 1, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 353208))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxAddressAcceptableTransmitTrafficDescriptorParam3.setStatus('mandatory')
if mibBuilder.loadTexts: atmxAddressAcceptableTransmitTrafficDescriptorParam3.setDescription('The address transmit parameter 3 cell rate in cells for this SVC.')
atmxAddressAcceptableTransmitTrafficQoSClass = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 6, 1, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxAddressAcceptableTransmitTrafficQoSClass.setStatus('mandatory')
if mibBuilder.loadTexts: atmxAddressAcceptableTransmitTrafficQoSClass.setDescription('The address transmit traffic QOS Class for this SVC.')
atmxAddressAcceptableTransmitTrafficBestEffort = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 6, 1, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxAddressAcceptableTransmitTrafficBestEffort.setStatus('mandatory')
if mibBuilder.loadTexts: atmxAddressAcceptableTransmitTrafficBestEffort.setDescription('The address transmit traffic best effort value for this SVC.')
atmxAddressAcceptableReceiveTrafficDescriptor = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 6, 1, 1, 27), AtmTrafficDescrTypes()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxAddressAcceptableReceiveTrafficDescriptor.setStatus('mandatory')
if mibBuilder.loadTexts: atmxAddressAcceptableReceiveTrafficDescriptor.setDescription('The address receive traffic descriptor for this SVC.')
atmxAddressAcceptableReceiveTrafficDescriptorParam1 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 6, 1, 1, 28), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 353208))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxAddressAcceptableReceiveTrafficDescriptorParam1.setStatus('mandatory')
if mibBuilder.loadTexts: atmxAddressAcceptableReceiveTrafficDescriptorParam1.setDescription('The address receive parameter 1 cell rate in cells/second for this SVC.')
atmxAddressAcceptableReceiveTrafficDescriptorParam2 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 6, 1, 1, 29), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 353208))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxAddressAcceptableReceiveTrafficDescriptorParam2.setStatus('mandatory')
if mibBuilder.loadTexts: atmxAddressAcceptableReceiveTrafficDescriptorParam2.setDescription('The address receive parameter 2 cell rate in cells/second for this SVC.')
atmxAddressAcceptableReceiveTrafficDescriptorParam3 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 6, 1, 1, 30), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 353208))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxAddressAcceptableReceiveTrafficDescriptorParam3.setStatus('mandatory')
if mibBuilder.loadTexts: atmxAddressAcceptableReceiveTrafficDescriptorParam3.setDescription('The address receive parameter 2 cell rate in cells for this SVC.')
atmxAddressAcceptableReceiveTrafficQoSClass = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 6, 1, 1, 31), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxAddressAcceptableReceiveTrafficQoSClass.setStatus('mandatory')
if mibBuilder.loadTexts: atmxAddressAcceptableReceiveTrafficQoSClass.setDescription('The address receive traffic QOS Class for this SVC.')
atmxAddressAcceptableReceiveTrafficBestEffort = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 6, 1, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxAddressAcceptableReceiveTrafficBestEffort.setStatus('mandatory')
if mibBuilder.loadTexts: atmxAddressAcceptableReceiveTrafficBestEffort.setDescription('The address receive traffic best effort value for this SVC.')
atmxAddressAdmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 6, 1, 1, 33), AtmAdminStatCodes()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxAddressAdmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmxAddressAdmStatus.setDescription('The address adminstration status - used to delete an address.')
atmxAddressServiceUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 6, 1, 1, 34), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxAddressServiceUsed.setStatus('mandatory')
if mibBuilder.loadTexts: atmxAddressServiceUsed.setDescription('The service number in which this address is used.')
atmxAddressAddrUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 6, 1, 1, 35), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxAddressAddrUsed.setStatus('mandatory')
if mibBuilder.loadTexts: atmxAddressAddrUsed.setDescription('Address being used or not being used, currently not implemented.')
atmxArpTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 4, 7, 1), )
if mibBuilder.loadTexts: atmxArpTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmxArpTable.setDescription('A table of ATM address to IP address information.')
atmxArpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 4, 7, 1, 1), ).setIndexNames((0, "XYLAN-ATM-MIB", "atmxArpIndex"))
if mibBuilder.loadTexts: atmxArpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmxArpEntry.setDescription('An entry in the table, containing information about the ATM address.')
atmxArpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 7, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxArpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmxArpIndex.setDescription('A unique value which identifies this arp entry.')
atmxArpIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 7, 1, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxArpIPAddress.setStatus('mandatory')
if mibBuilder.loadTexts: atmxArpIPAddress.setDescription('The IP address for this atm address.')
atmxArpAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 7, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxArpAtmAddress.setStatus('mandatory')
if mibBuilder.loadTexts: atmxArpAtmAddress.setDescription('A unique value which identifies this address.')
atmxArpVci = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 7, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1023))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxArpVci.setStatus('mandatory')
if mibBuilder.loadTexts: atmxArpVci.setDescription('The virtual channel identifier associated with this address.')
atmxArpTimeToLive = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 7, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxArpTimeToLive.setStatus('mandatory')
if mibBuilder.loadTexts: atmxArpTimeToLive.setDescription('The address time to live.')
atmxArpType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 7, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("static", 1), ("dynamic", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxArpType.setStatus('mandatory')
if mibBuilder.loadTexts: atmxArpType.setDescription('The address type, statically or dynamically created.')
atmLecConfigTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 1), )
if mibBuilder.loadTexts: atmLecConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmLecConfigTable.setDescription('This table contains all the configuration parameters for a LAN Emulation client. ')
atmLecConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 1, 1), ).setIndexNames((0, "XYLAN-ATM-MIB", "atmxLecConfigIndex"))
if mibBuilder.loadTexts: atmLecConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmLecConfigEntry.setDescription('Each table entry contains configuration information for one LAN Emulation Client. Most of the objects are derived from Initial State Parameters in the LAN Emulation specification.')
atmxLecConfigIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxLecConfigIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmxLecConfigIndex.setDescription('Index to identify an instance of this table.')
atmLecConfigLecsAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 1, 1, 2), XylanAtmLaneAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmLecConfigLecsAtmAddress.setStatus('mandatory')
if mibBuilder.loadTexts: atmLecConfigLecsAtmAddress.setDescription('The LAN Emulation Configuration Server which this client can use if the Well Known LECS address is not used.')
atmLecConfigUseDefaultLecsAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 1, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmLecConfigUseDefaultLecsAddr.setStatus('mandatory')
if mibBuilder.loadTexts: atmLecConfigUseDefaultLecsAddr.setDescription('This is to specify if this client is to use the Well Know LECS address or user supplied address. This object alone with atmLecConfigLecsAtmAddress is meaningless if the atmLecConfigMode is setted to manual(2) mode. 1 = TRUE 2 = FALSE ')
atmLecRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 1, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmLecRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmLecRowStatus.setDescription('This object lets network managers create and delete an instance for this table. 1 = Create, 2 = Delete, 3 = Modify.')
atmLecRowInUse = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLecRowInUse.setStatus('mandatory')
if mibBuilder.loadTexts: atmLecRowInUse.setDescription('This object returns a value to indicate if this instance is used by an ATM service. 1 = In use 2 = Free. ')
atmLecConfigMode = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("automatic", 1), ("manual", 2))).clone('automatic')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmLecConfigMode.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Sections 3.4.1.1 and 5.3')
if mibBuilder.loadTexts: atmLecConfigMode.setStatus('mandatory')
if mibBuilder.loadTexts: atmLecConfigMode.setDescription('Indicates whether this LAN Emulation Client should auto-configure the next time it is (re)started. In automatic(1) mode, a client uses a LAN Emulation Configuration Server to learn the ATM address of its LAN Emulation Server, and to obtain other parameters. atmLecConfig{ LanType, MaxDataFrameSize, LanName } are used in the Configure request. atmLecConfigLesAtmAddress is ignored. In manual(2) mode, management tells the client the ATM address of its LAN Emulation Server and the values of other parameters. atmLecConfig{ LanType, MaxDataFrameSize, LanName } are used in the Join request. atmLecConfigLesAtmAddress tells the client which LES to call.')
atmLecConfigLanType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 1, 1, 7), LecDataFrameFormat().clone('aflane8023')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmLecConfigLanType.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 5.1.1')
if mibBuilder.loadTexts: atmLecConfigLanType.setStatus('mandatory')
if mibBuilder.loadTexts: atmLecConfigLanType.setDescription('C2 LAN Type. The data frame format which this client will use the next time it returns to the Initial State. Auto-configuring clients use this parameter in their Configure requests. Manually-configured clients use it in their Join requests. This MIB object will not be overwritten with the new value from a LE_{JOIN,CONFIGURE}_RESPONSE. Instead, atmLecActualLanType will be.')
atmLecConfigMaxDataFrameSize = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 1, 1, 8), LecDataFrameSize().clone('max4544')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmLecConfigMaxDataFrameSize.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 5.1.1')
if mibBuilder.loadTexts: atmLecConfigMaxDataFrameSize.setStatus('mandatory')
if mibBuilder.loadTexts: atmLecConfigMaxDataFrameSize.setDescription('C3 Maximum Data Frame Size. The maximum data frame size which this client will use the next time it returns to the Initial State. Auto-configuring clients use this parameter in their Configure requests. Manually-configured clients use it in their Join requests. This MIB object will not be overwritten with the new value from a LE_{JOIN,CONFIGURE}_RESPONSE. Instead, atmLecActualMaxDataFrameSize will be.')
atmLecConfigLanName = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 1, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmLecConfigLanName.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 5.1.1')
if mibBuilder.loadTexts: atmLecConfigLanName.setStatus('mandatory')
if mibBuilder.loadTexts: atmLecConfigLanName.setDescription('C5 ELAN Name. The ELAN Name this client will use the next time it returns to the Initial State. Auto-configuring clients use this parameter in their Configure requests. Manually-configured clients use it in their Join requests. This MIB object will not be overwritten with the new value from a LE_{JOIN,CONFIGURE}_RESPONSE. Instead, atmLecActualLanName will be.')
atmLecConfigLesAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 1, 1, 10), XylanAtmLaneAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmLecConfigLesAtmAddress.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 5.1.1')
if mibBuilder.loadTexts: atmLecConfigLesAtmAddress.setStatus('mandatory')
if mibBuilder.loadTexts: atmLecConfigLesAtmAddress.setDescription("C9 LE Server ATM Address. The LAN Emulation Server which this client will use the next time it is started in manual configuration mode. When atmLecConfigMode is 'automatic', there is no need to set this address, and no advantage to doing so. The client will use the LECS to find a LES, putting the auto-configured address in atmLecActualLesAtmAddress while leaving atmLecConfigLesAtmAddress alone.")
atmLecControlTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 300)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmLecControlTimeout.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 5.1.1')
if mibBuilder.loadTexts: atmLecControlTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: atmLecControlTimeout.setDescription('C7 Control Time-out. Time out period used for timing out most request/response control frame interactions, as specified elsewhere [in the LAN Emulation specification]. This time value is expressed in seconds.')
atmLecMaxUnknownFrameCount = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmLecMaxUnknownFrameCount.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 5.1.1')
if mibBuilder.loadTexts: atmLecMaxUnknownFrameCount.setStatus('mandatory')
if mibBuilder.loadTexts: atmLecMaxUnknownFrameCount.setDescription('C10 Maximum Unknown Frame Count. See the description of atmLecMaxUnknownFrameTime below.')
atmLecMaxUnknownFrameTime = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmLecMaxUnknownFrameTime.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 5.1.1')
if mibBuilder.loadTexts: atmLecMaxUnknownFrameTime.setStatus('mandatory')
if mibBuilder.loadTexts: atmLecMaxUnknownFrameTime.setDescription('C11 Maximum Unknown Frame Time. Within the period of time defined by the Maximum Unknown Frame Time, a LE Client will send no more than Maximum Unknown Frame Count frames to the BUS for a given unicast LAN Destination, and it must also initiate the address resolution protocol to resolve that LAN Destination. This time value is expressed in seconds.')
atmLecVccTimeoutPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 1, 1, 14), Integer32().clone(1200)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmLecVccTimeoutPeriod.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 5.1.1')
if mibBuilder.loadTexts: atmLecVccTimeoutPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: atmLecVccTimeoutPeriod.setDescription('C12 VCC Time-out Period. A LE Client SHOULD release any Data Direct VCC that it has not used to transmit or receive any data frames for the length of the VCC Time-out Period. This parameter is only meaningful for SVC Data Direct VCCs. This time value is expressed in seconds. The default value is 20 minutes. A value of 0 seconds means that the timeout period is infinite. Negative values will be rejected by the agent.')
atmLecMaxRetryCount = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmLecMaxRetryCount.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 5.1.1')
if mibBuilder.loadTexts: atmLecMaxRetryCount.setStatus('mandatory')
if mibBuilder.loadTexts: atmLecMaxRetryCount.setDescription("C13 Maximum Retry Count. A LE CLient MUST not retry a LE_ARP_REQUEST for a given frame's LAN destination more than Maximum Retry Count times, after the first LE_ARP_REQUEST for that same frame's LAN destination.")
atmLecAgingTime = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 1, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 300)).clone(300)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmLecAgingTime.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 5.1.1')
if mibBuilder.loadTexts: atmLecAgingTime.setStatus('mandatory')
if mibBuilder.loadTexts: atmLecAgingTime.setDescription('C17 Aging Time. The maximum time that a LE Client will maintain an entry in its LE_ARP cache in the absence of a verification of that relationship. This time value is expressed in seconds.')
atmLecForwardDelayTime = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 1, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(4, 30)).clone(15)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmLecForwardDelayTime.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 5.1.1')
if mibBuilder.loadTexts: atmLecForwardDelayTime.setStatus('mandatory')
if mibBuilder.loadTexts: atmLecForwardDelayTime.setDescription('C18 Forward Delay Time. The maximum time that a LE Client will maintain an entry for a non-local MAC address in its LE_ARP cache in the absence of a verification of that relationship, as long as the Topology Change flag C19 is true. atmLecForwardDelayTime SHOULD BE less than atmLecAgingTime. When it is not, atmLecAgingTime governs LE_ARP aging. This time value is expressed in seconds.')
atmLecExpectedArpResponseTime = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 1, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 30)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmLecExpectedArpResponseTime.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 5.1.1')
if mibBuilder.loadTexts: atmLecExpectedArpResponseTime.setStatus('mandatory')
if mibBuilder.loadTexts: atmLecExpectedArpResponseTime.setDescription('C20 Expected LE_ARP Reponse Time. The maximum time that the LEC expects an LE_ARP_REQUEST/ LE_ARP_RESPONSE cycle to take. Used for retries and verifies. This time value is expressed in seconds.')
atmLecFlushTimeOut = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 1, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmLecFlushTimeOut.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 5.1.1')
if mibBuilder.loadTexts: atmLecFlushTimeOut.setStatus('mandatory')
if mibBuilder.loadTexts: atmLecFlushTimeOut.setDescription('C21 Flush Time-out. Time limit to wait to receive a LE_FLUSH_RESPONSE after the LE_FLUSH_REQUEST has been sent before taking recovery action. This time value is expressed in seconds.')
atmLecPathSwitchingDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 1, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8)).clone(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmLecPathSwitchingDelay.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 5.1.1')
if mibBuilder.loadTexts: atmLecPathSwitchingDelay.setStatus('mandatory')
if mibBuilder.loadTexts: atmLecPathSwitchingDelay.setDescription('C22 Path Switching Delay. The time since sending a frame to the BUS after which the LE Client may assume that the frame has been either discarded or delivered to the recipient. May be used to bypass the Flush protocol. This time value is expressed in seconds.')
atmLecUseForwardDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 1, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmLecUseForwardDelay.setStatus('mandatory')
if mibBuilder.loadTexts: atmLecUseForwardDelay.setDescription(' This is specify whether to use Forward delay or arp cache aging time 1 = No, 2 = Yes.')
atmLecUseTranslation = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 1, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmLecUseTranslation.setStatus('mandatory')
if mibBuilder.loadTexts: atmLecUseTranslation.setDescription(' Use translation option or not. If set to yes, user must set the translation options by the swch command in UI or the vportSwitchTable to set the translation option other than the default defined for LANE. 1 = no, 2 = yes.')
atmLecSrBridgeNum = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 1, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmLecSrBridgeNum.setStatus('mandatory')
if mibBuilder.loadTexts: atmLecSrBridgeNum.setDescription(' SR bridge number for the LEC')
atmLecSrRingNum = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 1, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmLecSrRingNum.setStatus('mandatory')
if mibBuilder.loadTexts: atmLecSrRingNum.setDescription(' SR Ring number for the LEC')
atmLecStatusTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 2), )
if mibBuilder.loadTexts: atmLecStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmLecStatusTable.setDescription('A read-only table containing identification, status, and operational information about the LAN Emulation Clients this agent manages.')
atmLecStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 2, 1), ).setIndexNames((0, "XYLAN-ATM-MIB", "atmxLecStatusSlotIndex"), (0, "XYLAN-ATM-MIB", "atmxLecStatusPortIndex"), (0, "XYLAN-ATM-MIB", "atmxLecStatusServiceNum"))
if mibBuilder.loadTexts: atmLecStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmLecStatusEntry.setDescription('Each table entry contains information about one LAN Emulation Client.')
atmxLecStatusSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxLecStatusSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmxLecStatusSlotIndex.setDescription('Slot index to identify an instance of this table.')
atmxLecStatusPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxLecStatusPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmxLecStatusPortIndex.setDescription('Port index to identify an instance of this table.')
atmxLecStatusServiceNum = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxLecStatusServiceNum.setStatus('mandatory')
if mibBuilder.loadTexts: atmxLecStatusServiceNum.setDescription('Service number index to identify an instance of this table.')
atmLecPrimaryAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 2, 1, 4), XylanAtmLaneAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLecPrimaryAtmAddress.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 5.1.1')
if mibBuilder.loadTexts: atmLecPrimaryAtmAddress.setStatus('mandatory')
if mibBuilder.loadTexts: atmLecPrimaryAtmAddress.setDescription("C1 LE Client's ATM Addresses. The primary ATM address of this LAN Emulation Client. This address is used to establish the Control Direct and Multicast Send VCCs, and may also be used to set up Data Direct VCCs. A client may have additional ATM addresses for use with Data Direct VCCs. These addresses are readable via the atmLecAtmAddressTable.")
atmLecID = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65279))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLecID.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 5.1.1')
if mibBuilder.loadTexts: atmLecID.setStatus('mandatory')
if mibBuilder.loadTexts: atmLecID.setDescription("C14 LE Client Identifier. Each LE Client requires a LE Client Identifier (LECID) assigned by the LE Server during the Join phase. The LECID is placed in control requests by the LE Client and MAY be used for echo suppression on multicast data frames sent by that LE Client. This value MUST NOT change without terminating the LE Client and returning to the Initial state. A valid LECID MUST be in the range X'0001' through X'FEFF'. The value of this object is only meaningful for a LEC that is connected to a LES. For a LEC which does not belong to an emulated LAN, the value of this object is defined to be 0.")
atmLecInterfaceState = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 2, 1, 6), LecState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLecInterfaceState.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 2.3.1')
if mibBuilder.loadTexts: atmLecInterfaceState.setStatus('mandatory')
if mibBuilder.loadTexts: atmLecInterfaceState.setDescription("The mandatory state of the LAN Emulation Client. Note that 'ifOperStatus' is defined to be 'up' when, and only when, 'atmLecInterfaceState' is 'operational'.")
atmLecLastFailureRespCode = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("none", 1), ("timeout", 2), ("undefinedError", 3), ("versionNotSupported", 4), ("invalidRequestParameters", 5), ("duplicateLanDestination", 6), ("duplicateAtmAddress", 7), ("insufficientResources", 8), ("accessDenied", 9), ("invalidRequesterId", 10), ("invalidLanDestination", 11), ("invalidAtmAddress", 12), ("noConfiguration", 13), ("leConfigureError", 14), ("insufficientInformation", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLecLastFailureRespCode.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 4.2, Table 13')
if mibBuilder.loadTexts: atmLecLastFailureRespCode.setStatus('mandatory')
if mibBuilder.loadTexts: atmLecLastFailureRespCode.setDescription("Status code from the last failed Configure response or Join response. Failed responses are those for which the LE_CONFIGURE_RESPONSE / LE_JOIN_RESPONSE frame contains a non-zero code, or fails to arrive within a timeout period. If none of this client's requests have failed, this object has the value 'none'. If the failed response contained a STATUS code that is not defined in the LAN Emulation specification, this object has the value 'undefinedError'. The value 'timeout' is self-explanatory. Other failure codes correspond to those defined in the specification, although they may have different numeric values.")
atmLecLastFailureState = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 2, 1, 8), LecState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLecLastFailureState.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 2.3.1')
if mibBuilder.loadTexts: atmLecLastFailureState.setStatus('mandatory')
if mibBuilder.loadTexts: atmLecLastFailureState.setDescription("The state this client was in when it updated the 'atmLecLastFailureRespCode'. If 'atmLecLastFailureRespCode' is 'none', this object has the value initialState(1).")
atmLecProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLecProtocol.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 4.2')
if mibBuilder.loadTexts: atmLecProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: atmLecProtocol.setDescription('The LAN Emulation protocol which this client supports, and specifies in its LE_JOIN_REQUESTs.')
atmLecVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 2, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLecVersion.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 4.2')
if mibBuilder.loadTexts: atmLecVersion.setStatus('mandatory')
if mibBuilder.loadTexts: atmLecVersion.setDescription('The LAN Emulation protocol version which this client supports, and specifies in its LE_JOIN_REQUESTs.')
atmLecTopologyChange = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 2, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLecTopologyChange.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 5.1.1')
if mibBuilder.loadTexts: atmLecTopologyChange.setStatus('mandatory')
if mibBuilder.loadTexts: atmLecTopologyChange.setDescription("C19 Topology Change. Boolean indication that the LE Client is using the Forward Delay Time C18, instead of the Aging Time C17, to age non-local entries in its LE_ARP cache C16. For a client which is not connected to the LES, this object is defined to have the value 'false'.")
atmLecConfigServerAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 2, 1, 12), XylanAtmLaneAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLecConfigServerAtmAddress.setStatus('mandatory')
if mibBuilder.loadTexts: atmLecConfigServerAtmAddress.setDescription('The ATM address of the LAN Emulation Configuration Server (if known) or the empty string (otherwise).')
atmLecConfigSource = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("gotAddressViaIlmi", 1), ("usedWellKnownAddress", 2), ("usedLecsPvc", 3), ("didNotUseLecs", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLecConfigSource.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 5.2')
if mibBuilder.loadTexts: atmLecConfigSource.setStatus('mandatory')
if mibBuilder.loadTexts: atmLecConfigSource.setDescription('Indicates whether this LAN Emulation Client used the LAN Emulation Configuration Server, and, if so, what method it used to establish the Configuration Direct VCC.')
atmLecActualLanType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 2, 1, 14), LecDataFrameFormat()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLecActualLanType.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 5.1.1')
if mibBuilder.loadTexts: atmLecActualLanType.setStatus('mandatory')
if mibBuilder.loadTexts: atmLecActualLanType.setDescription("C2 LAN Type. The data frame format that this LAN Emulation Client is using right now. This may come from * atmLecConfigLanType, * the LAN Emulation Configuration Server, or * the LAN Emulation Server This value is related to 'ifMtu' and 'ifType'. See the LEC management specification for more details.")
atmLecActualMaxDataFrameSize = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 2, 1, 15), LecDataFrameSize()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLecActualMaxDataFrameSize.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 5.1.1')
if mibBuilder.loadTexts: atmLecActualMaxDataFrameSize.setStatus('mandatory')
if mibBuilder.loadTexts: atmLecActualMaxDataFrameSize.setDescription('C3 Maximum Data Frame Size. The maximum data frame size that this LAN Emulation client is using right now. This may come from * atmLecConfigMaxDataFrameSize, * the LAN Emulation Configuration Server, or * the LAN Emulation Server ')
atmLecActualLanName = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 2, 1, 16), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLecActualLanName.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 5.1.1')
if mibBuilder.loadTexts: atmLecActualLanName.setStatus('mandatory')
if mibBuilder.loadTexts: atmLecActualLanName.setDescription('C5 ELAN Name. The identity of the emulated LAN which this client last joined, or wishes to join. This may come from * atmLecConfigLanName, * the LAN Emulation Configuration Server, or * the LAN Emulation Server ')
atmLecActualLesAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 2, 1, 17), XylanAtmLaneAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLecActualLesAtmAddress.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 5.1.1')
if mibBuilder.loadTexts: atmLecActualLesAtmAddress.setStatus('mandatory')
if mibBuilder.loadTexts: atmLecActualLesAtmAddress.setDescription("C9 LE Server ATM Address. The LAN Emulation Server address currently in use or most recently attempted. If no LAN Emulation Server attachment has been tried, this object's value is the zero-length string.")
atmLecProxyClient = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 2, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLecProxyClient.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 5.1.1')
if mibBuilder.loadTexts: atmLecProxyClient.setStatus('mandatory')
if mibBuilder.loadTexts: atmLecProxyClient.setDescription('C4 Proxy. Indicates whether this client is acting as a proxy. Proxy clients are allowed to represent unregistered MAC addresses, and receive copies of LE_ARP_REQUEST frames for such addresses.')
atmLecStatisticsTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 3), )
if mibBuilder.loadTexts: atmLecStatisticsTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmLecStatisticsTable.setDescription('An extension table containing traffic statistics for all the LAN Emulation Clients this host implements.')
atmLecStatisticsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 3, 1), ).setIndexNames((0, "XYLAN-ATM-MIB", "atmxLecStatsSlotIndex"), (0, "XYLAN-ATM-MIB", "atmxLecStatsPortIndex"), (0, "XYLAN-ATM-MIB", "atmxLecStatsServiceNum"))
if mibBuilder.loadTexts: atmLecStatisticsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmLecStatisticsEntry.setDescription('Each row in this table contains traffic statistics for one LAN Emulation client.')
atmxLecStatsSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxLecStatsSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmxLecStatsSlotIndex.setDescription('Slot index to identify an instance of this table.')
atmxLecStatsPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxLecStatsPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmxLecStatsPortIndex.setDescription('Port index to identify an instance of this table.')
atmxLecStatsServiceNum = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxLecStatsServiceNum.setStatus('mandatory')
if mibBuilder.loadTexts: atmxLecStatsServiceNum.setDescription('Service number index to identify an instance of this table.')
atmLecArpRequestsOut = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLecArpRequestsOut.setStatus('mandatory')
if mibBuilder.loadTexts: atmLecArpRequestsOut.setDescription('The number of LE_ARP_REQUESTs sent over the LUNI by this LAN Emulation Client.')
atmLecArpRequestsIn = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLecArpRequestsIn.setStatus('mandatory')
if mibBuilder.loadTexts: atmLecArpRequestsIn.setDescription('The number of LE_ARP_REQUESTs received over the LUNI by this LAN Emulation Client. Requests may arrive on the Control Direct VCC or on the Control Distribute VCC, depending upon how the LES is implemented and the chances it has had for learning. This counter covers both VCCs.')
atmLecArpRepliesOut = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLecArpRepliesOut.setStatus('mandatory')
if mibBuilder.loadTexts: atmLecArpRepliesOut.setDescription('The number of LE_ARP_RESPONSEs sent over the LUNI by this LAN Emulation Client.')
atmLecArpRepliesIn = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLecArpRepliesIn.setStatus('mandatory')
if mibBuilder.loadTexts: atmLecArpRepliesIn.setDescription('The number of LE_ARP_RESPONSEs received over the LUNI by this LAN Emulation Client. This count includes all such replies, whether solicited or not. Replies may arrive on the Control Direct VCC or on the Control Distribute VCC, depending upon how the LES is implemented. This counter covers both VCCs.')
atmLecControlFramesOut = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 3, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLecControlFramesOut.setStatus('mandatory')
if mibBuilder.loadTexts: atmLecControlFramesOut.setDescription('The total number of control packets sent by this LAN Emulation Client over the LUNI.')
atmLecControlFramesIn = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 3, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLecControlFramesIn.setStatus('mandatory')
if mibBuilder.loadTexts: atmLecControlFramesIn.setDescription('The total number of control packets received by this LAN Emulation Client over the LUNI.')
atmLecSvcFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 3, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLecSvcFailures.setStatus('mandatory')
if mibBuilder.loadTexts: atmLecSvcFailures.setDescription('The total number of * outgoing LAN Emulation SVCs which this client tried, but failed, to open; * incoming LAN Emulation SVCs which this client tried, but failed to establish; and * incoming LAN Emulation SVCs which this client rejected for protocol or security reasons. ')
atmLecServerVccTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 4), )
if mibBuilder.loadTexts: atmLecServerVccTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmLecServerVccTable.setDescription('A table identifying the Control and Multicast VCCs for each LAN Emulation Client this host implements.')
atmLecServerVccEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 4, 1), ).setIndexNames((0, "XYLAN-ATM-MIB", "atmxLecSlotIndex"), (0, "XYLAN-ATM-MIB", "atmxLecPortIndex"), (0, "XYLAN-ATM-MIB", "atmxLecServiceNum"))
if mibBuilder.loadTexts: atmLecServerVccEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmLecServerVccEntry.setDescription('Each row in this table describes the Control VCCs and Multicast VCCs for one LAN Emulation client.')
atmxLecSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxLecSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmxLecSlotIndex.setDescription('index that uniquely identify an instance of the atmLecServerVccTable.')
atmxLecPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxLecPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmxLecPortIndex.setDescription('index that uniquely identify an instance of the atmLecServerVccTable.')
atmxLecServiceNum = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 4, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxLecServiceNum.setStatus('mandatory')
if mibBuilder.loadTexts: atmxLecServiceNum.setDescription('Index that uniquely identify an instance of the atmLecServerVccTable.')
atmLecConfigDirectVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 4, 1, 4), VpiInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLecConfigDirectVpi.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 2.2.2.1.1')
if mibBuilder.loadTexts: atmLecConfigDirectVpi.setStatus('mandatory')
if mibBuilder.loadTexts: atmLecConfigDirectVpi.setDescription('If the Configuration Direct VCC exists, this object contains the VPI which identifies that VCC at the point where it connects to this LE client. Otherwise, this object has the value 0.')
atmLecConfigDirectVci = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 4, 1, 5), VciInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLecConfigDirectVci.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 2.2.2.1.1')
if mibBuilder.loadTexts: atmLecConfigDirectVci.setStatus('mandatory')
if mibBuilder.loadTexts: atmLecConfigDirectVci.setDescription('If the Configuration Direct VCC exists, this object contains the VCI which identifies that VCC at the point where it connects to this LE client. Otherwise, this object has the value 0.')
atmLecControlDirectVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 4, 1, 6), VpiInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLecControlDirectVpi.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 2.2.2.1.2')
if mibBuilder.loadTexts: atmLecControlDirectVpi.setStatus('mandatory')
if mibBuilder.loadTexts: atmLecControlDirectVpi.setDescription('If the Control Direct VCC exists, this object contains the VPI which identifies that VCC at the point where it connects to this LE client. Otherwise, this object has the value 0.')
atmLecControlDirectVci = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 4, 1, 7), VciInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLecControlDirectVci.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 2.2.2.1.2')
if mibBuilder.loadTexts: atmLecControlDirectVci.setStatus('mandatory')
if mibBuilder.loadTexts: atmLecControlDirectVci.setDescription('If the Control Direct VCC exists, this object contains the VCI which identifies that VCC at the point where it connects to this LE client. Otherwise, this object has the value 0.')
atmLecControlDistributeVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 4, 1, 8), VpiInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLecControlDistributeVpi.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 2.2.2.1.3')
if mibBuilder.loadTexts: atmLecControlDistributeVpi.setStatus('mandatory')
if mibBuilder.loadTexts: atmLecControlDistributeVpi.setDescription('If the Control Distribute VCC exists, this object contains the VPI which identifies that VCC at the point where it connects to this LE client. Otherwise, this object has the value 0.')
atmLecControlDistributeVci = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 4, 1, 9), VciInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLecControlDistributeVci.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 2.2.2.1.3')
if mibBuilder.loadTexts: atmLecControlDistributeVci.setStatus('mandatory')
if mibBuilder.loadTexts: atmLecControlDistributeVci.setDescription('If the Control Distribute VCC exists, this object contains the VCI which identifies that VCC at the point where it connects to this LE client. Otherwise, this object contains the value 0.')
atmLecMulticastSendVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 4, 1, 10), VpiInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLecMulticastSendVpi.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 2.2.2.2.2')
if mibBuilder.loadTexts: atmLecMulticastSendVpi.setStatus('mandatory')
if mibBuilder.loadTexts: atmLecMulticastSendVpi.setDescription('If the Multicast Send VCC exists, this object contains the VPI which identifies that VCC at the point where it connects to this LE client. Otherwise, this object has the value 0.')
atmLecMulticastSendVci = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 4, 1, 11), VciInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLecMulticastSendVci.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 2.2.2.2.2')
if mibBuilder.loadTexts: atmLecMulticastSendVci.setStatus('mandatory')
if mibBuilder.loadTexts: atmLecMulticastSendVci.setDescription('If the Multicast Send VCC exists, this object contains the VCI which identifies that VCC at the point where it connects to this LE client. Otherwise, this object has the value 0.')
atmLecMulticastForwardVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 4, 1, 12), VpiInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLecMulticastForwardVpi.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 2.2.2.2.3')
if mibBuilder.loadTexts: atmLecMulticastForwardVpi.setStatus('mandatory')
if mibBuilder.loadTexts: atmLecMulticastForwardVpi.setDescription('If the Multicast Forward VCC exists, this object contains the VPI which identifies that VCC at the point where it connects to this LE client. Otherwise, this object has the value 0.')
atmLecMulticastForwardVci = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 4, 1, 13), VciInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLecMulticastForwardVci.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 2.2.2.2.3')
if mibBuilder.loadTexts: atmLecMulticastForwardVci.setStatus('mandatory')
if mibBuilder.loadTexts: atmLecMulticastForwardVci.setDescription('If the Multicast Forward VCC exists, this object contains the VCI which identifies that VCC at the point where it connects to this LE client. Otherwise, this object has the value 0.')
atmLeArpTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 5), )
if mibBuilder.loadTexts: atmLeArpTable.setReference('ATM Forum LAN Emulation Over ATM Specification, Section 5.1.1')
if mibBuilder.loadTexts: atmLeArpTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmLeArpTable.setDescription("This table provides access to an ATM LAN Emulation Client's MAC-to-ATM ARP cache. It contains entries for unicast addresses and for the broadcast address, but not for multicast MAC addresses. C16 LE_ARP Cache. A table of entries, each of which establishes a relationship between a LAN Destination external to the LE Client and the ATM address to which data frames for that LAN Destination will be sent.")
atmLeArpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 5, 1), ).setIndexNames((0, "XYLAN-ATM-MIB", "atmxLeArpSlotIndex"), (0, "XYLAN-ATM-MIB", "atmxLeArpPortIndex"), (0, "XYLAN-ATM-MIB", "atmxLeArpServiceNum"), (0, "XYLAN-ATM-MIB", "atmLeArpIndex"))
if mibBuilder.loadTexts: atmLeArpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmLeArpEntry.setDescription('An ATM LAN Emulation ARP cache entry containing information about the binding of one MAC address to one ATM address.')
atmxLeArpSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxLeArpSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmxLeArpSlotIndex.setDescription('Slot index that uniquely identify an instance of the LeArp Table.')
atmxLeArpPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 5, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxLeArpPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmxLeArpPortIndex.setDescription('Port index that uniquely identify an instance of the LeArp Table.')
atmxLeArpServiceNum = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 5, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxLeArpServiceNum.setStatus('mandatory')
if mibBuilder.loadTexts: atmxLeArpServiceNum.setDescription('Service number index that uniquely identify an instance of the LeArp Table.')
atmLeArpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 5, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLeArpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmLeArpIndex.setDescription('Index that uniquely identify an instance of the LeArp Table.')
atmLeArpMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 5, 1, 5), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLeArpMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: atmLeArpMacAddress.setDescription("The MAC address for which this cache entry provides a translation. Since ATM LAN Emulation uses an ARP protocol to locate the Broadcast and Unknown Server, the value of this object could be the broadcast MAC address. MAC addresses should be unique within any given ATM Emulated LAN. However, there's no requirement that they be unique across disjoint emulated LANs.")
atmLeArpAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 5, 1, 6), XylanAtmLaneAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLeArpAtmAddress.setStatus('mandatory')
if mibBuilder.loadTexts: atmLeArpAtmAddress.setDescription("The ATM address of the Broadcast & Unknown Server or LAN Emulation Client whose MAC address is stored in 'atmLeArpMacAddress'. This value may be determined through the use of the LE_ARP procedure, through source address learning, or through other mechanisms. Some agents may provide write access to this object, as part of their support for 'static' LE_ARP entries. The effect of attempting to write an ATM address to a 'learned' row is explicitly undefined. Agents may disallow the write, accept the write and change the row's type, or even accept the write as-is.")
atmLeArpIsRemoteAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 5, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLeArpIsRemoteAddress.setStatus('mandatory')
if mibBuilder.loadTexts: atmLeArpIsRemoteAddress.setDescription("Indicates whether this entry is for a local or remote MAC address. In this context, 'local' means 'a MAC address that is local to the remote client', as opposed to 'one of my addresses'. true(1) The address is believed to be remote - or its local/remote status is unknown. For an entry created via the LE_ARP mechanism, this corresponds to the 'Remote address' flag being set in the LE_ARP_RESPONSE. During Topology Change periods, remote LE_ARP entries generally age out faster than others. Specifically, they are subject to the Forward Delay Time as well as to the Aging Time. false(2) The address is believed to be local - that is to say, registered with the LES by the client whose ATM address is atmLeArpAtmAddress. For an entry created via the LE_ARP mechanism, this corresponds to the 'Remote address' flag being cleared in the LE_ARP_RESPONSE.")
atmLeArpEntryType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 5, 1, 8), LeArpTableEntryType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLeArpEntryType.setStatus('mandatory')
if mibBuilder.loadTexts: atmLeArpEntryType.setDescription('Indicates how this LE_ARP table entry was created and whether it is aged.')
atmLeArpVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 5, 1, 9), VpiInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLeArpVpi.setStatus('mandatory')
if mibBuilder.loadTexts: atmLeArpVpi.setDescription('Indicates the vpi that this MAC is used to for it Data Direct VCC.')
atmLeArpVci = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 5, 1, 10), VciInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLeArpVci.setStatus('mandatory')
if mibBuilder.loadTexts: atmLeArpVci.setDescription('Indicates the vci that this MAC is used to for it Data Direct VCC.')
atmLeArpAge = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 5, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLeArpAge.setStatus('mandatory')
if mibBuilder.loadTexts: atmLeArpAge.setDescription('Indicates the time in second that this entry is being verified.')
atmLeArpType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 5, 1, 12), LeArpType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLeArpType.setStatus('mandatory')
if mibBuilder.loadTexts: atmLeArpType.setDescription('Indicates if this entry represents a SR RD or a ESI.')
xylanLecConfigTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 6), )
if mibBuilder.loadTexts: xylanLecConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: xylanLecConfigTable.setDescription('A supplementary table of the lecConfigTable in ATM Forum MIB providing additional information for creating and starting LEC service. This table is indexed by the lecIndex. Each row corresponding to the row with the same lecIndex in the lecConfigTable.')
xylanLecConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 6, 1), ).setIndexNames((0, "LAN-EMULATION-CLIENT-MIB", "lecIndex"))
if mibBuilder.loadTexts: xylanLecConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: xylanLecConfigEntry.setDescription('Each row contains a slot number, a port number, a service number and a group number for the LEC service.')
xylanLecSlotNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 6, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylanLecSlotNumber.setStatus('mandatory')
if mibBuilder.loadTexts: xylanLecSlotNumber.setDescription('The slot on which the ASM/FCSM module is located. The LEC service is to be created on that module. When a row has just been created, the first slot which has the ASM/FCSM module is assigned to this instance. If this number is not changed. The service will be created based on this assigned slot number.')
xylanLecPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 6, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylanLecPortNumber.setStatus('mandatory')
if mibBuilder.loadTexts: xylanLecPortNumber.setDescription('The port of the ASM/FCSM module on which The LEC service is to be created. When a row has just been created, the first available port of the ASM/FCSM module is assigned to this instance. If this number is not changed. The service will be created based on this assigned port number.')
xylanLecServiceNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 6, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xylanLecServiceNumber.setStatus('mandatory')
if mibBuilder.loadTexts: xylanLecServiceNumber.setDescription('The service number which is assigned by the system.')
xylanLecGroupNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 8, 6, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xylanLecGroupNumber.setStatus('mandatory')
if mibBuilder.loadTexts: xylanLecGroupNumber.setDescription('The group to which the LEC service belong. When a row has just been created, the default group number is assigned to this instance. If this number is not changed. The service will be created based on this assigned group number.')
atmCIPStatisticsTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 4, 9, 1), )
if mibBuilder.loadTexts: atmCIPStatisticsTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmCIPStatisticsTable.setDescription('An extension table containing traffic statistics for all the Classical IP this host implements.')
atmCIPStatisticsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 4, 9, 1, 1), ).setIndexNames((0, "XYLAN-ATM-MIB", "atmxCIPSlotIndex"), (0, "XYLAN-ATM-MIB", "atmxCIPPortIndex"), (0, "XYLAN-ATM-MIB", "atmxCIPServiceNum"))
if mibBuilder.loadTexts: atmCIPStatisticsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmCIPStatisticsEntry.setDescription('Each row in this table contains traffic statistics for one Classical IP Service.')
atmxCIPSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 9, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxCIPSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmxCIPSlotIndex.setDescription('Slot index to identify an instance of this table.')
atmxCIPPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 9, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxCIPPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmxCIPPortIndex.setDescription('Port index to identify an instance of this table.')
atmxCIPServiceNum = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 9, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxCIPServiceNum.setStatus('mandatory')
if mibBuilder.loadTexts: atmxCIPServiceNum.setDescription('Service number index to identify an instance of this table.')
atmCIPpktsFromIP = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 9, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmCIPpktsFromIP.setStatus('mandatory')
if mibBuilder.loadTexts: atmCIPpktsFromIP.setDescription('The number of packets received form IP.')
atmCIPBroadcastPktFromIP = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 9, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmCIPBroadcastPktFromIP.setStatus('mandatory')
if mibBuilder.loadTexts: atmCIPBroadcastPktFromIP.setDescription('The number of Broadcast packets received form IP.')
atmCIPPktsFromIPDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 9, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmCIPPktsFromIPDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: atmCIPPktsFromIPDiscard.setDescription('The number of packets received form IP discarded.')
atmCIPPktsToIP = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 9, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmCIPPktsToIP.setStatus('mandatory')
if mibBuilder.loadTexts: atmCIPPktsToIP.setDescription('The number of packets sent to IP.')
atmCIPPktsFromNet = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 9, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmCIPPktsFromNet.setStatus('mandatory')
if mibBuilder.loadTexts: atmCIPPktsFromNet.setDescription('The number of packets received from the Network.')
atmCIPPktsFromNetDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 9, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmCIPPktsFromNetDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: atmCIPPktsFromNetDiscard.setDescription('The number of packets sent to IP discarded.')
atmCIPArpRespFromNet = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 9, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmCIPArpRespFromNet.setStatus('mandatory')
if mibBuilder.loadTexts: atmCIPArpRespFromNet.setDescription('The number of Arp response packet received form the network.')
atmCIPArpReqFromNet = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 9, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmCIPArpReqFromNet.setStatus('mandatory')
if mibBuilder.loadTexts: atmCIPArpReqFromNet.setDescription('The number of Arp request packet received form the network.')
atmCIPInvArpRespFromNet = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 9, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmCIPInvArpRespFromNet.setStatus('mandatory')
if mibBuilder.loadTexts: atmCIPInvArpRespFromNet.setDescription('The number of Inverse Arp response packet received form the network.')
atmCIPInvArpReqFromNet = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 9, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmCIPInvArpReqFromNet.setStatus('mandatory')
if mibBuilder.loadTexts: atmCIPInvArpReqFromNet.setDescription('The number of Inverse Arp request packet received form the network.')
atmCIPInvArpNakFromNet = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 9, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmCIPInvArpNakFromNet.setStatus('mandatory')
if mibBuilder.loadTexts: atmCIPInvArpNakFromNet.setDescription('The number of Inverse Arp negative acknowledgement packet received form the network.')
atmCIPPktsToNet = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 9, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmCIPPktsToNet.setStatus('mandatory')
if mibBuilder.loadTexts: atmCIPPktsToNet.setDescription('The number of packets sent to the network.')
atmCIPPktsToNetDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 9, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmCIPPktsToNetDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: atmCIPPktsToNetDiscard.setDescription('The number of packets sent to the network.')
atmCIPArpRespToNet = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 9, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmCIPArpRespToNet.setStatus('mandatory')
if mibBuilder.loadTexts: atmCIPArpRespToNet.setDescription('The number of Arp response packet sent to the network.')
atmCIPArpReqToNet = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 9, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmCIPArpReqToNet.setStatus('mandatory')
if mibBuilder.loadTexts: atmCIPArpReqToNet.setDescription('The number of Arp request packet sent to the network.')
atmCIPInvArpRespToNet = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 9, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmCIPInvArpRespToNet.setStatus('mandatory')
if mibBuilder.loadTexts: atmCIPInvArpRespToNet.setDescription('The number of Inverse Arp response packet sent to the network.')
atmCIPInvArpReqToNet = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 9, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmCIPInvArpReqToNet.setStatus('mandatory')
if mibBuilder.loadTexts: atmCIPInvArpReqToNet.setDescription('The number of Inverse Arp request packet sent to the network.')
atmCIPInvArpNakToNet = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 9, 1, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmCIPInvArpNakToNet.setStatus('mandatory')
if mibBuilder.loadTexts: atmCIPInvArpNakToNet.setDescription('The number of Inverse Arp negative acknowledge packet sent to the network.')
atmGpToVcMappingTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 4, 12, 1), )
if mibBuilder.loadTexts: atmGpToVcMappingTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmGpToVcMappingTable.setDescription('An extension table containing mapping info for all group to VCI (and VPI) mapping for 1 Scaling service. This table is for create, delete 1 mapping entry. Utilize atmxServiceGroup to create or delete a 1483 Scaling Service. Create 1483 Scaling Service only with 1 group and 1 vc thru the atmxServiceGroup. Adding or removing other group-to-vc mapping should then use this atmx1483ScaleGroup.')
atmGpToVcMappingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 4, 12, 1, 1), ).setIndexNames((0, "XYLAN-ATM-MIB", "atmxGpToVcSlotIndex"), (0, "XYLAN-ATM-MIB", "atmxGpToVcPortIndex"), (0, "XYLAN-ATM-MIB", "atmxGpToVcServiceNum"), (0, "XYLAN-ATM-MIB", "atmxGpToVcGroupId"))
if mibBuilder.loadTexts: atmGpToVcMappingEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmGpToVcMappingEntry.setDescription('Each row in this table contains mapping info for 1 group to 1 VCI (and 1 VPI) entry. The value for VPI must be zero (0).')
atmxGpToVcSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 12, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxGpToVcSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmxGpToVcSlotIndex.setDescription('Slot index to identify an instance of this table.')
atmxGpToVcPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 12, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxGpToVcPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmxGpToVcPortIndex.setDescription('Port index to identify an instance of this table.')
atmxGpToVcServiceNum = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 12, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxGpToVcServiceNum.setStatus('mandatory')
if mibBuilder.loadTexts: atmxGpToVcServiceNum.setDescription('Service number index to identify an instance of this table.')
atmxGpToVcGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 12, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxGpToVcGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: atmxGpToVcGroupId.setDescription('Group number index to identify an instance of this table.')
atmxGpToVcVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 12, 1, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxGpToVcVpi.setStatus('mandatory')
if mibBuilder.loadTexts: atmxGpToVcVpi.setDescription('The VPI for 1 Scaling Service. VPI can only be zero .')
atmxGpToVcVci = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 12, 1, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxGpToVcVci.setStatus('mandatory')
if mibBuilder.loadTexts: atmxGpToVcVci.setDescription('The VCI for 1 Scaling Service. The range for VCI is from 1 to 1000.')
atmxGpToVcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 12, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("create", 1), ("delete", 2), ("active", 3), ("inactive", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxGpToVcRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmxGpToVcRowStatus.setDescription('Row Status indicates the state of a entry of this mapping table. For a Get-operation, the value to be returned values can be ACTIVE or INACTIVE. This RowStatus will return ACTIVE, if the atmxServiceAdminStatus (an object in atmxSerivceGroup) is set to ENABLE. RowStatus will be INACTIVE if atmxServiceAdminStatus is set to a value other than ENABLE. RowStatus can only set to CREATE or DELETE. The values ACTIVE and INACTIVE are read only. For a Set-operation, values to be set can be CREATE or DELETE. Utilize atmxServiceGroup to create or delete a 1483 Scaling Service. Create 1483 Scaling Service only with 1 group and 1 vc thru the atmxServiceGroup. Adding or removing other group-to-vc mapping should then use this atmx1483ScaleGroup.')
atmGpToVcBulkMappingTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 4, 12, 2), )
if mibBuilder.loadTexts: atmGpToVcBulkMappingTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmGpToVcBulkMappingTable.setDescription('An extension table containing mapping (bulk) info for all group to VCI (and VPI) mapping for 1 Scaling service. This table can only have 1 row. This table is for updating the whole mapping list (ie. all mapping entries ) at one time. ')
atmGpToVcBulkMappingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 4, 12, 2, 1), ).setIndexNames((0, "XYLAN-ATM-MIB", "atmxGpToVcBulkSlotIndex"), (0, "XYLAN-ATM-MIB", "atmxGpToVcBulkPortIndex"), (0, "XYLAN-ATM-MIB", "atmxGpToVcBulkServiceNum"))
if mibBuilder.loadTexts: atmGpToVcBulkMappingEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmGpToVcBulkMappingEntry.setDescription('There is only 1 row in this table. This row contains all group to VCI (and VPI) mapping for 1 Scaling service. There are 3 indices for this table. The value for VPI must be zero (0).')
atmxGpToVcBulkSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 12, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxGpToVcBulkSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmxGpToVcBulkSlotIndex.setDescription('Slot index to identify a Scaling service.')
atmxGpToVcBulkPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 12, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxGpToVcBulkPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmxGpToVcBulkPortIndex.setDescription('Port index to identify a Scaling service.')
atmxGpToVcBulkServiceNum = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 12, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxGpToVcBulkServiceNum.setStatus('mandatory')
if mibBuilder.loadTexts: atmxGpToVcBulkServiceNum.setDescription('Service number index to identify a Scaling service.')
atmxGpToVcBulkNumOfNodes = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 12, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxGpToVcBulkNumOfNodes.setStatus('mandatory')
if mibBuilder.loadTexts: atmxGpToVcBulkNumOfNodes.setDescription('Number of group to VCI (and VPI) mapping inside the bulk mapping list. ')
atmxGpToVcBulkMappingList = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 12, 2, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxGpToVcBulkMappingList.setStatus('mandatory')
if mibBuilder.loadTexts: atmxGpToVcBulkMappingList.setDescription('A list containing all group to VCI (and VPI) mapping entries. Each mapping entry has the following fields having the exact order : a) Group Number (4 bytes) b) VPI (2 bytes) c) VCI (2 bytes) A total of 8 bytes for each mapping structure. There is no separator in between matching structures, nor is a end-of-string in this whole matching list. The size of this whole mapping list must be a multiple of 8 bytes. For Set-Operations, if a user wants to update the mapping list, he must send the whole mapping list buffer. ')
atmxBwgTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 4, 11, 1), )
if mibBuilder.loadTexts: atmxBwgTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmxBwgTable.setDescription('A table of Bandwidth group parameters for Traffic Shaping')
atmxBwgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 4, 11, 1, 1), ).setIndexNames((0, "XYLAN-ATM-MIB", "atmxBwgSlotIndex"), (0, "XYLAN-ATM-MIB", "atmxBwgPortIndex"), (0, "XYLAN-ATM-MIB", "atmxBwgNum"))
if mibBuilder.loadTexts: atmxBwgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmxBwgEntry.setDescription('An entry in the table, containing information about the Traffic parameters for each of the 8 bandwidth groups')
atmxBwgSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 11, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 9))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxBwgSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmxBwgSlotIndex.setDescription('A unique value which identifies this hsm board slot.')
atmxBwgPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 11, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxBwgPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmxBwgPortIndex.setDescription('A unique value which identifies this atm submodule port.')
atmxBwgNum = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 11, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxBwgNum.setStatus('mandatory')
if mibBuilder.loadTexts: atmxBwgNum.setDescription('A unique value that identifies the bwg')
atmxBwgBE = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 11, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxBwgBE.setStatus('mandatory')
if mibBuilder.loadTexts: atmxBwgBE.setDescription('Whether to use Best Effort for tx data.')
atmxBwgPcr = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 11, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(535, 150000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxBwgPcr.setStatus('mandatory')
if mibBuilder.loadTexts: atmxBwgPcr.setDescription('The value of the Peak Cell Rate(Kbps) as defined in the Traffic Management Specification Version 4.0. atmxBwgPcr has no meaning when atmxBwgBE is equal to true.')
atmxBwgScr = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 11, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(35, 150000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxBwgScr.setStatus('mandatory')
if mibBuilder.loadTexts: atmxBwgScr.setDescription('The value of the Sustained Cell Rate(Kbps) as defined in the Traffic Management Specification Version 4.0. atmxBwgScr must be less or equal to atmxBwgPcr. atmxBwgScr has no meaning when atmxBwgBE is equal to true.')
atmxBwgMbs = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 11, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 124))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmxBwgMbs.setStatus('mandatory')
if mibBuilder.loadTexts: atmxBwgMbs.setDescription('The value of the max burst size when interleaving traffic from multiple sources as defined in the 4.0 Traffic Management specification. atmxBwgMbs has no meaning when atmxBwgBE is equal to true.')
atmxBwgOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 11, 1, 1, 8), AtmOperStatCodes()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxBwgOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmxBwgOperStatus.setDescription('If the bwg is being used by any service we return inService(2) , or we return outOfService(3).')
atmxBwgServiceTable = MibTable((1, 3, 6, 1, 4, 1, 800, 2, 4, 11, 2), )
if mibBuilder.loadTexts: atmxBwgServiceTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmxBwgServiceTable.setDescription('A table of Service group parameters for Traffic Shaping')
atmxBwgServiceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 2, 4, 11, 2, 1), ).setIndexNames((0, "XYLAN-ATM-MIB", "atmxBwgSlotIndex"), (0, "XYLAN-ATM-MIB", "atmxBwgPortIndex"), (0, "XYLAN-ATM-MIB", "atmxBwgNum"), (0, "XYLAN-ATM-MIB", "atmxBwgServiceNum"))
if mibBuilder.loadTexts: atmxBwgServiceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmxBwgServiceEntry.setDescription('Each entry represents an BandWidthGroup to Service mapping.')
atmxBwgServiceNum = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 2, 4, 11, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmxBwgServiceNum.setStatus('mandatory')
if mibBuilder.loadTexts: atmxBwgServiceNum.setDescription('A unique value which identifies a service.')
mibBuilder.exportSymbols("XYLAN-ATM-MIB", atmxVccRequestedTransmitTrafficDescriptorParam3=atmxVccRequestedTransmitTrafficDescriptorParam3, atmxAddressReceiveMaxSDU=atmxAddressReceiveMaxSDU, atmLeArpIndex=atmLeArpIndex, LecDataFrameFormat=LecDataFrameFormat, atmCIPStatisticsTable=atmCIPStatisticsTable, atmxVccStatsRxCellCrcErrors=atmxVccStatsRxCellCrcErrors, atmxAddressAcceptableTransmitTrafficDescriptorParam1=atmxAddressAcceptableTransmitTrafficDescriptorParam1, atmCIPPktsToNetDiscard=atmCIPPktsToNetDiscard, atmLecInterfaceState=atmLecInterfaceState, atmxServiceEntry=atmxServiceEntry, atmxAddressAddrUsed=atmxAddressAddrUsed, atmxLayerStatsTxSDUErrors=atmxLayerStatsTxSDUErrors, atmLecConfigLecsAtmAddress=atmLecConfigLecsAtmAddress, atmxVccAcceptableTransmitTrafficDescriptorParam3=atmxVccAcceptableTransmitTrafficDescriptorParam3, atmLeArpAge=atmLeArpAge, atmxVccConnectionUsed=atmxVccConnectionUsed, AtmConnectionOperStatCodes=AtmConnectionOperStatCodes, atmLeArpTable=atmLeArpTable, atmxVccActualReceiveTrafficDescriptor=atmxVccActualReceiveTrafficDescriptor, xylanLecPortNumber=xylanLecPortNumber, atmxAddressAcceptableTransmitTrafficDescriptorParam2=atmxAddressAcceptableTransmitTrafficDescriptorParam2, atmLecServerVccTable=atmLecServerVccTable, atmxAddressRequestedReceiveTrafficDescriptor=atmxAddressRequestedReceiveTrafficDescriptor, atmxPortPortIndex=atmxPortPortIndex, atmxAddressAdmStatus=atmxAddressAdmStatus, atmxAddressRequestedReceiveTrafficDescriptorParam2=atmxAddressRequestedReceiveTrafficDescriptorParam2, atmxLayerStatsTxOctets=atmxLayerStatsTxOctets, atmxLayerStatsRxSDUs=atmxLayerStatsRxSDUs, LecState=LecState, atmCIPPktsToNet=atmCIPPktsToNet, atmxVccServiceUsed=atmxVccServiceUsed, atmxAddressAcceptableReceiveTrafficDescriptorParam2=atmxAddressAcceptableReceiveTrafficDescriptorParam2, atmxLecStatsServiceNum=atmxLecStatsServiceNum, atmLeArpVpi=atmLeArpVpi, atmxPortGroup=atmxPortGroup, atmxBwgTable=atmxBwgTable, atmLecProxyClient=atmLecProxyClient, atmxVccStatsTable=atmxVccStatsTable, atmxBwgNum=atmxBwgNum, xylanLecGroupNumber=xylanLecGroupNumber, atmxAddressRequestedTransmitTrafficDescriptorParam2=atmxAddressRequestedTransmitTrafficDescriptorParam2, atmLecVccTimeoutPeriod=atmLecVccTimeoutPeriod, xylanLecConfigEntry=xylanLecConfigEntry, atmxCIPstatsGroup=atmxCIPstatsGroup, atmGpToVcBulkMappingEntry=atmGpToVcBulkMappingEntry, atmxAddressVpi=atmxAddressVpi, atmLecSrBridgeNum=atmLecSrBridgeNum, atmxPortSignalingVersion=atmxPortSignalingVersion, atmLecAgingTime=atmLecAgingTime, atmxPortRxSegmentSize=atmxPortRxSegmentSize, atmLecArpRequestsOut=atmLecArpRequestsOut, atmCIPInvArpReqFromNet=atmCIPInvArpReqFromNet, atmxLayerStatsRxCellNoBuffers=atmxLayerStatsRxCellNoBuffers, atmLecConfigDirectVpi=atmLecConfigDirectVpi, atmxServiceMulticastOutVcc=atmxServiceMulticastOutVcc, atmxLecStatusServiceNum=atmxLecStatusServiceNum, atmxLecPortIndex=atmxLecPortIndex, atmxVccAcceptableTransmitTrafficDescriptor=atmxVccAcceptableTransmitTrafficDescriptor, atmLecConfigMode=atmLecConfigMode, atmxVccStatsRxCellTrash=atmxVccStatsRxCellTrash, atmxAddressAcceptableReceiveTrafficBestEffort=atmxAddressAcceptableReceiveTrafficBestEffort, atmxVccStatsTxSDUDiscards=atmxVccStatsTxSDUDiscards, atmxVccActualReceiveTrafficQoSClass=atmxVccActualReceiveTrafficQoSClass, atmLecProtocol=atmLecProtocol, atmLecActualLanName=atmLecActualLanName, atmxVccStatsRxSDUErrors=atmxVccStatsRxSDUErrors, atmxArpTimeToLive=atmxArpTimeToLive, atmxAddressRequestedTransmitTrafficBestEffort=atmxAddressRequestedTransmitTrafficBestEffort, atmxGpToVcBulkNumOfNodes=atmxGpToVcBulkNumOfNodes, atmxPortEntry=atmxPortEntry, atmxPortProtocolType=atmxPortProtocolType, atmxVccOperStatus=atmxVccOperStatus, atmLecSvcFailures=atmLecSvcFailures, atmxGpToVcBulkServiceNum=atmxGpToVcBulkServiceNum, atmxVccActualTransmitTrafficDescriptorParam3=atmxVccActualTransmitTrafficDescriptorParam3, atmxLayerStatsRxCellErrors=atmxLayerStatsRxCellErrors, atmLecMaxUnknownFrameTime=atmLecMaxUnknownFrameTime, atmxLecStatusSlotIndex=atmxLecStatusSlotIndex, atmCIPInvArpNakFromNet=atmCIPInvArpNakFromNet, atmxArpEntry=atmxArpEntry, atmxVccRequestedReceiveTrafficQoSClass=atmxVccRequestedReceiveTrafficQoSClass, atmxBwgBE=atmxBwgBE, atmLecID=atmLecID, atmLecControlDistributeVpi=atmLecControlDistributeVpi, atmxAddressAcceptableTransmitTrafficBestEffort=atmxAddressAcceptableTransmitTrafficBestEffort, atmLecConfigSource=atmLecConfigSource, atmCIPArpRespToNet=atmCIPArpRespToNet, atmxVccRequestedTransmitTrafficDescriptorParam2=atmxVccRequestedTransmitTrafficDescriptorParam2, atmxServiceArpRequestServer=atmxServiceArpRequestServer, atmxCIPPortIndex=atmxCIPPortIndex, atmxServiceVclEncapType=atmxServiceVclEncapType, atmLeArpVci=atmLeArpVci, atmxLeArpPortIndex=atmxLeArpPortIndex, atmLecVersion=atmLecVersion, atmxVccActualReceiveTrafficBestEffort=atmxVccActualReceiveTrafficBestEffort, atmLecActualLanType=atmLecActualLanType, atmxVccRequestedTransmitTrafficQoSClass=atmxVccRequestedTransmitTrafficQoSClass, atmxVccStatsRxSDUNoBuffers=atmxVccStatsRxSDUNoBuffers, atmxServiceConnections=atmxServiceConnections, atmxVccStatsPortIndex=atmxVccStatsPortIndex, atmLecMulticastForwardVpi=atmLecMulticastForwardVpi, atmxLayerStatsTable=atmxLayerStatsTable, atmLecPrimaryAtmAddress=atmLecPrimaryAtmAddress, atmLeArpType=atmLeArpType, atmxGpToVcRowStatus=atmxGpToVcRowStatus, atmxBwgScr=atmxBwgScr, atmxLayerStatsTxCellErrors=atmxLayerStatsTxCellErrors, atmLecControlTimeout=atmLecControlTimeout, atmxAddressAcceptableReceiveTrafficDescriptor=atmxAddressAcceptableReceiveTrafficDescriptor, atmxVccAcceptableReceiveTrafficDescriptorParam2=atmxVccAcceptableReceiveTrafficDescriptorParam2, atmxPortUniType=atmxPortUniType, atmxLecConfigIndex=atmxLecConfigIndex, atmLecMaxRetryCount=atmLecMaxRetryCount, atmxVccRequestedReceiveTrafficDescriptorParam2=atmxVccRequestedReceiveTrafficDescriptorParam2, atmLecMaxUnknownFrameCount=atmLecMaxUnknownFrameCount, atmxBwgMbs=atmxBwgMbs, atmxAddressTransmitMaxSDU=atmxAddressTransmitMaxSDU, atmxVccStatsTxCellNoBuffers=atmxVccStatsTxCellNoBuffers, atmCIPArpReqToNet=atmCIPArpReqToNet, atmxLayerStatsTxSDUs=atmxLayerStatsTxSDUs, atmxPortConnectionType=atmxPortConnectionType, atmLeArpIsRemoteAddress=atmLeArpIsRemoteAddress, atmxPortMediaType=atmxPortMediaType, atmxAddressRequestedTransmitTrafficDescriptorParam3=atmxAddressRequestedTransmitTrafficDescriptorParam3, atmxVccRequestedTransmitTrafficDescriptorParam1=atmxVccRequestedTransmitTrafficDescriptorParam1, atmLecForwardDelayTime=atmLecForwardDelayTime, atmxVccStatsRxCellNoBuffers=atmxVccStatsRxCellNoBuffers, atmxLayerStatsRxSDUErrors=atmxLayerStatsRxSDUErrors, atmxPortTxSegmentSize=atmxPortTxSegmentSize, atmxArpAtmAddress=atmxArpAtmAddress, atmCIPInvArpRespFromNet=atmCIPInvArpRespFromNet, atmxVccAcceptableTransmitTrafficQoSClass=atmxVccAcceptableTransmitTrafficQoSClass, atmLecSrRingNum=atmLecSrRingNum, atmxArpTable=atmxArpTable, atmxLayerStatsTxCellDiscards=atmxLayerStatsTxCellDiscards, atmxServicePortIndex=atmxServicePortIndex, atmxLayerStatsRxSDUNoBuffers=atmxLayerStatsRxSDUNoBuffers, atmLecRowStatus=atmLecRowStatus, atmxVccGroup=atmxVccGroup, atmxPortDescription=atmxPortDescription, atmxVccTransmitMaxFrameSize=atmxVccTransmitMaxFrameSize, atmxVccStatsTxOctets=atmxVccStatsTxOctets, atmxAddressRequestedReceiveTrafficDescriptorParam3=atmxAddressRequestedReceiveTrafficDescriptorParam3, atmGpToVcBulkMappingTable=atmGpToVcBulkMappingTable, atmxBwgServiceEntry=atmxBwgServiceEntry, atmLecUseTranslation=atmLecUseTranslation, atmLecTopologyChange=atmLecTopologyChange, atmGpToVcMappingTable=atmGpToVcMappingTable, atmxVccPortIndex=atmxVccPortIndex, atmxVccRequestedReceiveTrafficDescriptorParam3=atmxVccRequestedReceiveTrafficDescriptorParam3, VciInteger=VciInteger, atmxVccRequestedTransmitTrafficDescriptor=atmxVccRequestedTransmitTrafficDescriptor, atmxGpToVcSlotIndex=atmxGpToVcSlotIndex, atmxVccStatsTxCells=atmxVccStatsTxCells, atmxServiceType=atmxServiceType, atmxVccStatsVci=atmxVccStatsVci, atmxPortMaxVCCs=atmxPortMaxVCCs, atmxAddressAcceptableTransmitTrafficDescriptorParam3=atmxAddressAcceptableTransmitTrafficDescriptorParam3, atmLecExpectedArpResponseTime=atmLecExpectedArpResponseTime, atmxVccDownTime=atmxVccDownTime, atmxVccActualTransmitTrafficDescriptorParam1=atmxVccActualTransmitTrafficDescriptorParam1, atmxCIPServiceNum=atmxCIPServiceNum, atmxPortILMIstatus=atmxPortILMIstatus, atmxAddressAtmAddress=atmxAddressAtmAddress, atmxLecSlotIndex=atmxLecSlotIndex, atmLeArpEntryType=atmLeArpEntryType, atmxAddressGroup=atmxAddressGroup, atmxVccStatsRxSDUCrcErrors=atmxVccStatsRxSDUCrcErrors, atmxLeArpServiceNum=atmxLeArpServiceNum, atmLecStatusTable=atmLecStatusTable, atmLecControlDirectVci=atmLecControlDirectVci, atmxLayerStatsEntry=atmxLayerStatsEntry, atmxVccStatsEntry=atmxVccStatsEntry, atmxVccStatsRxCellDiscards=atmxVccStatsRxCellDiscards, atmxVccStatsRxSDUDiscards=atmxVccStatsRxSDUDiscards, atmxGpToVcVci=atmxGpToVcVci, atmxVccStatsGroup=atmxVccStatsGroup, atmxAddressTable=atmxAddressTable, atmxLayerStatsTxCellNoBuffers=atmxLayerStatsTxCellNoBuffers, atmxPortTable=atmxPortTable, atmxVccReceiveMaxFrameSize=atmxVccReceiveMaxFrameSize, atmLecConfigServerAtmAddress=atmLecConfigServerAtmAddress, atmLecPathSwitchingDelay=atmLecPathSwitchingDelay, atmxPortTimingMode=atmxPortTimingMode, atmxVccRequestedReceiveTrafficDescriptor=atmxVccRequestedReceiveTrafficDescriptor, atmxArpGroup=atmxArpGroup, atmxLayerStatsRxCellDiscards=atmxLayerStatsRxCellDiscards, atmxAddressVci=atmxAddressVci, atmxBwgEntry=atmxBwgEntry, atmxLayerStatsRxSDUDiscards=atmxLayerStatsRxSDUDiscards, atmxVccStatsTxCellErrors=atmxVccStatsTxCellErrors, atmxPortSignalingVci=atmxPortSignalingVci, atmxPortILMIVci=atmxPortILMIVci, atmxLayerStatsTxSDUDiscards=atmxLayerStatsTxSDUDiscards, atmxVccAcceptableTransmitTrafficDescriptorParam2=atmxVccAcceptableTransmitTrafficDescriptorParam2, atmLecStatisticsTable=atmLecStatisticsTable, atmLecControlFramesOut=atmLecControlFramesOut, atmCIPBroadcastPktFromIP=atmCIPBroadcastPktFromIP, atmLeArpMacAddress=atmLeArpMacAddress, atmxArpType=atmxArpType, atmxAddressIndex=atmxAddressIndex, atmxArpIPAddress=atmxArpIPAddress, atmxVccAcceptableTransmitTrafficDescriptorParam1=atmxVccAcceptableTransmitTrafficDescriptorParam1, atmxVccAcceptableReceiveTrafficDescriptorParam1=atmxVccAcceptableReceiveTrafficDescriptorParam1, atmxLayerStatsTxCells=atmxLayerStatsTxCells, atmxPortLoopbackConfig=atmxPortLoopbackConfig, atmxAddressRequestedTransmitTrafficQoSClass=atmxAddressRequestedTransmitTrafficQoSClass, atmxPortTxBufferSize=atmxPortTxBufferSize, xylanLecConfigTable=xylanLecConfigTable, atmxAddressRequestedReceiveTrafficQoSClass=atmxAddressRequestedReceiveTrafficQoSClass, atmxVccAcceptableTransmitTrafficBestEffort=atmxVccAcceptableTransmitTrafficBestEffort, atmLecLastFailureRespCode=atmLecLastFailureRespCode, atmxServiceGroup=atmxServiceGroup, atmxAddressDescription=atmxAddressDescription, atmxPortSSCOPstatus=atmxPortSSCOPstatus, atmxBwgPcr=atmxBwgPcr, atmLecMulticastSendVci=atmLecMulticastSendVci, atmxLayerStatsTxSDUNoBuffers=atmxLayerStatsTxSDUNoBuffers, atmxLayerStatsRxSDUCrcErrors=atmxLayerStatsRxSDUCrcErrors, atmxLeArpSlotIndex=atmxLeArpSlotIndex, atmLecControlDistributeVci=atmLecControlDistributeVci, atmxLecStatusPortIndex=atmxLecStatusPortIndex, atmLeArpEntry=atmLeArpEntry, atmxGpToVcBulkMappingList=atmxGpToVcBulkMappingList, atmxServiceAddress=atmxServiceAddress, atmxPortPlScramble=atmxPortPlScramble, atmx1483ScaleGroup=atmx1483ScaleGroup, atmLecRowInUse=atmLecRowInUse, atmxLayerStatsRxSDUTrash=atmxLayerStatsRxSDUTrash, atmLecConfigUseDefaultLecsAddr=atmLecConfigUseDefaultLecsAddr, atmxVccCircuitType=atmxVccCircuitType, atmCIPpktsFromIP=atmCIPpktsFromIP, atmCIPStatisticsEntry=atmCIPStatisticsEntry, atmxVccRequestedReceiveTrafficBestEffort=atmxVccRequestedReceiveTrafficBestEffort, atmxVccEntry=atmxVccEntry, atmxVccDescription=atmxVccDescription, atmxVccStatsRxCellErrors=atmxVccStatsRxCellErrors, atmxLsmGroup=atmxLsmGroup, atmxPortAddress=atmxPortAddress, atmxLecServiceNum=atmxLecServiceNum, atmxVccStatsTxCellDiscards=atmxVccStatsTxCellDiscards, atmxCIPSlotIndex=atmxCIPSlotIndex, atmxServiceConnectionType=atmxServiceConnectionType, atmLecArpRepliesOut=atmLecArpRepliesOut, atmxLayerStatsRxSDUInvalidSz=atmxLayerStatsRxSDUInvalidSz, atmLecConfigMaxDataFrameSize=atmLecConfigMaxDataFrameSize, atmLecConfigLesAtmAddress=atmLecConfigLesAtmAddress, atmxVccAcceptableReceiveTrafficDescriptor=atmxVccAcceptableReceiveTrafficDescriptor, atmxVccSlotIndex=atmxVccSlotIndex, atmxGpToVcBulkSlotIndex=atmxGpToVcBulkSlotIndex, LeArpType=LeArpType, atmxServiceOperStatus=atmxServiceOperStatus, atmLecLastFailureState=atmLecLastFailureState, atmGpToVcMappingEntry=atmGpToVcMappingEntry)
mibBuilder.exportSymbols("XYLAN-ATM-MIB", atmxGpToVcGroupId=atmxGpToVcGroupId, atmxVccStatsRxOctets=atmxVccStatsRxOctets, atmxVccAdmStatus=atmxVccAdmStatus, XylanAtmLaneAddress=XylanAtmLaneAddress, LeArpTableEntryType=LeArpTableEntryType, atmLecControlDirectVpi=atmLecControlDirectVpi, atmCIPInvArpRespToNet=atmCIPInvArpRespToNet, atmxServiceEncapsType=atmxServiceEncapsType, atmxServiceAddresses=atmxServiceAddresses, atmCIPPktsFromNet=atmCIPPktsFromNet, atmxArpIndex=atmxArpIndex, atmCIPInvArpReqToNet=atmCIPInvArpReqToNet, atmxServiceDescription=atmxServiceDescription, atmxVccStatsTxSDUNoBuffers=atmxVccStatsTxSDUNoBuffers, atmCIPPktsToIP=atmCIPPktsToIP, atmxVccAcceptableReceiveTrafficDescriptorParam3=atmxVccAcceptableReceiveTrafficDescriptorParam3, atmxVccTable=atmxVccTable, atmxLayerStatsGroup=atmxLayerStatsGroup, atmLecConfigLanName=atmLecConfigLanName, atmLecArpRequestsIn=atmLecArpRequestsIn, atmxServiceNumVclMembers=atmxServiceNumVclMembers, atmxGpToVcPortIndex=atmxGpToVcPortIndex, atmxAddressAcceptableReceiveTrafficDescriptorParam3=atmxAddressAcceptableReceiveTrafficDescriptorParam3, AtmServiceOperStatCodes=AtmServiceOperStatCodes, atmxVccConnType=atmxVccConnType, atmxAddressAcceptableTransmitTrafficQoSClass=atmxAddressAcceptableTransmitTrafficQoSClass, atmxServiceNumber=atmxServiceNumber, AtmOperStatCodes=AtmOperStatCodes, atmxAddressRequestedReceiveTrafficDescriptorParam1=atmxAddressRequestedReceiveTrafficDescriptorParam1, xylanLecSlotNumber=xylanLecSlotNumber, atmxAddressType=atmxAddressType, atmLecConfigDirectVci=atmLecConfigDirectVci, atmCIPArpReqFromNet=atmCIPArpReqFromNet, atmxSahiBWGroup=atmxSahiBWGroup, atmxVccStatsRxSDUs=atmxVccStatsRxSDUs, atmxServiceSEL=atmxServiceSEL, atmLecMulticastForwardVci=atmLecMulticastForwardVci, atmxVccActualTransmitTrafficDescriptorParam2=atmxVccActualTransmitTrafficDescriptorParam2, atmxVccRequestedReceiveTrafficDescriptorParam1=atmxVccRequestedReceiveTrafficDescriptorParam1, atmxLayerStatsRxOctets=atmxLayerStatsRxOctets, atmxVccStatsRxSDUInvalidSz=atmxVccStatsRxSDUInvalidSz, atmLecActualMaxDataFrameSize=atmLecActualMaxDataFrameSize, atmLecActualLesAtmAddress=atmLecActualLesAtmAddress, atmLecConfigTable=atmLecConfigTable, atmxAddressAcceptableTransmitTrafficDescriptor=atmxAddressAcceptableTransmitTrafficDescriptor, atmxPortUniPortIndex=atmxPortUniPortIndex, AtmAdminStatCodes=AtmAdminStatCodes, atmxServiceLaneCfgTblIdx=atmxServiceLaneCfgTblIdx, atmxBwgServiceTable=atmxBwgServiceTable, atmxVccStatsTxSDUs=atmxVccStatsTxSDUs, atmLecConfigEntry=atmLecConfigEntry, atmxLaneGroup=atmxLaneGroup, VpiInteger=VpiInteger, atmLecUseForwardDelay=atmLecUseForwardDelay, atmxPortOperStatus=atmxPortOperStatus, atmxLayerStatsSlotIndex=atmxLayerStatsSlotIndex, atmCIPInvArpNakToNet=atmCIPInvArpNakToNet, atmxVccRequestedTransmitTrafficBestEffort=atmxVccRequestedTransmitTrafficBestEffort, atmxVccActualTransmitTrafficBestEffort=atmxVccActualTransmitTrafficBestEffort, atmxAddressAcceptableReceiveTrafficQoSClass=atmxAddressAcceptableReceiveTrafficQoSClass, atmxVccActualReceiveTrafficDescriptorParam3=atmxVccActualReceiveTrafficDescriptorParam3, atmxAddressServiceUsed=atmxAddressServiceUsed, AtmTransmissionTypes=AtmTransmissionTypes, atmxVccAcceptableReceiveTrafficQoSClass=atmxVccAcceptableReceiveTrafficQoSClass, atmxBwgSlotIndex=atmxBwgSlotIndex, atmxVccStatsRxSDUTrash=atmxVccStatsRxSDUTrash, atmxArpVci=atmxArpVci, atmxVccStatsTxSDUErrors=atmxVccStatsTxSDUErrors, atmxServiceSahiBwgNum=atmxServiceSahiBwgNum, atmLecArpRepliesIn=atmLecArpRepliesIn, atmLecStatisticsEntry=atmLecStatisticsEntry, atmCIPPktsFromNetDiscard=atmCIPPktsFromNetDiscard, atmxServiceTable=atmxServiceTable, atmxAddressRequestedReceiveTrafficBestEffort=atmxAddressRequestedReceiveTrafficBestEffort, atmxVccActualTransmitTrafficQoSClass=atmxVccActualTransmitTrafficQoSClass, atmxVccActualReceiveTrafficDescriptorParam1=atmxVccActualReceiveTrafficDescriptorParam1, atmxVccStatsRxCells=atmxVccStatsRxCells, atmLecControlFramesIn=atmLecControlFramesIn, atmxAddressRequestedTransmitTrafficDescriptorParam1=atmxAddressRequestedTransmitTrafficDescriptorParam1, atmLecStatusEntry=atmLecStatusEntry, atmxGpToVcBulkPortIndex=atmxGpToVcBulkPortIndex, atmxVccVpi=atmxVccVpi, atmxPortMaxVciBits=atmxPortMaxVciBits, atmxBwgOperStatus=atmxBwgOperStatus, atmxServiceAdmStatus=atmxServiceAdmStatus, atmxServiceVlan=atmxServiceVlan, atmxLayerStatsRxCells=atmxLayerStatsRxCells, atmxAddressRequestedTransmitTrafficDescriptor=atmxAddressRequestedTransmitTrafficDescriptor, atmxVccUpTime=atmxVccUpTime, atmxServiceSlotIndex=atmxServiceSlotIndex, atmxVccStatsSlotIndex=atmxVccStatsSlotIndex, atmxLecStatsPortIndex=atmxLecStatsPortIndex, atmLecServerVccEntry=atmLecServerVccEntry, atmCIPArpRespFromNet=atmCIPArpRespFromNet, atmxAddressAcceptableReceiveTrafficDescriptorParam1=atmxAddressAcceptableReceiveTrafficDescriptorParam1, atmxPortTransmissionType=atmxPortTransmissionType, atmxPortSlotIndex=atmxPortSlotIndex, atmxLecStatsSlotIndex=atmxLecStatsSlotIndex, atmxPortEnableILMI=atmxPortEnableILMI, atmxGpToVcServiceNum=atmxGpToVcServiceNum, xylanLecServiceNumber=xylanLecServiceNumber, atmxLayerStatsPortIndex=atmxLayerStatsPortIndex, atmxPortRxBufferSize=atmxPortRxBufferSize, AtmTrafficDescrTypes=AtmTrafficDescrTypes, atmxGpToVcVpi=atmxGpToVcVpi, atmxAddressEntry=atmxAddressEntry, atmCIPPktsFromIPDiscard=atmCIPPktsFromIPDiscard, atmxVccVci=atmxVccVci, atmLecConfigLanType=atmLecConfigLanType, atmxLayerStatsRxCellTrash=atmxLayerStatsRxCellTrash, atmxVccActualReceiveTrafficDescriptorParam2=atmxVccActualReceiveTrafficDescriptorParam2, atmxBwgServiceNum=atmxBwgServiceNum, atmLecMulticastSendVpi=atmLecMulticastSendVpi, atmxBwgPortIndex=atmxBwgPortIndex, atmxVccAcceptableReceiveTrafficBestEffort=atmxVccAcceptableReceiveTrafficBestEffort, atmLeArpAtmAddress=atmLeArpAtmAddress, AtmMediaTypes=AtmMediaTypes, atmxLayerStatsRxCellCrcErrors=atmxLayerStatsRxCellCrcErrors, atmxVccActualTransmitTrafficDescriptor=atmxVccActualTransmitTrafficDescriptor, atmLecFlushTimeOut=atmLecFlushTimeOut)

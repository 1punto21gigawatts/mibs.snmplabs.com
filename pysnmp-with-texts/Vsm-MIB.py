#
# PySNMP MIB module Vsm-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Vsm-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:35:46 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsIntersection, ValueSizeConstraint, ConstraintsUnion, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsIntersection", "ValueSizeConstraint", "ConstraintsUnion", "ValueRangeConstraint")
dv2, = mibBuilder.importSymbols("DV2-MIB", "dv2")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
iso, NotificationType, Unsigned32, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, Integer32, ModuleIdentity, Gauge32, TimeTicks, ObjectIdentity, Bits, IpAddress, Counter64, Counter32 = mibBuilder.importSymbols("SNMPv2-SMI", "iso", "NotificationType", "Unsigned32", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Integer32", "ModuleIdentity", "Gauge32", "TimeTicks", "ObjectIdentity", "Bits", "IpAddress", "Counter64", "Counter32")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
dv2Vsm = MibIdentifier((1, 3, 6, 1, 4, 1, 251, 1, 1, 47))
class VciInteger(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 65535)

class VpiInteger(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 255)

class VsmBundle(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 127)

vsmCardCfgTable = MibTable((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 1), )
if mibBuilder.loadTexts: vsmCardCfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsmCardCfgTable.setDescription('The VSM card configuration table.')
vsmCardCfgTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 1, 1), ).setIndexNames((0, "Vsm-MIB", "vsmCardCfgIndex"))
if mibBuilder.loadTexts: vsmCardCfgTableEntry.setStatus('mandatory')
vsmCardCfgIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmCardCfgIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vsmCardCfgIndex.setDescription('Index for VSM Card Cfg Table')
vsmCardCfgBndlTslotStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmCardCfgBndlTslotStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vsmCardCfgBndlTslotStatus.setDescription('Enables the collection of Bundle and Timeslot status')
vsmLinkTable = MibTable((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 2), )
if mibBuilder.loadTexts: vsmLinkTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsmLinkTable.setDescription('Table for VSM Link configuration')
vsmLinkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 2, 1), ).setIndexNames((0, "Vsm-MIB", "vsmLinkLink"))
if mibBuilder.loadTexts: vsmLinkEntry.setStatus('mandatory')
vsmLinkLink = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmLinkLink.setStatus('mandatory')
if mibBuilder.loadTexts: vsmLinkLink.setDescription('Link Number for Table Entry')
vsmLinkEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 1))).clone(namedValues=NamedValues(("disabled", 2), ("enabled", 1))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmLinkEnable.setStatus('mandatory')
if mibBuilder.loadTexts: vsmLinkEnable.setDescription("Enable/Disable Link <DETAIL_DESCRIPTION> The user has the ability to enable or disable each of the LIM's links individually.")
vsmLinkEnableStat = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 1, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("disabled", 2), ("enabled", 1), ("wait-for-valid-lim", 3), ("link-not-used", 4), ("error", 5), ("wait-signaling-lim", 6), ("wait-lim-framing", 7), ("wait-frame-bit", 8))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmLinkEnableStat.setStatus('mandatory')
if mibBuilder.loadTexts: vsmLinkEnableStat.setDescription('Link Enable Status <DETAIL_DESCRIPTION> The current status of link depends on a valid lim type, the availability of a link on the LIM and LIM Configuration.')
vsmLinkSigType = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 1))).clone(namedValues=NamedValues(("cas", 2), ("none", 1))).clone('cas')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmLinkSigType.setStatus('mandatory')
if mibBuilder.loadTexts: vsmLinkSigType.setDescription("Enable/Disable Signalling <DETAIL_DESCRIPTION> The user has the ability to enable or disable signalling for each of the LIM's links individually.")
vsmTsCfgTable = MibTable((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 3), )
if mibBuilder.loadTexts: vsmTsCfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsmTsCfgTable.setDescription('The timeslot configuration table.')
vsmTsCfgTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 3, 1), ).setIndexNames((0, "Vsm-MIB", "vsmTsCfgLinkNo"), (0, "Vsm-MIB", "vsmTsCfgTsNo"))
if mibBuilder.loadTexts: vsmTsCfgTableEntry.setStatus('mandatory')
vsmTsCfgLinkNo = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmTsCfgLinkNo.setStatus('mandatory')
if mibBuilder.loadTexts: vsmTsCfgLinkNo.setDescription('The link number.')
vsmTsCfgTsNo = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmTsCfgTsNo.setStatus('mandatory')
if mibBuilder.loadTexts: vsmTsCfgTsNo.setDescription('The timeslot number of the link.')
vsmTsCfgBundleNo = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 3, 1, 3), VsmBundle().clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmTsCfgBundleNo.setStatus('mandatory')
if mibBuilder.loadTexts: vsmTsCfgBundleNo.setDescription('The Bundle mapped to this timeslot.')
vsmTsCfgAALTyp = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 1))).clone(namedValues=NamedValues(("aal2", 2), ("aal1", 1))).clone('aal2')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmTsCfgAALTyp.setStatus('mandatory')
if mibBuilder.loadTexts: vsmTsCfgAALTyp.setDescription('AAL type used for timeslot. This must match the AAL type used by the bundle to which this timeslot is assigned.')
vsmTsCfgChanID = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(8, 255)).clone(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmTsCfgChanID.setStatus('mandatory')
if mibBuilder.loadTexts: vsmTsCfgChanID.setDescription('The Channel ID (CID) this TS is mapped to. The CID must be unique across AAL2 VCs of an end-to-end connection. AAL2 only. ')
vsmTsCfgCmprssionTyp = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 1))).clone(namedValues=NamedValues(("adpcmG726-32k", 2), ("none", 1))).clone('adpcmG726-32k')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmTsCfgCmprssionTyp.setStatus('mandatory')
if mibBuilder.loadTexts: vsmTsCfgCmprssionTyp.setDescription('The voice compression algorithm being used for the timeslot. AAL2 only.')
vsmTsCfgFaxMdmHndlng = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 1))).clone(namedValues=NamedValues(("auto-disable", 2), ("always-compress", 1))).clone('auto-disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmTsCfgFaxMdmHndlng.setStatus('mandatory')
if mibBuilder.loadTexts: vsmTsCfgFaxMdmHndlng.setDescription('The option to handle Fax/Modem signal. AAL2 only. pass-through: make no change when tone is detected, if compressing then keep compressing.bypass: If compressing and tone detected, attempt to switch to uncompressed')
vsmTsCfgEchoCancel = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 1, 2))).clone(namedValues=NamedValues(("auto-disable", 3), ("enable", 1), ("disable", 2))).clone('auto-disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmTsCfgEchoCancel.setStatus('mandatory')
if mibBuilder.loadTexts: vsmTsCfgEchoCancel.setDescription('Indicate whether echo cancellation is enabled.')
vsmTsCfgSilenceRmvl = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 1, 2))).clone(namedValues=NamedValues(("auto-disable", 3), ("enable", 1), ("disable", 2))).clone('auto-disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmTsCfgSilenceRmvl.setStatus('mandatory')
if mibBuilder.loadTexts: vsmTsCfgSilenceRmvl.setDescription('Allows for the configuration of silence removal. Auto will disable silence removal when a FAX/modem tone is detected. AAL2 only.')
vsmTsCfgIdleDetect = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 3, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmTsCfgIdleDetect.setStatus('mandatory')
if mibBuilder.loadTexts: vsmTsCfgIdleDetect.setDescription('Indicate whether idle channel detection is enabled. If disabled this timeslot will always send cells, even when on hook. AAL2 only.')
vsmTsCfgRmtLaw = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 3, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 1, 2))).clone(namedValues=NamedValues(("auto", 3), ("u-law", 1), ("a-law", 2))).clone('auto')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmTsCfgRmtLaw.setStatus('mandatory')
if mibBuilder.loadTexts: vsmTsCfgRmtLaw.setDescription("Indicates the remote VSM's companding type. u-law for T1, a-law for E1. Auto means use the same type as the local link.")
vsmTsCfgSignalTyp = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 3, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(6, 2, 3, 4, 5, 7, 8, 1))).clone(namedValues=NamedValues(("e-and-m", 6), ("gs-fxo-fxs", 2), ("gs-fxs-fxo", 3), ("ls-fxo-fxs", 4), ("ls-fxs-fxo", 5), ("ssr2", 7), ("plar", 8), ("none", 1))).clone('e-and-m')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmTsCfgSignalTyp.setStatus('mandatory')
if mibBuilder.loadTexts: vsmTsCfgSignalTyp.setDescription('This object specifies the signal type of the timeslot. None is used to turn off signaling to allow for data transport.')
vsmTsCfgSigCndTypNB = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 3, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 5, 6, 7))).clone(namedValues=NamedValues(("onhook-A0B0", 1), ("onhook-A0B1", 2), ("offhook-A01B01", 3), ("failure-A1B1", 5), ("failure-A10B1", 6), ("failure-A1B1C1D1", 7))).clone('onhook-A0B0')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmTsCfgSigCndTypNB.setStatus('mandatory')
if mibBuilder.loadTexts: vsmTsCfgSigCndTypNB.setDescription('The object specifies the type of signaling conditioning to narrowband.')
vsmTsCfgSigCndTypATM = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 3, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 5, 6, 7))).clone(namedValues=NamedValues(("onhook-A0B0", 1), ("onhook-A0B1", 2), ("offhook-A01B01", 3), ("failure-A1B1", 5), ("failure-A10B1", 6), ("failure-A1B1C1D1", 7))).clone('onhook-A0B0')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmTsCfgSigCndTypATM.setStatus('mandatory')
if mibBuilder.loadTexts: vsmTsCfgSigCndTypATM.setDescription('The object specifies the type of signaling conditioning to ATM.')
vsmTsCfgDataCndTypNB = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 3, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7, 8, 9, 10, 1))).clone(namedValues=NamedValues(("muLaw-0V-7F", 2), ("muLaw-0V-FF", 3), ("aLaw-0V-D5", 4), ("aLaw-0V-54", 5), ("dacs-trbl-E4", 6), ("ctrl-mode-FE", 7), ("cir-oos-36", 8), ("mux-oos-1A", 9), ("user-data-FF", 10), ("none", 1))).clone('muLaw-0V-7F')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmTsCfgDataCndTypNB.setStatus('mandatory')
if mibBuilder.loadTexts: vsmTsCfgDataCndTypNB.setDescription('The object specifies the type of data conditioning to narrowband.')
vsmTsCfgDataCndTypATM = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 3, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7, 8, 9, 10, 1))).clone(namedValues=NamedValues(("muLaw-0V-7F", 2), ("muLaw-0V-FF", 3), ("aLaw-0V-D5", 4), ("aLaw-0V-54", 5), ("dacs-trbl-E4", 6), ("ctrl-mode-FE", 7), ("cir-oos-36", 8), ("mux-oos-1A", 9), ("user-data-FF", 10), ("none", 1))).clone('muLaw-0V-7F')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmTsCfgDataCndTypATM.setStatus('mandatory')
if mibBuilder.loadTexts: vsmTsCfgDataCndTypATM.setDescription('The object specifies the type of data conditioning to ATM.')
vsmTsCfgMulticast = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 3, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 1))).clone(namedValues=NamedValues(("disabled", 2), ("enabled", 1))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmTsCfgMulticast.setStatus('mandatory')
if mibBuilder.loadTexts: vsmTsCfgMulticast.setDescription('Multicast state: disabled = no multicast')
vsmTsCfgOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 3, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 1, 3, 4, 5, 6, 7, 9, 10, 11, 12, 13, 14, 15, 16, 17))).clone(namedValues=NamedValues(("down", 2), ("up", 1), ("configured", 3), ("inv-cfg", 4), ("aal-mismatch", 5), ("no-more-DSPs", 6), ("inv-CID", 7), ("inv-Lk-no", 9), ("inv-Sil-Det", 10), ("inv-CmpTyp", 11), ("unknown-Lim", 12), ("inv-MCast", 13), ("inv-maxtslot", 14), ("aal1-max-TS", 15), ("inv-MCast-BN", 16), ("non-CAS-link", 17))).clone('down')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmTsCfgOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vsmTsCfgOperStatus.setDescription('The operating status of the timeslot.')
vsmTsCfgAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 3, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 1, 3))).clone(namedValues=NamedValues(("down", 2), ("up", 1), ("reconfig", 3))).clone('down')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmTsCfgAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vsmTsCfgAdminStatus.setDescription('The administrative status of the timeslot.')
vsmTsCfgValidity = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 3, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmTsCfgValidity.setStatus('mandatory')
if mibBuilder.loadTexts: vsmTsCfgValidity.setDescription('Set to invalid(2) to delete this row.')
vsmBundleCfgTable = MibTable((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 4), )
if mibBuilder.loadTexts: vsmBundleCfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsmBundleCfgTable.setDescription('The configuration table for a Bundle. <DETAIL_DESCRIPTION> A VSM Bundle specifies the service requirements of a virtual channel connection, including AAL type, connection type (pvc,svc), bandwidth and QoS.')
vsmBundleCfgTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 4, 1), ).setIndexNames((0, "Vsm-MIB", "vsmBundleCfgNo"))
if mibBuilder.loadTexts: vsmBundleCfgTableEntry.setStatus('mandatory')
vsmBundleCfgNo = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 4, 1, 1), VsmBundle()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmBundleCfgNo.setStatus('mandatory')
if mibBuilder.loadTexts: vsmBundleCfgNo.setDescription('The Bundle number.')
vsmBundleCfgVcVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 4, 1, 2), VpiInteger().clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmBundleCfgVcVpi.setStatus('mandatory')
if mibBuilder.loadTexts: vsmBundleCfgVcVpi.setDescription('The VPI of the VCC.')
vsmBundleCfgVcVci = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 4, 1, 3), VciInteger().clone(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmBundleCfgVcVci.setStatus('mandatory')
if mibBuilder.loadTexts: vsmBundleCfgVcVci.setDescription('The VCI of the VCC. This is the same as the Bundle no. for VSM.')
vsmBundleCfgVcAALTyp = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 1))).clone(namedValues=NamedValues(("aal2", 2), ("aal1", 1))).clone('aal2')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmBundleCfgVcAALTyp.setStatus('mandatory')
if mibBuilder.loadTexts: vsmBundleCfgVcAALTyp.setDescription('The AAL type used for the Bundle. This must match the AAL type used by the timeslot that is assigned to this bundle.')
vsmBundleCfgMaxTslot = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 4, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 120)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmBundleCfgMaxTslot.setStatus('mandatory')
if mibBuilder.loadTexts: vsmBundleCfgMaxTslot.setDescription('Specify the maximum number of timeslots that will be configured for the bundle. AAL2 only')
vsmBundleCfgVcCDV = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 4, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 128)).clone(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmBundleCfgVcCDV.setStatus('mandatory')
if mibBuilder.loadTexts: vsmBundleCfgVcCDV.setDescription('ATM cell delay variation between VSMs (in 125 microsecond intervals) <DETAIL_DESCRIPTION> ATM cell delay variation between VSMs (in 125 microsecond intervals). The maximum programmable value for cell delay variation is 16 milliseconds. Therefore, the greatest number which may be entered in this field is 128 (128 * 125 microsecond units). The default value is 8 (1 millisecond).')
vsmBundleCfgTimerCU = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 4, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 20)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmBundleCfgTimerCU.setStatus('mandatory')
if mibBuilder.loadTexts: vsmBundleCfgTimerCU.setDescription('Maximum amount of time (msec) to hold ATM cell before padding and sending. 0 results in an infinite wait. AAL2 only.')
vsmBundleCfgCESPartialFill = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 4, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 47)).clone(47)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmBundleCfgCESPartialFill.setStatus('mandatory')
if mibBuilder.loadTexts: vsmBundleCfgCESPartialFill.setDescription('Specify the no. of user octets per cell for partial cell fill. AAL1 only.')
vsmBundleCfgVcTyp = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 4, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("pvc", 1), ("spvc", 2), ("svc", 3))).clone('pvc')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmBundleCfgVcTyp.setStatus('mandatory')
if mibBuilder.loadTexts: vsmBundleCfgVcTyp.setDescription('The option to setup VCC.')
vsmBundleCfgTrapCfg = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 4, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no-trap", 1), ("state-change", 2))).clone('no-trap')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmBundleCfgTrapCfg.setStatus('mandatory')
if mibBuilder.loadTexts: vsmBundleCfgTrapCfg.setDescription('State change results in traps sent to the management station.')
vsmBundleCfgOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 4, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 1, 3, 4, 5, 7, 9, 10, 11))).clone(namedValues=NamedValues(("down", 2), ("up", 1), ("configured", 3), ("inv-cfg", 4), ("aal-mismatch", 5), ("inv-VPI", 7), ("bndl-novc", 9), ("inv-maxtslot", 10), ("inv-VPI-15", 11))).clone('down')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmBundleCfgOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vsmBundleCfgOperStatus.setDescription('The operating status of the bundle.')
vsmBundleCfgAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 4, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 1, 3))).clone(namedValues=NamedValues(("down", 2), ("up", 1), ("reconfig", 3))).clone('down')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmBundleCfgAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vsmBundleCfgAdminStatus.setDescription('The administration status of the bundle.')
vsmBundleCfgValidity = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 4, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmBundleCfgValidity.setStatus('mandatory')
if mibBuilder.loadTexts: vsmBundleCfgValidity.setDescription('Set to invalid(2) to delete this row.')
vsmCardStatTable = MibTable((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 5), )
if mibBuilder.loadTexts: vsmCardStatTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsmCardStatTable.setDescription('The VSM card status table.')
vsmCardStatTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 5, 1), ).setIndexNames((0, "Vsm-MIB", "vsmCardStatIndex"))
if mibBuilder.loadTexts: vsmCardStatTableEntry.setStatus('mandatory')
vsmCardStatIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmCardStatIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vsmCardStatIndex.setDescription('Index for VSM Card Status Table')
vsmCardStatBdType = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 5, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmCardStatBdType.setStatus('mandatory')
if mibBuilder.loadTexts: vsmCardStatBdType.setDescription('VSM Hardware type')
vsmCardStatHWSWCompatibility = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 5, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmCardStatHWSWCompatibility.setStatus('mandatory')
if mibBuilder.loadTexts: vsmCardStatHWSWCompatibility.setDescription('Hardware Software Compatibility between bin, Basecard & DOC')
vsmCardStatBinPres = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 5, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("bin-not-present", 1), ("present", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmCardStatBinPres.setStatus('mandatory')
if mibBuilder.loadTexts: vsmCardStatBinPres.setDescription('Indicates presence of vsm.bin file')
vsmCardStatBinRev = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 5, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmCardStatBinRev.setStatus('mandatory')
if mibBuilder.loadTexts: vsmCardStatBinRev.setDescription('The vsm.bin revision number')
vsmCardStatBdRev = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 5, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmCardStatBdRev.setStatus('mandatory')
if mibBuilder.loadTexts: vsmCardStatBdRev.setDescription('The Card Hardware Feature Revision')
vsmCardStatDoc1Type = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 5, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown-doc-type", 1), ("type-48-channel", 2), ("type-60-channel", 3), ("doc-not-present", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmCardStatDoc1Type.setStatus('mandatory')
if mibBuilder.loadTexts: vsmCardStatDoc1Type.setDescription('DOC 1 type supports 48 or 60 channels')
vsmCardStatDoc1TypeRev = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 5, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmCardStatDoc1TypeRev.setStatus('mandatory')
if mibBuilder.loadTexts: vsmCardStatDoc1TypeRev.setDescription('DOC 1 Hardware Revision')
vsmCardStatDoc2Type = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 5, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown-doc-type", 1), ("type-48-channel", 2), ("type-60-channel", 3), ("doc-not-present", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmCardStatDoc2Type.setStatus('mandatory')
if mibBuilder.loadTexts: vsmCardStatDoc2Type.setDescription('DOC 2 type supports 48 or 60 channels')
vsmCardStatDoc2TypeRev = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 5, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmCardStatDoc2TypeRev.setStatus('mandatory')
if mibBuilder.loadTexts: vsmCardStatDoc2TypeRev.setDescription('DOC 2 Hardware Revision')
vsmCardStatLimType = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 5, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("invalid-or-no-lim", 1), ("ds1-dual-signaling-lim", 2), ("ds1-quad-signaling-lim", 3), ("e1-dual-signaling-lim", 4), ("e1-quad-signaling-lim", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmCardStatLimType.setStatus('mandatory')
if mibBuilder.loadTexts: vsmCardStatLimType.setDescription('LIM detected for the VSM card.')
vsmTsStatTable = MibTable((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 6), )
if mibBuilder.loadTexts: vsmTsStatTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsmTsStatTable.setDescription('The VSM Timeslot status table.')
vsmTsStatTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 6, 1), ).setIndexNames((0, "Vsm-MIB", "vsmTsStatLinkNo"), (0, "Vsm-MIB", "vsmTsStatTSNo"))
if mibBuilder.loadTexts: vsmTsStatTableEntry.setStatus('mandatory')
vsmTsStatLinkNo = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmTsStatLinkNo.setStatus('mandatory')
if mibBuilder.loadTexts: vsmTsStatLinkNo.setDescription('The Link Number')
vsmTsStatTSNo = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 6, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmTsStatTSNo.setStatus('mandatory')
if mibBuilder.loadTexts: vsmTsStatTSNo.setDescription('The timeslot number of the link.')
vsmTsStatBundleNo = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 6, 1, 3), VsmBundle()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmTsStatBundleNo.setStatus('mandatory')
if mibBuilder.loadTexts: vsmTsStatBundleNo.setDescription('The Bundle number.')
vsmTsStatXmitBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 6, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmTsStatXmitBytes.setStatus('mandatory')
if mibBuilder.loadTexts: vsmTsStatXmitBytes.setDescription('Number of bytes which have been transmitted <DETAIL_DESCRIPTION> Only applies to AAL2 operating mode. This object provides the user with a count of the number of bytes which have been transmitted to the service interface.')
vsmTsStatRecvBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 6, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmTsStatRecvBytes.setStatus('mandatory')
if mibBuilder.loadTexts: vsmTsStatRecvBytes.setDescription('Number of packets which have been reassembled <DETAIL_DESCRIPTION> Only applies to AAL2 operating mode. This object provides the user with a count of the number of AAL2 packets which have been reassembled or played out to the service interface. It excludes packets that were discarded for any reason, including packets that were not used due to being declared misinserted or discarded while the reassembler was waiting to achieve synchronization')
vsmTsStatUnderflows = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 6, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmTsStatUnderflows.setStatus('mandatory')
if mibBuilder.loadTexts: vsmTsStatUnderflows.setDescription('Number of underflow indications <DETAIL_DESCRIPTION> Only applies to AAL2 operating mode. This object provides the user with a count of the number of underflow indications reported by the DSP to the Maker device (in 2 ms intervals).')
vsmTsStatLostPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 6, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmTsStatLostPackets.setStatus('mandatory')
if mibBuilder.loadTexts: vsmTsStatLostPackets.setDescription('Number of lost packets <DETAIL_DESCRIPTION> Only applies to AAL2 operating mode. This object provides the user with a count of the number of AAL2 packets which have been detected as lost in the network prior to the destination CES IWF layer processing. The cause of a lost packet is an invalid sequence number.')
vsmTsStatAALType = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 6, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 1))).clone(namedValues=NamedValues(("aal2", 2), ("aal1", 1))).clone('aal2')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmTsStatAALType.setStatus('mandatory')
if mibBuilder.loadTexts: vsmTsStatAALType.setDescription('AAL type used for timeslot.')
vsmTsStatVCID = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 6, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmTsStatVCID.setStatus('mandatory')
if mibBuilder.loadTexts: vsmTsStatVCID.setDescription('The number of the CID on which this BC is transmitting')
vsmTsStatCID = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 6, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmTsStatCID.setStatus('mandatory')
if mibBuilder.loadTexts: vsmTsStatCID.setDescription('The number of the CID assigned to this BC')
vsmTsStatActive = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 6, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmTsStatActive.setStatus('mandatory')
if mibBuilder.loadTexts: vsmTsStatActive.setDescription('State of Time Slot (Bearer Channel): yes = active; no = not active <DETAIL_DESCRIPTION> Provides the user with the activity mode of each Time Slot individually. A Time Slot is considered active if it is being processed into ATM cells. Examples of active Time Slots: 1) an off-hook voice channel 2) any data channel Example of inactive Time Slot: 1) an on-hook voice channel ')
vsmTsStatDataLnk = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 6, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dsp", 1), ("bypass", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmTsStatDataLnk.setStatus('mandatory')
if mibBuilder.loadTexts: vsmTsStatDataLnk.setDescription('Indicates whether bearer channel is using DSP or Bypass')
vsmTsStatBlocked = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 6, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 1))).clone(namedValues=NamedValues(("no", 2), ("yes", 1))).clone('no')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmTsStatBlocked.setStatus('mandatory')
if mibBuilder.loadTexts: vsmTsStatBlocked.setDescription('Indicates whether bearer channel is in blocked mode')
vsmTsStatIdleIdle = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 6, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 1))).clone(namedValues=NamedValues(("no", 2), ("yes", 1))).clone('no')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmTsStatIdleIdle.setStatus('mandatory')
if mibBuilder.loadTexts: vsmTsStatIdleIdle.setDescription('Indicates whether bearer channel is on-hook or off-hook')
vsmTsStatHold = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 6, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 1))).clone(namedValues=NamedValues(("no", 2), ("yes", 1))).clone('no')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmTsStatHold.setStatus('mandatory')
if mibBuilder.loadTexts: vsmTsStatHold.setDescription('Indicates whether bearer channel is in hold mode')
vsmTsStatRemoteCompressed = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 6, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 1))).clone(namedValues=NamedValues(("no", 2), ("yes", 1))).clone('no')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmTsStatRemoteCompressed.setStatus('mandatory')
if mibBuilder.loadTexts: vsmTsStatRemoteCompressed.setDescription('Indicates use of compression algorithm on remote channel <DETAIL_DESCRIPTION> A yes indicates that a compression algorithm is being used on the remote channel data. No indicates that no compression algorithm is being used on remote channel.')
vsmTsStatRemoteSilent = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 6, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 1))).clone(namedValues=NamedValues(("no", 2), ("yes", 1))).clone('no')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmTsStatRemoteSilent.setStatus('mandatory')
if mibBuilder.loadTexts: vsmTsStatRemoteSilent.setDescription('Indicates whether remote channel is in silent mode or non silent mode <DETAIL_DESCRIPTION> ')
vsmTsStatCompressed = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 6, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 1))).clone(namedValues=NamedValues(("no", 2), ("yes", 1))).clone('no')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmTsStatCompressed.setStatus('mandatory')
if mibBuilder.loadTexts: vsmTsStatCompressed.setDescription('Indicates use of compression algorithm on local channel <DETAIL_DESCRIPTION> A yes indicates that a compression algorithm is being used on the local channel data. No indicates that no compression algorithm is being used on the local channel.')
vsmTsStatSilent = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 6, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 1))).clone(namedValues=NamedValues(("no", 2), ("yes", 1))).clone('no')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmTsStatSilent.setStatus('mandatory')
if mibBuilder.loadTexts: vsmTsStatSilent.setDescription('Time Slot Silence Status <DETAIL_DESCRIPTION> Indicates whether local channel is in silent mode (yes) or non silent mode (no)')
vsmTsStatConditioning = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 6, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 1))).clone(namedValues=NamedValues(("no", 2), ("yes", 1))).clone('no')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmTsStatConditioning.setStatus('mandatory')
if mibBuilder.loadTexts: vsmTsStatConditioning.setDescription('Conditioning status: yes = conditioning; no = not conditioning <DETAIL_DESCRIPTION> Data conditioning is initiated upon the detection of a variety of error situations including, but not limited to, LOS, LOF and AIS.')
vsmTsStatRemoteConditioning = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 6, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 1))).clone(namedValues=NamedValues(("no", 2), ("yes", 1))).clone('no')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmTsStatRemoteConditioning.setStatus('mandatory')
if mibBuilder.loadTexts: vsmTsStatRemoteConditioning.setDescription('Conditioning status: yes = conditioning; no = not conditioning <DETAIL_DESCRIPTION> Data conditioning is initiated upon the detection of a variety of error situations including, but not limited to, LOS, LOF and AIS.This indicates the remote side is conditioning.')
vsmTsStatRIWF = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 6, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 1))).clone(namedValues=NamedValues(("no", 2), ("yes", 1))).clone('no')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmTsStatRIWF.setStatus('mandatory')
if mibBuilder.loadTexts: vsmTsStatRIWF.setDescription('Remote interworking function alarm active <DETAIL_DESCRIPTION> ')
vsmTsStatLossofRefresh = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 6, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 1))).clone(namedValues=NamedValues(("no", 2), ("yes", 1))).clone('no')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmTsStatLossofRefresh.setStatus('mandatory')
if mibBuilder.loadTexts: vsmTsStatLossofRefresh.setDescription("CAS Refresh status: yes = loss of refresh; no = no alarm <DETAIL_DESCRIPTION> This only applies when signalling is configured for the timeslot. When no signalling is configured this defaults to 'no'. When signalling is configured and it is detected that there is no response to the refresh packet, this bit is set to 'yes'. This will result in ATM signalling and data conditioning.")
vsmTsStatCasValuesPDH = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 6, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("a0-b0-c0-d0", 1), ("a0-b0-c0-d1", 2), ("a0-b0-c1-d0", 3), ("a0-b0-c1-d1", 4), ("a0-b1-c0-d0", 5), ("a0-b1-c0-d1", 6), ("a0-b1-c1-d0", 7), ("a0-b1-c1-d1", 8), ("a1-b0-c0-d0", 9), ("a1-b0-c0-d1", 10), ("a1-b0-c1-d0", 11), ("a1-b0-c1-d1", 12), ("a1-b1-c0-d0", 13), ("a1-b1-c0-d1", 14), ("a1-b1-c1-d0", 15), ("a1-b1-c1-d1", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmTsStatCasValuesPDH.setStatus('mandatory')
if mibBuilder.loadTexts: vsmTsStatCasValuesPDH.setDescription('Value of A B C D bits being sent from VSM physical interface (PDH side) <DETAIL_DESCRIPTION> Provides a snapshot of the current state of the A B C D signalling bits on the PDH side of the network')
vsmTsStatCasValuesATM = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 6, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("a0-b0-c0-d0", 1), ("a0-b0-c0-d1", 2), ("a0-b0-c1-d0", 3), ("a0-b0-c1-d1", 4), ("a0-b1-c0-d0", 5), ("a0-b1-c0-d1", 6), ("a0-b1-c1-d0", 7), ("a0-b1-c1-d1", 8), ("a1-b0-c0-d0", 9), ("a1-b0-c0-d1", 10), ("a1-b0-c1-d0", 11), ("a1-b0-c1-d1", 12), ("a1-b1-c0-d0", 13), ("a1-b1-c0-d1", 14), ("a1-b1-c1-d0", 15), ("a1-b1-c1-d1", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmTsStatCasValuesATM.setStatus('mandatory')
if mibBuilder.loadTexts: vsmTsStatCasValuesATM.setDescription('Value of A B C D bits being sent from the ATM network <DETAIL_DESCRIPTION> Provides a snapshot of the current state of the A B C D signalling bits on the ATM side of the network')
vsmTsStatReset = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 6, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 1))).clone(namedValues=NamedValues(("no", 2), ("yes", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmTsStatReset.setStatus('mandatory')
if mibBuilder.loadTexts: vsmTsStatReset.setDescription('Set to yes(1) to reset all counters in the Time Slot status table.')
vsmBundleStatTable = MibTable((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 7), )
if mibBuilder.loadTexts: vsmBundleStatTable.setStatus('mandatory')
if mibBuilder.loadTexts: vsmBundleStatTable.setDescription('The VSM Bundle status table.')
vsmBundleStatTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 7, 1), ).setIndexNames((0, "Vsm-MIB", "vsmBundleStatBundleNo"))
if mibBuilder.loadTexts: vsmBundleStatTableEntry.setStatus('mandatory')
vsmBundleStatBundleNo = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 7, 1, 1), VsmBundle()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmBundleStatBundleNo.setStatus('mandatory')
if mibBuilder.loadTexts: vsmBundleStatBundleNo.setDescription('The Bundle number.')
vsmBundleStatXmitCells = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 7, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmBundleStatXmitCells.setStatus('mandatory')
if mibBuilder.loadTexts: vsmBundleStatXmitCells.setDescription('The count of the number of AAL2 cells transmitted')
vsmBundleStatRecvCells = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 7, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmBundleStatRecvCells.setStatus('mandatory')
if mibBuilder.loadTexts: vsmBundleStatRecvCells.setDescription('The count of cells that have been played out to the PDH link.')
vsmBundleStatPvcActive = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 7, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 1))).clone(namedValues=NamedValues(("not-active", 2), ("active", 1))).clone('not-active')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmBundleStatPvcActive.setStatus('mandatory')
if mibBuilder.loadTexts: vsmBundleStatPvcActive.setDescription('Is the PVC on this Bundle active.')
vsmBundleStatAALType = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 7, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 1))).clone(namedValues=NamedValues(("aal2", 2), ("aal1", 1))).clone('aal2')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmBundleStatAALType.setStatus('mandatory')
if mibBuilder.loadTexts: vsmBundleStatAALType.setDescription('The AAL type used for the Bundle.')
vsmBundleStatBufUndrflws = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 7, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmBundleStatBufUndrflws.setStatus('mandatory')
if mibBuilder.loadTexts: vsmBundleStatBufUndrflws.setDescription('The number of buffer underflows (AAL1 only).')
vsmBundleStatBufOverflows = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 7, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmBundleStatBufOverflows.setStatus('mandatory')
if mibBuilder.loadTexts: vsmBundleStatBufOverflows.setDescription('The number of buffer overflows (AAL1 only).')
vsmBundleStatPtrReframes = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 7, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmBundleStatPtrReframes.setStatus('mandatory')
if mibBuilder.loadTexts: vsmBundleStatPtrReframes.setDescription('The count of the number of events in which SDT pointer is not where it is expected (AAL1 only). <DETAIL_DESCRIPTION> The count of the number of events in which SDT pointer is not where it is expected (AAL1 only). This counter is 0 for unstructured CES mode')
vsmBundleStatLostCells = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 7, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmBundleStatLostCells.setStatus('mandatory')
if mibBuilder.loadTexts: vsmBundleStatLostCells.setDescription('The number of AAL1 cells detected as lost prior to the destination')
vsmBundleStatHdrErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 7, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmBundleStatHdrErrors.setStatus('mandatory')
if mibBuilder.loadTexts: vsmBundleStatHdrErrors.setDescription('The count of all AAL1 and AAL2 header errors <DETAIL_DESCRIPTION> The Header Error count represents a sum of start pointer, sequence number and parity errors.')
vsmBundleStatBadCID = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 7, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmBundleStatBadCID.setStatus('mandatory')
if mibBuilder.loadTexts: vsmBundleStatBadCID.setDescription('The count of the number of AAL2 cells having a bad CID')
vsmBundleStatAAL2LostCells = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 7, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmBundleStatAAL2LostCells.setStatus('mandatory')
if mibBuilder.loadTexts: vsmBundleStatAAL2LostCells.setDescription('The count of the number of lost AAL2 cells <DETAIL_DESCRIPTION> When operating in AAL2 mode, a non-zero count of lost cells is an indication that invalid sequence numbers exist')
vsmBundleStatReset = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 7, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 1))).clone(namedValues=NamedValues(("no", 2), ("yes", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsmBundleStatReset.setStatus('mandatory')
if mibBuilder.loadTexts: vsmBundleStatReset.setDescription('Set to yes(1) to reset all counters in the Bundle status table.')
vsmBundleStatConditioning = MibTableColumn((1, 3, 6, 1, 4, 1, 251, 1, 1, 47, 7, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 1))).clone(namedValues=NamedValues(("no", 2), ("yes", 1))).clone('no')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsmBundleStatConditioning.setStatus('mandatory')
if mibBuilder.loadTexts: vsmBundleStatConditioning.setDescription('Conditioning status: yes = conditioning; no = not conditioning <DETAIL_DESCRIPTION> Data conditioning is initiated upon the detection of any or all of a variety of errors including: no received cell flow, header errors, buffer underflow, buffer overflow, pointer reframes or lost cells.')
mibBuilder.exportSymbols("Vsm-MIB", vsmTsStatUnderflows=vsmTsStatUnderflows, vsmTsStatLossofRefresh=vsmTsStatLossofRefresh, vsmCardStatBdType=vsmCardStatBdType, vsmTsCfgOperStatus=vsmTsCfgOperStatus, vsmCardStatDoc2Type=vsmCardStatDoc2Type, vsmTsCfgDataCndTypNB=vsmTsCfgDataCndTypNB, vsmCardStatHWSWCompatibility=vsmCardStatHWSWCompatibility, vsmCardStatTable=vsmCardStatTable, vsmBundleCfgNo=vsmBundleCfgNo, vsmBundleStatRecvCells=vsmBundleStatRecvCells, VsmBundle=VsmBundle, vsmBundleStatPvcActive=vsmBundleStatPvcActive, vsmTsStatAALType=vsmTsStatAALType, vsmTsStatConditioning=vsmTsStatConditioning, vsmTsStatActive=vsmTsStatActive, vsmBundleCfgTableEntry=vsmBundleCfgTableEntry, vsmLinkSigType=vsmLinkSigType, vsmBundleStatAAL2LostCells=vsmBundleStatAAL2LostCells, vsmCardStatDoc1Type=vsmCardStatDoc1Type, vsmTsStatTableEntry=vsmTsStatTableEntry, vsmBundleStatTable=vsmBundleStatTable, vsmTsCfgIdleDetect=vsmTsCfgIdleDetect, vsmBundleStatHdrErrors=vsmBundleStatHdrErrors, vsmTsStatCasValuesPDH=vsmTsStatCasValuesPDH, vsmTsCfgSilenceRmvl=vsmTsCfgSilenceRmvl, vsmTsCfgTsNo=vsmTsCfgTsNo, vsmBundleCfgMaxTslot=vsmBundleCfgMaxTslot, vsmBundleStatConditioning=vsmBundleStatConditioning, vsmTsStatCID=vsmTsStatCID, vsmTsStatDataLnk=vsmTsStatDataLnk, vsmTsStatBundleNo=vsmTsStatBundleNo, vsmTsCfgSigCndTypNB=vsmTsCfgSigCndTypNB, vsmCardCfgTable=vsmCardCfgTable, vsmBundleCfgVcCDV=vsmBundleCfgVcCDV, vsmTsStatLostPackets=vsmTsStatLostPackets, vsmTsStatIdleIdle=vsmTsStatIdleIdle, vsmCardCfgTableEntry=vsmCardCfgTableEntry, vsmTsCfgAALTyp=vsmTsCfgAALTyp, vsmLinkEnable=vsmLinkEnable, vsmTsStatRIWF=vsmTsStatRIWF, vsmLinkEnableStat=vsmLinkEnableStat, vsmTsStatXmitBytes=vsmTsStatXmitBytes, vsmTsStatRecvBytes=vsmTsStatRecvBytes, vsmLinkTable=vsmLinkTable, vsmBundleStatBadCID=vsmBundleStatBadCID, vsmBundleCfgAdminStatus=vsmBundleCfgAdminStatus, vsmCardCfgBndlTslotStatus=vsmCardCfgBndlTslotStatus, vsmBundleCfgVcVci=vsmBundleCfgVcVci, vsmBundleCfgTimerCU=vsmBundleCfgTimerCU, vsmBundleCfgVcTyp=vsmBundleCfgVcTyp, vsmCardStatBdRev=vsmCardStatBdRev, vsmBundleStatBundleNo=vsmBundleStatBundleNo, vsmBundleCfgVcVpi=vsmBundleCfgVcVpi, vsmBundleStatPtrReframes=vsmBundleStatPtrReframes, vsmBundleCfgOperStatus=vsmBundleCfgOperStatus, vsmTsCfgValidity=vsmTsCfgValidity, vsmCardCfgIndex=vsmCardCfgIndex, vsmTsCfgTableEntry=vsmTsCfgTableEntry, vsmTsStatTSNo=vsmTsStatTSNo, vsmBundleCfgValidity=vsmBundleCfgValidity, vsmCardStatLimType=vsmCardStatLimType, vsmTsStatReset=vsmTsStatReset, vsmTsCfgSignalTyp=vsmTsCfgSignalTyp, vsmBundleStatBufUndrflws=vsmBundleStatBufUndrflws, dv2Vsm=dv2Vsm, vsmTsCfgEchoCancel=vsmTsCfgEchoCancel, vsmTsCfgCmprssionTyp=vsmTsCfgCmprssionTyp, vsmCardStatIndex=vsmCardStatIndex, vsmTsStatBlocked=vsmTsStatBlocked, vsmTsCfgRmtLaw=vsmTsCfgRmtLaw, vsmBundleStatAALType=vsmBundleStatAALType, vsmTsCfgFaxMdmHndlng=vsmTsCfgFaxMdmHndlng, vsmCardStatTableEntry=vsmCardStatTableEntry, VpiInteger=VpiInteger, vsmBundleStatTableEntry=vsmBundleStatTableEntry, vsmTsCfgTable=vsmTsCfgTable, vsmBundleCfgVcAALTyp=vsmBundleCfgVcAALTyp, vsmTsCfgBundleNo=vsmTsCfgBundleNo, vsmTsCfgDataCndTypATM=vsmTsCfgDataCndTypATM, vsmBundleCfgCESPartialFill=vsmBundleCfgCESPartialFill, vsmTsStatVCID=vsmTsStatVCID, vsmBundleCfgTable=vsmBundleCfgTable, vsmBundleStatXmitCells=vsmBundleStatXmitCells, vsmLinkLink=vsmLinkLink, vsmTsStatRemoteCompressed=vsmTsStatRemoteCompressed, vsmCardStatDoc2TypeRev=vsmCardStatDoc2TypeRev, vsmCardStatDoc1TypeRev=vsmCardStatDoc1TypeRev, vsmTsCfgLinkNo=vsmTsCfgLinkNo, vsmTsCfgSigCndTypATM=vsmTsCfgSigCndTypATM, vsmBundleStatLostCells=vsmBundleStatLostCells, vsmBundleStatReset=vsmBundleStatReset, vsmBundleStatBufOverflows=vsmBundleStatBufOverflows, vsmTsCfgAdminStatus=vsmTsCfgAdminStatus, vsmTsStatTable=vsmTsStatTable, vsmTsStatHold=vsmTsStatHold, vsmTsStatRemoteSilent=vsmTsStatRemoteSilent, vsmBundleCfgTrapCfg=vsmBundleCfgTrapCfg, vsmCardStatBinRev=vsmCardStatBinRev, vsmTsStatCompressed=vsmTsStatCompressed, vsmLinkEntry=vsmLinkEntry, VciInteger=VciInteger, vsmTsCfgChanID=vsmTsCfgChanID, vsmTsStatSilent=vsmTsStatSilent, vsmTsStatCasValuesATM=vsmTsStatCasValuesATM, vsmTsCfgMulticast=vsmTsCfgMulticast, vsmTsStatRemoteConditioning=vsmTsStatRemoteConditioning, vsmCardStatBinPres=vsmCardStatBinPres, vsmTsStatLinkNo=vsmTsStatLinkNo)

#
# PySNMP MIB module Fore-Switch-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Fore-Switch-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:16:49 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueSizeConstraint, ConstraintsUnion, ValueRangeConstraint, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueSizeConstraint", "ConstraintsUnion", "ValueRangeConstraint", "SingleValueConstraint")
ipFilterStatsIfName, ipFilterStatsVPI, ipFilterStatsVCI = mibBuilder.importSymbols("Fore-Adapter-MIB", "ipFilterStatsIfName", "ipFilterStatsVPI", "ipFilterStatsVCI")
crXfrPrimaryTrapStatus, crXfrSecondaryTrapStatus, crXfrIndex, crMemoryAllocated = mibBuilder.importSymbols("Fore-Callrecord-MIB", "crXfrPrimaryTrapStatus", "crXfrSecondaryTrapStatus", "crXfrIndex", "crMemoryAllocated")
AtmSigProtocol, asxd, software, asx, EntryStatus, atmSwitch, NsapAddr, systems, NsapPrefix, GeneralState, IntegerBitString, TransitNetwork, ConnectionType, hardware, SpansAddress = mibBuilder.importSymbols("Fore-Common-MIB", "AtmSigProtocol", "asxd", "software", "asx", "EntryStatus", "atmSwitch", "NsapAddr", "systems", "NsapPrefix", "GeneralState", "IntegerBitString", "TransitNetwork", "ConnectionType", "hardware", "SpansAddress")
trapLogIndex, = mibBuilder.importSymbols("Fore-TrapLog-MIB", "trapLogIndex")
hrSystemDate, = mibBuilder.importSymbols("HOST-RESOURCES-MIB", "hrSystemDate")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
pnniNodeId, = mibBuilder.importSymbols("PNNI-MIB", "pnniNodeId")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Integer32, NotificationType, Counter64, ObjectIdentity, Unsigned32, TimeTicks, Counter32, Gauge32, MibScalar, MibTable, MibTableRow, MibTableColumn, MibIdentifier, iso, Bits, IpAddress, ModuleIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "Integer32", "NotificationType", "Counter64", "ObjectIdentity", "Unsigned32", "TimeTicks", "Counter32", "Gauge32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "MibIdentifier", "iso", "Bits", "IpAddress", "ModuleIdentity")
TestAndIncr, DisplayString, TextualConvention, TimeInterval, TimeStamp, RowStatus, DateAndTime, PhysAddress = mibBuilder.importSymbols("SNMPv2-TC", "TestAndIncr", "DisplayString", "TextualConvention", "TimeInterval", "TimeStamp", "RowStatus", "DateAndTime", "PhysAddress")
foreSwitchModule = ModuleIdentity((1, 3, 6, 1, 4, 1, 326, 2, 7))
if mibBuilder.loadTexts: foreSwitchModule.setLastUpdated('9911050000Z')
if mibBuilder.loadTexts: foreSwitchModule.setOrganization('FORE')
if mibBuilder.loadTexts: foreSwitchModule.setContactInfo(' Postal: FORE Systems Inc. 1000 FORE Drive Warrendale, PA 15086-7502 Tel: +1 724 742 6900 Email: nm_mibs@fore.com Web: http://www.fore.com')
if mibBuilder.loadTexts: foreSwitchModule.setDescription('Fore Switch MIB')
boardGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1))
moduleGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2))
timing = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 3))
netmodTimingGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 3, 1))
boardTimingGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 3, 2))
environment = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4))
alarmGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 1))
powerGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 2))
fansGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 3))
tempGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 4))
cpuGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 5))
mgmtGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 6))
fabricGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 7))
shmem = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5))
netmodShmemGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 1))
portShmemGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 2))
netmodShmem2Group = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 3))
portShmem2Group = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 4))
connShmem2Group = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 5))
netmodShmem3Group = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 6))
portShmem3Group = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 7))
connShmem3Group = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 8))
netmodGenericShmemGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 9))
genericOutputPortGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 10))
dualScp = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 6))
dualScpGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 6, 1))
etherChipSet = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 10))
etherChipSetDec = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 10, 1))
etherChipSetDec21440 = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 10, 1, 1))
switchGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 1))
portGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2))
pathGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3))
channelGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 4))
topologyGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 5))
signalingGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6))
spansGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 1))
q2931Group = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2))
q2931LayerGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1))
swBoardGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 7))
swBoardTopologyGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 8))
nsapGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 9))
upcContractGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 10))
confTopologyGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 11))
oamGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 12))
guardGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 13))
ifIndexMapGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 14))
ifIndexNameGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 15))
cesExtGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 16))
qosClassExpansionGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 17))
pathExtGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 18))
poolGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 19))
asxAtmIfGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 20))
syncStatusMsgGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 21))
syslogGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 22))
poolConfGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 19, 1))
snmp = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 2))
trapConfGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 2, 1))
snmpConfGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 2, 2))
snmpAgentAddressGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 2, 5))
class E164Address(TextualConvention, OctetString):
    description = 'E164 address format defined as 15 ASCII characters.'
    status = 'current'
    displayHint = '15a'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(15, 15)
    fixedLength = 15

class AtmConnSchedMode(TextualConvention, Integer32):
    description = 'The value of this object identifies the scheduling mode for an ATM connection (i.e., VCC or VPC). The possible values are default, roundrobin, guaranteed, and smoothed.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("default", 1), ("roundrobin", 2), ("smoothed", 3), ("guaranteed", 4))

class AtmOrigPathSchedMode(TextualConvention, Integer32):
    description = 'The value of this object identifies the scheduling mode for an originating path. The possible values are flat, shaped and shaped-roundrobin.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("flat", 1), ("shaped", 2), ("shaped-roundrobin", 3))

class AAL5CountingMode(TextualConvention, Integer32):
    description = 'The value of this object identifies the AAL5 counting mode for a connection (i.e., VCC or VPC). Possible values for this object are default, cell-counting and packet-counting.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("default", 1), ("cell-counting", 2), ("packet-counting", 3))

boardTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 1), )
if mibBuilder.loadTexts: boardTable.setStatus('current')
if mibBuilder.loadTexts: boardTable.setDescription('A table of ATM switch board information.')
boardEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 1, 1), ).setIndexNames((0, "Fore-Switch-MIB", "boardIndex"))
if mibBuilder.loadTexts: boardEntry.setStatus('current')
if mibBuilder.loadTexts: boardEntry.setDescription('A table entry containing ATM switch board information.')
boardIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: boardIndex.setStatus('current')
if mibBuilder.loadTexts: boardIndex.setDescription('The index of this board within the ATM switch.')
boardVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: boardVersion.setStatus('current')
if mibBuilder.loadTexts: boardVersion.setDescription('The ATM switch board version number in hex. The version number 0x1 is revision A, 0x2 is revision B etc. Version number 0x0 represents an unknown type.')
boardModel = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 4, 5, 6, 7, 8, 9, 10, 11, 12, 15, 16, 17, 18, 19, 20, 21, 22))).clone(namedValues=NamedValues(("unknown", 0), ("asx100", 1), ("asx200", 2), ("asx200wg", 4), ("asx200bx", 5), ("asx200bxe", 6), ("cabletron9A000", 7), ("asx1000", 8), ("le155", 9), ("sfcs200wg", 10), ("sfcs200bx", 11), ("sfcs1000", 12), ("tnx210", 15), ("tnx1100", 16), ("asx1200", 17), ("asx4000", 18), ("le25", 19), ("esx3000", 20), ("tnx1100b", 21), ("asx150", 22)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: boardModel.setStatus('current')
if mibBuilder.loadTexts: boardModel.setDescription('The ATM switch board model number.')
boardSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: boardSerialNumber.setStatus('current')
if mibBuilder.loadTexts: boardSerialNumber.setDescription('The ATM switch board serial number.')
numberOfModules = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: numberOfModules.setStatus('current')
if mibBuilder.loadTexts: numberOfModules.setDescription('The number of network modules on this ATM switch board.')
vpiLookupErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vpiLookupErrors.setStatus('obsolete')
if mibBuilder.loadTexts: vpiLookupErrors.setDescription('The number of VPI lookup errors.')
vciLookupErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vciLookupErrors.setStatus('obsolete')
if mibBuilder.loadTexts: vciLookupErrors.setDescription('The number of VCI lookup errors.')
boardControlPort = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: boardControlPort.setStatus('current')
if mibBuilder.loadTexts: boardControlPort.setDescription('This object identifies the index for the control port on this switch board.')
boardHDCOMPAsicVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: boardHDCOMPAsicVersion.setStatus('obsolete')
if mibBuilder.loadTexts: boardHDCOMPAsicVersion.setDescription('This object identifies the version number of the HDCOMP ASIC on this switch board.')
boardMcastSpaceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 1, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: boardMcastSpaceIndex.setStatus('current')
if mibBuilder.loadTexts: boardMcastSpaceIndex.setDescription('This object is the index into mcastSpaceTable that gives the number of multicast connections currently supported on this board. Changing this value has the effect of changing the number of multicast connections supported. Change will be effective after reboot only.')
numberOfBoards = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: numberOfBoards.setStatus('current')
if mibBuilder.loadTexts: numberOfBoards.setDescription('The number of switch boards on this ATM switch.')
utilization = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 3))
procUtilGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 3, 1))
mbufUtilGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 3, 3))
procUtilLastUpdate = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 3, 1, 1), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: procUtilLastUpdate.setStatus('current')
if mibBuilder.loadTexts: procUtilLastUpdate.setDescription(' The time the procUtilValue was last updated')
procUtilValue = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 3, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: procUtilValue.setStatus('current')
if mibBuilder.loadTexts: procUtilValue.setDescription(' The percentage of the processor power that has been used over the last monitoring interval')
procUtilMonInterval = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(100, 6000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: procUtilMonInterval.setStatus('current')
if mibBuilder.loadTexts: procUtilMonInterval.setDescription('The amount of time between calculations of the procUtilValue. This value is expressed in units of 10 msec, (100 per sec). This value may take the value of 1 to 60 seconds')
procUtilMinLoad = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 3, 1, 4), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: procUtilMinLoad.setStatus('current')
if mibBuilder.loadTexts: procUtilMinLoad.setDescription(' The MIN percentage of the processor power that has been. This value can be reset by setting the field procUtilHistoryReset.')
procUtilMinLoadLastUpdate = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 3, 1, 5), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: procUtilMinLoadLastUpdate.setStatus('current')
if mibBuilder.loadTexts: procUtilMinLoadLastUpdate.setDescription(' The time the procUtilMinLoad was last updated')
procUtilMaxLoad = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 3, 1, 6), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: procUtilMaxLoad.setStatus('current')
if mibBuilder.loadTexts: procUtilMaxLoad.setDescription(' The MAX percentage of the processor power that has been. This value can be reset by setting the field procUtilHistoryReset.')
procUtilMaxLoadLastUpdate = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 3, 1, 7), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: procUtilMaxLoadLastUpdate.setStatus('current')
if mibBuilder.loadTexts: procUtilMaxLoadLastUpdate.setDescription(' The time the procUtilMaxLoad was last updated')
procUtilHistoryReset = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 3, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: procUtilHistoryReset.setStatus('current')
if mibBuilder.loadTexts: procUtilHistoryReset.setDescription('This is in effect a WRITE_ONLY field. Setting this field resets the procUtilMinLoad, procUtilMinLoadLastUpdate, procUtilMaxLoad, and procUtilMaxLoadLastUpdate. This field can be set to anything by the NMS. When this field is read, it will always report NULL.')
procUtilsNumMallocPart = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 3, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: procUtilsNumMallocPart.setStatus('current')
if mibBuilder.loadTexts: procUtilsNumMallocPart.setDescription(' The number of malloc partitions used on this SCP.')
procUtilsSystemPartitionID = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 3, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: procUtilsSystemPartitionID.setStatus('current')
if mibBuilder.loadTexts: procUtilsSystemPartitionID.setDescription(' The partition ID os the system MALLOC pool. Use this value as an ID into the mallocUtilTable to view the system malloc pool statistics')
boardStatsTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 4), )
if mibBuilder.loadTexts: boardStatsTable.setStatus('current')
if mibBuilder.loadTexts: boardStatsTable.setDescription('A table of ATM switch fabric statistics information.')
boardStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 4, 1), ).setIndexNames((0, "Fore-Switch-MIB", "boardStatsBoard"), (0, "Fore-Switch-MIB", "boardStatsIndex"))
if mibBuilder.loadTexts: boardStatsEntry.setStatus('current')
if mibBuilder.loadTexts: boardStatsEntry.setDescription('A table entry containing ATM switch fabric statistics information.')
boardStatsBoard = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 4, 1, 1), Integer32())
if mibBuilder.loadTexts: boardStatsBoard.setStatus('current')
if mibBuilder.loadTexts: boardStatsBoard.setDescription('The index of this fabric within the ATM switch.')
boardStatsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 4, 1, 2), Integer32())
if mibBuilder.loadTexts: boardStatsIndex.setStatus('current')
if mibBuilder.loadTexts: boardStatsIndex.setDescription('The index of this statistics within the ATM switch fabric.')
boardStatsName = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 4, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: boardStatsName.setStatus('current')
if mibBuilder.loadTexts: boardStatsName.setDescription('The name of this statistics within the ATM switch fabric.')
boardStatsValue = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 4, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: boardStatsValue.setStatus('current')
if mibBuilder.loadTexts: boardStatsValue.setDescription('The value of this statistics within the ATM switch fabric.')
portCardGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 5))
portCardTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 5, 1), )
if mibBuilder.loadTexts: portCardTable.setStatus('current')
if mibBuilder.loadTexts: portCardTable.setDescription('A table of ATM switch port card information.')
portCardEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 5, 1, 1), ).setIndexNames((0, "Fore-Switch-MIB", "portCardIndex"))
if mibBuilder.loadTexts: portCardEntry.setStatus('current')
if mibBuilder.loadTexts: portCardEntry.setDescription('A table entry containing ATM switch port card information.')
portCardIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 5, 1, 1, 1), Integer32())
if mibBuilder.loadTexts: portCardIndex.setStatus('current')
if mibBuilder.loadTexts: portCardIndex.setDescription('The unique index of this port card within the ATM switch.')
portCardName = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portCardName.setStatus('current')
if mibBuilder.loadTexts: portCardName.setDescription('The name of this port card.')
portCardFlavor = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 5, 1, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portCardFlavor.setStatus('current')
if mibBuilder.loadTexts: portCardFlavor.setDescription('The flavor of this port card.')
portCardType = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 5, 1, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portCardType.setStatus('current')
if mibBuilder.loadTexts: portCardType.setDescription('The type description of this port card.')
portCardUptime = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 5, 1, 1, 5), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portCardUptime.setStatus('current')
if mibBuilder.loadTexts: portCardUptime.setDescription('The length of time this port card has been up in hundredths of a second.')
portCardSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 5, 1, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portCardSerialNumber.setStatus('current')
if mibBuilder.loadTexts: portCardSerialNumber.setDescription('The serial number of this port card.')
portCardAssemblyRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 5, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portCardAssemblyRevision.setStatus('current')
if mibBuilder.loadTexts: portCardAssemblyRevision.setDescription('The assembly revision number of this port card.')
portCardHardwareConf = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 5, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portCardHardwareConf.setStatus('current')
if mibBuilder.loadTexts: portCardHardwareConf.setDescription('The hardware configuration number of this port card.')
portCardState = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 5, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("reset", 1), ("inService", 2), ("outOfService", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portCardState.setStatus('current')
if mibBuilder.loadTexts: portCardState.setDescription('The desired state of this port card. If set to reset(1), the port card is reset. Normally, when the port card is active, it is inService(2).')
boardTrafficManagementGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 6))
boardTrafficManagementPerPriorityTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 6, 1), )
if mibBuilder.loadTexts: boardTrafficManagementPerPriorityTable.setStatus('current')
if mibBuilder.loadTexts: boardTrafficManagementPerPriorityTable.setDescription('A table of ATM switch fabric traffic management features that can be controlled per fabric and per priority.')
boardTrafficManagementPerPriorityEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 6, 1, 1), ).setIndexNames((0, "Fore-Switch-MIB", "btmPerPriorityBoard"), (0, "Fore-Switch-MIB", "btmPerPriorityPriority"), (0, "Fore-Switch-MIB", "btmPerPriorityFeature"))
if mibBuilder.loadTexts: boardTrafficManagementPerPriorityEntry.setStatus('current')
if mibBuilder.loadTexts: boardTrafficManagementPerPriorityEntry.setDescription('A table entry of ATM switch fabric traffic management features that can be controlled per fabric and per priority.')
btmPerPriorityBoard = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 6, 1, 1, 1), Integer32())
if mibBuilder.loadTexts: btmPerPriorityBoard.setStatus('current')
if mibBuilder.loadTexts: btmPerPriorityBoard.setDescription('The index of the fabric.')
btmPerPriorityPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 6, 1, 1, 2), Integer32())
if mibBuilder.loadTexts: btmPerPriorityPriority.setStatus('current')
if mibBuilder.loadTexts: btmPerPriorityPriority.setDescription('The index of the traffic priority.')
btmPerPriorityFeature = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 6, 1, 1, 3), Integer32())
if mibBuilder.loadTexts: btmPerPriorityFeature.setStatus('current')
if mibBuilder.loadTexts: btmPerPriorityFeature.setDescription('The index of the feature. Feature 1 is EPD Threshold.')
btmPerPriorityPriorityName = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 6, 1, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: btmPerPriorityPriorityName.setStatus('current')
if mibBuilder.loadTexts: btmPerPriorityPriorityName.setDescription('The name of the traffic priority (e.g. CBR or UBR).')
btmPerPriorityValue = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 6, 1, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: btmPerPriorityValue.setStatus('current')
if mibBuilder.loadTexts: btmPerPriorityValue.setDescription('The value of the specified feature for the specified priority.')
mallocUtilTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 3, 2), )
if mibBuilder.loadTexts: mallocUtilTable.setStatus('current')
if mibBuilder.loadTexts: mallocUtilTable.setDescription('A table containing malloc statistics for each memory partition')
mallocUtilEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 3, 2, 1), ).setIndexNames((0, "Fore-Switch-MIB", "mallocPartId"))
if mibBuilder.loadTexts: mallocUtilEntry.setStatus('current')
if mibBuilder.loadTexts: mallocUtilEntry.setDescription('A table containing malloc statistics for each memory partition')
mallocPartId = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 3, 2, 1, 1), Integer32())
if mibBuilder.loadTexts: mallocPartId.setStatus('current')
if mibBuilder.loadTexts: mallocPartId.setDescription(' The partition number for this malloc partition. The switch has a default partition named (procUtilsSystemPartitionID).')
numBytesFree = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 3, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: numBytesFree.setStatus('current')
if mibBuilder.loadTexts: numBytesFree.setDescription(' Number of Free Bytes in this partition')
numBlocksFree = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 3, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: numBlocksFree.setStatus('current')
if mibBuilder.loadTexts: numBlocksFree.setDescription(' The number of free blocks in this partition')
maxBlockSizeFree = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 3, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: maxBlockSizeFree.setStatus('current')
if mibBuilder.loadTexts: maxBlockSizeFree.setDescription(' The max block size that is free')
numBytesAlloc = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 3, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: numBytesAlloc.setStatus('current')
if mibBuilder.loadTexts: numBytesAlloc.setDescription(' Number of allocated bytes in this partition')
numBlocksAlloc = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 3, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: numBlocksAlloc.setStatus('current')
if mibBuilder.loadTexts: numBlocksAlloc.setDescription(' The number of allocated blocks in this partiton')
mbufsCount = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 3, 3, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbufsCount.setStatus('current')
if mibBuilder.loadTexts: mbufsCount.setDescription(' mbufs obtained from page pool')
mbufsClusters = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 3, 3, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbufsClusters.setStatus('current')
if mibBuilder.loadTexts: mbufsClusters.setDescription(' clusters obtained from page pool ')
mbufsSpace = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 3, 3, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbufsSpace.setStatus('current')
if mibBuilder.loadTexts: mbufsSpace.setDescription(' interface pages obtained from page pool ')
mbufsClFree = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 3, 3, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbufsClFree.setStatus('current')
if mibBuilder.loadTexts: mbufsClFree.setDescription(' Free Clusters ')
mbufsDrops = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 3, 3, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbufsDrops.setStatus('current')
if mibBuilder.loadTexts: mbufsDrops.setDescription(' Times failed to find space ')
mbufsWait = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 3, 3, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbufsWait.setStatus('current')
if mibBuilder.loadTexts: mbufsWait.setDescription(' Times waited for space')
mbufsDrain = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 3, 3, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbufsDrain.setStatus('current')
if mibBuilder.loadTexts: mbufsDrain.setDescription(' Times drained protocols for space ')
mbufsFreeAlloc = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 3, 3, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbufsFreeAlloc.setStatus('current')
if mibBuilder.loadTexts: mbufsFreeAlloc.setDescription(' # of mbufs allocated to free list ')
mbufsDataFreeAlloc = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 3, 3, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbufsDataFreeAlloc.setStatus('current')
if mibBuilder.loadTexts: mbufsDataFreeAlloc.setDescription(' # of mbufs allocated to dynamic (data) allocation ')
mbufsHeaderAlloc = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 3, 3, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbufsHeaderAlloc.setStatus('current')
if mibBuilder.loadTexts: mbufsHeaderAlloc.setDescription(' # of mbufs allocated to packet headers ')
mbufsSocketAlloc = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 3, 3, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbufsSocketAlloc.setStatus('current')
if mibBuilder.loadTexts: mbufsSocketAlloc.setDescription(' # of mbufs allocated to socket structures ')
mbufsPcbAlloc = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 3, 3, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbufsPcbAlloc.setStatus('current')
if mibBuilder.loadTexts: mbufsPcbAlloc.setDescription(' # of mbufs allocated to protocol control blocks ')
mbufsRtableAlloc = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 3, 3, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbufsRtableAlloc.setStatus('current')
if mibBuilder.loadTexts: mbufsRtableAlloc.setDescription(' # of mbufs allocated to routing tables ')
mbufsHtableAlloc = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 3, 3, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbufsHtableAlloc.setStatus('current')
if mibBuilder.loadTexts: mbufsHtableAlloc.setDescription(' # of mbufs allocated to IMP Host Tables ')
mbufsAtableAlloc = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 3, 3, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbufsAtableAlloc.setStatus('current')
if mibBuilder.loadTexts: mbufsAtableAlloc.setDescription(' # of mbufs allocated to Address Resolution Tables ')
mbufsSoNameAlloc = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 3, 3, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbufsSoNameAlloc.setStatus('current')
if mibBuilder.loadTexts: mbufsSoNameAlloc.setDescription(' # of mbufs allocated to Socket Name ')
mbufsZombieAlloc = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 3, 3, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbufsZombieAlloc.setStatus('current')
if mibBuilder.loadTexts: mbufsZombieAlloc.setDescription(' # of mbufs allocated to Zombie Processes ')
mbufsSoOptsAlloc = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 3, 3, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbufsSoOptsAlloc.setStatus('current')
if mibBuilder.loadTexts: mbufsSoOptsAlloc.setDescription(' # of mbufs allocated to Socket Options ')
mbufsFtableAlloc = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 3, 3, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbufsFtableAlloc.setStatus('current')
if mibBuilder.loadTexts: mbufsFtableAlloc.setDescription(' # of mbufs allocated to Fragment Re-assembly Headers ')
mbufsRightsAlloc = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 3, 3, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbufsRightsAlloc.setStatus('current')
if mibBuilder.loadTexts: mbufsRightsAlloc.setDescription(' # of mbufs allocated to Access Rights ')
mbufsIFaddrAlloc = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 1, 3, 3, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbufsIFaddrAlloc.setStatus('current')
if mibBuilder.loadTexts: mbufsIFaddrAlloc.setDescription(' # of mbufs allocated to Interface Addresses ')
moduleTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 1), )
if mibBuilder.loadTexts: moduleTable.setStatus('current')
if mibBuilder.loadTexts: moduleTable.setDescription('A table of network module information.')
moduleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 1, 1), ).setIndexNames((0, "Fore-Switch-MIB", "moduleBoard"), (0, "Fore-Switch-MIB", "moduleNumber"))
if mibBuilder.loadTexts: moduleEntry.setStatus('current')
if mibBuilder.loadTexts: moduleEntry.setDescription('A table entry containing network module information.')
moduleBoard = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleBoard.setStatus('current')
if mibBuilder.loadTexts: moduleBoard.setDescription('The index of this board within the ATM switch.')
moduleNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleNumber.setStatus('current')
if mibBuilder.loadTexts: moduleNumber.setDescription('The number of this network module within the ATM switch.')
moduleName = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleName.setStatus('current')
if mibBuilder.loadTexts: moduleName.setDescription('The type name of this network module within the ATM switch.')
moduleSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 1, 1, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleSpeed.setStatus('current')
if mibBuilder.loadTexts: moduleSpeed.setDescription('The speed of this network module within the ATM switch.')
moduleNumberOfPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleNumberOfPorts.setStatus('current')
if mibBuilder.loadTexts: moduleNumberOfPorts.setDescription('The number of ports on this network module.')
moduleUptime = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 1, 1, 6), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleUptime.setStatus('current')
if mibBuilder.loadTexts: moduleUptime.setDescription('The length of time this network module has been up, in hundredths of a second.')
moduleHwMajorRev = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleHwMajorRev.setStatus('current')
if mibBuilder.loadTexts: moduleHwMajorRev.setDescription('The hardware major revision number of the network module. For generationD network modules this revision number is an ascii character value.')
moduleHwMinorRev = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleHwMinorRev.setStatus('current')
if mibBuilder.loadTexts: moduleHwMinorRev.setDescription('The hardware minor revision number of the network module.')
moduleVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 67))).clone(namedValues=NamedValues(("generationA", 1), ("generationB", 2), ("generationC", 3), ("generationLC", 4), ("generationLE", 5), ("generationD", 6), ("generationPC1", 7), ("generationPC2", 8), ("generationE", 10), ("generationPCF1", 11), ("generationC2", 67)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleVersion.setStatus('current')
if mibBuilder.loadTexts: moduleVersion.setDescription('The hardware version of this network module.')
moduleTimingSupport = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleTimingSupport.setStatus('current')
if mibBuilder.loadTexts: moduleTimingSupport.setDescription('Does this network module support distributed timing?')
moduleProductNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 1, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleProductNumber.setStatus('current')
if mibBuilder.loadTexts: moduleProductNumber.setDescription('The product number of this network module.')
moduleState = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("reset", 1), ("inService", 2), ("outOfService", 3), ("resetPair", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: moduleState.setStatus('current')
if mibBuilder.loadTexts: moduleState.setDescription('The desired state of this network module. If set to reset(1), the netmod is reset. Normally, when the netmod is active, it is inService(2). To put a netmod out of service, this entry must be set to outOfService(3).')
moduleSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 1, 1, 13), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleSerialNumber.setStatus('current')
if mibBuilder.loadTexts: moduleSerialNumber.setDescription('The string representing the serial number for this network module.')
moduleTestAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("normal", 1), ("startTest", 2), ("abortTest", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: moduleTestAdminStatus.setStatus('current')
if mibBuilder.loadTexts: moduleTestAdminStatus.setDescription('This variable indicates the hardware test configuration of the network module. It can be set to startTest(2), which starts the hardware tests on the network module. abortTest(3) aborts the test, if the network module is under test. The network module returns to normal(0) after the test ends or is aborted.')
moduleTestOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("normal", 1), ("underTest", 2), ("testSuccessful", 3), ("testFailed", 4), ("testAborted", 5), ("testUnsupported", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleTestOperStatus.setStatus('current')
if mibBuilder.loadTexts: moduleTestOperStatus.setDescription('The status of the hardware tests on the network module. normal (1) indicates that the network module has never undergone hardware tests. The network module is underTest (2), after the test is started on it, and goes to testSuccessful (3) or testFailed (4), after the tests end. If the tests are aborted, the network module goes to testAborted (5) state. Those network modules that do not support hardware tests like Series-C and LC modules, are in testUnsupported (6) state.')
moduleTestStatusText = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 1, 1, 16), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleTestStatusText.setStatus('current')
if mibBuilder.loadTexts: moduleTestStatusText.setDescription('A message describing the status of the current test')
moduleAttachState = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("inService", 1), ("outOfService", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleAttachState.setStatus('current')
if mibBuilder.loadTexts: moduleAttachState.setDescription('The actual state of this network module. The netmod state is directed by the moduleState variable. This variable gives the actual state at a given time (which may lag behind the moduleState by several seconds).')
moduleCLEI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 1, 1, 18), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleCLEI.setStatus('current')
if mibBuilder.loadTexts: moduleCLEI.setDescription('The Common Language Equipment identifications (CLEI) of this network module.')
appModuleTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 6), )
if mibBuilder.loadTexts: appModuleTable.setStatus('current')
if mibBuilder.loadTexts: appModuleTable.setDescription('A table consisting of hardware components that have on-board CPUs. Currently, the FR/ATM, FUNI and IMA network modules appear in this table.')
appModuleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 6, 1), ).setIndexNames((0, "Fore-Switch-MIB", "appModuleIndex"))
if mibBuilder.loadTexts: appModuleEntry.setStatus('current')
if mibBuilder.loadTexts: appModuleEntry.setDescription('A table entry containing application module information.')
appModuleIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appModuleIndex.setStatus('current')
if mibBuilder.loadTexts: appModuleIndex.setDescription('The index of the application module in this switch.')
appModuleName = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 6, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appModuleName.setStatus('current')
if mibBuilder.loadTexts: appModuleName.setDescription('The name of this application module.')
appModuleOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("notConfigured", 1), ("hwInitInProgress", 2), ("up", 3), ("shutDownInProgress", 4), ("down", 5), ("failed", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appModuleOperState.setStatus('current')
if mibBuilder.loadTexts: appModuleOperState.setDescription("The operational state of this network module's hardware.")
appModuleStatusText = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 6, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appModuleStatusText.setStatus('current')
if mibBuilder.loadTexts: appModuleStatusText.setDescription('A text string describing the current state of the hardware.')
appModuleApplicationType = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 6, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appModuleApplicationType.setStatus('current')
if mibBuilder.loadTexts: appModuleApplicationType.setDescription('This variable indicates the application(s) running on this application module.')
appModuleSoftwareVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 6, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appModuleSoftwareVersion.setStatus('current')
if mibBuilder.loadTexts: appModuleSoftwareVersion.setDescription('Version of the software running on this application module.')
appModuleBootSoftwareVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 6, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appModuleBootSoftwareVersion.setStatus('current')
if mibBuilder.loadTexts: appModuleBootSoftwareVersion.setDescription('Version of the BOOT PROM software on this application module.')
appModuleOosLed = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 6, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("red", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appModuleOosLed.setStatus('current')
if mibBuilder.loadTexts: appModuleOosLed.setDescription("The color of the OOS LED on the application module. This LED is off (1) when the network module is up and running and red (2) when the network module is down (administratively placed out of service or operationally down temporarily). For example, when the network module's hardware initialization is in progress, the LED will be red until the hardware initialization is complete.")
appModulePanicAction = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 6, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("reset", 1), ("suspend", 2))).clone('reset')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appModulePanicAction.setStatus('current')
if mibBuilder.loadTexts: appModulePanicAction.setDescription('This variable indicates the action to be taken if the on-board CPU fails. This module will be reset if this variable is set to reset(1) and will be suspended if this variable is set to suspend(2).')
outputBufferTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 2), )
if mibBuilder.loadTexts: outputBufferTable.setStatus('current')
if mibBuilder.loadTexts: outputBufferTable.setDescription('A table of output buffer information.')
outputBufferEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 2, 1), ).setIndexNames((0, "Fore-Switch-MIB", "obufBoard"), (0, "Fore-Switch-MIB", "obufNumber"), (0, "Fore-Switch-MIB", "obufType"))
if mibBuilder.loadTexts: outputBufferEntry.setStatus('current')
if mibBuilder.loadTexts: outputBufferEntry.setDescription('A table entry containing output buffer information.')
obufBoard = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: obufBoard.setStatus('current')
if mibBuilder.loadTexts: obufBoard.setDescription("The index of this output buffer's switch board.")
obufNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: obufNumber.setStatus('current')
if mibBuilder.loadTexts: obufNumber.setDescription('The number of the network module for this output buffer.')
obufType = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: obufType.setStatus('current')
if mibBuilder.loadTexts: obufType.setDescription('The Priority of this output buffer- 0 is lowest priority')
obufOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("enabled", 2), ("disabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: obufOperStatus.setStatus('current')
if mibBuilder.loadTexts: obufOperStatus.setDescription('The operational status of this output buffer.')
obufBufferSize = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: obufBufferSize.setStatus('current')
if mibBuilder.loadTexts: obufBufferSize.setDescription('The logical size of this output buffer, in cells.')
obufQueueLength = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 2, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: obufQueueLength.setStatus('current')
if mibBuilder.loadTexts: obufQueueLength.setDescription('The number of cells in this output buffer.')
obufOverflows = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 2, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: obufOverflows.setStatus('current')
if mibBuilder.loadTexts: obufOverflows.setDescription('The number of cells dropped because this output buffer was full.')
obufPriorityName = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 2, 1, 8), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: obufPriorityName.setStatus('current')
if mibBuilder.loadTexts: obufPriorityName.setDescription('The priority name (eg. CBR, VBR) for this buffer.')
obufName = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 2, 1, 9), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: obufName.setStatus('current')
if mibBuilder.loadTexts: obufName.setDescription('The name (eg. 1, 1A) of this buffer.')
hwPortTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 3), )
if mibBuilder.loadTexts: hwPortTable.setStatus('current')
if mibBuilder.loadTexts: hwPortTable.setDescription('A table of hardware port information.')
hwPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 3, 1), ).setIndexNames((0, "Fore-Switch-MIB", "hwPortBoard"), (0, "Fore-Switch-MIB", "hwPortModule"), (0, "Fore-Switch-MIB", "hwPortNumber"))
if mibBuilder.loadTexts: hwPortEntry.setStatus('current')
if mibBuilder.loadTexts: hwPortEntry.setDescription('A table entry containing hardware port information.')
hwPortBoard = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPortBoard.setStatus('current')
if mibBuilder.loadTexts: hwPortBoard.setDescription('The switch board index of this port.')
hwPortModule = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPortModule.setStatus('current')
if mibBuilder.loadTexts: hwPortModule.setDescription('The network module number of this port.')
hwPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPortNumber.setStatus('current')
if mibBuilder.loadTexts: hwPortNumber.setDescription('The number of this port within its network module.')
hwPortVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 67))).clone(namedValues=NamedValues(("generationA", 1), ("generationB", 2), ("generationC", 3), ("generationLC", 4), ("generationLE", 5), ("generationD", 6), ("generationPC1", 7), ("generationPC2", 8), ("generationE", 10), ("generationPCF1", 11), ("generationC2", 67)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPortVersion.setStatus('current')
if mibBuilder.loadTexts: hwPortVersion.setDescription('The generation of this network module. In general, generation A indicates the most original FORE Systems netmods. Generation-B are intermediate DS3/E3/TAXI. Generation-C are shared-memory based netmods.')
hwPortModel = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35))).clone(namedValues=NamedValues(("model-TAXI-100", 1), ("model-TAXI-140", 2), ("model-DS3", 3), ("model-OC3", 4), ("model-8B10B", 5), ("model-6port-TAXI-100", 6), ("model-ASX-CTL", 7), ("model-OC12", 8), ("model-OC48", 9), ("model-DS3-PDH", 16), ("model-E3", 17), ("model-J2", 18), ("model-DS1", 19), ("model-E1", 20), ("model-TP25", 21), ("model-ASX-BP", 22), ("model-CESDS1", 23), ("model-CESE1", 24), ("model-FRAMDS1", 25), ("model-FRAME1", 26), ("model-IMADS1", 27), ("model-IMAE1", 28), ("model-RJ-45", 29), ("model-CHOC12", 30), ("model-STM1", 31), ("model-OC3-POS", 32), ("model-OC12-POS", 33), ("model-CHOC3", 34), ("model-ETH", 35)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPortModel.setStatus('current')
if mibBuilder.loadTexts: hwPortModel.setDescription('The type of physical connection of this port. The model-ASX(7) indicates this is the control port of the switch. NOTE: as of 2/8/95 the elements model-6port-TAXI-100(6) and model-DS3-PDH(16) should no longer be used. Use the basic types model-TAXI-100(1) and model-DS3(3) to indicate these.')
hwPortOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("up", 2), ("down", 3), ("unused", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPortOperStatus.setStatus('current')
if mibBuilder.loadTexts: hwPortOperStatus.setDescription('The operational status of this port. If a port was administered up (by hwPortAdminStatus), but the carrier or the framing bits were lost, the hwPortOperStatus indicates that the port is down(3). Otherwise, the hwPortOperStatus is up(2).')
hwPortBufferSize = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 3, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPortBufferSize.setStatus('deprecated')
if mibBuilder.loadTexts: hwPortBufferSize.setDescription("The logical size of this port's output buffer, in cells.")
hwPortQueueLength = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 3, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPortQueueLength.setStatus('deprecated')
if mibBuilder.loadTexts: hwPortQueueLength.setDescription("The number of cells in this port's output buffer.")
hwPortOverflows = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 3, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPortOverflows.setStatus('deprecated')
if mibBuilder.loadTexts: hwPortOverflows.setDescription("The number of seconds in which cells were dropped because this port's output buffer was full.")
hwPortErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 3, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPortErrors.setStatus('deprecated')
if mibBuilder.loadTexts: hwPortErrors.setDescription('The number of seconds in which errored cells were dropped by this port.')
hwPortCarrier = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 3, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("carrier", 1), ("noCarrier", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPortCarrier.setStatus('current')
if mibBuilder.loadTexts: hwPortCarrier.setDescription('The presence or absence of carrier at this port.')
hwPortGlobalIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 3, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPortGlobalIndex.setStatus('deprecated')
if mibBuilder.loadTexts: hwPortGlobalIndex.setDescription('The global index of this port within the ATM switch as a whole. It corresponds to the port number used in the software group of this MIB.')
hwPortName = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 3, 1, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 5))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPortName.setStatus('current')
if mibBuilder.loadTexts: hwPortName.setDescription('A textual description of the port indicating the Board Network module and Port (BNP) identifiers. The module is indicated by a letter (A-D), while the board and the port are indicated by numbers.')
hwPortAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 3, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwPortAdminStatus.setStatus('current')
if mibBuilder.loadTexts: hwPortAdminStatus.setDescription('The administrative state of the physical layer of this port. When a port is configured up(1), the physical layer is configured to process all physical layer events including the transmission and reception of data (cells). When a port is configured down(2), the physical layer should be shut down and should ignore all physical layer events (e.g. cell reception, carrier loss, loss of framing, parity errors, etc.). The operational status of a port is reflected in the hwPortOperStatus object.')
hwPortTAXILoopback = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 3, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noLoopback", 1), ("loopback", 2))).clone('noLoopback')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwPortTAXILoopback.setStatus('current')
if mibBuilder.loadTexts: hwPortTAXILoopback.setDescription('This variable represents the loopback status of a TAXI port. For non-TAXI ports (e.g. DS3/E3 or SONET) the loopback configuration should be set in their specific tables.')
hwPortLEDModel = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 3, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("lan", 1), ("wan", 2))).clone('lan')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwPortLEDModel.setStatus('current')
if mibBuilder.loadTexts: hwPortLEDModel.setDescription('The LED model to use for setting the colors of the LEDs on each port. LAN models typically blink the LEDs when data is transmitted or received on the port. WAN models typically keep the LEDs green unless an error condition exists on the port. With SONET netmods the LED models use the following algorithms: LAN (3 states): if (LOS || LOF || AIS_L || LOP_P || UNEQ_P || PLM_P || LCD) { rxLED = RED } else if (RDI_L) { rxLED = YELLOW } else { rxLED = AUTO } txLED = AUTO WAN (3 states): if (LOS || LOF || AIS_L || LOP_P || UNEQ_P || PLM_P || LCD) { rxLED = RED } else if (RDI_L) { rxLED = YELLOW } else { rxLED = GREEN } txLED = GREEN With LAN and WAN models: RED means fault in receive direction, YELLOW means fault in transmit direction (RDI_L defect), AUTO/GREEN means no fault. Only the receive LED color is changed. These models show only three states and do not reflect the status of the AIS_P and RDI_P defects.')
hwPortTxLED = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 3, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("off", 1), ("green", 2), ("red", 3), ("yellow", 4), ("auto", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPortTxLED.setStatus('current')
if mibBuilder.loadTexts: hwPortTxLED.setDescription('Indicates the color of the transmit LED for this port. Auto means that the LED is under hardware control. Typically hardware control means that the LED is normally dark with green blinks to indicate data traffic.')
hwPortRxLED = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 3, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("off", 1), ("green", 2), ("red", 3), ("yellow", 4), ("auto", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPortRxLED.setStatus('current')
if mibBuilder.loadTexts: hwPortRxLED.setDescription('Indicates the color of the receive LED for this port. Auto means that the LED is under hardware control. Typically hardware control means that the LED is normally dark with green blinks to indicate data traffic.')
hwPortIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 3, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPortIfIndex.setStatus('current')
if mibBuilder.loadTexts: hwPortIfIndex.setDescription('This entry indicates the IfIndex used to identify this port. It corresponds to the ifIndex used in the rfc2233 rfc1573 ifTables')
hwPortRxSyncLED = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 3, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("green", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPortRxSyncLED.setStatus('current')
if mibBuilder.loadTexts: hwPortRxSyncLED.setDescription('The synchronization LED which only applies to the receivers. When green, it indicates that the port is providing the 8 khz clock reference to the switch. This is a new entry which makes sense to those netmod ( currently only FRAM netmod support this LED) which can provide a 8 khz clock reference to the switch. At the netmod scope, only one such LED should be green if the switch is importing a port timing clock.')
hwPortCounterResetTime = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 3, 1, 21), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPortCounterResetTime.setStatus('current')
if mibBuilder.loadTexts: hwPortCounterResetTime.setDescription("Indicates when this port's physical interface counters were reset. The TimeStamp is equal to moduleUptime when the reset occurred. If this ports counters were never reset, hwPortCounterResetTime will be zero. This variable is updated whenever hwPortCounterReset or switchCounterReset is written.")
hwPortCounterReset = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 3, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 4))).clone(namedValues=NamedValues(("resetRequest", 1), ("resetTrue", 3), ("resetFalse", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwPortCounterReset.setStatus('current')
if mibBuilder.loadTexts: hwPortCounterReset.setDescription('Writing a value of resetRequest will result in a reset of all physical interface counters on this port. VCC indexed counters are excluded. A response value of resetTrue indicates a resetRequest has succeeded and is currently in effect. A response value of resetFalse indicates a reset is not currently in effect.')
hwPortSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 3, 1, 23), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwPortSpeed.setStatus('current')
if mibBuilder.loadTexts: hwPortSpeed.setDescription('The speed of this physical port in the ATM switch.')
netmodAlarmsTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 4), )
if mibBuilder.loadTexts: netmodAlarmsTable.setStatus('current')
if mibBuilder.loadTexts: netmodAlarmsTable.setDescription('A table of network module alarms information categorized on a per slot basis.')
netmodAlarmsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 4, 1), ).setIndexNames((0, "Fore-Switch-MIB", "netmodSlot"))
if mibBuilder.loadTexts: netmodAlarmsEntry.setStatus('current')
if mibBuilder.loadTexts: netmodAlarmsEntry.setDescription('A table entry containing network module alarm information.')
netmodSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: netmodSlot.setStatus('current')
if mibBuilder.loadTexts: netmodSlot.setDescription('This number represents the unique number of this netmod within the ATM switch. This number starts at 0.')
netmodSlotPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("high", 1), ("low", 2), ("none", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: netmodSlotPriority.setStatus('current')
if mibBuilder.loadTexts: netmodSlotPriority.setDescription('The priority assigned to this slot. Possible values are High (corresponding to netmodRemovedHighPrio), Low (corresponding to netmodRemovedLowPrio) and None (default)')
netmodStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("present", 1), ("absent", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: netmodStatus.setStatus('current')
if mibBuilder.loadTexts: netmodStatus.setDescription('The presence/absence of a netmod in this slot is determined by this variable.')
netmodName = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 4, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: netmodName.setStatus('current')
if mibBuilder.loadTexts: netmodName.setDescription('The name of this netmod. Example: 1A, 3D for ASX4000 and A, B for pre-ASX4000 switches.')
hdcompTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 5), )
if mibBuilder.loadTexts: hdcompTable.setStatus('current')
if mibBuilder.loadTexts: hdcompTable.setDescription('A table for information about HDCOMPs.')
hdcompEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 5, 1), ).setIndexNames((0, "Fore-Switch-MIB", "hdcompIndex"))
if mibBuilder.loadTexts: hdcompEntry.setStatus('current')
if mibBuilder.loadTexts: hdcompEntry.setDescription('A table for information about HDCOMPs.')
hdcompIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 5, 1, 1), Integer32())
if mibBuilder.loadTexts: hdcompIndex.setStatus('current')
if mibBuilder.loadTexts: hdcompIndex.setDescription('Index of the HDCOMP on the switch.')
hdcompDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 5, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 5))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hdcompDescr.setStatus('current')
if mibBuilder.loadTexts: hdcompDescr.setDescription('Description of the HDCOMP location on the switch.')
hdcompAsicVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 5, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hdcompAsicVersion.setStatus('current')
if mibBuilder.loadTexts: hdcompAsicVersion.setDescription('Version number of the HDCOMP ASIC on the switch.')
hdcompVpiLookupErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 5, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hdcompVpiLookupErrors.setStatus('current')
if mibBuilder.loadTexts: hdcompVpiLookupErrors.setDescription('The number of VPI lookup errors.')
hdcompVciLookupErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 2, 5, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hdcompVciLookupErrors.setStatus('current')
if mibBuilder.loadTexts: hdcompVciLookupErrors.setDescription('The number of VCI lookup errors.')
swAlarmTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 1, 1), )
if mibBuilder.loadTexts: swAlarmTable.setStatus('current')
if mibBuilder.loadTexts: swAlarmTable.setDescription('A table of switch alarm definitions and configuration.')
swAlarmEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 1, 1, 1), ).setIndexNames((0, "Fore-Switch-MIB", "swAlarmType"))
if mibBuilder.loadTexts: swAlarmEntry.setStatus('current')
if mibBuilder.loadTexts: swAlarmEntry.setDescription('A table entry containing switch alarm definitions.')
swAlarmType = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("powerSupplyInputFailed", 1), ("powerSupplyOutputFailed", 2), ("fanBankFailed", 3), ("tempSensorOverTemp", 4), ("linkFailed", 5), ("spansFailed", 6), ("powerSupplyOverCurrent", 7), ("powerSupply5VoltFailed", 8), ("netmodRemovedHighPrio", 9), ("netmodRemovedLowPrio", 10), ("fabricRemoved", 11), ("genPortFailure", 12), ("singleTimingRefFailed", 13), ("allTimingRefsFailed", 14), ("singleTCMFailed", 15), ("allTCMsFailed", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swAlarmType.setStatus('current')
if mibBuilder.loadTexts: swAlarmType.setDescription('The type of the alarm.')
swAlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swAlarmStatus.setStatus('current')
if mibBuilder.loadTexts: swAlarmStatus.setDescription('The status of this alarm entry. An alarm becomes active if the underlying condition is detected. For power supplies, the input failed alarm condition is asserted if the input voltage is not within the nominal range for the supply. This does not necessarily mean that an ouput failure will result. A power supply output failure condition is asserted if any power supply is failing or if it is physically removed. Power supply output alarms are only applicable to switches with multiple power supplies. Fan bank and temperature sensor failures are applicable only to switches with the appropriate sensing capabilities. Link and spans failures are applicable to all switches.')
swAlarmMinorCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swAlarmMinorCategory.setStatus('current')
if mibBuilder.loadTexts: swAlarmMinorCategory.setDescription('This object indicates whether a minor alarm is triggered when this event occurs.')
swAlarmMajorCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swAlarmMajorCategory.setStatus('current')
if mibBuilder.loadTexts: swAlarmMajorCategory.setDescription('This object indicates whether a major alarm is triggered when this event occurs.')
swAlarmReset = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("default", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swAlarmReset.setStatus('current')
if mibBuilder.loadTexts: swAlarmReset.setDescription('The manager may set this to the value 0 or 1 to cancel a current alarm. This is useful for silencing alarms triggered via edge detection. If this variable is readable, then the alarm is resettable.')
swAlarmCriticalCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swAlarmCriticalCategory.setStatus('current')
if mibBuilder.loadTexts: swAlarmCriticalCategory.setDescription('This object indicates whether a critical alarm is triggered when this event occurs. This is supported only on certain platforms.')
swAlarmACOState = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swAlarmACOState.setStatus('current')
if mibBuilder.loadTexts: swAlarmACOState.setDescription('This object indicates the Alarm Cutoff Status(ACO) of this alarm entry. To silence an active alarm relay condition this value can be set to on(1), by pushing the front panel ACO button. The ACO is turned off when the alarm status(SwAlarmStatus) becomes inactive.')
swAlarmMajorRelayState = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swAlarmMajorRelayState.setStatus('current')
if mibBuilder.loadTexts: swAlarmMajorRelayState.setDescription('This object indicates the current state of the major alarm relay. If one or more of the alarms (swAlarmType) that are defined major (swAlarmMajorCategory) are currently active (swAlarmStatus), and the alarm cutoff(swAlarmACOState) is off then this object will be on(1).')
swAlarmMinorRelayState = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swAlarmMinorRelayState.setStatus('current')
if mibBuilder.loadTexts: swAlarmMinorRelayState.setDescription('This object indicates the current state of the minor alarm relay. If one or more of the alarms (swAlarmType) that are defined minor (swAlarmMinorCategory) are currently active (swAlarmStatus), and the alarm cutoff(swAlarmACOState) is off then this object will be on(1).')
swAlarmCriticalRelayState = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swAlarmCriticalRelayState.setStatus('current')
if mibBuilder.loadTexts: swAlarmCriticalRelayState.setDescription('This object indicates the current state of the critical alarm relay. If one or more of the alarms (swAlarmType) that are defined critical (swAlarmCriticalCategory) are currently active (swAlarmStatus), and the alarm cutoff(swAlarmACOState) is off then this object will be on(1).')
swAlarmRelayTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 1, 5), )
if mibBuilder.loadTexts: swAlarmRelayTable.setStatus('current')
if mibBuilder.loadTexts: swAlarmRelayTable.setDescription('This table contains the alarm relay definitions for the switch alarms')
swAlarmRelayEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 1, 5, 1), ).setIndexNames((0, "Fore-Switch-MIB", "swAlarmRelayIndex"))
if mibBuilder.loadTexts: swAlarmRelayEntry.setStatus('current')
if mibBuilder.loadTexts: swAlarmRelayEntry.setDescription('This entry contains the alarm relay definitions for the switch alarms.')
swAlarmRelayIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 1, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swAlarmRelayIndex.setStatus('current')
if mibBuilder.loadTexts: swAlarmRelayIndex.setDescription('This is the index of the alarm relay on the switch.')
swAlarmRelayFunction = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 1, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("swUnusedRelay", 1), ("swMajorAlarmRelay", 2), ("swMinorAlarmRelay", 3), ("swCriticalAlarmRelay", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swAlarmRelayFunction.setStatus('current')
if mibBuilder.loadTexts: swAlarmRelayFunction.setDescription('This is the alarm function associated with an alarm relay on the switch. An alarm relay may either be unused, assigned to one of critical, major and minor alarm.')
swAlarmRelayState = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 1, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swAlarmRelayState.setStatus('current')
if mibBuilder.loadTexts: swAlarmRelayState.setDescription("This is the current state of the alarm relay. The state 'on' means that the alarm relay is activated; the state 'off' means that it is deactivated.")
swAlarmRelayOperMode = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 1, 5, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("test", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swAlarmRelayOperMode.setStatus('current')
if mibBuilder.loadTexts: swAlarmRelayOperMode.setDescription("This variable represents the operational mode of the relay. The operational mode 'enabled' means that the relay is under software control and the relay state will reflect 'on' or 'off' according to the alarm conditions. 'disabled' will make the alarm relay state always 'off'. 'test' will make it always 'on'.")
envMaxNumberOfPowerSupplies = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 2, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: envMaxNumberOfPowerSupplies.setStatus('current')
if mibBuilder.loadTexts: envMaxNumberOfPowerSupplies.setDescription('The maximum number of power supplies that can be installed on this ATM switch.')
envNumberOfPowerSupplies = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 2, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: envNumberOfPowerSupplies.setStatus('current')
if mibBuilder.loadTexts: envNumberOfPowerSupplies.setDescription('The number of power supply entries in the power supply table. This is the number of power supplies actually present.')
envPowerSupplyTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 2, 3), )
if mibBuilder.loadTexts: envPowerSupplyTable.setStatus('current')
if mibBuilder.loadTexts: envPowerSupplyTable.setDescription('A table of power supply information.')
envPowerSupplyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 2, 3, 1), ).setIndexNames((0, "Fore-Switch-MIB", "envPowerSupplyIndex"))
if mibBuilder.loadTexts: envPowerSupplyEntry.setStatus('current')
if mibBuilder.loadTexts: envPowerSupplyEntry.setDescription('A table entry containing power supply information.')
envPowerSupplyIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 2, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: envPowerSupplyIndex.setStatus('current')
if mibBuilder.loadTexts: envPowerSupplyIndex.setDescription('The index of this power supply.')
envPowerSupplyType = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 2, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("psUnknown", 1), ("psAutoRangeAC", 4), ("ps48VDC", 5), ("psRM1000HA", 6), ("ps30ADC", 7), ("psRM1000HA-C", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: envPowerSupplyType.setStatus('current')
if mibBuilder.loadTexts: envPowerSupplyType.setDescription('The type of this power supply.')
envPowerSupplyInputState = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 2, 3, 1, 3), GeneralState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: envPowerSupplyInputState.setStatus('current')
if mibBuilder.loadTexts: envPowerSupplyInputState.setDescription('The state of the input voltage to this power supply.')
envPowerSupplyOutputState = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 2, 3, 1, 4), GeneralState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: envPowerSupplyOutputState.setStatus('current')
if mibBuilder.loadTexts: envPowerSupplyOutputState.setDescription('The status of the output of this power supply. In case there are several output supplies (like +5V, +12V, -12V) this object indicates the aggregate state of all outputs.')
envPowerSupplySerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 2, 3, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: envPowerSupplySerialNumber.setStatus('current')
if mibBuilder.loadTexts: envPowerSupplySerialNumber.setDescription('The serial number of this power supply, if available.')
envPowerSupplyVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 2, 3, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: envPowerSupplyVersion.setStatus('current')
if mibBuilder.loadTexts: envPowerSupplyVersion.setDescription('The version of this power supply, if available.')
envPowerSupplyCurrentState = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 2, 3, 1, 7), GeneralState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: envPowerSupplyCurrentState.setStatus('current')
if mibBuilder.loadTexts: envPowerSupplyCurrentState.setDescription('The state of the current on the input return path of this power supply. Should be within 28A +/-2A.')
envPowerSupply5VoltState = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 2, 3, 1, 8), GeneralState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: envPowerSupply5VoltState.setStatus('current')
if mibBuilder.loadTexts: envPowerSupply5VoltState.setDescription('The state of the +5V output of this power supply. Should be within tolerance of 5.0 +/-0.1VDC.')
envNumberOfFanBanks = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 3, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: envNumberOfFanBanks.setStatus('current')
if mibBuilder.loadTexts: envNumberOfFanBanks.setDescription('The number of fan banks on this ATM switch.')
envFanBanksTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 3, 2), )
if mibBuilder.loadTexts: envFanBanksTable.setStatus('current')
if mibBuilder.loadTexts: envFanBanksTable.setDescription('A table of fan bank information.')
envFanBanksEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 3, 2, 1), ).setIndexNames((0, "Fore-Switch-MIB", "envFanBankIndex"))
if mibBuilder.loadTexts: envFanBanksEntry.setStatus('current')
if mibBuilder.loadTexts: envFanBanksEntry.setDescription('A table entry containing fan bank information.')
envFanBankIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: envFanBankIndex.setStatus('current')
if mibBuilder.loadTexts: envFanBankIndex.setDescription('The index of this fan bank.')
envFanBankState = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 3, 2, 1, 3), GeneralState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: envFanBankState.setStatus('current')
if mibBuilder.loadTexts: envFanBankState.setDescription('The status of the fan bank.')
envFanBankSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 3, 2, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: envFanBankSerialNumber.setStatus('current')
if mibBuilder.loadTexts: envFanBankSerialNumber.setDescription('Serial number of the fan tray.')
envFanBankType = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 3, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: envFanBankType.setStatus('current')
if mibBuilder.loadTexts: envFanBankType.setDescription('The type of fan bank installed.')
envFanBankRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 3, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: envFanBankRevision.setStatus('current')
if mibBuilder.loadTexts: envFanBankRevision.setDescription('The revision of the fan bank, as an ASCII character.')
envNumberOfTempSensors = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 4, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: envNumberOfTempSensors.setStatus('current')
if mibBuilder.loadTexts: envNumberOfTempSensors.setDescription('The number of temperature sensors installed on this ATM switch.')
envTempSensorsTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 4, 2), )
if mibBuilder.loadTexts: envTempSensorsTable.setStatus('current')
if mibBuilder.loadTexts: envTempSensorsTable.setDescription('A table of temperature sensors information.')
envTempSensorsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 4, 2, 1), ).setIndexNames((0, "Fore-Switch-MIB", "envTempSensorIndex"))
if mibBuilder.loadTexts: envTempSensorsEntry.setStatus('current')
if mibBuilder.loadTexts: envTempSensorsEntry.setDescription('A table entry containing temperature sensor information.')
envTempSensorIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 4, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("enclosure", 1), ("power-supply-1", 2), ("power-supply-2", 3), ("power-supply-3", 4), ("power-supply-4", 5), ("power-supply-5", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: envTempSensorIndex.setStatus('current')
if mibBuilder.loadTexts: envTempSensorIndex.setDescription('The index of this temperature sensor. The value of the index provides an indication of the location and function of the temperature sensor. The set of temperature sensors may vary by switch type.')
envTempSensorState = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 4, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("overTemp", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: envTempSensorState.setStatus('current')
if mibBuilder.loadTexts: envTempSensorState.setDescription('The temperature state of this sensor.')
envMaxNumberOfCPUs = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 5, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: envMaxNumberOfCPUs.setStatus('current')
if mibBuilder.loadTexts: envMaxNumberOfCPUs.setDescription('The maximum number of CPUs that can be installed on this ATM switch.')
envNumberOfCPUs = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 5, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: envNumberOfCPUs.setStatus('current')
if mibBuilder.loadTexts: envNumberOfCPUs.setDescription('The number entries in the CPU table.')
envCPUsTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 5, 3), )
if mibBuilder.loadTexts: envCPUsTable.setStatus('current')
if mibBuilder.loadTexts: envCPUsTable.setDescription('A table of CPU information.')
envCPUsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 5, 3, 1), ).setIndexNames((0, "Fore-Switch-MIB", "envCpuBoard"), (0, "Fore-Switch-MIB", "envCpuSlot"))
if mibBuilder.loadTexts: envCPUsEntry.setStatus('current')
if mibBuilder.loadTexts: envCPUsEntry.setDescription('A table entry containing CPU information.')
envCpuBoard = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 5, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: envCpuBoard.setStatus('current')
if mibBuilder.loadTexts: envCpuBoard.setDescription('The board index of this CPU.')
envCpuSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 5, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: envCpuSlot.setStatus('current')
if mibBuilder.loadTexts: envCpuSlot.setDescription('The slot index of this CPU.')
envCpuType = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 5, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("other", 1), ("sun4e", 2), ("sun4c", 3), ("sparc", 4), ("i960ca", 5), ("i960cf", 6), ("i960ha", 7), ("i960hd", 8), ("p55", 9), ("p6", 10), ("cpv5000", 11), ("p266", 12), ("p200", 13)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: envCpuType.setStatus('current')
if mibBuilder.loadTexts: envCpuType.setDescription('The type of this CPU. The i960 processor further can be of three types - ca, cf and ha.')
envCPUState = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 5, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("normal", 1), ("fail", 2), ("standby", 3), ("boot", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: envCPUState.setStatus('current')
if mibBuilder.loadTexts: envCPUState.setDescription('The state of the processor.')
envCpuDRAMSize = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 5, 3, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: envCpuDRAMSize.setStatus('current')
if mibBuilder.loadTexts: envCpuDRAMSize.setDescription('The size of the DRAM in bytes installed on the SCP.')
envCpuRevLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 5, 3, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: envCpuRevLevel.setStatus('current')
if mibBuilder.loadTexts: envCpuRevLevel.setDescription('The revision level of the processor.')
envCpuFlashSize = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 5, 3, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: envCpuFlashSize.setStatus('current')
if mibBuilder.loadTexts: envCpuFlashSize.setDescription('Size of Flash in bytes installed on this SCP board.')
envCpuBoardRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 5, 3, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: envCpuBoardRevision.setStatus('current')
if mibBuilder.loadTexts: envCpuBoardRevision.setDescription('Revision number of this SCP board. A 32-bit number with the most significant 16 bits represent the revison alphabet. For example, 0x20000 represents Rev B, 0xd0000 represents Rev M.')
envCpuPromRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 5, 3, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: envCpuPromRevision.setStatus('current')
if mibBuilder.loadTexts: envCpuPromRevision.setDescription('Revision number of the SCP PROM. Currently only available for boards with i960HA and i960HD processors. A 32-bit number. For example, 0x20000 represents Rev 2.0 and 0x20001 represents Rev 2.1')
envCpuMACAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 5, 3, 1, 10), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: envCpuMACAddress.setStatus('current')
if mibBuilder.loadTexts: envCpuMACAddress.setDescription('MAC address of ethernet chip on the SCP board.')
envCpuSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 5, 3, 1, 11), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: envCpuSerialNumber.setStatus('current')
if mibBuilder.loadTexts: envCpuSerialNumber.setDescription('Serial number of the SCP card. This gives the SCPIM serial number on an ASX-4000.')
envCpuProductPartNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 5, 3, 1, 12), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: envCpuProductPartNumber.setStatus('current')
if mibBuilder.loadTexts: envCpuProductPartNumber.setDescription('Product part number of the SCE. This gives the marketing product part number of RASCAL.')
envCpuCLEI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 5, 3, 1, 13), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: envCpuCLEI.setStatus('current')
if mibBuilder.loadTexts: envCpuCLEI.setDescription('The Common Language Equipment Identification (CLEI) of this SCP.')
envCpuIDESize = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 5, 3, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: envCpuIDESize.setStatus('current')
if mibBuilder.loadTexts: envCpuIDESize.setDescription('Size of IDE disk in bytes installed on this SCP board.')
envMgmtBoardType = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 6, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: envMgmtBoardType.setStatus('current')
if mibBuilder.loadTexts: envMgmtBoardType.setDescription('The board type of the management station or backplane.')
envMgmtBoardRevision = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 6, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: envMgmtBoardRevision.setStatus('current')
if mibBuilder.loadTexts: envMgmtBoardRevision.setDescription('The board revision number of the management station or backplane.')
envMgmtBoardSerialNumber = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 6, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: envMgmtBoardSerialNumber.setStatus('current')
if mibBuilder.loadTexts: envMgmtBoardSerialNumber.setDescription('The serial number of the management station or backplane.')
envFabricAlarmTripTemperature = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 7, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envFabricAlarmTripTemperature.setStatus('current')
if mibBuilder.loadTexts: envFabricAlarmTripTemperature.setDescription('The temperature threshold in degrees C at which a fabric temperature alarm will be raised.')
envFabricAlarmResetTemperature = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 7, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envFabricAlarmResetTemperature.setStatus('current')
if mibBuilder.loadTexts: envFabricAlarmResetTemperature.setDescription('The temperature in degrees C at which a fabric temperature alarm will be cancelled.')
envFabricTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 7, 3), )
if mibBuilder.loadTexts: envFabricTable.setStatus('current')
if mibBuilder.loadTexts: envFabricTable.setDescription('A table of fabric environmental information')
envFabricEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 7, 3, 1), ).setIndexNames((0, "Fore-Switch-MIB", "envFabricIndex"))
if mibBuilder.loadTexts: envFabricEntry.setStatus('current')
if mibBuilder.loadTexts: envFabricEntry.setDescription('A table containing fabric environmental information')
envFabricIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 7, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: envFabricIndex.setStatus('current')
if mibBuilder.loadTexts: envFabricIndex.setDescription('The index of the fabric')
envFabricTemperature = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 7, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: envFabricTemperature.setStatus('current')
if mibBuilder.loadTexts: envFabricTemperature.setDescription('The temperature measured at the fabric, in degrees C')
envFabricTemperatureState = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 4, 7, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("overTemp", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: envFabricTemperatureState.setStatus('current')
if mibBuilder.loadTexts: envFabricTemperatureState.setDescription("The software state of this fabric temperature sensor. This will indicate `normal' until the sensor temperature reaches the current trip threshold. It will then indicate `overTemp' until the temperature reaches the current reset threshold (or until the switch fabric is restarted).")
netmodTimingTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 3, 1, 1), )
if mibBuilder.loadTexts: netmodTimingTable.setStatus('obsolete')
if mibBuilder.loadTexts: netmodTimingTable.setDescription('This table is deprecated as the advanced timing options are removed.')
netmodTimingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 3, 1, 1, 1), ).setIndexNames((0, "Fore-Switch-MIB", "ntBoard"), (0, "Fore-Switch-MIB", "ntModule"))
if mibBuilder.loadTexts: netmodTimingEntry.setStatus('obsolete')
if mibBuilder.loadTexts: netmodTimingEntry.setDescription('A table entry containing network modeul timing information.')
ntBoard = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 3, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntBoard.setStatus('obsolete')
if mibBuilder.loadTexts: ntBoard.setDescription('The index of this board within the ATM switch.')
ntModule = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 3, 1, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntModule.setStatus('obsolete')
if mibBuilder.loadTexts: ntModule.setDescription('The number of this network module within the switch board.')
ntPrimaryRecoveredClock = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 3, 1, 1, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntPrimaryRecoveredClock.setStatus('obsolete')
if mibBuilder.loadTexts: ntPrimaryRecoveredClock.setDescription('The port number on this network module that provides the primary 8KHz reference clock from its received signal.')
ntSecondaryRecoveredClock = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 3, 1, 1, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntSecondaryRecoveredClock.setStatus('obsolete')
if mibBuilder.loadTexts: ntSecondaryRecoveredClock.setDescription('The port number on this network module that provides the secondary 8KHz reference clock from its received signal.')
ntPrimaryExportClock = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 3, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("primaryRecoveredClock", 1), ("crystalClock", 2), ("noClock", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntPrimaryExportClock.setStatus('obsolete')
if mibBuilder.loadTexts: ntPrimaryExportClock.setDescription('The primary 8KHz clock exported by this network module. The exported clock may be used as the network module global clock, which in turn, may be used by all ports that link their transmit clock to the network module global clock. The noClock option is valid only for tp25 (25mb) netmods.')
ntSecondaryExportClock = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 3, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("secondaryRecoveredClock", 1), ("crystalClock", 2), ("noClock", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntSecondaryExportClock.setStatus('obsolete')
if mibBuilder.loadTexts: ntSecondaryExportClock.setDescription('The secondary 8KHz clock exported by this network module. The exported clock may be used as the network module global clock. The secondary exported clock will be used if the primary exported clock is not available. The noClock option is valid only for tp25 (25mb) netmods.')
ntGlobalClock = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 3, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("exportClock", 1), ("importClock", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntGlobalClock.setStatus('obsolete')
if mibBuilder.loadTexts: ntGlobalClock.setDescription('The global 8KHz clock that is available to every port on this network module, when the port links its trasnmit clock to the network module global clock.')
ntExportClockOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 3, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("primaryClock", 1), ("secondaryClock", 2), ("crystalClock", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntExportClockOperStatus.setStatus('obsolete')
if mibBuilder.loadTexts: ntExportClockOperStatus.setDescription('The currently active 8KHz clock configuration. The tertiaryClock(3) is determined by the switch control software if both the primary and secondary clocks are not available.')
ntPrimaryImportClock = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 3, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("netmodAExportClock", 1), ("netmodBExportClock", 2), ("netmodCExportClock", 3), ("netmodDExportClock", 4), ("board1PrimaryClock", 5), ("board2PrimaryClock", 6), ("board3PrimaryClock", 7), ("board4PrimaryClock", 8), ("managementStationClock", 9)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntPrimaryImportClock.setStatus('obsolete')
if mibBuilder.loadTexts: ntPrimaryImportClock.setDescription('The primary 8kHz clock imported by this network module. The imported clock may be used as the network module global clock, which in turn, may be used by all ports that link their transmit clock to the network module global clock.')
ntSecondaryImportClock = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 3, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("netmodAExportClock", 1), ("netmodBExportClock", 2), ("netmodCExportClock", 3), ("netmodDExportClock", 4), ("board1PrimaryClock", 5), ("board2PrimaryClock", 6), ("board3PrimaryClock", 7), ("board4PrimaryClock", 8), ("managementStationClock", 9)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntSecondaryImportClock.setStatus('obsolete')
if mibBuilder.loadTexts: ntSecondaryImportClock.setDescription('The secondary 8kHz clock imported by this network module. The imported clock may be used as the network module global clock. The secondary imported clock will be used if the primary imported clock is not available.')
ntImportClockOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 3, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("primaryClock", 1), ("secondaryClock", 2), ("netmodExportClock", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntImportClockOperStatus.setStatus('obsolete')
if mibBuilder.loadTexts: ntImportClockOperStatus.setDescription('The currently active 8kHz import clock configuration. The tertiaryClock(3) is determined by the switch control software if both the primary and secondary clocks are not available.')
boardTimingTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 3, 2, 1), )
if mibBuilder.loadTexts: boardTimingTable.setStatus('obsolete')
if mibBuilder.loadTexts: boardTimingTable.setDescription('This table is deprecated as the advanced timing options are removed.')
boardTimingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 3, 2, 1, 1), ).setIndexNames((0, "Fore-Switch-MIB", "btBoard"))
if mibBuilder.loadTexts: boardTimingEntry.setStatus('obsolete')
if mibBuilder.loadTexts: boardTimingEntry.setDescription('A table entry containing switch board timing information.')
btBoard = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 3, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: btBoard.setStatus('obsolete')
if mibBuilder.loadTexts: btBoard.setDescription('The index of this board within the ATM switch.')
btPrimaryClock = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 3, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("netmodAExportClock", 1), ("netmodBExportClock", 2), ("netmodCExportClock", 3), ("netmodDExportClock", 4), ("netmodNone", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: btPrimaryClock.setStatus('obsolete')
if mibBuilder.loadTexts: btPrimaryClock.setDescription('The source of the primary 8kHz clock for this board. The clock may be used by each network module in the switch as the network module import clock. The clock may also be used by the management station as the primary or secondary source of the Stratum 3E clock.')
btSecondaryClock = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 3, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("netmodAExportClock", 1), ("netmodBExportClock", 2), ("netmodCExportClock", 3), ("netmodDExportClock", 4), ("netmodNone", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: btSecondaryClock.setStatus('obsolete')
if mibBuilder.loadTexts: btSecondaryClock.setDescription('The source of the secondary 8kHz clock. The clock may be used by the management station as the primary or secondary source of the Stratum 3E clock.')
btPrimaryClockOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 3, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clockUp", 1), ("clockDown", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: btPrimaryClockOperStatus.setStatus('obsolete')
if mibBuilder.loadTexts: btPrimaryClockOperStatus.setDescription('The current state of the 8kHz primary clock.')
btSecondaryClockOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 3, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clockUp", 1), ("clockDown", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: btSecondaryClockOperStatus.setStatus('obsolete')
if mibBuilder.loadTexts: btSecondaryClockOperStatus.setDescription('The current state of the 8kHz secondary clock.')
shmemConfTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 1, 1), )
if mibBuilder.loadTexts: shmemConfTable.setStatus('current')
if mibBuilder.loadTexts: shmemConfTable.setDescription("A table for shared memory network modules configuration. Implementation of this table is mandatory if at least one of the network modules' hardware is based on shared memory. The user should walk this table and select the shared memory configuration that suits his/her needs. The selection is done in the specific network module shared memory configuration entry (netmodShmemTable).")
shmemConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 1, 1, 1), ).setIndexNames((0, "Fore-Switch-MIB", "shmemConfIndex"))
if mibBuilder.loadTexts: shmemConfEntry.setStatus('current')
if mibBuilder.loadTexts: shmemConfEntry.setDescription('A table entry containing shared memory network module configuration information.')
shmemConfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: shmemConfIndex.setStatus('current')
if mibBuilder.loadTexts: shmemConfIndex.setDescription('The index of this shared memory configuration.')
shmemUcastConnections = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 1, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: shmemUcastConnections.setStatus('current')
if mibBuilder.loadTexts: shmemUcastConnections.setDescription('The maximum number of unicast connections that is supported by this shared memory configuration.')
shmemMcastConnections = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 1, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: shmemMcastConnections.setStatus('current')
if mibBuilder.loadTexts: shmemMcastConnections.setDescription('The maximum number of multicast connections that is supported by this shared memory configuration.')
shmemVpiVciLists = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 1, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: shmemVpiVciLists.setStatus('current')
if mibBuilder.loadTexts: shmemVpiVciLists.setDescription('The memory allocated for VPI/VCI lists (which is used for multicast connections) by this shared memory configuration.')
shmemCellsBuffers = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 1, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: shmemCellsBuffers.setStatus('current')
if mibBuilder.loadTexts: shmemCellsBuffers.setDescription('The number of cells buffers that is supported by this shared memory configuration.')
shmemConfName = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 1, 1, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: shmemConfName.setStatus('current')
if mibBuilder.loadTexts: shmemConfName.setDescription('The name of this shared memory configuration.')
shmemMemorySize = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 1, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: shmemMemorySize.setStatus('current')
if mibBuilder.loadTexts: shmemMemorySize.setDescription('The size of this shared memory configuration in units of 48 bit words (x48).')
netmodShmemTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 1, 2), )
if mibBuilder.loadTexts: netmodShmemTable.setStatus('current')
if mibBuilder.loadTexts: netmodShmemTable.setDescription('A table for shared memory network modules configuration. Implementation of this table is mandatory if the network module hardware is based on shared memory.')
netmodShmemEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 1, 2, 1), ).setIndexNames((0, "Fore-Switch-MIB", "nshmemBoard"), (0, "Fore-Switch-MIB", "nshmemModule"))
if mibBuilder.loadTexts: netmodShmemEntry.setStatus('current')
if mibBuilder.loadTexts: netmodShmemEntry.setDescription('A table entry containing shared memory network module configuration information.')
nshmemBoard = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 1, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nshmemBoard.setStatus('current')
if mibBuilder.loadTexts: nshmemBoard.setDescription('The index of this board within the ATM switch.')
nshmemModule = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 1, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nshmemModule.setStatus('current')
if mibBuilder.loadTexts: nshmemModule.setDescription('The number of this network module within the switch board.')
nshmemConfRow = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 1, 2, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nshmemConfRow.setStatus('current')
if mibBuilder.loadTexts: nshmemConfRow.setDescription('This object identify the row in the shared memory configuration table that was selected for this network module.')
nshmemConfSharedMemory = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 1, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nshmemConfSharedMemory.setStatus('current')
if mibBuilder.loadTexts: nshmemConfSharedMemory.setDescription('The amount of memory that was configured for this network module given all the user requirements as specified in the selected shared memory configuration row.')
nshmemCurrentUcastConnections = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 1, 2, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nshmemCurrentUcastConnections.setStatus('current')
if mibBuilder.loadTexts: nshmemCurrentUcastConnections.setDescription('The current number of unicast connections active on this shared memory network module.')
nshmemCurrentMcastConnections = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 1, 2, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nshmemCurrentMcastConnections.setStatus('current')
if mibBuilder.loadTexts: nshmemCurrentMcastConnections.setDescription('The current number of multicast connections active on this shared memory network module.')
nshmemCurrentVpiVciLists = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 1, 2, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nshmemCurrentVpiVciLists.setStatus('current')
if mibBuilder.loadTexts: nshmemCurrentVpiVciLists.setDescription('The current number of VPI/VCI lists active on this shared memory network module.')
nshmemCurrentCellsBuffers = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 1, 2, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nshmemCurrentCellsBuffers.setStatus('current')
if mibBuilder.loadTexts: nshmemCurrentCellsBuffers.setDescription('The current number cells buffers active on this shared memory network module.')
nshmemCurrentSharedMemory = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 1, 2, 1, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nshmemCurrentSharedMemory.setStatus('current')
if mibBuilder.loadTexts: nshmemCurrentSharedMemory.setDescription('The current value of the used shared memory on this network module.')
nshmemConfAal5PacketDrop = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 1, 2, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nshmemConfAal5PacketDrop.setStatus('current')
if mibBuilder.loadTexts: nshmemConfAal5PacketDrop.setDescription('The AAL5 packet drop threshold in percentage of cells. The switch software provides a reasonable default, however, the user may wish to change this value according to the type of traffic and size of packets being transmitted on the network.')
nshmemAssertXACPT = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 1, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clearXACPT", 1), ("assertXACPT", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nshmemAssertXACPT.setStatus('current')
if mibBuilder.loadTexts: nshmemAssertXACPT.setDescription('This variable establishes the setting fo the XACPT bit in the fs200sm main control register (section 3.1). This bit determines whether the signal XACPT is asserted whenever the shared memory is full. XACPT prevents the switch from sending cells to the network module. This bit takes advantage of any buffers on the switch to reduce cell loss, but it should not be used if guaranteed cell delay is being provided to high priority cells.')
nshmemMemorySize = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 1, 2, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nshmemMemorySize.setStatus('current')
if mibBuilder.loadTexts: nshmemMemorySize.setDescription("The size of this Series-C network module's shared memory in units of 48 bit words (x48).")
portShmemConfTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 2, 1), )
if mibBuilder.loadTexts: portShmemConfTable.setStatus('current')
if mibBuilder.loadTexts: portShmemConfTable.setDescription('A table for shared memory network modules configuration that is specified on a port basis. Implementation of this table is mandatory if the network module hardware is based on shared memory.')
portShmemConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 2, 1, 1), ).setIndexNames((0, "Fore-Switch-MIB", "pshmemConfBoard"), (0, "Fore-Switch-MIB", "pshmemConfModule"), (0, "Fore-Switch-MIB", "pshmemConfPort"))
if mibBuilder.loadTexts: portShmemConfEntry.setStatus('current')
if mibBuilder.loadTexts: portShmemConfEntry.setDescription('A table entry containing port configuration information for shared memory network modules.')
pshmemConfBoard = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pshmemConfBoard.setStatus('current')
if mibBuilder.loadTexts: pshmemConfBoard.setDescription('The index of this board within the ATM switch.')
pshmemConfModule = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 2, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pshmemConfModule.setStatus('current')
if mibBuilder.loadTexts: pshmemConfModule.setDescription('The number of this network module within the switch board.')
pshmemConfPort = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 2, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pshmemConfPort.setStatus('current')
if mibBuilder.loadTexts: pshmemConfPort.setDescription('The number of this port within the switch board and network module.')
pshmemMaxCDVforCBR = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 2, 1, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pshmemMaxCDVforCBR.setStatus('current')
if mibBuilder.loadTexts: pshmemMaxCDVforCBR.setDescription('The maximum transmitting CDV (Cell Delay Variation) in microseconds for CBR (Constant Bit Rate) / rtVBR (Real-Time Variable Bit Rate) traffic.')
pshmemMaxCDVforVBR = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 2, 1, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pshmemMaxCDVforVBR.setStatus('current')
if mibBuilder.loadTexts: pshmemMaxCDVforVBR.setDescription('The maximum transmitting CDV (Cell Delay Variation) in microseconds for nrtVBR (Non-Real-Time Variable Bit Rate) traffic.')
pshmemQsizeforABR = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 2, 1, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pshmemQsizeforABR.setStatus('current')
if mibBuilder.loadTexts: pshmemQsizeforABR.setDescription('The dedicated queue size in cells for ABR (Available Bit Rate) traffic.')
pshmemEfciOnABR = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 2, 1, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pshmemEfciOnABR.setStatus('current')
if mibBuilder.loadTexts: pshmemEfciOnABR.setDescription('The treshold on which the EFCI (Explicit Forward Congestion Indication) bit is turned on for ABR (Available Bit Rate) and UBR (Unspecified Bit Rate) traffic.')
pshmemEfciOffABR = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 2, 1, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pshmemEfciOffABR.setStatus('current')
if mibBuilder.loadTexts: pshmemEfciOffABR.setDescription('The treshold on which the EFCI (Explicit Forward Congestion Indication) bit is turned off for ABR (Available Bit Rate) and UBR (Unspecified Bit Rate) traffic.')
pshmemQsizeforCBR = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 2, 1, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pshmemQsizeforCBR.setStatus('current')
if mibBuilder.loadTexts: pshmemQsizeforCBR.setDescription('The dedicated queue size in cells for CBR (Constant Bit Rate) / rtVBR (Real-Time Variable Bit Rate) traffic.')
pshmemQsizeforVBR = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 2, 1, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pshmemQsizeforVBR.setStatus('current')
if mibBuilder.loadTexts: pshmemQsizeforVBR.setDescription('The dedicated queue size in cells for nrtVBR (Non-Real-Time Variable Bit Rate) traffic.')
pshmemClpThreshforCBR = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 2, 1, 1, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pshmemClpThreshforCBR.setStatus('current')
if mibBuilder.loadTexts: pshmemClpThreshforCBR.setDescription('The CLP=1 discard threshold in cells for CBR (Constant Bit Rate) / rtVBR (Real-Time Variable Bit Rate) traffic.')
pshmemClpThreshforVBR = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 2, 1, 1, 12), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pshmemClpThreshforVBR.setStatus('current')
if mibBuilder.loadTexts: pshmemClpThreshforVBR.setDescription('The CLP=1 discard threshold in cells for nrtVBR (Non-Real-Time Variable Bit Rate) traffic.')
pshmemClpThreshforABR = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 2, 1, 1, 13), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pshmemClpThreshforABR.setStatus('current')
if mibBuilder.loadTexts: pshmemClpThreshforABR.setDescription('The CLP=1 discard threshold in cells for ABR (Available Bit Rate) traffic.')
pShmemAtmInterfaceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 2, 1, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pShmemAtmInterfaceIndex.setStatus('current')
if mibBuilder.loadTexts: pShmemAtmInterfaceIndex.setDescription('The Atm interface index correspong to this port. This is also the index of the portTable.')
portShmemTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 2, 2), )
if mibBuilder.loadTexts: portShmemTable.setStatus('current')
if mibBuilder.loadTexts: portShmemTable.setDescription('A table for current state of port on shared memory network modules. Implementation of this table is mandatory if the network module hardware is based on shared memory.')
portShmemEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 2, 2, 1), ).setIndexNames((0, "Fore-Switch-MIB", "pshmemBoard"), (0, "Fore-Switch-MIB", "pshmemModule"), (0, "Fore-Switch-MIB", "pshmemPort"), (0, "Fore-Switch-MIB", "pshmemPriority"))
if mibBuilder.loadTexts: portShmemEntry.setStatus('current')
if mibBuilder.loadTexts: portShmemEntry.setDescription('A table entry containing current port configuration information for shared memory network modules.')
pshmemBoard = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pshmemBoard.setStatus('current')
if mibBuilder.loadTexts: pshmemBoard.setDescription('The index of this board within the ATM switch.')
pshmemModule = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 2, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pshmemModule.setStatus('current')
if mibBuilder.loadTexts: pshmemModule.setDescription('The number of this network module within the switch board.')
pshmemPort = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 2, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pshmemPort.setStatus('current')
if mibBuilder.loadTexts: pshmemPort.setDescription('The number of this port within the switch board and network module.')
pshmemPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("priorityUBR-ABR", 1), ("priorityVBR", 2), ("priorityCBR", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pshmemPriority.setStatus('current')
if mibBuilder.loadTexts: pshmemPriority.setDescription('The traffic type.')
pshmemClpThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 2, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pshmemClpThreshold.setStatus('current')
if mibBuilder.loadTexts: pshmemClpThreshold.setDescription('The threshold level in number of cells in which CLP=1 cells will be dropped.')
pshmemDedicatedQsize = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 2, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pshmemDedicatedQsize.setStatus('current')
if mibBuilder.loadTexts: pshmemDedicatedQsize.setDescription('The dedicated queue size for this type of traffic as was calculated by the switch software. The dedicated queue size is determined by the configured maximum CDV (Cell Delay Variation) for CBR/rtVBR (Constant Bit Rate / Real-Time Variable Bit Rate) and nrtVBR (Non-Real-Time Variable Bit Rate) as well as the configurable queue size for ABR (Available Bit Rate) and UBR (Unspecified Bit Rate) traffic.')
pshmemCurrentQsize = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 2, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pshmemCurrentQsize.setStatus('current')
if mibBuilder.loadTexts: pshmemCurrentQsize.setDescription('The current size of the queue.')
pshmemTxCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 2, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pshmemTxCells.setStatus('current')
if mibBuilder.loadTexts: pshmemTxCells.setDescription('The number of cells that were transmitted for this port and priority queue.')
pshmemLostCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 2, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pshmemLostCells.setStatus('current')
if mibBuilder.loadTexts: pshmemLostCells.setDescription('The total number of cells that were lost for this port and priority queue.')
shmem2ConfTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 3, 1), )
if mibBuilder.loadTexts: shmem2ConfTable.setStatus('current')
if mibBuilder.loadTexts: shmem2ConfTable.setDescription("A table for shared memory network modules configuration. Implementation of this table is mandatory if at least one of the network modules' hardware is based on shared memory. The user should walk this table and select the shared memory configuration that suits his/her needs. The selection is done in the specific network module shared memory configuration entry (netmodShmemTable).")
shmem2ConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 3, 1, 1), ).setIndexNames((0, "Fore-Switch-MIB", "shmem2ConfIndex"))
if mibBuilder.loadTexts: shmem2ConfEntry.setStatus('current')
if mibBuilder.loadTexts: shmem2ConfEntry.setDescription('A table entry containing shared memory network module configuration information.')
shmem2ConfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: shmem2ConfIndex.setStatus('current')
if mibBuilder.loadTexts: shmem2ConfIndex.setDescription('The index of this shared memory configuration.')
shmem2UcastConnections = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 3, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: shmem2UcastConnections.setStatus('current')
if mibBuilder.loadTexts: shmem2UcastConnections.setDescription('The maximum number of unicast connections that is supported by this shared memory configuration.')
shmem2McastConnections = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 3, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: shmem2McastConnections.setStatus('current')
if mibBuilder.loadTexts: shmem2McastConnections.setDescription('The maximum number of multicast connections that is supported by this shared memory configuration.')
shmem2CellsBuffers = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 3, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: shmem2CellsBuffers.setStatus('current')
if mibBuilder.loadTexts: shmem2CellsBuffers.setDescription('The number of cells buffers that is supported by this shared memory configuration.')
shmem2ConfName = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 3, 1, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: shmem2ConfName.setStatus('current')
if mibBuilder.loadTexts: shmem2ConfName.setDescription('The name of this shared memory configuration.')
shmem2Counters = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 3, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: shmem2Counters.setStatus('current')
if mibBuilder.loadTexts: shmem2Counters.setDescription('The number of counters that is supported by this shared memory configuration.')
shmem2CellMemorySize = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 3, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: shmem2CellMemorySize.setStatus('current')
if mibBuilder.loadTexts: shmem2CellMemorySize.setDescription('The size of this shared memory cell RAM configuration in units of 64 bit words (x64).')
shmem2TableMemorySize = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 3, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: shmem2TableMemorySize.setStatus('current')
if mibBuilder.loadTexts: shmem2TableMemorySize.setDescription('The size of this shared memory table RAM configuration in units of 32 bit words (x32).')
shmem2NumPriorities = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 3, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: shmem2NumPriorities.setStatus('current')
if mibBuilder.loadTexts: shmem2NumPriorities.setDescription('The number of priorities that this shared memory configuration supports.')
netmodShmem2Table = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 3, 2), )
if mibBuilder.loadTexts: netmodShmem2Table.setStatus('current')
if mibBuilder.loadTexts: netmodShmem2Table.setDescription('A table for shared memory network modules configuration. Implementation of this table is mandatory if the network module hardware is based on shared memory.')
netmodShmem2Entry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 3, 2, 1), ).setIndexNames((0, "Fore-Switch-MIB", "nShmem2Board"), (0, "Fore-Switch-MIB", "nShmem2Module"))
if mibBuilder.loadTexts: netmodShmem2Entry.setStatus('current')
if mibBuilder.loadTexts: netmodShmem2Entry.setDescription('A table entry containing shared memory network module configuration information.')
nShmem2Board = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nShmem2Board.setStatus('current')
if mibBuilder.loadTexts: nShmem2Board.setDescription('The index of this board within the ATM switch.')
nShmem2Module = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 3, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nShmem2Module.setStatus('current')
if mibBuilder.loadTexts: nShmem2Module.setDescription('The number of this network module within the switch board.')
nShmem2ConfRow = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 3, 2, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nShmem2ConfRow.setStatus('current')
if mibBuilder.loadTexts: nShmem2ConfRow.setDescription('This object identify the row in the shared memory configuration table that was selected for this network module.')
nShmem2ConfSharedMemory = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 3, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nShmem2ConfSharedMemory.setStatus('current')
if mibBuilder.loadTexts: nShmem2ConfSharedMemory.setDescription('The amount of memory that was configured for this network module given all the user requirements as specified in the selected shared memory configuration row.')
nShmem2CurrentUcastConnections = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 3, 2, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nShmem2CurrentUcastConnections.setStatus('current')
if mibBuilder.loadTexts: nShmem2CurrentUcastConnections.setDescription('The current number of unicast connections active on this shared memory network module.')
nShmem2CurrentMcastConnections = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 3, 2, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nShmem2CurrentMcastConnections.setStatus('current')
if mibBuilder.loadTexts: nShmem2CurrentMcastConnections.setDescription('The current number of multicast connections active on this shared memory network module.')
nShmem2CurrentCellsBuffers = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 3, 2, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nShmem2CurrentCellsBuffers.setStatus('current')
if mibBuilder.loadTexts: nShmem2CurrentCellsBuffers.setDescription('The current number cells buffers active on this shared memory network module.')
nShmem2CurrentSharedMemory = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 3, 2, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nShmem2CurrentSharedMemory.setStatus('current')
if mibBuilder.loadTexts: nShmem2CurrentSharedMemory.setDescription('The current value of the used shared memory on this network module.')
nShmem2ConfAal5PacketDrop = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 3, 2, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nShmem2ConfAal5PacketDrop.setStatus('current')
if mibBuilder.loadTexts: nShmem2ConfAal5PacketDrop.setDescription('The AAL5 packet drop threshold in percentage of cells. The switch software provides a reasonable default, however, the user may wish to change this value according to the type of traffic and size of packets being transmitted on the network.')
nShmem2ConfAal5PacketDropforUBR = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 3, 2, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nShmem2ConfAal5PacketDropforUBR.setStatus('current')
if mibBuilder.loadTexts: nShmem2ConfAal5PacketDropforUBR.setDescription('The AAL5 packet drop threshold, in percentage of cells for UBR queue in a four priority configuration or priorityNrt queue in a two priority configuration. The switch software provides a reasonable default. However, the user may wish to change this value according to the type of traffic and size of packets being transmitted on the network.')
nShmem2ConfEfciOn = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 3, 2, 1, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nShmem2ConfEfciOn.setStatus('current')
if mibBuilder.loadTexts: nShmem2ConfEfciOn.setDescription('The threshold on which the EFCI (Explicit Forward Congestion Indication) is enabled for UBR (Unspecified Bit Rate) and ABR (Available Bit Rate) traffic.')
nShmem2ConfEfciOff = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 3, 2, 1, 12), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nShmem2ConfEfciOff.setStatus('current')
if mibBuilder.loadTexts: nShmem2ConfEfciOff.setDescription('The threshold on which the EFCI (Explicit Forward Congestion Indication) is disabled for UBR (Unspecified Bit Rate) and ABR (Available Bit Rate) traffic.')
nShmem2CellMemorySize = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 3, 2, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nShmem2CellMemorySize.setStatus('current')
if mibBuilder.loadTexts: nShmem2CellMemorySize.setDescription('The size of this shared memory cell RAM configuration in units of 64 bit words (x64).')
nShmem2TableMemorySize = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 3, 2, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nShmem2TableMemorySize.setStatus('current')
if mibBuilder.loadTexts: nShmem2TableMemorySize.setDescription('The size of this shared memory table RAM configuration in units of 32 bit words (x32).')
nShmem2NumPriorities = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 3, 2, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nShmem2NumPriorities.setStatus('current')
if mibBuilder.loadTexts: nShmem2NumPriorities.setDescription('The number of priorities that this network module supports.')
nShmem2VBRPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 3, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("priorityRt", 1), ("priorityNrt", 2), ("unSupported", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nShmem2VBRPriority.setStatus('current')
if mibBuilder.loadTexts: nShmem2VBRPriority.setDescription('The queue through which VBR traffic is routed in a two priority configuration (priorityRt or priorityNrt). For a four priority configuration, it is unSupported.')
portShmem2ConfTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 4, 1), )
if mibBuilder.loadTexts: portShmem2ConfTable.setStatus('current')
if mibBuilder.loadTexts: portShmem2ConfTable.setDescription('A table for shared memory network modules configuration that is specified on a port basis. Implementation of this table is mandatory if the network module hardware is based on shared memory.')
portShmem2ConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 4, 1, 1), ).setIndexNames((0, "Fore-Switch-MIB", "pShmem2ConfBoard"), (0, "Fore-Switch-MIB", "pShmem2ConfModule"), (0, "Fore-Switch-MIB", "pShmem2ConfPort"))
if mibBuilder.loadTexts: portShmem2ConfEntry.setStatus('current')
if mibBuilder.loadTexts: portShmem2ConfEntry.setDescription('A table entry containing port configuration information for shared memory network modules.')
pShmem2ConfBoard = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 4, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pShmem2ConfBoard.setStatus('current')
if mibBuilder.loadTexts: pShmem2ConfBoard.setDescription('The index of this board within the ATM switch.')
pShmem2ConfModule = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 4, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pShmem2ConfModule.setStatus('current')
if mibBuilder.loadTexts: pShmem2ConfModule.setDescription('The number of this network module within the switch board.')
pShmem2ConfPort = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 4, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pShmem2ConfPort.setStatus('current')
if mibBuilder.loadTexts: pShmem2ConfPort.setDescription('The number of this port within the switch board and network module.')
pShmem2QsizeforCBR = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 4, 1, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pShmem2QsizeforCBR.setStatus('deprecated')
if mibBuilder.loadTexts: pShmem2QsizeforCBR.setDescription('The dedicated queue size in cells for CBR (Constant Bit Rate) / rtVBR (Real-Time Variable Bit Rate) traffic.')
pShmem2QsizeforVBR = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 4, 1, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pShmem2QsizeforVBR.setStatus('deprecated')
if mibBuilder.loadTexts: pShmem2QsizeforVBR.setDescription('The dedicated queue size in cells for nrtVBR (Non-Real-Time Variable Bit Rate) traffic.')
pShmem2QsizeforABR = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 4, 1, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pShmem2QsizeforABR.setStatus('deprecated')
if mibBuilder.loadTexts: pShmem2QsizeforABR.setDescription('The dedicated queue size in cells for ABR (Available Bit Rate) traffic.')
pShmem2QsizeforUBR = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 4, 1, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pShmem2QsizeforUBR.setStatus('deprecated')
if mibBuilder.loadTexts: pShmem2QsizeforUBR.setDescription('The dedicated queue size in cells for UBR (Unspecified Bit Rate) traffic.')
pShmem2ClpThreshforCBR = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 4, 1, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pShmem2ClpThreshforCBR.setStatus('deprecated')
if mibBuilder.loadTexts: pShmem2ClpThreshforCBR.setDescription('The CLP=1 discard threshold in cells for CBR (Constant Bit Rate) / rtVBR (Real-Time Variable Bit Rate) traffic.')
pShmem2ClpThreshforVBR = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 4, 1, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pShmem2ClpThreshforVBR.setStatus('deprecated')
if mibBuilder.loadTexts: pShmem2ClpThreshforVBR.setDescription('The CLP=1 discard threshold in cells for nrtVBR (Non-Real-Time Variable Bit Rate) traffic.')
pShmem2ClpThreshforABR = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 4, 1, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pShmem2ClpThreshforABR.setStatus('deprecated')
if mibBuilder.loadTexts: pShmem2ClpThreshforABR.setDescription('The CLP=1 discard threshold in cells for ABR (Available Bit Rate) traffic.')
pShmem2ClpThreshforUBR = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 4, 1, 1, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pShmem2ClpThreshforUBR.setStatus('deprecated')
if mibBuilder.loadTexts: pShmem2ClpThreshforUBR.setDescription('The CLP=1 discard threshold in cells for UBR (Unspecified Bit Rate) traffic.')
pShmem2AtmInterfaceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 4, 1, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pShmem2AtmInterfaceIndex.setStatus('current')
if mibBuilder.loadTexts: pShmem2AtmInterfaceIndex.setDescription('The Atm interface index correspong to this port. This is also the index of the portTable.')
portPriorityShmem2ConfTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 4, 3), )
if mibBuilder.loadTexts: portPriorityShmem2ConfTable.setStatus('current')
if mibBuilder.loadTexts: portPriorityShmem2ConfTable.setDescription('A table for shared memory network modules configuration that is specified on a port-priority basis. Implementation of this table is mandatory if the network module hardware is based on shared memory.')
portPriorityShmem2ConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 4, 3, 1), ).setIndexNames((0, "Fore-Switch-MIB", "ppShmem2ConfBoard"), (0, "Fore-Switch-MIB", "ppShmem2ConfModule"), (0, "Fore-Switch-MIB", "ppShmem2ConfPort"), (0, "Fore-Switch-MIB", "ppShmem2ConfPriority"))
if mibBuilder.loadTexts: portPriorityShmem2ConfEntry.setStatus('current')
if mibBuilder.loadTexts: portPriorityShmem2ConfEntry.setDescription('A table entry containing port-priority configuration information for shared memory network modules.')
ppShmem2ConfBoard = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 4, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ppShmem2ConfBoard.setStatus('current')
if mibBuilder.loadTexts: ppShmem2ConfBoard.setDescription('The index of this board within the ATM switch.')
ppShmem2ConfModule = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 4, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ppShmem2ConfModule.setStatus('current')
if mibBuilder.loadTexts: ppShmem2ConfModule.setDescription('The number of this network module within the switch board.')
ppShmem2ConfPort = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 4, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ppShmem2ConfPort.setStatus('current')
if mibBuilder.loadTexts: ppShmem2ConfPort.setDescription('The number of this port within the switch board and the network module.')
ppShmem2ConfPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 4, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("priorityABR", 1), ("priorityVBR", 2), ("priorityCBR", 3), ("priorityUBR", 4), ("priorityRt", 5), ("priorityNrt", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ppShmem2ConfPriority.setStatus('current')
if mibBuilder.loadTexts: ppShmem2ConfPriority.setDescription('The priority queue in the shared memory network module.')
ppShmem2Qsize = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 4, 3, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ppShmem2Qsize.setStatus('current')
if mibBuilder.loadTexts: ppShmem2Qsize.setDescription('The dedicated queue size for this port-priority combination, in number of cells.')
ppShmem2ClpThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 4, 3, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ppShmem2ClpThreshold.setStatus('current')
if mibBuilder.loadTexts: ppShmem2ClpThreshold.setDescription('CLP=1 threshold of this port-priority combination, in number of cells.')
portShmem2Table = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 4, 2), )
if mibBuilder.loadTexts: portShmem2Table.setStatus('current')
if mibBuilder.loadTexts: portShmem2Table.setDescription('A table for current state of port on shared memory network modules. Implementation of this table is mandatory if the network module hardware is based on shared memory.')
portShmem2Entry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 4, 2, 1), ).setIndexNames((0, "Fore-Switch-MIB", "pShmem2Board"), (0, "Fore-Switch-MIB", "pShmem2Module"), (0, "Fore-Switch-MIB", "pShmem2Port"), (0, "Fore-Switch-MIB", "pShmem2Priority"))
if mibBuilder.loadTexts: portShmem2Entry.setStatus('current')
if mibBuilder.loadTexts: portShmem2Entry.setDescription('A table entry containing current port configuration information for shared memory network modules.')
pShmem2Board = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 4, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pShmem2Board.setStatus('current')
if mibBuilder.loadTexts: pShmem2Board.setDescription('The index of this board within the ATM switch.')
pShmem2Module = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 4, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pShmem2Module.setStatus('current')
if mibBuilder.loadTexts: pShmem2Module.setDescription('The number of this network module within the switch board.')
pShmem2Port = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 4, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pShmem2Port.setStatus('current')
if mibBuilder.loadTexts: pShmem2Port.setDescription('The number of this port within the switch board and network module.')
pShmem2Priority = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 4, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("priorityABR", 1), ("priorityVBR", 2), ("priorityCBR", 3), ("priorityUBR", 4), ("priorityRt", 5), ("priorityNrt", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pShmem2Priority.setStatus('current')
if mibBuilder.loadTexts: pShmem2Priority.setDescription('The priority queue in the shared memory network module.')
pShmem2ClpThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 4, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pShmem2ClpThreshold.setStatus('current')
if mibBuilder.loadTexts: pShmem2ClpThreshold.setDescription('The threshold level in number of cells in which CLP=1 cells will be dropped.')
pShmem2DedicatedQsize = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 4, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pShmem2DedicatedQsize.setStatus('current')
if mibBuilder.loadTexts: pShmem2DedicatedQsize.setDescription('The dedicated queue size for this type of traffic as was calculated by the switch software. The dedicated queue size is determined by the configured maximum CDV (Cell Delay Variation) for CBR/rtVBR (Constant Bit Rate / Real-Time Variable Bit Rate) and nrtVBR (Non-Real-Time Variable Bit Rate) as well as the configurable queue size for ABR (Available Bit Rate) and UBR (Unspecified Bit Rate) traffic.')
pShmem2CurrentQsize = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 4, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pShmem2CurrentQsize.setStatus('current')
if mibBuilder.loadTexts: pShmem2CurrentQsize.setDescription('The current size of the queue.')
pShmem2TxCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 4, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pShmem2TxCells.setStatus('current')
if mibBuilder.loadTexts: pShmem2TxCells.setDescription('The number of cells that were transmitted for this port and priority queue.')
pShmem2LostCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 4, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pShmem2LostCells.setStatus('current')
if mibBuilder.loadTexts: pShmem2LostCells.setDescription('The total number of cells that were lost for this port and priority queue.')
pShmem2IntentionalLostCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 4, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pShmem2IntentionalLostCells.setStatus('current')
if mibBuilder.loadTexts: pShmem2IntentionalLostCells.setDescription('The number of cells that were lost for this port and priority queue due to EPD (Early Packet Discard) or PPD (Partial Packet Discard).')
pShmem2UnintentionalLostCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 4, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pShmem2UnintentionalLostCells.setStatus('current')
if mibBuilder.loadTexts: pShmem2UnintentionalLostCells.setDescription('The number of cells that were lost for this port and priority queue due to output memory shortages or the CLP (Cell Loss Priority) threshold.')
channelShmem2Table = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 5, 1), )
if mibBuilder.loadTexts: channelShmem2Table.setStatus('current')
if mibBuilder.loadTexts: channelShmem2Table.setDescription('A table of information about the channels through this shared memory network module.')
channelShmem2Entry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 5, 1, 1), ).setIndexNames((0, "Fore-Switch-MIB", "vcShmem2OutputPort"), (0, "Fore-Switch-MIB", "vcShmem2OutputVPI"), (0, "Fore-Switch-MIB", "vcShmem2OutputVCI"))
if mibBuilder.loadTexts: channelShmem2Entry.setStatus('current')
if mibBuilder.loadTexts: channelShmem2Entry.setDescription('A table entry containing channel shmem2 information.')
vcShmem2OutputPort = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 5, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcShmem2OutputPort.setStatus('current')
if mibBuilder.loadTexts: vcShmem2OutputPort.setDescription('The value of this object identifies the output port of this channel and is the same as the opathPort, and portNumber.')
vcShmem2OutputVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 5, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcShmem2OutputVPI.setStatus('current')
if mibBuilder.loadTexts: vcShmem2OutputVPI.setDescription('The value of this object identifies the output VPI (Virtual Path Identifier) of this channel and is the same as the opathVPI.')
vcShmem2OutputVCI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 5, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcShmem2OutputVCI.setStatus('current')
if mibBuilder.loadTexts: vcShmem2OutputVCI.setDescription('The output VCI (Virtual Channel Identifier) of this channel.')
vcShmem2TotalLostCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 5, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcShmem2TotalLostCells.setStatus('current')
if mibBuilder.loadTexts: vcShmem2TotalLostCells.setDescription('The number of cells on this channel that were dropped by the output network module.')
vcShmem2IntentionalLostCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 5, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcShmem2IntentionalLostCells.setStatus('current')
if mibBuilder.loadTexts: vcShmem2IntentionalLostCells.setDescription('The number of cells on this channel that were dropped due to EPD (Early Packet Discard) or PPD (Partial Packet Discard).')
vcShmem2UnintentionalLostCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 5, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcShmem2UnintentionalLostCells.setStatus('current')
if mibBuilder.loadTexts: vcShmem2UnintentionalLostCells.setDescription('The number of cells on this channel that were dropped due to output memory shortages or the CLP (Cell Loss Priority) threshold.')
vcShmem2TransmittedCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 5, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcShmem2TransmittedCells.setStatus('current')
if mibBuilder.loadTexts: vcShmem2TransmittedCells.setDescription('The number of cells on this channel that were transmitted.')
pathShmem2Table = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 5, 2), )
if mibBuilder.loadTexts: pathShmem2Table.setStatus('current')
if mibBuilder.loadTexts: pathShmem2Table.setDescription('A table of information about the paths through this shared memory network module.')
pathShmem2Entry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 5, 2, 1), ).setIndexNames((0, "Fore-Switch-MIB", "vpShmem2OutputPort"), (0, "Fore-Switch-MIB", "vpShmem2OutputVPI"))
if mibBuilder.loadTexts: pathShmem2Entry.setStatus('current')
if mibBuilder.loadTexts: pathShmem2Entry.setDescription('A table entry containing path shmem2 information.')
vpShmem2OutputPort = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 5, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vpShmem2OutputPort.setStatus('current')
if mibBuilder.loadTexts: vpShmem2OutputPort.setDescription('The value of this object identifies the output port of this path and is the same as the portNumber.')
vpShmem2OutputVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 5, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vpShmem2OutputVPI.setStatus('current')
if mibBuilder.loadTexts: vpShmem2OutputVPI.setDescription('The output VPI (Virtual Path Identifier) of this path.')
vpShmem2TotalLostCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 5, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vpShmem2TotalLostCells.setStatus('current')
if mibBuilder.loadTexts: vpShmem2TotalLostCells.setDescription('The number of cells on this path that were dropped by the output network module.')
vpShmem2IntentionalLostCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 5, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vpShmem2IntentionalLostCells.setStatus('current')
if mibBuilder.loadTexts: vpShmem2IntentionalLostCells.setDescription('The number of cells on this path that were dropped due to EPD (Early Packet Discard) or PPD (Partial Packet Discard).')
vpShmem2UnintentionalLostCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 5, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vpShmem2UnintentionalLostCells.setStatus('current')
if mibBuilder.loadTexts: vpShmem2UnintentionalLostCells.setDescription('The number of cells on this path that were dropped due to output memory shortages or the CLP (Cell Loss Priority) threshold.')
vpShmem2TransmittedCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 5, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vpShmem2TransmittedCells.setStatus('current')
if mibBuilder.loadTexts: vpShmem2TransmittedCells.setDescription('The number of cells on this path that were transmitted.')
netmodShmem2CustomBCSTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 3, 3), )
if mibBuilder.loadTexts: netmodShmem2CustomBCSTable.setStatus('current')
if mibBuilder.loadTexts: netmodShmem2CustomBCSTable.setDescription('A table for shared memory custom BCS mappings')
netmodShmem2CustomBCSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 3, 3, 1), ).setIndexNames((0, "Fore-Switch-MIB", "nShmem2CustomBCSBoard"), (0, "Fore-Switch-MIB", "nShmem2CustomBCSModule"), (0, "Fore-Switch-MIB", "nShmem2CustomBCSValue"))
if mibBuilder.loadTexts: netmodShmem2CustomBCSEntry.setStatus('current')
if mibBuilder.loadTexts: netmodShmem2CustomBCSEntry.setDescription('A table entry containing shared memory custom BCS mappings')
nShmem2CustomBCSBoard = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 3, 3, 1, 1), Integer32())
if mibBuilder.loadTexts: nShmem2CustomBCSBoard.setStatus('current')
if mibBuilder.loadTexts: nShmem2CustomBCSBoard.setDescription('The index of this board within the ATM switch.')
nShmem2CustomBCSModule = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 3, 3, 1, 2), Integer32())
if mibBuilder.loadTexts: nShmem2CustomBCSModule.setStatus('current')
if mibBuilder.loadTexts: nShmem2CustomBCSModule.setDescription('The number of this network module within the switch board.')
nShmem2CustomBCSValue = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 3, 3, 1, 3), Integer32())
if mibBuilder.loadTexts: nShmem2CustomBCSValue.setStatus('current')
if mibBuilder.loadTexts: nShmem2CustomBCSValue.setDescription('The value of this BCS')
nShmem2CustomBCSWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 3, 3, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nShmem2CustomBCSWeight.setStatus('current')
if mibBuilder.loadTexts: nShmem2CustomBCSWeight.setDescription('The weight assigned to this BCS')
nShmem2CustomBCSRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 3, 3, 1, 5), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nShmem2CustomBCSRowStatus.setStatus('current')
if mibBuilder.loadTexts: nShmem2CustomBCSRowStatus.setDescription('Administrative status of this entry')
shmem3ConfTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 6, 1), )
if mibBuilder.loadTexts: shmem3ConfTable.setStatus('current')
if mibBuilder.loadTexts: shmem3ConfTable.setDescription("A table for shared memory network modules configuration. Implementation of this table is mandatory if at least one of the network modules' hardware is based on shared memory. The user should walk this table and select the shared memory configuration that suits his/her needs. The selection is done in the specific network module shared memory configuration entry (netmodShmemTable).")
shmem3ConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 6, 1, 1), ).setIndexNames((0, "Fore-Switch-MIB", "shmem3ConfIndex"))
if mibBuilder.loadTexts: shmem3ConfEntry.setStatus('current')
if mibBuilder.loadTexts: shmem3ConfEntry.setDescription('A table entry containing shared memory network module configuration information.')
shmem3ConfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 6, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: shmem3ConfIndex.setStatus('current')
if mibBuilder.loadTexts: shmem3ConfIndex.setDescription('The index of this shared memory configuration.')
shmem3UcastConnections = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 6, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: shmem3UcastConnections.setStatus('current')
if mibBuilder.loadTexts: shmem3UcastConnections.setDescription('The maximum number of unicast connections that is supported by this shared memory configuration.')
shmem3McastConnections = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 6, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: shmem3McastConnections.setStatus('current')
if mibBuilder.loadTexts: shmem3McastConnections.setDescription('The maximum number of multicast connections that is supported by this shared memory configuration.')
shmem3VpiVciLists = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 6, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: shmem3VpiVciLists.setStatus('current')
if mibBuilder.loadTexts: shmem3VpiVciLists.setDescription('The memory allocated for VPI/VCI lists (which is used for multicast connections) by this shared memory configuration.')
shmem3CellsBuffers = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 6, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: shmem3CellsBuffers.setStatus('current')
if mibBuilder.loadTexts: shmem3CellsBuffers.setDescription('The number of cells buffers that is supported by this shared memory configuration.')
shmem3ConfName = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 6, 1, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: shmem3ConfName.setStatus('current')
if mibBuilder.loadTexts: shmem3ConfName.setDescription('The name of this shared memory configuration.')
shmem3Counters = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 6, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: shmem3Counters.setStatus('current')
if mibBuilder.loadTexts: shmem3Counters.setDescription('The number of counters that is supported by this shared memory configuration.')
shmem3CellMemorySize = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 6, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: shmem3CellMemorySize.setStatus('current')
if mibBuilder.loadTexts: shmem3CellMemorySize.setDescription('The size of this shared memory cell RAM configuration.')
shmem3TableMemorySize = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 6, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: shmem3TableMemorySize.setStatus('current')
if mibBuilder.loadTexts: shmem3TableMemorySize.setDescription('The size of this shared memory table RAM configuration.')
netmodShmem3Table = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 6, 2), )
if mibBuilder.loadTexts: netmodShmem3Table.setStatus('current')
if mibBuilder.loadTexts: netmodShmem3Table.setDescription('A table for shared memory network modules configuration. Implementation of this table is mandatory if the network module hardware is based on shared memory.')
netmodShmem3Entry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 6, 2, 1), ).setIndexNames((0, "Fore-Switch-MIB", "nShmem3Board"), (0, "Fore-Switch-MIB", "nShmem3Module"))
if mibBuilder.loadTexts: netmodShmem3Entry.setStatus('current')
if mibBuilder.loadTexts: netmodShmem3Entry.setDescription('A table entry containing shared memory network module configuration information.')
nShmem3Board = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 6, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nShmem3Board.setStatus('current')
if mibBuilder.loadTexts: nShmem3Board.setDescription('The index of this board within the ATM switch.')
nShmem3Module = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 6, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nShmem3Module.setStatus('current')
if mibBuilder.loadTexts: nShmem3Module.setDescription('The number of this network module within the switch board.')
nShmem3ConfRow = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 6, 2, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nShmem3ConfRow.setStatus('current')
if mibBuilder.loadTexts: nShmem3ConfRow.setDescription('This object identify the row in the shared memory configuration table that was selected for this network module.')
nShmem3ConfSharedMemory = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 6, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nShmem3ConfSharedMemory.setStatus('current')
if mibBuilder.loadTexts: nShmem3ConfSharedMemory.setDescription('The amount of memory that was configured for this network module given all the user requirements as specified in the selected shared memory configuration row.')
nShmem3CurrentUcastConnections = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 6, 2, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nShmem3CurrentUcastConnections.setStatus('current')
if mibBuilder.loadTexts: nShmem3CurrentUcastConnections.setDescription('The current number of unicast connections active on this shared memory network module.')
nShmem3CurrentMcastConnections = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 6, 2, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nShmem3CurrentMcastConnections.setStatus('current')
if mibBuilder.loadTexts: nShmem3CurrentMcastConnections.setDescription('The current number of multicast connections active on this shared memory network module.')
nShmem3CurrentVpiVciLists = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 6, 2, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nShmem3CurrentVpiVciLists.setStatus('current')
if mibBuilder.loadTexts: nShmem3CurrentVpiVciLists.setDescription('The current number of VPI/VCI lists active on this shared memory network module.')
nShmem3CurrentCellsBuffers = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 6, 2, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nShmem3CurrentCellsBuffers.setStatus('current')
if mibBuilder.loadTexts: nShmem3CurrentCellsBuffers.setDescription('The current number cells buffers active on this shared memory network module.')
nShmem3ConfAal5PacketDrop = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 6, 2, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nShmem3ConfAal5PacketDrop.setStatus('current')
if mibBuilder.loadTexts: nShmem3ConfAal5PacketDrop.setDescription('The AAL5 packet drop threshold in number of cells. The switch software provides a reasonable default, however, the user may wish to change this value according to the type of traffic and size of packets being transmitted on the network. Must be between 0 and 32767')
nShmem3ConfAal5PacketDropforUBR = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 6, 2, 1, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nShmem3ConfAal5PacketDropforUBR.setStatus('current')
if mibBuilder.loadTexts: nShmem3ConfAal5PacketDropforUBR.setDescription('The AAL5 packet drop threshold for UBR traffic in percentage of cells. The switch software provides a reasonable default, however, the user may wish to change this value according to the type of traffic and size of packets being transmitted on the network. Must be between 0 and 32767')
nShmem3ConfEfciOn = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 6, 2, 1, 12), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nShmem3ConfEfciOn.setStatus('current')
if mibBuilder.loadTexts: nShmem3ConfEfciOn.setDescription('The threshold on which the EFCI (Explicit Forward Congestion Indication) is enabled for UBR (Unspecified Bit Rate) and ABR (Available Bit Rate) traffic. Must be a multiple of 32, greater than or equal to EFCI-off threshold, and less than or equal to 32736.')
nShmem3ConfEfciOff = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 6, 2, 1, 13), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nShmem3ConfEfciOff.setStatus('current')
if mibBuilder.loadTexts: nShmem3ConfEfciOff.setDescription('The threshold on which the EFCI (Explicit Forward Congestion Indication) is disabled for UBR (Unspecified Bit Rate) and ABR (Available Bit Rate) traffic. Must be a multiple of 32, greater than or equal to 32, and less than or equal to EFCI-on threshold.')
nShmem3CellMemorySize = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 6, 2, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nShmem3CellMemorySize.setStatus('current')
if mibBuilder.loadTexts: nShmem3CellMemorySize.setDescription('The physical size of this shared memory cell RAM configuration.')
nShmem3TableMemorySize = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 6, 2, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nShmem3TableMemorySize.setStatus('current')
if mibBuilder.loadTexts: nShmem3TableMemorySize.setDescription('The physical size of this shared memory table RAM configuration.')
nShmem3ConfCountPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 6, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nShmem3ConfCountPackets.setStatus('current')
if mibBuilder.loadTexts: nShmem3ConfCountPackets.setDescription('Setting this variable to enable(1) causes the network module to count the number of AAL5 packets.')
nShmem3ConfAltCLP1Threshold = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 6, 2, 1, 17), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nShmem3ConfAltCLP1Threshold.setStatus('current')
if mibBuilder.loadTexts: nShmem3ConfAltCLP1Threshold.setDescription('Alternate CLP=1 threshold for nrt-VBR service class. Must be a multiple of 16, greater than or equal to 0, and less than AltCLP01 threshold.')
nShmem3ConfAltCLP01Threshold = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 6, 2, 1, 18), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nShmem3ConfAltCLP01Threshold.setStatus('current')
if mibBuilder.loadTexts: nShmem3ConfAltCLP01Threshold.setDescription('Alternate CLP=0+1 threshold for nrt-VBR service class. Must be a multiple of 16, greater than AltCLP1 threshold and less than or equal to 4080.')
nShmem3ConfVcCLP1ForCBR = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 6, 2, 1, 19), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nShmem3ConfVcCLP1ForCBR.setStatus('current')
if mibBuilder.loadTexts: nShmem3ConfVcCLP1ForCBR.setDescription('Per class CLP=1 threshold for CBR/rtVBR service class. Must be a multiple of 16, greater than or equal to 0, and less than VcCLP01ForCBR threshold.')
nShmem3ConfVcCLP01ForCBR = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 6, 2, 1, 20), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nShmem3ConfVcCLP01ForCBR.setStatus('current')
if mibBuilder.loadTexts: nShmem3ConfVcCLP01ForCBR.setDescription('Per class CLP=0+1 threshold for CBR/rtVBR service class. Must be a multiple of 16, greater than VcCLP1ForCBR threshold, and less than or equal to 4080.')
nShmem3ConfVcCLP1ForVBR = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 6, 2, 1, 21), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nShmem3ConfVcCLP1ForVBR.setStatus('current')
if mibBuilder.loadTexts: nShmem3ConfVcCLP1ForVBR.setDescription('Per class CLP=1 threshold for nrt-VBR service class. Must be a multiple of 16, greater than or equal to 0, and less than VcCLP01ForVBR threshold.')
nShmem3ConfVcCLP01ForVBR = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 6, 2, 1, 22), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nShmem3ConfVcCLP01ForVBR.setStatus('current')
if mibBuilder.loadTexts: nShmem3ConfVcCLP01ForVBR.setDescription('Per class CLP=0+1 threshold for nrt-VBR service class. Must be a multiple of 16, greater than VcCLP1ForVBR threshold, and less than or equal to 4080.')
nShmem3ConfVcCLP1ForABR = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 6, 2, 1, 23), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nShmem3ConfVcCLP1ForABR.setStatus('current')
if mibBuilder.loadTexts: nShmem3ConfVcCLP1ForABR.setDescription('Per class CLP=1 threshold for ABR service class. Must be a multiple of 16, greater than or equal to 0, and less than VcCLP01ForABR threshold.')
nShmem3ConfVcCLP01ForABR = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 6, 2, 1, 24), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nShmem3ConfVcCLP01ForABR.setStatus('current')
if mibBuilder.loadTexts: nShmem3ConfVcCLP01ForABR.setDescription('Per class CLP=0+1 threshold for ABR service class. Must be a multiple of 16, greater than VcCLP1ForABR threshold, and less than or equal to 4080.')
nShmem3ConfVcCLP1ForUBR = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 6, 2, 1, 25), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nShmem3ConfVcCLP1ForUBR.setStatus('current')
if mibBuilder.loadTexts: nShmem3ConfVcCLP1ForUBR.setDescription('Per class CLP=1 threshold for UBR service class. Must be a multiple of 16, greater than or equal to 0, and less than VcCLP01ForUBR threshold.')
nShmem3ConfVcCLP01ForUBR = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 6, 2, 1, 26), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nShmem3ConfVcCLP01ForUBR.setStatus('current')
if mibBuilder.loadTexts: nShmem3ConfVcCLP01ForUBR.setDescription('Per class CLP=0+1 threshold for UBR service class. Must be a multiple of 16, greater than VcCLP1ForUBR threshold, and less than or equal to 4080.')
portShmem3ConfTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 7, 1), )
if mibBuilder.loadTexts: portShmem3ConfTable.setStatus('current')
if mibBuilder.loadTexts: portShmem3ConfTable.setDescription('A table for shared memory network modules configuration that is specified on a port basis. Implementation of this table is mandatory if the network module hardware is based on shared memory.')
portShmem3ConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 7, 1, 1), ).setIndexNames((0, "Fore-Switch-MIB", "pShmem3ConfBoard"), (0, "Fore-Switch-MIB", "pShmem3ConfModule"), (0, "Fore-Switch-MIB", "pShmem3ConfPort"))
if mibBuilder.loadTexts: portShmem3ConfEntry.setStatus('current')
if mibBuilder.loadTexts: portShmem3ConfEntry.setDescription('A table entry containing port configuration information for shared memory network modules.')
pShmem3ConfBoard = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 7, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pShmem3ConfBoard.setStatus('current')
if mibBuilder.loadTexts: pShmem3ConfBoard.setDescription('The index of this board within the ATM switch.')
pShmem3ConfModule = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 7, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pShmem3ConfModule.setStatus('current')
if mibBuilder.loadTexts: pShmem3ConfModule.setDescription('The number of this network module within the switch board.')
pShmem3ConfPort = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 7, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pShmem3ConfPort.setStatus('current')
if mibBuilder.loadTexts: pShmem3ConfPort.setDescription('The number of this port within the switch board and network module.')
pShmem3QsizeforCBR = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 7, 1, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pShmem3QsizeforCBR.setStatus('current')
if mibBuilder.loadTexts: pShmem3QsizeforCBR.setDescription('The dedicated queue size in cells for CBR (Constant Bit Rate) / rtVBR (Real-Time Variable Bit Rate) traffic.')
pShmem3QsizeforVBR = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 7, 1, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pShmem3QsizeforVBR.setStatus('current')
if mibBuilder.loadTexts: pShmem3QsizeforVBR.setDescription('The dedicated queue size in cells for nrtVBR (Non-Real-Time Variable Bit Rate) traffic.')
pShmem3QsizeforABR = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 7, 1, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pShmem3QsizeforABR.setStatus('current')
if mibBuilder.loadTexts: pShmem3QsizeforABR.setDescription('The dedicated queue size in cells for ABR (Available Bit Rate) traffic.')
pShmem3QsizeforUBR = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 7, 1, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pShmem3QsizeforUBR.setStatus('current')
if mibBuilder.loadTexts: pShmem3QsizeforUBR.setDescription('The dedicated queue size in cells for UBR (Unspecified Bit Rate) traffic.')
pShmem3Clp01ThreshforCBR = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 7, 1, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pShmem3Clp01ThreshforCBR.setStatus('current')
if mibBuilder.loadTexts: pShmem3Clp01ThreshforCBR.setDescription('The CLP=0+1 discard threshold in cells for CBR (Constant Bit Rate) / rtVBR (Real-Time Variable Bit Rate) traffic.')
pShmem3Clp1ThreshforCBR = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 7, 1, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pShmem3Clp1ThreshforCBR.setStatus('current')
if mibBuilder.loadTexts: pShmem3Clp1ThreshforCBR.setDescription('The CLP=1 discard threshold in cells for CBR (Constant Bit Rate) / rtVBR (Real-Time Variable Bit Rate) traffic.')
pShmem3Clp01ThreshforVBR = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 7, 1, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pShmem3Clp01ThreshforVBR.setStatus('current')
if mibBuilder.loadTexts: pShmem3Clp01ThreshforVBR.setDescription('The CLP=0+1 discard threshold in cells for nrtVBR (Variable Bit Rate) traffic.')
pShmem3Clp1ThreshforVBR = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 7, 1, 1, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pShmem3Clp1ThreshforVBR.setStatus('current')
if mibBuilder.loadTexts: pShmem3Clp1ThreshforVBR.setDescription('The CLP=1 discard threshold in cells for nrtVBR (Variable Bit Rate) traffic.')
pShmem3Clp01ThreshforABR = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 7, 1, 1, 12), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pShmem3Clp01ThreshforABR.setStatus('current')
if mibBuilder.loadTexts: pShmem3Clp01ThreshforABR.setDescription('The CLP=0+1 discard threshold in cells for ABR (Available Bit Rate) traffic.')
pShmem3Clp1ThreshforABR = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 7, 1, 1, 13), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pShmem3Clp1ThreshforABR.setStatus('current')
if mibBuilder.loadTexts: pShmem3Clp1ThreshforABR.setDescription('The CLP=1 discard threshold in cells for ABR (Available Bit Rate) traffic.')
pShmem3Clp01ThreshforUBR = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 7, 1, 1, 14), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pShmem3Clp01ThreshforUBR.setStatus('current')
if mibBuilder.loadTexts: pShmem3Clp01ThreshforUBR.setDescription('The CLP=0+1 discard threshold in cells for UBR (Unspecified Bit Rate) traffic.')
pShmem3Clp1ThreshforUBR = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 7, 1, 1, 15), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pShmem3Clp1ThreshforUBR.setStatus('current')
if mibBuilder.loadTexts: pShmem3Clp1ThreshforUBR.setDescription('The CLP=1 discard threshold in cells for UBR (Unspecified Bit Rate) traffic.')
pShmem3RateLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 7, 1, 1, 16), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pShmem3RateLimit.setStatus('current')
if mibBuilder.loadTexts: pShmem3RateLimit.setDescription('The number of cells/second to limit this port. This in effect, sets a new logical line rate for this network module. If set to 0, rate-limiting is disabled. (i.e. full bandwidth is returned to the port).')
pShmem3ConfSVCSchedulingCBR = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 7, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("roundrobin", 2), ("smoothed", 3), ("guaranteed", 4))).clone('roundrobin')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pShmem3ConfSVCSchedulingCBR.setStatus('deprecated')
if mibBuilder.loadTexts: pShmem3ConfSVCSchedulingCBR.setDescription("This variable defines the scheduling discipline that is going to be used to service all CBR SVC connections that are output across this Series-D port. roundrobin: On Series-D netmod, this means that all CBR SVC's will be served only by one of the two round robin queues. smoothed: On Series-D netmod, this means that all CBR SVC's will be served by the rate controller. guaranteed: On Series-D netmod, this means that all CBR SVC's will be served by both the rate controller and the round robin queues.")
pShmem3ConfPVCSchedulingCBR = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 7, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("perupc", 1), ("roundrobin", 2), ("smoothed", 3), ("guaranteed", 4))).clone('roundrobin')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pShmem3ConfPVCSchedulingCBR.setStatus('deprecated')
if mibBuilder.loadTexts: pShmem3ConfPVCSchedulingCBR.setDescription("This variable defines the scheduling discipline that is going to be used to service all CBR PVC connections that are output across this port. Series-D netmods support all three scheduling modes. perupc: This means that each individual CBR PVC will be scheduled based on the discipline associated with the UPC contract used to open the connection. roundrobin: This means that each individual CBR PVC will served only by the rate controller. smoothed: On Series-D netmod, this means that all CBR PVC's will be served only by the rate controller. guaranteed: This means that all CBR PVC's will be served by both the rate controller and the round robin queues.")
pShmem3ConfSVCSchedulingVBR = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 7, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("roundrobin", 2), ("smoothed", 3), ("guaranteed", 4))).clone('roundrobin')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pShmem3ConfSVCSchedulingVBR.setStatus('deprecated')
if mibBuilder.loadTexts: pShmem3ConfSVCSchedulingVBR.setDescription("This variable defines the scheduling discipline that is going to be used to service all VBR SVC connections that are output across this Series-D port. roundrobin: On Series-D netmod, this means that all VBR SVC's will be served only by one of the two round robin queues. smoothed: On Series-D netmod, this means that all VBR SVC's will be served by the rate controller. guaranteed: On Series-D netmod, this means that all VBR SVC's will be served by both the rate controller and the round robin queues.")
pShmem3ConfPVCSchedulingVBR = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 7, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("perupc", 1), ("roundrobin", 2), ("smoothed", 3), ("guaranteed", 4))).clone('roundrobin')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pShmem3ConfPVCSchedulingVBR.setStatus('deprecated')
if mibBuilder.loadTexts: pShmem3ConfPVCSchedulingVBR.setDescription("This variable defines the scheduling discipline that is going to be used to service all VBR PVC connections that are output across this port. Series-D netmods support all three scheduling modes. perupc: This means that each individual VBR PVC will be scheduled based on the discipline associated with the UPC contract used to open the connection. roundrobin: This means that each individual VBR PVC will served only by the rate controller. smoothed: On Series-D netmod, this means that all VBR PVC's will be served only by the rate controller. guaranteed: This means that all VBR PVC's will be served by both the rate controller and the round robin queues.")
pShmem3ConfAltCLPConfigCBR = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 7, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("allOn", 1), ("allOff", 2), ("svcOn", 3), ("svcOff", 4))).clone('allOff')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pShmem3ConfAltCLPConfigCBR.setStatus('current')
if mibBuilder.loadTexts: pShmem3ConfAltCLPConfigCBR.setDescription("This vairable defines the per-port configuration for the use of the VC level Alternate CLP Thresholdold on CBR/rtVBR connections. The states mean the following: allOn: All CBR/rtVBR connections use the alt CLP threshold. allOff: No CBR/rtVBR connections use the alt CLP threshold. svcOn: All CBR/rtVBR SVC's will use the alt CLP threshold. For CBR/rtVBR PVC's, whether the alt CLP threshold is used is determined by the presence or absence of the 'altCLPthresh' flag in the UPC contract. svcOff: No CBR/rtVBR SVC's will use the alt CLP threshold. For CBR/rtVBR PVC's, whether the alt CLP threshold is used is determined by the presence or absence of the 'altCLPthresh' flag in the UPC contract.")
pShmem3ConfAltCLPConfigVBR = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 7, 1, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("allOn", 1), ("allOff", 2), ("svcOn", 3), ("svcOff", 4))).clone('allOff')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pShmem3ConfAltCLPConfigVBR.setStatus('current')
if mibBuilder.loadTexts: pShmem3ConfAltCLPConfigVBR.setDescription("This vairable defines the per-port configuration for the use of the VC level Alternate CLP Thresholdold on nrtVBR connections. The states mean the following: allOn: All nrtVBR connections use the alt CLP threshold. allOff: No nrtVBR connections use the alt CLP threshold. svcOn: All nrtVBR SVC's will use the alt CLP threshold. For nrtVBR PVC's, whether the alt CLP threshold is used is determined by the presence or absence of the 'altCLPthresh' flag in the UPC contract. svcOff: No nrtVBR SVC's will use the alt CLP threshold. For nrtVBR PVC's, whether the alt CLP threshold is used is determined by the presence or absence of the 'altCLPthresh' flag in the UPC contract.")
pShmem3ConfAltCLPConfigUBR = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 7, 1, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("allOn", 1), ("allOff", 2), ("svcOn", 3), ("svcOff", 4))).clone('allOff')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pShmem3ConfAltCLPConfigUBR.setStatus('current')
if mibBuilder.loadTexts: pShmem3ConfAltCLPConfigUBR.setDescription("This vairable defines the per-port configuration for the use of the VC level Alternate CLP Thresholdold on UBR connections. The states mean the following: allOn: All UBR connections use the alt CLP threshold. allOff: No UBR connections use the alt CLP threshold. svcOn: All UBR SVC's will use the alt CLP threshold. For UBR PVC's, whether the alt CLP threshold is used is determined by the presence or absence of the 'altCLPthresh' flag in the UPC contract. svcOff: No UBR SVC's will use the alt CLP threshold. For UBR PVC's, whether the alt CLP threshold is used is determined by the presence or absence of the 'altCLPthresh' flag in the UPC contract.")
pShmem3AtmInterfaceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 7, 1, 1, 24), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pShmem3AtmInterfaceIndex.setStatus('current')
if mibBuilder.loadTexts: pShmem3AtmInterfaceIndex.setDescription('The Atm interface index correspong to this port. This is also the index of the portTable.')
portShmem3Table = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 7, 2), )
if mibBuilder.loadTexts: portShmem3Table.setStatus('current')
if mibBuilder.loadTexts: portShmem3Table.setDescription('A table for current state of port on shared memory network modules. Implementation of this table is mandatory if the network module hardware is based on shared memory.')
portShmem3Entry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 7, 2, 1), ).setIndexNames((0, "Fore-Switch-MIB", "pShmem3Board"), (0, "Fore-Switch-MIB", "pShmem3Module"), (0, "Fore-Switch-MIB", "pShmem3Port"), (0, "Fore-Switch-MIB", "pShmem3Priority"))
if mibBuilder.loadTexts: portShmem3Entry.setStatus('current')
if mibBuilder.loadTexts: portShmem3Entry.setDescription('A table entry containing current port configuration information for shared memory network modules.')
pShmem3Board = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 7, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pShmem3Board.setStatus('current')
if mibBuilder.loadTexts: pShmem3Board.setDescription('The index of this board within the ATM switch.')
pShmem3Module = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 7, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pShmem3Module.setStatus('current')
if mibBuilder.loadTexts: pShmem3Module.setDescription('The number of this network module within the switch board.')
pShmem3Port = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 7, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pShmem3Port.setStatus('current')
if mibBuilder.loadTexts: pShmem3Port.setDescription('The number of this port within the switch board and network module.')
pShmem3Priority = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 7, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("priorityABR", 1), ("priorityVBR", 2), ("priorityCBR", 3), ("priorityUBR", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pShmem3Priority.setStatus('current')
if mibBuilder.loadTexts: pShmem3Priority.setDescription('The traffic type.')
pShmem3CurrentQsize = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 7, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pShmem3CurrentQsize.setStatus('current')
if mibBuilder.loadTexts: pShmem3CurrentQsize.setDescription('The current size of the queue.')
pShmem3TxCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 7, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pShmem3TxCells.setStatus('current')
if mibBuilder.loadTexts: pShmem3TxCells.setDescription('The number of cells that were transmitted for this port and priority queue.')
pShmem3EPDLostCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 7, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pShmem3EPDLostCells.setStatus('current')
if mibBuilder.loadTexts: pShmem3EPDLostCells.setDescription('The number of cells that were lost for this port and priority queue due to EPD threshold.')
pShmem3CLP01LostCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 7, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pShmem3CLP01LostCells.setStatus('current')
if mibBuilder.loadTexts: pShmem3CLP01LostCells.setDescription('The number of cells that were lost for this port and priority queue due CLP=0+1 threshold.')
pShmem3CLP1LostCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 7, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pShmem3CLP1LostCells.setStatus('current')
if mibBuilder.loadTexts: pShmem3CLP1LostCells.setDescription('The number of cells that were lost for this port and priority queue due to CLP=1 threshold.')
pShmem3VcCLPLostCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 7, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pShmem3VcCLPLostCells.setStatus('current')
if mibBuilder.loadTexts: pShmem3VcCLPLostCells.setDescription('The number of cells that were lost for this port and priority queue due to per VC CLP=1 and CLP=0+1 thresholds.')
pShmem3OverflowLostCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 7, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pShmem3OverflowLostCells.setStatus('current')
if mibBuilder.loadTexts: pShmem3OverflowLostCells.setDescription('The number of cells that were lost for this port and priority queue due to memory overflows.')
pShmem3PPDLostCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 7, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pShmem3PPDLostCells.setStatus('current')
if mibBuilder.loadTexts: pShmem3PPDLostCells.setDescription('The number of cells that were lost for this port and priority queue due to EPD, per port and per VC CLP, and memory overflows.')
channelShmem3Table = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 8, 1), )
if mibBuilder.loadTexts: channelShmem3Table.setStatus('current')
if mibBuilder.loadTexts: channelShmem3Table.setDescription('A table of information about the channels through this shared memory network module.')
channelShmem3Entry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 8, 1, 1), ).setIndexNames((0, "Fore-Switch-MIB", "vcShmem3OutputPort"), (0, "Fore-Switch-MIB", "vcShmem3OutputVPI"), (0, "Fore-Switch-MIB", "vcShmem3OutputVCI"))
if mibBuilder.loadTexts: channelShmem3Entry.setStatus('current')
if mibBuilder.loadTexts: channelShmem3Entry.setDescription('A table entry containing channel seriesD information.')
vcShmem3OutputPort = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 8, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcShmem3OutputPort.setStatus('current')
if mibBuilder.loadTexts: vcShmem3OutputPort.setDescription('The value of this object identifies the output port of this channel and is the same as the opathPort, and portNumber.')
vcShmem3OutputVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 8, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcShmem3OutputVPI.setStatus('current')
if mibBuilder.loadTexts: vcShmem3OutputVPI.setDescription('The value of this object identifies the output VPI (Virtual Path Identifier) of this channel and is the same as the opathVPI.')
vcShmem3OutputVCI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 8, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcShmem3OutputVCI.setStatus('current')
if mibBuilder.loadTexts: vcShmem3OutputVCI.setDescription('The output VCI (Virtual Channel Identifier) of this channel.')
vcShmem3IntentionalLostCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 8, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcShmem3IntentionalLostCells.setStatus('current')
if mibBuilder.loadTexts: vcShmem3IntentionalLostCells.setDescription('The number of cells on this channel that were dropped due to EPD (Early Packet Discard) or PPD (Partial Packet Discard).')
vcShmem3UnintentionalLostCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 8, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcShmem3UnintentionalLostCells.setStatus('current')
if mibBuilder.loadTexts: vcShmem3UnintentionalLostCells.setDescription('The number of cells on this channel that were dropped due to output memory shortages or the CLP (Cell Loss Priority) threshold.')
vcShmem3CLP0TxCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 8, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcShmem3CLP0TxCells.setStatus('current')
if mibBuilder.loadTexts: vcShmem3CLP0TxCells.setDescription('The number of CLP=0 cells on this channel that were transmitted.')
vcShmem3CLP1TxCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 8, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcShmem3CLP1TxCells.setStatus('current')
if mibBuilder.loadTexts: vcShmem3CLP1TxCells.setDescription('The number of CLP=1 cells on this channel that were transmitted.')
vcShmem3EPDLostCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 8, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcShmem3EPDLostCells.setStatus('current')
if mibBuilder.loadTexts: vcShmem3EPDLostCells.setDescription('The number of cells lost on this channel due to EPD.')
vcShmem3CLP1LostCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 8, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcShmem3CLP1LostCells.setStatus('current')
if mibBuilder.loadTexts: vcShmem3CLP1LostCells.setDescription('The number of cells lost on this channel due to CLP=1 threshold.')
vcShmem3CLP01LostCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 8, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcShmem3CLP01LostCells.setStatus('current')
if mibBuilder.loadTexts: vcShmem3CLP01LostCells.setDescription('The number of cells lost on this channel due to CLP=0+1 threshold.')
vcShmem3TransmittedPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 8, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcShmem3TransmittedPackets.setStatus('current')
if mibBuilder.loadTexts: vcShmem3TransmittedPackets.setDescription('The number of transmitted packets.')
vcShmem3CurrentQsize = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 8, 1, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcShmem3CurrentQsize.setStatus('current')
if mibBuilder.loadTexts: vcShmem3CurrentQsize.setDescription('The current size of the queue.')
pathShmem3Table = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 8, 2), )
if mibBuilder.loadTexts: pathShmem3Table.setStatus('current')
if mibBuilder.loadTexts: pathShmem3Table.setDescription('A table of information about the paths through this shared memory network module.')
pathShmem3Entry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 8, 2, 1), ).setIndexNames((0, "Fore-Switch-MIB", "vpShmem3OutputPort"), (0, "Fore-Switch-MIB", "vpShmem3OutputVPI"))
if mibBuilder.loadTexts: pathShmem3Entry.setStatus('current')
if mibBuilder.loadTexts: pathShmem3Entry.setDescription('A table entry containing path seriesD information.')
vpShmem3OutputPort = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 8, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vpShmem3OutputPort.setStatus('current')
if mibBuilder.loadTexts: vpShmem3OutputPort.setDescription('The value of this object identifies the output port of this path and is the same as the portNumber.')
vpShmem3OutputVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 8, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vpShmem3OutputVPI.setStatus('current')
if mibBuilder.loadTexts: vpShmem3OutputVPI.setDescription('The output VPI (Virtual Path Identifier) of this path.')
vpShmem3UnintentionalLostCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 8, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vpShmem3UnintentionalLostCells.setStatus('current')
if mibBuilder.loadTexts: vpShmem3UnintentionalLostCells.setDescription('The number of cells on this path that were dropped due to output memory shortages or the CLP (Cell Loss Priority) threshold.')
vpShmem3CLP0TxCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 8, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vpShmem3CLP0TxCells.setStatus('current')
if mibBuilder.loadTexts: vpShmem3CLP0TxCells.setDescription('The number of CLP=0 cells on this path that were transmitted.')
vpShmem3CLP1TxCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 8, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vpShmem3CLP1TxCells.setStatus('current')
if mibBuilder.loadTexts: vpShmem3CLP1TxCells.setDescription('The number of CLP=1 cells on this path that were transmitted.')
vpShmem3CLP1LostCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 8, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vpShmem3CLP1LostCells.setStatus('current')
if mibBuilder.loadTexts: vpShmem3CLP1LostCells.setDescription('The number of cells lost on this path due to CLP=1 threshold.')
vpShmem3CLP01LostCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 8, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vpShmem3CLP01LostCells.setStatus('current')
if mibBuilder.loadTexts: vpShmem3CLP01LostCells.setDescription('The number of cells lost on this path due to CLP=0+1 threshold.')
vpShmem3TransmittedPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 8, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vpShmem3TransmittedPackets.setStatus('current')
if mibBuilder.loadTexts: vpShmem3TransmittedPackets.setDescription('The number of transmitted packets.')
vpShmem3CurrentQsize = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 8, 2, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vpShmem3CurrentQsize.setStatus('current')
if mibBuilder.loadTexts: vpShmem3CurrentQsize.setDescription('The current size of the queue.')
netmodGenericShmemTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 9, 1), )
if mibBuilder.loadTexts: netmodGenericShmemTable.setStatus('current')
if mibBuilder.loadTexts: netmodGenericShmemTable.setDescription('A table for simple network modules. Implementation of this table is optional.')
netmodGenericShmemEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 9, 1, 1), ).setIndexNames((0, "Fore-Switch-MIB", "nGenericShmemBoard"), (0, "Fore-Switch-MIB", "nGenericShmemModule"), (0, "Fore-Switch-MIB", "nGenericShmemSubindex"))
if mibBuilder.loadTexts: netmodGenericShmemEntry.setStatus('current')
if mibBuilder.loadTexts: netmodGenericShmemEntry.setDescription('A table entry containing simple network module configuration information')
nGenericShmemBoard = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 9, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nGenericShmemBoard.setStatus('current')
if mibBuilder.loadTexts: nGenericShmemBoard.setDescription('The index of this board within the ATM switch.')
nGenericShmemModule = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 9, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nGenericShmemModule.setStatus('current')
if mibBuilder.loadTexts: nGenericShmemModule.setDescription('The number of this network module within the switch board.')
nGenericShmemSubindex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 9, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nGenericShmemSubindex.setStatus('current')
if mibBuilder.loadTexts: nGenericShmemSubindex.setDescription('The subindex of this generic shmem within the network module.')
nGenericShmemCurrentUcastConnections = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 9, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nGenericShmemCurrentUcastConnections.setStatus('current')
if mibBuilder.loadTexts: nGenericShmemCurrentUcastConnections.setDescription('The current number of unicast connections active on this network module. If a separate unicast connection space is not supported, this value will be -1.')
nGenericShmemCurrentMcastConnections = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 9, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nGenericShmemCurrentMcastConnections.setStatus('current')
if mibBuilder.loadTexts: nGenericShmemCurrentMcastConnections.setDescription('The current number of multicast connections active on this network module. If a separate multicast connection space is not supported, this value will be -1.')
nGenericShmemCurrentConnections = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 9, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nGenericShmemCurrentConnections.setStatus('current')
if mibBuilder.loadTexts: nGenericShmemCurrentConnections.setDescription('The current number of connections (either multicast or unicast) active on this network module.')
nGenericShmemMaxUcastConnections = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 9, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nGenericShmemMaxUcastConnections.setStatus('current')
if mibBuilder.loadTexts: nGenericShmemMaxUcastConnections.setDescription('The total number of unicast connections that this network module can support. If a separate unicast connection space is not supported, this value will be -1. The largest possible number of ATM connections can be 2^28 - 1 (i.e., 268435455) since VPI and VCI fields in the ATM cell header occupies a total of 28 bits (12 bits of VPI and 16 bits of VCI). Any value greater than 2^28 - 1 for this MIB will indicate that this network module can support an unlimited number of unicast connections.')
nGenericShmemMaxMcastConnections = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 9, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nGenericShmemMaxMcastConnections.setStatus('current')
if mibBuilder.loadTexts: nGenericShmemMaxMcastConnections.setDescription('The total number of multicast connections that this network module can support. If a separate multicast connection space is not supported, this value will be -1. The largest possible number of ATM connections can be 2^28 - 1 (i.e., 268435455) since VPI and VCI fields in the ATM cell header occupies a total of 28 bits (12 bits of VPI and 16 bits of VCI). Any value greater than 2^28 - 1 for this MIB will indicate that this network module can support an unlimited number of multicast connections.')
nGenericShmemMaxConnections = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 9, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nGenericShmemMaxConnections.setStatus('current')
if mibBuilder.loadTexts: nGenericShmemMaxConnections.setDescription('The total number of connections (either multicast or unicast) that this network module can support. The largest possible number of ATM connections can be 2^28 - 1 (i.e., 268435455) since VPI and VCI fields in the ATM cell header occupies a total of 28 bits (12 bits of VPI and 16 bits of VCI). Any value greater than 2^28 - 1 for this MIB will indicate that this network module can support an unlimited number of connections.')
netmodGenericShmemCustomBCSTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 9, 3), )
if mibBuilder.loadTexts: netmodGenericShmemCustomBCSTable.setStatus('current')
if mibBuilder.loadTexts: netmodGenericShmemCustomBCSTable.setDescription('A table for shared memory custom BCS mappings')
netmodGenericShmemCustomBCSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 9, 3, 1), ).setIndexNames((0, "Fore-Switch-MIB", "nGenericShmemCustomBCSBoard"), (0, "Fore-Switch-MIB", "nGenericShmemCustomBCSModule"), (0, "Fore-Switch-MIB", "nGenericShmemCustomBCSSubindex"), (0, "Fore-Switch-MIB", "nGenericShmemCustomBCSValue"))
if mibBuilder.loadTexts: netmodGenericShmemCustomBCSEntry.setStatus('current')
if mibBuilder.loadTexts: netmodGenericShmemCustomBCSEntry.setDescription('A table entry containing shared memory custom BCS mappings')
nGenericShmemCustomBCSBoard = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 9, 3, 1, 1), Integer32())
if mibBuilder.loadTexts: nGenericShmemCustomBCSBoard.setStatus('current')
if mibBuilder.loadTexts: nGenericShmemCustomBCSBoard.setDescription('The index of this board within the ATM switch.')
nGenericShmemCustomBCSModule = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 9, 3, 1, 2), Integer32())
if mibBuilder.loadTexts: nGenericShmemCustomBCSModule.setStatus('current')
if mibBuilder.loadTexts: nGenericShmemCustomBCSModule.setDescription('The number of this network module within the switch board.')
nGenericShmemCustomBCSSubindex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 9, 3, 1, 3), Integer32())
if mibBuilder.loadTexts: nGenericShmemCustomBCSSubindex.setStatus('current')
if mibBuilder.loadTexts: nGenericShmemCustomBCSSubindex.setDescription('The subindex of this generic shmem within the network module.')
nGenericShmemCustomBCSValue = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 9, 3, 1, 4), Integer32())
if mibBuilder.loadTexts: nGenericShmemCustomBCSValue.setStatus('current')
if mibBuilder.loadTexts: nGenericShmemCustomBCSValue.setDescription('The value of this BCS')
nGenericShmemCustomBCSWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 9, 3, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nGenericShmemCustomBCSWeight.setStatus('current')
if mibBuilder.loadTexts: nGenericShmemCustomBCSWeight.setDescription('The weight assigned to this BCS')
nGenericShmemCustomBCSRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 9, 3, 1, 6), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nGenericShmemCustomBCSRowStatus.setStatus('current')
if mibBuilder.loadTexts: nGenericShmemCustomBCSRowStatus.setDescription('Administrative status of this entry')
dualScpConfTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 6, 1, 1), )
if mibBuilder.loadTexts: dualScpConfTable.setStatus('current')
if mibBuilder.loadTexts: dualScpConfTable.setDescription('A table for current state of dual SCP configuration.')
dualScpConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 6, 1, 1, 1), ).setIndexNames((0, "Fore-Switch-MIB", "boardIndex"))
if mibBuilder.loadTexts: dualScpConfEntry.setStatus('current')
if mibBuilder.loadTexts: dualScpConfEntry.setDescription('A table entry containing current dual SCP configuration.')
dualScpSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 6, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("slotX", 1), ("slotY", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dualScpSlot.setStatus('current')
if mibBuilder.loadTexts: dualScpSlot.setDescription('The slot number for this SCP.')
dualScpState = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 6, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("standalone", 1), ("dual", 2), ("other", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dualScpState.setStatus('current')
if mibBuilder.loadTexts: dualScpState.setDescription('Shows whether the switch is operating with a single or dual SCPs. The value other(3) denotes that both SCPs are present but communication is not yet established.')
dualScpSyncState = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 6, 1, 1, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dualScpSyncState.setStatus('current')
if mibBuilder.loadTexts: dualScpSyncState.setDescription('This variable contains the current state of synchronization.')
dualScpPrimary = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 6, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("slotX", 1), ("slotY", 2))).clone('slotX')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dualScpPrimary.setStatus('current')
if mibBuilder.loadTexts: dualScpPrimary.setDescription('Controls which SCP is designated as the primary SCP.')
dualScpFailover = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 6, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dualScpFailover.setStatus('current')
if mibBuilder.loadTexts: dualScpFailover.setDescription('Disables the dual SCP failover mechanism. When set to disable(2), the backup SCP will not take over if the main SCP goes down.')
dualScpManualSyncRequest = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 6, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12))).clone(namedValues=NamedValues(("syncIdle", 1), ("syncFlash", 2), ("syncCdb", 3), ("syncPassword", 4), ("syncLecsConfig", 5), ("syncOS", 6), ("syncInit", 7), ("syncSecurid", 8), ("syncSecret", 9), ("syncLoader", 10), ("syncKrb5KeyTab", 12))).clone('syncIdle')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dualScpManualSyncRequest.setStatus('current')
if mibBuilder.loadTexts: dualScpManualSyncRequest.setDescription('This variable can be used to manually synchronize the entire flash or any of the specified files. syncIdle(1) - No synchronization. syncFlash(2) - Synchronize the entire flash. syncCdb(3) - Synchronize the CDB file. syncPassword(4) - Synchronize the password file (depracated). syncLecsConfig(5) - Synchronize the LECS configuration file. syncOS(6) - Synchronize the OS. syncInit(7) - Reformat the entire flash. syncSecurid(8) - Synchronize the securid configuration file. syncSecret(9) - Synchronize the securid node secret file. syncLoader(10) - Synchronize the mini-loader. syncKrb5KeyTab(12)- Synchronize the kerberos v5srvtab file.')
dualScpCdbSyncMode = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 6, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("manual", 1), ("automatic", 2))).clone('automatic')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dualScpCdbSyncMode.setStatus('current')
if mibBuilder.loadTexts: dualScpCdbSyncMode.setDescription('Controls whether CDB synchronization will be manual or automatic.')
dualScpManualSwitchOver = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 6, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dualScpManualSwitchOver.setStatus('current')
if mibBuilder.loadTexts: dualScpManualSwitchOver.setDescription('Forces the backup SCP to take switch control from the main SCP.')
dualScpSwitchOverTime = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 6, 1, 1, 1, 9), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dualScpSwitchOverTime.setStatus('current')
if mibBuilder.loadTexts: dualScpSwitchOverTime.setDescription('Show the time when switch over occurred.')
dualScpSwitchOverThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 6, 1, 1, 1, 10), Integer32().clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dualScpSwitchOverThreshold.setStatus('current')
if mibBuilder.loadTexts: dualScpSwitchOverThreshold.setDescription("Amount of time the standby SCP will wait after loss of active SCP's heartbeat before it takes control of the switch. The valid range is 2-300 seconds.")
dualScpSyncRequestList = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 6, 1, 1, 1, 11), IntegerBitString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dualScpSyncRequestList.setStatus('current')
if mibBuilder.loadTexts: dualScpSyncRequestList.setDescription('The current list of items that are waiting to be synchronized. This is a bit pattern containing the specified enumurated bits. The bit definitions are: 0x02 -- syncFlash 0x04 -- syncCdb 0x08 -- syncPassword 0x10 -- syncLecsConfig 0x20 -- syncOS 0x40 -- syncInit 0x80 -- syncSecurid 0x100 -- syncSecret 0x200 -- syncLoader 0x800 -- syncKrb5KeyTab')
dualScpNumSyncRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 6, 1, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dualScpNumSyncRequests.setStatus('current')
if mibBuilder.loadTexts: dualScpNumSyncRequests.setDescription('The number of synchronization requests since this agent was initialized.')
dualScpNumSyncFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 6, 1, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dualScpNumSyncFailures.setStatus('current')
if mibBuilder.loadTexts: dualScpNumSyncFailures.setDescription('The number of synchronization failures since this agent was initialized.')
dualScpResetStandbyScp = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 6, 1, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dualScpResetStandbyScp.setStatus('current')
if mibBuilder.loadTexts: dualScpResetStandbyScp.setDescription('Setting this variable to enable(1) resets the backup SCP forcing it to start over.')
dualScpAutoRemoveOldFiles = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 6, 1, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dualScpAutoRemoveOldFiles.setStatus('current')
if mibBuilder.loadTexts: dualScpAutoRemoveOldFiles.setDescription("Setting this variable to enable(1) instructs the backup SCP to remove old files during file synchronization in order to make room for the files that are being synchronized. This usually removes older copies of OS files. When synchronizing the OS, the current version of the OS will be removed if there isn't sufficient space for the new OS being synchronized.")
dualScpRedundancyState = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 6, 1, 1, 1, 16), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dualScpRedundancyState.setStatus('current')
if mibBuilder.loadTexts: dualScpRedundancyState.setDescription('This variable contains the current state of Dual SCP Redundancy.')
dualScpSVXCPStateSyncPercent = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 6, 1, 1, 1, 17), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dualScpSVXCPStateSyncPercent.setStatus('current')
if mibBuilder.loadTexts: dualScpSVXCPStateSyncPercent.setDescription('When SVx/SPVx Preservation is enabled, call state information will be transferred from the Active SCP to the Standby SCP, prior to any SCP control transfer. This MIB variable tracks the completion percentage of the information transfer. Before SCP control transfer occurs, the user can query this variable to find out how much of the information transfer has been done.')
dualScpSVXCPStateTransferFailed = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 6, 1, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("failed", 1), ("ok", 2))).clone('ok')).setMaxAccess("readonly")
if mibBuilder.loadTexts: dualScpSVXCPStateTransferFailed.setStatus('current')
if mibBuilder.loadTexts: dualScpSVXCPStateTransferFailed.setDescription("When SVx/SPVx Preservation is enabled, call state information will be transferred from the Active SCP to the Standby SCP. The value returned is 'Failed' for any failure in this transfer, 'OK' otherwise.")
dualScpSVXCPdroppedCallCount = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 6, 1, 1, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dualScpSVXCPdroppedCallCount.setStatus('current')
if mibBuilder.loadTexts: dualScpSVXCPdroppedCallCount.setDescription('SVx/SPVx Preservation has failed to preserve zero or more calls, whose number is given here.')
genericPortGroupConfTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 9, 2), )
if mibBuilder.loadTexts: genericPortGroupConfTable.setStatus('current')
if mibBuilder.loadTexts: genericPortGroupConfTable.setDescription('A table for simple network modules. Implementation of this table is optional.')
genericPortGroupConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 9, 2, 1), ).setIndexNames((0, "Fore-Switch-MIB", "genericPortGroupBoard"), (0, "Fore-Switch-MIB", "genericPortGroupIndex"), (0, "Fore-Switch-MIB", "genericPortGroupSubindex"), (0, "Fore-Switch-MIB", "genericPortGroupPrioIndex"))
if mibBuilder.loadTexts: genericPortGroupConfEntry.setStatus('current')
if mibBuilder.loadTexts: genericPortGroupConfEntry.setDescription('A table entry containing simple network module configuration information')
genericPortGroupBoard = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 9, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: genericPortGroupBoard.setStatus('current')
if mibBuilder.loadTexts: genericPortGroupBoard.setDescription('The index of this board within the ATM switch.')
genericPortGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 9, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: genericPortGroupIndex.setStatus('current')
if mibBuilder.loadTexts: genericPortGroupIndex.setDescription('The number of this port group(module) within a switch board. This is the number that identifies the port group within a switch board.')
genericPortGroupSubindex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 9, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: genericPortGroupSubindex.setStatus('current')
if mibBuilder.loadTexts: genericPortGroupSubindex.setDescription('The subindex of this port group identifying a port within this port group.')
genericPortGroupPrioIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 9, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: genericPortGroupPrioIndex.setStatus('current')
if mibBuilder.loadTexts: genericPortGroupPrioIndex.setDescription('The priority on the port.')
genericPortGroupAal5PacketDrop = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 9, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: genericPortGroupAal5PacketDrop.setStatus('current')
if mibBuilder.loadTexts: genericPortGroupAal5PacketDrop.setDescription('The AAL5 packet drop threshold in percentage of cells. The switch software provides a reasonable default, however, the user may wish to change this value according to the type of traffic and size of packets being transmitted on the network.')
genericPortGroupEfciOn = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 9, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: genericPortGroupEfciOn.setStatus('current')
if mibBuilder.loadTexts: genericPortGroupEfciOn.setDescription('The threshold at which the EFCI (Explicit Forward Congestion Indication) bit is turned on for ABR (Available Bit Rate) traffic. ')
genericPortGroupEfciOff = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 9, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: genericPortGroupEfciOff.setStatus('current')
if mibBuilder.loadTexts: genericPortGroupEfciOff.setDescription('The threshold at which the EFCI (Explicit Forward Congestion Indication) bit is turned off for ABR (Available Bit Rate) traffic. ')
genericPortGroupPrioName = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 9, 2, 1, 8), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: genericPortGroupPrioName.setStatus('current')
if mibBuilder.loadTexts: genericPortGroupPrioName.setDescription('The priority name (CBR, VBR, ABR, UBR) for this priority index.')
genericOutputPortConfTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 10, 1), )
if mibBuilder.loadTexts: genericOutputPortConfTable.setStatus('current')
if mibBuilder.loadTexts: genericOutputPortConfTable.setDescription('A table for managing the configurable items for a port in a generic manner. Implementation of this table is optional.')
genericOutputPortConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 10, 1, 1), ).setIndexNames((0, "Fore-Switch-MIB", "genericOutputPortConfBoard"), (0, "Fore-Switch-MIB", "genericOutputPortConfModule"), (0, "Fore-Switch-MIB", "genericOutputPortConfPort"), (0, "Fore-Switch-MIB", "genericOutputPortConfPrio"))
if mibBuilder.loadTexts: genericOutputPortConfEntry.setStatus('current')
if mibBuilder.loadTexts: genericOutputPortConfEntry.setDescription('A table entry containing generic port configuration information')
genericOutputPortConfBoard = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 10, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: genericOutputPortConfBoard.setStatus('current')
if mibBuilder.loadTexts: genericOutputPortConfBoard.setDescription('The index of this board within the ATM switch')
genericOutputPortConfModule = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 10, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: genericOutputPortConfModule.setStatus('current')
if mibBuilder.loadTexts: genericOutputPortConfModule.setDescription('The number of this port group within the switch board.')
genericOutputPortConfPort = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 10, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: genericOutputPortConfPort.setStatus('current')
if mibBuilder.loadTexts: genericOutputPortConfPort.setDescription('The number identifies the port within a switch board and a port group.')
genericOutputPortConfPrio = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 10, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: genericOutputPortConfPrio.setStatus('current')
if mibBuilder.loadTexts: genericOutputPortConfPrio.setDescription('The priority on the output port. ')
genericOutputPortConfPrioDedicatedQSize = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 10, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: genericOutputPortConfPrioDedicatedQSize.setStatus('current')
if mibBuilder.loadTexts: genericOutputPortConfPrioDedicatedQSize.setDescription('The dedicated (minimum) queue size, in cells for this pport and priority')
genericOutputPortConfPrioClp1Threshold = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 10, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: genericOutputPortConfPrioClp1Threshold.setStatus('current')
if mibBuilder.loadTexts: genericOutputPortConfPrioClp1Threshold.setDescription('The CLP=1 discard threshold, in cells for this port and priority.')
genericOutputPortConfPrioClp01Threshold = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 10, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: genericOutputPortConfPrioClp01Threshold.setStatus('current')
if mibBuilder.loadTexts: genericOutputPortConfPrioClp01Threshold.setDescription('The CLP=0+1 discard threshold, in cells for this port and priority.')
genericOutputPortConfPrioName = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 10, 1, 1, 8), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: genericOutputPortConfPrioName.setStatus('current')
if mibBuilder.loadTexts: genericOutputPortConfPrioName.setDescription('The priority name (CBR, VBR, ABR, UBR) for this genericOutputPortIndex on this port.')
genericOutputPortConfAtmif = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 10, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: genericOutputPortConfAtmif.setStatus('current')
if mibBuilder.loadTexts: genericOutputPortConfAtmif.setDescription('The AtmIf(BNP) of this shmem within the ATM switch')
genericOutputPortStatsTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 10, 2), )
if mibBuilder.loadTexts: genericOutputPortStatsTable.setStatus('current')
if mibBuilder.loadTexts: genericOutputPortStatsTable.setDescription('A table for managing Statistics information about the current state of a port in a generic manner. Implementation of this table is optional.')
genericOutputPortStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 10, 2, 1), ).setIndexNames((0, "Fore-Switch-MIB", "genericOutputPortStatsBoard"), (0, "Fore-Switch-MIB", "genericOutputPortStatsModule"), (0, "Fore-Switch-MIB", "genericOutputPortStatsPort"), (0, "Fore-Switch-MIB", "genericOutputPortStatsPrio"))
if mibBuilder.loadTexts: genericOutputPortStatsEntry.setStatus('current')
if mibBuilder.loadTexts: genericOutputPortStatsEntry.setDescription('A table entry containing generic port configuration information')
genericOutputPortStatsBoard = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 10, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: genericOutputPortStatsBoard.setStatus('current')
if mibBuilder.loadTexts: genericOutputPortStatsBoard.setDescription('The index of this board within the ATM switch.')
genericOutputPortStatsModule = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 10, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: genericOutputPortStatsModule.setStatus('current')
if mibBuilder.loadTexts: genericOutputPortStatsModule.setDescription('The number of this port group within the switch board.')
genericOutputPortStatsPort = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 10, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: genericOutputPortStatsPort.setStatus('current')
if mibBuilder.loadTexts: genericOutputPortStatsPort.setDescription('The number of this port within the switch board and the port group.')
genericOutputPortStatsPrio = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 10, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: genericOutputPortStatsPrio.setStatus('current')
if mibBuilder.loadTexts: genericOutputPortStatsPrio.setDescription('The index of this priority. ')
genericOutputPortStatsPrioTransmittedCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 10, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: genericOutputPortStatsPrioTransmittedCells.setStatus('current')
if mibBuilder.loadTexts: genericOutputPortStatsPrioTransmittedCells.setDescription('The number of cells transmitted on this port for this priority')
genericOutputPortStatsPrioClp1LostCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 10, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: genericOutputPortStatsPrioClp1LostCells.setStatus('current')
if mibBuilder.loadTexts: genericOutputPortStatsPrioClp1LostCells.setDescription('The number of cells lost on this port for this priority due to CLP=1 threshold.')
genericOutputPortStatsPrioClp01LostCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 10, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: genericOutputPortStatsPrioClp01LostCells.setStatus('current')
if mibBuilder.loadTexts: genericOutputPortStatsPrioClp01LostCells.setDescription('The number of cells lost on this port for this priority due to CLP=0+1 threshold.')
genericOutputPortStatsPrioName = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 10, 2, 1, 8), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: genericOutputPortStatsPrioName.setStatus('current')
if mibBuilder.loadTexts: genericOutputPortStatsPrioName.setDescription('The priority name (CBR, VBR, ABR, UBR) for this genericOutputPortIndex on this port.')
genericOutputPortStatsAtmif = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 10, 2, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: genericOutputPortStatsAtmif.setStatus('current')
if mibBuilder.loadTexts: genericOutputPortStatsAtmif.setDescription('The index of Atmif associated with this shmem in the ATM switch.')
genericOutputPortStatsPrioEpdPpdLostCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 5, 10, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: genericOutputPortStatsPrioEpdPpdLostCells.setStatus('current')
if mibBuilder.loadTexts: genericOutputPortStatsPrioEpdPpdLostCells.setDescription('The number of cells lost on this port for this priority due to EPD/PPD threshold.')
hardwareVersion = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hardwareVersion.setStatus('current')
if mibBuilder.loadTexts: hardwareVersion.setDescription('The version of the ATM switch hardware in hex. The version number 0x1 is revision A, 0x2 is revision B etc. Version number 0x0 represents an unknown type.')
softwareVersion = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: softwareVersion.setStatus('current')
if mibBuilder.loadTexts: softwareVersion.setDescription('The version of the ATM switch control software in hex. The version number is encoded into 6 hex digits. For example, version 1.2.3 is encoded as 0x010203.')
maxPaths = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: maxPaths.setStatus('current')
if mibBuilder.loadTexts: maxPaths.setDescription('The maximum number of input VPIs (Virtual Path Identifies).')
maxChannels = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: maxChannels.setStatus('current')
if mibBuilder.loadTexts: maxChannels.setDescription('The maximum number of input VCIs (Virtual Channel Identifiers).')
atmAddress = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 1, 5), SpansAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAddress.setStatus('current')
if mibBuilder.loadTexts: atmAddress.setDescription('The address of this ATM switch.')
uptime = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 1, 6), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: uptime.setStatus('current')
if mibBuilder.loadTexts: uptime.setDescription('The length of time this ATM switch has been up, in hundredths of a second.')
switchCDV = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: switchCDV.setStatus('obsolete')
if mibBuilder.loadTexts: switchCDV.setDescription('The switch Cell Delay Variation (CDV) specified in microseconds, indicates the time window in which a cell may be received on a connection and be accepted. A cell that is received on a connection outside the CDV window will be tagged or dropped as indicated by the switchPolicingAction object. The switchCDV is the default CDV for all the connections on this switch. Individual connections can be set to explicitly override this value.')
switchPolicingAction = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("tag", 1), ("drop", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: switchPolicingAction.setStatus('obsolete')
if mibBuilder.loadTexts: switchPolicingAction.setDescription('This object indicates the action the switch will take in case of bandwidth violation. The switchPolicingAction is the default policing action for all the connections on this switch. Individual connections can be set to explicitly override this default action.')
softwareVersionText = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 1, 9), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: softwareVersionText.setStatus('current')
if mibBuilder.loadTexts: softwareVersionText.setDescription('The version of the ATM switch control software. This object provides text information about the internal software configuration that was used when the switch control software was built.')
switchType = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 5, 6, 7, 8, 9, 10, 11, 12, 15, 16, 17, 18, 19, 20, 22))).clone(namedValues=NamedValues(("asx100", 1), ("asx200", 2), ("asx200wg", 4), ("asx200bx", 5), ("asx200bxe", 6), ("cabletron9A000", 7), ("asx1000", 8), ("le155", 9), ("sfcs200wg", 10), ("sfcs200bx", 11), ("sfcs1000", 12), ("tnx210", 15), ("tnx1100", 16), ("asx1200", 17), ("asx4000", 18), ("le25", 19), ("esx3000", 20), ("asx150", 22)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: switchType.setStatus('current')
if mibBuilder.loadTexts: switchType.setDescription('This object identifies the switch type.')
switchReservedPMPMinVCI = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 1, 12), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: switchReservedPMPMinVCI.setStatus('current')
if mibBuilder.loadTexts: switchReservedPMPMinVCI.setDescription('The minimum VCI that is reserved for PMP connections.')
switchReservedPMPMaxVCI = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 1, 13), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: switchReservedPMPMaxVCI.setStatus('current')
if mibBuilder.loadTexts: switchReservedPMPMaxVCI.setDescription('The maximum VCI that is reserved for PMP connections.')
switchTimeZone = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 1, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: switchTimeZone.setStatus('current')
if mibBuilder.loadTexts: switchTimeZone.setDescription('The TimeZone configured for this ATM switch. This variable follows the POSIX standard 1003.1-1988 for the format of the TZ environment variable. In particular, it is general enough to specify the rules for converting from Standard to Daylight Savings time for most timezones of the world. By default, the switch has the rules built in for the following timezones: EST5EDT CST6CDT MST7MDT PST8PDT AKST9AKDT. Locales outside of these timezones will need to supply the appropriate rule for switching between Daylight and Standard time. ')
switchGMTime = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 1, 15), DateAndTime()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: switchGMTime.setStatus('current')
if mibBuilder.loadTexts: switchGMTime.setDescription("The switch's notion of Greenwich Mean Time. Linked to hrSystemDate. Offset part of time spec, if supplied, is considered an error.")
switchProtocolType = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("tftp", 1), ("ftp", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: switchProtocolType.setStatus('current')
if mibBuilder.loadTexts: switchProtocolType.setDescription('The transfer protocol that is used when upgrading the switch software, backing up the CDB, etc.')
switchCurrentUserid = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 1, 17), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: switchCurrentUserid.setStatus('current')
if mibBuilder.loadTexts: switchCurrentUserid.setDescription('The value of this object identifies the user currently logged in or attempting to log in on the switch. It would be a NULL string if no one is logged in currently.')
switchCurrentLoginFrom = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 1, 18), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: switchCurrentLoginFrom.setStatus('current')
if mibBuilder.loadTexts: switchCurrentLoginFrom.setDescription('This string gives the IP address of the host from where the current user is logged in or attempting to log in. A NULL string is returned if no one is currently logged in on the switch. If its a serial port login, the string indicates the same')
switchPrimaryClock = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 1, 19), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: switchPrimaryClock.setStatus('deprecated')
if mibBuilder.loadTexts: switchPrimaryClock.setDescription('The port number whose 8KHz clock is used as primary clock by all the netmods on all the boards in this switch.')
switchSecondaryClock = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 1, 20), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: switchSecondaryClock.setStatus('deprecated')
if mibBuilder.loadTexts: switchSecondaryClock.setDescription('The port number whose 8KHz clock is used as secondary clock by all the netmods on all the boards in this switch.')
switchClockOperStatus = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("primaryClock", 1), ("secondaryClock", 2), ("crystalAClock", 3), ("crystalBClock", 4), ("crystalCClock", 5), ("crystalDClock", 6), ("tcmClock", 7), ("localCrystalClock", 8), ("primaryClockPartner", 9), ("secondaryClockPartner", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: switchClockOperStatus.setStatus('deprecated')
if mibBuilder.loadTexts: switchClockOperStatus.setDescription('The currently active 8KHz clock configuration. The crystal?Clock types are not currently used. The default mode is localCrystalClock which means each netmod runs off of its own crystal. If primary, secondary or tcm clocking is configured then the status will be updated by switch software accordingly.')
switchTimingMode = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3))).clone(namedValues=NamedValues(("switchMode", 1), ("tcmMode", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: switchTimingMode.setStatus('current')
if mibBuilder.loadTexts: switchTimingMode.setDescription("The timing mode in which the switch is running. switchMode(1) provides for the direct use of any port recovered clock from any timing-capable network module in the switch. tcmMode(3) uses the clock provided by the CEC-Plus' Timing Control Modules (TCM).")
switchConnectionPreservation = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: switchConnectionPreservation.setStatus('current')
if mibBuilder.loadTexts: switchConnectionPreservation.setDescription('When connection preservation is enabled the switch will not reset the hardware when a fail-over or software-reboot occurs. The software will preserve existing PVC connections and re-create other connections. This prevents cell traffic on PVC connections from being disrupted during the fail-over / software-reboot process. When connection preservation is disabled the switch will reset the hardware when a fail-over or software-reboot occurs. All connections will then be re-created. Cell traffic on all connections will be disrupted during the fail-over / software-reboot process. This is disabled by default on all asx200bx based switches. On all the other platforms, this is enabled by default.')
switchATMLayerOAM = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: switchATMLayerOAM.setStatus('current')
if mibBuilder.loadTexts: switchATMLayerOAM.setDescription('This object specifies whether the processing of ATM layer OAM cells by this switch is enabled or disabled.')
switchHttpServer = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: switchHttpServer.setStatus('current')
if mibBuilder.loadTexts: switchHttpServer.setDescription('This specifies whether the embedded HTTP Server (which is used for the element manager) is enabled or disabled.')
switchHttpHelpUrl = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 1, 26), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: switchHttpHelpUrl.setStatus('current')
if mibBuilder.loadTexts: switchHttpHelpUrl.setDescription("This specifies the URL path for the local depository of the WWW help pages for the web-based element manager on the switch. The URL is in the form: <ipaddress>[:port][<pathname>] For example: 1.2.3.4:8000/usr/fore/www This includes the IP address host to contact, and optionally the port on that host, and the directory on that host where the help pages were saved. If an empty string, the switch will use a default location on FORE's external web site.")
switchCtrlLinkid = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 1, 28), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: switchCtrlLinkid.setStatus('current')
if mibBuilder.loadTexts: switchCtrlLinkid.setDescription('The linkid of the ctrl port on this switch.')
switchClockCurrentStatus = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 1, 29), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: switchClockCurrentStatus.setStatus('current')
if mibBuilder.loadTexts: switchClockCurrentStatus.setDescription('The currently active 8KHz clock configuration. The value would indicate primary Clock or secondary Clock or if neither is available a <netmod> crystal Clock is determined by the switch control software. The software chooses the lowest netmod number with timing support')
softwareLicenseKey = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 1, 31), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: softwareLicenseKey.setStatus('current')
if mibBuilder.loadTexts: softwareLicenseKey.setDescription('The software license key of this switch.')
switchCounterResetTime = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 1, 32), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: switchCounterResetTime.setStatus('current')
if mibBuilder.loadTexts: switchCounterResetTime.setDescription('Indicates when all switch (except for virtual connection) counters were reset. The TimeStamp is equal to the sysUpTime when the reset occurred. If switch counters have never been reset, the switchCounterResetTime will be zero. This variable is updated whenever switchCounterReset is written.')
switchCounterReset = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 1, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("resetRequest", 1), ("unresetRequest", 2), ("resetTrue", 3), ("resetFalse", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: switchCounterReset.setStatus('current')
if mibBuilder.loadTexts: switchCounterReset.setDescription('Writing a value of resetRequest will result in a reset of all counters on the switch except for VCC indexed counters. Writing a value of unresetRequest will destroy all counter offsets and restore counter values to what has accumulated over the sysUpTime period. A response value of resetTrue indicates a resetRequest succeeded and is in effect. A response of resetFalse indicates a reset is not currently in effect.')
switchPrimaryClockPort = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 1, 35), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 5))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: switchPrimaryClockPort.setStatus('current')
if mibBuilder.loadTexts: switchPrimaryClockPort.setDescription('The name of the hardware port whose 8KHz clock is used as primary clock by all the netmods on all the boards in this switch.')
switchSecondaryClockPort = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 1, 36), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 5))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: switchSecondaryClockPort.setStatus('current')
if mibBuilder.loadTexts: switchSecondaryClockPort.setDescription('The name of the hardware port whose 8KHz clock is used as secondary clock by all the netmods on all the boards in this switch.')
switchPmpEnable = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 1, 38), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: switchPmpEnable.setStatus('current')
if mibBuilder.loadTexts: switchPmpEnable.setDescription('Disabling the PMP Feature disallows any point to multipoint connections. The services which require point to multi point connections also need to be disabled. By default the feature is enabled.')
switchCallPreservation = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 1, 39), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: switchCallPreservation.setStatus('current')
if mibBuilder.loadTexts: switchCallPreservation.setDescription('When SVx/SPVx Preservation is enabled, existing switched connections will be preserved during transfers of switch control from the Active SCP to the Standby SCP, whether user-initiated or due to SCP failure. Cell traffic is preserved during the failover/switchover process. When SVx/SPVx Preservation is disabled, and if Connection Preservation also is disabled, control transfers from the Active SCP to the Standby SCP will reset the switch hardware without having preserved the necessary call-state information. Hence, all switched connections will be cleared and will then have to be recreated. Cell traffic on all switched connections will be disrupted. By default, this feature is disabled on all supported dual-scp platforms.')
switchCallPresOperStatus = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: switchCallPresOperStatus.setStatus('current')
if mibBuilder.loadTexts: switchCallPresOperStatus.setDescription('When SVx/SPVx Preservation is enabled administratively, the feature nevertheless may be disabled operationally (e.g., because of hardware failures, like a missing Standby SCP). When it is operationally disabled, the effect is as though SVx/SPVx Preservation were disabled administratively.')
switchDebounceTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 1, 30), )
if mibBuilder.loadTexts: switchDebounceTable.setStatus('current')
if mibBuilder.loadTexts: switchDebounceTable.setDescription('A table, where each entry consists of debounce information associated with a unique port. This information includes the hysteresis value (a positive number in ms) for that port, i.e, the number of ms for which a physical-level failure persists for that port, after which the connection will be brought down')
switchDebounceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 1, 30, 1), ).setIndexNames((0, "Fore-Switch-MIB", "switchDebounceIndex"))
if mibBuilder.loadTexts: switchDebounceEntry.setStatus('current')
if mibBuilder.loadTexts: switchDebounceEntry.setDescription('A table entry containing physical interface debounce information.')
switchDebounceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 1, 30, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: switchDebounceIndex.setStatus('current')
if mibBuilder.loadTexts: switchDebounceIndex.setDescription('The index value for this entry - ties in with a unique port')
switchDebounceName = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 1, 30, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: switchDebounceName.setStatus('current')
if mibBuilder.loadTexts: switchDebounceName.setDescription('The persistent name of this interface - (the port name)')
switchDebounceHysteresis = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 1, 30, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: switchDebounceHysteresis.setStatus('current')
if mibBuilder.loadTexts: switchDebounceHysteresis.setDescription('The hysteresis value for this interface. The hysteresis value is the number of ms for which a physical-level failure persists for that interface, after which the connection will be brought down')
mcastGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 1, 27))
mcastSpaceTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 1, 27, 1), )
if mibBuilder.loadTexts: mcastSpaceTable.setStatus('current')
if mibBuilder.loadTexts: mcastSpaceTable.setDescription('A table containing information on number of multicast connections supported on this switch.')
mcastSpaceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 1, 27, 1, 1), ).setIndexNames((0, "Fore-Switch-MIB", "mcastSpaceIndex"))
if mibBuilder.loadTexts: mcastSpaceEntry.setStatus('current')
if mibBuilder.loadTexts: mcastSpaceEntry.setDescription('A table entry containing multicast space information')
mcastSpaceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 1, 27, 1, 1, 1), Integer32())
if mibBuilder.loadTexts: mcastSpaceIndex.setStatus('current')
if mibBuilder.loadTexts: mcastSpaceIndex.setDescription('Index of this multicast space entry. This value is used to set boardMcastIndex value.')
mcastSpaceNumConn = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 1, 27, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcastSpaceNumConn.setStatus('current')
if mibBuilder.loadTexts: mcastSpaceNumConn.setDescription('Number of multicast connections that this entry represents. When boardMcastIndex is set to mcastSpaceIndex value, the corresponding board will support mcastSpaceNumConn number of multicast connections.')
mcastSpaceName = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 1, 27, 1, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcastSpaceName.setStatus('current')
if mibBuilder.loadTexts: mcastSpaceName.setDescription('Name of this multicast space entry.')
switchSbprServerAddressTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 1, 34), )
if mibBuilder.loadTexts: switchSbprServerAddressTable.setStatus('current')
if mibBuilder.loadTexts: switchSbprServerAddressTable.setDescription('A table, where each entry consists of a static list of 5 bootp address entries.')
switchSbprServerAddressEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 1, 34, 1), ).setIndexNames((0, "Fore-Switch-MIB", "sbprServerAddressIndex"))
if mibBuilder.loadTexts: switchSbprServerAddressEntry.setStatus('current')
if mibBuilder.loadTexts: switchSbprServerAddressEntry.setDescription('A bootp Ip Address server entry.')
sbprServerAddressIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 1, 34, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sbprServerAddressIndex.setStatus('current')
if mibBuilder.loadTexts: sbprServerAddressIndex.setDescription('A unique value greater then zero used as an index into the bootp address table.')
sbprServerAddressIndexName = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 1, 34, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sbprServerAddressIndexName.setStatus('current')
if mibBuilder.loadTexts: sbprServerAddressIndexName.setDescription('Name of the Interface index into the bootp address table.')
sbprServerMaxHops = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 1, 34, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sbprServerMaxHops.setStatus('current')
if mibBuilder.loadTexts: sbprServerMaxHops.setDescription('The maximum number of hops that a BOOTREQUEST message is permitted to traverse before it must be discarded. Received BOOTREQUEST messages that have a hopcount greater than this value are discarded by this relay agent. The default value is 4.')
sbprServerMinSeconds = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 1, 34, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sbprServerMinSeconds.setStatus('current')
if mibBuilder.loadTexts: sbprServerMinSeconds.setDescription('The minimum number of seconds that a BOOTP client must have been attempting to boot before the relay agent will relay BOOTREQUESTs from that client. The default value is 0.')
sbprServerAddress1 = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 1, 34, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sbprServerAddress1.setStatus('current')
if mibBuilder.loadTexts: sbprServerAddress1.setDescription('The IP address of the BOOTP server.')
sbprServerAddress2 = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 1, 34, 1, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sbprServerAddress2.setStatus('current')
if mibBuilder.loadTexts: sbprServerAddress2.setDescription('The IP address of the BOOTP server.')
sbprServerAddress3 = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 1, 34, 1, 7), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sbprServerAddress3.setStatus('current')
if mibBuilder.loadTexts: sbprServerAddress3.setDescription('The IP address of the BOOTP server.')
sbprServerAddress4 = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 1, 34, 1, 8), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sbprServerAddress4.setStatus('current')
if mibBuilder.loadTexts: sbprServerAddress4.setDescription('The IP address of the BOOTP server.')
sbprServerAddress5 = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 1, 34, 1, 9), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sbprServerAddress5.setStatus('current')
if mibBuilder.loadTexts: sbprServerAddress5.setDescription('The IP address of the BOOTP server.')
sbprServerRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 1, 34, 1, 10), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sbprServerRowStatus.setStatus('current')
if mibBuilder.loadTexts: sbprServerRowStatus.setDescription('Administrative status of this entry. ')
serviceCategoryTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 1, 37), )
if mibBuilder.loadTexts: serviceCategoryTable.setStatus('current')
if mibBuilder.loadTexts: serviceCategoryTable.setDescription(' A table of ATM service categories supported.')
serviceCategoryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 1, 37, 1), ).setIndexNames((0, "Fore-Switch-MIB", "serviceCategoryIndex"))
if mibBuilder.loadTexts: serviceCategoryEntry.setStatus('current')
if mibBuilder.loadTexts: serviceCategoryEntry.setDescription(' A table entry containing ATM Service Category information.')
serviceCategoryIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 1, 37, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: serviceCategoryIndex.setStatus('current')
if mibBuilder.loadTexts: serviceCategoryIndex.setDescription(' The ATM service category index.')
serviceCategoryName = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 1, 37, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: serviceCategoryName.setStatus('current')
if mibBuilder.loadTexts: serviceCategoryName.setDescription(' The name of the ATM service category. The following values are supported: serviceCategoryIndex serviceCategoryName ----------------- ---------------------- 1 CBR 2 rtVBR 3 nrtVBR 4 ABR 5 UBR ')
confTopoHelloInterval = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 11, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: confTopoHelloInterval.setStatus('current')
if mibBuilder.loadTexts: confTopoHelloInterval.setDescription('This is the time interval in milli seconds between successive Hello Indication messages sent by SPANS')
confTopoNsapIndInterval = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 11, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: confTopoNsapIndInterval.setStatus('current')
if mibBuilder.loadTexts: confTopoNsapIndInterval.setDescription('This is the time interval in milli seconds between successive NSAP Indication messages sent by SPANS')
confTopoStaticUpdateInterval = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 11, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: confTopoStaticUpdateInterval.setStatus('current')
if mibBuilder.loadTexts: confTopoStaticUpdateInterval.setDescription('This is the time interval in milli seconds between successive refreshes of NSAP static routes in the NSAP topology')
confTopoMaxHopCount = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 11, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: confTopoMaxHopCount.setStatus('current')
if mibBuilder.loadTexts: confTopoMaxHopCount.setDescription('This is the upper limit on the number of hops in the source routes computed by the NSAP router')
confTopoACRPropMult = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 11, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: confTopoACRPropMult.setStatus('current')
if mibBuilder.loadTexts: confTopoACRPropMult.setDescription('This is the proportional multiplier expressed as a percentage of Available Cell Rate (ACR). If the percentage change of the ACR of any given link in the NSAP topology exceeds this threshold, then the change is deemed significant')
confTopoMinThresh = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 11, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: confTopoMinThresh.setStatus('current')
if mibBuilder.loadTexts: confTopoMinThresh.setDescription('This is the capacity value in Cells per second of the minimum value that the threshold value for determining the significant change can take. This minimum value is used to ensure that the threshold for determining significant changes to ACR does not become a very small value in cases where product of the ACR and the proportional multiplier is a very small number.')
confTopoMinVCAvail = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 11, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: confTopoMinVCAvail.setStatus('current')
if mibBuilder.loadTexts: confTopoMinVCAvail.setDescription('This is the minimum number of VCs that should be available on a link before the state of the link changes from VCs-not- available to VCs-available. This state is propagated in the link state information. The state changes from VCs-available to VCs-not-available when the number of VCs available becomes zero from a non-zero value.')
confTopoSpansAreaID = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 11, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: confTopoSpansAreaID.setStatus('current')
if mibBuilder.loadTexts: confTopoSpansAreaID.setDescription('This is the ID of the Area in the SPANS routing hierarchy to which this switch belongs. This number goes into the most significant byte of the SPANS ATM address')
confTopoSpansBorderSwitch = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 11, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: confTopoSpansBorderSwitch.setStatus('current')
if mibBuilder.loadTexts: confTopoSpansBorderSwitch.setDescription('This variable indicates wherher this switch is configured to operate as a SPANS-NNI Border Switch or not')
confTopoSwitchPrefix = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 11, 10), NsapPrefix()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: confTopoSwitchPrefix.setStatus('current')
if mibBuilder.loadTexts: confTopoSwitchPrefix.setDescription("The default NSAP (Network Service Access Point) prefix for this ATM switch. The NSAP prefix will be used in the ILMI address registration message as well as the 'hello-indication' SPANS-NNI message.")
confTopoSwitchPrefixMask = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 11, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: confTopoSwitchPrefixMask.setStatus('current')
if mibBuilder.loadTexts: confTopoSwitchPrefixMask.setDescription('This mask gives the number of leading bits in the above prefix to be used to aggregate the addresses that belong to the switch in SPANS-PNNI alias FORE-PNNI')
confTopoPeerGroupMask = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 11, 12), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: confTopoPeerGroupMask.setStatus('current')
if mibBuilder.loadTexts: confTopoPeerGroupMask.setDescription('This mask gives the number of the leading bits in the above prefix to be used to aggregate the addresses that belong to the peer group containing this switch in SPANS-PNNI alias FORE-PNNI')
confTopoSpansPnniBorderSwitch = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 11, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: confTopoSpansPnniBorderSwitch.setStatus('current')
if mibBuilder.loadTexts: confTopoSpansPnniBorderSwitch.setDescription('This variable indicates whether this switch is configured to operate as a SPANS-PNNI Border Switch or not')
confTopoPGSNReachCost = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 11, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: confTopoPGSNReachCost.setStatus('current')
if mibBuilder.loadTexts: confTopoPGSNReachCost.setDescription('This is used to indicate cost of link from border node to PGSN')
confTopoPGSNReachCostMethod = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 11, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("default", 1), ("user", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: confTopoPGSNReachCostMethod.setStatus('current')
if mibBuilder.loadTexts: confTopoPGSNReachCostMethod.setDescription('This variable indicates the method of computing cost of link from border node to PGSN')
confTopoFtPnniForeArea = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 11, 16), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: confTopoFtPnniForeArea.setStatus('deprecated')
if mibBuilder.loadTexts: confTopoFtPnniForeArea.setDescription('This variable is the area ID of the FT-PNNI autonomous system in the global fore hierarchy of PNNI and FT-PNNI peergroups')
confTopoFtPnniForeLevel = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 11, 17), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: confTopoFtPnniForeLevel.setStatus('deprecated')
if mibBuilder.loadTexts: confTopoFtPnniForeLevel.setDescription('This variable is the level of the FT-PNNI autonomous system in the global fore hierarchy of PNNI and FT-PNNI peergroups')
confTopoLBUbrLoadBalance = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 11, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: confTopoLBUbrLoadBalance.setStatus('current')
if mibBuilder.loadTexts: confTopoLBUbrLoadBalance.setDescription('This variable indicates whether this switch is to do Load Balanced UBR routing')
numberOfPorts = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: numberOfPorts.setStatus('current')
if mibBuilder.loadTexts: numberOfPorts.setDescription('The number of ports on this ATM switch.')
portTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 2), )
if mibBuilder.loadTexts: portTable.setStatus('current')
if mibBuilder.loadTexts: portTable.setDescription('A table of information about the ports on this ATM switch.')
portEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 2, 1), ).setIndexNames((0, "Fore-Switch-MIB", "portNumber"))
if mibBuilder.loadTexts: portEntry.setStatus('current')
if mibBuilder.loadTexts: portEntry.setDescription('A table entry containing port information.')
portNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portNumber.setStatus('current')
if mibBuilder.loadTexts: portNumber.setDescription('The value of this object identifies the port.')
portAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("down", 2), ("up", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portAdminStatus.setStatus('current')
if mibBuilder.loadTexts: portAdminStatus.setDescription("The desired state of this port. The up(3) state indicates that SPANS (Simple Protocol for ATM Network Signalling), FORE's link signalling protocol, is used to determine the operational status of the port. The down(2) state dictates that the operational status of the port should not be determined by SPANS.")
portOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portOperStatus.setStatus('current')
if mibBuilder.loadTexts: portOperStatus.setDescription("The current operational state of this port, as determined either by administrative action, when the value of portAdminStatus is down(2), or by SPANS (Simple Protocol for ATM Network Signalling), FORE's link signalling protocol, when the value of porAdminStatus is up(3). For FRAM netmod, it is equivalent to the ifOperStatus of the same port")
portTime = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 2, 1, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portTime.setStatus('current')
if mibBuilder.loadTexts: portTime.setDescription('The length of time this port has been in its current state, in hundredths of a second.')
portRemoteAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 2, 1, 5), SpansAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portRemoteAtmAddress.setStatus('current')
if mibBuilder.loadTexts: portRemoteAtmAddress.setDescription('The ATM address of the entity connected to this port.')
portRemoteIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 2, 1, 6), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portRemoteIpAddress.setStatus('current')
if mibBuilder.loadTexts: portRemoteIpAddress.setDescription('The IP address of the entity connected to this port.')
portMaxPathsIn = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portMaxPathsIn.setStatus('current')
if mibBuilder.loadTexts: portMaxPathsIn.setDescription('The maximum number of incoming virtual paths supported by this port.')
portNumPathsIn = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 2, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portNumPathsIn.setStatus('current')
if mibBuilder.loadTexts: portNumPathsIn.setDescription('The number of incoming virtual paths on this port.')
portMaxBandwidthIn = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 2, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portMaxBandwidthIn.setStatus('current')
if mibBuilder.loadTexts: portMaxBandwidthIn.setDescription('The maximum incoming bandwidth of this port, in cells per second.')
portAllocBandwidthIn = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 2, 1, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portAllocBandwidthIn.setStatus('current')
if mibBuilder.loadTexts: portAllocBandwidthIn.setDescription('The allocated incoming bandwidth of this port, in cells per second.')
portUsedBandwidthIn = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 2, 1, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portUsedBandwidthIn.setStatus('deprecated')
if mibBuilder.loadTexts: portUsedBandwidthIn.setDescription('The incoming bandwidth being used on this port, in cells per second.')
portReceivedCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portReceivedCells.setStatus('current')
if mibBuilder.loadTexts: portReceivedCells.setDescription('The number of cells received on this port.')
portMaxPathsOut = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 2, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portMaxPathsOut.setStatus('current')
if mibBuilder.loadTexts: portMaxPathsOut.setDescription('The maximum number of outgoing virtual paths supported by this port.')
portNumPathsOut = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 2, 1, 14), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portNumPathsOut.setStatus('current')
if mibBuilder.loadTexts: portNumPathsOut.setDescription('The number of outgoing virtual paths on this port.')
portMaxBandwidthOut = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 2, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portMaxBandwidthOut.setStatus('current')
if mibBuilder.loadTexts: portMaxBandwidthOut.setDescription('The maximum outgoing bandwidth of this port, in cells per second.')
portAllocBandwidthOut = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 2, 1, 16), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portAllocBandwidthOut.setStatus('current')
if mibBuilder.loadTexts: portAllocBandwidthOut.setDescription('The allocated outgoing bandwidth of this port, in cells per second.')
portUsedBandwidthOut = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 2, 1, 17), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portUsedBandwidthOut.setStatus('deprecated')
if mibBuilder.loadTexts: portUsedBandwidthOut.setDescription('The outgoing bandwidth being used on this port, in cells per second.')
portTransmittedCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 2, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portTransmittedCells.setStatus('current')
if mibBuilder.loadTexts: portTransmittedCells.setDescription('The number of cells transmitted on this port.')
portHwBoard = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 2, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portHwBoard.setStatus('current')
if mibBuilder.loadTexts: portHwBoard.setDescription('The hardware board number of this port.')
portHwModule = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 2, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portHwModule.setStatus('current')
if mibBuilder.loadTexts: portHwModule.setDescription('The hardware module number of this port. For a control port (a software port), the value of this object is the maximun number of hardware modules plus one.')
portHwNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 2, 1, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portHwNumber.setStatus('deprecated')
if mibBuilder.loadTexts: portHwNumber.setDescription('The hardware port number of this port. For a control port (a software port), the value of this object is 0.')
portILMIRemoteIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 2, 1, 22), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portILMIRemoteIpAddress.setStatus('current')
if mibBuilder.loadTexts: portILMIRemoteIpAddress.setDescription('The IP address of the entity connected to this port that was discovered using ILMI on path 0. If there is no q2931 siganlling path on VPI 0 that uses ILMI, the value of this object is 255.255.255.255.')
portCDVT = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 2, 1, 23), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portCDVT.setStatus('current')
if mibBuilder.loadTexts: portCDVT.setDescription('The Cell Delay Variation Tolerance associated with this physical port. Connections take their default value for CDVT from the input side port.')
portInputPolicingStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 2, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portInputPolicingStatus.setStatus('deprecated')
if mibBuilder.loadTexts: portInputPolicingStatus.setDescription("The state of policing on this input port. Enabled(1) forces every connection on this input port to be policed. Disabled(2) turns policing off for every connection on this input port. The functions of this variable have been subsumed by the new GCRAPolicingCBR and GCRAPolicingVBR variables below. Now, writing 'disabled' to this MIB variable has the effect of setting GCRAPolicingCBR=allOff and GCRAPolicingVBR=allOff. On read, this variable reports 'enabled', if either of the GCRAPolicing*BR options are in an 'On' setting. Use of this variable should be avoided, in favor of the two GCRA variables.")
portVbrOverbooking = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 2, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32767))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portVbrOverbooking.setStatus('deprecated')
if mibBuilder.loadTexts: portVbrOverbooking.setDescription('The percentage of overbooking for nrtVBR connections. The default value is 100 (no overbooking). ')
portVbrBufferOverb = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 2, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32767))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portVbrBufferOverb.setStatus('deprecated')
if mibBuilder.loadTexts: portVbrBufferOverb.setDescription('The percentage of buffer overbooking for nrtVBR connections. The default value is 100 (no overbooking).')
portManagementStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 2, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("managed", 1), ("un-managed", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portManagementStatus.setStatus('current')
if mibBuilder.loadTexts: portManagementStatus.setDescription("The visibility of this port in the management station's view. The default value is 1 (managed).")
portAISRDIGeneration = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 2, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portAISRDIGeneration.setStatus('current')
if mibBuilder.loadTexts: portAISRDIGeneration.setDescription('The port ATM layer AIS and RDI generation status.')
portGCRAPolicingCBR = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 2, 1, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("allOn", 1), ("allOff", 2), ("svcOn", 3), ("svcOff", 4), ("default", 5))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portGCRAPolicingCBR.setStatus('current')
if mibBuilder.loadTexts: portGCRAPolicingCBR.setDescription('This variable defines the per-port policing configuration for CBR connections. The states mean the following: allOn: ALL CBR connections arriving on this port will be subjected to GCRA policing. allOff: NO CBR connections arriving on this port will be subjected to GCRA policing. svcOn: ALL CRB SVCs arriving on this port will be subjected to GCRA policing svcOff: NO CBR SVCs arriving on this port will be subjected to GCRA policing. CBR PVCs will be GCRA policed based on the state of their UPC contract. default: ALL CBR UNI SVCs/SVPs arriving at this port will be subject to GCRA policing and NO CBR NNI SVCs/SVPs arriving at this port will be subject to GCRA policing. CBR PVCs/PVPs arriving at this port will be policed based on the state of their UPC contract.')
portGCRAPolicingVBR = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 2, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("allOn", 1), ("allOff", 2), ("svcOn", 3), ("svcOff", 4), ("default", 5))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portGCRAPolicingVBR.setStatus('deprecated')
if mibBuilder.loadTexts: portGCRAPolicingVBR.setDescription('This variable defines the per-port policing configuration for nrtVBR connections. The states mean the following: allOn: ALL nrtVBR connections arriving on this port will be subjected to GCRA policing. allOff: NO nrtVBR connections arriving on this port will be subjected to GCRA policing. svcOn: ALL nrtVBR SVCs arriving on this port will be subjected to GCRA policing svcOff: NO nrtVBR SVCs arriving on this port will be subjected to GCRA policing. nrtVBR PVCs will be GCRA policed based on the state of their UPC contract. default: ALL nrtVBR UNI SVCs/SVPs arriving at this port will be subject to GCRA policing and NO nrtVBR NNI SVCs/SVPs arriving at this port will be subject to GCRA policing. nrtVBR PVCs/PVPs arriving at this port will be policed based on the state of their UPC contract.')
portAAL5PacketDiscardCBR = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 2, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("allOn", 1), ("allOff", 2), ("svcOn", 3), ("svcOff", 4))).clone('svcOn')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portAAL5PacketDiscardCBR.setStatus('current')
if mibBuilder.loadTexts: portAAL5PacketDiscardCBR.setDescription("This variable defines the per-port AAL5 packet discard configuration for CBR connections. The states mean the following: allOn: All CBR AAL5 connections have packet discard performed on them. allOff: AAL5 packet discard is not performed on any CBR connections. svcOn: Any CBR SVC that 'requests' packet discard will have it performed. For CBR PVC's, AAL5 packet discard is enabled based on the UPC contract of the connection. svcOff: AAL5 packet discard is not performed on any CBR SVC's.For CBR PVC's, AAL5 packet discard is enabled based on the UPC contract of the connection.")
portAAL5PacketDiscardVBR = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 2, 1, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("allOn", 1), ("allOff", 2), ("svcOn", 3), ("svcOff", 4))).clone('svcOn')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portAAL5PacketDiscardVBR.setStatus('deprecated')
if mibBuilder.loadTexts: portAAL5PacketDiscardVBR.setDescription("This variable defines the per-port AAL5 packet discard configuration for nrtVBR connections. The states mean the following: allOn: All nrtVBR AAL5 connections have packet discard performed on them. allOff: AAL5 packet discard is not performed on any nrtVBR connections. svcOn: Any nrtVBR SVC that 'requests' packet discard will have it performed. For nrtVBR PVC's, AAL5 packet discard is enabled based on the UPC contract of the connection. svcOff: AAL5 packet discard is not performed on any nrtVBR SVC's.For nrtVBR PVC's, AAL5 packet discard is enabled based on the UPC contract of the connection.")
portAAL5PacketDiscardUBR = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 2, 1, 37), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("allOn", 1), ("allOff", 2), ("svcOn", 3), ("svcOff", 4))).clone('svcOn')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portAAL5PacketDiscardUBR.setStatus('current')
if mibBuilder.loadTexts: portAAL5PacketDiscardUBR.setDescription("This variable defines the per-port AAL5 packet discard configuration for UBR connections. The states mean the following: allOn: All UBR AAL5 connections have packet discard performed on them. allOff: AAL5 packet discard is not performed on any UBR connections. svcOn: Any UBR SVC that 'requests' packet discard will have it performed. For UBR PVC's, AAL5 packet discard is enabled based on the UPC contract of the connection. svcOff: AAL5 packet discard is not performed on any UBR SVC's.For UBR PVC's, AAL5 packet discard is enabled based on the UPC contract of the connection.")
portInputCACErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 2, 1, 38), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portInputCACErrors.setStatus('current')
if mibBuilder.loadTexts: portInputCACErrors.setDescription('The number of input CAC (Call Admission Control) failures on this port.')
portInputVPIErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 2, 1, 39), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portInputVPIErrors.setStatus('current')
if mibBuilder.loadTexts: portInputVPIErrors.setDescription('The number of input VPI allocation failures on this port.')
portInputVCIErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 2, 1, 40), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portInputVCIErrors.setStatus('current')
if mibBuilder.loadTexts: portInputVCIErrors.setDescription('The number of input VCI allocation failures on this port.')
portInputSetupErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 2, 1, 41), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portInputSetupErrors.setStatus('current')
if mibBuilder.loadTexts: portInputSetupErrors.setDescription('The number of input connection setup failures on this port.')
portOutputCACErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 2, 1, 42), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portOutputCACErrors.setStatus('current')
if mibBuilder.loadTexts: portOutputCACErrors.setDescription('The number of output CAC (Call Admission Control) failures on this port.')
portOutputVPIErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 2, 1, 43), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portOutputVPIErrors.setStatus('current')
if mibBuilder.loadTexts: portOutputVPIErrors.setDescription('The number of output VPI allocation failures on this port.')
portOutputVCIErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 2, 1, 44), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portOutputVCIErrors.setStatus('current')
if mibBuilder.loadTexts: portOutputVCIErrors.setDescription('The number of output VCI allocation failures on this port.')
portOutputSetupErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 2, 1, 45), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portOutputSetupErrors.setStatus('current')
if mibBuilder.loadTexts: portOutputSetupErrors.setDescription('The number of output connection setup failures on this port.')
portPPPolicingCBR = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 2, 1, 46), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("allOn", 1), ("allOff", 2), ("svcOn", 3), ("svcOff", 4))).clone('svcOn')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portPPPolicingCBR.setStatus('current')
if mibBuilder.loadTexts: portPPPolicingCBR.setDescription("This variable defines the per-port AAL5 Partial Packet Policing configuration for CBR connections. The states of this variable mean the following: allOn: All CBR AAL5 connections have partial packet policing performed on them. allOff: AAL5 partial packet policing is not performed on any CBR connections. svcOn: Any CBR SVC that uses AAL5 will have partial packet policing performed on it. For CBR PVC's, partial packet policing will be performed based on the UPC contract of the connection. svcOff: Partial packet policing will not be performed on any CBR SVC's. For CBR PVC's, partial packet policing is enabled based on the UPC contract of the connection.")
portPPPolicingVBR = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 2, 1, 47), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("allOn", 1), ("allOff", 2), ("svcOn", 3), ("svcOff", 4))).clone('svcOn')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portPPPolicingVBR.setStatus('deprecated')
if mibBuilder.loadTexts: portPPPolicingVBR.setDescription("This variable defines the per-port AAL5 Partial Packet Policing configuration for nrtVBR connections. The states of this variable mean the following: allOn: All nrtVBR AAL5 connections have partial packet policing performed on them. allOff: AAL5 partial packet policing is not performed on any nrtVBR connections. svcOn: Any nrtVBR SVC that uses AAL5 will have partial packet policing performed on it. For nrtVBR PVC's, partial packet policing will be performed based on the UPC contract of the connection. svcOff: Partial packet policing will not be performed on any nrtVBR SVC's. For nrtVBR PVC's, partial packet policing is enabled based on the UPC contract of the connection.")
portUBRTagging = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 2, 1, 48), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("allOn", 1), ("allOff", 2), ("svcOn", 3), ("svcOff", 4))).clone('svcOff')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portUBRTagging.setStatus('current')
if mibBuilder.loadTexts: portUBRTagging.setDescription("This variable defines the per-port configuration for tagging (setting CLP=1) of all cells on UBR connections. The states of this variable mean the following: allOn: All UBR connections will be tagged. allOff: No UBR connections will be subject to tagging. svcOn: All UBR SVC's will be tagged. UBR PVC's will be tagged based on their UPC contract. svcOff: No UBR SVC's will be tagged. UBR PVC's will be tagged based on their UPC contract.")
portInputCdv = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 2, 1, 49), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portInputCdv.setStatus('current')
if mibBuilder.loadTexts: portInputCdv.setDescription('The current value of Cell Delay Variation attributed to the input side of this port, which can be either a user specified value or the system default, as determined by the setting of portInputCdvMode.')
portInputMaxctd = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 2, 1, 50), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portInputMaxctd.setStatus('current')
if mibBuilder.loadTexts: portInputMaxctd.setDescription('This variable give the maximum Cell Transfer Delay that is being attributed to the input side of this port. The value can be either user specified or a hardware dependant system default value.')
portInputDelayMode = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 2, 1, 51), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("systemDefault", 1), ("userSpecified", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portInputDelayMode.setStatus('current')
if mibBuilder.loadTexts: portInputDelayMode.setDescription('This variable controls whether the Cell Delay Variation and Maximum Cell Transfer Delay values attributed to the input side of this port are based on a user defined value or the hardware dependant system default values.')
portOutputCdv = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 2, 1, 52), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portOutputCdv.setStatus('current')
if mibBuilder.loadTexts: portOutputCdv.setDescription('If portOutputDelayMode == userSpecified then this variable contains the constant amount of Cell Delay Variation that is being attributed to this output port. If portOutputDelayMode == systemDefault then an actual value for the Cell Delay Variation experienced by connections traversing this port is being calculated. In this case the value of this variable is meaningless since CDV can only be calculated on a per-connection basis.')
portOutputMaxctd = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 2, 1, 53), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portOutputMaxctd.setStatus('current')
if mibBuilder.loadTexts: portOutputMaxctd.setDescription('This variable gives the maximum Cell Transfer Delay that is being attributed to the output side of this port. The value can be either user specified or a hardware dependant system default value.')
portOutputDelayMode = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 2, 1, 54), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("systemDefault", 1), ("userSpecified", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portOutputDelayMode.setStatus('current')
if mibBuilder.loadTexts: portOutputDelayMode.setDescription('This variable controls whether the Cell Delay Variation value contributed by the input side of this port is based on a user defined value or the system default value.')
portCACStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 2, 1, 59), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portCACStatus.setStatus('current')
if mibBuilder.loadTexts: portCACStatus.setDescription('The enforcement state of call admission control. The default is enabled(1).')
portCounterResetTime = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 2, 1, 60), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portCounterResetTime.setStatus('deprecated')
if mibBuilder.loadTexts: portCounterResetTime.setDescription("Indicates when this port's counters were reset. The TimeStamp is equal to moduleUptime when the reset occurred. If this ports counters were never reset, portCounterResetTime will be zero. This variable is updated whenever portCounterReset or switchCounterReset is written.")
portCounterReset = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 2, 1, 61), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 4))).clone(namedValues=NamedValues(("resetRequest", 1), ("resetTrue", 3), ("resetFalse", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portCounterReset.setStatus('deprecated')
if mibBuilder.loadTexts: portCounterReset.setDescription('Writing a value of resetRequest will result in a reset of all counters on this port. VCC indexed counters are excluded. A response value of resetTrue indicates a resetRequest has succeeded and is currently in effect. A response value of resetFalse indicates a reset is not currently in effect.')
portName = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 2, 1, 62), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portName.setStatus('current')
if mibBuilder.loadTexts: portName.setDescription('The name of this port (BNP format or otherwise).')
portGCRAPolicingRTVBR = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 2, 1, 64), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("allOn", 1), ("allOff", 2), ("svcOn", 3), ("svcOff", 4), ("default", 5))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portGCRAPolicingRTVBR.setStatus('current')
if mibBuilder.loadTexts: portGCRAPolicingRTVBR.setDescription('This variable defines the per-port policing configuration for rtVBR connections. The states mean the following: allOn: ALL rtVBR connections arriving on this port will be subjected to GCRA policing. allOff: NO rtVBR connections arriving on this port will be subjected to GCRA policing. svcOn: ALL rtVBR SVCs arriving on this port will be subjected to GCRA policing svcOff: NO rtVBR SVCs arriving on this port will be subjected to GCRA policing. rtVBR PVCs will be GCRA policed based on the state of their UPC contract. default: ALL rtVBR UNI SVCs/SVPs arriving at this port will be subject to GCRA policing and NO rtVBR NNI SVCs/SVPs arriving at this port will be subject to GCRA policing. rtVBR PVCs/PVPs arriving at this port will be policed based on the state of their UPC contract.')
portGCRAPolicingNRTVBR = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 2, 1, 65), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("allOn", 1), ("allOff", 2), ("svcOn", 3), ("svcOff", 4), ("default", 5))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portGCRAPolicingNRTVBR.setStatus('current')
if mibBuilder.loadTexts: portGCRAPolicingNRTVBR.setDescription('This variable defines the per-port policing configuration for nrtVBR connections. The states mean the following: allOn: ALL nrtVBR connections arriving on this port will be subjected to GCRA policing. allOff: NO nrtVBR connections arriving on this port will be subjected to GCRA policing. svcOn: ALL nrtVBR SVCs arriving on this port will be subjected to GCRA policing svcOff: NO nrtVBR SVCs arriving on this port will be subjected to GCRA policing. nrtVBR PVCs will be GCRA policed based on the state of their UPC contract. default: ALL nrtVBR UNI SVCs/SVPs arriving at this port will be subject to GCRA policing and NO nrtVBR NNI SVCs/SVPs arriving at this port will be subject to GCRA policing. nrtVBR PVCs/PVPs arriving at this port will be policed based on the state of their UPC contract.')
portAAL5PacketDiscardRTVBR = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 2, 1, 66), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("allOn", 1), ("allOff", 2), ("svcOn", 3), ("svcOff", 4))).clone('svcOn')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portAAL5PacketDiscardRTVBR.setStatus('current')
if mibBuilder.loadTexts: portAAL5PacketDiscardRTVBR.setDescription("This variable defines the per-port AAL5 packet discard configuration for rtVBR connections. The states mean the following: allOn: All rtVBR AAL5 connections have packet discard performed on them. allOff: AAL5 packet discard is not performed on any rtVBR connections. svcOn: Any rtVBR SVC that 'requests' packet discard will have it performed. For rtVBR PVC's, AAL5 packet discard is enabled based on the UPC contract of the connection. svcOff: AAL5 packet discard is not performed on any rtVBR SVC's.For rtVBR PVC's, AAL5 packet discard is enabled based on the UPC contract of the connection.")
portAAL5PacketDiscardNRTVBR = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 2, 1, 67), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("allOn", 1), ("allOff", 2), ("svcOn", 3), ("svcOff", 4))).clone('svcOn')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portAAL5PacketDiscardNRTVBR.setStatus('current')
if mibBuilder.loadTexts: portAAL5PacketDiscardNRTVBR.setDescription("This variable defines the per-port AAL5 packet discard configuration for nrtVBR connections. The states mean the following: allOn: All nrtVBR AAL5 connections have packet discard performed on them. allOff: AAL5 packet discard is not performed on any nrtVBR connections. svcOn: Any nrtVBR SVC that 'requests' packet discard will have it performed. For nrtVBR PVC's, AAL5 packet discard is enabled based on the UPC contract of the connection. svcOff: AAL5 packet discard is not performed on any nrtVBR SVC's.For nrtVBR PVC's, AAL5 packet discard is enabled based on the UPC contract of the connection.")
portPPPolicingNRTVBR = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 2, 1, 68), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("allOn", 1), ("allOff", 2), ("svcOn", 3), ("svcOff", 4))).clone('svcOn')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portPPPolicingNRTVBR.setStatus('current')
if mibBuilder.loadTexts: portPPPolicingNRTVBR.setDescription("This variable defines the per-port AAL5 Partial Packet Policing configuration for nrtVBR connections. The states of this variable mean the following: allOn: All nrtVBR AAL5 connections have partial packet policing performed on them. allOff: AAL5 partial packet policing is not performed on any nrtVBR connections. svcOn: Any nrtVBR SVC that uses AAL5 will have partial packet policing performed on it. For nrtVBR PVC's, partial packet policing will be performed based on the UPC contract of the connection. svcOff: Partial packet policing will not be performed on any nrtVBR SVC's. For nrtVBR PVC's, partial packet policing is enabled based on the UPC contract of the connection.")
portPPPolicingRTVBR = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 2, 1, 69), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("allOn", 1), ("allOff", 2), ("svcOn", 3), ("svcOff", 4))).clone('svcOn')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portPPPolicingRTVBR.setStatus('current')
if mibBuilder.loadTexts: portPPPolicingRTVBR.setDescription("This variable defines the per-port AAL5 Partial Packet Policing configuration for rtVBR connections. The states of this variable mean the following: allOn: All rtVBR AAL5 connections have partial packet policing performed on them. allOff: AAL5 partial packet policing is not performed on any rtVBR connections. svcOn: Any rtVBR SVC that uses AAL5 will have partial packet policing performed on it. For rtVBR PVC's, partial packet policing will be performed based on the UPC contract of the connection. svcOff: Partial packet policing will not be performed on any rtVBR SVC's. For rtVBR PVC's, partial packet policing is enabled based on the UPC contract of the connection.")
portNrtVbrOverbooking = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 2, 1, 70), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32767))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portNrtVbrOverbooking.setStatus('current')
if mibBuilder.loadTexts: portNrtVbrOverbooking.setDescription('The percentage of overbooking for nrtVBR connections. The default value is 100 (no overbooking). ')
portNrtVbrBufferOverb = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 2, 1, 71), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32767))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portNrtVbrBufferOverb.setStatus('current')
if mibBuilder.loadTexts: portNrtVbrBufferOverb.setDescription('The percentage of buffer overbooking for nrtVBR connections. The default value is 100 (no overbooking).')
portRtVbrOverbooking = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 2, 1, 72), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32767))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portRtVbrOverbooking.setStatus('current')
if mibBuilder.loadTexts: portRtVbrOverbooking.setDescription('The percentage of overbooking for rtVBR connections. The default value is 100 (no overbooking). ')
portRtVbrBufferOverb = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 2, 1, 73), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32767))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portRtVbrBufferOverb.setStatus('current')
if mibBuilder.loadTexts: portRtVbrBufferOverb.setDescription('The percentage of buffer overbooking for rtVBR connections. The default value is 100 (no overbooking).')
portPathOverbooking = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 2, 1, 74), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32767))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portPathOverbooking.setStatus('current')
if mibBuilder.loadTexts: portPathOverbooking.setDescription('The percentage of overbooking for inelastic originating paths. The default value is 100 (no overbooking).')
atmIfConnSchedTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 3), )
if mibBuilder.loadTexts: atmIfConnSchedTable.setStatus('current')
if mibBuilder.loadTexts: atmIfConnSchedTable.setDescription('A table of connection scheduling information on this ATM If.')
atmIfConnSchedEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 3, 1), ).setIndexNames((0, "Fore-Switch-MIB", "atmIfConnSchedLink"), (0, "Fore-Switch-MIB", "atmIfConnSchedServCat"))
if mibBuilder.loadTexts: atmIfConnSchedEntry.setStatus('current')
if mibBuilder.loadTexts: atmIfConnSchedEntry.setDescription('A table of connection scheduling information on this ATM If.')
atmIfConnSchedLink = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 3, 1, 1), Integer32())
if mibBuilder.loadTexts: atmIfConnSchedLink.setStatus('current')
if mibBuilder.loadTexts: atmIfConnSchedLink.setDescription('The index of this ATM If.')
atmIfConnSchedServCat = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 3, 1, 2), Integer32())
if mibBuilder.loadTexts: atmIfConnSchedServCat.setStatus('current')
if mibBuilder.loadTexts: atmIfConnSchedServCat.setDescription('Index of this service category within serviceCategoryTable.')
atmIfConnSchedMode = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 3, 1, 3), AtmConnSchedMode()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfConnSchedMode.setStatus('current')
if mibBuilder.loadTexts: atmIfConnSchedMode.setDescription('The scheduling mode used for connections of type atmIfConnSchedServCat on this ATM if. The default choice of AtmConnSchedMode is not allowed at atmIf level.')
atmIfConnSchedOverride = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 2, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfConnSchedOverride.setStatus('current')
if mibBuilder.loadTexts: atmIfConnSchedOverride.setDescription('The override option used for connections of type atmIfConnSchedServCat on this ATM if.')
ifIndexMapTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 14, 1), )
if mibBuilder.loadTexts: ifIndexMapTable.setStatus('current')
if mibBuilder.loadTexts: ifIndexMapTable.setDescription('A table containing information about how physical interfaces ifIndexes relate to the b-n-p triplets. Other ifIndices will not have entries in this table.')
ifIndexMapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 14, 1, 1), ).setIndexNames((0, "Fore-Switch-MIB", "ifIndexMapIndex"))
if mibBuilder.loadTexts: ifIndexMapEntry.setStatus('current')
if mibBuilder.loadTexts: ifIndexMapEntry.setDescription('A table entry containing ifindex/b-n-p information.')
ifIndexMapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 14, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifIndexMapIndex.setStatus('current')
if mibBuilder.loadTexts: ifIndexMapIndex.setDescription('The ifIndex of this entry. The ifindex must be that of a physical interface.')
ifIndexMapBoard = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 14, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifIndexMapBoard.setStatus('current')
if mibBuilder.loadTexts: ifIndexMapBoard.setDescription('The board number that this ifIndex refers to')
ifIndexMapNetmod = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 14, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifIndexMapNetmod.setStatus('current')
if mibBuilder.loadTexts: ifIndexMapNetmod.setDescription('The netmod number that this ifIndex refers to')
ifIndexMapPort = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 14, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifIndexMapPort.setStatus('current')
if mibBuilder.loadTexts: ifIndexMapPort.setDescription('The port number that this ifIndex refers to')
cesExtTable = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 16, 1), TestAndIncr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesExtTable.setStatus('current')
if mibBuilder.loadTexts: cesExtTable.setDescription('This indicates the value of the next available index to be used for CES creation')
cbrctConfTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 16, 2), )
if mibBuilder.loadTexts: cbrctConfTable.setStatus('current')
if mibBuilder.loadTexts: cbrctConfTable.setDescription('A table of CBR Cut-through configuration information.')
cbrctConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 16, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: cbrctConfEntry.setStatus('current')
if mibBuilder.loadTexts: cbrctConfEntry.setDescription('A table entry containing CBR Cut-through configuration information for each CES connection. ')
cbrctState = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 16, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cbrctState.setStatus('current')
if mibBuilder.loadTexts: cbrctState.setDescription('This variable indicates whether the CBR Cut-through feature is enabled or disabled on the ingress connection. The values mean: enabled CBR Cut-through enabled disabled CBR Cut-through disabled')
cbrctIdleDetection = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 16, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("idlePattern", 1), ("cas", 2))).clone('idlePattern')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cbrctIdleDetection.setStatus('current')
if mibBuilder.loadTexts: cbrctIdleDetection.setDescription('This variable identifies the idle detection mechanism used on this connection. The different values are: idlePattern(1) detection is based on idle pattern detection cas(2) detection is based on CAS signalling')
cbrctIdleMask = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 16, 2, 1, 3), Integer32().clone(255)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cbrctIdleMask.setStatus('current')
if mibBuilder.loadTexts: cbrctIdleMask.setDescription('This contains the mask pattern for idle detection.')
cbrctNoOfIdlePatterns = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 16, 2, 1, 4), Integer32().clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cbrctNoOfIdlePatterns.setStatus('current')
if mibBuilder.loadTexts: cbrctNoOfIdlePatterns.setDescription('This variable contains the number of idle patterns configured for detection.')
cbrctIdlePatterns = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 16, 2, 1, 5), Integer32().clone(32767)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cbrctIdlePatterns.setStatus('current')
if mibBuilder.loadTexts: cbrctIdlePatterns.setDescription('This contains the patterns for idle detection. For detection based on both idle and mask patterns it contains the idle octet patterns. For detection based on signalling it contains the octet value of AB signalling bits (eg. 00000010 (02H), the bit 0 is B bit and bit 1 is A bit). Maximum of 4 idle patterns are used. The idle patterns get filled from the least significant byte. The cbrctNoOfIdlePatterns gives the number of idle patterns.')
cbrctIdleIntPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 16, 2, 1, 6), TimeInterval().clone(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cbrctIdleIntPeriod.setStatus('current')
if mibBuilder.loadTexts: cbrctIdleIntPeriod.setDescription('This contains the integration period for idle detection.')
cbrctActiveIntPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 16, 2, 1, 7), TimeInterval().clone(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cbrctActiveIntPeriod.setStatus('current')
if mibBuilder.loadTexts: cbrctActiveIntPeriod.setDescription('This contains the integration period for active detection.')
asxAtmIfTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 20, 1), )
if mibBuilder.loadTexts: asxAtmIfTable.setStatus('current')
if mibBuilder.loadTexts: asxAtmIfTable.setDescription('A table of atm interface information.')
asxAtmIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 20, 1, 1), ).setIndexNames((0, "Fore-Switch-MIB", "asxAtmIfName"))
if mibBuilder.loadTexts: asxAtmIfEntry.setStatus('current')
if mibBuilder.loadTexts: asxAtmIfEntry.setDescription('A table entry containing atm interface information.')
asxAtmIfName = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 20, 1, 1, 1), DisplayString())
if mibBuilder.loadTexts: asxAtmIfName.setStatus('current')
if mibBuilder.loadTexts: asxAtmIfName.setDescription('The persistent name of this atm interface. It is used to index this atm interface. All letters in the asxAtmIfName are always represented in uppercase.')
asxAtmIfLinkid = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 20, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: asxAtmIfLinkid.setStatus('current')
if mibBuilder.loadTexts: asxAtmIfLinkid.setDescription('The linkid of this atm interface.')
pathTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 1), )
if mibBuilder.loadTexts: pathTable.setStatus('current')
if mibBuilder.loadTexts: pathTable.setDescription('A table of information about the virtual paths passing through this ATM switch.')
pathEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 1, 1), ).setIndexNames((0, "Fore-Switch-MIB", "pathPort"), (0, "Fore-Switch-MIB", "pathVPI"))
if mibBuilder.loadTexts: pathEntry.setStatus('current')
if mibBuilder.loadTexts: pathEntry.setDescription('A table entry containing path information.')
pathPort = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pathPort.setStatus('current')
if mibBuilder.loadTexts: pathPort.setDescription('The value of this object identifies the input port of this path and is the same as the portNumber.')
pathVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pathVPI.setStatus('current')
if mibBuilder.loadTexts: pathVPI.setDescription('The input VPI (Virtual Path Identifier) of this path.')
pathStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 1, 1, 3), EntryStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pathStatus.setStatus('current')
if mibBuilder.loadTexts: pathStatus.setDescription('The status of this path entry.')
pathNumOutputs = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 1, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pathNumOutputs.setStatus('current')
if mibBuilder.loadTexts: pathNumOutputs.setDescription('The number of output ports to which this path is routed.')
pathMaxChannels = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 1, 1, 5), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pathMaxChannels.setStatus('current')
if mibBuilder.loadTexts: pathMaxChannels.setDescription('The maximum number of virtual channels that can be allocated on this path.')
pathNumChannels = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 1, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pathNumChannels.setStatus('current')
if mibBuilder.loadTexts: pathNumChannels.setDescription('The number of virtual channels currently allocated on this path.')
pathMaxBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 1, 1, 7), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pathMaxBandwidth.setStatus('current')
if mibBuilder.loadTexts: pathMaxBandwidth.setDescription('The maximum bandwidth of this path, in cells per second.')
pathAllocBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 1, 1, 8), Gauge32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pathAllocBandwidth.setStatus('current')
if mibBuilder.loadTexts: pathAllocBandwidth.setDescription('The allocated bandwidth of this path, in cells per second.')
pathUsedBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 1, 1, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pathUsedBandwidth.setStatus('deprecated')
if mibBuilder.loadTexts: pathUsedBandwidth.setDescription('The bandwidth being used on this path, in cells per second.')
pathCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pathCells.setStatus('current')
if mibBuilder.loadTexts: pathCells.setDescription('The number of cells transferred over this path.')
pathUptime = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 1, 1, 11), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pathUptime.setStatus('current')
if mibBuilder.loadTexts: pathUptime.setDescription('The time since this path was created, in hundredths of a second.')
pathSigProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 1, 1, 12), AtmSigProtocol()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pathSigProtocol.setStatus('current')
if mibBuilder.loadTexts: pathSigProtocol.setDescription('The signaling protocol that created this path.')
pathRejectedCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pathRejectedCells.setStatus('current')
if mibBuilder.loadTexts: pathRejectedCells.setDescription('The number of cells over this path that were rejected (i.e. dropped) by the policer on the switch fabric. This does not include any cells that may have been tagged with CLP=1 by the policer, only cells that were discarded.')
pathMinVCI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 1, 1, 14), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pathMinVCI.setStatus('current')
if mibBuilder.loadTexts: pathMinVCI.setDescription('The minimum VCI that can be allocated on this path.')
pathMaxVCI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 1, 1, 15), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pathMaxVCI.setStatus('current')
if mibBuilder.loadTexts: pathMaxVCI.setDescription('The maximum VCI that can be allocated on this path.')
pathCACErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pathCACErrors.setStatus('current')
if mibBuilder.loadTexts: pathCACErrors.setDescription('The number of CAC (Call Admission Control) failures on this path.')
pathVCIErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pathVCIErrors.setStatus('current')
if mibBuilder.loadTexts: pathVCIErrors.setDescription('The number of VCI allocation failures on this path.')
pathSetupErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pathSetupErrors.setStatus('current')
if mibBuilder.loadTexts: pathSetupErrors.setDescription('The number of connection setup failures on this path.')
pathRouteTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 2), )
if mibBuilder.loadTexts: pathRouteTable.setStatus('current')
if mibBuilder.loadTexts: pathRouteTable.setDescription('A table of information about the routing of paths through this ATM switch.')
pathRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 2, 1), ).setIndexNames((0, "Fore-Switch-MIB", "pathrInputPort"), (0, "Fore-Switch-MIB", "pathrInputVPI"), (0, "Fore-Switch-MIB", "pathrOutputPort"), (0, "Fore-Switch-MIB", "pathrOutputVPI"))
if mibBuilder.loadTexts: pathRouteEntry.setStatus('current')
if mibBuilder.loadTexts: pathRouteEntry.setDescription('A table entry containing path route information.')
pathrInputPort = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pathrInputPort.setStatus('current')
if mibBuilder.loadTexts: pathrInputPort.setDescription('The value of this object identifies the input port of this path and is the same as the portNumber.')
pathrInputVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pathrInputVPI.setStatus('current')
if mibBuilder.loadTexts: pathrInputVPI.setDescription('The input VPI (Virtual Path Identifier) of this path.')
pathrOutputPort = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pathrOutputPort.setStatus('current')
if mibBuilder.loadTexts: pathrOutputPort.setDescription('The value of this object identifies the output port of this path and is the same as the portNumber.')
pathrOutputVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pathrOutputVPI.setStatus('current')
if mibBuilder.loadTexts: pathrOutputVPI.setDescription('The output VPI (Virtual Path Identifier) of this path.')
pathrStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 2, 1, 5), EntryStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pathrStatus.setStatus('current')
if mibBuilder.loadTexts: pathrStatus.setDescription('The status of this path entry.')
pathrMaxBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pathrMaxBandwidth.setStatus('current')
if mibBuilder.loadTexts: pathrMaxBandwidth.setDescription('The maximum bandwidth of this path, in cells per second.')
pathrAllocBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 2, 1, 7), Gauge32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pathrAllocBandwidth.setStatus('current')
if mibBuilder.loadTexts: pathrAllocBandwidth.setDescription('The allocated bandwidth of this path, in cells per second.')
pathrCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pathrCells.setStatus('current')
if mibBuilder.loadTexts: pathrCells.setDescription('The number of cells transferred over this path.')
pathrUptime = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 2, 1, 9), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pathrUptime.setStatus('current')
if mibBuilder.loadTexts: pathrUptime.setDescription('The time since this path was created, in hundredths of a second.')
pathrSigProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 2, 1, 10), AtmSigProtocol()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pathrSigProtocol.setStatus('current')
if mibBuilder.loadTexts: pathrSigProtocol.setDescription('The signaling protocol that created this path.')
pathrRejectedCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pathrRejectedCells.setStatus('current')
if mibBuilder.loadTexts: pathrRejectedCells.setDescription('The number of cells over this through path that were rejected (i.e. dropped) by the policer on the switch fabric. This does not include any cells that may have been tagged with CLP=1 by the policer, only cells that were discarded.')
pathrLoopVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 2, 1, 12), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pathrLoopVPI.setStatus('current')
if mibBuilder.loadTexts: pathrLoopVPI.setDescription('If this value is other than -1, cells destined for pathrOutputPort, pathrOutputVPI will be translated by the netmod to pathrLoopVPI before actually being trasmitted. This was instituted to facilitate single port loopback.')
pathrUpcContract = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 2, 1, 13), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pathrUpcContract.setStatus('current')
if mibBuilder.loadTexts: pathrUpcContract.setDescription('The UPC contract that will be used to police this through path. This is the number of the row in the upcContractTable.')
pathrName = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 2, 1, 14), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pathrName.setStatus('current')
if mibBuilder.loadTexts: pathrName.setDescription(' The value of this object identifies the name that has been assigned for this path.')
pathrConnectionType = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 2, 1, 15), ConnectionType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pathrConnectionType.setStatus('current')
if mibBuilder.loadTexts: pathrConnectionType.setDescription(' This object identifies the type of the path endpoints with respect to a particular network.')
pathrServCat = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 2, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pathrServCat.setStatus('current')
if mibBuilder.loadTexts: pathrServCat.setDescription('Index of this service category within serviceCategoryTable')
outputPathTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 3), )
if mibBuilder.loadTexts: outputPathTable.setStatus('current')
if mibBuilder.loadTexts: outputPathTable.setDescription('A table of information about the virtual paths originating at this ATM switch.')
outputPathEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 3, 1), ).setIndexNames((0, "Fore-Switch-MIB", "opathPort"), (0, "Fore-Switch-MIB", "opathVPI"))
if mibBuilder.loadTexts: outputPathEntry.setStatus('current')
if mibBuilder.loadTexts: outputPathEntry.setDescription('A table entry containing output path information.')
opathPort = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: opathPort.setStatus('current')
if mibBuilder.loadTexts: opathPort.setDescription('The value of this object identifies the output port of this path and is the same as the portNumber.')
opathVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: opathVPI.setStatus('current')
if mibBuilder.loadTexts: opathVPI.setDescription('The VPI (Virtual Path Identifier) of this path.')
opathStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 3, 1, 3), EntryStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: opathStatus.setStatus('current')
if mibBuilder.loadTexts: opathStatus.setDescription('The status of this path entry.')
opathMaxChannels = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 3, 1, 4), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: opathMaxChannels.setStatus('current')
if mibBuilder.loadTexts: opathMaxChannels.setDescription('The maximum number of virtual channels that can be allocated on this path.')
opathNumChannels = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 3, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: opathNumChannels.setStatus('current')
if mibBuilder.loadTexts: opathNumChannels.setDescription('The number of virtual channels currently allocated on this path.')
opathMaxBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 3, 1, 6), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: opathMaxBandwidth.setStatus('current')
if mibBuilder.loadTexts: opathMaxBandwidth.setDescription('The maximum bandwidth of this path, in cells per second.')
opathAllocBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 3, 1, 7), Gauge32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: opathAllocBandwidth.setStatus('current')
if mibBuilder.loadTexts: opathAllocBandwidth.setDescription('The allocated bandwidth of this path, in cells per second.')
opathUsedBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 3, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: opathUsedBandwidth.setStatus('deprecated')
if mibBuilder.loadTexts: opathUsedBandwidth.setDescription('The bandwidth used on this path, in cells per second.')
opathCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 3, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: opathCells.setStatus('current')
if mibBuilder.loadTexts: opathCells.setDescription('The number of cells transmitted on this path.')
opathUptime = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 3, 1, 10), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: opathUptime.setStatus('current')
if mibBuilder.loadTexts: opathUptime.setDescription('The time since this path was created, in hundredths of a second.')
opathSigProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 3, 1, 11), AtmSigProtocol()).setMaxAccess("readonly")
if mibBuilder.loadTexts: opathSigProtocol.setStatus('current')
if mibBuilder.loadTexts: opathSigProtocol.setDescription('The signaling protocol that created this path.')
opathRejectedCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 3, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: opathRejectedCells.setStatus('current')
if mibBuilder.loadTexts: opathRejectedCells.setDescription('The number of cells on this output path that were rejected (i.e. dropped) by the policer on the switch fabric. This does not include any cells that may have been tagged with CLP=1 by the policer, only cells that were discarded.')
opathTrafficShapeVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 3, 1, 13), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: opathTrafficShapeVPI.setStatus('current')
if mibBuilder.loadTexts: opathTrafficShapeVPI.setDescription('The VPI of shaped cells')
opathVbrOverbooking = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 3, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 32767))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: opathVbrOverbooking.setStatus('deprecated')
if mibBuilder.loadTexts: opathVbrOverbooking.setDescription('The percentage of overbooking for nrtVBR connections. The default value is 100 (no overbooking). A value of -1 indicates that the path is elastic, and therefore the overbooking factors are meaningless.')
opathVbrBufferOverb = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 3, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 32767))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: opathVbrBufferOverb.setStatus('deprecated')
if mibBuilder.loadTexts: opathVbrBufferOverb.setDescription('The percentage of buffer overbooking for nrtVBR connections. The default value is 100 (no overbooking). A value of -1 indicates that the path is elastic, and therefore the overbooking factors are meaningless.')
opathMinVCI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 3, 1, 16), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: opathMinVCI.setStatus('current')
if mibBuilder.loadTexts: opathMinVCI.setDescription('The minimum VCI that can be allocated on this path.')
opathMaxVCI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 3, 1, 17), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: opathMaxVCI.setStatus('current')
if mibBuilder.loadTexts: opathMaxVCI.setDescription('The maximum VCI that can be allocated on this path.')
opathCACErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 3, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: opathCACErrors.setStatus('current')
if mibBuilder.loadTexts: opathCACErrors.setDescription('The number of CAC (Call Admission Control) failures on this path.')
opathVCIErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 3, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: opathVCIErrors.setStatus('current')
if mibBuilder.loadTexts: opathVCIErrors.setDescription('The number of VCI allocation failures on this path.')
opathSetupErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 3, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: opathSetupErrors.setStatus('current')
if mibBuilder.loadTexts: opathSetupErrors.setDescription('The number of connection setup failures on this path.')
opathLoopVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 3, 1, 21), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: opathLoopVPI.setStatus('current')
if mibBuilder.loadTexts: opathLoopVPI.setDescription('If this value is assigned to other than -1, the netmod will modify cell headers received from the fabric that are destined for opathPort, opathVPI to have the vpi value of opathLoopVPI before being transmitted. This extra translation can be used to loop cells back onto the fabric using a single port.')
opathSchedMode = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 3, 1, 22), AtmOrigPathSchedMode().clone('flat')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: opathSchedMode.setStatus('current')
if mibBuilder.loadTexts: opathSchedMode.setDescription('The value of this object identifies the scheduling mode for this originating path.')
opathNrtVbrOverbooking = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 3, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 32767))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: opathNrtVbrOverbooking.setStatus('current')
if mibBuilder.loadTexts: opathNrtVbrOverbooking.setDescription('The percentage of overbooking for nrtVBR connections. The default value is 100 (no overbooking). A value of -1 indicates that the path is elastic, and therefore the overbooking factors are meaningless.')
opathNrtVbrBufferOverb = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 3, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 32767))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: opathNrtVbrBufferOverb.setStatus('current')
if mibBuilder.loadTexts: opathNrtVbrBufferOverb.setDescription('The percentage of buffer overbooking for nrtVBR connections. The default value is 100 (no overbooking). A value of -1 indicates that the path is elastic, and therefore the overbooking factors are meaningless.')
opathRtVbrOverbooking = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 3, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 32767))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: opathRtVbrOverbooking.setStatus('current')
if mibBuilder.loadTexts: opathRtVbrOverbooking.setDescription('The percentage of overbooking for rtVBR connections. The default value is 100 (no overbooking). A value of -1 indicates that the path is elastic, and therefore the overbooking factors are meaningless.')
opathRtVbrBufferOverb = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 3, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 32767))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: opathRtVbrBufferOverb.setStatus('current')
if mibBuilder.loadTexts: opathRtVbrBufferOverb.setDescription('The percentage of buffer overbooking for rtVBR connections. The default value is 100 (no overbooking). A value of -1 indicates that the path is elastic, and therefore the overbooking factors are meaningless.')
outputPathStatsTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 4), )
if mibBuilder.loadTexts: outputPathStatsTable.setStatus('current')
if mibBuilder.loadTexts: outputPathStatsTable.setDescription('A table of statistics information about the virtual paths originating at this ATM switch.')
outputPathStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 4, 1), ).setIndexNames((0, "Fore-Switch-MIB", "opathStatsPort"), (0, "Fore-Switch-MIB", "opathStatsVPI"))
if mibBuilder.loadTexts: outputPathStatsEntry.setStatus('current')
if mibBuilder.loadTexts: outputPathStatsEntry.setDescription('A table entry containing originating channel statistics information.')
opathStatsPort = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: opathStatsPort.setStatus('current')
if mibBuilder.loadTexts: opathStatsPort.setDescription('The value of this object identifies the output port of this channel and is the same as the opathPort, and portNumber.')
opathStatsVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: opathStatsVPI.setStatus('current')
if mibBuilder.loadTexts: opathStatsVPI.setDescription('The value of this object identifies the output VPI (Virtual Path Identifier) of this channel and is the same as the opathVPI.')
opathStatsLostCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 4, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: opathStatsLostCells.setStatus('current')
if mibBuilder.loadTexts: opathStatsLostCells.setDescription('The number of cells on this output path that were dropped at the output netmod.')
opathStatsTransmittedCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: opathStatsTransmittedCells.setStatus('current')
if mibBuilder.loadTexts: opathStatsTransmittedCells.setDescription('The number of cells on this output path that were transmitted.')
opathStatsIntentionalLostCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 4, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: opathStatsIntentionalLostCells.setStatus('current')
if mibBuilder.loadTexts: opathStatsIntentionalLostCells.setDescription('The number of cells on this output path that were dropped intentionally at the output netmod.')
opathStatsCLP0Cells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 4, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: opathStatsCLP0Cells.setStatus('current')
if mibBuilder.loadTexts: opathStatsCLP0Cells.setDescription('The number of CLP = 0 cells transmitted on this output path.')
opathStatsLostPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 4, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: opathStatsLostPackets.setStatus('current')
if mibBuilder.loadTexts: opathStatsLostPackets.setDescription('The number of packets on this output path that were dropped at the output netmod.')
opathStatsTransmittedPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 4, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: opathStatsTransmittedPackets.setStatus('current')
if mibBuilder.loadTexts: opathStatsTransmittedPackets.setDescription('The number of Packets on this output path that were transmitted.')
outputPathChannelSchedTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 5), )
if mibBuilder.loadTexts: outputPathChannelSchedTable.setStatus('current')
if mibBuilder.loadTexts: outputPathChannelSchedTable.setDescription('A table of connection scheduling information on this output path.')
outputPathChannelSchedEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 5, 1), ).setIndexNames((0, "Fore-Switch-MIB", "opathChannelSchedPort"), (0, "Fore-Switch-MIB", "opathChannelSchedVPI"), (0, "Fore-Switch-MIB", "opathChannelSchedServCat"))
if mibBuilder.loadTexts: outputPathChannelSchedEntry.setStatus('current')
if mibBuilder.loadTexts: outputPathChannelSchedEntry.setDescription('A table of connection scheduling information on this output path.')
opathChannelSchedPort = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 5, 1, 1), Integer32())
if mibBuilder.loadTexts: opathChannelSchedPort.setStatus('current')
if mibBuilder.loadTexts: opathChannelSchedPort.setDescription('Index of this port')
opathChannelSchedVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 5, 1, 2), Integer32())
if mibBuilder.loadTexts: opathChannelSchedVPI.setStatus('current')
if mibBuilder.loadTexts: opathChannelSchedVPI.setDescription('The value of this object identifies the output VPI (Virtual Path Identifier) of this path.')
opathChannelSchedServCat = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 5, 1, 3), Integer32())
if mibBuilder.loadTexts: opathChannelSchedServCat.setStatus('current')
if mibBuilder.loadTexts: opathChannelSchedServCat.setDescription('Index of this service category within serviceCategoryTable')
opathChannelSchedSchedMode = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 5, 1, 4), AtmConnSchedMode()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: opathChannelSchedSchedMode.setStatus('current')
if mibBuilder.loadTexts: opathChannelSchedSchedMode.setDescription('The scheduling mode used for channels of type opathChannelSchedServCat within this path. The default choice of AtmConnSchedMode is not allowed at path level.')
opathChannelSchedSchedOverride = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 3, 5, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: opathChannelSchedSchedOverride.setStatus('current')
if mibBuilder.loadTexts: opathChannelSchedSchedOverride.setDescription('The override option used for channels of type opathChannelSchedServCat within this path')
channelTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 4, 1), )
if mibBuilder.loadTexts: channelTable.setStatus('current')
if mibBuilder.loadTexts: channelTable.setDescription('A table of information about the virtual channels passing through this ATM switch.')
channelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 4, 1, 1), ).setIndexNames((0, "Fore-Switch-MIB", "chanPort"), (0, "Fore-Switch-MIB", "chanVPI"), (0, "Fore-Switch-MIB", "chanVCI"))
if mibBuilder.loadTexts: channelEntry.setStatus('current')
if mibBuilder.loadTexts: channelEntry.setDescription('A table entry containing channel information.')
chanPort = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 4, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanPort.setStatus('current')
if mibBuilder.loadTexts: chanPort.setDescription('The value of this object identifies the input port of this channel and is the same as the pathPort and portNumber.')
chanVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 4, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanVPI.setStatus('current')
if mibBuilder.loadTexts: chanVPI.setDescription('The value of this object identifies the input VPI (Virtual Path Identifier) of this channel, and is the same as the pathVPI.')
chanVCI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 4, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanVCI.setStatus('current')
if mibBuilder.loadTexts: chanVCI.setDescription('The input VCI (Virtual Channel Identifier) of this channel.')
chanStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 4, 1, 1, 4), EntryStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: chanStatus.setStatus('current')
if mibBuilder.loadTexts: chanStatus.setDescription('The status of this channel entry.')
chanNumOutputs = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 4, 1, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanNumOutputs.setStatus('current')
if mibBuilder.loadTexts: chanNumOutputs.setDescription('The number of output ports to which this channel is routed.')
chanAllocBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 4, 1, 1, 6), Gauge32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: chanAllocBandwidth.setStatus('current')
if mibBuilder.loadTexts: chanAllocBandwidth.setDescription('The allocated bandwidth of this channel, in cells per second.')
chanUsedBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 4, 1, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanUsedBandwidth.setStatus('deprecated')
if mibBuilder.loadTexts: chanUsedBandwidth.setDescription('The bandwidth used on this channel, in cells per second.')
chanCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 4, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanCells.setStatus('current')
if mibBuilder.loadTexts: chanCells.setDescription('The number of cells transferred on this channel.')
chanUptime = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 4, 1, 1, 9), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanUptime.setStatus('current')
if mibBuilder.loadTexts: chanUptime.setDescription('The time since this channel was created, in hundredths of a second.')
chanSigProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 4, 1, 1, 10), AtmSigProtocol()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanSigProtocol.setStatus('current')
if mibBuilder.loadTexts: chanSigProtocol.setDescription('The signaling protocol that created this channel.')
chanRejectedCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 4, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanRejectedCells.setStatus('current')
if mibBuilder.loadTexts: chanRejectedCells.setDescription('The number of cells on this channel that were rejected (dropped) by the policer on the switch fabric. This does not include any cells that may have been tagged with CLP=1 by the policer, only cells that were discarded.')
chanCDV = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 4, 1, 1, 12), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: chanCDV.setStatus('current')
if mibBuilder.loadTexts: chanCDV.setDescription('The channel Cell Delay Variation Tolerance (CDV), specified in microseconds, indicates the time window in which a cell may be received on a channel and be accepted. A cell that is received on a channel outside the CDV window will be dropped or tagged, based on the value of chanPolicingAction. The chanCDV value overrides the default value inherited from the link.')
chanPolicingAction = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 4, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("tag", 1), ("drop", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: chanPolicingAction.setStatus('current')
if mibBuilder.loadTexts: chanPolicingAction.setDescription('This object indicates the action the switch will take in case of bandwidth violation on this channel.')
chanUpcContract = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 4, 1, 1, 14), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: chanUpcContract.setStatus('current')
if mibBuilder.loadTexts: chanUpcContract.setDescription('The UPC contract that will be used to police this channel. This is the number of the row in the upcContractTable.')
chanServCat = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 4, 1, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanServCat.setStatus('current')
if mibBuilder.loadTexts: chanServCat.setDescription('Index of this service category within serviceCategoryTable')
chanQosPoliceScheme = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 4, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("cbr1", 1), ("cbr0", 2), ("cbr0tag", 3), ("vbr1", 4), ("vbr2", 5), ("vbr3", 6), ("abr1", 7), ("ubr1", 8), ("ubr2", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanQosPoliceScheme.setStatus('current')
if mibBuilder.loadTexts: chanQosPoliceScheme.setDescription('It identifies the policing associated with the UPC contract as defined in the ATM Forum TM 4.0 specifications. However, the policing schemes cbr0 and cbr0tag are specific to FORE switches')
chanQosPCR = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 4, 1, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanQosPCR.setStatus('current')
if mibBuilder.loadTexts: chanQosPCR.setDescription('The peak cell rate (cells/sec)')
chanQosSCR = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 4, 1, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanQosSCR.setStatus('current')
if mibBuilder.loadTexts: chanQosSCR.setDescription('The sustained cell rate (cells/sec). It also holds the PCR0 value for cbr0 & cbr0tag contracts')
chanQosMBS = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 4, 1, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanQosMBS.setStatus('current')
if mibBuilder.loadTexts: chanQosMBS.setDescription('The maximum burst size (cells)')
chanQosCDVT = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 4, 1, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanQosCDVT.setStatus('current')
if mibBuilder.loadTexts: chanQosCDVT.setDescription('The channel Cell Delay Variation Tolerance (CDVT), specified in microseconds, indicates the time window in which a cell may be received on a channel and be accepted. A cell that is received on a channel outside the CDV window will be dropped or tagged, based on the value of chanPolicingAction. The chanCDV value overrides the default value inherited from the link.')
chanQosPoliceState = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 4, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanQosPoliceState.setStatus('current')
if mibBuilder.loadTexts: chanQosPoliceState.setDescription("Indicates if this connection is policed for traffic violations. When set to 'on' it overrides the policing status of the atm interface on which this connection is established.")
chanQosIsAAL5 = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 4, 1, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanQosIsAAL5.setStatus('current')
if mibBuilder.loadTexts: chanQosIsAAL5.setDescription('Indicates if this connection is AAL 5')
chanQosPerPacketPolicing = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 4, 1, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanQosPerPacketPolicing.setStatus('current')
if mibBuilder.loadTexts: chanQosPerPacketPolicing.setDescription('Should we perform AAL5 Partial Packet Policing on this UPC contract. This variable only has meaning if the connections is also AAL5.')
channelRouteTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 4, 2), )
if mibBuilder.loadTexts: channelRouteTable.setStatus('current')
if mibBuilder.loadTexts: channelRouteTable.setDescription('A table of information about the routing of channels through this ATM switch.')
channelRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 4, 2, 1), ).setIndexNames((0, "Fore-Switch-MIB", "chanrInputPort"), (0, "Fore-Switch-MIB", "chanrInputVPI"), (0, "Fore-Switch-MIB", "chanrInputVCI"), (0, "Fore-Switch-MIB", "chanrOutputPort"), (0, "Fore-Switch-MIB", "chanrOutputVPI"), (0, "Fore-Switch-MIB", "chanrOutputVCI"))
if mibBuilder.loadTexts: channelRouteEntry.setStatus('current')
if mibBuilder.loadTexts: channelRouteEntry.setDescription('A table entry containing channel route information.')
chanrInputPort = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 4, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanrInputPort.setStatus('current')
if mibBuilder.loadTexts: chanrInputPort.setDescription('The value of this object identifies the input port of this channel and is the same as the chanPort, pathPort, and portNumber.')
chanrInputVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 4, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanrInputVPI.setStatus('current')
if mibBuilder.loadTexts: chanrInputVPI.setDescription('The value of this object identifies the input VPI (Virtual Path Identifier) of this channel, and is the same as the chanVPI, and pathVPI.')
chanrInputVCI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 4, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanrInputVCI.setStatus('current')
if mibBuilder.loadTexts: chanrInputVCI.setDescription('The value of this object identifies the input VCI (Virtual Channel Identifier) of this channel, and is the same as chanVCI.')
chanrOutputPort = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 4, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanrOutputPort.setStatus('current')
if mibBuilder.loadTexts: chanrOutputPort.setDescription('The value of this object identifies the output port of this channel and is the same as the opathPort, and portNumber.')
chanrOutputVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 4, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanrOutputVPI.setStatus('current')
if mibBuilder.loadTexts: chanrOutputVPI.setDescription('The value of this object identifies the output VPI (Virtual Path Identifier) of this channel and is the same as the opathVPI.')
chanrOutputVCI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 4, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanrOutputVCI.setStatus('current')
if mibBuilder.loadTexts: chanrOutputVCI.setDescription('The output VCI (Virtual Channel Identifier) of this channel.')
chanrStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 4, 2, 1, 7), EntryStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: chanrStatus.setStatus('current')
if mibBuilder.loadTexts: chanrStatus.setDescription('The status of this channel entry.')
chanrSigProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 4, 2, 1, 8), AtmSigProtocol()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanrSigProtocol.setStatus('current')
if mibBuilder.loadTexts: chanrSigProtocol.setDescription('The signaling protocol that created this channel.')
chanrName = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 4, 2, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: chanrName.setStatus('current')
if mibBuilder.loadTexts: chanrName.setDescription(' The value of this object identifies the name that has been assigned for this channel.')
chanrConnectionType = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 4, 2, 1, 10), ConnectionType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: chanrConnectionType.setStatus('current')
if mibBuilder.loadTexts: chanrConnectionType.setDescription(' This object identifies the type of the channel endpoints with respect to a particular network.')
reverseChannelRouteTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 4, 3), )
if mibBuilder.loadTexts: reverseChannelRouteTable.setStatus('current')
if mibBuilder.loadTexts: reverseChannelRouteTable.setDescription('A table of information about reverse channel routes through this ATM switch.')
reverseChannelRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 4, 3, 1), ).setIndexNames((0, "Fore-Switch-MIB", "revChanrOutputPort"), (0, "Fore-Switch-MIB", "revChanrOutputVPI"), (0, "Fore-Switch-MIB", "revChanrOutputVCI"), (0, "Fore-Switch-MIB", "revChanrInputPort"), (0, "Fore-Switch-MIB", "revChanrInputVPI"), (0, "Fore-Switch-MIB", "revChanrInputVCI"))
if mibBuilder.loadTexts: reverseChannelRouteEntry.setStatus('current')
if mibBuilder.loadTexts: reverseChannelRouteEntry.setDescription('A table entry containing reverse channel route information.')
revChanrOutputPort = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 4, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: revChanrOutputPort.setStatus('current')
if mibBuilder.loadTexts: revChanrOutputPort.setDescription('The value of this object identifies the output port of this channel and is the same as the chanrOutputPort, opathPort and portNumber.')
revChanrOutputVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 4, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: revChanrOutputVPI.setStatus('current')
if mibBuilder.loadTexts: revChanrOutputVPI.setDescription('The value of this object identifies the output VPI (Virtual Path Identifier) of this channel and is the same as the chanrOutputVPI and opathVPI.')
revChanrOutputVCI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 4, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: revChanrOutputVCI.setStatus('current')
if mibBuilder.loadTexts: revChanrOutputVCI.setDescription('The output VCI (Virtual Channel Identifier) of this channel and is the same as chanrOutputVCI.')
revChanrInputPort = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 4, 3, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: revChanrInputPort.setStatus('current')
if mibBuilder.loadTexts: revChanrInputPort.setDescription('The value of this object identifies the input port of this channel and is the same as the chanPort, chanrInputPort, pathPort, and portNumber.')
revChanrInputVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 4, 3, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: revChanrInputVPI.setStatus('current')
if mibBuilder.loadTexts: revChanrInputVPI.setDescription('The value of this object identifies the input VPI (Virtual Path Identifier) of this channel, and is the same as the chanVPI, chanrInputVPI and pathVPI.')
revChanrInputVCI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 4, 3, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: revChanrInputVCI.setStatus('current')
if mibBuilder.loadTexts: revChanrInputVCI.setDescription('The value of this object identifies the input VCI (Virtual Channel Identifier) of this channel, and is the same as chanVCI and chanrInputVCI.')
revChanrSigProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 4, 3, 1, 7), AtmSigProtocol()).setMaxAccess("readonly")
if mibBuilder.loadTexts: revChanrSigProtocol.setStatus('current')
if mibBuilder.loadTexts: revChanrSigProtocol.setDescription('The signaling protocol that created this channel and is the same as chanrSigProtocol.')
outputChannelStatsTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 4, 4), )
if mibBuilder.loadTexts: outputChannelStatsTable.setStatus('current')
if mibBuilder.loadTexts: outputChannelStatsTable.setDescription('A table of statistics information about the virtual channels originating at this ATM switch.')
outputChannelStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 4, 4, 1), ).setIndexNames((0, "Fore-Switch-MIB", "ochanStatsPort"), (0, "Fore-Switch-MIB", "ochanStatsVPI"), (0, "Fore-Switch-MIB", "ochanStatsVCI"))
if mibBuilder.loadTexts: outputChannelStatsEntry.setStatus('current')
if mibBuilder.loadTexts: outputChannelStatsEntry.setDescription('A table entry containing originating channel statistics information.')
ochanStatsPort = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 4, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ochanStatsPort.setStatus('current')
if mibBuilder.loadTexts: ochanStatsPort.setDescription('The value of this object identifies the output port of this channel and is the same as the opathPort, and portNumber.')
ochanStatsVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 4, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ochanStatsVPI.setStatus('current')
if mibBuilder.loadTexts: ochanStatsVPI.setDescription('The value of this object identifies the output VPI (Virtual Path Identifier) of this channel and is the same as the opathVPI.')
ochanStatsVCI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 4, 4, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ochanStatsVCI.setStatus('current')
if mibBuilder.loadTexts: ochanStatsVCI.setDescription('The output VCI (Virtual Channel Identifier) of this channel.')
ochanStatsLostCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 4, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ochanStatsLostCells.setStatus('current')
if mibBuilder.loadTexts: ochanStatsLostCells.setDescription('The number of cells on this output channel that were dropped at the output netmod.')
ochanStatsTransmittedCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 4, 4, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ochanStatsTransmittedCells.setStatus('current')
if mibBuilder.loadTexts: ochanStatsTransmittedCells.setDescription('The number of cells on this output channel that were transmitted.')
ochanStatsIntentionalLostCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 4, 4, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ochanStatsIntentionalLostCells.setStatus('current')
if mibBuilder.loadTexts: ochanStatsIntentionalLostCells.setDescription('The number of cells on this output channel that were dropped intentionally.')
ochanStatsCLP0Cells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 4, 4, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ochanStatsCLP0Cells.setStatus('current')
if mibBuilder.loadTexts: ochanStatsCLP0Cells.setDescription('The number of CLP = 0 cells transmitted on this output path.')
ochanStatsLostPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 4, 4, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ochanStatsLostPackets.setStatus('current')
if mibBuilder.loadTexts: ochanStatsLostPackets.setDescription('The number of packets on this output path that were dropped at the output netmod.')
ochanStatsTransmittedPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 4, 4, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ochanStatsTransmittedPackets.setStatus('current')
if mibBuilder.loadTexts: ochanStatsTransmittedPackets.setDescription('The number of Packets on this output path that were transmitted.')
numberOfLinks = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 5, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: numberOfLinks.setStatus('current')
if mibBuilder.loadTexts: numberOfLinks.setDescription('Current number of links known by this ATM switch.')
linkTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 5, 2), )
if mibBuilder.loadTexts: linkTable.setStatus('current')
if mibBuilder.loadTexts: linkTable.setDescription("A table of links describing this switch's view of the ATM network topology.")
linkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 5, 2, 1), ).setIndexNames((0, "Fore-Switch-MIB", "linkSrc"), (0, "Fore-Switch-MIB", "linkDest"))
if mibBuilder.loadTexts: linkEntry.setStatus('current')
if mibBuilder.loadTexts: linkEntry.setDescription('A table entry containing link information.')
linkSrc = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 5, 2, 1, 1), SpansAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: linkSrc.setStatus('current')
if mibBuilder.loadTexts: linkSrc.setDescription('The ATM address of the source switch of this link.')
linkDest = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 5, 2, 1, 2), SpansAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: linkDest.setStatus('current')
if mibBuilder.loadTexts: linkDest.setDescription('The ATM address of the destination switch of this link.')
linkCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 5, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: linkCapacity.setStatus('current')
if mibBuilder.loadTexts: linkCapacity.setDescription('The free capacity of this link in kilobits per second.')
linkAge = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 5, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: linkAge.setStatus('current')
if mibBuilder.loadTexts: linkAge.setDescription('The freshness of this link information. The actual value has no units associated with it. It should be used for comparison.')
sigPathTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 1, 1), )
if mibBuilder.loadTexts: sigPathTable.setStatus('current')
if mibBuilder.loadTexts: sigPathTable.setDescription('A table of general information about the signaling path.')
sigPathEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 1, 1, 1), ).setIndexNames((0, "Fore-Switch-MIB", "sigPathPort"), (0, "Fore-Switch-MIB", "sigPathVPI"))
if mibBuilder.loadTexts: sigPathEntry.setStatus('current')
if mibBuilder.loadTexts: sigPathEntry.setDescription('A table entry containing signaling path information, indexed by port and path.')
sigPathPort = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sigPathPort.setStatus('current')
if mibBuilder.loadTexts: sigPathPort.setDescription('The value of this object identifies the port of this signalling path, and is the same as the portNumber.')
sigPathVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 1, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sigPathVPI.setStatus('current')
if mibBuilder.loadTexts: sigPathVPI.setDescription('The VPI (Virtual Path Identifier) of this signaling path.')
sigPathVCI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 1, 1, 1, 3), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sigPathVCI.setStatus('current')
if mibBuilder.loadTexts: sigPathVCI.setDescription('The VCI (Virtual Channel Identifier) of the signaling channel within the signaling path.')
sigPathClsVCI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 1, 1, 1, 4), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sigPathClsVCI.setStatus('current')
if mibBuilder.loadTexts: sigPathClsVCI.setDescription('The VCI (Virtual Channel Identifier) of the connectionless channel within the signaling path.')
sigPathAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sigPathAdminStatus.setStatus('current')
if mibBuilder.loadTexts: sigPathAdminStatus.setDescription('The desired state of this signaling channel. The up(1) state dictates that SPANS (Simple Protocol for ATM Network Siganlling) messages are used for signalling. The down(2) state dictates the SPANS protocol is not used for signalling.')
sigPathOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sigPathOperStatus.setStatus('current')
if mibBuilder.loadTexts: sigPathOperStatus.setDescription('The current operational state of this signaling channel, as determined either by administrative action, when the value of sigPathAdminStatus is down(2), or by a link monitoring protocol, when the value of sigPathAdminStatus is up(1).')
sigPathEntryStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 1, 1, 1, 7), EntryStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sigPathEntryStatus.setStatus('current')
if mibBuilder.loadTexts: sigPathEntryStatus.setDescription('The status of this signaling path entry.')
sigPathAALType = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("type34", 1), ("type5", 2), ("auto", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sigPathAALType.setStatus('current')
if mibBuilder.loadTexts: sigPathAALType.setDescription('The AAL (ATM Adaptation LAyer) type that is used by this signaling path.')
sigPathCDV = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 1, 1, 1, 9), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sigPathCDV.setStatus('current')
if mibBuilder.loadTexts: sigPathCDV.setDescription('The signalling path Cell Delay Variation (CDV) specified in microseconds, indicates the time window in which a cell may be received on a signalling channel and be accepted. A cell that is received on a channel outside the CDV window will be dropped. The sigPathCDV value overrides the default value of switchCDV.')
sigPathPolicingAction = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("tag", 1), ("drop", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sigPathPolicingAction.setStatus('current')
if mibBuilder.loadTexts: sigPathPolicingAction.setDescription('This object indicates the action the switch will take in case of bandwidth violation on a signalling channel. The value set here overrides the default value of switchPolicingAction.')
sigPathRemoteAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 1, 1, 1, 11), SpansAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sigPathRemoteAtmAddress.setStatus('current')
if mibBuilder.loadTexts: sigPathRemoteAtmAddress.setDescription('The ATM address of the entity connected to this signalling path.')
sigPathRemoteIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 1, 1, 1, 12), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sigPathRemoteIpAddress.setStatus('current')
if mibBuilder.loadTexts: sigPathRemoteIpAddress.setDescription('The IP address of the entity connected to this signalling path.')
sigPathType = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 1, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("uni", 1), ("nni", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sigPathType.setStatus('current')
if mibBuilder.loadTexts: sigPathType.setDescription('The type of the signalling path connection. uni(1) (User Network Interface) means that there is a host on remote side, while nni(2) (Network Network Interface) means there is another switch, that speaks SPANS, on the remote side.')
sigPathClsUpcContract = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 1, 1, 1, 14), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sigPathClsUpcContract.setStatus('current')
if mibBuilder.loadTexts: sigPathClsUpcContract.setDescription('The UPC contract that will be used to police the connectionless VC. This is the number of a row in the upcContractTable')
sigPathSigReservedBW = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 1, 1, 1, 15), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sigPathSigReservedBW.setStatus('current')
if mibBuilder.loadTexts: sigPathSigReservedBW.setDescription('Bandwidth reserved for the SPANS Signaling VC, in cells/sec.')
sigPathMinVCI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 1, 1, 1, 16), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sigPathMinVCI.setStatus('current')
if mibBuilder.loadTexts: sigPathMinVCI.setDescription('The minimum configured VCI (Virtual Channel Identifier) that can be used for SVCs (Signalled Virtual Circuits).')
sigPathMaxVCI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 1, 1, 1, 17), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sigPathMaxVCI.setStatus('current')
if mibBuilder.loadTexts: sigPathMaxVCI.setDescription('The maximum configured VCI (Virtual Channel Identifier) that can be used for SVCs (Signalled Virtual Circuits).')
sigPathOpenTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 1, 1, 1, 18), Integer32().clone(300)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sigPathOpenTimeout.setStatus('current')
if mibBuilder.loadTexts: sigPathOpenTimeout.setDescription('The timeout in msec for SPANS open requests. ')
sigPathCloseTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 1, 1, 1, 19), Integer32().clone(500)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sigPathCloseTimeout.setStatus('current')
if mibBuilder.loadTexts: sigPathCloseTimeout.setDescription('The timeout in msec for SPANS close requests.')
sigPathOutputSigService = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 1, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("vbr", 1), ("ubr", 2), ("oam", 3), ("default", 4))).clone('vbr')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sigPathOutputSigService.setStatus('current')
if mibBuilder.loadTexts: sigPathOutputSigService.setDescription('Service Queue where the output signalling vc should be inserted into.')
sigPathAALOperType = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 1, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("type34", 1), ("type5", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sigPathAALOperType.setStatus('current')
if mibBuilder.loadTexts: sigPathAALOperType.setDescription('The AAL (ATM Adaptation LAyer) type that is currently being used by this signaling path.')
sigPathStatsTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 1, 2), )
if mibBuilder.loadTexts: sigPathStatsTable.setStatus('current')
if mibBuilder.loadTexts: sigPathStatsTable.setDescription('A table of statistics about the signaling path.')
sigPathStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 1, 2, 1), ).setIndexNames((0, "Fore-Switch-MIB", "sigPathStatsPort"), (0, "Fore-Switch-MIB", "sigPathStatsVPI"))
if mibBuilder.loadTexts: sigPathStatsEntry.setStatus('current')
if mibBuilder.loadTexts: sigPathStatsEntry.setDescription('A table entry containing signaling path statistics, indexed by port and path.')
sigPathStatsPort = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 1, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sigPathStatsPort.setStatus('current')
if mibBuilder.loadTexts: sigPathStatsPort.setDescription('The value of this object identifies the port of this signalling path, and is the same as sigPathPort.')
sigPathStatsVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 1, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sigPathStatsVPI.setStatus('current')
if mibBuilder.loadTexts: sigPathStatsVPI.setDescription('The value of this object identifies the VPI (Virtual Path Identifier) of this signaling path statistics entry, and is the same as sigPathVPI.')
sigPathVCCs = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 1, 2, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sigPathVCCs.setStatus('current')
if mibBuilder.loadTexts: sigPathVCCs.setDescription('The number of Virtual Channel Connections (VCCs) on this signaling path.')
sigPathRestarts = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 1, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sigPathRestarts.setStatus('current')
if mibBuilder.loadTexts: sigPathRestarts.setDescription('The number of times the switch has lost and regained contact with the remote signaling entity on this path.')
sigPathCallsCompletions = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 1, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sigPathCallsCompletions.setStatus('current')
if mibBuilder.loadTexts: sigPathCallsCompletions.setDescription('The number of successfully completed calls on this signaling path.')
sigPathCallsFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 1, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sigPathCallsFailures.setStatus('current')
if mibBuilder.loadTexts: sigPathCallsFailures.setDescription('The number of call failures on this signaling path.')
sigPathCallsRejections = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 1, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sigPathCallsRejections.setStatus('current')
if mibBuilder.loadTexts: sigPathCallsRejections.setDescription('The number of connections on this signaling path that were rejected by the far end.')
sigPathSpansTransmittedMessages = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 1, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sigPathSpansTransmittedMessages.setStatus('current')
if mibBuilder.loadTexts: sigPathSpansTransmittedMessages.setDescription('The total number of SPANS messages that have been transmitted over this signalling path.')
sigPathSpansReceivedMessages = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 1, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sigPathSpansReceivedMessages.setStatus('current')
if mibBuilder.loadTexts: sigPathSpansReceivedMessages.setDescription('The total number of SPANS messages that have been received on this signalling path.')
sigPathClsTransmittedMessages = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 1, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sigPathClsTransmittedMessages.setStatus('current')
if mibBuilder.loadTexts: sigPathClsTransmittedMessages.setDescription('The total number of connectionless messages that have been transmitted over this signalling path.')
sigPathClsReceivedMessages = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 1, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sigPathClsReceivedMessages.setStatus('current')
if mibBuilder.loadTexts: sigPathClsReceivedMessages.setDescription('The total number of connectionless messages that have been received on this signalling path.')
spvcSrcNumberOfSPVCs = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: spvcSrcNumberOfSPVCs.setStatus('current')
if mibBuilder.loadTexts: spvcSrcNumberOfSPVCs.setDescription('The number of SPVCs (Smart Permanent Virtual Circuits) that are going out of this switch (i.e. this switch is their source).')
spvcSrcTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 1, 4), )
if mibBuilder.loadTexts: spvcSrcTable.setStatus('current')
if mibBuilder.loadTexts: spvcSrcTable.setDescription('This table contains information about SPVCs (Smart Permanent Virtual Circuits) that their source is this switch.')
spvcSrcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 1, 4, 1), ).setIndexNames((0, "Fore-Switch-MIB", "spvcSrcSpvcId"))
if mibBuilder.loadTexts: spvcSrcEntry.setStatus('current')
if mibBuilder.loadTexts: spvcSrcEntry.setDescription('A table entry containing source SPVC (Smart Permanent Virtual Circuits) information.')
spvcSrcSpvcId = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 1, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: spvcSrcSpvcId.setStatus('current')
if mibBuilder.loadTexts: spvcSrcSpvcId.setDescription('The value of this object uniquely identify the SPVC (Smart Permanent Virtual Circuits) that this switch is its source.')
spvcSrcSwitchAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 1, 4, 1, 2), SpansAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: spvcSrcSwitchAddr.setStatus('current')
if mibBuilder.loadTexts: spvcSrcSwitchAddr.setDescription('The ATM address of the source switch.')
spvcSrcDestSpvcId = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 1, 4, 1, 3), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: spvcSrcDestSpvcId.setStatus('current')
if mibBuilder.loadTexts: spvcSrcDestSpvcId.setDescription('The SPVC (Smart Permanent Virtual Circuits) identifier at the destination switch. This object should match the spvcDestSpvcId at the destination switch.')
spvcSrcDestSwitchAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 1, 4, 1, 4), SpansAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: spvcSrcDestSwitchAddr.setStatus('current')
if mibBuilder.loadTexts: spvcSrcDestSwitchAddr.setDescription('The ATM address of the destination switch.')
spvcSrcInPort = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 1, 4, 1, 5), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: spvcSrcInPort.setStatus('current')
if mibBuilder.loadTexts: spvcSrcInPort.setDescription('The value of this object identifies the input port of this SPVC (Smart Permanent Virtual Circuits), and is the same as the chanrInputPort, chanPort, pathPort, and portNumber.')
spvcSrcInVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 1, 4, 1, 6), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: spvcSrcInVPI.setStatus('current')
if mibBuilder.loadTexts: spvcSrcInVPI.setDescription('The value of this object identifies the input VPI (Virtual Path Identifier) of this SPVC (Smart Permanent Virtual Circuits), and is the same as the chanrInputVPI, chanVPI, pathVPI.')
spvcSrcInVCI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 1, 4, 1, 7), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: spvcSrcInVCI.setStatus('current')
if mibBuilder.loadTexts: spvcSrcInVCI.setDescription('The value of this object identifies the input VCI (Virtual Channel Identifier) of this SPVC (Smart Permanent Virtual Circuits), and is the same as the chanrInputVCI.')
spvcSrcAllocBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 1, 4, 1, 8), Gauge32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: spvcSrcAllocBandwidth.setStatus('current')
if mibBuilder.loadTexts: spvcSrcAllocBandwidth.setDescription('The allocated bandwidth of this SPVC (Smart Permanent Virtual Circuits).')
spvcSrcUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 1, 4, 1, 9), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: spvcSrcUpTime.setStatus('current')
if mibBuilder.loadTexts: spvcSrcUpTime.setDescription('The time since this SPVC (Smart Permanent Virtual Circuits) was created in hundredths of a second.')
spvcSrcStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 1, 4, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: spvcSrcStatus.setStatus('current')
if mibBuilder.loadTexts: spvcSrcStatus.setDescription('The status of this SPVC (Smart Permanent Virtual Circuits).')
spvcSrcEntryStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 1, 4, 1, 11), EntryStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: spvcSrcEntryStatus.setStatus('current')
if mibBuilder.loadTexts: spvcSrcEntryStatus.setDescription('The status of this SPVC (Smart Permanent Virtual Circuits) entry.')
spvcDestNumberOfSPVCs = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: spvcDestNumberOfSPVCs.setStatus('current')
if mibBuilder.loadTexts: spvcDestNumberOfSPVCs.setDescription('The number of SPVCs (Smart Permanent Virtual Circuits) that are coming into this switch (i.e. this switch is their destination).')
spvcDestTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 1, 6), )
if mibBuilder.loadTexts: spvcDestTable.setStatus('current')
if mibBuilder.loadTexts: spvcDestTable.setDescription('This table contains information about SPVCs (Smart Permanent Virtual Circuits) that their destination is this switch.')
spvcDestEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 1, 6, 1), ).setIndexNames((0, "Fore-Switch-MIB", "spvcDestSpvcId"))
if mibBuilder.loadTexts: spvcDestEntry.setStatus('current')
if mibBuilder.loadTexts: spvcDestEntry.setDescription('A table entry containing destination SPVC (Smart Permanent Virtual Circuits) information.')
spvcDestSpvcId = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 1, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: spvcDestSpvcId.setStatus('current')
if mibBuilder.loadTexts: spvcDestSpvcId.setDescription('The value of this object uniquely identify the SPVC (Smart Permanent Virtual Circuits) that this switch is its destination. The range of this object is [1..spvcDestNumberOfSPVCs].')
spvcDestSwitchAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 1, 6, 1, 2), SpansAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: spvcDestSwitchAddr.setStatus('current')
if mibBuilder.loadTexts: spvcDestSwitchAddr.setDescription('The ATM address of this (the destination) switch.')
spvcDestSrcSpvcId = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 1, 6, 1, 3), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: spvcDestSrcSpvcId.setStatus('current')
if mibBuilder.loadTexts: spvcDestSrcSpvcId.setDescription('The SPVC (Smart Permanent Virtual Circuits) identifier at the source switch. This object should match the spvcSrcSpvcId at the source switch.')
spvcDestSrcSwitchAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 1, 6, 1, 4), SpansAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: spvcDestSrcSwitchAddr.setStatus('current')
if mibBuilder.loadTexts: spvcDestSrcSwitchAddr.setDescription('The ATM address of the source switch.')
spvcDestOutPort = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 1, 6, 1, 5), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: spvcDestOutPort.setStatus('current')
if mibBuilder.loadTexts: spvcDestOutPort.setDescription('The value of this object identifies the output port of this SPVC (Smart Permanent Virtual Circuits) and is the same as the chanrOutputPort, opathPort, and portNumber.')
spvcDestOutVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 1, 6, 1, 6), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: spvcDestOutVPI.setStatus('current')
if mibBuilder.loadTexts: spvcDestOutVPI.setDescription('The value of this object identifies the output VPI (Virtual Path Identifier) of this SPVC (Smart Permanent Virtual Circuits), and is the same as the chanrOutputVPI, and opathVPI.')
spvcDestOutVCI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 1, 6, 1, 7), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: spvcDestOutVCI.setStatus('current')
if mibBuilder.loadTexts: spvcDestOutVCI.setDescription('The value of this object identifies the output VCI (Virtual Channel Identifier) of this SPVC (Smart Permanent Virtual Circuits), and is the same as the chanrOutputVCI.')
spvcDestAllocBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 1, 6, 1, 8), Gauge32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: spvcDestAllocBandwidth.setStatus('current')
if mibBuilder.loadTexts: spvcDestAllocBandwidth.setDescription('The allocated bandwidth of this SPVC (Smart Permanent Virtual Circuits).')
spvcDestUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 1, 6, 1, 9), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: spvcDestUpTime.setStatus('current')
if mibBuilder.loadTexts: spvcDestUpTime.setDescription('The time since this SPVC (Smart Permanent Virtual Circuits) was created in hundredths of a second.')
spvcDestStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 1, 6, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: spvcDestStatus.setStatus('current')
if mibBuilder.loadTexts: spvcDestStatus.setDescription('The status of this SPVC (Smart Permanent Virtual Circuits).')
spvcDestEntryStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 1, 6, 1, 11), EntryStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: spvcDestEntryStatus.setStatus('current')
if mibBuilder.loadTexts: spvcDestEntryStatus.setDescription('The status of this SPVC (Smart Permanent Virtual Circuits) entry.')
pnniSpvcSrcNumberOfSPVCs = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSpvcSrcNumberOfSPVCs.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcSrcNumberOfSPVCs.setDescription('The number of SPVCs (Smart Permanent Virtual Circuits) that have their source at this switch.')
pnniSpvcSrcTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 3), )
if mibBuilder.loadTexts: pnniSpvcSrcTable.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcSrcTable.setDescription('This table contains information about SPVCs (Smart Permanent Virtual Circuits) that have their source at this switch.')
pnniSpvcSrcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 3, 1), ).setIndexNames((0, "Fore-Switch-MIB", "pnniSpvcSrcIndex"))
if mibBuilder.loadTexts: pnniSpvcSrcEntry.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcSrcEntry.setDescription('A table entry containing source SPVC (Smart Permanent Virtual Circuits) information.')
pnniSpvcSrcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 3, 1, 1), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniSpvcSrcIndex.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcSrcIndex.setDescription('The value of this object uniquely identify the SPVCs (Smart Permanent Virtual Circuits) that have this switch as their source.')
pnniSpvcSrcCallingPort = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 3, 1, 2), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniSpvcSrcCallingPort.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcSrcCallingPort.setDescription('The value of this object identifies the input port of this SPVC (Smart Permanent Virtual Circuits), and is the same as the chanrInputPort, chanPort, pathPort, and portNumber.')
pnniSpvcSrcCallingVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 3, 1, 3), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniSpvcSrcCallingVPI.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcSrcCallingVPI.setDescription('The VPI to be used at the Calling NI for this SPVC.')
pnniSpvcSrcCallingVCI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 3, 1, 4), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniSpvcSrcCallingVCI.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcSrcCallingVCI.setDescription('The VCI to be used at the Calling NI SPVC.')
pnniSpvcSrcCalledAtmAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 3, 1, 5), NsapAddr()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniSpvcSrcCalledAtmAddr.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcSrcCalledAtmAddr.setDescription('The ATM address of the distant end NI (remote switch) for this SPVC.')
pnniSpvcSrcCalledPort = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 3, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSpvcSrcCalledPort.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcSrcCalledPort.setDescription('The value of this object identifies the port of this SPVC (Smart Permanent Virtual Circuits) at the destination end. It has a value of -1 if the port at the destination switch cannot be determined.')
pnniSpvcSrcCalledVPVCSel = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noPref", 1), ("require", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniSpvcSrcCalledVPVCSel.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcSrcCalledVPVCSel.setDescription('The Called VPI/VCI value selection qualifier.')
pnniSpvcSrcCalledVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 3, 1, 8), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniSpvcSrcCalledVPI.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcSrcCalledVPI.setDescription('The VPI to be used at the Called NI for this SPVC.')
pnniSpvcSrcCalledVCI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 3, 1, 9), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniSpvcSrcCalledVCI.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcSrcCalledVCI.setDescription('The VCI to be used at the Called NI for this SPVC.')
pnniSpvcSrcCalledAssignedVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 3, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSpvcSrcCalledAssignedVPI.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcSrcCalledAssignedVPI.setDescription('The VPI assigned at the Called NI for this SPVC. This value is only meaningful if the SPVC status is up.')
pnniSpvcSrcCalledAssignedVCI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 3, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSpvcSrcCalledAssignedVCI.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcSrcCalledAssignedVCI.setDescription('The VCI assigned at the Called NI for this SPVC. This value is only meaningful if the SPVC status is up.')
pnniSpvcSrcFwdUpcKey = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 3, 1, 12), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniSpvcSrcFwdUpcKey.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcSrcFwdUpcKey.setDescription('The forward UPC traffic contract key for this SPVC. This key must be defined in the upcContractTable.')
pnniSpvcSrcBckUpcKey = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 3, 1, 13), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniSpvcSrcBckUpcKey.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcSrcBckUpcKey.setDescription('The forward UPC traffic contract key for this SPVC. This key must be defined in the upcContractTable.')
pnniSpvcSrcBearerClass = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 3, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("classA", 1), ("classC", 2), ("classX", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniSpvcSrcBearerClass.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcSrcBearerClass.setDescription('The requested broadband bearer class for this SPVC.')
pnniSpvcSrcTrafficType = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 3, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noIndication", 1), ("cbr", 2), ("vbr", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniSpvcSrcTrafficType.setStatus('obsolete')
if mibBuilder.loadTexts: pnniSpvcSrcTrafficType.setDescription('The requested broadband bearer traffic type for this SPVC.')
pnniSpvcSrcTimingReq = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 3, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noIndication", 1), ("end2endRequired", 2), ("end2endNotReqd", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniSpvcSrcTimingReq.setStatus('obsolete')
if mibBuilder.loadTexts: pnniSpvcSrcTimingReq.setDescription('The requested broadband bearer timing requirements for this SPVC.')
pnniSpvcSrcSusceptClip = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 3, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniSpvcSrcSusceptClip.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcSrcSusceptClip.setDescription('The requested broadband bearer susceptability to for this SPVC.')
pnniSpvcSrcFwdQoSClass = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 3, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("class0", 1), ("class1", 2), ("class2", 3), ("class3", 4), ("class4", 5)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniSpvcSrcFwdQoSClass.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcSrcFwdQoSClass.setDescription('The requested quality of service for this SPVC in the forward (calling to called) direction.')
pnniSpvcSrcBckQoSClass = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 3, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("class0", 1), ("class1", 2), ("class2", 3), ("class3", 4), ("class4", 5)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniSpvcSrcBckQoSClass.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcSrcBckQoSClass.setDescription('The requested quality of service for this SPVC in the backward (called to calling) direction.')
pnniSpvcSrcTransitNetSel = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 3, 1, 20), TransitNetwork()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSpvcSrcTransitNetSel.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcSrcTransitNetSel.setDescription('The optional transit network selection for this SPVC.')
pnniSpvcSrcLastFailCause = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 3, 1, 21), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSpvcSrcLastFailCause.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcSrcLastFailCause.setDescription('The last call setup failure cause code for this SPVC.')
pnniSpvcSrcRetryCount = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 3, 1, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSpvcSrcRetryCount.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcSrcRetryCount.setDescription('The number of times the call setup has been attempted since the SPVC creation or the last successful call setup.')
pnniSpvcSrcLastChangeTime = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 3, 1, 23), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSpvcSrcLastChangeTime.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcSrcLastChangeTime.setDescription('The time since this SPVC (Smart Permanent Virtual Circuits) has been up/down in hundredths of a second.')
pnniSpvcSrcStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 3, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("failed", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSpvcSrcStatus.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcSrcStatus.setDescription('The operational status of this SPVC (Smart Permanent Virtual Circuit).')
pnniSpvcSrcName = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 3, 1, 25), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniSpvcSrcName.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcSrcName.setDescription(' The value of this object identifies the name that has been assigned for this SPVC.')
pnniSpvcSrcEntryStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 3, 1, 26), EntryStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniSpvcSrcEntryStatus.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcSrcEntryStatus.setDescription('The status of this SPVC (Smart Permanent Virtual Circuits) entry.')
pnniSpvcSrcRouteCost = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 3, 1, 27), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSpvcSrcRouteCost.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcSrcRouteCost.setDescription('The cumulative route cost for the current route of this SPVC (Smart Permanent Virtual Circuits).')
pnniSpvcSrcDtlIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 3, 1, 28), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniSpvcSrcDtlIndex.setStatus('obsolete')
if mibBuilder.loadTexts: pnniSpvcSrcDtlIndex.setDescription('The Designated Transit List (DTL) index for this SPVC (Smart Permanent Virtual Circuit). This variable has been deprecated. Any writes to this variable will be treated as writes to pnniSpvcSrcDtlIndex1. This value must be defined in the ftPnniDTLTable. The DTL specifies a preferred call routing for the SVC portion of the SPVC.')
pnniSpvcSrcActiveDtlIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 3, 1, 29), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSpvcSrcActiveDtlIndex.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcSrcActiveDtlIndex.setDescription('The Active Designated Transit List (DTL) index for this SPVC (Smart Permanent Virtual Circuit). This value along with pnniSpvcSrcActiveDtlNodeIndex uniquely identifies the DTL that is currently used by the SVC portion of the SPVC.')
pnniSpvcSrcRerouteStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 3, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniSpvcSrcRerouteStatus.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcSrcRerouteStatus.setDescription('The status of the reroute function for this SPVC (Smart Permanent Virtual Circuit). If set to disabled(2), no rerouting will be attempted for this SPVC.')
pnniSpvcSrcCallingDomain = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 3, 1, 31), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniSpvcSrcCallingDomain.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcSrcCallingDomain.setDescription('The Domain ID to be used at the Calling NI SPVC.')
pnniSpvcSrcQosIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 3, 1, 32), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniSpvcSrcQosIndex.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcSrcQosIndex.setDescription('The index for the QOS Class Expansion Table to be used for this spvc.')
pnniSpvcSrcDtlIndex1 = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 3, 1, 33), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniSpvcSrcDtlIndex1.setStatus('obsolete')
if mibBuilder.loadTexts: pnniSpvcSrcDtlIndex1.setDescription('The first Designated Transit List (DTL) index for this SPVC (Smart Permanent Virtual Circuit). This value must be defined in the ftPnniDTLTable. The DTL specifies a preferred call routing for the SVC portion of the SPVC.')
pnniSpvcSrcDtlIndex2 = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 3, 1, 34), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniSpvcSrcDtlIndex2.setStatus('obsolete')
if mibBuilder.loadTexts: pnniSpvcSrcDtlIndex2.setDescription('The second Designated Transit List (DTL) index for this SPVC (Smart Permanent Virtual Circuit). This value must be defined in the ftPnniDTLTable. The DTL specifies a preferred call routing for the SVC portion of the SPVC.')
pnniSpvcSrcDtlIndex3 = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 3, 1, 35), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniSpvcSrcDtlIndex3.setStatus('obsolete')
if mibBuilder.loadTexts: pnniSpvcSrcDtlIndex3.setDescription('The third Designated Transit List (DTL) index for this SPVC (Smart Permanent Virtual Circuit). This value must be defined in the ftPnniDTLTable. The DTL specifies a preferred call routing for the SVC portion of the SPVC.')
pnniSpvcSrcDtlIndex4 = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 3, 1, 36), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniSpvcSrcDtlIndex4.setStatus('obsolete')
if mibBuilder.loadTexts: pnniSpvcSrcDtlIndex4.setDescription('The fourth Designated Transit List (DTL) index for this SPVC (Smart Permanent Virtual Circuit). This value must be defined in the ftPnniDTLTable. The DTL specifies a preferred call routing for the SVC portion of the SPVC.')
pnniSpvcSrcDtlWeight1 = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 3, 1, 37), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniSpvcSrcDtlWeight1.setStatus('obsolete')
if mibBuilder.loadTexts: pnniSpvcSrcDtlWeight1.setDescription('The weight of the first Designated Transit List (DTL) index for this SPVC (Smart Permanent Virtual Circuit). The weight specifies the priority of this DTL index among the four DTL indices that can be specified for a particular SPVC.')
pnniSpvcSrcDtlWeight2 = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 3, 1, 38), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniSpvcSrcDtlWeight2.setStatus('obsolete')
if mibBuilder.loadTexts: pnniSpvcSrcDtlWeight2.setDescription('The weight of the second Designated Transit List (DTL) index for this SPVC (Smart Permanent Virtual Circuit). The weight specifies the priority of this DTL index among the four DTL indices that can be specified for a particular SPVC.')
pnniSpvcSrcDtlWeight3 = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 3, 1, 39), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniSpvcSrcDtlWeight3.setStatus('obsolete')
if mibBuilder.loadTexts: pnniSpvcSrcDtlWeight3.setDescription('The weight of the third Designated Transit List (DTL) index for this SPVC (Smart Permanent Virtual Circuit). The weight specifies the priority of this DTL index among the four DTL indices that can be specified for a particular SPVC.')
pnniSpvcSrcDtlWeight4 = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 3, 1, 40), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniSpvcSrcDtlWeight4.setStatus('obsolete')
if mibBuilder.loadTexts: pnniSpvcSrcDtlWeight4.setDescription('The weight of the fourth Designated Transit List (DTL) index for this SPVC (Smart Permanent Virtual Circuit). The weight specifies the priority of this DTL index among the four DTL indices that can be specified for a particular SPVC.')
pnniSpvcSrcBackoffStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 3, 1, 41), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniSpvcSrcBackoffStatus.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcSrcBackoffStatus.setDescription('The status of the backoff function for this SPVC (Smart Permanent Virtual Circuit). If set to disabled(2), directed dtls configured for this SPVC will be continually retried on failure.')
pnniSpvcSrcPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 3, 1, 42), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniSpvcSrcPriority.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcSrcPriority.setDescription('Priority of this SPVCC for connection')
pnniSpvcSrcLastLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 3, 1, 43), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSpvcSrcLastLocation.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcSrcLastLocation.setDescription('The last call setup failure location code for this SPVC. This indicates the switch that initiated the clearing for the call. This is formatted as a text string with the fields: FMT: Indicates diagnostic format RMT: Indicates whether a remote switch is the source of the failure or this switch inserted the location diag LINK:Link id that clear pertains to VPI: VPI that clear pertains to The remaining fields are format specific')
pnniSpvcSrcOldRouteCost = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 3, 1, 44), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSpvcSrcOldRouteCost.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcSrcOldRouteCost.setDescription('This OID is specified only to be included the the pnniSpvcUp trap. It specifies the path cost of the call the previous time this call was up. If the call has not been up, this will report a value of -1.')
pnniSpvcSrcDownReason = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 3, 1, 45), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("reroute", 1), ("failure", 2), ("deletion", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSpvcSrcDownReason.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcSrcDownReason.setDescription('This OID is specified only to be included the the pnniSpvccDown and pnniSpvccFail traps. This specifies whether the SPVC call was cleared due to a better route being found, a network failure, or SPVC deletion.')
pnniSpvcSrcActiveDtlNodeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 3, 1, 46), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSpvcSrcActiveDtlNodeIndex.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcSrcActiveDtlNodeIndex.setDescription('The Node index of the Active Designated Transit List for this SPVC (Smart Permanent Virtual Circuit). The active DTL indexed by the node index and DTL index identifies the DTL that is currently used by the SVC portion of the SPVC. The value of this object is 65535 for FTPNNI nodes.')
pnniSpvcSrcDtlTag = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 3, 1, 47), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniSpvcSrcDtlTag.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcSrcDtlTag.setDescription('This value specifies an index into a table of DTLs, the DTL entries in this table will be used to setup the SPVC.')
pnniSpvcSrcAutoDtlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 3, 1, 48), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniSpvcSrcAutoDtlStatus.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcSrcAutoDtlStatus.setDescription('The status of the dynamic path selection function for this SPVC (Smart Permanent Virtual Circuit). If set to disabled(2), auto path selection will not be used.')
pnniSpvcSrcRGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 3, 1, 49), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniSpvcSrcRGroupIndex.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcSrcRGroupIndex.setDescription('This specifies the entry in the Spvxc Redundancy Group table for information regarding the secondary port to be used as the redundant port')
pnniSpvcSrcSecondaryVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 3, 1, 50), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniSpvcSrcSecondaryVPI.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcSrcSecondaryVPI.setDescription('The Secondary VPI to be used at the originating switch for the redundant permanent portion of this SPVC. ')
pnniSpvcSrcSecondaryVCI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 3, 1, 51), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniSpvcSrcSecondaryVCI.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcSrcSecondaryVCI.setDescription('The Secondary VCI to be used at the originating switch for the redundant permanent portion of this SPVC.')
pnniSpvcDestNumberOfSPVCs = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSpvcDestNumberOfSPVCs.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcDestNumberOfSPVCs.setDescription('The number of connected SPVCs (Smart Permanent Virtual Circuits) that have their destination at this switch.')
pnniSpvcDestTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 5), )
if mibBuilder.loadTexts: pnniSpvcDestTable.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcDestTable.setDescription('This table contains information about SPVCs (Smart Permanent Virtual Circuits) that have their destination at this switch.')
pnniSpvcDestEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 5, 1), ).setIndexNames((0, "Fore-Switch-MIB", "pnniSpvcDestIndex"))
if mibBuilder.loadTexts: pnniSpvcDestEntry.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcDestEntry.setDescription('A table entry containing destination SPVC (Smart Permanent Virtual Circuits) information.')
pnniSpvcDestIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSpvcDestIndex.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcDestIndex.setDescription('The value of this object uniquely identify the SPVCs (Smart Permanent Virtual Circuits) that have this switch as their source.')
pnniSpvcDestCallingAtmAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 5, 1, 2), NsapAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSpvcDestCallingAtmAddr.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcDestCallingAtmAddr.setDescription('The ATM address of the local end NI (on this switch) for this SPVC.')
pnniSpvcDestCallingPort = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 5, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSpvcDestCallingPort.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcDestCallingPort.setDescription('The value of this object identifies the port of this terminating SPVC (Smart Permanent Virtual Circuits) at the source end. It has a value of -1 if the port at the destination switch cannot be determined.')
pnniSpvcDestCallingVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 5, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSpvcDestCallingVPI.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcDestCallingVPI.setDescription('The VPI to be used at the Calling NI for this SPVC.')
pnniSpvcDestCallingVCI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 5, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSpvcDestCallingVCI.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcDestCallingVCI.setDescription('The VCI to be used at the Calling NI for this SPVC.')
pnniSpvcDestCalledAtmAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 5, 1, 6), NsapAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSpvcDestCalledAtmAddr.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcDestCalledAtmAddr.setDescription('The ATM address of the distant end NI (remote switch) for this SPVC.')
pnniSpvcDestCalledPort = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 5, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSpvcDestCalledPort.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcDestCalledPort.setDescription('The value of this object identifies the port of this terminating SPVC (Smart Permanent Virtual Circuits) at the destination end. It has a value os -1 if the port at the destination switch cannot be determined.')
pnniSpvcDestAssignedVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 5, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSpvcDestAssignedVPI.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcDestAssignedVPI.setDescription('The VPI assigned at the Called NI for this SPVC. This value is only meaningful if the SPVC status is up.')
pnniSpvcDestAssignedVCI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 5, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSpvcDestAssignedVCI.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcDestAssignedVCI.setDescription('The VCI assigned at the Called NI for this SPVC. This value is only meaningful if the SPVC status is up.')
pnniSpvcDestBearerClass = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 5, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("classA", 1), ("classC", 2), ("classX", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSpvcDestBearerClass.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcDestBearerClass.setDescription('The broadband bearer class for this SPVC.')
pnniSpvcDestTrafficType = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 5, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noIndication", 1), ("cbr", 2), ("vbr", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSpvcDestTrafficType.setStatus('deprecated')
if mibBuilder.loadTexts: pnniSpvcDestTrafficType.setDescription('The broadband bearer traffic type for this SPVC.')
pnniSpvcDestTimingReq = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 5, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noIndication", 1), ("end2endRequired", 2), ("end2endNotReqd", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSpvcDestTimingReq.setStatus('deprecated')
if mibBuilder.loadTexts: pnniSpvcDestTimingReq.setDescription('The broadband bearer timing requirements for this SPVC.')
pnniSpvcDestSusceptClip = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 5, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSpvcDestSusceptClip.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcDestSusceptClip.setDescription('The broadband bearer susceptability to clipping for this SPVC.')
pnniSpvcDestUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 5, 1, 14), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSpvcDestUpTime.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcDestUpTime.setDescription('The time since this SPVC (Smart Permanent Virtual Circuits) was created in hundredths of a second.')
pnniSpvcDestFwdQoSClass = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 5, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("class0", 1), ("class1", 2), ("class2", 3), ("class3", 4), ("class4", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSpvcDestFwdQoSClass.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcDestFwdQoSClass.setDescription('The requested quality of service for this SPVC in the forward (calling to called) direction.')
pnniSpvcDestBckQoSClass = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 5, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("class0", 1), ("class1", 2), ("class2", 3), ("class3", 4), ("class4", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSpvcDestBckQoSClass.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcDestBckQoSClass.setDescription('The requested quality of service for this SPVC in the backward (called to calling) direction.')
pnniSpvcDestTransitNetSel = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 5, 1, 17), TransitNetwork()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSpvcDestTransitNetSel.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcDestTransitNetSel.setDescription('The optional transit network selection for this SPVC.')
pnniSpvcDestStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 5, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("failed", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSpvcDestStatus.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcDestStatus.setDescription('The operational status of this SPVC (Smart Permanent Virtual Circuit).')
pnniSpvcDestRGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 5, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSpvcDestRGroupIndex.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcDestRGroupIndex.setDescription('This specifies the entry in the Spvxc Redundancy Group table for information regarding the secondary port to be used as the redundant port. This will used at the terminating PVC end.')
pnniSpvcParamGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 7))
pnniSpvcPaceInterval = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 7, 1), TimeInterval().clone(200)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnniSpvcPaceInterval.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcPaceInterval.setDescription('The time interval between successive callbacks to the SPVC controller to open to the destinations of a batch of SPVCs')
pnniSpvcPaceNumSpvcs = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 7, 2), Integer32().clone(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnniSpvcPaceNumSpvcs.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcPaceNumSpvcs.setDescription('The max number of SPVCs that each batch of SPVCs that the SPVC controller tries to open to per pnniSpvcPaceInterval')
pnniSpvcRerouteInterval = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 7, 3), TimeInterval().clone(1000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnniSpvcRerouteInterval.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcRerouteInterval.setDescription('The time interval between successive callbacks to the SPVC controller to reroute existing SPVC connection if a better path is available to the destination')
pnniSpvcRerouteNumSpvcs = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 7, 4), Integer32().clone(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnniSpvcRerouteNumSpvcs.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcRerouteNumSpvcs.setDescription('The number of SPVCs that are attempted to be rerouted by the SPVC controller per pnniSpvcRerouteInterval')
pnniSpvcRerouteThreshold = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 7, 5), Integer32().clone(50)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnniSpvcRerouteThreshold.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcRerouteThreshold.setDescription('The percentage improvement in the cost that the new SPVC path must have over the current SPVC path before a reroute will be performed.')
pnniSpvcLowestPriority = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 7, 6), Integer32().clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnniSpvcLowestPriority.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcLowestPriority.setDescription('The value of lowest priority for SPVCCs')
pnniSpvcDefaultUbrBandwidth = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 7, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65534)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnniSpvcDefaultUbrBandwidth.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcDefaultUbrBandwidth.setDescription('The default bandwidth in Kilo-CPS to be used for UBR SPVCs')
pnniSpvcBackoffInterval = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 7, 9), TimeInterval().clone(60000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnniSpvcBackoffInterval.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcBackoffInterval.setDescription('The time interval to backoff a DTL that failed call setup. The DTL will not be used again until this interval has elapsed. The interval will not be applicable if backoff is disabled on the SPVC.')
pnniSpvcTrapMode = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 7, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("reroute", 1), ("failure", 2), ("all", 3), ("none", 4))).clone('reroute')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnniSpvcTrapMode.setStatus('current')
if mibBuilder.loadTexts: pnniSpvcTrapMode.setDescription('This configuration item specifies whether the switch should send the: spvcRerouteInitiated OR pnniSpvccUp and pnniSpvccFail OR pnniSpvccDown, pnniSpvccFail, and pnniSpvccUp traps.')
pnniPmpSpvcPartyPaceNum = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 7, 10), Integer32().clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnniPmpSpvcPartyPaceNum.setStatus('current')
if mibBuilder.loadTexts: pnniPmpSpvcPartyPaceNum.setDescription('The maximum number parties within a PMP SPVC that are activated per SpvcPacingInterval.')
pnniSpvpcParamGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 8))
pnniSpvpcPaceInterval = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 8, 1), TimeInterval().clone(200)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnniSpvpcPaceInterval.setStatus('current')
if mibBuilder.loadTexts: pnniSpvpcPaceInterval.setDescription('The time interval between successive callbacks to the SPVPC controller to open connections to the destinations of a batch of SPVPCs. This parameter along with pnniSpvpcPaceNumSpvpcs control the rate at which the SPVPCs that are down are established. Analogous SPVCC variable is pnniSpvcPaceInterval.')
pnniSpvpcPaceNumSpvpcs = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 8, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000)).clone(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnniSpvpcPaceNumSpvpcs.setStatus('current')
if mibBuilder.loadTexts: pnniSpvpcPaceNumSpvpcs.setDescription('The max number of SPVPCs that the SPVPC controller tries to activate per pnniSpvpcPaceInterval. This controls the rate at which SPVPCs that are down are established. The corresponding SPVCC variable is pnniSpvcPaceNumSpvcs.')
pnniSpvpcRerouteInterval = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 8, 3), TimeInterval().clone(1500)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnniSpvpcRerouteInterval.setStatus('current')
if mibBuilder.loadTexts: pnniSpvpcRerouteInterval.setDescription('The time interval between successive callbacks to the SPVPC controller to reroute existing SPVPC connections if a better path is available to the destination. This is one of the parameters that control the rate at which rerouting is attempted. The analogous SPVCC variable is pnniSpvcRerouteInterval.')
pnniSpvpcRerouteNumSpvpcs = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 8, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000)).clone(15)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnniSpvpcRerouteNumSpvpcs.setStatus('current')
if mibBuilder.loadTexts: pnniSpvpcRerouteNumSpvpcs.setDescription('The number of SPVPCs that are attempted to be rerouted by the SPVPC controller per pnniSpvpcRerouteInterval. Thus it determines the rerouting rate. The analogous SPVCC variable is pnniSpvcRerouteNumSpvcs.')
pnniSpvpcRerouteThreshold = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 8, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100)).clone(75)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnniSpvpcRerouteThreshold.setStatus('current')
if mibBuilder.loadTexts: pnniSpvpcRerouteThreshold.setDescription('The percentage improvement in the cost that the new SPVPC path must have over the current SPVPC path before a reroute will be performed. This is analogous to the pnniSpvcRerouteThreshold variable for SPVCCs.')
pnniSpvpcLowestPriority = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 8, 6), Integer32().clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnniSpvpcLowestPriority.setStatus('current')
if mibBuilder.loadTexts: pnniSpvpcLowestPriority.setDescription('The value of lowest priority for SPVPCs')
pnniSpvpcTrapMode = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 8, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("reroute", 1), ("failure", 2), ("all", 3), ("none", 4))).clone('reroute')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnniSpvpcTrapMode.setStatus('current')
if mibBuilder.loadTexts: pnniSpvpcTrapMode.setDescription('This configuration item specifies whether the switch should send the: spvcRerouteInitiated OR pnniSpvpcUp and pnniSpvpcFail OR pnniSpvpcDown, pnniSpvpcFail, and pnniSpvpcUp traps.')
pnniSpvpcBackoffInterval = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 8, 8), TimeInterval().clone(60000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnniSpvpcBackoffInterval.setStatus('current')
if mibBuilder.loadTexts: pnniSpvpcBackoffInterval.setDescription('The time interval to backoff a DTL that failed call setup. The DTL will not be used again until this interval has elapsed. The interval will not be applicable if backoff is disabled on the SPVPC.')
pnniSpvpcSrcTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 9), )
if mibBuilder.loadTexts: pnniSpvpcSrcTable.setStatus('current')
if mibBuilder.loadTexts: pnniSpvpcSrcTable.setDescription('This table contains information about SPVPCs (Smart Permanent Virtual Path Connections) that have their source at this switch. This table serves the same function that the pnniSpvcSrcTable serves for SPVCCs.')
pnniSpvpcSrcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 9, 1), ).setIndexNames((0, "Fore-Switch-MIB", "pnniSpvpcSrcIndex"))
if mibBuilder.loadTexts: pnniSpvpcSrcEntry.setStatus('current')
if mibBuilder.loadTexts: pnniSpvpcSrcEntry.setDescription('A table entry containing source SPVPC (Smart Permanent Virtual Path Connection) information.')
pnniSpvpcSrcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 9, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: pnniSpvpcSrcIndex.setStatus('current')
if mibBuilder.loadTexts: pnniSpvpcSrcIndex.setDescription('The value of this object uniquely identify the SPVPCs (Smart Permanent Virtual Path Connections) that have this switch as their source.')
pnniSpvpcSrcCallingPort = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 9, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1025))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniSpvpcSrcCallingPort.setStatus('current')
if mibBuilder.loadTexts: pnniSpvpcSrcCallingPort.setDescription('The value of this object identifies the input port of this SPVPC (Smart Permanent Virtual Path Connection), and is the same as the chanrInputPort, chanPort, pathPort, and portNumber. The maximum value of this variable depends on the type of the switch. The upper bound given is the highest possible as of now. In some switches the range will be much narrower.')
pnniSpvpcSrcCallingVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 9, 1, 3), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniSpvpcSrcCallingVPI.setStatus('current')
if mibBuilder.loadTexts: pnniSpvpcSrcCallingVPI.setDescription('The VPI to be used at the originating switch for the permanent portion of this SPVPC (Smart Permanent Virtual Path Connection).')
pnniSpvpcSrcCalledAtmAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 9, 1, 4), NsapAddr()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniSpvpcSrcCalledAtmAddr.setStatus('current')
if mibBuilder.loadTexts: pnniSpvpcSrcCalledAtmAddr.setDescription('The ATM address of the distant end NI (destination switch) for this SPVPC (Smart Permanent Virtual Path Connection). Distant end NI is the network interface at the destination switch at which the switched portion of this SPVPC terminates.')
pnniSpvpcSrcCalledPort = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 9, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSpvpcSrcCalledPort.setStatus('current')
if mibBuilder.loadTexts: pnniSpvpcSrcCalledPort.setDescription('The value of this object identifies the port where the permanent portion of this SPVPC (Smart Permanent Virtual Path Connection) resides at the destination switch. It has a value of -1 if this port at the destination switch cannot be determined.')
pnniSpvpcSrcCalledVPVCSel = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 9, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noPref", 1), ("require", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniSpvpcSrcCalledVPVCSel.setStatus('current')
if mibBuilder.loadTexts: pnniSpvpcSrcCalledVPVCSel.setDescription('The originating switch for a SPVPC can specify the VPI to be used for the permanent portion of this SPVPC at the destination switch. The value of this object indicates whether the SPVPC was configured with a specific value for this VPI or not. require(2) indicates that the user configured a specific value for this VPI and noPref(1) indicates that the user did not specify any.')
pnniSpvpcSrcCalledVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 9, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniSpvpcSrcCalledVPI.setStatus('current')
if mibBuilder.loadTexts: pnniSpvpcSrcCalledVPI.setDescription('The VPI to be used at the destination switch for the permanent portion of this SPVPC (Smart Permanent Virtual Path Connection). The range given above is the maximum possible. The upperbound varies with the type of netmod.')
pnniSpvpcSrcCalledAssignedVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 9, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSpvpcSrcCalledAssignedVPI.setStatus('current')
if mibBuilder.loadTexts: pnniSpvpcSrcCalledAssignedVPI.setDescription('The VPI that is assigned at the destination switch for the permanent portion of this SPVPC (Smart Permanent Virtual Path Connection). This value is only meaningful if the SPVPC status is up.')
pnniSpvpcSrcFwdUpcKey = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 9, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32767))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniSpvpcSrcFwdUpcKey.setStatus('current')
if mibBuilder.loadTexts: pnniSpvpcSrcFwdUpcKey.setDescription('The forward UPC traffic contract key for this SPVPC. This traffic contract will be used for the data traffic flow from the originating switch to the destination switch. This key must be defined in the upcContractTable.')
pnniSpvpcSrcBckUpcKey = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 9, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32767))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniSpvpcSrcBckUpcKey.setStatus('current')
if mibBuilder.loadTexts: pnniSpvpcSrcBckUpcKey.setDescription('The backward UPC traffic contract key for this SPVPC. This traffic contract will be used for the data flow in the direction from the destination switch to the originating switch. This key must be defined in the upcContractTable.')
pnniSpvpcSrcSusceptClip = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 9, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniSpvpcSrcSusceptClip.setStatus('current')
if mibBuilder.loadTexts: pnniSpvpcSrcSusceptClip.setDescription('The requested broadband bearer susceptibility to clipping for this SPVPC. This object will be used to fill the broadband bearer capability information element in the call setup message for this SPVPC.')
pnniSpvpcSrcFwdQoSClass = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 9, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("class0", 1), ("class1", 2), ("class2", 3), ("class3", 4), ("class4", 5)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniSpvpcSrcFwdQoSClass.setStatus('current')
if mibBuilder.loadTexts: pnniSpvpcSrcFwdQoSClass.setDescription('The requested quality of service class for this SPVPC in the forward (source to destination) direction. This determines the QoS objectives for the data path from the originating switch to the destination switch.')
pnniSpvpcSrcBckQoSClass = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 9, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("class0", 1), ("class1", 2), ("class2", 3), ("class3", 4), ("class4", 5)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniSpvpcSrcBckQoSClass.setStatus('current')
if mibBuilder.loadTexts: pnniSpvpcSrcBckQoSClass.setDescription('The requested quality of service class for this SPVPC in the backward (destination to source) direction. This object determines the QoS objectives for the data flow in the reverse direction (from the destination switch to the originating switch).')
pnniSpvpcSrcLastFailCause = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 9, 1, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSpvpcSrcLastFailCause.setStatus('current')
if mibBuilder.loadTexts: pnniSpvpcSrcLastFailCause.setDescription('The last call setup failure cause code for this SPVPC.')
pnniSpvpcSrcRetryCount = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 9, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSpvpcSrcRetryCount.setStatus('current')
if mibBuilder.loadTexts: pnniSpvpcSrcRetryCount.setDescription('The number of times the call setup has been attempted since the SPVPC creation or the last successful call setup for this SPVPC.')
pnniSpvpcSrcLastChangeTime = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 9, 1, 16), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSpvpcSrcLastChangeTime.setStatus('current')
if mibBuilder.loadTexts: pnniSpvpcSrcLastChangeTime.setDescription('The time since this SPVPC (Smart Permanent Virtual Path Connection) has been up/down in hundredths of a second.')
pnniSpvpcSrcStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 9, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSpvpcSrcStatus.setStatus('current')
if mibBuilder.loadTexts: pnniSpvpcSrcStatus.setDescription('The operational status of this SPVPC (Smart Permanent Virtual Path Connection). The value of up(1) indicates that this SPVPC is operational and down(2) indicates that the SPVPC is not-operational.')
pnniSpvpcSrcName = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 9, 1, 18), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniSpvpcSrcName.setStatus('current')
if mibBuilder.loadTexts: pnniSpvpcSrcName.setDescription('The value of this object identifies the name that has been assigned for this SPVPC.')
pnniSpvpcSrcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 9, 1, 19), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniSpvpcSrcRowStatus.setStatus('current')
if mibBuilder.loadTexts: pnniSpvpcSrcRowStatus.setDescription('The status of this SPVPC (Smart Permanent Virtual Path Connection) entry.')
pnniSpvpcSrcRouteCost = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 9, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSpvpcSrcRouteCost.setStatus('current')
if mibBuilder.loadTexts: pnniSpvpcSrcRouteCost.setDescription('The cumulative route cost for the current route of this SPVPC (Smart Permanent Virtual Path Connection).')
pnniSpvpcSrcRerouteStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 9, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniSpvpcSrcRerouteStatus.setStatus('current')
if mibBuilder.loadTexts: pnniSpvpcSrcRerouteStatus.setDescription('The status of the reroute function for this SPVPC (Smart Permanent Virtual Path Connection). If set to disabled(2), no rerouting will be attempted for this SPVPC.')
pnniSpvpcSrcCallingDomain = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 9, 1, 22), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniSpvpcSrcCallingDomain.setStatus('current')
if mibBuilder.loadTexts: pnniSpvpcSrcCallingDomain.setDescription('The Domain ID identifying the routing domain to be used at the Originating Switch for this SPVPC.')
pnniSpvpcSrcQosIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 9, 1, 23), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniSpvpcSrcQosIndex.setStatus('current')
if mibBuilder.loadTexts: pnniSpvpcSrcQosIndex.setDescription('The index for the QOS Class Expansion Table to be used for QoS class values into QoS parameter objectives for this SPVPC. The corresponding expansion table should be defined in the qosClassExpansionTable.')
pnniSpvpcSrcPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 9, 1, 24), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniSpvpcSrcPriority.setStatus('current')
if mibBuilder.loadTexts: pnniSpvpcSrcPriority.setDescription('Priority of this SPVPC for connection')
pnniSpvpcSrcLastLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 9, 1, 25), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSpvpcSrcLastLocation.setStatus('current')
if mibBuilder.loadTexts: pnniSpvpcSrcLastLocation.setDescription('The last call setup failure location code for this SPVPC. This indicates the switch that initiated the clearing for the call. This is formatted as a text string with the fields: FMT: Indicates diagnostic format RMT: Indicates whether a remote switch is the source of the failure or this switch inserted the location diag LINK:Link id that clear pertains to VPI: VPI that clear pertains to The remaining fields are format specific')
pnniSpvpcSrcOldRouteCost = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 9, 1, 26), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSpvpcSrcOldRouteCost.setStatus('current')
if mibBuilder.loadTexts: pnniSpvpcSrcOldRouteCost.setDescription('This OID is specified only to be included the the pnniSpvcUp trap. It specifies the path cost of the call the previous time this call was up. If the call has not been up, this will report a value of -1.')
pnniSpvpcSrcDownReason = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 9, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("reroute", 1), ("failure", 2), ("deletion", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSpvpcSrcDownReason.setStatus('current')
if mibBuilder.loadTexts: pnniSpvpcSrcDownReason.setDescription('This OID is specified only to be included the the pnniSpvccDown and pnniSpvccFail traps. This specifies whether the SPVC call was cleared due to a better route being found, a network failure, or SPVPC deletion.')
pnniSpvpcSrcBackoffStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 9, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniSpvpcSrcBackoffStatus.setStatus('current')
if mibBuilder.loadTexts: pnniSpvpcSrcBackoffStatus.setDescription('The status of the backoff function for this SPVC (Smart Permanent Virtual Path Circuit). If set to disabled(2), directed dtls configured for this SPVPC will be continually retried on failure.')
pnniSpvpcSrcActiveDtlIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 9, 1, 29), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSpvpcSrcActiveDtlIndex.setStatus('current')
if mibBuilder.loadTexts: pnniSpvpcSrcActiveDtlIndex.setDescription('The Active Designated Transit List (DTL) index for this SPVPC (Smart Permanent Virtual Path Circuit). This value along with pnniSpvcSrcActiveDtlNodeIndex uniquely identifies the DTL that is currently used by the SVC portion of the SPVPC.')
pnniSpvpcSrcActiveDtlNodeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 9, 1, 30), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSpvpcSrcActiveDtlNodeIndex.setStatus('current')
if mibBuilder.loadTexts: pnniSpvpcSrcActiveDtlNodeIndex.setDescription('The Node index of the Active Designated Transit List for this SPVPC (Smart Permanent Virtual Path Circuit). The active DTL indexed by the node index and DTL index identifies the DTL that is currently used by the SVC portion of the SPVPC. The value of this object is 65535 for FTPNNI nodes.')
pnniSpvpcSrcDtlTag = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 9, 1, 31), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniSpvpcSrcDtlTag.setStatus('current')
if mibBuilder.loadTexts: pnniSpvpcSrcDtlTag.setDescription('This value specifies an index into a table of DTLs, the DTL entries in this table will be used to setup the SPVPC.')
pnniSpvpcSrcAutoDtlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 9, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniSpvpcSrcAutoDtlStatus.setStatus('current')
if mibBuilder.loadTexts: pnniSpvpcSrcAutoDtlStatus.setDescription('The status of the dynamic path selection function for this SPVPC (Smart Permanent Virtual Path Circuit). If set to disabled(2), auto path selection will not be used.')
pnniSpvpcSrcRGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 9, 1, 33), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniSpvpcSrcRGroupIndex.setStatus('current')
if mibBuilder.loadTexts: pnniSpvpcSrcRGroupIndex.setDescription('This specifies the entry in the Spvxc Redundancy Group table for information regarding the secondary port to be used as the redundant port')
pnniSpvpcSrcSecondaryVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 9, 1, 34), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniSpvpcSrcSecondaryVPI.setStatus('current')
if mibBuilder.loadTexts: pnniSpvpcSrcSecondaryVPI.setDescription('The Secondary VPI to be used at the originating switch for the redundant permanent portion of this SPVPC. ')
pnniSpvpcStatsGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 10))
pnniSpvpcSrcNumberOfSPVPCs = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 10, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSpvpcSrcNumberOfSPVPCs.setStatus('current')
if mibBuilder.loadTexts: pnniSpvpcSrcNumberOfSPVPCs.setDescription('The number of SPVPCs (Smart Permanent Virtual Path Connections) that have their source at this switch. This object is analogous to the pnniSpvcSrcNumberOfSPVCs object defined for SPVCCs.')
pnniSpvpcDestNumberOfSPVPCs = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 10, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSpvpcDestNumberOfSPVPCs.setStatus('current')
if mibBuilder.loadTexts: pnniSpvpcDestNumberOfSPVPCs.setDescription('The number of connected SPVPCs (Smart Permanent Virtual Path Connections) that have their destination at this switch. This object is analogous to the pnniSpvcDestNumberOfSPVCs object for SPVCCs.')
pnniSpvpcDestTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 11), )
if mibBuilder.loadTexts: pnniSpvpcDestTable.setStatus('current')
if mibBuilder.loadTexts: pnniSpvpcDestTable.setDescription('This table contains information about SPVPCs (Smart Permanent Virtual Path Connections) that have their destination at this switch. This table provides the same functions that the pnniSpvcDestTable provides for SPVCCs.')
pnniSpvpcDestEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 11, 1), ).setIndexNames((0, "Fore-Switch-MIB", "pnniSpvpcDestIndex"))
if mibBuilder.loadTexts: pnniSpvpcDestEntry.setStatus('current')
if mibBuilder.loadTexts: pnniSpvpcDestEntry.setDescription('A table entry containing destination SPVPC (Smart Permanent Virtual Path Connection) information.')
pnniSpvpcDestIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 11, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSpvpcDestIndex.setStatus('current')
if mibBuilder.loadTexts: pnniSpvpcDestIndex.setDescription('The value of this object uniquely identifies the SPVPCs (Smart Permanent Virtual Path Connections) that have this switch as their destination.')
pnniSpvpcDestCallingAtmAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 11, 1, 2), NsapAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSpvpcDestCallingAtmAddr.setStatus('current')
if mibBuilder.loadTexts: pnniSpvpcDestCallingAtmAddr.setDescription('The ATM address of the calling end NI at the originating switch for this SPVPC (Smart Permanent Virtual Path Connection). Calling end NI is the network interface at the originating switch from which the switched portion of SPVPC originates.')
pnniSpvpcDestCallingPort = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 11, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1025))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSpvpcDestCallingPort.setStatus('current')
if mibBuilder.loadTexts: pnniSpvpcDestCallingPort.setDescription('The value of this object identifies the port of this terminating SPVPC (Smart Permanent Virtual Path Connection) at the source switch in which the permanent portion of the SPVPC resides. It has a value of -1 if the port at the source switch cannot be determined.')
pnniSpvpcDestCallingVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 11, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSpvpcDestCallingVPI.setStatus('current')
if mibBuilder.loadTexts: pnniSpvpcDestCallingVPI.setDescription('The VPI to be used at the originating switch for the permanent portion of this SPVPC.')
pnniSpvpcDestCalledAtmAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 11, 1, 5), NsapAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSpvpcDestCalledAtmAddr.setStatus('current')
if mibBuilder.loadTexts: pnniSpvpcDestCalledAtmAddr.setDescription('The ATM address of the local end NI (at this destination switch) for this SPVPC. Local end NI is network interface at this destination switch where the switched portion of this SPVPC terminates.')
pnniSpvpcDestCalledPort = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 11, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1025))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSpvpcDestCalledPort.setStatus('current')
if mibBuilder.loadTexts: pnniSpvpcDestCalledPort.setDescription('The value of this object identifies the port of this terminating SPVPC (Smart Permanent Virtual Path Connection) at this destination switch where the permanent portion of this SPVPC resides. It has a value of -1 if the port at the destination switch cannot be determined.')
pnniSpvpcDestAssignedVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 11, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSpvpcDestAssignedVPI.setStatus('current')
if mibBuilder.loadTexts: pnniSpvpcDestAssignedVPI.setDescription('The VPI assigned at this destination switch for the permanent portion of this SPVPC. This value is only meaningful if the SPVPC status is up.')
pnniSpvpcDestSusceptClip = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 11, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSpvpcDestSusceptClip.setStatus('current')
if mibBuilder.loadTexts: pnniSpvpcDestSusceptClip.setDescription('The value of this object identifies if the SPVPC was setup with the broadband bearer susceptibility to clipping set or not.')
pnniSpvpcDestUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 11, 1, 9), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSpvpcDestUpTime.setStatus('current')
if mibBuilder.loadTexts: pnniSpvpcDestUpTime.setDescription('The time since this SPVPC (Smart Permanent Virtual Path Connection) was created in hundredths of a second.')
pnniSpvpcDestFwdQoSClass = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 11, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("class0", 1), ("class1", 2), ("class2", 3), ("class3", 4), ("class4", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSpvpcDestFwdQoSClass.setStatus('current')
if mibBuilder.loadTexts: pnniSpvpcDestFwdQoSClass.setDescription('The requested quality of service class for this SPVPC in the direction from the source switch to the destination switch. This value determines the QoS parameter objectives for this SPVPC in that direction.')
pnniSpvpcDestBckQoSClass = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 11, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("class0", 1), ("class1", 2), ("class2", 3), ("class3", 4), ("class4", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSpvpcDestBckQoSClass.setStatus('current')
if mibBuilder.loadTexts: pnniSpvpcDestBckQoSClass.setDescription('The requested quality of service class for this SPVPC in the direction from the destination switch to the source switch. This value determines the QoS objectives for the data flow in that direction.')
pnniSpvpcDestStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 11, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSpvpcDestStatus.setStatus('current')
if mibBuilder.loadTexts: pnniSpvpcDestStatus.setDescription('The operational status of this SPVPC (Smart Permanent Virtual Path Connection). up(1) indicates that this SPVPC is operational while down(2) indicates that it is not.')
pnniSpvpcDestRGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 11, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSpvpcDestRGroupIndex.setStatus('current')
if mibBuilder.loadTexts: pnniSpvpcDestRGroupIndex.setDescription('This specifies the entry in the Spvxc Redundancy Group table for information regarding the secondary port to be used as the redundant port. This will used at the terminating PVC end.')
pnniPmpSpvccGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 12))
pnniPmpSpvccSrcNextRootIndex = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 12, 1), TestAndIncr()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnniPmpSpvccSrcNextRootIndex.setStatus('current')
if mibBuilder.loadTexts: pnniPmpSpvccSrcNextRootIndex.setDescription('The index of the next free root index in the pnniPmpSpvcSrcRootTable. Client is responsible for implementing a policy when a set on this variable fails. E.g. Keep testing this variable until a free index is found or choose a random number or a combination of the two.')
pnniPmpSpvccSrcNumberOfSpvccs = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 12, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniPmpSpvccSrcNumberOfSpvccs.setStatus('current')
if mibBuilder.loadTexts: pnniPmpSpvccSrcNumberOfSpvccs.setDescription('The number of PMP SPVCCs (Smart Permanent Virtual Circuits) that have their source at this switch.')
pnniPmpSpvccSrcRootTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 12, 3), )
if mibBuilder.loadTexts: pnniPmpSpvccSrcRootTable.setStatus('current')
if mibBuilder.loadTexts: pnniPmpSpvccSrcRootTable.setDescription('This table contains information about the root side of PMP SPVCCs (Smart Permanent Virtual Circuits) that have their source at this switch. It also contains the connection parameters that are common to all the parties')
pnniPmpSpvccSrcRootEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 12, 3, 1), ).setIndexNames((0, "Fore-Switch-MIB", "pnniPmpSpvccSrcRootIndex"))
if mibBuilder.loadTexts: pnniPmpSpvccSrcRootEntry.setStatus('current')
if mibBuilder.loadTexts: pnniPmpSpvccSrcRootEntry.setDescription('A table entry containing source PMP SPVCC (Smart Permanent Virtual Circuits) information.')
pnniPmpSpvccSrcRootIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 12, 3, 1, 1), Integer32())
if mibBuilder.loadTexts: pnniPmpSpvccSrcRootIndex.setStatus('current')
if mibBuilder.loadTexts: pnniPmpSpvccSrcRootIndex.setDescription('The value of this object uniquely identify the PMP SPVCCs (Smart Permanent Virtual Circuits) that have this switch as their source(root).')
pnniPmpSpvccSrcRootPort = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 12, 3, 1, 2), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniPmpSpvccSrcRootPort.setStatus('current')
if mibBuilder.loadTexts: pnniPmpSpvccSrcRootPort.setDescription('The value of this object identifies the input port of this PMP SPVCC (Smart Permanent Virtual Circuits), and is the same as the chanrInputPort, chanPort, pathPort, and portNumber.')
pnniPmpSpvccSrcRootVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 12, 3, 1, 3), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniPmpSpvccSrcRootVPI.setStatus('current')
if mibBuilder.loadTexts: pnniPmpSpvccSrcRootVPI.setDescription('The VPI to be used at the Calling(root) NI for this PMP SPVCC.')
pnniPmpSpvccSrcRootVCI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 12, 3, 1, 4), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniPmpSpvccSrcRootVCI.setStatus('current')
if mibBuilder.loadTexts: pnniPmpSpvccSrcRootVCI.setDescription('The VCI to be used at the Calling(root) NI for this PMP SPVCC.')
pnniPmpSpvccSrcRootFwdUpcKey = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 12, 3, 1, 5), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniPmpSpvccSrcRootFwdUpcKey.setStatus('current')
if mibBuilder.loadTexts: pnniPmpSpvccSrcRootFwdUpcKey.setDescription('The forward UPC traffic contract key for this PMP SPVCC. This key must be defined in the upcContractTable. Backward UPC traffic contract does not apply to PMP SPVCCs.')
pnniPmpSpvccSrcRootBearerClass = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 12, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("classA", 1), ("classC", 2), ("classX", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniPmpSpvccSrcRootBearerClass.setStatus('current')
if mibBuilder.loadTexts: pnniPmpSpvccSrcRootBearerClass.setDescription('The requested broadband bearer class for this PMP SPVCC.')
pnniPmpSpvccSrcRootSusceptClip = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 12, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniPmpSpvccSrcRootSusceptClip.setStatus('current')
if mibBuilder.loadTexts: pnniPmpSpvccSrcRootSusceptClip.setDescription('The requested broadband bearer susceptability to for this PMP SPVCC.')
pnniPmpSpvccSrcRootFwdQoSClass = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 12, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("class0", 1), ("class1", 2), ("class2", 3), ("class3", 4), ("class4", 5)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniPmpSpvccSrcRootFwdQoSClass.setStatus('current')
if mibBuilder.loadTexts: pnniPmpSpvccSrcRootFwdQoSClass.setDescription('The requested quality of service for this PMP SPVCC in the forward (calling to called) direction. Backward direction does not apply to PMP SPVCCs.')
pnniPmpSpvccSrcRootStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 12, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("wait", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniPmpSpvccSrcRootStatus.setStatus('current')
if mibBuilder.loadTexts: pnniPmpSpvccSrcRootStatus.setDescription('The operational status of this PMP SPVCC (Smart Permanent Virtual Circuit).')
pnniPmpSpvccSrcRootName = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 12, 3, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniPmpSpvccSrcRootName.setStatus('current')
if mibBuilder.loadTexts: pnniPmpSpvccSrcRootName.setDescription('The value of this object identifies the name that has been assigned for this PMP SPVCC.')
pnniPmpSpvccSrcRootPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 12, 3, 1, 11), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniPmpSpvccSrcRootPriority.setStatus('current')
if mibBuilder.loadTexts: pnniPmpSpvccSrcRootPriority.setDescription('Priority of this PMP SPVCC for connection. This priority is shared with any point-to-point SPVCCs configured on this switch.')
pnniPmpSpvccSrcRootNumberOfParties = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 12, 3, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniPmpSpvccSrcRootNumberOfParties.setStatus('current')
if mibBuilder.loadTexts: pnniPmpSpvccSrcRootNumberOfParties.setDescription('Number of parties currently configured with this PMP SPVCC')
pnniPmpSpvccSrcRootNextPartyIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 12, 3, 1, 13), TestAndIncr()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniPmpSpvccSrcRootNextPartyIndex.setStatus('current')
if mibBuilder.loadTexts: pnniPmpSpvccSrcRootNextPartyIndex.setDescription('This indicates the next allocatable party index')
pnniPmpSpvccSrcRootCallingDomain = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 12, 3, 1, 14), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniPmpSpvccSrcRootCallingDomain.setStatus('current')
if mibBuilder.loadTexts: pnniPmpSpvccSrcRootCallingDomain.setDescription('The Domain ID to be used at the Calling NI for this PMP SPVCC.')
pnniPmpSpvccSrcRootRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 12, 3, 1, 15), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniPmpSpvccSrcRootRowStatus.setStatus('current')
if mibBuilder.loadTexts: pnniPmpSpvccSrcRootRowStatus.setDescription('The status of this SPVCC (Smart Permanent Virtual Circuits) entry.')
pnniPmpSpvccSrcRootRGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 12, 3, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniPmpSpvccSrcRootRGroupIndex.setStatus('current')
if mibBuilder.loadTexts: pnniPmpSpvccSrcRootRGroupIndex.setDescription('This specifies the entry in the Spvxc Redundancy Group table for information regarding the secondary port to be used as the redundant port')
pnniPmpSpvccSrcRootSecondaryVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 12, 3, 1, 17), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniPmpSpvccSrcRootSecondaryVPI.setStatus('current')
if mibBuilder.loadTexts: pnniPmpSpvccSrcRootSecondaryVPI.setDescription('The Secondary VPI to be used at the originating switch for the redundant permanent portion of this SPVC. ')
pnniPmpSpvccSrcRootSecondaryVCI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 12, 3, 1, 18), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniPmpSpvccSrcRootSecondaryVCI.setStatus('current')
if mibBuilder.loadTexts: pnniPmpSpvccSrcRootSecondaryVCI.setDescription('The Secondary VCI to be used at the originating switch for the redundant permanent portion of this SPVC.')
pnniPmpSpvccSrcPartyTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 12, 4), )
if mibBuilder.loadTexts: pnniPmpSpvccSrcPartyTable.setStatus('current')
if mibBuilder.loadTexts: pnniPmpSpvccSrcPartyTable.setDescription('This table contains information about the parties of PMP SPVCCs (Smart Permanent Virtual Circuits) that have their source at this switch.')
pnniPmpSpvccSrcPartyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 12, 4, 1), ).setIndexNames((0, "Fore-Switch-MIB", "pnniPmpSpvccSrcRootIndex"), (0, "Fore-Switch-MIB", "pnniPmpSpvccSrcPartyIndex"))
if mibBuilder.loadTexts: pnniPmpSpvccSrcPartyEntry.setStatus('current')
if mibBuilder.loadTexts: pnniPmpSpvccSrcPartyEntry.setDescription('A table entry containing information about parties in a PMP SPVCC (Smart Permanent Virtual Circuits) at the source.')
pnniPmpSpvccSrcPartyIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 12, 4, 1, 1), Integer32())
if mibBuilder.loadTexts: pnniPmpSpvccSrcPartyIndex.setStatus('current')
if mibBuilder.loadTexts: pnniPmpSpvccSrcPartyIndex.setDescription("The value of this object uniquely identifies a party within a PMP SPVCC identified by pnniPmpSpvccSrcRootIndex. Root's parameters and commmon connection parameters for this party are availabe in pnniPmpSpvccSrcRootTable, indexed by pnniPmpSpvccSrcRootIndex.")
pnniPmpSpvccSrcPartyAtmAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 12, 4, 1, 2), NsapAddr()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniPmpSpvccSrcPartyAtmAddr.setStatus('current')
if mibBuilder.loadTexts: pnniPmpSpvccSrcPartyAtmAddr.setDescription('The ATM address of the distant end NI (remote switch) for this party.')
pnniPmpSpvccSrcPartyVPVCSel = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 12, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noPref", 1), ("require", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniPmpSpvccSrcPartyVPVCSel.setStatus('current')
if mibBuilder.loadTexts: pnniPmpSpvccSrcPartyVPVCSel.setDescription('The Called VPI/VCI value selection qualifier.')
pnniPmpSpvccSrcPartyVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 12, 4, 1, 4), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniPmpSpvccSrcPartyVPI.setStatus('current')
if mibBuilder.loadTexts: pnniPmpSpvccSrcPartyVPI.setDescription('The VPI to be used at the Called NI for this party.')
pnniPmpSpvccSrcPartyVCI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 12, 4, 1, 5), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniPmpSpvccSrcPartyVCI.setStatus('current')
if mibBuilder.loadTexts: pnniPmpSpvccSrcPartyVCI.setDescription('The VCI to be used at the Called NI for this party.')
pnniPmpSpvccSrcPartyAssignedVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 12, 4, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniPmpSpvccSrcPartyAssignedVPI.setStatus('current')
if mibBuilder.loadTexts: pnniPmpSpvccSrcPartyAssignedVPI.setDescription('The VPI assigned at the Called NI for this party. This value is only meaningful if the party status is up.')
pnniPmpSpvccSrcPartyAssignedVCI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 12, 4, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniPmpSpvccSrcPartyAssignedVCI.setStatus('current')
if mibBuilder.loadTexts: pnniPmpSpvccSrcPartyAssignedVCI.setDescription('The VCI assigned at the Called NI for this party. This value is only meaningful if the party status is up.')
pnniPmpSpvccSrcPartyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 12, 4, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("connecting", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniPmpSpvccSrcPartyStatus.setStatus('current')
if mibBuilder.loadTexts: pnniPmpSpvccSrcPartyStatus.setDescription('Operational status of this party in the PMP SPVCC.')
pnniPmpSpvccSrcPartyName = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 12, 4, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniPmpSpvccSrcPartyName.setStatus('current')
if mibBuilder.loadTexts: pnniPmpSpvccSrcPartyName.setDescription(' The value of this object identifies the name that has been assigned for this party.')
pnniPmpSpvccSrcPartyLastFailCause = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 12, 4, 1, 10), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniPmpSpvccSrcPartyLastFailCause.setStatus('current')
if mibBuilder.loadTexts: pnniPmpSpvccSrcPartyLastFailCause.setDescription('The last setup(addparty) failure cause code for this party.')
pnniPmpSpvccSrcPartyRetryCount = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 12, 4, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniPmpSpvccSrcPartyRetryCount.setStatus('current')
if mibBuilder.loadTexts: pnniPmpSpvccSrcPartyRetryCount.setDescription('The number of times the party setup/addparty has been attempted since the party creation or the last successful setup/addparty.')
pnniPmpSpvccSrcPartyLastChangeTime = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 12, 4, 1, 12), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniPmpSpvccSrcPartyLastChangeTime.setStatus('current')
if mibBuilder.loadTexts: pnniPmpSpvccSrcPartyLastChangeTime.setDescription('The time since this party has been up/down in hundredths of a second.')
pnniPmpSpvccSrcPartyFtDtlIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 12, 4, 1, 13), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniPmpSpvccSrcPartyFtDtlIndex.setStatus('current')
if mibBuilder.loadTexts: pnniPmpSpvccSrcPartyFtDtlIndex.setDescription('The Designated Transit List (DTL) index for this party. This value must be defined in the ftPnniDTLTable. The DTL specifies a preferred call routing for the SVC portion of the party. If a DTL is specified, this party will not be rerouted when rerouting is requested administratively. ')
pnniPmpSpvccSrcPartyRerouteStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 12, 4, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("rerouteNotRequested", 1), ("rerouteRequested", 2), ("rerouteCompleted", 3), ("rerouteNotApplicable", 4))).clone('rerouteNotRequested')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniPmpSpvccSrcPartyRerouteStatus.setStatus('current')
if mibBuilder.loadTexts: pnniPmpSpvccSrcPartyRerouteStatus.setDescription('The status of the reroute function for this party. Rerouting can be administratively requested, for active parties, by setting this variable to reroute_requested(2). On successful completion of rerouting, it will be set to reroute_completed(3). When a DTL is specified for a party, rerouting will not be performed for that party and this variable will set to reroute_not_applicable. ')
pnniPmpSpvccSrcPartyQosIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 12, 4, 1, 15), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniPmpSpvccSrcPartyQosIndex.setStatus('current')
if mibBuilder.loadTexts: pnniPmpSpvccSrcPartyQosIndex.setDescription('The index for the QOS Class Expansion Table to be used for this PMP SPVCC.')
pnniPmpSpvccSrcPartyRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 12, 4, 1, 16), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniPmpSpvccSrcPartyRowStatus.setStatus('current')
if mibBuilder.loadTexts: pnniPmpSpvccSrcPartyRowStatus.setDescription('The status of this party entry.')
pnniPmpSpvccSrcPartyLastLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 12, 4, 1, 17), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniPmpSpvccSrcPartyLastLocation.setStatus('current')
if mibBuilder.loadTexts: pnniPmpSpvccSrcPartyLastLocation.setDescription('The last call setup failure location code for this SPVC. This indicates the switch that initiated the clearing for the call. This is formatted as a text string with the fields: FMT: Indicates diagnostic format RMT: Indicates whether a remote switch is the source of the failure or this switch inserted the location diag LINK:Link id that clear pertains to VPI: VPI that clear pertains to The remaining fields are format specific')
pnniPmpSpvccSrcPartyAutoDtlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 12, 4, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniPmpSpvccSrcPartyAutoDtlStatus.setStatus('current')
if mibBuilder.loadTexts: pnniPmpSpvccSrcPartyAutoDtlStatus.setDescription('The status of the dynamic path selection function for this SPVC (Smart Permanent Virtual Circuit). If set to disabled(2), auto path selection will not be used.')
pnniPmpSpvccSrcPartyDownReason = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 12, 4, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("reroute", 1), ("failure", 2), ("deletion", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniPmpSpvccSrcPartyDownReason.setStatus('current')
if mibBuilder.loadTexts: pnniPmpSpvccSrcPartyDownReason.setDescription('The reason for the spvc down is set accordingly')
pnniPmpSpvccSrcPartyRouteCost = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 12, 4, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniPmpSpvccSrcPartyRouteCost.setStatus('current')
if mibBuilder.loadTexts: pnniPmpSpvccSrcPartyRouteCost.setDescription('The link cost associated for the party isset here')
pnniPmpSpvccDestNumberOfSpvccs = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 12, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniPmpSpvccDestNumberOfSpvccs.setStatus('current')
if mibBuilder.loadTexts: pnniPmpSpvccDestNumberOfSpvccs.setDescription('The number of connected PMP SPVCCs (Smart Permanent Virtual Circuits) that have their parties terminating at this switch.')
pnniPmpSpvccDestRootTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 12, 6), )
if mibBuilder.loadTexts: pnniPmpSpvccDestRootTable.setStatus('current')
if mibBuilder.loadTexts: pnniPmpSpvccDestRootTable.setDescription('This table contains information about the root of PMP SPVCCs (Smart Permanent Virtual Circuits) that have their parties terminating at this switch.')
pnniPmpSpvccDestRootEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 12, 6, 1), ).setIndexNames((0, "Fore-Switch-MIB", "pnniPmpSpvccDestRootIndex"))
if mibBuilder.loadTexts: pnniPmpSpvccDestRootEntry.setStatus('current')
if mibBuilder.loadTexts: pnniPmpSpvccDestRootEntry.setDescription('A table entry containing destination SPVCC (Smart Permanent Virtual Circuits) information.')
pnniPmpSpvccDestRootIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 12, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniPmpSpvccDestRootIndex.setStatus('current')
if mibBuilder.loadTexts: pnniPmpSpvccDestRootIndex.setDescription('The value of this object uniquely identifies the PMP SPVCCs (Smart Permanent Virtual Circuits) that has one or more parties terminating at this switch.')
pnniPmpSpvccDestRootAtmAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 12, 6, 1, 2), NsapAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniPmpSpvccDestRootAtmAddr.setStatus('current')
if mibBuilder.loadTexts: pnniPmpSpvccDestRootAtmAddr.setDescription('The ATM address of the root of the PMP SPVCC that has one or more parties terminating at this switch.')
pnniPmpSpvccDestRootPort = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 12, 6, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniPmpSpvccDestRootPort.setStatus('current')
if mibBuilder.loadTexts: pnniPmpSpvccDestRootPort.setDescription('The value of this object identifies the port of this terminating PMP SPVCC (Smart Permanent Virtual Circuits) at the source end. It has a value of -1 if the port at the destination switch cannot be determined.')
pnniPmpSpvccDestRootVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 12, 6, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniPmpSpvccDestRootVPI.setStatus('current')
if mibBuilder.loadTexts: pnniPmpSpvccDestRootVPI.setDescription('The VPI used for the PVCC portion of the connection at the root of the PMP SPVCC. The root switch is identified by pnniPmpSpvccDestCallingAtmAddr.')
pnniPmpSpvccDestRootVCI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 12, 6, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniPmpSpvccDestRootVCI.setStatus('current')
if mibBuilder.loadTexts: pnniPmpSpvccDestRootVCI.setDescription('The VCI used for the PVCC portion of the connection at the root of the PMP SPVCC. The root switch is identified by pnniPmpSpvccDestCallingAtmAddr.')
pnniPmpSpvccDestRootBearerClass = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 12, 6, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("classA", 1), ("classC", 2), ("classX", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniPmpSpvccDestRootBearerClass.setStatus('current')
if mibBuilder.loadTexts: pnniPmpSpvccDestRootBearerClass.setDescription('The broadband bearer class signalled for the first party of this PMP SPVCC. All subsequent parties should have the same value.')
pnniPmpSpvccDestRootSusceptClip = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 12, 6, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniPmpSpvccDestRootSusceptClip.setStatus('current')
if mibBuilder.loadTexts: pnniPmpSpvccDestRootSusceptClip.setDescription('The broadband bearer susceptability to clipping signalled for the first party of this PMP SPVCC. All subsequent parties should have the same value.')
pnniPmpSpvccDestRootFwdQoSClass = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 12, 6, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("class0", 1), ("class1", 2), ("class2", 3), ("class3", 4), ("class4", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniPmpSpvccDestRootFwdQoSClass.setStatus('current')
if mibBuilder.loadTexts: pnniPmpSpvccDestRootFwdQoSClass.setDescription('The requested quality of service for this PMP SPVCC in the forward (from root to leaves) direction. Backward QoS requirements do not apply to PMP SPVCCs.')
pnniPmpSpvccDestRootNumberOfParties = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 12, 6, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniPmpSpvccDestRootNumberOfParties.setStatus('current')
if mibBuilder.loadTexts: pnniPmpSpvccDestRootNumberOfParties.setDescription('Number of parties currently terminating at this switch within this PMP SPVCC')
pnniPmpSpvccDestPartyTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 12, 7), )
if mibBuilder.loadTexts: pnniPmpSpvccDestPartyTable.setStatus('current')
if mibBuilder.loadTexts: pnniPmpSpvccDestPartyTable.setDescription('This table contains information about the parties of PMP SPVCCs (Smart Permanent Virtual Circuits) that terminate at this switch.')
pnniPmpSpvccDestPartyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 12, 7, 1), ).setIndexNames((0, "Fore-Switch-MIB", "pnniPmpSpvccDestRootIndex"), (0, "Fore-Switch-MIB", "pnniPmpSpvccDestPartyIndex"))
if mibBuilder.loadTexts: pnniPmpSpvccDestPartyEntry.setStatus('current')
if mibBuilder.loadTexts: pnniPmpSpvccDestPartyEntry.setDescription('A table entry containing destination information about parties in a PMP SPVCC (Smart Permanent Virtual Circuits).')
pnniPmpSpvccDestPartyIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 12, 7, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniPmpSpvccDestPartyIndex.setStatus('current')
if mibBuilder.loadTexts: pnniPmpSpvccDestPartyIndex.setDescription('The value of this object uniquely identifies a party of PMP SPVCCs (Smart Permanent Virtual Circuits) that have one or more parties terminating at this switch. This value is unique within a PMP SPVCC represented by pnniPmpSpvccDestRootIndex')
pnniPmpSpvccDestPartyAtmAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 12, 7, 1, 2), NsapAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniPmpSpvccDestPartyAtmAddr.setStatus('current')
if mibBuilder.loadTexts: pnniPmpSpvccDestPartyAtmAddr.setDescription('The ATM address of the switch where this party of a PMP SPVCC terminates.')
pnniPmpSpvccDestPartyPort = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 12, 7, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniPmpSpvccDestPartyPort.setStatus('current')
if mibBuilder.loadTexts: pnniPmpSpvccDestPartyPort.setDescription('The value of this object identifies the port where this party of a PMP SPVCC (Smart Permanent Virtual Circuits) terminates.It has a value os -1 if the port at the destination switch cannot be determined.')
pnniPmpSpvccDestPartyAssignedVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 12, 7, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniPmpSpvccDestPartyAssignedVPI.setStatus('current')
if mibBuilder.loadTexts: pnniPmpSpvccDestPartyAssignedVPI.setDescription('The value of this object identifies the VPI assigned for this party of a PMP SPVCC (Smart Permanent Virtual Circuits) at the terminating switch. This value is only meaningful if the party status, identified by pnniPmpSpvccDestStatus, is up.')
pnniPmpSpvccDestPartyAssignedVCI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 12, 7, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniPmpSpvccDestPartyAssignedVCI.setStatus('current')
if mibBuilder.loadTexts: pnniPmpSpvccDestPartyAssignedVCI.setDescription('The value of this object identifies the VCI assigned for this party of a PMP SPVCC (Smart Permanent Virtual Circuits) at the terminating switch. This value is only meaningful if the party status, identified by pnniPmpSpvccDestStatus, is up.')
pnniPmpSpvccDestPartyUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 12, 7, 1, 6), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniPmpSpvccDestPartyUpTime.setStatus('current')
if mibBuilder.loadTexts: pnniPmpSpvccDestPartyUpTime.setDescription('The time since this party of PMP SPVCC (Smart Permanent Virtual Circuits) was created in hundredths of a second.')
pnniPmpSpvccDestPartyTransitNetSel = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 12, 7, 1, 7), TransitNetwork()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniPmpSpvccDestPartyTransitNetSel.setStatus('current')
if mibBuilder.loadTexts: pnniPmpSpvccDestPartyTransitNetSel.setDescription('The optional transit network selection for this party of PMP SPVCC.')
pnniPmpSpvccDestPartyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 12, 7, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("failed", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniPmpSpvccDestPartyStatus.setStatus('current')
if mibBuilder.loadTexts: pnniPmpSpvccDestPartyStatus.setDescription('The operational status of this party of PMP SPVCC (Smart Permanent Virtual Circuit).')
pnniPmpSpvccDestPartyRGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 12, 7, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniPmpSpvccDestPartyRGroupIndex.setStatus('current')
if mibBuilder.loadTexts: pnniPmpSpvccDestPartyRGroupIndex.setDescription('This specifies the entry in the Spvxc Redundancy Group table for information regarding the secondary port to be used as the redundant port. This will used at the terminating PVC end.')
pnniSpvxcRGroupTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 14), )
if mibBuilder.loadTexts: pnniSpvxcRGroupTable.setStatus('current')
if mibBuilder.loadTexts: pnniSpvxcRGroupTable.setDescription('A table of Primary to Secondary Port mappings that will be used for redundancy in permanent portion of SPVxCs. ')
pnniSpvxcRGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 14, 1), ).setIndexNames((0, "Fore-Switch-MIB", "pnniSpvxcRGroupIndex"))
if mibBuilder.loadTexts: pnniSpvxcRGroupEntry.setStatus('current')
if mibBuilder.loadTexts: pnniSpvxcRGroupEntry.setDescription('A table entry containing the primary to secondary port mappings.')
pnniSpvxcRGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 14, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: pnniSpvxcRGroupIndex.setStatus('current')
if mibBuilder.loadTexts: pnniSpvxcRGroupIndex.setDescription('The value of this object identifies the Group Index associated with this entry.')
pnniSpvxcRGroupPrimaryPort = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 14, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnniSpvxcRGroupPrimaryPort.setStatus('current')
if mibBuilder.loadTexts: pnniSpvxcRGroupPrimaryPort.setDescription('The value of this object identifies the primary port of this entry. This will used as the primary PVC port for the SPVC created with this group index. ')
pnniSpvxcRGroupSecondaryPort = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 14, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnniSpvxcRGroupSecondaryPort.setStatus('current')
if mibBuilder.loadTexts: pnniSpvxcRGroupSecondaryPort.setDescription('The value of this object identifies the secondary port of this group. This will used as the redundant PVC port for the SPVC created with this group index. During a switch command, the PVCs will be switched from primary port to this port.')
pnniSpvxcRGroupNsapAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 14, 1, 4), NsapAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSpvxcRGroupNsapAddr.setStatus('current')
if mibBuilder.loadTexts: pnniSpvxcRGroupNsapAddr.setDescription("This shows the default nsap address associated with this group using the default domain's prefix. This is a read-only variable available to view the default nsap address associated with this group.")
pnniSpvxcRGroupSwitchoverCmd = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 14, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("switch2primary", 1), ("switch2secondary", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnniSpvxcRGroupSwitchoverCmd.setStatus('current')
if mibBuilder.loadTexts: pnniSpvxcRGroupSwitchoverCmd.setDescription('The value of this MIB defines the switchover command. The value of 1 is used to switch over the permanent PVC portion to the primary port. The value of 2 is used to switch over the permanent PVC portion to the secondary port. If the permanent portions are already on the specified port, no action is taken ')
pnniSpvxcRGroupActivePort = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 14, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSpvxcRGroupActivePort.setStatus('current')
if mibBuilder.loadTexts: pnniSpvxcRGroupActivePort.setDescription('This specifies the port that is active. This can take any one of the primary or secondary port values. This is a read only variable useful to check the currently active port.')
pnniSpvxcRGroupPacingNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 14, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnniSpvxcRGroupPacingNumber.setStatus('current')
if mibBuilder.loadTexts: pnniSpvxcRGroupPacingNumber.setDescription('This specifies the pacing number for this group. During a pacing interval, pacing number of SPVCs will be attempted for PVC switch over. ')
pnniSpvxcRGroupPacingInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 14, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnniSpvxcRGroupPacingInterval.setStatus('current')
if mibBuilder.loadTexts: pnniSpvxcRGroupPacingInterval.setDescription('This specifies the pacing interval in units of milliseconds for this group. Every time a switchover command is issued, pacing number of SPVCs will be attempted for PVC switch over every Pacing Interval.')
pnniSpvxcRGroupAutoPVCSwitchover = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 14, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnniSpvxcRGroupAutoPVCSwitchover.setStatus('current')
if mibBuilder.loadTexts: pnniSpvxcRGroupAutoPVCSwitchover.setDescription('The value of this MIB defines if automatic switchover of the PVC portion is enable dor disabled. The default value is disabled(2).')
pnniSpvxcRGroupName = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 14, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnniSpvxcRGroupName.setStatus('current')
if mibBuilder.loadTexts: pnniSpvxcRGroupName.setDescription(' The value of this object identifies the name that has been assigned for this Rgroup.')
pnniSpvxcRGroupState = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 14, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("operational", 1), ("switchoverInProgress", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSpvxcRGroupState.setStatus('current')
if mibBuilder.loadTexts: pnniSpvxcRGroupState.setDescription('This specifies the state of the Redundancy Group. State operational(1) indicates that this group is in the normal state and switchover is not going on. State switchover_in_progress(2) indicates that switchover is presently going on for this group. In this state no new SPVCs can be added to this group.')
pnniSpvxcRGroupRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 14, 1, 12), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnniSpvxcRGroupRowStatus.setStatus('current')
if mibBuilder.loadTexts: pnniSpvxcRGroupRowStatus.setDescription('The status of this pnniSpvxcRGroup entry.')
q2931AdminTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1), )
if mibBuilder.loadTexts: q2931AdminTable.setStatus('current')
if mibBuilder.loadTexts: q2931AdminTable.setDescription('A table of general information about the Q2931 signaling path.')
q2931AdminEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1), ).setIndexNames((0, "Fore-Switch-MIB", "q2931AdminPort"), (0, "Fore-Switch-MIB", "q2931AdminVPI"))
if mibBuilder.loadTexts: q2931AdminEntry.setStatus('current')
if mibBuilder.loadTexts: q2931AdminEntry.setDescription('A table entry containing Q2931Admin signaling administration information, indexed by port and path.')
q2931AdminPort = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: q2931AdminPort.setStatus('current')
if mibBuilder.loadTexts: q2931AdminPort.setDescription('The value of this object identifies the port of this signalling path, and is the same as the portNumber.')
q2931AdminVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: q2931AdminVPI.setStatus('current')
if mibBuilder.loadTexts: q2931AdminVPI.setDescription('The VPI (Virtual Path Identifier) of this signaling path.')
q2931AdminVCI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 3), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: q2931AdminVCI.setStatus('current')
if mibBuilder.loadTexts: q2931AdminVCI.setDescription('The VCI (Virtual Channel Identifier) of the signaling channel within the signaling path.')
q2931AdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: q2931AdminStatus.setStatus('current')
if mibBuilder.loadTexts: q2931AdminStatus.setDescription('The desired state of this signaling channel. The up(1) state dictates that Q2931 messages are used for signalling. The down(2) state dictates that Q2931 protocol is not used for signalling.')
q2931OperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: q2931OperStatus.setStatus('current')
if mibBuilder.loadTexts: q2931OperStatus.setDescription('The current operational state of this signaling channel, as determined either by administrative action, when the value of q2931AdminStatus is down(2), or by a link monitoring protocol, when the value of q2931AdminStatus is up(1).')
q2931SSCOPOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: q2931SSCOPOperStatus.setStatus('current')
if mibBuilder.loadTexts: q2931SSCOPOperStatus.setDescription("The current operational state of the underlying SSCOP (Service Specific Connection Orientedd Protocol) on this channel. SSCOP's function is to provide a reliable data link layer for the exchange of Q.2931 signalling messages. The value up(1) reflects the value dataTransReady(4) for the SSCOPOperStatus object in the SSCOP Administration table (sscopAdminTable). All other values of that object are reflected as the value down(2) for this object.")
q2931ILMIAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: q2931ILMIAdminStatus.setStatus('current')
if mibBuilder.loadTexts: q2931ILMIAdminStatus.setDescription('The desired state of the underlying ILMI (Interim Local Manageemnt Interface) status and configuration channel. The up(1) state dictates that ILMI messages are used for status and configuration information. The down(2) state dictates that ILMI protocol is not used.')
q2931ILMIOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: q2931ILMIOperStatus.setStatus('current')
if mibBuilder.loadTexts: q2931ILMIOperStatus.setDescription('The current operational state of the underlying ILMI (Interim Local Manageemnt Interface) status and configuration channel, as determined either by administrative action, when the value of q2931ILMIAdminStatus is down(2), or by a link monitoring protocol, when the value of q2931ILMIAdminStatus is up(1).')
q2931AdminAALType = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("type34", 1), ("type5", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: q2931AdminAALType.setStatus('current')
if mibBuilder.loadTexts: q2931AdminAALType.setDescription('The AAL (ATM Adaptation Layer) type that is used by this Q2931 signaling path.')
q2931AdminUNISide = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("user", 1), ("network", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: q2931AdminUNISide.setStatus('current')
if mibBuilder.loadTexts: q2931AdminUNISide.setDescription('This object detemines the role this port takes in the UNI (User Network Interface). If this port is connected to a host via the private UNI, this port is on the network(2) side of the UNI, whilst if this port is connected to the Public UNI the port may be required to be the user(1) side of the connection.')
q2931AdminConfigType = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("publicUNI", 1), ("automode", 2), ("iisp", 3), ("ftPNNI", 4), ("privateNNI", 5), ("privateUNI", 6)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: q2931AdminConfigType.setStatus('current')
if mibBuilder.loadTexts: q2931AdminConfigType.setDescription('The configuration of the UNI (User Network Interface) at initialization. Configuring the UNI to publicUNI(1) means that this link will be used between the switch and a public switch. Configuring the UNI to automode(2) means that the operational type will be determined dynamically. Configuring the UNI to iisp(3) (Interim Inter-Switch Signalling Protocol) indicates that this link is used for static routing NNI (Network to Network Interface). Configuring the type to privateNNI allows the interface to come up as PNNI type and running the PNNI routing protocol. Configuring the type as privateUNI indicates that the interface should comeup as a user-network interface UNI.')
q2931AdminOperType = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("publicUNI", 1), ("privateUNI", 2), ("iisp", 3), ("ftPNNI", 4), ("privateNNI", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: q2931AdminOperType.setStatus('current')
if mibBuilder.loadTexts: q2931AdminOperType.setDescription('The operational configuration of the UNI (User Network Interface). publicUNI(1) is used between the switch and a public switch. privateUNI(2) is used between the switch and a host. IISP, iisp(3), stands for Interim Inter-Switch Signalling Protocol, is used between two switches using static routing. And spansNNI(4) is used between two switches using SPANS mapping messages for dynamic routing. If the q2931AdminConfigType is set to auto(2), the value of this object may be either privateUNI(2), or spansNNI(4).')
q2931AdminEntryStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 13), EntryStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: q2931AdminEntryStatus.setStatus('current')
if mibBuilder.loadTexts: q2931AdminEntryStatus.setDescription('The status of this signaling path entry. Setting this object to invalid(4) causes the q2931 path to be destroyed.')
q2931AdminRemoteIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 14), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: q2931AdminRemoteIpAddress.setStatus('current')
if mibBuilder.loadTexts: q2931AdminRemoteIpAddress.setDescription('The IP address of the entity connected to this q2931 signalling path. The remote IP address is derived using ILMI on this interface.')
q2931SigReservedBW = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 15), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: q2931SigReservedBW.setStatus('deprecated')
if mibBuilder.loadTexts: q2931SigReservedBW.setDescription('Bandwidth reserved for the UNI Signaling VC, in cells/sec.')
q2931ILMIReservedBW = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 16), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: q2931ILMIReservedBW.setStatus('deprecated')
if mibBuilder.loadTexts: q2931ILMIReservedBW.setDescription('Bandwidth reserved for the UNI ILMI VC, in cells/sec.')
q2931ILMIAdminVCI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 17), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: q2931ILMIAdminVCI.setStatus('current')
if mibBuilder.loadTexts: q2931ILMIAdminVCI.setDescription('The VCI (Virtual Channel Identifier) of the ILMI signalling channel.')
q2931AdminMinVCI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 18), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: q2931AdminMinVCI.setStatus('current')
if mibBuilder.loadTexts: q2931AdminMinVCI.setDescription('The minimum configured VCI (Virtual Channel Identifier) used for SVCs (Signalling Virtual Circuits).')
q2931AdminMaxVCI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 19), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: q2931AdminMaxVCI.setStatus('current')
if mibBuilder.loadTexts: q2931AdminMaxVCI.setDescription('The maximum configured VCI (Virtual Channel Identifier) used for SVCs (Signalling Virtual Circuits).')
q2931MinVCI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: q2931MinVCI.setStatus('current')
if mibBuilder.loadTexts: q2931MinVCI.setDescription('The minimum actual VCI (Virtual Channel Identifier) used for SVCs (Signalling Virtual Circuits).')
q2931MaxVCI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: q2931MaxVCI.setStatus('current')
if mibBuilder.loadTexts: q2931MaxVCI.setDescription('The maximum actual VCI (Virtual Channel Identifier) used for SVCs (Signalling Virtual Circuits).')
q2931UNIConfigVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("auto", 1), ("uni30", 2), ("uni31", 3), ("pnni10", 4), ("uni40", 5)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: q2931UNIConfigVersion.setStatus('current')
if mibBuilder.loadTexts: q2931UNIConfigVersion.setDescription('The configuration version of the UNI protocol to use at initialization. Configuring the UNI to auto(1), means that the UNI will attempt to automatically determine which version of the UNI protocol to use by reading the value of ILMI variable atmfAtmLayerUniVersion. Configuring the UNI to uni30(2) means that this link will use version 30 of the UNI protocol, likewise for uni31(3). If the nni interface has to be brought up as pnni then pnni10 version isspecified. To bring the interface as uni40 version then sepcify uni40.')
q2931UNIOperVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("auto", 0), ("uni30", 1), ("uni31", 2), ("pnni10", 3), ("uni40", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: q2931UNIOperVersion.setStatus('current')
if mibBuilder.loadTexts: q2931UNIOperVersion.setDescription('The version of the UNI that is currently being used on this link, i.e. the operational version of the UNI.')
q2931ILMIRegistration = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("ignore", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: q2931ILMIRegistration.setStatus('current')
if mibBuilder.loadTexts: q2931ILMIRegistration.setDescription('Whether to do ILMI Address and Prefix Registration across this UNI. If disabled, no prefix registration messages are sent by the network-side, and no address registration messages are generated by the user-side. If set to ignore, then the network-side performs as it normally would, except that addresses registered are not published into the routing database. This setting is not recommended except in Public Network situations where CPE equipment requires ILMI Address registration in order to function correctly. The default value of this variable is different depending on the type of UNI being created. If creating a public UNI, this variable defaults to disable, while it defaults to enable for all other types.')
q2931CallingPDefaultAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 25), NsapAddr()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: q2931CallingPDefaultAddress.setStatus('current')
if mibBuilder.loadTexts: q2931CallingPDefaultAddress.setDescription('The calling party address to be inserted in Connection Setup messages which do not contain Calling Party Addresses.')
q2931AdminUseNativeE164 = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: q2931AdminUseNativeE164.setStatus('current')
if mibBuilder.loadTexts: q2931AdminUseNativeE164.setDescription('Whether to use Native Form of E164 Addresses across this link. Used by Public UNI.')
q2931AdminNativeE164Address = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 27), E164Address()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: q2931AdminNativeE164Address.setStatus('current')
if mibBuilder.loadTexts: q2931AdminNativeE164Address.setDescription('Native E164 Address for this uni. ')
q2931AdminE164AddressResolution = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: q2931AdminE164AddressResolution.setStatus('current')
if mibBuilder.loadTexts: q2931AdminE164AddressResolution.setDescription('Whether to resolve Private NSAPs into Native E164 addresses (using the Q2931E164AddrResTable). If disabled, but if q2931AdminUseNativeE164 is enabled, then the only address conversion performed at this UNI will be of Private NSAPs in E.164 format.')
q2931AdminFtPnniOrigCost = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 29), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: q2931AdminFtPnniOrigCost.setStatus('deprecated')
if mibBuilder.loadTexts: q2931AdminFtPnniOrigCost.setDescription('The cost of each pnni orig loglink. It is configured at originating end of sigpath')
q2931AdminFtPnniTermCost = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 30), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: q2931AdminFtPnniTermCost.setStatus('deprecated')
if mibBuilder.loadTexts: q2931AdminFtPnniTermCost.setDescription('The cost of each pnni term loglink. The originating side of a link informs the terminating side of the configured q2931AdminFtPnniOrigCost in a hello message. The terminating side then uses the cost value in the hello message as the q2931AdminFtPnniTermCost for topology advertisement.')
q2931AdminAVPresentation = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 31), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: q2931AdminAVPresentation.setStatus('deprecated')
if mibBuilder.loadTexts: q2931AdminAVPresentation.setDescription('The set of Address Validation interface options as follows: (The bits in this integer have the following meanings:) Bit Significance Default ======== ============= ======== 0x0001 Address Validation Enabled disabled 0x0002 insertCallingPDefaultAddress disabled 0x0004 CallingP_delivery enabled 0x0008 CallingPSubAddr_trxf enabled 0x0010 CalledPSubAddr_trxf enabled 0x0020 BHLI_TRXF enabled 0x0040 BLLI_TRXF enabled 0x0080 BLLI_selection_TRXF enabled 0x0100 AAL_INFO_TRXF enabled --- Not used presently. ---- ')
q2931AdminSigMode = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("vpAssoc", 1), ("nonAssoc", 2), ("auto", 3))).clone('auto')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: q2931AdminSigMode.setStatus('current')
if mibBuilder.loadTexts: q2931AdminSigMode.setDescription('The configured mode for signalling: VP-associated, Non-Associated or auto mode. vpAssoc(1) stands for VP-associated signalling, if set to this value, the uni encodes the connection identifier with the VP-associated signalling bits. nonAssoc(2) is for Non-associated signalling, if set to this value the connection identifier is encoded with non-associated signalling bits. auto(3) stands for auto-configured signalling mode, if set to this value, the operating mode will be determined dynamically and will either be VP-associated or Non-associated depending on the operating type of the signalling link')
q2931AdminSigAlloc = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("allocVP", 1), ("allocLink", 2), ("auto", 3), ("allocVpBundle", 4), ("allocProxy", 5))).clone('auto')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: q2931AdminSigAlloc.setStatus('current')
if mibBuilder.loadTexts: q2931AdminSigAlloc.setDescription('The current configured allocation policy for a network side uni. If set to allocVP(1), the signalling entity will allocate connections within the containing VP only. If set to allocLink(2), the signalling entity will allocate connections in its containing VP and may allocate connections in other VPS that are available to it. If set to allocVpBundle, the uni will allocate connections in its containing VP and a bundle of other VPs which are pre-created. If set to auto(3), the operating allocation policy will be determined based on the operating type of the signalling entity and the VPI value of the VP in which the signalling channel is present. Based on these, it might be allocLink or allocVP or allocVpBundle')
q2931PeerPort = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 34), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: q2931PeerPort.setStatus('current')
if mibBuilder.loadTexts: q2931PeerPort.setDescription("The value of this object identifies the port of the peer's signalling path. The value starts at zero.")
q2931InputSigContract = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 35), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: q2931InputSigContract.setStatus('current')
if mibBuilder.loadTexts: q2931InputSigContract.setDescription('Traffic Contract to be applied to the input signalling channel.')
q2931OutputSigService = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("vbr", 1), ("ubr", 2), ("unknown", 3))).clone('unknown')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: q2931OutputSigService.setStatus('deprecated')
if mibBuilder.loadTexts: q2931OutputSigService.setDescription('Service Queue where the output signalling vc should be inserted into.')
q2931SSCOPNoRespTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 37), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: q2931SSCOPNoRespTimer.setStatus('current')
if mibBuilder.loadTexts: q2931SSCOPNoRespTimer.setDescription('The Value to be set for the duration of the SSCOP No response timer. This is the time in seconds that we will wait before bringing the SSCOP link down. If no value is specified by the user, a default value of 10 seconds is used if the oper version is uni30 and a default value of 7 secs is used if the oper version is uni31.')
q2931AdminIncomingNSAPFilterIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 46), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: q2931AdminIncomingNSAPFilterIndex.setStatus('current')
if mibBuilder.loadTexts: q2931AdminIncomingNSAPFilterIndex.setDescription('The Filter Index of the NSAP Address Filter used to filter incoming calls. If this variable is set to zero, all incoming calls on this UNI will be accepted.')
q2931AdminOutgoingNSAPFilterIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 47), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: q2931AdminOutgoingNSAPFilterIndex.setStatus('current')
if mibBuilder.loadTexts: q2931AdminOutgoingNSAPFilterIndex.setDescription('The Filter Index of the NSAP Address Filter used to filter outgoing calls. If this variable is set to zero, all incoming calls on this UNI will be accepted.')
q2931AdminIEFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 48), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: q2931AdminIEFilter.setStatus('current')
if mibBuilder.loadTexts: q2931AdminIEFilter.setDescription('The set of Information Element Filtering interface options as follows: (The bits in this integer have the following meanings:) Bit Significance Default ======== ============= ======== 0x0001 IE Filtering enabled disabled 0x0002 InsertCallingPDefaultAddress disabled 0x0004 CallingP_delivery enabled 0x0008 CallingPSubAddr_trxf enabled 0x0010 CalledPSubAddr_trxf enabled 0x0020 BHLI_trxf enabled 0x0040 BLLI_trxf enabled 0x0080 BLLI_selection_trxf enabled 0x0100 AAL_Info_trxf enabled --- not used presently ---- The valid combinations of bits 0x40 (BLLI_TRXF) and 0x80 (BLLI_selection_TRXF) are: 0xc0 (1 1) transfer all BLLIs default 0x80 (1 0) **invalid** 0x40 (0 1) transfer only the first BLLI 0x00 (0 0) remove all BLLIs ')
q2931SendCallProc = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 49), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('on')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: q2931SendCallProc.setStatus('deprecated')
if mibBuilder.loadTexts: q2931SendCallProc.setDescription('A flag which allows the user to specify at creation time if CALL PROCEEDING should be sent on this particular interface. If set to on(1), a CALL PROCEEDING message is sent out that interface for every SETUP received on that interface that is successfully forwarded. If set to off(2), no CALL PROCEEDING messages are sent on this interface.')
q2931VCIRangeStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 51), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: q2931VCIRangeStatus.setStatus('current')
if mibBuilder.loadTexts: q2931VCIRangeStatus.setDescription('A flag which indicates the status of Min/MaxVCI range with respect to whether or not the range values are assigned after negotiating with the peer through ILMI process. This variable is set to valid if ILMI is up and range negotiation with the peer is completed, except if a UNI (link) is configured as IISP or ILMI-down, then the value of this MIB value is always set to valid.')
q2931ClearOnCarrierLoss = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 52), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noClear", 1), ("clearCalls", 2))).clone('noClear')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: q2931ClearOnCarrierLoss.setStatus('obsolete')
if mibBuilder.loadTexts: q2931ClearOnCarrierLoss.setDescription('This object indicates whether to clear calls when carrier is lost on the link associated with this signalling channel. The default value is noClear(1). This follows the ATM Forum specification which requires the specific signalling timers to expire before clearing the connections. Setting this value to clearCalls(2) will result in the connections being torn down as soon as carrier loss is detected (not compliant with ATM Forum signalling specifications).')
q2931QosClassExpansionKey = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 54), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: q2931QosClassExpansionKey.setStatus('current')
if mibBuilder.loadTexts: q2931QosClassExpansionKey.setDescription('The key for the QOS Class Expansion Table to be used for this UNI.')
q2931AtmrConfDomainID = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 55), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: q2931AtmrConfDomainID.setStatus('current')
if mibBuilder.loadTexts: q2931AtmrConfDomainID.setDescription('This is the ID of the routing domain to which this interface belongs if this uni is operating as a private UNI, public UNI or IISP')
q2931AtmrPnniNodeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 56), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: q2931AtmrPnniNodeIndex.setStatus('current')
if mibBuilder.loadTexts: q2931AtmrPnniNodeIndex.setDescription('This is the index of the node to which this interface attaches for FT-PNNI and PNNI interfaces. The value is always 0xffff for FT-PNNI interfaces.')
q2931AdminOperSigMode = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 57), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("vpAssoc", 1), ("nonAssoc", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: q2931AdminOperSigMode.setStatus('current')
if mibBuilder.loadTexts: q2931AdminOperSigMode.setDescription('The operating mode for signalling: VP-associated or Non-associated. vpAssoc(1) stands for VP-associated signalling, if set to this value, the uni encodes the conn_id with the VP-associated signalling bits. nonAssoc(2) stands for Non-associated signalling, if set to this value, the uni encodes the conn_id with Non-associated signalling bits.')
q2931AdminOperSigAlloc = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 58), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 5))).clone(namedValues=NamedValues(("allocVP", 1), ("allocLink", 2), ("allocVpBundle", 4), ("allocProxy", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: q2931AdminOperSigAlloc.setStatus('current')
if mibBuilder.loadTexts: q2931AdminOperSigAlloc.setDescription('The operating allocation policy for a network side uni. If set to allocVP, the network side uni will allocate connections in its containing VP only. If set to allocLink, the uni will allocate connections in its containing VP and may allocate connections in other VPS that are available to it. If set to allocVpBundle, the uni will allocate connections in its containing VP and a bundle of other VPs which are pre-created.')
q2931OutputSigUpc = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 60), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: q2931OutputSigUpc.setStatus('current')
if mibBuilder.loadTexts: q2931OutputSigUpc.setDescription('Traffic contract to be applied to the output side of the signalling channel. If this is not specified, signalling will be put in the vbr queue with no bandwidth reservation and no policing.')
q2931AdminPlanType = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 61), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("international", 2), ("national", 3), ("subscriber", 4)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: q2931AdminPlanType.setStatus('current')
if mibBuilder.loadTexts: q2931AdminPlanType.setDescription('This is the plan type to be used in calling party number and called party number IEs in the signalling messages. The value of this variable is dependent on whether q2931AdminUseNativeE164 is set to enable or disable. Further, q2931AdminPlanType can be set in conjunction with q2931AdminUseNativeE164. When q2931AdminUseNativeE164 is set to disable, q2931AdminPlanType takes a default value of 1(unknown). All other values are invalid. When q2931AdminUseNativeE164 is set to enable, q2931AdminPlanType takes a default value of 2(international). Other valid values are 3(national) and 4(subscriber).')
q2931AdminMaxVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 62), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: q2931AdminMaxVPI.setStatus('current')
if mibBuilder.loadTexts: q2931AdminMaxVPI.setDescription('The maximum configured VPI (Virtual Path Identifier) that is used for SVPs (Signalling Virtual Paths) when this interface sets up SVP Connections and also the Max VPI that is used to create dynamic paths for SVCs (Signalling Virtual Circuit) connections.')
q2931MaxSvccVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 63), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: q2931MaxSvccVPI.setStatus('current')
if mibBuilder.loadTexts: q2931MaxSvccVPI.setDescription('The maximum actual VPI (Virtual Path Identifier) that will be used for SVCs (Signalling Virtual Circuit) dynamic paths. This variable denotes the operating value for the maximum VPI value that can be used for setting up dynamic path SVPS. The operating value can differ from the configured value (q2931AdminMaxVPI) as the operating value depends on the outcome of possible ILMI based VPI range negotiation procedure.')
q2931LastChangeTime = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 64), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: q2931LastChangeTime.setStatus('current')
if mibBuilder.loadTexts: q2931LastChangeTime.setDescription('The time the Signalling entity was created in hundredths of a second.')
q2931MaxSvpcVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 67), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: q2931MaxSvpcVPI.setStatus('current')
if mibBuilder.loadTexts: q2931MaxSvpcVPI.setDescription('The maximum actual VPI (Virtual Path Identifier) that will be used for SVPs (Signalling Virtual Paths). This variable denotes the operating value for the maximum VPI value that can be used for setting up dynamic path SVPS. The operating value can differ from the configured value (q2931AdminMaxVPI) as the operating value depends on the outcome of possible ILMI based VPI range negotiation procedure.')
q2931VpCapability = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 68), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("undefined", 1), ("vpCapable", 2), ("notVpCapable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: q2931VpCapability.setStatus('current')
if mibBuilder.loadTexts: q2931VpCapability.setDescription('This mib variable is used to determine if this interface is capable of supporting Switched VPs. For UNI3.x and VP Scope Signalling Interfaces, SVPs (Switch Virtual Paths) cannot be created and hence undefined(1). For UNI40 & PNNI Link Scope interfaces, if there is a non-zero VPI range intersection with the peer, the interface is vpCapable(2), else notVpCapable(3)')
q2931NNIProto = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 66), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("ftpnni", 2), ("forum-pnni", 3), ("iisp", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: q2931NNIProto.setStatus('current')
if mibBuilder.loadTexts: q2931NNIProto.setDescription('The NNI protocol being run on this link')
q2931AcceleratedClear = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 70), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('disable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: q2931AcceleratedClear.setStatus('current')
if mibBuilder.loadTexts: q2931AcceleratedClear.setDescription('This object indicates whether to clear calls when carrier is lost on the link associated with this signalling channel or the Virtual Path goes down. The default value is noClear(1). This follows the ATM Forum specification which requires the specific signalling timers to expire before clearing the connections. Setting this value to clearCalls(2) will result in the connections being torn down as soon as carrier loss/VP failure is detected (not compliant with ATM Forum signalling specifications).')
q2931VpciGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 69), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99999))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: q2931VpciGroupIndex.setStatus('current')
if mibBuilder.loadTexts: q2931VpciGroupIndex.setDescription('The index into the VPCI Mapping Group Table to use for this signalling interface.')
q2931ProxyDirGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 87), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99999))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: q2931ProxyDirGroupIndex.setStatus('current')
if mibBuilder.loadTexts: q2931ProxyDirGroupIndex.setDescription('The index into the proxy address group table to use for this signalling interface.')
q2931SupplementaryServicesStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 71), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("undefined", 3))).clone('disable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: q2931SupplementaryServicesStatus.setStatus('current')
if mibBuilder.loadTexts: q2931SupplementaryServicesStatus.setDescription('This MIB variable is used to enable or disable all the supplementary services features for this interface. This acts as a global switch for this interface to disable or enable all of the supplementary services. The MIB variables defined for all supplementary services will be used only when this is enabled. The supplementary services is disabled by default. The value of undefined(3) is a read-only value used for interfaces where supplementary services are not applicable.')
q2931CallingPAddressPresentation = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 72), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("undefined", 3))).clone('disable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: q2931CallingPAddressPresentation.setStatus('current')
if mibBuilder.loadTexts: q2931CallingPAddressPresentation.setDescription('The Calling party address presentation can be set to one of the two values as described above. The CLIP MIB variable is used when this interface is acting as a called party for a call setup message. When set to enable(1), while a call setup message is forwarded through this interface, the calling party number is provided. When set to disable(2), the calling party number is not provided in the call setup message. The value of undefined(3) is a read-only value used for interfaces where supplementary services are not applicable.')
q2931CallingPAddressRestriction = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 73), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("undefined", 3))).clone('disable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: q2931CallingPAddressRestriction.setStatus('current')
if mibBuilder.loadTexts: q2931CallingPAddressRestriction.setDescription('The Calling party address restriction can be set to one of the two values as described above. The CLIR MIB variable is used when this interface is acting as a calling party for a call setup message. When set to enable(1), while a call setup mes-sage is received from this interface and forwarded out, the calling party number is not provided to called user. When set to disable(2), the calling party number is provided to the called user. The value of undefined(3) is a read-only value used for interfaces where supplementary services are not applicable.')
q2931ConnectedPAddressPresentation = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 74), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("undefined", 3))).clone('disable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: q2931ConnectedPAddressPresentation.setStatus('current')
if mibBuilder.loadTexts: q2931ConnectedPAddressPresentation.setDescription('The Connected party address presentation can be set to one of the two values as described above. The COLP MIB variable is used when the interface is acting as a calling party to a call setup message. When set to enable(1), while a call establish-ment response message is forwarded through this interface, the connected party number is provided to the calling user. When set to disable(2), while a call establishment response message is forwarded through this interface, the connected party number is not provided to the calling user. The value of undefined(3) is a read-only value used for interfaces where supplementary services are not applicable.')
q2931ConnectedPAddressRestriction = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 75), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("undefined", 3))).clone('disable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: q2931ConnectedPAddressRestriction.setStatus('current')
if mibBuilder.loadTexts: q2931ConnectedPAddressRestriction.setDescription('The Connected party address restriction can be set to one of the two values as described above. The COLR MIB variable is used when the interface is acting as a called party to a call setup message. When set to enable(1), while a call establishment response message is forwarded from this interface, the connected party number is not provided to the calling user. When set to disable(2),while a call establishment response message is forwarded from this interface, the connected party number is provided to the calling user. The value of undefined(3) is a read-only value used for interfaces where supplementary services are not applicable.')
q2931ConnectedPDefaultAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 76), NsapAddr()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: q2931ConnectedPDefaultAddress.setStatus('current')
if mibBuilder.loadTexts: q2931ConnectedPDefaultAddress.setDescription('The connected party address to be used in Connection Acceptance (connect, add party ack etc.) messages that do not contain Connected Party Addresses.')
q2931SubaddressingAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 77), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("undefined", 3))).clone('disable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: q2931SubaddressingAdminStatus.setStatus('current')
if mibBuilder.loadTexts: q2931SubaddressingAdminStatus.setDescription('This is used to enable or disable the sub-addressing capability. If this is set to enable(1), the called party sub-address IE is passed along. Ifthis is set to disbale(2), this IE is removed while forwarding the messages. The value of undefined(3) is a read-only value used for interfaces where supplementary services are not applicable.')
q2931UserUserSignallingAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 78), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("undefined", 3))).clone('disable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: q2931UserUserSignallingAdminStatus.setStatus('current')
if mibBuilder.loadTexts: q2931UserUserSignallingAdminStatus.setDescription('This is used to enable or disable the User to User Signalling capability. If this is set to enable(1), the UUS IE is passed along. If this is set to disbale(2), this IE is removed while forwarding the messages. The value of undefined(3) is a read-only value used for interfaces where supplementary services are not applicable.')
q2931OutputIlmiUpc = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 79), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: q2931OutputIlmiUpc.setStatus('current')
if mibBuilder.loadTexts: q2931OutputIlmiUpc.setDescription('The index into the UPC table for the ILMI channel')
q2931OutputRccUpc = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 80), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: q2931OutputRccUpc.setStatus('current')
if mibBuilder.loadTexts: q2931OutputRccUpc.setDescription('The index into the UPC table for the RCC channel')
q2931PnniRccVci = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 81), Integer32().clone(18)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: q2931PnniRccVci.setStatus('current')
if mibBuilder.loadTexts: q2931PnniRccVci.setDescription(' This is used to specify the PVC RCC VCI used by PNNI. Normally this will always be 18, but if a user creates a VPT with a VCI range that does not contain 18, then this field is used to specify the PNNI PVC RCC VCI.')
q2931AdminubrCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 82), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('on')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: q2931AdminubrCalls.setStatus('current')
if mibBuilder.loadTexts: q2931AdminubrCalls.setDescription(' This flag is used to disable processing of UBR calls.')
q2931AdmincbrCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 83), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('on')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: q2931AdmincbrCalls.setStatus('current')
if mibBuilder.loadTexts: q2931AdmincbrCalls.setDescription(' This flag is used to disable processing of CBR calls.')
q2931AdminabrCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 84), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('on')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: q2931AdminabrCalls.setStatus('current')
if mibBuilder.loadTexts: q2931AdminabrCalls.setDescription(' This flag is used to disable processing of ABR calls.')
q2931AdminrtvbrCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 85), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('on')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: q2931AdminrtvbrCalls.setStatus('current')
if mibBuilder.loadTexts: q2931AdminrtvbrCalls.setDescription(' This flag is used to disable processing of RT-VBR calls.')
q2931AdminnrtvbrCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 1, 1, 86), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('on')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: q2931AdminnrtvbrCalls.setStatus('current')
if mibBuilder.loadTexts: q2931AdminnrtvbrCalls.setDescription(' This flag is used to disable processing of NRT-VBR calls.')
q2931StatsTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 2), )
if mibBuilder.loadTexts: q2931StatsTable.setStatus('current')
if mibBuilder.loadTexts: q2931StatsTable.setDescription('A table of statistics about the Q2931 signaling path.')
q2931StatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 2, 1), ).setIndexNames((0, "Fore-Switch-MIB", "q2931StatsPort"), (0, "Fore-Switch-MIB", "q2931StatsVPI"))
if mibBuilder.loadTexts: q2931StatsEntry.setStatus('current')
if mibBuilder.loadTexts: q2931StatsEntry.setDescription('A table entry containing signaling path statistics, indexed by port and path.')
q2931StatsPort = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: q2931StatsPort.setStatus('current')
if mibBuilder.loadTexts: q2931StatsPort.setDescription('The value of this object identifies the port of this signalling path, and is the same as q2931Port.')
q2931StatsVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: q2931StatsVPI.setStatus('current')
if mibBuilder.loadTexts: q2931StatsVPI.setDescription('The value of this object identifies the VPI (Virtual Path Identifier) of this signaling path statistics entry, and is the same as q2931VPI.')
q2931VCCs = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 2, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: q2931VCCs.setStatus('current')
if mibBuilder.loadTexts: q2931VCCs.setDescription('The number of Virtual Channel Connections (VCCs) on this signaling path.')
q2931Restarts = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: q2931Restarts.setStatus('current')
if mibBuilder.loadTexts: q2931Restarts.setDescription('The number of times the switch has lost and regained contact with the remote signaling entity on this path.')
q2931CallsCompletions = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: q2931CallsCompletions.setStatus('current')
if mibBuilder.loadTexts: q2931CallsCompletions.setDescription('The number of successfully completed calls on this signaling path.')
q2931CallsFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: q2931CallsFailures.setStatus('current')
if mibBuilder.loadTexts: q2931CallsFailures.setDescription('The number of call failures on this signaling path.')
q2931CallsRejections = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: q2931CallsRejections.setStatus('current')
if mibBuilder.loadTexts: q2931CallsRejections.setDescription('The number of connections on this signaling path that were rejected by the far end.')
q2931TransmittedMessages = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: q2931TransmittedMessages.setStatus('current')
if mibBuilder.loadTexts: q2931TransmittedMessages.setDescription('The total number of Q2931 messages that have been transmitted over this signalling path.')
q2931ReceivedMessages = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: q2931ReceivedMessages.setStatus('current')
if mibBuilder.loadTexts: q2931ReceivedMessages.setDescription('The total number of Q2931 messages that have been received on this signalling path.')
q2931PublicGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 6))
q2931E164AddrResTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 6, 1), )
if mibBuilder.loadTexts: q2931E164AddrResTable.setStatus('current')
if mibBuilder.loadTexts: q2931E164AddrResTable.setDescription('A table of E164 Address Resolution entries.')
q2931E164AddrResEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 6, 1, 1), ).setIndexNames((0, "Fore-Switch-MIB", "q2931E164Port"), (0, "Fore-Switch-MIB", "q2931E164VPI"), (0, "Fore-Switch-MIB", "q2931E164Nsap"), (0, "Fore-Switch-MIB", "q2931E164NsapMask"))
if mibBuilder.loadTexts: q2931E164AddrResEntry.setStatus('current')
if mibBuilder.loadTexts: q2931E164AddrResEntry.setDescription('A table entry containing E164 Address Resolution information, indexed by Nsap.')
q2931E164Port = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 6, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: q2931E164Port.setStatus('current')
if mibBuilder.loadTexts: q2931E164Port.setDescription('')
q2931E164VPI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 6, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: q2931E164VPI.setStatus('current')
if mibBuilder.loadTexts: q2931E164VPI.setDescription('')
q2931E164Nsap = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 6, 1, 1, 3), NsapAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: q2931E164Nsap.setStatus('current')
if mibBuilder.loadTexts: q2931E164Nsap.setDescription('')
q2931E164NsapMask = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 6, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: q2931E164NsapMask.setStatus('current')
if mibBuilder.loadTexts: q2931E164NsapMask.setDescription('')
q2931E164Address = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 6, 1, 1, 5), E164Address()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: q2931E164Address.setStatus('current')
if mibBuilder.loadTexts: q2931E164Address.setDescription('')
q2931E164AddrResStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 6, 1, 1, 6), EntryStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: q2931E164AddrResStatus.setStatus('current')
if mibBuilder.loadTexts: q2931E164AddrResStatus.setDescription('')
q2931NSAPPingGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 7))
q2931NPCallTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 7, 1), )
if mibBuilder.loadTexts: q2931NPCallTable.setStatus('current')
if mibBuilder.loadTexts: q2931NPCallTable.setDescription('A table of NSAP addressed and call parameters to be used in testing the reachability of destination addresses.')
q2931NPCallEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 7, 1, 1), ).setIndexNames((0, "Fore-Switch-MIB", "q2931NPCallIndex"))
if mibBuilder.loadTexts: q2931NPCallEntry.setStatus('current')
if mibBuilder.loadTexts: q2931NPCallEntry.setDescription('A table entry containing NSAP address, call parameter information.')
q2931NPCallIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 7, 1, 1, 1), Integer32())
if mibBuilder.loadTexts: q2931NPCallIndex.setStatus('current')
if mibBuilder.loadTexts: q2931NPCallIndex.setDescription('The value of this object identifies an entry in the q2931NPCallTable.')
q2931NPCallDstNsap = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 7, 1, 1, 2), NsapAddr()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: q2931NPCallDstNsap.setStatus('current')
if mibBuilder.loadTexts: q2931NPCallDstNsap.setDescription('The Destination NSAP address used by this table entry.')
q2931NPCallState = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 7, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("down", 1), ("inprogress", 2), ("up", 3), ("err", 4), ("locpref", 5), ("lochost", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: q2931NPCallState.setStatus('current')
if mibBuilder.loadTexts: q2931NPCallState.setDescription("This field keeps the state of the nsap call. This field is set to inprogress by default. 'up' means call was successful, 'down' means call was rejected by the destination, 'err' means call was not attempted primarily because no route to destination was available, 'locpref', 'lochost' mean that the address is local")
q2931NPCallClientType = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 7, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("noIndication", 1), ("lecs", 2), ("lec", 3), ("bus", 4), ("les", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: q2931NPCallClientType.setStatus('current')
if mibBuilder.loadTexts: q2931NPCallClientType.setDescription('Holds the type of the client expected to answer the call at destination. Set to noIndication by default.')
q2931NPCallFwdUpcKey = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 7, 1, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: q2931NPCallFwdUpcKey.setStatus('current')
if mibBuilder.loadTexts: q2931NPCallFwdUpcKey.setDescription('UPC table entry to be used in the forward direction of the call is stored here. Set to ZERO by default.')
q2931NPCallBckUpcKey = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 7, 1, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: q2931NPCallBckUpcKey.setStatus('current')
if mibBuilder.loadTexts: q2931NPCallBckUpcKey.setDescription('UPC table entry to be used in the backward direction of the call is stored here. Set to ZERO by default.')
q2931NPCallCallingDomain = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 7, 1, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: q2931NPCallCallingDomain.setStatus('current')
if mibBuilder.loadTexts: q2931NPCallCallingDomain.setDescription('The domain at the originating switch on which the call has to be routed. By default this is set to the default domain, control port domain.')
q2931NPCallQosIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 7, 1, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: q2931NPCallQosIndex.setStatus('current')
if mibBuilder.loadTexts: q2931NPCallQosIndex.setDescription('QOS Index entry to be used in the forward direction of the call is stored here. Set to ZERO by default.')
q2931NPCallQosClassFwd = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 7, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("class0", 1), ("class1", 2), ("class2", 3), ("class3", 4), ("class4", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: q2931NPCallQosClassFwd.setStatus('current')
if mibBuilder.loadTexts: q2931NPCallQosClassFwd.setDescription('QOS Class for forward direction of the call. Set to ZERO by default.')
q2931NPCallQosClassBwd = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 7, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("class0", 1), ("class1", 2), ("class2", 3), ("class3", 4), ("class4", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: q2931NPCallQosClassBwd.setStatus('current')
if mibBuilder.loadTexts: q2931NPCallQosClassBwd.setDescription('QOS Class for backward direction of the call. Set to ZERO by default.')
q2931NPCallBearerClass = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 7, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("classA", 1), ("classC", 2), ("classX", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: q2931NPCallBearerClass.setStatus('current')
if mibBuilder.loadTexts: q2931NPCallBearerClass.setDescription('Bearer Class to be used for the NSAP Ping call. Set to classX by default.')
q2931NPCallVerbose = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 7, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: q2931NPCallVerbose.setStatus('current')
if mibBuilder.loadTexts: q2931NPCallVerbose.setDescription('Holds the info, whether the call setup messages have to be displayed on user console or not. By default set to off.')
q2931NPCallStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 7, 1, 1, 14), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: q2931NPCallStatus.setStatus('current')
if mibBuilder.loadTexts: q2931NPCallStatus.setDescription('The status of this table entry. This entry may not be destroyed if there are any filter entries that refer to it.')
q2931NPPingState = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 7, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("invalid", 0), ("inprogress", 1), ("complete", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: q2931NPPingState.setStatus('current')
if mibBuilder.loadTexts: q2931NPPingState.setDescription("This field tracks the state of the ping process. Invalid is the initial state, when the connection is made the state changes to 'inprogress' and when the ping is complete the state changes to 'complete'.")
q2931NPCallCauseCode = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 7, 1, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: q2931NPCallCauseCode.setStatus('current')
if mibBuilder.loadTexts: q2931NPCallCauseCode.setDescription("The UNI call setup failure cause code. This value is valid only if the call state is 'down'")
q2931NPPingPktCount = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 7, 1, 1, 17), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: q2931NPPingPktCount.setStatus('current')
if mibBuilder.loadTexts: q2931NPPingPktCount.setDescription('The number of ping packets used in the ping process')
q2931NPPingStatsPktsSent = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 7, 1, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: q2931NPPingStatsPktsSent.setStatus('current')
if mibBuilder.loadTexts: q2931NPPingStatsPktsSent.setDescription('The number of ping packets actually sent')
q2931NPPingStatsPktsReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 7, 1, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: q2931NPPingStatsPktsReceived.setStatus('current')
if mibBuilder.loadTexts: q2931NPPingStatsPktsReceived.setDescription('The number of ping packets replied to by the destination ')
q2931NPPingStatsAverageDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 7, 1, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: q2931NPPingStatsAverageDelay.setStatus('current')
if mibBuilder.loadTexts: q2931NPPingStatsAverageDelay.setDescription('The average round trip delay expressed in milli seconds.')
q2931NPMeasureRoundTripDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 7, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: q2931NPMeasureRoundTripDelay.setStatus('current')
if mibBuilder.loadTexts: q2931NPMeasureRoundTripDelay.setDescription('Holds the info, whether the ping process has to be done after the connection is made, By default set to off')
q2931NPPingStatsMaximumDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 7, 1, 1, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: q2931NPPingStatsMaximumDelay.setStatus('current')
if mibBuilder.loadTexts: q2931NPPingStatsMaximumDelay.setDescription('The maximum round trip delay expressed in milli seconds.')
q2931NPPingStatsMinimumDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 7, 1, 1, 23), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: q2931NPPingStatsMinimumDelay.setStatus('current')
if mibBuilder.loadTexts: q2931NPPingStatsMinimumDelay.setDescription('The minimum round trip delay expressed in milli seconds.')
q2931NPCallNextIndex = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 7, 2), TestAndIncr()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: q2931NPCallNextIndex.setStatus('current')
if mibBuilder.loadTexts: q2931NPCallNextIndex.setDescription('The index of the next free row in the q2931NPCallTable.')
q2931AddressFilterGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 6))
q2931AFTemplateTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 6, 1), )
if mibBuilder.loadTexts: q2931AFTemplateTable.setStatus('current')
if mibBuilder.loadTexts: q2931AFTemplateTable.setDescription('A table of allowable (or rejectable) NSAP source and destination addresses.')
q2931AFTemplateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 6, 1, 1), ).setIndexNames((0, "Fore-Switch-MIB", "q2931AFTemplateIndex"))
if mibBuilder.loadTexts: q2931AFTemplateEntry.setStatus('current')
if mibBuilder.loadTexts: q2931AFTemplateEntry.setDescription('A table entry containing NSAP address filtering information.')
q2931AFTemplateIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 6, 1, 1, 1), Integer32())
if mibBuilder.loadTexts: q2931AFTemplateIndex.setStatus('current')
if mibBuilder.loadTexts: q2931AFTemplateIndex.setDescription('The value of this object identifies the NSAP Address Filter Template to which this entry belongs.')
q2931AFTemplateSrcPort = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 6, 1, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: q2931AFTemplateSrcPort.setStatus('current')
if mibBuilder.loadTexts: q2931AFTemplateSrcPort.setDescription('The source UNI port matched by this entry. A value of -1 matches all ports.')
q2931AFTemplateSrcVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 6, 1, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: q2931AFTemplateSrcVPI.setStatus('current')
if mibBuilder.loadTexts: q2931AFTemplateSrcVPI.setDescription('The source UNI VPI matched by this entry. A value of -1 matches all VPIs.')
q2931AFTemplateSrcNsap = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 6, 1, 1, 4), NsapAddr()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: q2931AFTemplateSrcNsap.setStatus('current')
if mibBuilder.loadTexts: q2931AFTemplateSrcNsap.setDescription('The Source NSAP address filtered by this table entry.')
q2931AFTemplateSrcNsapMask = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 6, 1, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: q2931AFTemplateSrcNsapMask.setStatus('current')
if mibBuilder.loadTexts: q2931AFTemplateSrcNsapMask.setDescription('The mask applied to the source address in order to compare against the above q2931AFTemplateEntrySrcNsap. A mask of 0 bits matches all source addresses.')
q2931AFTemplateDstPort = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 6, 1, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: q2931AFTemplateDstPort.setStatus('current')
if mibBuilder.loadTexts: q2931AFTemplateDstPort.setDescription('The destination UNI port matched by this entry. A value of -1 matches all ports.')
q2931AFTemplateDstVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 6, 1, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: q2931AFTemplateDstVPI.setStatus('current')
if mibBuilder.loadTexts: q2931AFTemplateDstVPI.setDescription('The destination UNI VPI matched by this entry. A value of -1 matches all VPIs.')
q2931AFTemplateDstNsap = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 6, 1, 1, 8), NsapAddr()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: q2931AFTemplateDstNsap.setStatus('current')
if mibBuilder.loadTexts: q2931AFTemplateDstNsap.setDescription('The Destination NSAP address filtered by this table entry.')
q2931AFTemplateDstNsapMask = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 6, 1, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: q2931AFTemplateDstNsapMask.setStatus('current')
if mibBuilder.loadTexts: q2931AFTemplateDstNsapMask.setDescription('The mask applied to the destination address in order to compare against the above q2931AFTemplateDstNsap. A mask of 0 bits matches all destination addresses.')
q2931AFTemplateAction = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 6, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("accept", 1), ("reject", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: q2931AFTemplateAction.setStatus('current')
if mibBuilder.loadTexts: q2931AFTemplateAction.setDescription('What to do with addresses that match this entry.')
q2931AFTemplateName = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 6, 1, 1, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: q2931AFTemplateName.setStatus('current')
if mibBuilder.loadTexts: q2931AFTemplateName.setDescription('An optional text name for the template.')
q2931AFTemplateStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 6, 1, 1, 12), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: q2931AFTemplateStatus.setStatus('current')
if mibBuilder.loadTexts: q2931AFTemplateStatus.setDescription('The status of this table entry. This entry may not be destroyed if there are any filter entries that refer to it.')
q2931AFTemplateNextIndex = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 6, 1, 2), TestAndIncr()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: q2931AFTemplateNextIndex.setStatus('current')
if mibBuilder.loadTexts: q2931AFTemplateNextIndex.setDescription('The index of the next free row in the q2931AFTemplateTable.')
q2931AFFilterTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 6, 2), )
if mibBuilder.loadTexts: q2931AFFilterTable.setStatus('current')
if mibBuilder.loadTexts: q2931AFFilterTable.setDescription('A table of filters, each composed of an ordered list of address filtering templates.')
q2931AFFilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 6, 2, 1), ).setIndexNames((0, "Fore-Switch-MIB", "q2931AFFilterIndex"))
if mibBuilder.loadTexts: q2931AFFilterEntry.setStatus('current')
if mibBuilder.loadTexts: q2931AFFilterEntry.setDescription('A table entry for one filter.')
q2931AFFilterIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 6, 2, 1, 1), Integer32())
if mibBuilder.loadTexts: q2931AFFilterIndex.setStatus('current')
if mibBuilder.loadTexts: q2931AFFilterIndex.setDescription('The value of this object identifies the NSAP Address Filter to which this entry belongs.')
q2931AFFilterName = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 6, 2, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: q2931AFFilterName.setStatus('current')
if mibBuilder.loadTexts: q2931AFFilterName.setDescription('An optional text name for the filter.')
q2931AFFilterStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 6, 2, 1, 3), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: q2931AFFilterStatus.setStatus('current')
if mibBuilder.loadTexts: q2931AFFilterStatus.setDescription('The status of this table entry. Setting this variable to destroy removes this row from the q2931AFFilterTable, and removes the corresponding entries from the q2931AFFilterTListTable.')
q2931AFFilterNextIndex = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 6, 2, 2), TestAndIncr()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: q2931AFFilterNextIndex.setStatus('current')
if mibBuilder.loadTexts: q2931AFFilterNextIndex.setDescription('The index of the next free row in the q2931AFFilterTable.')
q2931AFFilterTListTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 6, 3), )
if mibBuilder.loadTexts: q2931AFFilterTListTable.setStatus('current')
if mibBuilder.loadTexts: q2931AFFilterTListTable.setDescription('A table of template lists for filters. A template list is composed of an ordered list of address filtering templates. All objects with the same value for q2931AFFilterIndex are conceptually part of the corresponding q2931AFFilterEntry.')
q2931AFFilterTListEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 6, 3, 1), ).setIndexNames((0, "Fore-Switch-MIB", "q2931AFFilterIndex"), (0, "Fore-Switch-MIB", "q2931AFFilterTListIndex"))
if mibBuilder.loadTexts: q2931AFFilterTListEntry.setStatus('current')
if mibBuilder.loadTexts: q2931AFFilterTListEntry.setDescription("A table entry holding one template in a filter's template list.")
q2931AFFilterTListIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 6, 3, 1, 1), Integer32())
if mibBuilder.loadTexts: q2931AFFilterTListIndex.setStatus('current')
if mibBuilder.loadTexts: q2931AFFilterTListIndex.setDescription('The value of this object identifies the order in this NSAP Address Filter in which this template is applied.')
q2931AFFilterTListTemplateIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 6, 3, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: q2931AFFilterTListTemplateIndex.setStatus('current')
if mibBuilder.loadTexts: q2931AFFilterTListTemplateIndex.setDescription('The value of this object identifies the NSAP Address Filter Template for this entry.')
q2931AFFilterTListStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 6, 3, 1, 3), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: q2931AFFilterTListStatus.setStatus('current')
if mibBuilder.loadTexts: q2931AFFilterTListStatus.setDescription('The status of this table entry.')
q2931AFStatsTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 6, 4), )
if mibBuilder.loadTexts: q2931AFStatsTable.setStatus('current')
if mibBuilder.loadTexts: q2931AFStatsTable.setDescription('A table of address filtering statistics.')
q2931AFStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 6, 4, 1), ).setIndexNames((0, "Fore-Switch-MIB", "q2931AdminPort"), (0, "Fore-Switch-MIB", "q2931AdminVPI"), (0, "Fore-Switch-MIB", "q2931AFDirection"))
if mibBuilder.loadTexts: q2931AFStatsEntry.setStatus('current')
if mibBuilder.loadTexts: q2931AFStatsEntry.setDescription('An entry in the table of address filtering statistics. There are two entries for each UNI: one for incoming call setup attempts, and one for outgoing call setup attempts.')
q2931AFDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 6, 4, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("incoming", 1), ("outgoing", 2))))
if mibBuilder.loadTexts: q2931AFDirection.setStatus('current')
if mibBuilder.loadTexts: q2931AFDirection.setDescription('The value of this object identifies whether this row of the statistics table applies to incoming or outgoing call attempts.')
q2931AFAccepts = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 6, 4, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: q2931AFAccepts.setStatus('current')
if mibBuilder.loadTexts: q2931AFAccepts.setDescription('The total number of Q2931 messages that have been accepted by Address Filtering on this UNI.')
q2931AFRejectKnowns = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 6, 4, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: q2931AFRejectKnowns.setStatus('current')
if mibBuilder.loadTexts: q2931AFRejectKnowns.setDescription('The total number of Q2931 messages that have been rejected because the supplied address matched a template in the address filtering table where the action was to reject the call.')
q2931AFRejectUnknowns = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 6, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: q2931AFRejectUnknowns.setStatus('current')
if mibBuilder.loadTexts: q2931AFRejectUnknowns.setDescription('The total number of Q2931 messages that have been rejected because the supplied address matched no template in the address filtering table.')
q2931AFLookupTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 6, 5), )
if mibBuilder.loadTexts: q2931AFLookupTable.setStatus('current')
if mibBuilder.loadTexts: q2931AFLookupTable.setDescription('The Lookup facility for NSAP address filtering.')
q2931AFLookupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 6, 5, 1), ).setIndexNames((0, "Fore-Switch-MIB", "q2931AFLookupIndex"))
if mibBuilder.loadTexts: q2931AFLookupEntry.setStatus('current')
if mibBuilder.loadTexts: q2931AFLookupEntry.setDescription('The result of an inquiry to the Lookup facility.')
q2931AFLookupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 6, 5, 1, 1), Integer32())
if mibBuilder.loadTexts: q2931AFLookupIndex.setStatus('current')
if mibBuilder.loadTexts: q2931AFLookupIndex.setDescription('The value of this object identifies this entry in the Filter Lookup table.')
q2931AFLookupNSAPFilterIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 6, 5, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: q2931AFLookupNSAPFilterIndex.setStatus('current')
if mibBuilder.loadTexts: q2931AFLookupNSAPFilterIndex.setDescription('The index of the NSAP address filter for this lookup.')
q2931AFLookupSrcPort = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 6, 5, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: q2931AFLookupSrcPort.setStatus('current')
if mibBuilder.loadTexts: q2931AFLookupSrcPort.setDescription('The simulated incoming Port for this filter lookup.')
q2931AFLookupSrcVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 6, 5, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: q2931AFLookupSrcVPI.setStatus('current')
if mibBuilder.loadTexts: q2931AFLookupSrcVPI.setDescription('The simulated incoming VPI for this filter lookup.')
q2931AFLookupSrcNsap = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 6, 5, 1, 5), NsapAddr()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: q2931AFLookupSrcNsap.setStatus('current')
if mibBuilder.loadTexts: q2931AFLookupSrcNsap.setDescription('The Source NSAP address for this filter lookup.')
q2931AFLookupDstPort = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 6, 5, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: q2931AFLookupDstPort.setStatus('current')
if mibBuilder.loadTexts: q2931AFLookupDstPort.setDescription('The simulated outgoing Port for this filter lookup.')
q2931AFLookupDstVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 6, 5, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: q2931AFLookupDstVPI.setStatus('current')
if mibBuilder.loadTexts: q2931AFLookupDstVPI.setDescription('The simulated outgoing VPI for this filter lookup.')
q2931AFLookupDstNsap = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 6, 5, 1, 8), NsapAddr()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: q2931AFLookupDstNsap.setStatus('current')
if mibBuilder.loadTexts: q2931AFLookupDstNsap.setDescription('The Destination NSAP address for this filter lookup.')
q2931AFLookupResult = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 6, 5, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("accept", 1), ("reject", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: q2931AFLookupResult.setStatus('current')
if mibBuilder.loadTexts: q2931AFLookupResult.setDescription('The result of a filter Lookup on the selected values: 1 Accepted 2 Rejected')
q2931AFLookupTemplate = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 6, 5, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: q2931AFLookupTemplate.setStatus('current')
if mibBuilder.loadTexts: q2931AFLookupTemplate.setDescription('The index of the template in the address filter that either accepted or rejected the call. It is zero if the address was unknown.')
q2931AFLookupStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 6, 5, 1, 11), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: q2931AFLookupStatus.setStatus('current')
if mibBuilder.loadTexts: q2931AFLookupStatus.setDescription('The status of this table entry.')
q2931AFLastFailureGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 6, 6))
q2931AFLastFailureSrcPort = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 6, 6, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: q2931AFLastFailureSrcPort.setStatus('current')
if mibBuilder.loadTexts: q2931AFLastFailureSrcPort.setDescription('The incoming port for this failed call attempt.')
q2931AFLastFailureSrcVPI = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 6, 6, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: q2931AFLastFailureSrcVPI.setStatus('current')
if mibBuilder.loadTexts: q2931AFLastFailureSrcVPI.setDescription('The incoming VPI for this failed call attempt.')
q2931AFLastFailureSrcNsap = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 6, 6, 3), NsapAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: q2931AFLastFailureSrcNsap.setStatus('current')
if mibBuilder.loadTexts: q2931AFLastFailureSrcNsap.setDescription('The source address of this failed call attempt.')
q2931AFLastFailureDstPort = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 6, 6, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: q2931AFLastFailureDstPort.setStatus('current')
if mibBuilder.loadTexts: q2931AFLastFailureDstPort.setDescription('The outgoing port for this failed call attempt.')
q2931AFLastFailureDstVPI = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 6, 6, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: q2931AFLastFailureDstVPI.setStatus('current')
if mibBuilder.loadTexts: q2931AFLastFailureDstVPI.setDescription('The outgoing VPI for this failed call attempt.')
q2931AFLastFailureDstNsap = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 6, 6, 6), NsapAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: q2931AFLastFailureDstNsap.setStatus('current')
if mibBuilder.loadTexts: q2931AFLastFailureDstNsap.setDescription('The destination address of this failed call attempt.')
q2931AFLastFailureTemplateIndex = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 6, 6, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: q2931AFLastFailureTemplateIndex.setStatus('current')
if mibBuilder.loadTexts: q2931AFLastFailureTemplateIndex.setDescription('The index of the template which rejected this call attempt. If this call was rejected because its addresses were not known, this field is set to zero.')
q2931AFLastFailureDirection = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 6, 6, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("incoming", 1), ("outgoing", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: q2931AFLastFailureDirection.setStatus('current')
if mibBuilder.loadTexts: q2931AFLastFailureDirection.setDescription('The value of this object identifies whether the incoming (source) or outgoing (destination) filter rejected the call. Its value is irrelevant for accepted calls.')
proxyDirMapEntryGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 15))
proxyDirMapEntryTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 15, 1), )
if mibBuilder.loadTexts: proxyDirMapEntryTable.setStatus('current')
if mibBuilder.loadTexts: proxyDirMapEntryTable.setDescription('A table of ATM End system address, Proxy address directory and VPCI mappings. ')
proxyDirMapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 15, 1, 1), ).setIndexNames((0, "Fore-Switch-MIB", "proxyDirMapIndex"))
if mibBuilder.loadTexts: proxyDirMapEntry.setStatus('current')
if mibBuilder.loadTexts: proxyDirMapEntry.setDescription('A table entry containing ATM End System Address, proxy directory group index and VPCI. ')
proxyDirMapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 15, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99999)))
if mibBuilder.loadTexts: proxyDirMapIndex.setStatus('current')
if mibBuilder.loadTexts: proxyDirMapIndex.setDescription('The value of this object identifies the mapping associated with this entry.')
proxyDirMapAESA = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 15, 1, 1, 2), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: proxyDirMapAESA.setStatus('current')
if mibBuilder.loadTexts: proxyDirMapAESA.setDescription('The ATM End System Address associated with this entry')
proxyDirMapGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 15, 1, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: proxyDirMapGroup.setStatus('current')
if mibBuilder.loadTexts: proxyDirMapGroup.setDescription('The proxy directory address group identifier associated with this mapping')
proxyDirMapVPCI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 15, 1, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: proxyDirMapVPCI.setStatus('current')
if mibBuilder.loadTexts: proxyDirMapVPCI.setDescription('The VPCI value associated with this entry')
proxyDirMapStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 15, 1, 1, 5), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: proxyDirMapStatus.setStatus('current')
if mibBuilder.loadTexts: proxyDirMapStatus.setDescription('The status of this mapping entry.')
proxyDirMapVp = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 15, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: proxyDirMapVp.setStatus('current')
if mibBuilder.loadTexts: proxyDirMapVp.setDescription('The VP value associated with this entry')
proxyDirMapPort = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 15, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: proxyDirMapPort.setStatus('current')
if mibBuilder.loadTexts: proxyDirMapPort.setDescription('The port associated with this entry')
proxyDirGroupGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 16))
proxyDirGroupTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 16, 1), )
if mibBuilder.loadTexts: proxyDirGroupTable.setStatus('current')
if mibBuilder.loadTexts: proxyDirGroupTable.setDescription('A group of ATM End system address and VPCI mappings')
proxyDirGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 16, 1, 1), ).setIndexNames((0, "Fore-Switch-MIB", "proxyDirGroupIndex"))
if mibBuilder.loadTexts: proxyDirGroupEntry.setStatus('current')
if mibBuilder.loadTexts: proxyDirGroupEntry.setDescription('A group of ATM End system address and VPCI mappings')
proxyDirGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 16, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99999)))
if mibBuilder.loadTexts: proxyDirGroupIndex.setStatus('current')
if mibBuilder.loadTexts: proxyDirGroupIndex.setDescription('The value of this object identifies the mapping associated with this entry.')
proxyDirGroupPrefix = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 16, 1, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: proxyDirGroupPrefix.setStatus('current')
if mibBuilder.loadTexts: proxyDirGroupPrefix.setDescription('The prefix of the ATM End System Address that is used in mapping to a VPCI')
proxyDirGroupVPCIGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 16, 1, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: proxyDirGroupVPCIGroup.setStatus('current')
if mibBuilder.loadTexts: proxyDirGroupVPCIGroup.setDescription('The VPCI group index associated with this entry')
proxyDirGroupStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 16, 1, 1, 4), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: proxyDirGroupStatus.setStatus('current')
if mibBuilder.loadTexts: proxyDirGroupStatus.setDescription('The status of this mapping entry.')
vpciMappingTableGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 13))
vmtVpciMapTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 13, 1), )
if mibBuilder.loadTexts: vmtVpciMapTable.setStatus('current')
if mibBuilder.loadTexts: vmtVpciMapTable.setDescription('A table of VPCI, VPI and Port mappings. ')
vmtVpciMapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 13, 1, 1), ).setIndexNames((0, "Fore-Switch-MIB", "vmtVpciMapIndex"))
if mibBuilder.loadTexts: vmtVpciMapEntry.setStatus('current')
if mibBuilder.loadTexts: vmtVpciMapEntry.setDescription('A table entry containing a VPCI, VPI and Port mappings. ')
vmtVpciMapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 13, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99999)))
if mibBuilder.loadTexts: vmtVpciMapIndex.setStatus('current')
if mibBuilder.loadTexts: vmtVpciMapIndex.setDescription('The value of this object identifies the VPCI mapping associated with this entry.')
vmtVpciMapVPCI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 13, 1, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmtVpciMapVPCI.setStatus('current')
if mibBuilder.loadTexts: vmtVpciMapVPCI.setDescription('The VPCI associated with this VPCI mapping entry.')
vmtVpciMapVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 13, 1, 1, 3), Integer32().clone(-1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmtVpciMapVPI.setStatus('current')
if mibBuilder.loadTexts: vmtVpciMapVPI.setDescription('The VPI associated with this VPCI mapping entry. A value of -1 indicates that the VPI is the same as the VPI associated with the signalling interface using this VPCI mapping entry.')
vmtVpciMapPort = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 13, 1, 1, 4), Integer32().clone(-1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmtVpciMapPort.setStatus('current')
if mibBuilder.loadTexts: vmtVpciMapPort.setDescription('The Port associated with this VPCI mapping entry. A value of -1 indicates that the Port is the same as the Port associated with the signalling interface using this VPCI mapping entry.')
vmtVpciMapStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 13, 1, 1, 5), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmtVpciMapStatus.setStatus('current')
if mibBuilder.loadTexts: vmtVpciMapStatus.setDescription('The status of this VPCI mapping entry. The status cannot be set to destroy if there are any vmtVpciMapGroupTable entries that refer to it.')
vmtVpciMapGroupTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 13, 2), )
if mibBuilder.loadTexts: vmtVpciMapGroupTable.setStatus('current')
if mibBuilder.loadTexts: vmtVpciMapGroupTable.setDescription('A table of VPCI mapping groups. Each VPCI mapping group consists of a list if VPCI mapping entries.')
vmtVpciMapGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 13, 2, 1), ).setIndexNames((0, "Fore-Switch-MIB", "vmtVpciMapGroupIndex"))
if mibBuilder.loadTexts: vmtVpciMapGroupEntry.setStatus('current')
if mibBuilder.loadTexts: vmtVpciMapGroupEntry.setDescription('A table entry for one VPCI mapping group.')
vmtVpciMapGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 13, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99999)))
if mibBuilder.loadTexts: vmtVpciMapGroupIndex.setStatus('current')
if mibBuilder.loadTexts: vmtVpciMapGroupIndex.setDescription('The value of this object identifies the VPCI mapping group associated with this entry.')
vmtVpciMapGroupStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 13, 2, 1, 2), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmtVpciMapGroupStatus.setStatus('current')
if mibBuilder.loadTexts: vmtVpciMapGroupStatus.setDescription('The status of the VPCI mapping group entry. This object cannot be transitioned from the Active state to any other state if there are any signalling interfaces using this VPCI mapping group. Setting this variable to destroy will remove this row from the vmtVpciMapGroupTable and also remove the corresponding entries from the vmtVpciMapListTable.')
vmtVpciMapListTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 13, 3), )
if mibBuilder.loadTexts: vmtVpciMapListTable.setStatus('current')
if mibBuilder.loadTexts: vmtVpciMapListTable.setDescription('A table of VPCI mapping entries for VPCI mapping groups. A VPCI mapping list is composed of a list of VPCI mapping entries. All objects with the same value for vmtVpciMapGroupIndex are conceptually part of the same vmtVpciMapGroupEntry. Entries in this table may be added, deleted or modified only if the corresponding vpcigroup index is not being used by any signalling interface.')
vmtVpciMapListEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 13, 3, 1), ).setIndexNames((0, "Fore-Switch-MIB", "vmtVpciMapGroupIndex"), (0, "Fore-Switch-MIB", "vmtVpciMapListIndex"))
if mibBuilder.loadTexts: vmtVpciMapListEntry.setStatus('current')
if mibBuilder.loadTexts: vmtVpciMapListEntry.setDescription('A table entry holding one VPCI mapping entry in a VPCI mapping group.')
vmtVpciMapListIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 13, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99999)))
if mibBuilder.loadTexts: vmtVpciMapListIndex.setStatus('current')
if mibBuilder.loadTexts: vmtVpciMapListIndex.setDescription('The value of this object identifies the order of a VPCI mapping entry in the VPCI mapping group in which it is used.')
vmtVpciMapListMEIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 13, 3, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmtVpciMapListMEIndex.setStatus('current')
if mibBuilder.loadTexts: vmtVpciMapListMEIndex.setDescription('The value of this object identifies the VPCI mapping entry in the vmtVpciMapTable for this entry.')
vmtVpciMapListStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 13, 3, 1, 3), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmtVpciMapListStatus.setStatus('current')
if mibBuilder.loadTexts: vmtVpciMapListStatus.setDescription('The status of this entry. This object can be set to destroy only if the corresponding vmtVpciMapGroupStatus is not Active.')
perCallDbgFilterGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 8))
perCallDbgFilterTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 8, 1), )
if mibBuilder.loadTexts: perCallDbgFilterTable.setStatus('current')
if mibBuilder.loadTexts: perCallDbgFilterTable.setDescription(' A table of Per Call Debugging Filter entries.')
perCallDbgFilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 8, 1, 1), ).setIndexNames((0, "Fore-Switch-MIB", "perCallDbgFilterIndex"))
if mibBuilder.loadTexts: perCallDbgFilterEntry.setStatus('current')
if mibBuilder.loadTexts: perCallDbgFilterEntry.setDescription('A table entry containing a Per Call Debugging filter.')
perCallDbgFilterIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 8, 1, 1, 1), Integer32())
if mibBuilder.loadTexts: perCallDbgFilterIndex.setStatus('current')
if mibBuilder.loadTexts: perCallDbgFilterIndex.setDescription('The value of the object indicates the index of this entry in the PCD table. A limit will be set as a constant to limit the number of filter that can exist at once.')
perCallDbgFilterTemplateId = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 8, 1, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: perCallDbgFilterTemplateId.setStatus('current')
if mibBuilder.loadTexts: perCallDbgFilterTemplateId.setDescription('The value of this object reflects the index of the template to be used for this filter')
perCallDbgFilterName = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 8, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: perCallDbgFilterName.setStatus('current')
if mibBuilder.loadTexts: perCallDbgFilterName.setDescription('The value of this object reflects a name that will be printed out with the debug messages generated by this feature.')
perCallDbgFilterFlavor = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 8, 1, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: perCallDbgFilterFlavor.setStatus('current')
if mibBuilder.loadTexts: perCallDbgFilterFlavor.setDescription('The value of this object reflects the type of debugging that has been enabled.')
perCallDbgFilterMatches = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 8, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perCallDbgFilterMatches.setStatus('current')
if mibBuilder.loadTexts: perCallDbgFilterMatches.setDescription('The value of this object reflects the number of SVC setup messages matches that have been found for this filter.')
perCallDbgFilterRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 8, 1, 1, 6), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: perCallDbgFilterRowStatus.setStatus('current')
if mibBuilder.loadTexts: perCallDbgFilterRowStatus.setDescription('The status of this PCD filter entry.')
perCallDbgTransFlag = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 6, 2, 1, 8, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: perCallDbgTransFlag.setStatus('current')
if mibBuilder.loadTexts: perCallDbgTransFlag.setDescription('Enables a switch to generate and print PCD debugging information when a switch receives a PCD GIT IE. The default value will be enabled.')
nsapNetworkPrefixTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 9, 1), )
if mibBuilder.loadTexts: nsapNetworkPrefixTable.setStatus('current')
if mibBuilder.loadTexts: nsapNetworkPrefixTable.setDescription('A table of Network Prefix addresses')
nsapNetworkPrefixEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 9, 1, 1), ).setIndexNames((0, "Fore-Switch-MIB", "nsapNetworkPrefixPort"), (0, "Fore-Switch-MIB", "nsapNetworkPrefixVPI"), (0, "Fore-Switch-MIB", "nsapNetworkPrefixValue"))
if mibBuilder.loadTexts: nsapNetworkPrefixEntry.setStatus('current')
if mibBuilder.loadTexts: nsapNetworkPrefixEntry.setDescription('An entry in the Network Prefix table.')
nsapNetworkPrefixPort = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 9, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsapNetworkPrefixPort.setStatus('current')
if mibBuilder.loadTexts: nsapNetworkPrefixPort.setDescription('The value of this object identifies the port of this signalling path, and is the same as nsapPort.')
nsapNetworkPrefixVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 9, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsapNetworkPrefixVPI.setStatus('current')
if mibBuilder.loadTexts: nsapNetworkPrefixVPI.setDescription('The value of this object identifies the VPI (Virtual Path Identifier) of this signaling path statistics entry, and is the same as nsapVPI.')
nsapNetworkPrefixValue = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 9, 1, 1, 3), NsapPrefix()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsapNetworkPrefixValue.setStatus('current')
if mibBuilder.loadTexts: nsapNetworkPrefixValue.setDescription('The network prefix for ATM addresses which is in effect on the user-side of the ATM UNI port.')
nsapNetworkPrefixStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 9, 1, 1, 4), EntryStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nsapNetworkPrefixStatus.setStatus('current')
if mibBuilder.loadTexts: nsapNetworkPrefixStatus.setDescription('The status of this Network Prefix entry. Setting this object to invalid(4) causes this Network to disappear.')
nsapTopologyTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 9, 3), )
if mibBuilder.loadTexts: nsapTopologyTable.setStatus('current')
if mibBuilder.loadTexts: nsapTopologyTable.setDescription('A table for NSAP (Network Service Access Point) topology, based on NSAP routing.')
nsapTopologyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 9, 3, 1), ).setIndexNames((0, "Fore-Switch-MIB", "nsapTopoBoard"), (0, "Fore-Switch-MIB", "nsapTopoLinkSrc"), (0, "Fore-Switch-MIB", "nsapTopoLinkSrcMask"), (0, "Fore-Switch-MIB", "nsapTopoLinkSrcPort"), (0, "Fore-Switch-MIB", "nsapTopoLinkSrcVpi"), (0, "Fore-Switch-MIB", "nsapTopoLinkDest"), (0, "Fore-Switch-MIB", "nsapTopoLinkDestMask"), (0, "Fore-Switch-MIB", "nsapTopoLinkDestPort"), (0, "Fore-Switch-MIB", "nsapTopoLinkDestVpi"))
if mibBuilder.loadTexts: nsapTopologyEntry.setStatus('current')
if mibBuilder.loadTexts: nsapTopologyEntry.setDescription('An entry in the NSAP (Network Service Access Point) topology table.')
nsapTopoBoard = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 9, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsapTopoBoard.setStatus('current')
if mibBuilder.loadTexts: nsapTopoBoard.setDescription('The index of the switch board within the ATM switch cluster. This object is the same as the swBoardIndex.')
nsapTopoLinkSrc = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 9, 3, 1, 2), NsapAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsapTopoLinkSrc.setStatus('current')
if mibBuilder.loadTexts: nsapTopoLinkSrc.setDescription('The value of this object identifies the source NSAP (Network Service Access Point) address of this link.')
nsapTopoLinkSrcMask = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 9, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsapTopoLinkSrcMask.setStatus('current')
if mibBuilder.loadTexts: nsapTopoLinkSrcMask.setDescription('The value of this object identifies the mask that is used for the link source NSAP (Network Service Access Point) address. The mask identifies the number of bits in the NSAP address that are valid. The value of the mask object is in the range 0-160 (160 bits is the size of an NSAP address).')
nsapTopoLinkSrcPort = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 9, 3, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsapTopoLinkSrcPort.setStatus('current')
if mibBuilder.loadTexts: nsapTopoLinkSrcPort.setDescription('This object identifies the physical port of the link source.')
nsapTopoLinkSrcVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 9, 3, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsapTopoLinkSrcVpi.setStatus('current')
if mibBuilder.loadTexts: nsapTopoLinkSrcVpi.setDescription('This object identifies the virtual path identifier of the link source.')
nsapTopoLinkDest = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 9, 3, 1, 6), NsapAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsapTopoLinkDest.setStatus('current')
if mibBuilder.loadTexts: nsapTopoLinkDest.setDescription('The value of this object identifies the destination NSAP (Network Service Access Point) address of this link.')
nsapTopoLinkDestMask = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 9, 3, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsapTopoLinkDestMask.setStatus('current')
if mibBuilder.loadTexts: nsapTopoLinkDestMask.setDescription('The value of this object identifies the mask that is used for the link destination NSAP (Network Service Access Point) address. The mask identifies the number of bits in the NSAP address that are valid. The value of the mask object is in the range 0-160 (160 bits is the size of an NSAP address).')
nsapTopoLinkDestPort = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 9, 3, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsapTopoLinkDestPort.setStatus('current')
if mibBuilder.loadTexts: nsapTopoLinkDestPort.setDescription('This object identifies the physical port of the link destination.')
nsapTopoLinkDestVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 9, 3, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsapTopoLinkDestVpi.setStatus('current')
if mibBuilder.loadTexts: nsapTopoLinkDestVpi.setDescription('This object identifies the virtual path identifier of the link destination.')
nsapTopoLinkCost = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 9, 3, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsapTopoLinkCost.setStatus('current')
if mibBuilder.loadTexts: nsapTopoLinkCost.setDescription('The routing metric for this link.')
nsapTopoLinkUbrVCs = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 9, 3, 1, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsapTopoLinkUbrVCs.setStatus('deprecated')
if mibBuilder.loadTexts: nsapTopoLinkUbrVCs.setDescription('The number of UBR vcs.')
nsapTopoLinkCbrCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 9, 3, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsapTopoLinkCbrCapacity.setStatus('current')
if mibBuilder.loadTexts: nsapTopoLinkCbrCapacity.setDescription('The available capacity for additional CBR (Constant Bit Rate) connections. The available capacity is measured in Kbps.')
nsapTopoLinkCbrFifo = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 9, 3, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsapTopoLinkCbrFifo.setStatus('current')
if mibBuilder.loadTexts: nsapTopoLinkCbrFifo.setDescription('The size of the FIFO queue that is used for transmitting CBR (Constant Bit Rate) traffic. The size of the fifo is measured in number of cells.')
nsapTopoLinkVbrCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 9, 3, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsapTopoLinkVbrCapacity.setStatus('current')
if mibBuilder.loadTexts: nsapTopoLinkVbrCapacity.setDescription('The available capacity for additional VBR (Variable Bit Rate) connections. The available capacity is measured in Kbps.')
nsapTopoLinkVbrFifo = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 9, 3, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsapTopoLinkVbrFifo.setStatus('current')
if mibBuilder.loadTexts: nsapTopoLinkVbrFifo.setDescription('The size of the FIFO queue that is used for transmitting VBR (Variable Bit Rate) traffic. The size of the fifo is measured in number of cells.')
nsapTopoLinkOrig = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 9, 3, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("static-route", 1), ("spans-pnni", 2), ("ilmi-registered", 3), ("pnni", 4), ("external", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsapTopoLinkOrig.setStatus('current')
if mibBuilder.loadTexts: nsapTopoLinkOrig.setDescription('The source of this route information.')
nsapTopoLinkCapabilitySet = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 9, 3, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsapTopoLinkCapabilitySet.setStatus('current')
if mibBuilder.loadTexts: nsapTopoLinkCapabilitySet.setDescription('A bitmap indicate the capabilities of this link. For example, whether the link support ABR (Available Bit Rate) traffic.')
nsapTopoLinkFreshness = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 9, 3, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsapTopoLinkFreshness.setStatus('current')
if mibBuilder.loadTexts: nsapTopoLinkFreshness.setDescription('This object indicates the freshness (or staleness) of this NSAP (Network Service Access Point) link. As the number increases, the link becomes stale.')
nsapTopoLinkUbrEstimatedBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 9, 3, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsapTopoLinkUbrEstimatedBandwidth.setStatus('current')
if mibBuilder.loadTexts: nsapTopoLinkUbrEstimatedBandwidth.setDescription('The estimated UBR bandwidth on this link.')
nsapStaticRouteTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 9, 4), )
if mibBuilder.loadTexts: nsapStaticRouteTable.setStatus('current')
if mibBuilder.loadTexts: nsapStaticRouteTable.setDescription('A table for static NSAP (Network Service Access Point) route administration.')
nsapStaticRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 9, 4, 1), ).setIndexNames((0, "Fore-Switch-MIB", "nsapStaticRouteAddress"), (0, "Fore-Switch-MIB", "nsapStaticRouteMask"), (0, "Fore-Switch-MIB", "nsapStaticRoutePort"), (0, "Fore-Switch-MIB", "nsapStaticRouteVPI"))
if mibBuilder.loadTexts: nsapStaticRouteEntry.setStatus('current')
if mibBuilder.loadTexts: nsapStaticRouteEntry.setDescription('An entry in the NSAP (Network Service Access Point) static route administration table.')
nsapStaticRouteAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 9, 4, 1, 1), NsapAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsapStaticRouteAddress.setStatus('current')
if mibBuilder.loadTexts: nsapStaticRouteAddress.setDescription('The value of this object identifies the destination NSAP address')
nsapStaticRouteMask = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 9, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsapStaticRouteMask.setStatus('current')
if mibBuilder.loadTexts: nsapStaticRouteMask.setDescription('The value of this object identifies the mask that is used for this NSAP (Network Service Access Point) address.')
nsapStaticRoutePort = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 9, 4, 1, 3), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nsapStaticRoutePort.setStatus('current')
if mibBuilder.loadTexts: nsapStaticRoutePort.setDescription('The value of this object identifies the port through which this NSAP (Network Service Access Point) address can be reached.')
nsapStaticRouteVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 9, 4, 1, 4), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nsapStaticRouteVPI.setStatus('current')
if mibBuilder.loadTexts: nsapStaticRouteVPI.setDescription('The value of this object identifies the path through which this NSAP (Network Service Access Point) address can be reached.')
nsapStaticRouteCost = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 9, 4, 1, 5), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nsapStaticRouteCost.setStatus('current')
if mibBuilder.loadTexts: nsapStaticRouteCost.setDescription('The value of this object identifies the cost associated with this Static Route. This cost is to be used as a metric while routing')
nsapStaticRouteMaxCbrCap = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 9, 4, 1, 6), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nsapStaticRouteMaxCbrCap.setStatus('current')
if mibBuilder.loadTexts: nsapStaticRouteMaxCbrCap.setDescription('The value of this object identifies the maximum capacity available on this route for CBR connections')
nsapStaticRouteMaxVbrCap = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 9, 4, 1, 7), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nsapStaticRouteMaxVbrCap.setStatus('current')
if mibBuilder.loadTexts: nsapStaticRouteMaxVbrCap.setDescription('The value of this object identifies the maximum capacity available on this route for VBR connections')
nsapStaticRouteAbrSupport = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 9, 4, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("supported", 1), ("unsupported", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nsapStaticRouteAbrSupport.setStatus('current')
if mibBuilder.loadTexts: nsapStaticRouteAbrSupport.setDescription('The value identifies the capability to support ABR traffic on this route')
nsapStaticRouteEpdSupport = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 9, 4, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("supported", 1), ("unsupported", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nsapStaticRouteEpdSupport.setStatus('current')
if mibBuilder.loadTexts: nsapStaticRouteEpdSupport.setDescription('The value identifies the capability to support Early Packet Discard (EPD) on this route')
nsapStaticRouteStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 9, 4, 1, 10), EntryStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nsapStaticRouteStatus.setStatus('current')
if mibBuilder.loadTexts: nsapStaticRouteStatus.setDescription('The status of this NSAP (Network Service Access Point) address. Setting this object to invalid(4) causes this NSAP address to disappear.')
ftPnniDTLTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 9, 5), )
if mibBuilder.loadTexts: ftPnniDTLTable.setStatus('deprecated')
if mibBuilder.loadTexts: ftPnniDTLTable.setDescription('A table of Designated Transit List entries. The DTLs represent statically configured FT-PNNI routes')
ftPnniDTLEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 9, 5, 1), ).setIndexNames((0, "Fore-Switch-MIB", "ftPnniDTLIndex"), (0, "Fore-Switch-MIB", "ftPnniDTLEntryIndex"))
if mibBuilder.loadTexts: ftPnniDTLEntry.setStatus('deprecated')
if mibBuilder.loadTexts: ftPnniDTLEntry.setDescription('An entry in the FT-PNNI DTLble. A DTL is formed by concatenating rows of the table for which the ftPnniDTLIndex is the same')
ftPnniDTLIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 9, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ftPnniDTLIndex.setStatus('deprecated')
if mibBuilder.loadTexts: ftPnniDTLIndex.setDescription("The value of this object identifies the index of a (FT-PNNI) DTL in the table. A DTL (Designated Transit List) is a source route of entries comprising a FT-PNNI node and the corresponding logical output port at that node. The FT-PNNI node is given by the node's NSAP Prefix and mask. The logical port is given by the linkid and the VPI.")
ftPnniDTLEntryIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 9, 5, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ftPnniDTLEntryIndex.setStatus('deprecated')
if mibBuilder.loadTexts: ftPnniDTLEntryIndex.setDescription('The value of this object identifies the Index of an entry within a given DTL. A DTL is a source route and each entry in the DTL represents a single hop in the source route. Each hop is represented by a FT-PNNI node and the logical output port at that node. An entry in the DTL is given an index equal to its position in the source route. Thus the entry corresponding to the first hop is given an index of 1, the second hop an index of 2 and so on.')
ftPnniDTLNodePrefix = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 9, 5, 1, 3), NsapPrefix()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ftPnniDTLNodePrefix.setStatus('deprecated')
if mibBuilder.loadTexts: ftPnniDTLNodePrefix.setDescription('This the Prefix part of the Node ID of this DTL entry. In FT-PNNI, The Node IDs are represented as prefixes, that represents both the ID of the node and a summary of reachable addresses')
ftPnniDTLNodeMask = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 9, 5, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 104))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ftPnniDTLNodeMask.setStatus('deprecated')
if mibBuilder.loadTexts: ftPnniDTLNodeMask.setDescription('This the Mask corresponding to the ftPnniDTLNodePrefix. This gives the length of the above prefix in number of bits. This can vary from 0 to 104 (13 bytes).')
ftPnniDTLPort = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 9, 5, 1, 5), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ftPnniDTLPort.setStatus('deprecated')
if mibBuilder.loadTexts: ftPnniDTLPort.setDescription('This is the output port at the Node given by the above Node ID. This is also the port to which the next node in the DTL (if there is one) is connected.')
ftPnniDTLVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 9, 5, 1, 6), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ftPnniDTLVPI.setStatus('deprecated')
if mibBuilder.loadTexts: ftPnniDTLVPI.setDescription('This is the output path in the output port above that is the signalling path to the peer given by the next node in the DTL.')
ftPnniDTLStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 9, 5, 1, 7), EntryStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ftPnniDTLStatus.setStatus('deprecated')
if mibBuilder.loadTexts: ftPnniDTLStatus.setDescription('The entry status of this entry in the table.')
ftPnniSummaryTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 9, 6), )
if mibBuilder.loadTexts: ftPnniSummaryTable.setStatus('deprecated')
if mibBuilder.loadTexts: ftPnniSummaryTable.setDescription('A table of Prefixes that are used for either summarizing or suppressing internal and exterior reachability information by the FT-PNNI routing protocol')
ftPnniSummaryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 9, 6, 1), ).setIndexNames((0, "Fore-Switch-MIB", "ftPnniSummaryAddress"), (0, "Fore-Switch-MIB", "ftPnniSummaryPrefixLength"))
if mibBuilder.loadTexts: ftPnniSummaryEntry.setStatus('deprecated')
if mibBuilder.loadTexts: ftPnniSummaryEntry.setDescription('An entry in the FT-PNNI Summary table.')
ftPnniSummaryAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 9, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ftPnniSummaryAddress.setStatus('deprecated')
if mibBuilder.loadTexts: ftPnniSummaryAddress.setDescription('The address prefix that is to be either summarized or suppressed by the FT-PNNI routing protocol')
ftPnniSummaryPrefixLength = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 9, 6, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ftPnniSummaryPrefixLength.setStatus('deprecated')
if mibBuilder.loadTexts: ftPnniSummaryPrefixLength.setDescription('This value is the mask for the address. This gives length of the address prefix in number of bits')
ftPnniSummaryType = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 9, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("internal", 1), ("exterior", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ftPnniSummaryType.setStatus('deprecated')
if mibBuilder.loadTexts: ftPnniSummaryType.setDescription('This value identifies the type of the summary being described')
ftPnniSummarySuppress = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 9, 6, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ftPnniSummarySuppress.setStatus('deprecated')
if mibBuilder.loadTexts: ftPnniSummarySuppress.setDescription('The Suppress flag determinces what is to be done with this address. The default value (no) will indicate that the summary should be propagated. If the value is yes, this summary and any reachable address it summarizes are suppressed for being propagated')
ftPnniSummaryState = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 9, 6, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("advertising", 1), ("suppressing", 2), ("inactive", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ftPnniSummaryState.setStatus('deprecated')
if mibBuilder.loadTexts: ftPnniSummaryState.setDescription('This value indicates whether the summary is currently being advertised by the FT-PNNI routing protocol')
ftPnniSummaryStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 9, 6, 1, 6), EntryStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ftPnniSummaryStatus.setStatus('deprecated')
if mibBuilder.loadTexts: ftPnniSummaryStatus.setDescription('The entry status of this entry in the table.')
upcContractTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 10, 1), )
if mibBuilder.loadTexts: upcContractTable.setStatus('current')
if mibBuilder.loadTexts: upcContractTable.setDescription('A table of user defined UPC traffic contracts.')
upcContractEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 10, 1, 1), ).setIndexNames((0, "Fore-Switch-MIB", "upcContractKey"))
if mibBuilder.loadTexts: upcContractEntry.setStatus('current')
if mibBuilder.loadTexts: upcContractEntry.setDescription('A table entry containing a user defined UPC traffic contract.')
upcContractKey = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 10, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32767))).setMaxAccess("readonly")
if mibBuilder.loadTexts: upcContractKey.setStatus('current')
if mibBuilder.loadTexts: upcContractKey.setDescription('The key of this UPC configuration.')
upcContractEntryStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 10, 1, 1, 2), EntryStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: upcContractEntryStatus.setStatus('current')
if mibBuilder.loadTexts: upcContractEntryStatus.setDescription('The SNMP status of this upcContract entry.')
upcContractPCR01 = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 10, 1, 1, 3), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: upcContractPCR01.setStatus('deprecated')
if mibBuilder.loadTexts: upcContractPCR01.setDescription('The peak cell rate (cells/sec) for cell loss priority 0+1')
upcContractSCR01 = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 10, 1, 1, 4), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: upcContractSCR01.setStatus('deprecated')
if mibBuilder.loadTexts: upcContractSCR01.setDescription('The sustained cell rate (cells/sec) for cell loss priority 0+1')
upcContractMBS01 = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 10, 1, 1, 5), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: upcContractMBS01.setStatus('deprecated')
if mibBuilder.loadTexts: upcContractMBS01.setDescription('The maximum burst size (cells) for cell loss priority 0+1')
upcContractPCR0 = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 10, 1, 1, 6), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: upcContractPCR0.setStatus('deprecated')
if mibBuilder.loadTexts: upcContractPCR0.setDescription('The peak cell rate (cells/sec) for cell loss priority 0')
upcContractSCR0 = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 10, 1, 1, 7), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: upcContractSCR0.setStatus('deprecated')
if mibBuilder.loadTexts: upcContractSCR0.setDescription('The sustained cell rate (cells/sec) for cell loss priority 0')
upcContractMBS0 = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 10, 1, 1, 8), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: upcContractMBS0.setStatus('deprecated')
if mibBuilder.loadTexts: upcContractMBS0.setDescription('The maximum burst size (cells) for cell loss priority 0.')
upcContractCDVT = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 10, 1, 1, 9), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: upcContractCDVT.setStatus('current')
if mibBuilder.loadTexts: upcContractCDVT.setDescription("The Cell Delay Variation Tolerance associated with PCR's. The Default CDVT values (in microseconds) for the various physical media are: DS1_DEFAULT_LINK_CDVT - 5000 DS3_DEFAULT_LINK_CDVT - 2500 E1_DEFAULT_LINK_CDVT - 5000 E3_DEFAULT_LINK_CDVT - 2500 J2_DEFAULT_LINK_CDVT - 5000 SONET_OC3_LINK_DEFAULT_CDVT - 250 SONET_OC12_LINK_DEFAULT_CDVT - 250 SONET_OC48_LINK_DEFAULT_CDVT - 250 TAXI_DEFAULT_LINK_CDVT - 1000 TP25_DEFAULT_LINK_CDVT - 5000 CTRLPORT_DEFAULT_LINK_CDVT - 5000 BACKPLANE_DEFAULT_LINK_CDVT - 100")
upcContractTagReq = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 10, 1, 1, 10), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: upcContractTagReq.setStatus('deprecated')
if mibBuilder.loadTexts: upcContractTagReq.setDescription('Should we tag (instead of drop) non-compliant CLP=0 cells?.')
upcContractAal5Epd = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 10, 1, 1, 11), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: upcContractAal5Epd.setStatus('deprecated')
if mibBuilder.loadTexts: upcContractAal5Epd.setDescription("Should we do AAL5 EPD on this connection?. This variable has been subsumed by the two new variables upcContractIsAAL5 and upcContractdoPacketDiscard. These new variables allow us to decouple the AAL5'ness of a connection from whether we are going to do packet discard on it if it is AAL5.")
upcContractName = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 10, 1, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 19))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: upcContractName.setStatus('current')
if mibBuilder.loadTexts: upcContractName.setDescription('The name associated with this UPC traffic contract.')
upcContractDoGCRAPolicing = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 10, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('on')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: upcContractDoGCRAPolicing.setStatus('current')
if mibBuilder.loadTexts: upcContractDoGCRAPolicing.setDescription('Should we suppress GCRA policing on connections using this UPC Contract ?')
upcContractIsAAL5 = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 10, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2))).clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: upcContractIsAAL5.setStatus('current')
if mibBuilder.loadTexts: upcContractIsAAL5.setDescription('Is this UPC contract using AAL5?')
upcContractDoPacketDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 10, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('on')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: upcContractDoPacketDiscard.setStatus('current')
if mibBuilder.loadTexts: upcContractDoPacketDiscard.setDescription('Should we perform AAL5 Packet Discard (EPD/PPD) on this UPC contract. This variable only has meaning if the connection is also AAL5')
upcContractDoPPPolicing = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 10, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('off')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: upcContractDoPPPolicing.setStatus('current')
if mibBuilder.loadTexts: upcContractDoPPPolicing.setDescription('Should we perform AAL5 Partial Packet Policing on this UPC contract. This variable only has meaning if the connections is also AAL5.')
upcContractDoUBRTagging = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 10, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('off')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: upcContractDoUBRTagging.setStatus('deprecated')
if mibBuilder.loadTexts: upcContractDoUBRTagging.setDescription('Should we perform tagging (set CLP=1) of all cells of connections that use this UBR traffic contract?')
upcContractSchedMode = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 10, 1, 1, 18), AtmConnSchedMode().clone('default')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: upcContractSchedMode.setStatus('current')
if mibBuilder.loadTexts: upcContractSchedMode.setDescription('This variable indicates the scheduling mode that is requested for connections that use this UPC contract.')
upcContractUseAltCLPThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 10, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('off')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: upcContractUseAltCLPThreshold.setStatus('current')
if mibBuilder.loadTexts: upcContractUseAltCLPThreshold.setDescription("This flag determines whether the Series-DW per-VC Alternate CLP Threshold should be used for all non-ABR VC's created with this UPC contract.")
upcContractMCR = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 10, 1, 1, 20), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: upcContractMCR.setStatus('current')
if mibBuilder.loadTexts: upcContractMCR.setDescription('The minimum cell rate (cells/sec) for ABR connections.')
upcContractEstimatedUbrBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 10, 1, 1, 21), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: upcContractEstimatedUbrBandwidth.setStatus('current')
if mibBuilder.loadTexts: upcContractEstimatedUbrBandwidth.setDescription('The estimated UBR bandwidth in Kilo-CPS associated with this UPC contract')
upcContractAAL5CountingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 10, 1, 1, 22), AAL5CountingMode().clone('default')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: upcContractAAL5CountingMode.setStatus('current')
if mibBuilder.loadTexts: upcContractAAL5CountingMode.setDescription('The Counter mode for an AAL5 connection')
upcContractServiceCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 10, 1, 1, 23), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: upcContractServiceCategory.setStatus('current')
if mibBuilder.loadTexts: upcContractServiceCategory.setDescription('Index of this service category within serviceCategoryTable')
upcContractPoliceScheme = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 10, 1, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("cbr1", 1), ("cbr0", 2), ("cbr0tag", 3), ("vbr1", 4), ("vbr2", 5), ("vbr3", 6), ("abr1", 7), ("ubr1", 8), ("ubr2", 9)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: upcContractPoliceScheme.setStatus('current')
if mibBuilder.loadTexts: upcContractPoliceScheme.setDescription('It identifies the policing associated with the UPC contract as defined in the ATM Forum TM 4.0 specifications. However, the policing schemes cbr0 and cbr0tag are specific to FORE switches')
upcContractPCR = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 10, 1, 1, 25), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: upcContractPCR.setStatus('current')
if mibBuilder.loadTexts: upcContractPCR.setDescription('The peak cell rate (cells/sec)')
upcContractSCR = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 10, 1, 1, 26), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: upcContractSCR.setStatus('current')
if mibBuilder.loadTexts: upcContractSCR.setDescription('The sustained cell rate (cells/sec). It also holds the PCR0 value for cbr0 & cbr0tag contracts')
upcContractMBS = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 10, 1, 1, 27), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: upcContractMBS.setStatus('current')
if mibBuilder.loadTexts: upcContractMBS.setDescription('The maximum burst size (cells)')
upcContractServiceSubCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 10, 1, 1, 28), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: upcContractServiceSubCategory.setStatus('current')
if mibBuilder.loadTexts: upcContractServiceSubCategory.setDescription('The Service subcategory for this connection.Default value is 1.')
upcContractCongestionBasedPeakBw = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 10, 1, 1, 29), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: upcContractCongestionBasedPeakBw.setStatus('current')
if mibBuilder.loadTexts: upcContractCongestionBasedPeakBw.setDescription('The expected peak bandwidth for this congestion based UPC contract')
upcContractBehaviorClassSelector = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 10, 1, 1, 30), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: upcContractBehaviorClassSelector.setStatus('current')
if mibBuilder.loadTexts: upcContractBehaviorClassSelector.setDescription('The behavior class selector (BCS) for this UPC contract')
qosClassExpansionTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 17, 1), )
if mibBuilder.loadTexts: qosClassExpansionTable.setStatus('current')
if mibBuilder.loadTexts: qosClassExpansionTable.setDescription('A table of user defined QOS Class Expansions.')
qosClassExpansionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 17, 1, 1), ).setIndexNames((0, "Fore-Switch-MIB", "qosClassExpansionKey"), (0, "Fore-Switch-MIB", "qosClassValue"))
if mibBuilder.loadTexts: qosClassExpansionEntry.setStatus('current')
if mibBuilder.loadTexts: qosClassExpansionEntry.setDescription('A table entry containing a user defined QOS Class Expansion.')
qosClassExpansionKey = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 17, 1, 1, 1), Integer32())
if mibBuilder.loadTexts: qosClassExpansionKey.setStatus('current')
if mibBuilder.loadTexts: qosClassExpansionKey.setDescription('The unique key for the set of entries in this table that make up a QOS Class Mapping table. Only one entry for each Class is allowed per key.')
qosClassValue = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 17, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("class0", 1), ("class1", 2), ("class2", 3), ("class3", 4), ("class4", 5))))
if mibBuilder.loadTexts: qosClassValue.setStatus('current')
if mibBuilder.loadTexts: qosClassValue.setDescription('QOS Class which needs to be expanded. If a class does not exist for a specific Expansion Key, all qos parameters will be interpreted as any acceptable qos parameter value.')
qosClassExpansionEntryStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 17, 1, 1, 3), EntryStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: qosClassExpansionEntryStatus.setStatus('current')
if mibBuilder.loadTexts: qosClassExpansionEntryStatus.setDescription('The SNMP status of this Expansion entry.')
qosClassFwdCtd = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 17, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215)).clone(16777215)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: qosClassFwdCtd.setStatus('current')
if mibBuilder.loadTexts: qosClassFwdCtd.setDescription('The maximum acceptable forward Cell Transfer Delay in microseconds to be used for this expansion. A value of 16777215 will signify any acceptable forward CTD value.')
qosClassFwdCdv = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 17, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215)).clone(16777215)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: qosClassFwdCdv.setStatus('current')
if mibBuilder.loadTexts: qosClassFwdCdv.setDescription('The maximum acceptable peak to peak forward Cell Delay Variation in micro-seconds to be used for this expansion. A value of 16777215 will signify any acceptable forward CDV value.')
qosClassBackCdv = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 17, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215)).clone(16777215)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: qosClassBackCdv.setStatus('current')
if mibBuilder.loadTexts: qosClassBackCdv.setDescription('The maximum acceptable peak to peak backward Cell Delay Variation in micro-seconds to be used for this expansion. A value of 16777215 will signify any acceptable backward CDV value.')
qosClassFwdClr = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 17, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(255)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: qosClassFwdClr.setStatus('current')
if mibBuilder.loadTexts: qosClassFwdClr.setDescription('10 raised to the power of this value signifies the maximum acceptable forward Cell Loss Ratio value to be used for this expansion. The valid values are from 1 to 15 (both inclusive) and 255. A value of 255 will signify any acceptable forward CLR value.')
qosClassBackClr = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 17, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(255)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: qosClassBackClr.setStatus('current')
if mibBuilder.loadTexts: qosClassBackClr.setDescription('10 raised to the power of this value signifies the maximum acceptable backward Cell Loss Ratio value to be used for this expansion. The valid values are from 1 to 15 (both inclusive) and 255. A value of 255 will signify any acceptable backward CLR value.')
qosClassName = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 17, 1, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 19))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: qosClassName.setStatus('current')
if mibBuilder.loadTexts: qosClassName.setDescription('A name associated with this entry in the qos class table')
pathExtQosMetricTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 18, 1), )
if mibBuilder.loadTexts: pathExtQosMetricTable.setStatus('current')
if mibBuilder.loadTexts: pathExtQosMetricTable.setDescription('Qos metric table for path extension')
pathExtQosMetricEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 18, 1, 1), ).setIndexNames((0, "Fore-Switch-MIB", "pathExtQosMetricIndex"))
if mibBuilder.loadTexts: pathExtQosMetricEntry.setStatus('current')
if mibBuilder.loadTexts: pathExtQosMetricEntry.setDescription('')
pathExtQosMetricIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 18, 1, 1, 1), Integer32())
if mibBuilder.loadTexts: pathExtQosMetricIndex.setStatus('current')
if mibBuilder.loadTexts: pathExtQosMetricIndex.setDescription('')
pathExtQosMetricMaxCtd = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 18, 1, 1, 2), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pathExtQosMetricMaxCtd.setStatus('current')
if mibBuilder.loadTexts: pathExtQosMetricMaxCtd.setDescription('cell transfer delay in microseconds')
pathExtQosMetricMaxCdv = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 18, 1, 1, 3), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pathExtQosMetricMaxCdv.setStatus('current')
if mibBuilder.loadTexts: pathExtQosMetricMaxCdv.setDescription('cell delay variation in microseconds')
pathExtQosMetricMaxClr = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 18, 1, 1, 4), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pathExtQosMetricMaxClr.setStatus('current')
if mibBuilder.loadTexts: pathExtQosMetricMaxClr.setDescription('cell loss ratio. 10**(-n) where n is the returned value')
pathExtQosMetricEntryStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 18, 1, 1, 5), EntryStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pathExtQosMetricEntryStatus.setStatus('current')
if mibBuilder.loadTexts: pathExtQosMetricEntryStatus.setDescription('')
pathExtTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 18, 2), )
if mibBuilder.loadTexts: pathExtTable.setStatus('current')
if mibBuilder.loadTexts: pathExtTable.setDescription('path extension table')
pathExtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 18, 2, 1), ).setIndexNames((0, "Fore-Switch-MIB", "pathPort"), (0, "Fore-Switch-MIB", "pathVPI"))
if mibBuilder.loadTexts: pathExtEntry.setStatus('current')
if mibBuilder.loadTexts: pathExtEntry.setDescription('A table entry containing path Qos Metric information.')
pathExtCbrMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 18, 2, 1, 1), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pathExtCbrMetric.setStatus('current')
if mibBuilder.loadTexts: pathExtCbrMetric.setDescription('index to the path ext qos metric table')
pathExtRtVbrMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 18, 2, 1, 2), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pathExtRtVbrMetric.setStatus('current')
if mibBuilder.loadTexts: pathExtRtVbrMetric.setDescription('index to the path ext qos metric table')
pathExtNrtVbrMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 18, 2, 1, 3), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pathExtNrtVbrMetric.setStatus('current')
if mibBuilder.loadTexts: pathExtNrtVbrMetric.setDescription('index to the path ext qos metric table')
pathExtAbrMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 18, 2, 1, 4), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pathExtAbrMetric.setStatus('current')
if mibBuilder.loadTexts: pathExtAbrMetric.setDescription('index to the path ext qos metric table')
pathExtUbrMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 18, 2, 1, 5), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pathExtUbrMetric.setStatus('current')
if mibBuilder.loadTexts: pathExtUbrMetric.setDescription('index to the path ext qos metric table')
pathExtEntryStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 18, 2, 1, 6), EntryStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pathExtEntryStatus.setStatus('current')
if mibBuilder.loadTexts: pathExtEntryStatus.setDescription('')
outputPathExtTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 18, 3), )
if mibBuilder.loadTexts: outputPathExtTable.setStatus('current')
if mibBuilder.loadTexts: outputPathExtTable.setDescription('')
outputPathExtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 18, 3, 1), ).setIndexNames((0, "Fore-Switch-MIB", "opathPort"), (0, "Fore-Switch-MIB", "opathVPI"))
if mibBuilder.loadTexts: outputPathExtEntry.setStatus('current')
if mibBuilder.loadTexts: outputPathExtEntry.setDescription('')
opathExtCbrMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 18, 3, 1, 1), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: opathExtCbrMetric.setStatus('current')
if mibBuilder.loadTexts: opathExtCbrMetric.setDescription('index to the path ext qos metric table')
opathExtRtVbrMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 18, 3, 1, 2), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: opathExtRtVbrMetric.setStatus('current')
if mibBuilder.loadTexts: opathExtRtVbrMetric.setDescription('index to the path ext qos metric table')
opathExtNrtVbrMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 18, 3, 1, 3), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: opathExtNrtVbrMetric.setStatus('current')
if mibBuilder.loadTexts: opathExtNrtVbrMetric.setDescription('index to the path ext qos metric table')
opathExtAbrMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 18, 3, 1, 4), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: opathExtAbrMetric.setStatus('current')
if mibBuilder.loadTexts: opathExtAbrMetric.setDescription('index to the path ext qos metric table')
opathExtUbrMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 18, 3, 1, 5), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: opathExtUbrMetric.setStatus('current')
if mibBuilder.loadTexts: opathExtUbrMetric.setDescription('index to the path ext qos metric table')
opathExtEntryStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 18, 3, 1, 6), EntryStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: opathExtEntryStatus.setStatus('current')
if mibBuilder.loadTexts: opathExtEntryStatus.setDescription('')
vpGroupTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 18, 4), )
if mibBuilder.loadTexts: vpGroupTable.setStatus('current')
if mibBuilder.loadTexts: vpGroupTable.setDescription('')
vpGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 18, 4, 1), ).setIndexNames((0, "Fore-Switch-MIB", "vpGroupIndex"), (0, "Fore-Switch-MIB", "vpGroupPort"), (0, "Fore-Switch-MIB", "vpGroupVPI"))
if mibBuilder.loadTexts: vpGroupEntry.setStatus('current')
if mibBuilder.loadTexts: vpGroupEntry.setDescription('')
vpGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 18, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vpGroupIndex.setStatus('current')
if mibBuilder.loadTexts: vpGroupIndex.setDescription('Zero mean not belong to any vpgroup group')
vpGroupPort = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 18, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vpGroupPort.setStatus('current')
if mibBuilder.loadTexts: vpGroupPort.setDescription('')
vpGroupVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 18, 4, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vpGroupVPI.setStatus('current')
if mibBuilder.loadTexts: vpGroupVPI.setDescription('')
vpGroupVPCI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 18, 4, 1, 4), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vpGroupVPCI.setStatus('current')
if mibBuilder.loadTexts: vpGroupVPCI.setDescription('')
vpGroupEntryStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 18, 4, 1, 5), EntryStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vpGroupEntryStatus.setStatus('current')
if mibBuilder.loadTexts: vpGroupEntryStatus.setDescription('')
poolConfPPCalls = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 19, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: poolConfPPCalls.setStatus('current')
if mibBuilder.loadTexts: poolConfPPCalls.setDescription('Specifies the number of point to point calls that the switch should handle through pools. The switch comes up with enough resources in the pools to handle so many point to point calls. The new value will take effect at the next reboot.')
poolConfPMPCalls = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 19, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: poolConfPMPCalls.setStatus('current')
if mibBuilder.loadTexts: poolConfPMPCalls.setDescription('Specifies the number of point to multipoint calls that the switch should handle through pools. The switch comes up with enough resources in the pools to handle so many point to multipoint calls. The new value will take effect at the next reboot.')
poolConfMaxPercentage = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 19, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: poolConfMaxPercentage.setStatus('current')
if mibBuilder.loadTexts: poolConfMaxPercentage.setDescription('Limits the max percentage of the main heap that can be taken for pool configuration purposes.')
swBoardTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 7, 1), )
if mibBuilder.loadTexts: swBoardTable.setStatus('current')
if mibBuilder.loadTexts: swBoardTable.setDescription('A table of ATM switch cluster configuration information.')
swBoardEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 7, 1, 1), ).setIndexNames((0, "Fore-Switch-MIB", "swBoardIndex"))
if mibBuilder.loadTexts: swBoardEntry.setStatus('current')
if mibBuilder.loadTexts: swBoardEntry.setDescription('A table entry containing ATM switch cluster information, index by the switch board.')
swBoardIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 7, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swBoardIndex.setStatus('current')
if mibBuilder.loadTexts: swBoardIndex.setDescription('The index of this switch board within the ATM switch cluster.')
swBoardMaxPaths = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 7, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swBoardMaxPaths.setStatus('current')
if mibBuilder.loadTexts: swBoardMaxPaths.setDescription('The maximum number of input VPIs (Virtual Path Identifier) on this switch board.')
swBoardMaxChannels = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 7, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swBoardMaxChannels.setStatus('current')
if mibBuilder.loadTexts: swBoardMaxChannels.setDescription('The maximum number of input VCIs (Virtual Channel Identifiers) on this switch board.')
swBoardAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 7, 1, 1, 4), SpansAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swBoardAtmAddress.setStatus('current')
if mibBuilder.loadTexts: swBoardAtmAddress.setDescription('The address of this ATM switch board.')
swBoardUptime = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 7, 1, 1, 5), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swBoardUptime.setStatus('current')
if mibBuilder.loadTexts: swBoardUptime.setDescription('The length of time this ATM switch board has been up, in hundredths of a second.')
swBoardCDV = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 7, 1, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swBoardCDV.setStatus('deprecated')
if mibBuilder.loadTexts: swBoardCDV.setDescription('The switch board Cell Delay Variation (CDV) specified in microseconds, indicates the time window in which a cell may be received on a connection and be accepted. A cell that is received on a connection outside the CDV window will be tagged or dropped as indicated by the swBoardPolicingAction object. The boardCDV is the default CDV for all the connection on this switch board. Individual connections can be set to explicitly override this value.')
swBoardPolicingAction = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 7, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("tag", 1), ("drop", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swBoardPolicingAction.setStatus('deprecated')
if mibBuilder.loadTexts: swBoardPolicingAction.setDescription('This object indicates the action the switch board will take in case of bandwidth violation. The swBoardPolicingAction is the default policing action for all the connections on this switch board. Individual connections can be set to explicitly override this default action.')
swBoardNsapPrefix = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 7, 1, 1, 8), NsapPrefix()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swBoardNsapPrefix.setStatus('current')
if mibBuilder.loadTexts: swBoardNsapPrefix.setDescription("The default NSAP (Network Service Access Point) prefix for this ATM switch board. The NSAP prefix will be used in the ILMI address registration message as well as the 'hello-indication' SPANS-NNI message.")
swBoardClockScalingFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 7, 1, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swBoardClockScalingFactor.setStatus('current')
if mibBuilder.loadTexts: swBoardClockScalingFactor.setDescription('This specifies the value written into the switch boards Time Scaling Factor register. See Sec. 3.2.1 for more info. The Time Scaling Factor is an 8-bit register that determines the number of 25ns clock cycles that occur between increments of the Time and Interrupt Timer Reigsters. Increasing the Time Scale Factor increases the burst tolerance that can be represented by the policer (in multiples of .838 seconds) while reducing the precision of the policer by a similar factor. The possible values for this variable are 1 through 255.')
swBoardDebugMode = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 7, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swBoardDebugMode.setStatus('current')
if mibBuilder.loadTexts: swBoardDebugMode.setDescription('This object indicates whether or not debugging services are available for this switch.')
swBoardMulticastMode = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 7, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("non-extended", 1), ("extended", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swBoardMulticastMode.setStatus('current')
if mibBuilder.loadTexts: swBoardMulticastMode.setDescription('This object identifies the mode in which this ATM switch board is operating. Extended-mode provides greater flexibility when selecting VCI for point to multipoint connections. Non-extended (mixed) mode is more restrictive. If any series A or B netmods are present, the switch board should operate in non-extended mode.')
swBoardFingerMode = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 7, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swBoardFingerMode.setStatus('current')
if mibBuilder.loadTexts: swBoardFingerMode.setDescription('This object indicates whether or not finger services are available for this switch.')
swBoardATMLayerOAM = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 7, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swBoardATMLayerOAM.setStatus('deprecated')
if mibBuilder.loadTexts: swBoardATMLayerOAM.setDescription('This object specifies whether the processing of ATM layer OAM cells by this switch board is enabled or disabled.')
swBoardTopoTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 8, 1), )
if mibBuilder.loadTexts: swBoardTopoTable.setStatus('current')
if mibBuilder.loadTexts: swBoardTopoTable.setDescription('A table of switch board topology general information.')
swBoardTopoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 8, 1, 1), ).setIndexNames((0, "Fore-Switch-MIB", "swBoardTopoIndex"))
if mibBuilder.loadTexts: swBoardTopoEntry.setStatus('current')
if mibBuilder.loadTexts: swBoardTopoEntry.setDescription('A table entry containing switch board topology information.')
swBoardTopoIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 8, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swBoardTopoIndex.setStatus('current')
if mibBuilder.loadTexts: swBoardTopoIndex.setDescription('The index of this switch board within the ATM switch cluster. This object should be the same as the swBoardIndex.')
swBoardTopoNumberOfLinks = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 8, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swBoardTopoNumberOfLinks.setStatus('current')
if mibBuilder.loadTexts: swBoardTopoNumberOfLinks.setDescription('Current number of inter-switch links known by this switch board.')
swBoardLinkTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 8, 2), )
if mibBuilder.loadTexts: swBoardLinkTable.setStatus('current')
if mibBuilder.loadTexts: swBoardLinkTable.setDescription('A table of ATM links that are known to a given switch board in the switch cluster. If all boards in the switch cluster are interconnected, all swBoardLinkEntries will be identical.')
swBoardLinkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 8, 2, 1), ).setIndexNames((0, "Fore-Switch-MIB", "swBoardLinkIndex"), (0, "Fore-Switch-MIB", "swBoardLinkSrc"), (0, "Fore-Switch-MIB", "swBoardLinkDest"))
if mibBuilder.loadTexts: swBoardLinkEntry.setStatus('current')
if mibBuilder.loadTexts: swBoardLinkEntry.setDescription('A table entry containing link information known to a given switch board.')
swBoardLinkIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 8, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swBoardLinkIndex.setStatus('current')
if mibBuilder.loadTexts: swBoardLinkIndex.setDescription('The index of this switch board within the ATM switch cluster. This object should be the same as the swBoardIndex.')
swBoardLinkSrc = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 8, 2, 1, 2), SpansAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swBoardLinkSrc.setStatus('current')
if mibBuilder.loadTexts: swBoardLinkSrc.setDescription('The ATM address of the source switch of this link.')
swBoardLinkDest = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 8, 2, 1, 3), SpansAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swBoardLinkDest.setStatus('current')
if mibBuilder.loadTexts: swBoardLinkDest.setDescription('The ATM address of the destination switch of this link.')
swBoardLinkCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 8, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swBoardLinkCapacity.setStatus('current')
if mibBuilder.loadTexts: swBoardLinkCapacity.setDescription('The free capacity of this link in kilobits per second.')
swBoardLinkAge = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 8, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swBoardLinkAge.setStatus('current')
if mibBuilder.loadTexts: swBoardLinkAge.setDescription('The freshness of the information about this link. The actual value has no units associated with it. It should be used for comparison.')
oamGeneratingChannelTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 12, 1), )
if mibBuilder.loadTexts: oamGeneratingChannelTable.setStatus('current')
if mibBuilder.loadTexts: oamGeneratingChannelTable.setDescription('When an AIS cell is generated on a particular channel it gets added to this table. If a channel is deleted the corresponding entry is removed from this table.')
oamGeneratingChannelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 12, 1, 1), ).setIndexNames((0, "Fore-Switch-MIB", "chanPort"), (0, "Fore-Switch-MIB", "chanVPI"), (0, "Fore-Switch-MIB", "chanVCI"))
if mibBuilder.loadTexts: oamGeneratingChannelEntry.setStatus('current')
if mibBuilder.loadTexts: oamGeneratingChannelEntry.setDescription('A table entry containing a channel which has generated AIS cells.')
oamGeneratingChannelCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 12, 1, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: oamGeneratingChannelCells.setStatus('current')
if mibBuilder.loadTexts: oamGeneratingChannelCells.setDescription('The number of AIS OAM cells generated on this channel.')
oamGeneratingOpathTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 12, 2), )
if mibBuilder.loadTexts: oamGeneratingOpathTable.setStatus('current')
if mibBuilder.loadTexts: oamGeneratingOpathTable.setDescription('When an RDI cell is generated on a particular outgoing path it gets added to this table. If an outgoing path is deleted the corresponding entry is removed from this table.')
oamGeneratingOpathEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 12, 2, 1), ).setIndexNames((0, "Fore-Switch-MIB", "opathPort"), (0, "Fore-Switch-MIB", "opathVPI"))
if mibBuilder.loadTexts: oamGeneratingOpathEntry.setStatus('current')
if mibBuilder.loadTexts: oamGeneratingOpathEntry.setDescription('A table entry containing an outgoing path which has generated RDI cells.')
oamGeneratingOpathCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 12, 2, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: oamGeneratingOpathCells.setStatus('current')
if mibBuilder.loadTexts: oamGeneratingOpathCells.setDescription('The number of RDI OAM cells generated on this path.')
oamGeneratingPathrTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 12, 3), )
if mibBuilder.loadTexts: oamGeneratingPathrTable.setStatus('current')
if mibBuilder.loadTexts: oamGeneratingPathrTable.setDescription('When an AIS cell is generated on a particular through path it gets added to this table. If a through path is deleted the corresponding entry is removed from this table.')
oamGeneratingPathrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 12, 3, 1), ).setIndexNames((0, "Fore-Switch-MIB", "pathrInputPort"), (0, "Fore-Switch-MIB", "pathrInputVPI"), (0, "Fore-Switch-MIB", "pathrOutputPort"), (0, "Fore-Switch-MIB", "pathrOutputVPI"))
if mibBuilder.loadTexts: oamGeneratingPathrEntry.setStatus('current')
if mibBuilder.loadTexts: oamGeneratingPathrEntry.setDescription('A table entry containing a through path which has generated AIS cells.')
oamGeneratingPathrCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 12, 3, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: oamGeneratingPathrCells.setStatus('current')
if mibBuilder.loadTexts: oamGeneratingPathrCells.setDescription('The number of AIS OAM cells generated on this path.')
oamReceivedPathTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 12, 4), )
if mibBuilder.loadTexts: oamReceivedPathTable.setStatus('current')
if mibBuilder.loadTexts: oamReceivedPathTable.setDescription('When an OAM cell is received on a particular terminating path it gets added to this table. If a terminating path is deleted the corresponding entry is removed from this table.')
oamReceivedPathEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 12, 4, 1), ).setIndexNames((0, "Fore-Switch-MIB", "pathPort"), (0, "Fore-Switch-MIB", "pathVPI"))
if mibBuilder.loadTexts: oamReceivedPathEntry.setStatus('current')
if mibBuilder.loadTexts: oamReceivedPathEntry.setDescription('A table entry containing a terminating path which has received OAM cells.')
oamReceivedPathAISCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 12, 4, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: oamReceivedPathAISCells.setStatus('current')
if mibBuilder.loadTexts: oamReceivedPathAISCells.setDescription('The number of AIS OAM cells received on this path.')
oamReceivedPathRDICells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 12, 4, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: oamReceivedPathRDICells.setStatus('current')
if mibBuilder.loadTexts: oamReceivedPathRDICells.setDescription('The number of RDI OAM cells received on this path.')
guardTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 13, 1), )
if mibBuilder.loadTexts: guardTable.setStatus('current')
if mibBuilder.loadTexts: guardTable.setDescription('The OAM guards for each board in a switch.')
guardEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 13, 1, 1), ).setIndexNames((0, "Fore-Switch-MIB", "boardIndex"))
if mibBuilder.loadTexts: guardEntry.setStatus('current')
if mibBuilder.loadTexts: guardEntry.setDescription('A table entry containing the guards for a board.')
oamGuard = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 13, 1, 1, 1), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: oamGuard.setStatus('current')
if mibBuilder.loadTexts: oamGuard.setDescription('The value of sysUpTime the last time an OAM cell was generated/received on this board.')
trapNumberOfDest = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trapNumberOfDest.setStatus('deprecated')
if mibBuilder.loadTexts: trapNumberOfDest.setDescription('The current number of configured trap destinations. All traps are sent to all destinations.')
trapDestTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 2, 1, 2), )
if mibBuilder.loadTexts: trapDestTable.setStatus('deprecated')
if mibBuilder.loadTexts: trapDestTable.setDescription('A table of destinations to which the agent sends traps.')
trapDestEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 2, 1, 2, 1), ).setIndexNames((0, "Fore-Switch-MIB", "trapDest"))
if mibBuilder.loadTexts: trapDestEntry.setStatus('deprecated')
if mibBuilder.loadTexts: trapDestEntry.setDescription('A table entry containing address of a management station, to which the agent sends traps.')
trapDest = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 2, 1, 2, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trapDest.setStatus('deprecated')
if mibBuilder.loadTexts: trapDest.setDescription('Address to which the agent sends traps. Usually a network management station sets this address to itself.')
trapDestStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 2, 1, 2, 1, 2), EntryStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: trapDestStatus.setStatus('deprecated')
if mibBuilder.loadTexts: trapDestStatus.setDescription('The status of this trap destination entry.')
snmpReconfigure = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 2, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpReconfigure.setStatus('deprecated')
if mibBuilder.loadTexts: snmpReconfigure.setDescription('The SNMP agent will reset itself and reconfigure its database from the default database when this variable is set to enable(2). After reconfiguring is done, the value of this object is disable(1). Note that enabling snmpReconfigure will end up with a loss of the entire ATM configuration.')
snmpReadCommunity = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 2, 2, 2), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpReadCommunity.setStatus('deprecated')
if mibBuilder.loadTexts: snmpReadCommunity.setDescription("The community string used for SNMP (v1) read operations, i.e. get and getnext requests. This has been deprecated, since it's now possible to have more than one read community string. Setting this variable will result in all current read community strings being deleted, and this one added. Note this object is write-only and reading it will result in implementation-specific results.")
snmpWriteCommunity = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 2, 2, 3), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpWriteCommunity.setStatus('deprecated')
if mibBuilder.loadTexts: snmpWriteCommunity.setDescription("The community string used for SNMP (v1) write operations, i.e. set requests. This has been deprecated, since it's now possible to have more than one write community string. Setting this variable will result in all current write community strings being deleted, and this one added. Note this object is write-only and reading it will result in implementation-specific results.")
snmpWarmStart = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 2, 2, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpWarmStart.setStatus('current')
if mibBuilder.loadTexts: snmpWarmStart.setDescription('The SNMP agent will reset the switch, and restart the switch control software using the existing configuration database when this variable is set to enable(2). After the warm start, the value of this object is disable(1). A warmStart trap is sent after the switch control software restarts.')
snmpColdStart = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 2, 2, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disable", 1), ("enableResetATMconf", 2), ("enableResetAllConf", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpColdStart.setStatus('current')
if mibBuilder.loadTexts: snmpColdStart.setDescription('The SNMP agent will reset the configuration database for all ATM related configuration objects, and reboot the switch, when this variable is set to enableResetAtmConf(2). When the value of this variable is set to enableResetAllConf(3), all configuration objects, including ATM and IP objects will be removed, and the switch will be rebooted. A coldStart trap is sent just before the trap destination table is removed. After the cold start, the value of this object is disable(1).')
snmpRemoteSetsStatus = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 2, 2, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpRemoteSetsStatus.setStatus('deprecated')
if mibBuilder.loadTexts: snmpRemoteSetsStatus.setDescription('The value of this object controls SNMP set operations from remote management stations. The default value is enabled(1). If it is set to disabled(2), set requests from remote management stations will not be processed and an authorization error is returned. This value can be set only by the manager running on this device.')
snmpThisAgentBoardNumber = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 2, 5, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpThisAgentBoardNumber.setStatus('current')
if mibBuilder.loadTexts: snmpThisAgentBoardNumber.setDescription('The instance of this agent type within the enclosure; typically a board number.')
snmpAgentTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 2, 5, 2), )
if mibBuilder.loadTexts: snmpAgentTable.setStatus('current')
if mibBuilder.loadTexts: snmpAgentTable.setDescription('A table of SNMP agent IP addresses. Each entry in this table represents an IP address which may be used to reach the associated SNMP agent, assuming appropriate network connectivity.')
snmpAgentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 2, 5, 2, 1), ).setIndexNames((0, "Fore-Switch-MIB", "snmpAgentBoardNumber"), (0, "Fore-Switch-MIB", "snmpAgentInterface"))
if mibBuilder.loadTexts: snmpAgentEntry.setStatus('current')
if mibBuilder.loadTexts: snmpAgentEntry.setDescription('A table entry containing the identity and address of an SNMP agent.')
snmpAgentBoardNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 2, 5, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpAgentBoardNumber.setStatus('current')
if mibBuilder.loadTexts: snmpAgentBoardNumber.setDescription('The number of the SNMP agent within this enclosure. This generally corresponds to a board number.')
snmpAgentInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 2, 5, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpAgentInterface.setStatus('current')
if mibBuilder.loadTexts: snmpAgentInterface.setDescription('An interface number associated with the agent IP address. This number is for tabulation purposes only, and has no other significance.')
snmpAgentAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 2, 5, 2, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpAgentAddress.setStatus('current')
if mibBuilder.loadTexts: snmpAgentAddress.setDescription('The IP address of the identified SNMP agent.')
asxSwLinkDown = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 0)).setObjects(("Fore-Switch-MIB", "portNumber"), ("Fore-Switch-MIB", "portName"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxSwLinkDown.setStatus('current')
if mibBuilder.loadTexts: asxSwLinkDown.setDescription('An asxSwLinkDown trap signifies that the sending protocol entity recognizes a failure in one of the ATM Switch links that is connected to another switch.')
asxSwLinkUp = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 1)).setObjects(("Fore-Switch-MIB", "portNumber"), ("Fore-Switch-MIB", "portName"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxSwLinkUp.setStatus('current')
if mibBuilder.loadTexts: asxSwLinkUp.setDescription('An asxSwLinkUp trap signifies that the sending protocol entity recognizes that one of the ATM Switch links that is connected to another switch has come up.')
asxHostLinkDown = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 2)).setObjects(("Fore-Switch-MIB", "portNumber"), ("Fore-Switch-MIB", "portName"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxHostLinkDown.setStatus('current')
if mibBuilder.loadTexts: asxHostLinkDown.setDescription('An asxHostLinkDown trap signifies that the sending protocol entity recognizes a failure in one of the ATM Switch links that is connected to a host.')
asxHostLinkUp = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 3)).setObjects(("Fore-Switch-MIB", "portNumber"), ("Fore-Switch-MIB", "portName"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxHostLinkUp.setStatus('current')
if mibBuilder.loadTexts: asxHostLinkUp.setDescription('An asxHostLinkUp trap signifies that the sending protocol entity recognizes that one of the ATM Switch links that is connected to a host has come up.')
asxNetModuleDown = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 4)).setObjects(("Fore-Switch-MIB", "moduleBoard"), ("Fore-Switch-MIB", "moduleNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxNetModuleDown.setStatus('current')
if mibBuilder.loadTexts: asxNetModuleDown.setDescription('An asxNetModuleDown trap signifies that the sending protocol entity recognizes a failure in one of the ATM Switch network modules, that is identified by the board and the module numbers. This is probably caused by a hot-swap of a network module.')
asxNetModuleUp = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 5)).setObjects(("Fore-Switch-MIB", "moduleBoard"), ("Fore-Switch-MIB", "moduleNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxNetModuleUp.setStatus('current')
if mibBuilder.loadTexts: asxNetModuleUp.setDescription('An asxNetModuleUp trap signifies that the sending protocol entity recognizes a new operational ATM Switch network module, that is identified by the board and the module numbers. This is probably caused by a hot-swap of a network module.')
asxPsInputDown = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 6)).setObjects(("Fore-Switch-MIB", "envPowerSupplyIndex"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxPsInputDown.setStatus('current')
if mibBuilder.loadTexts: asxPsInputDown.setDescription('This trap alerts that one ATM switch power supply failed due to failure in the input voltage. The power supply that failed is identified by the power supply index. Note that an input voltage may be out of spec and may not cause a power supply failure if high loads are not applied.')
asxPsInputUp = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 7)).setObjects(("Fore-Switch-MIB", "envPowerSupplyIndex"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxPsInputUp.setStatus('current')
if mibBuilder.loadTexts: asxPsInputUp.setDescription('This trap alerts that one ATM switch power supply that had an input failure is up. The power supply that is back up is identified by the power supply index.')
asxPsOutputDown = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 9)).setObjects(("Fore-Switch-MIB", "envPowerSupplyIndex"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxPsOutputDown.setStatus('current')
if mibBuilder.loadTexts: asxPsOutputDown.setDescription('This trap alerts that one ATM switch power supply output failed, or the power supply was physically removed. The power supply that failed is identified by the power supply index.')
asxPsOutputUp = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 10)).setObjects(("Fore-Switch-MIB", "envPowerSupplyIndex"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxPsOutputUp.setStatus('current')
if mibBuilder.loadTexts: asxPsOutputUp.setDescription('This trap alerts that one ATM switch power supply that had an output failure or was removed is now up. The power supply that is back up is identified by the power supply index.')
asxFanBankDown = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 22)).setObjects(("Fore-Switch-MIB", "envFanBankIndex"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxFanBankDown.setStatus('current')
if mibBuilder.loadTexts: asxFanBankDown.setDescription('This trap alerts that one ATM switch fan bank failed. The fan bank that failed is identified by the fan bank index.')
asxFanBankUp = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 23)).setObjects(("Fore-Switch-MIB", "envFanBankIndex"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxFanBankUp.setStatus('current')
if mibBuilder.loadTexts: asxFanBankUp.setDescription('This trap alerts that one ATM switch fan bank is up. The fan bank that is back up is identified by the fan bank index.')
asxLinkDown = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 28)).setObjects(("Fore-Switch-MIB", "portNumber"), ("Fore-Switch-MIB", "portName"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxLinkDown.setStatus('current')
if mibBuilder.loadTexts: asxLinkDown.setDescription('This trap alerts that the link that is identified by portName was configured up, but its underlying physical layer has lost its carrier (or the framing bit) and is currently down.')
asxLinkUp = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 29)).setObjects(("Fore-Switch-MIB", "portNumber"), ("Fore-Switch-MIB", "portName"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxLinkUp.setStatus('current')
if mibBuilder.loadTexts: asxLinkUp.setDescription('This trap alerts that the link that is identified by portName is back up.')
asxSpansDown = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 30)).setObjects(("Fore-Switch-MIB", "portName"), ("Fore-Switch-MIB", "sigPathPort"), ("Fore-Switch-MIB", "sigPathVPI"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxSpansDown.setStatus('current')
if mibBuilder.loadTexts: asxSpansDown.setDescription('This trap alerts that the SPANS signalling on the link that is identified by the sigPathPort and sigPathVPI failed.')
asxSpansUp = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 31)).setObjects(("Fore-Switch-MIB", "portName"), ("Fore-Switch-MIB", "sigPathPort"), ("Fore-Switch-MIB", "sigPathVPI"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxSpansUp.setStatus('current')
if mibBuilder.loadTexts: asxSpansUp.setDescription('This trap alerts that the SPANS signalling on the link that is identified by the sigPathPort and sigPathVPI is up.')
asxTempSensorOverTemp = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 32)).setObjects(("Fore-Switch-MIB", "envTempSensorIndex"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxTempSensorOverTemp.setStatus('current')
if mibBuilder.loadTexts: asxTempSensorOverTemp.setDescription('This trap alerts that one of the temperature sensors indicates over temperature. The temperature sensor is identified by the temperature sensor index.')
asxTempSensorRegularTemp = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 33)).setObjects(("Fore-Switch-MIB", "envTempSensorIndex"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxTempSensorRegularTemp.setStatus('current')
if mibBuilder.loadTexts: asxTempSensorRegularTemp.setDescription('This trap alerts that one of the temperature sensors indicates regular temperature. The temperature sensor is identified by the temperature sensor index.')
asxFabricTemperatureOverTemp = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 34)).setObjects(("Fore-Switch-MIB", "envFabricIndex"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxFabricTemperatureOverTemp.setStatus('current')
if mibBuilder.loadTexts: asxFabricTemperatureOverTemp.setDescription('This trap alerts that one of the temperature sensors indicates over temperature. The temperature sensor is identified by the temperature sensor index.')
asxFabricTemperatureRegularTemp = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 35)).setObjects(("Fore-Switch-MIB", "envFabricIndex"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxFabricTemperatureRegularTemp.setStatus('current')
if mibBuilder.loadTexts: asxFabricTemperatureRegularTemp.setDescription('This trap alerts that one of the temperature sensors indicates regular temperature. The temperature sensor is identified by the temperature sensor index.')
asxSonetLOSDetected = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 36)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxSonetLOSDetected.setStatus('current')
if mibBuilder.loadTexts: asxSonetLOSDetected.setDescription('This trap indicates that the specified SONET port is experiencing Loss Of Signal. Bellcore Document TA-NWT-000253 Section 6.3.1.1.1 states that... A SONET NE shall declare a LOS failure when the LOS defect persists for 2.5 (+- .5) seconds, or when a LOS defect is present and the criteria for LOF failure declaration have been met.')
asxSonetLOSCleared = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 37)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxSonetLOSCleared.setStatus('current')
if mibBuilder.loadTexts: asxSonetLOSCleared.setDescription('This trap indicates that the LOS condition identified by trap asxSonetLOSDetected has been cleared.')
asxSonetPathLabelDetected = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 38)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxSonetPathLabelDetected.setStatus('current')
if mibBuilder.loadTexts: asxSonetPathLabelDetected.setDescription('This trap indicates that the specified SONET port is receiving and errored C2 Path Label byte. Reference Bellcore Document TA-NWT-000253 Section 3.3.2.3 and 6.3.1.1.8 the Path Label (C2) byte should have the value 0x13 or 0x01.')
asxSonetPathLabelCleared = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 39)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxSonetPathLabelCleared.setStatus('current')
if mibBuilder.loadTexts: asxSonetPathLabelCleared.setDescription('This trap indicates that the Errored Path Label (C2) byte error condition signaled by the asxSonetPathLabelDetected trap has been cleared.')
asxSonetLineAISDetected = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 40)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxSonetLineAISDetected.setStatus('current')
if mibBuilder.loadTexts: asxSonetLineAISDetected.setDescription('This trap indicates that the specified SONET port is receiving a Line level Alarm Indication Signal from the far-end equipment.')
asxSonetLineAISCleared = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 41)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxSonetLineAISCleared.setStatus('current')
if mibBuilder.loadTexts: asxSonetLineAISCleared.setDescription('This trap indicates that the Line AIS error condition signaled by the asxSonetLineAISDetected trap has been cleared.')
asxDS3PLCPYellowDetected = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 46)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxDS3PLCPYellowDetected.setStatus('current')
if mibBuilder.loadTexts: asxDS3PLCPYellowDetected.setDescription('This trap indicates that the specified DS3 port has detected incoming PLCP Yellow Alarm.')
asxDS3PLCPYellowCleared = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 47)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxDS3PLCPYellowCleared.setStatus('current')
if mibBuilder.loadTexts: asxDS3PLCPYellowCleared.setDescription('This trap indicates that the specified DS3 port has detected clearance of incoming PLCP Yellow Alarm.')
asxDS3PLCPLOFDetected = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 48)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxDS3PLCPLOFDetected.setStatus('current')
if mibBuilder.loadTexts: asxDS3PLCPLOFDetected.setDescription('This trap indicates that the specified DS3 port has detected incoming PLCP LOF Alarm.')
asxDS3PLCPLOFCleared = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 49)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxDS3PLCPLOFCleared.setStatus('current')
if mibBuilder.loadTexts: asxDS3PLCPLOFCleared.setDescription('This trap indicates that the specified DS3 port has detected clearance of incoming PLCP LOF Alarm.')
asxDS3LOFDetected = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 50)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxDS3LOFDetected.setStatus('current')
if mibBuilder.loadTexts: asxDS3LOFDetected.setDescription('This trap indicates that Loss Of Frame(LOF) is detected on the incoming signal.')
asxDS3LOFCleared = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 51)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxDS3LOFCleared.setStatus('current')
if mibBuilder.loadTexts: asxDS3LOFCleared.setDescription('This trap indicates that Loss Of Frame is cleared on the incoming signal.')
asxDS3AISDetected = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 52)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxDS3AISDetected.setStatus('current')
if mibBuilder.loadTexts: asxDS3AISDetected.setDescription('This trap indicates that AIS Alarm is detected on the incoming signal.')
asxDS3AISCleared = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 53)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxDS3AISCleared.setStatus('current')
if mibBuilder.loadTexts: asxDS3AISCleared.setDescription('This trap indicates that AIS Alarm is cleared on the incoming signal.')
asxDS1PLCPYellowDetected = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 60)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxDS1PLCPYellowDetected.setStatus('current')
if mibBuilder.loadTexts: asxDS1PLCPYellowDetected.setDescription('This trap indicates that the specified DS1 port has detected incoming PLCP Yellow Alarm.')
asxDS1PLCPYellowCleared = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 61)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxDS1PLCPYellowCleared.setStatus('current')
if mibBuilder.loadTexts: asxDS1PLCPYellowCleared.setDescription('This trap indicates that the specified DS1 port has detected clearance of incoming PLCP Yellow Alarm.')
asxDS1PLCPLOFDetected = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 62)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxDS1PLCPLOFDetected.setStatus('current')
if mibBuilder.loadTexts: asxDS1PLCPLOFDetected.setDescription('This trap indicates that the specified DS1 port has detected incoming PLCP LOF Alarm.')
asxDS1PLCPLOFCleared = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 63)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxDS1PLCPLOFCleared.setStatus('current')
if mibBuilder.loadTexts: asxDS1PLCPLOFCleared.setDescription('This trap indicates that the specified DS1 port has detected clearance of incoming PLCP LOF Alarm.')
asxDS1YellowDetected = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 64)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxDS1YellowDetected.setStatus('current')
if mibBuilder.loadTexts: asxDS1YellowDetected.setDescription('This trap indicates that Yellow Alarm is detected on the incoming signal.')
asxDS1YellowCleared = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 65)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxDS1YellowCleared.setStatus('current')
if mibBuilder.loadTexts: asxDS1YellowCleared.setDescription('This trap indicates that Yellow Alarm is cleared on the incoming signal.')
asxDS1AISDetected = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 66)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxDS1AISDetected.setStatus('current')
if mibBuilder.loadTexts: asxDS1AISDetected.setDescription('This trap indicates that AIS Alarm is detected on the incoming signal.')
asxDS1AISCleared = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 67)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxDS1AISCleared.setStatus('current')
if mibBuilder.loadTexts: asxDS1AISCleared.setDescription('This trap indicates that AIS Alarm is cleared on the incoming signal.')
asxDS1LOSDetected = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 68)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxDS1LOSDetected.setStatus('current')
if mibBuilder.loadTexts: asxDS1LOSDetected.setDescription('This trap indicates that LOS Alarm is detected on the incoming signal.')
asxDS1LOSCleared = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 69)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxDS1LOSCleared.setStatus('current')
if mibBuilder.loadTexts: asxDS1LOSCleared.setDescription('This trap indicates that LOS Alarm is cleared on the incoming signal.')
asxDS1LOFDetected = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 70)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxDS1LOFDetected.setStatus('current')
if mibBuilder.loadTexts: asxDS1LOFDetected.setDescription('This trap indicates that LOF Alarm is detected on the incoming signal.')
asxDS1LOFCleared = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 71)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxDS1LOFCleared.setStatus('current')
if mibBuilder.loadTexts: asxDS1LOFCleared.setDescription('This trap indicates that LOF Alarm is cleared on the incoming signal.')
asxDS3FERFDetected = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 74)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxDS3FERFDetected.setStatus('current')
if mibBuilder.loadTexts: asxDS3FERFDetected.setDescription('This trap indicates that FERF Alarm or DS3 Yellow Alarm is detected on the incoming signal.')
asxDS3FERFCleared = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 75)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxDS3FERFCleared.setStatus('current')
if mibBuilder.loadTexts: asxDS3FERFCleared.setDescription('This trap indicates that FERF Alarm or DS3 Yellow Alarm is cleared on the incoming signal.')
asxE3YellowDetected = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 78)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxE3YellowDetected.setStatus('current')
if mibBuilder.loadTexts: asxE3YellowDetected.setDescription('This trap indicates that the Yellow Alarm is being detected on the incoming signal.')
asxE3YellowCleared = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 79)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxE3YellowCleared.setStatus('current')
if mibBuilder.loadTexts: asxE3YellowCleared.setDescription('This trap indicates that Yellow alarm has cleared on the incoming signal.')
asxE3OOFDetected = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 80)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxE3OOFDetected.setStatus('current')
if mibBuilder.loadTexts: asxE3OOFDetected.setDescription('This trap indicates that Out Of Frame (OOF) is detected on the incoming signal.')
asxE3OOFCleared = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 81)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxE3OOFCleared.setStatus('current')
if mibBuilder.loadTexts: asxE3OOFCleared.setDescription('This trap indicates that Loss Of Frame is cleared on the incoming signal.')
asxE3AtmLCDDetected = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 82)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxE3AtmLCDDetected.setStatus('current')
if mibBuilder.loadTexts: asxE3AtmLCDDetected.setDescription('This trap indicates that the specified E3 port is experiencing Loss of Cell Deliniation (LCD). A LCD failure is declared when the LCD defect persists for a period of 2.5 +/- 0.5 seconds.')
asxE3AtmLCDCleared = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 83)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxE3AtmLCDCleared.setStatus('current')
if mibBuilder.loadTexts: asxE3AtmLCDCleared.setDescription('This trap indicates that the LCD failure identified by trap asxE3AtmLCDDetected has been cleared. A LCD failure is cleared when the LCD defect is absent for 10 +/- 0.5 seconds.')
asxE3PLCPYellowDetected = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 86)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxE3PLCPYellowDetected.setStatus('current')
if mibBuilder.loadTexts: asxE3PLCPYellowDetected.setDescription('This trap indicates that the specified E3 port has detected incoming PLCP Yellow Alarm.')
asxE3PLCPYellowCleared = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 87)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxE3PLCPYellowCleared.setStatus('current')
if mibBuilder.loadTexts: asxE3PLCPYellowCleared.setDescription('This trap indicates that the specified E3 port has detected clearance of incoming PLCP Yellow Alarm.')
asxE1YellowDetected = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 90)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxE1YellowDetected.setStatus('current')
if mibBuilder.loadTexts: asxE1YellowDetected.setDescription('This trap indicates that the Yellow Alarm is being detected on the incoming signal.')
asxE1YellowCleared = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 91)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxE1YellowCleared.setStatus('current')
if mibBuilder.loadTexts: asxE1YellowCleared.setDescription('This trap indicates that Yellow alarm has cleared on the incoming signal.')
asxE1LOFDetected = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 92)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxE1LOFDetected.setStatus('current')
if mibBuilder.loadTexts: asxE1LOFDetected.setDescription('This trap indicates that LOF is being detected on the incoming signal.')
asxE1LOFCleared = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 93)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxE1LOFCleared.setStatus('current')
if mibBuilder.loadTexts: asxE1LOFCleared.setDescription('This trap indicates that LOF is cleared on the incoming signal.')
asxE1PLCPYellowDetected = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 96)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxE1PLCPYellowDetected.setStatus('current')
if mibBuilder.loadTexts: asxE1PLCPYellowDetected.setDescription('This trap indicates that the specified E1 port has detected incoming PLCP Yellow Alarm.')
asxE1PLCPYellowCleared = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 97)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxE1PLCPYellowCleared.setStatus('current')
if mibBuilder.loadTexts: asxE1PLCPYellowCleared.setDescription('This trap indicates that the specified E1 port has detected clearance of incoming PLCP Yellow Alarm.')
asxE1PLCPLOFDetected = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 98)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxE1PLCPLOFDetected.setStatus('current')
if mibBuilder.loadTexts: asxE1PLCPLOFDetected.setDescription('This trap indicates that the specified E1 port has detected incoming PLCP LOF Alarm.')
asxE1PLCPLOFCleared = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 99)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxE1PLCPLOFCleared.setStatus('current')
if mibBuilder.loadTexts: asxE1PLCPLOFCleared.setDescription('This trap indicates that incoming PLCP LOF alarm has been cleared on the specified E1 port.')
asxE1LOSDetected = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 100)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxE1LOSDetected.setStatus('current')
if mibBuilder.loadTexts: asxE1LOSDetected.setDescription('This trap indicates that the specified E1 port has detected incoming LOS Alarm.')
asxE1LOSCleared = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 101)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxE1LOSCleared.setStatus('current')
if mibBuilder.loadTexts: asxE1LOSCleared.setDescription('This trap indicates that incoming LOS alarm has been cleared on the specified E1 port.')
asxE1AISDetected = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 102)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxE1AISDetected.setStatus('current')
if mibBuilder.loadTexts: asxE1AISDetected.setDescription('This trap indicates that the specified E1 port has detected incoming AIS Alarm.')
asxE1AISCleared = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 103)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxE1AISCleared.setStatus('current')
if mibBuilder.loadTexts: asxE1AISCleared.setDescription('This trap indicates that incoming AIS alarm has been cleared on the specified E1 port.')
asxE3AISDetected = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 104)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxE3AISDetected.setStatus('current')
if mibBuilder.loadTexts: asxE3AISDetected.setDescription('This trap indicates that the specified E3 port has detected incoming AIS Alarm.')
asxE3AISCleared = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 105)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxE3AISCleared.setStatus('current')
if mibBuilder.loadTexts: asxE3AISCleared.setDescription('This trap indicates that incoming AIS alarm has been cleared on the specified E3 port.')
asxE3LOSDetected = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 106)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxE3LOSDetected.setStatus('current')
if mibBuilder.loadTexts: asxE3LOSDetected.setDescription('This trap indicates that the specified E3 port has detected incoming LOS Alarm.')
asxE3LOSCleared = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 107)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxE3LOSCleared.setStatus('current')
if mibBuilder.loadTexts: asxE3LOSCleared.setDescription('This trap indicates that incoming LOS alarm has been cleared on the specified E3 port.')
asxE3PLCPLOFDetected = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 108)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxE3PLCPLOFDetected.setStatus('current')
if mibBuilder.loadTexts: asxE3PLCPLOFDetected.setDescription('This trap indicates that the specified E3 port has detected incoming PLCP LOF Alarm.')
asxE3PLCPLOFCleared = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 109)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxE3PLCPLOFCleared.setStatus('current')
if mibBuilder.loadTexts: asxE3PLCPLOFCleared.setDescription('This trap indicates that incoming PLCP LOF alarm has been cleared on the specified E3 port.')
asxJ2YellowDetected = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 112)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxJ2YellowDetected.setStatus('current')
if mibBuilder.loadTexts: asxJ2YellowDetected.setDescription('This trap indicates that Yellow Alarm is detected on the incoming signal.')
asxJ2YellowCleared = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 113)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxJ2YellowCleared.setStatus('current')
if mibBuilder.loadTexts: asxJ2YellowCleared.setDescription('This trap indicates that Yellow Alarm is cleared on the incoming signal.')
asxJ2AISDetected = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 114)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxJ2AISDetected.setStatus('current')
if mibBuilder.loadTexts: asxJ2AISDetected.setDescription('This trap indicates that AIS Alarm is detected on the incoming signal.')
asxJ2AISCleared = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 115)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxJ2AISCleared.setStatus('current')
if mibBuilder.loadTexts: asxJ2AISCleared.setDescription('This trap indicates that AIS Alarm is cleared on the incoming signal.')
asxJ2LOSDetected = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 116)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxJ2LOSDetected.setStatus('current')
if mibBuilder.loadTexts: asxJ2LOSDetected.setDescription('This trap indicates that LOS Alarm is detected on the incoming signal.')
asxJ2LOSCleared = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 117)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxJ2LOSCleared.setStatus('current')
if mibBuilder.loadTexts: asxJ2LOSCleared.setDescription('This trap indicates that LOS Alarm is cleared on the incoming signal.')
asxJ2LOFDetected = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 118)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxJ2LOFDetected.setStatus('current')
if mibBuilder.loadTexts: asxJ2LOFDetected.setDescription('This trap indicates that LOF Alarm is detected on the incoming signal.')
asxJ2LOFCleared = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 119)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxJ2LOFCleared.setStatus('current')
if mibBuilder.loadTexts: asxJ2LOFCleared.setDescription('This trap indicates that LOF Alarm is cleared on the incoming signal.')
asxDS3LOSDetected = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 120)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxDS3LOSDetected.setStatus('current')
if mibBuilder.loadTexts: asxDS3LOSDetected.setDescription('This trap indicates that the specified DS3 port has detected incoming LOS Alarm.')
asxDS3LOSCleared = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 121)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxDS3LOSCleared.setStatus('current')
if mibBuilder.loadTexts: asxDS3LOSCleared.setDescription('This trap indicates that the incoming LOS Alarm has been cleared on the specified DS3 port.')
asxSonetLOFDetected = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 130)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxSonetLOFDetected.setStatus('current')
if mibBuilder.loadTexts: asxSonetLOFDetected.setDescription('This trap indicates that the specified SONET port is experiencing Loss Of Frame (LOF) failure. An LOF failure is declared when the LOF defect persists fore a period of 2.5 +/- 0.5 seconds, except when an LOS defect or failure is present.')
asxSonetLOFCleared = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 131)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxSonetLOFCleared.setStatus('current')
if mibBuilder.loadTexts: asxSonetLOFCleared.setDescription('This trap indicates that the LOF failure identified by trap asxSonetLOFDetected has been cleared. The LOF failure is cleared when the LOS failure is declared, or when the LOF defect is absent for 10 +/- 0.5 seconds.')
asxSonetLineRDIDetected = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 132)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxSonetLineRDIDetected.setStatus('current')
if mibBuilder.loadTexts: asxSonetLineRDIDetected.setDescription('This trap indicates that the specified SONET port is experiencing Line Remote Defect Indication (LRDI). A Line RDI failure is declared when the incoming Line RDI defects lasts for 2.5 +/- 0.5 seconds.')
asxSonetLineRDICleared = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 133)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxSonetLineRDICleared.setStatus('current')
if mibBuilder.loadTexts: asxSonetLineRDICleared.setDescription('This trap indicates that the Line RDI failure identified by trap asxSonetLineRDIDetected has been cleared. The Line RDI failure is cleared when no Line RDI defects are detected for 10 +/- 0.5 seconds.')
asxSonetPathAISDetected = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 134)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxSonetPathAISDetected.setStatus('current')
if mibBuilder.loadTexts: asxSonetPathAISDetected.setDescription('This trap indicates that the specified SONET port is experiencing Path Alarm Inidication Signal (PAIS). A Path AIS failure is declared when the Path AIS defect persists for 2.5 +/- 0.5 seconds.')
asxSonetPathAISCleared = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 135)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxSonetPathAISCleared.setStatus('current')
if mibBuilder.loadTexts: asxSonetPathAISCleared.setDescription('This trap indicates that the PathAIS failure identified by trap asxSonetPathAISDetected has been cleared. A PAIS failure is cleared when the PAIS defect is absent for 10 +/- 0.5 seconds.')
asxSonetPathLOPDetected = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 136)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxSonetPathLOPDetected.setStatus('current')
if mibBuilder.loadTexts: asxSonetPathLOPDetected.setDescription('This trap indicates that the specified SONET port is experiencing Loss Of Pointer (LOP). A LOP failure is declared when the LOP defect persists for a period of 2.5 +/- 0.5 seconds.')
asxSonetPathLOPCleared = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 137)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxSonetPathLOPCleared.setStatus('current')
if mibBuilder.loadTexts: asxSonetPathLOPCleared.setDescription('This trap indicates that the LOP failure identified by trap asxSonetLOPDetected has been cleared. A LOP failure is cleared when the LOP defect is absent for 10 +/- 0.5 seconds.')
asxSonetPathUNEQDetected = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 138)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxSonetPathUNEQDetected.setStatus('current')
if mibBuilder.loadTexts: asxSonetPathUNEQDetected.setDescription('This trap indicates that the specified SONET port is experiencing unequiped (UNEQ). A UNEQ failure is declared when the UNEQ defect persists for a period of 2.5 +/- 0.5 seconds.')
asxSonetPathUNEQCleared = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 139)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxSonetPathUNEQCleared.setStatus('current')
if mibBuilder.loadTexts: asxSonetPathUNEQCleared.setDescription('This trap indicates that the UNEQ failure identified by trap asxSonetUNEQDetected has been cleared. A UNEQ failure is cleared when the UNEQ defect is absent for 10 +/- 0.5 seconds.')
asxSonetPathRDIDetected = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 140)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxSonetPathRDIDetected.setStatus('current')
if mibBuilder.loadTexts: asxSonetPathRDIDetected.setDescription('This trap indicates that the specified SONET port is experiencing Path Remote Defect Indication (PRDI). A Path RDI failure is declared when the incoming Path RDI defects lasts for 2.5 +/- 0.5 seconds.')
asxSonetPathRDICleared = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 141)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxSonetPathRDICleared.setStatus('current')
if mibBuilder.loadTexts: asxSonetPathRDICleared.setDescription('This trap indicates that the Path RDI failure identified by trap asxSonetPathRDIDetected has been cleared. The Path RDI failure is cleared when no Path RDI defects are detected for 10 +/- 0.5 seconds.')
asxSonetAtmLCDDetected = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 142)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxSonetAtmLCDDetected.setStatus('current')
if mibBuilder.loadTexts: asxSonetAtmLCDDetected.setDescription('This trap indicates that the specified SONET port is experiencing Loss of Cell Deliniation (LCD). A LCD failure is declared when the LCD defect persists for a period of 2.5 +/- 0.5 seconds.')
asxSonetAtmLCDCleared = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 143)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxSonetAtmLCDCleared.setStatus('current')
if mibBuilder.loadTexts: asxSonetAtmLCDCleared.setDescription('This trap indicates that the LCD failure identified by trap asxSonetAtmLCDDetected has been cleared. A LCD failure is cleared when the LCD defect is absent for 10 +/- 0.5 seconds.')
asxSonetAtmLineBIPDetected = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 144)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxSonetAtmLineBIPDetected.setStatus('current')
if mibBuilder.loadTexts: asxSonetAtmLineBIPDetected.setDescription('This trap indicates that the specified SONET port is experiencing Bit Interleaved Parity (BIP) errors. A Line BIP failure is declared when the Line BIP defect persists for a period of 2.5 +/- 0.5 seconds.')
asxSonetAtmLineBIPCleared = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 145)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxSonetAtmLineBIPCleared.setStatus('current')
if mibBuilder.loadTexts: asxSonetAtmLineBIPCleared.setDescription('This trap indicates that the Line BIP failure identified by trap asxSonetAtmLineBIPDetected has been cleared. A Line BIP failure is cleared when the Line BIP defect is absent for 10 +/- 0.5 seconds.')
asxDS3IdleDetected = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 160)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxDS3IdleDetected.setStatus('current')
if mibBuilder.loadTexts: asxDS3IdleDetected.setDescription('This trap indicates that an Idle Maintenance Signal (IDLE) is detected on the incoming signal.')
asxDS3IdleCleared = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 161)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxDS3IdleCleared.setStatus('current')
if mibBuilder.loadTexts: asxDS3IdleCleared.setDescription('This trap indicates that an Idle Maintenance Signal (IDLE) is cleared on the incoming signal.')
asxDS3AtmLCDDetected = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 162)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxDS3AtmLCDDetected.setStatus('current')
if mibBuilder.loadTexts: asxDS3AtmLCDDetected.setDescription('This trap indicates that the specified DS3 port is experiencing Loss of Cell Deliniation (LCD). A LCD failure is declared when the LCD defect persists for a period of 2.5 +/- 0.5 seconds.')
asxDS3AtmLCDCleared = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 163)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxDS3AtmLCDCleared.setStatus('current')
if mibBuilder.loadTexts: asxDS3AtmLCDCleared.setDescription('This trap indicates that the LCD failure identified by trap asxDS3AtmLCDDetected has been cleared. A LCD failure is cleared when the LCD defect is absent for 10 +/- 0.5 seconds.')
asxDS3PbitPerrDetected = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 164)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxDS3PbitPerrDetected.setStatus('current')
if mibBuilder.loadTexts: asxDS3PbitPerrDetected.setDescription('This trap indicates that the specified DS3 port is experiencing P-bit Parity errors. A P-bit Parity Error failure is declared when the P-bit Parity Error persists for a period of 2.5 +/- 0.5 seconds.')
asxDS3PbitPerrCleared = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 165)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxDS3PbitPerrCleared.setStatus('current')
if mibBuilder.loadTexts: asxDS3PbitPerrCleared.setDescription('This trap indicates that the P-bit Parity Error failure identified by trap asxDS3PbitPerrDetected has been cleared. A P-bit Parity Error failure is cleared when the P-bit Parity Error defect is absent for 10 +/- 0.5 seconds.')
asxDS1PRBSDetected = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 176)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxDS1PRBSDetected.setStatus('current')
if mibBuilder.loadTexts: asxDS1PRBSDetected.setDescription('This trap indicates that PRBS pattern is detected on the incoming signal.')
asxDS1PRBSCleared = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 177)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxDS1PRBSCleared.setStatus('current')
if mibBuilder.loadTexts: asxDS1PRBSCleared.setDescription('This trap indicates that PRBS pattern is cleared on the incoming signal.')
asxDS1AtmLCDDetected = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 178)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxDS1AtmLCDDetected.setStatus('current')
if mibBuilder.loadTexts: asxDS1AtmLCDDetected.setDescription('This trap indicates that the specified DS1 port is experiencing Loss of Cell Deliniation (LCD). A LCD failure is declared when the LCD defect persists for a period of 2.5 +/- 0.5 seconds.')
asxDS1AtmLCDCleared = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 179)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxDS1AtmLCDCleared.setStatus('current')
if mibBuilder.loadTexts: asxDS1AtmLCDCleared.setDescription('This trap indicates that the LCD failure identified by trap asxDS1AtmLCDDetected has been cleared. A LCD failure is cleared when the LCD defect is absent for 10 +/- 0.5 seconds.')
asxDS1CRCErrDetected = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 180)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxDS1CRCErrDetected.setStatus('current')
if mibBuilder.loadTexts: asxDS1CRCErrDetected.setDescription('This trap indicates that the specified DS1 port is experiencing excessive CRC-6 errors. A CRC-6 Error failure is declared when the CRC-6 Error persists for a period of 2.5 +/- 0.5 seconds.')
asxDS1CRCErrCleared = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 181)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxDS1CRCErrCleared.setStatus('current')
if mibBuilder.loadTexts: asxDS1CRCErrCleared.setDescription('This trap indicates that the excessive CRC-6 Error failure identified by trap asxDS1CRCErrDetected has been cleared. A CRC-6 Parity Error failure is cleared when the CRC-6 Error defect is absent for 10 +/- 0.5 seconds.')
asxE3TrailChangeDetected = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 192)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxE3TrailChangeDetected.setStatus('current')
if mibBuilder.loadTexts: asxE3TrailChangeDetected.setDescription('This trap indicates that a change in the trail trace message was detected on the incoming signal.')
asxE1AtmLCDDetected = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 208)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxE1AtmLCDDetected.setStatus('current')
if mibBuilder.loadTexts: asxE1AtmLCDDetected.setDescription('This trap indicates that the specified E1 port is experiencing Loss of Cell Deliniation (LCD). A LCD failure is declared when the LCD defect persists for a period of 2.5 +/- 0.5 seconds.')
asxE1AtmLCDCleared = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 209)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxE1AtmLCDCleared.setStatus('current')
if mibBuilder.loadTexts: asxE1AtmLCDCleared.setDescription('This trap indicates that the LCD failure identified by trap asxE1AtmLCDDetected has been cleared. A LCD failure is cleared when the LCD defect is absent for 10 +/- 0.5 seconds.')
asxJ2RLOCDetected = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 224)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxJ2RLOCDetected.setStatus('current')
if mibBuilder.loadTexts: asxJ2RLOCDetected.setDescription('This trap indicates that Receive Loss of Clock (RLOC) is detected on the incoming signal.')
asxJ2RLOCCleared = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 225)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxJ2RLOCCleared.setStatus('current')
if mibBuilder.loadTexts: asxJ2RLOCCleared.setDescription('This trap indicates that Receive Loss of Clock (RLOC) is cleared on the incoming signal.')
asxJ2HBERDetected = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 226)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxJ2HBERDetected.setStatus('current')
if mibBuilder.loadTexts: asxJ2HBERDetected.setDescription('This trap indicates that High Bit Error Rate (HBER) is detected on the incoming signal.')
asxJ2HBERCleared = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 227)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxJ2HBERCleared.setStatus('current')
if mibBuilder.loadTexts: asxJ2HBERCleared.setDescription('This trap indicates that High Bit Error Rate (HBER) is cleared on the incoming signal.')
asxJ2PAISDetected = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 228)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxJ2PAISDetected.setStatus('current')
if mibBuilder.loadTexts: asxJ2PAISDetected.setDescription('This trap indicates that Payload Alarm Indication Signal (PAIS) is detected on the incoming signal.')
asxJ2PAISCleared = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 229)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxJ2PAISCleared.setStatus('current')
if mibBuilder.loadTexts: asxJ2PAISCleared.setDescription('This trap indicates that Payload Alarm Indication SIgnal (PAIS) is cleared on the incoming signal.')
asxJ2AtmLCDDetected = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 230)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxJ2AtmLCDDetected.setStatus('current')
if mibBuilder.loadTexts: asxJ2AtmLCDDetected.setDescription('This trap indicates that the specified J2 port is experiencing Loss of Cell Deliniation (LCD). A LCD failure is declared when the LCD defect persists for a period of 2.5 +/- 0.5 seconds.')
asxJ2AtmLCDCleared = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 231)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxJ2AtmLCDCleared.setStatus('current')
if mibBuilder.loadTexts: asxJ2AtmLCDCleared.setDescription('This trap indicates that the LCD failure identified by trap asxJ2AtmLCDDetected has been cleared. A LCD failure is cleared when the LCD defect is absent for 10 +/- 0.5 seconds.')
asxJ2TLOCDetected = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 232)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxJ2TLOCDetected.setStatus('current')
if mibBuilder.loadTexts: asxJ2TLOCDetected.setDescription('This trap indicates that Transmit Loss of Clock (TLOC) is detected.')
asxJ2TLOCCleared = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 233)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxJ2TLOCCleared.setStatus('current')
if mibBuilder.loadTexts: asxJ2TLOCCleared.setDescription('This trap indicates that Transmit Loss of Clock (TLOC) is cleared.')
asxTP25LOSDetected = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 250)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxTP25LOSDetected.setStatus('current')
if mibBuilder.loadTexts: asxTP25LOSDetected.setDescription('This trap indicates that LOS Alarm is detected on the incoming signal.')
asxTP25LOSCleared = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 251)).setObjects(("Fore-Switch-MIB", "hwPortName"), ("Fore-Switch-MIB", "hwPortBoard"), ("Fore-Switch-MIB", "hwPortModule"), ("Fore-Switch-MIB", "hwPortNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxTP25LOSCleared.setStatus('current')
if mibBuilder.loadTexts: asxTP25LOSCleared.setDescription('This trap indicates that LOS Alarm is cleared on the incoming signal.')
asxOutputQueueCongested = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 1024)).setObjects(("Fore-Switch-MIB", "portName"), ("Fore-Switch-MIB", "pshmemPriority"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxOutputQueueCongested.setStatus('current')
if mibBuilder.loadTexts: asxOutputQueueCongested.setDescription('This trap indicates that the output queue for the given priority has exceeded its dedicated length, and has begun overflowing into the shared buffer space on the netmod.')
asxOutputQueueCellLoss = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 1025)).setObjects(("Fore-Switch-MIB", "portName"), ("Fore-Switch-MIB", "pshmemPriority"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxOutputQueueCellLoss.setStatus('current')
if mibBuilder.loadTexts: asxOutputQueueCellLoss.setDescription('This trap indicates that the output queue for the given priority has overflowed and cells have been dropped.')
asxExtendedModeViolation = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 1026)).setObjects(("Fore-Switch-MIB", "moduleBoard"), ("Fore-Switch-MIB", "moduleNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxExtendedModeViolation.setStatus('current')
if mibBuilder.loadTexts: asxExtendedModeViolation.setDescription('This trap indicates that a series A or B network module was inserted into a switch board running in extended mode. Multicast will not work on the series B module without removing all series D modules and rebooting the rebooted.')
asxNonextendedModeWarning = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 1027)).setObjects(("Fore-Switch-MIB", "moduleBoard"), ("Fore-Switch-MIB", "moduleNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxNonextendedModeWarning.setStatus('current')
if mibBuilder.loadTexts: asxNonextendedModeWarning.setDescription('This trap indicates that a series C or greater network module was inserted into a switch board running in non-extended mode.')
crConfMemoryOflow = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 1029)).setObjects(("Fore-Callrecord-MIB", "crMemoryAllocated"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: crConfMemoryOflow.setStatus('current')
if mibBuilder.loadTexts: crConfMemoryOflow.setDescription(' This trap is generated when the allocated callrecord memory(as indicated by crMemoryAllocated) is exceeded.')
crXfrPrimaryXfrFailed = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 1030)).setObjects(("Fore-Callrecord-MIB", "crXfrIndex"), ("Fore-Callrecord-MIB", "crXfrPrimaryTrapStatus"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: crXfrPrimaryXfrFailed.setStatus('current')
if mibBuilder.loadTexts: crXfrPrimaryXfrFailed.setDescription(' This trap is generated when the call record transfer to the primary host(as indicated by crXfrPrimaryUrl) fails.')
crXfrSecondaryXfrFailed = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 1031)).setObjects(("Fore-Callrecord-MIB", "crXfrIndex"), ("Fore-Callrecord-MIB", "crXfrSecondaryTrapStatus"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: crXfrSecondaryXfrFailed.setStatus('current')
if mibBuilder.loadTexts: crXfrSecondaryXfrFailed.setDescription(' This trap is generated when the call record transfer to the secondary host(as indicated by crXfrSecondaryUrl) fails.')
crConfMemAllocFail = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 1032)).setObjects(("Fore-Callrecord-MIB", "crMemoryAllocated"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: crConfMemAllocFail.setStatus('current')
if mibBuilder.loadTexts: crConfMemAllocFail.setDescription(" This trap is generated when Callrecord functionality is unable to allocate memory as specified by crMemoryAllocated. This can happen when the crConfAdminStatus changes state from `off' or when the switch reboots when Callrecords is configured `on'.")
crGeneralFailure = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 1033)).setObjects(("Fore-Callrecord-MIB", "crXfrIndex"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: crGeneralFailure.setStatus('current')
if mibBuilder.loadTexts: crGeneralFailure.setDescription(' This trap is generated when any of the callrecord related functionality fails for any reason. One example would be when the Callrecord Module fails to schedule an interval timer.')
asxDualScpSyncFailure = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 1034)).setObjects(("Fore-Switch-MIB", "boardIndex"), ("Fore-Switch-MIB", "dualScpSyncState"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxDualScpSyncFailure.setStatus('current')
if mibBuilder.loadTexts: asxDualScpSyncFailure.setDescription('This trap indicates that automatic CDB synchronization is disabled due to failures.')
asxDualScpSwitchOver = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 1035)).setObjects(("Fore-Switch-MIB", "boardIndex"), ("Fore-Switch-MIB", "dualScpSlot"), ("Fore-Switch-MIB", "dualScpSwitchOverTime"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxDualScpSwitchOver.setStatus('current')
if mibBuilder.loadTexts: asxDualScpSwitchOver.setDescription('This trap indicates that the backup SCP has taken control of the switch.')
asxDualScpHotSwap = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 1036)).setObjects(("Fore-Switch-MIB", "boardIndex"), ("Fore-Switch-MIB", "dualScpSlot"), ("Fore-Switch-MIB", "dualScpState"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxDualScpHotSwap.setStatus('current')
if mibBuilder.loadTexts: asxDualScpHotSwap.setDescription('This trap indicates that an SCP hotswap insertion or removal has occurred.')
asxVPAISDetected = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 1037)).setObjects(("Fore-Switch-MIB", "portName"), ("Fore-Switch-MIB", "pathPort"), ("Fore-Switch-MIB", "pathVPI"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxVPAISDetected.setStatus('current')
if mibBuilder.loadTexts: asxVPAISDetected.setDescription('This trap indicates that the Alarm Indication Signal (AIS) is detected on the incoming (terminating) virtual path. This trap is generated once when the virtual path is declared to be in the active AIS state.')
asxVPAISCleared = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 1038)).setObjects(("Fore-Switch-MIB", "portName"), ("Fore-Switch-MIB", "pathPort"), ("Fore-Switch-MIB", "pathVPI"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxVPAISCleared.setStatus('current')
if mibBuilder.loadTexts: asxVPAISCleared.setDescription('This trap indicates that the Alarm Indication Signal (AIS) has been removed from the incoming (terminating) virtual path. This trap is generated once when the virtual path is declared to be in the inactive AIS state.')
asxVPRDIDetected = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 1039)).setObjects(("Fore-Switch-MIB", "portName"), ("Fore-Switch-MIB", "pathPort"), ("Fore-Switch-MIB", "pathVPI"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxVPRDIDetected.setStatus('current')
if mibBuilder.loadTexts: asxVPRDIDetected.setDescription('This trap indicates that the Remote Defect Indication (RDI) is detected on the incoming (terminating) virtual path. This trap is generated once when the virtual path is declared to be in the active RDI state.')
asxVPRDICleared = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 1040)).setObjects(("Fore-Switch-MIB", "portName"), ("Fore-Switch-MIB", "pathPort"), ("Fore-Switch-MIB", "pathVPI"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxVPRDICleared.setStatus('current')
if mibBuilder.loadTexts: asxVPRDICleared.setDescription('This trap indicates that the Remote Defect Indication (RDI) has been removed from the incoming (terminating) virtual path. This trap is generated once when the virtual path is declared to be in the inactive RDI state.')
asxNonextendedModeViolation = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 1041)).setObjects(("Fore-Switch-MIB", "moduleBoard"), ("Fore-Switch-MIB", "moduleNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxNonextendedModeViolation.setStatus('current')
if mibBuilder.loadTexts: asxNonextendedModeViolation.setDescription('This trap indicates that a series D network module was inserted into a switch board running in non-extended mode. Multicast will not work on the series D module without removing all series B modules and rebooting the switch.')
asxUnsupportedNetworkModule = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 1042)).setObjects(("Fore-Switch-MIB", "moduleBoard"), ("Fore-Switch-MIB", "moduleNumber"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxUnsupportedNetworkModule.setStatus('current')
if mibBuilder.loadTexts: asxUnsupportedNetworkModule.setDescription('This trap indicates that a unsupported network module was inserted into a switch.')
asxDualScpRedundancy = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 1043)).setObjects(("Fore-Switch-MIB", "boardIndex"), ("Fore-Switch-MIB", "dualScpSlot"), ("Fore-Switch-MIB", "dualScpRedundancyState"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxDualScpRedundancy.setStatus('current')
if mibBuilder.loadTexts: asxDualScpRedundancy.setDescription('This trap indicates that there is a change in the state of dual SCP Redundancy.')
asxIpFilterViolation = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 1049)).setObjects(("Fore-Adapter-MIB", "ipFilterStatsVPI"), ("Fore-Adapter-MIB", "ipFilterStatsVCI"), ("Fore-Adapter-MIB", "ipFilterStatsIfName"))
if mibBuilder.loadTexts: asxIpFilterViolation.setStatus('current')
if mibBuilder.loadTexts: asxIpFilterViolation.setDescription('An asxIpFilterViolation trap occurs when an incoming IP packet is unauthorized to enter the switch control port and has been dropped.')
q2931AFRejectKnown = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 1053)).setObjects(("Fore-Switch-MIB", "portName"), ("Fore-Switch-MIB", "pathPort"), ("Fore-Switch-MIB", "pathVPI"), ("Fore-Switch-MIB", "portName"), ("Fore-Switch-MIB", "opathPort"), ("Fore-Switch-MIB", "opathVPI"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: q2931AFRejectKnown.setStatus('current')
if mibBuilder.loadTexts: q2931AFRejectKnown.setDescription("This trap is generated whenever any q2931 UNI with Address Filtering enabled rejects a Setup request because the request matched a template with the action 'reject'. The variables sent in the trap identify the source and destination UNI for the call.")
q2931AFRejectUnknown = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 1054)).setObjects(("Fore-Switch-MIB", "portName"), ("Fore-Switch-MIB", "pathPort"), ("Fore-Switch-MIB", "pathVPI"), ("Fore-Switch-MIB", "portName"), ("Fore-Switch-MIB", "opathPort"), ("Fore-Switch-MIB", "opathVPI"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: q2931AFRejectUnknown.setStatus('current')
if mibBuilder.loadTexts: q2931AFRejectUnknown.setDescription('This trap is generated whenever any q2931 UNI with Address Filtering enabled rejects a Setup request because the address matched no template. The variables sent in the trap identify the source and destination UNI for the call.')
q2931CreationFailure = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 1061)).setObjects(("Fore-Switch-MIB", "portName"), ("Fore-Switch-MIB", "q2931AdminPort"), ("Fore-Switch-MIB", "q2931AdminVPI"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: q2931CreationFailure.setStatus('current')
if mibBuilder.loadTexts: q2931CreationFailure.setDescription('This trap is generated whenever a switch fails to create a UNI. This is most likely due to a resource limitation on the switch.')
asxPsCurrentDown = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 1068)).setObjects(("Fore-Switch-MIB", "envPowerSupplyIndex"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxPsCurrentDown.setStatus('current')
if mibBuilder.loadTexts: asxPsCurrentDown.setDescription('This trap alerts that one ATM switch power supply had a curent failure. The power supply that failed is identified by the power supply index.')
asxPsCurrentUp = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 1069)).setObjects(("Fore-Switch-MIB", "envPowerSupplyIndex"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxPsCurrentUp.setStatus('current')
if mibBuilder.loadTexts: asxPsCurrentUp.setDescription('This trap alerts that one ATM switch power supply that had a curent failure is now up. The power supply that is back up is identified by the power supply index.')
asxPs5VoltDown = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 1070)).setObjects(("Fore-Switch-MIB", "envPowerSupplyIndex"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxPs5VoltDown.setStatus('current')
if mibBuilder.loadTexts: asxPs5VoltDown.setDescription('This trap alerts that one ATM switch power supply had a +5V failure. The power supply that failed is identified by the power supply index.')
asxPs5VoltUp = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 1071)).setObjects(("Fore-Switch-MIB", "envPowerSupplyIndex"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxPs5VoltUp.setStatus('current')
if mibBuilder.loadTexts: asxPs5VoltUp.setDescription('This trap alerts that one ATM switch power supply that had a +5V failure is now up. The power supply that is back up is identified by the power supply index.')
asxSwitchLoginDetected = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 1072)).setObjects(("Fore-Switch-MIB", "switchCurrentUserid"), ("Fore-Switch-MIB", "switchCurrentLoginFrom"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxSwitchLoginDetected.setStatus('current')
if mibBuilder.loadTexts: asxSwitchLoginDetected.setDescription('An asxSwitchLoginDetected trap signifies that a user logged in on the switch.')
asxSwitchLoginFailed = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 1073)).setObjects(("Fore-Switch-MIB", "switchCurrentUserid"), ("Fore-Switch-MIB", "switchCurrentLoginFrom"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxSwitchLoginFailed.setStatus('current')
if mibBuilder.loadTexts: asxSwitchLoginFailed.setDescription("An asxSwitchLoginFailed trap signifies that a user's attempt to log in on the switch failed.")
pnniTdbGuardbandResrvFail = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 1074)).setObjects(("PNNI-MIB", "pnniNodeId"), ("HOST-RESOURCES-MIB", "hrSystemDate"), ("Fore-Switch-MIB", "numBytesFree"), ("Fore-Switch-MIB", "numBlocksFree"), ("Fore-Switch-MIB", "numBlocksAlloc"), ("Fore-Switch-MIB", "maxBlockSizeFree"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: pnniTdbGuardbandResrvFail.setStatus('current')
if mibBuilder.loadTexts: pnniTdbGuardbandResrvFail.setDescription(' This trap is generated when guardband memory reserve for any of the PNNI TDB(Topology Database) related functionalites like creation,modification and deletion on objects like node, ptse,flags,interal prefixes,external prefixes and etc fails. The switch is low on memory.')
pnniTdbInconsistentState = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 1075)).setObjects(("PNNI-MIB", "pnniNodeId"), ("HOST-RESOURCES-MIB", "hrSystemDate"), ("Fore-Switch-MIB", "numBytesFree"), ("Fore-Switch-MIB", "numBlocksFree"), ("Fore-Switch-MIB", "numBlocksAlloc"), ("Fore-Switch-MIB", "maxBlockSizeFree"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: pnniTdbInconsistentState.setStatus('current')
if mibBuilder.loadTexts: pnniTdbInconsistentState.setDescription('This trap is generated when PNNI TDB(Topology Database) is in an unrecoverable error condition due to MALLOC and other TDB related faliures. When this happenes the associated logical node is shutdown and this trap is sent.The switch has to be rebooted to bring this PNNI logical node up again.')
asxShmem2OutputQueueCongested = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 1077)).setObjects(("Fore-Switch-MIB", "portName"), ("Fore-Switch-MIB", "pShmem2Priority"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxShmem2OutputQueueCongested.setStatus('current')
if mibBuilder.loadTexts: asxShmem2OutputQueueCongested.setDescription('This trap indicates that the output queue for the given priority has exceeded its dedicated length, and has begun overflowing into the shared buffer space on the netmod.')
asxShmem2OutputQueueCellLoss = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 1078)).setObjects(("Fore-Switch-MIB", "portName"), ("Fore-Switch-MIB", "pShmem2Priority"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxShmem2OutputQueueCellLoss.setStatus('current')
if mibBuilder.loadTexts: asxShmem2OutputQueueCellLoss.setDescription('This trap indicates that the output queue for the given priority has overflowed and cells have been dropped.')
fabricLvl3Lookup = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 1080)).setObjects(("Fore-Switch-MIB", "boardIndex"))
if mibBuilder.loadTexts: fabricLvl3Lookup.setStatus('current')
if mibBuilder.loadTexts: fabricLvl3Lookup.setDescription('This trap is generated when a fabric detects excessive level 3 lookup errors. The level 3 lookup count is read every second. If the lookup count is non-null for 5 consecutive seconds, then this trap is generated. If the errors continue, this trap will be generated continuously every 5 seconds. This trap can be caused by: a misconfigured PVC; bad hardware.')
fabricCorrectedLookup = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 1081)).setObjects(("Fore-Switch-MIB", "boardIndex"))
if mibBuilder.loadTexts: fabricCorrectedLookup.setStatus('current')
if mibBuilder.loadTexts: fabricCorrectedLookup.setDescription("This trap is generated when the SCP detects inconsistant information in the HDCOMP lookup. The switch has corrected the bad information in the HDCOMP lookup ASIC's data structures.")
spvcRerouteInitiated = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 1090)).setObjects(("Fore-Switch-MIB", "boardIndex"), ("Fore-Switch-MIB", "spvcSrcInPort"), ("Fore-Switch-MIB", "spvcSrcInVPI"), ("Fore-Switch-MIB", "spvcSrcInVCI"))
if mibBuilder.loadTexts: spvcRerouteInitiated.setStatus('current')
if mibBuilder.loadTexts: spvcRerouteInitiated.setDescription('This trap is sent when a SPVC is being re-routed due to a better path being found.')
asxQ2931Down = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 1091)).setObjects(("Fore-Switch-MIB", "portName"), ("Fore-Switch-MIB", "q2931AdminPort"), ("Fore-Switch-MIB", "q2931AdminVPI"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxQ2931Down.setStatus('current')
if mibBuilder.loadTexts: asxQ2931Down.setDescription('This trap is generated whenever UNI signalling goes down.')
asxQ2931Up = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 1092)).setObjects(("Fore-Switch-MIB", "portName"), ("Fore-Switch-MIB", "q2931AdminPort"), ("Fore-Switch-MIB", "q2931AdminVPI"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxQ2931Up.setStatus('current')
if mibBuilder.loadTexts: asxQ2931Up.setDescription('This trap is generated whenever UNI signalling goes up.')
asxFabricDown = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 1093)).setObjects(("Fore-Switch-MIB", "boardIndex"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxFabricDown.setStatus('current')
if mibBuilder.loadTexts: asxFabricDown.setDescription('An asxFabricDown trap signifies that the sending protocol entity recognizes a failure in one of the ATM Switch fabric, that is identified by the board number. This is probably caused by a hot-swap of a fabric module.')
asxFabricUp = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 1094)).setObjects(("Fore-Switch-MIB", "boardIndex"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxFabricUp.setStatus('current')
if mibBuilder.loadTexts: asxFabricUp.setDescription('An asxFabricUp trap signifies that the sending protocol entity recognizes a new operational ATM Switch fabric, that is identified by the board number. This is probably caused by a hot-swap of a fabric module.')
asxQ2931CallClearing = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 1095)).setObjects(("Fore-Switch-MIB", "portName"), ("Fore-Switch-MIB", "q2931AdminPort"), ("Fore-Switch-MIB", "q2931AdminVPI"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxQ2931CallClearing.setStatus('current')
if mibBuilder.loadTexts: asxQ2931CallClearing.setDescription('This trap is generated whenever calls are cleared in a signalling interface for the following reasons. * Carrier loss * SONET alarms in case of SONE * VP failure ')
pnniSpvccDown = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 2004)).setObjects(("Fore-Switch-MIB", "boardIndex"), ("Fore-Switch-MIB", "pnniSpvcSrcCallingPort"), ("Fore-Switch-MIB", "pnniSpvcSrcCallingVPI"), ("Fore-Switch-MIB", "pnniSpvcSrcCallingVCI"), ("Fore-Switch-MIB", "pnniSpvcSrcDownReason"), ("Fore-Switch-MIB", "pnniSpvcSrcName"), ("Fore-Switch-MIB", "pnniSpvcSrcLastFailCause"), ("Fore-Switch-MIB", "pnniSpvcSrcLastLocation"))
if mibBuilder.loadTexts: pnniSpvccDown.setStatus('current')
if mibBuilder.loadTexts: pnniSpvccDown.setDescription('This trap is sent when a SPVC call is cleared or deleted. The pnniSpvcSrcDownReason indicates if the call was cleared due to a better route being found or a network failure. It also may indicate SPVC deletion. This trap is only sent if pnniSpvcTrapMode is all.')
pnniSpvccUp = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 2005)).setObjects(("Fore-Switch-MIB", "boardIndex"), ("Fore-Switch-MIB", "pnniSpvcSrcCallingPort"), ("Fore-Switch-MIB", "pnniSpvcSrcCallingVPI"), ("Fore-Switch-MIB", "pnniSpvcSrcCallingVCI"), ("Fore-Switch-MIB", "pnniSpvcSrcOldRouteCost"), ("Fore-Switch-MIB", "pnniSpvcSrcName"), ("Fore-Switch-MIB", "pnniSpvcSrcRouteCost"))
if mibBuilder.loadTexts: pnniSpvccUp.setStatus('current')
if mibBuilder.loadTexts: pnniSpvccUp.setDescription('This trap is send when a SPVC call is established. It identifies the SPVC and the old and new cost. If the call has not been up before, the pnniSpvcSrcOldRouteCost will be -1. This trap is only sent if pnniSpvcTrapMode is failure or all.')
pnniSpvccFail = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 2006)).setObjects(("Fore-Switch-MIB", "boardIndex"), ("Fore-Switch-MIB", "pnniSpvcSrcCallingPort"), ("Fore-Switch-MIB", "pnniSpvcSrcCallingVPI"), ("Fore-Switch-MIB", "pnniSpvcSrcCallingVCI"), ("Fore-Switch-MIB", "pnniSpvcSrcDownReason"), ("Fore-Switch-MIB", "pnniSpvcSrcName"), ("Fore-Switch-MIB", "pnniSpvcSrcLastFailCause"), ("Fore-Switch-MIB", "pnniSpvcSrcLastLocation"))
if mibBuilder.loadTexts: pnniSpvccFail.setStatus('current')
if mibBuilder.loadTexts: pnniSpvccFail.setDescription('This trap is sent when a SPVC call that is down fails to get connected on 16 consecutive attempts. This trap is only sent if pnniSpvcTrapMode is failure or all.')
pnniSpvpcDown = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 2007)).setObjects(("Fore-Switch-MIB", "boardIndex"), ("Fore-Switch-MIB", "pnniSpvpcSrcCallingPort"), ("Fore-Switch-MIB", "pnniSpvpcSrcCallingVPI"), ("Fore-Switch-MIB", "pnniSpvpcSrcDownReason"), ("Fore-Switch-MIB", "pnniSpvpcSrcName"), ("Fore-Switch-MIB", "pnniSpvpcSrcLastFailCause"), ("Fore-Switch-MIB", "pnniSpvpcSrcLastLocation"))
if mibBuilder.loadTexts: pnniSpvpcDown.setStatus('current')
if mibBuilder.loadTexts: pnniSpvpcDown.setDescription('This trap is sent when a SPVP call is cleared. The pnniSpvcSrcDownReason indicates if the call was cleared due to a better route being found or a network failure. It also may indicate SPVPC deletion. This trap is only sent if pnniSpvpcTrapMode is all.')
pnniSpvpcUp = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 2008)).setObjects(("Fore-Switch-MIB", "boardIndex"), ("Fore-Switch-MIB", "pnniSpvpcSrcCallingPort"), ("Fore-Switch-MIB", "pnniSpvpcSrcCallingVPI"), ("Fore-Switch-MIB", "pnniSpvpcSrcOldRouteCost"), ("Fore-Switch-MIB", "pnniSpvpcSrcName"), ("Fore-Switch-MIB", "pnniSpvpcSrcRouteCost"))
if mibBuilder.loadTexts: pnniSpvpcUp.setStatus('current')
if mibBuilder.loadTexts: pnniSpvpcUp.setDescription('This trap is send when a SPVP call is established. It identifies the SPVP and the old and new cost. If the call has not been up before, the pnniSpvcSrcOldRouteCost will be -1. This trap is only sent if pnniSpvpcTrapMode is all or failure.')
pnniSpvpcFail = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 2009)).setObjects(("Fore-Switch-MIB", "boardIndex"), ("Fore-Switch-MIB", "pnniSpvpcSrcCallingPort"), ("Fore-Switch-MIB", "pnniSpvpcSrcCallingVPI"), ("Fore-Switch-MIB", "pnniSpvpcSrcDownReason"), ("Fore-Switch-MIB", "pnniSpvpcSrcName"), ("Fore-Switch-MIB", "pnniSpvpcSrcLastFailCause"), ("Fore-Switch-MIB", "pnniSpvpcSrcLastLocation"))
if mibBuilder.loadTexts: pnniSpvpcFail.setStatus('current')
if mibBuilder.loadTexts: pnniSpvpcFail.setDescription('This trap is sent when a SPVP call that is down fails to get connected on 16 consecutive attempts. This trap is only sent if pnniSpvpcTrapMode is all or failure.')
asxPortCardDown = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 2010)).setObjects(("Fore-Switch-MIB", "portCardName"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxPortCardDown.setStatus('current')
if mibBuilder.loadTexts: asxPortCardDown.setDescription('An asxPortCardDown trap signifies that the sending protocol entity recognizes a failure in one of the ATM Switch portcards, that is identified by the portcard name. This is probably caused by a hot-swap of the port card.')
asxPortCardUp = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 2011)).setObjects(("Fore-Switch-MIB", "portCardName"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxPortCardUp.setStatus('current')
if mibBuilder.loadTexts: asxPortCardUp.setDescription('An asxPortCardUp trap signifies that the sending protocol entity recognizes a new operational ATM Switch port card, that is identified by the portcard name. This is probably caused by a hot-swap of the port card.')
asxServiceCategoryOutputQueueCongested = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 2013)).setObjects(("Fore-Switch-MIB", "portName"), ("Fore-Switch-MIB", "serviceCategoryName"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxServiceCategoryOutputQueueCongested.setStatus('current')
if mibBuilder.loadTexts: asxServiceCategoryOutputQueueCongested.setDescription('This trap indicates that the output queue for the service category has exceeded its dedicated length, and has begun overflowing into the shared buffer space on the netmod.')
asxServiceCategoryOutputQueueCellLoss = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 2014)).setObjects(("Fore-Switch-MIB", "portName"), ("Fore-Switch-MIB", "serviceCategoryName"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxServiceCategoryOutputQueueCellLoss.setStatus('current')
if mibBuilder.loadTexts: asxServiceCategoryOutputQueueCellLoss.setDescription('This trap indicates that the output queue for the given service category has overflowed and cells have been dropped.')
pnniNormalToOverloadTransition = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 2015)).setObjects(("PNNI-MIB", "pnniNodeId"), ("HOST-RESOURCES-MIB", "hrSystemDate"), ("Fore-Switch-MIB", "numBytesFree"), ("Fore-Switch-MIB", "numBlocksFree"), ("Fore-Switch-MIB", "numBlocksAlloc"), ("Fore-Switch-MIB", "maxBlockSizeFree"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: pnniNormalToOverloadTransition.setStatus('current')
if mibBuilder.loadTexts: pnniNormalToOverloadTransition.setDescription('This trap is generated on transition from the normal state to the overload state.')
pnniOverloadToNormalTransition = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 2016)).setObjects(("PNNI-MIB", "pnniNodeId"), ("HOST-RESOURCES-MIB", "hrSystemDate"), ("Fore-Switch-MIB", "numBytesFree"), ("Fore-Switch-MIB", "numBlocksFree"), ("Fore-Switch-MIB", "numBlocksAlloc"), ("Fore-Switch-MIB", "maxBlockSizeFree"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: pnniOverloadToNormalTransition.setStatus('current')
if mibBuilder.loadTexts: pnniOverloadToNormalTransition.setDescription('This trap is generated on transition from the overload to the normal state.')
syslogFacility = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 22, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("daemon", 0), ("local0", 1), ("local1", 2), ("local2", 3), ("local3", 4), ("local4", 5), ("local5", 6), ("local6", 7), ("local7", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: syslogFacility.setStatus('current')
if mibBuilder.loadTexts: syslogFacility.setDescription('The syslog facility string, possible values are daemon, local[0-7].')
syslogConsoleState = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 22, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: syslogConsoleState.setStatus('current')
if mibBuilder.loadTexts: syslogConsoleState.setDescription('The syslog console state, ON means syslog messages are sent to console.')
syslogDestinationTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 22, 3), )
if mibBuilder.loadTexts: syslogDestinationTable.setStatus('current')
if mibBuilder.loadTexts: syslogDestinationTable.setDescription('This table lists all the syslog destinations')
syslogDestinationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 22, 3, 1), ).setIndexNames((0, "Fore-Switch-MIB", "syslogDestinationHost"))
if mibBuilder.loadTexts: syslogDestinationEntry.setStatus('current')
if mibBuilder.loadTexts: syslogDestinationEntry.setDescription('A structure containing the parameters for a syslog destination')
syslogDestinationHost = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 22, 3, 1, 1), IpAddress())
if mibBuilder.loadTexts: syslogDestinationHost.setStatus('current')
if mibBuilder.loadTexts: syslogDestinationHost.setDescription('The host IP address of the syslog destination')
syslogDestinationStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 1, 22, 3, 1, 2), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: syslogDestinationStatus.setStatus('current')
if mibBuilder.loadTexts: syslogDestinationStatus.setDescription('Administrative status of this entry')
pnniPmpRerouteInitiated = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 2020)).setObjects(("Fore-Switch-MIB", "pnniPmpSpvccSrcRootPort"), ("Fore-Switch-MIB", "pnniPmpSpvccSrcRootVPI"), ("Fore-Switch-MIB", "pnniPmpSpvccSrcRootVCI"))
if mibBuilder.loadTexts: pnniPmpRerouteInitiated.setStatus('current')
if mibBuilder.loadTexts: pnniPmpRerouteInitiated.setDescription('This trap is sent when a party is being re-routed due to a better path being found or if a reroute is requested using a AMI command.')
pnniPmpSpvcUp = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 2021)).setObjects(("Fore-Switch-MIB", "pnniPmpSpvccSrcRootPort"), ("Fore-Switch-MIB", "pnniPmpSpvccSrcRootVPI"), ("Fore-Switch-MIB", "pnniPmpSpvccSrcRootVCI"), ("Fore-Switch-MIB", "pnniPmpSpvccSrcPartyName"), ("Fore-Switch-MIB", "pnniPmpSpvccSrcPartyRouteCost"))
if mibBuilder.loadTexts: pnniPmpSpvcUp.setStatus('current')
if mibBuilder.loadTexts: pnniPmpSpvcUp.setDescription('This trap is send when a pmp SPVC call is established. This trap is only sent if pnniSpvcTrapMode is failure or all.')
pnniPmpSpvcDown = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 2022)).setObjects(("Fore-Switch-MIB", "pnniPmpSpvccSrcRootPort"), ("Fore-Switch-MIB", "pnniPmpSpvccSrcRootVPI"), ("Fore-Switch-MIB", "pnniPmpSpvccSrcRootVCI"), ("Fore-Switch-MIB", "pnniPmpSpvccSrcPartyDownReason"), ("Fore-Switch-MIB", "pnniPmpSpvccSrcPartyName"), ("Fore-Switch-MIB", "pnniPmpSpvccSrcPartyLastFailCause"), ("Fore-Switch-MIB", "pnniPmpSpvccSrcPartyLastLocation"))
if mibBuilder.loadTexts: pnniPmpSpvcDown.setStatus('current')
if mibBuilder.loadTexts: pnniPmpSpvcDown.setDescription('This trap is sent when a pmp SPVC call is cleared. The pnniSpvcSrcDownReason indicates if the call was cleared due to a better route being found or a network failure. This trap is only sent if pnniSpvpcTrapMode is all.')
pnniPmpSpvcFail = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 2023)).setObjects(("Fore-Switch-MIB", "pnniPmpSpvccSrcRootPort"), ("Fore-Switch-MIB", "pnniPmpSpvccSrcRootVPI"), ("Fore-Switch-MIB", "pnniPmpSpvccSrcRootVCI"), ("Fore-Switch-MIB", "pnniPmpSpvccSrcPartyDownReason"), ("Fore-Switch-MIB", "pnniPmpSpvccSrcPartyName"), ("Fore-Switch-MIB", "pnniPmpSpvccSrcPartyLastFailCause"), ("Fore-Switch-MIB", "pnniPmpSpvccSrcPartyLastLocation"))
if mibBuilder.loadTexts: pnniPmpSpvcFail.setStatus('current')
if mibBuilder.loadTexts: pnniPmpSpvcFail.setDescription('This trap is sent when a SPVC call that is down fails to get connected on 16 consecutive attempts. This trap is only sent if pnniSpvcTrapMode is failure or all.')
pnniSpvxRGroupSwover = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 2024)).setObjects(("Fore-Switch-MIB", "pnniSpvxcRGroupSwitchoverCmd"), ("Fore-Switch-MIB", "pnniSpvxcRGroupActivePort"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: pnniSpvxRGroupSwover.setStatus('current')
if mibBuilder.loadTexts: pnniSpvxRGroupSwover.setDescription('This trap is sent when a automatic switch over occurs in a SPVC Redundancy group that has automatic PVC switch over enabled.')
asxSVXCPStateTransferFailed = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 2025)).setObjects(("Fore-Switch-MIB", "dualScpSlot"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxSVXCPStateTransferFailed.setStatus('current')
if mibBuilder.loadTexts: asxSVXCPStateTransferFailed.setDescription('This trap is sent when the SVx/SPVx Preservation module is unable to transfer call and interface state information to the Standby SCP, due either to temporary unavailablility of system resources or to a permanent system error requiring a system reboot.')
asxSVXCPStateTransferRestarted = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 2026)).setObjects(("Fore-Switch-MIB", "dualScpSlot"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxSVXCPStateTransferRestarted.setStatus('current')
if mibBuilder.loadTexts: asxSVXCPStateTransferRestarted.setDescription('This trap is sent when the SVx/SPVx Preservation module has restarted its transfer of call and interface state information to the Standby SCP, which transfer was halted due to unavailablility of system resources.')
asxSVXCPStateDroppedCall = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 0, 2027)).setObjects(("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: asxSVXCPStateDroppedCall.setStatus('current')
if mibBuilder.loadTexts: asxSVXCPStateDroppedCall.setDescription('This trap is sent when the SVx/SPVx Preservation module has insufficient memory to store one or more calls during its transfer of call and interface state information to the Standby SCP. Such calls therefore will be lost (not preserved on switchover). This trap is sent only once, no matter how many calls suffer this fate. Recovering any lost calls is possible only by disabling and then re-enabling SVx/SPVx Preservation, in order to provoke a complete retrial of the transfer process.')
mibBuilder.exportSymbols("Fore-Switch-MIB", environment=environment, pshmemClpThreshforVBR=pshmemClpThreshforVBR, moduleTestAdminStatus=moduleTestAdminStatus, switchCurrentLoginFrom=switchCurrentLoginFrom, nshmemCurrentMcastConnections=nshmemCurrentMcastConnections, envFabricAlarmResetTemperature=envFabricAlarmResetTemperature, envCpuPromRevision=envCpuPromRevision, pnniSpvcSrcCalledAssignedVPI=pnniSpvcSrcCalledAssignedVPI, pnniSpvpcDestCalledPort=pnniSpvpcDestCalledPort, pathExtCbrMetric=pathExtCbrMetric, boardStatsBoard=boardStatsBoard, opathStatsPort=opathStatsPort, shmem3ConfName=shmem3ConfName, chanUsedBandwidth=chanUsedBandwidth, q2931SendCallProc=q2931SendCallProc, pShmem2Board=pShmem2Board, q2931StatsVPI=q2931StatsVPI, genericOutputPortStatsPrio=genericOutputPortStatsPrio, pnniPmpSpvccDestPartyTable=pnniPmpSpvccDestPartyTable, pnniSpvcSrcLastLocation=pnniSpvcSrcLastLocation, nsapTopoLinkCost=nsapTopoLinkCost, switchDebounceTable=switchDebounceTable, pnniPmpSpvccSrcPartyVCI=pnniPmpSpvccSrcPartyVCI, portCardName=portCardName, mbufsCount=mbufsCount, q2931AdminIncomingNSAPFilterIndex=q2931AdminIncomingNSAPFilterIndex, ifIndexMapPort=ifIndexMapPort, q2931NPPingState=q2931NPPingState, pnniSpvpcDestEntry=pnniSpvpcDestEntry, asxPsInputDown=asxPsInputDown, swAlarmCriticalRelayState=swAlarmCriticalRelayState, sigPathMaxVCI=sigPathMaxVCI, q2931AdminTable=q2931AdminTable, genericOutputPortStatsBoard=genericOutputPortStatsBoard, pnniPmpSpvccSrcPartyLastLocation=pnniPmpSpvccSrcPartyLastLocation, dualScpGroup=dualScpGroup, obufNumber=obufNumber, q2931LayerGroup=q2931LayerGroup, sigPathStatsVPI=sigPathStatsVPI, asxSVXCPStateTransferFailed=asxSVXCPStateTransferFailed, pnniSpvpcSrcCallingDomain=pnniSpvpcSrcCallingDomain, shmemUcastConnections=shmemUcastConnections, q2931AFTemplateSrcNsapMask=q2931AFTemplateSrcNsapMask, swBoardTopologyGroup=swBoardTopologyGroup, vmtVpciMapGroupIndex=vmtVpciMapGroupIndex, snmpReadCommunity=snmpReadCommunity, pShmem3Clp1ThreshforVBR=pShmem3Clp1ThreshforVBR, numberOfModules=numberOfModules, switchConnectionPreservation=switchConnectionPreservation, opathStatsVPI=opathStatsVPI, netmodGenericShmemTable=netmodGenericShmemTable, vcShmem2OutputPort=vcShmem2OutputPort, vpShmem2OutputPort=vpShmem2OutputPort, q2931AdminIEFilter=q2931AdminIEFilter, pnniSpvcSrcCalledVPVCSel=pnniSpvcSrcCalledVPVCSel, envCpuProductPartNumber=envCpuProductPartNumber, opathChannelSchedSchedMode=opathChannelSchedSchedMode, pnniSpvpcDestStatus=pnniSpvpcDestStatus, pnniSpvpcSrcSusceptClip=pnniSpvpcSrcSusceptClip, swBoardTable=swBoardTable, envCpuRevLevel=envCpuRevLevel, switchTimeZone=switchTimeZone, upcContractCDVT=upcContractCDVT, portPPPolicingNRTVBR=portPPPolicingNRTVBR, pnniSpvcSrcActiveDtlIndex=pnniSpvcSrcActiveDtlIndex, pshmemConfModule=pshmemConfModule, pShmem2DedicatedQsize=pShmem2DedicatedQsize, pnniSpvcSrcDtlWeight4=pnniSpvcSrcDtlWeight4, ftPnniSummaryTable=ftPnniSummaryTable, genericOutputPortConfPrioDedicatedQSize=genericOutputPortConfPrioDedicatedQSize, portGCRAPolicingVBR=portGCRAPolicingVBR, switchCDV=switchCDV, confTopoFtPnniForeArea=confTopoFtPnniForeArea, q2931AFTemplateTable=q2931AFTemplateTable, opathStatsTransmittedPackets=opathStatsTransmittedPackets, mcastSpaceIndex=mcastSpaceIndex, envMaxNumberOfPowerSupplies=envMaxNumberOfPowerSupplies, pShmem2ClpThreshforVBR=pShmem2ClpThreshforVBR, numBytesFree=numBytesFree, pnniSpvpcSrcDownReason=pnniSpvpcSrcDownReason, asxDS1AtmLCDCleared=asxDS1AtmLCDCleared, nGenericShmemCustomBCSRowStatus=nGenericShmemCustomBCSRowStatus, pnniSpvpcSrcBackoffStatus=pnniSpvpcSrcBackoffStatus, snmpAgentEntry=snmpAgentEntry, vciLookupErrors=vciLookupErrors, asxE1PLCPLOFDetected=asxE1PLCPLOFDetected, asxE1LOFDetected=asxE1LOFDetected, perCallDbgTransFlag=perCallDbgTransFlag, q2931OutputRccUpc=q2931OutputRccUpc, asxJ2LOFDetected=asxJ2LOFDetected, pShmem3Clp01ThreshforVBR=pShmem3Clp01ThreshforVBR, genericPortGroupSubindex=genericPortGroupSubindex, pShmem3Port=pShmem3Port, pnniSpvcDestAssignedVPI=pnniSpvcDestAssignedVPI, q2931CallsRejections=q2931CallsRejections, pnniPmpSpvccDestPartyTransitNetSel=pnniPmpSpvccDestPartyTransitNetSel, portVbrOverbooking=portVbrOverbooking, asxJ2RLOCCleared=asxJ2RLOCCleared, ftPnniDTLVPI=ftPnniDTLVPI, pnniSpvcDestCalledPort=pnniSpvcDestCalledPort, q2931AtmrPnniNodeIndex=q2931AtmrPnniNodeIndex, swBoardTopoEntry=swBoardTopoEntry, proxyDirMapEntry=proxyDirMapEntry, pnniPmpSpvccSrcRootVPI=pnniPmpSpvccSrcRootVPI, sbprServerMinSeconds=sbprServerMinSeconds, nsapNetworkPrefixVPI=nsapNetworkPrefixVPI, pnniSpvcSrcCalledPort=pnniSpvcSrcCalledPort, oamReceivedPathTable=oamReceivedPathTable, q2931AdminSigAlloc=q2931AdminSigAlloc, vmtVpciMapVPI=vmtVpciMapVPI, swBoardClockScalingFactor=swBoardClockScalingFactor, asxJ2YellowDetected=asxJ2YellowDetected, asxE3OOFCleared=asxE3OOFCleared, asxDS3PLCPLOFDetected=asxDS3PLCPLOFDetected, pShmem3ConfAltCLPConfigUBR=pShmem3ConfAltCLPConfigUBR, nShmem3ConfVcCLP01ForVBR=nShmem3ConfVcCLP01ForVBR, asxAtmIfLinkid=asxAtmIfLinkid, sigPathPolicingAction=sigPathPolicingAction, nsapTopoLinkVbrFifo=nsapTopoLinkVbrFifo, spvcDestSrcSwitchAddr=spvcDestSrcSwitchAddr, pnniSpvpcSrcAutoDtlStatus=pnniSpvpcSrcAutoDtlStatus, dualScpNumSyncFailures=dualScpNumSyncFailures, cbrctIdleDetection=cbrctIdleDetection, outputPathExtTable=outputPathExtTable, pnniSpvcSrcCalledVCI=pnniSpvcSrcCalledVCI, netmodShmem2CustomBCSEntry=netmodShmem2CustomBCSEntry, asxE3YellowCleared=asxE3YellowCleared, boardEntry=boardEntry, asxPortCardUp=asxPortCardUp, shmemCellsBuffers=shmemCellsBuffers, pnniSpvpcSrcRetryCount=pnniSpvpcSrcRetryCount, shmemConfEntry=shmemConfEntry, appModuleTable=appModuleTable, q2931InputSigContract=q2931InputSigContract, pShmem2Module=pShmem2Module, portAllocBandwidthIn=portAllocBandwidthIn, opathMinVCI=opathMinVCI, asxJ2AISDetected=asxJ2AISDetected, q2931AFTemplateIndex=q2931AFTemplateIndex, btPrimaryClock=btPrimaryClock, opathRtVbrBufferOverb=opathRtVbrBufferOverb, pnniSpvxcRGroupEntry=pnniSpvxcRGroupEntry, nShmem2CustomBCSWeight=nShmem2CustomBCSWeight, q2931E164AddrResStatus=q2931E164AddrResStatus, etherChipSet=etherChipSet, q2931ConnectedPAddressRestriction=q2931ConnectedPAddressRestriction, ifIndexMapIndex=ifIndexMapIndex, asxDS3AISDetected=asxDS3AISDetected, portInputMaxctd=portInputMaxctd, q2931E164Nsap=q2931E164Nsap, obufQueueLength=obufQueueLength, pshmemQsizeforABR=pshmemQsizeforABR, q2931AdminubrCalls=q2931AdminubrCalls, pathVPI=pathVPI, chanVPI=chanVPI, nshmemModule=nshmemModule, q2931NPCallBckUpcKey=q2931NPCallBckUpcKey, shmemConfTable=shmemConfTable, switchDebounceIndex=switchDebounceIndex, ochanStatsLostPackets=ochanStatsLostPackets, asxE3OOFDetected=asxE3OOFDetected, hwPortBoard=hwPortBoard, q2931E164AddrResEntry=q2931E164AddrResEntry, vpGroupEntryStatus=vpGroupEntryStatus, asxE3PLCPYellowDetected=asxE3PLCPYellowDetected, pnniSpvcSrcIndex=pnniSpvcSrcIndex, hwPortVersion=hwPortVersion, portMaxBandwidthOut=portMaxBandwidthOut, portNumPathsIn=portNumPathsIn, pnniOverloadToNormalTransition=pnniOverloadToNormalTransition, linkSrc=linkSrc, portName=portName, pnniSpvpcSrcSecondaryVPI=pnniSpvpcSrcSecondaryVPI, q2931E164NsapMask=q2931E164NsapMask, pShmem2ClpThreshforUBR=pShmem2ClpThreshforUBR, asxFabricTemperatureOverTemp=asxFabricTemperatureOverTemp, outputPathStatsEntry=outputPathStatsEntry, asxJ2RLOCDetected=asxJ2RLOCDetected, ftPnniDTLEntryIndex=ftPnniDTLEntryIndex, portCACStatus=portCACStatus, mbufsClFree=mbufsClFree, nShmem3ConfVcCLP01ForABR=nShmem3ConfVcCLP01ForABR, dualScpSlot=dualScpSlot, pnniSpvpcUp=pnniSpvpcUp, snmp=snmp, pShmem3PPDLostCells=pShmem3PPDLostCells, perCallDbgFilterGroup=perCallDbgFilterGroup, pnniSpvcSrcRouteCost=pnniSpvcSrcRouteCost, asxE3LOSDetected=asxE3LOSDetected, spvcRerouteInitiated=spvcRerouteInitiated, envMgmtBoardType=envMgmtBoardType, opathVPI=opathVPI, moduleGroup=moduleGroup, shmem3TableMemorySize=shmem3TableMemorySize, pathUptime=pathUptime, pnniSpvpcSrcPriority=pnniSpvpcSrcPriority, pnniPmpSpvccDestPartyAssignedVCI=pnniPmpSpvccDestPartyAssignedVCI, linkDest=linkDest, oamGeneratingChannelEntry=oamGeneratingChannelEntry, boardVersion=boardVersion, chanUptime=chanUptime, shmemVpiVciLists=shmemVpiVciLists, ppShmem2ConfPort=ppShmem2ConfPort, dualScpPrimary=dualScpPrimary, genericPortGroupBoard=genericPortGroupBoard, chanAllocBandwidth=chanAllocBandwidth, pnniSpvcDestStatus=pnniSpvcDestStatus, q2931AFTemplateStatus=q2931AFTemplateStatus, snmpWarmStart=snmpWarmStart, dualScpManualSyncRequest=dualScpManualSyncRequest, pShmem2Port=pShmem2Port, ppShmem2ConfBoard=ppShmem2ConfBoard, vmtVpciMapEntry=vmtVpciMapEntry, asxJ2AtmLCDCleared=asxJ2AtmLCDCleared, qosClassExpansionTable=qosClassExpansionTable, hwPortGlobalIndex=hwPortGlobalIndex, q2931AdminNativeE164Address=q2931AdminNativeE164Address, spvcSrcInVCI=spvcSrcInVCI, pnniSpvpcSrcFwdQoSClass=pnniSpvpcSrcFwdQoSClass, chanrStatus=chanrStatus, sigPathAALType=sigPathAALType, asxJ2HBERDetected=asxJ2HBERDetected, pShmem3ConfAltCLPConfigVBR=pShmem3ConfAltCLPConfigVBR, moduleBoard=moduleBoard, pshmemPort=pshmemPort, q2931AFTemplateDstPort=q2931AFTemplateDstPort, hwPortModel=hwPortModel, serviceCategoryTable=serviceCategoryTable, pathrName=pathrName, pathExtTable=pathExtTable, asxJ2LOSCleared=asxJ2LOSCleared, boardStatsName=boardStatsName, foreSwitchModule=foreSwitchModule, asxSwLinkDown=asxSwLinkDown, pnniSpvpcSrcName=pnniSpvpcSrcName, chanQosPoliceScheme=chanQosPoliceScheme, pathrMaxBandwidth=pathrMaxBandwidth, asxE3PLCPYellowCleared=asxE3PLCPYellowCleared, qosClassFwdCtd=qosClassFwdCtd, asxE1PLCPYellowCleared=asxE1PLCPYellowCleared, oamGeneratingOpathTable=oamGeneratingOpathTable, swBoardLinkTable=swBoardLinkTable, q2931AFRejectKnowns=q2931AFRejectKnowns, envCpuSerialNumber=envCpuSerialNumber, guardEntry=guardEntry, mbufsZombieAlloc=mbufsZombieAlloc, asxTempSensorOverTemp=asxTempSensorOverTemp, proxyDirMapGroup=proxyDirMapGroup, pnniSpvpcRerouteInterval=pnniSpvpcRerouteInterval, netmodShmemEntry=netmodShmemEntry, q2931AFTemplateSrcPort=q2931AFTemplateSrcPort, swBoardTopoNumberOfLinks=swBoardTopoNumberOfLinks, pnniSpvcSrcBckQoSClass=pnniSpvcSrcBckQoSClass, pnniPmpSpvcFail=pnniPmpSpvcFail)
mibBuilder.exportSymbols("Fore-Switch-MIB", asxDS3FERFDetected=asxDS3FERFDetected, outputBufferTable=outputBufferTable, swBoardDebugMode=swBoardDebugMode, asxLinkDown=asxLinkDown, vcShmem2UnintentionalLostCells=vcShmem2UnintentionalLostCells, envTempSensorState=envTempSensorState, nShmem3ConfAal5PacketDropforUBR=nShmem3ConfAal5PacketDropforUBR, envFabricAlarmTripTemperature=envFabricAlarmTripTemperature, genericOutputPortConfModule=genericOutputPortConfModule, maxPaths=maxPaths, spvcDestAllocBandwidth=spvcDestAllocBandwidth, upcContractTagReq=upcContractTagReq, ochanStatsVCI=ochanStatsVCI, spvcDestUpTime=spvcDestUpTime, mbufsHeaderAlloc=mbufsHeaderAlloc, genericPortGroupEfciOn=genericPortGroupEfciOn, asxJ2AISCleared=asxJ2AISCleared, opathChannelSchedVPI=opathChannelSchedVPI, pnniPmpSpvccSrcPartyVPI=pnniPmpSpvccSrcPartyVPI, asxSonetLOSCleared=asxSonetLOSCleared, channelRouteTable=channelRouteTable, ntImportClockOperStatus=ntImportClockOperStatus, pathExtQosMetricEntry=pathExtQosMetricEntry, asxSpansUp=asxSpansUp, netmodTimingEntry=netmodTimingEntry, mbufUtilGroup=mbufUtilGroup, upcContractPCR01=upcContractPCR01, hdcompVpiLookupErrors=hdcompVpiLookupErrors, pShmem3EPDLostCells=pShmem3EPDLostCells, pShmem3ConfPort=pShmem3ConfPort, moduleTimingSupport=moduleTimingSupport, asxDualScpHotSwap=asxDualScpHotSwap, pnniSpvcSrcBackoffStatus=pnniSpvcSrcBackoffStatus, q2931AdminConfigType=q2931AdminConfigType, asxDualScpRedundancy=asxDualScpRedundancy, pathExtRtVbrMetric=pathExtRtVbrMetric, shmem3McastConnections=shmem3McastConnections, vcShmem2TotalLostCells=vcShmem2TotalLostCells, syslogDestinationHost=syslogDestinationHost, pnniSpvcSrcBckUpcKey=pnniSpvcSrcBckUpcKey, q2931AFDirection=q2931AFDirection, shmem2ConfEntry=shmem2ConfEntry, asxDS3IdleDetected=asxDS3IdleDetected, opathNrtVbrOverbooking=opathNrtVbrOverbooking, vcShmem3EPDLostCells=vcShmem3EPDLostCells, asxDS3PbitPerrDetected=asxDS3PbitPerrDetected, btBoard=btBoard, asxSwLinkUp=asxSwLinkUp, etherChipSetDec=etherChipSetDec, ppShmem2Qsize=ppShmem2Qsize, hdcompEntry=hdcompEntry, pnniSpvpcSrcQosIndex=pnniSpvpcSrcQosIndex, mbufsDrain=mbufsDrain, q2931OperStatus=q2931OperStatus, genericOutputPortConfPrioClp01Threshold=genericOutputPortConfPrioClp01Threshold, pathCACErrors=pathCACErrors, pShmem2UnintentionalLostCells=pShmem2UnintentionalLostCells, portShmemConfEntry=portShmemConfEntry, asxE3PLCPLOFCleared=asxE3PLCPLOFCleared, alarmGroup=alarmGroup, chanNumOutputs=chanNumOutputs, ftPnniDTLIndex=ftPnniDTLIndex, oamReceivedPathRDICells=oamReceivedPathRDICells, q2931PublicGroup=q2931PublicGroup, numBytesAlloc=numBytesAlloc, asxHostLinkUp=asxHostLinkUp, q2931SSCOPOperStatus=q2931SSCOPOperStatus, guardTable=guardTable, q2931SigReservedBW=q2931SigReservedBW, q2931NPCallFwdUpcKey=q2931NPCallFwdUpcKey, nshmemCurrentUcastConnections=nshmemCurrentUcastConnections, pathExtQosMetricEntryStatus=pathExtQosMetricEntryStatus, snmpConfGroup=snmpConfGroup, nShmem3ConfVcCLP1ForUBR=nShmem3ConfVcCLP1ForUBR, asxDS1PLCPLOFCleared=asxDS1PLCPLOFCleared, swAlarmMinorRelayState=swAlarmMinorRelayState, channelShmem2Entry=channelShmem2Entry, spvcDestEntry=spvcDestEntry, envCpuFlashSize=envCpuFlashSize, chanQosSCR=chanQosSCR, chanServCat=chanServCat, nGenericShmemCustomBCSBoard=nGenericShmemCustomBCSBoard, envTempSensorsEntry=envTempSensorsEntry, pnniSpvcSrcRetryCount=pnniSpvcSrcRetryCount, sigPathClsReceivedMessages=sigPathClsReceivedMessages, nShmem2CurrentMcastConnections=nShmem2CurrentMcastConnections, numberOfLinks=numberOfLinks, swAlarmMinorCategory=swAlarmMinorCategory, asxDS3LOFCleared=asxDS3LOFCleared, snmpRemoteSetsStatus=snmpRemoteSetsStatus, pnniSpvcDestRGroupIndex=pnniSpvcDestRGroupIndex, ntSecondaryExportClock=ntSecondaryExportClock, switchType=switchType, asxDS3AtmLCDCleared=asxDS3AtmLCDCleared, pnniSpvpcDestAssignedVPI=pnniSpvpcDestAssignedVPI, portAdminStatus=portAdminStatus, asxE1YellowCleared=asxE1YellowCleared, proxyDirMapPort=proxyDirMapPort, pathrInputVPI=pathrInputVPI, pnniPmpSpvccSrcRootVCI=pnniPmpSpvccSrcRootVCI, maxBlockSizeFree=maxBlockSizeFree, sbprServerAddress1=sbprServerAddress1, ochanStatsLostCells=ochanStatsLostCells, vpShmem2IntentionalLostCells=vpShmem2IntentionalLostCells, switchCurrentUserid=switchCurrentUserid, pShmem2ConfBoard=pShmem2ConfBoard, pathShmem2Entry=pathShmem2Entry, envFanBankSerialNumber=envFanBankSerialNumber, nsapNetworkPrefixPort=nsapNetworkPrefixPort, vmtVpciMapListStatus=vmtVpciMapListStatus, pathShmem2Table=pathShmem2Table, q2931AFFilterTListTable=q2931AFFilterTListTable, q2931AFLookupDstPort=q2931AFLookupDstPort, confTopoMinVCAvail=confTopoMinVCAvail, envFabricTemperature=envFabricTemperature, ftPnniSummaryType=ftPnniSummaryType, envFabricEntry=envFabricEntry, softwareVersionText=softwareVersionText, sigPathClsTransmittedMessages=sigPathClsTransmittedMessages, nsapTopoLinkSrcVpi=nsapTopoLinkSrcVpi, upcContractSchedMode=upcContractSchedMode, portHwNumber=portHwNumber, pnniSpvcDestCallingPort=pnniSpvcDestCallingPort, genericPortGroupPrioIndex=genericPortGroupPrioIndex, mbufsSoOptsAlloc=mbufsSoOptsAlloc, upcContractPoliceScheme=upcContractPoliceScheme, shmem2McastConnections=shmem2McastConnections, portInputVPIErrors=portInputVPIErrors, portNumPathsOut=portNumPathsOut, nShmem3ConfSharedMemory=nShmem3ConfSharedMemory, nGenericShmemMaxConnections=nGenericShmemMaxConnections, pnniPmpSpvccDestRootIndex=pnniPmpSpvccDestRootIndex, q2931NPMeasureRoundTripDelay=q2931NPMeasureRoundTripDelay, nsapTopoLinkSrcPort=nsapTopoLinkSrcPort, sigPathRemoteIpAddress=sigPathRemoteIpAddress, asxJ2AtmLCDDetected=asxJ2AtmLCDDetected, pnniSpvcDestIndex=pnniSpvcDestIndex, switchReservedPMPMaxVCI=switchReservedPMPMaxVCI, portUsedBandwidthOut=portUsedBandwidthOut, nShmem2CustomBCSValue=nShmem2CustomBCSValue, pnniSpvxcRGroupNsapAddr=pnniSpvxcRGroupNsapAddr, confTopoLBUbrLoadBalance=confTopoLBUbrLoadBalance, shmemMcastConnections=shmemMcastConnections, q2931AtmrConfDomainID=q2931AtmrConfDomainID, genericOutputPortConfPrioName=genericOutputPortConfPrioName, upcContractSCR0=upcContractSCR0, hwPortLEDModel=hwPortLEDModel, vmtVpciMapListTable=vmtVpciMapListTable, nGenericShmemMaxUcastConnections=nGenericShmemMaxUcastConnections, asxServiceCategoryOutputQueueCongested=asxServiceCategoryOutputQueueCongested, oamGeneratingChannelCells=oamGeneratingChannelCells, pnniSpvcSrcDtlTag=pnniSpvcSrcDtlTag, q2931ConnectedPDefaultAddress=q2931ConnectedPDefaultAddress, q2931AFLastFailureSrcNsap=q2931AFLastFailureSrcNsap, asxDS3LOSCleared=asxDS3LOSCleared, asxSonetPathUNEQDetected=asxSonetPathUNEQDetected, pnniSpvxcRGroupName=pnniSpvxcRGroupName, upcContractDoUBRTagging=upcContractDoUBRTagging, q2931AFTemplateAction=q2931AFTemplateAction, pathShmem3Table=pathShmem3Table, q2931AdminOperSigAlloc=q2931AdminOperSigAlloc, snmpAgentInterface=snmpAgentInterface, q2931ILMIReservedBW=q2931ILMIReservedBW, ntBoard=ntBoard, pShmem3RateLimit=pShmem3RateLimit, outputPathStatsTable=outputPathStatsTable, dualScpSwitchOverTime=dualScpSwitchOverTime, chanQosPCR=chanQosPCR, nShmem2CurrentSharedMemory=nShmem2CurrentSharedMemory, vmtVpciMapGroupTable=vmtVpciMapGroupTable, spvcDestSrcSpvcId=spvcDestSrcSpvcId, q2931AdminFtPnniTermCost=q2931AdminFtPnniTermCost, portMaxPathsIn=portMaxPathsIn, nShmem2CurrentCellsBuffers=nShmem2CurrentCellsBuffers, asxJ2LOFCleared=asxJ2LOFCleared, syslogFacility=syslogFacility, pnniSpvpcSrcIndex=pnniSpvpcSrcIndex, reverseChannelRouteTable=reverseChannelRouteTable, pnniPmpSpvccDestRootPort=pnniPmpSpvccDestRootPort, btSecondaryClockOperStatus=btSecondaryClockOperStatus, q2931AFLookupDstNsap=q2931AFLookupDstNsap, pnniPmpSpvccDestPartyIndex=pnniPmpSpvccDestPartyIndex, oamReceivedPathEntry=oamReceivedPathEntry, pnniSpvcSrcCallingVCI=pnniSpvcSrcCallingVCI, pathrSigProtocol=pathrSigProtocol, poolConfPPCalls=poolConfPPCalls, genericOutputPortStatsPrioTransmittedCells=genericOutputPortStatsPrioTransmittedCells, hwPortName=hwPortName, pnniSpvpcStatsGroup=pnniSpvpcStatsGroup, asxPortCardDown=asxPortCardDown, q2931AFTemplateDstNsap=q2931AFTemplateDstNsap, asxDualScpSyncFailure=asxDualScpSyncFailure, pnniPmpSpvccSrcPartyIndex=pnniPmpSpvccSrcPartyIndex, q2931AdmincbrCalls=q2931AdmincbrCalls, oamGuard=oamGuard, procUtilMaxLoadLastUpdate=procUtilMaxLoadLastUpdate, vmtVpciMapGroupStatus=vmtVpciMapGroupStatus, spvcDestOutVPI=spvcDestOutVPI, q2931OutputIlmiUpc=q2931OutputIlmiUpc, nShmem3TableMemorySize=nShmem3TableMemorySize, pnniSpvcSrcLastFailCause=pnniSpvcSrcLastFailCause, pShmem3Clp01ThreshforCBR=pShmem3Clp01ThreshforCBR, opathStatsLostPackets=opathStatsLostPackets, envMaxNumberOfCPUs=envMaxNumberOfCPUs, asxJ2TLOCCleared=asxJ2TLOCCleared, swBoardNsapPrefix=swBoardNsapPrefix, asxNetModuleUp=asxNetModuleUp, pnniSpvcDestTransitNetSel=pnniSpvcDestTransitNetSel, netmodShmemTable=netmodShmemTable, portShmemTable=portShmemTable, confTopoACRPropMult=confTopoACRPropMult, hwPortTAXILoopback=hwPortTAXILoopback, asxFanBankUp=asxFanBankUp, switchPmpEnable=switchPmpEnable, AtmConnSchedMode=AtmConnSchedMode, envPowerSupplyOutputState=envPowerSupplyOutputState, ftPnniSummaryAddress=ftPnniSummaryAddress, pShmem3Clp1ThreshforUBR=pShmem3Clp1ThreshforUBR, nShmem3Board=nShmem3Board, chanQosPerPacketPolicing=chanQosPerPacketPolicing, pShmem2QsizeforUBR=pShmem2QsizeforUBR, nsapStaticRouteMaxCbrCap=nsapStaticRouteMaxCbrCap, channelShmem3Entry=channelShmem3Entry, ftPnniDTLStatus=ftPnniDTLStatus, q2931E164AddrResTable=q2931E164AddrResTable, pnniSpvcBackoffInterval=pnniSpvcBackoffInterval, switchCounterResetTime=switchCounterResetTime, switchReservedPMPMinVCI=switchReservedPMPMinVCI, pnniSpvcSrcDtlWeight3=pnniSpvcSrcDtlWeight3, portInputPolicingStatus=portInputPolicingStatus, portShmemConfTable=portShmemConfTable, genericPortGroupAal5PacketDrop=genericPortGroupAal5PacketDrop, portPathOverbooking=portPathOverbooking, portCardUptime=portCardUptime, pnniSpvcSrcDtlIndex2=pnniSpvcSrcDtlIndex2, swAlarmTable=swAlarmTable, upcContractDoPacketDiscard=upcContractDoPacketDiscard, q2931AdminStatus=q2931AdminStatus, sigPathEntry=sigPathEntry, q2931AFLookupStatus=q2931AFLookupStatus, hdcompIndex=hdcompIndex, q2931AdminFtPnniOrigCost=q2931AdminFtPnniOrigCost, vmtVpciMapGroupEntry=vmtVpciMapGroupEntry, netmodGenericShmemCustomBCSTable=netmodGenericShmemCustomBCSTable, pnniSpvpcSrcRerouteStatus=pnniSpvpcSrcRerouteStatus, snmpAgentBoardNumber=snmpAgentBoardNumber, vmtVpciMapVPCI=vmtVpciMapVPCI, cbrctActiveIntPeriod=cbrctActiveIntPeriod, vmtVpciMapListEntry=vmtVpciMapListEntry, opathAllocBandwidth=opathAllocBandwidth, envCPUsTable=envCPUsTable, pnniSpvcDestBckQoSClass=pnniSpvcDestBckQoSClass, shmem3ConfIndex=shmem3ConfIndex, obufPriorityName=obufPriorityName)
mibBuilder.exportSymbols("Fore-Switch-MIB", nsapNetworkPrefixEntry=nsapNetworkPrefixEntry, genericPortGroupEfciOff=genericPortGroupEfciOff, PYSNMP_MODULE_ID=foreSwitchModule, sbprServerAddress2=sbprServerAddress2, ftPnniSummaryPrefixLength=ftPnniSummaryPrefixLength, pnniSpvxcRGroupSecondaryPort=pnniSpvxcRGroupSecondaryPort, shmemConfIndex=shmemConfIndex, pnniPmpSpvccSrcNextRootIndex=pnniPmpSpvccSrcNextRootIndex, ftPnniSummaryState=ftPnniSummaryState, portPriorityShmem2ConfEntry=portPriorityShmem2ConfEntry, dualScpAutoRemoveOldFiles=dualScpAutoRemoveOldFiles, nShmem2CustomBCSModule=nShmem2CustomBCSModule, pShmem3Priority=pShmem3Priority, pathStatus=pathStatus, hwPortCarrier=hwPortCarrier, vcShmem3CLP1TxCells=vcShmem3CLP1TxCells, pShmem3Clp01ThreshforUBR=pShmem3Clp01ThreshforUBR, asxDS1AISDetected=asxDS1AISDetected, snmpWriteCommunity=snmpWriteCommunity, chanrInputPort=chanrInputPort, shmem2ConfIndex=shmem2ConfIndex, pShmem3Module=pShmem3Module, proxyDirMapIndex=proxyDirMapIndex, ntSecondaryImportClock=ntSecondaryImportClock, q2931ReceivedMessages=q2931ReceivedMessages, mbufsAtableAlloc=mbufsAtableAlloc, envFanBanksTable=envFanBanksTable, ftPnniDTLTable=ftPnniDTLTable, nsapTopoLinkSrcMask=nsapTopoLinkSrcMask, pathExtEntry=pathExtEntry, asxOutputQueueCellLoss=asxOutputQueueCellLoss, pnniSpvpcDestNumberOfSPVPCs=pnniSpvpcDestNumberOfSPVPCs, q2931StatsPort=q2931StatsPort, asxJ2YellowCleared=asxJ2YellowCleared, hwPortRxSyncLED=hwPortRxSyncLED, trapDestStatus=trapDestStatus, crGeneralFailure=crGeneralFailure, serviceCategoryEntry=serviceCategoryEntry, asxFanBankDown=asxFanBankDown, opathStatsIntentionalLostCells=opathStatsIntentionalLostCells, genericOutputPortConfTable=genericOutputPortConfTable, swBoardMulticastMode=swBoardMulticastMode, obufBufferSize=obufBufferSize, pathTable=pathTable, perCallDbgFilterRowStatus=perCallDbgFilterRowStatus, vpGroupVPI=vpGroupVPI, portMaxPathsOut=portMaxPathsOut, q2931CallingPAddressPresentation=q2931CallingPAddressPresentation, poolConfGroup=poolConfGroup, chanrConnectionType=chanrConnectionType, pnniSpvpcSrcCallingVPI=pnniSpvpcSrcCallingVPI, envFanBankType=envFanBankType, linkTable=linkTable, opathUsedBandwidth=opathUsedBandwidth, sigPathOperStatus=sigPathOperStatus, q2931AFTemplateName=q2931AFTemplateName, proxyDirGroupTable=proxyDirGroupTable, envNumberOfPowerSupplies=envNumberOfPowerSupplies, envPowerSupplySerialNumber=envPowerSupplySerialNumber, confTopoSpansBorderSwitch=confTopoSpansBorderSwitch, q2931E164Port=q2931E164Port, shmem2NumPriorities=shmem2NumPriorities, proxyDirGroupPrefix=proxyDirGroupPrefix, asxDS1AtmLCDDetected=asxDS1AtmLCDDetected, ochanStatsPort=ochanStatsPort, q2931ILMIOperStatus=q2931ILMIOperStatus, pShmem2TxCells=pShmem2TxCells, dualScpConfTable=dualScpConfTable, nsapTopoLinkDest=nsapTopoLinkDest, vcShmem2IntentionalLostCells=vcShmem2IntentionalLostCells, pShmem3OverflowLostCells=pShmem3OverflowLostCells, asxDS1PLCPLOFDetected=asxDS1PLCPLOFDetected, nShmem2NumPriorities=nShmem2NumPriorities, portShmemGroup=portShmemGroup, pShmem3Clp1ThreshforABR=pShmem3Clp1ThreshforABR, opathSigProtocol=opathSigProtocol, asxSVXCPStateDroppedCall=asxSVXCPStateDroppedCall, btmPerPriorityFeature=btmPerPriorityFeature, boardTimingGroup=boardTimingGroup, pathMaxChannels=pathMaxChannels, q2931AFFilterNextIndex=q2931AFFilterNextIndex, moduleTestOperStatus=moduleTestOperStatus, moduleHwMinorRev=moduleHwMinorRev, upcContractCongestionBasedPeakBw=upcContractCongestionBasedPeakBw, pnniPmpSpvccSrcPartyAssignedVPI=pnniPmpSpvccSrcPartyAssignedVPI, channelTable=channelTable, mcastSpaceTable=mcastSpaceTable, q2931NPCallState=q2931NPCallState, linkEntry=linkEntry, upcContractKey=upcContractKey, envCPUsEntry=envCPUsEntry, mbufsDrops=mbufsDrops, switchSbprServerAddressTable=switchSbprServerAddressTable, outputBufferEntry=outputBufferEntry, procUtilHistoryReset=procUtilHistoryReset, q2931SupplementaryServicesStatus=q2931SupplementaryServicesStatus, proxyDirGroupEntry=proxyDirGroupEntry, pnniSpvpcPaceInterval=pnniSpvpcPaceInterval, q2931CallsFailures=q2931CallsFailures, switchSecondaryClockPort=switchSecondaryClockPort, swAlarmRelayTable=swAlarmRelayTable, mbufsFtableAlloc=mbufsFtableAlloc, envCpuDRAMSize=envCpuDRAMSize, sigPathRemoteAtmAddress=sigPathRemoteAtmAddress, q2931AFTemplateSrcVPI=q2931AFTemplateSrcVPI, genericOutputPortStatsPort=genericOutputPortStatsPort, crXfrPrimaryXfrFailed=crXfrPrimaryXfrFailed, nsapTopoLinkVbrCapacity=nsapTopoLinkVbrCapacity, mbufsWait=mbufsWait, nsapTopoLinkUbrEstimatedBandwidth=nsapTopoLinkUbrEstimatedBandwidth, genericPortGroupIndex=genericPortGroupIndex, q2931AcceleratedClear=q2931AcceleratedClear, pnniSpvccUp=pnniSpvccUp, pnniSpvcDestTimingReq=pnniSpvcDestTimingReq, vpShmem3CurrentQsize=vpShmem3CurrentQsize, snmpReconfigure=snmpReconfigure, ochanStatsTransmittedCells=ochanStatsTransmittedCells, fansGroup=fansGroup, oamGeneratingChannelTable=oamGeneratingChannelTable, pnniSpvpcDestCalledAtmAddr=pnniSpvpcDestCalledAtmAddr, asxE3YellowDetected=asxE3YellowDetected, oamGroup=oamGroup, ntSecondaryRecoveredClock=ntSecondaryRecoveredClock, asxSonetLOFDetected=asxSonetLOFDetected, nShmem3ConfCountPackets=nShmem3ConfCountPackets, asxDS1PLCPYellowCleared=asxDS1PLCPYellowCleared, asxSonetAtmLineBIPCleared=asxSonetAtmLineBIPCleared, appModuleOosLed=appModuleOosLed, pnniPmpSpvccSrcPartyLastChangeTime=pnniPmpSpvccSrcPartyLastChangeTime, vcShmem3IntentionalLostCells=vcShmem3IntentionalLostCells, q2931AFLookupTemplate=q2931AFLookupTemplate, vpGroupEntry=vpGroupEntry, vpShmem2TotalLostCells=vpShmem2TotalLostCells, reverseChannelRouteEntry=reverseChannelRouteEntry, portShmem2Group=portShmem2Group, sigPathEntryStatus=sigPathEntryStatus, portEntry=portEntry, channelShmem2Table=channelShmem2Table, outputPathExtEntry=outputPathExtEntry, ftPnniSummaryEntry=ftPnniSummaryEntry, vcShmem3CLP1LostCells=vcShmem3CLP1LostCells, nGenericShmemCurrentUcastConnections=nGenericShmemCurrentUcastConnections, pshmemMaxCDVforCBR=pshmemMaxCDVforCBR, portOutputVCIErrors=portOutputVCIErrors, pnniSpvcSrcEntry=pnniSpvcSrcEntry, netmodShmem2Entry=netmodShmem2Entry, swAlarmACOState=swAlarmACOState, q2931AFFilterTListStatus=q2931AFFilterTListStatus, q2931AFLastFailureDirection=q2931AFLastFailureDirection, asxAtmIfEntry=asxAtmIfEntry, asxSonetPathLabelDetected=asxSonetPathLabelDetected, portRtVbrBufferOverb=portRtVbrBufferOverb, pnniSpvcSrcTransitNetSel=pnniSpvcSrcTransitNetSel, dualScpSwitchOverThreshold=dualScpSwitchOverThreshold, pnniSpvxcRGroupPacingNumber=pnniSpvxcRGroupPacingNumber, pnniSpvpcSrcLastChangeTime=pnniSpvpcSrcLastChangeTime, boardModel=boardModel, pshmemTxCells=pshmemTxCells, swAlarmRelayState=swAlarmRelayState, nShmem3ConfVcCLP01ForUBR=nShmem3ConfVcCLP01ForUBR, portCounterResetTime=portCounterResetTime, revChanrSigProtocol=revChanrSigProtocol, portGCRAPolicingNRTVBR=portGCRAPolicingNRTVBR, vpGroupIndex=vpGroupIndex, vpShmem3CLP01LostCells=vpShmem3CLP01LostCells, q2931AFLastFailureSrcPort=q2931AFLastFailureSrcPort, pnniSpvcSrcDtlIndex=pnniSpvcSrcDtlIndex, genericOutputPortConfPort=genericOutputPortConfPort, asxIpFilterViolation=asxIpFilterViolation, pathMaxVCI=pathMaxVCI, nShmem3CurrentMcastConnections=nShmem3CurrentMcastConnections, channelEntry=channelEntry, trapDestEntry=trapDestEntry, boardIndex=boardIndex, ppShmem2ClpThreshold=ppShmem2ClpThreshold, vpiLookupErrors=vpiLookupErrors, asxDS1AISCleared=asxDS1AISCleared, q2931LastChangeTime=q2931LastChangeTime, pnniPmpSpvccSrcRootSecondaryVPI=pnniPmpSpvccSrcRootSecondaryVPI, q2931AFLookupResult=q2931AFLookupResult, ntPrimaryImportClock=ntPrimaryImportClock, pnniSpvcPaceInterval=pnniSpvcPaceInterval, q2931AdminMaxVPI=q2931AdminMaxVPI, upcContractEstimatedUbrBandwidth=upcContractEstimatedUbrBandwidth, vcShmem3OutputPort=vcShmem3OutputPort, pnniSpvpcSrcActiveDtlIndex=pnniSpvpcSrcActiveDtlIndex, genericOutputPortStatsEntry=genericOutputPortStatsEntry, pnniSpvxcRGroupSwitchoverCmd=pnniSpvxcRGroupSwitchoverCmd, atmIfConnSchedMode=atmIfConnSchedMode, pnniSpvpcDestCallingAtmAddr=pnniSpvpcDestCallingAtmAddr, pathrRejectedCells=pathrRejectedCells, q2931CallingPAddressRestriction=q2931CallingPAddressRestriction, moduleNumberOfPorts=moduleNumberOfPorts, q2931VCCs=q2931VCCs, asxPs5VoltDown=asxPs5VoltDown, dualScpFailover=dualScpFailover, opathVbrOverbooking=opathVbrOverbooking, q2931CreationFailure=q2931CreationFailure, qosClassFwdCdv=qosClassFwdCdv, genericOutputPortConfBoard=genericOutputPortConfBoard, mcastSpaceNumConn=mcastSpaceNumConn, pShmem2QsizeforCBR=pShmem2QsizeforCBR, pnniPmpSpvccSrcPartyRowStatus=pnniPmpSpvccSrcPartyRowStatus, q2931AFRejectUnknowns=q2931AFRejectUnknowns, pnniSpvxcRGroupPrimaryPort=pnniSpvxcRGroupPrimaryPort, nShmem2ConfEfciOn=nShmem2ConfEfciOn, spvcSrcEntry=spvcSrcEntry, nsapStaticRouteAbrSupport=nsapStaticRouteAbrSupport, trapDest=trapDest, pathExtQosMetricTable=pathExtQosMetricTable, confTopoMaxHopCount=confTopoMaxHopCount, shmem2TableMemorySize=shmem2TableMemorySize, appModuleName=appModuleName, asxSonetLineAISDetected=asxSonetLineAISDetected, dualScpSyncRequestList=dualScpSyncRequestList, spvcSrcSpvcId=spvcSrcSpvcId, pnniSpvpcDestCallingPort=pnniSpvpcDestCallingPort, genericPortGroupConfTable=genericPortGroupConfTable, asxDS3AtmLCDDetected=asxDS3AtmLCDDetected, asxE3AtmLCDDetected=asxE3AtmLCDDetected, portOutputCACErrors=portOutputCACErrors, portVbrBufferOverb=portVbrBufferOverb, nsapTopoLinkSrc=nsapTopoLinkSrc, swBoardTopoTable=swBoardTopoTable, confTopoNsapIndInterval=confTopoNsapIndInterval, shmem2Counters=shmem2Counters, nshmemConfRow=nshmemConfRow, portAAL5PacketDiscardVBR=portAAL5PacketDiscardVBR, portHwModule=portHwModule, shmemMemorySize=shmemMemorySize, sigPathVPI=sigPathVPI, ftPnniDTLEntry=ftPnniDTLEntry, asxDS1LOSCleared=asxDS1LOSCleared, syslogConsoleState=syslogConsoleState, dualScp=dualScp, softwareVersion=softwareVersion, fabricCorrectedLookup=fabricCorrectedLookup, numberOfPorts=numberOfPorts, mgmtGroup=mgmtGroup, sigPathRestarts=sigPathRestarts, swBoardTopoIndex=swBoardTopoIndex, switchATMLayerOAM=switchATMLayerOAM, asxSonetPathRDIDetected=asxSonetPathRDIDetected, q2931AFRejectUnknown=q2931AFRejectUnknown, portTransmittedCells=portTransmittedCells, asxSonetAtmLineBIPDetected=asxSonetAtmLineBIPDetected, hwPortBufferSize=hwPortBufferSize, shmem2CellsBuffers=shmem2CellsBuffers, boardTimingEntry=boardTimingEntry, pnniPmpRerouteInitiated=pnniPmpRerouteInitiated, asxSonetPathRDICleared=asxSonetPathRDICleared, pnniSpvcSrcTimingReq=pnniSpvcSrcTimingReq, envFanBankRevision=envFanBankRevision, swAlarmRelayIndex=swAlarmRelayIndex)
mibBuilder.exportSymbols("Fore-Switch-MIB", pShmem3VcCLPLostCells=pShmem3VcCLPLostCells, switchGMTime=switchGMTime, pnniSpvcSrcDtlWeight2=pnniSpvcSrcDtlWeight2, portShmemEntry=portShmemEntry, mcastSpaceName=mcastSpaceName, sigPathOutputSigService=sigPathOutputSigService, q2931OutputSigUpc=q2931OutputSigUpc, q2931AdminEntry=q2931AdminEntry, ftPnniDTLNodePrefix=ftPnniDTLNodePrefix, pathExtQosMetricIndex=pathExtQosMetricIndex, pathrUptime=pathrUptime, q2931PnniRccVci=q2931PnniRccVci, pshmemPriority=pshmemPriority, nShmem3ConfAal5PacketDrop=nShmem3ConfAal5PacketDrop, outputPathEntry=outputPathEntry, pnniPmpSpvccSrcPartyTable=pnniPmpSpvccSrcPartyTable, envPowerSupplyEntry=envPowerSupplyEntry, pnniSpvcSrcBearerClass=pnniSpvcSrcBearerClass, switchDebounceHysteresis=switchDebounceHysteresis, netmodTimingTable=netmodTimingTable, swBoardUptime=swBoardUptime, nShmem2TableMemorySize=nShmem2TableMemorySize, ntPrimaryRecoveredClock=ntPrimaryRecoveredClock, pathSigProtocol=pathSigProtocol, pnniSpvpcPaceNumSpvpcs=pnniSpvpcPaceNumSpvpcs, q2931PeerPort=q2931PeerPort, q2931AdminnrtvbrCalls=q2931AdminnrtvbrCalls, switchHttpHelpUrl=switchHttpHelpUrl, pshmemLostCells=pshmemLostCells, mallocUtilTable=mallocUtilTable, pnniSpvcRerouteNumSpvcs=pnniSpvcRerouteNumSpvcs, pnniPmpSpvccSrcPartyRouteCost=pnniPmpSpvccSrcPartyRouteCost, nshmemCurrentSharedMemory=nshmemCurrentSharedMemory, nShmem2CustomBCSBoard=nShmem2CustomBCSBoard, pnniSpvcSrcCalledAssignedVCI=pnniSpvcSrcCalledAssignedVCI, portCardGroup=portCardGroup, envCPUState=envCPUState, q2931UserUserSignallingAdminStatus=q2931UserUserSignallingAdminStatus, nShmem3ConfEfciOff=nShmem3ConfEfciOff, portShmem2Entry=portShmem2Entry, pShmem2QsizeforABR=pShmem2QsizeforABR, q2931QosClassExpansionKey=q2931QosClassExpansionKey, switchSecondaryClock=switchSecondaryClock, atmIfConnSchedOverride=atmIfConnSchedOverride, pnniPmpSpvccSrcRootTable=pnniPmpSpvccSrcRootTable, signalingGroup=signalingGroup, pnniPmpSpvccSrcPartyQosIndex=pnniPmpSpvccSrcPartyQosIndex, pathAllocBandwidth=pathAllocBandwidth, opathNumChannels=opathNumChannels, pathRejectedCells=pathRejectedCells, asxQ2931CallClearing=asxQ2931CallClearing, nsapNetworkPrefixValue=nsapNetworkPrefixValue, qosClassValue=qosClassValue, cbrctIdlePatterns=cbrctIdlePatterns, hwPortCounterResetTime=hwPortCounterResetTime, envFabricTemperatureState=envFabricTemperatureState, pShmem3ConfPVCSchedulingCBR=pShmem3ConfPVCSchedulingCBR, channelRouteEntry=channelRouteEntry, nsapStaticRouteAddress=nsapStaticRouteAddress, asxDS3AISCleared=asxDS3AISCleared, netmodShmem2CustomBCSTable=netmodShmem2CustomBCSTable, chanQosMBS=chanQosMBS, pnniSpvpcDestIndex=pnniSpvpcDestIndex, asxE3AISCleared=asxE3AISCleared, sigPathCallsFailures=sigPathCallsFailures, pnniSpvpcSrcBckUpcKey=pnniSpvpcSrcBckUpcKey, boardStatsValue=boardStatsValue, spvcSrcDestSpvcId=spvcSrcDestSpvcId, swBoardMaxChannels=swBoardMaxChannels, envCpuMACAddress=envCpuMACAddress, q2931NPCallDstNsap=q2931NPCallDstNsap, nShmem3ConfVcCLP1ForVBR=nShmem3ConfVcCLP1ForVBR, q2931StatsEntry=q2931StatsEntry, q2931UNIOperVersion=q2931UNIOperVersion, proxyDirMapEntryTable=proxyDirMapEntryTable, oamGeneratingOpathEntry=oamGeneratingOpathEntry, nsapTopoLinkDestVpi=nsapTopoLinkDestVpi, vcShmem3UnintentionalLostCells=vcShmem3UnintentionalLostCells, q2931NPCallEntry=q2931NPCallEntry, ochanStatsVPI=ochanStatsVPI, asxServiceCategoryOutputQueueCellLoss=asxServiceCategoryOutputQueueCellLoss, asxSonetLOSDetected=asxSonetLOSDetected, pathPort=pathPort, pnniSpvpcParamGroup=pnniSpvpcParamGroup, pShmem3CLP1LostCells=pShmem3CLP1LostCells, nsapTopoLinkFreshness=nsapTopoLinkFreshness, pShmem2CurrentQsize=pShmem2CurrentQsize, pnniPmpSpvcUp=pnniPmpSpvcUp, portAllocBandwidthOut=portAllocBandwidthOut, upcContractAal5Epd=upcContractAal5Epd, q2931MaxVCI=q2931MaxVCI, asxHostLinkDown=asxHostLinkDown, pnniPmpSpvccSrcRootName=pnniPmpSpvccSrcRootName, moduleSerialNumber=moduleSerialNumber, pnniSpvcSrcFwdQoSClass=pnniSpvcSrcFwdQoSClass, moduleProductNumber=moduleProductNumber, ifIndexMapGroup=ifIndexMapGroup, moduleTable=moduleTable, proxyDirGroupGroup=proxyDirGroupGroup, asxTP25LOSCleared=asxTP25LOSCleared, portInputDelayMode=portInputDelayMode, pnniSpvpcDestCallingVPI=pnniSpvpcDestCallingVPI, pnniNormalToOverloadTransition=pnniNormalToOverloadTransition, sigPathStatsTable=sigPathStatsTable, confTopoSpansAreaID=confTopoSpansAreaID, switchCallPreservation=switchCallPreservation, pnniSpvccDown=pnniSpvccDown, pnniPmpSpvccSrcPartyEntry=pnniPmpSpvccSrcPartyEntry, pnniPmpSpvccSrcRootEntry=pnniPmpSpvccSrcRootEntry, asxJ2PAISCleared=asxJ2PAISCleared, confTopoFtPnniForeLevel=confTopoFtPnniForeLevel, pshmemConfBoard=pshmemConfBoard, nshmemConfAal5PacketDrop=nshmemConfAal5PacketDrop, q2931VpCapability=q2931VpCapability, nsapGroup=nsapGroup, opathStatus=opathStatus, trapNumberOfDest=trapNumberOfDest, genericPortGroupPrioName=genericPortGroupPrioName, snmpAgentAddress=snmpAgentAddress, pnniSpvxcRGroupState=pnniSpvxcRGroupState, qosClassExpansionEntry=qosClassExpansionEntry, appModuleIndex=appModuleIndex, portCardTable=portCardTable, pnniSpvpcLowestPriority=pnniSpvpcLowestPriority, spvcDestOutVCI=spvcDestOutVCI, spvcDestEntryStatus=spvcDestEntryStatus, asxE1AISDetected=asxE1AISDetected, upcContractMBS=upcContractMBS, vpShmem2OutputVPI=vpShmem2OutputVPI, portRemoteAtmAddress=portRemoteAtmAddress, pnniSpvxcRGroupPacingInterval=pnniSpvxcRGroupPacingInterval, q2931AdminPlanType=q2931AdminPlanType, asxDS1LOSDetected=asxDS1LOSDetected, shmem3ConfEntry=shmem3ConfEntry, swAlarmRelayEntry=swAlarmRelayEntry, envPowerSupplyIndex=envPowerSupplyIndex, q2931AdminabrCalls=q2931AdminabrCalls, netmodName=netmodName, opathExtEntryStatus=opathExtEntryStatus, envPowerSupplyCurrentState=envPowerSupplyCurrentState, q2931AFFilterEntry=q2931AFFilterEntry, chanCells=chanCells, asxSonetPathLabelCleared=asxSonetPathLabelCleared, portOutputVPIErrors=portOutputVPIErrors, opathTrafficShapeVPI=opathTrafficShapeVPI, shmem3CellsBuffers=shmem3CellsBuffers, nsapStaticRouteVPI=nsapStaticRouteVPI, pnniSpvcDestCallingAtmAddr=pnniSpvcDestCallingAtmAddr, pShmem3ConfSVCSchedulingVBR=pShmem3ConfSVCSchedulingVBR, q2931AdminUseNativeE164=q2931AdminUseNativeE164, portShmem2ConfTable=portShmem2ConfTable, asxTP25LOSDetected=asxTP25LOSDetected, q2931AFLastFailureGroup=q2931AFLastFailureGroup, pShmem3Clp01ThreshforABR=pShmem3Clp01ThreshforABR, nsapStaticRouteEpdSupport=nsapStaticRouteEpdSupport, pnniPmpSpvccDestRootVPI=pnniPmpSpvccDestRootVPI, asxDS1CRCErrDetected=asxDS1CRCErrDetected, pnniSpvcSrcDtlIndex3=pnniSpvcSrcDtlIndex3, procUtilMinLoad=procUtilMinLoad, hardwareVersion=hardwareVersion, opathSetupErrors=opathSetupErrors, q2931AddressFilterGroup=q2931AddressFilterGroup, upcContractEntryStatus=upcContractEntryStatus, shmem3VpiVciLists=shmem3VpiVciLists, nsapTopoLinkUbrVCs=nsapTopoLinkUbrVCs, boardStatsEntry=boardStatsEntry, switchGroup=switchGroup, pshmemClpThreshforABR=pshmemClpThreshforABR, nGenericShmemModule=nGenericShmemModule, appModulePanicAction=appModulePanicAction, nsapStaticRouteEntry=nsapStaticRouteEntry, vmtVpciMapListIndex=vmtVpciMapListIndex, pnniSpvcDestSusceptClip=pnniSpvcDestSusceptClip, ftPnniSummarySuppress=ftPnniSummarySuppress, pnniPmpSpvccDestPartyRGroupIndex=pnniPmpSpvccDestPartyRGroupIndex, asxFabricDown=asxFabricDown, hwPortErrors=hwPortErrors, portTable=portTable, mbufsPcbAlloc=mbufsPcbAlloc, asxSonetPathUNEQCleared=asxSonetPathUNEQCleared, asxJ2LOSDetected=asxJ2LOSDetected, mbufsSpace=mbufsSpace, confTopoMinThresh=confTopoMinThresh, pShmem3ConfSVCSchedulingCBR=pShmem3ConfSVCSchedulingCBR, opathVbrBufferOverb=opathVbrBufferOverb, ppShmem2ConfPriority=ppShmem2ConfPriority, pnniSpvccFail=pnniSpvccFail, spvcSrcInVPI=spvcSrcInVPI, upcContractDoPPPolicing=upcContractDoPPPolicing, pathrOutputPort=pathrOutputPort, pnniPmpSpvccSrcRootCallingDomain=pnniPmpSpvccSrcRootCallingDomain, asxJ2TLOCDetected=asxJ2TLOCDetected, sbprServerAddress4=sbprServerAddress4, oamReceivedPathAISCells=oamReceivedPathAISCells, pnniSpvpcRerouteNumSpvpcs=pnniSpvpcRerouteNumSpvpcs, nShmem2ConfAal5PacketDropforUBR=nShmem2ConfAal5PacketDropforUBR, mcastSpaceEntry=mcastSpaceEntry, asxSwitchLoginDetected=asxSwitchLoginDetected, q2931VpciGroupIndex=q2931VpciGroupIndex, genericOutputPortStatsModule=genericOutputPortStatsModule, hwPortAdminStatus=hwPortAdminStatus, swBoardLinkEntry=swBoardLinkEntry, proxyDirGroupIndex=proxyDirGroupIndex, revChanrInputVCI=revChanrInputVCI, portCardHardwareConf=portCardHardwareConf, moduleSpeed=moduleSpeed, upcContractSCR=upcContractSCR, nsapTopoLinkOrig=nsapTopoLinkOrig, q2931E164Address=q2931E164Address, pnniSpvpcSrcDtlTag=pnniSpvpcSrcDtlTag, nsapStaticRoutePort=nsapStaticRoutePort, pshmemConfPort=pshmemConfPort, nsapNetworkPrefixStatus=nsapNetworkPrefixStatus, q2931AFStatsTable=q2931AFStatsTable, pnniSpvcRerouteInterval=pnniSpvcRerouteInterval, sigPathCallsCompletions=sigPathCallsCompletions, q2931ILMIAdminVCI=q2931ILMIAdminVCI, crXfrSecondaryXfrFailed=crXfrSecondaryXfrFailed, pShmem3AtmInterfaceIndex=pShmem3AtmInterfaceIndex, switchHttpServer=switchHttpServer, netmodShmem3Table=netmodShmem3Table, pnniPmpSpvccSrcRootIndex=pnniPmpSpvccSrcRootIndex, ppShmem2ConfModule=ppShmem2ConfModule, opathChannelSchedServCat=opathChannelSchedServCat, q2931E164VPI=q2931E164VPI, q2931AFLookupEntry=q2931AFLookupEntry, netmodShmem3Group=netmodShmem3Group, envPowerSupplyType=envPowerSupplyType, q2931NNIProto=q2931NNIProto, numberOfBoards=numberOfBoards, envPowerSupplyInputState=envPowerSupplyInputState, q2931AdminOperSigMode=q2931AdminOperSigMode, confTopoSpansPnniBorderSwitch=confTopoSpansPnniBorderSwitch, asxNonextendedModeViolation=asxNonextendedModeViolation, pnniSpvcRerouteThreshold=pnniSpvcRerouteThreshold, proxyDirGroupStatus=proxyDirGroupStatus, asxE1YellowDetected=asxE1YellowDetected, qosClassExpansionKey=qosClassExpansionKey, proxyDirGroupVPCIGroup=proxyDirGroupVPCIGroup, pshmemCurrentQsize=pshmemCurrentQsize, sigPathMinVCI=sigPathMinVCI, pnniSpvpcSrcCalledPort=pnniSpvpcSrcCalledPort, q2931AFTemplateSrcNsap=q2931AFTemplateSrcNsap, proxyDirMapVp=proxyDirMapVp, asxAtmIfTable=asxAtmIfTable, linkCapacity=linkCapacity, oamGeneratingOpathCells=oamGeneratingOpathCells, swAlarmMajorRelayState=swAlarmMajorRelayState, chanPort=chanPort, upcContractName=upcContractName, vmtVpciMapPort=vmtVpciMapPort, mbufsClusters=mbufsClusters, moduleAttachState=moduleAttachState, nShmem2CellMemorySize=nShmem2CellMemorySize)
mibBuilder.exportSymbols("Fore-Switch-MIB", pnniSpvcDestUpTime=pnniSpvcDestUpTime, swBoardATMLayerOAM=swBoardATMLayerOAM, pnniPmpSpvccDestPartyAtmAddr=pnniPmpSpvccDestPartyAtmAddr, procUtilMonInterval=procUtilMonInterval, pnniSpvxcRGroupActivePort=pnniSpvxcRGroupActivePort, pShmem2Priority=pShmem2Priority, vpShmem3CLP1TxCells=vpShmem3CLP1TxCells, outputChannelStatsEntry=outputChannelStatsEntry, ochanStatsIntentionalLostCells=ochanStatsIntentionalLostCells, switchProtocolType=switchProtocolType, pnniSpvpcDestFwdQoSClass=pnniSpvpcDestFwdQoSClass, nShmem3ConfVcCLP1ForABR=nShmem3ConfVcCLP1ForABR, pnniSpvcSrcPriority=pnniSpvcSrcPriority, snmpThisAgentBoardNumber=snmpThisAgentBoardNumber, dualScpNumSyncRequests=dualScpNumSyncRequests, pnniSpvcDestNumberOfSPVCs=pnniSpvcDestNumberOfSPVCs, netmodShmemGroup=netmodShmemGroup, q2931AFFilterTable=q2931AFFilterTable, hwPortQueueLength=hwPortQueueLength, hwPortEntry=hwPortEntry, q2931AdminEntryStatus=q2931AdminEntryStatus, q2931AFLookupDstVPI=q2931AFLookupDstVPI, q2931Restarts=q2931Restarts, portCardAssemblyRevision=portCardAssemblyRevision, portNrtVbrBufferOverb=portNrtVbrBufferOverb, q2931NPPingStatsPktsReceived=q2931NPPingStatsPktsReceived, swBoardEntry=swBoardEntry, procUtilValue=procUtilValue, shmem3ConfTable=shmem3ConfTable, spvcDestStatus=spvcDestStatus, portInputVCIErrors=portInputVCIErrors, portCardIndex=portCardIndex, portPPPolicingVBR=portPPPolicingVBR, proxyDirMapVPCI=proxyDirMapVPCI, pathExtAbrMetric=pathExtAbrMetric, spvcSrcEntryStatus=spvcSrcEntryStatus, asxQ2931Down=asxQ2931Down, pnniPmpSpvccSrcRootStatus=pnniPmpSpvccSrcRootStatus, upcContractServiceSubCategory=upcContractServiceSubCategory, q2931OutputSigService=q2931OutputSigService, ftPnniDTLNodeMask=ftPnniDTLNodeMask, q2931AFLookupSrcVPI=q2931AFLookupSrcVPI, cesExtGroup=cesExtGroup, pnniSpvxcRGroupTable=pnniSpvxcRGroupTable, pathrInputPort=pathrInputPort, qosClassExpansionGroup=qosClassExpansionGroup, boardTrafficManagementPerPriorityTable=boardTrafficManagementPerPriorityTable, q2931AFFilterTListEntry=q2931AFFilterTListEntry, spvcDestTable=spvcDestTable, opathStatsLostCells=opathStatsLostCells, mbufsRtableAlloc=mbufsRtableAlloc, cbrctState=cbrctState, q2931AdminSigMode=q2931AdminSigMode, swBoardLinkDest=swBoardLinkDest, boardSerialNumber=boardSerialNumber, pathrLoopVPI=pathrLoopVPI, q2931MinVCI=q2931MinVCI, q2931NPPingStatsMinimumDelay=q2931NPPingStatsMinimumDelay, envTempSensorsTable=envTempSensorsTable, swBoardLinkSrc=swBoardLinkSrc, spvcSrcNumberOfSPVCs=spvcSrcNumberOfSPVCs, q2931NPCallCauseCode=q2931NPCallCauseCode, hwPortTable=hwPortTable, portShmem2Table=portShmem2Table, spvcSrcInPort=spvcSrcInPort, q2931CallsCompletions=q2931CallsCompletions, nsapTopoLinkCapabilitySet=nsapTopoLinkCapabilitySet, envMgmtBoardSerialNumber=envMgmtBoardSerialNumber, pShmem2ConfPort=pShmem2ConfPort, obufOverflows=obufOverflows, boardStatsTable=boardStatsTable, procUtilsSystemPartitionID=procUtilsSystemPartitionID, portGCRAPolicingCBR=portGCRAPolicingCBR, channelGroup=channelGroup, procUtilMaxLoad=procUtilMaxLoad, pnniSpvcSrcOldRouteCost=pnniSpvcSrcOldRouteCost, pathrAllocBandwidth=pathrAllocBandwidth, asxE3LOSCleared=asxE3LOSCleared, q2931AFStatsEntry=q2931AFStatsEntry, pnniPmpSpvccGroup=pnniPmpSpvccGroup, asxShmem2OutputQueueCellLoss=asxShmem2OutputQueueCellLoss, genericOutputPortStatsTable=genericOutputPortStatsTable, pnniSpvpcSrcNumberOfSPVPCs=pnniSpvpcSrcNumberOfSPVPCs, portPPPolicingCBR=portPPPolicingCBR, atmIfConnSchedLink=atmIfConnSchedLink, genericOutputPortConfAtmif=genericOutputPortConfAtmif, confTopoPGSNReachCost=confTopoPGSNReachCost, asxPsInputUp=asxPsInputUp, pnniPmpSpvccSrcPartyLastFailCause=pnniPmpSpvccSrcPartyLastFailCause, portOutputMaxctd=portOutputMaxctd, chanCDV=chanCDV, q2931NPCallVerbose=q2931NPCallVerbose, vcShmem3TransmittedPackets=vcShmem3TransmittedPackets, upcContractSCR01=upcContractSCR01, pnniPmpSpvccSrcRootFwdQoSClass=pnniPmpSpvccSrcRootFwdQoSClass, ftPnniSummaryStatus=ftPnniSummaryStatus, ifIndexNameGroup=ifIndexNameGroup, pshmemClpThreshold=pshmemClpThreshold, shmem2UcastConnections=shmem2UcastConnections, sigPathCloseTimeout=sigPathCloseTimeout, pathVCIErrors=pathVCIErrors, snmpAgentTable=snmpAgentTable, pnniSpvcSrcCalledVPI=pnniSpvcSrcCalledVPI, q2931AFLookupSrcPort=q2931AFLookupSrcPort, genericOutputPortConfPrio=genericOutputPortConfPrio, asxLinkUp=asxLinkUp, asxDS1PRBSDetected=asxDS1PRBSDetected, pnniSpvcDefaultUbrBandwidth=pnniSpvcDefaultUbrBandwidth, pnniSpvpcSrcCalledAssignedVPI=pnniSpvpcSrcCalledAssignedVPI, asxDS3PLCPYellowDetected=asxDS3PLCPYellowDetected, pShmem2IntentionalLostCells=pShmem2IntentionalLostCells, shmem2ConfTable=shmem2ConfTable, channelShmem3Table=channelShmem3Table, nGenericShmemCustomBCSWeight=nGenericShmemCustomBCSWeight, pnniSpvpcDestUpTime=pnniSpvpcDestUpTime, nShmem2CurrentUcastConnections=nShmem2CurrentUcastConnections, nShmem2VBRPriority=nShmem2VBRPriority, q2931AFTemplateEntry=q2931AFTemplateEntry, asxE1AISCleared=asxE1AISCleared, pnniSpvcDestCallingVCI=pnniSpvcDestCallingVCI, q2931AdminVCI=q2931AdminVCI, tempGroup=tempGroup, envNumberOfTempSensors=envNumberOfTempSensors, serviceCategoryName=serviceCategoryName, upcContractMBS0=upcContractMBS0, asxE1LOSCleared=asxE1LOSCleared, pnniSpvpcSrcTable=pnniSpvpcSrcTable, perCallDbgFilterTemplateId=perCallDbgFilterTemplateId, asxDS3PLCPYellowCleared=asxDS3PLCPYellowCleared, portCardType=portCardType, portShmem3ConfTable=portShmem3ConfTable, portPPPolicingRTVBR=portPPPolicingRTVBR, q2931NPPingStatsAverageDelay=q2931NPPingStatsAverageDelay, spansGroup=spansGroup, q2931AdminUNISide=q2931AdminUNISide, pathMinVCI=pathMinVCI, boardTrafficManagementGroup=boardTrafficManagementGroup, pshmemEfciOnABR=pshmemEfciOnABR, asxDS1LOFCleared=asxDS1LOFCleared, portRemoteIpAddress=portRemoteIpAddress, moduleVersion=moduleVersion, q2931AFTemplateNextIndex=q2931AFTemplateNextIndex, upcContractMCR=upcContractMCR, btmPerPriorityBoard=btmPerPriorityBoard, opathPort=opathPort, asxDS1CRCErrCleared=asxDS1CRCErrCleared, switchCounterReset=switchCounterReset, procUtilsNumMallocPart=procUtilsNumMallocPart, sigPathSpansTransmittedMessages=sigPathSpansTransmittedMessages, q2931UNIConfigVersion=q2931UNIConfigVersion, pnniSpvpcSrcOldRouteCost=pnniSpvpcSrcOldRouteCost, confTopoHelloInterval=confTopoHelloInterval, q2931MaxSvpcVPI=q2931MaxSvpcVPI, vcShmem3OutputVCI=vcShmem3OutputVCI, pShmem3QsizeforVBR=pShmem3QsizeforVBR, pathExtQosMetricMaxCdv=pathExtQosMetricMaxCdv, q2931AdminE164AddressResolution=q2931AdminE164AddressResolution, pShmem3ConfPVCSchedulingVBR=pShmem3ConfPVCSchedulingVBR, portMaxBandwidthIn=portMaxBandwidthIn, q2931AFTemplateDstNsapMask=q2931AFTemplateDstNsapMask, switchCtrlLinkid=switchCtrlLinkid, pnniSpvpcSrcEntry=pnniSpvpcSrcEntry, spvcSrcStatus=spvcSrcStatus, moduleHwMajorRev=moduleHwMajorRev, switchClockCurrentStatus=switchClockCurrentStatus, opathMaxVCI=opathMaxVCI, q2931AFTemplateDstVPI=q2931AFTemplateDstVPI, atmIfConnSchedServCat=atmIfConnSchedServCat, upcContractPCR0=upcContractPCR0, snmpAgentAddressGroup=snmpAgentAddressGroup, pathExtQosMetricMaxClr=pathExtQosMetricMaxClr, pshmemQsizeforVBR=pshmemQsizeforVBR, mbufsFreeAlloc=mbufsFreeAlloc, syslogGroup=syslogGroup, asxSonetLOFCleared=asxSonetLOFCleared, pnniPmpSpvccSrcRootNextPartyIndex=pnniPmpSpvccSrcRootNextPartyIndex, nsapTopoLinkDestPort=nsapTopoLinkDestPort, pnniTdbInconsistentState=pnniTdbInconsistentState, sbprServerAddress3=sbprServerAddress3, asxSonetAtmLCDCleared=asxSonetAtmLCDCleared, upcContractServiceCategory=upcContractServiceCategory, swBoardPolicingAction=swBoardPolicingAction, pathMaxBandwidth=pathMaxBandwidth, revChanrOutputVPI=revChanrOutputVPI, sbprServerRowStatus=sbprServerRowStatus, swAlarmReset=swAlarmReset, portCDVT=portCDVT, pnniSpvcDestTrafficType=pnniSpvcDestTrafficType, asxE3PLCPLOFDetected=asxE3PLCPLOFDetected, portReceivedCells=portReceivedCells, portNumber=portNumber, portOperStatus=portOperStatus, asxUnsupportedNetworkModule=asxUnsupportedNetworkModule, perCallDbgFilterIndex=perCallDbgFilterIndex, asxShmem2OutputQueueCongested=asxShmem2OutputQueueCongested, pnniPmpSpvccDestPartyPort=pnniPmpSpvccDestPartyPort, nsapTopoLinkCbrCapacity=nsapTopoLinkCbrCapacity, pnniPmpSpvccSrcRootPort=pnniPmpSpvccSrcRootPort, moduleState=moduleState, mallocUtilEntry=mallocUtilEntry, sbprServerAddressIndex=sbprServerAddressIndex, portHwBoard=portHwBoard, btPrimaryClockOperStatus=btPrimaryClockOperStatus, connShmem3Group=connShmem3Group, hwPortRxLED=hwPortRxLED, genericOutputPortStatsPrioClp01LostCells=genericOutputPortStatsPrioClp01LostCells, pnniPmpSpvccSrcPartyRetryCount=pnniPmpSpvccSrcPartyRetryCount, portUsedBandwidthIn=portUsedBandwidthIn, revChanrOutputVCI=revChanrOutputVCI, poolConfPMPCalls=poolConfPMPCalls, mcastGroup=mcastGroup, vcShmem2OutputVCI=vcShmem2OutputVCI, asxSonetPathLOPCleared=asxSonetPathLOPCleared, vpciMappingTableGroup=vpciMappingTableGroup, pnniSpvcSrcQosIndex=pnniSpvcSrcQosIndex, asxSwitchLoginFailed=asxSwitchLoginFailed, pnniPmpSpvccDestRootSusceptClip=pnniPmpSpvccDestRootSusceptClip, portOutputCdv=portOutputCdv, dualScpManualSwitchOver=dualScpManualSwitchOver, nShmem2ConfSharedMemory=nShmem2ConfSharedMemory, asxJ2PAISDetected=asxJ2PAISDetected, opathExtRtVbrMetric=opathExtRtVbrMetric, swBoardFingerMode=swBoardFingerMode, pShmem3CLP01LostCells=pShmem3CLP01LostCells, q2931AFLookupIndex=q2931AFLookupIndex, portGroup=portGroup, netmodShmem2Group=netmodShmem2Group, asxSonetLineRDICleared=asxSonetLineRDICleared, asxVPRDIDetected=asxVPRDIDetected, envCpuSlot=envCpuSlot, vpShmem3OutputPort=vpShmem3OutputPort, spvcDestSpvcId=spvcDestSpvcId, asxDS3PLCPLOFCleared=asxDS3PLCPLOFCleared, sigPathPort=sigPathPort, q2931TransmittedMessages=q2931TransmittedMessages, upcContractEntry=upcContractEntry, netmodGenericShmemEntry=netmodGenericShmemEntry, procUtilGroup=procUtilGroup, pnniSpvcParamGroup=pnniSpvcParamGroup, confTopoPGSNReachCostMethod=confTopoPGSNReachCostMethod, nShmem3ConfAltCLP01Threshold=nShmem3ConfAltCLP01Threshold, pathrConnectionType=pathrConnectionType, netmodTimingGroup=netmodTimingGroup, pnniSpvcSrcStatus=pnniSpvcSrcStatus, crConfMemAllocFail=crConfMemAllocFail, q2931NPCallIndex=q2931NPCallIndex, opathStatsCLP0Cells=opathStatsCLP0Cells, hdcompVciLookupErrors=hdcompVciLookupErrors, pShmem2AtmInterfaceIndex=pShmem2AtmInterfaceIndex, numBlocksAlloc=numBlocksAlloc, q2931AdminOperType=q2931AdminOperType, hwPortIfIndex=hwPortIfIndex, pnniSpvcSrcDtlIndex1=pnniSpvcSrcDtlIndex1, chanrOutputVPI=chanrOutputVPI)
mibBuilder.exportSymbols("Fore-Switch-MIB", vcShmem2TransmittedCells=vcShmem2TransmittedCells, cbrctConfEntry=cbrctConfEntry, nShmem3ConfVcCLP01ForCBR=nShmem3ConfVcCLP01ForCBR, envCpuBoardRevision=envCpuBoardRevision, pathExtEntryStatus=pathExtEntryStatus, envNumberOfFanBanks=envNumberOfFanBanks, nsapStaticRouteCost=nsapStaticRouteCost, vpShmem3UnintentionalLostCells=vpShmem3UnintentionalLostCells, envPowerSupplyTable=envPowerSupplyTable, envFanBankIndex=envFanBankIndex, pnniSpvcDestTable=pnniSpvcDestTable, confTopoSwitchPrefix=confTopoSwitchPrefix, asxAtmIfGroup=asxAtmIfGroup, nsapTopoLinkCbrFifo=nsapTopoLinkCbrFifo, perCallDbgFilterTable=perCallDbgFilterTable, pnniPmpSpvccDestRootNumberOfParties=pnniPmpSpvccDestRootNumberOfParties, chanrOutputVCI=chanrOutputVCI, vpGroupTable=vpGroupTable, nShmem2CustomBCSRowStatus=nShmem2CustomBCSRowStatus, asxE1LOSDetected=asxE1LOSDetected, netmodAlarmsEntry=netmodAlarmsEntry, asxDS1YellowCleared=asxDS1YellowCleared, mallocPartId=mallocPartId, vcShmem3CurrentQsize=vcShmem3CurrentQsize, chanUpcContract=chanUpcContract, vpGroupPort=vpGroupPort, asxExtendedModeViolation=asxExtendedModeViolation, pnniPmpSpvccSrcRootRGroupIndex=pnniPmpSpvccSrcRootRGroupIndex, portCardEntry=portCardEntry, asxVPAISCleared=asxVPAISCleared, sigPathCallsRejections=sigPathCallsRejections, pnniSpvcSrcLastChangeTime=pnniSpvcSrcLastChangeTime, asxJ2HBERCleared=asxJ2HBERCleared, portInputSetupErrors=portInputSetupErrors, nshmemCurrentCellsBuffers=nshmemCurrentCellsBuffers, q2931NPCallBearerClass=q2931NPCallBearerClass, pnniPmpSpvcDown=pnniPmpSpvcDown, mbufsIFaddrAlloc=mbufsIFaddrAlloc, genericOutputPortConfEntry=genericOutputPortConfEntry, revChanrInputPort=revChanrInputPort, pnniSpvcSrcCalledAtmAddr=pnniSpvcSrcCalledAtmAddr, portShmem3ConfEntry=portShmem3ConfEntry, chanrSigProtocol=chanrSigProtocol, upcContractIsAAL5=upcContractIsAAL5, asxPsOutputDown=asxPsOutputDown, swAlarmRelayOperMode=swAlarmRelayOperMode, netmodAlarmsTable=netmodAlarmsTable, confTopoStaticUpdateInterval=confTopoStaticUpdateInterval, asxVPAISDetected=asxVPAISDetected, topologyGroup=topologyGroup, portShmem3Group=portShmem3Group, pnniSpvpcSrcCallingPort=pnniSpvpcSrcCallingPort, chanrName=chanrName, confTopoSwitchPrefixMask=confTopoSwitchPrefixMask, pnniSpvpcFail=pnniSpvpcFail, pnniSpvpcDestBckQoSClass=pnniSpvpcDestBckQoSClass, asxNetModuleDown=asxNetModuleDown, pnniSpvpcSrcRowStatus=pnniSpvpcSrcRowStatus, outputPathChannelSchedTable=outputPathChannelSchedTable, asxDS3PbitPerrCleared=asxDS3PbitPerrCleared, boardTrafficManagementPerPriorityEntry=boardTrafficManagementPerPriorityEntry, atmAddress=atmAddress, asxFabricTemperatureRegularTemp=asxFabricTemperatureRegularTemp, switchCallPresOperStatus=switchCallPresOperStatus, etherChipSetDec21440=etherChipSetDec21440, switchDebounceName=switchDebounceName, pnniPmpSpvccDestPartyAssignedVPI=pnniPmpSpvccDestPartyAssignedVPI, pnniSpvcSrcDownReason=pnniSpvcSrcDownReason, sigPathVCI=sigPathVCI, mbufsHtableAlloc=mbufsHtableAlloc, asxDS3LOFDetected=asxDS3LOFDetected, asxQ2931Up=asxQ2931Up, q2931NPPingStatsMaximumDelay=q2931NPPingStatsMaximumDelay, swAlarmMajorCategory=swAlarmMajorCategory, swBoardLinkAge=swBoardLinkAge, swAlarmEntry=swAlarmEntry, q2931CallingPDefaultAddress=q2931CallingPDefaultAddress, pnniPmpSpvccSrcRootSusceptClip=pnniPmpSpvccSrcRootSusceptClip, chanSigProtocol=chanSigProtocol, pnniSpvpcDown=pnniSpvpcDown, portCardState=portCardState, pnniSpvpcSrcLastLocation=pnniSpvpcSrcLastLocation, moduleEntry=moduleEntry, asxE3AISDetected=asxE3AISDetected, envPowerSupplyVersion=envPowerSupplyVersion, pathNumChannels=pathNumChannels, q2931ILMIAdminStatus=q2931ILMIAdminStatus, pShmem3Board=pShmem3Board, mbufsSoNameAlloc=mbufsSoNameAlloc, q2931AFLookupTable=q2931AFLookupTable, sigPathSigReservedBW=sigPathSigReservedBW, pathrOutputVPI=pathrOutputVPI, q2931AFFilterTListIndex=q2931AFFilterTListIndex, vmtVpciMapStatus=vmtVpciMapStatus, asxDS1LOFDetected=asxDS1LOFDetected, q2931AFFilterIndex=q2931AFFilterIndex, q2931AFAccepts=q2931AFAccepts, swBoardMaxPaths=swBoardMaxPaths, netmodStatus=netmodStatus, switchPolicingAction=switchPolicingAction, vcShmem3CLP01LostCells=vcShmem3CLP01LostCells, hwPortSpeed=hwPortSpeed, genericOutputPortConfPrioClp1Threshold=genericOutputPortConfPrioClp1Threshold, ntModule=ntModule, pnniPmpSpvccSrcPartyAtmAddr=pnniPmpSpvccSrcPartyAtmAddr, pnniSpvcSrcName=pnniSpvcSrcName, netmodGenericShmemCustomBCSEntry=netmodGenericShmemCustomBCSEntry, shmem=shmem, fabricLvl3Lookup=fabricLvl3Lookup, atmIfConnSchedTable=atmIfConnSchedTable, ntExportClockOperStatus=ntExportClockOperStatus, portOutputDelayMode=portOutputDelayMode, q2931NSAPPingGroup=q2931NSAPPingGroup, moduleNumber=moduleNumber, nShmem3Module=nShmem3Module, pShmem3QsizeforABR=pShmem3QsizeforABR, q2931AFLookupNSAPFilterIndex=q2931AFLookupNSAPFilterIndex, cbrctIdleMask=cbrctIdleMask, pnniSpvxcRGroupAutoPVCSwitchover=pnniSpvxcRGroupAutoPVCSwitchover, serviceCategoryIndex=serviceCategoryIndex, trapDestTable=trapDestTable, upcContractDoGCRAPolicing=upcContractDoGCRAPolicing, pathSetupErrors=pathSetupErrors, opathNrtVbrBufferOverb=opathNrtVbrBufferOverb, pnniSpvpcTrapMode=pnniSpvpcTrapMode, asxE3TrailChangeDetected=asxE3TrailChangeDetected, chanrOutputPort=chanrOutputPort, ftPnniDTLPort=ftPnniDTLPort, vpShmem3CLP0TxCells=vpShmem3CLP0TxCells, opathChannelSchedPort=opathChannelSchedPort, dualScpRedundancyState=dualScpRedundancyState, asxDS1PLCPYellowDetected=asxDS1PLCPYellowDetected, obufName=obufName, portRtVbrOverbooking=portRtVbrOverbooking, q2931AFLookupSrcNsap=q2931AFLookupSrcNsap, q2931AdminMaxVCI=q2931AdminMaxVCI, ifIndexMapTable=ifIndexMapTable, nshmemCurrentVpiVciLists=nshmemCurrentVpiVciLists, q2931SubaddressingAdminStatus=q2931SubaddressingAdminStatus, switchPrimaryClockPort=switchPrimaryClockPort, chanVCI=chanVCI, asxSonetPathAISCleared=asxSonetPathAISCleared, pnniPmpSpvccSrcPartyAutoDtlStatus=pnniPmpSpvccSrcPartyAutoDtlStatus, q2931AdminPort=q2931AdminPort, nGenericShmemMaxMcastConnections=nGenericShmemMaxMcastConnections, opathUptime=opathUptime, pnniSpvpcSrcRGroupIndex=pnniSpvpcSrcRGroupIndex, nsapTopoLinkDestMask=nsapTopoLinkDestMask, nsapTopoBoard=nsapTopoBoard, pshmemBoard=pshmemBoard, netmodSlot=netmodSlot, asxE1LOFCleared=asxE1LOFCleared, swAlarmStatus=swAlarmStatus, vpShmem3TransmittedPackets=vpShmem3TransmittedPackets, pnniPmpSpvccSrcPartyDownReason=pnniPmpSpvccSrcPartyDownReason, asxE1PLCPLOFCleared=asxE1PLCPLOFCleared, portShmem3Table=portShmem3Table, pathNumOutputs=pathNumOutputs, pathrServCat=pathrServCat, pathExtQosMetricMaxCtd=pathExtQosMetricMaxCtd, portAAL5PacketDiscardNRTVBR=portAAL5PacketDiscardNRTVBR, genericOutputPortGroup=genericOutputPortGroup, nshmemConfSharedMemory=nshmemConfSharedMemory, sbprServerMaxHops=sbprServerMaxHops, portManagementStatus=portManagementStatus, pShmemAtmInterfaceIndex=pShmemAtmInterfaceIndex, asxPsOutputUp=asxPsOutputUp, genericOutputPortStatsPrioName=genericOutputPortStatsPrioName, pshmemMaxCDVforVBR=pshmemMaxCDVforVBR, revChanrOutputPort=revChanrOutputPort, swAlarmCriticalCategory=swAlarmCriticalCategory, sbprServerAddressIndexName=sbprServerAddressIndexName, proxyDirMapStatus=proxyDirMapStatus, pShmem2ClpThreshold=pShmem2ClpThreshold, spvcSrcUpTime=spvcSrcUpTime, pShmem2ClpThreshforCBR=pShmem2ClpThreshforCBR, switchPrimaryClock=switchPrimaryClock, envTempSensorIndex=envTempSensorIndex, q2931AdminMinVCI=q2931AdminMinVCI, nShmem2ConfEfciOff=nShmem2ConfEfciOff, sigPathStatsPort=sigPathStatsPort, pShmem3ConfAltCLPConfigCBR=pShmem3ConfAltCLPConfigCBR, pnniPmpSpvccSrcRootPriority=pnniPmpSpvccSrcRootPriority, portPriorityShmem2ConfTable=portPriorityShmem2ConfTable, pnniSpvcSrcRGroupIndex=pnniSpvcSrcRGroupIndex, pnniSpvcDestAssignedVCI=pnniSpvcDestAssignedVCI, perCallDbgFilterMatches=perCallDbgFilterMatches, envFanBankState=envFanBankState, q2931StatsTable=q2931StatsTable, guardGroup=guardGroup, pnniPmpSpvccSrcRootSecondaryVCI=pnniPmpSpvccSrcRootSecondaryVCI, netmodShmem2Table=netmodShmem2Table, nsapNetworkPrefixTable=nsapNetworkPrefixTable, perCallDbgFilterName=perCallDbgFilterName, pnniPmpSpvccDestRootAtmAddr=pnniPmpSpvccDestRootAtmAddr, dualScpResetStandbyScp=dualScpResetStandbyScp, asxE1AtmLCDDetected=asxE1AtmLCDDetected, asxPsCurrentDown=asxPsCurrentDown, sigPathOpenTimeout=sigPathOpenTimeout, pnniSpvcSrcActiveDtlNodeIndex=pnniSpvcSrcActiveDtlNodeIndex, ifIndexMapBoard=ifIndexMapBoard, netmodShmem3Entry=netmodShmem3Entry, pnniSpvcSrcSecondaryVPI=pnniSpvcSrcSecondaryVPI, sigPathType=sigPathType, syslogDestinationTable=syslogDestinationTable, hwPortOperStatus=hwPortOperStatus, pShmem3CurrentQsize=pShmem3CurrentQsize, portNrtVbrOverbooking=portNrtVbrOverbooking, q2931AFFilterStatus=q2931AFFilterStatus, pnniSpvpcDestSusceptClip=pnniSpvpcDestSusceptClip, pnniSpvpcSrcRouteCost=pnniSpvpcSrcRouteCost, btmPerPriorityValue=btmPerPriorityValue, pShmem3Clp1ThreshforCBR=pShmem3Clp1ThreshforCBR, genericOutputPortStatsPrioClp1LostCells=genericOutputPortStatsPrioClp1LostCells, q2931VCIRangeStatus=q2931VCIRangeStatus, pShmem2LostCells=pShmem2LostCells, swAlarmType=swAlarmType, pnniSpvcSrcEntryStatus=pnniSpvcSrcEntryStatus, q2931AdminOutgoingNSAPFilterIndex=q2931AdminOutgoingNSAPFilterIndex, pathShmem3Entry=pathShmem3Entry, vcShmem3OutputVPI=vcShmem3OutputVPI, pnniPmpSpvccSrcPartyFtDtlIndex=pnniPmpSpvccSrcPartyFtDtlIndex, dualScpSVXCPStateSyncPercent=dualScpSVXCPStateSyncPercent, opathRtVbrOverbooking=opathRtVbrOverbooking, pnniSpvpcSrcBckQoSClass=pnniSpvpcSrcBckQoSClass, pathRouteEntry=pathRouteEntry, q2931AFLastFailureSrcVPI=q2931AFLastFailureSrcVPI, opathExtCbrMetric=opathExtCbrMetric, mbufsSocketAlloc=mbufsSocketAlloc, pShmem3QsizeforCBR=pShmem3QsizeforCBR, vmtVpciMapTable=vmtVpciMapTable, asxSonetLineRDIDetected=asxSonetLineRDIDetected, dualScpSVXCPdroppedCallCount=dualScpSVXCPdroppedCallCount, q2931NPCallQosIndex=q2931NPCallQosIndex, syslogDestinationEntry=syslogDestinationEntry, qosClassFwdClr=qosClassFwdClr, hwPortNumber=hwPortNumber, pathExtUbrMetric=pathExtUbrMetric, pnniSpvpcDestRGroupIndex=pnniSpvpcDestRGroupIndex, envFabricIndex=envFabricIndex, netmodGenericShmemGroup=netmodGenericShmemGroup, chanQosIsAAL5=chanQosIsAAL5, opathCACErrors=opathCACErrors, opathStatsTransmittedCells=opathStatsTransmittedCells, pnniSpvcDestBearerClass=pnniSpvcDestBearerClass, hdcompTable=hdcompTable, q2931NPPingPktCount=q2931NPPingPktCount, ntGlobalClock=ntGlobalClock, nShmem3ConfAltCLP1Threshold=nShmem3ConfAltCLP1Threshold, chanRejectedCells=chanRejectedCells, asxSonetPathLOPDetected=asxSonetPathLOPDetected, obufType=obufType, moduleCLEI=moduleCLEI, nShmem2Module=nShmem2Module)
mibBuilder.exportSymbols("Fore-Switch-MIB", pnniSpvpcSrcFwdUpcKey=pnniSpvpcSrcFwdUpcKey, envFanBanksEntry=envFanBanksEntry, pShmem3ConfBoard=pShmem3ConfBoard, netmodSlotPriority=netmodSlotPriority, syncStatusMsgGroup=syncStatusMsgGroup, confTopoPeerGroupMask=confTopoPeerGroupMask, portAISRDIGeneration=portAISRDIGeneration, upcContractMBS01=upcContractMBS01, cbrctIdleIntPeriod=cbrctIdleIntPeriod, sigPathClsUpcContract=sigPathClsUpcContract, procUtilMinLoadLastUpdate=procUtilMinLoadLastUpdate, opathExtUbrMetric=opathExtUbrMetric, swBoardCDV=swBoardCDV, q2931AFLastFailureTemplateIndex=q2931AFLastFailureTemplateIndex, linkAge=linkAge, pnniPmpSpvccSrcPartyAssignedVCI=pnniPmpSpvccSrcPartyAssignedVCI, portCounterReset=portCounterReset, pnniSpvcSrcTrafficType=pnniSpvcSrcTrafficType, envFabricTable=envFabricTable, ifIndexMapNetmod=ifIndexMapNetmod, pnniSpvcSrcDtlIndex4=pnniSpvcSrcDtlIndex4, upcContractPCR=upcContractPCR, appModuleStatusText=appModuleStatusText, vpShmem3CLP1LostCells=vpShmem3CLP1LostCells, genericOutputPortStatsPrioEpdPpdLostCells=genericOutputPortStatsPrioEpdPpdLostCells, q2931AFFilterName=q2931AFFilterName, dualScpCdbSyncMode=dualScpCdbSyncMode, pnniSpvpcSrcStatus=pnniSpvpcSrcStatus, vpShmem2UnintentionalLostCells=vpShmem2UnintentionalLostCells, sigPathVCCs=sigPathVCCs, asxE3AtmLCDCleared=asxE3AtmLCDCleared, sigPathCDV=sigPathCDV, swBoardLinkCapacity=swBoardLinkCapacity, pnniSpvcDestCalledAtmAddr=pnniSpvcDestCalledAtmAddr, pnniPmpSpvccSrcRootNumberOfParties=pnniPmpSpvccSrcRootNumberOfParties, E164Address=E164Address, sigPathStatsEntry=sigPathStatsEntry, pshmemEfciOffABR=pshmemEfciOffABR, nGenericShmemSubindex=nGenericShmemSubindex, nGenericShmemCurrentConnections=nGenericShmemCurrentConnections, asxSonetPathAISDetected=asxSonetPathAISDetected, cesExtTable=cesExtTable, hwPortModule=hwPortModule, pnniSpvcDestEntry=pnniSpvcDestEntry, portOutputSetupErrors=portOutputSetupErrors, envMgmtBoardRevision=envMgmtBoardRevision, proxyDirMapAESA=proxyDirMapAESA, qosClassName=qosClassName, boardHDCOMPAsicVersion=boardHDCOMPAsicVersion, genericOutputPortStatsAtmif=genericOutputPortStatsAtmif, pnniPmpSpvccSrcPartyRerouteStatus=pnniPmpSpvccSrcPartyRerouteStatus, pnniPmpSpvccDestRootVCI=pnniPmpSpvccDestRootVCI, q2931NPCallClientType=q2931NPCallClientType, pathrUpcContract=pathrUpcContract, pnniSpvcSrcNumberOfSPVCs=pnniSpvcSrcNumberOfSPVCs, envCpuBoard=envCpuBoard, pnniPmpSpvccDestRootBearerClass=pnniPmpSpvccDestRootBearerClass, pnniPmpSpvccDestRootTable=pnniPmpSpvccDestRootTable, spvcSrcSwitchAddr=spvcSrcSwitchAddr, pathEntry=pathEntry, portInputCdv=portInputCdv, q2931ConnectedPAddressPresentation=q2931ConnectedPAddressPresentation, upcContractUseAltCLPThreshold=upcContractUseAltCLPThreshold, mbufsDataFreeAlloc=mbufsDataFreeAlloc, opathLoopVPI=opathLoopVPI, pnniPmpSpvccDestRootFwdQoSClass=pnniPmpSpvccDestRootFwdQoSClass, pnniPmpSpvccSrcPartyName=pnniPmpSpvccSrcPartyName, crConfMemoryOflow=crConfMemoryOflow, upcContractTable=upcContractTable, boardTimingTable=boardTimingTable, dualScpConfEntry=dualScpConfEntry, q2931Group=q2931Group, nsapTopologyTable=nsapTopologyTable, vcShmem3CLP0TxCells=vcShmem3CLP0TxCells, vpShmem2TransmittedCells=vpShmem2TransmittedCells, pnniSpvcTrapMode=pnniSpvcTrapMode, pShmem3ConfModule=pShmem3ConfModule, qosClassExpansionEntryStatus=qosClassExpansionEntryStatus, hwPortCounterReset=hwPortCounterReset, hdcompAsicVersion=hdcompAsicVersion, asxDS3LOSDetected=asxDS3LOSDetected, boardStatsIndex=boardStatsIndex, shmem2ConfName=shmem2ConfName, nShmem2Board=nShmem2Board, asxPsCurrentUp=asxPsCurrentUp, sigPathSpansReceivedMessages=sigPathSpansReceivedMessages, q2931SSCOPNoRespTimer=q2931SSCOPNoRespTimer, pnniSpvcSrcDtlWeight1=pnniSpvcSrcDtlWeight1, asxE1PLCPYellowDetected=asxE1PLCPYellowDetected, dualScpSVXCPStateTransferFailed=dualScpSVXCPStateTransferFailed, q2931NPCallStatus=q2931NPCallStatus, portInputCACErrors=portInputCACErrors, asxNonextendedModeWarning=asxNonextendedModeWarning, portTime=portTime, boardTable=boardTable, hwPortOverflows=hwPortOverflows, portILMIRemoteIpAddress=portILMIRemoteIpAddress, pnniSpvpcSrcCalledVPVCSel=pnniSpvpcSrcCalledVPVCSel, asxE1AtmLCDCleared=asxE1AtmLCDCleared, nShmem3ConfVcCLP1ForCBR=nShmem3ConfVcCLP1ForCBR, pnniSpvpcRerouteThreshold=pnniSpvpcRerouteThreshold, spvcSrcTable=spvcSrcTable, vcShmem2OutputVPI=vcShmem2OutputVPI, q2931NPCallNextIndex=q2931NPCallNextIndex, nsapStaticRouteMask=nsapStaticRouteMask, powerGroup=powerGroup, moduleUptime=moduleUptime, revChanrInputVPI=revChanrInputVPI, pnniPmpSpvccDestNumberOfSpvccs=pnniPmpSpvccDestNumberOfSpvccs, poolConfMaxPercentage=poolConfMaxPercentage, chanPolicingAction=chanPolicingAction, spvcSrcDestSwitchAddr=spvcSrcDestSwitchAddr, AAL5CountingMode=AAL5CountingMode, perCallDbgFilterEntry=perCallDbgFilterEntry, pshmemDedicatedQsize=pshmemDedicatedQsize, opathRejectedCells=opathRejectedCells, pnniSpvcDestCallingVPI=pnniSpvcDestCallingVPI, pnniSpvcDestFwdQoSClass=pnniSpvcDestFwdQoSClass, pnniSpvxcRGroupIndex=pnniSpvxcRGroupIndex, nshmemBoard=nshmemBoard, boardMcastSpaceIndex=boardMcastSpaceIndex, opathExtNrtVbrMetric=opathExtNrtVbrMetric, syslogDestinationStatus=syslogDestinationStatus, hdcompDescr=hdcompDescr, pathExtGroup=pathExtGroup, boardGroup=boardGroup, pnniSpvcSrcSecondaryVCI=pnniSpvcSrcSecondaryVCI, switchClockOperStatus=switchClockOperStatus, asxSpansDown=asxSpansDown, opathSchedMode=opathSchedMode, q2931NPCallQosClassBwd=q2931NPCallQosClassBwd, sigPathAdminStatus=sigPathAdminStatus, qosClassBackCdv=qosClassBackCdv, ifIndexMapEntry=ifIndexMapEntry, btSecondaryClock=btSecondaryClock, outputPathChannelSchedEntry=outputPathChannelSchedEntry, nGenericShmemCurrentMcastConnections=nGenericShmemCurrentMcastConnections, oamGeneratingPathrTable=oamGeneratingPathrTable, nShmem3CurrentCellsBuffers=nShmem3CurrentCellsBuffers, upcContractGroup=upcContractGroup, shmem3Counters=shmem3Counters, nShmem3CurrentVpiVciLists=nShmem3CurrentVpiVciLists, spvcSrcAllocBandwidth=spvcSrcAllocBandwidth, portUBRTagging=portUBRTagging, spvcDestOutPort=spvcDestOutPort, pnniSpvpcDestTable=pnniSpvpcDestTable, asxPs5VoltUp=asxPs5VoltUp, vpShmem3OutputVPI=vpShmem3OutputVPI, pShmem3QsizeforUBR=pShmem3QsizeforUBR, appModuleEntry=appModuleEntry, pnniSpvcSrcTable=pnniSpvcSrcTable, asxDualScpSwitchOver=asxDualScpSwitchOver, appModuleBootSoftwareVersion=appModuleBootSoftwareVersion, portAAL5PacketDiscardUBR=portAAL5PacketDiscardUBR, pnniPmpSpvccSrcNumberOfSpvccs=pnniPmpSpvccSrcNumberOfSpvccs, nsapTopologyEntry=nsapTopologyEntry, snmpColdStart=snmpColdStart, perCallDbgFilterFlavor=perCallDbgFilterFlavor, q2931AFFilterTListTemplateIndex=q2931AFFilterTListTemplateIndex, pnniSpvcSrcRerouteStatus=pnniSpvcSrcRerouteStatus, q2931ClearOnCarrierLoss=q2931ClearOnCarrierLoss, nGenericShmemCustomBCSValue=nGenericShmemCustomBCSValue, pathrCells=pathrCells, q2931NPPingStatsPktsSent=q2931NPPingStatsPktsSent, utilization=utilization, spvcDestSwitchAddr=spvcDestSwitchAddr, pshmemClpThreshforCBR=pshmemClpThreshforCBR, dualScpSyncState=dualScpSyncState, nShmem3ConfEfciOn=nShmem3ConfEfciOn, ochanStatsCLP0Cells=ochanStatsCLP0Cells, pnniSpvcSrcAutoDtlStatus=pnniSpvcSrcAutoDtlStatus, swBoardLinkIndex=swBoardLinkIndex, asxSonetAtmLCDDetected=asxSonetAtmLCDDetected, pnniPmpSpvccSrcPartyStatus=pnniPmpSpvccSrcPartyStatus, opathExtAbrMetric=opathExtAbrMetric, asxDS3FERFCleared=asxDS3FERFCleared, hwPortTxLED=hwPortTxLED, shmemConfName=shmemConfName, outputPathTable=outputPathTable, AtmOrigPathSchedMode=AtmOrigPathSchedMode, envPowerSupply5VoltState=envPowerSupply5VoltState, chanrInputVPI=chanrInputVPI, envCpuType=envCpuType, q2931AdminrtvbrCalls=q2931AdminrtvbrCalls, nsapStaticRouteMaxVbrCap=nsapStaticRouteMaxVbrCap, qosClassBackClr=qosClassBackClr, q2931AdminVPI=q2931AdminVPI, asxAtmIfName=asxAtmIfName, q2931AFLastFailureDstPort=q2931AFLastFailureDstPort, pshmemModule=pshmemModule, pnniSpvxRGroupSwover=pnniSpvxRGroupSwover, opathMaxBandwidth=opathMaxBandwidth, proxyDirMapEntryGroup=proxyDirMapEntryGroup, btmPerPriorityPriority=btmPerPriorityPriority, q2931NPCallTable=q2931NPCallTable, pnniSpvxcRGroupRowStatus=pnniSpvxcRGroupRowStatus, nshmemAssertXACPT=nshmemAssertXACPT, chanrInputVCI=chanrInputVCI, swBoardIndex=swBoardIndex, nGenericShmemCustomBCSModule=nGenericShmemCustomBCSModule, chanStatus=chanStatus, pnniSpvcSrcCallingVPI=pnniSpvcSrcCallingVPI, trapConfGroup=trapConfGroup, opathMaxChannels=opathMaxChannels, q2931NPCallQosClassFwd=q2931NPCallQosClassFwd, portShmem2ConfEntry=portShmem2ConfEntry, pnniTdbGuardbandResrvFail=pnniTdbGuardbandResrvFail, asxVPRDICleared=asxVPRDICleared, pnniSpvcLowestPriority=pnniSpvcLowestPriority, ochanStatsTransmittedPackets=ochanStatsTransmittedPackets, opathChannelSchedSchedOverride=opathChannelSchedSchedOverride, asxSVXCPStateTransferRestarted=asxSVXCPStateTransferRestarted, vmtVpciMapIndex=vmtVpciMapIndex, pnniSpvpcSrcLastFailCause=pnniSpvpcSrcLastFailCause, pnniSpvcSrcCallingDomain=pnniSpvcSrcCallingDomain, pnniPmpSpvccDestPartyStatus=pnniPmpSpvccDestPartyStatus, asxDS1YellowDetected=asxDS1YellowDetected, vpGroupVPCI=vpGroupVPCI, asxDS1PRBSCleared=asxDS1PRBSCleared, pathRouteTable=pathRouteTable, obufBoard=obufBoard, nShmem3CellMemorySize=nShmem3CellMemorySize, genericPortGroupConfEntry=genericPortGroupConfEntry, asxSonetLineAISCleared=asxSonetLineAISCleared, q2931AdminAALType=q2931AdminAALType, portCardFlavor=portCardFlavor, nsapStaticRouteTable=nsapStaticRouteTable, asxFabricUp=asxFabricUp, pnniSpvpcSrcCalledAtmAddr=pnniSpvpcSrcCalledAtmAddr, sigPathClsVCI=sigPathClsVCI, nshmemMemorySize=nshmemMemorySize, mbufsRightsAlloc=mbufsRightsAlloc, poolGroup=poolGroup, atmIfConnSchedEntry=atmIfConnSchedEntry, appModuleApplicationType=appModuleApplicationType, timing=timing, chanQosCDVT=chanQosCDVT, softwareLicenseKey=softwareLicenseKey, pnniPmpSpvccSrcPartyVPVCSel=pnniPmpSpvccSrcPartyVPVCSel, q2931ProxyDirGroupIndex=q2931ProxyDirGroupIndex, nShmem3ConfRow=nShmem3ConfRow, oamGeneratingPathrCells=oamGeneratingPathrCells, spvcDestNumberOfSPVCs=spvcDestNumberOfSPVCs, connShmem2Group=connShmem2Group, swAlarmRelayFunction=swAlarmRelayFunction, envCpuIDESize=envCpuIDESize, swBoardGroup=swBoardGroup, sigPathAALOperType=sigPathAALOperType, cbrctNoOfIdlePatterns=cbrctNoOfIdlePatterns, pathCells=pathCells, asxTempSensorRegularTemp=asxTempSensorRegularTemp, switchDebounceEntry=switchDebounceEntry, chanQosPoliceState=chanQosPoliceState, sigPathTable=sigPathTable)
mibBuilder.exportSymbols("Fore-Switch-MIB", appModuleSoftwareVersion=appModuleSoftwareVersion, pnniSpvcSrcSusceptClip=pnniSpvcSrcSusceptClip, upcContractAAL5CountingMode=upcContractAAL5CountingMode, portAAL5PacketDiscardCBR=portAAL5PacketDiscardCBR, pShmem2ConfModule=pShmem2ConfModule, pnniSpvpcSrcCalledVPI=pnniSpvpcSrcCalledVPI, q2931MaxSvccVPI=q2931MaxSvccVPI, pnniPmpSpvccDestPartyEntry=pnniPmpSpvccDestPartyEntry, oamGeneratingPathrEntry=oamGeneratingPathrEntry, obufOperStatus=obufOperStatus, dualScpState=dualScpState, pathrStatus=pathrStatus, pnniPmpSpvcPartyPaceNum=pnniPmpSpvcPartyPaceNum, confTopologyGroup=confTopologyGroup, q2931AdminRemoteIpAddress=q2931AdminRemoteIpAddress, switchTimingMode=switchTimingMode, ntPrimaryExportClock=ntPrimaryExportClock, cpuGroup=cpuGroup, q2931AFLastFailureDstNsap=q2931AFLastFailureDstNsap, switchSbprServerAddressEntry=switchSbprServerAddressEntry, moduleName=moduleName, q2931NPCallCallingDomain=q2931NPCallCallingDomain, fabricGroup=fabricGroup, portShmem3Entry=portShmem3Entry, pathGroup=pathGroup, nGenericShmemCustomBCSSubindex=nGenericShmemCustomBCSSubindex, q2931AFLastFailureDstVPI=q2931AFLastFailureDstVPI, pathUsedBandwidth=pathUsedBandwidth, swBoardAtmAddress=swBoardAtmAddress, boardControlPort=boardControlPort, btmPerPriorityPriorityName=btmPerPriorityPriorityName, pnniSpvpcBackoffInterval=pnniSpvpcBackoffInterval, pShmem3TxCells=pShmem3TxCells, pathExtNrtVbrMetric=pathExtNrtVbrMetric, numBlocksFree=numBlocksFree, pnniSpvcSrcFwdUpcKey=pnniSpvcSrcFwdUpcKey, pnniPmpSpvccDestRootEntry=pnniPmpSpvccDestRootEntry, pnniPmpSpvccSrcRootRowStatus=pnniPmpSpvccSrcRootRowStatus, q2931ILMIRegistration=q2931ILMIRegistration, q2931AFRejectKnown=q2931AFRejectKnown, portGCRAPolicingRTVBR=portGCRAPolicingRTVBR, vmtVpciMapListMEIndex=vmtVpciMapListMEIndex, portCardSerialNumber=portCardSerialNumber, uptime=uptime, sbprServerAddress5=sbprServerAddress5, pShmem2ClpThreshforABR=pShmem2ClpThreshforABR, pnniPmpSpvccSrcRootFwdUpcKey=pnniPmpSpvccSrcRootFwdUpcKey, nGenericShmemBoard=nGenericShmemBoard, nShmem3CurrentUcastConnections=nShmem3CurrentUcastConnections, upcContractBehaviorClassSelector=upcContractBehaviorClassSelector, pnniSpvcSrcCallingPort=pnniSpvcSrcCallingPort, appModuleOperState=appModuleOperState, shmem3UcastConnections=shmem3UcastConnections, nShmem2ConfRow=nShmem2ConfRow, pnniSpvcPaceNumSpvcs=pnniSpvcPaceNumSpvcs, opathVCIErrors=opathVCIErrors, shmem3CellMemorySize=shmem3CellMemorySize, pnniPmpSpvccDestPartyUpTime=pnniPmpSpvccDestPartyUpTime, maxChannels=maxChannels, pshmemQsizeforCBR=pshmemQsizeforCBR, pnniPmpSpvccSrcRootBearerClass=pnniPmpSpvccSrcRootBearerClass, nShmem2ConfAal5PacketDrop=nShmem2ConfAal5PacketDrop, envNumberOfCPUs=envNumberOfCPUs, pnniSpvpcSrcActiveDtlNodeIndex=pnniSpvpcSrcActiveDtlNodeIndex, portAAL5PacketDiscardRTVBR=portAAL5PacketDiscardRTVBR, pShmem2QsizeforVBR=pShmem2QsizeforVBR, procUtilLastUpdate=procUtilLastUpdate, q2931AdminAVPresentation=q2931AdminAVPresentation, moduleTestStatusText=moduleTestStatusText, asxDS3IdleCleared=asxDS3IdleCleared, envCpuCLEI=envCpuCLEI, asxOutputQueueCongested=asxOutputQueueCongested, cbrctConfTable=cbrctConfTable, shmem2CellMemorySize=shmem2CellMemorySize, opathCells=opathCells, outputChannelStatsTable=outputChannelStatsTable, nsapStaticRouteStatus=nsapStaticRouteStatus)

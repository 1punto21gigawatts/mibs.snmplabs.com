#
# PySNMP MIB module DEVFILTER-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/DEVFILTER-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:41:54 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
device, = mibBuilder.importSymbols("ANIROOT-MIB", "device")
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ValueSizeConstraint, ConstraintsIntersection, ValueRangeConstraint, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ValueSizeConstraint", "ConstraintsIntersection", "ValueRangeConstraint", "SingleValueConstraint")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
ModuleIdentity, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, NotificationType, TimeTicks, Counter32, Unsigned32, ObjectIdentity, Counter64, Gauge32, Bits, IpAddress, Integer32, iso = mibBuilder.importSymbols("SNMPv2-SMI", "ModuleIdentity", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "NotificationType", "TimeTicks", "Counter32", "Unsigned32", "ObjectIdentity", "Counter64", "Gauge32", "Bits", "IpAddress", "Integer32", "iso")
MacAddress, TextualConvention, RowStatus, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "MacAddress", "TextualConvention", "RowStatus", "DisplayString")
aniDevFilter = ModuleIdentity((1, 3, 6, 1, 4, 1, 4325, 2, 8))
if mibBuilder.loadTexts: aniDevFilter.setLastUpdated('0105091130Z')
if mibBuilder.loadTexts: aniDevFilter.setOrganization('Aperto Networks')
if mibBuilder.loadTexts: aniDevFilter.setContactInfo(' Postal: Aperto Networks Inc 1637 S Main Street Milpitas, California 95035 Tel: +1 408 719 9977 ')
if mibBuilder.loadTexts: aniDevFilter.setDescription('This group provides Filter related information for BSU or SU. ')
aniDevFilterTable = MibTable((1, 3, 6, 1, 4, 1, 4325, 2, 8, 1), )
if mibBuilder.loadTexts: aniDevFilterTable.setStatus('current')
if mibBuilder.loadTexts: aniDevFilterTable.setDescription('This table allows the user to view the configured IP Filters. ')
aniDevFilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4325, 2, 8, 1, 1), ).setIndexNames((0, "DEVFILTER-MIB", "aniDevFilterIfIndex"), (0, "DEVFILTER-MIB", "aniDevFilterIdentifier"))
if mibBuilder.loadTexts: aniDevFilterEntry.setStatus('current')
if mibBuilder.loadTexts: aniDevFilterEntry.setDescription('An entry containing objects for each IP Filter configured. ')
aniDevFilterIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 4325, 2, 8, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("ethernet", 1), ("wireless-port1", 2), ("wireless-port2", 3), ("wireless-port3", 4), ("wireless-port4", 5), ("wireless-port5", 6), ("wireless-port6", 7))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aniDevFilterIfIndex.setStatus('current')
if mibBuilder.loadTexts: aniDevFilterIfIndex.setDescription('The Interface Type. On SU, only ethernet(1) and wireless-port1(2) are valid. On BSU, ethernet(1) and all configured wireless interfaces -- wireless-port1(2), wireless-port2(3), wireless-port3(4), wireless-port4(5), wireless-port5(6), wireless-port6(7) are valid, that is, filtering should be allowed on these wireless interfaces only if they are configured. ')
aniDevFilterIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 4325, 2, 8, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aniDevFilterIdentifier.setStatus('current')
if mibBuilder.loadTexts: aniDevFilterIdentifier.setDescription('A unique number which identifies the filtering rule. ')
aniDevFilterName = MibTableColumn((1, 3, 6, 1, 4, 1, 4325, 2, 8, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aniDevFilterName.setStatus('current')
if mibBuilder.loadTexts: aniDevFilterName.setDescription('A name which identifies the filtering rule. ')
aniDevFilterPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 4325, 2, 8, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aniDevFilterPriority.setStatus('current')
if mibBuilder.loadTexts: aniDevFilterPriority.setDescription('The priority for the filtering rule. It should be unique. A higher number means higher priority. ')
aniDevFilterActivationState = MibTableColumn((1, 3, 6, 1, 4, 1, 4325, 2, 8, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("inactive", 1), ("active", 2))).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aniDevFilterActivationState.setStatus('current')
if mibBuilder.loadTexts: aniDevFilterActivationState.setDescription('The state of the filtering rule. ')
aniDevFilterPermission = MibTableColumn((1, 3, 6, 1, 4, 1, 4325, 2, 8, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("block", 1), ("pass", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aniDevFilterPermission.setStatus('current')
if mibBuilder.loadTexts: aniDevFilterPermission.setDescription('The permissions for the filtering rule. ')
aniDevFilterIpProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 4325, 2, 8, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 257))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aniDevFilterIpProtocol.setStatus('current')
if mibBuilder.loadTexts: aniDevFilterIpProtocol.setDescription('The IP protocol value. List of well known IP Protocols: Protocol Value -------- ----- ICMP 1 IGMP 2 TCP 6 EGP 8 UDP 17 IPIP 94 RSVP 46 GRE 47 TCP or UDP 257 Apart from the above protocols, the user can also specify other values. ')
aniDevFilterIpSaddr = MibTableColumn((1, 3, 6, 1, 4, 1, 4325, 2, 8, 1, 1, 8), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aniDevFilterIpSaddr.setStatus('current')
if mibBuilder.loadTexts: aniDevFilterIpSaddr.setDescription('The source IP address for this Filter. IP Source Address and Subnet Mask go in a pair. So if aniDevFilterIpSaddr is configured, then aniDevFilterIpSmask should be configured as well and vice versa. ')
aniDevFilterIpSmask = MibTableColumn((1, 3, 6, 1, 4, 1, 4325, 2, 8, 1, 1, 9), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aniDevFilterIpSmask.setStatus('current')
if mibBuilder.loadTexts: aniDevFilterIpSmask.setDescription('The Subnet mask for the source IP Address. IP Source Address and Subnet Mask go in a pair. So if aniDevFilterIpSaddr is configured, then aniDevFilterIpSmask should be configured as well and vice versa. ')
aniDevFilterIpDaddr = MibTableColumn((1, 3, 6, 1, 4, 1, 4325, 2, 8, 1, 1, 10), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aniDevFilterIpDaddr.setStatus('current')
if mibBuilder.loadTexts: aniDevFilterIpDaddr.setDescription('The destination IP address for this Filter. IP Destination Address and Subnet Mask go in a pair. So if aniDevFilterIpDaddr is configured, then aniDevFilterIpDmask should be configured as well and vice versa. ')
aniDevFilterIpDmask = MibTableColumn((1, 3, 6, 1, 4, 1, 4325, 2, 8, 1, 1, 11), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aniDevFilterIpDmask.setStatus('current')
if mibBuilder.loadTexts: aniDevFilterIpDmask.setDescription('The Subnet mask for the destination IP Address. IP Destination Address and Subnet Mask go in a pair. So if aniDevFilterIpDaddr is configured, then aniDevFilterIpDmask should be configured as well and vice versa. ')
aniDevFilterIpSourceStart = MibTableColumn((1, 3, 6, 1, 4, 1, 4325, 2, 8, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aniDevFilterIpSourceStart.setStatus('current')
if mibBuilder.loadTexts: aniDevFilterIpSourceStart.setDescription('The lowest bound value for the source port number. List of Some Well Known Ports: Application Port ----------- ---- Ftp Data 20 Ftp Control 21 HTTP 80 IMAP2 143 SNMP 161 POP3 110 SMTP 25 Telnet 23 TFTP 69 BootP Server 67 BootP Client 68 Gopher 70 Finger 79 BGP 179 In addition to the list, the user can enter any other value as well. This field is valid only if the aniDevFilterIpProtocol field is set to TCP, UDP, (TCP or UDP) or not specified by the user. aniIpFilterIpSourceEnd should be >= aniIpFilterIpSourceStart. Whenever aniIpFilterIpSourceEnd is configured, aniIpFilterIpSourceStart should be configured as well. ')
aniDevFilterIpSourceEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 4325, 2, 8, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aniDevFilterIpSourceEnd.setStatus('current')
if mibBuilder.loadTexts: aniDevFilterIpSourceEnd.setDescription('The highest bound value for the source port number. Refer to the Well known ports list under aniIpFilterIpSourceStart description. In addition to the list, the user can enter any other value as well. This field is valid only if the aniDevFilterIpProtocol is set to TCP, UDP, (TCP or UDP) or not specified by the user. aniDevFilterIpSourceEnd should be >= aniDevFilterIpSourceStart. Whenever aniDevFilterIpSourceEnd is configured, aniDevFilterIpSourceStart should be configured as well. ')
aniDevFilterIpDestStart = MibTableColumn((1, 3, 6, 1, 4, 1, 4325, 2, 8, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aniDevFilterIpDestStart.setStatus('current')
if mibBuilder.loadTexts: aniDevFilterIpDestStart.setDescription('The lowest bound value for the destination port number. Refer to the Well known ports list under aniIpFilterIpSourceStart description. In addition to the list, the user can enter any other value as well. This field is valid only if the aniDevFilterIpProtocol is set to TCP, UDP, (TCP or UDP) or not specified by the user. aniDevFilterIpDestEnd should be >= aniDevFilterIpDestStart. Whenever aniDevFilterIpDestStart is configured, aniDevFilterIpDestEnd should be configured as well. ')
aniDevFilterIpDestEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 4325, 2, 8, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aniDevFilterIpDestEnd.setStatus('current')
if mibBuilder.loadTexts: aniDevFilterIpDestEnd.setDescription('The highest bound value for the destination port number. Refer to the Well known ports list under aniIpFilterIpSourceStart description. In addition to the list, the user can enter any other value as well. This field is valid only if the aniDevFilterIpProtocol is set to TCP, UDP, (TCP or UDP) or not specified by the user. aniDevFilterIpDestEnd should be >= aniDevFilterIpDestStart. Whenever aniDevFilterIpDestStart is configured, aniDevFilterIpDestEnd should be configured as well. ')
aniDevFilterIpOptions = MibTableColumn((1, 3, 6, 1, 4, 1, 4325, 2, 8, 1, 1, 16), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aniDevFilterIpOptions.setStatus('current')
if mibBuilder.loadTexts: aniDevFilterIpOptions.setDescription('The Mask value for the IP Options. No Operation (0x000001) Route Record (0x000002) Time Stamp (0x000040) MTU Probe (0x000008) MTU Reply (0x000010) Trace Route (0x000080) Address Extension (0x004000) Loose Source Route (0x000200) Strict Source Route (0x002000) Extended Security (0x000400) Security (0x000100) Commercial Security (0x000800) Experimental Measurement (0x000004) Experimental Flow Control (0x040000) Experimental Access Control (0x008000) Stream Id (0x001000) IMI Traffic Descriptor (0x010000) ')
aniDevFilterIpSecOptions = MibTableColumn((1, 3, 6, 1, 4, 1, 4325, 2, 8, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("top-secret", 1), ("secret", 2), ("confidential", 3), ("unclassified", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aniDevFilterIpSecOptions.setStatus('current')
if mibBuilder.loadTexts: aniDevFilterIpSecOptions.setDescription('The IP Security Value. ')
aniDevFilterIcmpMsgType = MibTableColumn((1, 3, 6, 1, 4, 1, 4325, 2, 8, 1, 1, 18), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aniDevFilterIcmpMsgType.setStatus('current')
if mibBuilder.loadTexts: aniDevFilterIcmpMsgType.setDescription('The Message Type for ICMP Protocol. This field is valid only if the aniDevFilterIpProtocol is set to ICMP or not specified by the user. Valid Range: ICMP Message Type SubCode ------------ ---- ---- Echo reply 0 ------------------------------------------------------------ Destination Unreachable 3 0 = net unreachable; 1 = host unreachable; 2 = protocol unreachable; 3 = port unreachable; 4 = fragmentation needed and DF set; 5 = source route failed. ------------------------------------------------------------ Source Quench 4 ------------------------------------------------------------ Redirect 5 0 = Redirect datagrams for the Network. 1 = Redirect datagrams for the Host. 2 = Redirect datagrams for the Type of Service and Network. 3 = Redirect datagrams for the Type of Service and Host. ------------------------------------------------------------ Echo 8 ------------------------------------------------------------ Time Exceeded Message 11 0 = time to live exceeded in transit; 1 = fragment reassembly time exceeded. ------------------------------------------------------------ Parameter Problem 12 0 = pointer indicates the error. ------------------------------------------------------------ Timestamp message 13 ------------------------------------------------------------ Timestamp reply message 14 ------------------------------------------------------------ Information Request 15 ------------------------------------------------------------ Information Reply 16 ------------------------------------------------------------ Address Mask request 17 ------------------------------------------------------------ Address Mask reply 18 ------------------------------------------------------------ ')
aniDevFilterIcmpSubcode = MibTableColumn((1, 3, 6, 1, 4, 1, 4325, 2, 8, 1, 1, 19), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aniDevFilterIcmpSubcode.setStatus('current')
if mibBuilder.loadTexts: aniDevFilterIcmpSubcode.setDescription('The Subcode for ICMP Protocol. This field is valid only if the aniDevFilterIpProtocol is set to ICMP or not specified by the user. If this field is specified then aniDevFilterIcmpMsgType should already be specified. The values allowed for ICMP Code depend on aniDevFilterIcmpMsgType. Refer to the description under aniDevFilterIcmpMsgType for a detail list of values. ')
aniDevFilterTcpFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 4325, 2, 8, 1, 1, 20), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aniDevFilterTcpFlags.setStatus('current')
if mibBuilder.loadTexts: aniDevFilterTcpFlags.setDescription('The TCP Flags. The valid range: Urgent (0x20) Acknowledgement (0x10) Push (0x08) Reset (0x04) Sync (0x02) Sync-Ack (0x12) Finish (0x01) Finish-Ack (0x11) This field is valid only if the aniDevFilterIpProtocol is set to ICMP or not specified by the user. ')
aniDevFilterDestMacMask = MibTableColumn((1, 3, 6, 1, 4, 1, 4325, 2, 8, 1, 1, 21), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 12))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aniDevFilterDestMacMask.setStatus('current')
if mibBuilder.loadTexts: aniDevFilterDestMacMask.setDescription('The MAC address and mask value for destination. ')
aniDevFilterSourceMac = MibTableColumn((1, 3, 6, 1, 4, 1, 4325, 2, 8, 1, 1, 22), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aniDevFilterSourceMac.setStatus('current')
if mibBuilder.loadTexts: aniDevFilterSourceMac.setDescription('The MAC Address of the source. ')
aniDevFilterEnetType = MibTableColumn((1, 3, 6, 1, 4, 1, 4325, 2, 8, 1, 1, 23), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aniDevFilterEnetType.setStatus('current')
if mibBuilder.loadTexts: aniDevFilterEnetType.setDescription('The Ethernet type value in the ethernet header. The maximum length of the ethernet packet is 1500 (0x5DC). The value of the ethernet type must be greater than 1500. Appicable for Ethernet Version II frame type. If this type is being used then, DSAP (LLC Header), SSAP (LLC Header), Control Byte (LLC Header) and Local Code (SNAP) cannot be used and vice-versa. Valid Range: 0x5DD to 0xFFFF List of Ethernet Types: ----------------------------------------------------------- 0x800 DOD Internet Protocol (IP) ----------------------------------------------------------- 0x806 Address Resolution Protocol (ARP) (for IP and for CHAOS) ')
aniDevFilterLlcDSAP = MibTableColumn((1, 3, 6, 1, 4, 1, 4325, 2, 8, 1, 1, 24), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aniDevFilterLlcDSAP.setStatus('current')
if mibBuilder.loadTexts: aniDevFilterLlcDSAP.setDescription('The DSAP (Destination Service Access Point) value in LLC Header. Valid Range: 0 to 0xFF Applicable for IEEE 802.3 Frame Format only. ')
aniDevFilterLlcSSAP = MibTableColumn((1, 3, 6, 1, 4, 1, 4325, 2, 8, 1, 1, 25), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aniDevFilterLlcSSAP.setStatus('current')
if mibBuilder.loadTexts: aniDevFilterLlcSSAP.setDescription('The SSAP (Source Service Access Point) value in LLC Header. Valid Range: 0 to 0xFF Applicable for IEEE 802.3 Frame Format only. ')
aniDevFilterLlcControl = MibTableColumn((1, 3, 6, 1, 4, 1, 4325, 2, 8, 1, 1, 26), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aniDevFilterLlcControl.setStatus('current')
if mibBuilder.loadTexts: aniDevFilterLlcControl.setDescription('The Control Byte of the LLC Header. Valid Range: 0 to 0xFF Applicable for IEEE 802.3 Frame Format only. ')
aniDevFilterLocalCode = MibTableColumn((1, 3, 6, 1, 4, 1, 4325, 2, 8, 1, 1, 27), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aniDevFilterLocalCode.setStatus('current')
if mibBuilder.loadTexts: aniDevFilterLocalCode.setDescription('The Local Code for SNAP ethernet type. Applicable for IEEE 802.3 Frame Format only. DSAP should be set to 0xAA, SSAP should be set to 0xAA, Control Byte should be set to 0x03. Valid range: 0 - 0xFFFF. List of Ethernet Types: -------------------------------------------------------- 0x800 DOD Internet Protocol (IP) -------------------------------------------------------- 0x806 Address Resolution Protocol (ARP) (for IP and for CHAOS) ')
aniDevFilterRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 4325, 2, 8, 1, 1, 28), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aniDevFilterRowStatus.setStatus('current')
if mibBuilder.loadTexts: aniDevFilterRowStatus.setDescription('This represents the state of an entry within the table. It is used to manage creation and deletion of rows. The values include: active(1) notInService(2) notReady(3) createAndGo(4) createAndWait(5) destroy(6) When a Get request is sent, this object returns either active(1), notInService(2) or notReady(3) depending on the state of this row. A new row can be Created using either createAndGo(4) or createAndWait(5). For Deleting a row, this field should be set to destroy(6). ')
aniDevFilterUserPriorityHi = MibTableColumn((1, 3, 6, 1, 4, 1, 4325, 2, 8, 1, 1, 29), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aniDevFilterUserPriorityHi.setStatus('current')
if mibBuilder.loadTexts: aniDevFilterUserPriorityHi.setDescription("The high priority byte of the user priority. The user priority specifies the matching parameters for the IEEE 802.1P user_priority bits. An Ethernet packet with IEEE 802.1P user_priority value 'priority' matches these parameters if pri-low <= priority <= pri_high. ")
aniDevFilterUserPriorityLo = MibTableColumn((1, 3, 6, 1, 4, 1, 4325, 2, 8, 1, 1, 30), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aniDevFilterUserPriorityLo.setStatus('current')
if mibBuilder.loadTexts: aniDevFilterUserPriorityLo.setDescription("The low priority byte of the user priority. The user priority specifies the matching parameters for the IEEE 802.1P user_priority bits. An Ethernet packet with IEEE 802.1P user_priority value 'priority' matches these parameters if pri-low <= priority <= pri_high. ")
aniDevFilterVlanIdStart = MibTableColumn((1, 3, 6, 1, 4, 1, 4325, 2, 8, 1, 1, 31), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aniDevFilterVlanIdStart.setStatus('current')
if mibBuilder.loadTexts: aniDevFilterVlanIdStart.setDescription("The lower limit for the VLAN ID. This value is used to specify the lower limit in the range. Any IEEE 802.1P packet from a customer's VLAN that falls into the range matches the rule. aniDevFilterVlanIdStart and aniDevFilterVlanIdEnd must be defined in a pair. ")
aniDevFilterVlanIdEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 4325, 2, 8, 1, 1, 32), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aniDevFilterVlanIdEnd.setStatus('current')
if mibBuilder.loadTexts: aniDevFilterVlanIdEnd.setDescription("The upper limit for the VLAN ID. This value is used to specify the upper limit in the range. Any IEEE 802.1P packet from a customer's VLAN that falls into the range matches the rule. aniUSClassifierVlanIdStart and aniUSClassifierVlanIdEnd must be defined in a pair. ")
aniDevFilterIfTable = MibTable((1, 3, 6, 1, 4, 1, 4325, 2, 8, 2), )
if mibBuilder.loadTexts: aniDevFilterIfTable.setStatus('current')
if mibBuilder.loadTexts: aniDevFilterIfTable.setDescription('This table allows the user to enable/disable Filtering per interface basis. ')
aniDevFilterIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4325, 2, 8, 2, 1), ).setIndexNames((0, "DEVFILTER-MIB", "aniDevFilterIfIdentifier"))
if mibBuilder.loadTexts: aniDevFilterIfEntry.setStatus('current')
if mibBuilder.loadTexts: aniDevFilterIfEntry.setDescription('An entry containing objects for each IP Filter interface configured. ')
aniDevFilterIfIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 4325, 2, 8, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("ethernet", 1), ("wireless-port1", 2), ("wireless-port2", 3), ("wireless-port3", 4), ("wireless-port4", 5), ("wireless-port5", 6), ("wireless-port6", 7))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aniDevFilterIfIdentifier.setStatus('current')
if mibBuilder.loadTexts: aniDevFilterIfIdentifier.setDescription('The Interface Type. On SU, only ethernet(1) and wireless-port1(2) are valid. On BSU, ethernet(1) and all configured wireless interfaces -- wireless-port1(2), wireless-port2(3), wireless-port3(4), wireless-port4(5), wireless-port5(6), wireless-port6(7) are valid, that is, filtering should be allowed on these wireless interfaces only if they are configured. ')
aniDevFilterIfFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 4325, 2, 8, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aniDevFilterIfFlag.setStatus('current')
if mibBuilder.loadTexts: aniDevFilterIfFlag.setDescription('The flag to enable or disable filtering on a particular interface. The default value depends on whether a rule is configured on the particular interface or not. When a rule is configured on the interface, this flag will be set to enable(1) automatically. If no rule is configured, this flag should be disabled by default. ')
mibBuilder.exportSymbols("DEVFILTER-MIB", aniDevFilterIpDestEnd=aniDevFilterIpDestEnd, aniDevFilterIfTable=aniDevFilterIfTable, aniDevFilterLlcDSAP=aniDevFilterLlcDSAP, aniDevFilterLlcControl=aniDevFilterLlcControl, aniDevFilterSourceMac=aniDevFilterSourceMac, aniDevFilterIpSourceStart=aniDevFilterIpSourceStart, aniDevFilterIfIndex=aniDevFilterIfIndex, aniDevFilterIpSmask=aniDevFilterIpSmask, aniDevFilterIpSourceEnd=aniDevFilterIpSourceEnd, aniDevFilterIpSecOptions=aniDevFilterIpSecOptions, aniDevFilterIfEntry=aniDevFilterIfEntry, aniDevFilterVlanIdEnd=aniDevFilterVlanIdEnd, aniDevFilterIfIdentifier=aniDevFilterIfIdentifier, aniDevFilterName=aniDevFilterName, aniDevFilterPermission=aniDevFilterPermission, aniDevFilterIpDestStart=aniDevFilterIpDestStart, aniDevFilterIpDaddr=aniDevFilterIpDaddr, aniDevFilterIcmpMsgType=aniDevFilterIcmpMsgType, PYSNMP_MODULE_ID=aniDevFilter, aniDevFilterIcmpSubcode=aniDevFilterIcmpSubcode, aniDevFilterEntry=aniDevFilterEntry, aniDevFilterIpSaddr=aniDevFilterIpSaddr, aniDevFilterVlanIdStart=aniDevFilterVlanIdStart, aniDevFilterUserPriorityLo=aniDevFilterUserPriorityLo, aniDevFilterLlcSSAP=aniDevFilterLlcSSAP, aniDevFilterTable=aniDevFilterTable, aniDevFilterIpOptions=aniDevFilterIpOptions, aniDevFilterIpDmask=aniDevFilterIpDmask, aniDevFilterIpProtocol=aniDevFilterIpProtocol, aniDevFilterPriority=aniDevFilterPriority, aniDevFilterUserPriorityHi=aniDevFilterUserPriorityHi, aniDevFilterIdentifier=aniDevFilterIdentifier, aniDevFilterLocalCode=aniDevFilterLocalCode, aniDevFilterIfFlag=aniDevFilterIfFlag, aniDevFilterEnetType=aniDevFilterEnetType, aniDevFilter=aniDevFilter, aniDevFilterRowStatus=aniDevFilterRowStatus, aniDevFilterDestMacMask=aniDevFilterDestMacMask, aniDevFilterTcpFlags=aniDevFilterTcpFlags, aniDevFilterActivationState=aniDevFilterActivationState)

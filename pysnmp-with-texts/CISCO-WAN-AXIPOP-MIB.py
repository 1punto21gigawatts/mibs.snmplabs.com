#
# PySNMP MIB module CISCO-WAN-AXIPOP-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-WAN-AXIPOP-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:20:10 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ValueRangeConstraint, ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint")
rpmPort, atm, frPortCnf, atmLineCnfGrp, frPortCntSig, bbIfCnfResPartGrp, bbChanCntGrp, bbChanCnfGrp, ausmPortCnf, rpmInterface, cardGeneric, ausmChan, ausmPortCnt, vismPort, frPortCnfX21PortGrp, bbIfStateGrp, bbChanStateGrp, x21, atmLineCntGrp, basisAsm, frameRelay, bbIfCnf, frPortCnfResPartGrp, atmLmiSignaling, vismChanCnfGrp, frPortCnfSig, frPortServiceQueGrp, cesmChan, circuitEmulation, rpmChanGrp, voice, bbIfCnt, par, basisLines, ausmPort, frPort, cardSpecific, vismChanGrp, virtualInterface, axisDiagnostics, atmAddressRegistration, dsx0Vism, frPortCnt, frChan = mibBuilder.importSymbols("BASIS-MIB", "rpmPort", "atm", "frPortCnf", "atmLineCnfGrp", "frPortCntSig", "bbIfCnfResPartGrp", "bbChanCntGrp", "bbChanCnfGrp", "ausmPortCnf", "rpmInterface", "cardGeneric", "ausmChan", "ausmPortCnt", "vismPort", "frPortCnfX21PortGrp", "bbIfStateGrp", "bbChanStateGrp", "x21", "atmLineCntGrp", "basisAsm", "frameRelay", "bbIfCnf", "frPortCnfResPartGrp", "atmLmiSignaling", "vismChanCnfGrp", "frPortCnfSig", "frPortServiceQueGrp", "cesmChan", "circuitEmulation", "rpmChanGrp", "voice", "bbIfCnt", "par", "basisLines", "ausmPort", "frPort", "cardSpecific", "vismChanGrp", "virtualInterface", "axisDiagnostics", "atmAddressRegistration", "dsx0Vism", "frPortCnt", "frChan")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Gauge32, Bits, MibScalar, MibTable, MibTableRow, MibTableColumn, ObjectIdentity, IpAddress, ModuleIdentity, Unsigned32, MibIdentifier, iso, TimeTicks, Counter64, Counter32, NotificationType, Integer32 = mibBuilder.importSymbols("SNMPv2-SMI", "Gauge32", "Bits", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ObjectIdentity", "IpAddress", "ModuleIdentity", "Unsigned32", "MibIdentifier", "iso", "TimeTicks", "Counter64", "Counter32", "NotificationType", "Integer32")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
class AtmAddress(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 32)

class RpmNsapAddress(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(20, 20)
    fixedLength = 20

class IfNsapAddress(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(20, 20)
    fixedLength = 20

class NetPrefix(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(8, 13)

atmAddressGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 1, 4, 1, 2))
atmAddressTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 1, 4, 1, 2, 1), )
if mibBuilder.loadTexts: atmAddressTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmAddressTable.setDescription('A table implemented by the network-side of an ATM UNI port, containing the ATM-layer addresses in effect on the user-side of the UNI.')
atmAddressEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 1, 4, 1, 2, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "axisAtmAddressPort"), (0, "CISCO-WAN-AXIPOP-MIB", "axisAtmAddressAtmAddress"))
if mibBuilder.loadTexts: atmAddressEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmAddressEntry.setDescription('Information about a single ATM-layer address in effect on the user-side of a UNI port.')
axisAtmAddressPort = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 1, 4, 1, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: axisAtmAddressPort.setStatus('mandatory')
if mibBuilder.loadTexts: axisAtmAddressPort.setDescription('A unique value which identifies this port. The value of 0 has the special meaning of identifying the local UNI.')
axisAtmAddressAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 1, 4, 1, 2, 1, 1, 2), AtmAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: axisAtmAddressAtmAddress.setStatus('mandatory')
if mibBuilder.loadTexts: axisAtmAddressAtmAddress.setDescription('The ATM address which is in effect on the user-side of the ATM UNI port.')
axisAtmAddressStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 1, 4, 1, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: axisAtmAddressStatus.setStatus('mandatory')
if mibBuilder.loadTexts: axisAtmAddressStatus.setDescription('An indication of the validity of the ATM address at the user-side of the UNI port.')
atmNetPrefixGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 1, 4, 1, 1))
atmNetPrefixTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 1, 4, 1, 1, 1), )
if mibBuilder.loadTexts: atmNetPrefixTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmNetPrefixTable.setDescription('A table implemented by the UNI Management Entity on the user-side of an ATM UNI port, containing the network-prefix(es) for ATM-layer addresses in effect on the user-side of the UNI.')
atmNetPrefixEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 1, 4, 1, 1, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "axisAtmNetPrefixPort"), (0, "CISCO-WAN-AXIPOP-MIB", "axisAtmNetPrefixPrefix"))
if mibBuilder.loadTexts: atmNetPrefixEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmNetPrefixEntry.setDescription('An entry in the table, containing information about the ATM Prefix status.')
axisAtmNetPrefixPort = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 1, 4, 1, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: axisAtmNetPrefixPort.setStatus('mandatory')
if mibBuilder.loadTexts: axisAtmNetPrefixPort.setDescription('The unique value which identifies the ILMI port.')
axisAtmNetPrefixPrefix = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 1, 4, 1, 1, 1, 1, 2), NetPrefix()).setMaxAccess("readonly")
if mibBuilder.loadTexts: axisAtmNetPrefixPrefix.setStatus('mandatory')
if mibBuilder.loadTexts: axisAtmNetPrefixPrefix.setDescription('The network prefix for ATM addresses which is in effect on the user-side of the ATM UNI port.')
axisAtmNetPrefixAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 1, 4, 1, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: axisAtmNetPrefixAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: axisAtmNetPrefixAdminStatus.setDescription('An indication of the validity of the network prefix for ATM addresses, on the user-side of the UNI port.')
axisAtmNetPrefixOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 1, 4, 1, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("registering", 1), ("de-registering", 2), ("registered", 3), ("de-registered", 4), ("failRegistering", 5), ("failDe-registering", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: axisAtmNetPrefixOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: axisAtmNetPrefixOperStatus.setDescription('An indication of the current registration state for the prefix: registering, de-registering, success, fail.')
cardResourcePartition = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 2, 9))
cardLcnPartitionType = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 2, 9, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noPartition", 1), ("controllerBased", 2), ("portControllerBased", 3))).clone('noPartition')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cardLcnPartitionType.setStatus('mandatory')
if mibBuilder.loadTexts: cardLcnPartitionType.setDescription('This object specified the type of partition on LCN: 1. noPartition -- means that all controllers compete for the totoal (G)LCNs limited by the card 2. controllerBased -- means that the total number of (G)LCNs available to each controller is fixed but no reservation on each port. The number for each controller is specified in the smCardResPartGrpTable. 3. portControllerBased -- means that a certain number of (G)LCNs available on each port for each controller is reserved, it is specified in the port resouce partition table. NOTE: This object has to be configured before adding any connections and once a connection is added, this object cannot be changed until all of the connections are deleted. ')
cardResPartGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 2, 9, 2), )
if mibBuilder.loadTexts: cardResPartGrpTable.setStatus('mandatory')
if mibBuilder.loadTexts: cardResPartGrpTable.setDescription("This table contains the configuration of all the resource partition(s) that are on the card level, such as (G)LCN (if the object cardLcnPartitionType is configured as controller-based, if not, there is no need to configure this table since it'll be useless). ")
cardResPartGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 2, 9, 2, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "cardResPartCtrlrNum"))
if mibBuilder.loadTexts: cardResPartGrpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cardResPartGrpEntry.setDescription('This is an entry for a controller ')
cardResPartCtrlrNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 2, 9, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("par", 1), ("pnni", 2), ("tag", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cardResPartCtrlrNum.setStatus('mandatory')
if mibBuilder.loadTexts: cardResPartCtrlrNum.setDescription('This object is the index to the table ')
cardResPartRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 2, 9, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("add", 1), ("del", 2), ("mod", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cardResPartRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cardResPartRowStatus.setDescription('This object is records the status of this entry ')
cardResPartNumOfLcnAvail = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 2, 9, 2, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cardResPartNumOfLcnAvail.setStatus('mandatory')
if mibBuilder.loadTexts: cardResPartNumOfLcnAvail.setDescription('This object is configured to reserve the number of (G)LCNs for one controller on a SM card, it can be used on any port but the total number of connections added on all of the ports for that particular controller cannot exceed this number. ')
onlineDiagnostics = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 6, 3))
diagType = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 6, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("post", 1), ("onlinediag", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: diagType.setStatus('mandatory')
if mibBuilder.loadTexts: diagType.setDescription('This is used to identify the type of diagnostics. When a trap is sent to report diagnostics results this is used as a varbind to indicate the type of diagnostics. ')
diagResult = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 6, 3, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("passed", 1), ("failed", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: diagResult.setStatus('mandatory')
if mibBuilder.loadTexts: diagResult.setDescription('This is used to indicate the result of the diagnostics tests in traps. ')
diagTestId = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 6, 3, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: diagTestId.setStatus('mandatory')
if mibBuilder.loadTexts: diagTestId.setDescription('This is used to indicate the test number of the diagnostics test that failed. ')
bert = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 6, 1))
bertControl = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("acquireBert", 1), ("releaseBert", 2), ("cnfBert", 3), ("startBert", 4), ("modBert", 5), ("delBert", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bertControl.setStatus('mandatory')
if mibBuilder.loadTexts: bertControl.setDescription('This object controls all the SET operations on this MIB group. acquireBert : Acquire BERT resources. cnfBert : Configure the required BERT test. startBert : The configured test has to be started. modBert : Modify parameters for the ongoing BERT test. delBert : Running BERT test has to be stopped. The above list shows the sequence in which the SET operations on this group need to be done, ideally. Bert can be operated upon only with bertUserId and bertSlotNumber. The default value is 0, means no action. ')
bertResourceStatus = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("free", 1), ("inUse", 2), ("cleanupPending", 3))).clone('free')).setMaxAccess("readonly")
if mibBuilder.loadTexts: bertResourceStatus.setStatus('mandatory')
if mibBuilder.loadTexts: bertResourceStatus.setDescription('All of bert resources can be used by only one user at a time. This gives the status of the resources. ')
bertOwner = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bertOwner.setStatus('mandatory')
if mibBuilder.loadTexts: bertOwner.setDescription('This refers to the user who owns the BERT resources. If the user is a CLI user, then this is username. If it is SV+, then this would be the IP address. For example, this value can be, 192.9.209.157 within quotes. ')
bertUserId = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bertUserId.setStatus('mandatory')
if mibBuilder.loadTexts: bertUserId.setDescription('This identifies the user who wants to do a SET operation on this group. This will be compared against bertOwner and access will be given only if it matches. Hence, for every SET request, this object should have a valid value. If the user is a CLI user, then this is username. If it is SV+, then this would be the IP address. For example, this value can be, 192.9.209.157 within quotes. Required for bert operations. ')
bertStatus = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("inactive", 1), ("bertInSync", 2), ("bertOutOfSync", 3), ("searchingDDSCommands", 4), ("farEndInLoop", 5), ("facilityInLoop", 6), ("portFacilityFifoFault", 7), ("portFacilityFifoOutOfSync", 8), ("metallicInLoop", 9), ("bertFailed", 10))).clone('inactive')).setMaxAccess("readonly")
if mibBuilder.loadTexts: bertStatus.setStatus('mandatory')
if mibBuilder.loadTexts: bertStatus.setDescription('This variable provides the status of BERT in the shelf. ')
bertSlotNumber = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bertSlotNumber.setStatus('mandatory')
if mibBuilder.loadTexts: bertSlotNumber.setDescription('specifies the physical slot number of the Service Module which is to run BERT For MGX 8220, the range is 5-14. For MGX 8850, the range is 1-6, 9-14, 17-22, 25-30. Required for bert operations. ')
bertTestMedium = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("port", 1), ("line", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bertTestMedium.setStatus('mandatory')
if mibBuilder.loadTexts: bertTestMedium.setDescription('specifies whether the bert is to test a port or an entire T1/E1 line. No default value for this, it has to be set if bert is configured. ')
bertPort = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bertPort.setStatus('mandatory')
if mibBuilder.loadTexts: bertPort.setDescription('specifies the port number for BERT. ')
bertLine = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bertLine.setStatus('mandatory')
if mibBuilder.loadTexts: bertLine.setDescription('specifies the line number for BERT. If the test medium is port, this represents the line to which the port belongs. ')
bertMode = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("bertPatternTest", 1), ("ddsSeek", 2), ("loopback", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bertMode.setStatus('mandatory')
if mibBuilder.loadTexts: bertMode.setDescription('specifies the mode, the BERT module is to be configured for. ')
bertDeviceToLoop = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("noLatchOCUwith1", 1), ("noLatchOCUwitout1", 2), ("noLatchCSU", 3), ("noLatchDSU", 4), ("latchDS0Drop", 5), ("latchDS0Line", 6), ("latchOCU", 7), ("latchCSU", 8), ("latchDSU", 9), ("latchHL96", 10), ("v54Polynomial", 11), ("inband", 12), ("esf", 13), ("metallic", 14), ("noDevice", 15), ("smartJackInband", 16)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bertDeviceToLoop.setStatus('mandatory')
if mibBuilder.loadTexts: bertDeviceToLoop.setDescription('This shows the type of the end device and the type of the loopback used (latching/nonlatching/polynomial). ')
bertDS0DPIterationCount = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bertDS0DPIterationCount.setStatus('mandatory')
if mibBuilder.loadTexts: bertDS0DPIterationCount.setDescription('The Iteration Register needs to be programmed in SRM when DSO drop loop option is selected in bertDeviceToLoop. The value to be programmed there is minus one of this object value, since the register is 0 based. DSP-OP devices can be cross connected in the centeral office. By this, the user has capablitiy to put any of the devices in the chain in loopback mode. This is done by repeating the latching activation code in a specific manner. The binary number in the iterataion register determines how many times the first portion of a latching loop activation code needs to be repeated as per user request and according to the Bellcore spec. A value of 0 results in no iteration and will cause the very first device in chain to go into loop back. A value of 1 will result into one iteration and will cause the second device to go into loopback and so on. The range of this count is 1 to 32, and it would translate to a range of 0 to 31 for the iteration register. ')
bertPattern = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17))).clone(namedValues=NamedValues(("allZeros", 1), ("allOnes", 2), ("alternateONeZero", 3), ("doubleOneZero", 4), ("fifteenBit", 5), ("twentyBit", 6), ("twentyBitQRSS", 7), ("twentythreeBit", 8), ("oneInEight", 9), ("threeIntwentyfour", 10), ("dds-1", 11), ("dds-2", 12), ("dds-3", 13), ("dds-4", 14), ("dds-5", 15), ("nineBit", 16), ("elevenBit", 17)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bertPattern.setStatus('mandatory')
if mibBuilder.loadTexts: bertPattern.setDescription('This variable determines BERT pattern to be transmitted. ')
bertLoopback = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("farEndLoopback", 1), ("facilityLoopback", 2), ("metallicLoopback", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bertLoopback.setStatus('mandatory')
if mibBuilder.loadTexts: bertLoopback.setDescription('specifies the type of loopback to be (d)established. ')
bertLoopbackOperation = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("loopUp", 1), ("loopDown", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bertLoopbackOperation.setStatus('mandatory')
if mibBuilder.loadTexts: bertLoopbackOperation.setDescription('specifies the operation of loopback (up or down). ')
bertDS0Speed = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("speed56k", 1), ("speed64k", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bertDS0Speed.setStatus('mandatory')
if mibBuilder.loadTexts: bertDS0Speed.setDescription('represents the ds0 speed of the test running. ')
bertTimeSlots = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bertTimeSlots.setStatus('mandatory')
if mibBuilder.loadTexts: bertTimeSlots.setDescription('represents the number of ds0s in the test medium chosen. ')
bertStartTime = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 18), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bertStartTime.setStatus('mandatory')
if mibBuilder.loadTexts: bertStartTime.setDescription('The syntax is hh:mm:ss The time zone is as configured in the shelf. ')
bertStartDate = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 19), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(10, 10)).setFixedLength(10)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bertStartDate.setStatus('mandatory')
if mibBuilder.loadTexts: bertStartDate.setDescription('On MGX 8220, the syntax is mm/dd/yy On MGX 8850, the syntax is mm/dd/yyyy ')
bertBitCount = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bertBitCount.setStatus('mandatory')
if mibBuilder.loadTexts: bertBitCount.setDescription('This shows the number of bits transmitted. ')
bertBitErrorCount = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bertBitErrorCount.setStatus('mandatory')
if mibBuilder.loadTexts: bertBitErrorCount.setDescription('This shows the number of bits received in error. ')
bertErrorInjectCount = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bertErrorInjectCount.setStatus('mandatory')
if mibBuilder.loadTexts: bertErrorInjectCount.setDescription('This shows the number of times error was injected. ')
bertCleanupAction = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14))).clone(namedValues=NamedValues(("noAction", 1), ("smCleanup", 2), ("latchDS0DropLoopdown", 3), ("latchDS0LineLoopdown", 4), ("latchOCULoopdown", 5), ("latchCSULoopdown", 6), ("latchDSULoopdown", 7), ("latchHL96Loopdown", 8), ("v54PolynomialLoopdown", 9), ("inbandLoopdown", 10), ("esfLoopdown", 11), ("facilityLoopdown", 12), ("metallicLoopdown", 13), ("smartJackInbandLoopdown", 14))).clone('noAction')).setMaxAccess("readonly")
if mibBuilder.loadTexts: bertCleanupAction.setStatus('mandatory')
if mibBuilder.loadTexts: bertCleanupAction.setDescription('When the BERT has to be stopped or aborted (due to card state changes), this object would give the exact action to take. The bert related changes to the shelf, then, can be cleaned up. When its value is a Loopdown, it implies smCleanup plus the corresponding Loopdown. ')
bertAbortReason = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("ascStateChange", 1), ("smStateChange", 2), ("srmStateChange", 3), ("coreCardSwitch", 4), ("smRedundancySwitch", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bertAbortReason.setStatus('mandatory')
if mibBuilder.loadTexts: bertAbortReason.setDescription('when the BERT is aborted, this object would give the reason for that. ')
bertDDSSeekResultsTableFirstIndex = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bertDDSSeekResultsTableFirstIndex.setStatus('mandatory')
if mibBuilder.loadTexts: bertDDSSeekResultsTableFirstIndex.setDescription('Denotes the index of the oldest entry in the table. A value of zero means that there are no entries in the table. ')
bertDDSSeekResultsTableLastIndex = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bertDDSSeekResultsTableLastIndex.setStatus('mandatory')
if mibBuilder.loadTexts: bertDDSSeekResultsTableLastIndex.setDescription('Denotes the index of the latest entry in the table. A value of zero means that there are no entries in the table. ')
bertDDSSeekResultsTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 27), )
if mibBuilder.loadTexts: bertDDSSeekResultsTable.setStatus('mandatory')
if mibBuilder.loadTexts: bertDDSSeekResultsTable.setDescription('A list of detected DDS codes. ')
bertDDSSeekResultsTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 27, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "bertDDSSeekResultsTableIndex"))
if mibBuilder.loadTexts: bertDDSSeekResultsTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: bertDDSSeekResultsTableEntry.setDescription('An entry in the detected DDS codes table. ')
bertDDSSeekResultsTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 27, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bertDDSSeekResultsTableIndex.setStatus('mandatory')
if mibBuilder.loadTexts: bertDDSSeekResultsTableIndex.setDescription('Denotes the serial number of the entry in the table. ')
bertDDSCode = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 27, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(30, 10, 40, 44, 90, 126, 86, 114, 26, 42, 120, 28, 108, 58, 24, 50))).clone(namedValues=NamedValues(("abnormalStationCondition", 30), ("block", 10), ("channelLoopback", 40), ("dsuLoopback", 44), ("farEndVoice", 90), ("idle", 126), ("loopbackEnable", 86), ("mjuAlert", 114), ("muxOutOfSync", 26), ("ocuLoopback", 42), ("release", 120), ("test", 28), ("testAlert", 108), ("transitionInProgress", 58), ("unassignedMuxChannel", 24), ("unnamed", 50)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bertDDSCode.setStatus('mandatory')
if mibBuilder.loadTexts: bertDDSCode.setDescription('Denotes the type of DDS code detected. ')
bertSupportedTestsTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 28), )
if mibBuilder.loadTexts: bertSupportedTestsTable.setStatus('mandatory')
if mibBuilder.loadTexts: bertSupportedTestsTable.setDescription('A list of supported tests for a given SM. ')
bertSupportedTestsTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 28, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "bertSupportedTestsTableIndex"))
if mibBuilder.loadTexts: bertSupportedTestsTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: bertSupportedTestsTableEntry.setDescription('A general supported tests entry. ')
bertSupportedTestsTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 28, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bertSupportedTestsTableIndex.setStatus('mandatory')
if mibBuilder.loadTexts: bertSupportedTestsTableIndex.setDescription('This index is the physical slot number of the Service Module whose entry it represents in the table. For MGX 8220, the range is 5-14. For MGX 8850, the range is 1-6, 9-14, 17-22, 25-30. ')
bertSupportFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 28, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bertSupportFlag.setStatus('mandatory')
if mibBuilder.loadTexts: bertSupportFlag.setDescription("'yes' if the table entry correctly represents the supported tests for the SM on the corresponding slot. 'no' if no tests at all are supported. ")
bertTestMediumMask = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 28, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bertTestMediumMask.setStatus('mandatory')
if mibBuilder.loadTexts: bertTestMediumMask.setDescription('Every test medium is represented by a bit of mask. Bits 0-1 are valid in this integer. The meaning of the mask can be understood from the example below: -------------------------- TestMedium | SM | support -------------------------- port | 1 line | 1 -------------------------- (Table contents applicable to FRSM-4T1) bertTestMediumMask = 11 binary The column titles represent the variables bertTestMedium depends on. The mask is represented in column major order. ')
bertModeMask = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 28, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bertModeMask.setStatus('mandatory')
if mibBuilder.loadTexts: bertModeMask.setDescription('Every mode is represented by 2 bits of mask. Bits 0-5 are valid in this integer. The meaning of the mask can be understood from the example below: ----------------------------------------------------------- Mode | SM support | Test Medium: | | Multiple | | T1 time slots ----------------------------------------------------------- Pattern test | 1 | 1 DDS seek | 1 | 0 Loopback | 1 | 1 ----------------------------------------------------------- (Table contents applicable to FRSM-4T1) bertModeMask = 101111 binary The column titles represent the variables bertMode depends on. The mask is represented in column major order. ')
bertDeviceToLoopMask = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 28, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bertDeviceToLoopMask.setStatus('mandatory')
if mibBuilder.loadTexts: bertDeviceToLoopMask.setDescription("Every class of devices to loop is represented by 6 bits of mask. Bits 0-29 are valid in this integer. The meaning of the mask can be understood from the example below: ----------------------------------------------------------- | | | Test Medium Class of | SM | MODE |________________________________ devices |supp | Loopback|Line |multiple T1 | 64k | 56k | | | | time slots | | ----------------------------------------------------------- noLatch | 1 0 0 0 0 1 latch | 1 1 0 0 1 1 v54 | 1 1 0 1 1 1 inband/esf| 1 1 1 0 0 0 metallic | 1 0 1 0 0 0 ----------------------------------------------------------- (Table contents applicable to FRSM-4T1) bertDeviceToLoopMask = 001110011000100110000111011111 binary The column titles represent the variables bertDeviceToLoop depends on. The mask is represented in column major order. Due to the limitation on the length of the mask, 'noDevice' option is not represented in this mask. But, the mask for it, is assumed to be a row of ones except for a zero on 'MODE Loopback' column. ")
bertPatternMask = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 28, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bertPatternMask.setStatus('mandatory')
if mibBuilder.loadTexts: bertPatternMask.setDescription('Every class of patterns is represented by 2 bits of mask. Bits 0-3 are valid in this integer. The meaning of the mask can be understood from the example below: ---------------------------------------------- Class of | SM | Non latching patterns | support |device to loop ---------------------------------------------- Other patterns | 1 | 0 ---------------------------------------------- Patterns | 1 | 1 power 9 and 11 | | ---------------------------------------------- (Table contents applicable to FRSM-4T1) bertPatternMask = 1011 binary The column titles represent the variables bertPattern depends on. The mask is represented in column major order. ')
bertLoopbackMask = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 28, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bertLoopbackMask.setStatus('mandatory')
if mibBuilder.loadTexts: bertLoopbackMask.setDescription('Every loopback is represented by 2 bits of mask. Bits 0-5 are valid in this integer. The meaning of the mask can be understood from the example below: ---------------------------------------------- Loopback | SM | Test Medium | support | Port ---------------------------------------------- Far End Loopback | 1 | 1 Facility Loopback | 1 | 1 Metallic Loopback | 1 | 0 ---------------------------------------------- (Table contents applicable to FRSM-4T1) bertLoopbackMask = 011111 binary The column titles represent the variables bertLoopback depends on. The mask is represented in column major order. ')
bertCardT1E1Type = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 6, 1, 28, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("t1", 1), ("e1", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bertCardT1E1Type.setStatus('mandatory')
if mibBuilder.loadTexts: bertCardT1E1Type.setDescription('Specifies whether a t1 or e1 card. ')
srm3T3CnfGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 3, 10))
srm3T3CnfGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 3, 10, 1), )
if mibBuilder.loadTexts: srm3T3CnfGrpTable.setStatus('mandatory')
if mibBuilder.loadTexts: srm3T3CnfGrpTable.setDescription('The SRM 3T3 configuration table, it is the distribution of a T3 line. ')
srm3T3CnfGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 3, 10, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "srmT3LineNum"), (0, "CISCO-WAN-AXIPOP-MIB", "srmStartT1LineNum"))
if mibBuilder.loadTexts: srm3T3CnfGrpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: srm3T3CnfGrpEntry.setDescription('an entry in the T3 configuration table ')
srmT3LineNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 10, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: srmT3LineNum.setStatus('mandatory')
if mibBuilder.loadTexts: srmT3LineNum.setDescription('Select T3 line number. There is no default value for this object.')
srmStartT1LineNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 10, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 28))).setMaxAccess("readonly")
if mibBuilder.loadTexts: srmStartT1LineNum.setStatus('mandatory')
if mibBuilder.loadTexts: srmStartT1LineNum.setDescription('The start T1 number to be affected. There is no default value for this object.')
srmT1RowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 10, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("add", 1), ("delete", 2), ("modify", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: srmT1RowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: srmT1RowStatus.setDescription('a command is used to add, delete, or modify one or more DS1 mapping. Default value is delete.')
srmTargetSlotNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 10, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: srmTargetSlotNum.setStatus('mandatory')
if mibBuilder.loadTexts: srmTargetSlotNum.setDescription(' specify the target slot number to be linked. There is no default value for this object. For MGX8850: SRM01 services slots 1 - 6 and 9 - 14, SRM02 services slots 17 - 22 and 25 - 30 For MGX8220: SYNTAX INTEGER (5 ..14) ')
srmTargetSlotLineNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 10, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: srmTargetSlotLineNum.setStatus('mandatory')
if mibBuilder.loadTexts: srmTargetSlotLineNum.setDescription('0 means not assigned. There is no default value for this object.')
srmeCnfGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 3, 22))
srmeCnfGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 3, 22, 1), )
if mibBuilder.loadTexts: srmeCnfGrpTable.setStatus('mandatory')
if mibBuilder.loadTexts: srmeCnfGrpTable.setDescription('The SRME configuration table for bulk distribution of SRME lines. ')
srmeCnfGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 3, 22, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "srmeLineNum"), (0, "CISCO-WAN-AXIPOP-MIB", "srmeStartVtNum"))
if mibBuilder.loadTexts: srmeCnfGrpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: srmeCnfGrpEntry.setDescription('an entry in the SRME Distribution configuration table ')
srmeLineNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 22, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: srmeLineNum.setStatus('mandatory')
if mibBuilder.loadTexts: srmeLineNum.setDescription('Select SRME line number. For OC3/STM1: SYNTAX INTEGER 1 There is no default value for this object.')
srmeStartVtNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 22, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 84))).setMaxAccess("readonly")
if mibBuilder.loadTexts: srmeStartVtNum.setStatus('mandatory')
if mibBuilder.loadTexts: srmeStartVtNum.setDescription('The start T1 or E1 number (virtual tributary) to be affected. For OC3 with T1 tributaries: SYNTAX INTEGER (1 .. 84) For STM1 with E1 tributaries: SYNTAX INTEGER (1 .. 63) There is no default value for this object.')
srmeRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 22, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("add", 1), ("delete", 2), ("modify", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: srmeRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: srmeRowStatus.setDescription('Command used to add, delete, or modify one or more T1 or E1 mappings. Only the srmeVtFramingType object can be modified once the distribution link is added. To modify all other objects, user should first delete the link and add it again. Default value is modify.')
srmeTargetSlotNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 22, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: srmeTargetSlotNum.setStatus('mandatory')
if mibBuilder.loadTexts: srmeTargetSlotNum.setDescription(' specify the target slot number to be linked. There is no default value for this object. For MGX8x50: SRM01 services slots 1 - 6 and 9 - 14, SRM02 services slots 17 - 22 and 25 - 30 For MGX8x30: service slots 3-6 and 10-13 ')
srmeTargetSlotLineNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 22, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: srmeTargetSlotLineNum.setStatus('mandatory')
if mibBuilder.loadTexts: srmeTargetSlotLineNum.setDescription("Specify the target slot's line to be linked. 0 means not assigned. There is no default value for this object.")
srmeVtFramingType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 22, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("sf", 2), ("esf", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: srmeVtFramingType.setStatus('mandatory')
if mibBuilder.loadTexts: srmeVtFramingType.setDescription('Specifies the Framing Type of the target slot line. This is applicable only if the target module is a T1 Service Module and byte sync mapping is used on SRME. Not applicable to E1 Service Modules. sf: Superframe or D4 esf: Extended Superframe. Default is esf if SRME lines are configured for byte-synchronous mapping. Else, the default is notApplicable. ')
serialInterface = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 4, 1))
serialPortNumOfValidEntries = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: serialPortNumOfValidEntries.setStatus('mandatory')
if mibBuilder.loadTexts: serialPortNumOfValidEntries.setDescription('Number of rows in serialPortTable. This number is equal to the number of serial ports on the module. ')
serialInterfaceTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 4, 1, 1), )
if mibBuilder.loadTexts: serialInterfaceTable.setStatus('mandatory')
if mibBuilder.loadTexts: serialInterfaceTable.setDescription('This table represents Physical serial interfaces on the module ')
serialInterfaceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 4, 1, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "serialPortNum"))
if mibBuilder.loadTexts: serialInterfaceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: serialInterfaceEntry.setDescription('An entry for the serial interface ')
serialPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: serialPortNum.setStatus('mandatory')
if mibBuilder.loadTexts: serialPortNum.setDescription('serial interface number port 1. is always defined as debug port port 2. on BSC can perform SLIP. ')
serialPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("main", 1), ("debug", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: serialPortType.setStatus('mandatory')
if mibBuilder.loadTexts: serialPortType.setDescription('On the BSC board IP stack is mounted on the manager port, on the debug port dumb terminal can be connected function of the ports cannot be changed, except for enabling and disabling ')
serialPortEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: serialPortEnable.setStatus('mandatory')
if mibBuilder.loadTexts: serialPortEnable.setDescription('ports can be enabled or diabled ')
serialPortbps = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("bps9600", 1), ("bps2400", 2), ("bps19200", 3))).clone('bps9600')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: serialPortbps.setStatus('mandatory')
if mibBuilder.loadTexts: serialPortbps.setDescription('baud rate of the ports, each port can be config different ')
ethernetInterface = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 4, 2))
ethernetPhysicaAddress = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 4, 2, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethernetPhysicaAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ethernetPhysicaAddress.setDescription('ethernet address stored in the BSC BRAM, entered by manfacturing. ')
asmAlarmTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 1, 2, 1), )
if mibBuilder.loadTexts: asmAlarmTable.setStatus('mandatory')
if mibBuilder.loadTexts: asmAlarmTable.setDescription('The ASM Alarm table. The table size is given by the value of ASMNumOfValidEntries.')
asmAlarmEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 1, 2, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "asmAlarmNum"))
if mibBuilder.loadTexts: asmAlarmEntry.setStatus('mandatory')
if mibBuilder.loadTexts: asmAlarmEntry.setDescription('An entry in the Basis ASM Alarm Table.')
asmAlarmNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 1, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: asmAlarmNum.setStatus('mandatory')
if mibBuilder.loadTexts: asmAlarmNum.setDescription('This object is the identifier of a ASM alarm entry. The Alarm is further identified by the objects ASMAlarmType & ASMAlarmUnitNum.')
asmAlarmType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 1, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("alarmOther", 1), ("alarmTemperature", 2), ("alarmPSU", 3), ("alarmDCLevel", 4), ("alarmFanUnit", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: asmAlarmType.setStatus('mandatory')
if mibBuilder.loadTexts: asmAlarmType.setDescription('The value for this object indicates the type of Alarm represented in the entry of ASMAlarmTable indexed by ASMAlarmNum.')
asmAlarmUnitNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 1, 2, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: asmAlarmUnitNum.setStatus('mandatory')
if mibBuilder.loadTexts: asmAlarmUnitNum.setDescription('This object identifies one unit among a number of identical units represented in ASMAlarmTable having the same ASMAlarmType.')
asmAlarmThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 1, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: asmAlarmThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: asmAlarmThreshold.setDescription('This object specifies the threshold beyond which the alarmable unit is said to be in an abnormal state.')
asmAlarmSeverity = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 1, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("alarmMinor", 1), ("alarmMajor", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: asmAlarmSeverity.setStatus('mandatory')
if mibBuilder.loadTexts: asmAlarmSeverity.setDescription('This variable specifies the severity of the alarm to be declared when the ASMAlarmThreshold specified is exceeded for the entry of ASMAlarmTable indexed by ASMAlarmNum.')
asmUnitMeasurable = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 1, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: asmUnitMeasurable.setStatus('mandatory')
if mibBuilder.loadTexts: asmUnitMeasurable.setDescription('This object indicates if the alarm unit is measurable by the AXIS shelf.')
asmUnitMeasuredValue = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 1, 2, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: asmUnitMeasuredValue.setStatus('mandatory')
if mibBuilder.loadTexts: asmUnitMeasuredValue.setDescription('This object gives the mesaured value of the entity addressed by asmAlarmNum if it is measurable.')
asmPhysicalAlarmState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 1, 2, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: asmPhysicalAlarmState.setStatus('mandatory')
if mibBuilder.loadTexts: asmPhysicalAlarmState.setDescription('This object indicates the status of the ASM alarm represented in this entry. It is a bitmap where a set bit indicates an abnormal condition. A reset bit signifies normal operation.')
asmClrButton = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 1, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("asmAlarmNoAction", 1), ("asmAlarmClear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: asmClrButton.setStatus('mandatory')
if mibBuilder.loadTexts: asmClrButton.setDescription('This object when set to ASMAlarmClear causes the entry in the ASMAlarmTable represented by ASMAlarmNum to be cleared.')
asmNumOfValidEntries = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 1, 2, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: asmNumOfValidEntries.setStatus('mandatory')
if mibBuilder.loadTexts: asmNumOfValidEntries.setDescription('The number of valid ASMAlarmTable entries (regardless of how many are actually configured) in the table.')
asmShelfAlarmState = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 1, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("alarmOff", 1), ("alarmOn", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: asmShelfAlarmState.setStatus('mandatory')
if mibBuilder.loadTexts: asmShelfAlarmState.setDescription('This object indicates whether any Shelf Alarm has been declared in the BASIS system.')
aumClockConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 3, 1))
aumAddressTranslation = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 3, 2))
bnmCounters = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 3, 3))
bnmLineInterfaceMode = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 3, 12))
primaryMuxClockSource = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("internalOscillator", 1), ("aumInbandClock", 2), ("externalClock", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: primaryMuxClockSource.setStatus('mandatory')
if mibBuilder.loadTexts: primaryMuxClockSource.setDescription('Primary Mux Clock source for AUM card.')
secondaryMuxClockSource = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("internalOscillator", 1), ("aumInbandClock", 2), ("externalClock", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: secondaryMuxClockSource.setStatus('mandatory')
if mibBuilder.loadTexts: secondaryMuxClockSource.setDescription('Secondary clock source for AUM card.')
currentClock = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("primary", 1), ("secondary", 2), ("intOscillator", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: currentClock.setStatus('mandatory')
if mibBuilder.loadTexts: currentClock.setDescription('clock source currently selected for AUM card.')
clockSwitchState = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noChange", 1), ("clockSrcChanged", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: clockSwitchState.setStatus('mandatory')
if mibBuilder.loadTexts: clockSwitchState.setDescription('clock source switched.')
extClockPresent = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clkNotPresent", 1), ("clkPresent", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: extClockPresent.setStatus('mandatory')
if mibBuilder.loadTexts: extClockPresent.setDescription('Status of External T1/E1 Clock on AUM card.')
extClkSrcImpedance = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ohms75", 1), ("ohms100", 2), ("ohms120", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: extClkSrcImpedance.setStatus('mandatory')
if mibBuilder.loadTexts: extClkSrcImpedance.setDescription('Impedance on external clock input for AUM card.')
extClkConnectorType = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("db15Type", 1), ("bncType", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: extClkConnectorType.setStatus('mandatory')
if mibBuilder.loadTexts: extClkConnectorType.setDescription('This object describes the type of connector available for connecting the external clock source to the AUM-LM. The T3 and E3 cards are separate hence this field is not configurable for any BNM card type except bnm-155')
aumAddressTranslationTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 3, 2, 1), )
if mibBuilder.loadTexts: aumAddressTranslationTable.setStatus('mandatory')
if mibBuilder.loadTexts: aumAddressTranslationTable.setDescription('This table contains address translation parameters for AXIS connections.')
aumAddressTranslationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 3, 2, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "connShelfNum"), (0, "CISCO-WAN-AXIPOP-MIB", "connSlotNum"), (0, "CISCO-WAN-AXIPOP-MIB", "connChanNum"))
if mibBuilder.loadTexts: aumAddressTranslationEntry.setStatus('mandatory')
if mibBuilder.loadTexts: aumAddressTranslationEntry.setDescription('This entry exists when the connection specified by connShelfNum, connSlotNum and connChanNum exists.')
connShelfNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connShelfNum.setStatus('mandatory')
if mibBuilder.loadTexts: connShelfNum.setDescription('Index to shelf list on BASIS.')
connSlotNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 2, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connSlotNum.setStatus('mandatory')
if mibBuilder.loadTexts: connSlotNum.setDescription('Index to slot list on BASIS.')
connChanNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 2, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connChanNum.setStatus('mandatory')
if mibBuilder.loadTexts: connChanNum.setDescription('Index to channel list on BASIS.')
aumConnType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("vpConnection", 1), ("vcConnection", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aumConnType.setStatus('mandatory')
if mibBuilder.loadTexts: aumConnType.setDescription('Virtual channel connection or Virtual Path Connection')
connVPINum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 2, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connVPINum.setStatus('mandatory')
if mibBuilder.loadTexts: connVPINum.setDescription('Virtual channel connection or Virtual Path Connection')
aumAddressTranslationDeleteTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 3, 2, 2), )
if mibBuilder.loadTexts: aumAddressTranslationDeleteTable.setStatus('mandatory')
if mibBuilder.loadTexts: aumAddressTranslationDeleteTable.setDescription('This table contains address translation parameters for AXIS connections.')
aumAddressTranslationDeleteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 3, 2, 2, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "delShelfNum"), (0, "CISCO-WAN-AXIPOP-MIB", "delSlotNum"))
if mibBuilder.loadTexts: aumAddressTranslationDeleteEntry.setStatus('mandatory')
if mibBuilder.loadTexts: aumAddressTranslationDeleteEntry.setDescription('This entry controls bulk deletion of connections on a given AXIS slot.')
delShelfNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 2, 2, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: delShelfNum.setStatus('mandatory')
if mibBuilder.loadTexts: delShelfNum.setDescription('Index to shelf list on AXIS.')
delSlotNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 2, 2, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: delSlotNum.setStatus('mandatory')
if mibBuilder.loadTexts: delSlotNum.setDescription('Index to slot list on BASIS.')
connNumOfValidEntries = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 2, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: connNumOfValidEntries.setStatus('mandatory')
if mibBuilder.loadTexts: connNumOfValidEntries.setDescription('Number of rows in aumAddressTranslationTable.')
bnmPortCounterTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 3, 3, 1), )
if mibBuilder.loadTexts: bnmPortCounterTable.setStatus('mandatory')
if mibBuilder.loadTexts: bnmPortCounterTable.setDescription('The counter table is for the ATM interface, initially there is only one interface, but by making it a table multiple ATM interfaces can be accommodated later.')
bnmPortCounterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 3, 3, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "bnmPortCounterIndex"))
if mibBuilder.loadTexts: bnmPortCounterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: bnmPortCounterEntry.setDescription(' An entry for DS3 ATM counters ')
bnmPortCounterIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bnmPortCounterIndex.setStatus('mandatory')
if mibBuilder.loadTexts: bnmPortCounterIndex.setDescription('This specifies the BNM port being referenced.')
bnmPortRcvCells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 3, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bnmPortRcvCells.setStatus('mandatory')
if mibBuilder.loadTexts: bnmPortRcvCells.setDescription('The count of Received cells at the BNM port.')
bnmPortXmtCells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 3, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bnmPortXmtCells.setStatus('mandatory')
if mibBuilder.loadTexts: bnmPortXmtCells.setDescription('The count of cells transmitted by the BNM port.')
bnmPortCounterClrButton = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("bnmPortCounterNoAction", 1), ("bnmPortCounterClear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bnmPortCounterClrButton.setStatus('mandatory')
if mibBuilder.loadTexts: bnmPortCounterClrButton.setDescription('This object when set to bnmPortCounterClear causes all counters in the row referenced by bnmPortCounterIndex to be cleared.')
bnmPortRcvCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 3, 1, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bnmPortRcvCellRate.setStatus('mandatory')
if mibBuilder.loadTexts: bnmPortRcvCellRate.setDescription('The number of cells received from the BNM port (trunk) per second .')
bnmPortRcvUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 3, 1, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bnmPortRcvUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: bnmPortRcvUtilization.setDescription('The received percentage utilization of the BNM port (trunk)')
bnmPortXmtCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 3, 1, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bnmPortXmtCellRate.setStatus('mandatory')
if mibBuilder.loadTexts: bnmPortXmtCellRate.setDescription('The number of cells transmitted to the BNM port (trunk) per second.')
bnmPortXmtUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 3, 1, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bnmPortXmtUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: bnmPortXmtUtilization.setDescription('The transmitted percentage utilization of the BNM port (trunk)')
bnmPortCounterNumOfValidEntries = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 3, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bnmPortCounterNumOfValidEntries.setStatus('mandatory')
if mibBuilder.loadTexts: bnmPortCounterNumOfValidEntries.setDescription('This object specifies the number of rows in bnmPortCounterTable.')
bnmCellbusXmtCellCount = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 3, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bnmCellbusXmtCellCount.setStatus('mandatory')
if mibBuilder.loadTexts: bnmCellbusXmtCellCount.setDescription('This objects is a count of cells transmitted by the BNM Cell Bus Master to the cell bus.')
bnmCellbusNoAckCellCount = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 3, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bnmCellbusNoAckCellCount.setStatus('mandatory')
if mibBuilder.loadTexts: bnmCellbusNoAckCellCount.setDescription('This object is a count of cells transmitted by the BNM Cell Bus Master to the cell bus for which no acknowledgement was received i.e the slave card was missing or inactive.')
bnmCellbusGrantCount = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 3, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bnmCellbusGrantCount.setStatus('mandatory')
if mibBuilder.loadTexts: bnmCellbusGrantCount.setDescription('This object is a count of receiver grants given by the BNM Cell Bus Master')
bnmEgressXmtCellCountDuringAlarm = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 3, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bnmEgressXmtCellCountDuringAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: bnmEgressXmtCellCountDuringAlarm.setDescription('This object is a count of cells transmitted by the Egress Engine to the port i while a T3 Alarm condition was in effect.')
bnmEgressInvalidCellCount = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 3, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bnmEgressInvalidCellCount.setStatus('mandatory')
if mibBuilder.loadTexts: bnmEgressInvalidCellCount.setDescription('This object is a count of cells with disabled channel headers, received by the Egress Engine on the BNM and dropped.')
bnmEgressInvalidCellHdr = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 3, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bnmEgressInvalidCellHdr.setStatus('mandatory')
if mibBuilder.loadTexts: bnmEgressInvalidCellHdr.setDescription('This object gives the header of the first invalid cell that was dropped by the Egress Engine on the BNM since this object was last read and/or cleared.')
bnmIngressInvalidCellCount = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 3, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bnmIngressInvalidCellCount.setStatus('mandatory')
if mibBuilder.loadTexts: bnmIngressInvalidCellCount.setDescription('This object is a count of cells from disabled channels received by the Ingress Engine on the BNM. This is not available in Release 1.')
bnmIngressInvalidCellHdr = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 3, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bnmIngressInvalidCellHdr.setStatus('mandatory')
if mibBuilder.loadTexts: bnmIngressInvalidCellHdr.setDescription('This object gives the header of the first invalid cell that was dropped by the Ingress Engine on the BNM since this object was last read and/or cleared. This is not available in Release 1.')
bnmCountersClrButton = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 3, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("bnmCountersNoAction", 1), ("bnmCountersClear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bnmCountersClrButton.setStatus('mandatory')
if mibBuilder.loadTexts: bnmCountersClrButton.setDescription('This object clears the BNM counters')
bnmLineInterfaceFormat = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 12, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("bnmSti", 1), ("bnmUni", 2), ("bnmNni", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bnmLineInterfaceFormat.setStatus('mandatory')
if mibBuilder.loadTexts: bnmLineInterfaceFormat.setDescription('This indicates the format of the cells going out on the BNM trunk For T3 and E3 cards its currently fixed at STI mode. BNM-155 sonet cards can take on UNI or NNI options')
pxmClockConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 3, 16))
pxmPrimaryMuxClockSource = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 16, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("pxmInbandClock1", 1), ("pxmServiceModuleClock1", 2), ("pxmTopSRMClock", 3), ("pxmExternalClock", 4), ("pxmInbandClock2", 5), ("pxmServiceModuleClock2", 6), ("pxmBottomSRMClock", 7), ("pxmInternalOscillator", 8), ("pxmExternalClock2", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pxmPrimaryMuxClockSource.setStatus('mandatory')
if mibBuilder.loadTexts: pxmPrimaryMuxClockSource.setDescription('Primary Mux Clock source for PXM card. For pxmInbandClock1 and pxmInbandClock2, the pxmPrimaryInbandClockSourceLineNumber described the Line number that the clock is derived from. For pxmServiceModuleClock1 and pxmServiceModuleClock2, the pxmPrimarySMClockSourceSlotNumber described the SM slot number For pxmExternalClock and pxmExternalClock2, pxmPrimaryExternalClockSourcePortNumber describes the Port number from where the clock is derived. Also the pxmExtClockPresent and pxmExtClkConnectorType are used with the pxmExternalClock. And pxmExtClock2Present and pxmExtClk2ConnectorType are used with pxmExternalClock2.')
pxmPrimaryInbandClockSourceLineNumber = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 16, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pxmPrimaryInbandClockSourceLineNumber.setStatus('mandatory')
if mibBuilder.loadTexts: pxmPrimaryInbandClockSourceLineNumber.setDescription('If pxmPrimaryMuxClockSource is pxmInbandClock1 (1) or pxmServiceModuleClock2 (5), then this entry indicates Inband Line number.')
pxmPrimarySMClockSourceSlotNumber = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 16, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pxmPrimarySMClockSourceSlotNumber.setStatus('mandatory')
if mibBuilder.loadTexts: pxmPrimarySMClockSourceSlotNumber.setDescription('If pxmPrimaryMuxClockSource is pxmServiceModuleClock1(2) or pxmServiceModuleClock2 (6), then this entry indicates SM slot number.')
pxmSecondaryMuxClockSource = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 16, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("pxmInbandClock1", 1), ("pxmServiceModuleClock1", 2), ("pxmTopSRMClock", 3), ("pxmExternalClock", 4), ("pxmInbandClock2", 5), ("pxmServiceModuleClock2", 6), ("pxmBottomSRMClock", 7), ("pxmInternalOscillator", 8), ("pxmExternalClock2", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pxmSecondaryMuxClockSource.setStatus('mandatory')
if mibBuilder.loadTexts: pxmSecondaryMuxClockSource.setDescription('Secondary clock source for PXM card. For pxmInbandClock1 and pxmInbandClock2, the pxmSecondaryInbandClockSourceLineNumber described the Line number that the clock is derived from. For pxmServiceModuleClock1 and pxmServiceModuleClock2, the pxmSecondarySMClockSourceSlotNumber described the SM slot number pxmSecondaryExternalClockSourcePortNumber describes the Port number from where the clock is derived. Also the pxmExtClockPresent and pxmExtClkConnectorType are used with the pxmExternalClock. And pxmExtClockPresent2 and pxmExtClkConnectorType2 are used with pxmExternalClock2.')
pxmSecondaryInbandClockSourceLineNumber = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 16, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pxmSecondaryInbandClockSourceLineNumber.setStatus('mandatory')
if mibBuilder.loadTexts: pxmSecondaryInbandClockSourceLineNumber.setDescription('If pxmSecondaryMuxClockSource is pxmInbandClock1 (1) or pxmServiceModuleClock2 (5), then this entry indicates Inband Line number .')
pxmSecondarySMClockSourceSlotNumber = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 16, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pxmSecondarySMClockSourceSlotNumber.setStatus('mandatory')
if mibBuilder.loadTexts: pxmSecondarySMClockSourceSlotNumber.setDescription('If pxmSecondaryMuxClockSource is pxmServiceModuleClock1(2) or pxmServiceModuleClock2 (6), then this entry indicates SM slot number .')
pxmCurrentClock = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 16, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("primary", 1), ("secondary", 2), ("intOscillator", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pxmCurrentClock.setStatus('mandatory')
if mibBuilder.loadTexts: pxmCurrentClock.setDescription('Clock source currently selected for PXM card. If the pxmCurrentClock is primary then the pxmPrimaryMuxClockSource described further the source of the clock. If the pxmCurrentClock is secondary then the pxmSecondaryMuxClockSource described further the source of the clock.')
pxmPreviousClock = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 16, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("primary", 1), ("secondary", 2), ("intOscillator", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pxmPreviousClock.setStatus('mandatory')
if mibBuilder.loadTexts: pxmPreviousClock.setDescription('Clock source Previously selected for PXM card.')
pxmExtClockPresent = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 16, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clkNotPresent", 1), ("clkPresent", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pxmExtClockPresent.setStatus('mandatory')
if mibBuilder.loadTexts: pxmExtClockPresent.setDescription('Status of External T1/E1 Clock on PXM card.')
pxmExtClkSrcImpedance = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 16, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ohms75", 1), ("ohms100", 2), ("ohms120", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pxmExtClkSrcImpedance.setStatus('mandatory')
if mibBuilder.loadTexts: pxmExtClkSrcImpedance.setDescription('Impedance on external clock input for PXM card.')
pxmExtClkConnectorType = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 16, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("rj45Type", 1), ("smbType", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pxmExtClkConnectorType.setStatus('mandatory')
if mibBuilder.loadTexts: pxmExtClkConnectorType.setDescription('This object describes the type of connector available for connecting the external clock source to the PXM-LM.')
pxmClkStratumLevel = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 16, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("stratumUnknown", 1), ("stratumLevel1", 2), ("stratumLevel2", 3), ("stratumLevel3E", 4), ("stratumLevel3", 5), ("stratumLevel4", 6), ("stratumLevel4E", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pxmClkStratumLevel.setStatus('mandatory')
if mibBuilder.loadTexts: pxmClkStratumLevel.setDescription('This object describes the lowest stratum level provided by the interface the external clock source to the PXM-LM.')
pxmClkErrReason = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 16, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("goodClk", 1), ("unknownReason", 2), ("noClkSignal", 3), ("freqTooHigh", 4), ("freqTooLow", 5), ("excessiveJitter", 6), ("missingCard", 7), ("missingLogicalIf", 8), ("noClock", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pxmClkErrReason.setStatus('mandatory')
if mibBuilder.loadTexts: pxmClkErrReason.setDescription('This object gives more information about clock status (if known).')
pxmExtClock2Present = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 16, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clkNotPresent", 1), ("clkPresent", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pxmExtClock2Present.setStatus('mandatory')
if mibBuilder.loadTexts: pxmExtClock2Present.setDescription('Status of External T1/E1 Clock on port 2 of UI-S3 back card of PXM card.')
pxmExtClk2SrcImpedance = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 16, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ohms75", 1), ("ohms100", 2), ("ohms120", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pxmExtClk2SrcImpedance.setStatus('mandatory')
if mibBuilder.loadTexts: pxmExtClk2SrcImpedance.setDescription('Impedance on external clock input on port 2 of UI-S3 back card of PXM card.')
pxmExtClk2ConnectorType = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 16, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("rj45Type", 1), ("smbType", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pxmExtClk2ConnectorType.setStatus('mandatory')
if mibBuilder.loadTexts: pxmExtClk2ConnectorType.setDescription('This object describes the type of connector available for connecting the external clock source to the port 2 of UI-S3 back card of PXM-LM.')
ascFeatures = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 3, 5))
redundancyAllowed = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 5, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("redNotAllowed", 1), ("redAllowed", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: redundancyAllowed.setStatus('mandatory')
if mibBuilder.loadTexts: redundancyAllowed.setDescription('BRAM parameter indicating whether redundancy is allowed in this shelf. ')
coreCardCommands = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 3, 20))
switchCoreCard = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 20, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("noAction", 1), ("doswitchcc", 2), ("instswitchcc", 3), ("fallbackswitchcc", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: switchCoreCard.setStatus('mandatory')
if mibBuilder.loadTexts: switchCoreCard.setDescription('A SwitchCC command either to invoke switchcc or take noAction on the Core Card Set ')
ascChanStateSigLmiGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 3, 4, 3))
ascChanStateSigLmiGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 3, 4, 3, 1), )
if mibBuilder.loadTexts: ascChanStateSigLmiGrpTable.setStatus('mandatory')
if mibBuilder.loadTexts: ascChanStateSigLmiGrpTable.setDescription('The ATM LMI Channel State table ')
ascChanStateSigLmiGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 3, 4, 3, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "ascLmiVccLineNum"), (0, "CISCO-WAN-AXIPOP-MIB", "ascLmiVccVpi"), (0, "CISCO-WAN-AXIPOP-MIB", "ascLmiVccVci"))
if mibBuilder.loadTexts: ascChanStateSigLmiGrpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ascChanStateSigLmiGrpEntry.setDescription(' An entry for a Channel ')
ascLmiVccLineNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 4, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("lineNum", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ascLmiVccLineNum.setStatus('mandatory')
if mibBuilder.loadTexts: ascLmiVccLineNum.setDescription('Refers to the line number ')
ascLmiVccVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 4, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 14))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ascLmiVccVpi.setStatus('mandatory')
if mibBuilder.loadTexts: ascLmiVccVpi.setDescription('Refers to the Virtual Path Indicator ')
ascLmiVccVci = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 4, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 271))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ascLmiVccVci.setStatus('mandatory')
if mibBuilder.loadTexts: ascLmiVccVci.setDescription('Refers to the Virtual Channel Indicator ')
ascLmiXmtAbitState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 4, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ascLmiXmtAbitState.setStatus('mandatory')
if mibBuilder.loadTexts: ascLmiXmtAbitState.setDescription('This is the transmit A bit state 0 - A bit clear = not active 1 - A bit set = active ')
ascLmiRcvAbitState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 4, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ascLmiRcvAbitState.setStatus('mandatory')
if mibBuilder.loadTexts: ascLmiRcvAbitState.setDescription('This is the receive A bit state 0 - A bit clear = not active 1 - A bit set = active ')
ascLineCnfSigLmiGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 3, 4, 1))
ascCnfSigLmiGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 3, 4, 1, 1), )
if mibBuilder.loadTexts: ascCnfSigLmiGrpTable.setStatus('mandatory')
if mibBuilder.loadTexts: ascCnfSigLmiGrpTable.setDescription('The config table is for DS3 line interface ')
ascCnfSigLmiGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 3, 4, 1, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "ascLmiCnfLineNum"))
if mibBuilder.loadTexts: ascCnfSigLmiGrpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ascCnfSigLmiGrpEntry.setDescription(' An entry for logical line ')
ascLmiCnfLineNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 4, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("lmiCnflineNum", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ascLmiCnfLineNum.setStatus('mandatory')
if mibBuilder.loadTexts: ascLmiCnfLineNum.setDescription('Refers to the logical line index ')
ascLmiVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 4, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3))).clone(namedValues=NamedValues(("lmiVpi", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ascLmiVpi.setStatus('mandatory')
if mibBuilder.loadTexts: ascLmiVpi.setDescription('VPI used for ATM LMI signalling ')
ascLmiVci = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 4, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(31))).clone(namedValues=NamedValues(("lmiVci", 31)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ascLmiVci.setStatus('mandatory')
if mibBuilder.loadTexts: ascLmiVci.setDescription('VCI used for ATM LMI signalling ')
ascLmiEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 4, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("disable", 1), ("atmLmiEnable", 2), ("atmLmiwithExtEnable", 3), ("atmLmiEnhManualRecovery", 4), ("atmLmiEnhAutoRecovery", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ascLmiEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: ascLmiEnabled.setDescription('This will enable ATM LMI signalling, or ATM LMI with the Node Status Extensions ')
ascLmiPollingEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 4, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ascLmiPollingEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: ascLmiPollingEnabled.setDescription('This will enable ATM LMI polling ')
ascLmiPollingInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 4, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ascLmiPollingInterval.setStatus('mandatory')
if mibBuilder.loadTexts: ascLmiPollingInterval.setDescription('Status Enq Polling Interval in seconds Default is 10 seconds ')
ascLmiTimerT393 = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 4, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ascLmiTimerT393.setStatus('mandatory')
if mibBuilder.loadTexts: ascLmiTimerT393.setDescription('Status Enq timeout interval in seconds Default is 10 seconds ')
ascLmiTimerT394 = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 4, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ascLmiTimerT394.setStatus('mandatory')
if mibBuilder.loadTexts: ascLmiTimerT394.setDescription('Update Status timeout interval in seconds Default is 10 seconds ')
ascLmiMaxRetryN394 = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 4, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ascLmiMaxRetryN394.setStatus('mandatory')
if mibBuilder.loadTexts: ascLmiMaxRetryN394.setDescription('Status Enq maximum retry count Default is 3 ')
ascLmiMaxRetryN395 = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 4, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ascLmiMaxRetryN395.setStatus('mandatory')
if mibBuilder.loadTexts: ascLmiMaxRetryN395.setDescription('Update Status maximum retry count Default is 3 ')
ascLmiOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 4, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("atmLmiFailed", 1), ("atmLmiActive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ascLmiOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ascLmiOperStatus.setDescription('Operational status ')
ascCntSigLmiGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 3, 4, 2))
ascCntSigLmiGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 3, 4, 2, 1), )
if mibBuilder.loadTexts: ascCntSigLmiGrpTable.setStatus('mandatory')
if mibBuilder.loadTexts: ascCntSigLmiGrpTable.setDescription('The counter table is for DS3 line interface ')
ascCntSigLmiGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 3, 4, 2, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "ascLmiCntLineNum"))
if mibBuilder.loadTexts: ascCntSigLmiGrpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ascCntSigLmiGrpEntry.setDescription(' An entry for logical line ')
ascLmiCntLineNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 4, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("lmiCntLineNum", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ascLmiCntLineNum.setStatus('mandatory')
if mibBuilder.loadTexts: ascLmiCntLineNum.setDescription('Refers to the logical line index ')
ascLmiStatusTx = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 4, 2, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ascLmiStatusTx.setStatus('mandatory')
if mibBuilder.loadTexts: ascLmiStatusTx.setDescription('The number of Status PDUs transmitted ')
ascLmiStatusEnqTx = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 4, 2, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ascLmiStatusEnqTx.setStatus('mandatory')
if mibBuilder.loadTexts: ascLmiStatusEnqTx.setDescription('The number of Status Enquiry PDUs transmitted ')
ascLmiStatusAckTx = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 4, 2, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ascLmiStatusAckTx.setStatus('mandatory')
if mibBuilder.loadTexts: ascLmiStatusAckTx.setDescription('The number of Status Ack PDUs transmitted ')
ascLmiUpdateStatusTx = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 4, 2, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ascLmiUpdateStatusTx.setStatus('mandatory')
if mibBuilder.loadTexts: ascLmiUpdateStatusTx.setDescription('The number of Update Status PDUs transmitted ')
ascLmiStatusRx = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 4, 2, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ascLmiStatusRx.setStatus('mandatory')
if mibBuilder.loadTexts: ascLmiStatusRx.setDescription('The number of Status PDUs received ')
ascLmiStatusEnqRx = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 4, 2, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ascLmiStatusEnqRx.setStatus('mandatory')
if mibBuilder.loadTexts: ascLmiStatusEnqRx.setDescription('The number of Status Enquiry PDUs received ')
ascLmiStatusAckRx = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 4, 2, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ascLmiStatusAckRx.setStatus('mandatory')
if mibBuilder.loadTexts: ascLmiStatusAckRx.setDescription('The number of Status Ack PDUs received ')
ascLmiUpdateStatusRx = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 4, 2, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ascLmiUpdateStatusRx.setStatus('mandatory')
if mibBuilder.loadTexts: ascLmiUpdateStatusRx.setDescription('The number of Update Status PDUs received ')
ascLmiInvalidPduRx = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 4, 2, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ascLmiInvalidPduRx.setStatus('mandatory')
if mibBuilder.loadTexts: ascLmiInvalidPduRx.setDescription('The number of Invalid PDUs received. These are PDUs with invalid SSCOP or Q.2931 header, or invalid Protocol Discriminator ')
ascLmiInvalidPduLenRx = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 4, 2, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ascLmiInvalidPduLenRx.setStatus('mandatory')
if mibBuilder.loadTexts: ascLmiInvalidPduLenRx.setDescription('The number of PDUs received with invalid length. ATM LMI PDU Length field plus Q.2931 Header length does not equal actual message length ')
ascLmiUnknownPduRx = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 4, 2, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ascLmiUnknownPduRx.setStatus('mandatory')
if mibBuilder.loadTexts: ascLmiUnknownPduRx.setDescription('The number of PDUs with unknown Message Type received ')
ascLmiInvalidIeRx = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 4, 2, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ascLmiInvalidIeRx.setStatus('mandatory')
if mibBuilder.loadTexts: ascLmiInvalidIeRx.setDescription('The number of PDUs received with invalid Information Elements. This includes IEs with invalid length and missing mandatory IEs ')
ascLmiInvalidTransaction = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 4, 2, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ascLmiInvalidTransaction.setStatus('mandatory')
if mibBuilder.loadTexts: ascLmiInvalidTransaction.setDescription('The number of invalid transactions. The transaction number of a transmitted Update Status PDU does not match the transaction number of the corresponding received Status Ack PDU, or, the transaction number of a transmitted Status Enq PDU does not match the transaction number of the corresponding received Status PDU. ')
ascLmiTimeoutFailure = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 4, 2, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ascLmiTimeoutFailure.setStatus('mandatory')
if mibBuilder.loadTexts: ascLmiTimeoutFailure.setDescription('The number of timeout failures ')
ascLmiNodeStatusTx = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 4, 2, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ascLmiNodeStatusTx.setStatus('mandatory')
if mibBuilder.loadTexts: ascLmiNodeStatusTx.setDescription('The number of Node Status PDUs transmitted ')
ascLmiNodeStatusAckTx = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 4, 2, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ascLmiNodeStatusAckTx.setStatus('mandatory')
if mibBuilder.loadTexts: ascLmiNodeStatusAckTx.setDescription('The number of Node Status Ack PDUs transmitted ')
ascLmiNodeStatusRx = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 4, 2, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ascLmiNodeStatusRx.setStatus('mandatory')
if mibBuilder.loadTexts: ascLmiNodeStatusRx.setDescription('The number of Node Status PDUs received ')
ascLmiNodeStatusAckRx = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 4, 2, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ascLmiNodeStatusAckRx.setStatus('mandatory')
if mibBuilder.loadTexts: ascLmiNodeStatusAckRx.setDescription('The number of Node Status Ack PDUs received ')
pxmFeatures = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 3, 15))
vsiControllersAllowed = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 15, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsiControllersAllowed.setStatus('mandatory')
if mibBuilder.loadTexts: vsiControllersAllowed.setDescription('This respesents bit map of the VSI Controllers supported. Currently, we have BIT 0 - PAR BIT 1 - PNNI BIT 2 - TAG (e.g. A value of 1 in BIT 0 indicates the presence of PAR ) Remaining bits are set to 0. ')
apsCardAttributes = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 15, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apsCardAttributes.setStatus('mandatory')
if mibBuilder.loadTexts: apsCardAttributes.setDescription('This respesents bit map of the APS card attributes supported. Currently, we have BIT 0, 1 - unused BIT 2 - APS standard protocol configured (1 = TRUE ; 0 = FALSE) BIT 3, 4 ,5 - unused BIT 6 - Card HW supports APS 1+1 on two cards (1 = TRUE ; 0 = FALSE) BIT 7 - Card FW supports APS (1 = TRUE ; 0 = FALSE) Remaining bits are set to 0. ')
trkCACEnable = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 15, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trkCACEnable.setStatus('mandatory')
if mibBuilder.loadTexts: trkCACEnable.setDescription('This MIB variable allows one to add a new connection on the feeder trunk even if it is over-subscribed. ')
pxmAtmMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 16))
pxmAtmVcCrossConnectIndexNext = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 16, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pxmAtmVcCrossConnectIndexNext.setStatus('mandatory')
if mibBuilder.loadTexts: pxmAtmVcCrossConnectIndexNext.setDescription('This object contains an appropriate value to be used for pxmAtmVcCrossConnectIndex when creating entries in the pxmAtmVcCrossConnectTable. The value 0 indicates that no unassigned entries are available. To obtain the pxmAtmVpCrossConnectIndex value for a new entry, the manager issues a management protocol retrieval operation to obtain the current value of this object. After each retrieval, the agent should modify the value to the next unassigned index.')
pxmAtmVcCrossConnectTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 16, 11), )
if mibBuilder.loadTexts: pxmAtmVcCrossConnectTable.setStatus('mandatory')
if mibBuilder.loadTexts: pxmAtmVcCrossConnectTable.setDescription('The ATM VC Cross Connect table. A bi- directional VC cross-connect which cross-connects two end points (i.e., VCLs) is modeled as one entry in this table.')
pxmAtmVcCrossConnectEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 16, 11, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "pxmAtmVcCrossConnectIndex"), (0, "CISCO-WAN-AXIPOP-MIB", "pxmAtmVcCrossConnectLowIfIndex"), (0, "CISCO-WAN-AXIPOP-MIB", "pxmAtmVcCrossConnectLowVpi"), (0, "CISCO-WAN-AXIPOP-MIB", "pxmAtmVcCrossConnectLowVci"), (0, "CISCO-WAN-AXIPOP-MIB", "pxmAtmVcCrossConnectHighIfIndex"), (0, "CISCO-WAN-AXIPOP-MIB", "pxmAtmVcCrossConnectHighVpi"), (0, "CISCO-WAN-AXIPOP-MIB", "pxmAtmVcCrossConnectHighVci"))
if mibBuilder.loadTexts: pxmAtmVcCrossConnectEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pxmAtmVcCrossConnectEntry.setDescription('An entry in the ATM VC Cross Connect table. This entry is used to model a bi-directional ATM VC cross-connect cross-connecting two end points. Step-wise Procedures to set up a VC Cross-connect Once the entries in the pxmAtmVclTable are created, the following procedures are used to cross-connect the VCLs together to form a VCC segment. (1) The manager obtains a unique pxmAtmVcCrossConnectIndex by reading the pxmAtmVcCrossConnectIndexNext object. (2) Next, the manager creates a set of one or more rows in the ATM VC Cross Connect Table, one for each cross-connection between two VCLs. Each row is indexed by the ATM interface port numbers and VPI/VCI values of the two ends of that cross-connection. This set of rows specifies the topology of the VCC cross-connect and is identified by a single value of pxmAtmVcCrossConnectIndex. Negotiated VC Cross-Connect Establishment (2a) The manager creates a row in this table by setting pxmAtmVcCrossConnectRowStatus to createAndWait(5). The agent checks the requested topology and the mutual sanity of the ATM traffic parameters and QoS Classes, i.e., the row creation fails if: - the requested topology is not supported by the agent, - the traffic/QoS parameter values associated with the requested row are incompatible with those of already existing rows for this VC cross-connect. [For example, for setting up a point-to-point VC cross-connect, the ATM traffic parameters in the receive direction of a VCL at the low end of the cross-connect must equal to the traffic parameters in the transmit direction of the other VCL at the high end of the cross-connect, otherwise, the row creation fails.] The agent also checks for internal errors in building the cross-connect. The pxmAtmVcCrossConnectIndex values in the corresponding pxmAtmVclTable rows are filled in by the agent at this point. (2b) The manager promotes the row in the pxmAtmVcCrossConnectTable by setting pxmAtmVcCrossConnectRowStatus to active(1). If this set is successful, the agent has reserved the resources specified by the ATM traffic parameter and QoS Class values for each direction of the VC cross-connect in an ATM switch or network. (3) The manager sets the pxmAtmVcCrossConnectAdminStatus to up(1) in all rows of this VC cross-connect to turn the traffic flow on. One-Shot VC Cross-Connect Establishment A VC cross-connect may also be established in one step by a set-request with all necessary parameter values and pxmAtmVcCrossConnectRowStatus set to createAndGo(4). In contrast to the negotiated VC cross-connect establishment which allows for detailed error checking i.e., set errors are explicitly linked to particular resource acquisition failures), the one-shot VC cross-connect establishment performs the setup on one operation but does not have the advantage of step-wise error checking. VC Cross-Connect Retirement A VC cross-connect identified by a particular value of pxmAtmVcCrossConnectIndex is released by: (1) Setting pxmAtmVcCrossConnectRowStatus of all rows identified by this value of pxmAtmVcCrossConnectIndex to destroy(6). The agent may release all associated resources, and the pxmAtmVcCrossConnectIndex values in the corresponding pxmAtmVclTable row are removed. Note that a situation when only a subset of the associated rows are deleted corresponds to a VC topology change. (2) After deletion of the appropriate pxmAtmVcCrossConnectEntries, the manager may set pxmAtmVclRowStatus to destroy(6) the associated VCLs. The agent releases the resources and removes the associated rows in the pxmAtmVclTable. VC Cross-Connect Reconfiguration At the discretion of the agent, a VC cross-connect may be reconfigured by adding and/or deleting leafs to/from the VC topology as per the VC cross-connect establishment/retirement procedures. Reconfiguration of traffic/QoS parameter values requires release of the VC cross-connect before those parameter values may by changed for individual VCLs.')
pxmAtmVcCrossConnectIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 16, 11, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pxmAtmVcCrossConnectIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pxmAtmVcCrossConnectIndex.setDescription('A unique value to identify this VC cross-connect.')
pxmAtmVcCrossConnectLowIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 16, 11, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pxmAtmVcCrossConnectLowIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pxmAtmVcCrossConnectLowIfIndex.setDescription("The value of this object is equal to MIB II's ifIndex value of the ATM interface port for this VC cross-connect. The term low implies that this ATM interface has the numerically lower ifIndex value than the other ATM interface identified in the same pxmAtmVcCrossConnectEntry.")
pxmAtmVcCrossConnectLowVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 16, 11, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pxmAtmVcCrossConnectLowVpi.setStatus('mandatory')
if mibBuilder.loadTexts: pxmAtmVcCrossConnectLowVpi.setDescription('The value of this object is equal to the VPI value at the ATM interface associated with the VC cross-connect that is identified by pxmAtmVcCrossConnectLowIfIndex. The VPI value cannot exceed the number supported by the pxmAtmInterfaceMaxVpiBits at the low ATM interface port.')
pxmAtmVcCrossConnectLowVci = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 16, 11, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pxmAtmVcCrossConnectLowVci.setStatus('mandatory')
if mibBuilder.loadTexts: pxmAtmVcCrossConnectLowVci.setDescription('The value of this object is equal to the VCI value at the ATM interface associated with this VC cross-connect that is identified by pxmAtmVcCrossConnectLowIfIndex. The VCI value cannot exceed the number supported by the pxmAtmInterfaceMaxVciBits at the low ATM interface port.')
pxmAtmVcCrossConnectHighIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 16, 11, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pxmAtmVcCrossConnectHighIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pxmAtmVcCrossConnectHighIfIndex.setDescription("The value of this object is equal to MIB II's ifIndex value for the ATM interface port for this VC cross-connect. The term high implies that this VC cross-connect that this ATM interface has the numerically higher ifIndex value than the other ATM interface identified in the same pxmAtmVcCrossConnectEntry.")
pxmAtmVcCrossConnectHighVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 16, 11, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pxmAtmVcCrossConnectHighVpi.setStatus('mandatory')
if mibBuilder.loadTexts: pxmAtmVcCrossConnectHighVpi.setDescription('The value of this object is equal to the VPI value at the ATM interface associated with the VC cross-connect that is identified by pxmAtmVcCrossConnectHighIfIndex. The VPI value cannot exceed the number supported by the pxmAtmInterfaceMaxVpiBits at the high ATM interface port.')
pxmAtmVcCrossConnectHighVci = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 16, 11, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pxmAtmVcCrossConnectHighVci.setStatus('mandatory')
if mibBuilder.loadTexts: pxmAtmVcCrossConnectHighVci.setDescription('The value of this object is equal to the VCI value at the ATM interface associated with the VC cross-connect that is identified by pxmAtmVcCrossConnectHighIfIndex. The VCI value cannot exceed the number supported by the pxmAtmInterfaceMaxVciBits at the high ATM interface port.')
pxmAtmVcCrossConnectAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 16, 11, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2))).clone('down')).setMaxAccess("readonly")
if mibBuilder.loadTexts: pxmAtmVcCrossConnectAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: pxmAtmVcCrossConnectAdminStatus.setDescription('The value of this object identifies the desired administrative status of this bi-directional VC cross-connect. The up and down states indicate that the traffic flow is enabled or disabled respectively on this VC cross-connect.')
pxmAtmVcCrossConnectL2HOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 16, 11, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("unknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pxmAtmVcCrossConnectL2HOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: pxmAtmVcCrossConnectL2HOperStatus.setDescription('The value of this object identifies the current operational status of the VC cross-connect in one direction; (i.e., from the low to high direction). The up and down states indicate that this ATM VC cross-connect from low to high direction is operational or not operational respectively. The unknown state indicates that the state of it cannot be determined.')
pxmAtmVcCrossConnectH2LOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 16, 11, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("unknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pxmAtmVcCrossConnectH2LOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: pxmAtmVcCrossConnectH2LOperStatus.setDescription('The value of this object identifies the current operational status of the VC cross-connect in one direction; (i.e., from the high to low direction). The up and down states indicate that this ATM VC cross-connect from high to low direction is operational or not operational respectively. The unknown state indicates that the state of it cannot be determined.')
pxmAtmVcCrossConnectL2HLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 16, 11, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pxmAtmVcCrossConnectL2HLastChange.setStatus('mandatory')
if mibBuilder.loadTexts: pxmAtmVcCrossConnectL2HLastChange.setDescription("The value of MIB II's sysUpTime object at the time this VC cross-connect entered its current operational state in low to high direction. If the current state was entered prior to the last re-initialization of the agent, then this object contains a zero value.")
pxmAtmVcCrossConnectH2LLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 16, 11, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pxmAtmVcCrossConnectH2LLastChange.setStatus('mandatory')
if mibBuilder.loadTexts: pxmAtmVcCrossConnectH2LLastChange.setDescription("The value of MIB II's sysUpTime object at the time this VC cross-connect entered its current operational state in high to low direction. If the current state was entered prior to the last re-initialization of the agent, then this object contains a zero value.")
pxmAtmVcCrossConnectRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 16, 11, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pxmAtmVcCrossConnectRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: pxmAtmVcCrossConnectRowStatus.setDescription("The status of this entry in the pxmAtmVcCrossConnectTable. This object is used to create a new cross-connect for cross-connecting VCLs which are created using the pxmAtmVclTable or to change or delete existing cross-connect. This object must be initially set to `createAndWait' or `createAndGo'. This object cannot be set to `active' unless the following columnar object exists in this row: pxmAtmVcCrossConnectAdminStatus. To turn on a VC cross-connect, the pxmAtmVcCrossConnectAdminStatus is set to `up'.")
pxmAtmVcCrossConnectHighAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 16, 11, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("atmUni", 1), ("atmNni", 2), ("frameRelay", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pxmAtmVcCrossConnectHighAddressType.setStatus('mandatory')
if mibBuilder.loadTexts: pxmAtmVcCrossConnectHighAddressType.setDescription('The value of this object identifies the address type of the interface associated with the VC cross-connect that is identified by pxmAtmVcCrossConnectHighIfIndex. If the address type is pxmAtmUni, the first 4 bits of the VPI field is the GFCI and the remaing 12 bits of the VPI field is the VPI. If the address type is pxmAtmNni, the whole 16 bits of the VPI is the VPI. If the address type is the frameRelay, the combination of the VPI field and the VCI field are the DLCI.')
pxmAtmVcCrossConnectLowAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 16, 11, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("atmUni", 1), ("atmNni", 2), ("frameRelay", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pxmAtmVcCrossConnectLowAddressType.setStatus('mandatory')
if mibBuilder.loadTexts: pxmAtmVcCrossConnectLowAddressType.setDescription('The value of this object identifies the address type of the interface associated with the VC cross-connect that is identified by pxmAtmVcCrossConnectLowIfIndex. If the address type is pxmAtmUni, the first 4 bits of the VPI field is the GFCI and the remaing 12 bits of the VPI field is the VPI. If the address type is pxmAtmNni, the whole 16 bits of the VPI is the VPI. If the address type is the frameRelay, the combination of the VPI field and the VCI field are the DLCI.')
atmLineCnfTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 5, 1, 1), )
if mibBuilder.loadTexts: atmLineCnfTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmLineCnfTable.setDescription(' The ATM Line config table is for the physical interface. There will an entry for each of the physical line. ')
atmLineCnfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 5, 1, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "atmLineCnfNum"))
if mibBuilder.loadTexts: atmLineCnfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmLineCnfEntry.setDescription(' An entry for the physical interface. ')
atmLineCnfNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 5, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLineCnfNum.setStatus('mandatory')
if mibBuilder.loadTexts: atmLineCnfNum.setDescription(' Refers to the phsical line number, PXM port will have a maximum of 4 lines. ')
atmLineInterfaceFormat = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 5, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("atmUni", 2), ("atmNni", 3))).clone('atmUni')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmLineInterfaceFormat.setStatus('mandatory')
if mibBuilder.loadTexts: atmLineInterfaceFormat.setDescription(' This indicates the format of the cells going out on the physical interface ')
atmLineCntTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 5, 2, 1), )
if mibBuilder.loadTexts: atmLineCntTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmLineCntTable.setDescription(' The ATM Line count table is for the physical interface. There will an entry for each of the physical line. ')
atmLineCntEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 5, 2, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "atmLineNum"))
if mibBuilder.loadTexts: atmLineCntEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmLineCntEntry.setDescription(' An entry for the physical interface. These are counts which are collected on a physical line basis. ')
atmLineNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 5, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLineNum.setStatus('mandatory')
if mibBuilder.loadTexts: atmLineNum.setDescription(' Refers to the phsical line number, PXM port will have a maximum of 4 lines. ')
atmLineTotalRcvCells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 5, 2, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLineTotalRcvCells.setStatus('mandatory')
if mibBuilder.loadTexts: atmLineTotalRcvCells.setDescription(' The number of cells received in Ingress direction. ')
atmLineTotalXmtCells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 5, 2, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLineTotalXmtCells.setStatus('mandatory')
if mibBuilder.loadTexts: atmLineTotalXmtCells.setDescription(' The number of cells transmitted in the egress direction ')
atmLineRcvHecErrorCells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 5, 2, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmLineRcvHecErrorCells.setStatus('mandatory')
if mibBuilder.loadTexts: atmLineRcvHecErrorCells.setDescription(' Number of cells with HEC error ')
atmLineCntClrButton = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 5, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noAction", 1), ("resetCounters", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmLineCntClrButton.setStatus('mandatory')
if mibBuilder.loadTexts: atmLineCntClrButton.setDescription(' writing a value of 2 resets all the counters ')
bbIfCnfPortGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 1, 1))
bbIfCnfPortGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 1, 1, 1), )
if mibBuilder.loadTexts: bbIfCnfPortGrpTable.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfCnfPortGrpTable.setDescription(' The Broadband Interface config table is for logical interface. There will an entry for each of the logical partition of the physical line. ')
bbIfCnfPortGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 1, 1, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "bbIfNum"))
if mibBuilder.loadTexts: bbIfCnfPortGrpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfCnfPortGrpEntry.setDescription(' An entry for the logical interface. The interface may be further be configured to be used as a virtual trunk OR as a UNI Port. ')
bbIfNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 1, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bbIfNum.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfNum.setDescription(' This is logical interface number within a physical line num. In MGX PXM card, a physical port can have a maximum of 32 logical interfaces. ')
bbIfRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 1, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("add", 1), ("del", 2), ("mod", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbIfRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfRowStatus.setDescription(' This variable enables or disables the logical interface. 1 - enable 2 - disable 3 - modify ')
bbIfAdmin = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 1, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("writeOnly", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbIfAdmin.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfAdmin.setDescription(' This variable enables or disables the logical interface. 1 - up 2 - down 3 - writeOnly ')
bbIfLineNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 1, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbIfLineNum.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfLineNum.setDescription(' The line number associated with the logical interface. For PXM, there is currently 4 physical lines. ')
bbIfIngrPctBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 1, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbIfIngrPctBandwidth.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfIngrPctBandwidth.setDescription(' The percentage of aggregate physical line bandwidth, available for this broadband interface - Ingress. Default is 0 % ')
bbIfEgrPctBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 1, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbIfEgrPctBandwidth.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfEgrPctBandwidth.setDescription(' The percentage of aggregate physical line bandwidth, available for this broadband interface - Egress . Default is 0 % ')
bbIfMinVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 1, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbIfMinVpi.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfMinVpi.setDescription(' The lower limit of VPI range to be reserved for this logical interface. ')
bbIfMaxVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 1, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbIfMaxVpi.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfMaxVpi.setDescription(' The upper limit of VPI range to be reserved for this logical interface. For virtual trunks, bbIfMinVpi and bbIfMaxVpi should be the same. ')
bbIfSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 1, 1, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bbIfSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfSpeed.setDescription(' The speed of the port in cells per second ')
bbIfMaxCellRatePct = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 1, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbIfMaxCellRatePct.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfMaxCellRatePct.setDescription(' The maximum cell rate allowed for the port in terms of percentage. Must be greater than or equal to bbIfIngrPctBandwidth. The default is 100 percent. ')
nextBbIfNumAvailable = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nextBbIfNumAvailable.setStatus('mandatory')
if mibBuilder.loadTexts: nextBbIfNumAvailable.setDescription(' Indicates the next logical broadband interface number that is available ')
bbIfCnfRscPartGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 2, 1), )
if mibBuilder.loadTexts: bbIfCnfRscPartGrpTable.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfCnfRscPartGrpTable.setDescription(' The config table is for logical port interface There can be 32 entries for PXM card in MGX. ')
bbIfCnfRscPartGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 2, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "bbRscPartIfNum"), (0, "CISCO-WAN-AXIPOP-MIB", "bbRscPartCtrlrNum"))
if mibBuilder.loadTexts: bbIfCnfRscPartGrpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfCnfRscPartGrpEntry.setDescription(' An entry for a logical interface ')
bbRscPartIfNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bbRscPartIfNum.setStatus('mandatory')
if mibBuilder.loadTexts: bbRscPartIfNum.setDescription(' This is logical interface number. ')
bbRscPartCtrlrNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("par", 1), ("pnni", 2), ("tag", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bbRscPartCtrlrNum.setStatus('mandatory')
if mibBuilder.loadTexts: bbRscPartCtrlrNum.setDescription(' This is index for controller using the interface . 1 - PAR 2 - PNNI 3 - TAG ')
bbIfRscPrtRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("add", 1), ("del", 2), ("mod", 3))).clone('del')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbIfRscPrtRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfRscPrtRowStatus.setDescription(' This will add, delete or modify the partition. 1 ==> ADD 2 ==> DELETE 3 ==> MODIFY ')
bbIfRscPrtInUse = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("inUse", 1), ("notInUse", 2))).clone('notInUse')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbIfRscPrtInUse.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfRscPrtInUse.setDescription(' Setting this object to 1 indicates that the resources (LCN/Local VPID/VCI/VPI) have been partitioned and INS, network ctrlrs.,SV+ are currently using this information. The resource partition information can be changed after setting this variable to 2. The default value is 2 (NotInUse). ')
bbIfRscPrtIngrPctBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbIfRscPrtIngrPctBandwidth.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfRscPrtIngrPctBandwidth.setDescription(' The percentage of logical interface bandwidth ( bbIfIngrPctBandwidth ), available for UNI channels. ')
bbIfRscPrtEgrPctBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbIfRscPrtEgrPctBandwidth.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfRscPrtEgrPctBandwidth.setDescription(' The percentage of logical interface bandwidth ( bbIfIngrPctBandwidth ), available for UNI channels. ')
bbIfRscPrtVpiLow = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbIfRscPrtVpiLow.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfRscPrtVpiLow.setDescription(' The beginning of the VPI range reserved for this partition. ')
bbIfRscPrtVpiHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbIfRscPrtVpiHigh.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfRscPrtVpiHigh.setDescription(' The end of the VPI range reserved for this partition. ')
bbIfRscPrtVciLow = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbIfRscPrtVciLow.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfRscPrtVciLow.setDescription(' The beginning of the VCI range reserved for this partition. This field is only valid for logical interfaces configured with a single VPI. ')
bbIfRscPrtVciHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbIfRscPrtVciHigh.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfRscPrtVciHigh.setDescription(' The end of the VCI range reserved for this partition. This field is only valid for logical interfaces configured with a single VPI. ')
bbIfRscPrtVpidLow = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 2, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbIfRscPrtVpidLow.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfRscPrtVpidLow.setDescription(' The beginning of the VPID range reserved for partition. Used for VP conn.s ')
bbIfRscPrtVpidHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 2, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbIfRscPrtVpidHigh.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfRscPrtVpidHigh.setDescription(' The end of the VPID range reserved for partition. Used for VP conn.s ')
bbIfRscPrtMaxChans = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 2, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32767))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbIfRscPrtMaxChans.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfRscPrtMaxChans.setDescription(' This represents no. of channels that are available to the controller. ')
bbIfRscPartCtrlrID = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 2, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbIfRscPartCtrlrID.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfRscPartCtrlrID.setDescription(' This is the controller identifier for resource patition. The default value is set for PNNI controller. ')
bbIfCnfSigILMIGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 1, 2))
bbIfCnfSigILMIGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 1, 2, 1), )
if mibBuilder.loadTexts: bbIfCnfSigILMIGrpTable.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfCnfSigILMIGrpTable.setDescription('The config table is for upto 32 logical port interfaces. ')
bbIfCnfSigILMIGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 1, 2, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "bbIfSigPortNum"))
if mibBuilder.loadTexts: bbIfCnfSigILMIGrpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfCnfSigILMIGrpEntry.setDescription(' An entry for a boradband interface used as a UNI port. In MGX PXM card, a physical port can have a maximum of 32 logical interfaces. ')
bbIfSigPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 1, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bbIfSigPortNum.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfSigPortNum.setDescription(' Refers to the logical interface index on the PXM card in MGX node. ')
bbIfIlmiEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 1, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbIfIlmiEnable.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfIlmiEnable.setDescription(" The logical interface is a generic entity, it can be used as either a virtual trunk, or user port with UNI support. This variable is provided to enable/disable ILMI. ILMI should only be enabled on 'user ports' and not on 'virtual trunks' 1 - disable 2 - enable ")
bbIfSignallingProtocolType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 1, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("noSignalling", 2), ("iLMI", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbIfSignallingProtocolType.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfSignallingProtocolType.setDescription(' This will set the signalling protocol 1 - other 2 - noSignalling 3 - ILMI ')
bbIfSignallingVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 1, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbIfSignallingVpi.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfSignallingVpi.setDescription(' Indicates the VPI on which signalling cells arrive. ')
bbIfSignallingVci = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 1, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbIfSignallingVci.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfSignallingVci.setDescription(' Indicates the VCI on which signalling cells arrive. ')
bbIfAddrPrefix = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 1, 2, 1, 1, 6), NetPrefix()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbIfAddrPrefix.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfAddrPrefix.setDescription(' Network Prefix for the ATM address ')
bbIfCustomerId = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 1, 2, 1, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbIfCustomerId.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfCustomerId.setDescription(' For the INS as a read/write variable ')
bbIfProtocolRevNo = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 1, 2, 1, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbIfProtocolRevNo.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfProtocolRevNo.setDescription(' For the INS as a read/write variable. ')
bbIfIlmiTrapEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 1, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbIfIlmiTrapEnable.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfIlmiTrapEnable.setDescription(' Enable/disable ILMI Trap sending ')
bbIfMinTrapInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 1, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbIfMinTrapInterval.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfMinTrapInterval.setDescription(' Number of seconds between traps. ')
bbIfKeepAlivePollingEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 1, 2, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbIfKeepAlivePollingEnable.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfKeepAlivePollingEnable.setDescription(' Enable/disable Keep Alive Polling ')
bbIfErrorThresholdN491 = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 1, 2, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbIfErrorThresholdN491.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfErrorThresholdN491.setDescription(' Error Threshold (N491) value ')
bbIfEventThresholdN492 = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 1, 2, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbIfEventThresholdN492.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfEventThresholdN492.setDescription(' Event Threshold (N492) value ')
bbIfPollingIntervalT491 = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 1, 2, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60))).clone(namedValues=NamedValues(("v1", 5), ("v2", 10), ("v3", 15), ("v4", 20), ("v5", 25), ("v6", 30), ("v7", 35), ("v8", 40), ("v9", 45), ("v10", 50), ("v11", 55), ("v12", 60)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbIfPollingIntervalT491.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfPollingIntervalT491.setDescription(' Polling Interval (T491) value ')
bbIfMinEnquiryIntervalT493 = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 1, 2, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbIfMinEnquiryIntervalT493.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfMinEnquiryIntervalT493.setDescription(' Minimum Enquiry Interval (T493) ')
bbIfAddrRegEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 1, 2, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbIfAddrRegEnable.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfAddrRegEnable.setDescription(' Enable/disable ILMI Address Registration ')
bbIfCntGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 4, 1))
bbIfCntGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 4, 1, 1), )
if mibBuilder.loadTexts: bbIfCntGrpTable.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfCntGrpTable.setDescription(' The Broadband Interface Count table is for logical interface. There will an entry for each of the logical partition of the physical line. ')
bbIfCntGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 4, 1, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "bbCntIfNum"))
if mibBuilder.loadTexts: bbIfCntGrpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfCntGrpEntry.setDescription(' An entry for logical interface. ')
bbCntIfNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 4, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bbCntIfNum.setStatus('mandatory')
if mibBuilder.loadTexts: bbCntIfNum.setDescription(' Refers to the logical interface index on the PXM card in MGX node. ')
bbIfTotalCells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 4, 1, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bbIfTotalCells.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfTotalCells.setDescription(' Total number of cells (VC plus Qbin) that belong to this Interface. This maps on to the virtual interface of QE. ')
bbIfRcvValidOAMCells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 4, 1, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bbIfRcvValidOAMCells.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfRcvValidOAMCells.setDescription(' Total number of OAM cell received. ')
bbIfRcvRmCells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 4, 1, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bbIfRcvRmCells.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfRcvRmCells.setDescription(' Total number of RM cells Received. ')
bbIfRcvClp0Cells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 4, 1, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bbIfRcvClp0Cells.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfRcvClp0Cells.setDescription(' Total number of CLP-0 cells Received. ')
bbIfRcvClp1Cells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 4, 1, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bbIfRcvClp1Cells.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfRcvClp1Cells.setDescription(' Total number of CLP-1 cells Received. ')
bbIfRcvClp0DiscCells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 4, 1, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bbIfRcvClp0DiscCells.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfRcvClp0DiscCells.setDescription(' Total number of CLP-0 cells discarded at Ingress. ')
bbIfRcvClp1DiscCells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 4, 1, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bbIfRcvClp1DiscCells.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfRcvClp1DiscCells.setDescription(' Total number of CLP-1 cells discarded at Ingress. ')
bbIfXmtOAMCells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 4, 1, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bbIfXmtOAMCells.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfXmtOAMCells.setDescription(' Total number of OAM cells transmitted. ')
bbIfXmtRmCells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 4, 1, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bbIfXmtRmCells.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfXmtRmCells.setDescription(' Total number of RM cells transmitted. ')
bbIfXmtClp0Cells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 4, 1, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bbIfXmtClp0Cells.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfXmtClp0Cells.setDescription(' Total number of CLP-0 cells transmitted. ')
bbIfXmtClp1Cells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 4, 1, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bbIfXmtClp1Cells.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfXmtClp1Cells.setDescription(' Total number of CLP-1 cells transmitted. ')
bbIfCntClrButton = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 4, 1, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noAction", 1), ("resetCounters", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbIfCntClrButton.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfCntClrButton.setDescription(' Writing a value of 2 resets all the counters ')
bbIfCntSigILMIGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 4, 2))
bbIfCntSigILMIGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 4, 2, 1), )
if mibBuilder.loadTexts: bbIfCntSigILMIGrpTable.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfCntSigILMIGrpTable.setDescription(' The counter table is for upto 32 logical port interfaces. ')
bbIfCntSigILMIGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 4, 2, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "sigCntBbIfNum"))
if mibBuilder.loadTexts: bbIfCntSigILMIGrpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfCntSigILMIGrpEntry.setDescription(' An entry for a boradband interface used as a UNI port. In MGX PXM card, a physical port can have a maximum of 32 logical interfaces. ')
sigCntBbIfNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 4, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sigCntBbIfNum.setStatus('mandatory')
if mibBuilder.loadTexts: sigCntBbIfNum.setDescription(' Refers to the logical interface index on the PXM card in MGX node. ')
bbIfSnmpPduReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 4, 2, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bbIfSnmpPduReceived.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfSnmpPduReceived.setDescription(' The number of snmp packets received on this logical interface. ')
bbIfGetRequestReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 4, 2, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bbIfGetRequestReceived.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfGetRequestReceived.setDescription(' The number of get request messages received ')
bbIfGetNextRequestReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 4, 2, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bbIfGetNextRequestReceived.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfGetNextRequestReceived.setDescription(' The number of get-next messages received ')
bbIfSetRequestReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 4, 2, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bbIfSetRequestReceived.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfSetRequestReceived.setDescription(' The number of set messages received ')
bbIfTrapReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 4, 2, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bbIfTrapReceived.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfTrapReceived.setDescription(' The number of traps received ')
bbIfGetResponseReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 4, 2, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bbIfGetResponseReceived.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfGetResponseReceived.setDescription(' The number of Keep Alive response messages received ')
bbIfGetResponseTransmitted = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 4, 2, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bbIfGetResponseTransmitted.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfGetResponseTransmitted.setDescription(' The number of response messages transmitted ')
bbIfGetRequestTransmitted = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 4, 2, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bbIfGetRequestTransmitted.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfGetRequestTransmitted.setDescription(' The number of Keep Alive get request messages transmitted ')
bbIfTrapTransmitted = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 4, 2, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bbIfTrapTransmitted.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfTrapTransmitted.setDescription(' The number of trap messages transmitted ')
bbIfInvalidPDUReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 4, 2, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bbIfInvalidPDUReceived.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfInvalidPDUReceived.setDescription(' The number of invalid PDUs received ')
bbIfAsn1ParseError = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 4, 2, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bbIfAsn1ParseError.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfAsn1ParseError.setDescription(' The number of parse errors on ASN.1 ')
bbIfNoSuchNameError = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 4, 2, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bbIfNoSuchNameError.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfNoSuchNameError.setDescription(' The number of errors for name not present ')
bbIfTooBigError = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 4, 2, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bbIfTooBigError.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfTooBigError.setDescription(' The number of messages received with len > 484 ')
bbIfSigCntClrButton = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 4, 2, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noAction", 1), ("resetCounters", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbIfSigCntClrButton.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfSigCntClrButton.setDescription(' Writing a value of 2 resets all the counters ')
bbIfStateGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 3, 1), )
if mibBuilder.loadTexts: bbIfStateGrpTable.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfStateGrpTable.setDescription(' The state table for the logical interface there can be 32 entries for the PXM card in MGX. ')
bbIfStateGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 3, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "bbStateIfNum"))
if mibBuilder.loadTexts: bbIfStateGrpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfStateGrpEntry.setDescription(' An entry for logical interface. In MGX PXM card, a physical port can have a maximum of 32 logical interfaces. ')
bbStateIfNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bbStateIfNum.setStatus('mandatory')
if mibBuilder.loadTexts: bbStateIfNum.setDescription(' This is logical interface number within a physical line num. In MGX PXM card, a physical port can have a maximum of 32 logical interfaces. ')
bbIfState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 5, 6, 7))).clone(namedValues=NamedValues(("notConfigured", 1), ("active", 2), ("linefailure", 4), ("signallingfailure", 5), ("inactive", 6), ("lineinloopback", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bbIfState.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfState.setDescription(' This variable indicates the status of the logical interface. The following are not supported for the logical interface. -- remoteloopback (3), -- outofcelldelineation (6), -- localloopback (7) ')
bbIfOversubscribed = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bbIfOversubscribed.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfOversubscribed.setDescription(' This variable indicates the whether the logical interface is over subscribed or not. ')
bbIfIngrPercentUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bbIfIngrPercentUtil.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfIngrPercentUtil.setDescription(' Percentage Utilization of the interface in the Ingress direction. ')
bbIfEgrPercentUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 6, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bbIfEgrPercentUtil.setStatus('mandatory')
if mibBuilder.loadTexts: bbIfEgrPercentUtil.setDescription(' Percentage Utilization of the interface in the Egress direction. ')
bbChanCnfGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1), )
if mibBuilder.loadTexts: bbChanCnfGrpTable.setStatus('mandatory')
if mibBuilder.loadTexts: bbChanCnfGrpTable.setDescription(' The Broadband Channel config table is for a channel on logical interface. There will an entry for each of the channel added on the logical partition of the physical line. ')
bbChanCnfGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "bbChanCnfNum"))
if mibBuilder.loadTexts: bbChanCnfGrpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: bbChanCnfGrpEntry.setDescription(' The config table is for logical channel. ')
bbChanCnfNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 4111))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bbChanCnfNum.setStatus('mandatory')
if mibBuilder.loadTexts: bbChanCnfNum.setDescription(' This identifies a channel on the PXM logical interface, used as PXM port. ')
bbChanRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("add", 1), ("delete", 2), ("modify", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: bbChanRowStatus.setDescription(' This will add, delete or modify the channel 1 ==> ADD 2 ==> DELETE 3 ==> MODIFY ')
bbChanConnType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("vpc", 1), ("vcc", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanConnType.setStatus('mandatory')
if mibBuilder.loadTexts: bbChanConnType.setDescription(' This specifies the connection type 1 ==> Virtual Path Connection 2 ==> Virtual Channel Connection ')
bbChanServiceType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("cbr", 1), ("vbr", 2), ("abr", 3), ("ubr", 4), ("vbr-rt", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanServiceType.setStatus('mandatory')
if mibBuilder.loadTexts: bbChanServiceType.setDescription(' This specifies the service type 1 ==> Constant Bit Rate 2 ==> Variable Bit Rate 3 ==> Available Bit Rate 4 ==> Unspecified Bit Rate 5 ==> Variable Bit Rate - Real Time ')
bbChanConnDesc = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanConnDesc.setStatus('mandatory')
if mibBuilder.loadTexts: bbChanConnDesc.setDescription(' A string that has been defined to give a descriptive name to the connection ')
bbChanSvcFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("svc", 1), ("pvc", 2), ("spvc", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanSvcFlag.setStatus('mandatory')
if mibBuilder.loadTexts: bbChanSvcFlag.setDescription(' This specifies the connection type 1 ==> SVC connection 2 ==> PVC connection, used by PAR 3 ==> Soft PVC connection, used by PNNI ')
bbChanSvcConnId = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanSvcConnId.setStatus('mandatory')
if mibBuilder.loadTexts: bbChanSvcConnId.setDescription(' This connection ID is for future use Currently not supported. ')
bbChanIfNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanIfNum.setStatus('mandatory')
if mibBuilder.loadTexts: bbChanIfNum.setDescription(" Channel's logical Interface from which traffic of the connection will be received. ")
bbChanVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanVpi.setStatus('mandatory')
if mibBuilder.loadTexts: bbChanVpi.setDescription(' VPI for the connection. ')
bbChanVci = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanVci.setStatus('mandatory')
if mibBuilder.loadTexts: bbChanVci.setDescription(' VCI for the connection. ')
bbChanUpcEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanUpcEnable.setStatus('mandatory')
if mibBuilder.loadTexts: bbChanUpcEnable.setDescription(' enables/disables UPC for Ingress cells ')
bbChanUpcPCR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(50, 1412832))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanUpcPCR.setStatus('mandatory')
if mibBuilder.loadTexts: bbChanUpcPCR.setDescription(' PCR(0+1), Peak Cell Rate, specifies an upper bound on rate at which traffic can be submitted on an ATM connection. This object applies to the First Leaky Bucket for leaving cells with Cell Loss Priority of 0 or 1. . Units: cells per second. . Applicable connection types: UBR, CBR, VBR, ABR . Default: 50 . Ranges: T3 : 50-96000 E3 : 50-80000 OC3 : 50-353208 OC12: 50-1412832 ')
bbChanUpcCDVT = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanUpcCDVT.setStatus('mandatory')
if mibBuilder.loadTexts: bbChanUpcCDVT.setDescription(' Compliant Cell Delay Variation. Also known as CDVT(0+1), Cell Delay Variation Tolerance, which specifies the maximum time period for accumulated violations of cell-arrival time parameters. This object applies to the First Leaky bucket for cells with Cell Loss Priority of 0 or 1. . Units: microseconds. . Applicable connection types: UBR, CBR, VBR, ABR . Default: CBR: 10000 Others: 250000 ')
bbChanUpcSCR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1412832))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanUpcSCR.setStatus('mandatory')
if mibBuilder.loadTexts: bbChanUpcSCR.setDescription(' SCR, Sustainable Cell Rate, is an upper bound on the conforming average rate of an ATM connection, over time scales which are long relative to those for which the PCR is defined. Enforcement of this bound by the UPC could allow the network to allocate sufficient resources, but less than thos based on the PCR, and still ensure that the performance objectives (e.g., Cell Loss Ratio) can be achieved. . Units: cell per second. . Applicable connection types: . VBR, ABR . Ranges: T3 : 50-96000 E3 : 50-80000 OC3 : 50-353208 OC12: 50-1412832 . Default: 50 ')
bbChanUpcMBS = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanUpcMBS.setStatus('mandatory')
if mibBuilder.loadTexts: bbChanUpcMBS.setDescription(' Maximum Burst Size (MBS). Also known as Compliant Burst Size (CBS). . Units: cells . Applicable connection types: . VBR, ABR . Default: 1000 . Range : 1-5000000 ')
bbChanGcra1Action = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("noAction", 1), ("tagCells", 2), ("tagAndDiscard", 3), ("discardAllNonComformCells", 4))).clone('discardAllNonComformCells')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanGcra1Action.setStatus('mandatory')
if mibBuilder.loadTexts: bbChanGcra1Action.setDescription(' GCRA1 Action. 1 = No Action 2 = Tag Untagged cells 3 = Tag untagged cells and discard tagged cells 4 = Discard all (0+1) non-comforming cells ')
bbChanGcra2Action = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("noAction", 1), ("tagCells", 2), ("tagAndDiscard", 3), ("discardAllNonComformCells", 4))).clone('discardAllNonComformCells')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanGcra2Action.setStatus('mandatory')
if mibBuilder.loadTexts: bbChanGcra2Action.setDescription(' GCRA2 Action. 1 = No Action 2 = Tag Untagged cells 3 = Tag untagged cells and discard tagged cells 4 = Discard all (0+1) non-comforming cells ')
bbChanUpcSCRPolicing = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("clp0", 1), ("clp0and1", 2), ("off", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanUpcSCRPolicing.setStatus('mandatory')
if mibBuilder.loadTexts: bbChanUpcSCRPolicing.setDescription(' Selects SCR policing for CLP = 0 or all cells ')
bbChanEfciThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 491520)).clone(196608)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanEfciThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: bbChanEfciThreshold.setDescription(' Threshold above which EFCI bit is to be set. Default Value is 3/4 of max cell count. ')
bbChanDiscardOption = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clpHysteresis", 1), ("frameDiscard", 2))).clone('clpHysteresis')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanDiscardOption.setStatus('mandatory')
if mibBuilder.loadTexts: bbChanDiscardOption.setDescription(' Enable Frame Discard or CLP Hysteresis. ')
bbChanFrmDiscardThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 491520))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanFrmDiscardThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: bbChanFrmDiscardThreshold.setDescription(' Ingress Frame Discard Threshold. Valid only when Ingress Frame Discard option is selected. Default Value : TBD ')
bbChanClpHiThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 491520)).clone(196608)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanClpHiThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: bbChanClpHiThreshold.setDescription(' Ingress CLP High Threshold. Default is 3/4 of max cell count. ')
bbChanClpLoThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 491520)).clone(131072)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanClpLoThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: bbChanClpLoThreshold.setDescription(' Ingress CLP Low Threshold. Valid only when Ingress CLP Hysteresis option is selected. Default Value is 1/2 of max cell count. ')
bbChanCongstUpdateCode = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("dontUpdate", 1), ("setCiBit", 2), ("setEfciBit", 3), ("clearEfciBit", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanCongstUpdateCode.setStatus('mandatory')
if mibBuilder.loadTexts: bbChanCongstUpdateCode.setDescription(' Ingress Channel Congestion Update Code. Default Value : TBD ')
bbChanMaxCellMemThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 512000)).clone(262144)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanMaxCellMemThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: bbChanMaxCellMemThreshold.setDescription(' Maximum number of cells of that connection in the memory. Assuming Total Cell Memory is 512K cells, this is defaulted to half of total size. ')
bbChanIngrPercentUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanIngrPercentUtil.setStatus('mandatory')
if mibBuilder.loadTexts: bbChanIngrPercentUtil.setDescription(' Percentage Utilization of the IngrService Rate. This is used for connection admission control. Default Value : TBD ')
bbChanEgrPercentUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 27), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanEgrPercentUtil.setStatus('mandatory')
if mibBuilder.loadTexts: bbChanEgrPercentUtil.setDescription(' Percentage Utilization of the EgrService Rate. This is used for egress bandwidth calculation and connection admission control. Default Value : TBD ')
bbChanEgrSrvRate = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 28), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1412832))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanEgrSrvRate.setStatus('mandatory')
if mibBuilder.loadTexts: bbChanEgrSrvRate.setDescription(' Egress service rate - This is used for egress bandwidth calculation and for connection admission control. The actual value depends on the speed of the logical interface ')
bbChanOvrSubOvrRide = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanOvrSubOvrRide.setStatus('mandatory')
if mibBuilder.loadTexts: bbChanOvrSubOvrRide.setDescription(' Channel Over Subscrive Override This MIB variable allows one to add a new connection on a port even if it is over subscribed. ')
bbChanLocalVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 30), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bbChanLocalVpi.setStatus('mandatory')
if mibBuilder.loadTexts: bbChanLocalVpi.setDescription(' The VPI value for this channel ')
bbChanLocalVci = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 31), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bbChanLocalVci.setStatus('mandatory')
if mibBuilder.loadTexts: bbChanLocalVci.setDescription(' The VCI value for this channel ')
bbChanLocalNsapAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 32), IfNsapAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanLocalNsapAddr.setStatus('mandatory')
if mibBuilder.loadTexts: bbChanLocalNsapAddr.setDescription(' The Near End NSAP Address value for this channel. ')
bbChanRemoteVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 33), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanRemoteVpi.setStatus('mandatory')
if mibBuilder.loadTexts: bbChanRemoteVpi.setDescription(' The VPI value for this channel ')
bbChanRemoteVci = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 34), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanRemoteVci.setStatus('mandatory')
if mibBuilder.loadTexts: bbChanRemoteVci.setDescription(' The VCI value for this channel ')
bbChanRemoteNsapAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 35), IfNsapAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanRemoteNsapAddr.setStatus('mandatory')
if mibBuilder.loadTexts: bbChanRemoteNsapAddr.setDescription(' The Far End NSAP Address value for this channel. ')
bbChanMaster = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("master", 1), ("slave", 2), ("unknown", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanMaster.setStatus('mandatory')
if mibBuilder.loadTexts: bbChanMaster.setDescription(' This is used by the PXM switch platform module, to determine if this endpoint ia master or slave. ')
bbChanRtePriority = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 37), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanRtePriority.setStatus('mandatory')
if mibBuilder.loadTexts: bbChanRtePriority.setDescription(' This is also known as class of service, it is used by PXM to determine how important this connection is when selecting connections to route. ')
bbChanMaxCost = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 38), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(255)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanMaxCost.setStatus('mandatory')
if mibBuilder.loadTexts: bbChanMaxCost.setDescription(" Maximum allowed cost. It is related to Cost Based Routing. This is used by PXM so that it won't choose a path with a cost greater than this configured level. ")
bbChanRestrictTrkType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 39), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noRestriction", 1), ("terrestrialTrunk", 2), ("satelliteTrunk", 3))).clone('noRestriction')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanRestrictTrkType.setStatus('mandatory')
if mibBuilder.loadTexts: bbChanRestrictTrkType.setDescription(' Restricted trunk type for routind, used by PXM. It specifies that the connection either cannot be routed over satellite trunks or terrestrial trunks, or it can be on any type of trunk. ')
bbChanTestType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("testcon", 1), ("testdelay", 2), ("notest", 3))).clone('notest')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanTestType.setStatus('mandatory')
if mibBuilder.loadTexts: bbChanTestType.setDescription(' The chanTestType starts testing the continuity or delay of a connection. It sends specific cell patterns toward the network and the terminating end of this connection has to be an AXIS or ASI of a BPX in order for this test to be working. The receiving node would loop back when it receives these cells. The test should be done in about couple of seconds. The testcon tests the continuity of the connection and testdelay uses the same test except that it measures for delay through the network. To test the delay follow this procedure: a- set chanTestType to testdelay b- read chanTestState till it is Pass or Fail c- Read chanTestResult for the delay if it is Pass *Note that the chanTestType would go back to notest when the test is completed To test the continuity follow this procedure: a- set chanTestType to testcon b- read chanTestState till it is Pass or Fail *Note that the chanTestType would go back to notest when the test is completed You CAN NOT select 2 tests back to back, you have selcelt one and wait the result and then start the other one. SYNTAX When you select testdelay This is the type of the test 1 = Test Continuity 2 = Test Delay 3 = No Test tstconseg is performed on the port side, i.e, towards the CPE ')
bbChanTestState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 41), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("passed", 1), ("failed", 2), ("inprogress", 3), ("notinprogress", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bbChanTestState.setStatus('mandatory')
if mibBuilder.loadTexts: bbChanTestState.setDescription(' This shows the state of the test When you add a connection then the chanTestState becomes notinprogress and when you select any test, it would go to inprogress state and after it completes the test, it will go to failed or passed state. 1 = Passed 2 = Failed 3 = In Progress 4 = Not In Progress ')
bbChanTestResult = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 42), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bbChanTestResult.setStatus('mandatory')
if mibBuilder.loadTexts: bbChanTestResult.setDescription(' This is round trip delay in milliseconds. When you select testdelay option for the chanTestType, the result of the test that is measured in milliseconds can be read in chanTestResult. ')
bbChanTestTypeCPESide = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 43), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("testconseg", 1), ("notest", 2))).clone('notest')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanTestTypeCPESide.setStatus('mandatory')
if mibBuilder.loadTexts: bbChanTestTypeCPESide.setDescription(' The default is notest. The chanTestType starts testing the segment continuity of a connection. It sends OAM Segment loopback cell towards port side (CPE) The CPE would loop back the cell To test the continuity follow this procedure: a- set chanTestTypeCPEside to testconseg b- read chanTestState till it is Pass or Fail *Note that the chanTestType would go back to notest when the test is completed SYNTAX When you select testdelay This is the type of the test 1 = Test Continuity 2 = No Test ')
bbChanTestStateCPESide = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 44), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("passed", 1), ("failed", 2), ("inprogress", 3), ("notinprogress", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bbChanTestStateCPESide.setStatus('mandatory')
if mibBuilder.loadTexts: bbChanTestStateCPESide.setDescription(' This shows the state of the test When you add a connection then the chanTestState becomes notinprogress and when you select any test, it would go to inprogress state and after it completes the test, it will go to failed or passed state. 1 = Passed 2 = Failed 3 = In Progress 4 = Not In Progress ')
bbConnVpcFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 45), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("vpc", 1), ("vcc", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbConnVpcFlag.setStatus('mandatory')
if mibBuilder.loadTexts: bbConnVpcFlag.setDescription(' This represents the connection type, used for PXM to identify VPC/VCC ')
bbConnServiceType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 46), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 6, 8))).clone(namedValues=NamedValues(("cbr", 1), ("vbr", 2), ("ubr", 4), ("abrstd", 6), ("vbrrt", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbConnServiceType.setStatus('mandatory')
if mibBuilder.loadTexts: bbConnServiceType.setDescription(' This specifies the service type 1 ==> Constant Bit Rate 2 ==> Variable Bit Rate 4 ==> Unspecified Bit Rate 6 ==> Available Bit Rate ( standard ) 8 ==> Variable Bit Rate - Real-Time Note that this is used by PXM card, Also to make it compatible with existing AUSM MIB definition, value 3 is not used. foresight ABR is not supported in PXM , i.e Virtual Service Module ')
bbConnPCR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 47), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbConnPCR.setStatus('mandatory')
if mibBuilder.loadTexts: bbConnPCR.setDescription(' Peak cell rate, could be derived from the end point parameter ')
bbConnSCR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 48), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbConnSCR.setStatus('mandatory')
if mibBuilder.loadTexts: bbConnSCR.setDescription(' Sustained cell rate, could be derived from the end point parameter ')
bbConnPercentUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 49), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100)).clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbConnPercentUtil.setStatus('mandatory')
if mibBuilder.loadTexts: bbConnPercentUtil.setDescription(' This is the expected long-term utilization of the channel by this end-point. ')
bbRemoteConnPCR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 50), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbRemoteConnPCR.setStatus('mandatory')
if mibBuilder.loadTexts: bbRemoteConnPCR.setDescription(' Peak cell rate of the other end, if not set, will be set to the same as local end PCR (bbChanUpcPCR). However, note that if the PCRs for both local and remote end are set to the different value (i.e., asymmetric conn), then this should be set differently from local end PCR. ')
bbRemoteConnSCR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 51), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbRemoteConnSCR.setStatus('mandatory')
if mibBuilder.loadTexts: bbRemoteConnSCR.setDescription(' Sustained cell rate of the other end, if not set, will be set to the same as local end SCR (bbChanUpcSCR). However, note that if the PCRs for both local and remote end are set to the different value (i.e., asymmetric conn), then this should be set differently from local end SCR. ')
bbRemoteConnPercentUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 52), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100)).clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbRemoteConnPercentUtil.setStatus('mandatory')
if mibBuilder.loadTexts: bbRemoteConnPercentUtil.setDescription(" This is the expected long-term utilization of the channel by this end-point. If this is not specified in the connection setup request, it'll be defaulted to 100 percent ")
bbChanUpcMCR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 1, 1, 53), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1412832))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanUpcMCR.setStatus('mandatory')
if mibBuilder.loadTexts: bbChanUpcMCR.setDescription(' SCR, Sustainable Cell Rate, is an upper bound on the conforming average rate of an ATM connection, over time scales which are long relative to those for which the PCR is defined. Enforcement of this bound by the UPC could allow the network to allocate sufficient resources, but less than thos based on the PCR, and still ensure that the performance objectives (e.g., Cell Loss Ratio) can be achieved. . Units: cell per second. . Applicable connection types: . ABR . Ranges: T3 : 50-96000 E3 : 50-80000 OC3 : 50-353208 OC12: 50-1412832 . Default: 50 ')
bbChanNumNextAvailable = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 4111))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bbChanNumNextAvailable.setStatus('mandatory')
if mibBuilder.loadTexts: bbChanNumNextAvailable.setDescription(' This variable contains the next unused channel number of the possible 4096 . This number can be used in channel config table. ChanNumNextAvailable gets updated whenever this number is used to create a new logical channel. Value 0 for this variable indicates that no more channels are available. ')
bbChanVpIdNextAvailable = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bbChanVpIdNextAvailable.setStatus('mandatory')
if mibBuilder.loadTexts: bbChanVpIdNextAvailable.setDescription(' This in only valid for a Service Module, will NOT be used in PXM. This variable contains the next unused local VPId of the possible 1 to 4095. This number can be used in channel config table. It gets updated if the number is used to create a new vp connection. The max. no. of VP conn.s is limited to the VPI range configured for this logical interface. Value of 0 for this variable indicates that no more vp connections are available ')
bbChanCntGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 3, 1), )
if mibBuilder.loadTexts: bbChanCntGrpTable.setStatus('mandatory')
if mibBuilder.loadTexts: bbChanCntGrpTable.setDescription(' The Broadband Channel count table is for a channel on virtual interface or a physical line. There will an entry for each of the channel added on the logical partition of the physical line. ')
bbChanCntGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 3, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "bbChanCntNum"))
if mibBuilder.loadTexts: bbChanCntGrpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: bbChanCntGrpEntry.setDescription(' The count table is for logical channel. The available number of channels on the broadband interface on the PXM card is restricted to 4K. The PXM card has 2 Queue Engines ( QE0 and QE1). ')
bbChanCntNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 4111))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bbChanCntNum.setStatus('mandatory')
if mibBuilder.loadTexts: bbChanCntNum.setDescription(' Channel number. ')
bbChanRcvClp0Cells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 3, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bbChanRcvClp0Cells.setStatus('mandatory')
if mibBuilder.loadTexts: bbChanRcvClp0Cells.setDescription(' CLP_0 Cells Received From Port Count. ')
bbChanRcvClp1Cells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 3, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bbChanRcvClp1Cells.setStatus('mandatory')
if mibBuilder.loadTexts: bbChanRcvClp1Cells.setDescription(' CLP_1 Cells Received From Port Count. ')
bbChanNonConformCellsAtGcra1Policer = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 3, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bbChanNonConformCellsAtGcra1Policer.setStatus('mandatory')
if mibBuilder.loadTexts: bbChanNonConformCellsAtGcra1Policer.setDescription(' Non-Conforming Cells Received at Ingress GCRA1 Policer Count. ')
bbChanNonConformCellsAtGcra2Policer = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 3, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bbChanNonConformCellsAtGcra2Policer.setStatus('mandatory')
if mibBuilder.loadTexts: bbChanNonConformCellsAtGcra2Policer.setDescription(' Non-Conforming Cells Received at Ingress GCRA2 Policer Count. ')
bbChanRcvEOFCells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 3, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bbChanRcvEOFCells.setStatus('mandatory')
if mibBuilder.loadTexts: bbChanRcvEOFCells.setDescription(' Number of cells received from PXM port with EOF set. ')
bbChanDscdClp0Cells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 3, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bbChanDscdClp0Cells.setStatus('mandatory')
if mibBuilder.loadTexts: bbChanDscdClp0Cells.setDescription(' Number of discarded clp = 0 cells received from PXM port. ')
bbChanDscdClp1Cells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 3, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bbChanDscdClp1Cells.setStatus('mandatory')
if mibBuilder.loadTexts: bbChanDscdClp1Cells.setDescription(' Number of discarded clp = 1 cells received from PXM port. ')
bbChanRcvCellsSent = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 3, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bbChanRcvCellsSent.setStatus('mandatory')
if mibBuilder.loadTexts: bbChanRcvCellsSent.setDescription(' Number of cells received from port and sent out of the Queue Engine. ')
bbChanXmtClp0Cells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 3, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bbChanXmtClp0Cells.setStatus('mandatory')
if mibBuilder.loadTexts: bbChanXmtClp0Cells.setDescription(' Number of cells with EFCI clear transmitted to PXM port. ')
bbChanXmtClp1Cells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 3, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bbChanXmtClp1Cells.setStatus('mandatory')
if mibBuilder.loadTexts: bbChanXmtClp1Cells.setDescription(' Number of cells with EFCI set transmitted to PXM port. ')
bbChanDscdClpZeroCellsToPort = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 3, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bbChanDscdClpZeroCellsToPort.setStatus('mandatory')
if mibBuilder.loadTexts: bbChanDscdClpZeroCellsToPort.setDescription(' Number of discard CLP = 0 cells before transmitted to PXM port. ')
bbChanDscdClpOneCellsToPort = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 3, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bbChanDscdClpOneCellsToPort.setStatus('mandatory')
if mibBuilder.loadTexts: bbChanDscdClpOneCellsToPort.setDescription(' Number of discard CLP = 1 cells before transmitted to PXM port. ')
bbChanCntClrButton = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 3, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noAction", 1), ("resetCounters", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bbChanCntClrButton.setStatus('mandatory')
if mibBuilder.loadTexts: bbChanCntClrButton.setDescription(' Writing a value of 2 resets all the counters ')
bbChanStateGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 2, 1), )
if mibBuilder.loadTexts: bbChanStateGrpTable.setStatus('mandatory')
if mibBuilder.loadTexts: bbChanStateGrpTable.setDescription(' The Broadband Channel state table is for a channel on logical interface. There will an entry for each of the channel added on the logical partition of the physical line. ')
bbChanStateGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 2, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "bbChanStateNum"))
if mibBuilder.loadTexts: bbChanStateGrpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: bbChanStateGrpEntry.setDescription(' The state table is for logical channel. The available number of channels on the broadband interface (user ports) on the PXM card is restricted to 4K. The PXM card has 2 Queue Engines ( QE0 and QE1). Current calculations allow 31954 GLCNs on QE0, and 31748 GLCNs on QE1. ')
bbChanStateNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 4111))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bbChanStateNum.setStatus('mandatory')
if mibBuilder.loadTexts: bbChanStateNum.setDescription(' Refers to the logical channel number ')
bbChanState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notconfigured", 1), ("normal", 2), ("alarm", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bbChanState.setStatus('mandatory')
if mibBuilder.loadTexts: bbChanState.setDescription(' This variable indicates the state of the VC (channel). ')
bbChanEgrXmtState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("normal", 2), ("sendingAis", 3), ("sendingFerf", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bbChanEgrXmtState.setStatus('mandatory')
if mibBuilder.loadTexts: bbChanEgrXmtState.setDescription(' Indicates the status of port transmit(Egress) ')
bbChanIngrRcvState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 7, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("normal", 2), ("receivingAis", 3), ("receivingFerf", 4), ("alarm", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bbChanIngrRcvState.setStatus('mandatory')
if mibBuilder.loadTexts: bbChanIngrRcvState.setDescription(' indicates the status of port receive(Ingress) ')
virtualInterfaceCnf = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 8, 1))
vrtlIntrConfigTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 8, 1, 1), )
if mibBuilder.loadTexts: vrtlIntrConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrtlIntrConfigTable.setDescription(' Virtual Interface Configuration Table ')
vrtlIntrConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 8, 1, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "configVrtlIntrNum"))
if mibBuilder.loadTexts: vrtlIntrConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrtlIntrConfigEntry.setDescription('An entry in the Virtual Interface configuration Table ')
configVrtlIntrNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 8, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configVrtlIntrNum.setStatus('mandatory')
if mibBuilder.loadTexts: configVrtlIntrNum.setDescription(' Virtual Interface Number. There are totaly 32 Virtual Interfaces on the card (egress). ')
vrtlIntrPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 8, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrtlIntrPortNum.setStatus('mandatory')
if mibBuilder.loadTexts: vrtlIntrPortNum.setDescription(' Port number which will be connected to the Virtual Interface. Value zero meens that this virtual interface is not connected to any port. ')
vrtlIntrState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 8, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("down", 1), ("up", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrtlIntrState.setStatus('mandatory')
if mibBuilder.loadTexts: vrtlIntrState.setDescription(' Virtual Interface State. ')
vrtlIntrMaxQueMem = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 8, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrtlIntrMaxQueMem.setStatus('mandatory')
if mibBuilder.loadTexts: vrtlIntrMaxQueMem.setDescription(" Virtual Interface's Max queue memory. 1 = 4Kcells 2 = 8Kcells 3 = 16Kcells 4 = 32Kcells 5 = 64Kcells 6 = 128Kcells 7 = 256Kcells 8 = 512Kcells ")
vrtlIntrMinCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 8, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(103384, 353208))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrtlIntrMinCellRate.setStatus('mandatory')
if mibBuilder.loadTexts: vrtlIntrMinCellRate.setDescription(" Virtual Interface's minimum cell rate. The default value: for OC12 port is 1412832 cells/sec for OC3 port is 353208 cells/sec for T3 port is 96000 cells/sec for E3 port is 80000 cells/sec ")
vrtlIntrMaxCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 8, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(103384, 353208))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrtlIntrMaxCellRate.setStatus('mandatory')
if mibBuilder.loadTexts: vrtlIntrMaxCellRate.setDescription(" Virtual Interface's maximum cell rate. The default value: for OC12 port is 1412832 cells/sec for OC3 port is 353208 cells/sec for T3 port is 96000 cells/sec for E3 port is 80000 cells/sec ")
vrtlIntrCurrConfigPaths = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 8, 1, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtlIntrCurrConfigPaths.setStatus('mandatory')
if mibBuilder.loadTexts: vrtlIntrCurrConfigPaths.setDescription(' This is not a configurable parameter. This gives the count of paths currently configured on this VI. ')
virtualInterfaceCnt = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 8, 2))
vrtlIntrCounterTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 8, 2, 1), )
if mibBuilder.loadTexts: vrtlIntrCounterTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrtlIntrCounterTable.setDescription('Virtual Interface Counters Table. ')
vrtlIntrCounterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 8, 2, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "countVrtlIntrNum"))
if mibBuilder.loadTexts: vrtlIntrCounterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrtlIntrCounterEntry.setDescription('An entry in the Virtual Interface Counter Table. ')
countVrtlIntrNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 8, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: countVrtlIntrNum.setStatus('mandatory')
if mibBuilder.loadTexts: countVrtlIntrNum.setDescription(' Virtual Interface Number. ')
vrtlIntrTotalCellCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 8, 2, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtlIntrTotalCellCnt.setStatus('mandatory')
if mibBuilder.loadTexts: vrtlIntrTotalCellCnt.setDescription(' Total number of cells (VC plus Qbin) that belong to this Virtual Interface. ')
vrtlIntrTotalQbinCellCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 8, 2, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtlIntrTotalQbinCellCnt.setStatus('mandatory')
if mibBuilder.loadTexts: vrtlIntrTotalQbinCellCnt.setDescription(' Total number of cells in the Qbin belonging to this Virtual Interface. ')
vrtlIntrRxdValidOAMCellCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 8, 2, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtlIntrRxdValidOAMCellCnt.setStatus('mandatory')
if mibBuilder.loadTexts: vrtlIntrRxdValidOAMCellCnt.setDescription('Total number of OAM cell received. ')
vrtlIntrRxdRmCellCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 8, 2, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtlIntrRxdRmCellCnt.setStatus('mandatory')
if mibBuilder.loadTexts: vrtlIntrRxdRmCellCnt.setDescription('Total number of RM cells Received. ')
vrtlIntrRxdClpUntaggedCellCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 8, 2, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtlIntrRxdClpUntaggedCellCnt.setStatus('mandatory')
if mibBuilder.loadTexts: vrtlIntrRxdClpUntaggedCellCnt.setDescription('Total number of CLP-0 cells Received. ')
vrtlIntrRxdClpTaggedCellCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 8, 2, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtlIntrRxdClpTaggedCellCnt.setStatus('mandatory')
if mibBuilder.loadTexts: vrtlIntrRxdClpTaggedCellCnt.setDescription('Total number of CLP-1 cells Received. ')
vrtlIntrRxdClpUntaggedDiscardedCellCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 8, 2, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtlIntrRxdClpUntaggedDiscardedCellCnt.setStatus('mandatory')
if mibBuilder.loadTexts: vrtlIntrRxdClpUntaggedDiscardedCellCnt.setDescription('Total number of CLP-0 cells discarded at Ingress. ')
vrtlIntrRxdClpTaggedDiscardedCellCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 8, 2, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtlIntrRxdClpTaggedDiscardedCellCnt.setStatus('mandatory')
if mibBuilder.loadTexts: vrtlIntrRxdClpTaggedDiscardedCellCnt.setDescription('Total number of CLP-1 cells discarded at Ingress. ')
vrtlIntrXmtdOAMCellCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 8, 2, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtlIntrXmtdOAMCellCnt.setStatus('mandatory')
if mibBuilder.loadTexts: vrtlIntrXmtdOAMCellCnt.setDescription('Total number of OAM cells transmitted. ')
vrtlIntrXmtdRmCellCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 8, 2, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtlIntrXmtdRmCellCnt.setStatus('mandatory')
if mibBuilder.loadTexts: vrtlIntrXmtdRmCellCnt.setDescription('Total number of RM cells transmitted. ')
vrtlIntrXmtdClpUntaggedCellCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 8, 2, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtlIntrXmtdClpUntaggedCellCnt.setStatus('mandatory')
if mibBuilder.loadTexts: vrtlIntrXmtdClpUntaggedCellCnt.setDescription('Total number of CLP-0 cells transmitted. ')
vrtlIntrXmtdClpTaggedCellCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 8, 2, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtlIntrXmtdClpTaggedCellCnt.setStatus('mandatory')
if mibBuilder.loadTexts: vrtlIntrXmtdClpTaggedCellCnt.setDescription('Total number of CLP-1 cells transmitted. ')
virtualInterfaceQbinCnf = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 8, 3))
vrtlIntrQbinConfigTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 8, 3, 1), )
if mibBuilder.loadTexts: vrtlIntrQbinConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrtlIntrQbinConfigTable.setDescription('Virtual Interface QBin Configuration Table. ')
vrtlIntrQbinConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 8, 3, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "queConfigVrtlIntrNum"), (0, "CISCO-WAN-AXIPOP-MIB", "queConfigVrtlIntrQbinNum"))
if mibBuilder.loadTexts: vrtlIntrQbinConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrtlIntrQbinConfigEntry.setDescription('An entry in the Virtual Interface Qbin Config Table. ')
queConfigVrtlIntrNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 8, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: queConfigVrtlIntrNum.setStatus('mandatory')
if mibBuilder.loadTexts: queConfigVrtlIntrNum.setDescription(' Virtual Interface Number. ')
queConfigVrtlIntrQbinNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 8, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: queConfigVrtlIntrQbinNum.setStatus('mandatory')
if mibBuilder.loadTexts: queConfigVrtlIntrQbinNum.setDescription(' Virtual Interface Qbin Number. There are totaly 16 Qbin per Virtual Interface. ')
vrtlIntrQbinState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 8, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("down", 1), ("up", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrtlIntrQbinState.setStatus('mandatory')
if mibBuilder.loadTexts: vrtlIntrQbinState.setDescription(' Virtual Interface QBIN state. ')
vrtlIntrQbinPri = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 8, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrtlIntrQbinPri.setStatus('mandatory')
if mibBuilder.loadTexts: vrtlIntrQbinPri.setDescription(' This indicates the priority of the QBIN service within the Virtual Interface. ')
vrtlIntrQbinRate = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 8, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 353208))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrtlIntrQbinRate.setStatus('mandatory')
if mibBuilder.loadTexts: vrtlIntrQbinRate.setDescription(' The rate at which cells in the QBIN are serviced. Max Cell rate for OC3 interface is 353208 cell/sec. ')
vrtlIntrQbinDiscardSelection = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 8, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3))).clone(namedValues=NamedValues(("clpHysteresis", 1), ("frameDiscard", 3))).clone('clpHysteresis')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrtlIntrQbinDiscardSelection.setStatus('mandatory')
if mibBuilder.loadTexts: vrtlIntrQbinDiscardSelection.setDescription(' Virtual Interface QBin Congestion control option. ')
vrtlIntrQbinMaxThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 8, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 512000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrtlIntrQbinMaxThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: vrtlIntrQbinMaxThreshold.setDescription('Max cells that can be queued in the QBIN. The Get value will be different from the Set value because of FW internal round up. ')
vrtlIntrQbinClpHiThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 8, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 512000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrtlIntrQbinClpHiThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: vrtlIntrQbinClpHiThreshold.setDescription('The threshold above which the tagged cells will be dropped. The Get value will be different from the Set value because of FW internal round up. ')
vrtlIntrQbinClpLoThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 8, 3, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 512000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrtlIntrQbinClpLoThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: vrtlIntrQbinClpLoThreshold.setDescription('Valid only if congestion control is set to CLP hysterises. The threshold upto which the dropping of the tagged cells should continue once it has crossed CLP HI threshold. The Get value will be different from the Set value because of FW internal round up. ')
vrtlIntrQbinFrameDiscardThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 8, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 512000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrtlIntrQbinFrameDiscardThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: vrtlIntrQbinFrameDiscardThreshold.setDescription('Valid only if congestion control is set to Frame Discard. It is the threshold after which the QE will start discarding the entire frame if one or more cells of the frame is discarded.. The Get value will be different from the Set value because of FW internal round up. ')
vrtlIntrQbinEfciThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 8, 3, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 512000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrtlIntrQbinEfciThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: vrtlIntrQbinEfciThreshold.setDescription('The threshold above which the EFCI bits of the cell is set. The Get value will be different from the Set value because of FW internal round up. ')
virtualInterfaceQbinCnt = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 8, 4))
vrtlIntrQbinCounterTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 8, 4, 1), )
if mibBuilder.loadTexts: vrtlIntrQbinCounterTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrtlIntrQbinCounterTable.setDescription('Virtual Interface QBin Counter Table. ')
vrtlIntrQbinCounterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 8, 4, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "queConuterVrtlIntrNum"), (0, "CISCO-WAN-AXIPOP-MIB", "queCounterVrtlIntrQbinNum"))
if mibBuilder.loadTexts: vrtlIntrQbinCounterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrtlIntrQbinCounterEntry.setDescription('An entry in the Virtual Interface Qbin Counter Table. ')
queConuterVrtlIntrNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 8, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: queConuterVrtlIntrNum.setStatus('mandatory')
if mibBuilder.loadTexts: queConuterVrtlIntrNum.setDescription(' Virtual Interface Number. ')
queCounterVrtlIntrQbinNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 8, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: queCounterVrtlIntrQbinNum.setStatus('mandatory')
if mibBuilder.loadTexts: queCounterVrtlIntrQbinNum.setDescription(' Virtual Interface Qbin Number. There are totaly 16 Qbin per Virtual Interface. ')
vrtlIntrQbinCurrentCellCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 8, 4, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtlIntrQbinCurrentCellCnt.setStatus('mandatory')
if mibBuilder.loadTexts: vrtlIntrQbinCurrentCellCnt.setDescription(' Total number of cells currently in the Qbin. ')
vrtlIntrQbinRxdCellCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 8, 4, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtlIntrQbinRxdCellCnt.setStatus('mandatory')
if mibBuilder.loadTexts: vrtlIntrQbinRxdCellCnt.setDescription(' Total number of cells arrived to the QBIN. ')
vrtlIntrQbinTxdCellCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 8, 4, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtlIntrQbinTxdCellCnt.setStatus('mandatory')
if mibBuilder.loadTexts: vrtlIntrQbinTxdCellCnt.setDescription(' Total number of cells departured from QBIN. ')
vrtlIntrQbinDiscardedCellCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 8, 4, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrtlIntrQbinDiscardedCellCnt.setStatus('mandatory')
if mibBuilder.loadTexts: vrtlIntrQbinDiscardedCellCnt.setDescription(' Total number of arrivals to QBIN which were discarded. ')
rpmChanGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1), )
if mibBuilder.loadTexts: rpmChanGrpTable.setStatus('mandatory')
if mibBuilder.loadTexts: rpmChanGrpTable.setDescription(' The RPM channel table. ')
rpmChanGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "rpmChanSlotNum"), (0, "CISCO-WAN-AXIPOP-MIB", "rpmChanNum"))
if mibBuilder.loadTexts: rpmChanGrpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rpmChanGrpEntry.setDescription(' An entry for logical channel. ')
rpmChanSlotNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanSlotNum.setStatus('mandatory')
if mibBuilder.loadTexts: rpmChanSlotNum.setDescription(' Specifies the slot number of the RPM card. ')
rpmChanInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanInterface.setStatus('mandatory')
if mibBuilder.loadTexts: rpmChanInterface.setDescription(" This is the RPM's backplane interface. Currently there is only one interface. ")
rpmChanNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanNum.setStatus('mandatory')
if mibBuilder.loadTexts: rpmChanNum.setDescription(' This is the LCN. A unique number which identifies a connection. LCN maps VPI and VCI. For VCC, VCI range is 1..3825, and LCN range is 16..3840. LCN = VCI + 16. For VPC, VPI range is 1..255 and LCN range is 3841..4095. LCN = VPI + 3840. ')
rpmChanRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("add", 1), ("del", 2), ("mod", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rpmChanRowStatus.setDescription(' This indicates the status of this channel. 1 ==> ADD 2 ==> DELETE 3 ==> MODIFY ')
rpmChanVcd = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanVcd.setStatus('mandatory')
if mibBuilder.loadTexts: rpmChanVcd.setDescription(' Virtual Circuit Descriptor. A unique number which identifies a connection. ')
rpmChanVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanVpi.setStatus('mandatory')
if mibBuilder.loadTexts: rpmChanVpi.setDescription(' The VPI value for this channel. For VPC, VPI range is 1..255 and LCN range is 3841..4095. LCN = VPI + 3840 ')
rpmChanVci = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanVci.setStatus('mandatory')
if mibBuilder.loadTexts: rpmChanVci.setDescription(' The VCI value for this channel. For VCC, VCI range is 1..3825, and LCN range is 16..3840. LCN = VCI + 16. ')
rpmChanSubInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanSubInterface.setStatus('mandatory')
if mibBuilder.loadTexts: rpmChanSubInterface.setDescription(" This is the RPM's backplane sub-interface. (SNMP doent support index value 0) sub-interface starts from 1. The sub-interface 0 in CLI will be 1 here. So sub-interface is incremented by 1. ")
rpmChanLocalVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanLocalVpi.setStatus('mandatory')
if mibBuilder.loadTexts: rpmChanLocalVpi.setDescription(' This VPI together with the local VCI and NSAP represents the local end point in this connection. The VPI value is zero if it is a VCC conn. type. ')
rpmChanLocalVci = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanLocalVci.setStatus('mandatory')
if mibBuilder.loadTexts: rpmChanLocalVci.setDescription(' This VCI together with the local VPI and NSAP represents the local end point in this connection. ')
rpmChanLocalNsap = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 11), RpmNsapAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanLocalNsap.setStatus('mandatory')
if mibBuilder.loadTexts: rpmChanLocalNsap.setDescription(' The Near End NSAP Address value for this channel. This NSAP is 20 bytes binary, among these 20 bytes: 13 bytes as node name, 2 bytes for Cisco ID, 1 byte rsvd, 3 bytes for logical interface: slot (1 byte) and port number (2 bytes), the last byte is for SEL Of the 13 bytes for the node name, only the first 8 bytes are used. If the node name is n (0 < n < 8) bytes long, the node name must be left justified ( Bytes 1 to n contain the node name and bytes (n+1) to 8 must be 0 ). Bytes 9-13 must be always 0. ')
rpmChanRemoteVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanRemoteVpi.setStatus('mandatory')
if mibBuilder.loadTexts: rpmChanRemoteVpi.setDescription(' This VPI together with the remote VCI and NSAP represents the remote end point in this connection. ')
rpmChanRemoteVci = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanRemoteVci.setStatus('mandatory')
if mibBuilder.loadTexts: rpmChanRemoteVci.setDescription(' This VCI together with the remote VPI and NSAP represents the remote end point in this connection. ')
rpmChanRemoteNsap = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 14), RpmNsapAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanRemoteNsap.setStatus('mandatory')
if mibBuilder.loadTexts: rpmChanRemoteNsap.setDescription(' The Far End NSAP Address value for this channel. This NSAP is 20 bytes binary, among these 20 bytes: 13 bytes as prefix, 2 bytes for Cisco ID, 1 byte rsvd, 3 bytes for logical interface: slot (1 byte) and port number (2 bytes), the last byte is for SEL ')
rpmChanType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("svc", 1), ("pvc", 2), ("spvc", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanType.setStatus('mandatory')
if mibBuilder.loadTexts: rpmChanType.setDescription(' This specifies the connection type 1 ==> SVC 2 ==> PVC 3 ==> Soft PVC Currently only PVC is supported. ')
rpmChanConnType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("vpc", 1), ("vcc", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanConnType.setStatus('mandatory')
if mibBuilder.loadTexts: rpmChanConnType.setDescription(' This specifies the connection type 1 ==> Virtual Path Connection 2 ==> Virtual Channel Connection ')
rpmChanServiceType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 5, 6, 7))).clone(namedValues=NamedValues(("cbr", 1), ("vbr", 2), ("ubr", 4), ("atfr", 5), ("abrstd", 6), ("abrfst", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanServiceType.setStatus('mandatory')
if mibBuilder.loadTexts: rpmChanServiceType.setDescription(' This specifies the service type 1 ==> Constant Bit Rate 2 ==> Variable Bit Rate 4 ==> Unspecified Bit Rate 5 ==> ATM frame relay 6 ==> standard ABR 7 ==> foresight ABR Only VBR,standard ABR and UBR are supported in phase I. ')
rpmChanMastership = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("master", 1), ("slave", 2), ("unknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanMastership.setStatus('mandatory')
if mibBuilder.loadTexts: rpmChanMastership.setDescription(" This specifies which end of the connection is the master. This is used by PXM to determine if this end point is master or slave. Only in AXIS shelf, 'unknown' is always used. For consistency it was added here. ")
rpmChanRtePriority = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanRtePriority.setStatus('mandatory')
if mibBuilder.loadTexts: rpmChanRtePriority.setDescription(' This is also known as class of service, it is used by PXM to determine how important this connection is when selecting connections to route. ')
rpmChanMaxCost = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanMaxCost.setStatus('mandatory')
if mibBuilder.loadTexts: rpmChanMaxCost.setDescription(" Maximum allowed cost. It is related to Cost Based Routing. This is used by PXM so that it won't choose a path with a cost greater than this configured level. ")
rpmChanRestrictTrkType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noRestriction", 1), ("terrestrialTrunk", 2), ("satelliteTrunk", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanRestrictTrkType.setStatus('mandatory')
if mibBuilder.loadTexts: rpmChanRestrictTrkType.setDescription(' Restricted trunk type for routing, used by PXM. It specifies that the connection either cannot be routed over satellite trunks or terrestrial trunks, or it can be on any type of trunk. ')
rpmChanPCR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 353208))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanPCR.setStatus('mandatory')
if mibBuilder.loadTexts: rpmChanPCR.setDescription(' Peak cell rate.(in cells per sec.) ')
rpmChanRemotePCR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 353208))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanRemotePCR.setStatus('mandatory')
if mibBuilder.loadTexts: rpmChanRemotePCR.setDescription(' Peak cell rate of the other end, if not set, will be set to the same as local end PCR. ')
rpmChanMCR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 353208))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanMCR.setStatus('mandatory')
if mibBuilder.loadTexts: rpmChanMCR.setDescription(' Minimum cell rate.(in cells per sec.) ')
rpmChanRemoteMCR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 353208))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanRemoteMCR.setStatus('mandatory')
if mibBuilder.loadTexts: rpmChanRemoteMCR.setDescription(' Minimum cell rate of the other end, if not set, will be set to the same as local end MCR. ')
rpmChanPercentUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanPercentUtil.setStatus('mandatory')
if mibBuilder.loadTexts: rpmChanPercentUtil.setDescription(' This is the expected long-term utilization of the channel by this end-point. ')
rpmChanRemotePercentUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 27), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanRemotePercentUtil.setStatus('mandatory')
if mibBuilder.loadTexts: rpmChanRemotePercentUtil.setDescription(" This is the expected long-term utilization of the channel by the other end-point. If this is not specified in the connection setup request, it'll be set to be the same as the local end. ")
rpmChanEncapType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("aal5snap", 1), ("aal34smds", 2), ("aal5nlpid", 3), ("qsaal", 4), ("ilmi", 5), ("aal5muxXNS", 6), ("aal5muxIP", 7), ("aal5muxVINES", 8), ("aal5muxDECNET", 9), ("aal5muxNOVELL1", 10), ("ppp", 11), ("unknown", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanEncapType.setStatus('mandatory')
if mibBuilder.loadTexts: rpmChanEncapType.setDescription(' ATM adaptation layer (AAL) and Encapsulation type. aal5snap - LLC/SNAP precedes the protocol datagram. aal34smds - Encapsulation for SMDS network. aal5nlpid - Encapsulation that allows ATM interfaces to interoperate with HSSI. qsaal - signaling type PVC used for setting up or tearing down SVCs. ilmi - used to set up communication with ILMI. aal5mux[protocol] - a MUX-type Virtual circuit. ppp - PPP over ATM. The Encapsulation types aal34smds, qsaal and ilmi are not supported. ')
rpmChanMidLow = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 29), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanMidLow.setStatus('mandatory')
if mibBuilder.loadTexts: rpmChanMidLow.setDescription(' Starting Message Identifier Number for this PVC. ')
rpmChanMidHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 30), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanMidHigh.setStatus('mandatory')
if mibBuilder.loadTexts: rpmChanMidHigh.setDescription(' Ending Message Identifier Number for this PVC. ')
rpmChanBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 31), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanBurstSize.setStatus('mandatory')
if mibBuilder.loadTexts: rpmChanBurstSize.setDescription(' The Maximum number of ATM cells the virtual circuit can transmit. ')
rpmChanInArpFreq = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 32), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanInArpFreq.setStatus('mandatory')
if mibBuilder.loadTexts: rpmChanInArpFreq.setDescription(' Specifies how often (in minutes) Inverse ARP datagrams will be sent on this virtual circuit. ')
rpmChanOAMloopback = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 33), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 600))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanOAMloopback.setStatus('mandatory')
if mibBuilder.loadTexts: rpmChanOAMloopback.setDescription(' Specifies how often (in seconds) to generate an OAM F5 loopback cell from this virtual circuit. ')
rpmChanState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notConfigured", 1), ("active", 2), ("failed", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanState.setStatus('mandatory')
if mibBuilder.loadTexts: rpmChanState.setDescription(" This indicates the status of this channel. 1 ==> notConfigured 2 ==> active 3 ==> failed. Currently 'failed' state is not supported. When the channel is not added, the state is notConfigured. ")
rpmChanVirtualTemplate = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 35), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanVirtualTemplate.setStatus('mandatory')
if mibBuilder.loadTexts: rpmChanVirtualTemplate.setDescription(' Specifies the Virtual Template used for CISCO PPP. If it is not using Virtual Template then this value is 0. ')
rpmChanAbrRDF = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 36), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanAbrRDF.setStatus('mandatory')
if mibBuilder.loadTexts: rpmChanAbrRDF.setDescription('This is valid only for ABR Service Type. Rate Decrease Factor: Controls the rate decrease which occurs when backward RM-cells with CI=1 are received. Larger values lead to faster rate decrease. Reference - ATM Forum Traffic Management Specification Version 4.0 Section 5.10.2')
rpmChanAbrRIF = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 37), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanAbrRIF.setStatus('mandatory')
if mibBuilder.loadTexts: rpmChanAbrRIF.setDescription('This is valid only for ABR Service Type. Rate Increase Factor: Controls the rate increase which occurs when a backward RM-cell is received with CI=0 and NI=0. Larger values lead to faster rate increase. Reference - ATM Forum Traffic Management Specification Version 4.0 Section 5.10.2')
rpmPortTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 9, 1, 1), )
if mibBuilder.loadTexts: rpmPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: rpmPortTable.setDescription(' List of RPM backplane sub-interfaces. ')
rpmPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 9, 1, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "rpmPortSlotNum"), (0, "CISCO-WAN-AXIPOP-MIB", "rpmPortSubInterface"))
if mibBuilder.loadTexts: rpmPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rpmPortEntry.setDescription(" An entry for the RPM backplane sub interface. Each entry contains RPM's backplane sub interface number, its IP address and ATM address. ")
rpmPortSlotNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 9, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmPortSlotNum.setStatus('mandatory')
if mibBuilder.loadTexts: rpmPortSlotNum.setDescription(' Specifies the slot number of the RPM card. ')
rpmPortInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 9, 1, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmPortInterface.setStatus('mandatory')
if mibBuilder.loadTexts: rpmPortInterface.setDescription(" This is the RPM's backplane interface. Currently there is only one interface. ")
rpmPortSubInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 9, 1, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmPortSubInterface.setStatus('mandatory')
if mibBuilder.loadTexts: rpmPortSubInterface.setDescription(' It identifies a sub-interface. (SNMP doent support index value 0) sub-interface starts from 1. The sub-interface 0 in CLI will be 1 here. So sub-interface is incremented by 1. ')
rpmPortRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 9, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("add", 1), ("del", 2), ("mod", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmPortRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rpmPortRowStatus.setDescription(' This indicates the status of this sub-interface. 1 ==> ADD 2 ==> DELETE 3 ==> MODIFY ')
rpmPortIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 9, 1, 1, 1, 5), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmPortIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: rpmPortIpAddress.setDescription(' IP address of the sub-interface. ')
rpmPortSubNetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 9, 1, 1, 1, 6), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmPortSubNetMask.setStatus('mandatory')
if mibBuilder.loadTexts: rpmPortSubNetMask.setDescription(' SUB-NETMASK of the sub-interface. ')
rpmPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 9, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notConfigured", 1), ("active", 2), ("failed", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmPortState.setStatus('mandatory')
if mibBuilder.loadTexts: rpmPortState.setDescription(" This indicates the state of this sub-interface. 1 ==> notConfigured 2 ==> active 3 ==> failed. Currently 'failed' state is not supported. ")
rpmIfCnfResPart = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 9, 2))
rpmIfCnfRscPartTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 9, 2, 1), )
if mibBuilder.loadTexts: rpmIfCnfRscPartTable.setStatus('mandatory')
if mibBuilder.loadTexts: rpmIfCnfRscPartTable.setDescription(' The table is for RPM interface resource partition. ')
rpmIfCnfRscPartEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 9, 2, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "rpmIfRscSlotNum"), (0, "CISCO-WAN-AXIPOP-MIB", "rpmIfRscPartIfNum"), (0, "CISCO-WAN-AXIPOP-MIB", "rpmIfRscPartCtrlrNum"))
if mibBuilder.loadTexts: rpmIfCnfRscPartEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rpmIfCnfRscPartEntry.setDescription(' An entry for a logical interface ')
rpmIfRscSlotNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 9, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmIfRscSlotNum.setStatus('mandatory')
if mibBuilder.loadTexts: rpmIfRscSlotNum.setDescription(' Specifies the slot number of the RPM card. ')
rpmIfRscPartIfNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 9, 2, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmIfRscPartIfNum.setStatus('mandatory')
if mibBuilder.loadTexts: rpmIfRscPartIfNum.setDescription(' This is backplane interface number. Currently there is only one interface. ')
rpmIfRscPartCtrlrNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 9, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("par", 1), ("pnni", 2), ("tag", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmIfRscPartCtrlrNum.setStatus('mandatory')
if mibBuilder.loadTexts: rpmIfRscPartCtrlrNum.setDescription(' This is index for controller using the interface . 1 - PAR 2 - PNNI 3 - TAG ')
rpmIfRscPrtRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 9, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("add", 1), ("del", 2), ("mod", 3))).clone('del')).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmIfRscPrtRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rpmIfRscPrtRowStatus.setDescription(' This will add, delete or modify the partition. 1 ==> ADD 2 ==> DELETE 3 ==> MODIFY ')
rpmIfRscPrtIngrPctBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 9, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmIfRscPrtIngrPctBandwidth.setStatus('mandatory')
if mibBuilder.loadTexts: rpmIfRscPrtIngrPctBandwidth.setDescription(' The percentage of logical interface bandwidth. ')
rpmIfRscPrtEgrPctBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 9, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmIfRscPrtEgrPctBandwidth.setStatus('mandatory')
if mibBuilder.loadTexts: rpmIfRscPrtEgrPctBandwidth.setDescription(' The percentage of logical interface bandwidth. ')
rpmIfRscPrtVpiLow = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 9, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmIfRscPrtVpiLow.setStatus('mandatory')
if mibBuilder.loadTexts: rpmIfRscPrtVpiLow.setDescription(' The beginning of the VPI range reserved for this partition. ')
rpmIfRscPrtVpiHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 9, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmIfRscPrtVpiHigh.setStatus('mandatory')
if mibBuilder.loadTexts: rpmIfRscPrtVpiHigh.setDescription(' The end of the VPI range reserved for this partition. ')
rpmIfRscPrtVciLow = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 9, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmIfRscPrtVciLow.setStatus('mandatory')
if mibBuilder.loadTexts: rpmIfRscPrtVciLow.setDescription(' The beginning of the VCI range reserved for this partition. This field is only valid for logical interfaces configured with a single VPI. ')
rpmIfRscPrtVciHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 9, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmIfRscPrtVciHigh.setStatus('mandatory')
if mibBuilder.loadTexts: rpmIfRscPrtVciHigh.setDescription(' The end of the VCI range reserved for this partition. This field is only valid for logical interfaces configured with a single VPI. ')
rpmIfRscPrtMaxChans = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 9, 2, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4047))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmIfRscPrtMaxChans.setStatus('mandatory')
if mibBuilder.loadTexts: rpmIfRscPrtMaxChans.setDescription(' This represents no. of channels that are available to the controller. ')
parSelfNode = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 130, 1))
parInterfaces = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 130, 2))
parConnection = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 130, 3))
parNetworkClock = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 130, 4))
parConfigParms = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 130, 5))
class TruthValue(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("true", 1), ("false", 2))

parSnNodeId = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 223)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parSnNodeId.setStatus('mandatory')
if mibBuilder.loadTexts: parSnNodeId.setDescription(' This object specifies the node number of the node. When the network manager tries to modify the value of this object, a message is sent node state machine which propagates this information and the value gets modified only if the new node number is successfully propagated. The node number uniquely identifies a routing node in a network. ')
parSnNodeIP = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parSnNodeIP.setStatus('mandatory')
if mibBuilder.loadTexts: parSnNodeIP.setDescription(' This object specifies the IP address for routing node and is used for communication with SV+. ')
parSnNodeName = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parSnNodeName.setStatus('mandatory')
if mibBuilder.loadTexts: parSnNodeName.setDescription(' This object specifies the name of the node and is unique among all the nodes in the network. Whenever the name of the node is changed, AutoRoute has to propagate the information to the other nodes in the network. It also specifies the name of a PAR Feeder node. ')
parSnRevision = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parSnRevision.setStatus('mandatory')
if mibBuilder.loadTexts: parSnRevision.setDescription('This object specifies the primary revision of the PAR running on the node. Format: cc.c.cc Where: c = one ascii character')
parSnNodeAlarmStatus = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("clear", 1), ("minor", 2), ("major", 3), ("unreach", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: parSnNodeAlarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: parSnNodeAlarmStatus.setDescription('This object specifies the type of alarm on the node. If there is no alarm the value of this object is none(1). If there is a minor alarm the value of this object is min(2) If there is a major alarm the value of this object is maj(3). If the node is unreachable the value of this object is unreach(4).')
parSnNumberOfTrunks = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: parSnNumberOfTrunks.setStatus('mandatory')
if mibBuilder.loadTexts: parSnNumberOfTrunks.setDescription('This object specifies the number of trunks attached to the node.')
parIfTable = MibTable((1, 3, 6, 1, 4, 1, 351, 130, 2, 1), )
if mibBuilder.loadTexts: parIfTable.setStatus('mandatory')
if mibBuilder.loadTexts: parIfTable.setDescription('Table of all logical interfaces supported by PAR')
parIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 130, 2, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "parIfLogicalInterface"))
if mibBuilder.loadTexts: parIfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: parIfEntry.setDescription('Entries for logical interfaces.')
parIfLogicalInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parIfLogicalInterface.setStatus('mandatory')
if mibBuilder.loadTexts: parIfLogicalInterface.setDescription('This object specifies the logical interface number assigned by Platform Software')
parIfType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("userport", 1), ("routingtrunk", 2), ("feedertrunk", 3), ("clkport", 4), ("virtualtrunk", 5))).clone('userport')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parIfType.setStatus('mandatory')
if mibBuilder.loadTexts: parIfType.setDescription('Specifies the type of interface - uni, nni or clock. uni(1) interface is for user ports and trunks may be either nni or uni. Default type of the interface is uni(1) and it can be configured to nni(2) provided there are no connections on the port. Type of interface can be changed from nni(2) to uni(1) if the trunk is not added. clock type interface is one which is used derive the clock.')
parIfOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("up", 1), ("added", 2), ("failed", 3), ("added-failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: parIfOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: parIfOperStatus.setDescription('This object specifies the operation status of the interface. For interfaces of type uni(1) the status is either up(1) or failed(3) as reported by platform. For interfaces of type nni(2) the status is either of up(1), added(2), failed(3) or added-failed(4). Status up(1) indicates that the interface is configured as trunk but the trunk is not added. Status failed(3) indicates that the interface is configured as trunk, the trunk is not added and platform indicates an alarm on the interface. Status added(2) indicates that the interface is configured as trunk and the trunk is added. Status added-failed(4) indicates that the interface is configured as trunk, the trunk is added and there is an alarm on the trunk. This alarm could be generated by PAR or reported by Platform.')
parIfTxBw = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parIfTxBw.setStatus('mandatory')
if mibBuilder.loadTexts: parIfTxBw.setDescription('This object specifies the transmit bandwidth for the interface in units of cells per second.')
parIfRxBw = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parIfRxBw.setStatus('mandatory')
if mibBuilder.loadTexts: parIfRxBw.setDescription('This object specifies the receive bandwidth for the interface in units of cells per second.')
parIfMaxConn = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parIfMaxConn.setStatus('mandatory')
if mibBuilder.loadTexts: parIfMaxConn.setDescription('This object specifies the maximum number of connections that can be configured over the interface.')
parIfHiAddrMin = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parIfHiAddrMin.setStatus('mandatory')
if mibBuilder.loadTexts: parIfHiAddrMin.setDescription('This object specifies the minimum VPI that PAR can use for configuring connection in the interface.')
parIfHiAddrMax = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parIfHiAddrMax.setStatus('mandatory')
if mibBuilder.loadTexts: parIfHiAddrMax.setDescription('This object specifies the maximum VPI that PAR can use for configuring connection in the interface.')
parIfLoAddrMin = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parIfLoAddrMin.setStatus('mandatory')
if mibBuilder.loadTexts: parIfLoAddrMin.setDescription('This object specifies the minimum VCI that PAR can use for configuring connection in the interface.')
parIfLoAddrMax = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parIfLoAddrMax.setStatus('mandatory')
if mibBuilder.loadTexts: parIfLoAddrMax.setDescription('This object specifies the maximum VCI that PAR can use for configuring connection in the interface.')
parTrkTable = MibTable((1, 3, 6, 1, 4, 1, 351, 130, 2, 2), )
if mibBuilder.loadTexts: parTrkTable.setStatus('mandatory')
if mibBuilder.loadTexts: parTrkTable.setDescription('Trunk parameters')
parTrkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 130, 2, 2, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "parIfLogicalInterface"))
if mibBuilder.loadTexts: parTrkEntry.setStatus('mandatory')
if mibBuilder.loadTexts: parTrkEntry.setDescription('Entries for logical interfaces configured as trunks (parIfType nni).')
parTrkId = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parTrkId.setStatus('mandatory')
if mibBuilder.loadTexts: parTrkId.setDescription('This object specifies the logical trunk number associated with the trunk at the local node.')
parTrkStatReserve = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 2, 1, 2), Integer32().clone(1000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parTrkStatReserve.setStatus('mandatory')
if mibBuilder.loadTexts: parTrkStatReserve.setDescription('Specifies the bandwidth reserved as Statistical Reserve on the trunk in units of cells per second. This object cannot take a value beyond the bandwidth capacity of the trunk.')
parTrkCnfgCcRestrict = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 2, 1, 3), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parTrkCnfgCcRestrict.setStatus('mandatory')
if mibBuilder.loadTexts: parTrkCnfgCcRestrict.setDescription('This object specifies the operators preference for routing control plane traffic on the interface. If the object is set to False, then the interface may be chosen for control plane traffic. If it is True, then the interface is not chosen, unless there is no other trunk with parIfOperStatus added(2), in which case it is chosen regardless of the value of this object.')
parTrkCnfgLineType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("terrestrial", 1), ("satellite", 2))).clone('terrestrial')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parTrkCnfgLineType.setStatus('mandatory')
if mibBuilder.loadTexts: parTrkCnfgLineType.setDescription('This object specifies the type of interface terrestrial or satellite. The interfaces configured as terrestrial(1) are preferred over those configured as satellite(2) for routing control plane traffic. This information is also used for connections for which routing restrictions are specified.')
parTrkCnfgPassSync = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 2, 1, 5), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parTrkCnfgPassSync.setStatus('mandatory')
if mibBuilder.loadTexts: parTrkCnfgPassSync.setDescription('This object specifies whether the trunk can be used to pass clock sync. If the value of this object is True, clock can be synchronized through the trunk; otherwise not.')
parTrkCnfgDerouteDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 2, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parTrkCnfgDerouteDelay.setStatus('mandatory')
if mibBuilder.loadTexts: parTrkCnfgDerouteDelay.setDescription('This object specifies the value of deroute delay timer in seconds.')
parTrkCnfgTrafficClassFst = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 2, 1, 7), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parTrkCnfgTrafficClassFst.setStatus('mandatory')
if mibBuilder.loadTexts: parTrkCnfgTrafficClassFst.setDescription('This object indicates whether Foresight traffic can be routed over the trunk. If the value is True it can be rerouted otherwise not.')
parTrkCnfgTrafficClassFr = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 2, 1, 8), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parTrkCnfgTrafficClassFr.setStatus('mandatory')
if mibBuilder.loadTexts: parTrkCnfgTrafficClassFr.setDescription('This object indicates whether Frame Relay traffic can be routed over the trunk. If the value is True it can be rerouted otherwise not.')
parTrkCnfgTrafficClassNts = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 2, 1, 9), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parTrkCnfgTrafficClassNts.setStatus('mandatory')
if mibBuilder.loadTexts: parTrkCnfgTrafficClassNts.setDescription('This object indicates whether Non-Time Stamped traffic can be routed over the trunk. If the value is True it can be rerouted otherwise not.')
parTrkCnfgTrafficClassTs = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 2, 1, 10), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parTrkCnfgTrafficClassTs.setStatus('mandatory')
if mibBuilder.loadTexts: parTrkCnfgTrafficClassTs.setDescription('This object indicates whether Time Stamped traffic can be routed over the trunk. If the value is True it can be rerouted otherwise not.')
parTrkCnfgTrafficClassVoice = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 2, 1, 11), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parTrkCnfgTrafficClassVoice.setStatus('mandatory')
if mibBuilder.loadTexts: parTrkCnfgTrafficClassVoice.setDescription('This object indicates whether Voice traffic can be routed over the trunk. If the value is True it can be rerouted otherwise not.')
parTrkCnfgTrafficClassCbr = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 2, 1, 12), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parTrkCnfgTrafficClassCbr.setStatus('mandatory')
if mibBuilder.loadTexts: parTrkCnfgTrafficClassCbr.setDescription('This object indicates whether Constant Bit Rate traffic can be routed over the trunk. If the value is True it can be rerouted otherwise not.')
parTrkCnfgTrafficClassVbr = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 2, 1, 13), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parTrkCnfgTrafficClassVbr.setStatus('mandatory')
if mibBuilder.loadTexts: parTrkCnfgTrafficClassVbr.setDescription('This object indicates whether Variable Bit Rate traffic can be routed over the trunk. If the value is True it can be rerouted otherwise not.')
parTrkCnfgTrafficClassAbr = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 2, 1, 14), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parTrkCnfgTrafficClassAbr.setStatus('mandatory')
if mibBuilder.loadTexts: parTrkCnfgTrafficClassAbr.setDescription('This object indicates whether Available Bit Rate traffic can be routed over the trunk. If the value is True it can be rerouted otherwise not.')
parTrkCnfgAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("add", 1), ("delete", 2))).clone('delete')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parTrkCnfgAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: parTrkCnfgAdminStatus.setDescription('This object can be used to add or delete the trunk. The value of this object can be set to add(1) only if the parIfOperStatus is up. The value can be set to delete if parIfOperStatus is added or added-failed')
parTrkCnfgRoutingCost = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 2, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15)).clone(7)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parTrkCnfgRoutingCost.setStatus('mandatory')
if mibBuilder.loadTexts: parTrkCnfgRoutingCost.setDescription('This object specifies the cost associated with the trunk for the purpose of routing the connections. This object has significance if cost based routing feature is enabled. (parCmParmsCostBased)')
parTrkCnfgVccConids = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 2, 1, 17), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parTrkCnfgVccConids.setStatus('mandatory')
if mibBuilder.loadTexts: parTrkCnfgVccConids.setDescription('The max number of routing resource available on the trunk for VCC connections.')
parTrkCnfgVpcConids = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 2, 1, 18), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parTrkCnfgVpcConids.setStatus('mandatory')
if mibBuilder.loadTexts: parTrkCnfgVpcConids.setDescription('The max number of routing resource available on the trunk for VPC connections')
parTrkLocalSlotNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 2, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parTrkLocalSlotNumber.setStatus('mandatory')
if mibBuilder.loadTexts: parTrkLocalSlotNumber.setDescription('This object specifies the slot number of the interface card associated with the trunk at the local node.')
parTrkLocalPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 2, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parTrkLocalPortNumber.setStatus('mandatory')
if mibBuilder.loadTexts: parTrkLocalPortNumber.setDescription('This object specifies the port number of the interface card associated with the trunk at the local node.')
parTrkLocalVTrunkId = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 2, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: parTrkLocalVTrunkId.setStatus('mandatory')
if mibBuilder.loadTexts: parTrkLocalVTrunkId.setDescription('This object specifies the Virtual trunk of the interface card associated with the trunk at the local node. The value of this object is between 1 and 254, inclusive for a virtual trunk and 255 for a physical trunk.')
parTrkRemoteNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 2, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 223))).setMaxAccess("readonly")
if mibBuilder.loadTexts: parTrkRemoteNodeId.setStatus('mandatory')
if mibBuilder.loadTexts: parTrkRemoteNodeId.setDescription('This object specifies the node number of the node attached to the remote end of the trunk.')
parTrkRemoteTrunkId = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 2, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: parTrkRemoteTrunkId.setStatus('mandatory')
if mibBuilder.loadTexts: parTrkRemoteTrunkId.setDescription('This object specifies the logical trunk number at the node on the remote end of the trunk.')
parTrkRemoteSlotNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 2, 1, 24), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parTrkRemoteSlotNumber.setStatus('mandatory')
if mibBuilder.loadTexts: parTrkRemoteSlotNumber.setDescription('This object specifies the slot number of the interface card to which the trunk is attached on the remote node.')
parTrkRemotePortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 2, 1, 25), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parTrkRemotePortNumber.setStatus('mandatory')
if mibBuilder.loadTexts: parTrkRemotePortNumber.setDescription('This object specifies the port number of the interface card to which the trunk is attached on the remote node.')
parTrkRemoteVTrunkId = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 2, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: parTrkRemoteVTrunkId.setStatus('mandatory')
if mibBuilder.loadTexts: parTrkRemoteVTrunkId.setDescription('This object specifies the Virtual trunk of the interface card associated with the trunk at the remote node. The value of this object is between 1 and 254, inclusive for a virtual trunk and 255 for a physical trunk.')
parTrkRemoteNodeIP = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 2, 1, 27), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parTrkRemoteNodeIP.setStatus('mandatory')
if mibBuilder.loadTexts: parTrkRemoteNodeIP.setDescription('This object specifies the IP address for the Remote node, used for communication with NMS')
parTrkRemoteNodeType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 2, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("ipx", 1), ("igx", 2), ("bpx", 3), ("par", 4), ("unknown", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: parTrkRemoteNodeType.setStatus('mandatory')
if mibBuilder.loadTexts: parTrkRemoteNodeType.setDescription('Specifies the type of the node.')
parTrkRemoteNodeName = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 2, 1, 29), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parTrkRemoteNodeName.setStatus('mandatory')
if mibBuilder.loadTexts: parTrkRemoteNodeName.setDescription('This object specifies the name of the remote node and is unique among all the nodes in the network.')
parTrkAlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 2, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("clear", 1), ("minor", 2), ("major", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: parTrkAlarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: parTrkAlarmStatus.setDescription('This object specifies the severity of the alarm on the trunk. If there is no alarm the value of this object is none(1). If there is a minor alarm the value of this object is min(2). If there is a major alarm on the trunk the value of this object is maj(3).')
parTrkAlarmType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 2, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("rsrcunavail", 1), ("commfail", 2), ("unknown", 3), ("failed", 4), ("looped", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: parTrkAlarmType.setStatus('mandatory')
if mibBuilder.loadTexts: parTrkAlarmType.setDescription('This object specifies the type of alarm on the trunk. The value of this object has no significance if parTrunkAlarmStatus indicates no alarm. resources unavailable (1) indicates that the platform has not provided the resources required to make this interface into a trunk. communication failure (2) indicates that message exchange between neighboring nodes on this trunk has failed. unknown (3) indicates that the alarm type is unknown to PAR, for example if the platform has declared the interface in alarm due to some physical problem with the interface.')
parTrkBwCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 2, 1, 32), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parTrkBwCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: parTrkBwCapacity.setDescription('Specifies the bandwidth capacity of the trunk.')
parTrkLineLoad = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 2, 1, 33), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parTrkLineLoad.setStatus('mandatory')
if mibBuilder.loadTexts: parTrkLineLoad.setDescription('Specifies the bandwidth used by the connections routed over the trunk.')
parTrkLoadTable = MibTable((1, 3, 6, 1, 4, 1, 351, 130, 2, 3), )
if mibBuilder.loadTexts: parTrkLoadTable.setStatus('mandatory')
if mibBuilder.loadTexts: parTrkLoadTable.setDescription('Trunk Load Information')
parTrkLoadEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 130, 2, 3, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "parIfLogicalInterface"))
if mibBuilder.loadTexts: parTrkLoadEntry.setStatus('mandatory')
if mibBuilder.loadTexts: parTrkLoadEntry.setDescription('Load info for logical interfaces configured as trunks (parIfType nni).')
parTrkLoadXmtUsedCbr = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parTrkLoadXmtUsedCbr.setStatus('mandatory')
if mibBuilder.loadTexts: parTrkLoadXmtUsedCbr.setDescription('This object specifies the used bandwidth in the transmit direction for CBR traffic.')
parTrkLoadRcvUsedCbr = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parTrkLoadRcvUsedCbr.setStatus('mandatory')
if mibBuilder.loadTexts: parTrkLoadRcvUsedCbr.setDescription('This object specifies the used bandwidth in the receive direction for CBR traffic')
parTrkLoadXmtUsedVbr = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parTrkLoadXmtUsedVbr.setStatus('mandatory')
if mibBuilder.loadTexts: parTrkLoadXmtUsedVbr.setDescription('This object specifies the used bandwidth in the transmit direction for VBR.')
parTrkLoadRcvUsedVbr = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 3, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parTrkLoadRcvUsedVbr.setStatus('mandatory')
if mibBuilder.loadTexts: parTrkLoadRcvUsedVbr.setDescription('This object specifies the used bandwidth in the receive direction for VBR.')
parTrkLoadXmtUsedAbr = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 3, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parTrkLoadXmtUsedAbr.setStatus('mandatory')
if mibBuilder.loadTexts: parTrkLoadXmtUsedAbr.setDescription('This object specifies the used bandwidth in the transmit direction for ABR.')
parTrkLoadRcvUsedAbr = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 3, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parTrkLoadRcvUsedAbr.setStatus('mandatory')
if mibBuilder.loadTexts: parTrkLoadRcvUsedAbr.setDescription('This object specifies the used bandwidth in the receive direction for ABR.')
parTrkLoadXmtUsedNts = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 3, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parTrkLoadXmtUsedNts.setStatus('mandatory')
if mibBuilder.loadTexts: parTrkLoadXmtUsedNts.setDescription('This object specifies the used bandwidth in the transmit direction for Non-Time Stamped.')
parTrkLoadRcvUsedNts = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 3, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parTrkLoadRcvUsedNts.setStatus('mandatory')
if mibBuilder.loadTexts: parTrkLoadRcvUsedNts.setDescription('This object specifies the used bandwidth in the receive direction for Non-Time Stamped.')
parTrkLoadXmtUsedTs = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 3, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parTrkLoadXmtUsedTs.setStatus('mandatory')
if mibBuilder.loadTexts: parTrkLoadXmtUsedTs.setDescription('This object specifies the used bandwidth in the transmit direction for Time-Stamped.')
parTrkLoadRcvUsedTs = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 3, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parTrkLoadRcvUsedTs.setStatus('mandatory')
if mibBuilder.loadTexts: parTrkLoadRcvUsedTs.setDescription('This object specifies the used bandwidth in the receive direction for Time-Stamped.')
parTrkLoadXmtUsedVoice = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 3, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parTrkLoadXmtUsedVoice.setStatus('mandatory')
if mibBuilder.loadTexts: parTrkLoadXmtUsedVoice.setDescription('This object specifies the used bandwidth in the transmit direction for Voice.')
parTrkLoadRcvUsedVoice = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 3, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parTrkLoadRcvUsedVoice.setStatus('mandatory')
if mibBuilder.loadTexts: parTrkLoadRcvUsedVoice.setDescription('This object specifies the used bandwidth in the receive direction for Voice.')
parTrkLoadXmtUsedBdataA = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 3, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parTrkLoadXmtUsedBdataA.setStatus('mandatory')
if mibBuilder.loadTexts: parTrkLoadXmtUsedBdataA.setDescription('This object specifies the used bandwidth in the transmit direction for Busty Data A.')
parTrkLoadRcvUsedBdataA = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 3, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parTrkLoadRcvUsedBdataA.setStatus('mandatory')
if mibBuilder.loadTexts: parTrkLoadRcvUsedBdataA.setDescription('This object specifies the used bandwidth in the receive direction for Bursty Data A.')
parTrkLoadXmtUsedBdataB = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 3, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parTrkLoadXmtUsedBdataB.setStatus('mandatory')
if mibBuilder.loadTexts: parTrkLoadXmtUsedBdataB.setDescription('This object specifies the used bandwidth in the transmit direction for Bursty Data B.')
parTrkLoadRcvUsedBdataB = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 3, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parTrkLoadRcvUsedBdataB.setStatus('mandatory')
if mibBuilder.loadTexts: parTrkLoadRcvUsedBdataB.setDescription('This object specifies the used bandwidth in the receive direction for Bursty Data B.')
parTrkLoadVccConidsUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 3, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parTrkLoadVccConidsUsed.setStatus('mandatory')
if mibBuilder.loadTexts: parTrkLoadVccConidsUsed.setDescription('This object specifies the number of conids used for VCCs (not used) on the trunk.')
parTrkLoadVpcConidsUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 2, 3, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parTrkLoadVpcConidsUsed.setStatus('mandatory')
if mibBuilder.loadTexts: parTrkLoadVpcConidsUsed.setDescription('This object specifies the number of conids Used for VPCs (not used) on the trunk.')
parConnectionTable = MibTable((1, 3, 6, 1, 4, 1, 351, 130, 3, 1), )
if mibBuilder.loadTexts: parConnectionTable.setStatus('mandatory')
if mibBuilder.loadTexts: parConnectionTable.setDescription('Connections Mastered or slaved by the node.')
parConnectionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 130, 3, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "parConnLocalSlot"), (0, "CISCO-WAN-AXIPOP-MIB", "parConnLocalPort"), (0, "CISCO-WAN-AXIPOP-MIB", "parConnLocalVpi"), (0, "CISCO-WAN-AXIPOP-MIB", "parConnLocalVci"))
if mibBuilder.loadTexts: parConnectionEntry.setStatus('mandatory')
if mibBuilder.loadTexts: parConnectionEntry.setDescription('Entries for connections mastered or slaved by the node.')
parConnLocalSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parConnLocalSlot.setStatus('mandatory')
if mibBuilder.loadTexts: parConnLocalSlot.setDescription('This object specifies the slot number part of the local endpoint connection address.')
parConnLocalPort = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 3, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parConnLocalPort.setStatus('mandatory')
if mibBuilder.loadTexts: parConnLocalPort.setDescription('This object specifies the port number part of the local endpoint connection address.')
parConnLocalVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 3, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parConnLocalVpi.setStatus('mandatory')
if mibBuilder.loadTexts: parConnLocalVpi.setDescription('This object specifies the Virtual Path Identifier part of the local endpoint connection address.')
parConnLocalVci = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 3, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parConnLocalVci.setStatus('mandatory')
if mibBuilder.loadTexts: parConnLocalVci.setDescription('This object specifies the Virtual Channel Identifier part of the local endpoint connection address.')
parConnMasterShip = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 3, 1, 1, 5), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parConnMasterShip.setStatus('mandatory')
if mibBuilder.loadTexts: parConnMasterShip.setDescription('This object specifies whether this end of the connection is the master or the slave of the connection.')
parConnLocalVcIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 3, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parConnLocalVcIndx.setStatus('mandatory')
if mibBuilder.loadTexts: parConnLocalVcIndx.setDescription('This object specifies the Virtual Connection Index at this node. It is used by Network Management to correlate this end of the connection with the remote end.')
parConnLocalEndpt = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 3, 1, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parConnLocalEndpt.setStatus('mandatory')
if mibBuilder.loadTexts: parConnLocalEndpt.setDescription('This object specifies the actual physical connection endpoint at the local node.')
parConnRemoteNodeName = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 3, 1, 1, 8), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parConnRemoteNodeName.setStatus('mandatory')
if mibBuilder.loadTexts: parConnRemoteNodeName.setDescription('This object specifies the node name of the remote endpoint. For a intra-switch connection or feeder connection this object would specify the self node name.')
parConnRemoteSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 3, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parConnRemoteSlot.setStatus('mandatory')
if mibBuilder.loadTexts: parConnRemoteSlot.setDescription('This object specifies the slot number part of the remote endpoint connection address.')
parConnRemotePort = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 3, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parConnRemotePort.setStatus('mandatory')
if mibBuilder.loadTexts: parConnRemotePort.setDescription('This object specifies the port number part of the remote endpoint connection address.')
parConnRemoteVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 3, 1, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parConnRemoteVpi.setStatus('mandatory')
if mibBuilder.loadTexts: parConnRemoteVpi.setDescription('This object specifies the VPI part of the remote endpoint connection address.')
parConnRemoteVci = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 3, 1, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parConnRemoteVci.setStatus('mandatory')
if mibBuilder.loadTexts: parConnRemoteVci.setDescription('This object specifies the VCI part of the remote endpoint connection address.')
parConnRemoteVcIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 3, 1, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parConnRemoteVcIndx.setStatus('mandatory')
if mibBuilder.loadTexts: parConnRemoteVcIndx.setDescription('This object specifies the Virtual Connection Index at the remote node. It is used by Network Management to correlate this end of the connection with the remote end..')
parConnOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 3, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("routed", 1), ("unrouted", 2), ("lmifail", 3), ("unknown", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: parConnOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: parConnOperStatus.setDescription('This object specifies the status of connection as known and determined by PAR. The status shall be OK if there is an abit alarm on the connection.')
parConnAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 3, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("down", 1), ("up", 2), ("reroute", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parConnAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: parConnAdminStatus.setDescription("This object is used by the operator to reroute or down/up a connection. The value of this object is up when the connection is created. If the value of the object is set to down(1) the connection is derouted (if it is routed) and parConnOperStatus object is set to not routed. If the value of the object is up (2) and it is set to reroute(3) the connection is derouted and attempt is made to reroute the connection. If the value of the object is down (1) and the it is set to reroute (3), no action is performed and the object's value does not changes. If the value of object is down(1) and is set to up(2), an attempt is made to reroute the connection.")
parConnRoute = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 3, 1, 1, 16), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parConnRoute.setStatus('mandatory')
if mibBuilder.loadTexts: parConnRoute.setDescription('This object specifies the current path on which the connection is routed. A value of this object is valid only if parConnOperStatus is routed. Null string specifies that the connection is not routed. Format: Nodename {Trk--Trk Nodename} Where: Nodename = up to 8 characters, Trk = slot.port.vtrk, slot = 1 or 2 characters, port = 1 or two characters, and vtrk = 1 or two characters and is optional. The portion of the format shown in braces {like this} can be repeated up to 10 times.')
parConnRemoteEndpt = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 3, 1, 1, 17), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parConnRemoteEndpt.setStatus('mandatory')
if mibBuilder.loadTexts: parConnRemoteEndpt.setDescription('This object specifies the actual physical connection endpoint at the remote end of the connection. It shall be known only if the connection is a local(DAX) connection.')
parPrefRoute = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 3, 1, 1, 18), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parPrefRoute.setStatus('mandatory')
if mibBuilder.loadTexts: parPrefRoute.setDescription('This object specifies the preferred path for the connection. Null string specifies that the connection does not have a preferred route. Format: Nodename {Trk--Trk Nodename} Where: Nodename = up to 8 characters, Trk = slot.port.vtrk, slot = 1 or 2 characters, port = 1 or two characters, and vtrk = 1 or two characters and is optional. The portion of the format shown in braces {like this} can be repeated up to 10 times.')
parConnFailRsn = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 3, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("down", 1), ("hwalm", 2), ("abitalm", 3), ("lmifail", 4), ("rrtfail", 5), ("incomplete", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: parConnFailRsn.setStatus('mandatory')
if mibBuilder.loadTexts: parConnFailRsn.setDescription('This object specifies a reason code for the failure of the connection.')
parRrtFailRsn = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 3, 1, 1, 20), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parRrtFailRsn.setStatus('mandatory')
if mibBuilder.loadTexts: parRrtFailRsn.setDescription('This object specifies the Reason of failure of a connection to route.')
parConnRstrTyp = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 3, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("norestrict", 1), ("terrestrict", 2), ("satrestrict", 3), ("undefrestrict", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: parConnRstrTyp.setStatus('mandatory')
if mibBuilder.loadTexts: parConnRstrTyp.setDescription('This object specifies the Route restriction of a connection. The possible values are no restriction, terrestrial line restriction or sattelite line restriction.')
parConnRstrZcs = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 3, 1, 1, 22), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parConnRstrZcs.setStatus('mandatory')
if mibBuilder.loadTexts: parConnRstrZcs.setDescription('This object specifies whether ZCS lines should be avoided or not. The possible values are no restriction, terrestrial line restriction or sattelite line restriction.')
parConnCos = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 3, 1, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: parConnCos.setStatus('mandatory')
if mibBuilder.loadTexts: parConnCos.setDescription('This object specifies the COS for the connection.')
parClockTable = MibTable((1, 3, 6, 1, 4, 1, 351, 130, 4, 1), )
if mibBuilder.loadTexts: parClockTable.setStatus('mandatory')
if mibBuilder.loadTexts: parClockTable.setDescription('Table of clock sources available to PAR')
parClockEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 130, 4, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "parClockIndex"))
if mibBuilder.loadTexts: parClockEntry.setStatus('mandatory')
if mibBuilder.loadTexts: parClockEntry.setDescription('Each entry represent a clock source iavailable to PAR')
parClockIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 4, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parClockIndex.setStatus('mandatory')
if mibBuilder.loadTexts: parClockIndex.setDescription('This clock index is assigned by PAR. This object is used to index into parClockTable')
parClockType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("primary", 1), ("secondary", 2), ("tertiary", 3), ("null", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parClockType.setStatus('mandatory')
if mibBuilder.loadTexts: parClockType.setDescription('Specifies the type of clock - Primary, Secondary, Tertiary')
parClockSource = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("internal", 1), ("interface", 2), ("external", 3))).clone('internal')).setMaxAccess("readonly")
if mibBuilder.loadTexts: parClockSource.setStatus('mandatory')
if mibBuilder.loadTexts: parClockSource.setDescription('Specifies source of the clock - Internal, Interface, External')
parClockCurSource = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 4, 1, 1, 4), TruthValue().clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: parClockCurSource.setStatus('mandatory')
if mibBuilder.loadTexts: parClockCurSource.setDescription('Specifies whether clock source is a current clock source or not. The value is true if the cloock source is current and false otherwise')
parClockSourceId = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 4, 1, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parClockSourceId.setStatus('mandatory')
if mibBuilder.loadTexts: parClockSourceId.setDescription("Specifies identification of the clock - for example - if clock source is `Interface' then this field will carry logical interface number")
parClockPath = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 130, 4, 1, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parClockPath.setStatus('mandatory')
if mibBuilder.loadTexts: parClockPath.setDescription('Describes the path used for clock synchronization')
parVsiConfigParms = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 130, 5, 1))
parCmParms = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 130, 5, 2))
parMnUpdt = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 130, 5, 3))
parSwFunc = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 130, 5, 4))
parOnOff = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 130, 5, 5))
parSysParms = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 130, 5, 6))
parNetworkingParms = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 130, 5, 7))
parCmParmsMaxRoutingBundle = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 2, 1), Integer32().clone(24)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parCmParmsMaxRoutingBundle.setStatus('mandatory')
if mibBuilder.loadTexts: parCmParmsMaxRoutingBundle.setDescription('This object specifies the maximum number of connections that can be routed in one routing cycle.')
parCmParmsRerouteTimer = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 2, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parCmParmsRerouteTimer.setStatus('mandatory')
if mibBuilder.loadTexts: parCmParmsRerouteTimer.setDescription('This object specifies the minimum time after which a connection is routed once it has been successfully routed.')
parCmParmsResetTimer = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 2, 3), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parCmParmsResetTimer.setStatus('mandatory')
if mibBuilder.loadTexts: parCmParmsResetTimer.setDescription('This object specifies whether the reroute timer should be reset if the path for routed connection failed. If the value of the object is True the timer is reset on detecting path fail.')
parCmParmsDnUpPerPass = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 2, 4), Integer32().clone(50)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parCmParmsDnUpPerPass.setStatus('mandatory')
if mibBuilder.loadTexts: parCmParmsDnUpPerPass.setDescription('This object specifies the maximum number of connections that are upped or down in one schedule of down connection state machine.')
parCmParmsDnUpTimer = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 2, 5), Integer32().clone(30000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parCmParmsDnUpTimer.setStatus('mandatory')
if mibBuilder.loadTexts: parCmParmsDnUpTimer.setDescription('This object specifies the minimum time interval (in milliseconds) between two schedules of the down connection state machine.')
parCmParmsRrtErrsPerCycle = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 2, 6), Integer32().clone(50)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parCmParmsRrtErrsPerCycle.setStatus('mandatory')
if mibBuilder.loadTexts: parCmParmsRrtErrsPerCycle.setDescription('This object specifies the threshold for number of failures to route a connection before it is moved into the wait group. If the value of this object is 0 the feature is disabled.')
parCmParmsRrtCycleInterval = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 2, 7), Integer32().clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parCmParmsRrtCycleInterval.setStatus('mandatory')
if mibBuilder.loadTexts: parCmParmsRrtCycleInterval.setDescription('This object specifies the time (in minutes) for which no attempt is made to route a connection in the wait group.')
parCmParmsMaxRrtCycles = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 2, 8), Integer32().clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parCmParmsMaxRrtCycles.setStatus('mandatory')
if mibBuilder.loadTexts: parCmParmsMaxRrtCycles.setDescription('This object specifies the number of times a connection is added to the wait group before declaring it unroutable.')
parCmParmsRrtPauseTime = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 2, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parCmParmsRrtPauseTime.setStatus('mandatory')
if mibBuilder.loadTexts: parCmParmsRrtPauseTime.setDescription('This object specifies the time interval (in milliseconds) between two routing cycles.')
parCmParmsMaxUpdates = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 2, 10), Integer32().clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parCmParmsMaxUpdates.setStatus('mandatory')
if mibBuilder.loadTexts: parCmParmsMaxUpdates.setDescription('This object specifies the maximum number of connection management updates that are sent by the node in schedule..')
parCmParmsRerouteGroups = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 2, 11), Integer32().clone(50)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parCmParmsRerouteGroups.setStatus('mandatory')
if mibBuilder.loadTexts: parCmParmsRerouteGroups.setDescription('This object specifies the total number of reroute groups.')
parCmParmsMinRrGroupSize = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 2, 12), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parCmParmsMinRrGroupSize.setStatus('mandatory')
if mibBuilder.loadTexts: parCmParmsMinRrGroupSize.setDescription('This object specifies the minimum size of reroute group in Cell Load Units.')
parCmParmsRrGroupInc = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 2, 13), Integer32().clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parCmParmsRrGroupInc.setStatus('mandatory')
if mibBuilder.loadTexts: parCmParmsRrGroupInc.setDescription('This object specifies the increment of reroute group size (in Cell Load Units) between adjacent groups.')
parCmParmsCostBased = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 2, 14), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parCmParmsCostBased.setStatus('mandatory')
if mibBuilder.loadTexts: parCmParmsCostBased.setDescription('This object can be configured to enable or disable cost based routing feature. If the value of this object is True the feature is enabled else it is disabled.')
parCmParmsUseCache = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 2, 15), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parCmParmsUseCache.setStatus('mandatory')
if mibBuilder.loadTexts: parCmParmsUseCache.setDescription('This object can be configured to enable or disable hop based route selection from using cache of precomputed routes. If the value of this object is True the feature is enabled else it is disabled.')
parCmParmsUseDelay = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 2, 16), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parCmParmsUseDelay.setStatus('mandatory')
if mibBuilder.loadTexts: parCmParmsUseDelay.setDescription('This object can be configured to enable or disable cost based route selection from considering end-to-end delay associated with the routes. If the value of this object is True the delay would be considered otherwise daley would not be considered during routing of connection.')
parCmParmMaxViaCons = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 2, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 80000)).clone(50000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parCmParmMaxViaCons.setStatus('mandatory')
if mibBuilder.loadTexts: parCmParmMaxViaCons.setDescription('This object specifies the maximum number of via user connections that can be routed through the node.')
parMnUpdtInterval = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 3, 1), Integer32().clone(15)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parMnUpdtInterval.setStatus('mandatory')
if mibBuilder.loadTexts: parMnUpdtInterval.setDescription(' This object specifies the timer interval (in seconds) for the mandatory update state machine.')
parMnUpdtNodesPerInt = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 3, 2), Integer32().clone(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parMnUpdtNodesPerInt.setStatus('mandatory')
if mibBuilder.loadTexts: parMnUpdtNodesPerInt.setDescription('This object specifies the maximum number of nodes to which mandatory updates can be sent per interval.')
parMnUpdtBatchSend = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 3, 3), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parMnUpdtBatchSend.setStatus('mandatory')
if mibBuilder.loadTexts: parMnUpdtBatchSend.setDescription('This object specifies whether mandatory updates to any node are sent one at a time or all in one go. If the value of this object is True, all mandatory updates are sent to the node simultaneously. If the value of this object is False, mandatory updates are sent one at a time.')
parSwFuncAbrVsvd = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 4, 1), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parSwFuncAbrVsvd.setStatus('mandatory')
if mibBuilder.loadTexts: parSwFuncAbrVsvd.setDescription('This object enables/disables the ABR standard with VSVD. The feature is enabled if the value of the object is True.')
parSwFuncNodeType = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 4, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("routing", 1), ("feeder", 2))).clone('routing')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parSwFuncNodeType.setStatus('mandatory')
if mibBuilder.loadTexts: parSwFuncNodeType.setDescription('This object specifies whether the node is a routing node or a feeder node. To configure the node from a routing(1) node to feeder(2) node the node should be part of a single node network. To configure the node from feeder node to routing node, there should be no feeder trunk attached to the node.')
parOnOffBackgroundUpdt = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 5, 1), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parOnOffBackgroundUpdt.setStatus('mandatory')
if mibBuilder.loadTexts: parOnOffBackgroundUpdt.setDescription('This object can be used to enable or disable Background updates. If the value of the object is True Background updates are enabled; otherwise they are disabled.')
parOnOffDynamicBwAlloc = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 5, 2), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parOnOffDynamicBwAlloc.setStatus('mandatory')
if mibBuilder.loadTexts: parOnOffDynamicBwAlloc.setDescription('This object can be used to enable or disable Bandwidth state machine. If the value of the object is True Bandwidth state machine is enabled; otherwise it is disabled.')
parOnOffCmUpdts = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 5, 3), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parOnOffCmUpdts.setStatus('mandatory')
if mibBuilder.loadTexts: parOnOffCmUpdts.setDescription('This object can be used to enable or disable Connection management updates. If the value of the object is True Connection management updates are enabled; otherwise they are disabled.')
parOnOffRouting = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 5, 4), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parOnOffRouting.setStatus('mandatory')
if mibBuilder.loadTexts: parOnOffRouting.setDescription('This object can be used to enable or disable connection routing. If the value of the object is True routing is enabled; otherwise it is disabled.')
parOnOffCommFailTest = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 5, 5), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parOnOffCommFailTest.setStatus('mandatory')
if mibBuilder.loadTexts: parOnOffCommFailTest.setDescription('This object can be used to enable or disable Comm Fail Test. If the value of the object is True Comm Fail test is enabled; otherwise it is disabled.')
parOnOffDrtDelay = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 5, 6), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parOnOffDrtDelay.setStatus('mandatory')
if mibBuilder.loadTexts: parOnOffDrtDelay.setDescription('This object can be used to enable or disable Deroute Delay feature. If the value of the object is True Derote delay feature is enabled; otherwise it is disabled.')
parOnOffRenumRec = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 5, 7), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parOnOffRenumRec.setStatus('mandatory')
if mibBuilder.loadTexts: parOnOffRenumRec.setDescription('This object can be used to enable or disable Renumber recovery feature. If the value of the object is True renumber recovery feature is enabled; otherwise it is disabled.')
parOnOffCommBreak = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 5, 8), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parOnOffCommBreak.setStatus('mandatory')
if mibBuilder.loadTexts: parOnOffCommBreak.setDescription('This object can be used to enable or disable Comm Break Test. If the value of the object is True Comm Break Test feature is enabled; otherwise it is disabled.')
parSysParmsTsPacketAge = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 6, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64)).clone(64)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parSysParmsTsPacketAge.setStatus('mandatory')
if mibBuilder.loadTexts: parSysParmsTsPacketAge.setDescription('Time Stamped packets older than this value (in milliseconds) are discarded. This is a network wide parameter.')
parSysParmsConnFail = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 6, 2), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parSysParmsConnFail.setStatus('mandatory')
if mibBuilder.loadTexts: parSysParmsConnFail.setDescription('This object specifies whether the connections to a node should be failed when comm fail is declared with the node. If the value of this object is True the connection will be failed. This is a network wide parameter.')
parSysParmsVcPollRate = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 6, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parSysParmsVcPollRate.setStatus('mandatory')
if mibBuilder.loadTexts: parSysParmsVcPollRate.setDescription('This object specifies the rate at which VC statistics are to be polled. This is a network wide parameter. For Portable AutoRoute statistic collections would be done by platform software.')
parSysParmsMaxVDelay = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 6, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parSysParmsMaxVDelay.setStatus('mandatory')
if mibBuilder.loadTexts: parSysParmsMaxVDelay.setDescription('This object specifies the maximum delay for voice connection with VAD enabled in milli-seconds. This is a network wide parameter.')
parSysParmsMaxCDelay = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 6, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parSysParmsMaxCDelay.setStatus('mandatory')
if mibBuilder.loadTexts: parSysParmsMaxCDelay.setDescription('This object specifies the maximum delay for ADPCM compressed voice connection with VAD enabled in milli-seconds. This is a network wide parameter.')
parSysParmsMaxDDelay = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 6, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parSysParmsMaxDDelay.setStatus('mandatory')
if mibBuilder.loadTexts: parSysParmsMaxDDelay.setDescription('This object specifies the maximum delay for data connection in milli-seconds. This is a network wide parameter.')
parSysParmsMaxADelay = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 6, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parSysParmsMaxADelay.setStatus('mandatory')
if mibBuilder.loadTexts: parSysParmsMaxADelay.setDescription('This object specifies the maximum delay for ADPCM compressed voice connection in milli-seconds. This is a network wide parameter.')
parSysParmsMaxHsdDelay = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 6, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parSysParmsMaxHsdDelay.setStatus('mandatory')
if mibBuilder.loadTexts: parSysParmsMaxHsdDelay.setDescription('This object specifies the maximum delay for High Speed data connection in milli-seconds. This is a network wide parameter.')
parSysParmsDeEnable = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 6, 9), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parSysParmsDeEnable.setStatus('mandatory')
if mibBuilder.loadTexts: parSysParmsDeEnable.setDescription('This object specifies whether DE bit of Frame Relay frames can be modified. DE bit can be modified if the value of this object is True. This is a network wide parameter.')
parSysParmsFrStandard = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 6, 10), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parSysParmsFrStandard.setStatus('mandatory')
if mibBuilder.loadTexts: parSysParmsFrStandard.setDescription('This object specifies whether standard Frame Relay parameters, Be and Bc, are to be used. If the value of this object is True, standard parameters are used. This is a network wide parameter.')
parSysParmsDrtDelay = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 6, 11), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parSysParmsDrtDelay.setStatus('mandatory')
if mibBuilder.loadTexts: parSysParmsDrtDelay.setDescription('This object specifies whether Deroute Delay feature is enabled. If the value of this object is True, the feature is enabled. This is a network wide parameter.')
parSysParmsInvLogAlarmThres = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 6, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parSysParmsInvLogAlarmThres.setStatus('mandatory')
if mibBuilder.loadTexts: parSysParmsInvLogAlarmThres.setDescription('This object specifies the threshold for invalid login attempts before triggering an alarm. If the value of this object is zero, this feature is disabled. This is a network wide parameter.')
parSysParmsMaxCdpVDelay = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 6, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parSysParmsMaxCdpVDelay.setStatus('mandatory')
if mibBuilder.loadTexts: parSysParmsMaxCdpVDelay.setDescription('This object specifies the maximum network delay for CDP to CDP voice connection with VAD enabled in milli-seconds. This is a network wide parameter.')
parSysParmsMaxCdpCDelay = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 6, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parSysParmsMaxCdpCDelay.setStatus('mandatory')
if mibBuilder.loadTexts: parSysParmsMaxCdpCDelay.setDescription('This object specifies the maximum network delay for CDP to CDP ADPCM compressed voice connection with VAD enabled in milli-seconds. This is a network wide parameter.')
parSysParmsMaxCdpDDelay = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 6, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parSysParmsMaxCdpDDelay.setStatus('mandatory')
if mibBuilder.loadTexts: parSysParmsMaxCdpDDelay.setDescription('This object specifies the maximum network delay for CDP to CDP data connection in milli-seconds. This is a network wide parameter.')
parSysParmsMaxCdpADelay = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 6, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parSysParmsMaxCdpADelay.setStatus('mandatory')
if mibBuilder.loadTexts: parSysParmsMaxCdpADelay.setDescription('This object specifies the maximum network delay for CDP to CDP ADPCM compressed voice connection in milli-seconds. This is a network wide parameter.')
parSysParmsMaxCdpHsdDelay = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 6, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parSysParmsMaxCdpHsdDelay.setStatus('mandatory')
if mibBuilder.loadTexts: parSysParmsMaxCdpHsdDelay.setDescription('This object specifies the maximum network delay for CDP to CDP High Speed data connection in milli-seconds. This is a network wide parameter.')
parSysParmsMaxIpcdpVDelay = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 6, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parSysParmsMaxIpcdpVDelay.setStatus('mandatory')
if mibBuilder.loadTexts: parSysParmsMaxIpcdpVDelay.setDescription('This object specifies the maximum local delay for CDP to CDP voice connection with VAD enabled in milli-seconds. This is a network wide parameter.')
parSysParmsMaxIpcdpCDelay = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 6, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parSysParmsMaxIpcdpCDelay.setStatus('mandatory')
if mibBuilder.loadTexts: parSysParmsMaxIpcdpCDelay.setDescription('This object specifies the maximum local delay for CDP to CDP ADPCM compressed voice connection with VAD enabled in milli-seconds. This is a network wide parameter.')
parSysParmsMaxIpcdpDDelay = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 6, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parSysParmsMaxIpcdpDDelay.setStatus('mandatory')
if mibBuilder.loadTexts: parSysParmsMaxIpcdpDDelay.setDescription('This object specifies the maximum local delay for CDP to CDP data connection in milli-seconds. This is a network wide parameter.')
parSysParmsMaxIpcdpADelay = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 6, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parSysParmsMaxIpcdpADelay.setStatus('mandatory')
if mibBuilder.loadTexts: parSysParmsMaxIpcdpADelay.setDescription('This object specifies the maximum local delay for CDP to CDP ADPCM compressed voice connection in milli-seconds. This is a network wide parameter.')
parSysParmsMaxIpcdpHsdDelay = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 6, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parSysParmsMaxIpcdpHsdDelay.setStatus('mandatory')
if mibBuilder.loadTexts: parSysParmsMaxIpcdpHsdDelay.setDescription('This object specifies the maximum local delay for CDP to CDP High Speed data connection in milli-seconds. This is a network wide parameter.')
parSysParmsMaxIphsdDelay = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 6, 23), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parSysParmsMaxIphsdDelay.setStatus('mandatory')
if mibBuilder.loadTexts: parSysParmsMaxIphsdDelay.setDescription('This object specifies the maximum local delay for High Speed data connection in milli-seconds. This is a network wide parameter.')
parSysParmsFpdDeJitter = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 6, 24), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parSysParmsFpdDeJitter.setStatus('mandatory')
if mibBuilder.loadTexts: parSysParmsFpdDeJitter.setDescription('This object specifies the jitter delay for Fast Pad. This is a network wide parameter.')
parNetParmCondInitialStgr = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 7, 1), Integer32().clone(5000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parNetParmCondInitialStgr.setStatus('mandatory')
if mibBuilder.loadTexts: parNetParmCondInitialStgr.setDescription('This object specifies the initial pause time (in milliseconds) per new node added on addition of node(s) in the network before initiating conditional updates.')
parNetParmCondPerNodeInterval = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 7, 2), Integer32().clone(30000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parNetParmCondPerNodeInterval.setStatus('mandatory')
if mibBuilder.loadTexts: parNetParmCondPerNodeInterval.setDescription('This object specifies the minimum interval (in milliseconds) between sending of conditional updates to any two nodes.')
parNetParmCbDelay = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 7, 3), Integer32().clone(30000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parNetParmCbDelay.setStatus('mandatory')
if mibBuilder.loadTexts: parNetParmCbDelay.setDescription('This object specifies the minimum interval (in milliseconds) between initiating comm break tests between any two nodes.')
parNetParmCbOffset = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 7, 4), Integer32().clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parNetParmCbOffset.setStatus('mandatory')
if mibBuilder.loadTexts: parNetParmCbOffset.setDescription('TBD.')
parNetParmMsgTimeout = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 7, 5), Integer32().clone(1700)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parNetParmMsgTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: parNetParmMsgTimeout.setDescription('This object specifies the timeout (in milliseconds) for acknowledgment for control plane message sent to another node.')
parNetParmMsgMaxTimeout = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 7, 6), Integer32().clone(7)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parNetParmMsgMaxTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: parNetParmMsgMaxTimeout.setDescription('This object specifies the maximum number of times a network handler timeout waiting for acknowledgment for control plane message sent to another node reachable through all terrestrial trunks.')
parNetParmMsgMaxTimeoutSat = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 7, 7), Integer32().clone(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parNetParmMsgMaxTimeoutSat.setStatus('mandatory')
if mibBuilder.loadTexts: parNetParmMsgMaxTimeoutSat.setDescription('This object specifies the maximum number of times a network handler timeout waiting for acknowledgment for control plane message sent to another node reachable through all satellite trunks.')
parNetParmBlindMaxTimeout = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 7, 8), Integer32().clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parNetParmBlindMaxTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: parNetParmBlindMaxTimeout.setDescription('This object specifies the maximum number of times a network handler timeout waiting for acknowledgment for control plane blind message sent to another node.')
parNetParmCbMaxTimeout = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 7, 9), Integer32().clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parNetParmCbMaxTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: parNetParmCbMaxTimeout.setDescription('This object specifies the maximum number of times a network handler timeout waiting for acknowledgment for comm break test message sent to another node.')
parNetParmCfTestInterval = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 7, 10), Integer32().clone(10000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parNetParmCfTestInterval.setStatus('mandatory')
if mibBuilder.loadTexts: parNetParmCfTestInterval.setDescription('This object specifies the minimum time interval between the comm fail tests for a trunk.')
parNetParmCfTestMultiplier = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 7, 11), Integer32().clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parNetParmCfTestMultiplier.setStatus('mandatory')
if mibBuilder.loadTexts: parNetParmCfTestMultiplier.setDescription('This object specifies the multiplier for the comm fail test interval for good trunks, that is, trunks not in comm fail.')
parNetParmNetwWindowSz = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 7, 12), Integer32().clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parNetParmNetwWindowSz.setStatus('mandatory')
if mibBuilder.loadTexts: parNetParmNetwWindowSz.setDescription('This object specifies the window size for the network handler for messages to any node. That is, the number of messages that the network handler can send simultaneous to a node without receiving the acknowledgment for them.')
parNetParmNetwLetWait = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 7, 13), Integer32().clone(50)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parNetParmNetwLetWait.setStatus('mandatory')
if mibBuilder.loadTexts: parNetParmNetwLetWait.setDescription('This object specifies the maximum interval (in milliseconds) network handler waits for the letter (message) from the processes running on its nodes before checking the received cells.')
parNetParmCfDelay = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 7, 14), Integer32().clone(60)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parNetParmCfDelay.setStatus('mandatory')
if mibBuilder.loadTexts: parNetParmCfDelay.setDescription('TBD (in milliseconds).')
parNetParmHighTxRate = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 7, 15), Integer32().clone(2500)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parNetParmHighTxRate.setStatus('mandatory')
if mibBuilder.loadTexts: parNetParmHighTxRate.setDescription('This object specifies the rate (in fast packets per second) at which the network handler sends control plane message cells to high performance nodes (High performance node are BPX and MGX).')
parNetParmLowTxRate = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 7, 16), Integer32().clone(500)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parNetParmLowTxRate.setStatus('mandatory')
if mibBuilder.loadTexts: parNetParmLowTxRate.setDescription('This object specifies the rate (in fast packets per second) at which the network handler sends control plane message cells to low capacity nodes (Low capacity node are IPX and IGX).')
parNetParmMaxNodeBlks = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 7, 17), Integer32().clone(3000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parNetParmMaxNodeBlks.setStatus('mandatory')
if mibBuilder.loadTexts: parNetParmMaxNodeBlks.setDescription('This object specifies the maximum number of blocks, of size 256 bytes, that should be queued up for transmission to a node.')
parNetParmTopoMsgSegSz = MibScalar((1, 3, 6, 1, 4, 1, 351, 130, 5, 7, 18), Integer32().clone(3570)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parNetParmTopoMsgSegSz.setStatus('mandatory')
if mibBuilder.loadTexts: parNetParmTopoMsgSegSz.setDescription('This object specifies the maximum size (in bytes) of the segment into which the topology message, sent during network join, is divided.')
ausmPortCnfPortImaGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 4))
ausmPortImaGrpRestart = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 7))
ausmPortCnfPortImaGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 4, 1), )
if mibBuilder.loadTexts: ausmPortCnfPortImaGrpTable.setStatus('mandatory')
if mibBuilder.loadTexts: ausmPortCnfPortImaGrpTable.setDescription('The config table is for the IMA port (IMA group). There are 8 entries in all. ')
ausmPortCnfPortImaGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 4, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "imaPortNum"))
if mibBuilder.loadTexts: ausmPortCnfPortImaGrpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ausmPortCnfPortImaGrpEntry.setDescription(' An entry for every IMA port (total of 8 entries) ')
imaPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: imaPortNum.setStatus('mandatory')
if mibBuilder.loadTexts: imaPortNum.setDescription('This is the logical port number. ')
imaPortEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("delport", 1), ("addport", 2), ("addlinks", 3), ("dellinks", 4), ("modify", 5))).clone('delport')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: imaPortEnable.setStatus('mandatory')
if mibBuilder.loadTexts: imaPortEnable.setDescription("This variable enables, disables or modifies the configuration of the port 1 - delport (Disables the entire IMA group) 2 - addport (Enables the IMA group) 3 - addlinks (Adds links to an existing IMA group) 4 - dellinks (Deletes links from an existing IMA group) 5 - modify (Modifies parameters in an existing IMA group) An IMA group is synonymous with an IMA port. To configure an IMA port, the different lines in the IMA port should be enabled and then the IMA port should be added using the enumeration 'addport'. To delete an IMA port, the enumeration 'delport' should be used. To increase the bandwidth of an IMA group, the enumeration 'addlinks' should be used. To decrease the bandwidth of an IMA group, the enumeration 'dellinks' should be used. 'modify' is used to change parameters other than links in the IMA group ")
imaPortSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 38328))).setMaxAccess("readonly")
if mibBuilder.loadTexts: imaPortSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: imaPortSpeed.setDescription('The speed of the port in cells per second. This depends on the nuber of links in the IMA group and the configuration of the physical interface on each link (eg: T1, Normal E1, Clear E1 etc). ')
numLinksInImaGrp = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: numLinksInImaGrp.setStatus('mandatory')
if mibBuilder.loadTexts: numLinksInImaGrp.setDescription('The number of links configured in the IMA group This is same as axisImaGroupNumTxCfgLnks in Forum Compliant Ima ')
listOfLinksInImaGrp = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 4, 1, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: listOfLinksInImaGrp.setStatus('mandatory')
if mibBuilder.loadTexts: listOfLinksInImaGrp.setDescription('The list of links in the IMA group delimited by dots ')
lcpCellsPeriodicity = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 4, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(32, 128)).clone(128)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcpCellsPeriodicity.setStatus('mandatory')
if mibBuilder.loadTexts: lcpCellsPeriodicity.setDescription('Period at wich LCP cells of the IMA protocol can be transmitted. A value of 32 indicates that after 32 cells, one LCP cell is transmitted on that link of the IMA group. Currently, the only value supported is 128 This has same meaning as axisImaGroupTxFrameLength in Forum Compliant Ima. ')
lcpDelayTolerance = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 4, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1)).clone(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcpDelayTolerance.setStatus('mandatory')
if mibBuilder.loadTexts: lcpDelayTolerance.setDescription('The number of IMA frames for which an LCP cell on any link can be missed before the IMA state machine should remove the link from the IMA group. At present, this is hard-coded to 1 and is not programmable. Not supported in Forum Compliant Ima ')
readPtrWrPtrDiff = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 4, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(4, 12)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: readPtrWrPtrDiff.setStatus('mandatory')
if mibBuilder.loadTexts: readPtrWrPtrDiff.setDescription('The difference between the read and write pointer of a link in the common cell buffer. A lower value reduces the latency in the common cell buffer but also increases the probability of an IMA group being stalled for a cell-time due to a slower link in the IMA group Not supported in Forum Compliant Ima. ')
numRedundantLinks = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 4, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: numRedundantLinks.setStatus('mandatory')
if mibBuilder.loadTexts: numRedundantLinks.setDescription('The degree of resiliency in the IMA group. This indicates the number of links the system can lose from this IMA group without bringing it down. By default, the system can tolerate {configured #links - 1} to go down. Not supported in Forum Compliant Ima. ')
maxTolerableDiffDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 4, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 275))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: maxTolerableDiffDelay.setStatus('mandatory')
if mibBuilder.loadTexts: maxTolerableDiffDelay.setDescription('This indicates the maximum tolerable differential delay in milliseconds between the various links in the IMA group. The default value is variable and depends on the type of card with IMA feature: For AUSM-8p: 200 milliseconds for an IMA group consisting of E1 lines 275 milliseconds for an IMA group consisting of T1 lines. For IMATM: 50 milliseconds for an IMA group consisting of either T1/E1 lines. This is same as axisImaGroupDiffDelayMax of Forum Compliant Ima. ')
imaPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 4, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("uni", 1), ("nni", 2), ("sti", 3), ("vpTrkUni", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: imaPortType.setStatus('mandatory')
if mibBuilder.loadTexts: imaPortType.setDescription('This indicates whether the port is to be configured for UNI/NNI/STI mode. STI mode is supported only in the case of IMATM. vpTrkUni should be used only in IMATM when virtual trunks are passing through IMATM (i.e. the cell format is UNI but ForeSight information is carried in the lower 16 bits) ')
axisImaGroupTxAvailCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 4, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 38330))).setMaxAccess("readonly")
if mibBuilder.loadTexts: axisImaGroupTxAvailCellRate.setStatus('mandatory')
if mibBuilder.loadTexts: axisImaGroupTxAvailCellRate.setDescription('The current cell rate(truncated value in cells per second) provided by the IMA group in the transmit direction, considering all the transmit links in the Active state. The generic formula for the link rate with N links active is : N * link Rate * (M-1)/M * (2048/2049), where M is the Ima Frame length. Suppose M = 128, then following are the link rates : In case of T1,for 8 lines the value is 28728 cells/sec. In case of Normal E1(for 8 Lines), the value is 35920 cells/sec. In case of Clear E1(for 8 Lines),the value is 38312 cells/sec. ')
axisImaGroupSymmetry = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 4, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("symmetricOperation", 1), ("asymmetricOperation", 2), ("asymmetriConfiguration", 3))).clone('symmetricOperation')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: axisImaGroupSymmetry.setStatus('mandatory')
if mibBuilder.loadTexts: axisImaGroupSymmetry.setDescription('Symmetry of the IMA group. AsymmetricOperation,AsymmetricConfiguration are not supported. ')
axisImaGroupMinNumRxLinks = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 4, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: axisImaGroupMinNumRxLinks.setStatus('mandatory')
if mibBuilder.loadTexts: axisImaGroupMinNumRxLinks.setDescription('Minimum number of receive links required to be active for the IMA group to be in the Up state.At present since only symmetric configuration is supported,this should be equal to axisImaGroupMinNumTxLinks. ')
axisImaGroupNeTxClkMode = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 4, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ctc", 1), ("itc", 2))).clone('ctc')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: axisImaGroupNeTxClkMode.setStatus('mandatory')
if mibBuilder.loadTexts: axisImaGroupNeTxClkMode.setDescription('Transmit clocking mode used by the near-end IMA group. ITC is not available in ausm8(B). Only default value (ctc) is supported. ')
axisImaGroupAlphaValue = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 4, 1, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2)).clone(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: axisImaGroupAlphaValue.setStatus('mandatory')
if mibBuilder.loadTexts: axisImaGroupAlphaValue.setDescription("This indicates the 'alpha' value used to specify the number of consecutive invalid ICP cells to be detected before moving to the IMA HUNT state. Only default values are supported. ")
axisImaGroupBetaValue = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 4, 1, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)).clone(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: axisImaGroupBetaValue.setStatus('mandatory')
if mibBuilder.loadTexts: axisImaGroupBetaValue.setDescription("This indicates the 'beta'value used to specify the number of consecutive errored ICP cells to be detected before moving to the IMA HUNT state. Only default values are supported. ")
axisImaGroupGammaValue = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 4, 1, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)).clone(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: axisImaGroupGammaValue.setStatus('mandatory')
if mibBuilder.loadTexts: axisImaGroupGammaValue.setDescription("This indicates the 'gamma' value used to specify the number of consecutive valid ICP cells to be detected before moving to the IMA SYNC state from the PRESYNC state. Only default values are supported. ")
axisImaGroupNumRxCfgLnks = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 4, 1, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: axisImaGroupNumRxCfgLnks.setStatus('mandatory')
if mibBuilder.loadTexts: axisImaGroupNumRxCfgLnks.setDescription('The Number of links that are configured to receive in this IMA Group. ')
axisImaGroupTestLinkIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 4, 1, 1, 20), Integer32().clone(-1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: axisImaGroupTestLinkIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: axisImaGroupTestLinkIfIndex.setDescription('This object is used to designate an interface as the test link. A value of -1 specifies that the implementation may choose the test link. In this case ,the implementation may also choose the value of axisImaGroupTestPattern. ')
axisImaGroupTestPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 4, 1, 1, 21), Integer32().clone(-1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: axisImaGroupTestPattern.setStatus('mandatory')
if mibBuilder.loadTexts: axisImaGroupTestPattern.setDescription("The value of this object is used to specify the test pattern in an IMA group loopback operation. A value in the range 0 to 255 designates a specific pattern. A value of -1 specifies that the implementation may choose the value. In this case,the implementation may also choose the value of 'axisImaGroupTestLinkIfIndex. ")
axisImaGroupTestProcStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 4, 1, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disabled", 1), ("operating", 2), ("linkfail", 3))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: axisImaGroupTestProcStatus.setStatus('mandatory')
if mibBuilder.loadTexts: axisImaGroupTestProcStatus.setDescription('This object is used to enable or disable the Test Pattern Proceudre,and to note whether at least one link failed the test. The test is started by setting operating(2) status.If any link should fail the test ,the IMA will set the status to linkfail(3).The linkfail(3) state will persist until either the disabled(1) state is set or until no instance of imaLinkTestProcStatus has the value linkfail(3). Only the values disabled(1) and operating(2) may be written. Writing the opersting(2) value will not cause clearing of the linkfail(3) state. ')
axisImaGroupIntegrationUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 4, 1, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(100, 100000)).clone(2500)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: axisImaGroupIntegrationUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: axisImaGroupIntegrationUpTime.setDescription(' Integration UP time for alarm integration.Persisting checking time to enter a failure alarm condition,in case of LIF,LODS,RFI-IMA fault failure alarms. Time in Milli Seconds. ')
axisImaGroupIntegrationDownTime = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 4, 1, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(100, 400000)).clone(10000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: axisImaGroupIntegrationDownTime.setStatus('mandatory')
if mibBuilder.loadTexts: axisImaGroupIntegrationDownTime.setDescription(' Integration DOWN time for alarm integration.Persisting clearing time to exit the LIF,LODS,RFI-IMA failure alarm conditions. Time in Milli seconds. ')
axisImaGroupMinNumTxLinks = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 4, 1, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: axisImaGroupMinNumTxLinks.setStatus('mandatory')
if mibBuilder.loadTexts: axisImaGroupMinNumTxLinks.setDescription('Minimum number of transmit links required to be active for the IMA group to be in the Up state.Eventhough the range is 1..8,this value should be <= maximum number of configured links in IMA group. ')
axisImaGroupRxImaId = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 4, 1, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: axisImaGroupRxImaId.setStatus('mandatory')
if mibBuilder.loadTexts: axisImaGroupRxImaId.setDescription('The Ima id used by the far end. ')
nextPortNumAvailable = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 4, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nextPortNumAvailable.setStatus('mandatory')
if mibBuilder.loadTexts: nextPortNumAvailable.setDescription('Indicates the next logical port number (i.e. either ATM T1/E1 UNI or IMA port) that is available ')
ausmPortImaGrpRestartTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 7, 1), )
if mibBuilder.loadTexts: ausmPortImaGrpRestartTable.setStatus('mandatory')
if mibBuilder.loadTexts: ausmPortImaGrpRestartTable.setDescription('The restart table is for the IMA port (IMA group). There are 8 entries in all. ')
ausmPortImaGrpRestartEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 7, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "axisImaGroupimaPortNum"))
if mibBuilder.loadTexts: ausmPortImaGrpRestartEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ausmPortImaGrpRestartEntry.setDescription(' An entry for every IMA port (total of 8 entries) ')
axisImaGroupimaPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 7, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: axisImaGroupimaPortNum.setStatus('mandatory')
if mibBuilder.loadTexts: axisImaGroupimaPortNum.setDescription('This is the logical port number. ')
axisImaGroupRestartImaGrp = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 7, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noAction", 1), ("persistent", 2), ("dorelearn", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: axisImaGroupRestartImaGrp.setStatus('mandatory')
if mibBuilder.loadTexts: axisImaGroupRestartImaGrp.setDescription('This variable restarts the Ima grp. We have the option of relearning the Ima id or retaining the stored ID. ')
ausmPortCntPortImaGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 3, 3))
ausmPortCntPortImaGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 3, 3, 1), )
if mibBuilder.loadTexts: ausmPortCntPortImaGrpTable.setStatus('mandatory')
if mibBuilder.loadTexts: ausmPortCntPortImaGrpTable.setDescription('The counter table is for the IMA groups (8 possible entries) ')
ausmPortCntPortImaGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 3, 3, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "imaCntPortNum"))
if mibBuilder.loadTexts: ausmPortCntPortImaGrpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ausmPortCntPortImaGrpEntry.setDescription(' An entry for the IMA group ')
imaCntPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 3, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: imaCntPortNum.setStatus('mandatory')
if mibBuilder.loadTexts: imaCntPortNum.setDescription('This is the logical port number. This object does not have any default value. ')
rcvAcpCells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 3, 3, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvAcpCells.setStatus('mandatory')
if mibBuilder.loadTexts: rcvAcpCells.setDescription('This is the number of ICP cells received. This object does not have any default value. ')
rcvAcpErrCells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 3, 3, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvAcpErrCells.setStatus('mandatory')
if mibBuilder.loadTexts: rcvAcpErrCells.setDescription('This is the number of errored ICP cells on this IMA group. This object does not have any default value. ')
xmtAcpCells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 3, 3, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtAcpCells.setStatus('mandatory')
if mibBuilder.loadTexts: xmtAcpCells.setDescription('This is the number of ACP cells transmitted on this IMA group. This object does not have any default value. Not supported in Forum Compliant Ima. ')
xmtAcpCellsMissed = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 3, 3, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtAcpCellsMissed.setStatus('mandatory')
if mibBuilder.loadTexts: xmtAcpCellsMissed.setDescription('This is the number of ACP cells that could not be transmitted on this IMA group due to lack of resources (buffers). This object does not have any default value. Not supported in Forum Compliant Ima. ')
imaGrpRcvHecErrCount = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 3, 3, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: imaGrpRcvHecErrCount.setStatus('mandatory')
if mibBuilder.loadTexts: imaGrpRcvHecErrCount.setDescription('This is the number of HEC errored cells received on all the links currently in the IMA group This object does not have any default value. ')
imaGrpRcvHecErrSecCount = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 3, 3, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: imaGrpRcvHecErrSecCount.setStatus('mandatory')
if mibBuilder.loadTexts: imaGrpRcvHecErrSecCount.setDescription('This is the number of HEC errored seconds for the IMA group-- that is the number of seconds in which at least one link in the IMA group experienced a HEC error This object does not have any default value. ')
imaGrpRcvHecErrSESecCount = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 3, 3, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: imaGrpRcvHecErrSESecCount.setStatus('mandatory')
if mibBuilder.loadTexts: imaGrpRcvHecErrSESecCount.setDescription('This is the number of severely errored seconds received on all the links currently in the IMA group. A severely errored second for an IMA group is defined if the following condn is true: if (sigma (number of HEC errors of all links in IMA group) > (HEC_SE_COUNT * nlinks)) where HEC_SE_COUNT is defined as 10 This object does not have any default value. ')
imaCntClrButton = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 3, 3, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noAction", 1), ("resetCounters", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: imaCntClrButton.setStatus('mandatory')
if mibBuilder.loadTexts: imaCntClrButton.setDescription('writing a value of 2 resets all the counters This object does not have any default value. ')
axisImaGroupRunningSecs = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 3, 3, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: axisImaGroupRunningSecs.setStatus('mandatory')
if mibBuilder.loadTexts: axisImaGroupRunningSecs.setDescription('The amount of time(in seconds) since this IMA group has been in opeartion(UP or DOWN.) ')
axisImaGroupUnavailSecs = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 3, 3, 1, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: axisImaGroupUnavailSecs.setStatus('mandatory')
if mibBuilder.loadTexts: axisImaGroupUnavailSecs.setDescription('Count of one second intervals where IMA group traffic state machine is down. ')
axisImaGroupNeNumFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 3, 3, 1, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: axisImaGroupNeNumFailures.setStatus('mandatory')
if mibBuilder.loadTexts: axisImaGroupNeNumFailures.setDescription('The number of times a near-end group failure(Config-abort, Insufficient-Links) has been reported since power-up or reboot. ')
axisImaGroupFeNumFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 3, 3, 1, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: axisImaGroupFeNumFailures.setStatus('mandatory')
if mibBuilder.loadTexts: axisImaGroupFeNumFailures.setDescription('The number of times a far-end group failure(config-abort-FE, Insufficient-links-FE,Blocked-FE) has been reported since power-up or reboot. ')
ausmPortStateImaGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 4))
ausmPortStateImaGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 4, 1), )
if mibBuilder.loadTexts: ausmPortStateImaGrpTable.setStatus('mandatory')
if mibBuilder.loadTexts: ausmPortStateImaGrpTable.setDescription('The state table for the IMA port interface: there are 8 entries for the 8 (maximum possible) IMA groups ')
ausmPortStateImaGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 4, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "imaStatePortNum"))
if mibBuilder.loadTexts: ausmPortStateImaGrpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ausmPortStateImaGrpEntry.setDescription(' An entry for every IMA group ')
imaStatePortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: imaStatePortNum.setStatus('mandatory')
if mibBuilder.loadTexts: imaStatePortNum.setDescription('This is the logical port number This object does not have any default value ')
imaPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 20))).clone(namedValues=NamedValues(("unconfigured", 1), ("active", 2), ("bandwidthChanged", 3), ("failedDueToAcpTimeout", 4), ("failedDueToMajorAlmonImaGrp", 5), ("failedDueToImaSigFailure", 6), ("failedDueToBadDiffDelay", 7), ("failedDueToArbConflict", 8), ("receivingLoamAis", 9), ("receivingLoamRdi", 10), ("failedDueToIlmiSignalling", 20)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: imaPortState.setStatus('mandatory')
if mibBuilder.loadTexts: imaPortState.setDescription('Indicates the state of the IMA port. The following error conditions are currently reported: 1 - Unconfigured state 2 - Active state 3 - Bandwidth changed due to addition/deletion of links. The addition/deletion can be triggered by either end 4 - FailedDueToACPTimeout (indicates that a timeout occurred due to non-arrival of an ACP cell) 5 - FailedDueToMajorAlarmOnIMAGroup (issued when the bandwidth of an IMA group falls below a certain threshold due to loss of links from an IMA group) 6 - FailedDueToImaSigFailure (this indicates configuration mismatch or non-arrival of LCP cells during set up of an IMA group) 7 - FailedDueToBadDiffDelay (indicates that the differential delay exceeded the maximum threshold) 8 - FailedDueToArbConflict (indicates that the IMA-ID could not be resolved between the 2 ends of the IMA pipe) 9 - Receiving Local OAM AIS from peer IMA node (valid only for network modules) 10- Receiving LOAM RDI from peer IMA node (valud only for network modules) 20- Failed due to ILMI signalling failure This object does not have any default value ')
numLinksPresentInImaGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: numLinksPresentInImaGroup.setStatus('mandatory')
if mibBuilder.loadTexts: numLinksPresentInImaGroup.setDescription('Indicates the number of links that are currently present in the IMA group. This object does not have any default value Same as axisImaGroupNumTxActLnks in Forum Compliant Ima. ')
listLinksPresentInImaGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 4, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: listLinksPresentInImaGroup.setStatus('mandatory')
if mibBuilder.loadTexts: listLinksPresentInImaGroup.setDescription('Indicates the list of links currently present in the IMA group. Different links in the IMA group are delimited by dots. The position of each link in the displayed string indicates the relative order of the links in the round-robin (multiplexing order) This object does not have any default value ')
remoteImaId = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: remoteImaId.setStatus('mandatory')
if mibBuilder.loadTexts: remoteImaId.setDescription('Indicates the IMA-ID in use at the remote end when sending LCP/ACP cells. Same as axisImaGroupRxImaId in Forum Compliant Ima . This object does not have any default value ')
locImaId = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 4, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: locImaId.setStatus('mandatory')
if mibBuilder.loadTexts: locImaId.setDescription('Indicates the IMA-ID in use at the local end when sending LCP/ACP cells. This is same as axisImaGroupTxImaId in Forum Compliant Ima This object does not have any default value ')
imaArbitrationWinner = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 4, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("isUnknown", 1), ("isWinner", 2), ("isLoser", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: imaArbitrationWinner.setStatus('mandatory')
if mibBuilder.loadTexts: imaArbitrationWinner.setDescription('Result of arbitration between the two ends of the IMA pipe. This object does not have any default value Retaining for the backward compatibility. Not supported in Forum Compliant Ima. ')
imaObsDiffDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 4, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: imaObsDiffDelay.setStatus('mandatory')
if mibBuilder.loadTexts: imaObsDiffDelay.setDescription('The observed differential delay in milliseconds between the different physical links in the IMA group This object does not have any default value Same as axisImaGroupDiffDelayMaxObs in Forum Compliant Ima. ')
imaPortOversubscribed = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 4, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: imaPortOversubscribed.setStatus('mandatory')
if mibBuilder.loadTexts: imaPortOversubscribed.setDescription('This variable indicates whether the port is over-subscribed or not This object does not have any default value ')
imaPortIngrPercentUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 4, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: imaPortIngrPercentUtil.setStatus('mandatory')
if mibBuilder.loadTexts: imaPortIngrPercentUtil.setDescription('Percent Utilization of the IMA Port in the Ingress direction This object does not have any default value ')
imaPortEgrPercentUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 4, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: imaPortEgrPercentUtil.setStatus('mandatory')
if mibBuilder.loadTexts: imaPortEgrPercentUtil.setDescription('Percent Utilization of the IMA Port in the Egress direction This object does not have any default value ')
axisImaGroupRxAvailCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 4, 1, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: axisImaGroupRxAvailCellRate.setStatus('mandatory')
if mibBuilder.loadTexts: axisImaGroupRxAvailCellRate.setDescription('The current cell-rate (truncated value in cells per second) provided by this IMA group in the receive direction,considering all the receive links in the active state. ')
axisImaGroupFeState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 4, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("notConfigured", 1), ("startUp", 2), ("startUpAck", 3), ("configAbortUnsupportedM", 4), ("configAbortIncompatibleSymmetry", 5), ("configAbortOther", 6), ("insufficientLinks", 7), ("blocked", 8), ("operational", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: axisImaGroupFeState.setStatus('mandatory')
if mibBuilder.loadTexts: axisImaGroupFeState.setDescription("The current operational state of the far-end IMA group state machine 1) notConfigured : The Group doesn't exist.This is the GSM initial state. 2) startUp : On UM configuring the IMA group,GSM comes to this state. 3) startUpAck : On getting the Start-up-ack from FE(this info from received ICP cell. i.e. FE accepting the proposed group parameters by this END.), GSM goes to this state. 4) configAbortUnsupportedM : This state is entered when FE is not accepting the parameter M. 5) configAbortIncompatibleSymmetry : When Group symmetry is not supported by the FE,this group is entered. 6) configAbortOther : If any of the other group parameters are not supported by the FE,then this state is entered. 7) insufficientLinks : On getting one of the following events from FE, when GSM is in startUpAck state,GSM moves to insufficientLinks state. evens : 1) Start-up-ack 2) insufficient links 3) Blocked or operational 8) blocked : For to maintenance purpose,if group is blcoked (inhibited by UM),GSM goes to this state. 9) operational : When the group has sufficient links in both Tx and Rx directions GSM goes to this state. ")
axisImaGroupFailureStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 4, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("noFailure", 1), ("startUpNe", 2), ("startUpFe", 3), ("invalidMValueNe", 4), ("invalidMValueFe", 5), ("failedAssymetricNe", 6), ("failedAssymetricFe", 7), ("insufficientLinksNe", 8), ("insufficientLinksFe", 9), ("blockedNe", 10), ("blockedFe", 11), ("otherFailure", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: axisImaGroupFailureStatus.setStatus('mandatory')
if mibBuilder.loadTexts: axisImaGroupFailureStatus.setDescription("The current failure status of the IMA group(the reason why the GTSM is in the DOWN state. 1) noFailure : The group is UP. 2) startUpNe : When the NE GSM is in startUp state. 3) startUpFe : When the FE GSM is in startUp state. 4) invalidMValueNe : If FE doesn't support M value this end 5) invalidMValueFe : When the FE M value is not supported by NE. 6) failedAssymetricNe : If FE doesn't support Assymetric operation of the NE. 7) failedAssymetricFe : When the FE assymetry is not supported by the NE. 8) insufficientLinksNe: When the NE is in insufficient links state 9) insufficientLinksFe: If the FE is in insufficient links state and if that message is conveyed to this end by ICP cell. 10) blockedNe : If the GSM is in blocked state. 11) blockedFe : If the FE is in blocked state. 12) otherFailure: Start-up-ack and others. ")
axisImaGroupFeTxClkMode = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 4, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ctc", 1), ("itc", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: axisImaGroupFeTxClkMode.setStatus('mandatory')
if mibBuilder.loadTexts: axisImaGroupFeTxClkMode.setDescription('Transmit clocking mode used by the far-end IMA group.')
axisImaGroupTxTimingRefLink = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 4, 1, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: axisImaGroupTxTimingRefLink.setStatus('mandatory')
if mibBuilder.loadTexts: axisImaGroupTxTimingRefLink.setDescription('The IfIndex of the transmit timing reference link to be used by the near-end for IMA data cell clock recovery from the ATM layer. ')
axisImaGroupRxTimingRefLink = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 4, 1, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: axisImaGroupRxTimingRefLink.setStatus('mandatory')
if mibBuilder.loadTexts: axisImaGroupRxTimingRefLink.setDescription('The IfIndex of the receive timing reference link to be used by the near-end for IMA data cell clock recovery toward the ATM layer. ')
axisImaGroupLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 4, 1, 1, 18), OctetString().subtype(subtypeSpec=ValueSizeConstraint(11, 11)).setFixedLength(11)).setMaxAccess("readonly")
if mibBuilder.loadTexts: axisImaGroupLastChange.setStatus('mandatory')
if mibBuilder.loadTexts: axisImaGroupLastChange.setDescription("The time-of-day the IMA group last changed operational state( i.e. value of axisImaGroupNeState changed.) SPLAY-HINT 2d-1d-1d,1d:1d:1d.1d,1a1d:1d field octets contents range ----- ------ -------- ----- 1 1-2 year 0..65536 2 3 month 1..12 3 4 day 1..31 4 5 hour 0..23 5 6 minutes 0..59 6 7 seconds 0..60 (use 60 for leap-second) 7 8 deci-seconds 0..9 8 9 direction from UTC '+' / '-' 9 10 hours from UTC 0..11 10 11 minutes from UTC 0..59 For example, Tuesday May 26, 1992 at 1:30:15 PM EDT would be displayed as: 1992-5-26,13:30:15.0,-4:0 Note that if only local time is known,then,timezone information (fields 8- 10) is not present. This variable is not supported anymore in forum Ima. ")
axisImaGroupRxFrameLength = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 4, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(32, 64, 128, 256))).clone(namedValues=NamedValues(("m32", 32), ("m64", 64), ("m128", 128), ("m256", 256)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: axisImaGroupRxFrameLength.setStatus('mandatory')
if mibBuilder.loadTexts: axisImaGroupRxFrameLength.setDescription('Value of IMA frame length as received from remote IMA function. ')
axisImaGroupLeastDelayLink = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 4, 1, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: axisImaGroupLeastDelayLink.setStatus('mandatory')
if mibBuilder.loadTexts: axisImaGroupLeastDelayLink.setDescription('The IfIndex of the link configured in the IMA group which has the smallest link propagation delay. This value has meaning only if at least 1 link has been configured in IMA group. ')
axisImaGroupNumRxActLnks = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 4, 1, 1, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: axisImaGroupNumRxActLnks.setStatus('mandatory')
if mibBuilder.loadTexts: axisImaGroupNumRxActLnks.setDescription('The number of links which are configured to receive and are currently Active in this IMA group. ')
axisImaGroupNeState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 4, 1, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("notConfigured", 1), ("startUp", 2), ("startUpAck", 3), ("configAbortUnsupportedM", 4), ("configAbortIncompatibleSymmetry", 5), ("configAbortOther", 6), ("insufficientLinks", 7), ("blocked", 8), ("operational", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: axisImaGroupNeState.setStatus('mandatory')
if mibBuilder.loadTexts: axisImaGroupNeState.setDescription("The current operational state of the near-end IMA group state machine. 1) notConfigured : The Group doesn't exist.This is the GSM initial state. 2) startUp : On UM configuring the IMA group,GSM comes to this state. 3) startUpAck : On getting the Start-up-ack from FE(this info from received ICP cell. i.e. FE accepting the proposed group parameters by this END.), GSM goes to this state. 4) configAbortUnsupportedM : This state is entered when FE is not accepting the parameter M. 5) configAbortIncompatibleSymmetry : When Group symmetry is not supported by the FE,this group is entered. 6) configAbortOther : If any of the other group parameters are not supported by the FE,then this state is entered. 7) insufficientLinks : On getting one of the following events from FE, when GSM is in startUpAck state,GSM moves to insufficientLinks state. evens : 1) Start-up-ack 2) insufficient links 3) Blocked or operational 8) blocked : For to maintenance purpose,if group is blcoked (inhibited by UM),GSM goes to this state. 9) operational : When the group has sufficient links in both Tx and Rx directions GSM goes to this state. ")
axisImaGroupNumber = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 4, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: axisImaGroupNumber.setStatus('mandatory')
if mibBuilder.loadTexts: axisImaGroupNumber.setDescription('The number of IMA groups configured with the lines.')
imatmClkCfgGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 3, 8))
primaryClockSource = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 8, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("liu-rclk0", 1), ("liu-rclk1", 2), ("liu-rclk2", 3), ("liu-rclk3", 4), ("liu-rclk4", 5), ("liu-rclk5", 6), ("liu-rclk6", 7), ("liu-rclk7", 8), ("dsx3", 9), ("bp8clk", 10))).clone('bp8clk')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: primaryClockSource.setStatus('mandatory')
if mibBuilder.loadTexts: primaryClockSource.setDescription('Primary reference for the clock source. Each of these codes are to be interpreted as follows: liu-rclk0: Recovered clock from physical line 0 liu-rclk1: Recovered clock from physical line 1 liu-rclk2: Recovered clock from physical line 2 liu-rclk3: Recovered clock from physical line 3 liu-rclk4: Recovered clock from physical line 4 liu-rclk5: Recovered clock from physical line 5 liu-rclk6: Recovered clock from physical line 6 liu-rclk7: Recovered clock from physical line 7 dsx3: Recovered clock from the T3/E3 line bp8clk: Back-plane 8 KHz clock ')
secondaryClockSource = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 8, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("liu-rclk0", 1), ("liu-rclk1", 2), ("liu-rclk2", 3), ("liu-rclk3", 4), ("liu-rclk4", 5), ("liu-rclk5", 6), ("liu-rclk6", 7), ("liu-rclk7", 8), ("dsx3", 9), ("bp8clk", 10), ("none", 11))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: secondaryClockSource.setStatus('mandatory')
if mibBuilder.loadTexts: secondaryClockSource.setDescription('Secondary reference for the clock source. Each of these codes are to be interpreted as follows: liu-rclk0: Recovered clock from physical line 0 liu-rclk1: Recovered clock from physical line 1 liu-rclk2: Recovered clock from physical line 2 liu-rclk3: Recovered clock from physical line 3 liu-rclk4: Recovered clock from physical line 4 liu-rclk5: Recovered clock from physical line 5 liu-rclk6: Recovered clock from physical line 6 liu-rclk7: Recovered clock from physical line 7 dsx3: Recovered clock from the T3/E3 line bp8clk: Back-plane 8 KHz clock none : No secondary clock is configured ')
currentClockSource = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 8, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("primary", 1), ("secondary", 2), ("internal", 3))).clone('primary')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: currentClockSource.setStatus('mandatory')
if mibBuilder.loadTexts: currentClockSource.setDescription('This object holds the current source for the clock ')
imatmDsx3CntrsGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 3, 9))
imatmDsx3PortCntrsGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 3, 9, 1), )
if mibBuilder.loadTexts: imatmDsx3PortCntrsGrpTable.setStatus('mandatory')
if mibBuilder.loadTexts: imatmDsx3PortCntrsGrpTable.setDescription('The dsx3 port counters table is for the DS3 port in IMATM. At present there is only one entry (corresponding to the single DS3 port available). This structure has been made a table for flexibility (although there is only one entry in the table at present) ')
imatmDsx3PortCntrsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 3, 9, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "imatmDsx3PortIndex"))
if mibBuilder.loadTexts: imatmDsx3PortCntrsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: imatmDsx3PortCntrsEntry.setDescription('An entry for each T3 port (total of only one entry at present) ')
imatmDsx3PortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 9, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1))).setMaxAccess("readonly")
if mibBuilder.loadTexts: imatmDsx3PortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: imatmDsx3PortIndex.setDescription('Index to the dsx3 port number ')
imatmDsx3PortRcvCells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 9, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: imatmDsx3PortRcvCells.setStatus('mandatory')
if mibBuilder.loadTexts: imatmDsx3PortRcvCells.setDescription('Number of cells received on the DS3 port ')
imatmDsx3PortXmtCells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 9, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: imatmDsx3PortXmtCells.setStatus('mandatory')
if mibBuilder.loadTexts: imatmDsx3PortXmtCells.setDescription('Number of cells transmitted on the DS3 port ')
imatmPortRcvInvCells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 9, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: imatmPortRcvInvCells.setStatus('mandatory')
if mibBuilder.loadTexts: imatmPortRcvInvCells.setDescription('Number of invalid cells received on the DS3 port ')
imatmPortCntrClrButton = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 9, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noaction", 1), ("clear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: imatmPortCntrClrButton.setStatus('mandatory')
if mibBuilder.loadTexts: imatmPortCntrClrButton.setDescription('This variable is used to clear all the counters maintained by the card for this DS3 port ')
imatmDsx3PortLastMismatchVpiVci = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 9, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: imatmDsx3PortLastMismatchVpiVci.setStatus('mandatory')
if mibBuilder.loadTexts: imatmDsx3PortLastMismatchVpiVci.setDescription('This variable denotes the last mismatch VPI/VCI value that was received over the DS3 interface. ')
imatmPortImaCtrlMatchCells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 9, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: imatmPortImaCtrlMatchCells.setStatus('mandatory')
if mibBuilder.loadTexts: imatmPortImaCtrlMatchCells.setDescription('This variable is used to count the number of cells from the DS3 interface that were discarded due to match with IMA Control header ')
dsx3CardSpecCnfgGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 3, 14))
imatmDsx3CardSpecConfigGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 3, 14, 1), )
if mibBuilder.loadTexts: imatmDsx3CardSpecConfigGrpTable.setStatus('mandatory')
if mibBuilder.loadTexts: imatmDsx3CardSpecConfigGrpTable.setDescription('The dsx3 Card spec Config group table will contain all the configuration variable for DSX3. Right now there is only one configurable parameter in this group. Moreover this structure has been made a table for flexibility (although there is only one entry in the table at present). ')
imatmDsx3CardSpecConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 3, 14, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "imatmdsx3PortIndex"))
if mibBuilder.loadTexts: imatmDsx3CardSpecConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: imatmDsx3CardSpecConfigEntry.setDescription('Each entry gives the config parameters for the given port.')
imatmdsx3PortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 14, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1))).setMaxAccess("readonly")
if mibBuilder.loadTexts: imatmdsx3PortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: imatmdsx3PortIndex.setDescription('Index to the dsx3 port number ')
imatmDsx3SingleBitErrCorrEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 14, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: imatmDsx3SingleBitErrCorrEnable.setStatus('mandatory')
if mibBuilder.loadTexts: imatmDsx3SingleBitErrCorrEnable.setDescription('This variable refers to dsx3 HEC correction enabled/disabled default is disable.')
imatmVpTrkGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 3, 13))
imatmVpTrkMapGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 3, 13, 1))
imatmVpTrkMapGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 3, 13, 1, 1), )
if mibBuilder.loadTexts: imatmVpTrkMapGrpTable.setStatus('mandatory')
if mibBuilder.loadTexts: imatmVpTrkMapGrpTable.setDescription('The imatmVpTrkMapGrpTable entry contains the information for mapping VPI ranges to different trunks in IMATM. ')
imatmVpTrkMapGrpTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 3, 13, 1, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "imatmRangeNum"))
if mibBuilder.loadTexts: imatmVpTrkMapGrpTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: imatmVpTrkMapGrpTableEntry.setDescription('An entry for each VPI range ')
imatmRangeNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 13, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: imatmRangeNum.setStatus('mandatory')
if mibBuilder.loadTexts: imatmRangeNum.setDescription('An index to the VpTrkTbl ')
imatmTrkNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 13, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: imatmTrkNum.setStatus('mandatory')
if mibBuilder.loadTexts: imatmTrkNum.setDescription('This variable refers to the trunk number on the IMATM card. The trunk number is the same as logical port number. ')
imatmTrkMinVp = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 13, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: imatmTrkMinVp.setStatus('mandatory')
if mibBuilder.loadTexts: imatmTrkMinVp.setDescription('This variable refers to the minimum VPI value to be configured in the range of VPIs that are to be mapped to an IMATM trunk. ')
imatmTrkMaxVp = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 13, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: imatmTrkMaxVp.setStatus('mandatory')
if mibBuilder.loadTexts: imatmTrkMaxVp.setDescription('This variable refers to the maximum VPI value to be configured in the range of VPIs that are to be mapped to an IMATM trunk. It should be necessarily greater than or equal to the value of imatmTrkMinVp. ')
imatmTrkOpType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 13, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2), ("modify", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: imatmTrkOpType.setStatus('mandatory')
if mibBuilder.loadTexts: imatmTrkOpType.setDescription("This variable refers to the operation type for the VPI range in question. 'disable' deletes an existing row from the table 'enable' adds a new row to the table 'modify' modifies the attributes of an existing row to the table ")
nextRangeNumAvail = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 13, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nextRangeNumAvail.setStatus('mandatory')
if mibBuilder.loadTexts: nextRangeNumAvail.setDescription('This variable indicates the next range number to be used as the index for the VpTrkTbl. ')
imatmVpTrkClrGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 3, 13, 2))
imatmVpTrkClrGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 3, 13, 2, 1), )
if mibBuilder.loadTexts: imatmVpTrkClrGrpTable.setStatus('mandatory')
if mibBuilder.loadTexts: imatmVpTrkClrGrpTable.setDescription('This table is for each trunk in IMATM and is used if the user wishes to remove all VPI ranges for an IMATM trunk. ')
imatmVpTrkClrGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 3, 13, 2, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "imatmClrVpTrkNum"))
if mibBuilder.loadTexts: imatmVpTrkClrGrpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: imatmVpTrkClrGrpEntry.setDescription('An entry for each IMATM trunk ')
imatmClrVpTrkNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 13, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: imatmClrVpTrkNum.setStatus('mandatory')
if mibBuilder.loadTexts: imatmClrVpTrkNum.setDescription("This variable is used to identify the IMATM trunk number on which the 'Clear Map Table' operation needs to be done. ")
imatmClrVpTrkButton = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 3, 13, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noaction", 1), ("clear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: imatmClrVpTrkButton.setStatus('mandatory')
if mibBuilder.loadTexts: imatmClrVpTrkButton.setDescription("This variable implements the 'Clear Map Table' for a specified IMATM trunk. ")
imaAutoRestartFeature = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 3, 21))
imaAutoRestart = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 21, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: imaAutoRestart.setStatus('mandatory')
if mibBuilder.loadTexts: imaAutoRestart.setDescription(' This object allows the user to enable/disable the IMA group auto-restart feature on IMA capable cards. The effect of this object is card-wide. A value of 1 disables the feature. A value of 2 enables the feature. ')
commonChannel = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 2, 7))
commonChanTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 2, 7, 1), )
if mibBuilder.loadTexts: commonChanTable.setStatus('mandatory')
if mibBuilder.loadTexts: commonChanTable.setDescription('The common port table is for the common ports.')
commonChanTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 2, 7, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "commonChanNum"))
if mibBuilder.loadTexts: commonChanTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: commonChanTableEntry.setDescription(' An entry for every common port group. ')
commonChanNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 2, 7, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 1015))).setMaxAccess("readonly")
if mibBuilder.loadTexts: commonChanNum.setStatus('mandatory')
if mibBuilder.loadTexts: commonChanNum.setDescription('This is the index to the channel number. ')
commonConnType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 2, 7, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("vpc", 1), ("vcc", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: commonConnType.setStatus('mandatory')
if mibBuilder.loadTexts: commonConnType.setDescription('This specifies the connection type 1 ==> Virtual Path Connection 2 ==> Virtual Channel Connection ')
commonChanStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 2, 7, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notconfigured", 1), ("normal", 2), ("alarm", 3))).clone('notconfigured')).setMaxAccess("readonly")
if mibBuilder.loadTexts: commonChanStatus.setStatus('mandatory')
if mibBuilder.loadTexts: commonChanStatus.setDescription('This variable indicates the state of the VC (channel)( ')
commonAlarmState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 2, 7, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: commonAlarmState.setStatus('mandatory')
if mibBuilder.loadTexts: commonAlarmState.setDescription('This is the alarm state of the port. ')
commonChanPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 2, 7, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: commonChanPortNum.setStatus('mandatory')
if mibBuilder.loadTexts: commonChanPortNum.setDescription('This variable indicates the port number associated with the channel ')
commonChanServiceType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 2, 7, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("cbr", 1), ("vbr", 2), ("abr", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: commonChanServiceType.setStatus('mandatory')
if mibBuilder.loadTexts: commonChanServiceType.setDescription('This specifies the service type 1 ==> Constant Bit Rate 2 ==> Variable Bit Rate 3 ==> Associated Bit Rate ')
commonChanIngrXmtState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 2, 7, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("normal", 2), ("receivingAis", 3), ("receivingFerf", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: commonChanIngrXmtState.setStatus('mandatory')
if mibBuilder.loadTexts: commonChanIngrXmtState.setDescription('This variable indicates the transmit state of the VC (channel) on the CellBus side (Ingress) ')
commonChanIngrRcvState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 2, 7, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("normal", 2), ("receivingAis", 3), ("receivingFerf", 4), ("alarm", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: commonChanIngrRcvState.setStatus('mandatory')
if mibBuilder.loadTexts: commonChanIngrRcvState.setDescription('This variable indicates the status of port receive (Ingress) ')
commonChanEgrXmtState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 2, 7, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("normal", 2), ("sendingAis", 3), ("sendingFerf", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: commonChanEgrXmtState.setStatus('mandatory')
if mibBuilder.loadTexts: commonChanEgrXmtState.setDescription('indicates the status of port transmit(Egress) ')
commonChanEgrRcvState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 2, 7, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("normal", 2), ("sendingAis", 3), ("sendingFerf", 4), ("alarm", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: commonChanEgrRcvState.setStatus('mandatory')
if mibBuilder.loadTexts: commonChanEgrRcvState.setDescription('Indicates the receiving state of the VC (channel) on the Cellbus side (Egress) ')
commonConnParm1 = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 2, 7, 1, 1, 11), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: commonConnParm1.setStatus('mandatory')
if mibBuilder.loadTexts: commonConnParm1.setDescription('Connection paramter 1 ')
commonConnParm2 = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 2, 7, 1, 1, 12), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: commonConnParm2.setStatus('mandatory')
if mibBuilder.loadTexts: commonConnParm2.setDescription('Connection paramter 2 ')
commonPort = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 2, 6))
commonPortTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 2, 6, 1), )
if mibBuilder.loadTexts: commonPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: commonPortTable.setDescription('The common port table is for the common ports.')
commonPortTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 2, 6, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "commonPortNum"))
if mibBuilder.loadTexts: commonPortTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: commonPortTableEntry.setDescription(' An entry for every common port group. ')
commonPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 2, 6, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: commonPortNum.setStatus('mandatory')
if mibBuilder.loadTexts: commonPortNum.setDescription('This is the index to the port number. ')
commonPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 2, 6, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("framerelayport", 1), ("atmport", 2), ("imaport", 3))).clone('atmport')).setMaxAccess("readonly")
if mibBuilder.loadTexts: commonPortType.setStatus('mandatory')
if mibBuilder.loadTexts: commonPortType.setDescription('This is the type of the port. 1 - Frame Relay Port. 2 - ATM Port. 3 - IMA Port. ')
commonPortStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 2, 6, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('disable')).setMaxAccess("readonly")
if mibBuilder.loadTexts: commonPortStatus.setStatus('mandatory')
if mibBuilder.loadTexts: commonPortStatus.setDescription('This variable enables or disables the port 1 - disable 2 - enable ')
commonPortSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 2, 6, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 37360))).setMaxAccess("readonly")
if mibBuilder.loadTexts: commonPortSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: commonPortSpeed.setDescription('This is the speed of the port in cells per second. ')
commonPortAlarmState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 2, 6, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("inalarm", 1), ("outofalarm", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: commonPortAlarmState.setStatus('mandatory')
if mibBuilder.loadTexts: commonPortAlarmState.setDescription('This variable states the alarm status of the port 1 - port in alarm 2 - port out of alarm ')
commonPortSignallingProtocolType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 2, 6, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("tbd", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: commonPortSignallingProtocolType.setStatus('mandatory')
if mibBuilder.loadTexts: commonPortSignallingProtocolType.setDescription('This variable indicates the signalling protocol type of the port. This field is TBD. It is unused in IMATM/AUSM. ')
commonPortSignallingState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 2, 6, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("tbd", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: commonPortSignallingState.setStatus('mandatory')
if mibBuilder.loadTexts: commonPortSignallingState.setDescription('This variable indicates the signalling state of the port. ')
commonPortAssocLines = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 2, 6, 1, 1, 8), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: commonPortAssocLines.setStatus('mandatory')
if mibBuilder.loadTexts: commonPortAssocLines.setDescription('This variable indicates the list of physical lines in the port delimited by dots. ')
commonPortAssocChannels = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 2, 6, 1, 1, 9), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: commonPortAssocChannels.setStatus('mandatory')
if mibBuilder.loadTexts: commonPortAssocChannels.setDescription('The variable indicates the list of channels that are used in the ds1 frame. ')
ausmChanCnfGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1))
ausmChanCnfGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1), )
if mibBuilder.loadTexts: ausmChanCnfGrpTable.setStatus('mandatory')
if mibBuilder.loadTexts: ausmChanCnfGrpTable.setDescription('The config table is for logical channel interface there are 1000 entries for the 8 logical ports in AUSM (8-port) and 256 entries for the 4 logical ports in AUSM (4-port card). In AUSM (4-port card), a logical port is same as a physical port. ')
ausmChanCnfGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "ausmChanNum"))
if mibBuilder.loadTexts: ausmChanCnfGrpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ausmChanCnfGrpEntry.setDescription(' An entry for logical channel ')
ausmChanNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 1015))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ausmChanNum.setStatus('mandatory')
if mibBuilder.loadTexts: ausmChanNum.setDescription('Refers to the virtual connection index. In AUSM (4-port card), valid range is from 16..271. ')
ausmChanRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("add", 1), ("del", 2), ("mod", 3), ("outOfService", 4))).clone('del')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ausmChanRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ausmChanRowStatus.setDescription("This will add, delete or modify the channel 1 ==> ADD 2 ==> DELETE 3 ==> MODIFY Setting this object to outOfService takes the channel out of service or brings the channel 'down'. The channel can be brought 'up' again by setting the object to mod ")
chanConnType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("vpc", 1), ("vcc", 2))).clone('vcc')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chanConnType.setStatus('mandatory')
if mibBuilder.loadTexts: chanConnType.setDescription('This specifies the connection type 1 ==> Virtual Path Connection 2 ==> Virtual Channel Connection ')
chanServiceType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("cbr", 1), ("vbr", 2), ("abr", 3), ("ubr", 4), ("rtvbr", 5))).clone('cbr')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chanServiceType.setStatus('mandatory')
if mibBuilder.loadTexts: chanServiceType.setDescription('This specifies the service type 1 ==> Constant Bit Rate 2 ==> Variable Bit Rate 3 ==> Available Bit Rate 4 ==> Unspecified Bit Rate 5 ==> Real-Time Variable Bit Rate ')
chanConnDesc = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chanConnDesc.setStatus('mandatory')
if mibBuilder.loadTexts: chanConnDesc.setDescription('A string that has been defined to give a descriptive name to the connection ')
chanSvcFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("svc", 1), ("pvc", 2), ("spvc", 3), ("par", 4), ("pnni", 5), ("tag", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chanSvcFlag.setStatus('mandatory')
if mibBuilder.loadTexts: chanSvcFlag.setDescription('This specifies the connection type 1 ==> SVC connection 2 ==> PVC connection 3 ==> SPVC connection 4 ==> connection added by PAR 5 ==> connection added by PNNI 6 ==> connection added by TAG ')
chanSvcConnId = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chanSvcConnId.setStatus('mandatory')
if mibBuilder.loadTexts: chanSvcConnId.setDescription('This connection ID is for future use Currently not supported ')
ausmChanPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ausmChanPortNum.setStatus('mandatory')
if mibBuilder.loadTexts: ausmChanPortNum.setDescription('Refers to the logical port on the board to which logical channel is associated. In AUSM (4-port card), a logical port is same as a physical port. ')
chanVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chanVpi.setStatus('mandatory')
if mibBuilder.loadTexts: chanVpi.setDescription('The VPI value for this channel ')
chanVci = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chanVci.setStatus('mandatory')
if mibBuilder.loadTexts: chanVci.setDescription('The VCI value for this channel ')
chanEgrQSelect = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chanEgrQSelect.setStatus('mandatory')
if mibBuilder.loadTexts: chanEgrQSelect.setDescription('Selects one out of the 16 possible queues Each queue may have a different service algorithm ')
ingrQDepth = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16000)).clone(1000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ingrQDepth.setStatus('mandatory')
if mibBuilder.loadTexts: ingrQDepth.setDescription('This variable sets the max depth for queue, before it starts dropping the cells. In AUSM (4-port card), the valid range is from 1..8000. ')
ingrQCLPThreshHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ingrQCLPThreshHigh.setStatus('mandatory')
if mibBuilder.loadTexts: ingrQCLPThreshHigh.setDescription('This variable sets the higher threshold for dropping CLP set cells in the ingress direction. In AUSM (4-port card), the valid range is from 1..8000.This value should be less than or equal to ingrQDepth. Default value depends on the ingrQDepth. ')
ingrQCLPThreshLow = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ingrQCLPThreshLow.setStatus('mandatory')
if mibBuilder.loadTexts: ingrQCLPThreshLow.setDescription('This variable sets the lower threshold for dropping CLP set cells in the ingress direction. In AUSM (4-port card), the valid range is from 1..8000.This value should be less than or equal to ingrQCLPThreshHigh. Default value depends on the ingrQDepth. ')
ingrQCLPState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("low", 1), ("high", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ingrQCLPState.setStatus('mandatory')
if mibBuilder.loadTexts: ingrQCLPState.setDescription('This variable indicates the CLP state for the channel ')
ingrQEfciThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16000)).clone(1000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ingrQEfciThresh.setStatus('mandatory')
if mibBuilder.loadTexts: ingrQEfciThresh.setDescription('This variable sets the efci threshold value for setting efci bit in the ingress direction. In AUSM (4-port card), the valid range is from 1..8000.This value should be less than or equal to ingrQDepth. ')
ingrUpcEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ingrUpcEnable.setStatus('mandatory')
if mibBuilder.loadTexts: ingrUpcEnable.setDescription('enables/disables UPC for Ingress cells ')
ingrUpcPCR01 = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 38328))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ingrUpcPCR01.setStatus('mandatory')
if mibBuilder.loadTexts: ingrUpcPCR01.setDescription("Peak Cell Rate for CLP [0+1] cells. The actual value depends on the speed of the logical port (which can be a T1, E1 (normal), E1 (clear), IMA T1, IMA E1 (normal) or IMA E1 (clear) port. Note that the IMA port's speed is variable and depends on the number of links in the port. In AUSM (4-port), maximum value is 4830. ")
ingrUpcCIR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 38328))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ingrUpcCIR.setStatus('mandatory')
if mibBuilder.loadTexts: ingrUpcCIR.setDescription("Complaint Information Rate. The actual value depends on the speed of the logical port (which can be a T1, E1 (normal), E1 (clear), IMA T1, IMA E1 (normal) or IMA E1 (clear) port. Note that the IMA port's speed is variable and depends on the number of links in the port. In AUSM (4-port), maximum value is 4830. ")
ingrUpcCCDV = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 250000)).clone(10000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ingrUpcCCDV.setStatus('mandatory')
if mibBuilder.loadTexts: ingrUpcCCDV.setDescription('Complaint Cell Delay Variation for all cells ')
ingrUpcCBS = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5000)).clone(1000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ingrUpcCBS.setStatus('mandatory')
if mibBuilder.loadTexts: ingrUpcCBS.setDescription('Complaint Burst Size The unit of this parameter is in terms of number of cells. CBS is applicable only for VBR and ABR connections. In MGX switches, release 3.0.0.0 and above, the default value is 1024 ')
ingrUpcIBS = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4830)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ingrUpcIBS.setStatus('mandatory')
if mibBuilder.loadTexts: ingrUpcIBS.setDescription('Initial Burst Size. The Burst size allowed for a connection that has been idle for some time. The unit of this parameter is in terms of number of cells. IBS is applicable only for VBR and ABR connections. IBS value should be less than CBS for VBR and ABR connections. IBS value will be ignored for other service types. ')
ingrUpcMFS = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 200))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ingrUpcMFS.setStatus('mandatory')
if mibBuilder.loadTexts: ingrUpcMFS.setDescription('Maximum Frame Size ')
ingrUpcSCRPolicing = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("clp0", 1), ("clp0and1", 2), ("off", 3))).clone('clp0')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ingrUpcSCRPolicing.setStatus('mandatory')
if mibBuilder.loadTexts: ingrUpcSCRPolicing.setDescription('selects SCR policing for CLP = 0 or all cells ')
ingrUpcPCR0 = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 38328))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ingrUpcPCR0.setStatus('mandatory')
if mibBuilder.loadTexts: ingrUpcPCR0.setDescription("Peak Cell Rate for CLP=0 cells. The actual value depends on the speed of the logical port (which can be a T1, E1 (normal), E1 (clear), IMA T1, IMA E1 (normal) or IMA E1 (clear) port. Note that the IMA port's speed is variable and depends on the number of links in the port. In AUSM (4-port), maximum value is 4830. ")
ingrUpcCDVT0 = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 250000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ingrUpcCDVT0.setStatus('mandatory')
if mibBuilder.loadTexts: ingrUpcCDVT0.setDescription('Complaint Cell Delay Variation for CLP=0 cells ')
ingrUpcCLPTagEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ingrUpcCLPTagEnable.setStatus('mandatory')
if mibBuilder.loadTexts: ingrUpcCLPTagEnable.setDescription('enables/disables CLP tagging for Ingress cells ')
ingrUpcFGCRAEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ingrUpcFGCRAEnable.setStatus('mandatory')
if mibBuilder.loadTexts: ingrUpcFGCRAEnable.setDescription('enables/disables Frame based GCRA ')
foresightEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: foresightEnable.setStatus('mandatory')
if mibBuilder.loadTexts: foresightEnable.setDescription('enables/disables Foresight ')
foresightMIR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 30), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 38328))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: foresightMIR.setStatus('mandatory')
if mibBuilder.loadTexts: foresightMIR.setDescription("Minimum Information Rate. The actual value depends on the speed of the logical port (which can be a T1, E1 (normal), E1 (clear), IMA T1, IMA E1 (normal) or IMA E1 (clear) port. Note that the IMA port's speed is variable and depends on the number of links in the port. In AUSM (4-port), maximum value is 4830. ")
foresightPIR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 31), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 38328))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: foresightPIR.setStatus('mandatory')
if mibBuilder.loadTexts: foresightPIR.setDescription("Peak Information Rate. The actual value depends on the speed of the logical port (which can be a T1, E1 (normal), E1 (clear), IMA T1, IMA E1 (normal) or IMA E1 (clear) port. Note that the IMA port's speed is variable and depends on the number of links in the port. In AUSM (4-port), maximum value is 4830. ")
foresightQIR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 32), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 38328))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: foresightQIR.setStatus('mandatory')
if mibBuilder.loadTexts: foresightQIR.setDescription("Quiescent Information Rate. The actual value depends on the speed of the logical port (which can be a T1, E1 (normal), E1 (clear), IMA T1, IMA E1 (normal) or IMA E1 (clear) port. Note that the IMA port's speed is variable and depends on the number of links in the port. In AUSM (4-port), maximum value is 4830. ")
ausmChanLocRmtLpbkState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ausmChanLocRmtLpbkState.setStatus('mandatory')
if mibBuilder.loadTexts: ausmChanLocRmtLpbkState.setDescription('The default is disable. This variable enables or disables the remote loopback for each channel. When you enable this option on a connection (channel) then all the cells that are coming from the network side would be looped back toward the network and all the frames coming from the user side would be dropped. This channel remote loopback has nothing to do with the chanTestType option, each one does a different function. For example, the channel remote loopback is used for looping the data toward the network and if this connection is terminated on an IPX then they can put a test equipment and measure some of the characteristics of the network. 1 = enable 2 = disable ')
ausmChanTestType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("testcon", 1), ("testdelay", 2), ("notest", 3))).clone('notest')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ausmChanTestType.setStatus('mandatory')
if mibBuilder.loadTexts: ausmChanTestType.setDescription('The default is notest. The chanTestType starts testing the continuity or delay of a connection. It sends specific cell patterns toward the network and the terminating end of this connection has to be an AXIS or ASI of a BPX in order for this test to be working. The receiving node would loop back when it receives these cells. The test should be done in about couple of seconds. The testcon tests the continuity of the connection and testdelay uses the same test except that it measures for delay through the network. To test the delay follow this procedure: a- set chanTestType to testdelay b- read chanTestState till it is Pass or Fail c- Read chanRTDResult for the delay if it is Pass *Note that the chanTestType would go back to notest when the test is completed To test the continuity follow this procedure: a- set chanTestType to testcon b- read chanTestState till it is Pass or Fail *Note that the chanTestType would go back to notest when the test is completed You CAN NOT select 2 tests back to back, you have selcelt one and wait the result and then start the other one. SYNTAX When you select testdelay This is the type of the test 1 = Test Continuity 2 = Test Delay 3 = No Test ')
ausmChanTestState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("passed", 1), ("failed", 2), ("inprogress", 3), ("notinprogress", 4))).clone('notinprogress')).setMaxAccess("readonly")
if mibBuilder.loadTexts: ausmChanTestState.setStatus('mandatory')
if mibBuilder.loadTexts: ausmChanTestState.setDescription('This shows the state of the test When you add a connection then the chanTestState becomes notinprogress and when you select any test, it would go to inprogress state and after it completes the test, it will go to failed or passed state. 1 = Passed 2 = Failed 3 = In Progress 4 = Not In Progress ')
ausmChanRTDResult = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 36), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ausmChanRTDResult.setStatus('mandatory')
if mibBuilder.loadTexts: ausmChanRTDResult.setDescription('This is round trip delay in milliseconds. When you select testdelay option for the chanTestType, the result of the test that is measured in milliseconds can be read in chanRTDResult. ')
ausmChanTestTypeCPESide = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 37), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("testconseg", 1), ("notest", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ausmChanTestTypeCPESide.setStatus('mandatory')
if mibBuilder.loadTexts: ausmChanTestTypeCPESide.setDescription('The default is notest. The chanTestType starts testing the segment continuity of a connection. It sends OAM Segment loopback cell towards port side (CPE) The CPE would loop back the cell To test the continuity follow this procedure: a- set chanTestTypeCPEside to testconseg b- read chanTestState till it is Pass or Fail *Note that the chanTestType would go back to notest when the test is completed SYNTAX When you select testdelay This is the type of the test 1 = Test Continuity 2 = No Test ')
ausmChanTestStateCPESide = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 38), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("passed", 1), ("failed", 2), ("inprogress", 3), ("notinprogress", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ausmChanTestStateCPESide.setStatus('mandatory')
if mibBuilder.loadTexts: ausmChanTestStateCPESide.setDescription('This shows the state of the test When you add a connection then the chanTestState becomes notinprogress and when you select any test, it would go to inprogress state and after it completes the test, it will go to failed or passed state. 1 = Passed 2 = Failed 3 = In Progress 4 = Not In Progress ')
ausmChanIngrPercentUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 39), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127)).clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ausmChanIngrPercentUtil.setStatus('mandatory')
if mibBuilder.loadTexts: ausmChanIngrPercentUtil.setDescription('Percentage Utilization of the IngrService Rate. This is used for connection admission control. ')
ausmChanEgrPercentUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 40), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127)).clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ausmChanEgrPercentUtil.setStatus('mandatory')
if mibBuilder.loadTexts: ausmChanEgrPercentUtil.setDescription('Percentage Utilization of the EgrService Rate. This is used for egress bandwidth calculation and connection admission control. ')
ausmChanEgrSrvRate = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 41), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 38328))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ausmChanEgrSrvRate.setStatus('mandatory')
if mibBuilder.loadTexts: ausmChanEgrSrvRate.setDescription(" Egress service rate - This is used for egress bandwidth calculation and for connection admission control. The actual value depends on the speed of the logical port (which can be a T1, E1 (normal), E1 (clear), IMA T1, IMA E1 (normal) or IMA E1 (clear) port. Note that the IMA port's speed is variable and depends on the number of links in the port. In AUSM (4-port), maximum value is 4830. ")
ausmChanOvrSubOvrRide = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 42), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ausmChanOvrSubOvrRide.setStatus('mandatory')
if mibBuilder.loadTexts: ausmChanOvrSubOvrRide.setDescription('This MIB variable allows one to add a new connection on a port even if it is over subscribed. ')
ausmChanLocalVpId = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 43), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 340))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ausmChanLocalVpId.setStatus('mandatory')
if mibBuilder.loadTexts: ausmChanLocalVpId.setDescription(' Every VP connection will have a unique local VpId between 1 to 340. This is sent to ASC at the time of vp connection setup. This number along with the slot number will form a number which is unique across the shelf. This will be set only at the time adding the connection. This range varies dpending on the BNM interface. For STI 1..100 For UNI 1..20 For NNI 1..340 In case of AUSM-4P maximum localVpId can be only 1..255 ')
ausmChanRMEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 44), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ausmChanRMEnable.setStatus('mandatory')
if mibBuilder.loadTexts: ausmChanRMEnable.setDescription('enables/disables sending Resource Mangement Cells ')
ausmIngrDiscardOption = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 45), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clpHysterisis", 1), ("frameDiscard", 2))).clone('clpHysterisis')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ausmIngrDiscardOption.setStatus('mandatory')
if mibBuilder.loadTexts: ausmIngrDiscardOption.setDescription('This variable specifies whether Frame based Discard is to be enabled or CLP Threshold is to be used for determining the criterion for dropping cells. FrameDiscard enables the EPD/PPD features ')
ausmIngrFrDiscardThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 46), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ausmIngrFrDiscardThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: ausmIngrFrDiscardThreshold.setDescription('This variable specifies the Ingress Frame Discard Threshold. Valid only when Ingress Frame Discard option is selected. By default, the value of this variable would be the peak queue depth of the queue. The value of this variable should be less than the peak queue depth that is configured for the queue ')
ausmCDRNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 47), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ausmCDRNumber.setStatus('mandatory')
if mibBuilder.loadTexts: ausmCDRNumber.setDescription('This is the key to correlate cell/frame counts, start/end record. ')
ausmLocalVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 48), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ausmLocalVpi.setStatus('mandatory')
if mibBuilder.loadTexts: ausmLocalVpi.setDescription('This VPI has different meaning with the end point VPI (CPE), it can be same with the end point VPI but not necessary, it represents the local end point VPI, this object is read only, therefore, SM is responsible to assign a value to it. ')
ausmLocalVci = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 49), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ausmLocalVci.setStatus('mandatory')
if mibBuilder.loadTexts: ausmLocalVci.setDescription('This VCI has different meaning with the end point VCI (CPE), it can be same with the end point VPI but not necessary it represents the local end point VCI, this object is read only, therefore, SM is responsible to assign a value to it. ')
ausmLocalNSAP = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 50), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ausmLocalNSAP.setStatus('mandatory')
if mibBuilder.loadTexts: ausmLocalNSAP.setDescription('This NSAP is 20 bytes binary, among these 20 bytes: 13 bytes as prefix, 2 bytes for Cisco ID, 2 bytes rsvd, 2 bytes for slot (5 bits) and port number (11 bits), and 1 byte for SEL')
ausmRemoteVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 51), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ausmRemoteVpi.setStatus('mandatory')
if mibBuilder.loadTexts: ausmRemoteVpi.setDescription('This VPI has different with the remote end point VPI (CPE), this is similar to a connection ID and it can be same with the remote end point VPI but not necessary')
ausmRemoteVci = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 52), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ausmRemoteVci.setStatus('mandatory')
if mibBuilder.loadTexts: ausmRemoteVci.setDescription('This VCI has different with the remote end point VCI (CPE), this is similar to a connection ID and it can be same with the remote end point VPI but not necessary')
ausmRemoteNSAP = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 53), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ausmRemoteNSAP.setStatus('mandatory')
if mibBuilder.loadTexts: ausmRemoteNSAP.setDescription('This NSAP is 20bytes binary, among these 20 bytes: 13 bytes as prefix, 2 bytes for Cisco ID, 2 bytes rsvd, 2 bytes for slot (5 bits) and port number (11 bits), and 1 byte for SEL')
ausmMastership = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 54), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("master", 1), ("slave", 2), ("unknown", 3))).clone('slave')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ausmMastership.setStatus('mandatory')
if mibBuilder.loadTexts: ausmMastership.setDescription(' This is used by PXM to determine if this end point is master or slave. In AXIS shelf, unknown is always used, but in MGX shelf, if unknown is set, PXM will fail the set request. ')
ausmVpcFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 55), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("vpc", 1), ("vcc", 2))).clone('vcc')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ausmVpcFlag.setStatus('mandatory')
if mibBuilder.loadTexts: ausmVpcFlag.setDescription(' This represents the connection type, used for PXM to identify VPC/VCC ')
ausmConnServiceType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 56), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 5, 6, 7, 8, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32))).clone(namedValues=NamedValues(("cbr", 1), ("vbr", 2), ("ubr", 4), ("atfr", 5), ("abrstd", 6), ("abrfst", 7), ("rtvbr", 8), ("cbr1", 21), ("vbr1rt", 22), ("vbr2rt", 23), ("vbr3rt", 24), ("vbr1nrt", 25), ("vbr2nrt", 26), ("vbr3nrt", 27), ("ubr1", 28), ("ubr2", 29), ("stdabr", 30), ("cbr2", 31), ("cbr3", 32))).clone('cbr')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ausmConnServiceType.setStatus('mandatory')
if mibBuilder.loadTexts: ausmConnServiceType.setDescription("This specifies the service type 1 ==> Constant Bit Rate 2 ==> Variable Bit Rate 3 ==> Not used 4 ==> Unspecified Bit Rate 5 ==> ATM frame relay 6 ==> standard ABR 7 ==> foresight ABR 8 ==> Real-Time Variable Bit Rate Note that this is used by PXM card, FRSM doesn't need to set it Also to make it compatible with existing AUSM MIB definition, value 3 is not used. The following types are being added for PNNI support. and are based on UNI 4.0 cbr1 (21) - CBR.1 vbr1rt (22) - Real time VBR.1 vbr2rt (23) - Real time VBR.2 vbr3rt (24) - Real time VBR.3 vbr1nrt(25) - Non Real time VBR.1 vbr2nrt(26) - Non Real time VBR.2 vbr3nrt(27) - Non Real time VBR.3 ubr1 (28) - UBR.1 ubr2 (29) - UBR.2 stdabr (30) - TM 4.0 compliant standard ABR cbr2 (31) - CBR.2 cbr3 (32) - CBR.3 ")
ausmRoutingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 57), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ausmRoutingPriority.setStatus('mandatory')
if mibBuilder.loadTexts: ausmRoutingPriority.setDescription(' This is also known as class of service, it is used by PXM to determine how important this connection is when selecting connections to route ')
ausmMaxCost = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 58), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ausmMaxCost.setStatus('mandatory')
if mibBuilder.loadTexts: ausmMaxCost.setDescription(" Maximum allowed cost. It is related to Cost Based Routing. This is used by PXM so that it won't choose a path with a cost greater than this configured level. When used with PAR controller the valid range is 1..65535 and the default value is 255. When used with PNNI controller the valid range is 1..2147483647 and the default value is 2147483647. ")
ausmRestrictTrunkType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 59), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noresriction", 1), ("terrestrialTrunk", 2), ("sateliteTrunk", 3))).clone('noresriction')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ausmRestrictTrunkType.setStatus('mandatory')
if mibBuilder.loadTexts: ausmRestrictTrunkType.setDescription(' Restricted trunk type for routing, used by PXM. It specifies that the connection either cannot be routed over satelite trunks, or terrestrial trunks, or it can be on any type of trunk. ')
ausmConnPCR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 60), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 38328))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ausmConnPCR.setStatus('mandatory')
if mibBuilder.loadTexts: ausmConnPCR.setDescription(' Peak cell rate, if not set in MGX, will be derived from the end point parameter ')
ausmConnMCR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 61), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 38328))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ausmConnMCR.setStatus('mandatory')
if mibBuilder.loadTexts: ausmConnMCR.setDescription(' Minimum cell rate, if not set in MGX, will be derived from the end point parameter ')
ausmConnPercentUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 62), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100)).clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ausmConnPercentUtil.setStatus('mandatory')
if mibBuilder.loadTexts: ausmConnPercentUtil.setDescription('This is the expected long-term utilization of the channel by theis end-point.')
ausmConnRemotePCR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 63), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 38328))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ausmConnRemotePCR.setStatus('mandatory')
if mibBuilder.loadTexts: ausmConnRemotePCR.setDescription(' Peak cell rate of the other end, if not set in MGX, will be derived from the end point parameter ')
ausmConnRemoteMCR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 64), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 38328))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ausmConnRemoteMCR.setStatus('mandatory')
if mibBuilder.loadTexts: ausmConnRemoteMCR.setDescription(' Minimum cell rate of the other end, if not set in MGX, will be derived from the end point parameter ')
ausmConnRemotePercentUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 65), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100)).clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ausmConnRemotePercentUtil.setStatus('mandatory')
if mibBuilder.loadTexts: ausmConnRemotePercentUtil.setDescription('This is the expected long-term utilization of the channel by the other end-point.')
ausmConnForeSightEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 66), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ausmConnForeSightEnable.setStatus('mandatory')
if mibBuilder.loadTexts: ausmConnForeSightEnable.setDescription('This object is used by the controller(PAR/PNNI/TAG) to set up the Qbin for the connection')
ausmConnFGCRAEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 67), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ausmConnFGCRAEnable.setStatus('mandatory')
if mibBuilder.loadTexts: ausmConnFGCRAEnable.setDescription('enables/disables Frame based GCRA (early packet discard). ')
ausmChanReroute = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 68), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2))).clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ausmChanReroute.setStatus('mandatory')
if mibBuilder.loadTexts: ausmChanReroute.setDescription(' This is used by the administrator to trigger the re-routing of the connection. The rerouting takes effect, when this object is set to true(1). When set to false (2), no action is taken. A get on this object always returns false (2). This object is not applicable to MGX Release 1.x. ')
ausmConnSCR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 69), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 38328))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ausmConnSCR.setStatus('mandatory')
if mibBuilder.loadTexts: ausmConnSCR.setDescription(' Sustained cell rate, Used for VBR connections setup with PNNI controller. ')
ausmConnRemoteSCR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 70), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 38328))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ausmConnRemoteSCR.setStatus('mandatory')
if mibBuilder.loadTexts: ausmConnRemoteSCR.setDescription(' Sustained cell rate of the other end, Used for VBR connections setup with PNNI controller. ')
ausmConnMBS = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 71), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ausmConnMBS.setStatus('mandatory')
if mibBuilder.loadTexts: ausmConnMBS.setDescription(' Maximum burst size, Used for VBR connections setup with PNNI controller. In MGX switches, release 3.0.0.0 and above, the default value is 1024 ')
ausmConnRemoteMBS = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 72), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ausmConnRemoteMBS.setStatus('mandatory')
if mibBuilder.loadTexts: ausmConnRemoteMBS.setDescription(' Maximum burst size at the remote end of the connection, Used for VBR connections setup with PNNI controller. ')
ausmConnTemplateId = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 73), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 17)).clone(17)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ausmConnTemplateId.setStatus('mandatory')
if mibBuilder.loadTexts: ausmConnTemplateId.setDescription('This object specifies the template identifier for the connection template associated with this connection. The valid range for templates is 1..16. A value of 17 indicates no template is associated with this connection')
ausmConnAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 1, 1, 74), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2))).clone('down')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ausmConnAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ausmConnAdminStatus.setDescription('This object specifies channel admin status. This object is not applicable to MGX Release 1.x. ')
ausmChanNumNextAvailable = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 1015))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ausmChanNumNextAvailable.setStatus('mandatory')
if mibBuilder.loadTexts: ausmChanNumNextAvailable.setDescription('This variable contains the next unused channel number of the possible 1000. This number can be used in channel config table. ChanNumNextAvailable gets updated whenever this number is used to create a new logical channel. Value 0 for this variable indicates that no more channels are available. In AUSM (4-port card), the maximum number of values for this variable is 256 (i.e. 16 ..271). ')
ausmChanVpIdNextAvailable = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ausmChanVpIdNextAvailable.setStatus('mandatory')
if mibBuilder.loadTexts: ausmChanVpIdNextAvailable.setDescription('This variable contains the next unused local VPId of the possible 1 to 100. This number can be used in channel config table. It gets updated if the number is used to create a new vp connection. There can max 100 vp connections per slot. Value of 0 for this variable indicates that no more vp connections are available. ')
ausmStdABRCnfGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 4), )
if mibBuilder.loadTexts: ausmStdABRCnfGrpTable.setStatus('mandatory')
if mibBuilder.loadTexts: ausmStdABRCnfGrpTable.setDescription('The ABR config table is for logical channel interface there are 1000 entries for the 8 logical ports in AUSM (8-port). ')
ausmStdABRCnfGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 4, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "ausmStdABRCnfChanNum"))
if mibBuilder.loadTexts: ausmStdABRCnfGrpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ausmStdABRCnfGrpEntry.setDescription(' An entry for logical channel ')
ausmStdABRCnfChanNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 1015))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ausmStdABRCnfChanNum.setStatus('mandatory')
if mibBuilder.loadTexts: ausmStdABRCnfChanNum.setDescription('Refers to the virtual connection index. ')
ausmStdABRType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("switchBehaviour", 1), ("srcDestBehaviour", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ausmStdABRType.setStatus('mandatory')
if mibBuilder.loadTexts: ausmStdABRType.setDescription('StdabrType of value 1 indicates a TM4.0 switch behaving connection (Transparent connection) which assumes that RM cells will be received from a TM4.0 compliant CPE. Value 2 indicates a TM4.0 source destination behaving connection (Terminating connection) which generates RM cells by itself. ')
ausmStdABRTBE = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215)).clone(16777215)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ausmStdABRTBE.setStatus('mandatory')
if mibBuilder.loadTexts: ausmStdABRTBE.setDescription('Transient Buffer Exposure. The unit is number of cells. ')
ausmStdABRFRTT = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16700))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ausmStdABRFRTT.setStatus('mandatory')
if mibBuilder.loadTexts: ausmStdABRFRTT.setDescription('Fixed Round-Trip Time. The unit is milliseconds. Value 0 signifies that FRTT value is not available. ')
ausmStdABRRDF = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 4, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32768)).clone(16)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ausmStdABRRDF.setStatus('mandatory')
if mibBuilder.loadTexts: ausmStdABRRDF.setDescription('Rate Decrease Factor. This unitless value has to be inversed to arrive at the actual value. The valid values possible are only powers of 2; i.e. 1, 2, 4, 8 ..... 32768 . The SNMP agent has to verify this compliance. ')
ausmStdABRRIF = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 4, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32768)).clone(64)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ausmStdABRRIF.setStatus('mandatory')
if mibBuilder.loadTexts: ausmStdABRRIF.setDescription('Rate Increase Factor. This unitless value has to be inversed to arrive at the actual value. The valid values possible are are only powers of 2; i.e. 1, 2, 4, 8 ..... 32768 . The SNMP agent has to verify this compliance. ')
ausmStdABRNrm = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 4, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 256)).clone(64)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ausmStdABRNrm.setStatus('mandatory')
if mibBuilder.loadTexts: ausmStdABRNrm.setDescription('Maximum number of cells a source may send for each forward RM cell. The valid values possible are only powers of 2 starting from 2 ; i.e. 2, 4, 8 ..... 256. The SNMP agent has to verify this compliance. ')
ausmStdABRTrm = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 4, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(3, 255)).clone(255)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ausmStdABRTrm.setStatus('mandatory')
if mibBuilder.loadTexts: ausmStdABRTrm.setDescription('Upper bound on the time between forward RM cells for an active source. The unit is in milliseconds. ')
ausmStdABRCDF = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 4, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 64)).clone(16)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ausmStdABRCDF.setStatus('mandatory')
if mibBuilder.loadTexts: ausmStdABRCDF.setDescription('Cutoff Decrease Factor. This unitless value has to be inversed to arrive at the actual value. The valid values possible are 0 and only powers of 2; i.e. 1, 2, 4, 8, 16, 32, 64 . The SNMP agent has to verify this compliance. ')
ausmStdABRADTF = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 4, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 10230)).clone(500)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ausmStdABRADTF.setStatus('mandatory')
if mibBuilder.loadTexts: ausmStdABRADTF.setDescription('ACR Decrease Time Factor. Unit of this value is milliseconds. Granularity allowed is 10 milli seconds. The SNMP agent has to verify this compliance. ')
ausmStdABRICR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 4, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 38328)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ausmStdABRICR.setStatus('mandatory')
if mibBuilder.loadTexts: ausmStdABRICR.setDescription("Initial cell Rate. The actual value depends on the speed of the logical port (which can be a T1, E1 (normal), E1 (clear), IMA T1, IMA T1, IMA E1 (normal) or IMA E1 (clear) port. Note that the IMA port's speed is variable and depends on the number of links in the port. ")
ausmStdABRMCR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 4, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 38328)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ausmStdABRMCR.setStatus('mandatory')
if mibBuilder.loadTexts: ausmStdABRMCR.setDescription("Minimum cell Rate. The actual value depends on the speed of the logical port (which can be a T1, E1 (normal), E1 (clear), IMA T1 IMA E1 (normal) or IMA E1 (clear) port. Note that the IMA port's speed is variable and depends on the number of links in the port. Please note that the MCR value will include bandwidth occupied by Data cells as well as all in-rate RM cells. ")
ausmStdABRPCR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 1, 4, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 38328)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ausmStdABRPCR.setStatus('mandatory')
if mibBuilder.loadTexts: ausmStdABRPCR.setDescription("Peak cell Rate. The actual value depends on the speed of the logical port (which can be a T1, E1 (normal), E1 (clear), IMA T1 IMA E1 (normal) or IMA E1 (clear) port. Note that the IMA port's speed is variable and depends on the number of links in the port. Please note that the PCR value will include bandwidth occupied by Data cells as well as all in-rate RM cells. ")
ausmChanCntGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 3))
ausmChanCntGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 3, 1), )
if mibBuilder.loadTexts: ausmChanCntGrpTable.setStatus('mandatory')
if mibBuilder.loadTexts: ausmChanCntGrpTable.setDescription('The config table is for logical channel interface there are 1000 entries for 8 logical ports. In AUSM (4-port card), a logical port is synonymous with a physical port and the number of supported entries in this table is 256. ')
ausmChanCntGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 3, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "ausmCntChanNum"))
if mibBuilder.loadTexts: ausmChanCntGrpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ausmChanCntGrpEntry.setDescription(' An entry for logical channel ')
ausmCntChanNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 1015))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ausmCntChanNum.setStatus('mandatory')
if mibBuilder.loadTexts: ausmCntChanNum.setDescription('Refers to the logical channel number. In AUSM (4-port card), the permissible range is from 16..271. ')
chanSecInService = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 3, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanSecInService.setStatus('mandatory')
if mibBuilder.loadTexts: chanSecInService.setDescription('The number of seconds channel is in service ')
chanCongestMinutes = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 3, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanCongestMinutes.setStatus('mandatory')
if mibBuilder.loadTexts: chanCongestMinutes.setDescription('The number of minutes for which congestion was experienced ')
chanIngrPeakQDepth = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanIngrPeakQDepth.setStatus('mandatory')
if mibBuilder.loadTexts: chanIngrPeakQDepth.setDescription('Peak queue depth on the ingress direction ')
chanIngrRcvCells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 3, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanIngrRcvCells.setStatus('mandatory')
if mibBuilder.loadTexts: chanIngrRcvCells.setDescription('The number of cells received in the Ingress direction ')
chanIngrClpSetRcvCells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 3, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanIngrClpSetRcvCells.setStatus('mandatory')
if mibBuilder.loadTexts: chanIngrClpSetRcvCells.setDescription('The number of CLP set cells received in Ingress direction ')
chanIngrEfciSetRcvCells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 3, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanIngrEfciSetRcvCells.setStatus('mandatory')
if mibBuilder.loadTexts: chanIngrEfciSetRcvCells.setDescription('The number of EFCI set cells received in Ingress direction ')
chanIngrQfullDiscardCells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 3, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanIngrQfullDiscardCells.setStatus('mandatory')
if mibBuilder.loadTexts: chanIngrQfullDiscardCells.setDescription('The number of cells discarded due to ingress Q full ')
chanIngrClpSetDiscardCells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 3, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanIngrClpSetDiscardCells.setStatus('mandatory')
if mibBuilder.loadTexts: chanIngrClpSetDiscardCells.setDescription('The number of CLP set cells discarded in Ingress direction ')
chanIngrUpcClpSetCells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 3, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanIngrUpcClpSetCells.setStatus('mandatory')
if mibBuilder.loadTexts: chanIngrUpcClpSetCells.setDescription('The number of cells for which CLP was set by UPC ')
chanIngrXmtCells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 3, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanIngrXmtCells.setStatus('mandatory')
if mibBuilder.loadTexts: chanIngrXmtCells.setDescription('The number of cells transmitted to the cellbus ')
chanShelfAlarmDiscardCells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 3, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanShelfAlarmDiscardCells.setStatus('mandatory')
if mibBuilder.loadTexts: chanShelfAlarmDiscardCells.setDescription('The number of cells discarded due to Shelf Alarm ')
ausmChanClrButton = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 3, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noAction", 1), ("resetCounters", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ausmChanClrButton.setStatus('mandatory')
if mibBuilder.loadTexts: ausmChanClrButton.setDescription('writing a value of 2 resets all the counters ')
chanEpdDiscCells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 3, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanEpdDiscCells.setStatus('mandatory')
if mibBuilder.loadTexts: chanEpdDiscCells.setDescription('The number of cells discarded due to EPD (Early Packet Discard) condition ')
chanPpdDiscCells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 3, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanPpdDiscCells.setStatus('mandatory')
if mibBuilder.loadTexts: chanPpdDiscCells.setDescription('The number of cells discarded due to PPD (Partial Packet Discard) condition ')
chanIngrRcvCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 3, 1, 1, 16), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanIngrRcvCellRate.setStatus('mandatory')
if mibBuilder.loadTexts: chanIngrRcvCellRate.setDescription('The number of cells received per second from the port. Statistics collected before UPC and ingress qeueing. The maximum value is 5000 because clear E1 rate is 4830. ')
chanIngrRcvUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 3, 1, 1, 17), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanIngrRcvUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: chanIngrRcvUtilization.setDescription('The percentage utilization of the reserved bandwidth (PCR). Statistics collected before UPC and ingress queueing. The maximum value is 200 because a connection can oversubcribe. ')
chanIngrXmtCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 3, 1, 1, 18), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanIngrXmtCellRate.setStatus('mandatory')
if mibBuilder.loadTexts: chanIngrXmtCellRate.setDescription('The number of cells transmitted per second to the network. Statistics collected after UPC and ingress qeueing. ')
chanIngrXmtUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 3, 1, 1, 19), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanIngrXmtUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: chanIngrXmtUtilization.setDescription('The percentage utilization of the reserved bandwidth (PCR). Statistics collected after UPC and ingress queueing. ')
chanEgrRcvCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 3, 1, 1, 20), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanEgrRcvCellRate.setStatus('mandatory')
if mibBuilder.loadTexts: chanEgrRcvCellRate.setDescription('The number of cells received per second from the network. Statistics collected before egress qeueing. ')
chanEgrRcvUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 3, 1, 1, 21), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanEgrRcvUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: chanEgrRcvUtilization.setDescription('The percentage utilization of the reserved bandwidth (PCR). Statistics collected before egress queueing. ')
chanIngrXmtAAL5Frames = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 3, 1, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanIngrXmtAAL5Frames.setStatus('mandatory')
if mibBuilder.loadTexts: chanIngrXmtAAL5Frames.setDescription('This statistics provides a count of the number of AAL5 Frames that are sent to the network ')
chanIngrEfciSetXmtCells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 3, 1, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanIngrEfciSetXmtCells.setStatus('mandatory')
if mibBuilder.loadTexts: chanIngrEfciSetXmtCells.setDescription('This statistics provides a count of the number of EFCI set cells that are transmitted to the network. This statistis is collected after the policing and queueing. ')
chanEgrPortQfullDiscardCells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 3, 1, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanEgrPortQfullDiscardCells.setStatus('mandatory')
if mibBuilder.loadTexts: chanEgrPortQfullDiscardCells.setDescription('This statistics provides a count of the number of cells discarded because of Egress Port Queue full. This count is displayed for the queue corresponding to port and the service type to which this channel belongs. ')
chanEgrPortQClpThresDiscardCells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 3, 1, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanEgrPortQClpThresDiscardCells.setStatus('mandatory')
if mibBuilder.loadTexts: chanEgrPortQClpThresDiscardCells.setDescription('This statistics provides a count of the number of cells discarded because of Egress Port Queue CLP Threshold exceed. This count is displayed for the queue corresponding to port and the service type to which this channel belongs. ')
chanTxFifoFullCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 3, 1, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanTxFifoFullCnt.setStatus('mandatory')
if mibBuilder.loadTexts: chanTxFifoFullCnt.setDescription('This statistics provides a count of the number of times the AUSM card tried to send a cell, but was unable to send because the Transmit FIFO was full. Note that this is NOT a count of the number of cells dropped. This statistics is per card statistics. ')
chanIngrCurrQDepth = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 3, 1, 1, 27), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanIngrCurrQDepth.setStatus('mandatory')
if mibBuilder.loadTexts: chanIngrCurrQDepth.setDescription('Current queue depth on the ingress direction ')
ausmChanStateGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 2))
ausmChanStateGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 2, 1), )
if mibBuilder.loadTexts: ausmChanStateGrpTable.setStatus('mandatory')
if mibBuilder.loadTexts: ausmChanStateGrpTable.setDescription('Table of transmit/receive states of channels. ')
ausmChanStateGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 2, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "ausmStateChanNum"))
if mibBuilder.loadTexts: ausmChanStateGrpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ausmChanStateGrpEntry.setDescription('An entry for AusmChannelStateGrpEntry. ')
ausmStateChanNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 1015))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ausmStateChanNum.setStatus('mandatory')
if mibBuilder.loadTexts: ausmStateChanNum.setDescription('Refers to the logical channel number. In AUSM (4-port card), the permissible range is from 16..271. ')
ausmChanState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notconfigured", 1), ("normal", 2), ("alarm", 3), ("failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ausmChanState.setStatus('mandatory')
if mibBuilder.loadTexts: ausmChanState.setDescription('This variable indicates the state of the VC (channel) failed(4) is added to distinguish between alarm (when the connection segment is not actually broken) and failed(when the segment is actually broken). This is applicable only to the PNNI environment. ')
chanEgrXmtState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("normal", 2), ("sendingAis", 3), ("sendingFerf", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanEgrXmtState.setStatus('mandatory')
if mibBuilder.loadTexts: chanEgrXmtState.setDescription('indicates the status of port transmit(Egress) ')
chanIngrRcvState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("normal", 2), ("receivingAis", 3), ("receivingFerf", 4), ("alarm", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanIngrRcvState.setStatus('mandatory')
if mibBuilder.loadTexts: chanIngrRcvState.setDescription('indicates the status of port receive(Ingress) ')
chanIngrXmtState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("normal", 2), ("sendingAis", 3), ("sendingFerf", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanIngrXmtState.setStatus('mandatory')
if mibBuilder.loadTexts: chanIngrXmtState.setDescription('This variable indicates the transmit state of the VC (channel) on the Cellbus side (Ingress) 1 - other 2- normal 3 - sendingAIS 4 - sendingFerf ')
chanEgrRcvState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("normal", 2), ("receivingAis", 3), ("receivingFerf", 4), ("alarm", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanEgrRcvState.setStatus('mandatory')
if mibBuilder.loadTexts: chanEgrRcvState.setDescription('This variable indicates the receiving state of the VC (channel) on the Cellbus side (Egress) 1 - other 2- normal 3 - receivingAIS 4 - receivingFERF ')
ausmChanStatusBitMap = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 2, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ausmChanStatusBitMap.setStatus('mandatory')
if mibBuilder.loadTexts: ausmChanStatusBitMap.setDescription('This variable indicates the consolidated bit map of the channel alarm state. Individual bit positions are as defined below. Bit position Fail/Alarm Reason ------------ ---------- ------ 0 Alarm port side AIS/RDI Rx 1 Alarm n/w side AIS/RDI Rx 2 Fail Conditioned(A bit from n/w) 3 Alarm Reserved 4 Fail Reserved 5 Fail Reserved 6 Alarm Reserved 7 Alarm Reserved Fail bitmap mask : 0x34 Alarm bitmap mask: 0xCB This object is not applicable to MGX Release 1.x. ')
ausmEndPointMapGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 3))
ausmEndPointMapGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 3, 1), )
if mibBuilder.loadTexts: ausmEndPointMapGrpTable.setStatus('mandatory')
if mibBuilder.loadTexts: ausmEndPointMapGrpTable.setDescription(' For Ausm-4p There are 255 entries For Ausm-8p There are 1000 entries For PXM (MGX) There are 4096 entries Port Num and VpiVci will uniquely identify a row. ')
ausmEndPointMapGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 3, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "ausmEndPortNum"), (0, "CISCO-WAN-AXIPOP-MIB", "endVpi"), (0, "CISCO-WAN-AXIPOP-MIB", "endVci"))
if mibBuilder.loadTexts: ausmEndPointMapGrpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ausmEndPointMapGrpEntry.setDescription(' An entry in the table ')
ausmEndPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ausmEndPortNum.setStatus('mandatory')
if mibBuilder.loadTexts: ausmEndPortNum.setDescription(' Refers to the logical port on the board. In AUSM (4-port card), a logical port is synonymous with a physical port. In PXM, a port refers to the Logical Broadband Interface. Refer bbIfCnfPortGrp.my for more information. ')
endVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: endVpi.setStatus('mandatory')
if mibBuilder.loadTexts: endVpi.setDescription('The VPI value for the connection ')
endVci = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: endVci.setStatus('mandatory')
if mibBuilder.loadTexts: endVci.setDescription('The VCI value for the connection ')
ausmEndChanNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 4111))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ausmEndChanNum.setStatus('mandatory')
if mibBuilder.loadTexts: ausmEndChanNum.setDescription('Refers to the logical connection for this port and VpiVci. In AUSM (4-port card), the permissible range is 16..271 In AUSM (8-port card), the permissible range is 16..1015 In PXM (MGX ) , the permissible range is 16..4111 ')
endChanType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("vpc", 1), ("vcc", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: endChanType.setStatus('mandatory')
if mibBuilder.loadTexts: endChanType.setDescription('Refers to the type of the connection for this Port and VpiVci ')
ausmPortCnfPortGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 1))
ausmPortCnfPortGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 1, 1), )
if mibBuilder.loadTexts: ausmPortCnfPortGrpTable.setStatus('mandatory')
if mibBuilder.loadTexts: ausmPortCnfPortGrpTable.setDescription('The config table is for logical port interface there are 8 entries for either T1 or E1 ')
ausmPortCnfPortGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 1, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "ausmPortNum"))
if mibBuilder.loadTexts: ausmPortCnfPortGrpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ausmPortCnfPortGrpEntry.setDescription(' An entry for logical port. In AUSM (4-port card), a logical port is same as a physical port. ')
ausmPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ausmPortNum.setStatus('mandatory')
if mibBuilder.loadTexts: ausmPortNum.setDescription('This is logical port number. In AUSM (4-port card), a logical port is same as a physical port. ')
portEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portEnable.setStatus('mandatory')
if mibBuilder.loadTexts: portEnable.setDescription('This variable enables or disables the port 1 - disable 2 - enable ')
ausmPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("uni", 1), ("nni", 2), ("sti", 3), ("vpTrkUni", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ausmPortType.setStatus('mandatory')
if mibBuilder.loadTexts: ausmPortType.setDescription('This variable indicates whether UNI/NNI/STI interface STI mode is supported only in IMATM. vpTrkUni should be used only in IMATM when virtual trunks are passing through IMATM (i.e. the cell format is UNI but ForeSight information is carried in the lower 16 bits) ')
ausmPortIfType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("t1", 2), ("e1", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ausmPortIfType.setStatus('mandatory')
if mibBuilder.loadTexts: ausmPortIfType.setDescription('This variable indicates the type of interface ')
ausmPortSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 1, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ausmPortSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: ausmPortSpeed.setDescription('The speed of the port in cells per second ')
ausmLineNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 1, 1, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ausmLineNum.setStatus('mandatory')
if mibBuilder.loadTexts: ausmLineNum.setDescription('The line number associated with the logical port. For AUSM (4 port), the line number is same as the logical port. In AUSM-8p, these two can be different ')
ausmPortCnfResPartGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 5))
ausmPortDelSvcsGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 6))
ausmPortCnfResPartGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 5, 1), )
if mibBuilder.loadTexts: ausmPortCnfResPartGrpTable.setStatus('mandatory')
if mibBuilder.loadTexts: ausmPortCnfResPartGrpTable.setDescription('The config table is for logical port interface there are 4/8 entries for either T1 or E1 or AIMUX ports For PXM (MGX), there are 32 entries. ')
ausmPortCnfResPartGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 5, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "ausmResPartPortNum"))
if mibBuilder.loadTexts: ausmPortCnfResPartGrpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ausmPortCnfResPartGrpEntry.setDescription(' An entry for logical port ')
ausmResPartPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ausmResPartPortNum.setStatus('mandatory')
if mibBuilder.loadTexts: ausmResPartPortNum.setDescription(' This is logical port number In PXM, a port refers to the Logical Broadband Interface. Refer bbIfCnfPortGrp.my for more information. ')
ausmPortSvcInUse = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("inUse", 1), ("notInUse", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ausmPortSvcInUse.setStatus('mandatory')
if mibBuilder.loadTexts: ausmPortSvcInUse.setDescription(' Setting this object to 1 indicates that the resources (LCN/Local VPID/VCI/VPI) have been partitioned and INS and SV+ are currently using this information. The resource partition information can be changed after setting this variable to 2. The default value is 2 (NotInUse). ')
ausmPortSvcShareLcnVpid = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 5, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("portBased", 1), ("cardBased", 2))).clone('cardBased')).setMaxAccess("readonly")
if mibBuilder.loadTexts: ausmPortSvcShareLcnVpid.setStatus('mandatory')
if mibBuilder.loadTexts: ausmPortSvcShareLcnVpid.setDescription('Indicates whether or not the LCN and VPid address spaces are shared across all the ports. Default value is 2 (cardBased). ')
ausmPortSvcLcnLow = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 5, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 4111))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ausmPortSvcLcnLow.setStatus('mandatory')
if mibBuilder.loadTexts: ausmPortSvcLcnLow.setDescription("The beginning of the LCN range reserved for SVCs. Both the LCN low and high values apply to all ports when the 'atmPortSvcShareLcnVpid' object is set to 2 (CardBased). When they are changed for one port the change is applicable/propagated to all ports. ")
ausmPortSvcLcnHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 5, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 4111))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ausmPortSvcLcnHigh.setStatus('mandatory')
if mibBuilder.loadTexts: ausmPortSvcLcnHigh.setDescription('The end of the LCN range reserved for SVCs. ')
ausmPortSvcVpidLow = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 5, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ausmPortSvcVpidLow.setStatus('mandatory')
if mibBuilder.loadTexts: ausmPortSvcVpidLow.setDescription("The beginning of the VPID range reserved for SVCs. Both the VPID low and high values apply to all ports when the 'atmPortSvcShareLcnVpid' object is set to 2 (CardBased). When they are changed for one port the change is applicable/propagated to all ports. ")
ausmPortSvcVpidHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 5, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ausmPortSvcVpidHigh.setStatus('mandatory')
if mibBuilder.loadTexts: ausmPortSvcVpidHigh.setDescription('The end of the VPID range reserved for SVCs. ')
ausmPortSvcVciLow = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 5, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ausmPortSvcVciLow.setStatus('mandatory')
if mibBuilder.loadTexts: ausmPortSvcVciLow.setDescription('The beginning of the VCI range reserved for SVCs. For VPI connections the valid VCI values are 0 - 4095 ')
ausmPortSvcVciHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 5, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ausmPortSvcVciHigh.setStatus('mandatory')
if mibBuilder.loadTexts: ausmPortSvcVciHigh.setDescription('The end of the VCI range reserved for SVCs. For VPI connections the valid VCI values are 0 -4095 ')
ausmPortSvcVpiLow = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 5, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ausmPortSvcVpiLow.setStatus('mandatory')
if mibBuilder.loadTexts: ausmPortSvcVpiLow.setDescription('The beginning of the VCI range reserved for SVCs. ')
ausmPortSvcVpiHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 5, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ausmPortSvcVpiHigh.setStatus('mandatory')
if mibBuilder.loadTexts: ausmPortSvcVpiHigh.setDescription('The end of the VPI range reserved for SVCs. ')
ausmPortIngrSvcBandW = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 5, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ausmPortIngrSvcBandW.setStatus('mandatory')
if mibBuilder.loadTexts: ausmPortIngrSvcBandW.setDescription('This represents Ingress Bandwidth reserved for SVC ')
ausmPortEgrSvcBandW = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 5, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ausmPortEgrSvcBandW.setStatus('mandatory')
if mibBuilder.loadTexts: ausmPortEgrSvcBandW.setDescription('This represents Egress Bandwidth reserved for SVC ')
ausmPortDelSvcsGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 6, 1), )
if mibBuilder.loadTexts: ausmPortDelSvcsGrpTable.setStatus('mandatory')
if mibBuilder.loadTexts: ausmPortDelSvcsGrpTable.setDescription('The table is for logical port interface there are 4/8 entries for either T1 or E1 or AIMUX ports For PXM (MGX), there are 32 entries. ')
ausmPortDelSvcsGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 6, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "ausmDelSvcsPortNum"))
if mibBuilder.loadTexts: ausmPortDelSvcsGrpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ausmPortDelSvcsGrpEntry.setDescription(' An entry for logical port ')
ausmDelSvcsPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 6, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ausmDelSvcsPortNum.setStatus('mandatory')
if mibBuilder.loadTexts: ausmDelSvcsPortNum.setDescription('This is logical port number In PXM, a port refers to the Logical Broadband Interface. Refer bbIfCnfPortGrp.my for more information. ')
ausmPortDeleteSvcs = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 6, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("delete", 1), ("other", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ausmPortDeleteSvcs.setStatus('mandatory')
if mibBuilder.loadTexts: ausmPortDeleteSvcs.setDescription('Setting this object to 1 indicates that all the SVC connections on the given port has to be deleted ')
ausmPortCnfServiceQueGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 2))
ausmPortCnfServiceQueGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 2, 1), )
if mibBuilder.loadTexts: ausmPortCnfServiceQueGrpTable.setStatus('mandatory')
if mibBuilder.loadTexts: ausmPortCnfServiceQueGrpTable.setDescription('In AUSM (4port): the Service queue table has 64 entries, 16 each for every port, in addition there are 4 queues for OAM/ILMI traffic In AUSM (8-port), the Service queue table has 128 entries, 16 each for every port, in addition there are 8 queues for OAM/ILMI traffic ')
ausmPortCnfServiceQueGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 2, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "servicePortNum"), (0, "CISCO-WAN-AXIPOP-MIB", "egrQIndex"))
if mibBuilder.loadTexts: ausmPortCnfServiceQueGrpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ausmPortCnfServiceQueGrpEntry.setDescription(' An entry for a single queue ')
egrQIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: egrQIndex.setStatus('mandatory')
if mibBuilder.loadTexts: egrQIndex.setDescription('Egress queue number. In AUSM (4 port), only range from 1..12 is permissible ')
servicePortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: servicePortNum.setStatus('mandatory')
if mibBuilder.loadTexts: servicePortNum.setDescription('Logical port number to which egress queue is associated. In AUSM (4-port card), a logical port is same as a physical port. This is read only and queue mapping is as follows 1-16 port no 1 17-32 port no 2 33-48 port no 3 49-64 port no 4 For AUSM 8-port card, the following queue mapping is used in addition to the above: 65-80 port no 5 81-96 port no 6 97-112 port no 7 113-128 port no 8 ')
egrQBinState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: egrQBinState.setStatus('mandatory')
if mibBuilder.loadTexts: egrQBinState.setDescription('Egress queue state ')
egrQServiceSequence = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: egrQServiceSequence.setStatus('mandatory')
if mibBuilder.loadTexts: egrQServiceSequence.setDescription('Egress queue number sequence in the priority list. In AUSM (4 port), range from only 1..12 is permissible ')
egrQDepthMax = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: egrQDepthMax.setStatus('mandatory')
if mibBuilder.loadTexts: egrQDepthMax.setDescription('The maximum depth of the egress queue. In AUSM (4 port), range from only 1..8000 is permissible ')
egrQCLPThreshHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: egrQCLPThreshHigh.setStatus('mandatory')
if mibBuilder.loadTexts: egrQCLPThreshHigh.setDescription('High CLP threshold of the egress queue. In AUSM (4 port), range from only 1..8000 is permissible.This value should be less than or equal to egrQDepthMax. ')
egrQCLPThreshLow = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: egrQCLPThreshLow.setStatus('mandatory')
if mibBuilder.loadTexts: egrQCLPThreshLow.setDescription('Low CLP threshold of the egress queue. In AUSM (4 port), range from only 1..8000 is permissible. This value should be less than or equal to egrQCLPThreshHigh. ')
egrQEfciThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: egrQEfciThresh.setStatus('mandatory')
if mibBuilder.loadTexts: egrQEfciThresh.setDescription('Threshold of the egress queue for EFCI. In AUSM (4 port), range from only 1..8000 is permissible.This value should be less than or equal to egrQDepthMax. ')
egrQAlgorithm = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: egrQAlgorithm.setStatus('mandatory')
if mibBuilder.loadTexts: egrQAlgorithm.setDescription("The algorithm number for the Egress queue 1-5 are valid values 'ff'h is disable ")
egrMaxBwInc = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 512))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: egrMaxBwInc.setStatus('mandatory')
if mibBuilder.loadTexts: egrMaxBwInc.setDescription('The increment for the Maximum carry for the queue. In AUSM (8 port), range from only 1..511 is permissible ')
egrMinBwInc = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 2, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 512))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: egrMinBwInc.setStatus('mandatory')
if mibBuilder.loadTexts: egrMinBwInc.setDescription('The increment for the minimum carry for the queue. In AUSM (8 port), range from only 1..511 is permissible ')
egrQCLPState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 2, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clplow", 1), ("clphigh", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: egrQCLPState.setStatus('mandatory')
if mibBuilder.loadTexts: egrQCLPState.setDescription('this variable indicates the CLP state for the queue ')
egrQfullDiscardCells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 2, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: egrQfullDiscardCells.setStatus('mandatory')
if mibBuilder.loadTexts: egrQfullDiscardCells.setDescription('The number of cells discarded due to Egress Q full ')
egrQClpSetDiscardCells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 2, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: egrQClpSetDiscardCells.setStatus('mandatory')
if mibBuilder.loadTexts: egrQClpSetDiscardCells.setDescription('The number of CLP set cells discarded in Egress direction ')
ausmPortCnfSig = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 3))
ausmPortCnfSigILMIGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 3, 1))
ausmPortCnfSigILMIGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 3, 1, 1), )
if mibBuilder.loadTexts: ausmPortCnfSigILMIGrpTable.setStatus('mandatory')
if mibBuilder.loadTexts: ausmPortCnfSigILMIGrpTable.setDescription('The config table is for upto 8 logical port interfaces ')
ausmPortCnfSigILMIGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 3, 1, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "sigPortNum"))
if mibBuilder.loadTexts: ausmPortCnfSigILMIGrpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ausmPortCnfSigILMIGrpEntry.setDescription(' An entry for a logical port. In AUSM (4-port card), a logical port is same as a physical port. ')
sigPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 3, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sigPortNum.setStatus('mandatory')
if mibBuilder.loadTexts: sigPortNum.setDescription('Refers to the logical port index. In AUSM (4-port card), a logical port is same as a physical port. ')
ausmSignallingProtocolType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 3, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("noSignalling", 2), ("iLMI", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ausmSignallingProtocolType.setStatus('mandatory')
if mibBuilder.loadTexts: ausmSignallingProtocolType.setDescription('This will set the signalling protocol 1 - other 2 - noSignalling 3 - ILMI ')
signallingVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 3, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: signallingVpi.setStatus('mandatory')
if mibBuilder.loadTexts: signallingVpi.setDescription('indicates the VPI on which signalling cells arrive ')
signallingVci = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 3, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: signallingVci.setStatus('mandatory')
if mibBuilder.loadTexts: signallingVci.setDescription('indicates the VCI on which signalling cells arrive ')
addrPrefix = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 3, 1, 1, 1, 5), NetPrefix()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: addrPrefix.setStatus('mandatory')
if mibBuilder.loadTexts: addrPrefix.setDescription('Network Prefix for the ATM address ')
customerId = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 3, 1, 1, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: customerId.setStatus('mandatory')
if mibBuilder.loadTexts: customerId.setDescription('for the INS as a read/write variable ')
protocolRevNo = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 3, 1, 1, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: protocolRevNo.setStatus('mandatory')
if mibBuilder.loadTexts: protocolRevNo.setDescription('for the INS as a read/write variable ')
iLMITrapEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 3, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: iLMITrapEnable.setStatus('mandatory')
if mibBuilder.loadTexts: iLMITrapEnable.setDescription('Enable/disable ILMI Trap sending ')
minTrapInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 3, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: minTrapInterval.setStatus('mandatory')
if mibBuilder.loadTexts: minTrapInterval.setDescription('number of seconds between traps ')
keepAlivePollingEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 3, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: keepAlivePollingEnable.setStatus('mandatory')
if mibBuilder.loadTexts: keepAlivePollingEnable.setDescription('Enable/disable Keep Alive Polling ')
errorThresholdN491 = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 3, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: errorThresholdN491.setStatus('mandatory')
if mibBuilder.loadTexts: errorThresholdN491.setDescription('Error Threshold (N491) value ')
eventThresholdN492 = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 3, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eventThresholdN492.setStatus('mandatory')
if mibBuilder.loadTexts: eventThresholdN492.setDescription('Event Threshold (N492) value ')
pollingIntervalT491 = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 3, 1, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60))).clone(namedValues=NamedValues(("v1", 5), ("v2", 10), ("v3", 15), ("v4", 20), ("v5", 25), ("v6", 30), ("v7", 35), ("v8", 40), ("v9", 45), ("v10", 50), ("v11", 55), ("v12", 60)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pollingIntervalT491.setStatus('mandatory')
if mibBuilder.loadTexts: pollingIntervalT491.setDescription('Polling Interval (T491) value ')
minEnquiryIntervalT493 = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 3, 1, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: minEnquiryIntervalT493.setStatus('mandatory')
if mibBuilder.loadTexts: minEnquiryIntervalT493.setDescription('Minimum Enquiry Interval (T493) ')
addrRegEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 1, 3, 1, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: addrRegEnable.setStatus('mandatory')
if mibBuilder.loadTexts: addrRegEnable.setDescription('Enable/disable ILMI Address Registration ')
ausmPortCntPortGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 3, 1))
ausmPortCntPortGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 3, 1, 1), )
if mibBuilder.loadTexts: ausmPortCntPortGrpTable.setStatus('mandatory')
if mibBuilder.loadTexts: ausmPortCntPortGrpTable.setDescription('The config table is for logical port interface there are 8 entries for either T1 or E1 ')
ausmPortCntPortGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 3, 1, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "ausmCntPortNum"))
if mibBuilder.loadTexts: ausmPortCntPortGrpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ausmPortCntPortGrpEntry.setDescription(' An entry for logical port ')
ausmCntPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 3, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ausmCntPortNum.setStatus('mandatory')
if mibBuilder.loadTexts: ausmCntPortNum.setDescription('This is the logical port number. In AUSM (4-port card), a logical port is same as a physical port. ')
ingrRcvCells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 3, 1, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ingrRcvCells.setStatus('mandatory')
if mibBuilder.loadTexts: ingrRcvCells.setDescription('The number of cells received in Ingress direction ')
ingrGfcErrCells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 3, 1, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ingrGfcErrCells.setStatus('mandatory')
if mibBuilder.loadTexts: ingrGfcErrCells.setDescription('The number of cells received in Ingress direction with non zero-GFC ')
ingrVpiVciErrCells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 3, 1, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ingrVpiVciErrCells.setStatus('mandatory')
if mibBuilder.loadTexts: ingrVpiVciErrCells.setDescription('The number of cells received in Ingress direction with unknown VpiVci ')
ingrLastUnknVpiVci = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 3, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ingrLastUnknVpiVci.setStatus('mandatory')
if mibBuilder.loadTexts: ingrLastUnknVpiVci.setDescription('The last unknown Vpi Vci value ')
egrXmtCells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 3, 1, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: egrXmtCells.setStatus('mandatory')
if mibBuilder.loadTexts: egrXmtCells.setDescription('The number of cells transmitted in the egress direction ')
egrPortAlarmDiscardCells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 3, 1, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: egrPortAlarmDiscardCells.setStatus('mandatory')
if mibBuilder.loadTexts: egrPortAlarmDiscardCells.setDescription('The number of cells discarded due to port alarm ')
egrXmtClpSetCells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 3, 1, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: egrXmtClpSetCells.setStatus('mandatory')
if mibBuilder.loadTexts: egrXmtClpSetCells.setDescription('The number of cells transmitted in Egress direction with CLP bit set ')
egrXmtEfciSetCells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 3, 1, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: egrXmtEfciSetCells.setStatus('mandatory')
if mibBuilder.loadTexts: egrXmtEfciSetCells.setDescription('The number of cells transmitted in Egress direction with EFCI bit set ')
portXmtAisCells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 3, 1, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portXmtAisCells.setStatus('mandatory')
if mibBuilder.loadTexts: portXmtAisCells.setDescription('The number of AIS cells transmitted towards port ')
portXmtSgmtLpbkCells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 3, 1, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portXmtSgmtLpbkCells.setStatus('mandatory')
if mibBuilder.loadTexts: portXmtSgmtLpbkCells.setDescription('The number of Segment Loopback cells transmitted towards port ')
portRcvAisCells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 3, 1, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portRcvAisCells.setStatus('mandatory')
if mibBuilder.loadTexts: portRcvAisCells.setDescription('The number of AIS cells received in Ingress direction ')
portRcvFerfCells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 3, 1, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portRcvFerfCells.setStatus('mandatory')
if mibBuilder.loadTexts: portRcvFerfCells.setDescription('The number of FERF cells received in Ingress direction ')
portRcvSgmtLpbkCells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 3, 1, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portRcvSgmtLpbkCells.setStatus('mandatory')
if mibBuilder.loadTexts: portRcvSgmtLpbkCells.setDescription('The number of Segment Loopback cells received in Ingress direction ')
portRcvCrcErrOAMCells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 3, 1, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portRcvCrcErrOAMCells.setStatus('mandatory')
if mibBuilder.loadTexts: portRcvCrcErrOAMCells.setDescription('The number of OAM cells received in Ingress direction with CRC error ')
ausmPortClrButton = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 3, 1, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noAction", 1), ("resetCounters", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ausmPortClrButton.setStatus('mandatory')
if mibBuilder.loadTexts: ausmPortClrButton.setDescription('writing a value of 2 resets all the counters ')
ingrRcvClpSetCells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 3, 1, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ingrRcvClpSetCells.setStatus('mandatory')
if mibBuilder.loadTexts: ingrRcvClpSetCells.setDescription('The number of cells received from the port which had the CLP bit in the ATM cell header equal to 1. ')
ingrXmtCells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 3, 1, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ingrXmtCells.setStatus('mandatory')
if mibBuilder.loadTexts: ingrXmtCells.setDescription('The number of cells out of the received cells from the port that were sent to the network. This count is taken after policing and ingress queueing. ')
egrRcvCells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 3, 1, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: egrRcvCells.setStatus('mandatory')
if mibBuilder.loadTexts: egrRcvCells.setDescription('The number of cells received from the network in the egress direction ')
ingrRcvCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 3, 1, 1, 1, 20), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ingrRcvCellRate.setStatus('mandatory')
if mibBuilder.loadTexts: ingrRcvCellRate.setDescription('The number of cells received per second from the port in the ingress direction. Maximum value is 5000 because because clear E1 rate is 4830. ')
ingrRcvUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 3, 1, 1, 1, 21), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ingrRcvUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: ingrRcvUtilization.setDescription('The percentage utilization of the port speed in the ingress direction. ')
egrXmtCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 3, 1, 1, 1, 22), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: egrXmtCellRate.setStatus('mandatory')
if mibBuilder.loadTexts: egrXmtCellRate.setDescription('The number of cells received transmitted to the port in the egress direction. ')
egrXmtUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 3, 1, 1, 1, 23), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: egrXmtUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: egrXmtUtilization.setDescription('The percentage utilization of the port speed in the egress direction. ')
egrRcvCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 3, 1, 1, 1, 24), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: egrRcvCellRate.setStatus('mandatory')
if mibBuilder.loadTexts: egrRcvCellRate.setDescription('The number of cells received per second from the network in the egress receive direction. ')
egrRcvUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 3, 1, 1, 1, 25), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: egrRcvUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: egrRcvUtilization.setDescription('The percentage utilization of the port speed in the egress receive direction. ')
totalIngrQfulldiscardCells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 3, 1, 1, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: totalIngrQfulldiscardCells.setStatus('mandatory')
if mibBuilder.loadTexts: totalIngrQfulldiscardCells.setDescription('The total number of cells dropped on all the channels on this port because the the ingress Q was full. Adds up all the IngressQfull discard per channel statistics for all the channels in the port. ')
txFifoFullCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 3, 1, 1, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txFifoFullCnt.setStatus('mandatory')
if mibBuilder.loadTexts: txFifoFullCnt.setDescription('This statistics provides a count of the number of times the AUSM card tried to send a cell, but was unable to send because the Transmit FIFO was full. Note that this is NOT a count of the number of cells dropped. This statistics is per card statistics. This counter is duplicated in channel count group to help monitoring. ')
totalIngrClpSetDiscardCells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 3, 1, 1, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: totalIngrClpSetDiscardCells.setStatus('mandatory')
if mibBuilder.loadTexts: totalIngrClpSetDiscardCells.setDescription('The total number of cells with CLP=1 dropped on all the channels on this port because of either PCR Exceeded, SCR exceeded (with CLP tagging disabled) or CLP Hysteris. Adds up all the IngressClpSet discard per channel statistics for all the channels in the port. ')
ausmPortCntSig = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 3, 2))
ausmPortCntSigILMIGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 3, 2, 1))
ausmPortCntSigILMIGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 3, 2, 1, 1), )
if mibBuilder.loadTexts: ausmPortCntSigILMIGrpTable.setStatus('mandatory')
if mibBuilder.loadTexts: ausmPortCntSigILMIGrpTable.setDescription('The config table is for physical port interface there are 8 entries for either T1 or E1 or IMA ')
ausmPortCntSigILMIGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 3, 2, 1, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "sigCntPortNum"))
if mibBuilder.loadTexts: ausmPortCntSigILMIGrpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ausmPortCntSigILMIGrpEntry.setDescription(' An entry for logical port. In AUSM (4-port card), a logical port is same as a physical port. ')
sigCntPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 3, 2, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sigCntPortNum.setStatus('mandatory')
if mibBuilder.loadTexts: sigCntPortNum.setDescription('This is the logical port number. ')
snmpPduReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 3, 2, 1, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpPduReceived.setStatus('mandatory')
if mibBuilder.loadTexts: snmpPduReceived.setDescription('The number of snmp packets received ')
getRequestReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 3, 2, 1, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: getRequestReceived.setStatus('mandatory')
if mibBuilder.loadTexts: getRequestReceived.setDescription('The number of get request messages received ')
getNextRequestReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 3, 2, 1, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: getNextRequestReceived.setStatus('mandatory')
if mibBuilder.loadTexts: getNextRequestReceived.setDescription('The number of get-next messages received ')
setRequestReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 3, 2, 1, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: setRequestReceived.setStatus('mandatory')
if mibBuilder.loadTexts: setRequestReceived.setDescription('The number of set messages received ')
trapReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 3, 2, 1, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trapReceived.setStatus('mandatory')
if mibBuilder.loadTexts: trapReceived.setDescription('The number of traps received ')
getResponseReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 3, 2, 1, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: getResponseReceived.setStatus('mandatory')
if mibBuilder.loadTexts: getResponseReceived.setDescription('The number of Keep Alive response messages received ')
getResponseTransmitted = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 3, 2, 1, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: getResponseTransmitted.setStatus('mandatory')
if mibBuilder.loadTexts: getResponseTransmitted.setDescription('The number of response messages transmitted ')
getRequestTransmitted = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 3, 2, 1, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: getRequestTransmitted.setStatus('mandatory')
if mibBuilder.loadTexts: getRequestTransmitted.setDescription('The number of Keep Alive get request messages transmitted ')
trapTransmitted = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 3, 2, 1, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trapTransmitted.setStatus('mandatory')
if mibBuilder.loadTexts: trapTransmitted.setDescription('The number of trap messages transmitted ')
invalidPDUReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 3, 2, 1, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: invalidPDUReceived.setStatus('mandatory')
if mibBuilder.loadTexts: invalidPDUReceived.setDescription('The number of invalid PDUs received ')
asn1ParseError = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 3, 2, 1, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: asn1ParseError.setStatus('mandatory')
if mibBuilder.loadTexts: asn1ParseError.setDescription('The number of parse errors on ASN.1 ')
noSuchNameError = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 3, 2, 1, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: noSuchNameError.setStatus('mandatory')
if mibBuilder.loadTexts: noSuchNameError.setDescription('The number of errors for name not present ')
tooBigError = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 3, 2, 1, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tooBigError.setStatus('mandatory')
if mibBuilder.loadTexts: tooBigError.setDescription('The number of messages received with len > 484 ')
portSigClrButton = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 3, 2, 1, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noAction", 1), ("resetCounters", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portSigClrButton.setStatus('mandatory')
if mibBuilder.loadTexts: portSigClrButton.setDescription('writing a value of 2 resets all the counters ')
ausmPortStateGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 2))
ausmPortStateGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 2, 1), )
if mibBuilder.loadTexts: ausmPortStateGrpTable.setStatus('mandatory')
if mibBuilder.loadTexts: ausmPortStateGrpTable.setDescription('The state table for the port interface there are 8 entries for either T1 or E1 or IMA. ')
ausmPortStateGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 2, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "ausmStatePortNum"))
if mibBuilder.loadTexts: ausmPortStateGrpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ausmPortStateGrpEntry.setDescription(' An entry for logical port. In AUSM (4-port card), a logical port is same as a physical port. ')
ausmStatePortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ausmStatePortNum.setStatus('mandatory')
if mibBuilder.loadTexts: ausmStatePortNum.setDescription('This is logical port number. In AUSM (4-port card), a logical port is same as a physical port. ')
ausmPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("notConfigured", 1), ("active", 2), ("remoteloopback", 3), ("linefailure", 4), ("signallingfailure", 5), ("outofcelldelineation", 6), ("localloopback", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ausmPortState.setStatus('mandatory')
if mibBuilder.loadTexts: ausmPortState.setDescription('This variable indicates the status of the port ')
ausmPortOversubscribed = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ausmPortOversubscribed.setStatus('mandatory')
if mibBuilder.loadTexts: ausmPortOversubscribed.setDescription('This variable indicates the whether the port is over subscribed or not ')
ausmPortIngrPercentUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ausmPortIngrPercentUtil.setStatus('mandatory')
if mibBuilder.loadTexts: ausmPortIngrPercentUtil.setDescription('Percentage Utilization of the Port in the Ingress direction. ')
ausmPortEgrPercentUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ausmPortEgrPercentUtil.setStatus('mandatory')
if mibBuilder.loadTexts: ausmPortEgrPercentUtil.setDescription('Percentage Utilization of the Port in the Egress direction. ')
ausmPortInterfaceGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 5))
ausmInterfaceConfTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 5, 1), )
if mibBuilder.loadTexts: ausmInterfaceConfTable.setStatus('mandatory')
if mibBuilder.loadTexts: ausmInterfaceConfTable.setDescription('This table contains ATM local interface configuration parameters, one entry per ATM (ausm) interface port. ')
ausmInterfaceConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 5, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "ausmInterfacePortNum"))
if mibBuilder.loadTexts: ausmInterfaceConfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ausmInterfaceConfEntry.setDescription('This list contains ATM interface configuration parameters and state variables and is indexed by ausmInterfacePortNum values of ATM interfaces. ')
ausmInterfacePortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ausmInterfacePortNum.setStatus('mandatory')
if mibBuilder.loadTexts: ausmInterfacePortNum.setDescription('This is logical port number. In AUSM, a logical port is same as a physical port. ')
ausmInterfaceMyNeighborIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 1, 5, 1, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ausmInterfaceMyNeighborIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ausmInterfaceMyNeighborIpAddress.setDescription('The IP address of the neighbor system connected to the far end of this interface, to which a Network Management Station can send SNMP messages, as IP datagrams sent to UDP port 161, in order to access network management information concerning the operation of that system. Note that the value of this object may be obtained in different ways, e.g., by manual configuration, or through ILMI interaction with the neighbor system. ')
cesmChanCnfGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1))
cesmChanCnfGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1), )
if mibBuilder.loadTexts: cesmChanCnfGrpTable.setStatus('mandatory')
if mibBuilder.loadTexts: cesmChanCnfGrpTable.setDescription('The config table is for logical channel interface there are 4 entries for 4 DS1s in case of CESM-4P in case of CESM-8P it can have 263 entries. For CESM-T3/E3 , this will have only one entry. ')
cesmChanCnfGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "cesCnfChanNum"))
if mibBuilder.loadTexts: cesmChanCnfGrpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cesmChanCnfGrpEntry.setDescription(' An entry for logical channel ')
cesCnfChanNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 279))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesCnfChanNum.setStatus('mandatory')
if mibBuilder.loadTexts: cesCnfChanNum.setDescription('Refers to the virtual connection no. In case of CESM-4P the range is 16..19 (only for 4 entries). for CESM-8t1 we can have 192 and for CESM-8e1 we can have 248 channels. For CESM-T3/E3 we can have only one connection. For CESM-T1/E1/T3/E3, channel number starts from 35 in Release2.2 ')
cesChanRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("add", 1), ("del", 2), ("mod", 3), ("outOfService", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesChanRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cesChanRowStatus.setDescription("This indicates the channel status 1 ==> ADD 2 ==> DELETE 3 ==> MODIFY 4 ==> Setting this object to outOfService takes the channel out of service or brings the channel 'down'. The channel can be brought 'up' again by setting the object to mod. ")
cesMapPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesMapPortNum.setStatus('mandatory')
if mibBuilder.loadTexts: cesMapPortNum.setDescription('In case of CESM-4P this variable specifies the port number to which this channel is associated. Mappings are as - Port 1 - channel 16, 2-17, 3-18, 4-19 (it can take value from 1..4) In CESM-8 this variable gives mapping between logical channel and physical line number. In case of CESM-8P instead of this cesChanPortNum will be used to have the mapping between Channel and logical Port. In case of CESM-T3 it can be 1..1 ')
cesMapVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 14))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesMapVpi.setStatus('mandatory')
if mibBuilder.loadTexts: cesMapVpi.setDescription('The value of this object is equal to the VPI used for the emulated circuit represented by this connection. In MGX8220( formerly AXIS) Implementaion slot number of the card will be used for this. ')
cesMapVci = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 279))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesMapVci.setStatus('mandatory')
if mibBuilder.loadTexts: cesMapVci.setDescription('This specifies VCI for emulated circuit represented by this VC. Our Implementation cesCnfChanNum will be used for this. In case of CESM-4P valid range is 16..19. In case of CESM-8P valid range is 32..279. In case of CESM-T3/E3 valid value is 32. ')
cesCBRService = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("unstructured", 1), ("structured", 2))).clone('unstructured')).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesCBRService.setStatus('mandatory')
if mibBuilder.loadTexts: cesCBRService.setDescription('This specifies data type supported by the CBR service Only Unstructured mode is supported in CESM-4P CESM-8P supports both structured and unstructured mode for T1/E1 and supports only unstructured mode in case of T3/E3. In CESM-T3 only unstructured is supported. ')
cesCBRClockMode = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("synchronous", 1), ("srts", 2), ("adaptive", 3))).clone('synchronous')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesCBRClockMode.setStatus('mandatory')
if mibBuilder.loadTexts: cesCBRClockMode.setDescription('This specifies clocking mode of the CBR service Only synchronous mode is supported in CESM-4P Structured mode is always synchronous. CESM -T3 will support only synchronous. ')
cesCas = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("basic", 1), ("e1Cas", 2), ("ds1SfCas", 3), ("ds1EsfCas", 4), ("ccs", 5), ("conditionedE1Cas", 6), ("basicNoPointer", 7), ("ds1SfCasMF", 8), ("ds1EsfCasMF", 9))).clone('basic')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesCas.setStatus('mandatory')
if mibBuilder.loadTexts: cesCas.setDescription('Specifies if CAS bits are carried by the service. This also selects which AAL1 format should be used. Only basic mode is supported for unstructured connections Only basic mode is supported in CESM-4P and CESM-T3E3 . If type is ccs then this particular VC is carrying Signaling information. ccs option is not supported in CESM-8T1E1. In CESM-8T1/E1 all channels on a line should have the same value. basicNoPointer should be used for adding 1x64 basic connections without an AAL1 pointer ( CES-IS 2.0 compliance ). when cesCas = basic, for 1x64 connections, cells will be generated with a AAL1 pointer.Similarly while receiving, pointer will be expected in the incoming cells. ds1SfCasMF and ds1EsfCasMF should be used when line level multiframe sync to be enabled. ')
cesPartialFill = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 47)).clone(47)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesPartialFill.setStatus('mandatory')
if mibBuilder.loadTexts: cesPartialFill.setDescription('Specifies the number of user octets per cell, if partial cell fill is used. 47 means partial fill disabled. Partial fill is not supported in CESM-4P Ranges for partial fill are: T1 struct 25 - 47 T1 unstruct 33 - 47 E1 struct 20 - 47 E1 unstruct 33 - 47 and partial fill for any channel should always exceed the number of time slots assigned to that channel. ')
cesBufMaxSize = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesBufMaxSize.setStatus('mandatory')
if mibBuilder.loadTexts: cesBufMaxSize.setDescription('Specifies the maximum size in octets of egress buffer. CESM - 4P: Should be at least 0.6*CDVRxT for a T1 line and 0.7 * CDVRxT for a E1 line. 0 can be specified to internally compute the value Defaults for CESM-8T1E1 and CESM-T3E3 ------------------------------------- Default value of cesBufMaxSize is 0. Maximum value for CESM-8T1E1 and CESM-T3E3 ------------------------------------------- For T1 UDT and E1 UDT : 16224 bytes For T1 SDT : 384 * N bytes For E1 SDT : 417 * N bytes For T3 UDT and E3 UDT : 16224 bytes where N is the number of timeslots assigned in Nx64 connection. For T1-UDT and E1 UDT use N = 32 . Minimum value for CESM-8T1E1 and CESM-T3E3 ------------------------------------------- In CESM-8T1/E1 and CESM-T3E3 this object ( unit in bytes ) should be at least the greater of (1) CDVT in frames * 2 * N (2) ( CDVT in frames + number of frames in two cells ) * N where N is the number of timeslots assigned in Nx64 connection. For T1-UDT and E1-UDT use N = 32. ')
cesCDVRxT = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(125, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesCDVRxT.setStatus('mandatory')
if mibBuilder.loadTexts: cesCDVRxT.setDescription(' Specifies maximum cell arrival jitter that the reassembly process will tolerate. In case of CESM-8P it should be in increment of 125 micro secs and Max limit are as follows. T1 = 24 ms E1 = 26 ms T3 = 1.447 ms and E3 = 1.884 ms. Default values in CESM-8T1/E1 and CESM-T3/E3.: For T1 and E1 , 1000 microsecs. For T3 and E3 , 1000 microsecs. ')
cesCellLossIntegrationPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1000, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesCellLossIntegrationPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: cesCellLossIntegrationPeriod.setDescription('Specifies the cell loss integration period in milliseconds ')
cesChanLocRmtLpbkState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesChanLocRmtLpbkState.setStatus('mandatory')
if mibBuilder.loadTexts: cesChanLocRmtLpbkState.setDescription('Loopback on cellbus in egress direction. ')
cesChanTestType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("testcon", 1), ("testdelay", 2), ("notest", 3), ("testconsti", 4), ("testdelaysti", 5))).clone('notest')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesChanTestType.setStatus('mandatory')
if mibBuilder.loadTexts: cesChanTestType.setDescription('This is the type of the test 1 = Test Continuity 2 = Test Delay 3 = no test is initated 4 = test continuity with sti cell format 5 = test delay with sti cell format ')
cesChanTestState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("passed", 1), ("failed", 2), ("inprogress", 3), ("notinprogress", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesChanTestState.setStatus('mandatory')
if mibBuilder.loadTexts: cesChanTestState.setDescription('This shows the state of the test 1 = Passed 2 = Failed 3 = In Progress 4 = Not In Progress ')
cesChanRTDResult = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesChanRTDResult.setStatus('mandatory')
if mibBuilder.loadTexts: cesChanRTDResult.setDescription('This is round trip delay in milliseconds ')
cesChanPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 248))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesChanPortNum.setStatus('mandatory')
if mibBuilder.loadTexts: cesChanPortNum.setDescription(' This indicates to which logical port this connection belongs. Applicable on CESM-8T1/E1 or CESM-T3/E3. 1.. 248 for E1 1.. 192 for T1 1.. 1 for T3 Only applicable to CESM-8P ')
cesChanConnType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("pvc", 1), ("svc", 2), ("spvc", 3))).clone('pvc')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesChanConnType.setStatus('mandatory')
if mibBuilder.loadTexts: cesChanConnType.setDescription('This indicates the type of connection. 1 = PVC 2 = SVC 3 ==> SPVC connection Only applicable to CESM-8P and CESM-T3/E3. ')
cesChanStrauSciNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("nonStrauChannel", 1), ("sci1", 2), ("sci2", 3), ("sci3", 4), ("sci4", 5))).clone('nonStrauChannel')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesChanStrauSciNum.setStatus('mandatory')
if mibBuilder.loadTexts: cesChanStrauSciNum.setDescription('This indicates the type of connection. 1 = Normal Channel (nonStrauChannel(0) ) 2 = SCI 1 i.e bit 1 & 2 3 = SCI 2 i.e bit 3 & 4 4 = SCI 3 i.e bit 5 & 6 5 = SCI 4 i.e bit 7 & 8 Currently not supported in CESM-8 Not applicable for CESM-4 and CESM-T3/E3 ')
cesChanIdleDetEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disable", 1), ("enableOnhookDet", 2), ("enableIdlePatternDet", 3))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesChanIdleDetEnable.setStatus('mandatory')
if mibBuilder.loadTexts: cesChanIdleDetEnable.setDescription('This indicates the type of Idle detection enabled 1 = Idle code detection is disabled. 2 = This will enable Idle detection whenver it detects Onhook in ABCD bits. Onhook code is configurable using cesChanOnhookCode. Applicable in structured mode. 3 = This will enable payload Idle code detection. Idle pattern is configurable through cesChanIdleSignalCode variable. Only applicable to CESM-8T1/E1 and non strau channels This will be supported in future release ')
cesChanIdleSignalCode = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesChanIdleSignalCode.setStatus('mandatory')
if mibBuilder.loadTexts: cesChanIdleSignalCode.setDescription('When cesChanIdleDetEnable = enableIdlePatternDet 3. This object will carry value 0..0xff and this will indicate Idle pattern in DS0 time slots. Only applicable to CESM-8P and not supported in this release. ')
cesChanIdleCodeIntgnPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesChanIdleCodeIntgnPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: cesChanIdleCodeIntgnPeriod.setDescription(' This variable indicates the Integration period in seconds whenever cesChanIdleDetEnable = enableIdlePatternDet Only applicable to CESM-8P and not supported in this release. ')
cesChanOnhookCode = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesChanOnhookCode.setStatus('mandatory')
if mibBuilder.loadTexts: cesChanOnhookCode.setDescription(' When cesChanIdleDetEnable = enableOnhookDet 1. This will carry value 0..3 for framing mode SF. 2. This will carry value 0..15 for framing mode ESF/e1Cas. Only applicable for CESM-8T1/E1 ')
cesChanConditionedData = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(255)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesChanConditionedData.setStatus('mandatory')
if mibBuilder.loadTexts: cesChanConditionedData.setDescription(' This byte will indicate Idle data to be sent towards the line whenever channels goes in to Underrun Only applicable for CESM-8T1/E1 ')
cesmChanExtTrgIdleSupp = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disablesuppression", 1), ("enableSuppresion", 2))).clone('disablesuppression')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesmChanExtTrgIdleSupp.setStatus('mandatory')
if mibBuilder.loadTexts: cesmChanExtTrgIdleSupp.setDescription('Using this variable we can initiate Idle suppression on the connection. This can be set by external signalling device. Only applicable to CESM-8T1/E1. ')
cesmChanConditionedSigCode = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(255)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesmChanConditionedSigCode.setStatus('mandatory')
if mibBuilder.loadTexts: cesmChanConditionedSigCode.setDescription(' This byte will indicate Signal code to be sent sent towards the line whenever channels goes in to Underrun Only applicable to CESM-8T1/E1 ')
cesLocalVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 27), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesLocalVpi.setStatus('mandatory')
if mibBuilder.loadTexts: cesLocalVpi.setDescription("This VPI together with the local VCI and NSAP represents the local end point in this connection, this object is read only, therefore it'll be assigned by SM to 0. ")
cesLocalVci = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 28), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesLocalVci.setStatus('mandatory')
if mibBuilder.loadTexts: cesLocalVci.setDescription("This VCI together with the local VPI and NSAP represents the local end point in this connection, this object is read only, therefore it'll be assigned by SM to 0. ")
cesLocalNSAP = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 29), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesLocalNSAP.setStatus('mandatory')
if mibBuilder.loadTexts: cesLocalNSAP.setDescription('This NSAP is 20 bytes binary, among these 20 bytes: 13 bytes as prefix, 2 bytes for Cisco ID, 1 byte rsvd, 3 bytes for logical interface: slot (1 byte) and port number (2 bytes), the last byte is for SEL')
cesRemoteVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 30), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesRemoteVpi.setStatus('mandatory')
if mibBuilder.loadTexts: cesRemoteVpi.setDescription('This VPI together with the remote VCI and NSAP represents the remote end point in this connection. The value should be 0 for a DACS connection in MGX')
cesRemoteVci = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 31), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesRemoteVci.setStatus('mandatory')
if mibBuilder.loadTexts: cesRemoteVci.setDescription('This VCI together with the remote VPI and NSAP represents the remote end point in this connection. The value should be 0 for a DACS connection in MGX')
cesRemoteNSAP = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 32), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesRemoteNSAP.setStatus('mandatory')
if mibBuilder.loadTexts: cesRemoteNSAP.setDescription('This NSAP is 20 bytes binary, among these 20 bytes: 13 bytes as prefix, 2 bytes for Cisco ID, 1 byte rsvd, 3 bytes for logical interface: slot (1 byte) and port number (2 bytes), the last byte is for SEL')
cesMastership = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("master", 1), ("slave", 2), ("unkown", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesMastership.setStatus('mandatory')
if mibBuilder.loadTexts: cesMastership.setDescription(' This is used by PXM to determine if this end point is master or slave, a new type unknown is added to identify the SM in MGX8220(formerly AXIS) shelf and the SM in MGX shelf. In MGX8220 shelf, user can still use addchan to add a channel without specifying X/Y/P parameters. But in MGX shelf, if the user uses addchan without X/Y/P set (based on this object being set to type 3 unknown), SPM on PXM will reject the request. It must be supplied in connection setup request ')
cesVpcFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("vpc", 1), ("vcc", 2))).clone('vcc')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesVpcFlag.setStatus('mandatory')
if mibBuilder.loadTexts: cesVpcFlag.setDescription(" This represents the connection type, used for PXM to identify VPC/VCC but CESM card doesn't use it always set to vcc for CESM card ")
cesConnServiceType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 5, 6, 7, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32))).clone(namedValues=NamedValues(("cbr", 1), ("vbr", 2), ("ubr", 4), ("atfr", 5), ("abrstd", 6), ("abrfst", 7), ("cbr1", 21), ("vbr1rt", 22), ("vbr2rt", 23), ("vbr3rt", 24), ("vbr1nrt", 25), ("vbr2nrt", 26), ("vbr3nrt", 27), ("ubr1", 28), ("ubr2", 29), ("stdabr", 30), ("cbr2", 31), ("cbr3", 32)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesConnServiceType.setStatus('mandatory')
if mibBuilder.loadTexts: cesConnServiceType.setDescription("This specifies the service type 1 ==> Constant Bit Rate 2 ==> Variable Bit Rate 3 ==> Not used 4 ==> Unspecified Bit Rate 5 ==> ATM frame relay 6 ==> standard ABR 7 ==> foresight ABR Note that this is used by PXM card, SV+ doesn't need to set it, if not set in the connection setup request, it'll be defaulted to CBR type for CESM. Also to make it compatible with existing AUSM MIB definition, value 3 is not used. The following types are being added for PNNI support and are based on UNI 4.0. cbr1 (21) - CBR.1 vbr1rt (22) - Real time VBR.1 vbr2rt (23) - Real time VBR.2 vbr3rt (24) - Real time VBR.3 vbr1nrt(25) - Non Real time VBR.1 vbr2nrt(26) - Non Real time VBR.2 vbr3nrt(27) - Non Real time VBR.3 ubr1 (28) - UBR.1 ubr2 (29) - UBR.2 stdabr (30) - TM 4.0 compliant standard ABR cbr2 (31) - CBR.2 cbr3 (32) - CBR.3 Note that for CESM, the only valid connection type for PNNI support is cbr1(21). Other enumerations have been added for the sake of consistency across Narrow-Band service modules. ")
cesRoutingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 36), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesRoutingPriority.setStatus('mandatory')
if mibBuilder.loadTexts: cesRoutingPriority.setDescription(' This is used by PXM to determine how important this connection is when selecting connections to route ')
cesMaxCost = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 37), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesMaxCost.setStatus('mandatory')
if mibBuilder.loadTexts: cesMaxCost.setDescription(" Maximum allowed cost. It is related to Cost Based Routing. This is used by PXM so that it won't choose a path with a cost greater than this configured level. This is not necessary to be provided in the connection setup request, if not provided, the default value 255 will be used. When used with PAR controller the valid range is 1..65535 and the default value is 255. When used with PNNI controller the valid range is 1..2147483647 and the default value is 2147483647. ")
cesRestrictTrunkType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 38), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noresriction", 1), ("terrestrialTrunk", 2), ("sateliteTrunk", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesRestrictTrunkType.setStatus('mandatory')
if mibBuilder.loadTexts: cesRestrictTrunkType.setDescription(' Restricted trunk type for routing, used by PXM. It specifies that the connection either cannot be routed over satelite trunks, or terrestrial trunks, or it can be on any type of trunk. It is not necessary to be provide in the connection setup request, the default value is noresriction(1). ')
cesConnPCR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 39), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesConnPCR.setStatus('mandatory')
if mibBuilder.loadTexts: cesConnPCR.setDescription(' Peak cell rate,if not provided in the connection setup request,it will be computed as follows, For CESM-8T1/E1 - N * 64 Kbps , where N = Number of timeslots assigned to this channel. For CESM-T3, the value is 44736 Kbps For CESM-E3, the value is 34368 Kbps. ')
cesConnMCR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 40), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesConnMCR.setStatus('mandatory')
if mibBuilder.loadTexts: cesConnMCR.setDescription(' Minimum cell rate,if not provided in the connection setup request,it will be computed as follows, For CESM-8T1/E1 - N * 64 Kbps , where N = Number of timeslots assigned to this channel. For CESM-T3, the value is 44736 Kbps For CESM-E3, the value is 34368 Kbps. ')
cesConnPercentUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 41), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesConnPercentUtil.setStatus('mandatory')
if mibBuilder.loadTexts: cesConnPercentUtil.setDescription('This is the expected long-term utilization of the channel by theis end-point. For CESM-8T1/E1/T3/E3 , the value is 100%')
cesmConnRemotePCR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 42), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesmConnRemotePCR.setStatus('mandatory')
if mibBuilder.loadTexts: cesmConnRemotePCR.setDescription(' Peak cell rate of the other end, if not set in MGX, will be derived from the end point parameter ')
cesmConnRemoteMCR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 43), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesmConnRemoteMCR.setStatus('mandatory')
if mibBuilder.loadTexts: cesmConnRemoteMCR.setDescription(' Minimum cell rate of the other end, if not set in MGX, will be derived from the end point parameter ')
cesmConnRemotePercentUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 44), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesmConnRemotePercentUtil.setStatus('mandatory')
if mibBuilder.loadTexts: cesmConnRemotePercentUtil.setDescription('This is the expected long-term utilization of the channel by the other end-point.')
cesmConnForeSightEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 45), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesmConnForeSightEnable.setStatus('mandatory')
if mibBuilder.loadTexts: cesmConnForeSightEnable.setDescription('This object is used by the controller(PAR/PNNI/TAG) to set up the Qbin for the connection. This is notapplicable to CESM-8T1/E1/T3/E3. ')
cesmConnFGCRAEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 46), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesmConnFGCRAEnable.setStatus('mandatory')
if mibBuilder.loadTexts: cesmConnFGCRAEnable.setDescription('enables/disables Frame based GCRA (early packet discard). This is not applicable to CESM-8T1/E1/T3/E3.')
cesmChanReroute = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 47), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2))).clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesmChanReroute.setStatus('mandatory')
if mibBuilder.loadTexts: cesmChanReroute.setDescription('This is used by the administrator to trigger the re-routing of the connection. The rerouting takes effect, when this object is set to true(1). When set to false (2), no action is taken. A get on this object always returns false (2). This object is not applicable to MGX Release 1.x. ')
cesmConnAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 1, 1, 48), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2))).clone('down')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesmConnAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cesmConnAdminStatus.setDescription('This object specifies channel admin status. This object is not applicable to MGX Release 1.x. ')
cesmChanNumNextAvailable = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 279))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesmChanNumNextAvailable.setStatus('mandatory')
if mibBuilder.loadTexts: cesmChanNumNextAvailable.setDescription('This variable contains the next unused channel number of the possible 248. This number can be used in channel config table. cesChanNumNextAvailable gets updated whenever this number is used to create a new logical channel. Value 0 for this variable indicates that no more channels are available. In CESM 8-port card), the maximum number of values for this variable is 248 (i.e. 32 ..279). Only applicable to CESM-8T1/E1/T3/E3. ')
cesmChanCntGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 2))
cesmChanCntGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 2, 1), )
if mibBuilder.loadTexts: cesmChanCntGrpTable.setStatus('mandatory')
if mibBuilder.loadTexts: cesmChanCntGrpTable.setDescription('The config table is for logical channel interface there are 4 entries for 4 DS1s in case of CESM-4P In case of CESM-8P it can have 352 entries. ')
cesmChanCntGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 2, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "cesCntChanNum"))
if mibBuilder.loadTexts: cesmChanCntGrpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cesmChanCntGrpEntry.setDescription(' An entry for logical channel ')
cesCntChanNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 279))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesCntChanNum.setStatus('mandatory')
if mibBuilder.loadTexts: cesCntChanNum.setDescription('Refers to the channel Number 16 - 19 for CESM-4P 32 - 279 for CESM-8t1e1 32 for CESM-T3/E3 ')
cesChanState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notConfigured", 1), ("okay", 2), ("alarm", 3), ("failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesChanState.setStatus('mandatory')
if mibBuilder.loadTexts: cesChanState.setDescription(' This variable indicates the connection status failed(4) is added to distinguish between alarm (when the connection segment is not actually broken) and failed(when the segment is actually broken). This is applicable only to the PNNI environment. ')
cesXmtATMState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("normal", 2), ("sendingAIS", 3), ("sendingFERF", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesXmtATMState.setStatus('mandatory')
if mibBuilder.loadTexts: cesXmtATMState.setDescription(' This variable indicates the transmit state of channel on the ATM side (towards the network). ')
cesRcvATMState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("normal", 2), ("receivingAIS", 3), ("receivingFERF", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesRcvATMState.setStatus('mandatory')
if mibBuilder.loadTexts: cesRcvATMState.setDescription(' This variable indicates the receive state of channel on the ATM side (from the network). ')
cesCellLossStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noLoss", 1), ("loss", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesCellLossStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cesCellLossStatus.setDescription('When cells are lost for the CellLossIntegrationPeriod the value is set to loss ( 2). when cells are no longer lost, the value is set to noLoss(1). ')
cesReassCells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 2, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesReassCells.setStatus('mandatory')
if mibBuilder.loadTexts: cesReassCells.setDescription('The number of cells played out to T1/E1/T3E3 interface. It excludes cells that were discarded for any reason. ')
cesGenCells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 2, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesGenCells.setStatus('mandatory')
if mibBuilder.loadTexts: cesGenCells.setDescription('The number of cells generated from T1/E1/T3E3 interface and sent towards network. ')
cesHdrErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 2, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesHdrErrors.setStatus('mandatory')
if mibBuilder.loadTexts: cesHdrErrors.setDescription('The number of AAL-1 header errors detected and possibly corrected. Header errors include correctable and uncor- rectable CRC, plus bad parity. ')
cesPointerReframes = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 2, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesPointerReframes.setStatus('mandatory')
if mibBuilder.loadTexts: cesPointerReframes.setDescription('The number of events in which the AAL1 reassembler found that an SDT pointer is not where it is expected and the and the pointer must be reacquired. Not supported in cesm8P due limitation in AAL1 SAR. Not applicable for CESM-4T1/E1 and CESM-T3/E3 ')
cesLostCells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 2, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesLostCells.setStatus('mandatory')
if mibBuilder.loadTexts: cesLostCells.setDescription('The number of cells lost in egress direction due to AAL 1 header errors and missing cells. ')
cesBufUnderflows = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 2, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesBufUnderflows.setStatus('mandatory')
if mibBuilder.loadTexts: cesBufUnderflows.setDescription('The number of buffer underflows in Egress direction Not supported in cesm8P due limitation in AAL1 SAR. ')
cesBufOverflows = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 2, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesBufOverflows.setStatus('mandatory')
if mibBuilder.loadTexts: cesBufOverflows.setDescription('The number of buffer overflows in Egress direction Not supported in cesm8P due limitation in AAL1 SAR. ')
cesIngrDiscardedBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 2, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesIngrDiscardedBytes.setStatus('mandatory')
if mibBuilder.loadTexts: cesIngrDiscardedBytes.setDescription('The number of bytes discarded due to shelf alarm in ingress direction from port data. Not supported in CESM-8P. ')
cesUflowInsCells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 2, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesUflowInsCells.setStatus('mandatory')
if mibBuilder.loadTexts: cesUflowInsCells.setDescription("The Number of All 1's cells inserted in case of Egress Buffer Underflow Not supported in CESM-8P. ")
cesOflowDropBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 2, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesOflowDropBytes.setStatus('mandatory')
if mibBuilder.loadTexts: cesOflowDropBytes.setDescription('The Number of bytes discarded in Egress direction because of Egress buffer overflow Not supported in CESM-8P. ')
cesCellSeqMismatchCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 2, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesCellSeqMismatchCnt.setStatus('mandatory')
if mibBuilder.loadTexts: cesCellSeqMismatchCnt.setDescription('The Number of times SAR received a valid out of sequence AAL-1 cell from CellBus. ')
counterClrButton = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 2, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noAction", 1), ("resetCounters", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: counterClrButton.setStatus('mandatory')
if mibBuilder.loadTexts: counterClrButton.setDescription('writing a value of 2 resets all the counters ')
cesChanSecUptime = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 2, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesChanSecUptime.setStatus('mandatory')
if mibBuilder.loadTexts: cesChanSecUptime.setDescription('The Number of seconds channel is in service only applicable for CESM-8P ')
cesChanSignalingStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 2, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off-hook", 1), ("on-hook", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesChanSignalingStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cesChanSignalingStatus.setDescription(' This variable indicates the connection signalling status Connection will be in Idle suppression mode if it in on-hook. Not applicable for T3E3 and CESM-4P. ')
cesChanStatusBitMap = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 2, 2, 1, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesChanStatusBitMap.setStatus('mandatory')
if mibBuilder.loadTexts: cesChanStatusBitMap.setDescription('This variable indicates the consolidated bit map of the channel alarm state. Individual bit positions are as defined below. Bit position Fail/Alarm Reason ------------ ---------- ------ 0 Alarm Reserved 1 Alarm n/w side AIS/RDI Rx 2 Fail Conditioned(A bit from n/w) 3 Alarm Reserved 4 Fail Reserved 5 Fail Reserved 6 Alarm Reserved 7 Alarm Cell loss alarm Fail bitmap mask : 0x34 Alarm bitmap mask: 0xCB This object is not applicable to MGX Release 1.x. ')
cesmPort = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 1))
cesmPortCnfGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 1, 1))
cesmPortCnfGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 1, 1, 1), )
if mibBuilder.loadTexts: cesmPortCnfGrpTable.setStatus('mandatory')
if mibBuilder.loadTexts: cesmPortCnfGrpTable.setDescription('The config table is for logical port interface there are 192 entries for 8 DS1s or 248 entries for 8 E1s ')
cesmPortCnfGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 1, 1, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "cesPortNum"))
if mibBuilder.loadTexts: cesmPortCnfGrpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cesmPortCnfGrpEntry.setDescription(' An entry for logical port ')
cesPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 1, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 248))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesPortNum.setStatus('mandatory')
if mibBuilder.loadTexts: cesPortNum.setDescription('This is logical port number. If we have T1 card then the maximum port number is 192 and if we have E1 card the maximum port number can be 248 for T3 only one port is supported. ')
cesPortRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 1, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("add", 1), ("del", 2), ("mod", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesPortRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cesPortRowStatus.setDescription('This variable enables or modifies the port 1- add 2 - del 3 - mod ')
cesPortLineNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 1, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesPortLineNum.setStatus('mandatory')
if mibBuilder.loadTexts: cesPortLineNum.setDescription('This represents the line number to which this port is associated. For T3 only one line is supported. ')
cesPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 1, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("structured", 1), ("unstructured", 2), ("framingOnVcDisconnect", 3), ("strau", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesPortType.setStatus('mandatory')
if mibBuilder.loadTexts: cesPortType.setDescription('This represents port type whether it is carrying subrate circuits strau. If it is strau port then it can have only one DS0 time slot. In case of unstructured all the time slots will be allocated to that. Strau ports are not supported in CESM-8T1/E1 or CESM-T3E3. framingOnVcDisconnect is similar to unstructured port during normal operation. In case of channel failure, line data will be looped back towards line. CESM-T3E3 card will support only unstructured mode. ')
cesPortDs0ConfigBitMap = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 1, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesPortDs0ConfigBitMap.setStatus('mandatory')
if mibBuilder.loadTexts: cesPortDs0ConfigBitMap.setDescription('This respesents bit map of DS0s for a line which are used to form this logical port. Bit 0 represents DS0-1. ')
cesPortNumOfDs0Slot = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 1, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesPortNumOfDs0Slot.setStatus('mandatory')
if mibBuilder.loadTexts: cesPortNumOfDs0Slot.setDescription('This represents number of DS0 time slots configured to this Port. If the port type is strau then this can not have more than 1 DS0 time slot. ')
cesPortNumOfSCIPerDS0 = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 1, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesPortNumOfSCIPerDS0.setStatus('mandatory')
if mibBuilder.loadTexts: cesPortNumOfSCIPerDS0.setDescription('This is applicable only to the Strau Port. represents number of subcircuit in the DS0 time slot. 8 = there are 8 no .of 8kbps links (1 bit) 4 = there are 4 no .of 16kbps links (2 bit) 2 = there are 2 no .of 32kbps links (4 bit) Currently not supported in CESM-8 ')
cesPortSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 1, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 44736))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesPortSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: cesPortSpeed.setDescription('Configured speed of port in kbps Max speed for T1 = 1544 Max speed for E1 = 2038 Max speed for T3 = 44736 Max spped for E3 = 34368 ')
cesPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 1, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("notConfigured", 1), ("active", 2), ("remoteLoopback", 3), ("failedDueToLine", 4), ("failedDueToSignalling", 5), ("inactive", 6), ("inBert", 7), ("farEndRemoteLoopback", 8))).clone('notConfigured')).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesPortState.setStatus('mandatory')
if mibBuilder.loadTexts: cesPortState.setDescription('This variable indicates the state of the logical port ')
cesPortBERTEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 1, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesPortBERTEnable.setStatus('mandatory')
if mibBuilder.loadTexts: cesPortBERTEnable.setDescription('This variable enables BERT This object is not supported in CESM-T3E3. ')
cesPortNextAvailable = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 248))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesPortNextAvailable.setStatus('mandatory')
if mibBuilder.loadTexts: cesPortNextAvailable.setDescription("This variable contains the next UNUSED logical port number of the possible 32 DS0s * n ports. This number can be used in channel config table, the cesportNextAvailable gets updated if the number gets used to create a logical port. A '0' indicates that no more ports are available. ")
cesPortsUsedLine1 = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesPortsUsedLine1.setStatus('mandatory')
if mibBuilder.loadTexts: cesPortsUsedLine1.setDescription('Each bits set represents a DS0 that is used by all the logical ports defined so far for that DS1, the most significant byte is invalid for DS1 This is for line 1 ')
cesPortsUsedLine2 = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesPortsUsedLine2.setStatus('mandatory')
if mibBuilder.loadTexts: cesPortsUsedLine2.setDescription('Each bits set represents a DS0 that is used by all the logical ports defined so far for that DS1, the most significant byte is invalid for DS1 This is for line 2 ')
cesPortsUsedLine3 = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesPortsUsedLine3.setStatus('mandatory')
if mibBuilder.loadTexts: cesPortsUsedLine3.setDescription('Each bits set represents a DS0 that is used by all the logical ports defined so far for that DS1, the most significant byte is invalid for DS1 This is for line 3 ')
cesPortsUsedLine4 = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesPortsUsedLine4.setStatus('mandatory')
if mibBuilder.loadTexts: cesPortsUsedLine4.setDescription('Each bits set represents a DS0 that is used by all the logical ports defined so far for that DS1, the most significant byte is invalid for DS1 This is for line 4 ')
cesPortsUsedLine5 = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesPortsUsedLine5.setStatus('mandatory')
if mibBuilder.loadTexts: cesPortsUsedLine5.setDescription('Each bits set represents a DS0 that is used by all the logical ports defined so far for that DS1, the most significant byte is invalid for DS1 This is for line 5 ')
cesPortsUsedLine6 = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesPortsUsedLine6.setStatus('mandatory')
if mibBuilder.loadTexts: cesPortsUsedLine6.setDescription('Each bits set represents a DS0 that is used by all the logical ports defined so far for that DS1, the most significant byte is invalid for DS1 This is for line 6 ')
cesPortsUsedLine7 = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesPortsUsedLine7.setStatus('mandatory')
if mibBuilder.loadTexts: cesPortsUsedLine7.setDescription('Each bits set represents a DS0 that is used by all the logical ports defined so far for that DS1, the most significant byte is invalid for DS1 This is for line 7 ')
cesPortsUsedLine8 = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesPortsUsedLine8.setStatus('mandatory')
if mibBuilder.loadTexts: cesPortsUsedLine8.setDescription('Each bits set represents a DS0 that is used by all the logical ports defined so far for that DS1, the most significant byte is invalid for DS1 This is for line 8 ')
cesmPortCnfResPartGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 1, 2))
cesmPortCnfResPartGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 1, 2, 1), )
if mibBuilder.loadTexts: cesmPortCnfResPartGrpTable.setStatus('mandatory')
if mibBuilder.loadTexts: cesmPortCnfResPartGrpTable.setDescription('This table contains the configuration of port resource partition This is applicable for MGX8820(formerly AXIS) Rel. 5 and MGX. ')
cesmPortCnfResPartGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 1, 2, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "cesmResPartPortNum"), (0, "CISCO-WAN-AXIPOP-MIB", "cesmResPartCtrlrNum"))
if mibBuilder.loadTexts: cesmPortCnfResPartGrpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cesmPortCnfResPartGrpEntry.setDescription('An entry for logical port ')
cesmResPartPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 1, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 248))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesmResPartPortNum.setStatus('mandatory')
if mibBuilder.loadTexts: cesmResPartPortNum.setDescription('This is the logical port number, the index to this table. If we have T1 card then the maximum port number is 192 and if we have E1 card the maximum port number can be 248. CESM-T3/E3 supports only one port. ')
cesmResPartCtrlrNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 1, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("par", 1), ("pnni", 2), ("tag", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesmResPartCtrlrNum.setStatus('mandatory')
if mibBuilder.loadTexts: cesmResPartCtrlrNum.setDescription('This is index for controller using the port ')
cesmResPartRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 1, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("add", 1), ("del", 2), ("mod", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesmResPartRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cesmResPartRowStatus.setDescription(' This will add, delete or modify the partition. 1 ==> ADD 2 ==> DELETE 3 ==> MODIFY ')
cesmResPartNumOfLcnAvail = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 1, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 248))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesmResPartNumOfLcnAvail.setStatus('mandatory')
if mibBuilder.loadTexts: cesmResPartNumOfLcnAvail.setDescription(' This represents number of LCNs available for this controller and this port. In CESM-T3/E3 and 8-T1/E1,this value is 1. ')
cesmResPartLcnLow = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 1, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 248))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesmResPartLcnLow.setStatus('mandatory')
if mibBuilder.loadTexts: cesmResPartLcnLow.setDescription('This represents low end of reserved LCN In CESM-8T1/E1 and T3/E3, this refers to the logical port. ')
cesmResPartLcnHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 1, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 248))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesmResPartLcnHigh.setStatus('mandatory')
if mibBuilder.loadTexts: cesmResPartLcnHigh.setDescription('This represents high end of reserved LCN In CESM-8T1/E1 and T3/E3, this refers to the logical port. ')
cesmResPartIngrPctBW = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 1, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesmResPartIngrPctBW.setStatus('mandatory')
if mibBuilder.loadTexts: cesmResPartIngrPctBW.setDescription('The percentage of total ingress bandwidth reserved. In CESM-8T1/E1 and T3/E3, as there is only one LCN per port and it could be used by only one controller,this value is 100% for that controller. ')
cesmResPartEgrPctBW = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 1, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesmResPartEgrPctBW.setStatus('mandatory')
if mibBuilder.loadTexts: cesmResPartEgrPctBW.setDescription('The percentage of total egress bandwidth reserved In CESM-8T1/E1 and T3/E3, as there is only one LCN per port and it could be used by only one controller,this value is 100% for that controller. ')
cesmResPartCtrlrID = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 1, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cesmResPartCtrlrID.setStatus('mandatory')
if mibBuilder.loadTexts: cesmResPartCtrlrID.setDescription('This is the controller identifier for the resource patition. The default value is set for PNNI controller. ')
cesmEndPtMapGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 3))
cesmEndPtMapGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 3, 1), )
if mibBuilder.loadTexts: cesmEndPtMapGrpTable.setStatus('mandatory')
if mibBuilder.loadTexts: cesmEndPtMapGrpTable.setDescription('There are 248 entries and port num will uniquely identify a row. For CESM-8T1/E1 , only 248 ports are possible. For CESM-T3/E3, only one port is possible. ')
cesmEndPtMapGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 3, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "cesEndPortNum"))
if mibBuilder.loadTexts: cesmEndPtMapGrpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cesmEndPtMapGrpEntry.setDescription('An entry for cesmEndPtMapGrpEntry. ')
cesEndPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 248))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesEndPortNum.setStatus('mandatory')
if mibBuilder.loadTexts: cesEndPortNum.setDescription('Refers to the logical port index CESM-8E1 supports 248 ports. CESM-8T1 supports 192 ports. CESM-T3/E3 supports only one port. ')
cesEndChanNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(32, 279))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesEndChanNum.setStatus('mandatory')
if mibBuilder.loadTexts: cesEndChanNum.setDescription('Logical connection number for above cesEndPortNum ')
cesEndLineNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 3, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cesEndLineNum.setStatus('mandatory')
if mibBuilder.loadTexts: cesEndLineNum.setDescription('Refers to the physical line index In case T3 only one line will be supported. ')
frChanCnfGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1))
frChanCnfGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1), )
if mibBuilder.loadTexts: frChanCnfGrpTable.setStatus('mandatory')
if mibBuilder.loadTexts: frChanCnfGrpTable.setDescription('The config table is for logical channel interface (upto 4000 entries). The actual number of entries supported by a card depends on the type of card. eg: FRSM-4T1/E1 supports 256 entries FRSM-8T1/E1 supports 1000 entries FRSM-T3/E3/HS2/HS2B-HSSI/T3B/E3B supports 2000 entries FRSM-2CT3/HS2B-12IN1 supports 4000 entries FRSM12 supports 16000 entries ')
frChanCnfGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "chanNum"))
if mibBuilder.loadTexts: frChanCnfGrpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: frChanCnfGrpEntry.setDescription(' An entry for logical channel ')
chanNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanNum.setStatus('mandatory')
if mibBuilder.loadTexts: chanNum.setDescription('Refers to the virtual connection index Note that the actual range of the index supported by a card depends on the type of card. eg: FRSM-4T1/E1 supports a range from 16..271 (256 entries) FRSM-8T1/E1 supports a range from 16..1015 (1000 entries) FRSM-T3/E3/HS2/HS2B-HSSI/T3B/E3B supports a range from 16..2015 (2000 entries) FRSM-2CT3/HS2B-12IN1 supports a range from 16..4015 (4000 entries) For FRSM12 Card: Byte 3 = Chassis Number, Byte 2 = Slot Number, Byte 1 & 0 = channel Number. Lower two bytes range from 16..16015 (16000 entries) ')
chanRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("add", 1), ("del", 2), ("mod", 3), ("outOfService", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chanRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: chanRowStatus.setDescription("This will add, delete or modify the channel 1 ==> ADD 2 ==> DELETE 3 ==> MODIFY Setting this object to outOfService takes the channel out of service or brings the channel 'down'. The channel can be brought 'up' again by setting the object to mod ")
chanPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chanPortNum.setStatus('mandatory')
if mibBuilder.loadTexts: chanPortNum.setDescription("Refers to the logical ports that are possible on this card, the user must set this variable For FRSM12 Card: This object contains the port's ifIndex value. ")
dLCI = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8388607))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dLCI.setStatus('mandatory')
if mibBuilder.loadTexts: dLCI.setDescription('This variable is the DLCI number of the channel. The user has to set this variable. All the connections on the same port should have a unique DLCI number. Note that if we are adding a channel to a port that has LMI signalling enabled, then we can not use DLCI number 0(ANNEX A & D) and 1023(STRATA LMI). For FRSM12 Card: For FR header length of 2-bytes, DLCI range is (0 .. 1023) and 0, 1007, 1023 DLCIs cannot be used. For FR header length of 4-bytes, DLCI range is (0 .. 8388607) and 0, 8257535 DLCIs cannot be used. ')
egressQSelect = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("highPriority", 1), ("lowPriority", 2), ("notSupported", 3))).clone('lowPriority')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: egressQSelect.setStatus('mandatory')
if mibBuilder.loadTexts: egressQSelect.setDescription('Selects one out of two possible port queues. The default port queue number is 1 which is the high pririty queue. 1 = High priority queue 2 = Low priority queue 3 = Indicates that this entry is not used (eg: in FRSM-VHS, chanServType indicates the channel service type and would determine the queue to which the channel gets mapped) For FRSM12 Card: This object is used to select between the two ATM-COS queues in the egress direction. ')
ingressQDepth = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(4510, 2097151)).clone(65535)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ingressQDepth.setStatus('mandatory')
if mibBuilder.loadTexts: ingressQDepth.setDescription("This variable sets the max depth for queue, before it starts dropping the cells. It is defined in terms of number of bytes. In all cards except the FRSM-VHS card, the range is limited to (4510..'ffff'h). ingressQDepth should be greater than ingressQECNThresh and ingressQDEThresh For FRSM12 Card: Not Supported ")
ingressQECNThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2097151)).clone(6553)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ingressQECNThresh.setStatus('mandatory')
if mibBuilder.loadTexts: ingressQECNThresh.setDescription("This variable sets the max depth for queue, before it starts flow control. It is defined in terms of number of bytes. In all cards except the FRSM-VHS card, the range is limited to (0..'ffff'h). For FRSM12 Card: Not Supported ")
ingressQDEThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2097151)).clone(32767)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ingressQDEThresh.setStatus('mandatory')
if mibBuilder.loadTexts: ingressQDEThresh.setDescription("This variable sets the max depth for queue, before they become discard eligible. It is defined in terms of number of bytes. In all cards except the FRSM-VHS card, the range is limited to (0..'ffff'h). For FRSM12 Card: Not Supported ")
egressQDepth = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2097151)).clone(65535)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: egressQDepth.setStatus('mandatory')
if mibBuilder.loadTexts: egressQDepth.setDescription("This variable sets the max depth for queue, before it starts dropping the cells. It is defined in terms of number of bytes. In all cards except the FRSM-VHS card, the range is limited to (0..'ffff'h). egressQDepth should be greater than egressQDEThresh and egressQECNThresh For FRSM12 Card: Not Supported ")
egressQDEThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2097151)).clone(32767)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: egressQDEThresh.setStatus('mandatory')
if mibBuilder.loadTexts: egressQDEThresh.setDescription("This variable sets the max depth for queue, before they become discard eligible. It is defined in terms of number of bytes. In all cards except the FRSM-VHS card, the range is limited to (0..'ffff'h). For FRSM12 Card: Not Supported ")
egressQECNThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2097151)).clone(6553)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: egressQECNThresh.setStatus('mandatory')
if mibBuilder.loadTexts: egressQECNThresh.setDescription("This variable sets the max depth for queue, before it starts flow control. It is defined in terms of number of bytes. In all cards except the FRSM-VHS card, the range is limited to (0..'ffff'h). For FRSM12 Card: Not Supported ")
deTaggingEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: deTaggingEnable.setStatus('mandatory')
if mibBuilder.loadTexts: deTaggingEnable.setDescription('The default value is 2. This variable enables DE tagging in the ingress direction only. enable = 1 disable = 2 For FRSM12 Card: When this object is disabled, the ingress policer will never set the DE bit to 1 in the Frame Relay frames even if the incoming frame exceeds the Bc bucket. ')
cir = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 52000000)).clone(2400)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cir.setStatus('mandatory')
if mibBuilder.loadTexts: cir.setDescription('The default value is 2400 cir defines committed information rate cir is in bits per second Maximum value for cir for an E1 card is 2048000 and for a T1 card is 1536000. cir has to be less than or equal to the port speed. Maximum value for cir for an E3 card is 34368000, for a T3 card is 44736000m, and for HSSI it is 52000000. Note that for FRSM-2CT3 card, the peak value of permissible CIR is 1536000. Maximum value for FRSM-HS2B-12IN1 is 10240000 Any value from 1 to 2399 will be rounded off to 2400. For FRSM12 Card: The range is 0-44736000 bps for T3, and The range is 0-34368000 bps for E3. cir can be 0 only for chanServType of uBR. ')
bc = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2097151)).clone(5100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bc.setStatus('mandatory')
if mibBuilder.loadTexts: bc.setDescription('The default value is 5100 bc defines burst committed. bc is in bytes. bc can not be 0 when cir is not 0. bc has to be 0 if cir is 0. The peak value for bc in FRSM-VHS cards is (2^21 -1), i.e. 2097151 and for all other cards, it is 65535. For FRSM-VHS cards, the relation between CIR and Bc should be such that Tc is always less than 512 seconds. For FRSM12 Card: The range is 0-2097151 ')
be = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2097151)).clone(5100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: be.setStatus('mandatory')
if mibBuilder.loadTexts: be.setDescription('The default value is 5100 be defines the burst excess. be can not be 0 when cir is 0. be is in bytes. The peak value for be in FRSM-VHS cards is (2^21 -1), i.e. 2097151 and for all other cards, it is 65535. For FRSM-VHS cards, setting the value of 2091751 will cause the policing to be disabled. For FRSM12 Card: The range is 0-2097151 ')
ibs = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2097151)).clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibs.setStatus('mandatory')
if mibBuilder.loadTexts: ibs.setDescription('The default value is 100 ibs should be less or equal to bc when cir is greater than 0. ibs has to be 0 when cir is 0. The peak value for ibs in FRSM-VHS cards is (2^21 -1), i.e. 2097151 and for all other cards, it is 65535. For FRSM12 Card: Not Supported ')
foreSightEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: foreSightEnable.setStatus('mandatory')
if mibBuilder.loadTexts: foreSightEnable.setDescription('The default value is 2 This variable sets foreSight option Note that when you enable foresight option then you can modify qir, mir and pir, otherwise you CAN NOT change these values if you are disabling foresight or if foresight option is already disabled. The RATE CONTROL FEATURE has to be ON in order to enable foresight and also modify its parameter. enable = 1 disable = 2 For FRSM12 Card: Not Supported ')
qir = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(160, 6400000)).clone(160)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qir.setStatus('mandatory')
if mibBuilder.loadTexts: qir.setDescription('The dafault is 160 qir is defined in fastpackets/sec and it defines quiescent information rate for Foresight. 1 cell/sec is equal to 16 fastpackets/sec. Following information about cps is for reference only: The peak value for qir in FRSM-VHS cards is 285714 cps and for all other cards, it is 10000 cps. For FRSM-VHS cards, cell will be the ATM cell (48 byte payload). For FRSM12 Card: Not Supported ')
mir = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(160, 6400000)).clone(160)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mir.setStatus('mandatory')
if mibBuilder.loadTexts: mir.setDescription('The dafault is 160 mir is defined in fastpackets/sec and it defines minimum information rate for Foresight. 1 cell/sec is equal to 16 fastpackets/sec. Following information about cps is for reference only: The peak value for qir in FRSM-VHS cards is 285714 cps and for all other cards, it is 10000 cps. For FRSM-VHS cards, cell will be the ATM cell (48 byte payload). For FRSM12 Card: Not Supported ')
pir = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(160, 6400000)).clone(160)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pir.setStatus('mandatory')
if mibBuilder.loadTexts: pir.setDescription('The dafault is 160 pir is defined in fastpackets/sec and it defines peak information rate for Foresight. 1 cell/sec is equal to 16 fastpackets/sec. Following information about cps is for reference only: The peak value for qir in FRSM-VHS cards is 285714 cps and for all other cards, it is 10000 cps. For FRSM-VHS cards, cell will be the ATM cell (48 byte payload). For FRSM12 Card: Not Supported ')
chanLocRmtLpbkState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chanLocRmtLpbkState.setStatus('mandatory')
if mibBuilder.loadTexts: chanLocRmtLpbkState.setDescription('The default is disable. This variable enables or disables the remote loopback for each channel. When you enable this option on a connection (channel) then all the cells that are coming from the network side would be looped back toward the network and all the frames coming from the user side would be dropped. This channel remote loopback has nothing to do with the chanTestType option, each one does a different function. For example, the channel remote loopback is used for looping the data toward the network and if this connection is terminated on an IPX then they can put a test equipment and measure some of the characteristics of the network. 1 = enable 2 = disable For FRSM12 Card: Not Supported ')
chanTestType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("testcon", 1), ("testdelay", 2), ("notest", 3))).clone('notest')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chanTestType.setStatus('mandatory')
if mibBuilder.loadTexts: chanTestType.setDescription('The default is notest. The chanTestType starts testing the continuity or delay of a connection. It sends specific cell patterns toward the network and the terminating end of this connection has to be an AXIS or ASI of a BPX in order for this test to be working. The receiving node would loop back when it receives these cells. The test should be done in about couple of seconds. The testcon tests the continuity of the connection and testdelay uses the same test except that it measures for delay through the network. To test the delay follow this procedure: a- set chanTestType to testdelay b- read chanTestState till it is Pass or Fail c- Read chanRTDResult for the delay if it is Pass *Note that the chanTestType would go back to notest when the test is completed To test the continuity follow this procedure: a- set chanTestType to testcon b- read chanTestState till it is Pass or Fail *Note that the chanTestType would go back to notest when the test is completed You CAN NOT select 2 tests back to back, you have selcelt one and wait the result and then start the other one. SYNTAX When you select testdelay This is the type of the test 1 = Test Continuity 2 = Test Delay 3 = No Test ')
chanTestState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("passed", 1), ("failed", 2), ("inprogress", 3), ("notinprogress", 4))).clone('notinprogress')).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanTestState.setStatus('mandatory')
if mibBuilder.loadTexts: chanTestState.setDescription('This shows the state of the test When you add a connection then the chanTestState becomes notinprogress and when you select any test, it would go to inprogress state and after it completes the test, it will go to failed or passed state. 1 = Passed 2 = Failed 3 = In Progress 4 = Not In Progress ')
chanRTDResult = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(65535)).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanRTDResult.setStatus('mandatory')
if mibBuilder.loadTexts: chanRTDResult.setDescription('This is round trip delay in milliseconds. When you select testdelay option for the chanTestType, the result of the test that is measured in milliseconds can be read in chanRTDResult. ')
chanType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("frNIW", 1), ("frSIW-transparent", 2), ("frSIW-translate", 3), ("frFUNI", 4), ("frForward", 5), ("frNIWReplace", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chanType.setStatus('mandatory')
if mibBuilder.loadTexts: chanType.setDescription('sets channel type Type 1 is frame-relay network interworking (NIW-unicast) type 2 is service interworking with out any SDU translation type 3 is service interworking with SDU translation type 4 is frame-relay UNI, currently mode-1a which is ALL5 type 5 is frame forwarding types 1,2,3 and 5 are supported as explained above type 4 (frame-relay UNI) is NOT supported type 6 is also supported. It means frame-relay Network Interworking with DLCI in FRSSCS-PDU always set to 1022 For FRSM12 Card: frFUNI is not supported. ')
chanFECNconfig = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("mapEFCI", 1), ("setEFCIzero", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chanFECNconfig.setStatus('mandatory')
if mibBuilder.loadTexts: chanFECNconfig.setDescription('sets FECN config mapEFCI valid only for SIW The FECN bits in frame-relay are mapped to EFCI bit in the ATM cells. ')
chanDEtoCLPmap = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("mapCLP", 1), ("setCLPzero", 2), ("setCLPone", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chanDEtoCLPmap.setStatus('mandatory')
if mibBuilder.loadTexts: chanDEtoCLPmap.setDescription('sets mapping of CLP bit The DE bit is mapped to CLP bit in ATM cell in Case 2 and 3, the DE bit is ignored and CLP bit is set to a constant value For FRSM12 Card: Should not be mapCLP for chanType of frForward. ')
chanCLPtoDEmap = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("mapDE", 1), ("setDEzero", 2), ("setDEone", 3), ("ignoreCLP", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chanCLPtoDEmap.setStatus('mandatory')
if mibBuilder.loadTexts: chanCLPtoDEmap.setDescription('sets mapping of DE bit 1,2,3 valid for SIW 1,4 valid for NIW The CLP bit is mapped to DE bit in frame-relay in the Case of 2 and 3, the CLP bit is ignored and DE bit is set to a constant value ignoreCLP ignores CLP bit and DE bit remains as received. For FRSM12 Card: Should be ignoreCLP for chanType of frForward. Should not be setDEzero/setDEone for chanType of frNIW and frNIWReplace. Should not be ignoreCLP for chanType of frSIW-transparent and frSIW-translate. ')
chanIngrPercentUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 29), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100)).clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chanIngrPercentUtil.setStatus('mandatory')
if mibBuilder.loadTexts: chanIngrPercentUtil.setDescription('the channel ingress utilized percentage ')
chanEgrPercentUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 30), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100)).clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chanEgrPercentUtil.setStatus('mandatory')
if mibBuilder.loadTexts: chanEgrPercentUtil.setDescription('the channel egress utilized percentage ')
chanEgrSrvRate = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 31), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2400, 52000000)).clone(2400)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chanEgrSrvRate.setStatus('mandatory')
if mibBuilder.loadTexts: chanEgrSrvRate.setDescription('The channel egress cir. Maximum value for chanEgrSrvRate for an E1 card is 2048000 and for a T1 card is 1536000. chanEgrSrvRate has to be less than or equal to the port speed. Maximum value for chanEgrSrvRate for an E3 card is 34368000, for a T3 card is 44736000m, and for HSSI it is 52000000. Note that for FRSM-2CT3 card, the peak value of permissible chanEgrSrvRate is 1536000. For FRSM12 Card: This object is used only for CAC and the range will be same as the range for cir object. The Maximum value is 44736000m. ')
chanOvrSubOvrRide = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chanOvrSubOvrRide.setStatus('mandatory')
if mibBuilder.loadTexts: chanOvrSubOvrRide.setDescription('This MIB variable allows one to add a new connection on a port even if it is over subscribed. For FRSM12 Card: Not Supported ')
chanFrConnType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("pvc", 1), ("svc", 2), ("spvc", 3), ("par", 4), ("pnni", 5), ("tag", 6))).clone('pvc')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chanFrConnType.setStatus('mandatory')
if mibBuilder.loadTexts: chanFrConnType.setDescription('channel connection type 1 for pvc 2 for svc 3 for spvc 4 par (only for trunk connection) 5 pnni (only for trunk connection) 6 tag (only for trunk connection) For FRSM12 Card: Not Supported ')
frCDRNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 34), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frCDRNumber.setStatus('mandatory')
if mibBuilder.loadTexts: frCDRNumber.setDescription('This is the key to correlate cell/frame counts, start/end record. For FRSM12 Card: Not Supported ')
frLocalVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 35), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frLocalVpi.setStatus('mandatory')
if mibBuilder.loadTexts: frLocalVpi.setDescription("This VPI together with the local VCI and NSAP represents the local end point in this connection, this object is read only, therefore it'll be assigned by SM to 0. ")
frLocalVci = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 36), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frLocalVci.setStatus('mandatory')
if mibBuilder.loadTexts: frLocalVci.setDescription("This VCI together with the local VPI and NSAP represents the local end point in this connection, this object is read only, therefore it'll be assigned by SM to be equal to DLCI. ")
frLocalNSAP = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 37), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frLocalNSAP.setStatus('mandatory')
if mibBuilder.loadTexts: frLocalNSAP.setDescription('This NSAP is 20 bytes binary, among these 20 bytes: 13 bytes as prefix, 2 bytes for Cisco ID, 1 byte rsvd, 3 bytes for logical interface: slot (1 byte) and port number (2 bytes), the last byte is for SEL For FRSM12 Card: This object will have the NSAP format as required by the PNNI controller ')
frRemoteVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 38), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frRemoteVpi.setStatus('mandatory')
if mibBuilder.loadTexts: frRemoteVpi.setDescription('This VPI together with the remote VCI and NSAP represents the remote end point in this connection ')
frRemoteVci = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 39), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frRemoteVci.setStatus('mandatory')
if mibBuilder.loadTexts: frRemoteVci.setDescription('This VCI together with the remote VPI and NSAP represents the remote end point in this connection ')
frRemoteNSAP = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 40), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frRemoteNSAP.setStatus('mandatory')
if mibBuilder.loadTexts: frRemoteNSAP.setDescription('This NSAP is 20 bytes binary, among these 20 bytes: 13 bytes as prefix, 2 bytes for Cisco ID, 1 byte rsvd, 3 bytes for logical interface: slot (1 byte) and port number (2 bytes), the last byte is for SEL')
frMastership = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 41), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("master", 1), ("slave", 2), ("unknown", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frMastership.setStatus('mandatory')
if mibBuilder.loadTexts: frMastership.setDescription(' This is used by PXM to determine if this end point is master or slave, a new type unknown is added to identify the SM in AXIS shelf and the SM in MGX shelf. In AXIS shelf, user can still use addchan to add a channel without specifying X/Y/P parameters. But in MGX shelf, if the user uses addchan without X/Y/P set (based on this object being set to type 3 unknown), SPM on PXM will reject the request. It must be supplied in connection setup request. In the feeder mode, this is always set to master. ')
frVpcFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 42), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("vpc", 1), ("vcc", 2))).clone('vcc')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frVpcFlag.setStatus('mandatory')
if mibBuilder.loadTexts: frVpcFlag.setDescription(" This represents the connection type, used for PXM to identify VPC/VCC but FRSM card doesn't use it always set to vcc for FRSM card For FRSM12 Card: This object is used by the PNNI controller and is always set to VCC ")
frConnServiceType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 43), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32))).clone(namedValues=NamedValues(("cbr", 1), ("vbr", 2), ("notUsed", 3), ("ubr", 4), ("atfr", 5), ("abrstd", 6), ("abrfst", 7), ("vbrrt", 8), ("cbr1", 21), ("vbr1rt", 22), ("vbr2rt", 23), ("vbr3rt", 24), ("vbr1nrt", 25), ("vbr2nrt", 26), ("vbr3nrt", 27), ("ubr1", 28), ("ubr2", 29), ("stdabr", 30), ("cbr2", 31), ("cbr3", 32))).clone('atfr')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frConnServiceType.setStatus('mandatory')
if mibBuilder.loadTexts: frConnServiceType.setDescription("This specifies the service type 1 ==> Constant Bit Rate 2 ==> Variable Bit Rate 3 ==> Not used 4 ==> Unspecified Bit Rate 5 ==> ATM frame relay 6 ==> standard ABR 7 ==> foresight ABR Note that this is used by PXM card, SV+ doesn't need to set it, if not set in the connection setup request, it'll be defaulted to ATFR type for FRSM. Also to make it compatible with existing AUSM MIB definition, value 3 is not used. The following types are being added for PNNI support. and are based on UNI 4.0 cbr1 (21) - CBR.1 vbr1rt (22) - Real time VBR.1 vbr2rt (23) - Real time VBR.2 vbr3rt (24) - Real time VBR.3 vbr1nrt(25) - Non Real time VBR.1 vbr2nrt(26) - Non Real time VBR.2 vbr3nrt(27) - Non Real time VBR.3 ubr1 (28) - UBR.1 ubr2 (29) - UBR.2 stdabr (30) - TM 4.0 compliant standard ABR cbr2 (31) - CBR.2 cbr3 (32) - CBR.3 For FRSM12 Card: Not Supported. Derived from chanServType. ")
frRoutingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 44), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frRoutingPriority.setStatus('mandatory')
if mibBuilder.loadTexts: frRoutingPriority.setDescription(' This is used by PXM to determine how important this connection is when selecting connections to route ')
frMaxCost = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 45), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frMaxCost.setStatus('mandatory')
if mibBuilder.loadTexts: frMaxCost.setDescription(" Maximum allowed cost. It is related to Cost Based Routing. This is used by PXM so that it won't choose a path with a cost greater than this configured level. This is not necessary to be provided in the connection setup request, if not provided, the default value 255 will be used. When used with PAR controller the valid range is 1..65535 and the default value is 255. When used with PNNI controller the valid range is 1..2147483647 and the default value is 2147483647. ")
frRestrictTrunkType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 46), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("norestriction", 1), ("terrestrialTrunk", 2), ("sateliteTrunk", 3))).clone('norestriction')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frRestrictTrunkType.setStatus('mandatory')
if mibBuilder.loadTexts: frRestrictTrunkType.setDescription(' Restricted trunk type for routing, used by PXM. It specifies that the connection either cannot be routed over satelite trunks, or terrestrial trunks, or it can be on any type of trunk. It is not necessary to be provide in the connection setup request, the default value is norestriction(1). For FRSM12 Card: Not Supported ')
frConnPCR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 47), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frConnPCR.setStatus('mandatory')
if mibBuilder.loadTexts: frConnPCR.setDescription(" Peak cell rate, if not provided in the connection setup request, it'll be derived from pir. For FRSM12 Card: Default value is (1.44 * CIR) ")
frConnRemotePCR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 48), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frConnRemotePCR.setStatus('mandatory')
if mibBuilder.loadTexts: frConnRemotePCR.setDescription(' Peak cell rate of the other end, if not set, will be set to the same as local end PCR (frConnPCR). However, note that if the CIRs for both local and remote end are set to the different value (i.e., asymmetric conn), then this should be set differently from local end PCR. For FRSM12 Card: Default value is frConnPCR ')
frConnMCR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 49), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frConnMCR.setStatus('mandatory')
if mibBuilder.loadTexts: frConnMCR.setDescription(" Minimum cell rate, if not provided in the connection setup request, it'll be derived from mir. For FRSM12 Card: Default value is frConnPCR ")
frConnRemoteMCR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 50), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frConnRemoteMCR.setStatus('mandatory')
if mibBuilder.loadTexts: frConnRemoteMCR.setDescription(' Minimum cell rate of the other end, if not set, will be set to the same as local end MCR (frConnMCR). However, note that if the CIRs for both local and remote end are set to the different value (i.e., asymmetric conn), then this should be set differently from local end MCR. For FRSM12 Card: Default value is frConnMCR ')
frConnPercentUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 51), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100)).clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frConnPercentUtil.setStatus('mandatory')
if mibBuilder.loadTexts: frConnPercentUtil.setDescription("This is the expected long-term utilization of the channel by this end-point. If this is not specified in the connection setup request, it'll be defaulted to 100 percent For FRSM12 Card: Not Supported ")
frConnRemotePercentUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 52), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frConnRemotePercentUtil.setStatus('mandatory')
if mibBuilder.loadTexts: frConnRemotePercentUtil.setDescription("This is the expected long-term utilization of the channel by the other end-point. If this is not specified in the connection setup request, it'll be set to be the same as the local end frConnPercentUtil value assuming that the connection is symmetric. In a asymmetric connection, this object is supposed to be set. For FRSM12 Card: Not Supported ")
frConnForeSightEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 53), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frConnForeSightEnable.setStatus('mandatory')
if mibBuilder.loadTexts: frConnForeSightEnable.setDescription(" This object is used by the controller(PAR/PNNI/TAG) to set up the Qbin for the connection, if this is not set, it'll be defaulted by SM to the same as foreSightEnable in the end point parameters. For FRSM12 Card: Not Supported ")
frConnFGCRAEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 54), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frConnFGCRAEnable.setStatus('mandatory')
if mibBuilder.loadTexts: frConnFGCRAEnable.setDescription('enables/disables Frame based GCRA (early packet discard). For FRSM12 Card: Not Supported ')
chanServType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 55), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("highpriority", 1), ("rtVBR", 2), ("nrtVBR", 3), ("aBR", 4), ("uBR", 5), ("queue6", 6), ("queue7", 7), ("queue8", 8), ("stdABR", 9)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chanServType.setStatus('mandatory')
if mibBuilder.loadTexts: chanServType.setDescription('This indicates the class of the connection 1-High priority (typically CBR connections) 2- real-time VBR 3- non-real time VBR 4- Available Bit Rate 5- Unspecified Bit Rate 9- Standard ABR There are 8 queues actually but only 4 are currently being used (the 4 queues are for CBR, VBR-rt, <VBR-nrt and ABR>, UBR traffic). This object is currently suuported only in FRSM-VHS and FRSM-8T1E1. For FRSM-8T1E1, a 0 indicates that the connections are of old model type where chanServType object is unused. Note that chanServType is not modifiable after a channel has been enabled For FRSM12 Card: The types aBR, queue6, queue7, queue8 are not supported ')
chanServiceRateOverride = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 56), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chanServiceRateOverride.setStatus('mandatory')
if mibBuilder.loadTexts: chanServiceRateOverride.setDescription('This variable sets the SAR IR programming option. Foresight and chanServiceRateOverride are mutually exclusive. For FRSM12 Card: Not Supported ')
chanServiceRate = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 57), Integer32().subtype(subtypeSpec=ValueRangeConstraint(160, 6400000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chanServiceRate.setStatus('mandatory')
if mibBuilder.loadTexts: chanServiceRate.setDescription('This is the rate to which IR can be set to when chanServiceRateOverride is set to enabled. If chanServiceRateOverride is disabled then this object does not have any significance. For FRSM-8P, this is defined in fastpackets/sec. For FRSM-VHS, this is defined in atm cells per second. For VHS the range in cells per second will be 10 to 400000 cps. For FRSM12 Card: Not Supported ')
zeroCirConEir = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 58), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 52000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: zeroCirConEir.setStatus('mandatory')
if mibBuilder.loadTexts: zeroCirConEir.setDescription("zeroCirConEir defines EIR value for '0' CIR connection. If zeroCirConEir is '0', EIR is set to port speed. If zeroCirConEir is non-zero value, EIR is set to value of this object, and this value is used for policing in ingress direction. This object is valid only for a zero cir connection. zeroCirConEir has to be less than or equal to the port speed.")
chanReroute = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 59), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2))).clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chanReroute.setStatus('mandatory')
if mibBuilder.loadTexts: chanReroute.setDescription(' This is used by the administrator to trigger the re-routing of the connection. The rerouting takes effect, when this object is set to true(1). When set to false (2), no action is taken. A get on this object always returns false (2). This object is not applicable to MGX Release 1.x. ')
frConnSCR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 60), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frConnSCR.setStatus('mandatory')
if mibBuilder.loadTexts: frConnSCR.setDescription(' Sustained cell rate, Used for VBR connections setup with PNNI controller. For FRSM12 Card: Default value is frConnPCR This object is not applicable to MGX Release 1.x ')
frConnRemoteSCR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 61), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frConnRemoteSCR.setStatus('mandatory')
if mibBuilder.loadTexts: frConnRemoteSCR.setDescription(' Sustained cell rate of the other end, Used for VBR connections setup with PNNI controller. For FRSM12 Card: Default value is frConnSCR This object is not applicable to MGX Release 1.x ')
frConnTemplateId = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 62), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 17)).clone(17)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frConnTemplateId.setStatus('mandatory')
if mibBuilder.loadTexts: frConnTemplateId.setDescription('This object specifies the template identifier for the connection template associated with this connection. The valid range for templates is 1..16. A value of 17 indicates no template is associated with this connection For FRSM12 Card: Not Supported This object is not applicable to MGX Release 1.x ')
frConnAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 63), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2))).clone('down')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frConnAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: frConnAdminStatus.setDescription('This object specifies channel admin status. This object is not applicable to MGX Release 1.x. ')
frChanCnfChangeCount = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 64), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frChanCnfChangeCount.setStatus('mandatory')
if mibBuilder.loadTexts: frChanCnfChangeCount.setDescription(' This object is added only for FRSM12 card. This counter tracks the number of configuration changes that happen on a channel. The counter is associated only with the end point and NOT with the connection itself. This counter is used by the NMS to determine if a connection configuration had been modified and requires an upload. This functionality is conventionally achieved by time stamping using a time-of-day clock. However, in switches where time-of-day clock is not available, the following scheme is used: The upload counter is incremented, when: * assignment of connection to an end point channel. This happens when a connection is added and assigned this channel number. * de-assignment of connection from a channel number. This happens when a connection is deleted and the end point resource is released. * When there is a configuration change done to the connection that is associated with this end point channel number. In a new system, an unutilised resouce (channel number) has a counter value of zero. When a connection is added to this channel end point, the counter is incremented. And is incremented for any of the above operations. When a connection is deleted the value of this counter is incremented and preserved till a new connection gets associated with this channel end point. This object is not applicable to MGX Release 1.x.')
frChanCnfIgnoreIncomingDE = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 65), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frChanCnfIgnoreIncomingDE.setStatus('mandatory')
if mibBuilder.loadTexts: frChanCnfIgnoreIncomingDE.setDescription(' This object is added for FRSM12 card. When this object is enabled, the incoming frames with DE(Discard Eligible) bit set to 1 are counted in the Bc bucket instead of Be bucket This object is not applicable to MGX Release 1.x. ')
frChanOamCCEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 66), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frChanOamCCEnable.setStatus('mandatory')
if mibBuilder.loadTexts: frChanOamCCEnable.setDescription(' This object is added for FRSM12 card. This object serves to enable or disable continuity check(CC) on a connection endpoint. When continuity check is enabled on an endpoint, the endpoint anticipates OAM CC cells from its peer endpoint. OAM CC cells are sent when the peer endpoint does not have traffic cells to send. If the connection is idle and this endpoint has not received OAM CC cells for a period of 3.5 +/- 0.5 seconds, it declares continuity failure. This object serves to administratively control the CC feature. Typical implementations (of this feature) may choose to ignore this control or impose other conditions to actually enable CC cell flow. However, if this object is set to false(2), then this feature should be disabled This object is not applicable to MGX Release 1.x. ')
frChanStatsEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 67), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frChanStatsEnable.setStatus('mandatory')
if mibBuilder.loadTexts: frChanStatsEnable.setDescription(' This object is added for FRSM12 card. Limits imposed by software or hardware implementations could restrict the amount of statistical data that can be maintained in a physical entity (like a service module card). Hence there could be a need to restrict statistics collection to a smaller subset. This object serves the purpose of enabling/disabling statistics collection on a per connection basis. In implementations which do not have such limitations, this object can be set to enable(1) for all connections This object is not applicable to MGX Release 1.x. ')
frChanLocalLpbkEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 68), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frChanLocalLpbkEnable.setStatus('mandatory')
if mibBuilder.loadTexts: frChanLocalLpbkEnable.setDescription(' This object is added for FRSM12 card. This object when enabled adds a channel-level loopback towards the port side. If the connection is in loopback, Connection MIB (FrChanCnfGrpEntry) variables cannot be modified. This object is not applicable to MGX Release 1.x. ')
frChanUpcEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 69), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frChanUpcEnable.setStatus('mandatory')
if mibBuilder.loadTexts: frChanUpcEnable.setDescription(' This object is added for FRSM12 card. This object when disabled, disables Frame Relay policing. This object is not applicable to MGX Release 1.x. ')
frChanSlaveType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 70), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("persistentSlave", 1), ("nonPersistentSlave", 2))).clone('persistentSlave')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frChanSlaveType.setStatus('mandatory')
if mibBuilder.loadTexts: frChanSlaveType.setDescription(" This object is added for FRSM12 card. This object indicates whether a master endpoint has a persistent slave or not. A connection with a master and a non-persistent slave is considered a single-ended SPVC. This object is only meaningful when 'frMastership' contains the value of 'master(1)'. And this variable must be used with 'frMastership' to decide if a connection is single-ended or not. This object is not applicable to MGX Release 1.x. ")
frConnRemoteMBS = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 1, 1, 71), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5000000)).clone(1024)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frConnRemoteMBS.setStatus('mandatory')
if mibBuilder.loadTexts: frConnRemoteMBS.setDescription("Remote Maximum Burst Size in terms of number of cells. This object should be set by the user in cases when the remote end of the connection is an ATM end-point where the Local MBS can be explicitly specified. In such cases, this element should be set to be equal to the remote end-point's local MBS. This object is not applicable to MGX Release 1.x. ")
chanNumNextAvailable = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 4015))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanNumNextAvailable.setStatus('mandatory')
if mibBuilder.loadTexts: chanNumNextAvailable.setDescription("This variable contains the next UNUSED channel number of the possible 4000 (ranging from 16 to 4015). This number can be used in channel config table, the ChanNumNextAvailable gets updated if the number gets used to create a logical channel. A '0' indicates that no more channels are available. For FRSM12 Card: Not Supported ")
frstdABRCnfGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 3), )
if mibBuilder.loadTexts: frstdABRCnfGrpTable.setStatus('mandatory')
if mibBuilder.loadTexts: frstdABRCnfGrpTable.setDescription('The ABR config table is for logical channel interface (upto 4000 entries). The actual number of entries supported by a card depends on the type of card. eg: FRSM-4T1/E1 supports 256 entries FRSM-8T1/E1 supports 1000 entries FRSM-T3/E3/HS2/T3B/E3B/HS2B-HSSI supports 2000 entries FRSM-2CT3/HS2B-12IN1 supports 4000 entries FRSM12 supports 16000 entries ')
frstdABRCnfGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 3, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "frstdABRcnfChanNum"))
if mibBuilder.loadTexts: frstdABRCnfGrpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: frstdABRCnfGrpEntry.setDescription(' An entry for logical channel ')
frstdABRcnfChanNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frstdABRcnfChanNum.setStatus('mandatory')
if mibBuilder.loadTexts: frstdABRcnfChanNum.setDescription('Refers to the virtual connection index Note that the actual range of the index supported by a card depends on the type of card. eg: FRSM-4T1/E1 supports a range from 16..271 (256 entries) FRSM-8T1/E1 supports a range from 16..1015 (1000 entries) FRSM-T3/E3/HS2/T3B/E3B/HS2B-HSSI supports a range from 16..2015 (2000 entries) FRSM-2CT3/HS2B-12IN1 supports a range from 16..4015 (4000 entries) For FRSM12 Card: Byte 3 = Chassis Number, Byte 2 = Slot Number, Byte 1 & 0 = channel Number. Lower two bytes range from 16..16015 (16000 entries) ')
frstdABRTBE = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215)).clone(16777215)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frstdABRTBE.setStatus('mandatory')
if mibBuilder.loadTexts: frstdABRTBE.setDescription('Transient Buffer Exposure. The unit is number of cells.')
frstdABRFRTT = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16700))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frstdABRFRTT.setStatus('mandatory')
if mibBuilder.loadTexts: frstdABRFRTT.setDescription('Fixed Round-Trip Time. The unit is milliseconds. Value 0 signifies that FRTT is not available.')
frstdABRRDF = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32768)).clone(16)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frstdABRRDF.setStatus('mandatory')
if mibBuilder.loadTexts: frstdABRRDF.setDescription('Rate Decrease Factor. This unitless value has to be inverted to arrive at the actual value. The valid values possible are only powers of 2; i.e. 1, 2, 4, 8 ..... 32768. The SNMP agent has to verify this compliance.')
frstdABRRIF = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32768)).clone(64)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frstdABRRIF.setStatus('mandatory')
if mibBuilder.loadTexts: frstdABRRIF.setDescription('Rate Increase Factor. This unitless value has to be inverted to arrive at the actual value. The valid values possible are only powers of 2; i.e. 1, 2, 4, 8 ..... 32768. The SNMP agent has to verify this compliance.')
frstdABRNrm = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 3, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 256)).clone(64)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frstdABRNrm.setStatus('mandatory')
if mibBuilder.loadTexts: frstdABRNrm.setDescription('Maximum number of cells a source may send for each forward RM cell. The valid values possible are only powers of 2 starting from 2; i.e. 2, 4, 8 ..... 256. The SNMP agent has to verify this compliance.')
frstdABRTrm = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 3, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(3, 255)).clone(255)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frstdABRTrm.setStatus('mandatory')
if mibBuilder.loadTexts: frstdABRTrm.setDescription('Upper bound on the time between forward RM cells for an active source. The unit is in milliseconds.')
frstdABRCDF = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 3, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 64)).clone(16)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frstdABRCDF.setStatus('mandatory')
if mibBuilder.loadTexts: frstdABRCDF.setDescription('Cutoff Decrease Factor. This unitless value has to be inverted to arrive at the actual value. The valid values possible are 0 and only powers of 2; i.e., 1, 2, 4, 8, 16, 32, 64. The SNMP agent has to verify this compliance.')
frstdABRADTF = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 3, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 10230)).clone(500)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frstdABRADTF.setStatus('mandatory')
if mibBuilder.loadTexts: frstdABRADTF.setDescription('ACR DecreaseTime Factor. Unit of this value is milliseconds. Granularity allowed is 10 milli seconds. The SNMP agent has to verify this compliance.')
frstdABRICR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 3, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 400000)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frstdABRICR.setStatus('mandatory')
if mibBuilder.loadTexts: frstdABRICR.setDescription(' Initial Cell Rate is the rate at which the source should send initially and after an idle period. This includes the bandwidth allocated for both data cells as well as all in-rate RM cells. Unit is cells/sec. The Range will be 10 to 400000. .')
frstdABRMCR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 3, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 400000)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frstdABRMCR.setStatus('mandatory')
if mibBuilder.loadTexts: frstdABRMCR.setDescription(' Minimum Cell Rate is the rate at which the source is allowed to send. This includes the bandwidth allocated for both data cells as well as all in-rate RM cells. Unit is cells/sec. The Range will be 10 to 400000. .')
frstdABRPCR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 1, 3, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 400000)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frstdABRPCR.setStatus('mandatory')
if mibBuilder.loadTexts: frstdABRPCR.setDescription(' Peak Cell Rate is the rate at which the source is allowed to send. This includes the bandwidth allocated for both data cells as well as all in-rate RM cells. Unit is cells/sec. The Range will be 10 to 400000. ')
frChanCntGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 3))
frChanCntGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 3, 1), )
if mibBuilder.loadTexts: frChanCntGrpTable.setStatus('mandatory')
if mibBuilder.loadTexts: frChanCntGrpTable.setDescription('The config table is for logical channel interface there are upto 4000 entries. ')
frChanCntGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 3, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "cntChanNum"))
if mibBuilder.loadTexts: frChanCntGrpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: frChanCntGrpEntry.setDescription(' An entry for logical channel ')
cntChanNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntChanNum.setStatus('mandatory')
if mibBuilder.loadTexts: cntChanNum.setDescription('Refers to the virtual connection index Note that the actual range of the index supported by a card depends on the type of card. eg: FRSM-4T1/E1 supports a range from 16..271 (256 entries) FRSM-8T1/E1 supports a range from 16..1015 (1000 entries) FRSM-T3/E3/HS2 supports a range from 16..2015 (2000 entries) FRSM-2CT3 supports a range from 16..4015 (4000 entries) FRSM12 supports a range from 16..16015 (16000 entries) For FRSM12 Card: Byte 3 = Chassis Number, Byte 2 = Slot Number, Byte 1 & 0 = channel Number ')
rcvFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 3, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvFrames.setStatus('mandatory')
if mibBuilder.loadTexts: rcvFrames.setDescription('The number of frames Received on the ingress ')
rcvBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 3, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvBytes.setStatus('mandatory')
if mibBuilder.loadTexts: rcvBytes.setDescription('The number of bytes Received on the ingress ')
rcvFramesDE = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 3, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvFramesDE.setStatus('mandatory')
if mibBuilder.loadTexts: rcvFramesDE.setDescription('The number of DE frames Received on the ingress ')
rcvBytesDE = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 3, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvBytesDE.setStatus('mandatory')
if mibBuilder.loadTexts: rcvBytesDE.setDescription('The number of DE bytes Received on the ingress ')
rcvFramesDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 3, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvFramesDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: rcvFramesDiscard.setDescription('The number of frames discarded on the ingress ')
rcvBytesDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 3, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvBytesDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: rcvBytesDiscard.setDescription('The number of bytes discarded on the ingress ')
rcvFramesDiscShelfAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 3, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvFramesDiscShelfAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: rcvFramesDiscShelfAlarm.setDescription('The number of frames discarded on the ingress due to shelf alarm For FRSM12 Card: Not Supported ')
rcvFramesDiscXceedQDepth = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 3, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvFramesDiscXceedQDepth.setStatus('mandatory')
if mibBuilder.loadTexts: rcvFramesDiscXceedQDepth.setDescription('The number of frames discarded on the ingress due to exceeded queue depth ')
rcvBytesDiscXceedQDepth = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 3, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvBytesDiscXceedQDepth.setStatus('mandatory')
if mibBuilder.loadTexts: rcvBytesDiscXceedQDepth.setDescription('The number of bytes discarded on the ingress due to exceeded queue depth ')
rcvFramesDiscXceedDEThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 3, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvFramesDiscXceedDEThresh.setStatus('mandatory')
if mibBuilder.loadTexts: rcvFramesDiscXceedDEThresh.setDescription('The number of frames discarded on the ingress due to exceeded DE Threshold ')
rcvFramesFECN = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 3, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvFramesFECN.setStatus('mandatory')
if mibBuilder.loadTexts: rcvFramesFECN.setDescription('The number of frames received with FECN bit already set ')
rcvFramesBECN = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 3, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvFramesBECN.setStatus('mandatory')
if mibBuilder.loadTexts: rcvFramesBECN.setDescription('The number of frames received with BECN bit already set ')
rcvFramesTaggedFECN = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 3, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvFramesTaggedFECN.setStatus('mandatory')
if mibBuilder.loadTexts: rcvFramesTaggedFECN.setDescription('The number of frames received that were tagged with FECN bit ')
rcvFramesTaggedBECN = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 3, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvFramesTaggedBECN.setStatus('mandatory')
if mibBuilder.loadTexts: rcvFramesTaggedBECN.setDescription('The number of frames received that were tagged with BECN bit ')
rcvFramesTaggedDE = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 3, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvFramesTaggedDE.setStatus('mandatory')
if mibBuilder.loadTexts: rcvFramesTaggedDE.setDescription('The number of frames received that were tagged with DE bit ')
rcvBytesTaggedDE = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 3, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvBytesTaggedDE.setStatus('mandatory')
if mibBuilder.loadTexts: rcvBytesTaggedDE.setDescription('The number of bytes received that were tagged with DE bit ')
rcvKbpsAIR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 3, 1, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvKbpsAIR.setStatus('mandatory')
if mibBuilder.loadTexts: rcvKbpsAIR.setDescription('Received Average Information Rate in KBPS ')
xmtFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 3, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtFrames.setStatus('mandatory')
if mibBuilder.loadTexts: xmtFrames.setDescription('The number of frames transmitted ')
xmtBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 3, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtBytes.setStatus('mandatory')
if mibBuilder.loadTexts: xmtBytes.setDescription('The number of bytes transmitted ')
xmtFramesFECN = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 3, 1, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtFramesFECN.setStatus('mandatory')
if mibBuilder.loadTexts: xmtFramesFECN.setDescription('The number of frames transmitted with FECN bit already set ')
xmtFramesBECN = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 3, 1, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtFramesBECN.setStatus('mandatory')
if mibBuilder.loadTexts: xmtFramesBECN.setDescription('The number of frames transmitted with BECN bit already set ')
xmtFramesDE = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 3, 1, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtFramesDE.setStatus('mandatory')
if mibBuilder.loadTexts: xmtFramesDE.setDescription('The number of DE frames transmitted ')
xmtBytesDE = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 3, 1, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtBytesDE.setStatus('mandatory')
if mibBuilder.loadTexts: xmtBytesDE.setDescription('The number of DE bytes transmitted ')
xmtFramesDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 3, 1, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtFramesDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: xmtFramesDiscard.setDescription('The number of frames discarded on the eggress ')
xmtBytesDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 3, 1, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtBytesDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: xmtBytesDiscard.setDescription('The number of bytes discarded on the egress For FRSM12 Card: Not Supported ')
xmtFramesDiscXceedQDepth = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 3, 1, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtFramesDiscXceedQDepth.setStatus('mandatory')
if mibBuilder.loadTexts: xmtFramesDiscXceedQDepth.setDescription('The number of frames discarded on the egress due to exceeded queue depth For FRSM12 Card: Not Supported ')
xmtBytesDiscXceedQDepth = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 3, 1, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtBytesDiscXceedQDepth.setStatus('mandatory')
if mibBuilder.loadTexts: xmtBytesDiscXceedQDepth.setDescription('The number of bytes discarded on the egress due to exceeded queue depth For FRSM12 Card: Not Supported ')
xmtFramesDiscXceedDEThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 3, 1, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtFramesDiscXceedDEThresh.setStatus('mandatory')
if mibBuilder.loadTexts: xmtFramesDiscXceedDEThresh.setDescription('The number of frames discarded on the egress due to exceeded DE Threshold For FRSM12 Card: Not Supported ')
xmtFramesDiscPhyLayerFail = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 3, 1, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtFramesDiscPhyLayerFail.setStatus('mandatory')
if mibBuilder.loadTexts: xmtFramesDiscPhyLayerFail.setDescription('The number of frames discarded on the egress due to physical layer failure ')
xmtFramesDiscCRCError = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 3, 1, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtFramesDiscCRCError.setStatus('mandatory')
if mibBuilder.loadTexts: xmtFramesDiscCRCError.setDescription('The number of frames discarded on the egress due to CRC Error ')
xmtFramesDiscReassmFail = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 3, 1, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtFramesDiscReassmFail.setStatus('mandatory')
if mibBuilder.loadTexts: xmtFramesDiscReassmFail.setDescription('The number of frames discarded on the egress due to reassembly failure For FRSM12 Card: Not Supported ')
xmtFramesDiscSrcAbort = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 3, 1, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtFramesDiscSrcAbort.setStatus('mandatory')
if mibBuilder.loadTexts: xmtFramesDiscSrcAbort.setDescription('The number of frames discarded on the egress due to source abort ')
xmtFramesDuringLMIAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 3, 1, 1, 34), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtFramesDuringLMIAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: xmtFramesDuringLMIAlarm.setDescription('The number of frames transmitted during LMI logical port alarm ')
xmtBytesDuringLMIAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 3, 1, 1, 35), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtBytesDuringLMIAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: xmtBytesDuringLMIAlarm.setDescription('The number of bytes transmitted during LMI logical port alarm ')
xmtFramesTaggedFECN = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 3, 1, 1, 36), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtFramesTaggedFECN.setStatus('mandatory')
if mibBuilder.loadTexts: xmtFramesTaggedFECN.setDescription('The number of frames transmitted that were tagged with FECN bit ')
xmtFramesTaggedBECN = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 3, 1, 1, 37), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtFramesTaggedBECN.setStatus('mandatory')
if mibBuilder.loadTexts: xmtFramesTaggedBECN.setDescription('The number of frames transmitted that were tagged with BECN bit ')
xmtKbpsAIR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 3, 1, 1, 38), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtKbpsAIR.setStatus('mandatory')
if mibBuilder.loadTexts: xmtKbpsAIR.setDescription('Transmitted Average Information Rate in KBPS ')
chanClrButton = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 3, 1, 1, 39), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noaction", 1), ("clear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chanClrButton.setStatus('mandatory')
if mibBuilder.loadTexts: chanClrButton.setDescription('Channel clear button. Clears Channel Counters. ')
xmtFramesTaggedDE = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 3, 1, 1, 40), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtFramesTaggedDE.setStatus('mandatory')
if mibBuilder.loadTexts: xmtFramesTaggedDE.setDescription('The number of frames transmitted which have been DE tagged at the far end ingress in excess of CIR ')
xmtBytesTaggedDE = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 3, 1, 1, 41), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtBytesTaggedDE.setStatus('mandatory')
if mibBuilder.loadTexts: xmtBytesTaggedDE.setDescription('The number of bytes transmitted which have been DE tagged at the far end ingress in excess of CIR ')
rcvFramesDiscUPC = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 3, 1, 1, 42), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvFramesDiscUPC.setStatus('mandatory')
if mibBuilder.loadTexts: rcvFramesDiscUPC.setDescription('The number of frames discarded at ingress due to the UPC measurement in excess of CIR+EIR ')
chanSecUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 3, 1, 1, 43), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanSecUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: chanSecUpTime.setDescription('The time in seconds the PVC stay in service ')
xmtFramesInvalidCPIs = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 3, 1, 1, 44), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtFramesInvalidCPIs.setStatus('mandatory')
if mibBuilder.loadTexts: xmtFramesInvalidCPIs.setDescription('Number of frames transmitted with invalid CPI header. currently valid is 0 ')
xmtFramesLengthViolations = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 3, 1, 1, 45), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtFramesLengthViolations.setStatus('mandatory')
if mibBuilder.loadTexts: xmtFramesLengthViolations.setDescription('The number of frames discarded due to violation of length in the egress direction. ')
xmtFramesOversizedSDUs = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 3, 1, 1, 46), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtFramesOversizedSDUs.setStatus('mandatory')
if mibBuilder.loadTexts: xmtFramesOversizedSDUs.setDescription('The number of frames discarded because the size is beyond the max in the egress direction ')
xmtFramesUnknownProtocols = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 3, 1, 1, 47), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtFramesUnknownProtocols.setStatus('mandatory')
if mibBuilder.loadTexts: xmtFramesUnknownProtocols.setDescription('The number of frames discarded for Unknown protocol in the egress direction. Used only in SIW for PDUs that are dropped. ')
rcvFramesUnknownProtocols = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 3, 1, 1, 48), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvFramesUnknownProtocols.setStatus('mandatory')
if mibBuilder.loadTexts: rcvFramesUnknownProtocols.setDescription('Number of frames discarded for Unknown protocol in the ingress direction. Used only in SIW for PDUs that are dropped ')
frChanStateGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 2))
frChanStateGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 2, 1), )
if mibBuilder.loadTexts: frChanStateGrpTable.setStatus('mandatory')
if mibBuilder.loadTexts: frChanStateGrpTable.setDescription('Table of transmit/receive states of channels. ')
frChanStateGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 2, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "stateChanNum"))
if mibBuilder.loadTexts: frChanStateGrpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: frChanStateGrpEntry.setDescription('An entry for FrChannelStateGrpEntry. ')
stateChanNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stateChanNum.setStatus('mandatory')
if mibBuilder.loadTexts: stateChanNum.setDescription('Refers to the virtual connection index Note that the actual range of the index supported by a card depends on the type of card. eg: FRSM-4T1/E1 supports a range from 16..271 (256 entries) FRSM-8T1/E1 supports a range from 16..1015 (1000 entries) FRSM-T3/E3/HS2 supports a range from 16..2015 (2000 entries) FRSM-2CT3 supports a range from 16..4015 (4000 entries) For FRSM12 Card: Byte 3 = Chassis Number, Byte 2 = Slot Number, Byte 1 & 0 = channel Number. Lower two bytes range from 16..16015 (16000 entries) ')
chanState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notConfigured", 1), ("okay", 2), ("alarm", 3), ("failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanState.setStatus('mandatory')
if mibBuilder.loadTexts: chanState.setDescription('This variable indicates the LMI state of the VC (channel) failed(4) is added to distinguish between alarm (when the connection in the PNNI n/w is not actually broken) and failed (when the connection in the PNNI n/w is actually broken). This is applicable only to the PNNI environment. ')
xmtAbitState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("sendingAequal1", 2), ("sendingAequal0", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtAbitState.setStatus('mandatory')
if mibBuilder.loadTexts: xmtAbitState.setDescription('The A bit transmit state 1 - LMI off 2 - LMI on and connection is O.K. 3 - LMI on and connection has failed ')
rcvAbitState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("rcvingAequal1", 2), ("rcvingAequal0", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvAbitState.setStatus('mandatory')
if mibBuilder.loadTexts: rcvAbitState.setDescription('The A bit receive state 1 - LMI off 2 - LMI on and connection is O.K. 3 - LMI on and connection has failed ')
xmtATMState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notSending", 1), ("sendingAIS", 2), ("sendingFERF", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtATMState.setStatus('mandatory')
if mibBuilder.loadTexts: xmtATMState.setDescription('This variable indicates the transmit state of the VC (channel) on the ATM side 1 - Not sending any state 2 - Sending AIS OAM state 3 - Sending FERF OAM state ')
rcvATMState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notRcving", 1), ("rcvingAIS", 2), ("rcvingFERF", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvATMState.setStatus('mandatory')
if mibBuilder.loadTexts: rcvATMState.setDescription('This variable indicates the receiving state of the VC (channel) on the ATM side 1 - Not receiving any state 2 - Receiving AIS OAM 3 - Receiving FERF OAM ')
chanStatusBitMap = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 2, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanStatusBitMap.setStatus('mandatory')
if mibBuilder.loadTexts: chanStatusBitMap.setDescription('This variable indicates the consolidated bit map of the channel alarm state. Individual bit positions are as defined below. Bit position Fail/Alarm Reason ------------ ---------- ------ 0 Alarm Reserved 1 Alarm n/w side AIS/RDI Rx 2 Fail Conditioned(A bit from n/w) 3 Alarm Reserved 4 Fail CC failed/RAS failed 5 Fail Mismatch 6 Alarm ingress A bit (LMI) 7 Alarm Reserved Fail bitmap mask : 0x34 Alarm bitmap mask: 0xCB This object is not applicable to MGX Release 1.x. ')
frEndPtMapGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 3))
frEndPtMapGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 3, 1), )
if mibBuilder.loadTexts: frEndPtMapGrpTable.setStatus('mandatory')
if mibBuilder.loadTexts: frEndPtMapGrpTable.setDescription('Table of transmit/receive states of channels. ')
frEndPtMapGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 3, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "endPortNum"), (0, "CISCO-WAN-AXIPOP-MIB", "endDLCI"))
if mibBuilder.loadTexts: frEndPtMapGrpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: frEndPtMapGrpEntry.setDescription('An entry for FrEndPtMapGrpEntry. ')
endPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: endPortNum.setStatus('mandatory')
if mibBuilder.loadTexts: endPortNum.setDescription("Refers to the logical port index For FRSM12 card: The ifIndex of the port's corresponding row in ifTable. Byte 3 = Chassis Number, Byte 2 = Slot Number, Byte 1 & 0 = Encoded unique number for Port. ")
endDLCI = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8388607))).setMaxAccess("readonly")
if mibBuilder.loadTexts: endDLCI.setStatus('mandatory')
if mibBuilder.loadTexts: endDLCI.setDescription('Refers to the DLCI index ')
endChanNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 3, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: endChanNum.setStatus('mandatory')
if mibBuilder.loadTexts: endChanNum.setDescription('Logical connection number 0 if port.dlci is a multicast group Note that the actual range of endChanNum supported by a card depends on the type of card. eg: FRSM-4T1/E1 supports a range from 16..271 (256 entries) FRSM-8T1/E1 supports a range from 16..1015 (1000 entries) FRSM-T3/E3/HS2 supports a range from 16..2015 (2000 entries) FRSM-2CT3 supports a range from 16..4015 (4000 entries) For FRSM12 Card: Byte 3 = Chassis Number, Byte 2 = Slot Number, Byte 1 & 0 = channel Number. Lower two bytes range from 16..16015 (16000 entries) ')
endLineNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 3, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: endLineNum.setStatus('mandatory')
if mibBuilder.loadTexts: endLineNum.setDescription('Refers to the physical line index. Note that the actual range of endLineNum supported by a card depends on the type of card. eg: FRSM-4T1/E1 supports a range from 1..4 (4 entries) FRSM-8T1/E1 supports a range from 1..8 (8 entries) FRSM-T3/E3/HS2 supports a range from 1..2 (2 entries) FRSM-2CT3 supports a range from 1..56 (56 entries) For FRSM12 Card: The ifIndex of the physical line on which this channel is provisioned. ')
frPortCnfPortGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1))
frPortCnfPortGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 1), )
if mibBuilder.loadTexts: frPortCnfPortGrpTable.setStatus('mandatory')
if mibBuilder.loadTexts: frPortCnfPortGrpTable.setDescription('The config table is for logical port interface. In FRSM-VHS, there are upto 256 entries for FRSM-2CT3 card and 2 entries for FRSM-T3/E3/HS2/T3B/E3B/HS2B-HSSI cards and 8 entries for FRSM-HS2B-12IN1 card. For other cards, there are upto 192 entries (for 8 DS1s) and upto 248 entries (for 8 E1s). For FRSM12 cards: There are upto 12 entries. When a new row is added to this table, the corresponding row is created in ifTable. ')
frPortCnfPortGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "portNum"))
if mibBuilder.loadTexts: frPortCnfPortGrpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: frPortCnfPortGrpEntry.setDescription(' An entry for logical port ')
portNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portNum.setStatus('mandatory')
if mibBuilder.loadTexts: portNum.setDescription("This is logical port number. If we have T1 card then the maximum port number is 192 and if we have E1 card the maximum port number can be 248. For FRSM-2CT3 card, the maximum port number is 256 and for unchannelized FRSM-VHS cards (FRSM-T3/E3/HS2/T3B/E3B/HS2B-HSSI), the maximum port number is 2 For FRSM-HS2B-12IN1 card, the maximum port number is 8 For FRSM12 card: The ifIndex of the port's corresponding row in ifTable. Byte 3 = Chassis Number, Byte 2 = Slot Number, Byte 1 & 0 = Encoded unique number for Port. ")
portLineNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 1, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portLineNum.setStatus('mandatory')
if mibBuilder.loadTexts: portLineNum.setDescription('This represents the line number For FRSM12 card: The ifIndex of the physical line on which this port is provisioned. ')
portRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("add", 1), ("del", 2), ("mod", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: portRowStatus.setDescription('This variable enables or modifies the port 1- add 2 - del 3 - mod For FRSM12 card: For Snmp GET operations, only mod is returned. ')
portDs0ConfigBitMap = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portDs0ConfigBitMap.setStatus('mandatory')
if mibBuilder.loadTexts: portDs0ConfigBitMap.setDescription("This respesents bit map of DS0s for a line which are used to form this logical port. Bit 0 represents DS0-1. This entry is not used for unchannelized FRSM-VHS/FRSM12 cards. For these cases, this field carries a value of 'ffffff'h always. ")
portDs0Speed = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("speed56k", 1), ("speed64k", 2), ("unUsed", 3))).clone('speed64k')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portDs0Speed.setStatus('mandatory')
if mibBuilder.loadTexts: portDs0Speed.setDescription("This represents port speed of 64 or 56 1 - speed56k 2 - speed64k 3 - unUsed. This field is not used for unchannelised FRSM-VHS (FRSM-2T3/ FRSM-2E3/FRSM-HS2/FRSM-T3B/FRSM-E3B/FRSM-HS2B) cards; in such cards, the portDs0Speed field carries a value of 'unUsed' always. For FRSM12 card: This is set to 3 - unUsed. ")
portFlagsBetweenFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portFlagsBetweenFrames.setStatus('mandatory')
if mibBuilder.loadTexts: portFlagsBetweenFrames.setDescription('Number of flags transmitted between FR frames For FRSM12 card: Only the values 1 to 8 are supported. The mapping is as follows: MIB object value No. of HDLC flags inserted 1 1 2 2 3 4 4 8 5 16 6 32 7 64 8 128 ')
portEqueueServiceRatio = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portEqueueServiceRatio.setStatus('mandatory')
if mibBuilder.loadTexts: portEqueueServiceRatio.setDescription('Number of times queue 1 is serviced for every time queue 2 is serviced. The value 0 is supported only by FRSM-VHS. FRSM-VHS supports two different egress queue servicing algorithms depending on the Egress Qos Feature. if EgrQosFeature is ENABLED, Weighted Fair queueing algorithm will be used to select one queue out of 4 data queues and this object will be set to a default value of 0 in this case and this value cannot be modified by user. In case of EgrQosFeature being DISABLED, this object will be set to a default value of 1 and can be configured to user desired value. This value will be used to decide number of times High priority queue has to be serviced for every time low priority queue is serviced. For FRSM12 card: There is only one scheme of egress scheduling of COS queues within ports, which uses only two COS queues for user data. The scheduling scheme uses a pre-defined ratio to schedule these COS queues on a given port. This object will be used to decide number of times High priority queue has to be serviced for every time low priority queue is serviced. ')
portSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: portSpeed.setDescription('Configured speed of port in kbps ')
portAdmin = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("write-Only", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portAdmin.setStatus('mandatory')
if mibBuilder.loadTexts: portAdmin.setDescription(' used to up and down the port For FRSM12 card: This variable will be equivalent to ifAdminStatus of of ifTable. The write-only is not used. ')
portType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("frame-relay", 1), ("frFUNI", 2), ("frame-forward", 3))).clone('frame-relay')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portType.setStatus('mandatory')
if mibBuilder.loadTexts: portType.setDescription('This represents port type For FRSM12 card: frFUNI not Applicable. For frame-relay the ifType is frameRelayService(44) and for frame-forward it is frForward(158). ')
portSvcStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portSvcStatus.setStatus('mandatory')
if mibBuilder.loadTexts: portSvcStatus.setDescription('This represents SVC status For FRSM12 card: Not Supported ')
portSvcInUse = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("not-use", 1), ("in-use", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portSvcInUse.setStatus('mandatory')
if mibBuilder.loadTexts: portSvcInUse.setDescription('This represents port svc in use For FRSM12 card: Not Supported ')
portSvcShareLcn = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("port-based", 1), ("card-based", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSvcShareLcn.setStatus('mandatory')
if mibBuilder.loadTexts: portSvcShareLcn.setDescription('This represents port type For FRSM12 card: Not Supported ')
portSvcLcnLow = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 4015))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSvcLcnLow.setStatus('mandatory')
if mibBuilder.loadTexts: portSvcLcnLow.setDescription('This represents low end of reserved LCN for svc For FRSM12 card: Not Supported ')
portSvcLcnHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 4015))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSvcLcnHigh.setStatus('mandatory')
if mibBuilder.loadTexts: portSvcLcnHigh.setDescription('This represents high end of reserved LCN for svc For FRSM12 card: Not Supported ')
portSvcDlciLow = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 1, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSvcDlciLow.setStatus('mandatory')
if mibBuilder.loadTexts: portSvcDlciLow.setDescription('This represents low end of reserved DLCI for svc For FRSM12 card: Not Supported ')
portSvcDlciHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 1, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSvcDlciHigh.setStatus('mandatory')
if mibBuilder.loadTexts: portSvcDlciHigh.setDescription('This represents high end of reserved DLCI for svc For FRSM12 card: Not Supported ')
portDeleteSvcs = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("delete", 1), ("other", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portDeleteSvcs.setStatus('mandatory')
if mibBuilder.loadTexts: portDeleteSvcs.setDescription('Setting this object to 1 indicates that all the SVC connections on the given port has to be deleted For FRSM12 card: Not Supported ')
portIngrSvcBandW = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 1, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portIngrSvcBandW.setStatus('mandatory')
if mibBuilder.loadTexts: portIngrSvcBandW.setDescription('This represents Ingress Bandwidth reserve for SVC For FRSM12 card: Not Supported ')
portEgrSvcBandW = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 1, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portEgrSvcBandW.setStatus('mandatory')
if mibBuilder.loadTexts: portEgrSvcBandW.setDescription('This represents Egress Bandwidth reserve for SVC For FRSM12 card: Not Supported ')
portBERTEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portBERTEnable.setStatus('mandatory')
if mibBuilder.loadTexts: portBERTEnable.setDescription('This variable enables BERT For FRSM12 card: Not Supported ')
portEnhancedSIW = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 1, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portEnhancedSIW.setStatus('mandatory')
if mibBuilder.loadTexts: portEnhancedSIW.setDescription('This variable enables/disables enhanced SIW feature. Enabling this permits support for SIW translation of Appletalk. This feature is currently supported only in the FRSM-VHS card. For FRSM12 card: Not Supported This object is not required in FRSM12 since Appletalk is supported by default in FRF.8.1 and FRSM12 supports FRF.8.1 ')
portM32EgrQueueThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 1, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 6000)).clone(6000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portM32EgrQueueThresh.setStatus('mandatory')
if mibBuilder.loadTexts: portM32EgrQueueThresh.setDescription('This represents the M32 logical port Egress Queue threshold in bytes. Frames will not be queued until the number of bytes in the queue is less than the threshold. The default value is 6000. Using a very low value could under utilize the logical port. This is supported in FRSM 8t1e1 and FRSM 4t1e1 Service Modules only. For FRSM12 card: Not Supported ')
portHeaderLen = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 1, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("twoOctets", 1), ("fourOctets", 2))).clone('twoOctets')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portHeaderLen.setStatus('mandatory')
if mibBuilder.loadTexts: portHeaderLen.setDescription(' This object is added for FRSM12. The value of this object identifies the Q.922 Address field length and DLCI length for this UNI/NNI logical port. This object is not applicable to MGX Release 1.x. ')
portFrameChkSumType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 1, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("crc16", 1), ("crc32", 2))).clone('crc16')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portFrameChkSumType.setStatus('mandatory')
if mibBuilder.loadTexts: portFrameChkSumType.setDescription(' This object is added for FRSM12. The value of this object identifies the CRC Length in the HDLC Packet. Applicable for FrameForwarding ports only. This object is not applicable to MGX Release 1.x. ')
portFileId = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 1, 1, 26), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portFileId.setStatus('mandatory')
if mibBuilder.loadTexts: portFileId.setDescription('The ID of the SCT file that holds module specific configuration parameters for this FR virtual interface. This object is not applicable to MGX Release 1.x.')
portOverSubEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 1, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portOverSubEnable.setStatus('mandatory')
if mibBuilder.loadTexts: portOverSubEnable.setDescription(' This object is added for FRSM12. When this object is enabled the port will be allowed to be over subscribed. This object is not applicable to MGX Release 1.x. ')
portsUsedLine1 = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portsUsedLine1.setStatus('mandatory')
if mibBuilder.loadTexts: portsUsedLine1.setDescription('Each bits set represents a DS0 that is used by all the logical ports defined so far for that DS1, the most significant byte is invalid for DS1 This is for line 1 ')
portsUsedLine2 = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portsUsedLine2.setStatus('mandatory')
if mibBuilder.loadTexts: portsUsedLine2.setDescription('Each bits set represents a DS0 that is used by all the logical ports defined so far for that DS1, the most significant byte is invalid for DS1 This is for line 2 ')
portsUsedLine3 = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portsUsedLine3.setStatus('mandatory')
if mibBuilder.loadTexts: portsUsedLine3.setDescription('Each bits set represents a DS0 that is used by all the logical ports defined so far for that DS1, the most significant byte is invalid for DS1 This is for line 3 ')
portsUsedLine4 = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portsUsedLine4.setStatus('mandatory')
if mibBuilder.loadTexts: portsUsedLine4.setDescription('Each bits set represents a DS0 that is used by all the logical ports defined so far for that DS1, the most significant byte is invalid for DS1 This is for line 4 ')
portsUsedLine5 = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portsUsedLine5.setStatus('mandatory')
if mibBuilder.loadTexts: portsUsedLine5.setDescription('Each bits set represents a DS0 that is used by all the logical ports defined so far for that DS1, the most significant byte is invalid for DS1 This is for line 5 ')
portsUsedLine6 = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portsUsedLine6.setStatus('mandatory')
if mibBuilder.loadTexts: portsUsedLine6.setDescription('Each bits set represents a DS0 that is used by all the logical ports defined so far for that DS1, the most significant byte is invalid for DS1 This is for line 6 ')
portsUsedLine7 = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portsUsedLine7.setStatus('mandatory')
if mibBuilder.loadTexts: portsUsedLine7.setDescription('Each bits set represents a DS0 that is used by all the logical ports defined so far for that DS1, the most significant byte is invalid for DS1 This is for line 7 ')
portsUsedLine8 = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portsUsedLine8.setStatus('mandatory')
if mibBuilder.loadTexts: portsUsedLine8.setDescription('Each bits set represents a DS0 that is used by all the logical ports defined so far for that DS1, the most significant byte is invalid for DS1 This is for line 8 ')
portNextAvailable = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portNextAvailable.setStatus('mandatory')
if mibBuilder.loadTexts: portNextAvailable.setDescription("This variable contains the next UNUSED logical port number. This number can be used in channel config table, the portNextAvailable gets updated if the number gets used to create a logical port. A '0' indicates that no more ports are available. For FRSM12 Card: Not Supported ")
frPortsUsedLineGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 11), )
if mibBuilder.loadTexts: frPortsUsedLineGrpTable.setStatus('mandatory')
if mibBuilder.loadTexts: frPortsUsedLineGrpTable.setDescription('Contains a sequence of entries for each DS1 line. each entry gives the number of DS0 slots being used added for FRSM_VHS')
frPortsUsedLineGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 11, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "frPortsUsedLineIndex"))
if mibBuilder.loadTexts: frPortsUsedLineGrpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: frPortsUsedLineGrpEntry.setDescription('One entry per DS1')
frPortsUsedLineIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 11, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 56))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frPortsUsedLineIndex.setStatus('mandatory')
if mibBuilder.loadTexts: frPortsUsedLineIndex.setDescription('This is the Index to the table containing the portsUsedLine for the 56 DS1s')
frPortsUsedLine = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 1, 11, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frPortsUsedLine.setStatus('mandatory')
if mibBuilder.loadTexts: frPortsUsedLine.setDescription('Each bits set represents a DS0 that is used by all the logical ports defined so far for that DS1, the most significant byte is invalid for DS1 ')
frPortCnfSigCLLMGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 2, 2))
frPortCnfSigCLLMGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 2, 2, 1), )
if mibBuilder.loadTexts: frPortCnfSigCLLMGrpTable.setStatus('mandatory')
if mibBuilder.loadTexts: frPortCnfSigCLLMGrpTable.setDescription('The config table is for logical port interface ')
frPortCnfSigCLLMGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 2, 2, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "cllmCnfPortNum"))
if mibBuilder.loadTexts: frPortCnfSigCLLMGrpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: frPortCnfSigCLLMGrpEntry.setDescription(' An entry for logical port ')
cllmCnfPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 2, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cllmCnfPortNum.setStatus('mandatory')
if mibBuilder.loadTexts: cllmCnfPortNum.setDescription("Refers to the logical port index For FRSM12 card: The ifIndex of the port's corresponding row in ifTable. Byte 3 = Chassis Number, Byte 2 = Slot Number, Byte 1 & 0 = Encoded unique number for Port. ")
cllmEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 2, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cllmEnable.setStatus('mandatory')
if mibBuilder.loadTexts: cllmEnable.setDescription('This will enable CLLM 1 - disabled 2 - enabled CLLM is not applicable for frame forwarding ports ')
xmtCLLMStatusTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 2, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(40, 5000)).clone(40)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xmtCLLMStatusTimer.setStatus('mandatory')
if mibBuilder.loadTexts: xmtCLLMStatusTimer.setDescription('Interval in milliseconds for CLLM to send CLLM updates CLLM parameters are not applicable for frame forwarding ports ')
rcvCLLMStatusTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 2, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1000))).clone(namedValues=NamedValues(("rcvCLLMTimerValue", 1000))).clone('rcvCLLMTimerValue')).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvCLLMStatusTimer.setStatus('mandatory')
if mibBuilder.loadTexts: rcvCLLMStatusTimer.setDescription('Timeout value for receiving CLLM updates CLLM parameters are not applicable for frame forwarding ports ')
frPortCnfSigLMIGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 2, 1))
frPortCnfSigLMIGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 2, 1, 1), )
if mibBuilder.loadTexts: frPortCnfSigLMIGrpTable.setStatus('mandatory')
if mibBuilder.loadTexts: frPortCnfSigLMIGrpTable.setDescription('The config table is for logical port interface there are upto 248 entries (8 E1s) and 192 entries (8 T1s). In FRSM-VHS, there are a total of 256 entries. In FRSM12, there are 12 entries. ')
frPortCnfSigLMIGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 2, 1, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "lmiCnfPortNum"))
if mibBuilder.loadTexts: frPortCnfSigLMIGrpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: frPortCnfSigLMIGrpEntry.setDescription(' An entry for logical port ')
lmiCnfPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 2, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lmiCnfPortNum.setStatus('mandatory')
if mibBuilder.loadTexts: lmiCnfPortNum.setDescription("Refers to the logical port index For FRSM12 card: The ifIndex of the port's corresponding row in ifTable. Byte 3 = Chassis Number, Byte 2 = Slot Number, Byte 1 & 0 = Encoded unique number for Port. ")
signallingProtocolType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 2, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("other", 1), ("noSignalling", 2), ("strataLMI", 3), ("annexAUNI", 4), ("annexDUNI", 5), ("annexANNI", 6), ("annexDNNI", 7))).clone('noSignalling')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: signallingProtocolType.setStatus('mandatory')
if mibBuilder.loadTexts: signallingProtocolType.setDescription('This will set the signalling protocol 1 - other 2 - noSignalling 3 - strataLMI 4 - annexAUNI 5 - annexDUNI 6 - annexANNI 7 - annexDNNI Only noSignalling is applicable to frame forwarding ports For FRSM12: strataLMI is not supported for portHeaderLen of fourOctets. ')
asynchronousUpdates = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 2, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2), ("fsenable", 3), ("updfsenable", 4))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: asynchronousUpdates.setStatus('mandatory')
if mibBuilder.loadTexts: asynchronousUpdates.setDescription('disable - disable Asynchronous Status Updates & Unsolicited Full Status enable - enable Asynchronous Status Updates fsenable - enable Unsolicited Full Status updfsenable - enable Asynchronous Status Updates & Unsolicited Full Status The signalling parameters are not applicable for the frame forwarding port. ')
t391LinkIntegrityTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 2, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 30)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: t391LinkIntegrityTimer.setStatus('mandatory')
if mibBuilder.loadTexts: t391LinkIntegrityTimer.setDescription('Interval in seconds for NNI to do status polling The signalling parameters are not applicable for the frame forwarding port. ')
t392PollingVerificationTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 2, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 30)).clone(15)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: t392PollingVerificationTimer.setStatus('mandatory')
if mibBuilder.loadTexts: t392PollingVerificationTimer.setDescription('Interval in seconds for UNI to expect status polling The signalling parameters are not applicable for the frame forwarding port. ')
n391FullStatusPollingCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 2, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: n391FullStatusPollingCounter.setStatus('mandatory')
if mibBuilder.loadTexts: n391FullStatusPollingCounter.setDescription('Number of UNI/NNI Polling cycles The signalling parameters are not applicable for the frame forwarding port. ')
n392ErrorThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 2, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: n392ErrorThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: n392ErrorThreshold.setDescription('UNI/NNI Error Threshold The signalling parameters are not applicable for the frame forwarding port. ')
n393MonitoredEventCount = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 2, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: n393MonitoredEventCount.setStatus('mandatory')
if mibBuilder.loadTexts: n393MonitoredEventCount.setDescription('UNI/NNI Events, always greater than n392 The signalling parameters are not applicable for the frame forwarding port. ')
enhancedLmi = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 2, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: enhancedLmi.setStatus('mandatory')
if mibBuilder.loadTexts: enhancedLmi.setDescription('This object defines if enhanced LMI is enabled on a logical port. The signalling parameters are not applicable for the frame forwarding port. ')
portFRF1Dot2Support = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 2, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portFRF1Dot2Support.setStatus('mandatory')
if mibBuilder.loadTexts: portFRF1Dot2Support.setDescription(' This object is added for FRSM12. This variable enables/disables FRF 1.2 feature. This object is not applicable to MGX Release 1.x ')
frPortCntPortGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1))
frPortCntPortGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1), )
if mibBuilder.loadTexts: frPortCntPortGrpTable.setStatus('mandatory')
if mibBuilder.loadTexts: frPortCntPortGrpTable.setDescription('The config table is for logical port interface there are upto 248 entries (for 8 E1s) or 192 (for 8 T1s). In FRSM-VHS, there is support for upto 256 entries. ')
frPortCntPortGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "cntPortNum"))
if mibBuilder.loadTexts: frPortCntPortGrpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: frPortCntPortGrpEntry.setDescription(' An entry for logical port ')
cntPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntPortNum.setStatus('mandatory')
if mibBuilder.loadTexts: cntPortNum.setDescription("Refers to the logical port index For FRSM12 card: The ifIndex of the port's corresponding row in ifTable. Byte 3 = Chassis Number, Byte 2 = Slot Number, Byte 1 & 0 = Encoded unique number for Port. ")
rcvPortFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvPortFrames.setStatus('mandatory')
if mibBuilder.loadTexts: rcvPortFrames.setDescription('The number of frames Received on the ingress ')
rcvPortBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvPortBytes.setStatus('mandatory')
if mibBuilder.loadTexts: rcvPortBytes.setDescription('The number of bytes Received on the ingress ')
rcvPortFramesDE = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvPortFramesDE.setStatus('mandatory')
if mibBuilder.loadTexts: rcvPortFramesDE.setDescription('The number of frames with DE bit set Received on the ingress ')
rcvPortFramesFECN = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvPortFramesFECN.setStatus('mandatory')
if mibBuilder.loadTexts: rcvPortFramesFECN.setDescription('The number of frames with FECN bit set Received on the ingress ')
rcvPortFramesBECN = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvPortFramesBECN.setStatus('mandatory')
if mibBuilder.loadTexts: rcvPortFramesBECN.setDescription('The number of frames with BECN bit set Received on the ingress ')
rcvFramesDiscCRCError = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvFramesDiscCRCError.setStatus('mandatory')
if mibBuilder.loadTexts: rcvFramesDiscCRCError.setDescription('The number of frames discarded on the ingress due to CRC error ')
rcvFramesDiscAlignmentError = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvFramesDiscAlignmentError.setStatus('mandatory')
if mibBuilder.loadTexts: rcvFramesDiscAlignmentError.setDescription('The number of frames discarded on the ingress due to Alignment error ')
rcvFramesDiscIllegalLen = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvFramesDiscIllegalLen.setStatus('mandatory')
if mibBuilder.loadTexts: rcvFramesDiscIllegalLen.setDescription('The number of frames discarded on the ingress due to illegal length ')
rcvFramesDiscIllegalHeader = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvFramesDiscIllegalHeader.setStatus('mandatory')
if mibBuilder.loadTexts: rcvFramesDiscIllegalHeader.setDescription('The number of frames discarded on the ingress due to illegal header ')
rcvFramesAbort = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvFramesAbort.setStatus('mandatory')
if mibBuilder.loadTexts: rcvFramesAbort.setDescription('The number of received frames aborted ')
rcvFramesUnknownDLCI = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvFramesUnknownDLCI.setStatus('mandatory')
if mibBuilder.loadTexts: rcvFramesUnknownDLCI.setDescription('The number of frames received with an unknown DLCI ')
rcvLastUnknownDLCI = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvLastUnknownDLCI.setStatus('mandatory')
if mibBuilder.loadTexts: rcvLastUnknownDLCI.setDescription('The last unknown DLCI received ')
rcvPortFramesTaggedFECN = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvPortFramesTaggedFECN.setStatus('mandatory')
if mibBuilder.loadTexts: rcvPortFramesTaggedFECN.setDescription('The number of frames received that were tagged with FECN bit ')
rcvPortFramesTaggedBECN = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvPortFramesTaggedBECN.setStatus('mandatory')
if mibBuilder.loadTexts: rcvPortFramesTaggedBECN.setDescription('The number of frames received that were tagged with BECN bit ')
rcvPortFramesTaggedDE = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvPortFramesTaggedDE.setStatus('mandatory')
if mibBuilder.loadTexts: rcvPortFramesTaggedDE.setDescription('The number of frames received that were tagged with DE bit ')
rcvPortFramesDiscXceedDEThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvPortFramesDiscXceedDEThresh.setStatus('mandatory')
if mibBuilder.loadTexts: rcvPortFramesDiscXceedDEThresh.setDescription('The number of frames discarded on the ingress due to exceeded DE Threshold ')
rcvPortKbpsAIR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvPortKbpsAIR.setStatus('mandatory')
if mibBuilder.loadTexts: rcvPortKbpsAIR.setDescription('Received Average Information Rate in KBPS ')
rcvBufNotAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvBufNotAvailable.setStatus('mandatory')
if mibBuilder.loadTexts: rcvBufNotAvailable.setDescription('The number of times the receiver is turned off ')
xmtPortFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtPortFrames.setStatus('mandatory')
if mibBuilder.loadTexts: xmtPortFrames.setDescription('The number of frames transmitted ')
xmtPortBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtPortBytes.setStatus('mandatory')
if mibBuilder.loadTexts: xmtPortBytes.setDescription('The number of bytes transmitted ')
xmtPortFramesFECN = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtPortFramesFECN.setStatus('mandatory')
if mibBuilder.loadTexts: xmtPortFramesFECN.setDescription('The number of frames transmittedc with FECN bit already set ')
xmtPortFramesBECN = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtPortFramesBECN.setStatus('mandatory')
if mibBuilder.loadTexts: xmtPortFramesBECN.setDescription('The number of frames transmitted with BECN bit already set ')
xmtPortFramesDiscXceedQDepth = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtPortFramesDiscXceedQDepth.setStatus('mandatory')
if mibBuilder.loadTexts: xmtPortFramesDiscXceedQDepth.setDescription('The number of frames discarded on the egress due to exceeded queue depth For FRSM12 Card: Not Supported ')
xmtPortBytesDiscXceedQDepth = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtPortBytesDiscXceedQDepth.setStatus('mandatory')
if mibBuilder.loadTexts: xmtPortBytesDiscXceedQDepth.setDescription('The number of bytes discarded on the egress due to exceeded queue depth For FRSM12 Card: Not Supported ')
xmtPortFramesDuringLMIAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtPortFramesDuringLMIAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: xmtPortFramesDuringLMIAlarm.setDescription('The number of frames transmitted during LMI logical port alarm ')
xmtPortBytesDuringLMIAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtPortBytesDuringLMIAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: xmtPortBytesDuringLMIAlarm.setDescription('The number of bytes transmitted during LMI logical port alarm ')
xmtFramesAbort = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtFramesAbort.setStatus('mandatory')
if mibBuilder.loadTexts: xmtFramesAbort.setDescription('The number of transmit frames aborted For FRSM12 Card: Not Supported ')
xmtFramesUnderrun = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtFramesUnderrun.setStatus('mandatory')
if mibBuilder.loadTexts: xmtFramesUnderrun.setDescription('The number of frames discarded due to underrun ')
xmtPortKbpsAIR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 30), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtPortKbpsAIR.setStatus('mandatory')
if mibBuilder.loadTexts: xmtPortKbpsAIR.setDescription('Transmit Average Information Rate in KBPS ')
xmtBufNotAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtBufNotAvailable.setStatus('mandatory')
if mibBuilder.loadTexts: xmtBufNotAvailable.setDescription('The number of times the transmitter is turned off For FRSM12 Card: Not Supported ')
portClrButton = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noaction", 1), ("clear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portClrButton.setStatus('mandatory')
if mibBuilder.loadTexts: portClrButton.setDescription('Port clear button. Resets all counters. ')
rcvFramesDiscNoChan = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvFramesDiscNoChan.setStatus('mandatory')
if mibBuilder.loadTexts: rcvFramesDiscNoChan.setDescription('The number of frames received when no channel is setup ')
rcvFramesDiscOverrun = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 1, 1, 1, 34), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvFramesDiscOverrun.setStatus('mandatory')
if mibBuilder.loadTexts: rcvFramesDiscOverrun.setDescription(' The number of frames discarded in Ingress direction due to FIFO overrun in HDLC Controller. This object is not applicable to MGX Release 1.x ')
frPortCntSigCLLMGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 2, 2))
frPortCntSigCLLMGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 2, 2, 1), )
if mibBuilder.loadTexts: frPortCntSigCLLMGrpTable.setStatus('mandatory')
if mibBuilder.loadTexts: frPortCntSigCLLMGrpTable.setDescription('The CLLM counter table is for logical port interface ')
frPortCntSigCLLMGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 2, 2, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "cllmSigPortNum"))
if mibBuilder.loadTexts: frPortCntSigCLLMGrpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: frPortCntSigCLLMGrpEntry.setDescription(' An entry for logical port ')
cllmSigPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 2, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cllmSigPortNum.setStatus('mandatory')
if mibBuilder.loadTexts: cllmSigPortNum.setDescription("Refers to the logical port index For FRSM12 card: The ifIndex of the port's corresponding row in ifTable. Byte 3 = Chassis Number, Byte 2 = Slot Number, Byte 1 & 0 = Encoded unique number for Port. ")
rcvFramesCLLM = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 2, 2, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvFramesCLLM.setStatus('mandatory')
if mibBuilder.loadTexts: rcvFramesCLLM.setDescription('The number of CLLM frames received ')
rcvBytesCLLM = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 2, 2, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvBytesCLLM.setStatus('mandatory')
if mibBuilder.loadTexts: rcvBytesCLLM.setDescription('The number of CLLM bytes received ')
xmtFramesCLLM = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 2, 2, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtFramesCLLM.setStatus('mandatory')
if mibBuilder.loadTexts: xmtFramesCLLM.setDescription('The number of CLLM frames transmitted ')
xmtBytesCLLM = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 2, 2, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtBytesCLLM.setStatus('mandatory')
if mibBuilder.loadTexts: xmtBytesCLLM.setDescription('The number of CLLM bytes transmitted ')
cllmFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 2, 2, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cllmFailures.setStatus('mandatory')
if mibBuilder.loadTexts: cllmFailures.setDescription('The number of times an expected CLLM message was not received ')
frPortCntSigLMIGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 2, 1))
frPortCntSigLMIGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 2, 1, 1), )
if mibBuilder.loadTexts: frPortCntSigLMIGrpTable.setStatus('mandatory')
if mibBuilder.loadTexts: frPortCntSigLMIGrpTable.setDescription('The LMI counter table is for logical port interface there are upto 248 entries (for 8 E1s) and upto 192 entries (for 8 T1s). In FRSM-VHS, there are upto 256 entries. ')
frPortCntSigLMIGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 2, 1, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "lmiSigPortNum"))
if mibBuilder.loadTexts: frPortCntSigLMIGrpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: frPortCntSigLMIGrpEntry.setDescription(' An entry for logical port ')
lmiSigPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 2, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lmiSigPortNum.setStatus('mandatory')
if mibBuilder.loadTexts: lmiSigPortNum.setDescription("Refers to the logical port index For FRSM12 card: The ifIndex of the port's corresponding row in ifTable. Byte 3 = Chassis Number, Byte 2 = Slot Number, Byte 1 & 0 = Encoded unique number for Port. ")
rcvStatusInquiry = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 2, 1, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvStatusInquiry.setStatus('mandatory')
if mibBuilder.loadTexts: rcvStatusInquiry.setDescription('The number of Status Inquiry messages received ')
rcvInvalidRequest = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 2, 1, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvInvalidRequest.setStatus('mandatory')
if mibBuilder.loadTexts: rcvInvalidRequest.setDescription('The number of Invalid Request messages received ')
rcvUNISeqMismatch = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 2, 1, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvUNISeqMismatch.setStatus('mandatory')
if mibBuilder.loadTexts: rcvUNISeqMismatch.setDescription('The number of times UNI messages with sequence number mismatches were received ')
xmtStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 2, 1, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtStatus.setStatus('mandatory')
if mibBuilder.loadTexts: xmtStatus.setDescription('The number of times Status response messages transmitted ')
xmtAsynchUpdate = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 2, 1, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtAsynchUpdate.setStatus('mandatory')
if mibBuilder.loadTexts: xmtAsynchUpdate.setDescription('The number of times Asynch Status messages transmitted ')
uniSignalingTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 2, 1, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: uniSignalingTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: uniSignalingTimeout.setDescription('The number of times UNI Status requests were not received ')
xmtStatusInquiry = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 2, 1, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtStatusInquiry.setStatus('mandatory')
if mibBuilder.loadTexts: xmtStatusInquiry.setDescription('The number of Status Inquiry messages transmitted ')
rcvStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 2, 1, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rcvStatus.setDescription('The number of times Status response messages received ')
rcvAsynchUpdate = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 2, 1, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvAsynchUpdate.setStatus('mandatory')
if mibBuilder.loadTexts: rcvAsynchUpdate.setDescription('The number of times Asynch Status messages received ')
rcvNNISeqMismatch = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 2, 1, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvNNISeqMismatch.setStatus('mandatory')
if mibBuilder.loadTexts: rcvNNISeqMismatch.setDescription('The number of times NNI messages with sequence number mismatches were received ')
nniSignalingTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 2, 2, 1, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nniSignalingTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: nniSignalingTimeout.setDescription('The number of times NNI Status requests were not received ')
frPortStateGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 3))
frPortStateGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 3, 1), )
if mibBuilder.loadTexts: frPortStateGrpTable.setStatus('mandatory')
if mibBuilder.loadTexts: frPortStateGrpTable.setDescription('Table of transmit/receive states of ports. ')
frPortStateGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 3, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "statePortNum"))
if mibBuilder.loadTexts: frPortStateGrpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: frPortStateGrpEntry.setDescription('An entry for logical port. ')
statePortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statePortNum.setStatus('mandatory')
if mibBuilder.loadTexts: statePortNum.setDescription("Refers to the logical port index For FRSM12 card: The ifIndex of the port's corresponding row in ifTable. Byte 3 = Chassis Number, Byte 2 = Slot Number, Byte 1 & 0 = Encoded unique number for Port. ")
portState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("notConfigured", 1), ("active", 2), ("remoteLoopback", 3), ("failedDueToLine", 4), ("failedDueToSignalling", 5), ("inactive", 6), ("inBert", 7), ("farEndRemoteLoopback", 8), ("latchDS0DropFeLoop", 9), ("latchDS0LineFeLoop", 10), ("latchOcuFeLoop", 11), ("latchCsuFeLoop", 12), ("latchDsuFeLoop", 13), ("latchHL96FeLoop", 14), ("v54PolynomialFeLoop", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portState.setStatus('mandatory')
if mibBuilder.loadTexts: portState.setDescription('This variable indicates the state of the logical port ')
portSignallingState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSignallingState.setStatus('mandatory')
if mibBuilder.loadTexts: portSignallingState.setDescription('Bit 0 = 0 -> LMI O.K. or not enabled Bit 0 = 1 -> LMI failed Bit 1 = 0 -> CLLM O.K. or not enabled Bit 1 = 1 -> CLLM failed ')
portOversubscribed = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portOversubscribed.setStatus('mandatory')
if mibBuilder.loadTexts: portOversubscribed.setDescription('This variable indicates the whether the port is over subscribed or not ')
portIngrPercentUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portIngrPercentUtil.setStatus('mandatory')
if mibBuilder.loadTexts: portIngrPercentUtil.setDescription('Percentage Utilization of the Port in the Ingress direction. ')
portEgrPercentUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portEgrPercentUtil.setStatus('mandatory')
if mibBuilder.loadTexts: portEgrPercentUtil.setDescription('Percentage Utilization of the Port in the Egress direction. ')
frPortCnfResPartGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 5, 1), )
if mibBuilder.loadTexts: frPortCnfResPartGrpTable.setStatus('mandatory')
if mibBuilder.loadTexts: frPortCnfResPartGrpTable.setDescription('This table contains the configuration of port resource partition ')
frPortCnfResPartGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 5, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "frResPartPortNum"), (0, "CISCO-WAN-AXIPOP-MIB", "frResPartCtrlrNum"))
if mibBuilder.loadTexts: frPortCnfResPartGrpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: frPortCnfResPartGrpEntry.setDescription('An entry for logical port ')
frResPartPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 5, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frResPartPortNum.setStatus('mandatory')
if mibBuilder.loadTexts: frResPartPortNum.setDescription("This is the logical port number, the index to this table. If we have T1 card then the maximum port number is 192 and if we have E1 card the maximum port number can be 248 For FRSM VHS 2CT3 the maximum port number is 256. For FRSM12 card: The ifIndex of the port's corresponding row in ifTable. Byte 3 = Chassis Number, Byte 2 = Slot Number, Byte 1 & 0 = Encoded unique number for Port. ")
frResPartCtrlrNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("par", 1), ("pnni", 2), ("tag", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frResPartCtrlrNum.setStatus('mandatory')
if mibBuilder.loadTexts: frResPartCtrlrNum.setDescription('This is index for controller using the port In MGX release 1.0, the value par should be used In MGX release 2.0, the value pnni should be used ')
frResPartRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 5, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("add", 1), ("del", 2), ("mod", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frResPartRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: frResPartRowStatus.setDescription(' This will add, delete or modify the partition. In MGX Release1.0: To add an entry, this object should be set to add, value for other objects should not be specified. FRSM will choose default values for all other objects. In MGX Release2.0: To add an entry, this object should be set to add, value for frResPartCtrlrID may be specified. FRSM will choose default values for all other objects. Currently the value mod is not supported. To delete an entry, this object has to be set to del. The resource partition can be deleted only after deleting all the connections (LCNs). ')
frResPartNumOfLcnAvail = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 5, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frResPartNumOfLcnAvail.setStatus('mandatory')
if mibBuilder.loadTexts: frResPartNumOfLcnAvail.setDescription(' This represents number of LCNs available for this controller and this port FRSM VHS 2CT3 can support LCNs upto 4000. FRSM12 can support LCNs upto 16000. ')
frResPartDlciLow = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 5, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8388607))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frResPartDlciLow.setStatus('mandatory')
if mibBuilder.loadTexts: frResPartDlciLow.setDescription('This represents low end of reserved DLCI ')
frResPartDlciHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 5, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8388607))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frResPartDlciHigh.setStatus('mandatory')
if mibBuilder.loadTexts: frResPartDlciHigh.setDescription('This represents high end of reserved DLCI ')
frResPartIngrPctBW = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 5, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frResPartIngrPctBW.setStatus('mandatory')
if mibBuilder.loadTexts: frResPartIngrPctBW.setDescription('The percentage of total ingress bandwidth reserved ')
frResPartEgrPctBW = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 5, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frResPartEgrPctBW.setStatus('mandatory')
if mibBuilder.loadTexts: frResPartEgrPctBW.setDescription('The percentage of total egress bandwidth reserved ')
frResPartCtrlrID = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 5, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frResPartCtrlrID.setStatus('mandatory')
if mibBuilder.loadTexts: frResPartCtrlrID.setDescription('This is the controller identifier for the resource patition. The default value is set for PNNI controller. ')
frPortServiceQueGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 4, 1), )
if mibBuilder.loadTexts: frPortServiceQueGrpTable.setStatus('mandatory')
if mibBuilder.loadTexts: frPortServiceQueGrpTable.setDescription('The config table is for logical port interface. In FRSM-VHS, there are 256 entries for FRSM-2CT3 card and 2 entries for FRSM-T3/E3/HS2/T3B/E3B/HS2B-HSSI cards and 8 entries for FRSM-HS2B-12IN1. The table is currently supported only in FRSM-VHS when the object egrQosFeature in the cardSpecific group is set to egrQosFeatureEnabled. ')
frPortServiceQueGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 4, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "frServPortNum"), (0, "CISCO-WAN-AXIPOP-MIB", "portServiceQueueNo"))
if mibBuilder.loadTexts: frPortServiceQueGrpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: frPortServiceQueGrpEntry.setDescription(' An entry for logical port ')
frServPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frServPortNum.setStatus('mandatory')
if mibBuilder.loadTexts: frServPortNum.setDescription('This is the logical port number. ')
portServiceQueueNo = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("highpriorityQ", 1), ("rtVBRQ", 2), ("nrtVBRandABRQ", 3), ("uBRQ", 4), ("queue5", 5), ("queue6", 6), ("queue7", 7), ("queue8", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portServiceQueueNo.setStatus('mandatory')
if mibBuilder.loadTexts: portServiceQueueNo.setDescription('This identifies the Q depending on the Service Type 1 High Priority Queue 2 rt VBR Queue 3 nrt VBR and ABR Queue 4 UBR Queue queue5(5) to queue8(8) are reserved for future use There are 8 queues but only four are being used as of now. ')
portEgresQDepth = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2097151)).clone(1048575)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portEgresQDepth.setStatus('mandatory')
if mibBuilder.loadTexts: portEgresQDepth.setDescription('Indicates the peak Egress queue depth for the logical port. The total queue depth of all connections mapped to this queue should not exceed this value. ')
portEgresECNThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2097151)).clone(104857)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portEgresECNThresh.setStatus('mandatory')
if mibBuilder.loadTexts: portEgresECNThresh.setDescription('ECN threshold for the logical port. If the total queue depth of all connections mapped to this port queue exceeds this threshold, then the appropriate ECN bit (FECN in the downstream direction and BECN in the upstream direction) get set. ')
portEgresDEThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2097151)).clone(524287)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portEgresDEThresh.setStatus('mandatory')
if mibBuilder.loadTexts: portEgresDEThresh.setDescription('DE threshold for the logical port. If the total queue depth of all connections mapped to this port queue exceeds this threshold, and the DE bit is set in the incoming frame, then the frame gets dropped. ')
portQBwInc = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 4, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16383))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portQBwInc.setStatus('mandatory')
if mibBuilder.loadTexts: portQBwInc.setDescription('Denotes the bandwidth increment for this port queue. The bandwidth increment is the percentage of the port bandwidth used by all connections mapped to a particular queue scaled by the value 16384. ')
portBytesDiscXceedQueFull = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 4, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portBytesDiscXceedQueFull.setStatus('mandatory')
if mibBuilder.loadTexts: portBytesDiscXceedQueFull.setDescription('Counter maintained for the no of bytes discarded due to port queue depth exceeded. ')
portBytesDiscXceedDEThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 4, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portBytesDiscXceedDEThresh.setStatus('mandatory')
if mibBuilder.loadTexts: portBytesDiscXceedDEThresh.setDescription('Counter maintained for the no of bytes discarded due to DE threshold exceeded. ')
smFeatures = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 3, 6))
smRateControlConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 3, 7))
smCardUtilization = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 3, 11))
smRasConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 3, 18))
rasOamLpbkInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 3, 19))
channelizedAllowed = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 6, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("nonChannelized", 1), ("channelized", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: channelizedAllowed.setStatus('mandatory')
if mibBuilder.loadTexts: channelizedAllowed.setDescription('BRAM parameter indicating whether this card will support DS0 channels. ')
rateControlAllowed = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 6, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("rateControlDisabled", 1), ("rateControlEnabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rateControlAllowed.setStatus('mandatory')
if mibBuilder.loadTexts: rateControlAllowed.setDescription('BRAM parameter indicating whether this card will support foresight. ')
svcAllowed = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 6, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("svcDisabled", 1), ("svcEnabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: svcAllowed.setStatus('mandatory')
if mibBuilder.loadTexts: svcAllowed.setDescription('BRAM parameter indicating whether this card will support svc. ')
funiAllowed = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 6, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("funiDisabled", 1), ("funiEnabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: funiAllowed.setStatus('mandatory')
if mibBuilder.loadTexts: funiAllowed.setDescription('BRAM parameter indicating whether this card will support FUNI. ')
imaAllowed = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 6, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("imaDisabled", 1), ("imaEnabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: imaAllowed.setStatus('mandatory')
if mibBuilder.loadTexts: imaAllowed.setDescription('BRAM parameter indicating whether this card will support Inverse Multiplexing for ATM (IMA) feature ')
mulTrksAllowed = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 6, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("mulTrksDisabled", 1), ("mulTrksEnabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mulTrksAllowed.setStatus('mandatory')
if mibBuilder.loadTexts: mulTrksAllowed.setDescription('BRAM parameter indicating whether this card will support multiple IMA trunks feature. A value of 1 indicates that the feature is not allowed and a value of 2 indicates that the features is allowed ')
egrQosFeature = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 6, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("egrQosFeatureEnabled", 1), ("egrQosFeatureDisabled", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: egrQosFeature.setStatus('mandatory')
if mibBuilder.loadTexts: egrQosFeature.setDescription('If this is set to egrQosFeatureEnabled then the various class of service viz. Hi Priority, VBR rt, etc. as defined by the channel MIB object chanServType are supported. If this is set to egrQosFeatureDisabled then, the priority based queuing as defined by the channel MIB object egressQSelect is supported.')
rateUp = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 7, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rateUp.setStatus('mandatory')
if mibBuilder.loadTexts: rateUp.setDescription('Rate Up value for this card. ')
rateDown = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 7, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rateDown.setStatus('mandatory')
if mibBuilder.loadTexts: rateDown.setDescription('Rate Down value for this card. ')
rateFastDown = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 7, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rateFastDown.setStatus('mandatory')
if mibBuilder.loadTexts: rateFastDown.setDescription('Rate Fast Down value for this card. ')
rtdMeasurementTime = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 7, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtdMeasurementTime.setStatus('mandatory')
if mibBuilder.loadTexts: rtdMeasurementTime.setDescription('Round Trip delay measurement time in secs for this card. ')
qirTimeout = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 7, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qirTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: qirTimeout.setDescription('QIR timeout in secs for this card. ')
cardOversubscribed = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 11, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cardOversubscribed.setStatus('mandatory')
if mibBuilder.loadTexts: cardOversubscribed.setDescription('This variable indicates the whether the card is over subscribed or not ')
cardIngrPercentUtil = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 11, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cardIngrPercentUtil.setStatus('mandatory')
if mibBuilder.loadTexts: cardIngrPercentUtil.setDescription('Percentage Utilization of the Card in the Ingress direction. ')
rasOamlpbkAllowed = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 18, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("rasOamlpbkEnabled", 1), ("rasOamlpbkDisabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rasOamlpbkAllowed.setStatus('mandatory')
if mibBuilder.loadTexts: rasOamlpbkAllowed.setDescription('Object indicating whether RAS- OAM loopback test is enabled or disabled for this card. ')
rasOamlpbkFrequency = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 18, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rasOamlpbkFrequency.setStatus('mandatory')
if mibBuilder.loadTexts: rasOamlpbkFrequency.setDescription('Object indicating the frequency in minutes in which RAS task sends one OAM loopback cell per idle connection. ')
chanPacketNumber = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 19, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanPacketNumber.setStatus('mandatory')
if mibBuilder.loadTexts: chanPacketNumber.setDescription('Each trap will send status for 256 channels bitmapping the status. This object identities the chunk of 256 channels. The channel numbers for which the trap indicates the status is found as chanPacketNumber * 256 + bitoffset + 16. This object cannot be set or read. ')
chanOAMstatus32 = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 19, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanOAMstatus32.setStatus('mandatory')
if mibBuilder.loadTexts: chanOAMstatus32.setDescription('Bit map indicating Ras_oam_lpbk test state of 32 channels from chanPacketNumber * 256 + 16 to chanPacketNumber * 256 + 47 MSB represent lower channel and LSB represent higher channel 0 in bit position indicate lpbk test ok 1 in bit position indicate lpbk test failed This object cannot be set or read ')
chanOAMstatus64 = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 19, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanOAMstatus64.setStatus('mandatory')
if mibBuilder.loadTexts: chanOAMstatus64.setDescription('Bit map indicating Ras_oam_lpbk test state of 32 channels from chanPacketNumber * 256 + 48 to chanPacketNumber * 256 + 79 MSB represent lower channel and LSB represent higher channel 0 in bit position indicate lpbk test ok 1 in bit position indicate lpbk test failed This object cannot be set or read ')
chanOAMstatus96 = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 19, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanOAMstatus96.setStatus('mandatory')
if mibBuilder.loadTexts: chanOAMstatus96.setDescription('Bit map indicating Ras_oam_lpbk test state of 32 channels from chanPacketNumber * 256 + 80 to chanPacketNumber * 256 + 111 MSB represent lower channel and LSB represent higher channel 0 in bit position indicate lpbk test ok 1 in bit position indicate lpbk test failed This object cannot be set or read ')
chanOAMstatus128 = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 19, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanOAMstatus128.setStatus('mandatory')
if mibBuilder.loadTexts: chanOAMstatus128.setDescription('Bit map indicating Ras_oam_lpbk test state of 32 channels from chanPacketNumber * 256 + 112 to chanPacketNumber * 256 + 143 MSB represent lower channel and LSB represent higher channel 0 in bit position indicate lpbk test ok 1 in bit position indicate lpbk test failed This object cannot be set or read ')
chanOAMstatus160 = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 19, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanOAMstatus160.setStatus('mandatory')
if mibBuilder.loadTexts: chanOAMstatus160.setDescription('Bit map indicating Ras_oam_lpbk test state of 32 channels from chanPacketNumber * 256 + 144 to chanPacketNumber * 256 + 175 MSB represent lower channel and LSB represent higher channel 0 in bit position indicate lpbk test ok 1 in bit position indicate lpbk test failed This object cannot be set or read ')
chanOAMstatus192 = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 19, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanOAMstatus192.setStatus('mandatory')
if mibBuilder.loadTexts: chanOAMstatus192.setDescription('Bit map indicating Ras_oam_lpbk test state of 32 channels from chanPacketNumber * 256 + 176 to chanPacketNumber * 256 + 207 MSB represent lower channel and LSB represent higher channel 0 in bit position indicate lpbk test ok 1 in bit position indicate lpbk test failed This object cannot be set or read ')
chanOAMstatus224 = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 19, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanOAMstatus224.setStatus('mandatory')
if mibBuilder.loadTexts: chanOAMstatus224.setDescription('Bit map indicating Ras_oam_lpbk test state of 32 channels from chanPacketNumber * 256 + 208 to chanPacketNumber * 256 + 239 MSB represent lower channel and LSB represent higher channel 0 in bit position indicate lpbk test ok 1 in bit position indicate lpbk test failed This object cannot be set or read ')
chanOAMstatus256 = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 19, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanOAMstatus256.setStatus('mandatory')
if mibBuilder.loadTexts: chanOAMstatus256.setDescription('Bit map indicating Ras_oam_lpbk test state of 32 channels from chanPacketNumber * 256 + 240 to chanPacketNumber * 256 + 271 MSB represent lower channel and LSB represent higher channel 0 in bit position indicate lpbk test ok 1 in bit position indicate lpbk test failed This object cannot be set or read ')
frPortCnfX21PortGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 3, 1), )
if mibBuilder.loadTexts: frPortCnfX21PortGrpTable.setStatus('mandatory')
if mibBuilder.loadTexts: frPortCnfX21PortGrpTable.setDescription('The config table is for X.21/HSSI logical port interface ')
frPortCnfX21PortGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 3, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "x21portNum"))
if mibBuilder.loadTexts: frPortCnfX21PortGrpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: frPortCnfX21PortGrpEntry.setDescription(' An entry for logical port ')
x21portNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x21portNum.setStatus('mandatory')
if mibBuilder.loadTexts: x21portNum.setDescription('This is logical port number. The HSSI backcard can support upto 3 ports, whereas the X.21 can support 4 logical ports. No defaults. ')
x21portLineNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x21portLineNum.setStatus('mandatory')
if mibBuilder.loadTexts: x21portLineNum.setDescription('This represents the line number. On FRSM-HS1 the HSSI can support 3 lines and X.21 4 lines. No defaults. ')
x21portRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("add", 1), ("del", 2), ("mod", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x21portRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: x21portRowStatus.setDescription('This variable adds, deletes, or modifies the port 1- add 2 - delete 3 - modify Default is add. ')
x21portFlagsBetweenFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x21portFlagsBetweenFrames.setStatus('mandatory')
if mibBuilder.loadTexts: x21portFlagsBetweenFrames.setDescription('Number of flags transmitted between two consecutive HDLC frames. Default is 1 flag. ')
x21portEqueueServiceRatio = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x21portEqueueServiceRatio.setStatus('mandatory')
if mibBuilder.loadTexts: x21portEqueueServiceRatio.setDescription('Number of times queue 1 is serviced for every time queue 2 is serviced. Default is 1. ')
x21portSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 3, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x21portSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: x21portSpeed.setDescription('Port speed in kbps. At present it is same as line speed. No defaults. ')
x21portAdmin = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("write-Only", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x21portAdmin.setStatus('mandatory')
if mibBuilder.loadTexts: x21portAdmin.setDescription(' Up/down used to up and down the port. Default is the up state. ')
x21portType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("frame-relay", 1), ("frFUNI", 2), ("frame-forward", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x21portType.setStatus('mandatory')
if mibBuilder.loadTexts: x21portType.setDescription('This represents port type. The processing of the frames depends on the type of the port. ')
x21portSvcStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 3, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x21portSvcStatus.setStatus('mandatory')
if mibBuilder.loadTexts: x21portSvcStatus.setDescription('This represents SVC status ')
x21portSvcInUse = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("not-use", 1), ("in-use", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x21portSvcInUse.setStatus('mandatory')
if mibBuilder.loadTexts: x21portSvcInUse.setDescription('This represents port svc in use ')
x21portSvcShareLcn = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 3, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("port-based", 1), ("card-based", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x21portSvcShareLcn.setStatus('mandatory')
if mibBuilder.loadTexts: x21portSvcShareLcn.setDescription('This represents port type ')
x21portSvcLcnLow = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 3, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 271))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x21portSvcLcnLow.setStatus('mandatory')
if mibBuilder.loadTexts: x21portSvcLcnLow.setDescription('This represents low end of reserved LCN for svc ')
x21portSvcLcnHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 3, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 271))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x21portSvcLcnHigh.setStatus('mandatory')
if mibBuilder.loadTexts: x21portSvcLcnHigh.setDescription('This represents high end of reserved LCN for svc ')
x21portSvcDlciLow = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 3, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x21portSvcDlciLow.setStatus('mandatory')
if mibBuilder.loadTexts: x21portSvcDlciLow.setDescription('This represents low end of reserved DLCI for svc ')
x21portSvcDlciHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 3, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x21portSvcDlciHigh.setStatus('mandatory')
if mibBuilder.loadTexts: x21portSvcDlciHigh.setDescription('This represents high end of reserved DLCI for svc ')
x21portDeleteSvcs = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 3, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("delete", 1), ("other", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x21portDeleteSvcs.setStatus('mandatory')
if mibBuilder.loadTexts: x21portDeleteSvcs.setDescription('Setting this object to 1 indicates that all the SVC connections on the given port has to be deleted ')
x21portIngrSvcBandW = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 3, 1, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x21portIngrSvcBandW.setStatus('mandatory')
if mibBuilder.loadTexts: x21portIngrSvcBandW.setDescription('This represents Ingress Bandwidth reserve for SVC ')
x21portEgrSvcBandW = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 1, 1, 1, 3, 1, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x21portEgrSvcBandW.setStatus('mandatory')
if mibBuilder.loadTexts: x21portEgrSvcBandW.setDescription('This represents Egress Bandwidth reserve for SVC ')
x21AlmCnfGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 4, 5, 2))
x21AlmCnfGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 4, 5, 2, 1), )
if mibBuilder.loadTexts: x21AlmCnfGrpTable.setStatus('mandatory')
if mibBuilder.loadTexts: x21AlmCnfGrpTable.setDescription('The FRSM-HS1/HS2 interface alarm configuration table. ')
x21AlmCnfGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 4, 5, 2, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "x21AlmCnfLineNum"))
if mibBuilder.loadTexts: x21AlmCnfGrpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: x21AlmCnfGrpEntry.setDescription('An entry in the X.21/HSSI Alarm Configuration table ')
x21AlmCnfLineNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 5, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x21AlmCnfLineNum.setStatus('mandatory')
if mibBuilder.loadTexts: x21AlmCnfLineNum.setDescription('X.21/HSSI line number. No defaults. FRSM-HS2/HS2B-HSSI supports a range from 1 to 2 FRSM-HS2B-12IN1 supports a range from 1 to 8 ')
x21Severity = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 5, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("minor", 1), ("major", 2), ("dontcare", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x21Severity.setStatus('mandatory')
if mibBuilder.loadTexts: x21Severity.setDescription('This variable is used to setup the severity of LOS or clock mismatch alarm. Whenever the above condition arises, the FRSM-HS1/HS2/HS2B will send the alarm with appropriate status. ')
x21AlmGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 4, 5, 3))
x21AlmGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 4, 5, 3, 1), )
if mibBuilder.loadTexts: x21AlmGrpTable.setStatus('mandatory')
if mibBuilder.loadTexts: x21AlmGrpTable.setDescription('The X.21/HSSI interface alarm configuration table. The size of table is given by the value of x21LineNum')
x21AlmGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 4, 5, 3, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "x21AlmLineNum"))
if mibBuilder.loadTexts: x21AlmGrpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: x21AlmGrpEntry.setDescription('An entry in the X21 Alarm table')
x21AlmLineNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 5, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x21AlmLineNum.setStatus('mandatory')
if mibBuilder.loadTexts: x21AlmLineNum.setDescription('This object is the identifier (line number) of a X.21/HSSI interface. FRSM-HS2/HS2B-HSSI supports a range from 1 to 2 FRSM-HS2B-12IN1 supports a range from 1 to 8 ')
x21LineAlarmState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 5, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x21LineAlarmState.setStatus('mandatory')
if mibBuilder.loadTexts: x21LineAlarmState.setDescription('This variable is a bitmap of the X21 Line ALarms on the FRSM-HS1. A value of zero indicates no alarms. Itemized below are the individual bits: BitPosition Alarm ----------- ----- 0 C/I signal is OFF (also used to indicate LOS) 1 Clock rate mismatch (used in DTE mode) 2 Internal Loopback (diagnostic loopback) 3 HSSI Local LoopA (line is in loopback) 4 HSSI Local LoopB (line is in loopback) 5 Remote Loopback (line is transmitting loopcodes) 6 For V35 DTE mode, DCD and CTS both are inactive 7 For V35 DCE mode, RTS is inactive 8 No cable attached to V35 backcard 9 Wrong cable attached to V35 backcard If all the bit-states are 0s: - line is not in alarm, or - line not in loopback, or - line is transmitting any loopback codes. ')
x21LineEIAStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 5, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x21LineEIAStatus.setStatus('mandatory')
if mibBuilder.loadTexts: x21LineEIAStatus.setDescription('Indicates the status of X.21/HSSI lines: 0x01 -- c-lead high 0x02 -- i-lead high 0x04 -- LC-lead high (valid only for HSSI DCE mode). ')
x21AlarmClrButton = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 5, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noaction", 1), ("clear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x21AlarmClrButton.setStatus('mandatory')
if mibBuilder.loadTexts: x21AlarmClrButton.setDescription('This variable is used to clear all the alarms for the line. 1 = No action 2 = Clear alarm ')
x21CnfGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 4, 5, 1))
x21CnfGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 4, 5, 1, 1), )
if mibBuilder.loadTexts: x21CnfGrpTable.setStatus('mandatory')
if mibBuilder.loadTexts: x21CnfGrpTable.setDescription('The X21 Configuration table. The table size is given by the value of x21LineNumofValidEntries ')
x21CnfGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 4, 5, 1, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "x21LineNum"))
if mibBuilder.loadTexts: x21CnfGrpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: x21CnfGrpEntry.setDescription('An entry in the X21 Configuration table. ')
x21LineNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 5, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x21LineNum.setStatus('mandatory')
if mibBuilder.loadTexts: x21LineNum.setDescription(' This object is the identifier of a X.21 interface. No defaults. FRSM-HS2/HS2B-HSSI supports a range from 1 to 2 FRSM-HS2B-12IN1 supports a range from 1 to 8 ')
x21LineEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 5, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2), ("modify", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x21LineEnable.setStatus('mandatory')
if mibBuilder.loadTexts: x21LineEnable.setDescription('This variable disables, enables or modifies a line 1 - disable 2 - enable 3 - modify Default is enable. ')
x21LineType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 5, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("dte", 1), ("dce", 2), ("dteST", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x21LineType.setStatus('mandatory')
if mibBuilder.loadTexts: x21LineType.setDescription('This variable indicates the type X21 line type. The line-type affects the clock -- the DCE device always provides the clock and DTE accepts it. dteST is only applicable to V.35 interfaces Default is DTE. ')
x21LineRate = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 5, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108))).clone(namedValues=NamedValues(("r48Kbps", 1), ("r56Kbps", 2), ("r64Kbps", 3), ("r112Kbps", 4), ("r128Kbps", 5), ("r168Kbps", 6), ("r192Kbps", 7), ("r224Kbps", 8), ("r256Kbps", 9), ("r280Kbps", 10), ("r320Kbps", 11), ("r336Kbps", 12), ("r384Kbps", 13), ("r392Kbps", 14), ("r448Kbps", 15), ("r512Kbps", 16), ("r768Kbps", 17), ("r1024Kbps", 18), ("r1536Kbps", 19), ("r1544Kbps", 20), ("r1792Kbps", 21), ("r1920Kbps", 22), ("r1984Kbps", 23), ("r2048Kbps", 24), ("r3097Kbps", 25), ("r3157Kbps", 26), ("r4096Kbps", 27), ("r4645Kbps", 28), ("r4736Kbps", 29), ("r6195Kbps", 30), ("r6315Kbps", 31), ("r7744Kbps", 32), ("r7899Kbps", 33), ("r8192Kbps", 34), ("r9289Kbps", 35), ("r9472Kbps", 36), ("r10240Kbps", 37), ("r10890Kbps", 38), ("r11060Kbps", 39), ("r12390Kbps", 40), ("r12630Kbps", 41), ("r13900Kbps", 42), ("r14220Kbps", 43), ("r14340Kbps", 44), ("r15490Kbps", 45), ("r15800Kbps", 46), ("r16380Kbps", 47), ("r20030Kbps", 48), ("r24990Kbps", 49), ("r52Mbps", 50), ("r17370Kbps", 51), ("r18950Kbps", 52), ("r20530Kbps", 53), ("r22100Kbps", 54), ("r23680Kbps", 55), ("r3088Kbps", 56), ("r4632Kbps", 57), ("r6176Kbps", 58), ("r7720Kbps", 59), ("r9264Kbps", 60), ("r10808Kbps", 61), ("r12352Kbps", 62), ("r13896Kbps", 63), ("r15440Kbps", 64), ("r16984Kbps", 65), ("r18528Kbps", 66), ("r20072Kbps", 67), ("r21616Kbps", 68), ("r23160Kbps", 69), ("r24704Kbps", 70), ("r26248Kbps", 71), ("r27792Kbps", 72), ("r29336Kbps", 73), ("r30880Kbps", 74), ("r32424Kbps", 75), ("r33968Kbps", 76), ("r35512Kbps", 77), ("r37056Kbps", 78), ("r38600Kbps", 79), ("r40144Kbps", 80), ("r41688Kbps", 81), ("r43232Kbps", 82), ("r44776Kbps", 83), ("r46320Kbps", 84), ("r47864Kbps", 85), ("r49408Kbps", 86), ("r50952Kbps", 87), ("r6144Kbps", 88), ("r12288Kbps", 89), ("r14336Kbps", 90), ("r16384Kbps", 91), ("r18432Kbps", 92), ("r20480Kbps", 93), ("r22528Kbps", 94), ("r24576Kbps", 95), ("r26624Kbps", 96), ("r28672Kbps", 97), ("r30720Kbps", 98), ("r32768Kbps", 99), ("r34816Kbps", 100), ("r36864Kbps", 101), ("r38912Kbps", 102), ("r40960Kbps", 103), ("r43008Kbps", 104), ("r45056Kbps", 105), ("r47104Kbps", 106), ("r49152Kbps", 107), ("r51200Kbps", 108)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x21LineRate.setStatus('mandatory')
if mibBuilder.loadTexts: x21LineRate.setDescription('This variable configures the X.21/HSSI/V.35 line-rate. Note that enumerations 51 through 108 are supported only by FRSM-HS2/HS2B card. default is r48Kbps on FRSM-HS2B-12IN1 default is r52Mbps on FRSM-HS2/HS2B-HSSI ')
x21LineLoopbackCommand = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 5, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("x21NoLoop", 1), ("x21DiagnosticMetallicLoop", 2), ("x21DiagnosticFrontcardLoop", 3), ("x21RemoteLoop", 4), ("v35MetallicLoop", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x21LineLoopbackCommand.setStatus('mandatory')
if mibBuilder.loadTexts: x21LineLoopbackCommand.setDescription('This variable represents the loopback state x21NoLoop Not in the loopback state. Normal traffic can be sent x21DiagnosticMetallicLoop Loopbacks the line on the back-card towards the Network. x21DiagnosticFrontcardLoop Loopbacks the line on the frontcard toward the Network. x21RemoteLoop The remote NTU is in the loop back mode. In this state, the FRSM-HS1 is sending the loopback code to remote NTU. Default is x21NoLoop. Note: Before going into one of the loopbacks the state should be x21NoLoop. ')
x21LineSendCode = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 5, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("x21NoCode", 1), ("x21SendLoopACode", 2), ("x21SendLoopBCode", 3), ("x21SendLocalLoopCode", 4), ("x21SendRemoteLoopCode", 5), ("x21SendUnLoopCode", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x21LineSendCode.setStatus('mandatory')
if mibBuilder.loadTexts: x21LineSendCode.setDescription('This variable indicates what type of code is being sent across the X.21/HSSI interface by the device. The values mean: x21NoCode: No loopback. x21SendLoopACode: Start sending Loop A code. Valid only if the backcard is HSSI and the line-type is DTE. This command loops the line module of the remote device. x21SendLoopBCode: Start sending Loop B code. Valid only if the backcard is HSSI and the line-type is DTE. This command loops the digital section of the remote device. x21SendLocalLoopCode: Start sending CCITT X.21 Loopback Type 3 code. This is valid only if the backcard is X.21 type. x21SendRemoteLoopCode: Start sending CCITT X.21 Loopback Type 2 code. This is valid only if the backcard is X.21 type. x21SendUnLoopCode: Sending a loopback termination request. Valid for both HSSI and X.21 lines. To execute any of the loop-codes the x21LineLoopbackCommand should be set to x21RemoteLoop. Once the x21SendUnLoopCode succeeds the x21LineLoopbackCommand would transition back to x21NoLoop state. Default is x21NoCode.')
x21LineLoopbackCodeDetection = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 5, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("codeDetectDisabled", 1), ("codeDetectEnabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x21LineLoopbackCodeDetection.setStatus('mandatory')
if mibBuilder.loadTexts: x21LineLoopbackCodeDetection.setDescription('Enable detection of line Loopback Codes. In the current release, the loopback detection is implemented only in HSSI DCE mode. Default is codeDetectDisabled. ')
x21ConnectorType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 5, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("x21Backcard", 1), ("hssiBackcard", 2), ("v35Backcard", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x21ConnectorType.setStatus('mandatory')
if mibBuilder.loadTexts: x21ConnectorType.setDescription('back card type This object is not used by FRSM-HS2/HS2B ')
x21InvertClock = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 5, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("nonInvertedAndNotLooped", 1), ("invertedAndNotLooped", 2), ("nonInvertedAndLooped", 3), ("invertedAndLooped", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x21InvertClock.setStatus('mandatory')
if mibBuilder.loadTexts: x21InvertClock.setDescription('This object configures two options: a) To invert the clock sent by HS1/HS2B with the TX data or not. b) If DCE,to expect the receive clock looped back from DTE or not. If DTE,to loop back the receive clock from DCE or not. nonInvertedAndNotLooped(1)- a)=dont invert, b)=dont expect rcv clock/ dont loop rcv clock invertedAndNotLooped(2) - a)=invert, b)=dont expect rcv clock/ dont loop rcv clock nonInvertedAndLooped(3) - a)=dont invert, b)=expect rcv clock/ loop rcv clock invertedAndLooped(4) - a)=invert, b)=expect rcv clock/ loop rcv clock Enums 1 and 2 are applicable for X.21/HSSI/V.35 interfaces. Enums 3 and 4 are applicable only for V.35. Default for X.21/HSSI is nonInvertedAndNotLooped(1) Default for V.35 is nonInvertedAndLooped(3) This object is not used by FRSM-HS2/FRSM-HS2B-HSSI This object is used by FRSM-HS2B-12IN1 and default values are nonInvertedAndNotLooped(1) for X.21, nonInvertedAndLooped(3) for V.35 ')
x21LineInterfaceType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 5, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("hssi", 1), ("x21", 2), ("v35", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x21LineInterfaceType.setStatus('mandatory')
if mibBuilder.loadTexts: x21LineInterfaceType.setDescription(' This object indicates serial interface type. Default is hssi. This object is not is configurable in FRSM-HS2 and FRSM-HS2B-HSSI. It will be set hssi by default for these cards This object is configurable in FRSM-H2B-12IN1. Default is v35')
x21ClkFrequencyThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 5, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x21ClkFrequencyThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: x21ClkFrequencyThreshold.setDescription('This object indicates user configurable percentage of clock frequency, which is used by DTE clock monitoring to declare clock rate out of bound alarm. This object is valid only for X.21/v.35/HSSI DTE interfaces. This object is supported by FRSM-HS2 and FRSM-HS2/B')
serialLineRate = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 5, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(48000, 51840000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: serialLineRate.setStatus('mandatory')
if mibBuilder.loadTexts: serialLineRate.setDescription(' line rate for X.21/HSSI/V.35 interfaces in bps. This object is supported only by FRSM-HS2/B card, only multiples of 1000 are accepted. Default is 48Kbps for X.21/V.35 interfaces and 51840Kbps for HSSI interface ')
serialLineRateVariation = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 5, 1, 1, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: serialLineRateVariation.setStatus('mandatory')
if mibBuilder.loadTexts: serialLineRateVariation.setDescription(' This object indicates line rate variation of HSSI/X.21/V.35 DCE interfaces in ppm (parts per million). i.e. clock generated from DCE hardware interface = (serialLineRate +/- (serialLineRateVariation * 10^6)/ serialLineRate) This object is supported only by FRSM-HS2/B card ')
x21LineNumofValidEntries = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 4, 5, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x21LineNumofValidEntries.setStatus('mandatory')
if mibBuilder.loadTexts: x21LineNumofValidEntries.setDescription('The number of X.21/HSSI configuration entries (regardless of their current configuration) in the x21ConfigTable table.')
vismConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 3, 17))
vismIpGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 1))
vismVoIpGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 2))
vismDspGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 3))
vismSystemGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4))
vismTrapObjGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 5))
vismAal2Grp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 6))
vismInteropGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 7))
vismIpAddress = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: vismIpAddress.setDescription(' The IP address of VISM card. Each VISM card has its own IP address. IP address for each VISM card is required to communicate with the Call agent. The IP address should be configured before adding endpoints. This object is applicable if the mode is voIP or switching. From vism 2.0.3 release onwards this object can be configured in any application but will be applicable only in switching applications. ')
vismSubNetMask = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismSubNetMask.setStatus('mandatory')
if mibBuilder.loadTexts: vismSubNetMask.setDescription(' SUB-NETMASK of the VISM IP interface. This object is applicable if the mode is voIP or switching. From vism 2.0.3 release onwards this object can be configured in any application but will be applicable only in switching applications. ')
vismControlTos = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(96)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismControlTos.setStatus('mandatory')
if mibBuilder.loadTexts: vismControlTos.setDescription(' This object is used to provision the bitmask used for the TOS (Type Of Service) octet for cells carrying the control (xGCP ) traffic. Default value 96 = 0x60 => Precedence = 3 and TOS nibble = 0 The bitmask can be only a byte value. ')
vismBearerIpAddress = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismBearerIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: vismBearerIpAddress.setDescription(' The bearer IP address of VISM card. This is an optional second IP address of the VISM card. If this bearer IP address is defined, the vismIpAddress automatically becomes the control IP address. From vism 2.0.3 release onwards this object can be configured in any application but will be applicable only in switching applications. ')
vismBearerSubNetMask = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismBearerSubNetMask.setStatus('mandatory')
if mibBuilder.loadTexts: vismBearerSubNetMask.setDescription(' Bearer SUB-NETMASK of the VISM IP interface. This optional bearer subnet mask must be provided when vismBearerIpAddress is provided. From vism 2.0.3 release onwards this object can be configured in any application but will be applicable only in switching applications. ')
vismBearerTos = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 2, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(160)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismBearerTos.setStatus('mandatory')
if mibBuilder.loadTexts: vismBearerTos.setDescription(' This object is used to provision the bitmask used for the TOS (Type Of Service) octet for cells carrying VoIP bearer (RTP ) traffic. Default value 160 = 0xA0 => Precedence = 5 and TOS nibble = 0 The bitmask can be only a byte value. ')
vismRtcpRepInterval = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 2, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(500, 15000)).clone(5000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismRtcpRepInterval.setStatus('mandatory')
if mibBuilder.loadTexts: vismRtcpRepInterval.setDescription(" This attribute defines the RTCP report interval ( defined in RFC 1889). This indicates the interval at which the RTCP reports should be sent to the participating members. The value is expressed in units of milliseconds. The RTCP reports are not sent at a fixed rate at this interval. Rather, this value is used as a base value to arrive at a random number between 0.5 and 1.5 times this value. This interval timer also serves the purpose of RTP packets receive timer. At every 'vismRtcpRecvMultiplier' times this interval, where 'vismRtcpRecvMultiplier'is specified in the MIB object below, a check is made on a VoIP connection (which is in SENDRECV or RECVONLY xGCP modes) to see if any RTP packets have been received. If not, gateway-initiated DLCX should be sent to the Call Agent. Currently, this interval timer is a card-specific value, which means the value is configurable on a per card basis and not on a per call basis. This value is applicable for VoIP adaptation only. From vism 2.0.3 release onwards this object can be configured in any mode/adaptations, but will be applicable only in voip adaptation. ")
vismRtpReceiveTimer = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismRtpReceiveTimer.setStatus('mandatory')
if mibBuilder.loadTexts: vismRtpReceiveTimer.setDescription(' This object defines whether the RTP packets receive timer on the VISM needs to be enabled or not. For some VoIP applications (as in South Carolina release), if a connection is in send-recv mode or recv-only mode, after the bearer cur-through is done, the RTP stream should be monitored for RTP packets. If there are no packets received within a time interval specified by 5 seconds, then a Gateway initiated DLCX (Delete connection) should be sent on that connection. If this object is set to enable, the RTP stream is monitored. Otherwise, it is not monitored. This value is applicable for VoIP adaptation only. From vism 2.0.3 release onwards this object can be configured in any mode/adaptations, but will be applicable only in voip adaptation. ')
vismPacketizationPeriod = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 2, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(10, 20, 30, 40))).clone(namedValues=NamedValues(("tenms", 10), ("twentyms", 20), ("thirtyms", 30), ("fourtyms", 40))).clone('tenms')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismPacketizationPeriod.setStatus('deprecated')
if mibBuilder.loadTexts: vismPacketizationPeriod.setDescription(' This object is used to provision the packetization period to be applied. This object is applicable for VoIP adaptation only. For VoAAL2 adaptations, the packetization period is derived from the profile table entry. For VoAAL1 adaptation, it is fixed at 5.875 ms. ')
vismVoIpDtmfRelay = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 2, 5), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismVoIpDtmfRelay.setStatus('mandatory')
if mibBuilder.loadTexts: vismVoIpDtmfRelay.setDescription(' This attribute defines whether the DTMF (Dual Tone, Multi-Frequency) digits need to be transported to the other endpoint via NSE packets. The value in this object will be utilised when the Call Agent does not specify this. ')
vismVoIpCasTransport = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 2, 6), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismVoIpCasTransport.setStatus('mandatory')
if mibBuilder.loadTexts: vismVoIpCasTransport.setDescription('This attribute defines whether the CAS (ABCD bits) bits need to be transported to the other endpoint via NSE packets. The value in this object will be utilized when the Call Agent does not specify this. ')
vismVoIpTripleRedundancy = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 2, 7), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismVoIpTripleRedundancy.setStatus('mandatory')
if mibBuilder.loadTexts: vismVoIpTripleRedundancy.setDescription('This attribute defines whether triple redundancy is enabled or not. With triple redundancy, NSEs are sent three times at 20 ms intervals. For reliable channels, triple redundancy can be disabled in order to save the bandwidth and the processing overheads. The value in this object will be utilized when the Call Agent does not specify this. ')
vismVoIpVADTimer = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 2, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(250, 65535)).clone(250)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismVoIpVADTimer.setStatus('mandatory')
if mibBuilder.loadTexts: vismVoIpVADTimer.setDescription('This attribute defines the hangover time for VAD in milliseconds. Once the voice inactivity is detected, the gateway will wait for this duration before activating silence suppression. The value in this object will be utilized when the Call Agent does not specify this. ')
vismVoIpNTECapabilityNegotiate = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 2, 9), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismVoIpNTECapabilityNegotiate.setStatus('mandatory')
if mibBuilder.loadTexts: vismVoIpNTECapabilityNegotiate.setDescription(' This attribute defines whether the VISM has the capability to negotiate the list of events either NSE (Named Signal Event) or NTE (Named Telephony Events), using rtpmap and fmtpmap in the SDP. If the value is TRUE, then VISM will include / accept rtpmap and fmtpmap in the SDP. Any events NSE / NTE not listed will be interpreted as not supported. If the value is FALSE, then VISM will neither include nor accept rtpmap for X-NSE & X-NTE, and fmtpmap. For the backward compatibility sake VISM will transmit DTMF digits using NSEs if the value is FALSE ')
vismVoIpSIDPayloadType = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 2, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(13)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismVoIpSIDPayloadType.setStatus('mandatory')
if mibBuilder.loadTexts: vismVoIpSIDPayloadType.setDescription('This attribute sets the payload type of a RTP packet carrying SID which is sent to the other end when silence is detected. The default value is in accordance to the earlier revisions of draft-ietf-avt-provile-new-10.txt ')
vismVoIpDPvcOamCellGap = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 2, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 5000)).clone(500)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismVoIpDPvcOamCellGap.setStatus('mandatory')
if mibBuilder.loadTexts: vismVoIpDPvcOamCellGap.setDescription('This attribute defines the inter cell gap for dual PVC OAM cells. The value represents the time in milliseconds. ')
vismVoIpDPvcRetryCnt = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 2, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismVoIpDPvcRetryCnt.setStatus('mandatory')
if mibBuilder.loadTexts: vismVoIpDPvcRetryCnt.setDescription('This attribute defines the threshold for failure of a PVC. If the number of consecutive OAM cells sent for which no ack was received equals this number then the connection is considered failed. ')
vismVoIpDPvcRecoverCnt = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 2, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismVoIpDPvcRecoverCnt.setStatus('mandatory')
if mibBuilder.loadTexts: vismVoIpDPvcRecoverCnt.setDescription('This attribute defines the threshold for recovery of a PVC. If the number of consecutive OAM cells sent for which ack was received equals this number then the connection is considered recovered from failure. ')
vismRtcpRecvMultiplier = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 2, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismRtcpRecvMultiplier.setStatus('mandatory')
if mibBuilder.loadTexts: vismRtcpRecvMultiplier.setDescription(" The 'vismRtcpRepInterval' MIB object specified above defines an approximate RTCP report interval (defined in RFC 1889) which indicates the interval in milliseconds at which the RTCP reports should be sent to the participating members. This MIB object, 'vismRtcpRecvMultiplier', defines how many times the RTCP reports may fail before exception condition activity may be done. At this number of times specified in this MIB object times the RTCP Report Interval, a check is made on a VoIP connection (which is in SENDRECV or RECVONLY xGCP modes) to see if any RTP packets have been received. If not, gateway-initiated DLCX should be sent to the Call Agent. Currently, this interval multiplier is a card-specific value, which means the value is configurable on a per card basis and not on a per call basis. This value is applicable for VoIP adaptation only. ")
vismVoIpLapdTrunkPVC = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 2, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("control", 1), ("bearer", 2))).clone('control')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismVoIpLapdTrunkPVC.setStatus('mandatory')
if mibBuilder.loadTexts: vismVoIpLapdTrunkPVC.setDescription("This object should be used for VoIP Trunking applications and only if the signalling type is configured to be CCS. By default the PRI D-channel information will be sent on the control channel. If the control network is totally seperated from the bearer network then the user needs to set this object to 'bearer' to send his Lapd trunk messages to the remote VISM. ")
vismVoIpEventNegotiationPolicy = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 2, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("proprietary", 2), ("all", 3))).clone('proprietary')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismVoIpEventNegotiationPolicy.setStatus('mandatory')
if mibBuilder.loadTexts: vismVoIpEventNegotiationPolicy.setDescription(' This attribute defines whether or not the VISM should advertise the event codecs, NSE (Named Signal Events), NTE (Named Telephony Events), or Cisco-rtp, in addition to the list of events specified by the call agent. If the value is none, then VISM will not include any more event codecs than what has been specified by the call agent. If the value is proprietary, then VISM can advertise proprietary event codecs in addition to the event codecs specified by the call agent. If the value is all, then VISM can advertise both proprietary as well as standard event codecs in addition to the event codecs specified by the call agent. ')
vismEcanCnfIdlePattern = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("pattern1", 1), ("pattern2", 2), ("pattern3", 3), ("pattern4", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismEcanCnfIdlePattern.setStatus('deprecated')
if mibBuilder.loadTexts: vismEcanCnfIdlePattern.setDescription(' Echo Canceller pattern for Idle code. Mu-Law : 1 - 7f, 2 - ff, 3 - 7f or ff, 4 - f7 A-Law : 1 - None, 2 - 54, 3 - 55, 4 - Programable Idle code. DEFVAL : pattern3 (7f or ff) for Mu-law and pattern2 (54) for A-Law. ')
vismEcanCnfIdleDirection = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 3, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("both", 1), ("either", 2), ("send", 3), ("receive", 4))).clone('both')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismEcanCnfIdleDirection.setStatus('deprecated')
if mibBuilder.loadTexts: vismEcanCnfIdleDirection.setDescription(' Echo Canceller Idle Direction. This determines in which direction the Idle code must be present. ')
vismCompCnfPacketSize = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 3, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(80, 160)).clone(80)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismCompCnfPacketSize.setStatus('mandatory')
if mibBuilder.loadTexts: vismCompCnfPacketSize.setDescription(' Compressed output packet size - This value is used in the DSP interface API commands to configure the DSPs for the maximum packet size. The valid values are 80 and 160 only. NOTE: This object is not used currently. In future it is applicable only if the mode is VoAAL1. From vism 2.0.3 release onwards this object can be configured in any mode/adaptations, but will be applicable only in aal1 adaptation. ')
vismERL = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 3, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("zerodb", 1), ("threedb", 2), ("sixdb", 3), ("worstdb", 4))).clone('sixdb')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismERL.setStatus('mandatory')
if mibBuilder.loadTexts: vismERL.setDescription(' This object is used to provision the return echo lost, i.e the db loss of the echo that the DSPs are supposed to cancel. ')
vismJitterDelayMode = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 3, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("fixed", 1), ("adaptive", 2))).clone('fixed')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismJitterDelayMode.setStatus('deprecated')
if mibBuilder.loadTexts: vismJitterDelayMode.setDescription(' This object is used to provision the jitter buffer mode to be apply to a call connection. The possible values are: fixed - means use a constant jitter buffer size, which is defined by the vismJitterInitialDelay mib variable. adaptive - means let the DSP pick the optimal value for the call connection. ')
vismJitterInitialDelay = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 3, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100))).clone(namedValues=NamedValues(("zero", 1), ("five", 5), ("ten", 10), ("fifteen", 15), ("twenty", 20), ("twentyfive", 25), ("thirty", 30), ("thirtyfive", 35), ("fourty", 40), ("fortyfive", 45), ("fifty", 50), ("fiftyfive", 55), ("sixty", 60), ("sixtyfive", 65), ("seventy", 70), ("seventyfive", 75), ("eighty", 80), ("eightyfive", 85), ("ninty", 90), ("ninetyfive", 95), ("hundred", 100))).clone('fourty')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismJitterInitialDelay.setStatus('deprecated')
if mibBuilder.loadTexts: vismJitterInitialDelay.setDescription(' Defines the jitter buffer size. If the vismJitterDelayMode is set to be fixed, the jitter buffer is fixed at this value for the call. If vismJitterDelayMode is adaptive, this is the initial jitter buffer size, and the DSP will adapt to an optimal size. The range 10,20,30,40,50,60,70,80,90,100 is applicable to 1.5 release only. The range 1,5,10,15,20,25,30,35 .... is applicable from vism2.0 release onwards. The valid range for template 1 : 1,10,20,30,40,50,60,70,80,90,100 The valid range for template 2 : 1,5,10,15,20,25,30,35,40,45,50, 55,60,65,70,75,80,85,90,95,100. When the template of the card changes, either from template 1 to 2 or vice versa the value of this object will be implicitly set to default value. ')
vismAdaptiveGainControl = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 3, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismAdaptiveGainControl.setStatus('mandatory')
if mibBuilder.loadTexts: vismAdaptiveGainControl.setDescription('If set to on, the DSP will adjust the gain of the of the call connection to an optimal value. ')
vismDspHealth = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 3, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismDspHealth.setStatus('mandatory')
if mibBuilder.loadTexts: vismDspHealth.setDescription(' This attribute indicates the health of the DSPs. It is a percentage of the total number of DSPs that are currently functional. Currently No action is planned upon the failure of a DSP chip in a card, other than resetting the card. ')
vismUpspeedCodec = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 3, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("g-711u", 1), ("g-711a", 2), ("g-726-32", 3), ("clearChannel", 4), ("g-723h", 5), ("g-723l", 6), ("g-726-16", 7), ("g-726-24", 8), ("g-726-40", 9)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismUpspeedCodec.setStatus('mandatory')
if mibBuilder.loadTexts: vismUpspeedCodec.setDescription(' This object specifies the codec to be used when fax upspeed happens. The default value for this object is G.711u when the line type is T1 and G.711a when the line type is E1 This object is applicable only in the case of VOIP applications, for AAL2 the upspeedCodec is obtained from profile table and this object will have no affect. ')
vismPayloadType = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 3, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 256)).clone(256)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismPayloadType.setStatus('mandatory')
if mibBuilder.loadTexts: vismPayloadType.setDescription(' This object specifies the payload type to be used when fax upspeed happens. IANA values (0..95) are static payload and (96..127) are dynamic payload type. This object is applicable only in the case of VOIP applications, for AAL2 the upspeedCodec is obtained from profile table and this object will have no affect. ')
vismDaughterCardSerialNum = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 6))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismDaughterCardSerialNum.setStatus('mandatory')
if mibBuilder.loadTexts: vismDaughterCardSerialNum.setDescription(' A unique value for each VISM daughter card, entered in nvram by manf. The serial No. is on the non-volatile RAM on the VISM daughter card. ')
vismDaughterCardDescription = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismDaughterCardDescription.setStatus('mandatory')
if mibBuilder.loadTexts: vismDaughterCardDescription.setDescription(' Describes the VISM daughter card. ')
vismDaughterCardHWRev = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismDaughterCardHWRev.setStatus('mandatory')
if mibBuilder.loadTexts: vismDaughterCardHWRev.setDescription(' Hardware revision number for the daughter card. ')
vismEcanEncoding = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("mu-law", 1), ("a-law", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismEcanEncoding.setStatus('mandatory')
if mibBuilder.loadTexts: vismEcanEncoding.setDescription(' Voice encoding type, Mu-law or A-law. mu-law is returned for T1 lines and a-law is returned for E1 lines. ')
vismMode = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 99, 100))).clone(namedValues=NamedValues(("voipSwitching", 1), ("aal2Trunking", 2), ("aal1Svc", 3), ("switchedVoipCASBh", 4), ("switchedVoipPRIBh", 5), ("switchedAal2CASBh", 6), ("switchedAal2Svc", 7), ("switchedAal2Pvc", 8), ("voipAndAal1Svc", 9), ("superMode", 99), ("unknownMode", 100))).clone('voipSwitching')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismMode.setStatus('mandatory')
if mibBuilder.loadTexts: vismMode.setDescription(" This attribute defines the connection model that the VISM card is configured to operate with. This object can be modified by CLI only. The CLI 'cnfvismmode' can be used to set this object. VISM card will be reset after modifying this parameter for the VISM card to come up in the new mode. Each mode enables a set of features on the VISM card. The feature set for each of the above modes is : voipSwitching - VoIP mode. In this mode VISM interacts with the Call Agent using XGCP protocol, bearer path is VoIP (AAL5). This mode is also used for VoIP applications that dosen't use call agent. (VoIP Trunking) aal2Trunking - AAL2 Trunking mode. In this mode VISM does not interact with the Call Agent. Bearer Path is AAL2. aal1Svc - AAL1 SVC mode. In this mode VISM interacts with Call Agent using XGCP protocol over AAL5 control PVCs. In this mode, bearer path is VoAAL1 and the bearer connections are SVCs. i.e VISM dynamically sets-up and tears down bearer connections. This value is applicable in VISM2.0 and onwards. switchedVoipCASBh, switchedVoipPRIBh, switchedAal2CASBh, switchedAal2Svc and superMode are ignored. switchedAal2Pvc - Switched and trunked AAL2 PVC with CAS xGCP backhaul, CCS and CAS forwarding. switchedAal2Svc - Switched AAL2 SVC with PRI backhaul. voipAndAal1Svc - VoIP and ATM Groomer. unknowMode - Unknown mode, when user change vismFeatureBitMap to a combination of Features that are not in the above modes. This object has to be synchronized with vismFeatureBitMap. When vismFeatureBitMag is changed this object will be implictly set to the mode that has the right combination of features. From Indiana release and onwards, when user change mode VISM card is not reset and the configuration is not cleared. ")
vismPrevMode = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("voipSwitching", 1), ("aal2Trunking", 2), ("aal1Svc", 3), ("aal2PvcSwitching", 4))).clone('voipSwitching')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismPrevMode.setStatus('deprecated')
if mibBuilder.loadTexts: vismPrevMode.setDescription(" This attribute indicates the mode in which VISM was operating before the vismMode value was changed. i.e It gives the value of vismMode before it got changed to the current value. When the card comes up in the default mode, the value of vismPrevMode will be the same as vismMode. From Indiana release and onwards, when user change mode VISM card is not reset and the configuration is not cleared. Therefore we don't need this object anymore. ")
vismCacEnable = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismCacEnable.setStatus('mandatory')
if mibBuilder.loadTexts: vismCacEnable.setDescription(' This attribute describes whether CAC (Connection Admission Control) functionality needs to be applied on the VISM card, on a per PVC basis. For some applications, the CAC functionality may not be required and in that case, it has to be disabled on a card basis. ')
vismAvailableDs0Count = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 248))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismAvailableDs0Count.setStatus('mandatory')
if mibBuilder.loadTexts: vismAvailableDs0Count.setDescription(' This attribute describes the no. of DS0s available for new connections on VISM. This is modified by the VISM firmware after each connection is setup. In indiana release the number of connections has been increased to 248, as the number of endpoints supported has been increased. ')
vismAppliedTemplate = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismAppliedTemplate.setStatus('mandatory')
if mibBuilder.loadTexts: vismAppliedTemplate.setDescription(' This attribute describes the Codec template currently configured on the VISM card. The value refers to an index to the vismCodecTemplate table. This template is applicable for all connections on the card. When a switch is made to a new template, the number of channels (endpoints) in use will be checked to ensure the switch will not occur if there are more endpoints active at the present time than what the new template (vismCodecTemplateMaxChanCount) allows. Also whenever an attempt is made to add a new endpoint for any template, this template maximum number will limit the number of endpoints that may be added for this template. ')
vismTftpServerDn = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismTftpServerDn.setStatus('mandatory')
if mibBuilder.loadTexts: vismTftpServerDn.setDescription(" This object holds the domain name of the tftp server from where the cas module will download the cas files. This domain name can be resolved internally or externally. Before configuring this object the domain name should be added in the mgDomainNameTable and at least one Ip address (internal or external) should be associated with this domain name in mgcResolutionTable. By default, the object is set to TFTPDOMAIN. Before the last entry corresponding to the tftp domain is deleted from the mgDomainNameTable or the last Ip address associated with this object is deleted from mgcResolutionTable, it should be set to 'TFTPDOMAIN'. If the user configures 'localhost' to be the tftp server domain then the cas files will be downloaded from PXM. If the user configures the domain name to be TFTPDOMIAN or localhost then that entry need not be present in mgDomainNameTable or mgcResolutionTable. ")
vismXgcpBearerNetworkType = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ip", 1), ("atm", 2))).clone('ip')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismXgcpBearerNetworkType.setStatus('mandatory')
if mibBuilder.loadTexts: vismXgcpBearerNetworkType.setDescription(' This object specifies the network type to use in order to transport bearer traffic. The user can configure this to IP or ATM based on where the VISM will be located. If the call agent specifies the network type in the MGCP local connection options (CRCX request), then the configuration of this object will have no effect, else the value of this object will be used when sending CRCX response. This object is applicable only from vism 2.0.3 release onwards. ')
vismXgcpBearerVCType = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("pvc", 1), ("svc", 2))).clone('pvc')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismXgcpBearerVCType.setStatus('mandatory')
if mibBuilder.loadTexts: vismXgcpBearerVCType.setDescription(' This object specifies the vc type to use in order to transport bearer traffic. If the call agent specifies the VC type in the MGCP local connection options (CRCX request), then the configuration of this object will have no effect, else the value of this object will be used when sending CRCX response. This object is applicable only from vism 2.0.3 release onwards. ')
vismXgcpBearerConnectionType = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("aal1Sdt", 1), ("aal2", 2), ("notApplicable", 3))).clone('notApplicable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismXgcpBearerConnectionType.setStatus('mandatory')
if mibBuilder.loadTexts: vismXgcpBearerConnectionType.setDescription(' This object specifies the connection type used to transport bearer traffic. If the BearerNetworkType is chosen to be IP then the value of this object has to be/will be set to not-applicable. If the call agent specifies the connection type in the MGCP local connection options (CRCX request), then the configuration of this object will have no effect, else the value of this object will be used when sending CRCX response. This object is applicable only from vism2.0.3 release onwards. ')
vismBearerContinuityTimer = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000)).clone(1000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismBearerContinuityTimer.setStatus('mandatory')
if mibBuilder.loadTexts: vismBearerContinuityTimer.setDescription(' This object specifies the co4 (bearer continuity) timer in millisecs. The timer will be started in the terminating/orginating gateway for a duration as specified in this MIB object when a co3 message is sent from the terminating/orginating gateway to the originating/terminating gateway. If the terminating/originating gateway does not receive co4 as an acknowledgement from the originating/termintaing gateway and the timer expires, gateway initiated DLCX is sent to the call agent from the terminating/originating gateway. This object is applicable when the call agent feature is available. ')
vismCodecNegotiationOption = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("lcoRcdLcl", 1), ("lcoLclRcd", 2), ("rcdLcoLcl", 3), ("rcdLclLco", 4), ("lclLcoRcd", 5), ("lclRcdLco", 6))).clone('lcoRcdLcl')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismCodecNegotiationOption.setStatus('mandatory')
if mibBuilder.loadTexts: vismCodecNegotiationOption.setDescription(' This object helps in forming an ordered intersection of lists and one of the lists must be used in determining the resulting order of codecs. Lco - local connection options Rcd - remote connection description Lcl - local codec list If the value of this object is 1 then effectively we are giving first priority to the local connection options sent by the Call Agent, followed by remote connection description sent by the remote gateway (CA) and the last priority will be to local codec list stored in vism. If the value of this object is 2 then effectively we are giving first priority to local connection options sent by the call agent, followed by local codec list stored in vism and the last priority will be to remote connection description sent by the remote gateway (or remote CA). If the value of this object is 3 then effectively we are giving first priority to remote connection description sent by the remote gateway /call agent, followed by local connection options sent by the call agent and the last priority will be to the local codec list stored on the local gateway(vism). If the value of this object is 4 then effectively we are giving first priority to remote connection description sent by the remote gateway/CA followed by local codec list stored on the local gateway and the last priority will be to the local connection options sent by the CA. If the value of this object is 5 then effectively we are giving first priority to local codec list stored on the local gateway (vism) followed by local connection options sent by the call agent and the last priority will be to remote connection description sent by the remote gateway (or remote CA). If the value of this object is 6 then effectively we are giving first priority to local codec list stored on the vism followed by remote connection description sent by the remote gateway (or remote CA) and the last priority will be to local connection options sent by the call agent. ')
vismProfileNegotiationOption = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("lcoRcdLcl", 1), ("lcoLclRcd", 2), ("rcdLcoLcl", 3), ("rcdLclLco", 4), ("lclLcoRcd", 5), ("lclRcdLco", 6))).clone('lcoRcdLcl')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismProfileNegotiationOption.setStatus('mandatory')
if mibBuilder.loadTexts: vismProfileNegotiationOption.setDescription(' This object helps in forming an ordered intersection of lists and one of the lists must be used in determining the resulting order of profiles. Lco - local connection options Rcd - remote connection description Lcl - local codec list If the value of this object is 1 then effectively we are giving first priority to the local connection options sent by the Call Agent, followed by remote connection description sent by the remote gateway (CA) and the last priority will be to local codec list stored in vism. If the value of this object is 2 then effectively we are giving first priority to local connection options sent by the call agent, followed by local codec list stored in vism and the last priority will be to remote connection description sent by the remote gateway (or remote CA). If the value of this object is 3 then effectively we are giving first priority to remote connection description sent by the remote gateway /call agent, followed by local connection options sent by the call agent and the last priority will be to the local codec list stored on the local gateway(vism). If the value of this object is 4 then effectively we are giving first priority to remote connection description sent by the remote gateway/CA followed by local codec list stored on the local gateway and the last priority will be to the local connection options sent by the CA. If the value of this object is 5 then effectively we are giving first priority to local codec list stored on the local gateway (vism) followed by local connection options sent by the call agent and the last priority will be to remote connection description sent by the remote gateway (or remote CA). If the value of this object is 6 then effectively we are giving first priority to local codec list stored on the vism followed by remote connection description sent by the remote gateway (or remote CA) and the last priority will be to local connection options sent by the call agent. ')
vismCarrierLossPolicy = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("previousCodec", 1), ("upspeedCodec", 2))).clone('previousCodec')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismCarrierLossPolicy.setStatus('mandatory')
if mibBuilder.loadTexts: vismCarrierLossPolicy.setDescription(" This object defines the policy that needs to be applied when a carrier loss is detected. This states whether to switch to the pre-upspeed codec or to remain with the upspeed codec. This object is applicable in case of SVCs. This object will be applicable in case of PVC if the per PVC object - vismChanCarrierLossPolicy (defined in vismChanCacTable) is set to 'unspecified'. Configuring this object will not have any affect when card level cac is disabled (vismCacEnable). ")
vismCacRejectionPolicy = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("delete", 1), ("maintain", 2))).clone('maintain')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismCacRejectionPolicy.setStatus('mandatory')
if mibBuilder.loadTexts: vismCacRejectionPolicy.setDescription("This attribute defines the policy that needs to be applied once the CAC function rejects the upspeeding of a connection, due to a fax/modem switch-over request. The applicable options are: 1 - To delete the connection that got rejected by CAC for upspeed 2 - To maintain the connection with the prior compression scheme. This object is applicable in case of SVCs . This object will be applicable in case of PVCs if the per PVC object - vismChanCacRejectionPolicy (defined in vismChanCacTable) is set to 'unspecified'. Configuring this object will not have any affect when card level cac is disabled (vismCacEnable). ")
vismExtDnsServerDn = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 20), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismExtDnsServerDn.setStatus('mandatory')
if mibBuilder.loadTexts: vismExtDnsServerDn.setDescription(" This object refers to the domain name of the external DNS server which will be used to resolve other domain name. Currently this domain name can only be resolved internally. Therefore, before configuring this object not only the domain name has to be added in the mgDomainNameTable with resolution type 'internalOnly' but also at least one IP address has been added with this domain name in mgcResolutionTable. Before deleting external DNS server from mgDomainNameTable or deleting the last IP address associated with the external DNS server this object should be set to 'NULL'. After we change the value of this object to NULL, all the externally resolved IP address in mgcResolutionTable will be purged. By default this object will be set to 'NULL'. ")
vismFeatureBitMap = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 21), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismFeatureBitMap.setStatus('mandatory')
if mibBuilder.loadTexts: vismFeatureBitMap.setDescription('This object denotes the bit map for VISM features. It indicates the current features that are enabled. It should be consistant with vismMode. When user change vismMode, this object is implicitly set to the feature combination that inidicate to that mode. The change of vismFeatureBitMap will not cause VISM to reset and the configuration will not be cleared. For each bit, value 1 means the feature is enabled, 0 means disabled. Bit 0 - AAL1 adaptation Bit 1 - AAL2 adaptation Bit 2 - AAL5 adaptation (Bearer network type is IP). Bit 3 - Switching (with Call Agent) Bit 4 - Trunking (without Call Agent) Bit 5 - Bearer VC type is PVC. Bit 6 - Bearer VC type is SVC. Bit 7 - CAS signaling Bit 8 - PRI backhaul Bit 9 - CCS signaling Bit 10 - Domain Name For example, 0x5AC corresponds to vismMode 1 (VoipSwitching). Currently this object is not settable, it can only be set thru some debug commands. ')
vismVADTolerance = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10000)).clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismVADTolerance.setStatus('mandatory')
if mibBuilder.loadTexts: vismVADTolerance.setDescription(' The value in this object refers to the customer accepted drop rate for voice connections when the bandwidth usage exceeds allowed value. The actual range of this object is 0.0001% - 1.00 % The unit is in percentage, since the default is 0.01 %, and since we cannot express such fractions in MIB , it is being multiplied by 10000 . However, when the underlying CAC module is notified of the change in this object, then the value has to be divided by a factor of 10000. Multiplication factor 10000 is picked as someone might be interested in a tolerance as low as 0.0001%. This object will be applicable in case of aal2 SVCs where the user does not add a PVC and also this object will be applicable if the per PVC level object (vismChanVADTolerance) is configured to have a value of zero. Configuring this object will not have any affect when card level cac is disabled (vismCacEnable). ')
vismVADDutyCycle = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100)).clone(61)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismVADDutyCycle.setStatus('mandatory')
if mibBuilder.loadTexts: vismVADDutyCycle.setDescription(' This object refers to the talk-spurts duty cycle. The unit is in percentage. When the value of this object is to be passed to underlying CAC module in VISM this value has to be divided by 100. This causes the actual range of this object to be 0.01 to 0.99 and not 0.01 to 1.00 as specified in the range of values above. Since a value of 100 will cause a floating point exception, this value is disallowed. The default value is 0.61 and since we cannot have fractions in a MIB variable the value is being multiplied by 100 and is expressed as 61. This object will be applicable in case of aal2 SVCs where the user does not add a PVC and also this object will be applicable if the per PVC level object (vismChanVADDutyCycle) is configured to have a value of zero. Configuring this object will not have any affect when card level cac is disabled (vismCacEnable). ')
vismAggregateTrafficClipping = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismAggregateTrafficClipping.setStatus('mandatory')
if mibBuilder.loadTexts: vismAggregateTrafficClipping.setDescription('This attribute defines the aggregate traffic clipping policy which is applicable to all bearer traffic generated at VISM card. The applicable options are: 1 - aggregate traffic clipping is disabled, VISM card traffic management does not perform aggregate traffic clipping. 2 - aggregate traffic clipping is enabled, VISM card traffic management performs aggregate traffic clipping. This is applicable to only AAL2 SVC voice bearer traffic. When aggregate traffic clipping is enabled, VISM card can discard cells which are exceeding VISM card aggregate SVC bandwidth which is specified as vismAggregateSvcBandwidth value. ')
vismAggregateSvcBandwidth = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismAggregateSvcBandwidth.setStatus('mandatory')
if mibBuilder.loadTexts: vismAggregateSvcBandwidth.setDescription('The aggregate svc bandwidth is used for AAL2 SVC aggregate SVC Connection Admision Control and also used for aggregate traffic clipping at VISM card when vismAggregateTrafficClipping is enabled. This is expressed in cells per second. This need to be configured for AAL2 SVC aggregate bandwidth call admision control to admit AAL2 SVC connections at VISM card. ')
vismBearerContinuityTest = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 26), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismBearerContinuityTest.setStatus('mandatory')
if mibBuilder.loadTexts: vismBearerContinuityTest.setDescription("This attribute defines whether the bearer continuity test for a connection will be performed at the time of call setup or not. When the vismBearerContinuityTest is enabled, the terminating media Gateway initiates a NSE/type 3 packet towards the originating gateway and starts a timer defined by vismBearerContinuityTimer. The originating gateway, on receipt of co3, responds by sending a co4 to the terminating end. If the terminating gateway doesn't receive co4 NSE/type 3 packet with in the time defined by co4 timer, it initiates a GW-initiated DLCX to the call agent which in turn deletes the connection. The value in this object will be utilised when the Call Agent does not specify this. ")
vismCaleaEnable = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 27), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismCaleaEnable.setStatus('mandatory')
if mibBuilder.loadTexts: vismCaleaEnable.setDescription(' This attribute describes whether CALEA (Communication Assistance for Law Enforcement Agency)) functionality needs to be enabled on the VISM card. This attribute enables/disables this feature at a card level. This command is only applicable for CALEA enable image. ')
vismXgcpSdpOst = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 7, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismXgcpSdpOst.setStatus('mandatory')
if mibBuilder.loadTexts: vismXgcpSdpOst.setDescription(" This object is used to enable/disable building of s=,t=,o= lines in SDP message. If this object is set to 'enable' then it indicates that the o=, s=, t= lines be built before sending SDP (Session Description Protocol), if it set to 'disable' then it indicates that the o=,s=,t= parameters need not be built for SDP. where o field indicates the owner/creator and session identifier s field indicates the session name t field indicates the duration while a session is valid. ")
vismDynamicPT = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 7, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismDynamicPT.setStatus('mandatory')
if mibBuilder.loadTexts: vismDynamicPT.setDescription(' This object is used to enable / disable dynamic payload type configuration on the VISM Card. ')
vismConfigChangeTypeBitMap = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 5, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismConfigChangeTypeBitMap.setStatus('mandatory')
if mibBuilder.loadTexts: vismConfigChangeTypeBitMap.setDescription('Configuration change Type BitMap used in vismTableChanged trap and vismScalarChanged trap. When used in vismTableChanged trap, the bits indicate the following: bit 0 set = mgcTable changed bit 1 set = mgEndpointTable changed bit 2 set = mgcResolutionTable changed bit 3 set = srcpPeerTable changed bit 4 set = vismDsx1Table changed bit 5 set = vismXgcpPeerTable changed bit 6 set = xgcpPackageTable changed bit 7 set = vismChanCacTable changed bit 8 set = vismCasVariantTable changed bit 9 set = vismCasXgcpVariantTable changed bit 10 set = vismAal2CidCnfTable changed bit 11 set = dsx0VismCnfTable changed bit 12 set = vismHdlcChanCnfTable changed bit 13 set = lineAssignmentTable changed bit 14 set = vismCodecCnfTable changed bit 15 set = vismLapdTable changed bit 16 set = vismRudpSessionCnfTable changed bit 17 set = aal2ProfilesGrpTable changed bit 18 set = mgDomainNameTable changed bit 19 set = vismPortCnfGrpTable changed bit 20 set = mgcRedundancyGrpTable changed bit 21 set = mgcRedundancyGrpParamTable changed bit 22 set = srcpPeerGrpParamTable changed bit 23 set = vismRtpConnGrpTable changed bit 24 set = vismCodecGenParmTable changed bit 25 set = t38FaxRelayGrpTable changed bit 26 set = mgcRedundancyProtocolTable changed bit 27 set = vismSessionSetTable changed bit 28 set = vismSessionGrpTable changed When used in vismScalarChanged trap, the bits indicate the following: bit 0 set = mediaGateway group changed bit 1 set = mediaGatewayEndpoint group changed bit 2 set = mediaGatewayControllerResolution group changed bit 3 set = srcpAdminObjects group changed bit 4 set = vismConfig group changed bit 5 set = vismXgcpCoreObjects group changed bit 6 set = xgcpCoreObjects group changed bit 7 set = xgcpExtensionObjects group changed bit 8 set = xgcpPackageObjects group changed bit 9 set = vismSvcAtmQosGrp Objects group changed bit 10 set = vismSvcTrfScalingGrp Objects group changed bit 11 set = vismSvcAal2CidGrp Objects group changed bit 12 set = srcpAdminRetryObjects Objects group changed bit 13 set = vismConfig IpGrp group objects changed bit 14 set = vismConfig VoipGrp group objects changed bit 15 set = vismConfig DspGrp group objects changed bit 16 set = vismConfig SystemGrp group objects changed bit 17 set = vismConfig Aal2Grp group objects changed bit 18 set = vismConfig InteropGrp group objects changed bit 19 set = announceControlGrp Objects group changed bit 20 set = vismXgcpEnhancementsObjects group changed default value is 0, no change This MIB makes sense only in traps. A GET on this may not return a Useful result. ')
vismTrapIntIndex1 = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 5, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismTrapIntIndex1.setStatus('mandatory')
if mibBuilder.loadTexts: vismTrapIntIndex1.setDescription('This object is used only for the purpose of sending it in the trap varbind. This object is used for two purposes: 1. When the integer index of a SMIv2 table has to be sent, this object will be used instead of the actual index object. The instance value of the object will be the instance value of the actual index. 2. In the config change trap trapVismTableChange, to send the index value of the table entry which got changed. This object will contain the value of the first integer index. The NMS applications should not depend on the implementation of this object. The SNMP Requests(GET,GET-NEXT) may not be valid for this object. ')
vismTrapIntIndex2 = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 5, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismTrapIntIndex2.setStatus('mandatory')
if mibBuilder.loadTexts: vismTrapIntIndex2.setDescription('This object is used only for the purpose of sending it in the trap varbind. This object is used for two purposes: 1. This object will be used when the SMIv2 table has two index objects and the 2nd object is an integer. This object will be used instead of the actual second index object. The instance value of the object will be the instance value of the actual second index. 2. In the config change trap trapVismTableChange, to send the index value of the table entry which got changed. This object will contain the value of the second integer index. The NMS applications should not depend on the implementation of this object. The SNMP Requests(GET,GET-NEXT) may not be valid for this object. ')
vismTrapStrIndex1 = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 5, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 66))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismTrapStrIndex1.setStatus('mandatory')
if mibBuilder.loadTexts: vismTrapStrIndex1.setDescription('This object is used only for the purpose of sending it in the trap varbind. This object is used for two purposes: 1. When the OctetString index of a SMIv2 table has to be sent, this object will be used instead of the actual index object. The instance value of the object will be the instance value of the actual index. 2. In the config change trap trapVismTableChange, to send the index value of the table entry which got changed. This object will contain the value of the first OctetString index. The NMS applications should not depend on the implementation of this object. The SNMP Requests(GET,GET-NEXT) may not be valid for this object. ')
vismAal2SubcellMuxing = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 6, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismAal2SubcellMuxing.setStatus('mandatory')
if mibBuilder.loadTexts: vismAal2SubcellMuxing.setDescription(' This object is a card level parameter for AAL2 adaptation and it identifies the mutiplexing function of the AAL2 Common Part Sublayer. When it is disabled then each CPS-Packet would fill only one or two cells with padding. (Partial fill cells) Note that the length field for each CPS-Packet can be up to 64bytes. When this option is enabled then mutiple streams of CPS-Packets are mutiplexed to a single ATM connection without partial fill unless there is time-out. Refer to ITU-T I.363.2 for more information. When the muxing type changes if cids are present, then we need to check for CAC voilation for all cids, if the CAC fails then the change request will be rejected else the muxing status will be changed and the vismAal2MuxingTrap will be sent and the card will be reset . All the existing connecitons will come up in new muxing type. when the muxing type changes while there are no cids then the card will NOT be reset, but the vismAal2MuxingTrap will be sent. ')
vismAal2DtmfRelay = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 6, 2), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismAal2DtmfRelay.setStatus('mandatory')
if mibBuilder.loadTexts: vismAal2DtmfRelay.setDescription(' This attribute defines whether the DTMF (Dual Tone Multi Frequency) digits need to be transported to the other end-point or not. The value in this object will be utilised when the Call Agent does not specify this in CRCX. ')
vismAal2CasTransport = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 6, 3), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismAal2CasTransport.setStatus('mandatory')
if mibBuilder.loadTexts: vismAal2CasTransport.setDescription('This attribute defines whether the CAS (ABCD bits) bits need to be transported to the other endpoint. In the case of switching application, the CAS bits are backhauled to the Call Agent through xGCP-CAS protocol. The value in this object will be utilised when the Call Agent does not specify this in CRCX. ')
vismAal2Type3Redundancy = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 6, 4), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismAal2Type3Redundancy.setStatus('mandatory')
if mibBuilder.loadTexts: vismAal2Type3Redundancy.setDescription('This attribute defines whether the triple redundancy is supported for type 3 packets in AAL2 SVC/PVC . When Triple redundancy is enabled , the type 3 packets (CAS bits, dialled digits and user state control packets) are transmitted in triplicates with an interval defined as per the standards I.366.2. For channels which are quite reliable, triple redundancy can be disabled in order to save the bandwidth and the processing overheads. The value in this object will be utilised when the Call Agent does not specify this in CRCX. ')
vismAal2VADTimer = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 6, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(250, 65535)).clone(250)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismAal2VADTimer.setStatus('mandatory')
if mibBuilder.loadTexts: vismAal2VADTimer.setDescription('This attribute defines the hangover time for VAD in milliseconds. Once the voice inactivity is detected, the gateway will wait for this duration before activating silence suppression on an AAL2 SVC/PVC. The value in this object will be utilised when the Call Agent does not specify this in CRCX. ')
vismAal2CidFillTimer = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 6, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 100)).clone(30)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismAal2CidFillTimer.setStatus('mandatory')
if mibBuilder.loadTexts: vismAal2CidFillTimer.setDescription(' This attribute defines the time (millisecs) to wait for filling up the cell when the next packet is not ready. After waiting for the time configured in this object, the cell will be sent out. This timer has no effect when vismAal2SubcellMuxing is disabled. This object is applicable only for aal2 adaptations. ')
vismChanCnfGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 1, 1), )
if mibBuilder.loadTexts: vismChanCnfGrpTable.setStatus('mandatory')
if mibBuilder.loadTexts: vismChanCnfGrpTable.setDescription('The channel config table for voice traffic. ')
vismChanCnfGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 1, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "vismCnfChanNum"))
if mibBuilder.loadTexts: vismChanCnfGrpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vismChanCnfGrpEntry.setDescription('An entry for each voice channel. ')
vismCnfChanNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(131, 510))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismCnfChanNum.setStatus('mandatory')
if mibBuilder.loadTexts: vismCnfChanNum.setDescription('Logical Channel Number for the PVC. ')
vismChanRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("add", 1), ("del", 2), ("mod", 3), ("outOfService", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismChanRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vismChanRowStatus.setDescription(" An entry is created by setting this object to add. Once the entry is added, the value mod is returned for successive GETs. The value mod is used to modify an existing entry. An entry is deleted by setting this object to del. Setting this object to outOfService takes the channel out of service or brings the channel 'down'. The channel can be brought 'up' again by setting the object to mod. If there is redundant configuration for the channel, an active channel can be deleted only after locking the channel. ")
vismChanPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 1, 1, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismChanPortNum.setStatus('mandatory')
if mibBuilder.loadTexts: vismChanPortNum.setDescription(' This refers to the virtual port between VISM and PXM. This number is defaulted to the appropriate number for the shelf. (1 for PXM1 and 255 for PXM1E) ')
vismChanLocRmtLpbkState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismChanLocRmtLpbkState.setStatus('mandatory')
if mibBuilder.loadTexts: vismChanLocRmtLpbkState.setDescription('Loopback on cellbus in egress direction. This variable enables or disables the remote loopback for each channel. When you enable this option on a connection (channel) then all the cells that are coming from the network side would be looped back toward the network and all the frames coming from the user side would be dropped. ')
vismChanTestType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("testcon", 1), ("testdelay", 2), ("notest", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismChanTestType.setStatus('mandatory')
if mibBuilder.loadTexts: vismChanTestType.setDescription('This is the type of the test. 1 = Test Continuity 2 = Test Delay 3 = No test notest is meant for GET only. While doing a SET on this object, the SET request should contain only this parameter and no other MIB objects in this table. ')
vismChanTestState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("passed", 1), ("failed", 2), ("inprogress", 3), ("notinprogress", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismChanTestState.setStatus('mandatory')
if mibBuilder.loadTexts: vismChanTestState.setDescription('This shows the state of the test. ')
vismChanRTDResult = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismChanRTDResult.setStatus('mandatory')
if mibBuilder.loadTexts: vismChanRTDResult.setDescription('This is round trip delay in milliseconds. ')
vismChanPvcType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("aal-5", 1), ("aal-2", 2), ("aal-1", 3))).clone('aal-5')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismChanPvcType.setStatus('mandatory')
if mibBuilder.loadTexts: vismChanPvcType.setDescription('PVC type. In VISM 1.0 pvc type VoIP was supported. It has been deprecated in the current release. This is a mandatory parameter when adding a PVC. ')
vismChanConnType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("pvc", 1))).clone('pvc')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismChanConnType.setStatus('mandatory')
if mibBuilder.loadTexts: vismChanConnType.setDescription('Connection type. ')
vismLocalVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismLocalVpi.setStatus('mandatory')
if mibBuilder.loadTexts: vismLocalVpi.setDescription('This VPI together with the local VCI and NSAP represents the local end point in this connection. GET on this object returns value=0. ')
vismLocalVci = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismLocalVci.setStatus('mandatory')
if mibBuilder.loadTexts: vismLocalVci.setDescription('This VCI together with the local VPI and NSAP represents the local end point in this connection. GET on this object returns the vismCnfChanNum or LCN. ')
vismLocalNSAP = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 1, 1, 1, 12), OctetString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismLocalNSAP.setStatus('mandatory')
if mibBuilder.loadTexts: vismLocalNSAP.setDescription('This NSAP is 20 bytes binary, among these 20 bytes: 13 bytes as prefix(node name), 2 bytes for Cisco ID, 1 byte rsvd, 3 bytes for logical interface: slot (1 byte) and port number (2 bytes), the last byte is for SEL. ')
vismRemoteVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 1, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismRemoteVpi.setStatus('mandatory')
if mibBuilder.loadTexts: vismRemoteVpi.setDescription('This VPI together with the remote VCI and NSAP represents the remote end point in this connection. This parameter is required only if vismMastership is set to master. ')
vismRemoteVci = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 1, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismRemoteVci.setStatus('mandatory')
if mibBuilder.loadTexts: vismRemoteVci.setDescription('This VCI together with the remote VPI and NSAP represents the remote end point in this connection. This parameter is required only if vismMastership is set to master. ')
vismRemoteNSAP = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 1, 1, 1, 15), OctetString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismRemoteNSAP.setStatus('mandatory')
if mibBuilder.loadTexts: vismRemoteNSAP.setDescription('This NSAP is 20 bytes binary, among these 20 bytes: 13 bytes as prefix, 2 bytes for Cisco ID, 1 byte rsvd, 3 bytes for logical interface: slot (1 byte) and port number (2 bytes), the last byte is for SEL. This parameter is required only if vismMastership is set to master. This object contains the NSAP address of the cross-connect (PXM/AUSM). ')
vismMastership = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 1, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("master", 1), ("slave", 2), ("unknown", 3))).clone('master')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismMastership.setStatus('mandatory')
if mibBuilder.loadTexts: vismMastership.setDescription(' This is used by PXM to determine if this end point is master or slave. For VoIP channel, the value is master (1). ')
vismVpcFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 1, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2))).clone(namedValues=NamedValues(("vcc", 2))).clone('vcc')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismVpcFlag.setStatus('mandatory')
if mibBuilder.loadTexts: vismVpcFlag.setDescription(' This is used by PXM to identify the connection type. ')
vismConnServiceType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 1, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("cbr", 1), ("vbr-rt", 2), ("vbr-nrt", 3), ("vbr3-rt", 4), ("vbr2-rt", 5), ("vbr2-nrt", 6), ("vbr3-nrt", 7))).clone('cbr')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismConnServiceType.setStatus('mandatory')
if mibBuilder.loadTexts: vismConnServiceType.setDescription('This specifies the class of service or service type 1 ==> Constant Bit Rate 2 ==> Variable Bit Rate 1 (Real Time) Although, VISM does not do any kind of traffic shaping, the PVC has to be specified as vbr-rt for PXM to treat the connection as a VBR1 connection. Variable Bit Rate is not currently supported. 3 ==> Variable Bit Rate 1 (non real time) VISM has to support all these kinds of traffic rates from Indiana release onwards The service type of the connection cannot be modified once the PVC is added. 4 ==> Variable Bit Rate 3 (Real Time) Although, VISM does not do any kind of traffic shaping, the PVC has to be specified as vbr3-rt for PXM to treat the connection as a VBR3 connection. Variable Bit Rate is not currently supported. 5 ==> Variable Bit Rate 2 (Real Time) Although, VISM does not do any kind of traffic shaping, the PVC has to be specified as vbr2-rt for PXM to treat the connection as a VBR2 connection. Variable Bit Rate is not currently supported. 6 ==> Variable Bit Rate 2 (non real time) VISM has to support all these kinds of traffic rates from Indiana release onwards The service type of the connection cannot be modified once the PVC is added. 7 ==> Variable Bit Rate 3 (non real time) VISM has to support all these kinds of traffic rates from Indiana release onwards The service type of the connection cannot be modified once the PVC is added. ')
vismRoutingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 1, 1, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15)).clone(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismRoutingPriority.setStatus('mandatory')
if mibBuilder.loadTexts: vismRoutingPriority.setDescription(' This is used by PXM to determine how important this connection is when selecting connections to route. ')
vismMaxCost = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 1, 1, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismMaxCost.setStatus('mandatory')
if mibBuilder.loadTexts: vismMaxCost.setDescription(" Maximum allowed cost. It is related to Cost Based Routing. This is used by PXM so that it won't choose a path with a cost greater than this configured level. This is not necessary to be provided in the connection setup request, if not provided, the default value 255 will be used. When used with PAR controller the valid range is 1..65535 and the default value is 255. When used with PNNI controller the valid range is 1..2147483647 and the default value is 2147483647. ")
vismRestrictTrunkType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 1, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noresriction", 1), ("terrestrialTrunk", 2), ("sateliteTrunk", 3))).clone('noresriction')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismRestrictTrunkType.setStatus('mandatory')
if mibBuilder.loadTexts: vismRestrictTrunkType.setDescription(' Restricted trunk type for routing, used by PXM. It specifies that the connection either cannot be routed over satelite trunks, or terrestrial trunks, or it can be on any type of trunk. It is not necessary to be provide in the connection setup request, the default value is noresriction(1). ')
vismConnPCR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 1, 1, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismConnPCR.setStatus('mandatory')
if mibBuilder.loadTexts: vismConnPCR.setDescription('This indicates bandwidth(Peak Cell Rate) in cells per second from the local end i.e in the ingress direction of the PVC. For a VoIP bearer PVC, the max value is 75600 cps. For a VoIP control PVC, the max value is 24400 cps. For AAL2 PVCs, the PCR to be specified has to be computed based on: a) The no. of channels multiplexed on an AAL2 PVC b) The Codec (Compression Algorithm) used. c) The VAD factor d) Partial fill factor. For a AAL2 bearer PVC, the max value is 60,000 cps on E1 card and 50,000 cps on T1 card. For a signaling PVC, the max value is 400 cps. This is a mandatory parameter when adding a PVC. Hence a default value is not applicable. This parameter can not be changed when there are calls active on the PVC. From Indiana release onwards For a VOIP bearer PVC the max allowed value is 80000 For a VOIP control PVC the max allowed value is 20000 increased as we will allow 248 endpoints. For Aal2 the values remain the same 50000/60000. For vbr connections the minimum value of PCR is 15. ')
vismConnPercentUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 1, 1, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100)).clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismConnPercentUtil.setStatus('mandatory')
if mibBuilder.loadTexts: vismConnPercentUtil.setDescription('This is the expected long-term utilization of the channel by this end-point. Currently only 100 is allowed. ')
vismConnRemotePCR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 1, 1, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismConnRemotePCR.setStatus('mandatory')
if mibBuilder.loadTexts: vismConnRemotePCR.setDescription('This indicates bandwidth(Peak Cell Rate) from the other end i.e in the egress direction of the PVC. This value is expressed in units of cells per second. If not set, will be set to the same as local end PCR. From Indiana release onwards The range of this object is 1..100000 ')
vismConnRemotePercentUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 1, 1, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100)).clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismConnRemotePercentUtil.setStatus('mandatory')
if mibBuilder.loadTexts: vismConnRemotePercentUtil.setDescription('This is the expected long-term utilization of the channel by the other end-point. Currently only 100 is allowed. ')
vismChanProtection = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 1, 1, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("protected", 1), ("unprotected", 2))).clone('unprotected')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismChanProtection.setStatus('mandatory')
if mibBuilder.loadTexts: vismChanProtection.setDescription('This object is used to configure a PVC protection group (or redundant group) with the PVCs protecting each other. Currently only two PVCs are supported in a protection group. One of them is primary and the other one is secondary. This is intended for PVCs designated to carry control traffic and needs to be protected. (However the same PVC may also be used to carry VoIP bearer traffic or other traffic). Channels that are protected share the following characteristics: 1. They are monitored for their health (including emission of traps in case of state changes) 2. An active channel is protected by another protected channel which is standby. This means when an active channel fails, switchover to another channel will happen if one is available. 3. It is also possible to do a forced switchover (through locking). Even in the case of forced switchover, switchover to another channel, which is in standby, will happen. 4. Channels may be locked to force switchover and/or to take the channel out of service in a graceful fashion. This object takes the default value of unprotected during the creation of the table entry. Once the primary and secondary channels have been created as unprotected channels, they can be protected by doing a SET on the primary channel by specifying the vismChanProtection as protected and by specifying the vismChanFallbackLcn as the LCN number of the secondary channel. The sequence of operations for setting up the protection group is: step 1: Add primary channel as unprotected step 2: Add secondary channel as unprotected. The PCR value for the secondary should be the same as that of the primary. step 3: Do a SET on the primary channel with vismChanProtection set to protected and vismChanFallbackLcn set to the LCN number of the secondary channel. This operation sets-up the protection group. The primary channel becomes active and the secondary channel becomes standby. Please note that all the cac releated parameters for the both the PVCs in the protecting group should be same. In other words the vismChanCacMaster vismChanCarrierLossPolicy, vismChanCacRejectionPolicy, VAD tolerance etc.. should have the same value for the PVCs that are protecting each other, else the set request to protect two channels will be rejected. Once the protection group is setup, if the active channel fails, it automatically switches over to the standby. The standby channel then becomes active. The channels can be removed from the protection group by setting this object to unprotected. Deletion of a protected channel is not allowed. Channels have to be removed from the protection group first before deleting. The sequence of operations for deleting protected channels is: step 1: Remove the channels from the protection group by setting vismChanProtection to unprotected. step 2: Delete secondary channel. step 3: Delete primary channel. ')
vismChanPreference = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 1, 1, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("primary", 1), ("secondary", 2))).clone('primary')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismChanPreference.setStatus('mandatory')
if mibBuilder.loadTexts: vismChanPreference.setDescription('This object is used to identify a PVC as primary or secondary. The primary PVC should be added before the secondary. Similarly secondary should be deleted before deleting the primary. When the protection group is setup, the primary becomes active and secondary becomes standby. The distinction of primary and secondary is meaningful only if the PVC is protected. This is a mandatory parameter when adding a PVC. ')
vismChanActivityState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 1, 1, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("active", 1), ("standby", 2), ("failed", 3), ("unknown", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismChanActivityState.setStatus('mandatory')
if mibBuilder.loadTexts: vismChanActivityState.setDescription('Indicates whether the PVC is currently used to carry IP traffic or not, and whether it has failed. The possible states are: active - Channel is healthy and is currently designated to carry IP traffic. A channel can only be active if it is also unlocked. standby - Channel is healthy but not designated to carry IP traffic. Switchover to this channel is allowed. failed - Channel is unable to carry any traffic. unknown - Channel is unprotected and hence health of the channel is not monitored. The default value upon creation of the row will be standby for a protected channel and unknown for an unprotected channel. VISM may then transition a protected channel to active if it determines that this channel should be the one carrying the traffic. ')
vismChanLockingState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 1, 1, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("unlock", 1), ("lock", 2))).clone('unlock')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismChanLockingState.setStatus('mandatory')
if mibBuilder.loadTexts: vismChanLockingState.setDescription('This object is used to control the switchover of protected channels. The possible values are: unlock - Transition state to unlock. A channel which is in lock state has to be brought to unlock state for it to be available for switchover. Whether a switchover to a channel is allowed or not is dependent on both vismChanActivityState and vismChanLockingState. A switchover is allowed if its vismChanActivityState is standby and its vismChanLockingState is unlock. Changing the vismChanLockingState to unlock does not cause a change in the vismChanActivityState. A channel which is in unlock state may carry traffic depending on its activity state (active or standby). lock - Transition state to lock. If the activity state is active, it transitions to standby and a switchover occurs to another channel which is standby and unlocked. When a channel is in lock state, switchover to this channel is not allowed. A channel which is in lock state, is always in either standby or failed state. Hence it will not carry any traffic. Switchover to a channel which is in lock state is not allowed. The default value of this object is unlock. It can be set to locked to force a switchover and/or to perform maintenance operations related to that channel. A channel that is unprotected will always be in unlock state. It can not be set to lock state. ')
vismChanScrIngress = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 1, 1, 1, 30), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismChanScrIngress.setStatus('mandatory')
if mibBuilder.loadTexts: vismChanScrIngress.setDescription(' This object defines the SCR (Sustained Cell Rate) for the PVC. SCR is used for vbr connection types only. Although, based on the value of SCR, any kind of traffic shaping is not done on the VISM card, this value is useful for setting up the parameters for the end-to-end PVC. This value is expressed in units of cells per second. This object defines the SCR value for the ingress direction of the PVC. From Indiana release onwards For a VOIP bearer PVC the max value is 80000 For a VOIP control PVC the max value is 20000 increased as we will allow 248 endpoints. For Aal2 the values remain the same (50000/60000). If the user provides a value that is greater than vismConnPCR then the SET request will be rejected. For vbr connections the allowed range of values of SCR is from 15 - PCR. ')
vismChanMbsIngress = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 1, 1, 1, 31), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismChanMbsIngress.setStatus('mandatory')
if mibBuilder.loadTexts: vismChanMbsIngress.setDescription(' This object defines the MBS (Max. Burst Size) in cells per second. This object is meaningful for VBR connections only. This object defines the MBS value for the ingress direction of the PVC. The MBS value cannot be greater than 10 times vismChanSCRIngress value. ')
vismChanClrIngress = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 1, 1, 1, 32), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismChanClrIngress.setStatus('mandatory')
if mibBuilder.loadTexts: vismChanClrIngress.setDescription(' This object defines the CLR (Cell Loss Ratio) for the PVC. This field is also meaningful for VBR connections only. This object defines the CLR value for the ingress direction of the PVC. ')
vismChanCdvt = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 1, 1, 1, 33), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 30)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismChanCdvt.setStatus('mandatory')
if mibBuilder.loadTexts: vismChanCdvt.setDescription(' This object defines the CDVT (Cell Delay Variation Tolerance) for the connection. CDVT is useful for detemining the playout buffer size in the DSPs. This object is applicable only in AAL1 adaptation. For AAL2, the equivalent of this parameter, known as PDVT (Packet Delay Variation Tolerance) is internally derived. ')
vismConnPCREgress = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 1, 1, 1, 34), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismConnPCREgress.setStatus('mandatory')
if mibBuilder.loadTexts: vismConnPCREgress.setDescription(' This object defines the PCR (Peak Cell Rate) for the PVC. PCR is applicable to all connection service types ie. CBR, RT-VBR and nRT-VBR. This value is expressed in units of cells per second. This object defines the PCR value for the egress direction of the PVC. This is a mandatory parameter when adding a PVC. ')
vismChanScrEgress = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 1, 1, 1, 35), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismChanScrEgress.setStatus('mandatory')
if mibBuilder.loadTexts: vismChanScrEgress.setDescription(' This object defines the SCR (Sustained Cell Rate) for the PVC. SCR is used for vbr connection types only. Although, based on the value of SCR, any kind of traffic shaping is not done on the VISM card, this value is useful for setting up the parameters for the end-to-end PVC. This value is expressed in units of cells per second. This object defines the SCR value for the egress direction of the PVC. From Indiana release onwards the range of this object has been increased to 100000. ')
vismChanMbsEgress = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 1, 1, 1, 36), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismChanMbsEgress.setStatus('mandatory')
if mibBuilder.loadTexts: vismChanMbsEgress.setDescription(' This object defines the MBS (Max. Burst Size) in cells per second. This object is meaningful for VBR connections only. This object defines the MBS value for the egress direction of the PVC. ')
vismChanClrEgress = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 1, 1, 1, 37), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismChanClrEgress.setStatus('mandatory')
if mibBuilder.loadTexts: vismChanClrEgress.setDescription(' This object defines the CLR (Cell Loss Ratio) for the PVC. This field is also meaningful for VBR connections only. This object defines the MBS value for the egress direction of the PVC. ')
vismChanApplication = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 1, 1, 1, 38), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("control", 1), ("bearer", 2), ("signaling", 3))).clone('bearer')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismChanApplication.setStatus('mandatory')
if mibBuilder.loadTexts: vismChanApplication.setDescription(' This object defines the application that the LCN is used for. There are 4 types of PVCs known so far: 1 - Control PVC used for carrying control traffic only (SGCP packets) 2 - bearer PVC, used for carrying voice payload traffic only 3 - signaling PVC, used for carrying the signaling protocol messages This is a mandatory parameter when adding a PVC. ')
vismChanFallbackLcn = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 1, 1, 1, 39), Integer32().subtype(subtypeSpec=ValueRangeConstraint(131, 510))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismChanFallbackLcn.setStatus('mandatory')
if mibBuilder.loadTexts: vismChanFallbackLcn.setDescription(' This object defines the LCN to be used as a fallback mechanism, in case the primary PVC fails. This is applicable if the PVC is configured for redundancy. The redundancy is applicable for both applications i.e control PVC and bearer PVC. This object is applicable only if the vismChanProtection is set to protected. It is mandatory if the PVC is protected. ')
vismChanReroute = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 1, 1, 1, 40), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismChanReroute.setStatus('mandatory')
if mibBuilder.loadTexts: vismChanReroute.setDescription(' This is used by the administrator to trigger the re-routing of the connection. The rerouting takes effect, when this object is set to true(1). When set to false (2), no action is taken. A get on this object always returns false (2). ')
vismFarEndAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 1, 1, 1, 41), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notapplicable", 1), ("nsap", 2), ("e164", 3), ("gwid", 4), ("unspecified", 5))).clone('notapplicable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismFarEndAddressType.setStatus('mandatory')
if mibBuilder.loadTexts: vismFarEndAddressType.setDescription(' The address type can be one of five types: NSAP, E164, GWID, notapplicable or unspecified. It determines which object contains the scope for the VCCI, i.e. whether the VCCI needs to be unique relative to NSAP, E164 address or GWID. In case of nsap, object vismFarEndNSAPAddress contains the address. In case of e164, object vismFarEndE164Address contains the address. In case of gwid, object vismFarEndGWIDAddress contains the address. In case this object is set to notapplicable, no valid addresses are required and no validation of VCCI uniqueness for a remote address is performed. In case this object is set to unspecified, no valid addresses are required but VCCI needs to be unique. While this object is writeable, it is recommended not to change the value of this object once it has been created. However, upon modification to any value other than notapplicable, it will be ensured that the resulting combination of VCCI and remote address is unique. Requests that would result in a non-unique combination will be rejected. If the vismFarEndAddressType is one of nsap, e164 or gwid, the far end address has to be specified. ')
vismFarEndE164Address = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 1, 1, 1, 42), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismFarEndE164Address.setStatus('mandatory')
if mibBuilder.loadTexts: vismFarEndE164Address.setDescription(" The E.164 address of the far end peer. The address is expressed as decimal numbers with up to 15 digits. If the vismFarEndAddressType is different from e164, this object is not applicable and it should be ignored. This object serves as the scope for VCCI identifiers (vismVCCI) if vismFarEndAddressType is equal to e164. In that case, the combination of (vismFarEndE164Address, vismVCCI) will always be unique for any given agent. It thus constitutes a label denoting the scope for a VCCI address space; it has no purpose otherwise. While this object is writeable, it is recommended not to change the value of this object once it has been created. However, upon modification, it will be ensured that the resulting combination of VCCI and remote E164 address is unique (as long as the remote address type is E164). Requests that would result in a non-unique combination will be rejected. Beyond this, there are no other integrity constraints that will be enforced for this object. This includes network-level consistency with the actual address of the remote peer. The value of this object cannot be modified when there are active calls on this PVC. The valid characters allowed are '0..9'. ")
vismFarEndGWIDAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 1, 1, 1, 43), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismFarEndGWIDAddress.setStatus('mandatory')
if mibBuilder.loadTexts: vismFarEndGWIDAddress.setDescription(' The gateway ID of the far end peer. The address is expressed as ASCII characters. If the vismFarEndAddressType is different from gwid, this object is not applicable and it should be ignored. This object serves as the scope for VCCI identifiers (vismVCCI) if vismFarEndAddressType is equal to gwid. In that case, the combination of (vismFarEndGWIDAddress, vismVCCI) will always be unique for any given agent. It thus constitutes a label denoting the scope for a VCCI address space; it has no purpose otherwise. While this object is writeable, it is recommended not to change the value of this object once it has been created. However, upon modification, it will be ensured that the resulting combination of VCCI and far end GWID address is unique (as long as the vismFarEndAddress type is GWID). Requests that would result in a non-unique combination will be rejected. Beyond this, there are no other integrity constraints that will be enforced for this object. This includes network-level consistency with the actual address of the remote peer. The value of this object cannot be modified when there are active calls on this PVC. All ASCII characters are allowed by this object. ')
vismFarEndNSAPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 1, 1, 1, 44), OctetString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismFarEndNSAPAddress.setStatus('mandatory')
if mibBuilder.loadTexts: vismFarEndNSAPAddress.setDescription(' This object contains the 20 byte NSAP address of the far end peer. If the vismFarEndAddressType is different from nsap, this object is not applicable and it should be ignored. This object serves as the scope for VCCI identifiers (vismVCCI) if vismFarEndAddressType is equal to nsap. In that case, the combination of (vismFarEndNSAPAddress, vismVCCI) will always be unique for any given agent. It thus constitutes a label denoting the scope for a VCCI address space; it has no purpose otherwise. While this object is writeable, it is recommended not to change the value of this object once it has been created. However, upon modification, it will be ensured that the resulting combination of VCCI and far end NSAP address is unique (as long as the far end address type is GWID). Requests that would result in a non-unique combination will be rejected. Beyond this, there are no other integrity constraints that will be enforced for this object. This includes network-level consistency with the actual address of the remote peer. The value of this object cannot be modified when there are active calls on this PVC. When the user adds a connection, by default the value of this object will be set to vismRemoteNSAP, unless the user specifies a value for this object. This object is represented as hex (0 .. 9,A .. F) ')
vismVCCI = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 1, 1, 1, 45), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismVCCI.setStatus('mandatory')
if mibBuilder.loadTexts: vismVCCI.setDescription(' The VCCI, or Virtual Circuit Connection Identifier, is a variable that identifies a virtual circuit connection between two nodes. A virtual circuit connection, or VCC, consists of one virtual circuit link or a series of concatenated virtual circuit links. In its most common usage, the value of the VCCI is unique between the nodes at the extremities of the virtual circuit connection, but not on a network-wide basis. Hence, its value needs to be qualified by the ATM addresses of these end nodes. At one of these end nodes, its value needs to be qualified by the ATM address of the far-end node. Some applications can extend this definition to make the VCCI value unique on a network- wide basis. This is specially possible when VCCIs are administered from a management system and not locally assigned by a node. In this MIB, the VCCI serves as a label to be assigned by an external application. VCCIs need to be unique for a given remote peer, however, the same VCCI can be reused for different remote peers. Accordingly, the combination of (remote address, VCCI) will always be unique for any given agent. This allows a controller to refer to a VC by the VCCI and remote peer address, in contrast to VPI/VCI and port. It thus constitutes a convenience feature, providing an alternative identification scheme for a VC which is managed by an outside user, such as a management system. The remote peer address can be specified in NSAP, E.164, or GWID format, as indicated by the address type (vismRemoteAddressType). Depending on the address type specified, uniqueness will be relative to NSAP, E.164 address, or GWID. While this object is writeable, it is recommended not to change the value of this object once it has been created. However, upon modification, it will be ensured that the resulting combination of VCCI and remote address is unique. Requests that would result in a non-unique combination will be rejected. Beyond this, there are no other integrity constraints that will be enforced for this object. This includes network-level consistency whether the remote peer, or an external controller, use the same VCCI designation for the VC. ')
vismConnAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 1, 1, 1, 46), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismConnAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vismConnAdminStatus.setDescription('This object specifies channel administration status. ')
vismChanNumNextAvailable = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 510))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismChanNumNextAvailable.setStatus('mandatory')
if mibBuilder.loadTexts: vismChanNumNextAvailable.setDescription('This variable contains the next unused channel number. When channels are available the range is 32..510. This number can be used in channel config table. Value 0 for this variable indicates that no more channels are available. ')
vismChanStateGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 2))
vismChanStateGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 2, 1), )
if mibBuilder.loadTexts: vismChanStateGrpTable.setStatus('mandatory')
if mibBuilder.loadTexts: vismChanStateGrpTable.setDescription('voice connection state table ')
vismChanStateGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 2, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "vismStateChanNum"))
if mibBuilder.loadTexts: vismChanStateGrpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vismChanStateGrpEntry.setDescription(' An entry for each channel (PVC) ')
vismStateChanNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(131, 510))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismStateChanNum.setStatus('mandatory')
if mibBuilder.loadTexts: vismStateChanNum.setDescription('Refers to the channel Number LCN. ')
vismChanState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notConfigured", 1), ("okay", 2), ("alarm", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismChanState.setStatus('mandatory')
if mibBuilder.loadTexts: vismChanState.setDescription(' Channel status. ')
vismChanXmtATMState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("normal", 2), ("sendingAIS", 3), ("sendingFERF", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismChanXmtATMState.setStatus('mandatory')
if mibBuilder.loadTexts: vismChanXmtATMState.setDescription(' This variable indicates the transmit state of channel on the ATM side(towards the network). ')
vismChanRcvATMState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("normal", 2), ("receivingAIS", 3), ("receivingFERF", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismChanRcvATMState.setStatus('mandatory')
if mibBuilder.loadTexts: vismChanRcvATMState.setDescription(' This variable indicates the receive state of channel on the ATM side(from the network). ')
vismChanStatusBitMap = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismChanStatusBitMap.setStatus('mandatory')
if mibBuilder.loadTexts: vismChanStatusBitMap.setDescription('This variable indicates the consolidated bit map of the channel alarm state. Individual bit positions are as defined below, all reserved bits will be set to zero. Bit position Fail/Alarm Reason ------------ ---------- ------ 0 Alarm Reserved 1 Alarm n/w side CC failure/AIS/RDI Rx 2 Fail Conditioned (Abit from n/w) 3 Alarm Reserved 4 Fail Reserved 5 Fail Reserved 6 Alarm Reserved 7 Alarm Reserved Fail bitmap mask : 0x34 Alarm bitmap mask: 0xCB ')
vismChanCntGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 3))
vismChanCntGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 3, 1), )
if mibBuilder.loadTexts: vismChanCntGrpTable.setStatus('mandatory')
if mibBuilder.loadTexts: vismChanCntGrpTable.setDescription('vism channel counters table. This table gets implicitly created and deleted at the time of creation and deletion of ChanCnfGrp. ')
vismChanCntGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 3, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "vismCntChanNum"))
if mibBuilder.loadTexts: vismChanCntGrpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vismChanCntGrpEntry.setDescription(' An entry for each voice channel. ')
vismCntChanNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(131, 510))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismCntChanNum.setStatus('mandatory')
if mibBuilder.loadTexts: vismCntChanNum.setDescription('Refers to the logical channel Number. ')
vismCntClrButton = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noAction", 1), ("resetCounters", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismCntClrButton.setStatus('mandatory')
if mibBuilder.loadTexts: vismCntClrButton.setDescription('writing a value of 2 resets all the counters. ')
vismChanAal2HecErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 3, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismChanAal2HecErrors.setStatus('mandatory')
if mibBuilder.loadTexts: vismChanAal2HecErrors.setDescription('The count of egress AAL2 CPS(Common Part Sub-layer) PDUs dropped due to HEC (Header Error Control) error. ')
vismChanAal2CrcErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 3, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismChanAal2CrcErrors.setStatus('mandatory')
if mibBuilder.loadTexts: vismChanAal2CrcErrors.setDescription('The count of egress AAL2 type3 CPS PDUs dropped due to invalid CRC-10 error. CRC validation is for type 3 packets only. Type 1 packets are not subjected to CRC-10 error validation. Also this counter keeps track of CRC-10 errors for the type 3 packets which are generated by the the datamover CPU only. It does not take into account of type3 packets generated by the DSPs. ')
vismChanAal2OamLpbLostCells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 3, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismChanAal2OamLpbLostCells.setStatus('mandatory')
if mibBuilder.loadTexts: vismChanAal2OamLpbLostCells.setDescription('The count of OAM loopback cells lost. OAM loopback cells are sent on a periodic basis (1sec) on each PVC to monitor the health of the PVC. This is applicable for all PVCs. ')
vismChanAal2InvOsfCells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 3, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismChanAal2InvOsfCells.setStatus('mandatory')
if mibBuilder.loadTexts: vismChanAal2InvOsfCells.setDescription('The Number of AAL2 cells dropped due to invalid OSF (OffSet Field) in the egress direction. ')
vismChanAal2InvParCells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 3, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismChanAal2InvParCells.setStatus('mandatory')
if mibBuilder.loadTexts: vismChanAal2InvParCells.setDescription('The Number of AAL2 cells dropped due to invalid Parity bit field in the egress direction. ')
vismChanAal2CpsSentPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 3, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismChanAal2CpsSentPkts.setStatus('mandatory')
if mibBuilder.loadTexts: vismChanAal2CpsSentPkts.setDescription('The count of AAL2 CPS packets sent to the network. ')
vismChanAal2CpsRcvdPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 3, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismChanAal2CpsRcvdPkts.setStatus('mandatory')
if mibBuilder.loadTexts: vismChanAal2CpsRcvdPkts.setDescription('The count of AAL2 CPS packets received from the network. This does not include the packets which are counted as error packets. ')
vismChanAal2CpsInvCidPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 3, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismChanAal2CpsInvCidPkts.setStatus('mandatory')
if mibBuilder.loadTexts: vismChanAal2CpsInvCidPkts.setDescription('The count of AAL2 CPS packets dropped in the egress direction due to invalid CID (Channel ID). The CID may be considered as invalid if - a) It is out of range. b) It is not configured ')
vismChanAal2CpsInvUuiPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 3, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismChanAal2CpsInvUuiPkts.setStatus('mandatory')
if mibBuilder.loadTexts: vismChanAal2CpsInvUuiPkts.setDescription('The count of AAL2 CPS packets dropped in the egress direction due to invalid UUI (User-to-User Info.) field. ')
vismChanAal2CpsInvLenPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 3, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismChanAal2CpsInvLenPkts.setStatus('mandatory')
if mibBuilder.loadTexts: vismChanAal2CpsInvLenPkts.setDescription('The count of AAL2 CPS packets dropped in the egress direction due to invalid length field. ')
vismChanAal5InvCpiPdus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 3, 1, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismChanAal5InvCpiPdus.setStatus('mandatory')
if mibBuilder.loadTexts: vismChanAal5InvCpiPdus.setDescription('The count of AAL5 PDUs dropped in the egress direction due to invalid CPI (common part indicator) field in the AAL5 PDU trailer. This is applicable only to the PVCs configured as AAL5 PVCs (VoIP PVCs or CCS PVCs in the case of VoAAL2 application). ')
vismChanAal5OversizedSdusRcvdPdus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 3, 1, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismChanAal5OversizedSdusRcvdPdus.setStatus('mandatory')
if mibBuilder.loadTexts: vismChanAal5OversizedSdusRcvdPdus.setDescription('The count of AAL5 PDUs dropped due to the SDU size bigger than the configured value. This is applicable for AAL5 PVCs only. ')
vismChanAal5InvLenPdus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 3, 1, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismChanAal5InvLenPdus.setStatus('mandatory')
if mibBuilder.loadTexts: vismChanAal5InvLenPdus.setDescription('The count of AAL5 PDUs dropped due to the length violations. This is applicable to the CCS PVCs. The HDLC frames should have a minimum frame size in order for the proper interpretation by the upper layer protocol. ')
vismChanAal5Crc32ErrorPdus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 3, 1, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismChanAal5Crc32ErrorPdus.setStatus('mandatory')
if mibBuilder.loadTexts: vismChanAal5Crc32ErrorPdus.setDescription('The count of AAL5 PDUs dropped in the egress direction due to CRC-32 errors detected by the SAR. ')
vismChanAal5ReassemTimerExpiryPdus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 3, 1, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismChanAal5ReassemTimerExpiryPdus.setStatus('mandatory')
if mibBuilder.loadTexts: vismChanAal5ReassemTimerExpiryPdus.setDescription('The count of AAL5 PDU reassembly timer expirations. The timers are maintained in the egress direction for building an AAL5 PDU from the cells. ')
vismPortCnfGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 2, 1))
vismPortCnfGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 2, 1, 1), )
if mibBuilder.loadTexts: vismPortCnfGrpTable.setStatus('mandatory')
if mibBuilder.loadTexts: vismPortCnfGrpTable.setDescription('Port configuration table for the virtual port. Only one entry is allowed in this table. ')
vismPortCnfGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 2, 1, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "vismPortNum"))
if mibBuilder.loadTexts: vismPortCnfGrpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vismPortCnfGrpEntry.setDescription(' An entry for logical port. ')
vismPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 2, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismPortNum.setStatus('mandatory')
if mibBuilder.loadTexts: vismPortNum.setDescription('This is a logical port number. If PXM1 is the PXM used on the shelf this object should be set to 1. For PXM1E this object should be set to 255. . ')
vismPortRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 2, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("add", 1), ("del", 2), ("mod", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismPortRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vismPortRowStatus.setDescription('To add, del or modify a port. To add the port, this object has to be set to add, values for other objects should not be specififed (refer to Note 1). VISM will choose default values for all other objects (Note 1). Once added, the value mod is returned for a GET. To delete the port, this object has to be set to del. The port can be deleted only after deleting all the connections and the resource partition. Note 1: From VISM 2.x release onwards, vismPortRowStatus will be set to mod after adding the VISM port. Also, vismPortSpeed can be specified optionaly when VISM port is added. ')
vismPortLineNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 2, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismPortLineNum.setStatus('mandatory')
if mibBuilder.loadTexts: vismPortLineNum.setDescription('This represents the line number to which this port is associated. Since the network port is not associated with any line, line number 0 is returned on a GET. This object is currently not used and SET is not allowed on this object. ')
vismPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 2, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("voIP", 1), ("userPort", 2))).clone('voIP')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismPortType.setStatus('mandatory')
if mibBuilder.loadTexts: vismPortType.setDescription('The value of this object is always set to voIP. It indicates that it is the network port. The same value is used even when VISM supports VoAAL1 or VoAAL2. The value userPort is not applicable for VISM. SET is not allowed on this object. ')
vismPortDs0ConfigBitMap = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 2, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismPortDs0ConfigBitMap.setStatus('mandatory')
if mibBuilder.loadTexts: vismPortDs0ConfigBitMap.setDescription('This respesents the bit map of DS0s which is used to create this port. Bit 0 represents DS0-1. Since this object is not applicable to the network port, value 0 is returned on a GET. SET is not allowed on this object. ')
vismPortSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 2, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5651320)).clone(5651320)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismPortSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: vismPortSpeed.setDescription('The speed of the port in cells per second. It is used by VISM card to advertise virtual port bandwidth to the controller, SVC and PVC connection admission control and aggregate traffic clipping. This object can be modified only when there is no existing resource partition on the port. Changed from read-only to read-write from VISM2.x release. ')
vismPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 2, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notConfigured", 1), ("active", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismPortState.setStatus('mandatory')
if mibBuilder.loadTexts: vismPortState.setDescription('This object indicates the state of the port. ')
vismPortResPartCnfGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 2, 2))
vismPortResPartCnfGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 2, 2, 1), )
if mibBuilder.loadTexts: vismPortResPartCnfGrpTable.setStatus('mandatory')
if mibBuilder.loadTexts: vismPortResPartCnfGrpTable.setDescription('This table contains the configuration of port resource partition. Currently this table contains a single row. ')
vismPortResPartCnfGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 2, 2, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "vismResPartPortNum"), (0, "CISCO-WAN-AXIPOP-MIB", "vismResPartCtrlrNum"))
if mibBuilder.loadTexts: vismPortResPartCnfGrpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vismPortResPartCnfGrpEntry.setDescription('An entry for port resource partition. ')
vismResPartPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 2, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismResPartPortNum.setStatus('mandatory')
if mibBuilder.loadTexts: vismResPartPortNum.setDescription('This is the logical port number, the index to this table. If PXM1 is the PXM used on the shelf this object should be set to 1. For PXM1E this object should be set to 255. ')
vismResPartCtrlrNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 2, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("par", 1), ("pnni", 2), ("tag", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismResPartCtrlrNum.setStatus('mandatory')
if mibBuilder.loadTexts: vismResPartCtrlrNum.setDescription('This is index for controller using the port. In MGX release 1.0, the value par should be used. In MGX release 2.0, the value pnni should be used. ')
vismResPartRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 2, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("add", 1), ("del", 2), ("mod", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismResPartRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vismResPartRowStatus.setDescription('This will add, delete or modify the partition. In MGX Release1.0: To add an entry, this object should be set to add, value for other objects should not be specified. VISM will choose default values for all other objects. In MGX Release2.0: To add an entry, this object should be set to add, value for vismResPartCtrlrID may be specified. VISM will choose default values for all other objects. Currently the value mod is not supported. To delete an entry, this object has to be set to del. The resource partition can be deleted only after deleting all the connections (LCNs). ')
vismResPartNumOfLcnAvail = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 2, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 380))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismResPartNumOfLcnAvail.setStatus('mandatory')
if mibBuilder.loadTexts: vismResPartNumOfLcnAvail.setDescription('This represents number of LCNs available for this controller and this port. The default value for this object is chosen based on vismMode : default value in voipSwitching mode - 3 default value in aal2Trunking mode - 72 Currently SET is not allowed on this object. From vism2.0.3 release onwards as there is no concept of modes the number of lcns will be set to maximum of number of lcns supported. ')
vismResPartLcnLow = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 2, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(131, 510)).clone(131)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismResPartLcnLow.setStatus('mandatory')
if mibBuilder.loadTexts: vismResPartLcnLow.setDescription('This represents low end of reserved LCN. Currently SET is not allowed on this object. ')
vismResPartLcnHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 2, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(131, 510)).clone(510)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismResPartLcnHigh.setStatus('mandatory')
if mibBuilder.loadTexts: vismResPartLcnHigh.setDescription('This represents high end of reserved LCN. Currently SET is not allowed on this object. ')
vismResPartIngrPctBW = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 2, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100)).clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismResPartIngrPctBW.setStatus('mandatory')
if mibBuilder.loadTexts: vismResPartIngrPctBW.setDescription('The percentage of total ingress bandwidth reserved. Since we have only one LCN for VoIP, the value is 100. Currently SET is not allowed on this object. From vism 2.0.3 release onwards since the mode will be gone this object will be writable. ')
vismResPartEgrPctBW = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 2, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100)).clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismResPartEgrPctBW.setStatus('mandatory')
if mibBuilder.loadTexts: vismResPartEgrPctBW.setDescription('The percentage of total egress bandwidth reserved Since we have only one LCN for VoIP, the value is 100. Currently SET is not allowed on this object. From vism 2.0.3 release onwards since the mode will be gone this object will be writable. ')
vismResPartCtrlrID = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 2, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismResPartCtrlrID.setStatus('mandatory')
if mibBuilder.loadTexts: vismResPartCtrlrID.setDescription('This is the controller identifier of the PNNI controller. ')
vismChanCacTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 1, 3), )
if mibBuilder.loadTexts: vismChanCacTable.setStatus('mandatory')
if mibBuilder.loadTexts: vismChanCacTable.setDescription("This table defines the CAC success or failure statistics. CAC functionality is applied on a per PVC basis for accepting the new calls in a switching model (i.e when CRCX message is received from the Call Agent) and when adding a new binding between a CID and a PVC in the AAL2 trunking application ('addcid' command). In both switching and trunking models, the CAC functionality is applied for upspeeding the connections due to the detection of fax/modem tone on a connection configured with voice compression. ")
vismChanCacEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 1, 3, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "vismChanNum"))
if mibBuilder.loadTexts: vismChanCacEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vismChanCacEntry.setDescription(' This table is used for CAC functions on a PVC. Each entry in this table corresponds to a PVC, since the CAC functionality is applied on a per PVC basis. The bandwidth is allocated on a per PVC basis and the connection admission control is done by comparing the available bandwidth on a PVC with the required bandwidth as a result of new connection setup request or upspeed request. The entries in this table are implicitly created and deleted with the creation and deletion of entries in vismChanCnfGrpEntry. ')
vismChanNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(131, 510))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismChanNum.setStatus('mandatory')
if mibBuilder.loadTexts: vismChanNum.setDescription('This attribute defines the index for the vismChanCac Table. The LCN Number is the same as the LCN value used as the index for the vismChanCnfGrpTable i.e. vismCnfChanNum ')
vismChanCacMaster = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 1, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("master", 1), ("slave", 2))).clone('master')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismChanCacMaster.setStatus('mandatory')
if mibBuilder.loadTexts: vismChanCacMaster.setDescription('This attribute defines whether the PVC is the master end or slave end. CAC functionality is applied only at the master end of the PVC. It is not necessary if the PVC end is configured as the slave end. This is to prevent the glare condition resulting from the simulatenous allocation of the same bandwidth for different calls from both the ends. This parameter is applicable only in the trunking mode. ')
vismChanCacPassedCons = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 1, 3, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismChanCacPassedCons.setStatus('mandatory')
if mibBuilder.loadTexts: vismChanCacPassedCons.setDescription("This attribute defines the count of connections that passed successfully the CAC function. CAC functionality is applied either due to 1) The CRCX message sent to VISM from the Call Agent to set up a new connection OR at the time of 'addcid' command in AAL2 trunking application. 2) Upspeed request due to Fax/modem tone detection on a connection configured for compression. For the initial version of Alabama release, only case 2 is valid. ")
vismChanCacRejectedCons = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 1, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismChanCacRejectedCons.setStatus('mandatory')
if mibBuilder.loadTexts: vismChanCacRejectedCons.setDescription('This attribute defines the count of connections that got rejected due to CAC function. The CAC rejection was due to the bandwidth not being available on a given PVC. ')
vismChanCacRejectionPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 1, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("delete", 1), ("maintain", 2), ("unspecified", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismChanCacRejectionPolicy.setStatus('mandatory')
if mibBuilder.loadTexts: vismChanCacRejectionPolicy.setDescription("This attribute defines the policy that needs to be applied once the CAC function rejects the upspeeding of a connection, due to a fax/modem switch-over request. The applicable options are 1 - To delete the connection that got rejected by CAC for upspeed 2 - To maintain the connection with the prior compression scheme. Note that the default value of maintaining the prior encoding scheme is applicable in the trunking application only since the connection is not deleted after the fax/modem switchover. In the case of switching application, the connection is deleted after the fax/modem switchover. From Indiana release onwards by default the value of this object will be unspecified. If the value of this object is 'unspecified' then the cac rejection policy as defined in the card level object vismCacRejectionPolicy will be used, else the value of this object will be used . Configuring this object will not have any affect when card level cac is disabled (vismCacEnable). ")
vismChanCarrierLossPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 1, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("previousCodec", 1), ("upspeedCodec", 2), ("unspecified", 3))).clone('unspecified')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismChanCarrierLossPolicy.setStatus('mandatory')
if mibBuilder.loadTexts: vismChanCarrierLossPolicy.setDescription(' This object defines the policy that needs to be applied when a carrier loss is detected. This states whether to switch to the pre-upspeed codec or to remain with the upspeed codec. By default the value of this object will be unspecified in that case the card level object value (vismCarrierLossPolicy) will be used. Configuring this object will not have any affect when card level cac is disabled (vismCacEnable). ')
vismChanVADTolerance = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 1, 3, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000)).clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismChanVADTolerance.setStatus('mandatory')
if mibBuilder.loadTexts: vismChanVADTolerance.setDescription(' The value in this object refers to the customer accepted drop rate for voice connections when the bandwidth usage exceeds allowed value. The actual range of this object is 0.0001% - 1.00 % The unit is in percentage, since the default is 0.01 %, and since we cannot express such fractions in MIB , it is being multiplied by 10000 . However, when the underlying CAC module is notified of the change in this object, then the value has to be divided by a factor of 10000. Multiplication factor 10000 is picked as someone might be interested in a tolerance as low as 0.0001%. A value of zero indicates an invalid value. In that case the card level object value will be used (vismVADTolerance). Configuring this object will not have any affect when card level cac is disabled (vismCacEnable). ')
vismChanVADDutyCycle = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 1, 3, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100)).clone(61)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismChanVADDutyCycle.setStatus('mandatory')
if mibBuilder.loadTexts: vismChanVADDutyCycle.setDescription(' This object refers to the talk-spurts duty cycle. The unit is in percentage. The actual range of this object is 0.01 to 0.99 % and not 0.01 to 1.00 % as specified in the range values above. Since a value of 100 will cause a floating point exception, this value is disallowed. The default value is 0.61% and since we cannot have fractions in a MIB variable the value is being multiplied by 100 and is expressed as 61. When the value of this object is to be passed to underlying CAC module in VISM this value has to be divided by 100. A value of zero indicates an invalid value. In that case the card level object value will be used (vismVADDutyCycle). Configuring this object will not have any affect when card level cac is disabled (vismCacEnable). only value 1 - 99 is allowed to be set. ')
networkCacConfigState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 1, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("notOk", 2))).clone('ok')).setMaxAccess("readonly")
if mibBuilder.loadTexts: networkCacConfigState.setStatus('mandatory')
if mibBuilder.loadTexts: networkCacConfigState.setDescription(" This attribute defines whether the originating and terminating VISMs are configured properly or not, by default the configuration is assumed to be ok and this object is set to ok, if later during upspeed if we discover that both the originating and terminating VISMs are configured as either cac master or slave then it is considered as an invalid configuration and this object will be set to 'notOk' and trapNetworkCacConfigState change trap will be sent. This parameter is applicable only in trunking applications. ")
vismCasGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 8))
vismCasVariantTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 8, 1), )
if mibBuilder.loadTexts: vismCasVariantTable.setStatus('mandatory')
if mibBuilder.loadTexts: vismCasVariantTable.setDescription('This table contains configuration information about different CAS variants. ')
vismCasVariantEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 8, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "vismCasVariantName"))
if mibBuilder.loadTexts: vismCasVariantEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vismCasVariantEntry.setDescription('An entry in the vismCasVariantTable. Each entry consists of configuration information for a specific CAS variant. An entry may be created by specifying vismCasVariantName, and vismCasFileName. Upon the creation of the table entry, the file specified by vismCasFileName will be downloaded and the CAS finite state machine will be initialized based on the information contained in this file. ')
vismCasVariantName = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 8, 1, 1, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismCasVariantName.setStatus('mandatory')
if mibBuilder.loadTexts: vismCasVariantName.setDescription(' This object is a string identifier for the CAS variant. It is used as index to the table. The maximum length allowed is 64 bytes. ')
vismCasFileName = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 8, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(2, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismCasFileName.setStatus('mandatory')
if mibBuilder.loadTexts: vismCasFileName.setDescription(' This object gives the name of the file which contains the signal definition and the Finite State Machine definition for the CAS variant. The name is supplied during the creation of the table entry. Modifying the value of this object is not allowed. Upon the creation of the table entry, the file will be downloaded from a tftp server configured in the vismTftpServerDn object and the CAS finite state machine will be initialized based on the information contained in this file. This object must be provided in order to create en entry in this table. ')
vismCasTRinging = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 8, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 600)).clone(180)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismCasTRinging.setStatus('deprecated')
if mibBuilder.loadTexts: vismCasTRinging.setDescription(' This object gives the ringing time in seconds for the Cas Variant. The ringing will be on until this timer expires or until an off hook is received. ')
vismCasDigitMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 8, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("mf", 1), ("dtmf", 2))).clone('dtmf')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismCasDigitMethod.setStatus('mandatory')
if mibBuilder.loadTexts: vismCasDigitMethod.setDescription(' The default digit method to be used for digit collection. If the digit method can not be derived from the digit map specified by the call agent in the XGCP message, this digit method will be used. ')
vismCasInterdigitTpart = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 8, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 10000)).clone(16)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismCasInterdigitTpart.setStatus('mandatory')
if mibBuilder.loadTexts: vismCasInterdigitTpart.setDescription(' This object represents the partial dial timing in seconds and is used along with a digit map as the inter-digit timer. The timer is not started untill the first digit is entered, and the timer is restarted after each new digit is entered untill either a digit map match or mismatch occurs. ')
vismCasInterdigitTcrit = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 8, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismCasInterdigitTcrit.setStatus('mandatory')
if mibBuilder.loadTexts: vismCasInterdigitTcrit.setDescription(' This object represents the critical timing in seconds. If used along with a digit map, the timer is started when the last digit is received. i.e and when no more digits are required for a digit map match. After this timer expires, the digit map match is assumed to be complete. If used without a digit map, the timer is started immediately and cancelled (but not restarted) as soon as a digit is entered. ')
vismCasInterdigitTMF = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 8, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismCasInterdigitTMF.setStatus('mandatory')
if mibBuilder.loadTexts: vismCasInterdigitTMF.setDescription('This object represents the interdigit timeout value for MF digits. The timeout value is in seconds. ')
vismCasVariantState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 8, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notConfigured", 1), ("configInProgress", 2), ("configured", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismCasVariantState.setStatus('mandatory')
if mibBuilder.loadTexts: vismCasVariantState.setDescription('This variable indicates the configuration status of the CAS variant. When the table entry is created, downloading of the file will be initiated and the state will be set to configInProgress. Once the file is successfully downloaded and the CAS finite state machine successfully initialized, the state will be set to configured. If the initialization fails, the state will be set to notConfigured. ')
vismCasRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 8, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4, 6))).clone(namedValues=NamedValues(("active", 1), ("createAndGo", 4), ("destroy", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismCasRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vismCasRowStatus.setDescription('This variable allows to add, delete or modify the entry for a CAS variant. createAndGo: Use this to add an entry in this table, provided the vismCasVariantName and vismCasFileName MIB objects are available to be set. active: This values is returned, once the row is created destroy: Use this to delete an entry from this table. ')
vismCasCountryCode = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 8, 1, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 2)).clone('US')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismCasCountryCode.setStatus('deprecated')
if mibBuilder.loadTexts: vismCasCountryCode.setDescription(' Represents a case-insensitive 2-letter country code taken from ISO-3166. ')
vismCasVariantSource = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 8, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unspecified", 1), ("internal", 2), ("external", 3))).clone('unspecified')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismCasVariantSource.setStatus('mandatory')
if mibBuilder.loadTexts: vismCasVariantSource.setDescription('This object specifies where the file defining this CAS variant resides. 1. Unspecified. This value indicates that the location of the file is not specified here. In this case, the location is determined based on whether the TFTP server domain is defined on VISM. The file is built into the firmware if no tftp domain is defined on VISM and resides on the TFTP server if a TFTP domain is defined on VISM. 2. Internal. Indicates that the file is built into the firmware. 3. External. Indicates that the file resides on the TFTP server configured on VISM. ')
vismCasXgcpVariantTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 8, 2), )
if mibBuilder.loadTexts: vismCasXgcpVariantTable.setStatus('mandatory')
if mibBuilder.loadTexts: vismCasXgcpVariantTable.setDescription(' An entry in this table is implicitly created/deleted when an entry in vismCasVariantTable is created/deleted in switching mode .')
vismCasXgcpVariantEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 8, 2, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "vismCasXgcpVariantName"))
if mibBuilder.loadTexts: vismCasXgcpVariantEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vismCasXgcpVariantEntry.setDescription('An entry in the vismCasXgcpVariantTable. ')
vismCasXgcpVariantName = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 8, 2, 1, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismCasXgcpVariantName.setStatus('mandatory')
if mibBuilder.loadTexts: vismCasXgcpVariantName.setDescription(' This object is a string identifier for the CAS variant. It is used as index to the table. ')
vismCasXgcpFileName = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 8, 2, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismCasXgcpFileName.setStatus('mandatory')
if mibBuilder.loadTexts: vismCasXgcpFileName.setDescription(' This object gives the name of the file which contains the signal definition and the Finite State Machine definition for the CAS variant. ')
vismCasXgcpMaxReXmitTime = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 8, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 10000)).clone(500)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismCasXgcpMaxReXmitTime.setStatus('mandatory')
if mibBuilder.loadTexts: vismCasXgcpMaxReXmitTime.setDescription(' This object represents the maximum timeout value in milli seconds, used for retransmitting unacknowledged XGCP messages at the Call Agent - CAS/PBX interface. The value of this object is settable in 10 ms increments. ')
vismCasXgcpInitialReXmitTime = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 8, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 10000)).clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismCasXgcpInitialReXmitTime.setStatus('mandatory')
if mibBuilder.loadTexts: vismCasXgcpInitialReXmitTime.setDescription(' This object represents the initial timeout value in milli seconds, used for retransmitting unacknowledged XGCP messages at the Call Agent - CAS/PBX interface. The value of this object is settable in 10 ms increments. ')
vismCasXgcpMaxRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 8, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismCasXgcpMaxRetries.setStatus('mandatory')
if mibBuilder.loadTexts: vismCasXgcpMaxRetries.setDescription(' This object specifies the number of retries for a message that exceeds vismCasXgcpMaxReXmitTime or vismCasXgcpInitialReXmitTime. ')
vismAal2CidGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 4))
vismAal2CidCnfTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 4, 1), )
if mibBuilder.loadTexts: vismAal2CidCnfTable.setStatus('mandatory')
if mibBuilder.loadTexts: vismAal2CidCnfTable.setDescription('This table is defined to establish the binding between an endpoint and a PVC/CID pair in the case of AAL2 adaptation. This table is created and used in trunking mode VISM application only. The maximum number of CIDs that can be configured depends on the current codec template being used as represented by vismAppliedTemplate object. The signaling type of the line has to be configured before adding any CID on that line. ')
vismAal2CidEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 4, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "vismAal2CidLcn"), (0, "CISCO-WAN-AXIPOP-MIB", "vismAal2CidNum"))
if mibBuilder.loadTexts: vismAal2CidEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vismAal2CidEntry.setDescription(' Please see the above description. ')
vismAal2CidNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(8, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismAal2CidNum.setStatus('mandatory')
if mibBuilder.loadTexts: vismAal2CidNum.setDescription('This attribute defines part of the index for the cid Table. vismAal2CidNum is the CID (or Channel ID) of a voice channel. CID has to be the same at both endpoints for a connection. CID is unique only within the context of a Virtual Circuit (PVC or SVC). ')
vismAal2CidLcn = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(131, 510))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismAal2CidLcn.setStatus('mandatory')
if mibBuilder.loadTexts: vismAal2CidLcn.setDescription('This attribute defines part of the index for the cid Table. Since CID is unique to a PVC, a combination of LCN and CID uniquely identifies a voice connection. This field refers to vismChanNum defined in vismChanCnfGrp. ')
vismAal2EndptNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismAal2EndptNum.setStatus('mandatory')
if mibBuilder.loadTexts: vismAal2EndptNum.setDescription('This attribute defines the endpoint number to which this CId is associated. It is the same as mgEndpointNumber in in mgEndpointTable ')
vismAal2CidRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4, 6))).clone(namedValues=NamedValues(("active", 1), ("createAndGo", 4), ("destroy", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismAal2CidRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vismAal2CidRowStatus.setDescription('This variable allows to add or delete a CID. A CID can only be added or deleted. Once added, mdifying an entry is not allowed. createAndGo: Use this to add an entry in this table. active: This values is returned, once the row is created destroy: Use this to delete an entry from this table. For creating a CID, a value for vismAal2EndptNum, vismAal2CidCodecType vismAal2CidProfileType, vismAal2CidProfileNum must be provided. To all other objects, defaults defined by the agent implementation may apply. ')
vismAal2CidType3Redundancy = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 4, 1, 1, 5), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismAal2CidType3Redundancy.setStatus('mandatory')
if mibBuilder.loadTexts: vismAal2CidType3Redundancy.setDescription('This attribute defines whether the triple redundancy is supported for type 3 packets in AAL2 for this channel. When Triple redundancy is enabled for a channel, the type 3 packets (CAS bits, dialled digits and user state control packets) are transmitted in triplicates with an interval defined as per the standards I.366.2. For channels which are quite reliable, triple redundancy can be disabled in order to save the bandwidth and the processing overheads. The default value of this object is true if either vismAal2CidCasTransport or vismAal2CidDtmfTransport is true, otherwise the default value is false. ')
vismAal2CidVad = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 4, 1, 1, 6), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismAal2CidVad.setStatus('mandatory')
if mibBuilder.loadTexts: vismAal2CidVad.setDescription('This attribute defines whether the VAD (Voice Activity Detection) has to be applied on this channel, upon detection of silence. For algorithms that do not have VAD (Voice Activity Detection) standards, Cisco-proprietary VAD can be applied and the generic SID packet as specified in I.366.2 standards can be sent to the other end. When the codecType is clearChannel vad has to be off. ')
vismAal2CidProfileType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 4, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("itu", 1), ("atm", 2), ("custom", 3), ("none", 4))).clone('custom')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismAal2CidProfileType.setStatus('mandatory')
if mibBuilder.loadTexts: vismAal2CidProfileType.setDescription('This attribute defines the profile type. The profile type defines which group of the profile tables the profile number should correspond to. There are three possible groups: itu - corresponding to the tables in ITU format in the profile is being used. atm - This is not supported custom - VISM specific custom profiles For doing a SET on this object, a value for vismAal2CidprofileNum also has to be specified. This is a mandatory parameter while adding a cid. ')
vismAal2CidProfileNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 4, 1, 1, 8), Integer32().clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismAal2CidProfileNum.setStatus('mandatory')
if mibBuilder.loadTexts: vismAal2CidProfileNum.setDescription('This attribute defines the profile number. A profile is a set of entries, where each entry specifies an encoding format with a UUI range and length. This set defines a mapping that informs the receiver of a type 1 packet how to interpret the packet contents, i.e. which encoding format in the profile is being used. For doing a SET on this object, a value for vismAal2CidprofileType also has to be specified. This is a mandatory parameter while adding a cid. ')
vismAal2CidCodecType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 4, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 13, 14))).clone(namedValues=NamedValues(("g711u", 1), ("g711a", 2), ("g726r32000", 3), ("g729a", 4), ("g729ab", 5), ("clearChannel", 6), ("g726r16000", 7), ("g726r24000", 8), ("g726r40000", 9), ("g723h", 11), ("g723ah", 12), ("g723l", 13), ("g723al", 14)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismAal2CidCodecType.setStatus('mandatory')
if mibBuilder.loadTexts: vismAal2CidCodecType.setDescription("This attribute defines the codec Type used for the connection. g711u represents PCMU with 64 kbps. g711a represents PCMA with 64 kbps. g726r32000 represents G.726 at rate 32 kbps g726r16000 represents G.726 at rate 16 kbps g726r24000 represents G.726 at rate 24 kbps g726r40000 represents G.726 at rate 40 kbps g729a represents G.729 Annex A algorithm. g729ab represents G.729 Annex A and Annex B algorithm. clearChannel represents CCD with 64 kbps. g723h represents G.723.1-H at rate 6.3kbps. g723ah represents G.723.1-H at rate 6.3kbps with Silence Supression(SID) ON. g723l represents G.723.1-L at rate 5.3kbps. g723al represents G.723.1-L at rate 5.3kbps with Silence Supression(SID) ON. Note : 1. When codec type is clearChannel, vismAal2CidProfileType and vismAal2CidProfileNum are not applicable and will be ignored. 2. Value 10 is RESERVED and can't be used in future. ")
vismAal2CidDtmfTransport = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 4, 1, 1, 10), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismAal2CidDtmfTransport.setStatus('mandatory')
if mibBuilder.loadTexts: vismAal2CidDtmfTransport.setDescription('This attribute defines whether the DTMF (Dual Tone Multi Frequency) digits need to be transported to the other end-point. ')
vismAal2CidCasTransport = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 4, 1, 1, 11), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismAal2CidCasTransport.setStatus('mandatory')
if mibBuilder.loadTexts: vismAal2CidCasTransport.setDescription("This attribute defines whether the CAS (ABCD bits) bits need to be transported to the other endpoint. In the case of switching application, the CAS bits are backhauled to the Call Agent thro' xGCP-CAS protocol. Note that if the line signaling type is CAS the default value is TRUE, else the default value is FALSE. ")
vismAal2CidEcanEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 4, 1, 1, 12), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismAal2CidEcanEnable.setStatus('mandatory')
if mibBuilder.loadTexts: vismAal2CidEcanEnable.setDescription('This attribute defines whether Echo Cancellation has to be enabled on this connection. If it is set to True, echo cancellation is enabled. If it is set to False, echo cancellation is disabled. ')
vismAal2InitVadTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 4, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(250, 65535)).clone(250)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismAal2InitVadTimer.setStatus('mandatory')
if mibBuilder.loadTexts: vismAal2InitVadTimer.setDescription('This attribute defines the hangover time for VAD in milliseconds. Once the voice inactivity is detected, the gateway will wait for this duration before activating silence suppression. ')
vismAal2CnfPktPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 4, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 10, 20, 30, 40))).clone(namedValues=NamedValues(("five", 5), ("ten", 10), ("twenty", 20), ("thirty", 30), ("fourty", 40))).clone('ten')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismAal2CnfPktPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: vismAal2CnfPktPeriod.setDescription(' This object is used to configure the packetization period for a given codec. This pkt period has to be a valid entry in the profile table. Profile type and number identify a unique profile table and one codec type in this table might have one or more packetization period. This is applicable only if the vismAal2CidCodecType is G.729a. The configurable values for G.729a are 10,20,30 & 40. If a cid entry is configured with a codec other than G.729a then the user cannot configure the pkt period for that codec and the pkt period is picked from the profile table. Hence when we do get/walk on this entry/table any one of the above values could be returned. The packetization periods of 20, 30 and 40 ms. are not allowable in case of G729-a for the list of profiles that we support now. We can only support 10ms. For G.723 the configurable values is 30. Default value would be 30. Please see ENG-45055 or ITU specification I.366.2 annex P for more information. ')
vismAal2CidICSEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 4, 1, 1, 15), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismAal2CidICSEnable.setStatus('mandatory')
if mibBuilder.loadTexts: vismAal2CidICSEnable.setDescription(' This object is used to enable or disable the Idle Channel Suppresion for a cid. This can be specified while adding the cid and cannot be modified. When the Idle Channel Suppression is enabled the DSP will look for the idle cas (ABCD bits) pattern specified in ds0IdleCode in dsx0 MIB. If the idle pattern is present the DSP stops generating voice packets towards ATM side. By default the ds0IdleCode will be zero unless the user has configured it before adding the cid. If the ds0IdleCode is changed after the cid is added it will have no affect unless the card is reset. Idle Channel Suppression is applicable only for trunking application, In case of switching there is no need for Idle channel Suppression as the calls are teared down and set up dynamically. ')
vismAal2CidState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 4, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("cidStateActive", 1), ("cidStateFailed", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismAal2CidState.setStatus('mandatory')
if mibBuilder.loadTexts: vismAal2CidState.setDescription("Indicates the state of the cid. active - the cid is in service and operational failed - the cid is in service but not operational, e.g. because the PVC that the cid belongs to is receiving F5 level alarm When VISM sees alarm on a CID (network side) sets this object to cidStateFailed, trapVismCidState trap will be sent, and an AIS will be sent on the ds0 that this cid corresponds to. If the whole PVC is in alarm then all the cids on that PVC will be set to cidStateFailed, trapVismChanFailed trap will be sent and all the ds0's that corresponds to each of the cids on this PVC will be in alarm. (NOTE: no trapVismCidState will be sent). If VISM sees an alarm on a ds0 in a line then an RAI will be sent on the cid that corresponds to this ds0, however the cid will not be put in failed state. ")
vismAal2CidFailReason = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 3, 4, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("self", 1), ("highLevel", 2), ("both", 3), ("notFail", 4))).clone('notFail')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismAal2CidFailReason.setStatus('mandatory')
if mibBuilder.loadTexts: vismAal2CidFailReason.setDescription('This object is used to indicate the cid failure reason. self: fail because of non-PVC alarm highLevel: fail because of PVC alarm both: fail because of both PVC and non-PVC alarm notFail: not fail ')
vismSvcGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 10))
vismSvcTxSetups = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 10, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismSvcTxSetups.setStatus('mandatory')
if mibBuilder.loadTexts: vismSvcTxSetups.setDescription(' This is the number of Setup messages sent to the PXM from the VISM since VISM reset. ')
vismSvcRxSetups = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 10, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismSvcRxSetups.setStatus('mandatory')
if mibBuilder.loadTexts: vismSvcRxSetups.setDescription(' This is the number of Setup messages received by the VISM from the PXM since VISM reset. ')
vismSvcTxCallProcs = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 10, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismSvcTxCallProcs.setStatus('mandatory')
if mibBuilder.loadTexts: vismSvcTxCallProcs.setDescription(' This is the number of Call proceeding messages sent to the PXM from the VISM since VISM reset. ')
vismSvcRxCallProcs = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 10, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismSvcRxCallProcs.setStatus('mandatory')
if mibBuilder.loadTexts: vismSvcRxCallProcs.setDescription(' This is the number of Call proceeding messages received by the VISM from the PXM since VISM reset. ')
vismSvcTxConns = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 10, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismSvcTxConns.setStatus('mandatory')
if mibBuilder.loadTexts: vismSvcTxConns.setDescription(' This is the number of Connect messages sent to the PXM from the VISM since VISM reset. ')
vismSvcTxConnAcks = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 10, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismSvcTxConnAcks.setStatus('mandatory')
if mibBuilder.loadTexts: vismSvcTxConnAcks.setDescription(' This is the number of Connect ack messages sent to the PXM from the VISM since VISM reset. ')
vismSvcRxConns = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 10, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismSvcRxConns.setStatus('mandatory')
if mibBuilder.loadTexts: vismSvcRxConns.setDescription(' This is the number of Connect messages received by the VISM from the PXM since VISM reset. ')
vismSvcRxConnAcks = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 10, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismSvcRxConnAcks.setStatus('mandatory')
if mibBuilder.loadTexts: vismSvcRxConnAcks.setDescription(' This is the number of Connect ack messages received by the VISM from the PXM since VISM reset. ')
vismSvcTxReleases = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 10, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismSvcTxReleases.setStatus('mandatory')
if mibBuilder.loadTexts: vismSvcTxReleases.setDescription(' This is the number of Release messages sent to the PXM from the VISM since VISM reset. ')
vismSvcTxReleaseCompls = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 10, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismSvcTxReleaseCompls.setStatus('mandatory')
if mibBuilder.loadTexts: vismSvcTxReleaseCompls.setDescription(' This is the number of Release complete messages sent to the PXM from the VISM since VISM reset. ')
vismSvcRxReleases = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 10, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismSvcRxReleases.setStatus('mandatory')
if mibBuilder.loadTexts: vismSvcRxReleases.setDescription(' This is the number of Release messages received by the VISM from the PXM since VISM reset. ')
vismSvcRxReleaseCompls = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 10, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismSvcRxReleaseCompls.setStatus('mandatory')
if mibBuilder.loadTexts: vismSvcRxReleaseCompls.setDescription(' This is the number of Release complete messages received by the VISM from the PXM since VISM reset. ')
vismSvcTxRestarts = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 10, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismSvcTxRestarts.setStatus('mandatory')
if mibBuilder.loadTexts: vismSvcTxRestarts.setDescription(' This is the number of Restart messages sent to the PXM from the VISM since VISM reset. ')
vismSvcTxRestartAcks = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 10, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismSvcTxRestartAcks.setStatus('mandatory')
if mibBuilder.loadTexts: vismSvcTxRestartAcks.setDescription(' This is the number of Restart ack messages sent to the PXM from the VISM since VISM reset. ')
vismSvcRxRestarts = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 10, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismSvcRxRestarts.setStatus('mandatory')
if mibBuilder.loadTexts: vismSvcRxRestarts.setDescription(' This is the number of Restart messages received by the VISM from the PXM since VISM reset. ')
vismSvcRxRestartAcks = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 10, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismSvcRxRestartAcks.setStatus('mandatory')
if mibBuilder.loadTexts: vismSvcRxRestartAcks.setDescription(' This is the number of Restart ack messages received by the VISM from the PXM since VISM reset. ')
vismSvcTxResyncStrts = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 10, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismSvcTxResyncStrts.setStatus('mandatory')
if mibBuilder.loadTexts: vismSvcTxResyncStrts.setDescription(' This is the number of Resync start messages sent to the PXM from the VISM since VISM reset. ')
vismSvcTxResyncStrtAcks = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 10, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismSvcTxResyncStrtAcks.setStatus('mandatory')
if mibBuilder.loadTexts: vismSvcTxResyncStrtAcks.setDescription(' This is the number of Resync start ack messages sent to the PXM from the VISM since VISM reset. ')
vismSvcRxResyncStrts = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 10, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismSvcRxResyncStrts.setStatus('mandatory')
if mibBuilder.loadTexts: vismSvcRxResyncStrts.setDescription(' This is the number of Resync start messages received by the VISM from the PXM since VISM reset. ')
vismSvcRxResyncStrtAcks = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 10, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismSvcRxResyncStrtAcks.setStatus('mandatory')
if mibBuilder.loadTexts: vismSvcRxResyncStrtAcks.setDescription(' This is the number of Resync start ack messages received by the VISM from the PXM since VISM reset. ')
vismSvcTxResyncEnds = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 10, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismSvcTxResyncEnds.setStatus('mandatory')
if mibBuilder.loadTexts: vismSvcTxResyncEnds.setDescription(' This is the number of Resync end messages sent to the PXM from the VISM since VISM reset. ')
vismSvcTxResyncEndAcks = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 10, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismSvcTxResyncEndAcks.setStatus('mandatory')
if mibBuilder.loadTexts: vismSvcTxResyncEndAcks.setDescription(' This is the number of Resync end ack messages sent to the PXM from the VISM since VISM reset. ')
vismSvcRxResyncEnds = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 10, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismSvcRxResyncEnds.setStatus('mandatory')
if mibBuilder.loadTexts: vismSvcRxResyncEnds.setDescription(' This is the number of Resync end messages received by the VISM from the PXM since VISM reset. ')
vismSvcRxResyncEndAcks = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 10, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismSvcRxResyncEndAcks.setStatus('mandatory')
if mibBuilder.loadTexts: vismSvcRxResyncEndAcks.setDescription(' This is the number of Resync end ack messages received by the VISM from the PXM since VISM reset. ')
vismSvcTxBulkResyncs = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 10, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismSvcTxBulkResyncs.setStatus('mandatory')
if mibBuilder.loadTexts: vismSvcTxBulkResyncs.setDescription(' This is the number of Bulk resync messages sent to the PXM from the VISM since VISM reset. ')
vismSvcRxBulkResyncs = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 10, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismSvcRxBulkResyncs.setStatus('mandatory')
if mibBuilder.loadTexts: vismSvcRxBulkResyncs.setDescription(' This is the number of Bulk resync messages received by the VISM from the PXM since VISM reset. ')
vismSvcCallProcExpiries = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 10, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismSvcCallProcExpiries.setStatus('mandatory')
if mibBuilder.loadTexts: vismSvcCallProcExpiries.setDescription(' Call proceeding expirations ')
vismSvcReleasExpiries = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 10, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismSvcReleasExpiries.setStatus('mandatory')
if mibBuilder.loadTexts: vismSvcReleasExpiries.setDescription(' Release completion expirations ')
vismSvcConnExpiries = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 10, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismSvcConnExpiries.setStatus('mandatory')
if mibBuilder.loadTexts: vismSvcConnExpiries.setDescription(' Connect expirations ')
vismSvcConnAckExpiries = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 10, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismSvcConnAckExpiries.setStatus('mandatory')
if mibBuilder.loadTexts: vismSvcConnAckExpiries.setDescription(' Connect ack expirations ')
vismSvcRestartExpiries = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 10, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismSvcRestartExpiries.setStatus('mandatory')
if mibBuilder.loadTexts: vismSvcRestartExpiries.setDescription(' Restart expirations ')
vismSvcResyncExpiries = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 10, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismSvcResyncExpiries.setStatus('mandatory')
if mibBuilder.loadTexts: vismSvcResyncExpiries.setDescription(' Resync expirations ')
vismSvcCnfGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 19))
vismSvcAtmQosGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 19, 1))
vismSvcAtmQosCdv = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 19, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(500, 20000)).clone(20000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismSvcAtmQosCdv.setReference("The references are from ATM Forum 'Voice & Telephony over ATM' specifications af-vtoa-0089.000, af-vtoa-0113.000. ")
if mibBuilder.loadTexts: vismSvcAtmQosCdv.setStatus('mandatory')
if mibBuilder.loadTexts: vismSvcAtmQosCdv.setDescription("End-to-end cell delay variation used in voice SVC establishment. It is used to guarantee the quality of the route selected for a voice SVC. It is applicable to both AAL1 and AAL2 SVC connection establishment. The value specified to this object is in 'micro-seconds'. This value is sent in voice SVC setup messages in extended quality of services information element as the objective value. ")
vismSvcAtmQosCtd = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 19, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(20000, 150000)).clone(150000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismSvcAtmQosCtd.setReference('The references are from ITU G-Series Recomendations: G.114 - One-way transmission time. ')
if mibBuilder.loadTexts: vismSvcAtmQosCtd.setStatus('mandatory')
if mibBuilder.loadTexts: vismSvcAtmQosCtd.setDescription("End-to-end maximum cell transfer delay used in voice SVC establishment. It is used to guarantee the quality of the route selected for a voice SVC. It is applicable to both AAL1 and AAL2 SVC connection establishment. The value specified to this object is in 'micro-seconds'. This value is sent in voice SVC setup messages in end-to-end transit delay information element as the objective value. ")
vismSvcAtmQosClr = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 19, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(4, 8)).clone(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismSvcAtmQosClr.setReference(' The references are from BellCore specifications - GR.1110 ')
if mibBuilder.loadTexts: vismSvcAtmQosClr.setStatus('mandatory')
if mibBuilder.loadTexts: vismSvcAtmQosClr.setDescription('Maximum Cell Loss Ratio used in voice SVC establishment. It is used to guarantee the quality of the route selected for a voice SVC. It is applicable to both AAL1 and AAL2 SVC connection establishment. This value is sent in voice SVC setup messages in extended quality of services information element as maximum cell loss ratio value. ')
vismSvcTrfScalingGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 19, 2))
vismSvcTrfScalingFactor = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 19, 2, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(50, 200)).clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismSvcTrfScalingFactor.setStatus('mandatory')
if mibBuilder.loadTexts: vismSvcTrfScalingFactor.setDescription("Traffic scaling Factor used to compute factored bandwidth which is used in ATM signaling to establish voice SVC. When this value is less than 100 it can be referred as a `discount factor' and when more than 100 referred as an `excess factor' It is applicable only to VBR SVC connection establishment. The traffic scaling is not applicable to AAL2 SVC calls that require G.711 and clear channel codecs ")
vismSvcAal2CidGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 19, 3))
vismSvcAal2CidNumber = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 19, 3, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(8, 255)).clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismSvcAal2CidNumber.setReference('The references are from ITU I-Series Recomendations: I.363.2 B-ISDN ATM Adaptation Layer specification: Type 2 AAL. ')
if mibBuilder.loadTexts: vismSvcAal2CidNumber.setStatus('mandatory')
if mibBuilder.loadTexts: vismSvcAal2CidNumber.setDescription('The default AAL2 Channel IDentification (CID) number used for AAL2 SVC connections. ')
vismSigGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 6))
vismHdlcChanTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 6, 1), )
if mibBuilder.loadTexts: vismHdlcChanTable.setStatus('mandatory')
if mibBuilder.loadTexts: vismHdlcChanTable.setDescription('This table is used for maintaining the statistics info for the HDLC channels on VISM. It also keeps track of some configurable parameters required for proper operation of HDLC driver in VISM. ')
vismHdlcChanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 6, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "vismHdlcChanNum"))
if mibBuilder.loadTexts: vismHdlcChanEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vismHdlcChanEntry.setDescription('An entry for each HDLC channel.')
vismHdlcChanNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 6, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 248))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismHdlcChanNum.setStatus('mandatory')
if mibBuilder.loadTexts: vismHdlcChanNum.setDescription(' This object is the index of this table. It refers to the ds0IfIndex in the dsx0VismCnfTable. ')
vismHdlcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 6, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4, 6))).clone(namedValues=NamedValues(("active", 1), ("createAndGo", 4), ("destroy", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismHdlcRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vismHdlcRowStatus.setDescription('This variable allows to add, delete or modify the entry. createAndGo: Use this to add an entry in this table. There are two case of creating a entry: 1) a ccs channel is explicitly created for Aal2 trunking. In this case, if the DS0 already created for PRI or GR-303 the request of creation should be rejected. 2) A Hdlc entry will be implicitly created before creating a LAPD entry. In this case if the DS0 is already used for Aal2 trunking the request should be rejected. No entry in Lapd shall be created. active: This values is returned, once the row is created destroy: Use this to delete an entry from this table. According to the creation, an entry can be explicitly destroyed or implicitly removed. ')
vismHdlcMaxFrameSize = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 6, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismHdlcMaxFrameSize.setStatus('deprecated')
if mibBuilder.loadTexts: vismHdlcMaxFrameSize.setDescription('This object describes the maximum frame size that is allowed on this HDLC channel. This value is not configurable. The value for this object is 264. ')
vismHdlcLcnNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 6, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(131, 510))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismHdlcLcnNum.setStatus('mandatory')
if mibBuilder.loadTexts: vismHdlcLcnNum.setDescription('This object describes LCN or the PVC channel number with which the HDLC channel is associated with. It is applicable only for trunking applications where the CCS frames are transmitted to the other end point over an AAL5 PVC. For PRI or GR-303 applications, this is not applicable since the CCS frames in that case are backhauled to the call agent. ')
vismHdlcXmtFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 6, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismHdlcXmtFrames.setStatus('mandatory')
if mibBuilder.loadTexts: vismHdlcXmtFrames.setDescription('This object maintains the count of HDLC frames transmitted to the HDLC channel on VISM. ')
vismHdlcRcvFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 6, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismHdlcRcvFrames.setStatus('mandatory')
if mibBuilder.loadTexts: vismHdlcRcvFrames.setDescription('This object maintains the count of HDLC frames received from the HDLC channel on VISM. ')
vismHdlcRcvCrcErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 6, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismHdlcRcvCrcErrors.setStatus('mandatory')
if mibBuilder.loadTexts: vismHdlcRcvCrcErrors.setDescription('This object describes the count of HDLC frames dropped due to CRC errors in the frames received from the HDLC Channel. ')
vismHdlcRcvBufOverflows = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 6, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismHdlcRcvBufOverflows.setStatus('mandatory')
if mibBuilder.loadTexts: vismHdlcRcvBufOverflows.setDescription('This object describes the count of HDLC receiver buffer overflow condition. This can occur if the rate of arrival of HDLC frames from the line is more than the processing rate by the CPU. ')
vismHdlcTxUnderflows = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 6, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismHdlcTxUnderflows.setStatus('mandatory')
if mibBuilder.loadTexts: vismHdlcTxUnderflows.setDescription('This object describes the count of HDLC Tx underflow condition. ')
vismHdlcTxAbortFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 6, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismHdlcTxAbortFrames.setStatus('mandatory')
if mibBuilder.loadTexts: vismHdlcTxAbortFrames.setDescription('This object describes the count of HDLC Abort frames transmitted. ')
vismHdlcRxAbortFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 6, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismHdlcRxAbortFrames.setStatus('mandatory')
if mibBuilder.loadTexts: vismHdlcRxAbortFrames.setDescription('This object describes the count of HDLC Abort frames received. ')
bearerConnGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 9))
bearerConnTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 9, 1), )
if mibBuilder.loadTexts: bearerConnTable.setStatus('mandatory')
if mibBuilder.loadTexts: bearerConnTable.setDescription(' This table describes the statistical information available on a per-bearer connection basis. These values are applicable equally to an endpoint. However, a separate table has been maintained instead of extending the endpoint table because the endpoint table is the standards-based MgMib.')
bearerConnEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 9, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "bearerEndptNum"))
if mibBuilder.loadTexts: bearerConnEntry.setStatus('mandatory')
if mibBuilder.loadTexts: bearerConnEntry.setDescription(' Each entry in this table corresponds to a bearer connection, that was setup by binding an endpoint with VC/CID pair, either through CLI or SNMP. The statistical counters in this table are generic voice quality parameters that are equally applicable in all types of Voice Over Packet adapations (VoIP, VoAAL1 and VoAAL2). However, they are maintained only in the PVC (trunking) model because, these counters get reset in the switching model on a per call basis. The entries in this table are implicitly created/deleted at the time of creation/deletion of entries in the Aal2Cid table. ')
bearerEndptNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 9, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bearerEndptNum.setStatus('mandatory')
if mibBuilder.loadTexts: bearerEndptNum.setDescription('This attribute defines the index for the bearer connection Table. This refers to the same value as the index to the mgEndpoint Table ie. mgEndpointNumber ')
bearerCid = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 9, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bearerCid.setStatus('mandatory')
if mibBuilder.loadTexts: bearerCid.setDescription('This attribute defines the CID (Channel ID associated with this bearer connection.This refers to the same value as vismAal2CidNum in the vismAal2CidCnfTable. ')
bearerLcn = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 9, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(131, 510))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bearerLcn.setStatus('mandatory')
if mibBuilder.loadTexts: bearerLcn.setDescription('This attribute defines the PVC or LCN number to which this bearer connection is associated with. This refers to the same value as in vismChanNum in vismChanCnfGrp table. ')
bearerSentPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 9, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bearerSentPkts.setStatus('mandatory')
if mibBuilder.loadTexts: bearerSentPkts.setDescription('This attribute defines the count of packets sent towards the network since setup. ')
bearerRcvdPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 9, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bearerRcvdPkts.setStatus('mandatory')
if mibBuilder.loadTexts: bearerRcvdPkts.setDescription('This attribute defines the count of packets received from the network since setup. ')
bearerSentOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 9, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bearerSentOctets.setStatus('mandatory')
if mibBuilder.loadTexts: bearerSentOctets.setDescription('This attribute defines the count of bytes sent towards the network since this connection setup. ')
bearerRcvdOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 9, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bearerRcvdOctets.setStatus('mandatory')
if mibBuilder.loadTexts: bearerRcvdOctets.setDescription('This attribute defines the count of bytes received from the network since this connection setup. ')
bearerLostPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 9, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bearerLostPkts.setStatus('mandatory')
if mibBuilder.loadTexts: bearerLostPkts.setDescription('This attribute defines the count of packets lost in the egress direction (from the network). This is a computed number based on the expected number of packets and the actual number of packets arrived from the network. Currently this object is not used. ')
bearerJitter = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 9, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bearerJitter.setStatus('mandatory')
if mibBuilder.loadTexts: bearerJitter.setDescription('This attribute defines the jitter (a.k.a interarrival jitter) This value is determined by the DSP and obtained by the HOST processor upon querying the DSP on a periodic basis. This value is expressed in units of milliseconds. Currently this object is not used. ')
bearerLatency = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 9, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bearerLatency.setStatus('mandatory')
if mibBuilder.loadTexts: bearerLatency.setDescription('This attribute defines the latency (a.k.a end-to-end average transmission delay for a voice packet. This value is expressed in units of milliseconds. Currently this object is not used. ')
bearerAal2ExtAISCnts = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 9, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bearerAal2ExtAISCnts.setStatus('mandatory')
if mibBuilder.loadTexts: bearerAal2ExtAISCnts.setDescription(" This object contains the number of external AIS aal2 Type3 packets received. External AIS - is a Alarm Indication Signal associated with a maintenance alarm detected on a defective maintenance span, that is transmitted in the direction of the defect as a substitute for normal signal. The purpose is to show the downstream entities that a defect has been identified and to prevent other maintenance alrams consequent to this first defect. External AIS bit stream is represented by an all 1's signal. Ref - ITU-T Rec. M.20 sec. 5.4.2 a ")
bearerAal2ExtRAICnts = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 9, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bearerAal2ExtRAICnts.setStatus('mandatory')
if mibBuilder.loadTexts: bearerAal2ExtRAICnts.setDescription(' This object contains the number of external RAI aal2 Type3 packets received. External RAI - is a Remote Alarm Indication signal that is transmitted upstream from an entity that has detected defects persisting long enough to constitute a received signal failure. Its purpose is to report in the backward direction that there is an interruption of service in the forward direction. Ref - ITU-T Rec. G.704 section 2.1.3.1.3 ')
bearerAal2ConnAISCnts = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 9, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bearerAal2ConnAISCnts.setStatus('mandatory')
if mibBuilder.loadTexts: bearerAal2ConnAISCnts.setDescription(' This object contains the number of external Conn AIS aal2 Type2 packets received. External Conn AIS - is a Alarm Indicating Signal transmitted in the downstream direction from the AAL type 2 connecting point that first detects a defect affecting the AAL type 2 connection; this includes defects indicated by lower layers. Ref - ITU-T Rec. I.610 sec 6.2.2.1.1.1 ')
bearerAal2ConnRDICnts = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 9, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bearerAal2ConnRDICnts.setStatus('mandatory')
if mibBuilder.loadTexts: bearerAal2ConnRDICnts.setDescription(' This object contains the number of external Conn RDI (Remote Defect Ind.) aal2 Type2 packets received. External Conn RDI - is a signal transmitted upstream by an AAl type 2 endpoint that is in an alarm state as the result of having received an AAL type2 connection AIS or having detected a defect that affects the AAL type2 connection. ')
bearerCntClrButton = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 9, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noaction", 1), ("clear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bearerCntClrButton.setStatus('mandatory')
if mibBuilder.loadTexts: bearerCntClrButton.setDescription(' This object is used to clear bearerSentPkts, bearerRcvdPkts, bearerSentOctets, and bearerRcvdOctets. ')
dsx0VismCnfTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 4, 7, 1), )
if mibBuilder.loadTexts: dsx0VismCnfTable.setStatus('mandatory')
if mibBuilder.loadTexts: dsx0VismCnfTable.setDescription('The entries in this table are created and deleted implicitly at the time of adding and deleting the line. For every DS0 on a line, one row will be created. ')
dsx0VismCnfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 4, 7, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "ds0IfIndex"))
if mibBuilder.loadTexts: dsx0VismCnfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dsx0VismCnfEntry.setDescription(' This ds0 table contains both cas related and non cas related parameters. The non cas related parameters are applicable accross all line signaling types, while the following cas related parameters are applicable only if the signaling type of the line to which this ds0 belongs is cas. ds0IdleCode ds0SeizedCode ds0ReceivedCode ds0CasVariantName ds0CasCadenceOnTime ds0CasCadenceOffTime ds0InsertLocalCas ds0LocalCasPattern ds0CasParameterSource ds0CasOnHookMinMakeTime ds0CasOffHookMinMakeTime ds0CasWinkMinMakeTime ds0CasWinkMaxMakeTime ds0CasWinkBreakTime ds0CasGlareTime ds0CasGaurdTime ds0CasDelayImmedStart ds0CasMinDelayDialTime ds0CasMinStartDialTime ds0CasFlashMinMakeTime ds0CasFlashMaxMakeTime ds0CasDirectionality ds0CasGlarePolicy ds0CasIncomingMgcpPackage ds0CasOutgoingMgcpPackage When the line signaling type changes from cas to non-cas and vice versa, then the user will be forced to delete endpoint/ccs channels associated with any ds0 on that line When an endpoint is deleted the ds0CasVariantName associated with that endpoint will also be implicitly deleted. Other than that none of the above cas related parameters are modified across line signaling type changes. ')
ds0IfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 7, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 248))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds0IfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ds0IfIndex.setDescription('This attribute defines the index for this table. This is derived from the following formula: index = 31 * (Ds1# - 1) + ds0# where : Ds1# - The T1/E1 line number in the range 1 - 8. ds0# - The ds0 channel number ranging from 1 to 24 for T1 and 1 to 31 for E1. ')
ds0RobbedBitSignalling = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 7, 1, 1, 2), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ds0RobbedBitSignalling.setStatus('mandatory')
if mibBuilder.loadTexts: ds0RobbedBitSignalling.setDescription('This object indicates if Robbed Bit Signalling is turned on or off for a given ds0. This only applies to DS0s on a DS1 link. For E1 links the value is always off (false). For T1 links, the default value is true if the line is configured for CAS signaling, the default value is false if the line is configured for CCS signaling or no signaling. ')
ds0IdleCode = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 7, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ds0IdleCode.setStatus('mandatory')
if mibBuilder.loadTexts: ds0IdleCode.setDescription('This object contains the code transmitted in the ABCD bits when the ds0 is not connected and ds0TransmitCodesEnable is enabled. The object is a bitmap and the various bit positions are: Bit 0 (value 1) D bit Bit 1 (value 2) C bit Bit 2 (value 4) B bit Bit 3 (value 8) A bit This object is useful for ds0 conditioning to be done if an alarm condition is detected from the network side. DS0 conditioning is implemented in the trunking application only. This object is not applicable in the CAS backhaul application. From vism 2.0.3 release onwards this object can be configured in any mode, but will be applicable only in trunking application and will be ignored in other applications. ')
ds0SeizedCode = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 7, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)).clone(15)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ds0SeizedCode.setStatus('mandatory')
if mibBuilder.loadTexts: ds0SeizedCode.setDescription('This object contains the code transmitted in the ABCD bits when the ds0 is connected and ds0TransmitCodesEnable is enabled. The object is a bitmap and the various bit positions are: Bit 0 (value 1) D bit Bit 1 (value 2) C bit Bit 2 (value 4) B bit Bit 3 (value 8) A bit This object is useful for ds0 conditioning to be done if an alarm condition is detected from the network side. DS0 conditioning is implemented in the trunking application only. This object is not applicable in the CAS backhaul application. From vism 2.0.3 release onwards this object can be configured in any mode, but will be applicable only in trunking application and will be ignored in other applications. ')
ds0ReceivedCode = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 7, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds0ReceivedCode.setStatus('mandatory')
if mibBuilder.loadTexts: ds0ReceivedCode.setDescription('This object contains the code being received in the ABCD bits. The object is a bitmap and the various bit positions are: Bit 0 (value 1) D bit Bit 1 (value 2) C bit Bit 2 (value 4) B bit Bit 3 (value 8) A bit')
ds0TransmitCodesEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 7, 1, 1, 6), TruthValue().clone('true')).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds0TransmitCodesEnable.setStatus('deprecated')
if mibBuilder.loadTexts: ds0TransmitCodesEnable.setDescription('This object determines if the idle and seized codes are transmitted. If the value of this object is true then the codes are transmitted. This object is not applicable in the CAS backhaul application.')
ds0BundleMapped = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 7, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds0BundleMapped.setStatus('mandatory')
if mibBuilder.loadTexts: ds0BundleMapped.setDescription('This object indicates endpoint number as specified by mgEndpointNumber of endpoint table. If it is not associated with any endpoint, then it is set to -1. It should be noted that the endpoint is associated with bearer DS0s only. For signaling channel or DS0 as in the case of CCS channel, there is no endpoint number associated with it and the value is set to -1. ')
ds0IfType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 7, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(81, 63, 1))).clone(namedValues=NamedValues(("bearer", 81), ("ccs-signaling", 63), ("unknown", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds0IfType.setStatus('mandatory')
if mibBuilder.loadTexts: ds0IfType.setDescription('This object indicates the interface type associated with the ds0. ds0 ifType is considered as bearer if it the DS0 is used for carrying voice traffic. ds0 ifType is considered as ccs-signaling, if the DS0 is configured as the D-channel ')
ds0CasVariantName = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 7, 1, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ds0CasVariantName.setStatus('mandatory')
if mibBuilder.loadTexts: ds0CasVariantName.setDescription('This object indicates the index to the CAS variant table. This parameter can be configured after configuring this ds0 as an endpoint. This object cannot be modified while connections exist on this endpoint. The CAS variant table is used for configuring the system parameters associated with various types of CAS signaling methods supported on VISM. ')
ds0CasCadenceOnTime = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 7, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 9999)).clone(75)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ds0CasCadenceOnTime.setStatus('mandatory')
if mibBuilder.loadTexts: ds0CasCadenceOnTime.setDescription(' This attribute describes the duration during which the digit tone is generated. This object is applicable only for CAS backhaul applications. For trunking application it is not applicable. The value is expresssed in units of milliseconds. From vism2.0.3 release onwards this object can configured in any application, but will be applicable only in non-trunking applications and will be ignored in other applications. ')
ds0CasCadenceOffTime = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 7, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9999)).clone(75)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ds0CasCadenceOffTime.setStatus('mandatory')
if mibBuilder.loadTexts: ds0CasCadenceOffTime.setDescription(' This attribute corresponds to the silence between the digit tones. This object is applicable only for CAS backhaul applications. For trunking application it is not applicable. The value is expresssed in units of milliseconds. From vism2.0.3 release onwards this object can configured in any application, but will be applicable only in non-trunking applications and will be ignored in other applications. ')
ds0InsertLocalCas = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 7, 1, 1, 12), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ds0InsertLocalCas.setStatus('mandatory')
if mibBuilder.loadTexts: ds0InsertLocalCas.setDescription(' This object tells the framer whether to force the cas bits to a value defined by ds0LocalCasPattern or not. If this is enabled the framer will force the cas (ABCD) bits to a value defined in ds0LocalCasPattern by ignorning the cas bits sent by DSP. Else the framer will transmit the cas bits sent by DSP. Setting of this object is not allowed when the signaling type of this line is cas. Also setting of this object is not allowed when the ds0LoopbackCommand is set to RemoteLoop, because in this situation we are suppose to loopback whatever comes from the TDM side and not force the cas bits to something else. This object can be set only if the line type is T1. ')
ds0LocalCasPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 7, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ds0LocalCasPattern.setStatus('mandatory')
if mibBuilder.loadTexts: ds0LocalCasPattern.setDescription(' This object contains the pattern that the cas (ABCD) bits will have when ds0InsertLocalCas is enabled. ')
ds0LoopbackCommand = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 7, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noLoop", 1), ("remoteLoop", 2), ("localLoop", 3))).clone('noLoop')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ds0LoopbackCommand.setStatus('mandatory')
if mibBuilder.loadTexts: ds0LoopbackCommand.setDescription(' This object represents the loopback type at the ds0 level.The ds0 configuration overrides the line level configuration. NoLoop There is no loopback on this ds0. LocalLoop The data received from the ATM side is loopedback to the ATM side. RemoteLoop The data from the TDM side is looped back to the TDM side. Setting of this object to RemoteLoop will not be allowed when insert local cas for this ds0 (ds0InsertLocalCas object) is enabled as we are suppose to force the cas bits to the pattern configured in ds0LocalCasPattern, and not do loopback on the TDM side. ')
ds0CasParameterSource = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 7, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("casAppl", 1), ("mibValue", 2))).clone('casAppl')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ds0CasParameterSource.setStatus('mandatory')
if mibBuilder.loadTexts: ds0CasParameterSource.setDescription(' This object indicates VISM whether to read the cas related timer parameters from the casAppl file downloaded for that endpoint or to read from this mib. This gives the flexibility of configuring different cas related timer values for different endpoints associated with the same cas variant. This object cannot be configured if the signaling type for the line to which this ds0 belongs is non cas. For a cas line this object CAN only be configured only after associating this ds0 with an endpoint. ')
ds0CasOnHookMinMakeTime = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 7, 1, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(300)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ds0CasOnHookMinMakeTime.setStatus('mandatory')
if mibBuilder.loadTexts: ds0CasOnHookMinMakeTime.setDescription(' This indicates the the minimum time in msecs for which the on hook pattern should be present in order for it to be recognised else the signal will be considered to be a spurious signal and will be ignored. This object cannot be configured if the signaling type for the line to which this ds0 belongs is non cas. For a cas line this object CAN only be configured only after associating this ds0 with an endpoint. This object will be applicable if ds0CasParameterSource has a value of mibValue (2). The allowed range for this object is 10..1000 ')
ds0CasOffHookMinMakeTime = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 7, 1, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ds0CasOffHookMinMakeTime.setStatus('mandatory')
if mibBuilder.loadTexts: ds0CasOffHookMinMakeTime.setDescription(' This indicates the minimum time in msecs for which the off hook pattern should be present in order for it to be recognised else the signal will be considered to be a spurious signal and will be ignored. This object cannot be configured if the signaling type for the line to which this ds0 belongs is non cas. For a cas line this object CAN only be configured only after associating this ds0 with an endpoint This object will be applicable if ds0CasParameterSource has a value of mibValue (2). The allowed range for this object is 10..1000 ')
ds0CasWinkMinMakeTime = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 7, 1, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ds0CasWinkMinMakeTime.setStatus('mandatory')
if mibBuilder.loadTexts: ds0CasWinkMinMakeTime.setDescription(' The wink consists of off-hook A-B bit pattern, followed by on-hook A-B bit pattern in timed sequence. This object indicates the minimum duration for which the off-hook part of wink signal should persist. This object cannot be configured if the signaling type for the line to which this ds0 belongs is non cas. For a cas line this object CAN only be configured only after associating this ds0 with an endpoint This object will be applicable if ds0CasParameterSource has a value of mibValue (2). The allowed range for this object is 10..1000 and the range is in msecs. ')
ds0CasWinkMaxMakeTime = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 7, 1, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(350)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ds0CasWinkMaxMakeTime.setStatus('mandatory')
if mibBuilder.loadTexts: ds0CasWinkMaxMakeTime.setDescription(' The wink consists of off-hook A-B bit pattern, followed by on-hook A-B bit pattern in timed sequence. This object indicates the maximum duration for which the off-hook part of the wink signal should persist, if it exceeds this time limit the signal will be considered to be spurious and will be ignored. This object cannot be configured if the signaling type for the line to which this ds0 belongs is non cas. For a cas line this object CAN only be configured only after associating this ds0 with an endpoint This object will be applicable if ds0CasParameterSource has a value of mibValue (2). The allowed range for this object is 10..3000 and the units is in msecs. This object should be greater than or equal to ds0CasWinkMinMakeTime ')
ds0CasWinkBreakTime = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 7, 1, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(70)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ds0CasWinkBreakTime.setStatus('mandatory')
if mibBuilder.loadTexts: ds0CasWinkBreakTime.setDescription(' The wink consists of off-hook A-B bit pattern, followed by on-hook A-B bit pattern in timed sequence. This object indicates the minimum duration for which the on-hook part of wink signal should persist. This object cannot be configured if the signaling type for the line to which this ds0 belongs is non cas. For a cas line this object CAN only be configured only after associating this ds0 with an endpoint This object will be applicable if ds0CasParameterSource has a value of mibValue (2). The allowed range for this object is 10..1000 and the units. is in msecs. ')
ds0CasGlareTime = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 7, 1, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ds0CasGlareTime.setStatus('mandatory')
if mibBuilder.loadTexts: ds0CasGlareTime.setDescription(" When the terminating gateway receives off Hook event from the Call Agent it starts the timer specified in this object to see if the terminating side is also trying to originate a call. If this is true, we have a 'glare' condition. The way glare is resolved is thru this user programmable timer, we will not honor any off hook events from the originating PBX during this time. This object cannot be configured if the signaling type for the line to which this ds0 belongs is non CAS. For a CAS line this object can only be configured only after associating this ds0 with an endpoint This object will be applicable if ds0CasParameterSource has a value of mibValue (2). The allowed range for this object is 10..10000 and the units is in msecs. ")
ds0CasGaurdTime = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 7, 1, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(800)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ds0CasGaurdTime.setStatus('mandatory')
if mibBuilder.loadTexts: ds0CasGaurdTime.setDescription(' The gaurd time is the duration between the end of one call and the start of next call. This object specifies what should be such a duration. All state changes from the PBX are ignored for this duration. After receiving DLCX, this timer will be started for a period as configured in this object, and will not honor any off-hook events before the expiration of this timer. This object cannot be configured if the signaling type for the line to which this ds0 belongs is non cas. For a cas line this object CAN only be configured only after associating this ds0 with an endpoint This object will be applicable if ds0CasParameterSource has a value of mibValue (2). The allowed range for this object is 10..1000 and the units is in msecs. ')
ds0CasDelayImmedStart = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 7, 1, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(500)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ds0CasDelayImmedStart.setStatus('mandatory')
if mibBuilder.loadTexts: ds0CasDelayImmedStart.setDescription(' This timer indicates the time that VISM should wait before outpulsing digits to the PBX after sending an off hook event. This applies only to immediate start protocol. This object cannot be configured if the signaling type for the line to which this ds0 belongs is non cas. For a cas line this object CAN only be configured only after associating this ds0 with an endpoint. This object will be applicable if ds0CasParameterSource has a value of mibValue (2). The allowed range for this object is 10..1000 and the units is in msecs. ')
ds0SignalingType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 7, 1, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("cas", 1), ("ccs", 2), ("none", 3))).clone('none')).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds0SignalingType.setStatus('mandatory')
if mibBuilder.loadTexts: ds0SignalingType.setDescription(' This attribute indicates the type of signaling on the line to which this ds0 belongs. CAS - Channel Associated Signaling CCS - Common Channel Signaling none - no signaling used. This object will be implicitly set to line signaling type every time it changes. ')
ds0CasMinDelayDialTime = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 7, 1, 1, 25), Integer32().clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ds0CasMinDelayDialTime.setStatus('mandatory')
if mibBuilder.loadTexts: ds0CasMinDelayDialTime.setDescription(" This is an object for an E & M signaling protocol like wink-start for this ds0. The difference is that the address-control signal is different from wink. The originating VISM, on receiving a seize (AB=11) from the PBX, responds by sending the delay-dial (AB=11) signal back to the PBX. When the originating VISM is ready to collect the digits, it sends a start-dial (AB=00) signal. This operation is symmetric. So the terminating VISM, on seizing a trunk, should receive AB=11 (as an ack that the trunk is operational). Subsequently, when it receives the start signal (AB=00) from the connected PBX, it should outpulse the digits. The rest of the operation is similiar to wink-start. The allowed range for this object is 100..1000 with units in milliseconds. In delay-dial operation, the outgoing interface (this interface), after sending a seize signal (AB = 11), waits for the delay-dial signal (AB = 11). The delay-dial signal, apart from acknowledging the seize signal, tells this interface that the connected equipment is not ready for the digits yet. This object specifies the time in milliseconds, after which incoming AB=11 will be interpreted by this interface as the delay-dial signal. References: Generic Requirements, GR-506-CORE, Issue 1, June 1996, Revision 1, November 1996, LSSGR: Signaling for Analog Interfaces Section 11.2.3 is about 'Delay-Dial Operation' (in general) In particular, section 11.2.3.1 ([R11-21] is about these timing requirements. ")
ds0CasMinStartDialTime = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 7, 1, 1, 26), Integer32().clone(70)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ds0CasMinStartDialTime.setStatus('mandatory')
if mibBuilder.loadTexts: ds0CasMinStartDialTime.setDescription(" This is an object for an E & M signaling protocol like wink-start for this ds0. The difference is that the address-control signal is different from wink. The originating VISM, on receiving a seize (AB=11) from the PBX, responds by sending the delay-dial (AB=11) signal back to the PBX. When the originating VISM is ready to collect the digits, it sends a start-dial (AB=00) signal. This operation is symmetric. So the terminating VISM, on seizing a trunk, should receive AB=11 (as an ack that the trunk is operational). Subsequently, when it receives the start signal (AB=00) from the connected PBX, it should outpulse the digits. The rest of the operation is similiar to wink-start. The allowed range for this object is 70..1000 with units in milliseconds. In delay-dial operation, the outgoing interface (this interface), after receiving a delay-dial signal (AB=11) from the connected equipment, waits for the start-dial signal (AB = 00) before sending the digits to the connected equipment. The start-dial signal tells this interface that the connected equipment is ready for the digits. This object specifies the time in milliseconds, after which incoming AB=00 will be interpreted by this interface as the start dial signal. References: Generic Requirements, GR-506-CORE, Issue 1, June 1996, Revision 1, November 1996, LSSGR: Signaling for Analog Interfaces Section 11.2.3 is about 'Delay-Dial Operation' (in general) In particular, section 11.2.3.1 ([R11-22] and [R11-23]) is about these timing requirements. ")
ds0CasFlashMinMakeTime = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 7, 1, 1, 27), Integer32().clone(300)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ds0CasFlashMinMakeTime.setStatus('mandatory')
if mibBuilder.loadTexts: ds0CasFlashMinMakeTime.setDescription(' Flash is a CAS signal generated by users to request special services. The interpretation of the flash depends on the protocol in use. The signal itself is an on-hook followed by an off-hook. This object specifies the minimum duration for the signal to be recognized as a flash by VISM. This duration, expressed in milliseconds, is defined as the elapsed time between the off-to-on-hook transition followed by the on-to-off-hook transition. If the on-hook duration is shorter than the value of this object, the signal will be ignored. This object cannot be configured if the signaling type for the line to which this ds0 belongs is non-CAS. For a CAS line, this object can only be configured after associating this ds0 with an endpoint. If no endpoint was added for this Ds0, any configuration attempt will be rejected. This object will be applicable if ds0CasParameterSource has a value of mibvalue (2). The allowed range for this object is 50..1550 (msec). ')
ds0CasFlashMaxMakeTime = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 7, 1, 1, 28), Integer32().clone(1400)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ds0CasFlashMaxMakeTime.setStatus('mandatory')
if mibBuilder.loadTexts: ds0CasFlashMaxMakeTime.setDescription(" Flash is a CAS signal generated by users to request special services. The interpretation of the flash depends on the protocol in use. The signal itself is an on-hook followed by an off-hook. This object specifies the maximum duration for the signal to be recognized as a flash by VISM. This duration, expressed in milliseconds, is defined as the elapsed time between the off-to-on-hook transition followed by the on-to-off-hook transition. If the on-hook duration is longer than the value of this object, the signal will be ignored. This object cannot be configured if the signaling type for the line to which this ds0 belongs is non-CAS. For a CAS line, this object can only be configured after associating this ds0 with an endpoint. This means that if no endpoint was added for this Ds0, any configuration set attempt will be rejected, but any get will be allowed. This object will be applicable if ds0CasParameterSource has a value of 'mibvalue'(2). The allowed range for this object is 50..1550 (msec.) with the additional requirement that the value of this object should be greater than or equal to ds0CasFlashMinMakeTime. ")
ds0CasDirectionality = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 7, 1, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("bidirectional", 1), ("incoming", 2), ("outgoing", 3))).clone('bidirectional')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ds0CasDirectionality.setStatus('mandatory')
if mibBuilder.loadTexts: ds0CasDirectionality.setDescription(' This object specifies the direction in which CAS calls will be accepted on this endpoint. If this object is set to incoming, then calls from the connected PBX will be accepted by VISM on this endpoint. If set to outgoing, VISM will send calls towards the connected PBX and not accept calls from the PBX. For VISM to both send and receive calls on this endpoint, this object should be set to bidirectional. The main difference between bidirectional and one-way trunks is the occurrence of glare. On bidirectional trunks, since both VISM and the connected PBX can seize the endpoint at approximately the same time, glare (dual seizure) is likely to occur. The protocol assigned to a bidirectional endpoint should be capable of detecting and resolving glare. Wink-start and delay-dial are examples of protocols capable of glare handling and immediate-start, ground-start and loop-start, of those that cannot. This object cannot be configured if the signaling type for the line to which this ds0 belongs is non-CAS. For a CAS line, this object can only be configured after associating this ds0 with an endpoint. This means that if no endpoint was added for this Ds0, any configuration set attempt will be rejected, but any get will be allowed. ')
ds0CasGlarePolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 7, 1, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("controlling", 1), ("releasing", 2))).clone('controlling')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ds0CasGlarePolicy.setStatus('mandatory')
if mibBuilder.loadTexts: ds0CasGlarePolicy.setDescription(' This object specifies how a bidirectional endpoint should resolve glare. This object will be used only if dsx0VismDirectionality of the endpoint is bidirectional. When glare is detected, if this object is set to controlling, VISM will wait for the connected PBX to assert on-hook. When the connected PBX goes on-hook, VISM proceeds to dial the numbers out waits for answer. If this object is set to releasing, VISM indicates the glare situation to the Call Agent (as specified by the control protocol), prepares to collect digits from the PBX and asserts on hook. The incoming call should go through. If the CAS protocol assigned to the endpoint cannot detect glare or if it cannot resolve glare according to the policy provisioned via this object, this object will not be used. This object cannot be configured if the signaling type for the line to which this ds0 belongs is non-CAS. For a CAS line, this object can only be configured after associating this ds0 with an endpoint. This means that if no endpoint was added for this Ds0, any configuration set attempt will be rejected, but any get will be allowed. ')
ds0CasIncomingMgcpPackage = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 7, 1, 1, 31), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ds0CasIncomingMgcpPackage.setStatus('mandatory')
if mibBuilder.loadTexts: ds0CasIncomingMgcpPackage.setDescription(" This object, in conjunction with the card level persistentXgcpEventsTable, controls how persistent CAS events (like seize, disconnect, etc) related to an incoming call observed on this DS0 are notified to the Media Gateway Controller (MGC). At the card level, the persistentXgcpEventsTable allows MGCP package-event combinations to be configured as persistent. For example, when L/hd is added to the persistentXgcpEventsTable, the hook-down event in line package will be notified to the MGC every time it is observed without the MGC requesting for that event. Since the same CAS event can map to different MGCP events under different packages (eg. the CAS event 'seize' can be 'sup' in 'MS' package and 'hd' in 'BL' package) and different lines could be running different packages at a given time, there needs to be a per-DS0 object indicating what package should be used while notifying CAS events observed on that DS0. This object, ds0CasIncomingMgcpPackage specifies the package that will be used while notifying CAS events observed on an incoming call on this DS0. This object can be set to a package name from xgcpCapabilityPackageTable whose xgcpCapabilityPackageEnable is true or the string 'basic' indicating that one of the basic packages in that table (G, T, L, H, R, D or M) to which the observed event belongs can be used. This object is used only if the protocol is MGCP. If the notification is in response to an RQNT, VISM uses the package (and event name) that the MGC used to request the event regardless what this object is set to. In the absence of an RQNT, the observed CAS event is encoded according to the package that this object specifies. A 'seize' observed on the CAS signaling channel on this DS0, for example is encoded as 'ms/sup' if this object is set to 'ms', 'bl/hd' if this object is set to 'bl' or as 'L/hd' if this object is set to 'basic'. If this package/event is present in persistentXgcpEventsTable, a notification is generated, otherwise this event is discarded. An attempt to set this object to a package name whose xgcpCapabilityPackageEnable is false in xgcpCapabilityPackageTable will fail. This object is used only if the ds0CasDirectionality is set to bidirectional or incoming. ")
ds0CasOutgoingMgcpPackage = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 7, 1, 1, 32), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ds0CasOutgoingMgcpPackage.setStatus('mandatory')
if mibBuilder.loadTexts: ds0CasOutgoingMgcpPackage.setDescription(" This object, in conjunction with the card level persistentXgcpEventsTable, controls how persistent CAS events (like answer, disconnect, etc) related to an outgoing call observed on this DS0 are notified to the Media Gateway Controller (MGC). At the card level, the persistentXgcpEventsTable allows MGCP package-event combinations to be configured as persistent. For example, when L/hd is added to the persistentXgcpEventsTable, the hook-down event in line package will be notified to the MGC every time it is observed without the MGC requesting for that event. Since the same CAS event can map to different MGCP events under different packages (eg. the CAS event 'answer' can be 'ans' in 'MS' package and 'hd' in 'BL' package) and different lines could be running different packages at a given time, there needs to be a per-DS0 object indicating what package should be used while notifying CAS events observed on that DS0. This object, ds0CasOutgoingMgcpPackage specifies the package that will be used while notifying CAS events observed on an outgoing call on this DS0. This object can be set to a package name from xgcpCapabilityPackageTable whose xgcpCapabilityPackageEnable is true or the string 'basic' indicating that one of the basic packages in that table (G, T, L, H, R, D or M) to which the observed event belongs can be used. This object is used only if the protocol is MGCP. If the notification is in response to an RQNT, VISM uses the package (and event name) that the MGC used to request the event regardless what this object is set to. In the absence of an RQNT, the observed CAS event is encoded according to the package that this object specifies. An answer observed on the CAS signaling channel on this DS0, for example is encoded as 'ms/ans' if this object is set to 'ms', 'bl/hd' if this object is set to 'bl' or as 'L/hd' if this object is set to 'basic'. If this package/event is present in persistentXgcpEventsTable, a notification is generated, otherwise this event is discarded. An attempt to set this object to a package name whose xgcpCapabilityPackageEnable is false in xgcpCapabilityPackageTable will fail. This object is used only if the ds0CasDirectionality is set to bidirectional or outgoing. ")
ds0InputGain = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 7, 1, 1, 33), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-6, 14))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ds0InputGain.setStatus('mandatory')
if mibBuilder.loadTexts: ds0InputGain.setDescription('This object indicates the amount of gain inserted at the receiver side of a ds0 channel, in dB (decibel) units. The default value of this object is 0 dB. The input gain settings only define a gain/loss relative to the 0 dB setting. The absolute loss at the 0 dB setting could be implementation dependent based on the desired network loss plan. This object can be set when there are active call going on, and in this case the new gain will take effective immediately. It can also be set at both unbound endpoints and bound but non-active endpoints. ')
ds0OutputAttenuation = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 7, 1, 1, 34), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 14))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ds0OutputAttenuation.setStatus('mandatory')
if mibBuilder.loadTexts: ds0OutputAttenuation.setDescription('This object contains the amount of attenuation inserted at the transmit side of a ds0 channel, in dB (decibel) units. The output attenuation settings only define a loss relative to 0 dB setting. The absolute loss at the 0 dB setting could be implementation dependent based on the desired network loss plan. This object can be set when there are active call going on, and in this case the new gain will take effective immediately. It can also be set at both unbound endpoints and bound but non-active endpoints. ')
ds0MusicThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 7, 1, 1, 35), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-70, -30)).clone(-38)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ds0MusicThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: ds0MusicThreshold.setDescription('The indicates Music On Hold Threshold in dBm. Based on this value, VISM DSP will interprete the incoming signal from TDM side as either silence or voice, and consequently turn on or off VAD. This object can be set when there is active call going on at the ds0 channel, and at both unbound endpoints and bound non-active endpoints. ')
ds0SidPacket = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 7, 1, 1, 36), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ds0SidPacket.setStatus('mandatory')
if mibBuilder.loadTexts: ds0SidPacket.setDescription(' This object specifies whether the Silence Indication Detection (SID) packet should be generated when silence suppression is in active mode. The SID packet indicates the noise level during silence, which is used as a reference to generate comfort noise on the other side of the gateway. This object is used for VoIP only. ')
dsx0VismChanMapTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 4, 7, 2), )
if mibBuilder.loadTexts: dsx0VismChanMapTable.setStatus('mandatory')
if mibBuilder.loadTexts: dsx0VismChanMapTable.setDescription('This table is created implicitly at the time of creating and deleting the endpoints. This table provides the mapping information from a line and channel to obtain an index for that channel.')
dsx0VismChanMapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 4, 7, 2, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "dsx1LineNum"), (0, "CISCO-WAN-AXIPOP-MIB", "ds0ChanNum"))
if mibBuilder.loadTexts: dsx0VismChanMapEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dsx0VismChanMapEntry.setDescription(' Please see the above description. ')
dsx1LineNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 7, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsx1LineNum.setStatus('mandatory')
if mibBuilder.loadTexts: dsx1LineNum.setDescription('This object describes the physical line number on VISM card. ')
ds0ChanNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 7, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds0ChanNum.setStatus('mandatory')
if mibBuilder.loadTexts: ds0ChanNum.setDescription('This object describes the ds0 number or channel number within a T1 or E1 line. The valid channel numbers are 1 to 24 for T1 line and 1 - 31 for E1 line. ')
ds0ChanMapIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 4, 7, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds0ChanMapIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ds0ChanMapIfIndex.setDescription('This object describes the ifIndex derived based on the line number and the channel number within the line according to the formula: IfIndex = 31 * (Ds1# - 1) + ds0# where : Ds1# - The T1/E1 line number in the range 1 - 8. ds0# - The ds0 channel number ranging from 1 to 24 for T1 and 1 to 31 for E1. ')
vismCodecTemplateCnfGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 7))
vismCodecTemplateCnfGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 7, 1), )
if mibBuilder.loadTexts: vismCodecTemplateCnfGrpTable.setStatus('mandatory')
if mibBuilder.loadTexts: vismCodecTemplateCnfGrpTable.setDescription('This table defines the DSP templates that are applicable on a card basis. It defines the set of codecs supported in each template and the maximum number of DS0s supported on the VISM card for a given template. ')
vismCodecTemplateCnfGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 7, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "vismCodecTemplateNum"))
if mibBuilder.loadTexts: vismCodecTemplateCnfGrpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vismCodecTemplateCnfGrpEntry.setDescription('An entry is defined for each set of codecs supported. The codecs supported are a combination of : G.711Mu (PCM - Mu-law) G.711A (PCM - A-law) G.726/32 (ADPCM) G.729a (CS-ACELP - Annex A) G.729ab (CS-ACELP - Annex B) clearChannel (clear channel voice) G.723.1-H G.723.1a-H G.723.1-L G.723.1a-L ')
vismCodecTemplateNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 7, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismCodecTemplateNum.setStatus('mandatory')
if mibBuilder.loadTexts: vismCodecTemplateNum.setDescription("This attribute defines the index for the CodecTemplate table. Template number is input at the time of configuring a template using 'cnftemp' CLI command. ")
vismCodecSupported = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 7, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismCodecSupported.setStatus('mandatory')
if mibBuilder.loadTexts: vismCodecSupported.setDescription('This attribute represents a bit map of Codecs supported in this template. Bit 0 - represents the G.711 Mu-law codec. Bit 1 - represents the G.711 A-law codec. Bit 2 - represents the G.726 at rate 32 kbps. Bit 3 - represents the G.729a codec. Bit 4 - represents the G.729ab codec. Bit 5 - represents clear channel. Bit 6 - represents the G.726 at rate 16 kbps Bit 7 - represents the G.726 at rate 24 kbps Bit 8 - represents the G.726 at rate 40 kbps Bit 9 - Internal use (T.38) Bit 10 - represents the G.723.1-H codec. Bit 11 - represents the G.723.1a-H codec. Bit 12 - represents the G.723.1-L codec. Bit 13 - represents the G.723.1a-L codec. The remaining bits will be defined in future when other types of codecs are supported. ')
vismCodecTemplateMaxChanCount = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 7, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismCodecTemplateMaxChanCount.setStatus('mandatory')
if mibBuilder.loadTexts: vismCodecTemplateMaxChanCount.setDescription('The max. number of channels supported for this template. Based on the codec that is of the maximum complexity, the maximum no. of channels that can be supported with a given set of codecs is determined and stored in this variable. ')
vismCodecCnfGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 18))
vismCodecCnfTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 18, 1), )
if mibBuilder.loadTexts: vismCodecCnfTable.setStatus('mandatory')
if mibBuilder.loadTexts: vismCodecCnfTable.setDescription('This table contains configuration information about different codecs and there packetization periods. ')
vismCodecCnfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 18, 1, 1), ).setIndexNames((0, "CISCO-WAN-AXIPOP-MIB", "vismCodecCnfIndex"))
if mibBuilder.loadTexts: vismCodecCnfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vismCodecCnfEntry.setDescription('An entry in the vismCodecCnf table. Each entry consists of packetization period information for a specific codec. All the entries in this table are implicitly created when the card comes up with appropriate default values and the user can modify the packetization period for a particular codec any point in time. ')
vismCodecCnfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 18, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 13, 14))).clone(namedValues=NamedValues(("g711u", 1), ("g711a", 2), ("g726r32000", 3), ("g729a", 4), ("g729ab", 5), ("clearChannel", 6), ("g726r16000", 7), ("g726r24000", 8), ("g726r40000", 9), ("g723h", 11), ("g723ah", 12), ("g723l", 13), ("g723al", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismCodecCnfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vismCodecCnfIndex.setDescription(' This object is a index to this table. 1 represents G.711u 2 represents G.711a 3 represents G.726 at rate 32 kbps 4 represents G.729a 5 represents G.729ab 6 represents clear channel 7 represents G.726 at rate 16 kbps 8 represents G.726 at rate 24 kbps 9 represents G.726 at rate 40 kbps 10 RESERVED 11 represents G.723.1-H at rate 6.4kbps 12 represents G.723.1a-H at rate 6.4kbps with SID 13 represents G.723.1-L at rate 5.3kbps 14 represents G.723.1a-L at rate 5.3kbps with SID ')
vismCodecName = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 18, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismCodecName.setStatus('mandatory')
if mibBuilder.loadTexts: vismCodecName.setDescription(' This object holds the name of the codec for example index 1 will have G.711u as the codec name index 2 will have G.711a as the codec name and so on.... ')
vismCodecPktPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 18, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(10, 20, 30, 40, 60))).clone(namedValues=NamedValues(("ten", 10), ("twenty", 20), ("thirty", 30), ("fourty", 40), ("sixty", 60)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismCodecPktPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: vismCodecPktPeriod.setDescription(' This object gives the packetization period for a particular codec in milli secs. for G.711a allowed values are 10 & 20 for G.711u allowed values are 10 & 20 for G.726 at rate 32 kbps allowed values are 10 ,20 30 & 40 for G.729a allowed values are 10, 20 ,30 & 40 for G.729ab allowed values are 10, 20, 30 & 40 for clear channel allowed values are 10 and 20 for G.723 allowed values are 30 & 60 Default value for G.723 is 30 and for other codecs it is 10. ')
vismCodecPreference = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 18, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismCodecPreference.setStatus('mandatory')
if mibBuilder.loadTexts: vismCodecPreference.setDescription(' This object contains the user configured preference for each codec. Lower the number, higher the preference of the codec . Since currently we only have 14 codecs supported, the allowed range of this object is 0-13. If the call agent does not specify the preferred codec list in CRCX request then the codec used will be the one of highest preference, as configured in this object. The default preference based on the codec type is G729ab will have preference 1 G729a will have preference 2 G726 at rate 16 kbps will have preference 3 G726 at rate 24 kbps will have preference 4 G726 at rate 32 kbps will have preference 5 G726 at rate 40 kbps will have preference 6 G.711u will have preference 7 for T1 and will have preference 8 for E1 G.711a will have preference 7 for E1 card and will have preference 8 for T1 clearChannel will have preference 9 G723H will have preference 10 G723AH will have preference 11 G723L will have preference 12 G723AL will have preference 13 This object is not applicable in releases earlier than VISM2.0.1. If the preference of a codec is zero then that codec will not be used. ')
vismCodecString = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 18, 1, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismCodecString.setStatus('mandatory')
if mibBuilder.loadTexts: vismCodecString.setDescription(' The local connection option or SDP descriptor string that vism would get from the call agent for the codec to be used will be in the form of PCMU, PCMA, G726 at rate 32 kbps, G729a, CCD ..... where in PCMU stands for G711u PCMA stands for G711a and CCD stands for clear channel This object serves as a mapping string, and the vism will use the value configured in this object to match the SDP descriptor string obtained for a codec in a CRCX or MDCX message. Since the entries in this table are implicitly created by default the entry with codec = G.711u will have a value of PCMU G.711a will have a value of PCMA clear channel will have a value of CCD G.726 at rate 32 kbps will have G726 at rate 32 kbps G.726 at rate 16 kbps will have G726 at rate 16 kbps G.726 at rate 24 kbps will have G726 at rate 24 kbps G.726 at rate 40 kbps will have G726 at rate 40 kbps G.729a will have G729a G.729ab will have G729ab G.723.1-H will have G723H G.723.1a-H will have G723AH G.723.1-L will have G723L G.723.1a-L will have G723AL ')
vismCodecIanaType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 18, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 96))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismCodecIanaType.setStatus('mandatory')
if mibBuilder.loadTexts: vismCodecIanaType.setDescription(' The codecs are assigned types (numbers) by IANA. This object will contain such a number. In future we may have more numbers. currently by default we have PCMU = 0 G.726 at rate 32 kbps = 2 PCMA = 8 and the rest codecs will have 96 If in a SDP string we would just receive an IANA type number and not the codec string, then vism would use the value in this object to derive the actual codec to be used in the bearer path. The valid Iana type numbers currently defined are from (0 .. 95) So if an entry has a value of 96 that means it is not a registered codec.In that case the actual codec will be determined by the vism using the rtpmap in SDP string. ')
vismCardCacFailuresGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 20))
vismPortCacPvcAddFailures = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 20, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismPortCacPvcAddFailures.setStatus('mandatory')
if mibBuilder.loadTexts: vismPortCacPvcAddFailures.setDescription('Total number of attempts to add or modify a PVC to VISM virtual port that were rejected by port level connection admission control. ')
vismPortCacSvcAddFailures = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 20, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismPortCacSvcAddFailures.setStatus('mandatory')
if mibBuilder.loadTexts: vismPortCacSvcAddFailures.setDescription('Total number of attempts to add a SVC to VISM virtual port that were rejected by port level connection admission control. ')
vismVcCacPvcFailures = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 20, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismVcCacPvcFailures.setStatus('mandatory')
if mibBuilder.loadTexts: vismVcCacPvcFailures.setDescription('Total number of attempts to admit voice connections over bearer PVC connections that were rejected by voice connection admission control. It is sum of all voice connection admission control failures for all VISM bearer PVC connections. ')
vismVcCacPvcUpspeedFailures = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 20, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismVcCacPvcUpspeedFailures.setStatus('mandatory')
if mibBuilder.loadTexts: vismVcCacPvcUpspeedFailures.setDescription('Total number of attempts to upspeed voice connections over bearer PVC connections that were rejected by Port Level Connection Admission Control. ')
vismPortCacSvcUpspeedFailures = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 20, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismPortCacSvcUpspeedFailures.setStatus('mandatory')
if mibBuilder.loadTexts: vismPortCacSvcUpspeedFailures.setDescription('Total number of attempts to upspeed voice connections over bearer SVC connections that were rejected by Port Level Connection Admission Control. ')
mibBuilder.exportSymbols("CISCO-WAN-AXIPOP-MIB", ascLmiStatusTx=ascLmiStatusTx, vismHdlcRcvCrcErrors=vismHdlcRcvCrcErrors, vismCacRejectionPolicy=vismCacRejectionPolicy, cesChanIdleDetEnable=cesChanIdleDetEnable, bbChanGcra1Action=bbChanGcra1Action, delShelfNum=delShelfNum, ds0InputGain=ds0InputGain, frConnMCR=frConnMCR, ausmInterfacePortNum=ausmInterfacePortNum, vismChanMbsEgress=vismChanMbsEgress, rcvFramesDiscXceedQDepth=rcvFramesDiscXceedQDepth, vismChanRcvATMState=vismChanRcvATMState, vismSvcRxCallProcs=vismSvcRxCallProcs, vrtlIntrRxdRmCellCnt=vrtlIntrRxdRmCellCnt, portIngrSvcBandW=portIngrSvcBandW, ascLmiInvalidTransaction=ascLmiInvalidTransaction, bertBitErrorCount=bertBitErrorCount, portEqueueServiceRatio=portEqueueServiceRatio, srmeCnfGrpTable=srmeCnfGrpTable, frConnRemotePCR=frConnRemotePCR, bbIfCntSigILMIGrp=bbIfCntSigILMIGrp, vismFarEndAddressType=vismFarEndAddressType, pxmSecondaryInbandClockSourceLineNumber=pxmSecondaryInbandClockSourceLineNumber, ausmStdABRADTF=ausmStdABRADTF, bbIfStateGrpTable=bbIfStateGrpTable, frChanStateGrpEntry=frChanStateGrpEntry, vismPortCnfGrp=vismPortCnfGrp, parTrkStatReserve=parTrkStatReserve, ausmConnPercentUtil=ausmConnPercentUtil, ausmPortCnfServiceQueGrp=ausmPortCnfServiceQueGrp, portSpeed=portSpeed, vismVoIpDPvcOamCellGap=vismVoIpDPvcOamCellGap, chanDEtoCLPmap=chanDEtoCLPmap, trapReceived=trapReceived, ausmChanTestStateCPESide=ausmChanTestStateCPESide, ds0ReceivedCode=ds0ReceivedCode, bnmPortXmtCellRate=bnmPortXmtCellRate, bbIfCntGrpEntry=bbIfCntGrpEntry, vismAal2CidFailReason=vismAal2CidFailReason, chanReroute=chanReroute, bbRemoteConnPCR=bbRemoteConnPCR, cesPortsUsedLine7=cesPortsUsedLine7, ausmPortStateGrp=ausmPortStateGrp, cesPortsUsedLine3=cesPortsUsedLine3, ds0CasGlareTime=ds0CasGlareTime, bbIfOversubscribed=bbIfOversubscribed, rpmChanMCR=rpmChanMCR, vismDspGrp=vismDspGrp, chanLocRmtLpbkState=chanLocRmtLpbkState, portIngrPercentUtil=portIngrPercentUtil, vismChanVADTolerance=vismChanVADTolerance, bbChanLocalNsapAddr=bbChanLocalNsapAddr, rpmIfRscPrtEgrPctBandwidth=rpmIfRscPrtEgrPctBandwidth, bbChanNonConformCellsAtGcra2Policer=bbChanNonConformCellsAtGcra2Policer, cesPortLineNum=cesPortLineNum, bbChanDscdClp1Cells=bbChanDscdClp1Cells, atmNetPrefixGroup=atmNetPrefixGroup, ascLineCnfSigLmiGrp=ascLineCnfSigLmiGrp, frPortStateGrpTable=frPortStateGrpTable, frResPartDlciLow=frResPartDlciLow, ausmEndPortNum=ausmEndPortNum, cesReassCells=cesReassCells, aumClockConfig=aumClockConfig, rcvFramesDiscAlignmentError=rcvFramesDiscAlignmentError, vismChanCdvt=vismChanCdvt, vismCardCacFailuresGrp=vismCardCacFailuresGrp, ausmPortCnfPortImaGrpEntry=ausmPortCnfPortImaGrpEntry, connNumOfValidEntries=connNumOfValidEntries, chanSecInService=chanSecInService, commonConnParm2=commonConnParm2, imatmDsx3PortCntrsEntry=imatmDsx3PortCntrsEntry, chanShelfAlarmDiscardCells=chanShelfAlarmDiscardCells, frstdABRTBE=frstdABRTBE, tooBigError=tooBigError, vrtlIntrPortNum=vrtlIntrPortNum, rpmChanVirtualTemplate=rpmChanVirtualTemplate, stateChanNum=stateChanNum, ingressQDEThresh=ingressQDEThresh, chanServiceRate=chanServiceRate, xmtBytes=xmtBytes, primaryClockSource=primaryClockSource, cesmEndPtMapGrpEntry=cesmEndPtMapGrpEntry, vismSvcConnAckExpiries=vismSvcConnAckExpiries, ausmStdABRTBE=ausmStdABRTBE, vismHdlcChanTable=vismHdlcChanTable, chanIngrPeakQDepth=chanIngrPeakQDepth, egrQIndex=egrQIndex, srm3T3CnfGrp=srm3T3CnfGrp, parTrkLineLoad=parTrkLineLoad, rcvBytesCLLM=rcvBytesCLLM, vismPortResPartCnfGrp=vismPortResPartCnfGrp, parCmParmsRrGroupInc=parCmParmsRrGroupInc, parTrkLoadXmtUsedCbr=parTrkLoadXmtUsedCbr, endVpi=endVpi, parSelfNode=parSelfNode, vrtlIntrState=vrtlIntrState, ausmPortCnfServiceQueGrpTable=ausmPortCnfServiceQueGrpTable, cesCntChanNum=cesCntChanNum, x21CnfGrp=x21CnfGrp, atmAddressTable=atmAddressTable, vismChanLocRmtLpbkState=vismChanLocRmtLpbkState, parMnUpdt=parMnUpdt, vismVoIpVADTimer=vismVoIpVADTimer, parIfLoAddrMax=parIfLoAddrMax, vismRestrictTrunkType=vismRestrictTrunkType, ds0CasCadenceOffTime=ds0CasCadenceOffTime, commonPortSpeed=commonPortSpeed, xmtBytesTaggedDE=xmtBytesTaggedDE, vrtlIntrQbinClpHiThreshold=vrtlIntrQbinClpHiThreshold, rcvAsynchUpdate=rcvAsynchUpdate, frstdABRCnfGrpTable=frstdABRCnfGrpTable, bbChanOvrSubOvrRide=bbChanOvrSubOvrRide, egrRcvUtilization=egrRcvUtilization, snmpPduReceived=snmpPduReceived, delSlotNum=delSlotNum, vismStateChanNum=vismStateChanNum, rpmIfRscSlotNum=rpmIfRscSlotNum, bbChanRcvEOFCells=bbChanRcvEOFCells, cesVpcFlag=cesVpcFlag, cesChanOnhookCode=cesChanOnhookCode, vismChanAal2CpsInvCidPkts=vismChanAal2CpsInvCidPkts, ausmChanClrButton=ausmChanClrButton, vrtlIntrXmtdOAMCellCnt=vrtlIntrXmtdOAMCellCnt, cesmPortCnfResPartGrp=cesmPortCnfResPartGrp, vismSvcTxConns=vismSvcTxConns, foresightEnable=foresightEnable, parTrkCnfgAdminStatus=parTrkCnfgAdminStatus, parTrkLoadRcvUsedTs=parTrkLoadRcvUsedTs, axisImaGroupFailureStatus=axisImaGroupFailureStatus, parOnOffDynamicBwAlloc=parOnOffDynamicBwAlloc, frstdABRADTF=frstdABRADTF, queConfigVrtlIntrNum=queConfigVrtlIntrNum, bnmIngressInvalidCellHdr=bnmIngressInvalidCellHdr, axisAtmNetPrefixPort=axisAtmNetPrefixPort, cesChanStatusBitMap=cesChanStatusBitMap, parTrkLoadVpcConidsUsed=parTrkLoadVpcConidsUsed, parConnRstrZcs=parConnRstrZcs, chanEgrRcvState=chanEgrRcvState, frRemoteVci=frRemoteVci, vismCodecName=vismCodecName, ausmCDRNumber=ausmCDRNumber, frstdABRICR=frstdABRICR, vismCnfChanNum=vismCnfChanNum, pxmExtClockPresent=pxmExtClockPresent, rpmIfRscPartIfNum=rpmIfRscPartIfNum, aumConnType=aumConnType, serialPortNumOfValidEntries=serialPortNumOfValidEntries, vismSvcTxRestartAcks=vismSvcTxRestartAcks, parCmParmMaxViaCons=parCmParmMaxViaCons, cesPortDs0ConfigBitMap=cesPortDs0ConfigBitMap, vismResPartCtrlrID=vismResPartCtrlrID, bertOwner=bertOwner, bnmPortXmtUtilization=bnmPortXmtUtilization, vismCasTRinging=vismCasTRinging, vismCodecIanaType=vismCodecIanaType, parTrkTable=parTrkTable, channelizedAllowed=channelizedAllowed, vismHdlcLcnNum=vismHdlcLcnNum, bearerRcvdOctets=bearerRcvdOctets, bbConnPercentUtil=bbConnPercentUtil, ausmStateChanNum=ausmStateChanNum, axisAtmAddressAtmAddress=axisAtmAddressAtmAddress, pxmClkStratumLevel=pxmClkStratumLevel, cesmConnRemotePCR=cesmConnRemotePCR, frPortServiceQueGrpEntry=frPortServiceQueGrpEntry, parTrkCnfgTrafficClassAbr=parTrkCnfgTrafficClassAbr, portNextAvailable=portNextAvailable, frPortStateGrpEntry=frPortStateGrpEntry, parSysParmsMaxIpcdpHsdDelay=parSysParmsMaxIpcdpHsdDelay, imaCntPortNum=imaCntPortNum, bertBitCount=bertBitCount, vismJitterInitialDelay=vismJitterInitialDelay, parCmParmsRerouteGroups=parCmParmsRerouteGroups, ausmPortIngrSvcBandW=ausmPortIngrSvcBandW, pxmPrimarySMClockSourceSlotNumber=pxmPrimarySMClockSourceSlotNumber, ausmLocalVci=ausmLocalVci, pxmClkErrReason=pxmClkErrReason, x21Severity=x21Severity, parOnOffRenumRec=parOnOffRenumRec, bbChanConnType=bbChanConnType, frConnRemoteMBS=frConnRemoteMBS, frChanUpcEnable=frChanUpcEnable, parConnRemoteEndpt=parConnRemoteEndpt, vismConfig=vismConfig, vismChanCacRejectionPolicy=vismChanCacRejectionPolicy, txFifoFullCnt=txFifoFullCnt, cesLocalVpi=cesLocalVpi, rcvFramesDiscUPC=rcvFramesDiscUPC, vismSvcTxCallProcs=vismSvcTxCallProcs, bbIfCntGrpTable=bbIfCntGrpTable, chanVpi=chanVpi, x21LineRate=x21LineRate, axisAtmNetPrefixOperStatus=axisAtmNetPrefixOperStatus, chanPacketNumber=chanPacketNumber, vismPortCnfGrpEntry=vismPortCnfGrpEntry, bbIfCnfSigILMIGrp=bbIfCnfSigILMIGrp, parSysParmsMaxIpcdpDDelay=parSysParmsMaxIpcdpDDelay, vismAal2Grp=vismAal2Grp, ausmChanReroute=ausmChanReroute, bbChanIngrPercentUtil=bbChanIngrPercentUtil, parTrkLocalSlotNumber=parTrkLocalSlotNumber, parCmParmsUseCache=parCmParmsUseCache, xmtFramesLengthViolations=xmtFramesLengthViolations, bbIfMaxCellRatePct=bbIfMaxCellRatePct, vismAal2CidCodecType=vismAal2CidCodecType, cesmResPartNumOfLcnAvail=cesmResPartNumOfLcnAvail, ausmLineNum=ausmLineNum, vismResPartEgrPctBW=vismResPartEgrPctBW, egrQCLPState=egrQCLPState, vismSvcTxResyncStrts=vismSvcTxResyncStrts, lcpDelayTolerance=lcpDelayTolerance, ausmPortSvcVciLow=ausmPortSvcVciLow, xmtFramesBECN=xmtFramesBECN, bbIfNoSuchNameError=bbIfNoSuchNameError, ausmChanEgrPercentUtil=ausmChanEgrPercentUtil, chanCongestMinutes=chanCongestMinutes, portRowStatus=portRowStatus, portSvcShareLcn=portSvcShareLcn, parSwFuncAbrVsvd=parSwFuncAbrVsvd, xmtCLLMStatusTimer=xmtCLLMStatusTimer, bbChanRemoteVpi=bbChanRemoteVpi, serialInterfaceEntry=serialInterfaceEntry, rcvLastUnknownDLCI=rcvLastUnknownDLCI, foresightPIR=foresightPIR, bert=bert, vismMaxCost=vismMaxCost, ausmInterfaceConfEntry=ausmInterfaceConfEntry, pxmAtmVcCrossConnectH2LLastChange=pxmAtmVcCrossConnectH2LLastChange, ausmPortSvcVpiLow=ausmPortSvcVpiLow, cesLocalVci=cesLocalVci, vismLocalVpi=vismLocalVpi, frServPortNum=frServPortNum, ds0CasOutgoingMgcpPackage=ds0CasOutgoingMgcpPackage, ausmChanCntGrpEntry=ausmChanCntGrpEntry, parTrkAlarmType=parTrkAlarmType, aumAddressTranslationTable=aumAddressTranslationTable, bbChanUpcEnable=bbChanUpcEnable, cllmFailures=cllmFailures, parIfLogicalInterface=parIfLogicalInterface, asynchronousUpdates=asynchronousUpdates, vismVoIpDPvcRecoverCnt=vismVoIpDPvcRecoverCnt, vismCodecTemplateMaxChanCount=vismCodecTemplateMaxChanCount, rcvFramesDE=rcvFramesDE, rpmChanBurstSize=rpmChanBurstSize, ausmChanTestTypeCPESide=ausmChanTestTypeCPESide, atmLineRcvHecErrorCells=atmLineRcvHecErrorCells, cesmResPartLcnLow=cesmResPartLcnLow, vismAal2CidEntry=vismAal2CidEntry, vismHdlcRcvFrames=vismHdlcRcvFrames, rpmChanRemotePCR=rpmChanRemotePCR, vrtlIntrRxdClpUntaggedDiscardedCellCnt=vrtlIntrRxdClpUntaggedDiscardedCellCnt, imatmClrVpTrkButton=imatmClrVpTrkButton, ausmConnPCR=ausmConnPCR, portFRF1Dot2Support=portFRF1Dot2Support)
mibBuilder.exportSymbols("CISCO-WAN-AXIPOP-MIB", bbIfMinTrapInterval=bbIfMinTrapInterval, rpmChanVcd=rpmChanVcd, vrtlIntrXmtdClpTaggedCellCnt=vrtlIntrXmtdClpTaggedCellCnt, vrtlIntrRxdClpUntaggedCellCnt=vrtlIntrRxdClpUntaggedCellCnt, portSvcLcnLow=portSvcLcnLow, queConfigVrtlIntrQbinNum=queConfigVrtlIntrQbinNum, NetPrefix=NetPrefix, portDs0Speed=portDs0Speed, imatmDsx3SingleBitErrCorrEnable=imatmDsx3SingleBitErrCorrEnable, switchCoreCard=switchCoreCard, axisImaGroupIntegrationUpTime=axisImaGroupIntegrationUpTime, asmUnitMeasuredValue=asmUnitMeasuredValue, egrQServiceSequence=egrQServiceSequence, ausmChanState=ausmChanState, frChanStatsEnable=frChanStatsEnable, vismCntClrButton=vismCntClrButton, chanOAMstatus128=chanOAMstatus128, xmtBytesDiscXceedQDepth=xmtBytesDiscXceedQDepth, bbIfSpeed=bbIfSpeed, srm3T3CnfGrpEntry=srm3T3CnfGrpEntry, portRcvCrcErrOAMCells=portRcvCrcErrOAMCells, parCmParmsDnUpPerPass=parCmParmsDnUpPerPass, vismConfigChangeTypeBitMap=vismConfigChangeTypeBitMap, vismResPartRowStatus=vismResPartRowStatus, axisImaGroupBetaValue=axisImaGroupBetaValue, portsUsedLine3=portsUsedLine3, axisImaGroupMinNumRxLinks=axisImaGroupMinNumRxLinks, vismSvcRxBulkResyncs=vismSvcRxBulkResyncs, bnmPortXmtCells=bnmPortXmtCells, bertDDSCode=bertDDSCode, axisImaGroupIntegrationDownTime=axisImaGroupIntegrationDownTime, smRasConfig=smRasConfig, bertPort=bertPort, imatmTrkMaxVp=imatmTrkMaxVp, cesEndPortNum=cesEndPortNum, vismPortResPartCnfGrpTable=vismPortResPartCnfGrpTable, vismAggregateTrafficClipping=vismAggregateTrafficClipping, parSysParmsDrtDelay=parSysParmsDrtDelay, axisImaGroupNeTxClkMode=axisImaGroupNeTxClkMode, imatmDsx3CardSpecConfigGrpTable=imatmDsx3CardSpecConfigGrpTable, axisAtmAddressPort=axisAtmAddressPort, vismSvcRxConns=vismSvcRxConns, cesLocalNSAP=cesLocalNSAP, bbChanCnfGrpTable=bbChanCnfGrpTable, vismFarEndNSAPAddress=vismFarEndNSAPAddress, vismSvcAtmQosGrp=vismSvcAtmQosGrp, bbIfMinVpi=bbIfMinVpi, ausmConnForeSightEnable=ausmConnForeSightEnable, vismChanAal2CpsInvUuiPkts=vismChanAal2CpsInvUuiPkts, atmLineCnfTable=atmLineCnfTable, cardOversubscribed=cardOversubscribed, sigCntBbIfNum=sigCntBbIfNum, imatmDsx3PortRcvCells=imatmDsx3PortRcvCells, xmtFramesDE=xmtFramesDE, vismAal2Type3Redundancy=vismAal2Type3Redundancy, bbChanUpcCDVT=bbChanUpcCDVT, parVsiConfigParms=parVsiConfigParms, ascLmiInvalidPduLenRx=ascLmiInvalidPduLenRx, vismCasVariantName=vismCasVariantName, vismAal2CidCasTransport=vismAal2CidCasTransport, vismChanCacRejectedCons=vismChanCacRejectedCons, parSysParmsMaxHsdDelay=parSysParmsMaxHsdDelay, ausmEndPointMapGrp=ausmEndPointMapGrp, vismBearerSubNetMask=vismBearerSubNetMask, vismVcCacPvcUpspeedFailures=vismVcCacPvcUpspeedFailures, cesConnServiceType=cesConnServiceType, parTrkRemoteNodeId=parTrkRemoteNodeId, ausmPortCnfSigILMIGrp=ausmPortCnfSigILMIGrp, vismCodecTemplateCnfGrp=vismCodecTemplateCnfGrp, bnmPortRcvCells=bnmPortRcvCells, ds0InsertLocalCas=ds0InsertLocalCas, bbIfXmtRmCells=bbIfXmtRmCells, vismLocalNSAP=vismLocalNSAP, vismChanStateGrpEntry=vismChanStateGrpEntry, portRcvSgmtLpbkCells=portRcvSgmtLpbkCells, frRoutingPriority=frRoutingPriority, chanNumNextAvailable=chanNumNextAvailable, imatmdsx3PortIndex=imatmdsx3PortIndex, vismChanAal2InvParCells=vismChanAal2InvParCells, ausmPortCntSigILMIGrp=ausmPortCntSigILMIGrp, diagType=diagType, locImaId=locImaId, parTrkLoadRcvUsedVoice=parTrkLoadRcvUsedVoice, parNetParmNetwLetWait=parNetParmNetwLetWait, ausmStdABRRIF=ausmStdABRRIF, parSysParmsInvLogAlarmThres=parSysParmsInvLogAlarmThres, x21LineEIAStatus=x21LineEIAStatus, vrtlIntrConfigEntry=vrtlIntrConfigEntry, ausmPortCnfPortGrp=ausmPortCnfPortGrp, bertLoopbackOperation=bertLoopbackOperation, chanOAMstatus64=chanOAMstatus64, parNetParmCondInitialStgr=parNetParmCondInitialStgr, ingrXmtCells=ingrXmtCells, xmtFramesTaggedDE=xmtFramesTaggedDE, getRequestReceived=getRequestReceived, ds0CasFlashMinMakeTime=ds0CasFlashMinMakeTime, vismXgcpSdpOst=vismXgcpSdpOst, bbIfGetRequestTransmitted=bbIfGetRequestTransmitted, chanPpdDiscCells=chanPpdDiscCells, vismAal2EndptNum=vismAal2EndptNum, bbChanFrmDiscardThreshold=bbChanFrmDiscardThreshold, parTrkRemoteNodeType=parTrkRemoteNodeType, bearerSentPkts=bearerSentPkts, parTrkEntry=parTrkEntry, be=be, parCmParms=parCmParms, ingrUpcPCR0=ingrUpcPCR0, bnmPortCounterEntry=bnmPortCounterEntry, cesChanRowStatus=cesChanRowStatus, frConnTemplateId=frConnTemplateId, ausmPortDeleteSvcs=ausmPortDeleteSvcs, parConnLocalPort=parConnLocalPort, vrtlIntrCurrConfigPaths=vrtlIntrCurrConfigPaths, frConnAdminStatus=frConnAdminStatus, parConnRemotePort=parConnRemotePort, getResponseReceived=getResponseReceived, cesGenCells=cesGenCells, parPrefRoute=parPrefRoute, dsx3CardSpecCnfgGrp=dsx3CardSpecCnfgGrp, cesOflowDropBytes=cesOflowDropBytes, pxmAtmVcCrossConnectTable=pxmAtmVcCrossConnectTable, vismPrevMode=vismPrevMode, bbIfRcvClp0DiscCells=bbIfRcvClp0DiscCells, cesMaxCost=cesMaxCost, portBERTEnable=portBERTEnable, portsUsedLine5=portsUsedLine5, xmtBufNotAvailable=xmtBufNotAvailable, vismCacEnable=vismCacEnable, vismSvcRxResyncEndAcks=vismSvcRxResyncEndAcks, cesCDVRxT=cesCDVRxT, dsx0VismCnfEntry=dsx0VismCnfEntry, vismPortRowStatus=vismPortRowStatus, cesmChanCnfGrp=cesmChanCnfGrp, vrtlIntrCounterEntry=vrtlIntrCounterEntry, frstdABRCDF=frstdABRCDF, rcvFramesTaggedFECN=rcvFramesTaggedFECN, currentClock=currentClock, axisImaGroupNeState=axisImaGroupNeState, ausmConnSCR=ausmConnSCR, trapTransmitted=trapTransmitted, chanStatusBitMap=chanStatusBitMap, bbChanEfciThreshold=bbChanEfciThreshold, serialPortType=serialPortType, bbChanCntClrButton=bbChanCntClrButton, cesMapPortNum=cesMapPortNum, vismSystemGrp=vismSystemGrp, bertLoopbackMask=bertLoopbackMask, vismSvcAtmQosCdv=vismSvcAtmQosCdv, ausmCntPortNum=ausmCntPortNum, vismHdlcRcvBufOverflows=vismHdlcRcvBufOverflows, bbChanRcvCellsSent=bbChanRcvCellsSent, ausmStatePortNum=ausmStatePortNum, frPortCnfSigCLLMGrp=frPortCnfSigCLLMGrp, vismPortCacSvcAddFailures=vismPortCacSvcAddFailures, ausmChanStateGrpTable=ausmChanStateGrpTable, svcAllowed=svcAllowed, rcvFramesDiscIllegalHeader=rcvFramesDiscIllegalHeader, x21portSvcStatus=x21portSvcStatus, eventThresholdN492=eventThresholdN492, ingrRcvClpSetCells=ingrRcvClpSetCells, bertStatus=bertStatus, imatmPortRcvInvCells=imatmPortRcvInvCells, imaAutoRestart=imaAutoRestart, parTrkCnfgTrafficClassFr=parTrkCnfgTrafficClassFr, chanState=chanState, keepAlivePollingEnable=keepAlivePollingEnable, onlineDiagnostics=onlineDiagnostics, ds0CasWinkBreakTime=ds0CasWinkBreakTime, parRrtFailRsn=parRrtFailRsn, imaAllowed=imaAllowed, vismChanCnfGrpEntry=vismChanCnfGrpEntry, vismMastership=vismMastership, portEgresECNThresh=portEgresECNThresh, vismChanAal2CpsInvLenPkts=vismChanAal2CpsInvLenPkts, cesmConnForeSightEnable=cesmConnForeSightEnable, atmLineTotalRcvCells=atmLineTotalRcvCells, parClockPath=parClockPath, bbIfGetNextRequestReceived=bbIfGetNextRequestReceived, vrtlIntrQbinEfciThreshold=vrtlIntrQbinEfciThreshold, frEndPtMapGrpEntry=frEndPtMapGrpEntry, rpmIfRscPrtMaxChans=rpmIfRscPrtMaxChans, asmPhysicalAlarmState=asmPhysicalAlarmState, vismConnRemotePCR=vismConnRemotePCR, ausmRemoteVpi=ausmRemoteVpi, bnmEgressInvalidCellCount=bnmEgressInvalidCellCount, vismTrapObjGrp=vismTrapObjGrp, bbIfProtocolRevNo=bbIfProtocolRevNo, vismResPartPortNum=vismResPartPortNum, ds0SidPacket=ds0SidPacket, vismRemoteVpi=vismRemoteVpi, vismCodecCnfIndex=vismCodecCnfIndex, bbChanNumNextAvailable=bbChanNumNextAvailable, ausmPortCntSigILMIGrpEntry=ausmPortCntSigILMIGrpEntry, bbChanDiscardOption=bbChanDiscardOption, frPortCnfX21PortGrpTable=frPortCnfX21PortGrpTable, vismCasXgcpFileName=vismCasXgcpFileName, parNetParmHighTxRate=parNetParmHighTxRate, ascCntSigLmiGrp=ascCntSigLmiGrp, pxmAtmVcCrossConnectAdminStatus=pxmAtmVcCrossConnectAdminStatus, parIfEntry=parIfEntry, vismChanAal2CpsRcvdPkts=vismChanAal2CpsRcvdPkts, vismAal2InitVadTimer=vismAal2InitVadTimer, bbIfErrorThresholdN491=bbIfErrorThresholdN491, parCmParmsRrtCycleInterval=parCmParmsRrtCycleInterval, extClkSrcImpedance=extClkSrcImpedance, qirTimeout=qirTimeout, frConnServiceType=frConnServiceType, vismResPartNumOfLcnAvail=vismResPartNumOfLcnAvail, bertDDSSeekResultsTableIndex=bertDDSSeekResultsTableIndex, ascLmiMaxRetryN394=ascLmiMaxRetryN394, rtdMeasurementTime=rtdMeasurementTime, virtualInterfaceCnt=virtualInterfaceCnt, axisImaGroupNumRxCfgLnks=axisImaGroupNumRxCfgLnks, rpmChanInterface=rpmChanInterface, chanClrButton=chanClrButton, cesChanTestState=cesChanTestState, cesmResPartLcnHigh=cesmResPartLcnHigh, frstdABRTrm=frstdABRTrm, imatmVpTrkClrGrpTable=imatmVpTrkClrGrpTable, vismCntChanNum=vismCntChanNum, frChanStateGrpTable=frChanStateGrpTable, cllmSigPortNum=cllmSigPortNum, vismHdlcRowStatus=vismHdlcRowStatus, xmtFramesDiscSrcAbort=xmtFramesDiscSrcAbort, vrtlIntrTotalCellCnt=vrtlIntrTotalCellCnt, parTrkCnfgVpcConids=parTrkCnfgVpcConids, portSvcDlciHigh=portSvcDlciHigh, rpmChanLocalNsap=rpmChanLocalNsap, vismChanRowStatus=vismChanRowStatus, frChanCntGrp=frChanCntGrp, rcvStatus=rcvStatus, bertResourceStatus=bertResourceStatus, vismChanCarrierLossPolicy=vismChanCarrierLossPolicy, atmLineNum=atmLineNum, cesMapVpi=cesMapVpi, vismTftpServerDn=vismTftpServerDn, vismCasInterdigitTcrit=vismCasInterdigitTcrit, x21portSvcLcnHigh=x21portSvcLcnHigh, frPortCntSigCLLMGrpTable=frPortCntSigCLLMGrpTable, rpmChanState=rpmChanState, ascLmiStatusAckTx=ascLmiStatusAckTx, vismSvcTxRestarts=vismSvcTxRestarts, bnmPortCounterTable=bnmPortCounterTable, bbConnServiceType=bbConnServiceType, ausmChanCntGrp=ausmChanCntGrp, chanIngrEfciSetXmtCells=chanIngrEfciSetXmtCells, ethernetInterface=ethernetInterface, parTrkLoadTable=parTrkLoadTable, vismSvcAtmQosClr=vismSvcAtmQosClr, parConnLocalSlot=parConnLocalSlot, frChanSlaveType=frChanSlaveType, portRcvAisCells=portRcvAisCells, IfNsapAddress=IfNsapAddress, ausmPortSvcVpidHigh=ausmPortSvcVpidHigh)
mibBuilder.exportSymbols("CISCO-WAN-AXIPOP-MIB", bbIfRscPrtVpidHigh=bbIfRscPrtVpidHigh, bbIfRscPrtInUse=bbIfRscPrtInUse, asmAlarmSeverity=asmAlarmSeverity, commonChanEgrRcvState=commonChanEgrRcvState, bbIfSignallingVpi=bbIfSignallingVpi, parSnNodeId=parSnNodeId, vismSigGrp=vismSigGrp, chanEgrRcvUtilization=chanEgrRcvUtilization, parInterfaces=parInterfaces, cesmResPartCtrlrNum=cesmResPartCtrlrNum, imaPortState=imaPortState, pxmPrimaryMuxClockSource=pxmPrimaryMuxClockSource, vismAal2SubcellMuxing=vismAal2SubcellMuxing, ascLmiCnfLineNum=ascLmiCnfLineNum, asmAlarmEntry=asmAlarmEntry, frPortCnfSigLMIGrpTable=frPortCnfSigLMIGrpTable, vismChanAal2OamLpbLostCells=vismChanAal2OamLpbLostCells, xmtFramesDiscReassmFail=xmtFramesDiscReassmFail, bbIfPollingIntervalT491=bbIfPollingIntervalT491, smCardUtilization=smCardUtilization, vismBearerContinuityTimer=vismBearerContinuityTimer, addrRegEnable=addrRegEnable, parConnRstrTyp=parConnRstrTyp, bbChanUpcMBS=bbChanUpcMBS, commonPortNum=commonPortNum, pxmSecondaryMuxClockSource=pxmSecondaryMuxClockSource, ausmMastership=ausmMastership, bbIfSignallingProtocolType=bbIfSignallingProtocolType, cesChanRTDResult=cesChanRTDResult, xmtPortBytesDuringLMIAlarm=xmtPortBytesDuringLMIAlarm, ingrQCLPThreshHigh=ingrQCLPThreshHigh, bertPatternMask=bertPatternMask, ausmEndChanNum=ausmEndChanNum, ingrUpcEnable=ingrUpcEnable, cesPortNumOfDs0Slot=cesPortNumOfDs0Slot, axisImaGroupTestPattern=axisImaGroupTestPattern, cesChanStrauSciNum=cesChanStrauSciNum, xmtFramesDuringLMIAlarm=xmtFramesDuringLMIAlarm, bbChanStateNum=bbChanStateNum, bbIfRcvValidOAMCells=bbIfRcvValidOAMCells, vismExtDnsServerDn=vismExtDnsServerDn, vismChanClrEgress=vismChanClrEgress, srmStartT1LineNum=srmStartT1LineNum, vismSvcRxReleases=vismSvcRxReleases, cardLcnPartitionType=cardLcnPartitionType, vismChanTestState=vismChanTestState, pxmAtmVcCrossConnectIndexNext=pxmAtmVcCrossConnectIndexNext, frRemoteNSAP=frRemoteNSAP, imaGrpRcvHecErrCount=imaGrpRcvHecErrCount, rcvInvalidRequest=rcvInvalidRequest, xmtFramesUnderrun=xmtFramesUnderrun, ds0CasDelayImmedStart=ds0CasDelayImmedStart, rpmChanLocalVpi=rpmChanLocalVpi, pxmClockConfig=pxmClockConfig, axisImaGroupTxTimingRefLink=axisImaGroupTxTimingRefLink, ausmPortDelSvcsGrp=ausmPortDelSvcsGrp, bertSupportedTestsTableEntry=bertSupportedTestsTableEntry, serialPortNum=serialPortNum, pxmExtClkConnectorType=pxmExtClkConnectorType, parNetParmCondPerNodeInterval=parNetParmCondPerNodeInterval, dsx0VismCnfTable=dsx0VismCnfTable, parNetParmCfDelay=parNetParmCfDelay, bbChanMaxCost=bbChanMaxCost, bbChanTestState=bbChanTestState, frPortStateGrp=frPortStateGrp, ausmPortStateImaGrpTable=ausmPortStateImaGrpTable, rcvPortFramesDE=rcvPortFramesDE, bertSlotNumber=bertSlotNumber, imaPortEnable=imaPortEnable, bbIfRscPrtVpidLow=bbIfRscPrtVpidLow, vismSvcResyncExpiries=vismSvcResyncExpiries, rcvFramesUnknownDLCI=rcvFramesUnknownDLCI, imaPortEgrPercentUtil=imaPortEgrPercentUtil, ausmPortCntPortImaGrp=ausmPortCntPortImaGrp, ausmStdABRPCR=ausmStdABRPCR, chanEgrPortQfullDiscardCells=chanEgrPortQfullDiscardCells, connChanNum=connChanNum, frPortCnfX21PortGrpEntry=frPortCnfX21PortGrpEntry, vismFarEndGWIDAddress=vismFarEndGWIDAddress, parTrkLoadRcvUsedCbr=parTrkLoadRcvUsedCbr, cesmChanCnfGrpEntry=cesmChanCnfGrpEntry, bbIfRscPrtMaxChans=bbIfRscPrtMaxChans, frPortsUsedLineGrpEntry=frPortsUsedLineGrpEntry, portRcvFerfCells=portRcvFerfCells, bbChanIfNum=bbChanIfNum, ascLmiUpdateStatusRx=ascLmiUpdateStatusRx, xmtFramesDiscXceedQDepth=xmtFramesDiscXceedQDepth, vismResPartIngrPctBW=vismResPartIngrPctBW, parTrkCnfgTrafficClassFst=parTrkCnfgTrafficClassFst, connVPINum=connVPINum, bbChanDscdClpZeroCellsToPort=bbChanDscdClpZeroCellsToPort, srm3T3CnfGrpTable=srm3T3CnfGrpTable, vismSvcReleasExpiries=vismSvcReleasExpiries, lcpCellsPeriodicity=lcpCellsPeriodicity, ausmPortCnfPortGrpEntry=ausmPortCnfPortGrpEntry, ausmChanTestState=ausmChanTestState, rcvPortFramesTaggedDE=rcvPortFramesTaggedDE, chanOAMstatus192=chanOAMstatus192, ausmPortCntPortGrpEntry=ausmPortCntPortGrpEntry, vismChanProtection=vismChanProtection, rcvFramesTaggedDE=rcvFramesTaggedDE, ds0CasIncomingMgcpPackage=ds0CasIncomingMgcpPackage, vrtlIntrQbinRxdCellCnt=vrtlIntrQbinRxdCellCnt, pxmAtmVcCrossConnectEntry=pxmAtmVcCrossConnectEntry, parTrkCnfgPassSync=parTrkCnfgPassSync, frstdABRMCR=frstdABRMCR, bnmPortRcvCellRate=bnmPortRcvCellRate, commonConnType=commonConnType, parTrkCnfgTrafficClassVoice=parTrkCnfgTrafficClassVoice, queCounterVrtlIntrQbinNum=queCounterVrtlIntrQbinNum, ausmPortImaGrpRestart=ausmPortImaGrpRestart, ascLmiNodeStatusAckTx=ascLmiNodeStatusAckTx, commonPort=commonPort, portsUsedLine7=portsUsedLine7, frPortCntSigLMIGrp=frPortCntSigLMIGrp, ascLmiRcvAbitState=ascLmiRcvAbitState, egrXmtCellRate=egrXmtCellRate, xmtATMState=xmtATMState, cesmPortCnfResPartGrpEntry=cesmPortCnfResPartGrpEntry, pxmExtClkSrcImpedance=pxmExtClkSrcImpedance, serialLineRate=serialLineRate, foresightMIR=foresightMIR, bbIfLineNum=bbIfLineNum, frResPartCtrlrID=frResPartCtrlrID, vrtlIntrQbinCurrentCellCnt=vrtlIntrQbinCurrentCellCnt, chanTestType=chanTestType, frChanCnfChangeCount=frChanCnfChangeCount, vismChanPreference=vismChanPreference, bbIfSigCntClrButton=bbIfSigCntClrButton, parNetParmBlindMaxTimeout=parNetParmBlindMaxTimeout, aumAddressTranslationEntry=aumAddressTranslationEntry, frResPartEgrPctBW=frResPartEgrPctBW, bnmPortRcvUtilization=bnmPortRcvUtilization, pir=pir, imatmTrkNum=imatmTrkNum, vismPayloadType=vismPayloadType, x21LineInterfaceType=x21LineInterfaceType, vismVCCI=vismVCCI, xmtPortBytesDiscXceedQDepth=xmtPortBytesDiscXceedQDepth, vismHdlcTxAbortFrames=vismHdlcTxAbortFrames, ds0CasVariantName=ds0CasVariantName, asmAlarmNum=asmAlarmNum, bbRemoteConnSCR=bbRemoteConnSCR, vrtlIntrConfigTable=vrtlIntrConfigTable, cesCnfChanNum=cesCnfChanNum, bbIfCntSigILMIGrpEntry=bbIfCntSigILMIGrpEntry, vrtlIntrCounterTable=vrtlIntrCounterTable, portHeaderLen=portHeaderLen, xmtPortFramesFECN=xmtPortFramesFECN, vismChanScrIngress=vismChanScrIngress, srmeRowStatus=srmeRowStatus, pxmAtmVcCrossConnectLowVci=pxmAtmVcCrossConnectLowVci, ausmResPartPortNum=ausmResPartPortNum, vismRemoteVci=vismRemoteVci, vismChanActivityState=vismChanActivityState, x21AlmGrpTable=x21AlmGrpTable, parCmParmsRerouteTimer=parCmParmsRerouteTimer, vismPacketizationPeriod=vismPacketizationPeriod, rpmChanGrpEntry=rpmChanGrpEntry, vismChanStateGrpTable=vismChanStateGrpTable, rcvATMState=rcvATMState, vismVoIpCasTransport=vismVoIpCasTransport, x21portIngrSvcBandW=x21portIngrSvcBandW, pxmAtmVcCrossConnectHighVci=pxmAtmVcCrossConnectHighVci, commonPortType=commonPortType, parSysParmsMaxCDelay=parSysParmsMaxCDelay, ausmPortSvcLcnHigh=ausmPortSvcLcnHigh, x21AlmCnfLineNum=x21AlmCnfLineNum, vismChanMbsIngress=vismChanMbsIngress, chanConnDesc=chanConnDesc, bearerAal2ExtAISCnts=bearerAal2ExtAISCnts, ds0TransmitCodesEnable=ds0TransmitCodesEnable, ascLmiPollingInterval=ascLmiPollingInterval, egrQosFeature=egrQosFeature, bertAbortReason=bertAbortReason, cesRestrictTrunkType=cesRestrictTrunkType, xmtFramesDiscPhyLayerFail=xmtFramesDiscPhyLayerFail, parNetParmMsgMaxTimeout=parNetParmMsgMaxTimeout, dLCI=dLCI, commonPortSignallingProtocolType=commonPortSignallingProtocolType, cardResPartNumOfLcnAvail=cardResPartNumOfLcnAvail, bbStateIfNum=bbStateIfNum, vismVoIpSIDPayloadType=vismVoIpSIDPayloadType, vismChanLockingState=vismChanLockingState, asmNumOfValidEntries=asmNumOfValidEntries, diagResult=diagResult, bbChanCntGrpTable=bbChanCntGrpTable, bbChanClpHiThreshold=bbChanClpHiThreshold, x21AlmCnfGrp=x21AlmCnfGrp, ingrRcvUtilization=ingrRcvUtilization, bearerCntClrButton=bearerCntClrButton, bnmEgressXmtCellCountDuringAlarm=bnmEgressXmtCellCountDuringAlarm, axisImaGroupTestProcStatus=axisImaGroupTestProcStatus, parSysParmsMaxCdpADelay=parSysParmsMaxCdpADelay, portServiceQueueNo=portServiceQueueNo, egressQDEThresh=egressQDEThresh, ausmDelSvcsPortNum=ausmDelSvcsPortNum, x21portSvcLcnLow=x21portSvcLcnLow, vismSvcTrfScalingGrp=vismSvcTrfScalingGrp, bbCntIfNum=bbCntIfNum, bbIfCntSigILMIGrpTable=bbIfCntSigILMIGrpTable, ingrQDepth=ingrQDepth, maxTolerableDiffDelay=maxTolerableDiffDelay, bertDS0DPIterationCount=bertDS0DPIterationCount, xmtBytesDE=xmtBytesDE, t392PollingVerificationTimer=t392PollingVerificationTimer, xmtFramesTaggedBECN=xmtFramesTaggedBECN, bbIfRscPrtVciLow=bbIfRscPrtVciLow, vismResPartLcnLow=vismResPartLcnLow, ausmPortCnfResPartGrpTable=ausmPortCnfResPartGrpTable, bbChanXmtClp0Cells=bbChanXmtClp0Cells, frPortCntPortGrpEntry=frPortCntPortGrpEntry, apsCardAttributes=apsCardAttributes, nextRangeNumAvail=nextRangeNumAvail, frResPartCtrlrNum=frResPartCtrlrNum, lmiSigPortNum=lmiSigPortNum, imaPortNum=imaPortNum, rpmIfCnfResPart=rpmIfCnfResPart, vismChanConnType=vismChanConnType, vismSvcTrfScalingFactor=vismSvcTrfScalingFactor, rcvNNISeqMismatch=rcvNNISeqMismatch, frConnForeSightEnable=frConnForeSightEnable, rcvFramesFECN=rcvFramesFECN, ausmPortDelSvcsGrpTable=ausmPortDelSvcsGrpTable, vismChanCacPassedCons=vismChanCacPassedCons, parIfType=parIfType, vismAal2CidProfileType=vismAal2CidProfileType, cesmResPartRowStatus=cesmResPartRowStatus, srmTargetSlotLineNum=srmTargetSlotLineNum, ds0ChanNum=ds0ChanNum, ausmStdABRCDF=ausmStdABRCDF, trkCACEnable=trkCACEnable, vismBearerTos=vismBearerTos, vismRtcpRepInterval=vismRtcpRepInterval, frPortCnfResPartGrpEntry=frPortCnfResPartGrpEntry, bearerAal2ExtRAICnts=bearerAal2ExtRAICnts, vismPortCnfGrpTable=vismPortCnfGrpTable, rcvUNISeqMismatch=rcvUNISeqMismatch, clockSwitchState=clockSwitchState, cesPortNextAvailable=cesPortNextAvailable, bnmLineInterfaceMode=bnmLineInterfaceMode, egressQDepth=egressQDepth, iLMITrapEnable=iLMITrapEnable, cesmConnFGCRAEnable=cesmConnFGCRAEnable, rcvBytes=rcvBytes, rcvFramesTaggedBECN=rcvFramesTaggedBECN, parTrkId=parTrkId, egrQBinState=egrQBinState, rcvFramesDiscNoChan=rcvFramesDiscNoChan, bnmPortCounterNumOfValidEntries=bnmPortCounterNumOfValidEntries, asmAlarmUnitNum=asmAlarmUnitNum, vismSvcTxSetups=vismSvcTxSetups, bbChanRcvClp0Cells=bbChanRcvClp0Cells, portSvcStatus=portSvcStatus)
mibBuilder.exportSymbols("CISCO-WAN-AXIPOP-MIB", bnmPortCounterClrButton=bnmPortCounterClrButton, portEgresDEThresh=portEgresDEThresh, parNetParmMsgTimeout=parNetParmMsgTimeout, imaGrpRcvHecErrSESecCount=imaGrpRcvHecErrSESecCount, vrtlIntrRxdClpTaggedDiscardedCellCnt=vrtlIntrRxdClpTaggedDiscardedCellCnt, imatmDsx3CardSpecConfigEntry=imatmDsx3CardSpecConfigEntry, bbIfEgrPctBandwidth=bbIfEgrPctBandwidth, vismChanAal2CrcErrors=vismChanAal2CrcErrors, commonPortAssocLines=commonPortAssocLines, ausmPortType=ausmPortType, cesChanConnType=cesChanConnType, cesCellLossIntegrationPeriod=cesCellLossIntegrationPeriod, addrPrefix=addrPrefix, minTrapInterval=minTrapInterval, rcvFramesDiscXceedDEThresh=rcvFramesDiscXceedDEThresh, chanOvrSubOvrRide=chanOvrSubOvrRide, cesUflowInsCells=cesUflowInsCells, vsiControllersAllowed=vsiControllersAllowed, rpmIfRscPrtVciLow=rpmIfRscPrtVciLow, vismERL=vismERL, ds0CasWinkMaxMakeTime=ds0CasWinkMaxMakeTime, rpmIfCnfRscPartTable=rpmIfCnfRscPartTable, ausmPortCnfSigILMIGrpEntry=ausmPortCnfSigILMIGrpEntry, rcvPortFramesFECN=rcvPortFramesFECN, chanOAMstatus96=chanOAMstatus96, vismSvcTxBulkResyncs=vismSvcTxBulkResyncs, chanEgrPercentUtil=chanEgrPercentUtil, ausmStdABRCnfGrpTable=ausmStdABRCnfGrpTable, portFlagsBetweenFrames=portFlagsBetweenFrames, bbIfRscPrtVciHigh=bbIfRscPrtVciHigh, parCmParmsDnUpTimer=parCmParmsDnUpTimer, pxmPreviousClock=pxmPreviousClock, parIfLoAddrMin=parIfLoAddrMin, x21portSvcShareLcn=x21portSvcShareLcn, parClockCurSource=parClockCurSource, vismSvcRxConnAcks=vismSvcRxConnAcks, bbRscPartCtrlrNum=bbRscPartCtrlrNum, bearerRcvdPkts=bearerRcvdPkts, parSysParmsMaxCdpDDelay=parSysParmsMaxCdpDDelay, nextBbIfNumAvailable=nextBbIfNumAvailable, chanSvcFlag=chanSvcFlag, ingrQCLPState=ingrQCLPState, vismChanAal5OversizedSdusRcvdPdus=vismChanAal5OversizedSdusRcvdPdus, bertStartTime=bertStartTime, bertTestMediumMask=bertTestMediumMask, bbIfEgrPercentUtil=bbIfEgrPercentUtil, vrtlIntrMaxQueMem=vrtlIntrMaxQueMem, chanServiceType=chanServiceType, bbChanVpi=bbChanVpi, chanEpdDiscCells=chanEpdDiscCells, ausmChanPortNum=ausmChanPortNum, smRateControlConfig=smRateControlConfig, bbIfXmtOAMCells=bbIfXmtOAMCells, mir=mir, deTaggingEnable=deTaggingEnable, parSwFuncNodeType=parSwFuncNodeType, vismConnPercentUtil=vismConnPercentUtil, frPortCntPortGrpTable=frPortCntPortGrpTable, rpmChanConnType=rpmChanConnType, ascLmiVccVpi=ascLmiVccVpi, vismAal2CidLcn=vismAal2CidLcn, bearerLcn=bearerLcn, remoteImaId=remoteImaId, parTrkLocalPortNumber=parTrkLocalPortNumber, ausmPortCnfSigILMIGrpTable=ausmPortCnfSigILMIGrpTable, ausmPortSvcVpidLow=ausmPortSvcVpidLow, cesConnMCR=cesConnMCR, ds0CasMinStartDialTime=ds0CasMinStartDialTime, ausmPortCnfResPartGrpEntry=ausmPortCnfResPartGrpEntry, rcvBytesDiscXceedQDepth=rcvBytesDiscXceedQDepth, cesPortsUsedLine2=cesPortsUsedLine2, xmtKbpsAIR=xmtKbpsAIR, ascCntSigLmiGrpEntry=ascCntSigLmiGrpEntry, egrQDepthMax=egrQDepthMax, imatmTrkMinVp=imatmTrkMinVp, bearerConnTable=bearerConnTable, portBytesDiscXceedQueFull=portBytesDiscXceedQueFull, bertControl=bertControl, cesmPortCnfGrp=cesmPortCnfGrp, vismCasXgcpVariantEntry=vismCasXgcpVariantEntry, chanIngrRcvUtilization=chanIngrRcvUtilization, vismAal2CidVad=vismAal2CidVad, cesChanSignalingStatus=cesChanSignalingStatus, ausmPortStateGrpTable=ausmPortStateGrpTable, parNetParmCbOffset=parNetParmCbOffset, ingrQEfciThresh=ingrQEfciThresh, vismPortSpeed=vismPortSpeed, rpmChanInArpFreq=rpmChanInArpFreq, parCmParmsUseDelay=parCmParmsUseDelay, ascLmiInvalidIeRx=ascLmiInvalidIeRx, pxmAtmVcCrossConnectIndex=pxmAtmVcCrossConnectIndex, axisImaGroupAlphaValue=axisImaGroupAlphaValue, ascLmiOperStatus=ascLmiOperStatus, ds0IfIndex=ds0IfIndex, chanOAMstatus32=chanOAMstatus32, mulTrksAllowed=mulTrksAllowed, bbIfAddrRegEnable=bbIfAddrRegEnable, cesmChanReroute=cesmChanReroute, ausmEndPointMapGrpTable=ausmEndPointMapGrpTable, cesmChanCntGrpEntry=cesmChanCntGrpEntry, rpmChanRemoteVpi=rpmChanRemoteVpi, t391LinkIntegrityTimer=t391LinkIntegrityTimer, cesmChanCntGrp=cesmChanCntGrp, chanEgrXmtState=chanEgrXmtState, vismPortNum=vismPortNum, bearerAal2ConnRDICnts=bearerAal2ConnRDICnts, asmClrButton=asmClrButton, ausmChanCnfGrp=ausmChanCnfGrp, cesmPortCnfGrpTable=cesmPortCnfGrpTable, vrtlIntrQbinDiscardedCellCnt=vrtlIntrQbinDiscardedCellCnt, parIfRxBw=parIfRxBw, cesRcvATMState=cesRcvATMState, portSigClrButton=portSigClrButton, rcvFramesBECN=rcvFramesBECN, axisImaGroupUnavailSecs=axisImaGroupUnavailSecs, egrPortAlarmDiscardCells=egrPortAlarmDiscardCells, bbIfRscPrtEgrPctBandwidth=bbIfRscPrtEgrPctBandwidth, cesPortsUsedLine4=cesPortsUsedLine4, xmtPortBytes=xmtPortBytes, portSvcInUse=portSvcInUse, vismChanAal5InvLenPdus=vismChanAal5InvLenPdus, pxmAtmVcCrossConnectLowAddressType=pxmAtmVcCrossConnectLowAddressType, pxmAtmVcCrossConnectLowIfIndex=pxmAtmVcCrossConnectLowIfIndex, chanServType=chanServType, chanPortNum=chanPortNum, vismSvcRxSetups=vismSvcRxSetups, ds0CasParameterSource=ds0CasParameterSource, bbIfIngrPercentUtil=bbIfIngrPercentUtil, vismVcCacPvcFailures=vismVcCacPvcFailures, frChanCntGrpEntry=frChanCntGrpEntry, imatmPortCntrClrButton=imatmPortCntrClrButton, xmtStatusInquiry=xmtStatusInquiry, vismCarrierLossPolicy=vismCarrierLossPolicy, commonPortTable=commonPortTable, queConuterVrtlIntrNum=queConuterVrtlIntrNum, imaPortSpeed=imaPortSpeed, x21CnfGrpEntry=x21CnfGrpEntry, ausmConnAdminStatus=ausmConnAdminStatus, imatmVpTrkClrGrp=imatmVpTrkClrGrp, primaryMuxClockSource=primaryMuxClockSource, bertDeviceToLoop=bertDeviceToLoop, endChanType=endChanType, bbIfGetResponseReceived=bbIfGetResponseReceived, frConnPCR=frConnPCR, bbIfInvalidPDUReceived=bbIfInvalidPDUReceived, portOverSubEnable=portOverSubEnable, ausmPortCnfPortImaGrpTable=ausmPortCnfPortImaGrpTable, ingrUpcSCRPolicing=ingrUpcSCRPolicing, ds0SeizedCode=ds0SeizedCode, ausmPortCntPortGrpTable=ausmPortCntPortGrpTable, cesConnPercentUtil=cesConnPercentUtil, vismConnServiceType=vismConnServiceType, cesHdrErrors=cesHdrErrors, rpmChanRowStatus=rpmChanRowStatus, srmeTargetSlotNum=srmeTargetSlotNum, bbIfCnfSigILMIGrpEntry=bbIfCnfSigILMIGrpEntry, parClockType=parClockType, vismAal2CidState=vismAal2CidState, ds0CasOffHookMinMakeTime=ds0CasOffHookMinMakeTime, frLocalNSAP=frLocalNSAP, x21CnfGrpTable=x21CnfGrpTable, vismProfileNegotiationOption=vismProfileNegotiationOption, bbIfTooBigError=bbIfTooBigError, ausmConnTemplateId=ausmConnTemplateId, parMnUpdtBatchSend=parMnUpdtBatchSend, signallingVpi=signallingVpi, x21portLineNum=x21portLineNum, parCmParmsResetTimer=parCmParmsResetTimer, axisImaGroupRxImaId=axisImaGroupRxImaId, cesmResPartCtrlrID=cesmResPartCtrlrID, ausmChanLocRmtLpbkState=ausmChanLocRmtLpbkState, vrtlIntrMaxCellRate=vrtlIntrMaxCellRate, bbIfXmtClp0Cells=bbIfXmtClp0Cells, parIfOperStatus=parIfOperStatus, rpmIfRscPrtVpiHigh=rpmIfRscPrtVpiHigh, pxmExtClock2Present=pxmExtClock2Present, parTrkRemoteVTrunkId=parTrkRemoteVTrunkId, cesCas=cesCas, vismChanPortNum=vismChanPortNum, vrtlIntrQbinPri=vrtlIntrQbinPri, rpmChanAbrRDF=rpmChanAbrRDF, rcvBytesTaggedDE=rcvBytesTaggedDE, ausmConnRemoteMCR=ausmConnRemoteMCR, frChanCnfIgnoreIncomingDE=frChanCnfIgnoreIncomingDE, parTrkLoadXmtUsedBdataA=parTrkLoadXmtUsedBdataA, parCmParmsMaxRrtCycles=parCmParmsMaxRrtCycles, imatmVpTrkMapGrp=imatmVpTrkMapGrp, egrXmtClpSetCells=egrXmtClpSetCells, cesPortsUsedLine8=cesPortsUsedLine8, vismAggregateSvcBandwidth=vismAggregateSvcBandwidth, rcvFramesDiscOverrun=rcvFramesDiscOverrun, bbChanTestType=bbChanTestType, ausmPortCnfSig=ausmPortCnfSig, srmeStartVtNum=srmeStartVtNum, dsx0VismChanMapEntry=dsx0VismChanMapEntry, egressQSelect=egressQSelect, vismDynamicPT=vismDynamicPT, imatmClkCfgGrp=imatmClkCfgGrp, portEnhancedSIW=portEnhancedSIW, cesRoutingPriority=cesRoutingPriority, endVci=endVci, bbIfTotalCells=bbIfTotalCells, bbChanRcvClp1Cells=bbChanRcvClp1Cells, parTrkLoadRcvUsedBdataA=parTrkLoadRcvUsedBdataA, commonPortSignallingState=commonPortSignallingState, vismBearerContinuityTest=vismBearerContinuityTest, pxmAtmVcCrossConnectL2HOperStatus=pxmAtmVcCrossConnectL2HOperStatus, srmT1RowStatus=srmT1RowStatus, asmAlarmType=asmAlarmType, ausmPortSvcVciHigh=ausmPortSvcVciHigh, axisImaGroupNeNumFailures=axisImaGroupNeNumFailures, parMnUpdtInterval=parMnUpdtInterval, frPortsUsedLineGrpTable=frPortsUsedLineGrpTable, ds0SignalingType=ds0SignalingType, bc=bc, cesChanLocRmtLpbkState=cesChanLocRmtLpbkState, vrtlIntrQbinFrameDiscardThreshold=vrtlIntrQbinFrameDiscardThreshold, axisAtmNetPrefixPrefix=axisAtmNetPrefixPrefix, bbChanTestStateCPESide=bbChanTestStateCPESide, x21portFlagsBetweenFrames=x21portFlagsBetweenFrames, chanRowStatus=chanRowStatus, vismChanFallbackLcn=vismChanFallbackLcn, vismCodecCnfGrp=vismCodecCnfGrp, xmtFramesOversizedSDUs=xmtFramesOversizedSDUs, vismVoIpDtmfRelay=vismVoIpDtmfRelay, rcvFramesDiscCRCError=rcvFramesDiscCRCError, aumAddressTranslationDeleteEntry=aumAddressTranslationDeleteEntry, parSysParmsVcPollRate=parSysParmsVcPollRate, bbConnPCR=bbConnPCR, ausmStdABRMCR=ausmStdABRMCR, rateControlAllowed=rateControlAllowed, bbChanCntGrpEntry=bbChanCntGrpEntry, ausmIngrDiscardOption=ausmIngrDiscardOption, frPortCntSigCLLMGrp=frPortCntSigCLLMGrp, parNetParmTopoMsgSegSz=parNetParmTopoMsgSegSz, x21LineNumofValidEntries=x21LineNumofValidEntries, bbChanDscdClpOneCellsToPort=bbChanDscdClpOneCellsToPort, vismCasXgcpInitialReXmitTime=vismCasXgcpInitialReXmitTime, ausmChanCnfGrpTable=ausmChanCnfGrpTable, rpmChanRtePriority=rpmChanRtePriority, vismUpspeedCodec=vismUpspeedCodec, parConnCos=parConnCos, xmtPortFramesDuringLMIAlarm=xmtPortFramesDuringLMIAlarm, cesmConnRemotePercentUtil=cesmConnRemotePercentUtil, vismControlTos=vismControlTos, xmtAbitState=xmtAbitState, vismChanCnfGrpTable=vismChanCnfGrpTable, parSysParmsDeEnable=parSysParmsDeEnable, parCmParmsMaxRoutingBundle=parCmParmsMaxRoutingBundle, cesmChanNumNextAvailable=cesmChanNumNextAvailable, vismCasGrp=vismCasGrp, axisImaGroupRunningSecs=axisImaGroupRunningSecs, ausmPortSpeed=ausmPortSpeed, serialInterfaceTable=serialInterfaceTable)
mibBuilder.exportSymbols("CISCO-WAN-AXIPOP-MIB", imaArbitrationWinner=imaArbitrationWinner, cesPortNumOfSCIPerDS0=cesPortNumOfSCIPerDS0, cesLostCells=cesLostCells, ausmChanStateGrpEntry=ausmChanStateGrpEntry, frConnRemotePercentUtil=frConnRemotePercentUtil, protocolRevNo=protocolRevNo, bertUserId=bertUserId, rpmChanNum=rpmChanNum, rcvKbpsAIR=rcvKbpsAIR, ascLmiXmtAbitState=ascLmiXmtAbitState, ascLmiVpi=ascLmiVpi, vismChanVADDutyCycle=vismChanVADDutyCycle, ausmPortOversubscribed=ausmPortOversubscribed, parNetParmCbMaxTimeout=parNetParmCbMaxTimeout, rcvFramesUnknownProtocols=rcvFramesUnknownProtocols, pxmSecondarySMClockSourceSlotNumber=pxmSecondarySMClockSourceSlotNumber, bertCleanupAction=bertCleanupAction, bbChanEgrPercentUtil=bbChanEgrPercentUtil, bbChanUpcSCRPolicing=bbChanUpcSCRPolicing, srmeVtFramingType=srmeVtFramingType, cesChanConditionedData=cesChanConditionedData, parClockEntry=parClockEntry, parSysParmsMaxIphsdDelay=parSysParmsMaxIphsdDelay, customerId=customerId, chanEgrSrvRate=chanEgrSrvRate, parIfHiAddrMax=parIfHiAddrMax, vismAal2CidGrp=vismAal2CidGrp, cesmConnAdminStatus=cesmConnAdminStatus, bbRscPartIfNum=bbRscPartIfNum, egrQfullDiscardCells=egrQfullDiscardCells, ascCnfSigLmiGrpEntry=ascCnfSigLmiGrpEntry, bbIfState=bbIfState, bbIfRscPrtVpiHigh=bbIfRscPrtVpiHigh, ausmRestrictTrunkType=ausmRestrictTrunkType, parIfMaxConn=parIfMaxConn, bbChanTestResult=bbChanTestResult, vrtlIntrTotalQbinCellCnt=vrtlIntrTotalQbinCellCnt, vismCodecCnfTable=vismCodecCnfTable, parOnOffCmUpdts=parOnOffCmUpdts, vismChanCacMaster=vismChanCacMaster, parSysParmsMaxCdpHsdDelay=parSysParmsMaxCdpHsdDelay, ingrQCLPThreshLow=ingrQCLPThreshLow, ascLmiPollingEnabled=ascLmiPollingEnabled, axisImaGroupTxAvailCellRate=axisImaGroupTxAvailCellRate, parTrkLoadEntry=parTrkLoadEntry, ascLmiUnknownPduRx=ascLmiUnknownPduRx, frPortCnfSigLMIGrpEntry=frPortCnfSigLMIGrpEntry, parIfTable=parIfTable, parTrkCnfgTrafficClassTs=parTrkCnfgTrafficClassTs, vismCodecSupported=vismCodecSupported, srmeTargetSlotLineNum=srmeTargetSlotLineNum, frMaxCost=frMaxCost, noSuchNameError=noSuchNameError, cesBufOverflows=cesBufOverflows, egrMaxBwInc=egrMaxBwInc, rpmChanMaxCost=rpmChanMaxCost, portsUsedLine8=portsUsedLine8, bnmCountersClrButton=bnmCountersClrButton, chanVci=chanVci, cllmEnable=cllmEnable, ascLmiVccVci=ascLmiVccVci, frPortCnfSigCLLMGrpEntry=frPortCnfSigCLLMGrpEntry, signallingProtocolType=signallingProtocolType, xmtFramesAbort=xmtFramesAbort, xmtFramesFECN=xmtFramesFECN, xmtFrames=xmtFrames, cesCellSeqMismatchCnt=cesCellSeqMismatchCnt, imatmClrVpTrkNum=imatmClrVpTrkNum, rcvPortFramesTaggedFECN=rcvPortFramesTaggedFECN, ascFeatures=ascFeatures, countVrtlIntrNum=countVrtlIntrNum, vismCompCnfPacketSize=vismCompCnfPacketSize, rcvPortFramesTaggedBECN=rcvPortFramesTaggedBECN, vismIpGrp=vismIpGrp, frPortCntSigLMIGrpEntry=frPortCntSigLMIGrpEntry, vismDaughterCardDescription=vismDaughterCardDescription, bbRemoteConnPercentUtil=bbRemoteConnPercentUtil, ingrVpiVciErrCells=ingrVpiVciErrCells, portM32EgrQueueThresh=portM32EgrQueueThresh, vismPortCacSvcUpspeedFailures=vismPortCacSvcUpspeedFailures, bertStartDate=bertStartDate, egrQCLPThreshHigh=egrQCLPThreshHigh, vismSvcAal2CidGrp=vismSvcAal2CidGrp, portSignallingState=portSignallingState, bbIfIngrPctBandwidth=bbIfIngrPctBandwidth, frLocalVci=frLocalVci, vismInteropGrp=vismInteropGrp, xmtPortFramesBECN=xmtPortFramesBECN, parConnRemoteVci=parConnRemoteVci, axisImaGroupNumRxActLnks=axisImaGroupNumRxActLnks, endChanNum=endChanNum, ausmChanIngrPercentUtil=ausmChanIngrPercentUtil, bbChanSvcConnId=bbChanSvcConnId, x21ClkFrequencyThreshold=x21ClkFrequencyThreshold, bnmCellbusNoAckCellCount=bnmCellbusNoAckCellCount, axisImaGroupRxFrameLength=axisImaGroupRxFrameLength, vismCasXgcpMaxRetries=vismCasXgcpMaxRetries, vismCasRowStatus=vismCasRowStatus, xmtFramesTaggedFECN=xmtFramesTaggedFECN, xmtFramesDiscXceedDEThresh=xmtFramesDiscXceedDEThresh, vismAal2CidCnfTable=vismAal2CidCnfTable, x21ConnectorType=x21ConnectorType, ingrUpcPCR01=ingrUpcPCR01, srmTargetSlotNum=srmTargetSlotNum, commonChanStatus=commonChanStatus, getResponseTransmitted=getResponseTransmitted, frPortCntSigCLLMGrpEntry=frPortCntSigCLLMGrpEntry, rcvAbitState=rcvAbitState, vismFeatureBitMap=vismFeatureBitMap, bbChanMaxCellMemThreshold=bbChanMaxCellMemThreshold, vismChanScrEgress=vismChanScrEgress, errorThresholdN491=errorThresholdN491, cesRemoteNSAP=cesRemoteNSAP, ascLmiVci=ascLmiVci, parNetParmMaxNodeBlks=parNetParmMaxNodeBlks, egrQAlgorithm=egrQAlgorithm, frVpcFlag=frVpcFlag, dsx0VismChanMapTable=dsx0VismChanMapTable, rpmPortSubNetMask=rpmPortSubNetMask, parConnRemoteNodeName=parConnRemoteNodeName, bbIfAddrPrefix=bbIfAddrPrefix, vismTrapIntIndex2=vismTrapIntIndex2, cesCBRService=cesCBRService, portsUsedLine4=portsUsedLine4, frPortCnfPortGrp=frPortCnfPortGrp, connSlotNum=connSlotNum, connShelfNum=connShelfNum, portEgrSvcBandW=portEgrSvcBandW, vismChanCntGrpTable=vismChanCntGrpTable, ausmStdABRICR=ausmStdABRICR, asmShelfAlarmState=asmShelfAlarmState, parSysParmsConnFail=parSysParmsConnFail, bbChanUpcSCR=bbChanUpcSCR, cesConnPCR=cesConnPCR, bbIfCnfSigILMIGrpTable=bbIfCnfSigILMIGrpTable, imaAutoRestartFeature=imaAutoRestartFeature, vismDaughterCardHWRev=vismDaughterCardHWRev, vismChanState=vismChanState, vismAal2CidProfileNum=vismAal2CidProfileNum, ausmChanStateGrp=ausmChanStateGrp, vismCasFileName=vismCasFileName, vismConnAdminStatus=vismConnAdminStatus, chanIngrCurrQDepth=chanIngrCurrQDepth, getNextRequestReceived=getNextRequestReceived, vismLocalVci=vismLocalVci, rpmChanRemotePercentUtil=rpmChanRemotePercentUtil, vismChanNum=vismChanNum, vismFarEndE164Address=vismFarEndE164Address, bearerJitter=bearerJitter, asmAlarmThreshold=asmAlarmThreshold, ausmRoutingPriority=ausmRoutingPriority, ds0RobbedBitSignalling=ds0RobbedBitSignalling, vismCasXgcpVariantTable=vismCasXgcpVariantTable, bertErrorInjectCount=bertErrorInjectCount, parSysParmsMaxIpcdpCDelay=parSysParmsMaxIpcdpCDelay, parTrkCnfgTrafficClassCbr=parTrkCnfgTrafficClassCbr, chanTestState=chanTestState, foreSightEnable=foreSightEnable, bertLine=bertLine, bbIfCntClrButton=bbIfCntClrButton, portEgrPercentUtil=portEgrPercentUtil, parConnMasterShip=parConnMasterShip, portAdmin=portAdmin, bertSupportFlag=bertSupportFlag, portNum=portNum, srmeCnfGrp=srmeCnfGrp, ausmChanTestType=ausmChanTestType, ausmConnFGCRAEnable=ausmConnFGCRAEnable, frConnSCR=frConnSCR, sigCntPortNum=sigCntPortNum, x21LineEnable=x21LineEnable, bnmEgressInvalidCellHdr=bnmEgressInvalidCellHdr, totalIngrClpSetDiscardCells=totalIngrClpSetDiscardCells, rpmIfRscPrtVciHigh=rpmIfRscPrtVciHigh, ausmChanNum=ausmChanNum, vismVpcFlag=vismVpcFlag, vrtlIntrQbinConfigEntry=vrtlIntrQbinConfigEntry, bbIfIlmiTrapEnable=bbIfIlmiTrapEnable, xmtBytesCLLM=xmtBytesCLLM, bbChanRemoteVci=bbChanRemoteVci, vismEcanCnfIdleDirection=vismEcanCnfIdleDirection, bbIfRcvClp1DiscCells=bbIfRcvClp1DiscCells, vismRemoteNSAP=vismRemoteNSAP, rpmChanPercentUtil=rpmChanPercentUtil, ausmPortImaGrpRestartEntry=ausmPortImaGrpRestartEntry, bbChanCnfGrpEntry=bbChanCnfGrpEntry, rcvBytesDE=rcvBytesDE, ingrUpcMFS=ingrUpcMFS, vrtlIntrXmtdClpUntaggedCellCnt=vrtlIntrXmtdClpUntaggedCellCnt, TruthValue=TruthValue, serialPortEnable=serialPortEnable, rpmIfRscPrtVpiLow=rpmIfRscPrtVpiLow, parTrkRemoteTrunkId=parTrkRemoteTrunkId, axisImaGroupimaPortNum=axisImaGroupimaPortNum, x21LineType=x21LineType, parTrkCnfgTrafficClassNts=parTrkCnfgTrafficClassNts, x21InvertClock=x21InvertClock, vismCodecTemplateCnfGrpEntry=vismCodecTemplateCnfGrpEntry, ascLmiStatusRx=ascLmiStatusRx, frstdABRPCR=frstdABRPCR, rpmChanRemoteNsap=rpmChanRemoteNsap, bbChanEgrSrvRate=bbChanEgrSrvRate, vismSvcTxResyncEndAcks=vismSvcTxResyncEndAcks, axisImaGroupLastChange=axisImaGroupLastChange, bbIfCntGrp=bbIfCntGrp, frstdABRNrm=frstdABRNrm, bbConnSCR=bbConnSCR, ausmChanNumNextAvailable=ausmChanNumNextAvailable, vismSvcRxResyncStrtAcks=vismSvcRxResyncStrtAcks, rpmPortEntry=rpmPortEntry, ds0CasDirectionality=ds0CasDirectionality, vismMode=vismMode, parConnRemoteVpi=parConnRemoteVpi, cesmChanExtTrgIdleSupp=cesmChanExtTrgIdleSupp, rcvBufNotAvailable=rcvBufNotAvailable, commonChanServiceType=commonChanServiceType, frConnPercentUtil=frConnPercentUtil, atmLineCntClrButton=atmLineCntClrButton, chanEgrRcvCellRate=chanEgrRcvCellRate, bbIfRcvClp1Cells=bbIfRcvClp1Cells, ingrUpcCBS=ingrUpcCBS, ausmPortStateGrpEntry=ausmPortStateGrpEntry, frChanStateGrp=frChanStateGrp, egrQCLPThreshLow=egrQCLPThreshLow, rpmPortTable=rpmPortTable, imatmDsx3PortLastMismatchVpiVci=imatmDsx3PortLastMismatchVpiVci, portClrButton=portClrButton, bbChanSvcFlag=bbChanSvcFlag, ausmPortCnfServiceQueGrpEntry=ausmPortCnfServiceQueGrpEntry, frChanCnfGrpTable=frChanCnfGrpTable, x21portRowStatus=x21portRowStatus, imaGrpRcvHecErrSecCount=imaGrpRcvHecErrSecCount, frPortsUsedLineIndex=frPortsUsedLineIndex, ausmPortCntPortGrp=ausmPortCntPortGrp, ausmStdABRCnfGrpEntry=ausmStdABRCnfGrpEntry, vismDaughterCardSerialNum=vismDaughterCardSerialNum, vismJitterDelayMode=vismJitterDelayMode, parSysParmsMaxIpcdpVDelay=parSysParmsMaxIpcdpVDelay, cesmEndPtMapGrpTable=cesmEndPtMapGrpTable, pxmAtmVcCrossConnectHighVpi=pxmAtmVcCrossConnectHighVpi, rateDown=rateDown, bbChanClpLoThreshold=bbChanClpLoThreshold, endPortNum=endPortNum, axisAtmNetPrefixAdminStatus=axisAtmNetPrefixAdminStatus, vismChanAal5ReassemTimerExpiryPdus=vismChanAal5ReassemTimerExpiryPdus, cesBufMaxSize=cesBufMaxSize, xmtStatus=xmtStatus, cesEndLineNum=cesEndLineNum, ascLmiStatusEnqRx=ascLmiStatusEnqRx, cardResourcePartition=cardResourcePartition, bbChanDscdClp0Cells=bbChanDscdClp0Cells, imaPortOversubscribed=imaPortOversubscribed, vismAal2CidRowStatus=vismAal2CidRowStatus, parSysParmsTsPacketAge=parSysParmsTsPacketAge)
mibBuilder.exportSymbols("CISCO-WAN-AXIPOP-MIB", ds0BundleMapped=ds0BundleMapped, vrtlIntrQbinDiscardSelection=vrtlIntrQbinDiscardSelection, parConnectionEntry=parConnectionEntry, cesPortSpeed=cesPortSpeed, vismTrapIntIndex1=vismTrapIntIndex1, ingrUpcIBS=ingrUpcIBS, pxmExtClk2SrcImpedance=pxmExtClk2SrcImpedance, parNetParmMsgMaxTimeoutSat=parNetParmMsgMaxTimeoutSat, ds0LocalCasPattern=ds0LocalCasPattern, vismChanCacEntry=vismChanCacEntry, cesPortRowStatus=cesPortRowStatus, pxmCurrentClock=pxmCurrentClock, srmeLineNum=srmeLineNum, parConnRemoteSlot=parConnRemoteSlot, rcvBytesDiscard=rcvBytesDiscard, parSnRevision=parSnRevision, parNetworkingParms=parNetworkingParms, rpmChanSubInterface=rpmChanSubInterface, atmNetPrefixTable=atmNetPrefixTable, chanEgrPortQClpThresDiscardCells=chanEgrPortQClpThresDiscardCells, bertDDSSeekResultsTable=bertDDSSeekResultsTable, bbChanTestTypeCPESide=bbChanTestTypeCPESide, ausmRemoteNSAP=ausmRemoteNSAP, egressQECNThresh=egressQECNThresh, bearerAal2ConnAISCnts=bearerAal2ConnAISCnts, pxmAtmVcCrossConnectHighIfIndex=pxmAtmVcCrossConnectHighIfIndex, imaPortType=imaPortType, parNetParmCbDelay=parNetParmCbDelay, ausmConnMCR=ausmConnMCR, ds0CasOnHookMinMakeTime=ds0CasOnHookMinMakeTime, parTrkLoadXmtUsedNts=parTrkLoadXmtUsedNts, rcvFrames=rcvFrames, rpmChanMidHigh=rpmChanMidHigh, bbIfGetRequestReceived=bbIfGetRequestReceived, rpmChanRemoteVci=rpmChanRemoteVci, vismPortResPartCnfGrpEntry=vismPortResPartCnfGrpEntry, cesIngrDiscardedBytes=cesIngrDiscardedBytes, ingrUpcCIR=ingrUpcCIR, virtualInterfaceCnf=virtualInterfaceCnf, parNetParmCfTestMultiplier=parNetParmCfTestMultiplier, cesPortType=cesPortType, chanIngrEfciSetRcvCells=chanIngrEfciSetRcvCells, vismSvcCallProcExpiries=vismSvcCallProcExpiries, rpmPortSlotNum=rpmPortSlotNum, ausmPortStateImaGrpEntry=ausmPortStateImaGrpEntry, pxmAtmVcCrossConnectL2HLastChange=pxmAtmVcCrossConnectL2HLastChange, parConnAdminStatus=parConnAdminStatus, commonAlarmState=commonAlarmState, vismHdlcRxAbortFrames=vismHdlcRxAbortFrames, pxmAtmVcCrossConnectH2LOperStatus=pxmAtmVcCrossConnectH2LOperStatus, cesmEndPtMapGrp=cesmEndPtMapGrp, bertDDSSeekResultsTableFirstIndex=bertDDSSeekResultsTableFirstIndex, atmLineCntTable=atmLineCntTable, vismHdlcChanEntry=vismHdlcChanEntry, pxmExtClk2ConnectorType=pxmExtClk2ConnectorType, chanSvcConnId=chanSvcConnId, chanCLPtoDEmap=chanCLPtoDEmap, ds0CasGlarePolicy=ds0CasGlarePolicy, vismCodecTemplateNum=vismCodecTemplateNum, vismCasVariantTable=vismCasVariantTable, bearerLatency=bearerLatency, vismSvcTxResyncStrtAcks=vismSvcTxResyncStrtAcks, bbIfRscPrtIngrPctBandwidth=bbIfRscPrtIngrPctBandwidth, portSvcLcnHigh=portSvcLcnHigh, chanServiceRateOverride=chanServiceRateOverride, vismChanCacTable=vismChanCacTable, parClockSourceId=parClockSourceId, portXmtSgmtLpbkCells=portXmtSgmtLpbkCells, frResPartDlciHigh=frResPartDlciHigh, ausmConnMBS=ausmConnMBS, pxmAtmVcCrossConnectRowStatus=pxmAtmVcCrossConnectRowStatus, bbIfSetRequestReceived=bbIfSetRequestReceived, cesChanIdleCodeIntgnPeriod=cesChanIdleCodeIntgnPeriod, portDs0ConfigBitMap=portDs0ConfigBitMap, parConnRoute=parConnRoute, setRequestReceived=setRequestReceived, parCmParmsMinRrGroupSize=parCmParmsMinRrGroupSize, parNetParmLowTxRate=parNetParmLowTxRate, bbIfCnfPortGrp=bbIfCnfPortGrp, bbIfRscPartCtrlrID=bbIfRscPartCtrlrID, vismAal2CidICSEnable=vismAal2CidICSEnable, bertDDSSeekResultsTableLastIndex=bertDDSSeekResultsTableLastIndex, rpmIfRscPartCtrlrNum=rpmIfRscPartCtrlrNum, atmLineCntEntry=atmLineCntEntry, cesMastership=cesMastership, parClockTable=parClockTable, vismSvcRxReleaseCompls=vismSvcRxReleaseCompls, portsUsedLine1=portsUsedLine1, bbIfRcvRmCells=bbIfRcvRmCells, bbIfAsn1ParseError=bbIfAsn1ParseError, parSysParmsMaxCdpVDelay=parSysParmsMaxCdpVDelay, bbIfCnfRscPartGrpEntry=bbIfCnfRscPartGrpEntry, chanIngrXmtCells=chanIngrXmtCells, cesChanPortNum=cesChanPortNum, cesmChanCnfGrpTable=cesmChanCnfGrpTable, frEndPtMapGrpTable=frEndPtMapGrpTable, enhancedLmi=enhancedLmi, xmtPortFramesDiscXceedQDepth=xmtPortFramesDiscXceedQDepth, vismVADDutyCycle=vismVADDutyCycle, networkCacConfigState=networkCacConfigState, frEndPtMapGrp=frEndPtMapGrp, vismAal2CidEcanEnable=vismAal2CidEcanEnable, vrtlIntrMinCellRate=vrtlIntrMinCellRate, rpmChanVpi=rpmChanVpi, parConnLocalVcIndx=parConnLocalVcIndx, parNetParmCfTestInterval=parNetParmCfTestInterval, vismChanStateGrp=vismChanStateGrp, aumAddressTranslationDeleteTable=aumAddressTranslationDeleteTable, parMnUpdtNodesPerInt=parMnUpdtNodesPerInt, vismCasCountryCode=vismCasCountryCode, egrRcvCellRate=egrRcvCellRate, vrtlIntrQbinConfigTable=vrtlIntrQbinConfigTable, ascCnfSigLmiGrpTable=ascCnfSigLmiGrpTable, parTrkRemoteNodeName=parTrkRemoteNodeName, cesChanIdleSignalCode=cesChanIdleSignalCode, ausmStdABRNrm=ausmStdABRNrm, vismSvcGrp=vismSvcGrp, cardResPartGrpTable=cardResPartGrpTable, vismSvcAal2CidNumber=vismSvcAal2CidNumber, vismChanAal5Crc32ErrorPdus=vismChanAal5Crc32ErrorPdus, vismPortState=vismPortState, parTrkCnfgRoutingCost=parTrkCnfgRoutingCost, rcvFramesCLLM=rcvFramesCLLM, chanFrConnType=chanFrConnType, bbIfCnfRscPartGrpTable=bbIfCnfRscPartGrpTable, parOnOff=parOnOff, parTrkLoadRcvUsedAbr=parTrkLoadRcvUsedAbr, parOnOffCommFailTest=parOnOffCommFailTest, dsx1LineNum=dsx1LineNum, frChanOamCCEnable=frChanOamCCEnable, xmtBytesDuringLMIAlarm=xmtBytesDuringLMIAlarm, axisImaGroupFeState=axisImaGroupFeState, axisImaGroupNumber=axisImaGroupNumber, chanConnType=chanConnType, parTrkLoadXmtUsedBdataB=parTrkLoadXmtUsedBdataB, frPortCntSigLMIGrpTable=frPortCntSigLMIGrpTable, cesPortNum=cesPortNum, bbChanStateGrpEntry=bbChanStateGrpEntry, bertDDSSeekResultsTableEntry=bertDDSSeekResultsTableEntry, bertModeMask=bertModeMask, commonPortTableEntry=commonPortTableEntry, totalIngrQfulldiscardCells=totalIngrQfulldiscardCells, ausmVpcFlag=ausmVpcFlag, bbChanGcra2Action=bbChanGcra2Action, ingrRcvCellRate=ingrRcvCellRate, vismRtcpRecvMultiplier=vismRtcpRecvMultiplier, secondaryMuxClockSource=secondaryMuxClockSource, bbChanXmtClp1Cells=bbChanXmtClp1Cells, parClockIndex=parClockIndex, ausmPortCnfPortGrpTable=ausmPortCnfPortGrpTable, vismChanXmtATMState=vismChanXmtATMState, uniSignalingTimeout=uniSignalingTimeout, aumAddressTranslation=aumAddressTranslation, bbIfRcvClp0Cells=bbIfRcvClp0Cells, frChanCnfGrpEntry=frChanCnfGrpEntry, vismChanPvcType=vismChanPvcType, bbIfTrapReceived=bbIfTrapReceived, vismSubNetMask=vismSubNetMask, parOnOffRouting=parOnOffRouting, ausmStdABRTrm=ausmStdABRTrm, bnmCounters=bnmCounters, rcvPortFramesBECN=rcvPortFramesBECN, bbChanLocalVpi=bbChanLocalVpi, vismBearerIpAddress=vismBearerIpAddress, bnmCellbusXmtCellCount=bnmCellbusXmtCellCount, vismAal2CidNum=vismAal2CidNum, listLinksPresentInImaGroup=listLinksPresentInImaGroup, vismSvcConnExpiries=vismSvcConnExpiries, ascCntSigLmiGrpTable=ascCntSigLmiGrpTable, pxmPrimaryInbandClockSourceLineNumber=pxmPrimaryInbandClockSourceLineNumber, frResPartRowStatus=frResPartRowStatus, cesPortState=cesPortState, parIfHiAddrMin=parIfHiAddrMin, parTrkRemoteSlotNumber=parTrkRemoteSlotNumber, vismConnPCREgress=vismConnPCREgress, axisImaGroupLeastDelayLink=axisImaGroupLeastDelayLink, axisImaGroupMinNumTxLinks=axisImaGroupMinNumTxLinks, parSysParmsMaxIpcdpADelay=parSysParmsMaxIpcdpADelay, bbChanConnDesc=bbChanConnDesc, ds0CasGaurdTime=ds0CasGaurdTime, bbChanServiceType=bbChanServiceType, srmT3LineNum=srmT3LineNum, vismPortLineNum=vismPortLineNum, cesChanTestType=cesChanTestType, portEgresQDepth=portEgresQDepth, commonChanTable=commonChanTable, commonChanTableEntry=commonChanTableEntry, frstdABRFRTT=frstdABRFRTT, rcvFramesDiscard=rcvFramesDiscard, bearerConnGrp=bearerConnGrp, bbChanUpcPCR=bbChanUpcPCR, axisImaGroupSymmetry=axisImaGroupSymmetry, ausmChanRTDResult=ausmChanRTDResult, bbIfTrapTransmitted=bbIfTrapTransmitted, bbChanCnfNum=bbChanCnfNum, portDeleteSvcs=portDeleteSvcs, rpmChanMidLow=rpmChanMidLow, chanFECNconfig=chanFECNconfig, chanIngrQfullDiscardCells=chanIngrQfullDiscardCells, x21AlmGrp=x21AlmGrp, portBytesDiscXceedDEThresh=portBytesDiscXceedDEThresh, bbIfSignallingVci=bbIfSignallingVci, vrtlIntrRxdClpTaggedCellCnt=vrtlIntrRxdClpTaggedCellCnt, ds0CasFlashMaxMakeTime=ds0CasFlashMaxMakeTime, qir=qir, rpmChanVci=rpmChanVci, ascLmiNodeStatusRx=ascLmiNodeStatusRx, ausmChanEgrSrvRate=ausmChanEgrSrvRate, ds0CasMinDelayDialTime=ds0CasMinDelayDialTime, vismAal2CidDtmfTransport=vismAal2CidDtmfTransport, parNetworkClock=parNetworkClock, chanIngrClpSetDiscardCells=chanIngrClpSetDiscardCells, frPortServiceQueGrpTable=frPortServiceQueGrpTable, vismChanAal2InvOsfCells=vismChanAal2InvOsfCells, parSysParmsFrStandard=parSysParmsFrStandard, bbIfRowStatus=bbIfRowStatus, ausmIngrFrDiscardThreshold=ausmIngrFrDiscardThreshold, endDLCI=endDLCI, cntPortNum=cntPortNum, ascLmiStatusAckRx=ascLmiStatusAckRx, axisAtmAddressStatus=axisAtmAddressStatus, rasOamlpbkFrequency=rasOamlpbkFrequency, virtualInterfaceQbinCnt=virtualInterfaceQbinCnt, ausmPortCntSigILMIGrpTable=ausmPortCntSigILMIGrpTable, cesPartialFill=cesPartialFill, ausmChanRMEnable=ausmChanRMEnable, ascLmiVccLineNum=ascLmiVccLineNum, ingressQDepth=ingressQDepth, xmtFramesCLLM=xmtFramesCLLM, bearerSentOctets=bearerSentOctets, frChanLocalLpbkEnable=frChanLocalLpbkEnable, bbIfNum=bbIfNum, parTrkLoadRcvUsedNts=parTrkLoadRcvUsedNts, asmUnitMeasurable=asmUnitMeasurable, cesmResPartIngrPctBW=cesmResPartIngrPctBW, chanSecUpTime=chanSecUpTime, invalidPDUReceived=invalidPDUReceived, vismChanTestType=vismChanTestType, vrtlIntrRxdValidOAMCellCnt=vrtlIntrRxdValidOAMCellCnt, rcvPortFramesDiscXceedDEThresh=rcvPortFramesDiscXceedDEThresh, rcvFramesAbort=rcvFramesAbort, bbChanState=bbChanState, vismRoutingPriority=vismRoutingPriority, rpmChanType=rpmChanType, parConnectionTable=parConnectionTable, vismTrapStrIndex1=vismTrapStrIndex1, parConnLocalVpi=parConnLocalVpi, portSvcDlciLow=portSvcDlciLow, bnmIngressInvalidCellCount=bnmIngressInvalidCellCount, rpmChanRestrictTrkType=rpmChanRestrictTrkType, ausmStdABRType=ausmStdABRType, ingressQECNThresh=ingressQECNThresh, x21LineNum=x21LineNum, parConnOperStatus=parConnOperStatus)
mibBuilder.exportSymbols("CISCO-WAN-AXIPOP-MIB", rasOamlpbkAllowed=rasOamlpbkAllowed, frCDRNumber=frCDRNumber, pxmAtmVcCrossConnectHighAddressType=pxmAtmVcCrossConnectHighAddressType, frstdABRCnfGrpEntry=frstdABRCnfGrpEntry, egrXmtUtilization=egrXmtUtilization, cesmResPartPortNum=cesmResPartPortNum, vismAppliedTemplate=vismAppliedTemplate, extClkConnectorType=extClkConnectorType, ingrRcvCells=ingrRcvCells, bbChanCntNum=bbChanCntNum, ausmPortClrButton=ausmPortClrButton, atmLineCnfEntry=atmLineCnfEntry, vismVoIpGrp=vismVoIpGrp, vismHdlcXmtFrames=vismHdlcXmtFrames, ausmPortSvcLcnLow=ausmPortSvcLcnLow, portType=portType, cesRemoteVci=cesRemoteVci, bbIfEventThresholdN492=bbIfEventThresholdN492, vrtlIntrQbinCounterTable=vrtlIntrQbinCounterTable, cesmResPartEgrPctBW=cesmResPartEgrPctBW, bbChanStateGrpTable=bbChanStateGrpTable, frstdABRcnfChanNum=frstdABRcnfChanNum, egrRcvCells=egrRcvCells, bbIfCnfPortGrpTable=bbIfCnfPortGrpTable, vismSvcCnfGroups=vismSvcCnfGroups, asmAlarmTable=asmAlarmTable, rpmPortState=rpmPortState, rcvPortFrames=rcvPortFrames, bbChanUpcMCR=bbChanUpcMCR, vismConnRemotePercentUtil=vismConnRemotePercentUtil, parSnNodeIP=parSnNodeIP, vrtlIntrXmtdRmCellCnt=vrtlIntrXmtdRmCellCnt, xmtBytesDiscard=xmtBytesDiscard, chanOAMstatus160=chanOAMstatus160, virtualInterfaceQbinCnf=virtualInterfaceQbinCnf, x21portNum=x21portNum, numRedundantLinks=numRedundantLinks, xmtAsynchUpdate=xmtAsynchUpdate, frLocalVpi=frLocalVpi, frRestrictTrunkType=frRestrictTrunkType, bbIfCustomerId=bbIfCustomerId, bertDeviceToLoopMask=bertDeviceToLoopMask, chanIngrRcvCellRate=chanIngrRcvCellRate, parOnOffBackgroundUpdt=parOnOffBackgroundUpdt, rateFastDown=rateFastDown, cesMapVci=cesMapVci, rasOamLpbkInfo=rasOamLpbkInfo, vismIpAddress=vismIpAddress, x21portSpeed=x21portSpeed, parOnOffDrtDelay=parOnOffDrtDelay, vismChanRTDResult=vismChanRTDResult, bearerEndptNum=bearerEndptNum, egrQClpSetDiscardCells=egrQClpSetDiscardCells, rpmPortInterface=rpmPortInterface, ausmPortCntSig=ausmPortCntSig, portState=portState, vismAal2CidType3Redundancy=vismAal2CidType3Redundancy, serialPortbps=serialPortbps, ausmPortCnfResPartGrp=ausmPortCnfResPartGrp, bearerConnEntry=bearerConnEntry, rcvCLLMStatusTimer=rcvCLLMStatusTimer, vismXgcpBearerConnectionType=vismXgcpBearerConnectionType, ds0LoopbackCommand=ds0LoopbackCommand, commonChanEgrXmtState=commonChanEgrXmtState, ausmPortIngrPercentUtil=ausmPortIngrPercentUtil, chanIngrUpcClpSetCells=chanIngrUpcClpSetCells, cesRemoteVpi=cesRemoteVpi, n392ErrorThreshold=n392ErrorThreshold, frPortCnfPortGrpEntry=frPortCnfPortGrpEntry, parTrkRemoteNodeIP=parTrkRemoteNodeIP, rpmChanSlotNum=rpmChanSlotNum, parClockSource=parClockSource, endLineNum=endLineNum, parSnNumberOfTrunks=parSnNumberOfTrunks, vismCodecTemplateCnfGrpTable=vismCodecTemplateCnfGrpTable, rpmPortIpAddress=rpmPortIpAddress, axisImaGroupRxAvailCellRate=axisImaGroupRxAvailCellRate, ethernetPhysicaAddress=ethernetPhysicaAddress, ausmConnRemotePercentUtil=ausmConnRemotePercentUtil, chanIngrPercentUtil=chanIngrPercentUtil, cesPortsUsedLine6=cesPortsUsedLine6, parSysParms=parSysParms, parOnOffCommBreak=parOnOffCommBreak, parConnLocalEndpt=parConnLocalEndpt, frResPartPortNum=frResPartPortNum, rcvFramesDiscIllegalLen=rcvFramesDiscIllegalLen, parSysParmsMaxCdpCDelay=parSysParmsMaxCdpCDelay, parTrkLoadRcvUsedBdataB=parTrkLoadRcvUsedBdataB, rpmChanRemoteMCR=rpmChanRemoteMCR, rpmChanPCR=rpmChanPCR, pxmAtmMIBObjects=pxmAtmMIBObjects, cardResPartCtrlrNum=cardResPartCtrlrNum, atmAddressGroup=atmAddressGroup, vrtlIntrQbinClpLoThreshold=vrtlIntrQbinClpLoThreshold, parConnFailRsn=parConnFailRsn, ds0CasCadenceOnTime=ds0CasCadenceOnTime, ingrUpcCCDV=ingrUpcCCDV, parCmParmsCostBased=parCmParmsCostBased, foresightQIR=foresightQIR, rpmChanLocalVci=rpmChanLocalVci, chanEgrQSelect=chanEgrQSelect, ascLmiNodeStatusTx=ascLmiNodeStatusTx, ingrLastUnknVpiVci=ingrLastUnknVpiVci, imatmVpTrkClrGrpEntry=imatmVpTrkClrGrpEntry, cesEndChanNum=cesEndChanNum, ausmPortStateImaGrp=ausmPortStateImaGrp, zeroCirConEir=zeroCirConEir, rpmChanAbrRIF=rpmChanAbrRIF, frConnRemoteSCR=frConnRemoteSCR, vismCodecString=vismCodecString, vismVoIpTripleRedundancy=vismVoIpTripleRedundancy, ascChanStateSigLmiGrpTable=ascChanStateSigLmiGrpTable, parIfTxBw=parIfTxBw, parTrkBwCapacity=parTrkBwCapacity, parTrkLoadVccConidsUsed=parTrkLoadVccConidsUsed, vismChanApplication=vismChanApplication, bbChanRestrictTrkType=bbChanRestrictTrkType, commonConnParm1=commonConnParm1, serialInterface=serialInterface, ausmPortInterfaceGrp=ausmPortInterfaceGrp, ascLmiMaxRetryN395=ascLmiMaxRetryN395, parTrkCnfgTrafficClassVbr=parTrkCnfgTrafficClassVbr, secondaryClockSource=secondaryClockSource, rpmChanEncapType=rpmChanEncapType, ascLmiEnabled=ascLmiEnabled, bnmLineInterfaceFormat=bnmLineInterfaceFormat, bbIfStateGrpEntry=bbIfStateGrpEntry, bbChanVpIdNextAvailable=bbChanVpIdNextAvailable, frPortsUsedLine=frPortsUsedLine, vismAal2CasTransport=vismAal2CasTransport, bbIfXmtClp1Cells=bbIfXmtClp1Cells, ausmStdABRFRTT=ausmStdABRFRTT, ausmPortIfType=ausmPortIfType, coreCardCommands=coreCardCommands, egrXmtCells=egrXmtCells, ausmPortSvcVpiHigh=ausmPortSvcVpiHigh, chanOAMstatus224=chanOAMstatus224, bbIfIlmiEnable=bbIfIlmiEnable, vismVoIpEventNegotiationPolicy=vismVoIpEventNegotiationPolicy, bearerCid=bearerCid, bbChanRtePriority=bbChanRtePriority, parSwFunc=parSwFunc, chanIngrXmtAAL5Frames=chanIngrXmtAAL5Frames, xmtPortFrames=xmtPortFrames, bbChanRowStatus=bbChanRowStatus, axisImaGroupRxTimingRefLink=axisImaGroupRxTimingRefLink, x21AlmCnfGrpTable=x21AlmCnfGrpTable, parSysParmsMaxVDelay=parSysParmsMaxVDelay, axisImaGroupTestLinkIfIndex=axisImaGroupTestLinkIfIndex, vismAvailableDs0Count=vismAvailableDs0Count, imatmDsx3PortXmtCells=imatmDsx3PortXmtCells, bbChanRemoteNsapAddr=bbChanRemoteNsapAddr, configVrtlIntrNum=configVrtlIntrNum, cesChanState=cesChanState, ausmInterfaceMyNeighborIpAddress=ausmInterfaceMyNeighborIpAddress, bnmCellbusGrantCount=bnmCellbusGrantCount, vismChanAal2HecErrors=vismChanAal2HecErrors, x21portSvcDlciLow=x21portSvcDlciLow, imatmDsx3PortIndex=imatmDsx3PortIndex, cardResPartGrpEntry=cardResPartGrpEntry, ausmPortEgrSvcBandW=ausmPortEgrSvcBandW, cesmPort=cesmPort, frstdABRRIF=frstdABRRIF, vismVADTolerance=vismVADTolerance, ausmPortCntPortImaGrpTable=ausmPortCntPortImaGrpTable, funiAllowed=funiAllowed, ausmLocalVpi=ausmLocalVpi, cesmChanConditionedSigCode=cesmChanConditionedSigCode, bbIfSigPortNum=bbIfSigPortNum, portFileId=portFileId, rpmChanGrpTable=rpmChanGrpTable, minEnquiryIntervalT493=minEnquiryIntervalT493, parTrkCnfgLineType=parTrkCnfgLineType, atmNetPrefixEntry=atmNetPrefixEntry, ausmChanCntGrpTable=ausmChanCntGrpTable, vismCasDigitMethod=vismCasDigitMethod, rcvAcpErrCells=rcvAcpErrCells, srmeCnfGrpEntry=srmeCnfGrpEntry, bbChanEgrXmtState=bbChanEgrXmtState, vismSvcTxResyncEnds=vismSvcTxResyncEnds, rpmIfRscPrtRowStatus=rpmIfRscPrtRowStatus, x21portSvcInUse=x21portSvcInUse, ascLmiCntLineNum=ascLmiCntLineNum, atmLineCnfNum=atmLineCnfNum, ausmConnServiceType=ausmConnServiceType, bbIfMinEnquiryIntervalT493=bbIfMinEnquiryIntervalT493, parTrkCnfgDerouteDelay=parTrkCnfgDerouteDelay, imaObsDiffDelay=imaObsDiffDelay, chanIngrXmtState=chanIngrXmtState, statePortNum=statePortNum, x21portEqueueServiceRatio=x21portEqueueServiceRatio, x21portAdmin=x21portAdmin, cesCellLossStatus=cesCellLossStatus, ascChanStateSigLmiGrpEntry=ascChanStateSigLmiGrpEntry, rcvFramesDiscShelfAlarm=rcvFramesDiscShelfAlarm, vismHdlcMaxFrameSize=vismHdlcMaxFrameSize, imaPortIngrPercentUtil=imaPortIngrPercentUtil, vismSvcRxResyncEnds=vismSvcRxResyncEnds, frChanCntGrpTable=frChanCntGrpTable, ausmChanRowStatus=ausmChanRowStatus, chanIngrXmtCellRate=chanIngrXmtCellRate, cntChanNum=cntChanNum, vismSvcTxReleaseCompls=vismSvcTxReleaseCompls, ingrGfcErrCells=ingrGfcErrCells, ascLmiInvalidPduRx=ascLmiInvalidPduRx, imatmDsx3PortCntrsGrpTable=imatmDsx3PortCntrsGrpTable, ingrUpcCDVT0=ingrUpcCDVT0, frRemoteVpi=frRemoteVpi, imatmRangeNum=imatmRangeNum, counterClrButton=counterClrButton, vismEcanEncoding=vismEcanEncoding, nextPortNumAvailable=nextPortNumAvailable, vismCasVariantState=vismCasVariantState, x21portDeleteSvcs=x21portDeleteSvcs, cesPortsUsedLine5=cesPortsUsedLine5, vismSvcAtmQosCtd=vismSvcAtmQosCtd, parConnection=parConnection, RpmNsapAddress=RpmNsapAddress, ausmChanCnfGrpEntry=ausmChanCnfGrpEntry, egrMinBwInc=egrMinBwInc, cesmConnRemoteMCR=cesmConnRemoteMCR, cesXmtATMState=cesXmtATMState, bbIfRscPrtVpiLow=bbIfRscPrtVpiLow, vismHdlcChanNum=vismHdlcChanNum, ausmPortCnfPortImaGrp=ausmPortCnfPortImaGrp, egrXmtEfciSetCells=egrXmtEfciSetCells, nniSignalingTimeout=nniSignalingTimeout, vismCasInterdigitTMF=vismCasInterdigitTMF, rpmIfRscPrtIngrPctBandwidth=rpmIfRscPrtIngrPctBandwidth, vismAal2CnfPktPeriod=vismAal2CnfPktPeriod, ascLmiNodeStatusAckRx=ascLmiNodeStatusAckRx, vismVoIpDPvcRetryCnt=vismVoIpDPvcRetryCnt, vismSvcTxReleases=vismSvcTxReleases, vrtlIntrQbinTxdCellCnt=vrtlIntrQbinTxdCellCnt, bbIfMaxVpi=bbIfMaxVpi, vismPortDs0ConfigBitMap=vismPortDs0ConfigBitMap, atmLineTotalXmtCells=atmLineTotalXmtCells, bbChanVci=bbChanVci, extClockPresent=extClockPresent, ascLmiUpdateStatusTx=ascLmiUpdateStatusTx, frResPartIngrPctBW=frResPartIngrPctBW, AtmAddress=AtmAddress, parTrkLoadXmtUsedTs=parTrkLoadXmtUsedTs, ausmPortImaGrpRestartTable=ausmPortImaGrpRestartTable, bertDS0Speed=bertDS0Speed, bertSupportedTestsTableIndex=bertSupportedTestsTableIndex, vrtlIntrQbinMaxThreshold=vrtlIntrQbinMaxThreshold, bertTestMedium=bertTestMedium, portEnable=portEnable, vismXgcpBearerNetworkType=vismXgcpBearerNetworkType, imatmTrkOpType=imatmTrkOpType, cllmCnfPortNum=cllmCnfPortNum, bbChanLocalVci=bbChanLocalVci, chanTxFifoFullCnt=chanTxFifoFullCnt)
mibBuilder.exportSymbols("CISCO-WAN-AXIPOP-MIB", portOversubscribed=portOversubscribed, parSysParmsMaxDDelay=parSysParmsMaxDDelay, ausmPortDelSvcsGrpEntry=ausmPortDelSvcsGrpEntry, bbChanNonConformCellsAtGcra1Policer=bbChanNonConformCellsAtGcra1Policer, ascLmiStatusEnqTx=ascLmiStatusEnqTx, x21LineAlarmState=x21LineAlarmState, frConnRemoteMCR=frConnRemoteMCR, bbIfSnmpPduReceived=bbIfSnmpPduReceived, ausmLocalNSAP=ausmLocalNSAP, parCmParmsRrtPauseTime=parCmParmsRrtPauseTime, ausmInterfaceConfTable=ausmInterfaceConfTable, sigPortNum=sigPortNum, ds0IfType=ds0IfType, vismResPartCtrlrNum=vismResPartCtrlrNum, parSysParmsFpdDeJitter=parSysParmsFpdDeJitter, parTrkAlarmStatus=parTrkAlarmStatus, chanType=chanType, ausmStdABRRDF=ausmStdABRRDF, signallingVci=signallingVci, cesmPortCnfGrpEntry=cesmPortCnfGrpEntry, bbIfAdmin=bbIfAdmin, vismSvcRxRestartAcks=vismSvcRxRestartAcks, cesmChanCntGrpTable=cesmChanCntGrpTable, frstdABRRDF=frstdABRRDF, parTrkCnfgVccConids=parTrkCnfgVccConids, parTrkLoadRcvUsedVbr=parTrkLoadRcvUsedVbr, parConnLocalVci=parConnLocalVci, vrtlIntrQbinCounterEntry=vrtlIntrQbinCounterEntry, vismResPartLcnHigh=vismResPartLcnHigh, cesPortBERTEnable=cesPortBERTEnable, ds0MusicThreshold=ds0MusicThreshold, ds0IdleCode=ds0IdleCode, x21AlmGrpEntry=x21AlmGrpEntry, frResPartNumOfLcnAvail=frResPartNumOfLcnAvail, chanIngrClpSetRcvCells=chanIngrClpSetRcvCells, chanRTDResult=chanRTDResult, vrtlIntrQbinRate=vrtlIntrQbinRate, rpmChanOAMloopback=rpmChanOAMloopback, x21AlmLineNum=x21AlmLineNum, vismChanNumNextAvailable=vismChanNumNextAvailable, parConfigParms=parConfigParms, ds0CasWinkMinMakeTime=ds0CasWinkMinMakeTime, bbIfKeepAlivePollingEnable=bbIfKeepAlivePollingEnable, parTrkLoadXmtUsedVoice=parTrkLoadXmtUsedVoice, smFeatures=smFeatures, vismChanStatusBitMap=vismChanStatusBitMap, ausmChanStatusBitMap=ausmChanStatusBitMap, vismAdaptiveGainControl=vismAdaptiveGainControl, x21LineSendCode=x21LineSendCode, bbIfRscPrtRowStatus=bbIfRscPrtRowStatus, parCmParmsMaxUpdates=parCmParmsMaxUpdates, vismSvcRxRestarts=vismSvcRxRestarts, imatmVpTrkGrp=imatmVpTrkGrp, vismChanAal5InvCpiPdus=vismChanAal5InvCpiPdus, ausmPortCntPortImaGrpEntry=ausmPortCntPortImaGrpEntry, cesPortsUsedLine1=cesPortsUsedLine1, x21LineLoopbackCommand=x21LineLoopbackCommand, parConnRemoteVcIndx=parConnRemoteVcIndx, x21portEgrSvcBandW=x21portEgrSvcBandW, vismSvcRestartExpiries=vismSvcRestartExpiries, cesCBRClockMode=cesCBRClockMode, ausmConnRemoteMBS=ausmConnRemoteMBS, redundancyAllowed=redundancyAllowed, vismCaleaEnable=vismCaleaEnable, ausmPortSvcShareLcnVpid=ausmPortSvcShareLcnVpid, cesChanSecUptime=cesChanSecUptime, commonPortAssocChannels=commonPortAssocChannels, frPortCnfResPartGrpTable=frPortCnfResPartGrpTable, egrQEfciThresh=egrQEfciThresh, vismAal2DtmfRelay=vismAal2DtmfRelay, vismCasVariantEntry=vismCasVariantEntry, ausmCntChanNum=ausmCntChanNum, n391FullStatusPollingCounter=n391FullStatusPollingCounter, commonPortAlarmState=commonPortAlarmState, vismConnPCR=vismConnPCR, atmLineInterfaceFormat=atmLineInterfaceFormat, x21portSvcDlciHigh=x21portSvcDlciHigh, rcvPortKbpsAIR=rcvPortKbpsAIR, x21LineLoopbackCodeDetection=x21LineLoopbackCodeDetection, chanIngrXmtUtilization=chanIngrXmtUtilization, rpmChanServiceType=rpmChanServiceType, xmtAcpCells=xmtAcpCells, vismChanClrIngress=vismChanClrIngress, vismChanReroute=vismChanReroute, bertPattern=bertPattern, bbChanCongstUpdateCode=bbChanCongstUpdateCode, rateUp=rateUp, parSnNodeAlarmStatus=parSnNodeAlarmStatus, ibs=ibs, serialLineRateVariation=serialLineRateVariation, x21AlarmClrButton=x21AlarmClrButton, rpmChanMastership=rpmChanMastership, x21AlmCnfGrpEntry=x21AlmCnfGrpEntry, rpmIfCnfRscPartEntry=rpmIfCnfRscPartEntry, ausmPortSvcInUse=ausmPortSvcInUse, parTrkLocalVTrunkId=parTrkLocalVTrunkId, ds0ChanMapIfIndex=ds0ChanMapIfIndex, commonChanIngrRcvState=commonChanIngrRcvState, bbConnVpcFlag=bbConnVpcFlag, rcvStatusInquiry=rcvStatusInquiry, n393MonitoredEventCount=n393MonitoredEventCount, xmtFramesUnknownProtocols=xmtFramesUnknownProtocols, bbIfGetResponseTransmitted=bbIfGetResponseTransmitted, ausmSignallingProtocolType=ausmSignallingProtocolType, listOfLinksInImaGrp=listOfLinksInImaGrp, bbIfCnfPortGrpEntry=bbIfCnfPortGrpEntry, chanNum=chanNum, numLinksInImaGrp=numLinksInImaGrp, currentClockSource=currentClockSource, ausmPortState=ausmPortState, vismSvcRxResyncStrts=vismSvcRxResyncStrts, bertCardT1E1Type=bertCardT1E1Type, ausmRemoteVci=ausmRemoteVci, ingrUpcFGCRAEnable=ingrUpcFGCRAEnable, pxmFeatures=pxmFeatures, frPortCnfSigCLLMGrpTable=frPortCnfSigCLLMGrpTable, pxmAtmVcCrossConnectLowVpi=pxmAtmVcCrossConnectLowVpi, vismSvcTxConnAcks=vismSvcTxConnAcks, commonChanPortNum=commonChanPortNum, servicePortNum=servicePortNum, asn1ParseError=asn1ParseError, parNetParmNetwWindowSz=parNetParmNetwWindowSz, parTrkCnfgCcRestrict=parTrkCnfgCcRestrict, numLinksPresentInImaGroup=numLinksPresentInImaGroup, ausmMaxCost=ausmMaxCost, bbChanMaster=bbChanMaster, vismCasXgcpMaxReXmitTime=vismCasXgcpMaxReXmitTime, frPortCntPortGrp=frPortCntPortGrp, cir=cir, ausmConnRemoteSCR=ausmConnRemoteSCR, imatmVpTrkMapGrpTable=imatmVpTrkMapGrpTable, portXmtAisCells=portXmtAisCells, xmtFramesInvalidCPIs=xmtFramesInvalidCPIs, frConnFGCRAEnable=frConnFGCRAEnable, axisImaGroupRestartImaGrp=axisImaGroupRestartImaGrp, x21portType=x21portType, ascLmiTimerT394=ascLmiTimerT394, axisImaGroupFeTxClkMode=axisImaGroupFeTxClkMode, cesPointerReframes=cesPointerReframes, vismChanCntGrpEntry=vismChanCntGrpEntry, portLineNum=portLineNum, ascLmiTimerT393=ascLmiTimerT393, ausmStdABRCnfChanNum=ausmStdABRCnfChanNum, getRequestTransmitted=getRequestTransmitted, rcvPortBytes=rcvPortBytes, commonChannel=commonChannel, ausmChanLocalVpId=ausmChanLocalVpId, axisImaGroupFeNumFailures=axisImaGroupFeNumFailures, frMastership=frMastership, vismPortCacPvcAddFailures=vismPortCacPvcAddFailures, bertSupportedTestsTable=bertSupportedTestsTable, parTrkRemotePortNumber=parTrkRemotePortNumber, commonPortStatus=commonPortStatus, cesmPortCnfResPartGrpTable=cesmPortCnfResPartGrpTable, ascChanStateSigLmiGrp=ascChanStateSigLmiGrp, imaStatePortNum=imaStatePortNum, vismHdlcTxUnderflows=vismHdlcTxUnderflows, parTrkLoadXmtUsedVbr=parTrkLoadXmtUsedVbr, frChanCnfGrp=frChanCnfGrp, bertTimeSlots=bertTimeSlots, imatmVpTrkMapGrpTableEntry=imatmVpTrkMapGrpTableEntry, commonChanIngrXmtState=commonChanIngrXmtState, vismChanAal2CpsSentPkts=vismChanAal2CpsSentPkts, readPtrWrPtrDiff=readPtrWrPtrDiff, ausmPortEgrPercentUtil=ausmPortEgrPercentUtil, ausmPortNum=ausmPortNum, ausmEndPointMapGrpEntry=ausmEndPointMapGrpEntry, frPortCnfSigLMIGrp=frPortCnfSigLMIGrp, parSnNodeName=parSnNodeName, lmiCnfPortNum=lmiCnfPortNum, vismCasXgcpVariantName=vismCasXgcpVariantName, vismCodecPktPeriod=vismCodecPktPeriod, diagTestId=diagTestId, rcvAcpCells=rcvAcpCells, rpmPortSubInterface=rpmPortSubInterface, vismCasInterdigitTpart=vismCasInterdigitTpart, parTrkLoadXmtUsedAbr=parTrkLoadXmtUsedAbr, vismPortType=vismPortType, vismChanCntGrp=vismChanCntGrp, imatmDsx3CntrsGrp=imatmDsx3CntrsGrp, portsUsedLine6=portsUsedLine6, commonChanNum=commonChanNum, parSysParmsMaxADelay=parSysParmsMaxADelay, ausmConnRemotePCR=ausmConnRemotePCR, bertLoopback=bertLoopback, xmtPortKbpsAIR=xmtPortKbpsAIR, vismEcanCnfIdlePattern=vismEcanCnfIdlePattern, cardResPartRowStatus=cardResPartRowStatus, vismCodecNegotiationOption=vismCodecNegotiationOption, ausmChanVpIdNextAvailable=ausmChanVpIdNextAvailable, xmtFramesDiscCRCError=xmtFramesDiscCRCError, parCmParmsRrtErrsPerCycle=parCmParmsRrtErrsPerCycle, vismDspHealth=vismDspHealth, chanIngrRcvState=chanIngrRcvState, portsUsedLine2=portsUsedLine2, xmtAcpCellsMissed=xmtAcpCellsMissed, imatmPortImaCtrlMatchCells=imatmPortImaCtrlMatchCells, vrtlIntrQbinState=vrtlIntrQbinState, atmAddressEntry=atmAddressEntry, vismAal2VADTimer=vismAal2VADTimer, vismVoIpLapdTrunkPVC=vismVoIpLapdTrunkPVC, vismRtpReceiveTimer=vismRtpReceiveTimer, vismCodecPreference=vismCodecPreference, chanIngrRcvCells=chanIngrRcvCells, vismCasVariantSource=vismCasVariantSource, chanOAMstatus256=chanOAMstatus256, ingrUpcCLPTagEnable=ingrUpcCLPTagEnable, vismVoIpNTECapabilityNegotiate=vismVoIpNTECapabilityNegotiate, vismXgcpBearerVCType=vismXgcpBearerVCType, portQBwInc=portQBwInc, bnmPortCounterIndex=bnmPortCounterIndex, ds0OutputAttenuation=ds0OutputAttenuation, rpmPortRowStatus=rpmPortRowStatus, pollingIntervalT491=pollingIntervalT491, cesBufUnderflows=cesBufUnderflows, bertMode=bertMode, imaCntClrButton=imaCntClrButton, vismAal2CidFillTimer=vismAal2CidFillTimer, bearerLostPkts=bearerLostPkts, portFrameChkSumType=portFrameChkSumType, ascLmiTimeoutFailure=ascLmiTimeoutFailure, vismCodecCnfEntry=vismCodecCnfEntry, cardIngrPercentUtil=cardIngrPercentUtil, ausmChanOvrSubOvrRide=ausmChanOvrSubOvrRide, axisImaGroupGammaValue=axisImaGroupGammaValue, bbChanIngrRcvState=bbChanIngrRcvState, frPortCnfPortGrpTable=frPortCnfPortGrpTable, xmtFramesDiscard=xmtFramesDiscard)

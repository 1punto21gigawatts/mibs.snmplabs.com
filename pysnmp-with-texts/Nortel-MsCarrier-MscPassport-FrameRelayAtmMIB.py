#
# PySNMP MIB module Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB
# Produced by pysmi-0.3.4 at Wed May  1 14:30:06 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ConstraintsIntersection, SingleValueConstraint, ValueSizeConstraint, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ConstraintsIntersection", "SingleValueConstraint", "ValueSizeConstraint", "ValueRangeConstraint")
StorageType, Gauge32, Unsigned32, RowStatus, RowPointer, Counter32, Integer32, InterfaceIndex, DisplayString = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-StandardTextualConventionsMIB", "StorageType", "Gauge32", "Unsigned32", "RowStatus", "RowPointer", "Counter32", "Integer32", "InterfaceIndex", "DisplayString")
Unsigned64, IntegerSequence, HexString, NonReplicated, AsciiString, Link, EnterpriseDateAndTime, PassportCounter64 = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-TextualConventionsMIB", "Unsigned64", "IntegerSequence", "HexString", "NonReplicated", "AsciiString", "Link", "EnterpriseDateAndTime", "PassportCounter64")
mscComponents, mscPassportMIBs = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-UsefulDefinitionsMIB", "mscComponents", "mscPassportMIBs")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
TimeTicks, IpAddress, ModuleIdentity, NotificationType, Gauge32, ObjectIdentity, Unsigned32, MibIdentifier, Bits, iso, Counter32, MibScalar, MibTable, MibTableRow, MibTableColumn, Integer32, Counter64 = mibBuilder.importSymbols("SNMPv2-SMI", "TimeTicks", "IpAddress", "ModuleIdentity", "NotificationType", "Gauge32", "ObjectIdentity", "Unsigned32", "MibIdentifier", "Bits", "iso", "Counter32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Integer32", "Counter64")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
frameRelayAtmMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 51))
mscFrAtm = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72))
mscFrAtmRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 1), )
if mibBuilder.loadTexts: mscFrAtmRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmRowStatusTable.setDescription('This entry controls the addition and deletion of mscFrAtm components.')
mscFrAtmRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"))
if mibBuilder.loadTexts: mscFrAtmRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmRowStatusEntry.setDescription('A single entry in the table represents a single mscFrAtm component.')
mscFrAtmRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscFrAtm components. These components can be added and deleted.')
mscFrAtmComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscFrAtmStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmStorageType.setDescription('This variable represents the storage type value for the mscFrAtm tables.')
mscFrAtmIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: mscFrAtmIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmIndex.setDescription('This variable represents the index for the mscFrAtm tables.')
mscFrAtmCidDataTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 10), )
if mibBuilder.loadTexts: mscFrAtmCidDataTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmCidDataTable.setDescription("This group contains the attribute for a component's Customer Identifier (CID). Refer to the attribute description for a detailed explanation of CIDs.")
mscFrAtmCidDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"))
if mibBuilder.loadTexts: mscFrAtmCidDataEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmCidDataEntry.setDescription('An entry in the mscFrAtmCidDataTable.')
mscFrAtmCustomerIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 8191), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmCustomerIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmCustomerIdentifier.setDescription("This attribute holds the Customer Identifier (CID). Every component has a CID. If a component has a cid attribute, the component's CID is the provisioned value of that attribute; otherwise the component inherits the CID of its parent. The top- level component has a CID of 0. Every operator session also has a CID, which is the CID provisioned for the operator's user ID. An operator will see only the stream data for components having a matching CID. Also, the operator will be allowed to issue commands for only those components which have a matching CID. An operator CID of 0 is used to identify the Network Manager (referred to as 'NetMan' in DPN). This CID matches the CID of any component. Values 1 to 8191 inclusive (equivalent to 'basic CIDs' in DPN) may be assigned to specific customers.")
mscFrAtmStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 11), )
if mibBuilder.loadTexts: mscFrAtmStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmStateTable.setDescription('This group contains the three OSI State attributes and the six OSI Status attributes. The descriptions generically indicate what each attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241- 7001-150, Passport Operations and Maintenance Guide.')
mscFrAtmStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"))
if mibBuilder.loadTexts: mscFrAtmStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmStateEntry.setDescription('An entry in the mscFrAtmStateTable.')
mscFrAtmAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscFrAtmOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscFrAtmUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 11, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscFrAtmAvailabilityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 11, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmAvailabilityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmAvailabilityStatus.setDescription('If supported by the component, this attribute indicates the OSI Availability status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value inTest indicates that the resource is undergoing a test procedure. If adminState is locked or shuttingDown, the normal users are precluded from using the resource and controlStatus is reservedForTest. Tests that do not exclude additional users can be present in any operational or administrative state but the reservedForTest condition should not be present. The value failed indicates that the component has an internal fault that prevents it from operating. The operationalState is disabled. The value dependency indicates that the component cannot operate because some other resource on which it depends is unavailable. The operationalState is disabled. The value powerOff indicates the resource requires power to be applied and it is not powered on. The operationalState is disabled. The value offLine indicates the resource requires a routine operation (either manual, automatic, or both) to be performed to place it on-line and make it available for use. The operationalState is disabled. The value offDuty indicates the resource is inactive in accordance with a predetermined time schedule. In the absence of other disabling conditions, the operationalState is enabled or disabled. The value degraded indicates the service provided by the component is degraded in some way, such as in speed or operating capacity. However, the resource remains available for service. The operationalState is enabled. The value notInstalled indicates the resource is not present. The operationalState is disabled. The value logFull is not used. Description of bits: inTest(0) failed(1) powerOff(2) offLine(3) offDuty(4) dependency(5) degraded(6) notInstalled(7) logFull(8)')
mscFrAtmProceduralStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 11, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmProceduralStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmProceduralStatus.setDescription("If supported by the component, this attribute indicates the OSI Procedural status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value initializationRequired indicates (for a resource which doesn't initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState is disabled. The value notInitialized indicates (for a resource which does initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState may be enabled or disabled. The value initializing indicates that initialization has been initiated but is not yet complete. The operationalState may be enabled or disabled. The value reporting indicates the resource has completed some processing operation and is notifying the results. The operationalState is enabled. The value terminating indicates the component is in a termination phase. If the resource doesn't reinitialize autonomously, operationalState is disabled; otherwise it is enabled or disabled. Description of bits: initializationRequired(0) notInitialized(1) initializing(2) reporting(3) terminating(4)")
mscFrAtmControlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 11, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmControlStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmControlStatus.setDescription('If supported by the component, this attribute indicates the OSI Control status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value subjectToTest indicates the resource is available but tests may be conducted simultaneously at unpredictable times, which may cause it to exhibit unusual characteristics. The value partOfServicesLocked indicates that part of the service is restricted from users of a resource. The adminState is unlocked. The value reservedForTest indicates that the component is administratively unavailable because it is undergoing a test procedure. The adminState is locked. The value suspended indicates that the service has been administratively suspended. Description of bits: subjectToTest(0) partOfServicesLocked(1) reservedForTest(2) suspended(3)')
mscFrAtmAlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 11, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmAlarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmAlarmStatus.setDescription('If supported by the component, this attribute indicates the OSI Alarm status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value underRepair indicates the component is currently being repaired. The operationalState is enabled or disabled. The value critical indicates one or more critical alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value major indicates one or more major alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value minor indicates one or more minor alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value alarmOutstanding generically indicates that an alarm of some severity is outstanding against the component. Description of bits: underRepair(0) critical(1) major(2) minor(3) alarmOutstanding(4)')
mscFrAtmStandbyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 11, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 15))).clone(namedValues=NamedValues(("hotStandby", 0), ("coldStandby", 1), ("providingService", 2), ("notSet", 15))).clone('notSet')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmStandbyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmStandbyStatus.setDescription('If supported by the component, this attribute indicates the OSI Standby status of the component. The value notSet indicates that either the attribute is not supported or that none of the status conditions described below are present. Note that this is a non-standard value, used because the original specification indicated this attribute was set-valued and thus, did not provide a value to indicate that none of the other three are applicable. The value hotStandby indicates that the resource is not providing service but will be immediately able to take over the role of the resource to be backed up, without initialization activity, and containing the same information as the resource to be backed up. The value coldStandby indicates the resource is a backup for another resource but will not be immediately able to take over the role of the backed up resource and will require some initialization activity. The value providingService indicates that this component, as a backup resource, is currently backing up another resource.')
mscFrAtmUnknownStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 11, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmUnknownStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmUnknownStatus.setDescription('This attribute indicates the OSI Unknown status of the component. The value false indicates that all of the other OSI State and Status attribute values can be considered accurate. The value true indicates that the actual state of the component is not known for sure.')
mscFrAtmStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 12), )
if mibBuilder.loadTexts: mscFrAtmStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmStatsTable.setDescription('FrUni/n Statistics This group contains the statistics about the operational behavior of the service at the interface level.')
mscFrAtmStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"))
if mibBuilder.loadTexts: mscFrAtmStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmStatsEntry.setDescription('An entry in the mscFrAtmStatsTable.')
mscFrAtmLastUnknownDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 12, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmLastUnknownDlci.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmLastUnknownDlci.setDescription('This attribute identifies the most recent DLCI which user frames were received on for which a DLCI has not been provisioned on the port.')
mscFrAtmUnknownDlciFramesFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 12, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmUnknownDlciFramesFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmUnknownDlciFramesFromIf.setDescription('This attribute contains a count of the number of frames received from the interface with an unknown DLCI (DLCI which is not provisioned). When the maximum is reached the count wraps to zero.')
mscFrAtmInvalidHeaderFramesFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 12, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmInvalidHeaderFramesFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmInvalidHeaderFramesFromIf.setDescription('This attribute counts the number of frames received from the interface with an invalid header format. When the maximum is reached the count wraps to zero.')
mscFrAtmIfEntryTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 13), )
if mibBuilder.loadTexts: mscFrAtmIfEntryTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmIfEntryTable.setDescription('This group contains the provisionable attributes for the ifEntry.')
mscFrAtmIfEntryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"))
if mibBuilder.loadTexts: mscFrAtmIfEntryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmIfEntryEntry.setDescription('An entry in the mscFrAtmIfEntryTable.')
mscFrAtmIfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmIfAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmIfAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational. The down state indicates the interface is not operational. The testing state indicates that no operational packets can be passed.')
mscFrAtmIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 13, 1, 2), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmIfIndex.setDescription('This is the index for the IfEntry. Its value is automatically initialized during the provisioning process.')
mscFrAtmOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 14), )
if mibBuilder.loadTexts: mscFrAtmOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
mscFrAtmOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 14, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"))
if mibBuilder.loadTexts: mscFrAtmOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmOperStatusEntry.setDescription('An entry in the mscFrAtmOperStatusTable.')
mscFrAtmSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
mscFrAtmEmissionPriorityQsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 15), )
if mibBuilder.loadTexts: mscFrAtmEmissionPriorityQsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmEmissionPriorityQsTable.setDescription('This group contains the provisionable attribute to specifie the number of Frame Relay egress emission priority queues to be used on that Frame Relay Interface')
mscFrAtmEmissionPriorityQsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 15, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"))
if mibBuilder.loadTexts: mscFrAtmEmissionPriorityQsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmEmissionPriorityQsEntry.setDescription('An entry in the mscFrAtmEmissionPriorityQsTable.')
mscFrAtmNumberOfEmissionQs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 15, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(2, 2), ValueRangeConstraint(4, 4), )).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmNumberOfEmissionQs.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmNumberOfEmissionQs.setDescription('This attribute specifies the number of egress emission priority queues that will be used for that Frame Relay interface. The possible values of this attribute are 2 or 4: For V.35, V.11, HSSI, E1, DS1, E3, DS3 or 8pDS1 the possible values are: 2 (in which case they are hardware queues), or 4 (in which case they are software queues). For DS1C, E1C or DS3C the possible values are 2, 4 (in all cases they are software queues).')
mscFrAtmFrmToIfByQueueTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 341), )
if mibBuilder.loadTexts: mscFrAtmFrmToIfByQueueTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmFrmToIfByQueueTable.setDescription('This attribute counts the total number of frames transmitted to the interface per egress emission priority queue since the component has been activated. There is potientially a maximum of 4 emission priority queues. The number of available egress queues varies according to the value of the provisionable attribute numberOfEmissionQs. Egress queue 0 has the lowest priority, while egress queue 3 has the highest priority. The queue values are only indicated when the numberOfEmissionQs is set to 4 queues.')
mscFrAtmFrmToIfByQueueEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 341, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmFrmToIfByQueueIndex"))
if mibBuilder.loadTexts: mscFrAtmFrmToIfByQueueEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmFrmToIfByQueueEntry.setDescription('An entry in the mscFrAtmFrmToIfByQueueTable.')
mscFrAtmFrmToIfByQueueIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 341, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3)))
if mibBuilder.loadTexts: mscFrAtmFrmToIfByQueueIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmFrmToIfByQueueIndex.setDescription('This variable represents the index for the mscFrAtmFrmToIfByQueueTable.')
mscFrAtmFrmToIfByQueueValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 341, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmFrmToIfByQueueValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmFrmToIfByQueueValue.setDescription('This variable represents an individual value for the mscFrAtmFrmToIfByQueueTable.')
mscFrAtmOctetToIfByQueueTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 342), )
if mibBuilder.loadTexts: mscFrAtmOctetToIfByQueueTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmOctetToIfByQueueTable.setDescription('This attribute counts the total number of octets transmitted from the service to the interface per emission priority queue since the component has been activated. There is potientially a maximum of 4 emission priority queues. The number of available egress queues varies according to the value of the provisionable attribute numberOfEmissionQs. Egress queue 0 has the lowest priority, while egress queue 3 has the highest priority.')
mscFrAtmOctetToIfByQueueEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 342, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmOctetToIfByQueueIndex"))
if mibBuilder.loadTexts: mscFrAtmOctetToIfByQueueEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmOctetToIfByQueueEntry.setDescription('An entry in the mscFrAtmOctetToIfByQueueTable.')
mscFrAtmOctetToIfByQueueIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 342, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3)))
if mibBuilder.loadTexts: mscFrAtmOctetToIfByQueueIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmOctetToIfByQueueIndex.setDescription('This variable represents the index for the mscFrAtmOctetToIfByQueueTable.')
mscFrAtmOctetToIfByQueueValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 342, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmOctetToIfByQueueValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmOctetToIfByQueueValue.setDescription('This variable represents an individual value for the mscFrAtmOctetToIfByQueueTable.')
mscFrAtmFramer = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 2))
mscFrAtmFramerRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 2, 1), )
if mibBuilder.loadTexts: mscFrAtmFramerRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmFramerRowStatusTable.setDescription('This entry controls the addition and deletion of mscFrAtmFramer components.')
mscFrAtmFramerRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmFramerIndex"))
if mibBuilder.loadTexts: mscFrAtmFramerRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmFramerRowStatusEntry.setDescription('A single entry in the table represents a single mscFrAtmFramer component.')
mscFrAtmFramerRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmFramerRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmFramerRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscFrAtmFramer components. These components can be added and deleted.')
mscFrAtmFramerComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmFramerComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmFramerComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscFrAtmFramerStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmFramerStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmFramerStorageType.setDescription('This variable represents the storage type value for the mscFrAtmFramer tables.')
mscFrAtmFramerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscFrAtmFramerIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmFramerIndex.setDescription('This variable represents the index for the mscFrAtmFramer tables.')
mscFrAtmFramerProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 2, 10), )
if mibBuilder.loadTexts: mscFrAtmFramerProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmFramerProvTable.setDescription('This group contains the base provisioning data for the Framer component. Application or hardware interface specific provisioning data is contained in other provisionable Framer groups.')
mscFrAtmFramerProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmFramerIndex"))
if mibBuilder.loadTexts: mscFrAtmFramerProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmFramerProvEntry.setDescription('An entry in the mscFrAtmFramerProvTable.')
mscFrAtmFramerInterfaceName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 2, 10, 1, 1), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmFramerInterfaceName.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmFramerInterfaceName.setDescription("This attribute contains a hardware component name. The attribute associates the application with a specific link. This defines the module processor on which Framer's parent component (as well as Framer itself) will run.")
mscFrAtmFramerLinkTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 2, 11), )
if mibBuilder.loadTexts: mscFrAtmFramerLinkTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmFramerLinkTable.setDescription('This group contains attributes defining the framing of data on the link interface.')
mscFrAtmFramerLinkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 2, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmFramerIndex"))
if mibBuilder.loadTexts: mscFrAtmFramerLinkEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmFramerLinkEntry.setDescription('An entry in the mscFrAtmFramerLinkTable.')
mscFrAtmFramerDataInversion = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 2, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 16))).clone(namedValues=NamedValues(("off", 0), ("on", 16))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmFramerDataInversion.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmFramerDataInversion.setDescription("This attribute determines whether data bits are to be inverted (1 to 0 and 0 to 1) before transmission of frames to the interface. If the value of this attribute is On, the incoming data bits will also be inverted when frames are received from the link before being processed. This option is typically used in hdlc framing mode when inversion is used to guarantee 1's density. Note that aborts (in hdlc and interrupting modes) are corrupted when data is inverted. This attribute may only take its default value for non-MSA cards.")
mscFrAtmFramerFrameCrcType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 2, 11, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("crc16", 0), ("crc32", 1), ("noCrc", 2))).clone('crc16')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmFramerFrameCrcType.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmFramerFrameCrcType.setDescription('This attribute defines the type of CRC used. The CRC value calculated is appended to the end of the frames transmitted to the link. The CRC value is removed from the end of frames received from the link and checked for correctness. NoCrc means that CRC is not used. This attribute may take only its default value for non-MSA cards.')
mscFrAtmFramerFlagsBetweenFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 2, 11, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmFramerFlagsBetweenFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmFramerFlagsBetweenFrames.setDescription('This attribute defines the number of flags that are inserted between frames sent to the link interface.')
mscFrAtmFramerStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 2, 12), )
if mibBuilder.loadTexts: mscFrAtmFramerStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmFramerStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscFrAtmFramerStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 2, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmFramerIndex"))
if mibBuilder.loadTexts: mscFrAtmFramerStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmFramerStateEntry.setDescription('An entry in the mscFrAtmFramerStateTable.')
mscFrAtmFramerAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 2, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmFramerAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmFramerAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscFrAtmFramerOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 2, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmFramerOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmFramerOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscFrAtmFramerUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 2, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmFramerUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmFramerUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscFrAtmFramerStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 2, 13), )
if mibBuilder.loadTexts: mscFrAtmFramerStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmFramerStatsTable.setDescription('This group contains the operational statistics data for a Framer component.')
mscFrAtmFramerStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 2, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmFramerIndex"))
if mibBuilder.loadTexts: mscFrAtmFramerStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmFramerStatsEntry.setDescription('An entry in the mscFrAtmFramerStatsTable.')
mscFrAtmFramerFrmToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 2, 13, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmFramerFrmToIf.setStatus('obsolete')
if mibBuilder.loadTexts: mscFrAtmFramerFrmToIf.setDescription('The number of frames transmitted to the link interface by Framer. Note: This does not include the number of frames transmitted directly to the hardware queue, thus bypassing the Framer component.')
mscFrAtmFramerFrmFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 2, 13, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmFramerFrmFromIf.setStatus('obsolete')
if mibBuilder.loadTexts: mscFrAtmFramerFrmFromIf.setDescription('The number of frames received from the link interface by Framer.')
mscFrAtmFramerOctetFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 2, 13, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmFramerOctetFromIf.setStatus('obsolete')
if mibBuilder.loadTexts: mscFrAtmFramerOctetFromIf.setDescription('The number of bytes received from the link interface by Framer.')
mscFrAtmFramerAborts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 2, 13, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmFramerAborts.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmFramerAborts.setDescription('This attribute is the total number of aborts received.')
mscFrAtmFramerCrcErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 2, 13, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmFramerCrcErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmFramerCrcErrors.setDescription('This attribute is the total number of frames with CRC errors, occurring in the receive direction from the link.')
mscFrAtmFramerLrcErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 2, 13, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmFramerLrcErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmFramerLrcErrors.setDescription('This attribute is the total number of frames with LRC errors, occurring in the Tx link prior to transmission onto the link.')
mscFrAtmFramerNonOctetErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 2, 13, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmFramerNonOctetErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmFramerNonOctetErrors.setDescription('This attribute is the total number of frames that were non octet aligned.')
mscFrAtmFramerOverruns = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 2, 13, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmFramerOverruns.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmFramerOverruns.setDescription('This attribute is the total number of frames received from the link for which overruns occurred.')
mscFrAtmFramerUnderruns = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 2, 13, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmFramerUnderruns.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmFramerUnderruns.setDescription('This attribute is the total number of frames transmitted to the link for which underruns occurred.')
mscFrAtmFramerLargeFrmErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 2, 13, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmFramerLargeFrmErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmFramerLargeFrmErrors.setDescription('This attribute is the total number of frames received which were too large. The frame execeeded the maximumFrameLengthLimit provisioned attribute or it contained more than the 255 block hardware limit.')
mscFrAtmFramerFrmModeErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 2, 13, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmFramerFrmModeErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmFramerFrmModeErrors.setDescription('This attribute is the total number of frames detected with framing mode errors. A framingModeError is flagged when frames are inconsistent with the specified framingType, that is when interrupting frames are used while running in hdlc mode.')
mscFrAtmFramerFrmToIf64 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 2, 13, 1, 14), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmFramerFrmToIf64.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmFramerFrmToIf64.setDescription('The number of frames transmitted to the link interface by Framer. Note: This does not include the number of frames transmitted directly to the hardware queue, thus bypassing the Framer component.')
mscFrAtmFramerFrmFromIf64 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 2, 13, 1, 15), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmFramerFrmFromIf64.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmFramerFrmFromIf64.setDescription('The number of frames received from the link interface by Framer.')
mscFrAtmFramerOctetFromIf64 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 2, 13, 1, 16), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmFramerOctetFromIf64.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmFramerOctetFromIf64.setDescription('The number of bytes received from the link interface by Framer.')
mscFrAtmFramerUtilTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 2, 14), )
if mibBuilder.loadTexts: mscFrAtmFramerUtilTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmFramerUtilTable.setDescription('This group contains the link utilizaiton operational data for a Framer component.')
mscFrAtmFramerUtilEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 2, 14, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmFramerIndex"))
if mibBuilder.loadTexts: mscFrAtmFramerUtilEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmFramerUtilEntry.setDescription('An entry in the mscFrAtmFramerUtilTable.')
mscFrAtmFramerNormPrioLinkUtilToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 2, 14, 1, 1), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmFramerNormPrioLinkUtilToIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmFramerNormPrioLinkUtilToIf.setDescription('This attribute is the utilization of the normal and high priority data traffic (interruptable traffic) sent to the link as a percentage of the available bandwidth on the link. Note that this indluces traffic with Transfer Priorities (TP) of 0, 6 and 9 and/or Emission Priority of 2 and 3. The utilization is the average for the last minute.')
mscFrAtmFramerNormPrioLinkUtilFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 2, 14, 1, 3), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmFramerNormPrioLinkUtilFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmFramerNormPrioLinkUtilFromIf.setDescription('This attribute is the utilization of the normal and high priority data traffic (interruptable traffic) received from the link as a percentage of the available bandwidth on the link. Note that this includes traffic with Transfer Priorities (TP) of 0, 6 and 9 and/or Emission Priority of 2 and 3. The utilization is the average for the last minute.')
mscFrAtmLmi = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 3))
mscFrAtmLmiRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 3, 1), )
if mibBuilder.loadTexts: mscFrAtmLmiRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmLmiRowStatusTable.setDescription('This entry controls the addition and deletion of mscFrAtmLmi components.')
mscFrAtmLmiRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 3, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmLmiIndex"))
if mibBuilder.loadTexts: mscFrAtmLmiRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmLmiRowStatusEntry.setDescription('A single entry in the table represents a single mscFrAtmLmi component.')
mscFrAtmLmiRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 3, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmLmiRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmLmiRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscFrAtmLmi components. These components cannot be added nor deleted.')
mscFrAtmLmiComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmLmiComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmLmiComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscFrAtmLmiStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmLmiStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmLmiStorageType.setDescription('This variable represents the storage type value for the mscFrAtmLmi tables.')
mscFrAtmLmiIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscFrAtmLmiIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmLmiIndex.setDescription('This variable represents the index for the mscFrAtmLmi tables.')
mscFrAtmLmiParmsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 3, 10), )
if mibBuilder.loadTexts: mscFrAtmLmiParmsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmLmiParmsTable.setDescription('This group contains the provisionable attributes of the LMI component.')
mscFrAtmLmiParmsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 3, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmLmiIndex"))
if mibBuilder.loadTexts: mscFrAtmLmiParmsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmLmiParmsEntry.setDescription('An entry in the mscFrAtmLmiParmsTable.')
mscFrAtmLmiProcedures = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 3, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 0), ("vendorForum", 1), ("ansi", 2), ("itu", 3), ("autoConfigure", 4))).clone('autoConfigure')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmLmiProcedures.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmLmiProcedures.setDescription('This attribute selects the procedures to be used for the Local Management Interface. The following procedures are supported: none: no Local Management Interface procedures are running on this interface. This accommodates Frame Relay user equipment that has not implemented any LMI procedures. The remaining attributes of this group are ignored. vendorForum: Local Management Interface procedures from the Vendor Forum specification are supported on this interface. DLCI 1023 is used for the LMI protocol. This value cannot be used if the side attribute is both. ansi: Local Management Interface procedures from the ANSI specification are supported. DLCI 0 is used for the LMI protocol. itu: Local Management Interface procedures from the ITU-T specification are supported. DLCI 0 is used for the LMI protocol. Was previously ccitt. autoConfigure: The interface determines automatically which Local Management Interface procedures to use. This value cannot be used if the side attribute is user. The procedures currently in use can be seen in the operational attribute opProcedures.')
mscFrAtmLmiAsyncStatusReport = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 3, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmLmiAsyncStatusReport.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmLmiAsyncStatusReport.setDescription('This attribute selects the use of asynchronous PVC status report procedures as specified in ANSI, CCITT, and Vendor Forum. This attribute can be set to on or off. If procedures is set to none, this attribute is ignored.')
mscFrAtmLmiErrorEventThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 3, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmLmiErrorEventThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmLmiErrorEventThreshold.setDescription('An event is defined as follows: (1) receipt of a STATUS ENQUIRY message; or (2) expiration of timer T392. An error event is (1) nonreceipt of STATUS ENQUIRY in T392 seconds; (2) invalid contents of a LMI message; (3) invalid receive sequence number. This attribute specifies the number of error events which, if they occur within eventCount events, cause a protocol error condition. The condition is cleared after eventCount sequential correct events occur. This attribute corresponds to the nN2 parameter described in the Vendor Forum Specification. It must be less than or equal to eventCount.')
mscFrAtmLmiEventCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 3, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmLmiEventCount.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmLmiEventCount.setDescription('This attribute specifies the number of contiguous events within which no more than eventErrorThreshold error events are allowed. This attribute corresponds to the nN3 parameter described in the Vendor Forum Specification. It must be greater than or equal to errorEventThreshold.')
mscFrAtmLmiCheckPointTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 3, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(5, 5), ValueRangeConstraint(10, 10), ValueRangeConstraint(15, 15), ValueRangeConstraint(20, 20), ValueRangeConstraint(25, 25), ValueRangeConstraint(30, 30), )).clone(15)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmLmiCheckPointTimer.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmLmiCheckPointTimer.setDescription('This attribute selects the time (in seconds) within which a STATUS ENQUIRY message is expected. This attribute corresponds to the nT2 parameter described in the Vendor Forum Specification. It must be less than messageCountTimer.')
mscFrAtmLmiMessageCountTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 3, 10, 1, 6), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(5, 5), ValueRangeConstraint(10, 10), ValueRangeConstraint(15, 15), ValueRangeConstraint(20, 20), ValueRangeConstraint(25, 25), ValueRangeConstraint(30, 30), )).clone(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmLmiMessageCountTimer.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmLmiMessageCountTimer.setDescription('This attribute selects the time (in seconds) within which at most five (this is a fixed value and corresponds to maximum message count in VendorForum) STATUS ENQUIRY messages are expected. This attribute applies only when the lmiProcedures is set to vendorForum. messageCountTimer must always be greater than checkPointTimer.')
mscFrAtmLmiIgnoreActiveBit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 3, 10, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmLmiIgnoreActiveBit.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmLmiIgnoreActiveBit.setDescription('This attribute specifies whether the Frame Relay LMI Active Bit (A-bit) has a bearing on the transfer of user data across this Frame Relay interface for both directions of traffic flow. When this attribute is set to yes, the A-bit status of a user DLCI connection does not affect data transfer. When this attribute is set to no, data received from the local interface will be discarded if an A-bit =0 condition exists towards the local user. Data being sent to the local interface is discarded if an A-bit = 0 condition exists towards the subnet.')
mscFrAtmLmiSide = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 3, 10, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("network", 0), ("user", 1), ("both", 2))).clone('network')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmLmiSide.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmLmiSide.setDescription('This attribute can be set to user, network, or both. When this attribute is set to user, USP LMI procedures are running. When this attribute is set to network, NSP LMI procedures are running. When this attribute is set to both, USPNSP LMI procedures are running. When the value is both, the procedures attribute must not be set to vendorForum. Setting the value to user when the procedures attribute is set to autoConfigure is disallowed semantically.')
mscFrAtmLmiPvcConfigParmsInFsr = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 3, 10, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmLmiPvcConfigParmsInFsr.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmLmiPvcConfigParmsInFsr.setDescription('When this attribute is set to yes, additional Q.933 information elements are included in the LMI Full Status message to facilitate CPE PVC parameter configuring. When set to yes, the Check Prov command fails if the Lmi side is not set to network. When set to yes, Check Prov fails if the number of DLCIs on the FrUni is greater than 300. If the service is not a FrUni this attribute is ignored.')
mscFrAtmLmiStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 3, 11), )
if mibBuilder.loadTexts: mscFrAtmLmiStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmLmiStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscFrAtmLmiStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 3, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmLmiIndex"))
if mibBuilder.loadTexts: mscFrAtmLmiStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmLmiStateEntry.setDescription('An entry in the mscFrAtmLmiStateTable.')
mscFrAtmLmiAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 3, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmLmiAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmLmiAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscFrAtmLmiOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 3, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmLmiOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmLmiOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscFrAtmLmiUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 3, 11, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmLmiUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmLmiUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscFrAtmLmiPsiTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 3, 12), )
if mibBuilder.loadTexts: mscFrAtmLmiPsiTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmLmiPsiTable.setDescription('This group provides the protocol status of the Local Management Interface.')
mscFrAtmLmiPsiEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 3, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmLmiIndex"))
if mibBuilder.loadTexts: mscFrAtmLmiPsiEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmLmiPsiEntry.setDescription('An entry in the mscFrAtmLmiPsiTable.')
mscFrAtmLmiProtocolStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 3, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("errorCondition", 0), ("normalCondition", 1), ("configuring", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmLmiProtocolStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmLmiProtocolStatus.setDescription('This attribute indicates whether the LMI is in an error condition or whether the LMI procedures are behaving normally. When operating with no LMI protocol, this attribute is always set to normalCondition. When operating with LMI procedures, this attribute is set to errorCondition after n392 of the last n393 events are in error. The consequence of an errorCondition is that all DLCIs on this interface will become inactive in both directions. The errorCondition is cleared and a normalCondition is indicated when a sufficient number of events have occurred without error. In ANSI, this occurs when n393 consecutive good events take place. If the procedures attribute is set to autoConfigure, this attribute is set to configuring while adaptive LMI determines which LMI procedures are running on the link. A single LMI error event during auto configuration causes the attribute value to change to errorCondition. If during configuring no LMI message is received, an LMI errorCondition is raised after n392 x t392 seconds.')
mscFrAtmLmiOpProcedures = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 3, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 0), ("vendorForum", 1), ("ansi", 2), ("itu", 3), ("unknown", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmLmiOpProcedures.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmLmiOpProcedures.setDescription('The opProcedures attribute indicates the procedures being used for the Local Management Interface. This attribute should be ignored if protocolStatus is not normalCondition. The following procedures are supported: none: Local Management Interface procedures are not running on this interface. This accommodates Frame Relay user equipment that has not implemented any LMI procedures. vendorForum: Local Management Interface procedures from the Vendor Forum specification are running on this interface. DLCI 1023 is used for the LMI protocol. ansi: Local Management Interface procedures from the ANSI specification are running. DLCI 0 is used for the LMI protocol. itu: Local Management Interface procedures from the ITU-T specification are running. DLCI 0 is used for the LMI protocol. Was previously ccitt. unknown: Local Management Interface procedures have yet to be determined by Adaptive LMI.')
mscFrAtmLmiStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 3, 13), )
if mibBuilder.loadTexts: mscFrAtmLmiStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmLmiStatsTable.setDescription('This group contains the operational statistics for the Frame Relay Local Management Interface.')
mscFrAtmLmiStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 3, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmLmiIndex"))
if mibBuilder.loadTexts: mscFrAtmLmiStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmLmiStatsEntry.setDescription('An entry in the mscFrAtmLmiStatsTable.')
mscFrAtmLmiKeepAliveStatusToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 3, 13, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmLmiKeepAliveStatusToIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmLmiKeepAliveStatusToIf.setDescription('This attribute counts the number of Local Management Interface keep alive status messages sent to the external user device in response to a status enquiry for keep alive status. When the maximum count is exceeded it wraps to zero.')
mscFrAtmLmiFullStatusToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 3, 13, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmLmiFullStatusToIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmLmiFullStatusToIf.setDescription('This attribute counts the number of Local Management Interface full status messages sent to the external user device in response to a status enquiry for keep alive or full status. When the maximum count is reached it wraps to zero.')
mscFrAtmLmiKeepAliveStatusEnqFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 3, 13, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmLmiKeepAliveStatusEnqFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmLmiKeepAliveStatusEnqFromIf.setDescription('This attribute counts the number of Local Management Interface valid keep alive status enquiry messages received from the external user device. When the maximum count is reached it wraps to zero.')
mscFrAtmLmiFullStatusEnqFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 3, 13, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmLmiFullStatusEnqFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmLmiFullStatusEnqFromIf.setDescription('This attribute counts the number of Local Management Interface valid full status enquiry messages received from the external user device. When the maximum count is reached it wraps to zero.')
mscFrAtmLmiNetworkSideEventHistory = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 3, 13, 1, 5), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmLmiNetworkSideEventHistory.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmLmiNetworkSideEventHistory.setDescription("This attribute displays the Local Management Interface network side procedure event history in order of occurrence. An event is represented by a single symbol. A '+' symbol indicates a good event. An 'X' symbol indicates a protocol error event. The leftmost event is the most recent to occur. The provisioned eventCount (nN3/ N393) dictates the maximum number of events displayed. A good event is triggered by receipt of a valid status enquiry message. An error event is one of three possibilities, either a nT2/T392 timer expiry, receipt of a status enquiry message with bad sequence numbers, or when lmiProcedures is provisioned to vendorForum and we receive more than nN4 status enquiry messages within the provisioned messageCountTimer (nT3).")
mscFrAtmLmiProtocolErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 3, 13, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmLmiProtocolErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmLmiProtocolErrors.setDescription('This attribute counts the number of Local Management Interface protocol errors. It is the sum of the sequence (sequenceErrors), timeout (pollingVerifTimeouts) and too many status enquiry messages received within the messageCountTimer (nT3) errors. The too many status enquiries error only applies when lmiProcedures is set to vendorForum. When the maximum count is exceeded it wraps to zero.')
mscFrAtmLmiUnexpectedIes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 3, 13, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmLmiUnexpectedIes.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmLmiUnexpectedIes.setDescription('This attribute counts the number of Local Management Interface frames received with an Information Element identifier that is unknown or unexpected. An unexpected Information Element is not a protocol error. When the maximum count is reached, this counter wraps to zero.')
mscFrAtmLmiSequenceErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 3, 13, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmLmiSequenceErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmLmiSequenceErrors.setDescription('This attribute counts the number of Local Management Interface Status Enquiry message sequence errors. A sequence error is receipt of a Status Enquiry message with a receive sequence number not equal to the last send sequence number. When the maximum count is reached the counter wraps to zero.')
mscFrAtmLmiUnexpectedReports = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 3, 13, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmLmiUnexpectedReports.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmLmiUnexpectedReports.setDescription('This attribute counts the number of Local Management Interface frames received with an unknown or unexpected report type. An unexpected report type is not a protocol error. When the maximum count is reached the counter wraps to zero.')
mscFrAtmLmiPollingVerifTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 3, 13, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmLmiPollingVerifTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmLmiPollingVerifTimeouts.setDescription('This attribute counts the number of checkPointTImer (t392) timer expiries occurring on the Local Management Interface. When the maximum count is reached the counter wraps to zero.')
mscFrAtmLmiKeepAliveEnqToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 3, 13, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmLmiKeepAliveEnqToIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmLmiKeepAliveEnqToIf.setDescription('This attribute counts the number of Local Management Interface keep alive enquiry status messages sent to the external user device for keep alive status. When the maximum count is reached it wraps to zero.')
mscFrAtmLmiFullStatusEnqToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 3, 13, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmLmiFullStatusEnqToIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmLmiFullStatusEnqToIf.setDescription('This attribute counts the number of Local Management Interface full status messages sent to the external user device in response to a status enquiry for keep alive or full status. When the maximum count is reached it wraps to zero.')
mscFrAtmLmiUserSideEventHistory = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 3, 13, 1, 13), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmLmiUserSideEventHistory.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmLmiUserSideEventHistory.setDescription("This attribute displays the Local Management Interface user side procedure event history in order of occurrence. An event is represented by a single symbol. A '+' symbol indicates a good event. An 'X' symbol indicates a protocol error event. The left most event is the most recent to occur. The provisioned eventCount (nN3/ N393) dictates the maximum number of events displayed. A good event is triggered by receipt of a valid status message. An error event is either a nT1/T391 timer expiry or receipt of a status message with bad sequence numbers.")
mscFrAtmLmiStatusSequenceErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 3, 13, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmLmiStatusSequenceErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmLmiStatusSequenceErrors.setDescription('This attribute counts the number of Local Management Interface Status message sequence errors. A sequence error is receipt of a Status message with a receive sequence number not equal to the last send sequence number. When the maximum count is reached the counter wraps to zero.')
mscFrAtmLmiNoStatusReportCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 3, 13, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmLmiNoStatusReportCount.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmLmiNoStatusReportCount.setDescription('This attribute counts the number of times when no status report or an invalid status report comes from the external network. This attribute is incremented in two cases: i) after a status enquiry is sent out and T391 timer expires without having a status report received. ii) an invalid status report is received. When the maximum count is reached it wraps to zero.')
mscFrAtmLmiUspParmsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 3, 14), )
if mibBuilder.loadTexts: mscFrAtmLmiUspParmsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmLmiUspParmsTable.setDescription('This group contains the provisionable attributes of the Local Management Interface user side procedure.')
mscFrAtmLmiUspParmsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 3, 14, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmLmiIndex"))
if mibBuilder.loadTexts: mscFrAtmLmiUspParmsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmLmiUspParmsEntry.setDescription('An entry in the mscFrAtmLmiUspParmsTable.')
mscFrAtmLmiFullStatusPollingCycles = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 3, 14, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmLmiFullStatusPollingCycles.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmLmiFullStatusPollingCycles.setDescription('This attribute specifies how frequently the Frame Relay UNI service should initiate a Status Enquiry for a full PVC status report. A polling cycle is a Status Enquiry and Status Report exchange. This attribute is used only if the side attribute is either user or both.')
mscFrAtmLmiLinkVerificationTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 3, 14, 1, 2), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(5, 5), ValueRangeConstraint(10, 10), ValueRangeConstraint(15, 15), ValueRangeConstraint(20, 20), ValueRangeConstraint(25, 25), ValueRangeConstraint(30, 30), )).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmLmiLinkVerificationTimer.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmLmiLinkVerificationTimer.setDescription('This attribute specifies how frequently the Frame Relay UNI service should initiate a Status Enquiry for link integrity verification. It must be less than checkPointTimer (t392). When the Lmi side is network, this attribute is ignored.')
mscFrAtmDlci = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4))
mscFrAtmDlciRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 1), )
if mibBuilder.loadTexts: mscFrAtmDlciRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciRowStatusTable.setDescription('This entry controls the addition and deletion of mscFrAtmDlci components.')
mscFrAtmDlciRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciIndex"))
if mibBuilder.loadTexts: mscFrAtmDlciRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciRowStatusEntry.setDescription('A single entry in the table represents a single mscFrAtmDlci component.')
mscFrAtmDlciRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmDlciRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscFrAtmDlci components. These components can be added and deleted.')
mscFrAtmDlciComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscFrAtmDlciStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciStorageType.setDescription('This variable represents the storage type value for the mscFrAtmDlci tables.')
mscFrAtmDlciIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 1007)))
if mibBuilder.loadTexts: mscFrAtmDlciIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciIndex.setDescription('This variable represents the index for the mscFrAtmDlci tables.')
mscFrAtmDlciStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 10), )
if mibBuilder.loadTexts: mscFrAtmDlciStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscFrAtmDlciStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciIndex"))
if mibBuilder.loadTexts: mscFrAtmDlciStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciStateEntry.setDescription('An entry in the mscFrAtmDlciStateTable.')
mscFrAtmDlciAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscFrAtmDlciOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscFrAtmDlciUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscFrAtmDlciABitTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 11), )
if mibBuilder.loadTexts: mscFrAtmDlciABitTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciABitTable.setDescription('This group contains the A-Bit status information for this Data Link Connection Identifier.')
mscFrAtmDlciABitEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciIndex"))
if mibBuilder.loadTexts: mscFrAtmDlciABitEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciABitEntry.setDescription('An entry in the mscFrAtmDlciABitTable.')
mscFrAtmDlciABitStatusToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("inactive", 0), ("active", 1), ("notApplicable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciABitStatusToIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciABitStatusToIf.setDescription("This attribute contains the most recent A-bit status sent to the interface. The A-bit status is part of the LMI protocol, and indicates the remote end's willingness to accept data from the local interface. When an inactive setting is sent out, the Frame Relay service will discard any data offered from the local interface. When an active setting is sent out, the Frame Relay service tries to process all data offered from the local interface.")
mscFrAtmDlciABitReasonToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("notApplicable", 0), ("remoteUserSignaled", 1), ("localLmiError", 2), ("remoteLmiError", 3), ("localLinkDown", 4), ("remoteLinkDown", 5), ("pvcDown", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciABitReasonToIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciABitReasonToIf.setDescription('This attribute provides the reason (if any) for an inactive status to be sent to the interface. This reason is notApplicable for an active status.')
mscFrAtmDlciABitStatusFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 11, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("inactive", 0), ("active", 1), ("notApplicable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciABitStatusFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciABitStatusFromIf.setDescription('This attribute indicates the most recent A-Bit status received from the interface.')
mscFrAtmDlciABitReasonFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 11, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 4, 6, 7))).clone(namedValues=NamedValues(("notApplicable", 0), ("remoteUserSignaled", 1), ("localLmiError", 2), ("localLinkDown", 4), ("pvcDown", 6), ("missingFromLmiReport", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciABitReasonFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciABitReasonFromIf.setDescription('This attribute provides the reason (if any) for an inactive status to be sent to the subnet. The value is notApplicable when the aBitStatusFromIf attribute is active. The value is remoteUserSignaled if the remote interface originating the A-Bit status detects that the virtual circuit is down at the remote network through the LMI protocol. The remote interface must be running network site LMI protocol for this A-Bit status reason to be sent. The value is localLmiError if the LMI protocol is down at this interface. The value is localLinkDown if the physical link is disabled at this interface. The value is pvcDown if no A-Bit status has been sent to this interface from the local network. The value is missingFromLmiReport if the remote interface did not provide a reason along with the inactive A-Bit status. DESCRIPTION')
mscFrAtmDlciSpOpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 12), )
if mibBuilder.loadTexts: mscFrAtmDlciSpOpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSpOpTable.setDescription('This group contains service parameters for the Dlci component.')
mscFrAtmDlciSpOpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciIndex"))
if mibBuilder.loadTexts: mscFrAtmDlciSpOpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSpOpEntry.setDescription('An entry in the mscFrAtmDlciSpOpTable.')
mscFrAtmDlciMaximumFrameSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 12, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 8187))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciMaximumFrameSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciMaximumFrameSize.setDescription('This attribute indicates the maximum number of octets which can be included in the information field. This definition does not include the FrameRelay header and CRC octets. This attribute corresponds to the dN1 parameter described in the Vendor Forum Specification.')
mscFrAtmDlciRateEnforcement = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciRateEnforcement.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciRateEnforcement.setDescription('This attribute indicates whether rate enforcement is in effect for this user Data Link Connection on this FrAtm interface. When rate enforcement is on, Committed Information Rate (CIR) and DE=1 traffic will be measured and enforced. When rate enforcement is off, all frames from the user will be accepted and no modifications to the frame with respect to the DE bit will be made.')
mscFrAtmDlciCommittedInformationRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 12, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 50000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciCommittedInformationRate.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciCommittedInformationRate.setDescription('This attribute indicates the committed information rate (CIR) in bits per second (bit/s) and represents the rate at which the network agrees to transfer information under normal conditions when rateEnforcement is on. This rate is measured over a measurement interval (t). This attribute is not applicable when rateEnforcement is off.')
mscFrAtmDlciCommittedBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 12, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 50000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciCommittedBurstSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciCommittedBurstSize.setDescription('This attribute indicates the committed burst size (Bc) in bits and represents the amount of data that a network agrees to transfer under normal conditions over a measurement interval (t) when rateEnforcement is on. Data marked with DE=1 is not accounted for in committed burst size. This attribute is not applicable when rateEnforcement is off.')
mscFrAtmDlciExcessBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 12, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 50000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciExcessBurstSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciExcessBurstSize.setDescription('This attribute indicates the excess burst size (Be) in bits and represents the amount of uncommitted data that the network attempts to deliver over measurement interval (t) when rateEnforcement is on. Data marked DE=1 by the user or by the network is accounted for here. This attribute is not applicable ignored when rateEnforcement is off.')
mscFrAtmDlciMeasurementInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 12, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciMeasurementInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciMeasurementInterval.setDescription('This attribute indicates the time interval over which rates and burst sizes are measured. This attribute is not applicable when rateEnforcement is off.')
mscFrAtmDlciEmissionPriorityToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 12, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 1), ValueRangeConstraint(2, 2), ValueRangeConstraint(3, 3), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciEmissionPriorityToIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciEmissionPriorityToIf.setDescription('This attribute indicates the emission priority of frames sent to the interface. If the value of FrAtm/n numberOfEmissionQs is 2, set the value of this attribute to either 0 or 1; if the value of FrAtm/n numberOfEmissionQs is 4, set the value of this attribute to one of 0, 1, 2, 3.')
mscFrAtmDlciDlciType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 12, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("serviceInterworking", 0), ("networkInterworking", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciDlciType.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciDlciType.setDescription('This attribute indicates the type of DLCI. A value of serviceInterworking indicates that a FrAtm/n Dlci/n Siwf component is present. A value of networkInterworking indicates that a FrAtm/n Dlci/n Niwf component is present.')
mscFrAtmDlciTroubled = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 12, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciTroubled.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciTroubled.setDescription('This attribute indicates whether or not the connection is in a troubled state. Connections may become troubled for the following reasons; if CAC failed to admit the call, or if one of the attributes aBitStatusToIf, aBitStatusFromIf goes inactive; otherwise it is set to no.')
mscFrAtmDlciTroubledReason = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 12, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("notApplicable", 0), ("notAdmitted", 1))).clone('notApplicable')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciTroubledReason.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciTroubledReason.setDescription('This attribute provides the reason (if any) for a troubled connection. A value of notApplicable indicates no current failures; either Connection Admission Control (CAC) is off, or call was admitted. A value of notAdmitted indicates the CAC algorithm fails to admit this connection. Check if there is a sufficient bandwidth allocation.')
mscFrAtmDlciStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 13), )
if mibBuilder.loadTexts: mscFrAtmDlciStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciStatsTable.setDescription('This group contains the operational statistics for the Frame Relay Data Link Connection Identifier.')
mscFrAtmDlciStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciIndex"))
if mibBuilder.loadTexts: mscFrAtmDlciStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciStatsEntry.setDescription('An entry in the mscFrAtmDlciStatsTable.')
mscFrAtmDlciFrmToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 13, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciFrmToIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciFrmToIf.setDescription('This attribute counts the number of frames sent to the interface. When the maximum count is reached, the count wraps to zero.')
mscFrAtmDlciFecnFrmToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 13, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciFecnFrmToIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciFecnFrmToIf.setDescription('This attribute counts the number of frames sent to the interface with the Forward Explicit Congestion Notification (FECN) bit set. When the maximum count is reached, the count wraps to zero.')
mscFrAtmDlciBecnFrmToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 13, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciBecnFrmToIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciBecnFrmToIf.setDescription('This attribute counts the number of frames sent to the interface with the Backward Explicit Congestion Notification (BECN) bit set. When the maximum count is reached, the count wraps to zero.')
mscFrAtmDlciDeFrmToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 13, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciDeFrmToIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciDeFrmToIf.setDescription('This attribute counts the number of frames sent to the interface with the Discard Eligibility (DE) bit set. When the maximum count is reached, the count wraps to zero.')
mscFrAtmDlciDiscCongestedToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 13, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciDiscCongestedToIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciDiscCongestedToIf.setDescription('This attribute counts the number of frame discards at the Frame Relay service due to local congestion in the direction toward the interface. When the maximum count is reached, the count wraps to zero.')
mscFrAtmDlciDiscDeCongestedToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 13, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciDiscDeCongestedToIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciDiscDeCongestedToIf.setDescription('This attribute counts the number of discarded frames, with the Discard Eligibility (DE) bit set, at the Frame Relay service, due to local congestion in the direction toward the interface. When the maximum count is reached, the count wraps to zero.')
mscFrAtmDlciFrmFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 13, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciFrmFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciFrmFromIf.setDescription('This attribute counts the number of frames received from the interface. Frames that are discarded due to error or excess are not counted. When the maximum count is reached, the count wraps to zero.')
mscFrAtmDlciFecnFrmFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 13, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciFecnFrmFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciFecnFrmFromIf.setDescription('This attribute counts the number of frames received from the interface with the Forward Explicit Congestion Notification (FECN) bit set. When the maximum count is reached, the count wraps to zero.')
mscFrAtmDlciBecnFrmFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 13, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciBecnFrmFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciBecnFrmFromIf.setDescription('This attribute counts the number of frames received from the interface with the Backward Explicit Congestion Notification (BECN) bit set. When the maximum count is reached, the count wraps to zero.')
mscFrAtmDlciEfciFrmFromNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 13, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciEfciFrmFromNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciEfciFrmFromNetwork.setDescription('This attribute counts the number of frames received from the interworking function with the Explicit Forward Congestion Indication (EFCI) bit set. When the maximum count is reached, the count wraps to zero.')
mscFrAtmDlciDeFrmFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 13, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciDeFrmFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciDeFrmFromIf.setDescription('This attribute counts the number of frames received from the interface with the Discard Eligibility (DE) bit set. When the maximum count is reached, the count wraps to zero.')
mscFrAtmDlciExcessFrmFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 13, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciExcessFrmFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciExcessFrmFromIf.setDescription('This attribute counts the number of frames received from the interface with the Discard Eligibility (DE) bit clear, but subsequently set by the network due to rate enforcement. When the maximum count is reached, the count wraps to zero.')
mscFrAtmDlciDiscExcessFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 13, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciDiscExcessFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciDiscExcessFromIf.setDescription('This attribute counts the number of frames which were discarded due to rate enforcement. When the maximum count is reached, the count wraps to zero.')
mscFrAtmDlciDiscFrameAbit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 13, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciDiscFrameAbit.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciDiscFrameAbit.setDescription('This attribute counts the number of frame discards at the Frame Relay Service, due to an inactive PVC status, in the direction toward the interworking function. When the maximum count is reached, the count wraps to zero.')
mscFrAtmDlciDiscCongestedFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 13, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciDiscCongestedFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciDiscCongestedFromIf.setDescription('This attribute counts the number of frame discards at the Frame Relay service due to local congestion in the direction toward the interworking function. When the maximum count is reached, the count wraps to zero.')
mscFrAtmDlciDiscDeCongestedFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 13, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciDiscDeCongestedFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciDiscDeCongestedFromIf.setDescription('This attribute counts the number of discarded frames, with the Discard Eligibility (DE) bit set due to local congestion in the direction toward the interworking function. When the maximum count is reached, the count wraps to zero.')
mscFrAtmDlciErrorShortFrmFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 13, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciErrorShortFrmFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciErrorShortFrmFromIf.setDescription('This attribute counts the number of frames received with 0 octets in the information field. When the maximum count is reached, the count wraps to zero.')
mscFrAtmDlciErrorLongFrmFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 13, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciErrorLongFrmFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciErrorLongFrmFromIf.setDescription('This attribute counts the number of frames received with number of octets in the information field greater than the subscribed maximum. When the maximum count is reached, the count wraps to zero. The hardware ignores frame lengths greater than the hardware receive buffer, and therfore does not includes them in this count.')
mscFrAtmDlciBecnFrmSetByService = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 13, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciBecnFrmSetByService.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciBecnFrmSetByService.setDescription('This attribute counts the number of frames with BECN set by the Frame Relay service. It is incremented when the Frame Relay service sets BECN on a frame upon detecting local congestion. This count is incremented regardless of whether the frame already bears a set BECN bit since its use is to determine the place of congestion. When the maximum count is reached, the count wraps to zero.')
mscFrAtmDlciBytesToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 13, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciBytesToIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciBytesToIf.setDescription('This attribute counts the number of bytes sent out the interface. When the maximum count is reached, the count wraps to zero.')
mscFrAtmDlciDeBytesToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 13, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciDeBytesToIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciDeBytesToIf.setDescription('This attribute counts the number of bytes sent to the interface with the Discard Eligibility (DE) bit set. When the maximum count is reached, the count wraps to zero.')
mscFrAtmDlciDiscCongestedToIfBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 13, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciDiscCongestedToIfBytes.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciDiscCongestedToIfBytes.setDescription('This attribute counts the number of byte discards at the Frame Relay service due to local congestion in the direction toward the link. When the maximum count is reached, the count wraps to zero.')
mscFrAtmDlciDiscDeCongestedToIfBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 13, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciDiscDeCongestedToIfBytes.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciDiscDeCongestedToIfBytes.setDescription('This attribute counts the number of discard eligible (DE=1) byte discards at the Frame Relay service due to local congestion in the direction toward the link. When the maximum count is reached, the count wraps to zero.')
mscFrAtmDlciBytesFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 13, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciBytesFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciBytesFromIf.setDescription('This attribute counts the number of bytes received from the interface. Bytes that are discarded due to error or excess are not counted. When the maximum count is reached, the count wraps to zero.')
mscFrAtmDlciDeBytesFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 13, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciDeBytesFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciDeBytesFromIf.setDescription('This attribute counts the number of bytes received from the interface with the Discard Eligibility (DE) bit set. When the maximum count is reached, the count wraps to zero.')
mscFrAtmDlciExcessBytesFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 13, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciExcessBytesFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciExcessBytesFromIf.setDescription('This attribute counts the number of bytes received from the interface with the Discard Eligibility (DE) bit clear, but subsequently set by the network due to rate enforcement. When the maximum count is reached, the count wraps to zero.')
mscFrAtmDlciDiscExcessFromIfBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 13, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciDiscExcessFromIfBytes.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciDiscExcessFromIfBytes.setDescription('This attribute counts the number of bytes which were discarded due to rate enforcement. When the maximum count is reached, the count wraps to zero.')
mscFrAtmDlciDiscByteAbit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 13, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciDiscByteAbit.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciDiscByteAbit.setDescription('This attribute counts the bytes number of which were discarded due to the A-bit being turned off. When the maximum count is reached, the count wraps to zero.')
mscFrAtmDlciDiscCongestedFromIfBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 13, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciDiscCongestedFromIfBytes.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciDiscCongestedFromIfBytes.setDescription('This attribute counts the number of byte discards at the Frame Relay service due to local congestion in the direction toward the interworking function. When the maximum count is reached, the count wraps to zero.')
mscFrAtmDlciDiscDeCongestedFromIfBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 13, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciDiscDeCongestedFromIfBytes.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciDiscDeCongestedFromIfBytes.setDescription('This attribute counts the number of discard eligible (DE=1) byte discards at the Frame Relay service due to local congestion in the direction toward the interworking function. When the maximum count is reached, the count wraps to zero.')
mscFrAtmDlciErrorShortBytesFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 13, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciErrorShortBytesFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciErrorShortBytesFromIf.setDescription('This attribute counts the number of bytes received with 0 octets in the information field. When the maximum count is reached, the count wraps to zero.')
mscFrAtmDlciErrorLongBytesFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 13, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciErrorLongBytesFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciErrorLongBytesFromIf.setDescription('This attribute counts the number of bytes received when the number of octets in the information field is greater than the subscribed maximum. The hardware ignores bytes lengths greater than the hardware receive buffer and therefore does not include them in this count. When the maximum count is reached, the count wraps to zero.')
mscFrAtmDlciCalldTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 14), )
if mibBuilder.loadTexts: mscFrAtmDlciCalldTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciCalldTable.setDescription('This group contains the operational values for the FrAtm Dlci call data. If the accountingEnabled attribute is no, then this group except for accountingEnabled is not displayed.')
mscFrAtmDlciCalldEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 14, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciIndex"))
if mibBuilder.loadTexts: mscFrAtmDlciCalldEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciCalldEntry.setDescription('An entry in the mscFrAtmDlciCalldTable.')
mscFrAtmDlciAccountingEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciAccountingEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciAccountingEnabled.setDescription('This attribute indicates whether accounting is enabled. To enable accounting, the FrAtm Ca accountCollection attribute must be non- empty and FrAtm Dlci Sp accounting attribute must be on.')
mscFrAtmDlciAccountingEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 14, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("callingEnd", 0), ("calledEnd", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciAccountingEnd.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciAccountingEnd.setDescription('This attribute indicates whether this DLCI represents the called or calling end of the connection. If the accountingEnabled attribute is no, then this attribute is not displayed.')
mscFrAtmDlciCorrelationTag = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 14, 1, 3), HexString().subtype(subtypeSpec=ValueSizeConstraint(0, 28)).clone(hexValue="")).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciCorrelationTag.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciCorrelationTag.setDescription('This attribute indicates the unique string which identifies this connection. The value of this operational attribute can be provisioned in the correlationTag attribute of either the Siwf Npvc, Siwf Spvc, or Niwf Spvc subcomponents. For the Siwf Spvc and Niwf Spvc cases, when the provisionable correlationTag is an empty string, then this attribute receives the value of a system- generated correlationTag. Downstream processing uses this attribute to correlate accounting records issued at different nodes in the network. If the accountingEnabled attribute is no, then this attribute is not displayed.')
mscFrAtmDlciIntTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 15), )
if mibBuilder.loadTexts: mscFrAtmDlciIntTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciIntTable.setDescription('This group contains the operational statistics for the FrAtm Dlci interval data.')
mscFrAtmDlciIntEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 15, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciIndex"))
if mibBuilder.loadTexts: mscFrAtmDlciIntEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciIntEntry.setDescription('An entry in the mscFrAtmDlciIntTable.')
mscFrAtmDlciStartTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 15, 1, 1), EnterpriseDateAndTime().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(19, 19), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciStartTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciStartTime.setDescription('This attribute indicates the start time of this interval. A new interval is started each time an accounting record is generated and call at a setup. If the accountingEnabled attribute is no, then this attribute is not displayed.')
mscFrAtmDlciTotalIngressBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 15, 1, 2), Unsigned64().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciTotalIngressBytes.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciTotalIngressBytes.setDescription('This attribute counts the total payload bytes in received from the link since the start of the interval. To calculate total valid payload bytes received from link, subtract discardedBytes from this attribute. The start of the interval is captured in the startTime attribute. The count is reset to zero when an accounting record is generated or at call setup. If the accountingEnabled attribute is no, then this attribute is not displayed.')
mscFrAtmDlciTotalEgressBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 15, 1, 3), Unsigned64().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciTotalEgressBytes.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciTotalEgressBytes.setDescription('This attribute counts the total payload bytes sent to the link since the start of the interval. The start of the interval is captured in the startTime attribute. The count is reset to zero when an accounting record is generated or at call setup. If the accountingEnabled attribute is no, then this attribute is not displayed.')
mscFrAtmDlciEirIngressBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 15, 1, 4), Unsigned64().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciEirIngressBytes.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciEirIngressBytes.setDescription('This attribute counts the total valid payload bytes in frames with the Discard Eligibility (DE) bit set to 1 received from the link since the start of the interval. Subtract this attribute and discardedBytes from totalIngressBytes to calculate total valid payload bytes in frames received from the link, with the DE bit set to 0. The start of the interval is captured in the startTime attribute. The count is reset to zero when an accounting record is generated or at call setup. If the accountingEnabled attribute is no, then this attribute is not displayed.')
mscFrAtmDlciEirEgressBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 15, 1, 5), Unsigned64().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciEirEgressBytes.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciEirEgressBytes.setDescription('This attribute counts the total valid payload bytes in frames with the Discard Eligibility (DE) bit set sent to the link since the start of the interval. Subtract the value of this attribute from totalEgressBytes to calculate total valid payload bytes in frames, with DE set to 0, sent to the link. The start of the interval is captured in the startTime attribute. The count is reset to zero when an accounting record is generated or at call setup. If the accountingEnabled attribute is no, then this attribute is not displayed.')
mscFrAtmDlciDiscardedBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 15, 1, 6), Unsigned64().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciDiscardedBytes.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciDiscardedBytes.setDescription('This attribute counts the total payload bytes in invalid frames received from the link and discarded at the DLCI since the start of the interval. This count is a sum of octets in frames discarded due to: frames too long or too short; A-Bit off; or to rate enforcement. The start of the interval is captured in the startTime attribute. The count is reset to zero when an accounting record is generated or at call setup. If the accountingEnabled attribute is no, then this attribute is not displayed.')
mscFrAtmDlciTotalIngressFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 15, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciTotalIngressFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciTotalIngressFrames.setDescription('This attribute counts the total number of frames received from the link since the start of the interval. To calculate the total valid number of frames received from the link, subtract discardedFrames from this attribute. The start of the interval is captured in the startTime attribute. The count is reset to zero when an accounting record is generated or at call setup. If the accountingEnabled attribute is no, then this attribute is not displayed.')
mscFrAtmDlciTotalEgressFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 15, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciTotalEgressFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciTotalEgressFrames.setDescription('This attribute counts the total number of frames sent to the link since the start of the interval. The start of the interval is captured in the startTime attribute. The count is reset to zero when an accounting record is generated or at call setup. If the accountingEnabled attribute is no, then this attribute is not displayed.')
mscFrAtmDlciEirIngressFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 15, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciEirIngressFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciEirIngressFrames.setDescription('This attribute counts the number of valid frames with the Discard Eligibility (DE) bit set to 1 received from the link since the start of the interval. Subtract this attribute and discardedFrames from totalIngressFrames to calculate total valid frames received from the link, with the DE bit set to 0. The start of the interval is captured in the startTime attribute. The count is reset to zero when an accounting record is generated or at call setup. If the accountingEnabled attribute is no, then this attribute is not displayed.')
mscFrAtmDlciEirEgressFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 15, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciEirEgressFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciEirEgressFrames.setDescription('This attribute counts the number of frames with the Discard Eligibility (DE) bit set sent to the link since the start of the interval. Subtract the value of this attribute from totalEgressFrames to calculate total frames, with DE set to 0, sent to the link.The start of the interval is captured in the startTime attribute. The count is reset to zero when an accounting record is generated call setup. If the accountingEnabled attribute is no, then this attribute is not displayed.')
mscFrAtmDlciDiscardedFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 15, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciDiscardedFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciDiscardedFrames.setDescription('This attribute counts the number of invalid frames received from the link and discarded at the DLCI. The count is reset to zero when an accounting record is generated or at call setup. The count is a sum of frames discarded due to: frames too long or too short; A-Bit is off; or rate enforcement. If the accountingEnabled attribute is no, then this attribute is not displayed.')
mscFrAtmDlciElapsedDifference = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 15, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciElapsedDifference.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciElapsedDifference.setDescription('This attribute indicates the elapsed time representing the of this interval data. It is the elapsed time in 0.1 second increments since the start of the interval. If the accountingEnabled attribute is no, then this attribute is not displayed.')
mscFrAtmDlciSp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 2))
mscFrAtmDlciSpRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 2, 1), )
if mibBuilder.loadTexts: mscFrAtmDlciSpRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSpRowStatusTable.setDescription('This entry controls the addition and deletion of mscFrAtmDlciSp components.')
mscFrAtmDlciSpRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciSpIndex"))
if mibBuilder.loadTexts: mscFrAtmDlciSpRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSpRowStatusEntry.setDescription('A single entry in the table represents a single mscFrAtmDlciSp component.')
mscFrAtmDlciSpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciSpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSpRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscFrAtmDlciSp components. These components cannot be added nor deleted.')
mscFrAtmDlciSpComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciSpComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSpComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscFrAtmDlciSpStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciSpStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSpStorageType.setDescription('This variable represents the storage type value for the mscFrAtmDlciSp tables.')
mscFrAtmDlciSpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscFrAtmDlciSpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSpIndex.setDescription('This variable represents the index for the mscFrAtmDlciSp tables.')
mscFrAtmDlciSpProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 2, 10), )
if mibBuilder.loadTexts: mscFrAtmDlciSpProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSpProvTable.setDescription('This group contains the provisionable attributes for the Data Link Connection Identifier. These attributes reflect the service parameters specific to this instance of DLCI. The congestion control attributes in this group are defined in T1.606 Addendum 1.')
mscFrAtmDlciSpProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciSpIndex"))
if mibBuilder.loadTexts: mscFrAtmDlciSpProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSpProvEntry.setDescription('An entry in the mscFrAtmDlciSpProvTable.')
mscFrAtmDlciSpMaximumFrameSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 2, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 8187)).clone(2100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmDlciSpMaximumFrameSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSpMaximumFrameSize.setDescription('This attribute specifies the maximum number of octets which may be included in the information field. The Frame Relay header and CRC octets are not included in this definition. This attribute corresponds to the dN1 parameter described in the Vendor Forum Specification.')
mscFrAtmDlciSpRateEnforcement = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('on')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmDlciSpRateEnforcement.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSpRateEnforcement.setDescription('This attribute specifies whether rate enforcement is in effect for this user data link connection. When rateEnforcement is on, the CIR and De=1 traffic will be measured and enforced. When rateEnforcement is off, all frames from the user are accepted and no modifications to the frame with respect to the De bit will be made.')
mscFrAtmDlciSpCommittedInformationRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 2, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 50000000)).clone(64000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmDlciSpCommittedInformationRate.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSpCommittedInformationRate.setDescription('This attribute specifies the committed information rate (CIR). It represents the rate at which the network agrees to transfer information under normal conditions when rate enforcement is in effect. When rate enforcement is not in effect, this attribute is ignored. Determination of the actual CIR is based on committedInformationRate, committedBurstSize and a measurement interval. The measurement interval is determined internally when committedInformationRate has a non-zero value. Otherwise, it is based on measurementInterval which must be explicitly provisioned. Note: The committedBurstSize must have a value of 0 when rate enforcement is in effect and committedInformationRate has a value of 0.')
mscFrAtmDlciSpCommittedBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 2, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 50000000)).clone(64000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmDlciSpCommittedBurstSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSpCommittedBurstSize.setDescription('This attribute specifies the committed burst size (Bc). It represents the amount of data that a network agrees to transfer under normal conditions over a measurement interval when rate enforcement is in effect. Data marked DE=1 is not accounted for in the committed burst size. When rate enforcement is not in effect, this attribute is ignored. Note: The committedInformationRate must have a value of 0 when rate enforcement is in effect and committedBurstSize has a value of 0.')
mscFrAtmDlciSpExcessBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 2, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 50000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmDlciSpExcessBurstSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSpExcessBurstSize.setDescription('This attribute specifies the excess burst size (Be). It represents the amount of uncommitted data that the network will attempt to deliver over a measurement interval when rate enforcement is in effect. Data marked DE=1 by the user or by the network is accounted for here. committedInformationRate, committedBurstSize, and excessBurstSize cannot all be zero when rate enforcement is in effect.')
mscFrAtmDlciSpMeasurementInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 2, 10, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 25500))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmDlciSpMeasurementInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSpMeasurementInterval.setDescription('This attribute specifies the time interval over which rates and burst sizes are measured when rate enforcement is in effect. When rate enforcement is in effect and both committedInformationRate and committedBurstSize have values of zero, this attribute must have a non-zero value. When rate enforcement is not in effect or when committedInformationRate and committedBurstSize have non-zero values, this attribute is ignored. When committedInformationRate and committedBurstSize have non-zero values, the time interval is internally calculated. In this situation, measurementInterval is ignored, and it does not represent the time interval.')
mscFrAtmDlciSpEmissionPriorityToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 2, 10, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 3))).clone(namedValues=NamedValues(("low", 0), ("high", 3))).clone('low')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmDlciSpEmissionPriorityToIf.setStatus('obsolete')
if mibBuilder.loadTexts: mscFrAtmDlciSpEmissionPriorityToIf.setDescription('This attribute specifies the emission priority of frames sent to the interface. The high priority frames in the high priority frame queue will be served before the low priority frames in the low priority queue. This attribute is obsoleted. During migration, its value will be transferred to emissionPriToIf.')
mscFrAtmDlciSpEmissionPrioToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 2, 10, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 1), ValueRangeConstraint(2, 2), ValueRangeConstraint(3, 3), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmDlciSpEmissionPrioToIf.setStatus('obsolete')
if mibBuilder.loadTexts: mscFrAtmDlciSpEmissionPrioToIf.setDescription('This attribute specifies the emission priority of frames sent to the interface. Frames in a higher priority queue will be sent before frames in a lower priority queue. The value of this attribute must be greater than or equal to 0, and less than the value of the provisionable attribute numberOfEmissionQs.')
mscFrAtmDlciSpAccounting = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 2, 10, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmDlciSpAccounting.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSpAccounting.setDescription('This attribute allows the operator to control accounting for this DLCI. To enable accounting data collection and record generation, the value of this attribute must be on and at least one of the accountCollection reasons in the FrAtm Ca component must be set.')
mscFrAtmDlciSiwf = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3))
mscFrAtmDlciSiwfRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 1), )
if mibBuilder.loadTexts: mscFrAtmDlciSiwfRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfRowStatusTable.setDescription('This entry controls the addition and deletion of mscFrAtmDlciSiwf components.')
mscFrAtmDlciSiwfRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciSiwfIndex"))
if mibBuilder.loadTexts: mscFrAtmDlciSiwfRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfRowStatusEntry.setDescription('A single entry in the table represents a single mscFrAtmDlciSiwf component.')
mscFrAtmDlciSiwfRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmDlciSiwfRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscFrAtmDlciSiwf components. These components can be added and deleted.')
mscFrAtmDlciSiwfComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciSiwfComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscFrAtmDlciSiwfStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciSiwfStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfStorageType.setDescription('This variable represents the storage type value for the mscFrAtmDlciSiwf tables.')
mscFrAtmDlciSiwfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscFrAtmDlciSiwfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfIndex.setDescription('This variable represents the index for the mscFrAtmDlciSiwf tables.')
mscFrAtmDlciSiwfConnOpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 11), )
if mibBuilder.loadTexts: mscFrAtmDlciSiwfConnOpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfConnOpTable.setDescription('This group contains operational attributes for the ATM connection.')
mscFrAtmDlciSiwfConnOpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciSiwfIndex"))
if mibBuilder.loadTexts: mscFrAtmDlciSiwfConnOpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfConnOpEntry.setDescription('An entry in the mscFrAtmDlciSiwfConnOpTable.')
mscFrAtmDlciSiwfDiscardPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("dp1", 1), ("dp2", 2), ("dp3", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciSiwfDiscardPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfDiscardPriority.setDescription('This attribute indicates the discard priority of frames sent to and received from the ATM connection. When discardPriority is dp3 the frames belonging to this connection will be discarded first when the FrAtm/n Dlci/n Siwf and the ATM End-Point experience congestion. When discardPriority is dp2 the frames belonging to this connection will be discarded after all the dp3 priority frames are discarded when the FrAtm/n Dlci/n Siwf and the ATM End-Point experience congestion. When discardPriority is dp1 the frames belonging to this connection will be discarded after all the dp2 and dp3 priority frames are discarded when the FrAtm/n Dlci/n Siwf and the ATM End-Point experience congestion.')
mscFrAtmDlciSiwfAtmServiceCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 11, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 5))).clone(namedValues=NamedValues(("ubr", 0), ("cbr", 1), ("rtVbr", 2), ("nrtVbr", 3), ("notApplicable", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciSiwfAtmServiceCategory.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfAtmServiceCategory.setDescription('This attribute indicates the ATM service category that is used for this connection. This attribute is only displayed for SPVCs.')
mscFrAtmDlciSiwfTrafficParmConvPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 11, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("notApplicable", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciSiwfTrafficParmConvPolicy.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfTrafficParmConvPolicy.setDescription('This attribute indicates the traffic parameter conversion policy that is being used for this connection. For Npvcs, this attribute is not displayed. Policy 3 characterizes the traffic in the following way: - ATM traffic descriptor type 6 is selected - ATM service category rtVbr and nrtVbr supported only - PCR0+1 is based on AR - SCR0+1 is based on CIR and EIR - MBS0+1 is based on Bc, Be, CIR, EIR and AR - Takes into account that the instantaneous rate of the frame relay stream can be above CIR and up to the AR. Policy 4 characterizes the traffic in the following way: - ATM traffic descriptor type 7 or 8 is selected. Type 7 is chosen when non-conforming cells are to be discarded and type 8 when non-conforming cells are tagged by UPC traffic policer. - PCR0+1 is based on AR - SCR0 is based on CIR - MBS0 is based on Bc, CIR, and AR - There is no direct characterization of EIR. The allowed EIR can be derived using the difference between the AR and CIR. Policy 5 characterizes the traffic in the following way: - ATM traffic descriptor type 7 or 8 is selected. Type 7 is chosen when non-conforming cells are to be discarded and type 8 when non-conforming cells are tagged by UPC traffic policer - ATM service category rtVbr and nrtVbr supported only - PCR0+1 is based on CIR and EIR - SCR0 is based on the CIR - MBS0 is based on the CIR - The maximum PCR is no longer based on the AR but rather on the CIR and EIR or CIR. Policy 6 characterizes the traffic in the following way: - ATM traffic descriptor type 3 is selected - ATM service category ubr, cbr, rtVbr and nrtVbr supported only - PCR0+1 is based only on CIR. DESCRIPTION')
mscFrAtmDlciSiwfAvgFrameSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 11, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8187))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciSiwfAvgFrameSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfAvgFrameSize.setDescription('This attribute indicates the average frame size that is used for this connection as part of the traffic parameter conversion policy. Average frame size is not applicable for Npvcs, and therefore it is not displayed.')
mscFrAtmDlciSiwfRemoteAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 11, 1, 8), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(1, 44))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciSiwfRemoteAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfRemoteAddress.setDescription('This attribute indicates the remote address (native E.164, native X.121 or NSAP) for this connection. This attribute is only displayed for SPVCs.')
mscFrAtmDlciSiwfRemoteConnectionIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 11, 1, 9), IntegerSequence().subtype(subtypeSpec=ValueSizeConstraint(3, 9))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciSiwfRemoteConnectionIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfRemoteConnectionIdentifier.setDescription("This attribute indicates the remote connection identifier. This identifier is either a remote Atm Vpi.Vci logical channel number or a remote Frame Relay Dlci logical channel number. The remote Atm Vpi.Vci logical channel number is displayed as 'Vpi.Vci'. and the remote Frame Relay Dlci logical channel number is displayed as '0.remoteDlci'. For NPVCs, this attribute is not displayed.")
mscFrAtmDlciSiwfSdOpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 12), )
if mibBuilder.loadTexts: mscFrAtmDlciSiwfSdOpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfSdOpTable.setDescription('This group contains operational information for a Siwf component.')
mscFrAtmDlciSiwfSdOpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciSiwfIndex"))
if mibBuilder.loadTexts: mscFrAtmDlciSiwfSdOpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfSdOpEntry.setDescription('An entry in the mscFrAtmDlciSiwfSdOpTable.')
mscFrAtmDlciSiwfMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("translationMode", 0), ("transparentMode", 1), ("speTranslationMode", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciSiwfMode.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfMode.setDescription('This attribute indicates the mode of interoperability between the Frame Relay and ATM connections regarding upper layer protocol encapsulations. A value of translationMode indicates that the interworking function performs translation between RFC 1490 and RFC 1483 encapsulated headers, including routed protocol translation, bridged protocol translation, and connection oriented protocol translation (except for RFC 1490 connection oriented protocol without RFC 1490 header, which is done in speTranslationMode). A value of transparentMode indicates that the interworking function forwards data without altering the upper layer user protocol encapsulation. Transparent mode is selected when the upper layer user protocol encapsulation methods are compatible between terminal equipments. A value of speTranslationMode indicates that the interworking function performs single protocol translation between RFC 1490 with no header and RFC 1483 encapsulated packets.')
mscFrAtmDlciSiwfDeToClpMapping = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("always0", 0), ("always1", 1), ("preserve", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciSiwfDeToClpMapping.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfDeToClpMapping.setDescription('This attribute indicates the type of DE to CLP mapping that is performed in the Frame Relay to ATM direction. A value of preserve indicates that the DE field in a Q.922 core frame is copied to the ATM CLP field of every cell containing the information of that frame. A value of always0 indicates that the CLP field of every generated ATM cell is always 0. A value of always1 indicates that the CLP field of every generated ATM cell is always1.')
mscFrAtmDlciSiwfClpToDeMapping = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("always0", 0), ("always1", 1), ("preserve", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciSiwfClpToDeMapping.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfClpToDeMapping.setDescription('This attribute indicates the type of CLP to DE mapping that is performed in the ATM to Frame Relay direction. A value of preserve indicates that the DE field of the Q.922 Core frame is set when one or more ATM cells belonging to an AAL5 frame have their CLP field set. A value of always0 indicates that the DE field of the Q.922 Core frame is always set to 0. A value of always1 indicates that the DE field of the Q.922 Core frame is always set to 1.')
mscFrAtmDlciSiwfFecnToEfciMapping = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 12, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2))).clone(namedValues=NamedValues(("always0", 0), ("preserve", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciSiwfFecnToEfciMapping.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfFecnToEfciMapping.setDescription('This attribute indicates the type of FECN to EFCI mapping that is performed in the Frame Relay to ATM direction. A value of preserve indicates that the FECN field in a Q.922 Core frame is copied directly to the ATM EFCI field of every cell. A value of always0 indicates that the EFCI field in every ATM cell generated is set to 0.')
mscFrAtmDlciSiwfCrToUuMapping = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 12, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2))).clone(namedValues=NamedValues(("always0", 0), ("preserve", 2))).clone('preserve')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciSiwfCrToUuMapping.setStatus('obsolete')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfCrToUuMapping.setDescription('This attribute indicates the type of CR to UU mapping that is performed in the Frame Relay to ATM direction. A value of preserve indicates that the CR field in the Q.922 Core frame is mapped directly to the ATM UU field of every cell generated by the AAL5 segmentation process. A value of always0 indicates that the UU field in every ATM cell generated is set to 0.')
mscFrAtmDlciSiwfTransferPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 12, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 253))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8), ("n9", 9), ("n10", 10), ("n11", 11), ("n12", 12), ("n13", 13), ("n14", 14), ("n15", 15), ("notApplicable", 253)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciSiwfTransferPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfTransferPriority.setDescription('This attribute indicates the transfer priority used to establish the connection. For Npvcs, the value is notApplicable.')
mscFrAtmDlciSiwfAssignedBandwidthPool = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 12, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8), ("n9", 9), ("n10", 10), ("n11", 11), ("n12", 12), ("n13", 13), ("n14", 14), ("n15", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciSiwfAssignedBandwidthPool.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfAssignedBandwidthPool.setDescription('This attribute specifies the bandwidth pool that this Dlci uses.')
mscFrAtmDlciSiwfSiwfSpvcOpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 13), )
if mibBuilder.loadTexts: mscFrAtmDlciSiwfSiwfSpvcOpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfSiwfSpvcOpTable.setDescription('This group contains operational attributes for the FrAtm Dlci Siwf Spvc connection.')
mscFrAtmDlciSiwfSiwfSpvcOpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciSiwfIndex"))
if mibBuilder.loadTexts: mscFrAtmDlciSiwfSiwfSpvcOpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfSiwfSpvcOpEntry.setDescription('An entry in the mscFrAtmDlciSiwfSiwfSpvcOpTable.')
mscFrAtmDlciSiwfPeakCellRate0 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 13, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciSiwfPeakCellRate0.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfPeakCellRate0.setDescription('This attribute indicates the Peak Cell Rate (PCR) of the ATM VCC to which this interworking function is linked for all cells (with CLP=0 and CLP=1). The pcr0 is derived from the remote end traffic parameters using the conversion policy of the transferPriorityMapping. For NPVCs, this attribute is not displayed.')
mscFrAtmDlciSiwfPeakCellRate01 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 13, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciSiwfPeakCellRate01.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfPeakCellRate01.setDescription('This attribute indicates the Peak Cell Rate (PCR) of the ATM VCC to which this interworking function is linked for all cells (with CLP=0 and CLP=1). The pcr01 is derived from the remote end traffic parameters using the conversion policy of the transferPriorityMapping. For NPVCs, this attribute is not displayed.')
mscFrAtmDlciSiwfSustainedCellRate0 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 13, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciSiwfSustainedCellRate0.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfSustainedCellRate0.setDescription('This attribute indicates the Sustained Cell Rate (SCR) of the ATM VCC to which this interworking function is linked for high priority cells (with CLP=0). The scr0 is derived from the remote end traffic parameters using the conversion policy of the transferPriorityMapping. For NPVCs, this attribute is not displayed.')
mscFrAtmDlciSiwfSustainedCellRate01 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 13, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciSiwfSustainedCellRate01.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfSustainedCellRate01.setDescription('This attribute indicates the Sustained Cell Rate (SCR) of the ATM VCC that to which this interworking function is linked for all cells (with CLP=0 and CLP=1). The scr01 is derived from the remote end traffic parameters using the conversion policy of the transferPriorityMapping. For NPVCs, this attribute is not displayed.')
mscFrAtmDlciSiwfMaximumBurstSize0 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 13, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciSiwfMaximumBurstSize0.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfMaximumBurstSize0.setDescription('This attribute indicates the Maximum Burst Size (MBS) of the ATM VCC to which this interworking function is linked for high priority cells (with CLP=0). The mbs0 is derived from the remote end traffic parameters using the conversion policy of the transferPriorityMapping. For NPVCs, this attribute is not displayed.')
mscFrAtmDlciSiwfMaximumBurstSize01 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 13, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciSiwfMaximumBurstSize01.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfMaximumBurstSize01.setDescription('This attribute indicates the Maximum Burst Size (MBS) of the ATM VCC to which this interworking function is linked for all cells (with CLP=0 and CLP=1). The mbs01 is derived from the remote end traffic parameters using the conversion policy of the transferPriorityMapping. For NPVCs, this attribute is not displayed.')
mscFrAtmDlciSiwfEquivalentBitRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 13, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciSiwfEquivalentBitRate.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfEquivalentBitRate.setDescription('This attribute indicates the access reserved bandwidth for this FR- ATM connection when CAC is on. If a connection is subcribed to CIR only or CIR plus EIR service, the EBR reserved is CIR. If a connection is subcribed to EIR only service, the EBR reserved is 0.')
mscFrAtmDlciSiwfType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 13, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("master", 0), ("slave", 1), ("notApplicable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciSiwfType.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfType.setDescription('This attribute indicates if the component provisioned is a calling or called end. If the value is master, the Dlci Siwf Spvc component is provisioned as a calling end and is responsible for originating the call to set up the ATM VCC. If the value is slave, this Dlci Siwf component is provisioned as a called end and is responsible for terminating call setup requests from the remote end. This attribute is not displayed for NPVCs.')
mscFrAtmDlciSiwfVccClearCause = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 13, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciSiwfVccClearCause.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfVccClearCause.setDescription('This attribute indicates the last received clear cause message from the network. This attribute is not displayed for NPVCs. Please refer to ATM User-Network Interface Specification for possible clear causes.')
mscFrAtmDlciSiwfVccCauseDiag = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 13, 1, 15), HexString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciSiwfVccCauseDiag.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfVccCauseDiag.setDescription('This attribute indicates the diagnostic value of the last release message received from the network. This attribute is not displayed for NPVCs. Please refer to ATM User-Network Interface Specification for possible diagnostic values.')
mscFrAtmDlciSiwfStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 14), )
if mibBuilder.loadTexts: mscFrAtmDlciSiwfStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfStatsTable.setDescription('This group contains statistics for the Siwf component.')
mscFrAtmDlciSiwfStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 14, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciSiwfIndex"))
if mibBuilder.loadTexts: mscFrAtmDlciSiwfStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfStatsEntry.setDescription('An entry in the mscFrAtmDlciSiwfStatsTable.')
mscFrAtmDlciSiwfUnknown1490Frames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 14, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciSiwfUnknown1490Frames.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfUnknown1490Frames.setDescription('This attribute counts the number of frames received from the interface that have a frame header that is not recognized by the RFC 1490. When the maximum count is reached, it wraps to zero.')
mscFrAtmDlciSiwfInvalid1490Frames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 14, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciSiwfInvalid1490Frames.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfInvalid1490Frames.setDescription('This attribute counts the number of frames received from the interface that have an invalid frame header. An invalid frame header occurs when the frame has less than the expected number of bytes. When the maximum count is reached, the count wraps to zero.')
mscFrAtmDlciSiwfLastUnknown1490ProtocolHeader = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 14, 1, 3), HexString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciSiwfLastUnknown1490ProtocolHeader.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfLastUnknown1490ProtocolHeader.setDescription('This attribute contains the most recent unrecognized protocol header that was received from the interface. All the RFC 1490 protocols described in sections 5.3.1.1 through 5.3.1.3 of FRF.8 are supported, except ARP is not supported.')
mscFrAtmDlciSiwfUnknown1483Frames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 14, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciSiwfUnknown1483Frames.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfUnknown1483Frames.setDescription('This attribute counts the number of frames received from the ATM connection that have a frame header that is not recognized by the RFC 1483. When the maximum count is reached, it wraps to zero.')
mscFrAtmDlciSiwfInvalid1483Frames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 14, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciSiwfInvalid1483Frames.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfInvalid1483Frames.setDescription('This attribute counts the number of frames received from the ATM connection that have an invalid frame header. An invalid frame header occurs when the frame has less than the expected number of bytes. When the maximum count is reached, it wraps to zero.')
mscFrAtmDlciSiwfLastUnknown1483ProtocolHeader = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 14, 1, 6), HexString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciSiwfLastUnknown1483ProtocolHeader.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfLastUnknown1483ProtocolHeader.setDescription('This attribute identifies the most recent unrecognized protocol header that was received from the ATM connection. All the RFC 1483 protocols described in sections 5.3.1.1 through 5.3.1.3 of FRF.8 are supported except ARP.')
mscFrAtmDlciSiwfSd = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 2))
mscFrAtmDlciSiwfSdRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 2, 1), )
if mibBuilder.loadTexts: mscFrAtmDlciSiwfSdRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfSdRowStatusTable.setDescription('This entry controls the addition and deletion of mscFrAtmDlciSiwfSd components.')
mscFrAtmDlciSiwfSdRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciSiwfIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciSiwfSdIndex"))
if mibBuilder.loadTexts: mscFrAtmDlciSiwfSdRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfSdRowStatusEntry.setDescription('A single entry in the table represents a single mscFrAtmDlciSiwfSd component.')
mscFrAtmDlciSiwfSdRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmDlciSiwfSdRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfSdRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscFrAtmDlciSiwfSd components. These components can be added and deleted.')
mscFrAtmDlciSiwfSdComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciSiwfSdComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfSdComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscFrAtmDlciSiwfSdStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciSiwfSdStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfSdStorageType.setDescription('This variable represents the storage type value for the mscFrAtmDlciSiwfSd tables.')
mscFrAtmDlciSiwfSdIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscFrAtmDlciSiwfSdIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfSdIndex.setDescription('This variable represents the index for the mscFrAtmDlciSiwfSd tables.')
mscFrAtmDlciSiwfSdProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 2, 10), )
if mibBuilder.loadTexts: mscFrAtmDlciSiwfSdProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfSdProvTable.setDescription('This group contains provisionable attributes for the parent Siwf component.')
mscFrAtmDlciSiwfSdProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciSiwfIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciSiwfSdIndex"))
if mibBuilder.loadTexts: mscFrAtmDlciSiwfSdProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfSdProvEntry.setDescription('An entry in the mscFrAtmDlciSiwfSdProvTable.')
mscFrAtmDlciSiwfSdMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 255))).clone(namedValues=NamedValues(("translationMode", 0), ("transparentMode", 1), ("speTranslationMode", 2), ("sameAsInterface", 255))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmDlciSiwfSdMode.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfSdMode.setDescription('This attribute specifies the mode of interoperability between the Frame Relay and ATM connections regarding upper layer protocol encapsulations. When translationMode is selected, the interworking function performs translations between RFC 1490 and RFC 1483 encapsulated headers, including routed protocol translation, bridged protocol translation, and connection oriented protocol translation (except for RFC 1490 connection oriented protocol without RFC 1490 header, which is done in speTranslationMode). A value of transparentMode indicates that the interworking function forwards data without altering the upper layer user protocol encapsulation. Transparent mode is selected when the upper layer user protocol encapsulation methods are compatible between terminal equipments. A value of speTranslationMode indicates that the interworking function performs single protocol translation between RFC 1490 with no header and RFC 1483 encapsulated packets. The default value is sameAsInterface, which means as defined in FrAtm/n Ca sdMode.')
mscFrAtmDlciSiwfSdDeToClpMapping = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 255))).clone(namedValues=NamedValues(("always0", 0), ("always1", 1), ("preserve", 2), ("sameAsInterface", 255))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmDlciSiwfSdDeToClpMapping.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfSdDeToClpMapping.setDescription('This attribute specifies the DE to CLP mapping that is performed in the Frame Relay to ATM direction. When preserve is selected, the DE field in the Q.922 core frame is mapped to the ATM CLP field of every cell generated by the segmentation process of the AAL5 PDU containing the information of that frame. When always0 is selected, the CLP field of every ATM cell generated by the segmentation process of the AAL5 PDU containing the information of that frame is always set to 0. When always1 is selected, the CLP field of every ATM cell generated by the segmentation process of the AAL5 PDU containing the information of that frame is always set to 1.')
mscFrAtmDlciSiwfSdClpToDeMapping = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 255))).clone(namedValues=NamedValues(("always0", 0), ("always1", 1), ("preserve", 2), ("sameAsInterface", 255))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmDlciSiwfSdClpToDeMapping.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfSdClpToDeMapping.setDescription('This attribute specifies the type of CLP to DE mapping that is performed in the ATM to Frame Relay to direction. When preserve is selected, the DE field of the Q.922 Core frame is set when one or more ATM cells belonging to an AAL5 frame have their CLP field set. When always0 is selected, the DE field of the Q.922 Core frame is always set to 0. When always1 is selected, the DE field of the Q.922 Core frame is always set to 1.')
mscFrAtmDlciSiwfSdFecnToEfciMapping = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 2, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2, 255))).clone(namedValues=NamedValues(("always0", 0), ("preserve", 2), ("sameAsInterface", 255))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmDlciSiwfSdFecnToEfciMapping.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfSdFecnToEfciMapping.setDescription('This attribute specifies the type of FECN to EFCI mapping that is performed in the Frame Relay to ATM direction. When preserve is selected, the FECN field in the Q.922 Core frame is mapped directly to the ATM EFCI field of every cell generated by the AAL5 segmentation process. When always0 is selected, the EFCI field in every ATM cell generated is set to 0.')
mscFrAtmDlciSiwfSdCrToUuMapping = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 2, 10, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2, 255))).clone(namedValues=NamedValues(("always0", 0), ("preserve", 2), ("sameAsInterface", 255))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmDlciSiwfSdCrToUuMapping.setStatus('obsolete')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfSdCrToUuMapping.setDescription('This attribute indicates the type of CR to UU mapping that is performed in the Frame Relay to ATM direction. A value of preserve indicates that the CR field in the Q.922 Core frame is mapped directly to the ATM UU field of every cell generated by the AAL5 segmentation process. A value of always0 indicates that the UU field in every ATM cell generated is set to 0.')
mscFrAtmDlciSiwfNPvc = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 3))
mscFrAtmDlciSiwfNPvcRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 3, 1), )
if mibBuilder.loadTexts: mscFrAtmDlciSiwfNPvcRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfNPvcRowStatusTable.setDescription('This entry controls the addition and deletion of mscFrAtmDlciSiwfNPvc components.')
mscFrAtmDlciSiwfNPvcRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 3, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciSiwfIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciSiwfNPvcIndex"))
if mibBuilder.loadTexts: mscFrAtmDlciSiwfNPvcRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfNPvcRowStatusEntry.setDescription('A single entry in the table represents a single mscFrAtmDlciSiwfNPvc component.')
mscFrAtmDlciSiwfNPvcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmDlciSiwfNPvcRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfNPvcRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscFrAtmDlciSiwfNPvc components. These components can be added and deleted.')
mscFrAtmDlciSiwfNPvcComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciSiwfNPvcComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfNPvcComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscFrAtmDlciSiwfNPvcStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciSiwfNPvcStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfNPvcStorageType.setDescription('This variable represents the storage type value for the mscFrAtmDlciSiwfNPvc tables.')
mscFrAtmDlciSiwfNPvcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscFrAtmDlciSiwfNPvcIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfNPvcIndex.setDescription('This variable represents the index for the mscFrAtmDlciSiwfNPvc tables.')
mscFrAtmDlciSiwfNPvcProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 3, 10), )
if mibBuilder.loadTexts: mscFrAtmDlciSiwfNPvcProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfNPvcProvTable.setDescription('This group contains provisionable attributes for the NPvc component.')
mscFrAtmDlciSiwfNPvcProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 3, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciSiwfIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciSiwfNPvcIndex"))
if mibBuilder.loadTexts: mscFrAtmDlciSiwfNPvcProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfNPvcProvEntry.setDescription('An entry in the mscFrAtmDlciSiwfNPvcProvTable.')
mscFrAtmDlciSiwfNPvcAtmConnection = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 3, 10, 1, 1), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmDlciSiwfNPvcAtmConnection.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfNPvcAtmConnection.setDescription('This attribute specifies the ATM connection to which the interworking function is linked. The ATM connection must be linked to an ATM end-point. For example AtmIf/m Vcc/m Nep.')
mscFrAtmDlciSiwfNPvcCorrelationTag = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 3, 10, 1, 3), HexString().subtype(subtypeSpec=ValueSizeConstraint(0, 28)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmDlciSiwfNPvcCorrelationTag.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfNPvcCorrelationTag.setDescription('This attribute specifies a unique string, set by the operator, which identifies the call for accounting purposes. Downstream processing uses this attribute to correlate accounting records issued at different nodes in the network. Normally, this value is provisioned with the same value at each end of the connection. If the value of accountingEnabled is no, this attribute has no effect. This attribute is also visible in the FrAtm Dlci component when accounting is enabled.')
mscFrAtmDlciSiwfNPvcSiwfNpvcOpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 3, 11), )
if mibBuilder.loadTexts: mscFrAtmDlciSiwfNPvcSiwfNpvcOpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfNPvcSiwfNpvcOpTable.setDescription('This group contains the operational attributes for the FrAtm Dlci Siwf Npvc connection.')
mscFrAtmDlciSiwfNPvcSiwfNpvcOpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 3, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciSiwfIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciSiwfNPvcIndex"))
if mibBuilder.loadTexts: mscFrAtmDlciSiwfNPvcSiwfNpvcOpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfNPvcSiwfNpvcOpEntry.setDescription('An entry in the mscFrAtmDlciSiwfNPvcSiwfNpvcOpTable.')
mscFrAtmDlciSiwfNPvcConnectionToAtm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 3, 11, 1, 1), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciSiwfNPvcConnectionToAtm.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfNPvcConnectionToAtm.setDescription('This attribute indicates the ATM connection to which the interworking function is linked.')
mscFrAtmDlciSiwfSPvc = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 4))
mscFrAtmDlciSiwfSPvcRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 4, 1), )
if mibBuilder.loadTexts: mscFrAtmDlciSiwfSPvcRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfSPvcRowStatusTable.setDescription('This entry controls the addition and deletion of mscFrAtmDlciSiwfSPvc components.')
mscFrAtmDlciSiwfSPvcRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 4, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciSiwfIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciSiwfSPvcIndex"))
if mibBuilder.loadTexts: mscFrAtmDlciSiwfSPvcRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfSPvcRowStatusEntry.setDescription('A single entry in the table represents a single mscFrAtmDlciSiwfSPvc component.')
mscFrAtmDlciSiwfSPvcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 4, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmDlciSiwfSPvcRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfSPvcRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscFrAtmDlciSiwfSPvc components. These components can be added and deleted.')
mscFrAtmDlciSiwfSPvcComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciSiwfSPvcComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfSPvcComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscFrAtmDlciSiwfSPvcStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciSiwfSPvcStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfSPvcStorageType.setDescription('This variable represents the storage type value for the mscFrAtmDlciSiwfSPvc tables.')
mscFrAtmDlciSiwfSPvcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 4, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscFrAtmDlciSiwfSPvcIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfSPvcIndex.setDescription('This variable represents the index for the mscFrAtmDlciSiwfSPvc tables.')
mscFrAtmDlciSiwfSPvcProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 4, 10), )
if mibBuilder.loadTexts: mscFrAtmDlciSiwfSPvcProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfSPvcProvTable.setDescription('This group contains provisionable attributes for the soft PVC component.')
mscFrAtmDlciSiwfSPvcProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 4, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciSiwfIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciSiwfSPvcIndex"))
if mibBuilder.loadTexts: mscFrAtmDlciSiwfSPvcProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfSPvcProvEntry.setDescription('An entry in the mscFrAtmDlciSiwfSPvcProvTable.')
mscFrAtmDlciSiwfSPvcRemoteAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 4, 10, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(1, 44))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmDlciSiwfSPvcRemoteAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfSPvcRemoteAddress.setDescription("This attribute specifies the remote address of the SPVC. It is represented as a prefix NPI string and a sequence of up to 15 digits to specify either a native (E.164 or X.121) address format or Atm End System Address(AESA) in ISO NSAP format. For example: native E.164 = 'e.upto15digits' native X.121 = 'x.upto14digits' NSAP address = '40 hexadecimal digits'")
mscFrAtmDlciSiwfSPvcRemoteConnectionIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 4, 10, 1, 3), IntegerSequence().subtype(subtypeSpec=ValueSizeConstraint(3, 9))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmDlciSiwfSPvcRemoteConnectionIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfSPvcRemoteConnectionIdentifier.setDescription("This attribute specifies the remote connection identifier. The identifier is either a remote Atm Vpi.Vci logical channel number assignment or a remote Frame Relay Dlci logical channel number assignment. The remote Atm Vpi.Vci logical channel number is input as 'Vpi.Vci' and the remote Frame Relay Dlci logical channel number is input as '0.remoteDlci'.")
mscFrAtmDlciSiwfSPvcCorrelationTag = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 4, 10, 1, 4), HexString().subtype(subtypeSpec=ValueSizeConstraint(0, 28)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmDlciSiwfSPvcCorrelationTag.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfSPvcCorrelationTag.setDescription('This attribute specifies the unique string, set by the operator, which identifies the call for accounting purposes. Downstream processing uses this attribute to correlate accounting records issued at different nodes in the network. If the value of accountingEnabled is no, this attribute has no effect. This attribute is also visible in the FrAtm Dlci component when accounting is enabled. When this attribute is an empty string, the operational correlationTag attribute in the FrAtm Dlci component receives the value of a system-generated correlationTag.')
mscFrAtmDlciSiwfQoS = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 5))
mscFrAtmDlciSiwfQoSRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 5, 1), )
if mibBuilder.loadTexts: mscFrAtmDlciSiwfQoSRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfQoSRowStatusTable.setDescription('This entry controls the addition and deletion of mscFrAtmDlciSiwfQoS components.')
mscFrAtmDlciSiwfQoSRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 5, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciSiwfIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciSiwfQoSIndex"))
if mibBuilder.loadTexts: mscFrAtmDlciSiwfQoSRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfQoSRowStatusEntry.setDescription('A single entry in the table represents a single mscFrAtmDlciSiwfQoS component.')
mscFrAtmDlciSiwfQoSRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 5, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmDlciSiwfQoSRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfQoSRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscFrAtmDlciSiwfQoS components. These components can be added and deleted.')
mscFrAtmDlciSiwfQoSComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciSiwfQoSComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfQoSComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscFrAtmDlciSiwfQoSStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciSiwfQoSStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfQoSStorageType.setDescription('This variable represents the storage type value for the mscFrAtmDlciSiwfQoS tables.')
mscFrAtmDlciSiwfQoSIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 5, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscFrAtmDlciSiwfQoSIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfQoSIndex.setDescription('This variable represents the index for the mscFrAtmDlciSiwfQoS tables.')
mscFrAtmDlciSiwfQoSProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 5, 10), )
if mibBuilder.loadTexts: mscFrAtmDlciSiwfQoSProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfQoSProvTable.setDescription('This group contains the provisionable quality of service attributes for the Qos component.')
mscFrAtmDlciSiwfQoSProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 5, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciSiwfIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciSiwfQoSIndex"))
if mibBuilder.loadTexts: mscFrAtmDlciSiwfQoSProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfQoSProvEntry.setDescription('An entry in the mscFrAtmDlciSiwfQoSProvTable.')
mscFrAtmDlciSiwfQoSEmissionPriorityToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 5, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 254, 255))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("deriveFromTp", 254), ("sameAsInterface", 255))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmDlciSiwfQoSEmissionPriorityToIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfQoSEmissionPriorityToIf.setDescription('This attribute specifies the emission priority of frames sent to the FrAtm interface. Frames in a higher priority queue, represented by a numerically higher number, will be sent before frames in a lower priority queue. The value of this attribute is interpreted according to the value of the provisionable attribute numberOfEmissionQs under the parent FrAtm component. If the numberOfEmissionQs attribute is set to 2, emissionPriorityToIf value of 0 maps to emission priority queue 0 representing a lower priority queue, and emissionPriorityToIf values of 1, 2, and 3 are mapped to emission priority queue 1 representing the highest priority queue. If the numberOfEmissionQs is set to 4, the emissionPriorityToIf values are directly assigned to the emission priority queues. A value of deriveFromTp specifies that the emission priority is to be extracted from the Mod Frs AtmNet Tpm/n component using the transferPriority attribute. A value of sameAsInterface specifies that the emission priority is to be extracted from the FrAtm Ca component using the niwfEmissionPriorityToIf attribute.')
mscFrAtmDlciSiwfQoSTransferPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 5, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 255))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8), ("n9", 9), ("n10", 10), ("n11", 11), ("n12", 12), ("n13", 13), ("n14", 14), ("n15", 15), ("sameAsInterface", 255))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmDlciSiwfQoSTransferPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfQoSTransferPriority.setDescription('This attribute specifies the transfer priority of frames sent to the ATM connection using this particular Dlci. In the Frame Relay to ATM direction, the tp selects the ATM service category of the connection. In the ATM to Frame Relay direction, the tp selects the FrAtm emission priority queue. A value of sameAsInterface specifies that the emission priority extracts from the FrAtm Ca component using the siwfTransferPriority attribute. DESCRIPTION')
mscFrAtmDlciSiwfAtmCon = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 6))
mscFrAtmDlciSiwfAtmConRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 6, 1), )
if mibBuilder.loadTexts: mscFrAtmDlciSiwfAtmConRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfAtmConRowStatusTable.setDescription('This entry controls the addition and deletion of mscFrAtmDlciSiwfAtmCon components.')
mscFrAtmDlciSiwfAtmConRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 6, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciSiwfIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciSiwfAtmConIndex"))
if mibBuilder.loadTexts: mscFrAtmDlciSiwfAtmConRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfAtmConRowStatusEntry.setDescription('A single entry in the table represents a single mscFrAtmDlciSiwfAtmCon component.')
mscFrAtmDlciSiwfAtmConRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 6, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciSiwfAtmConRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfAtmConRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscFrAtmDlciSiwfAtmCon components. These components cannot be added nor deleted.')
mscFrAtmDlciSiwfAtmConComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 6, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciSiwfAtmConComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfAtmConComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscFrAtmDlciSiwfAtmConStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 6, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciSiwfAtmConStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfAtmConStorageType.setDescription('This variable represents the storage type value for the mscFrAtmDlciSiwfAtmCon tables.')
mscFrAtmDlciSiwfAtmConIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 6, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscFrAtmDlciSiwfAtmConIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfAtmConIndex.setDescription('This variable represents the index for the mscFrAtmDlciSiwfAtmCon tables.')
mscFrAtmDlciSiwfAtmConOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 6, 10), )
if mibBuilder.loadTexts: mscFrAtmDlciSiwfAtmConOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfAtmConOperTable.setDescription('This attribute group contains the operational attributes for the NapAtmConnection component.')
mscFrAtmDlciSiwfAtmConOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 6, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciSiwfIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciSiwfAtmConIndex"))
if mibBuilder.loadTexts: mscFrAtmDlciSiwfAtmConOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfAtmConOperEntry.setDescription('An entry in the mscFrAtmDlciSiwfAtmConOperTable.')
mscFrAtmDlciSiwfAtmConNextHop = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 3, 6, 10, 1, 1), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciSiwfAtmConNextHop.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciSiwfAtmConNextHop.setDescription('This attribute shows the component name of the AtmIf Vcc Ep or AtmCon component to which this switched connection is established.')
mscFrAtmDlciNiwf = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 4))
mscFrAtmDlciNiwfRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 4, 1), )
if mibBuilder.loadTexts: mscFrAtmDlciNiwfRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciNiwfRowStatusTable.setDescription('This entry controls the addition and deletion of mscFrAtmDlciNiwf components.')
mscFrAtmDlciNiwfRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 4, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciNiwfIndex"))
if mibBuilder.loadTexts: mscFrAtmDlciNiwfRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciNiwfRowStatusEntry.setDescription('A single entry in the table represents a single mscFrAtmDlciNiwf component.')
mscFrAtmDlciNiwfRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 4, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmDlciNiwfRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciNiwfRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscFrAtmDlciNiwf components. These components can be added and deleted.')
mscFrAtmDlciNiwfComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciNiwfComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciNiwfComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscFrAtmDlciNiwfStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciNiwfStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciNiwfStorageType.setDescription('This variable represents the storage type value for the mscFrAtmDlciNiwf tables.')
mscFrAtmDlciNiwfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 4, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscFrAtmDlciNiwfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciNiwfIndex.setDescription('This variable represents the index for the mscFrAtmDlciNiwf tables.')
mscFrAtmDlciNiwfOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 4, 10), )
if mibBuilder.loadTexts: mscFrAtmDlciNiwfOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciNiwfOperTable.setDescription('This group contains operational networking description information for a Niwf component.')
mscFrAtmDlciNiwfOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 4, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciNiwfIndex"))
if mibBuilder.loadTexts: mscFrAtmDlciNiwfOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciNiwfOperEntry.setDescription('An entry in the mscFrAtmDlciNiwfOperTable.')
mscFrAtmDlciNiwfDeToClpMapping = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 4, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("always0", 0), ("always1", 1), ("preserve", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciNiwfDeToClpMapping.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciNiwfDeToClpMapping.setDescription('This attribute indicates the type of DE to CLP mapping that is performed in the Frame Relay to ATM direction. A value of preserve indicates that the DE field in the Q.922 core frame copies to the CLP field of every ATM cell containing the frame. A value of always0 indicates that the CLP field of every ATM cell is always set to 0. A value of always1 indicates that the CLP field of every ATM cell is always set to 1.')
mscFrAtmDlciNiwfClpToDeMapping = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 4, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("preserve", 2), ("transparent", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciNiwfClpToDeMapping.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciNiwfClpToDeMapping.setDescription('This attribute indicates the type of CLP to DE mapping that is performed in the ATM to Frame Relay direction. A value of preserve indicates that the DE field of the Q.922 core frame is set when one or more ATM cells belonging to the frame has its CLP field set, or when the DE field of the FR-SSCS PDU is set. A value of transparent indicates that the DE field of the Q.922 core frame copies directly from the DE field of the FR-SSCS PDU.')
mscFrAtmDlciNiwfTransferPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 4, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciNiwfTransferPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciNiwfTransferPriority.setDescription('This attribute indicates the transfer priority in use for a specific connection. This is the transfer priority that the local Frame Relay network uses for this connection to an ATM network. In the Frame Relay to ATM direction, the tp selects the FRF.5 End Point which multiplexes the frames. In the ATM to Frame Relay direction, the tp selects the default FrAtm emission priority queue to be used by this Dlci.')
mscFrAtmDlciNiwfAtmServiceCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 4, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 255))).clone(namedValues=NamedValues(("ubr", 0), ("cbr", 1), ("rtVbr", 2), ("nrtVbr", 3), ("scNotAvailable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciNiwfAtmServiceCategory.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciNiwfAtmServiceCategory.setDescription('This attribute indicates the ATM service category that was mapped for this connection. A value of scNotAvailable indicates that atmServiceCategory is not yet available for this connection.')
mscFrAtmDlciNiwfTrafficParmConvPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 4, 10, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 3, 4, 5, 6))).clone(namedValues=NamedValues(("policyNotAvailable", 0), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciNiwfTrafficParmConvPolicy.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciNiwfTrafficParmConvPolicy.setDescription('This attribute indicates the traffic parameter conversion policy that is used for this connection. Policy 3 characterizes the traffic in the following way: - ATM traffic descriptor type 6 is selected. - PCR(0+1) is based on the ATM link rate. - SCR(0+1) is based on the CIR and EIR. - MB(0+1) is based on Bc, Be, CIR, EIR and AR. - Takes into account that the instantaneous rate of the frame relay stream can be above CIR and up to the AR. Policy 4 characterizes the traffic in the following way: - ATM traffic descriptor type 7 or 8 is selected. Type 7 is chosen when non-conforming cells are to be discarded and type 8 when non-conforming cells are tagged by UPC traffic policer. - PCR(0+1) is based on AR. - SCR(0) is based on the CIR. - MBS(0) is based on Bc, CIR, and AR. - There is no direct characterization of EIR. The allowed EIR can be derived using the difference between the AR and CIR. Policy 5 characterizes the traffic in the following way: - ATM traffic descriptor type 7 or 8 is selected. Type 7 is chosen when non-conforming cells are to be discarded and type 8 when non-conforming cells are tagged by UPC traffic policer. - PCR(0+1) is based on the CIR and EIR. - SCR(0) is based on the CIR. - MBS(0) is based on the CIR. - The maximum PCR is no longer based on the AR but rather on the CIR and EIR. Policy 6 characterizes the traffic in the following way: - ATM traffic descriptor type 3 is selected. - PCR(0+1) is based only on the CIR policyNotAvailable indicates that the trafficParmConvPolicy is not yet available for this connection.')
mscFrAtmDlciNiwfAvgFrameSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 4, 10, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8187))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciNiwfAvgFrameSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciNiwfAvgFrameSize.setDescription('This attribute indicates the average frame size that was used for this connection as part of the traffic parameter conversion policy. A value of zero indicates that the avgFrameSize is not yet available for this connection.')
mscFrAtmDlciNiwfEquivalentBitRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 4, 10, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciNiwfEquivalentBitRate.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciNiwfEquivalentBitRate.setDescription('This attribute indicates the access reserved bandwidth for this FR- ATM connection when CAC is on. If a connection is subcribed to CIR only or CIR plus EIR service, the EBR reserved is CIR. If a connection is subcribed to EIR only service, the EBR reserved is 0.')
mscFrAtmDlciNiwfAtmDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 4, 10, 1, 8), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciNiwfAtmDlci.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciNiwfAtmDlci.setDescription('This attribute displays the DLCI logical channel used inside the ATM VCC. A null value indicates that the atmDlci is not yet available for this connection.')
mscFrAtmDlciNiwfAssignedBandwidthPool = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 4, 10, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8), ("n9", 9), ("n10", 10), ("n11", 11), ("n12", 12), ("n13", 13), ("n14", 14), ("n15", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciNiwfAssignedBandwidthPool.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciNiwfAssignedBandwidthPool.setDescription('This attribute specifies the bandwidth pool which is used by this Dlci.')
mscFrAtmDlciNiwfSpvc = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 4, 2))
mscFrAtmDlciNiwfSpvcRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 4, 2, 1), )
if mibBuilder.loadTexts: mscFrAtmDlciNiwfSpvcRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciNiwfSpvcRowStatusTable.setDescription('This entry controls the addition and deletion of mscFrAtmDlciNiwfSpvc components.')
mscFrAtmDlciNiwfSpvcRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 4, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciNiwfIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciNiwfSpvcIndex"))
if mibBuilder.loadTexts: mscFrAtmDlciNiwfSpvcRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciNiwfSpvcRowStatusEntry.setDescription('A single entry in the table represents a single mscFrAtmDlciNiwfSpvc component.')
mscFrAtmDlciNiwfSpvcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 4, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciNiwfSpvcRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciNiwfSpvcRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscFrAtmDlciNiwfSpvc components. These components cannot be added nor deleted.')
mscFrAtmDlciNiwfSpvcComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 4, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciNiwfSpvcComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciNiwfSpvcComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscFrAtmDlciNiwfSpvcStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 4, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciNiwfSpvcStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciNiwfSpvcStorageType.setDescription('This variable represents the storage type value for the mscFrAtmDlciNiwfSpvc tables.')
mscFrAtmDlciNiwfSpvcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 4, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscFrAtmDlciNiwfSpvcIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciNiwfSpvcIndex.setDescription('This variable represents the index for the mscFrAtmDlciNiwfSpvc tables.')
mscFrAtmDlciNiwfSpvcProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 4, 2, 10), )
if mibBuilder.loadTexts: mscFrAtmDlciNiwfSpvcProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciNiwfSpvcProvTable.setDescription('This group contains the provisionable attributes for the soft PVC component.')
mscFrAtmDlciNiwfSpvcProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 4, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciNiwfIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciNiwfSpvcIndex"))
if mibBuilder.loadTexts: mscFrAtmDlciNiwfSpvcProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciNiwfSpvcProvEntry.setDescription('An entry in the mscFrAtmDlciNiwfSpvcProvTable.')
mscFrAtmDlciNiwfSpvcRemoteAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 4, 2, 10, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(3, 17))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmDlciNiwfSpvcRemoteAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciNiwfSpvcRemoteAddress.setDescription("This attribute specifies the remote address of the SPVC. It is represented as a prefix NPI string and a sequence of up to 15 digits to specify either a native E.164 or native X.121 address format. For example, native E.164 = 'e.upto15digits'.")
mscFrAtmDlciNiwfSpvcRemoteDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 4, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(16, 1007), ValueRangeConstraint(1022, 1022), )).clone(1022)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmDlciNiwfSpvcRemoteDlci.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciNiwfSpvcRemoteDlci.setDescription('This attribute specifies the remote connection identifier. This identifier is the DLCI logical channel number assignment used inside the ATM pipe.')
mscFrAtmDlciNiwfSpvcCorrelationTag = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 4, 2, 10, 1, 3), HexString().subtype(subtypeSpec=ValueSizeConstraint(0, 28)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmDlciNiwfSpvcCorrelationTag.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciNiwfSpvcCorrelationTag.setDescription('This attribute specifies aunique string, set by the operator, which identifies the call for accounting purposes. Downstream processing uses this attribute to correlate accounting records issued at different nodes in the network. Normally, the attribute is provisioned with the same value at both ends of the connection. If the value of accountingEnabled is no, this attribute has no effect. This attribute is also visible in the FrAtm Dlci component when accounting is enabled. When this attribute is an empty string, the operational correlationTag attribute in the FrAtm Dlci component receives the value of a system-generated correlationTag.')
mscFrAtmDlciNiwfNd = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 4, 3))
mscFrAtmDlciNiwfNdRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 4, 3, 1), )
if mibBuilder.loadTexts: mscFrAtmDlciNiwfNdRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciNiwfNdRowStatusTable.setDescription('This entry controls the addition and deletion of mscFrAtmDlciNiwfNd components.')
mscFrAtmDlciNiwfNdRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 4, 3, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciNiwfIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciNiwfNdIndex"))
if mibBuilder.loadTexts: mscFrAtmDlciNiwfNdRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciNiwfNdRowStatusEntry.setDescription('A single entry in the table represents a single mscFrAtmDlciNiwfNd component.')
mscFrAtmDlciNiwfNdRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 4, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmDlciNiwfNdRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciNiwfNdRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscFrAtmDlciNiwfNd components. These components can be added and deleted.')
mscFrAtmDlciNiwfNdComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 4, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciNiwfNdComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciNiwfNdComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscFrAtmDlciNiwfNdStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 4, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciNiwfNdStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciNiwfNdStorageType.setDescription('This variable represents the storage type value for the mscFrAtmDlciNiwfNd tables.')
mscFrAtmDlciNiwfNdIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 4, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscFrAtmDlciNiwfNdIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciNiwfNdIndex.setDescription('This variable represents the index for the mscFrAtmDlciNiwfNd tables.')
mscFrAtmDlciNiwfNdProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 4, 3, 10), )
if mibBuilder.loadTexts: mscFrAtmDlciNiwfNdProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciNiwfNdProvTable.setDescription('This group contains provisionable attributes for the parent Niwf component.')
mscFrAtmDlciNiwfNdProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 4, 3, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciNiwfIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciNiwfNdIndex"))
if mibBuilder.loadTexts: mscFrAtmDlciNiwfNdProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciNiwfNdProvEntry.setDescription('An entry in the mscFrAtmDlciNiwfNdProvTable.')
mscFrAtmDlciNiwfNdDeToClpMapping = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 4, 3, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 255))).clone(namedValues=NamedValues(("always0", 0), ("always1", 1), ("preserve", 2), ("sameAsInterface", 255))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmDlciNiwfNdDeToClpMapping.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciNiwfNdDeToClpMapping.setDescription('This attribute specifies the type of DE to CLP mapping performs in the Frame Relay to ATM direction. When preserve is selected, the DE field in the Q.922 core frame copies to the CLP field of every ATM cell containing the frame. When always0 is selected, the CLP field of every ATM cell is always set to 0. When always1 is selected, the CLP field of every ATM cell is always set to 1.')
mscFrAtmDlciNiwfNdClpToDeMapping = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 4, 3, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 255))).clone(namedValues=NamedValues(("preserve", 2), ("transparent", 3), ("sameAsInterface", 255))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmDlciNiwfNdClpToDeMapping.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciNiwfNdClpToDeMapping.setDescription('This attribute specifies the type of CLP to DE mapping performs in the ATM to Frame Relay direction. When preserve is selected, the DE field of the Q.922 core frame is set when one or more ATM cells belonging the frame has its CLP field set, or when the DE field of the FR-SSCS PDU is set. When transparent is selected, the DE field of the Q.922 core frame copies directly from the DE field of the FR-SSCS PDU.')
mscFrAtmDlciNiwfNdTransferPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 4, 3, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 255))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8), ("n9", 9), ("n10", 10), ("n11", 11), ("n12", 12), ("n13", 13), ("n14", 14), ("n15", 15), ("sameAsInterface", 255))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmDlciNiwfNdTransferPriority.setStatus('obsolete')
if mibBuilder.loadTexts: mscFrAtmDlciNiwfNdTransferPriority.setDescription('This attribute specifies the transfer priority of frames sent to and received from the ATM connection. In the Frame Relay to ATM direction, the tp selects the FRF.5 End Point which multiplexes the frames. In the ATM to Frame Relay direction, the tp is applied to frames on a per-DLCI basis. This attribute is obsoleted. During migration, its value will be transfered to the QualityOfService transferPriority.')
mscFrAtmDlciNiwfQoS = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 4, 4))
mscFrAtmDlciNiwfQoSRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 4, 4, 1), )
if mibBuilder.loadTexts: mscFrAtmDlciNiwfQoSRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciNiwfQoSRowStatusTable.setDescription('This entry controls the addition and deletion of mscFrAtmDlciNiwfQoS components.')
mscFrAtmDlciNiwfQoSRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 4, 4, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciNiwfIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciNiwfQoSIndex"))
if mibBuilder.loadTexts: mscFrAtmDlciNiwfQoSRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciNiwfQoSRowStatusEntry.setDescription('A single entry in the table represents a single mscFrAtmDlciNiwfQoS component.')
mscFrAtmDlciNiwfQoSRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 4, 4, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmDlciNiwfQoSRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciNiwfQoSRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscFrAtmDlciNiwfQoS components. These components can be added and deleted.')
mscFrAtmDlciNiwfQoSComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 4, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciNiwfQoSComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciNiwfQoSComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscFrAtmDlciNiwfQoSStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 4, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciNiwfQoSStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciNiwfQoSStorageType.setDescription('This variable represents the storage type value for the mscFrAtmDlciNiwfQoS tables.')
mscFrAtmDlciNiwfQoSIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 4, 4, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscFrAtmDlciNiwfQoSIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciNiwfQoSIndex.setDescription('This variable represents the index for the mscFrAtmDlciNiwfQoS tables.')
mscFrAtmDlciNiwfQoSProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 4, 4, 10), )
if mibBuilder.loadTexts: mscFrAtmDlciNiwfQoSProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciNiwfQoSProvTable.setDescription('This group contains the provisionable quality of service attributes for the Qos component.')
mscFrAtmDlciNiwfQoSProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 4, 4, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciNiwfIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciNiwfQoSIndex"))
if mibBuilder.loadTexts: mscFrAtmDlciNiwfQoSProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciNiwfQoSProvEntry.setDescription('An entry in the mscFrAtmDlciNiwfQoSProvTable.')
mscFrAtmDlciNiwfQoSEmissionPriorityToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 4, 4, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 254, 255))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("deriveFromTp", 254), ("sameAsInterface", 255))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmDlciNiwfQoSEmissionPriorityToIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciNiwfQoSEmissionPriorityToIf.setDescription('This attribute specifies the emission priority of frames sent to the FrAtm interface. Frames in a higher priority queue, depicted by a numerically higher number, are sent before frames in a lower priority queue. The value of this attribute is interpreted according to the value of the provisionable attribute numberOfEmissionQs under the parent FrAtm component. If the numberOfEmissionQs attribute is set to 2, emissionPriorityToIf value of 0 maps to emission priority queue 0 representing a lower priority queue, and emissionPriorityToIf values of 1, 2, and 3 map to emission priority queue 1 representing the highest priority queue. If the numberOfEmissionQs is set to 4, the emissionPriorityToIf values are directly assigned to the emission priority queues. A value of deriveFromTp specifies that the emission priority is to be extracted from the Mod Frs AtmNet Tpm/n component using the transferPriority attribute. A value of sameAsInterface specifies that the emission priority is extracts from the FrAtm Ca component using the niwfEmissionPriorityToIf attribute.')
mscFrAtmDlciNiwfQoSTransferPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 4, 4, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 255))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8), ("n9", 9), ("n10", 10), ("n11", 11), ("n12", 12), ("n13", 13), ("n14", 14), ("n15", 15), ("sameAsInterface", 255))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmDlciNiwfQoSTransferPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciNiwfQoSTransferPriority.setDescription('This attribute specifies the transfer priority of frames sent to the ATM connection. In the Frame Relay to ATM direction, the tp selects the FRF.5 End Point which multiplexes the frames. In the ATM to Frame Relay direction, the tp selects the default FrAtm emission priority queue to be used by this DLCI. A value of sameAsInterface specifies that the emission priority is to be extracted from the FrAtm Ca component using the niwfTransferPriority attribute. DESCRIPTION')
mscFrAtmDlciEgSp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 5))
mscFrAtmDlciEgSpRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 5, 1), )
if mibBuilder.loadTexts: mscFrAtmDlciEgSpRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciEgSpRowStatusTable.setDescription('This entry controls the addition and deletion of mscFrAtmDlciEgSp components.')
mscFrAtmDlciEgSpRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 5, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciEgSpIndex"))
if mibBuilder.loadTexts: mscFrAtmDlciEgSpRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciEgSpRowStatusEntry.setDescription('A single entry in the table represents a single mscFrAtmDlciEgSp component.')
mscFrAtmDlciEgSpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 5, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmDlciEgSpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciEgSpRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscFrAtmDlciEgSp components. These components can be added and deleted.')
mscFrAtmDlciEgSpComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciEgSpComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciEgSpComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscFrAtmDlciEgSpStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmDlciEgSpStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciEgSpStorageType.setDescription('This variable represents the storage type value for the mscFrAtmDlciEgSp tables.')
mscFrAtmDlciEgSpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 5, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscFrAtmDlciEgSpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciEgSpIndex.setDescription('This variable represents the index for the mscFrAtmDlciEgSp tables.')
mscFrAtmDlciEgSpProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 5, 10), )
if mibBuilder.loadTexts: mscFrAtmDlciEgSpProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciEgSpProvTable.setDescription('This group contains the provisionable attributes of the egress direction for the Data Link Connection Identifier. These attributes reflect the service parameters for the egress direction specific to this instance of Dlci.')
mscFrAtmDlciEgSpProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 5, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmDlciEgSpIndex"))
if mibBuilder.loadTexts: mscFrAtmDlciEgSpProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciEgSpProvEntry.setDescription('An entry in the mscFrAtmDlciEgSpProvTable.')
mscFrAtmDlciEgSpCommittedInformationRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 5, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 50000000)).clone(64000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmDlciEgSpCommittedInformationRate.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciEgSpCommittedInformationRate.setDescription('This attribute specifies the committed information rate (CIR) for the egress direction. It is used for bandwidth reservation for the purpose of performing a Call Admission Control (CAC) function towards the egress link. This attribute is not used to perform rate enforcement towards the egress link.')
mscFrAtmDlciEgSpCommittedBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 5, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 50000000)).clone(64000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmDlciEgSpCommittedBurstSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciEgSpCommittedBurstSize.setDescription('This attribute specifies the committed burst size (Bc) for the egress direction. It is used for bandwidth reservation for the purpose of performing a Call Admission Control (CAC) function towards the egress link. This attribute is not used to perform rate enforcement towards the egress link.')
mscFrAtmDlciEgSpExcessBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 5, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 50000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmDlciEgSpExcessBurstSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciEgSpExcessBurstSize.setDescription('This attribute specifies the excess burst size (Be) for the egress direction. It is used for bandwidth reservation for the purpose of performing a Call Admission Control (CAC) function towards the egress link. This attribute is not used to perform rate enforcement towards the egress link.')
mscFrAtmDlciEgSpMeasurementInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 4, 5, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 25500))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmDlciEgSpMeasurementInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmDlciEgSpMeasurementInterval.setDescription('This attribute specifies the time interval for the egress direction. It is used for bandwidth reservation for the purpose of performing a Call Admission Control (CAC) function towards the egress link. This attribute is not used to perform rate enforcement towards the egress link.')
mscFrAtmVFramer = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 5))
mscFrAtmVFramerRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 5, 1), )
if mibBuilder.loadTexts: mscFrAtmVFramerRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmVFramerRowStatusTable.setDescription('This entry controls the addition and deletion of mscFrAtmVFramer components.')
mscFrAtmVFramerRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 5, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmVFramerIndex"))
if mibBuilder.loadTexts: mscFrAtmVFramerRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmVFramerRowStatusEntry.setDescription('A single entry in the table represents a single mscFrAtmVFramer component.')
mscFrAtmVFramerRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 5, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmVFramerRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmVFramerRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscFrAtmVFramer components. These components can be added and deleted.')
mscFrAtmVFramerComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmVFramerComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmVFramerComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscFrAtmVFramerStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmVFramerStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmVFramerStorageType.setDescription('This variable represents the storage type value for the mscFrAtmVFramer tables.')
mscFrAtmVFramerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 5, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscFrAtmVFramerIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmVFramerIndex.setDescription('This variable represents the index for the mscFrAtmVFramer tables.')
mscFrAtmVFramerProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 5, 10), )
if mibBuilder.loadTexts: mscFrAtmVFramerProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmVFramerProvTable.setDescription('This group contains provisionable attributes for the VirtualFramer component.')
mscFrAtmVFramerProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 5, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmVFramerIndex"))
if mibBuilder.loadTexts: mscFrAtmVFramerProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmVFramerProvEntry.setDescription('An entry in the mscFrAtmVFramerProvTable.')
mscFrAtmVFramerOtherVirtualFramer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 5, 10, 1, 1), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmVFramerOtherVirtualFramer.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmVFramerOtherVirtualFramer.setDescription('This attribute specifies the other VirtualFramer to which the service is linked, for example, FrUni/n VirtualFramer, FrDte/n VirtualFramer.')
mscFrAtmVFramerLogicalProcessor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 5, 10, 1, 2), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmVFramerLogicalProcessor.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmVFramerLogicalProcessor.setDescription('This attribute specifies the logical processor on which the service component will reside.')
mscFrAtmVFramerStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 5, 11), )
if mibBuilder.loadTexts: mscFrAtmVFramerStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmVFramerStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscFrAtmVFramerStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 5, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmVFramerIndex"))
if mibBuilder.loadTexts: mscFrAtmVFramerStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmVFramerStateEntry.setDescription('An entry in the mscFrAtmVFramerStateTable.')
mscFrAtmVFramerAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 5, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmVFramerAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmVFramerAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscFrAtmVFramerOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 5, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmVFramerOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmVFramerOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscFrAtmVFramerUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 5, 11, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmVFramerUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmVFramerUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscFrAtmVFramerStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 5, 12), )
if mibBuilder.loadTexts: mscFrAtmVFramerStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmVFramerStatsTable.setDescription('This group contains the operational statistics data for a VirtualFramer component.')
mscFrAtmVFramerStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 5, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmVFramerIndex"))
if mibBuilder.loadTexts: mscFrAtmVFramerStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmVFramerStatsEntry.setDescription('An entry in the mscFrAtmVFramerStatsTable.')
mscFrAtmVFramerFrmToOtherVFramer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 5, 12, 1, 2), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmVFramerFrmToOtherVFramer.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmVFramerFrmToOtherVFramer.setDescription('This attribute counts the frames transmitted to the otherVirtualFramer.')
mscFrAtmVFramerFrmFromOtherVFramer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 5, 12, 1, 3), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmVFramerFrmFromOtherVFramer.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmVFramerFrmFromOtherVFramer.setDescription('This attribute counts the frames received from the otherVirtualFramer.')
mscFrAtmVFramerOctetFromOtherVFramer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 5, 12, 1, 5), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmVFramerOctetFromOtherVFramer.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmVFramerOctetFromOtherVFramer.setDescription('This attribute counts the octets received from the otherVirtualFramer.')
mscFrAtmAddr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 6))
mscFrAtmAddrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 6, 1), )
if mibBuilder.loadTexts: mscFrAtmAddrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmAddrRowStatusTable.setDescription('This entry controls the addition and deletion of mscFrAtmAddr components.')
mscFrAtmAddrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 6, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmAddrIndex"))
if mibBuilder.loadTexts: mscFrAtmAddrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmAddrRowStatusEntry.setDescription('A single entry in the table represents a single mscFrAtmAddr component.')
mscFrAtmAddrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 6, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmAddrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmAddrRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscFrAtmAddr components. These components can be added and deleted.')
mscFrAtmAddrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 6, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmAddrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmAddrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscFrAtmAddrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 6, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmAddrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmAddrStorageType.setDescription('This variable represents the storage type value for the mscFrAtmAddr tables.')
mscFrAtmAddrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 6, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscFrAtmAddrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmAddrIndex.setDescription('This variable represents the index for the mscFrAtmAddr tables.')
mscFrAtmAddrProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 6, 10), )
if mibBuilder.loadTexts: mscFrAtmAddrProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmAddrProvTable.setDescription('This group specifies the address of the FrAtm Interface.')
mscFrAtmAddrProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 6, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmAddrIndex"))
if mibBuilder.loadTexts: mscFrAtmAddrProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmAddrProvEntry.setDescription('An entry in the mscFrAtmAddrProvTable.')
mscFrAtmAddrAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 6, 10, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(1, 44))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmAddrAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmAddrAddress.setDescription("This attribute contains digits which form the unique identifier of the customer. It is the equivalent of the telephone number in the telephone network (either native E.164 or X.121 address formats, or Atm End System Address(AESA) in ISO NSAP format.). For example, E.164 prefix 'e.613722', X.121 prefix 'x.302', NSAP '45000441812460730F000000000020480D200100'.")
mscFrAtmAddrAddrOpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 6, 11), )
if mibBuilder.loadTexts: mscFrAtmAddrAddrOpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmAddrAddrOpTable.setDescription('This group display the address of the FrAtm Interface.')
mscFrAtmAddrAddrOpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 6, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmAddrIndex"))
if mibBuilder.loadTexts: mscFrAtmAddrAddrOpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmAddrAddrOpEntry.setDescription('An entry in the mscFrAtmAddrAddrOpTable.')
mscFrAtmAddrMyAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 6, 11, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(40, 40)).setFixedLength(40)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmAddrMyAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmAddrMyAddress.setDescription("This attribute displays the parent FRATM component's address in the ISO NSAP format.")
mscFrAtmCa = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 7))
mscFrAtmCaRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 7, 1), )
if mibBuilder.loadTexts: mscFrAtmCaRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmCaRowStatusTable.setDescription('This entry controls the addition and deletion of mscFrAtmCa components.')
mscFrAtmCaRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 7, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmCaIndex"))
if mibBuilder.loadTexts: mscFrAtmCaRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmCaRowStatusEntry.setDescription('A single entry in the table represents a single mscFrAtmCa component.')
mscFrAtmCaRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 7, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmCaRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmCaRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscFrAtmCa components. These components cannot be added nor deleted.')
mscFrAtmCaComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 7, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmCaComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmCaComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscFrAtmCaStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 7, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmCaStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmCaStorageType.setDescription('This variable represents the storage type value for the mscFrAtmCa tables.')
mscFrAtmCaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 7, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscFrAtmCaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmCaIndex.setDescription('This variable represents the index for the mscFrAtmCa tables.')
mscFrAtmCaProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 7, 10), )
if mibBuilder.loadTexts: mscFrAtmCaProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmCaProvTable.setDescription('This attribute group contains the common provisionable attributes of the Ca component.')
mscFrAtmCaProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 7, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmCaIndex"))
if mibBuilder.loadTexts: mscFrAtmCaProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmCaProvEntry.setDescription('An entry in the mscFrAtmCaProvTable.')
mscFrAtmCaCallAdmissionControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 7, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmCaCallAdmissionControl.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmCaCallAdmissionControl.setDescription('This attribute specifies the control to turn on Call Admission Control (CAC). The default value for CAC is off.')
mscFrAtmCaOverrideLinkRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 7, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 520000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmCaOverrideLinkRate.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmCaOverrideLinkRate.setDescription('This attribute allows the link rate to be overridden for this interface. This allows the user to specify a value other than the actual physical link rate computed when a Framer component is provisioned. In the absence of a Framer component, or when a VirtualFramer component is provisioned, this value needs to be explictly set to provide an equivalent link rate. This attribute provides control on the amount of bandwidth available for performing CAC. This attribute also provides the requested amount of bandwidth that is negotiated across an ATM network for traffic conversion polices 3 and 4, since these policies are a function of the access rate.')
mscFrAtmCaSdTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 7, 11), )
if mibBuilder.loadTexts: mscFrAtmCaSdTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmCaSdTable.setDescription('This group contains provisionable service interworking attributes for the FrAtm component. The attributes defined in this group provide the defaults for all the connections on the FrAtm interface.')
mscFrAtmCaSdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 7, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmCaIndex"))
if mibBuilder.loadTexts: mscFrAtmCaSdEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmCaSdEntry.setDescription('An entry in the mscFrAtmCaSdTable.')
mscFrAtmCaSdMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 7, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("translationMode", 0), ("transparentMode", 1), ("speTranslationMode", 2))).clone('translationMode')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmCaSdMode.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmCaSdMode.setDescription('This attribute specifies the mode of interoperability between the Frame Relay and ATM connections regarding upper layer protocol encapsulations. This is used as the default for all the connections on the interface. When translationMode is selected, the interworking function performs translations between RFC1490 and RFC1483 encapsulated headers. This includes routed protocol translation, bridged protocol translation, and connection oriented protocol translation (except for RFC 1490 connection oriented protocol without RFC 1490 header, which is done in speTranslationMode). A value of transparentMode indicates that the interworking function is forwarding data without altering the upper layer user protocol encapsulation. Use transparent mode when the upper layer user protocol encapsulation methods are compatible between terminal equipments. A value of speTranslationMode indicates that the interworking function performs single protocol translation between RFC1490 with no header and RFC1483 encapsulated packets.')
mscFrAtmCaSdDeToClpMapping = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 7, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("always0", 0), ("always1", 1), ("preserve", 2))).clone('preserve')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmCaSdDeToClpMapping.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmCaSdDeToClpMapping.setDescription('This attribute specifies the DE to CLP mapping that is performed in the Frame Relay to ATM direction. This is used as the default for all the connections on the interface. When preserve is selected, the DE field in a Q.922 core frame copies to the ATM CLP field of every cell containing the information of that frame. When always0 is selected, the CLP field of every generated ATM cell is always 0. When always1 is selected, the CLP field of every generated ATM cell is always 1.')
mscFrAtmCaSdClpToDeMapping = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 7, 11, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("always0", 0), ("always1", 1), ("preserve", 2))).clone('preserve')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmCaSdClpToDeMapping.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmCaSdClpToDeMapping.setDescription('This attribute specifies the type of CLP to DE mapping that is performed in the ATM to Frame Relay direction. When preserve is selected, the DE field of the Q.922 core frame is set when one or more ATM cells belonging to an AAL5 frame has its CLP field set. When always0 is selected, the DE field of the Q.922 core frame is always set to 0. When always1 is selected, the DE field of the Q.922 core frame is always set to 1.')
mscFrAtmCaSdFecnToEfciMapping = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 7, 11, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2))).clone(namedValues=NamedValues(("always0", 0), ("preserve", 2))).clone('preserve')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmCaSdFecnToEfciMapping.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmCaSdFecnToEfciMapping.setDescription('This attribute specifies the type of FECN to EFCI mapping that is performed in the Frame Relay to ATM direction. When preserve is selected, the FECN field in the Q.922 Core frame maps directly to the ATM EFCI field of every cell generated by the AAL5 segmentation process. When always0 is selected, the EFCI field in every ATM cell generated is set to 0.')
mscFrAtmCaSdCrToUuMapping = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 7, 11, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2))).clone(namedValues=NamedValues(("always0", 0), ("preserve", 2))).clone('preserve')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmCaSdCrToUuMapping.setStatus('obsolete')
if mibBuilder.loadTexts: mscFrAtmCaSdCrToUuMapping.setDescription('This attribute indicates the type of CR to UU mapping that is performed in the Frame Relay to ATM direction. A value of preserve indicates that the CR field in the Q.922 Core frame maps directly to the ATM UU field of every cell generated by the AAL5 segmentation process. A value of always0 indicates that the UU field in every ATM cell generated is set to 0.')
mscFrAtmCaNdTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 7, 12), )
if mibBuilder.loadTexts: mscFrAtmCaNdTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmCaNdTable.setDescription('This group contains the default provisionable networking attributes for the FrAtm component.')
mscFrAtmCaNdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 7, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmCaIndex"))
if mibBuilder.loadTexts: mscFrAtmCaNdEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmCaNdEntry.setDescription('An entry in the mscFrAtmCaNdTable.')
mscFrAtmCaNdDeToClpMapping = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 7, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("always0", 0), ("always1", 1), ("preserve", 2))).clone('preserve')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmCaNdDeToClpMapping.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmCaNdDeToClpMapping.setDescription('This attribute specifies the type of DE to CLP mapping to be performed in the Frame Relay to ATM direction. When preserve is selected, the DE field in the Q.922 core frame copies to the CLP field of every ATM cell containing the frame. When always0 is selected, the CLP field of every ATM cell is always set to 0. When always1 is selected, the CLP field of every ATM cell is always set to 1.')
mscFrAtmCaNdClpToDeMapping = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 7, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("preserve", 2), ("transparent", 3))).clone('preserve')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmCaNdClpToDeMapping.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmCaNdClpToDeMapping.setDescription('This attribute specifies the type of CLP to DE mapping to be performed in the ATM to Frame Relay direction. When preserve is selected, the DE field of the Q.922 core frame is set when one or more ATM cells belonging to the frame has its CLP field set, or when the DE field of the FR-SSCS PDU is set. When transparent is selected, the DE field of the Q.922 core frame copies directly from the DE field of the FR-SSCS PDU.')
mscFrAtmCaIfQoSTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 7, 13), )
if mibBuilder.loadTexts: mscFrAtmCaIfQoSTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmCaIfQoSTable.setDescription('This attribute group contains the provisionable quality of service attributes for the parent FrAtm interface.')
mscFrAtmCaIfQoSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 7, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmCaIndex"))
if mibBuilder.loadTexts: mscFrAtmCaIfQoSEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmCaIfQoSEntry.setDescription('An entry in the mscFrAtmCaIfQoSTable.')
mscFrAtmCaSiwfEmissionPriorityToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 7, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 254))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("deriveFromTp", 254))).clone('n0')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmCaSiwfEmissionPriorityToIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmCaSiwfEmissionPriorityToIf.setDescription('This attribute specifies the emission priority of frames sent to this FrAtm interface from its service interworking functions. Frames in a higher priority queue, designated by a numerically higher number, are sent before frames in a lower priority queue. The value of this attribute is interpreted according to the value of the provisionable attribute numberOfEmissionQs under the parent FrAtm component. If the numberOfEmissionQs attribute is set to 2, siwfEmissionPriorityToIf value of 0 maps to emission priority queue 0 representing a lower priority queue, and siwfEmissionPriorityToIf values of 1, 2 or 3 map to emission priority queue 1 representing the highest priority queue. If the numberOfEmissionQs is set to 4, the siwfEmissionPriorityToIf values directly map to the emission priority queues. A value of deriveFromTp specifies that the emission priority is extracted from the Mod Frs AtmNet Tpm/n component using the siwfTransferPriority attribute. The siwfEmissionPriorityToIf can also be overridden on a per connection basis by setting the emissionPriorityToIf attribute in the FrAtm Dlci Siwf Qos component.')
mscFrAtmCaSiwfTransferPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 7, 13, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmCaSiwfTransferPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmCaSiwfTransferPriority.setDescription('This attribute specifies the transfer priority of frames sent to and received from the ATM connection, through the service interworking functions of this interface. In the Frame Relay to ATM direction, the stp selects the ATM service category of the connection. In the ATM to Frame Relay direction, the stp selects the FrAtm emission priority queue. The siwfTransferPriority can also be overridden on a per connection basis by setting the transferPriority atribute in the FrAtm Dlci Siwf Qos component.')
mscFrAtmCaNiwfEmissionPriorityToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 7, 13, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 254))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("deriveFromTp", 254))).clone('deriveFromTp')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmCaNiwfEmissionPriorityToIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmCaNiwfEmissionPriorityToIf.setDescription('This attribute specifies the emission priority of frames sent to this FrAtm interface from its network interworking functions. Frames in a higher priority queue are sent before frames in a lower priority queue. The value of this attribute is interpreted according to the value of the provisionable attribute numberOfEmissionQs under the parent FrAtm component. If the numberOfEmissionQs attribute is set to 2, niwfEmissionPriorityToIf value of 0 maps to emission priority queue 0 representing a lower priority queue, and niwfEmissionPriorityToIf values of 1, 2 or 3 map to emission priority queue 1 representing the highest priority queue. If the numberOfEmissionQs is set to 4, the emissionPrioToIf values directly assign to the emission priority queues. A value of deriveFromTp specifies that the emission priority is extracted from the Mod Frs AtmNet Tpm/n component using the niwfTransferPriority attribute. The niwfEmissionPriorityToIf can also be overridden on a per connection basis by setting the emissionPriorityToIf atribute in the FrAtm Dlci Niwf Qos component.')
mscFrAtmCaNiwfTransferPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 7, 13, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmCaNiwfTransferPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmCaNiwfTransferPriority.setDescription('This attribute specifies the transfer priority of frames sent to and received from the ATM connection, through the network interworking functions of this interface. In the Frame Relay to ATM direction, the ntp selects the Frf5EndPoint which multiplexes the frames. In the ATM to Frame Relay direction, the ntp selects the default FrAtm emission priority queue. The niwfTransferPriority can also be overridden on a per connection basis by setting the transferPriority atribute in the FrAtm Dlci Niwf Qos component.')
mscFrAtmCaOpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 7, 14), )
if mibBuilder.loadTexts: mscFrAtmCaOpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmCaOpTable.setDescription('This attribute group contains the operational status of the Ca component.')
mscFrAtmCaOpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 7, 14, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmCaIndex"))
if mibBuilder.loadTexts: mscFrAtmCaOpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmCaOpEntry.setDescription('An entry in the mscFrAtmCaOpTable.')
mscFrAtmCaLinkRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 7, 14, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 520000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmCaLinkRate.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmCaLinkRate.setDescription('This attribute indicates the link rate. If the provisionable attribute, overrideLinkRate, under the Ca component is 0, then the link rate reported is the actual link rate of the port or channel. Otherwise, the link rate reported is the overrideLinkRate provisioned under the Ca component.')
mscFrAtmCaNailedUpPvcs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 7, 14, 1, 3), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmCaNailedUpPvcs.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmCaNailedUpPvcs.setDescription('This attribute indicates the number of nailed-Up PVCs currently provisioned on this interface.')
mscFrAtmCaTroubledDlcis = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 7, 14, 1, 5), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmCaTroubledDlcis.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmCaTroubledDlcis.setDescription('This attribute indicates the total number of DLCIs that are disabled and are experiencing problems. This counter increments as a result of the following problem scenarios: Abit down, PVC down, local CAC failure, or call setup failure due to network problem.')
mscFrAtmCaSoftPvcs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 7, 14, 1, 6), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmCaSoftPvcs.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmCaSoftPvcs.setDescription('This attribute indicates the number of soft PVCs currently provisioned on this interface.')
mscFrAtmCaAccountingOptionsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 7, 15), )
if mibBuilder.loadTexts: mscFrAtmCaAccountingOptionsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmCaAccountingOptionsTable.setDescription('This group contains the common provisioned attributes for accounting on a FrAtm.')
mscFrAtmCaAccountingOptionsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 7, 15, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmCaIndex"))
if mibBuilder.loadTexts: mscFrAtmCaAccountingOptionsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmCaAccountingOptionsEntry.setDescription('An entry in the mscFrAtmCaAccountingOptionsTable.')
mscFrAtmCaAccountClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 7, 15, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmCaAccountClass.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmCaAccountClass.setDescription('This attribute specifies the accounting class, which is reserved for network operations usage. Its value is an arbitrary number. The accounting records the value of this attribute.')
mscFrAtmCaAccountCollection = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 7, 15, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1).clone(hexValue="80")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmCaAccountCollection.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmCaAccountCollection.setDescription('This attribute controls accounting data collection at the interface level. It contains the following values: bill, test, study, audit, force which are used to specify the reason(s) for which accounting records are collected. If the bill, test, study and audit options are selected in the accountCollection field, accounting records are collected for bill, test, study, or audit purposes. If the force option is selected in the accountCollection field, accounting records are collected regardless of whether other reasons are provisioned. If no reason is provisioned for this attribute, then accounting data collection does not occur. Description of bits: bill(0) test(1) study(2) audit(3) force(4)')
mscFrAtmCaServiceExchange = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 7, 15, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmCaServiceExchange.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmCaServiceExchange.setDescription('This attribute is an arbitrary number, which is reserved for network operations usage. It is recorded in the accounting record.')
mscFrAtmCaBwPoolTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 7, 365), )
if mibBuilder.loadTexts: mscFrAtmCaBwPoolTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmCaBwPoolTable.setDescription('Port capacity is partitioned into 16 pools (pool 0 through pool 15). This attribute specifies the percentage of port capacity that is allowed for each pool. The percentage for each pool ranges from 0% to 1000%. It allows for under or over subscription of the port. Under subscription occurs when the sum of the percentage assigned to the 16 pools is less than 100%. Over subscription occurs when the sum of the percentage for the 16 pools exceeds 100%. The sum of the percentage assigned to the 16 pools cannot exceed 1000%. The default is full sharing of port capacity without pre-set partitions between transfer priorities.')
mscFrAtmCaBwPoolEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 7, 365, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmCaIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmCaBwPoolIndex"))
if mibBuilder.loadTexts: mscFrAtmCaBwPoolEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmCaBwPoolEntry.setDescription('An entry in the mscFrAtmCaBwPoolTable.')
mscFrAtmCaBwPoolIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 7, 365, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)))
if mibBuilder.loadTexts: mscFrAtmCaBwPoolIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmCaBwPoolIndex.setDescription('This variable represents the mscFrAtmCaBwPoolTable specific index for the mscFrAtmCaBwPoolTable.')
mscFrAtmCaBwPoolValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 7, 365, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmCaBwPoolValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmCaBwPoolValue.setDescription('This variable represents an individual value for the mscFrAtmCaBwPoolTable.')
mscFrAtmCaPoolProvBwTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 7, 366), )
if mibBuilder.loadTexts: mscFrAtmCaPoolProvBwTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmCaPoolProvBwTable.setDescription('This attribute indicates the total bandwidth requested for provisioned connections from each bandwidth pool. Total bandwidth for a given pool can be oversubcribed or undersubcribed.')
mscFrAtmCaPoolProvBwEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 7, 366, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmCaIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmCaPoolProvBwIndex"))
if mibBuilder.loadTexts: mscFrAtmCaPoolProvBwEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmCaPoolProvBwEntry.setDescription('An entry in the mscFrAtmCaPoolProvBwTable.')
mscFrAtmCaPoolProvBwIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 7, 366, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)))
if mibBuilder.loadTexts: mscFrAtmCaPoolProvBwIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmCaPoolProvBwIndex.setDescription('This variable represents the mscFrAtmCaPoolProvBwTable specific index for the mscFrAtmCaPoolProvBwTable.')
mscFrAtmCaPoolProvBwValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 7, 366, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 520000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmCaPoolProvBwValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmCaPoolProvBwValue.setDescription('This variable represents an individual value for the mscFrAtmCaPoolProvBwTable.')
mscFrAtmCaPoolAvailBwTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 7, 367), )
if mibBuilder.loadTexts: mscFrAtmCaPoolAvailBwTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmCaPoolAvailBwTable.setDescription('This attribute indicates the total available bandwidth from the bandwidth pool.')
mscFrAtmCaPoolAvailBwEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 7, 367, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmCaIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmCaPoolAvailBwIndex"))
if mibBuilder.loadTexts: mscFrAtmCaPoolAvailBwEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmCaPoolAvailBwEntry.setDescription('An entry in the mscFrAtmCaPoolAvailBwTable.')
mscFrAtmCaPoolAvailBwIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 7, 367, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)))
if mibBuilder.loadTexts: mscFrAtmCaPoolAvailBwIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmCaPoolAvailBwIndex.setDescription('This variable represents the mscFrAtmCaPoolAvailBwTable specific index for the mscFrAtmCaPoolAvailBwTable.')
mscFrAtmCaPoolAvailBwValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 7, 367, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 52000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmCaPoolAvailBwValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmCaPoolAvailBwValue.setDescription('This variable represents an individual value for the mscFrAtmCaPoolAvailBwTable.')
mscFrAtmCaPoolAdmitBwTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 7, 380), )
if mibBuilder.loadTexts: mscFrAtmCaPoolAdmitBwTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmCaPoolAdmitBwTable.setDescription('This attribute indicates the total admitted bandwidth from each bandwidth pool. Each value is the sum of the equivalent bit rates of the admitted connections.')
mscFrAtmCaPoolAdmitBwEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 7, 380, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmCaIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmCaPoolAdmitBwIndex"))
if mibBuilder.loadTexts: mscFrAtmCaPoolAdmitBwEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmCaPoolAdmitBwEntry.setDescription('An entry in the mscFrAtmCaPoolAdmitBwTable.')
mscFrAtmCaPoolAdmitBwIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 7, 380, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)))
if mibBuilder.loadTexts: mscFrAtmCaPoolAdmitBwIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmCaPoolAdmitBwIndex.setDescription('This variable represents the mscFrAtmCaPoolAdmitBwTable specific index for the mscFrAtmCaPoolAdmitBwTable.')
mscFrAtmCaPoolAdmitBwValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 7, 380, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 520000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmCaPoolAdmitBwValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmCaPoolAdmitBwValue.setDescription('This variable represents an individual value for the mscFrAtmCaPoolAdmitBwTable.')
mscFrAtmCaTpm = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 7, 2))
mscFrAtmCaTpmRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 7, 2, 1), )
if mibBuilder.loadTexts: mscFrAtmCaTpmRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmCaTpmRowStatusTable.setDescription('This entry controls the addition and deletion of mscFrAtmCaTpm components.')
mscFrAtmCaTpmRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 7, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmCaIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmCaTpmIndex"))
if mibBuilder.loadTexts: mscFrAtmCaTpmRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmCaTpmRowStatusEntry.setDescription('A single entry in the table represents a single mscFrAtmCaTpm component.')
mscFrAtmCaTpmRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 7, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmCaTpmRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmCaTpmRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscFrAtmCaTpm components. These components can be added and deleted.')
mscFrAtmCaTpmComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 7, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmCaTpmComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmCaTpmComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscFrAtmCaTpmStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 7, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrAtmCaTpmStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmCaTpmStorageType.setDescription('This variable represents the storage type value for the mscFrAtmCaTpm tables.')
mscFrAtmCaTpmIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 7, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)))
if mibBuilder.loadTexts: mscFrAtmCaTpmIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmCaTpmIndex.setDescription('This variable represents the index for the mscFrAtmCaTpm tables.')
mscFrAtmCaTpmProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 7, 2, 10), )
if mibBuilder.loadTexts: mscFrAtmCaTpmProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmCaTpmProvTable.setDescription('This attribute group contains the provisionable attributes of the Tpm component at this interface.')
mscFrAtmCaTpmProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 7, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmCaIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", "mscFrAtmCaTpmIndex"))
if mibBuilder.loadTexts: mscFrAtmCaTpmProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmCaTpmProvEntry.setDescription('An entry in the mscFrAtmCaTpmProvTable.')
mscFrAtmCaTpmAssignedBandwidthPool = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 7, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 255))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8), ("n9", 9), ("n10", 10), ("n11", 11), ("n12", 12), ("n13", 13), ("n14", 14), ("n15", 15), ("samePoolAsModule", 255))).clone('samePoolAsModule')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmCaTpmAssignedBandwidthPool.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmCaTpmAssignedBandwidthPool.setDescription('This attribute specifies the bandwidth pool that supports this transfer priority at this interface.')
mscFrAtmCaTpmTrafficParmConvPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 7, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 3, 4, 5, 6))).clone(namedValues=NamedValues(("sameAsModule", 0), ("policy3", 3), ("policy4", 4), ("policy5", 5), ("policy6", 6))).clone('sameAsModule')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmCaTpmTrafficParmConvPolicy.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmCaTpmTrafficParmConvPolicy.setDescription('This attribute specifies the traffic parameter conversion policy to use for a specific transfer priority for specifying equivalent bandwidth rate at the FrAtm interface. Policy 3 characterizes the traffic in the following way: - ATM traffic descriptor type 6 is selected - ATM service category rtVbr and nrtVbr supported only - PCR0+1 is based on AR - SCR0+1 is based on CIR and EIR - MBS0+1 is based on Bc, Be, CIR, EIR and AR - Takes into account that the instantaneous rate of the Frame Relay stream can be above CIR and up to the AR. Policy 4 characterizes the traffic in the following way: - ATM traffic descriptor type 7 or 8 is selected. Type 7 is chosen when non-conforming cells are to be discarded and type 8 when non-conforming cells are tagged by the UPC traffic policer. - PCR0+1 is based on AR - ATM service category rtVbr and nrtVbr supported only - SCR0 is based on CIR - MBS0 is based on Bc, CIR, and AR - There is no direct characterization of EIR. The allowed EIR can be derived using the difference between the AR and CIR. Policy 5 characterizes the traffic in the following way: - ATM traffic descriptor type 7 or 8 is selected. Type 7 is chosen when non-conforming cells are to be discarded and type 8 when non-conforming cells are tagged by the UPC traffic policer. - ATM service category rtVbr and nrtVbr supported only - PCR0+1 is based on CIR for descriptor type 7 - PCR0+1 is based on CIR and EIR for descriptor type 8 - SCR0 is based on CIR - MBS0 is based on Bc, CIR, and AR - The maximum PCR is no longer based on the AR but rather on the CIR and EIR or CIR Policy 6 characterizes the traffic in the following way: - ATM traffic descriptor type 3 is selected - ATM service category ubr, cbr, rtVbr and nrtVbr supported only - PCR0+1 is based only on CIR. The default value sameAsModule implies the trafficParmConversionPolicy of Mod Frs AtmNet Tpm/n is as defined as Mod Frs AtmNet Tpm/n.')
mscFrAtmCaTpmAverageFrameSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 72, 7, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8187))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrAtmCaTpmAverageFrameSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrAtmCaTpmAverageFrameSize.setDescription('This attribute specifies the average frame size at the FrAtm interface for connections using this transfer priority. If a value of 0 is specified, the average frame size defined in Mod Frs AtmNet Tpm/n avgFrameSize attribute is used.')
frameRelayAtmGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 51, 1))
frameRelayAtmGroupCA = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 51, 1, 1))
frameRelayAtmGroupCA02 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 51, 1, 1, 3))
frameRelayAtmGroupCA02A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 51, 1, 1, 3, 2))
frameRelayAtmCapabilities = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 51, 3))
frameRelayAtmCapabilitiesCA = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 51, 3, 1))
frameRelayAtmCapabilitiesCA02 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 51, 3, 1, 3))
frameRelayAtmCapabilitiesCA02A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 51, 3, 1, 3, 2))
mibBuilder.exportSymbols("Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", mscFrAtmLmiIgnoreActiveBit=mscFrAtmLmiIgnoreActiveBit, mscFrAtmAddrStorageType=mscFrAtmAddrStorageType, mscFrAtmDlciAdminState=mscFrAtmDlciAdminState, mscFrAtmDlciSiwfQoSRowStatus=mscFrAtmDlciSiwfQoSRowStatus, mscFrAtmDlciSpComponentName=mscFrAtmDlciSpComponentName, mscFrAtmOctetToIfByQueueIndex=mscFrAtmOctetToIfByQueueIndex, mscFrAtmFramerUsageState=mscFrAtmFramerUsageState, mscFrAtmLmiRowStatusEntry=mscFrAtmLmiRowStatusEntry, mscFrAtmDlciSiwfSPvcComponentName=mscFrAtmDlciSiwfSPvcComponentName, mscFrAtmVFramerStatsTable=mscFrAtmVFramerStatsTable, frameRelayAtmCapabilitiesCA02A=frameRelayAtmCapabilitiesCA02A, mscFrAtmDlciSiwfComponentName=mscFrAtmDlciSiwfComponentName, mscFrAtmCaOpTable=mscFrAtmCaOpTable, mscFrAtmDlciSiwfSustainedCellRate0=mscFrAtmDlciSiwfSustainedCellRate0, mscFrAtmDlciSiwfSdFecnToEfciMapping=mscFrAtmDlciSiwfSdFecnToEfciMapping, mscFrAtmDlciIntEntry=mscFrAtmDlciIntEntry, mscFrAtmDlciSiwfQoSRowStatusTable=mscFrAtmDlciSiwfQoSRowStatusTable, mscFrAtmAddr=mscFrAtmAddr, mscFrAtmCaPoolAvailBwIndex=mscFrAtmCaPoolAvailBwIndex, mscFrAtmDlciNiwfSpvcComponentName=mscFrAtmDlciNiwfSpvcComponentName, mscFrAtmFramerOperationalState=mscFrAtmFramerOperationalState, mscFrAtmDlciBecnFrmFromIf=mscFrAtmDlciBecnFrmFromIf, mscFrAtmDlciTotalIngressFrames=mscFrAtmDlciTotalIngressFrames, mscFrAtmLmiFullStatusPollingCycles=mscFrAtmLmiFullStatusPollingCycles, mscFrAtmDlciTotalEgressFrames=mscFrAtmDlciTotalEgressFrames, mscFrAtmDlciNiwfQoSComponentName=mscFrAtmDlciNiwfQoSComponentName, mscFrAtmLmiOpProcedures=mscFrAtmLmiOpProcedures, mscFrAtmVFramerRowStatusEntry=mscFrAtmVFramerRowStatusEntry, mscFrAtmDlciNiwfSpvcIndex=mscFrAtmDlciNiwfSpvcIndex, mscFrAtmDlciSiwfSPvcProvEntry=mscFrAtmDlciSiwfSPvcProvEntry, mscFrAtmCaNdClpToDeMapping=mscFrAtmCaNdClpToDeMapping, mscFrAtmCaServiceExchange=mscFrAtmCaServiceExchange, mscFrAtmVFramerLogicalProcessor=mscFrAtmVFramerLogicalProcessor, frameRelayAtmMIB=frameRelayAtmMIB, mscFrAtmFramer=mscFrAtmFramer, mscFrAtmDlciABitReasonFromIf=mscFrAtmDlciABitReasonFromIf, mscFrAtmDlciSiwfSPvcStorageType=mscFrAtmDlciSiwfSPvcStorageType, mscFrAtmCaSdDeToClpMapping=mscFrAtmCaSdDeToClpMapping, mscFrAtmFramerFrmToIf64=mscFrAtmFramerFrmToIf64, mscFrAtmDlciSiwfFecnToEfciMapping=mscFrAtmDlciSiwfFecnToEfciMapping, mscFrAtmDlciEgSpExcessBurstSize=mscFrAtmDlciEgSpExcessBurstSize, mscFrAtmLmiPsiTable=mscFrAtmLmiPsiTable, mscFrAtmDlciCorrelationTag=mscFrAtmDlciCorrelationTag, mscFrAtmDlciEgSpStorageType=mscFrAtmDlciEgSpStorageType, mscFrAtmDlciSpStorageType=mscFrAtmDlciSpStorageType, mscFrAtmLmiStatusSequenceErrors=mscFrAtmLmiStatusSequenceErrors, mscFrAtmDlciSpEmissionPrioToIf=mscFrAtmDlciSpEmissionPrioToIf, mscFrAtmDlciSiwfQoSProvEntry=mscFrAtmDlciSiwfQoSProvEntry, mscFrAtmFramerFrmToIf=mscFrAtmFramerFrmToIf, mscFrAtmDlciCalldEntry=mscFrAtmDlciCalldEntry, mscFrAtmDlciABitStatusToIf=mscFrAtmDlciABitStatusToIf, mscFrAtmDlciSpOpEntry=mscFrAtmDlciSpOpEntry, mscFrAtmDlciSiwfCrToUuMapping=mscFrAtmDlciSiwfCrToUuMapping, mscFrAtmLmiKeepAliveEnqToIf=mscFrAtmLmiKeepAliveEnqToIf, mscFrAtmCaIfQoSTable=mscFrAtmCaIfQoSTable, mscFrAtmDlciNiwfSpvcStorageType=mscFrAtmDlciNiwfSpvcStorageType, mscFrAtmCaSdFecnToEfciMapping=mscFrAtmCaSdFecnToEfciMapping, mscFrAtmCaLinkRate=mscFrAtmCaLinkRate, mscFrAtmDlciNiwfQoSStorageType=mscFrAtmDlciNiwfQoSStorageType, mscFrAtmDlciRowStatusTable=mscFrAtmDlciRowStatusTable, mscFrAtmCaCallAdmissionControl=mscFrAtmCaCallAdmissionControl, mscFrAtmDlciNiwfSpvcProvEntry=mscFrAtmDlciNiwfSpvcProvEntry, mscFrAtmFramerUtilEntry=mscFrAtmFramerUtilEntry, mscFrAtmLmiUsageState=mscFrAtmLmiUsageState, mscFrAtmDlciEmissionPriorityToIf=mscFrAtmDlciEmissionPriorityToIf, mscFrAtmLmiRowStatus=mscFrAtmLmiRowStatus, mscFrAtmDlciSiwfQoSTransferPriority=mscFrAtmDlciSiwfQoSTransferPriority, mscFrAtmCaOverrideLinkRate=mscFrAtmCaOverrideLinkRate, mscFrAtmCaOpEntry=mscFrAtmCaOpEntry, mscFrAtmDlciEirIngressBytes=mscFrAtmDlciEirIngressBytes, mscFrAtmDlciEgSpIndex=mscFrAtmDlciEgSpIndex, frameRelayAtmGroup=frameRelayAtmGroup, mscFrAtmDlciDiscFrameAbit=mscFrAtmDlciDiscFrameAbit, mscFrAtmVFramerIndex=mscFrAtmVFramerIndex, mscFrAtmDlciDeBytesFromIf=mscFrAtmDlciDeBytesFromIf, mscFrAtmDlciSpAccounting=mscFrAtmDlciSpAccounting, mscFrAtmDlciEgSp=mscFrAtmDlciEgSp, mscFrAtmDlciSiwfAtmConRowStatusTable=mscFrAtmDlciSiwfAtmConRowStatusTable, mscFrAtmFramerLinkTable=mscFrAtmFramerLinkTable, mscFrAtmDlciExcessBurstSize=mscFrAtmDlciExcessBurstSize, mscFrAtmDlciSiwfAtmConStorageType=mscFrAtmDlciSiwfAtmConStorageType, mscFrAtmDlciNiwfAtmDlci=mscFrAtmDlciNiwfAtmDlci, mscFrAtmDlciSiwfNPvcRowStatus=mscFrAtmDlciSiwfNPvcRowStatus, mscFrAtmCa=mscFrAtmCa, mscFrAtmDlciErrorLongBytesFromIf=mscFrAtmDlciErrorLongBytesFromIf, mscFrAtmDlciABitReasonToIf=mscFrAtmDlciABitReasonToIf, mscFrAtmDlciNiwfSpvcRemoteDlci=mscFrAtmDlciNiwfSpvcRemoteDlci, mscFrAtmDlciNiwfNdComponentName=mscFrAtmDlciNiwfNdComponentName, mscFrAtmLmiParmsTable=mscFrAtmLmiParmsTable, mscFrAtmLmiSequenceErrors=mscFrAtmLmiSequenceErrors, mscFrAtmDlciSiwfConnOpTable=mscFrAtmDlciSiwfConnOpTable, mscFrAtmOctetToIfByQueueTable=mscFrAtmOctetToIfByQueueTable, mscFrAtmDlciSpExcessBurstSize=mscFrAtmDlciSpExcessBurstSize, mscFrAtmDlciABitTable=mscFrAtmDlciABitTable, mscFrAtmDlciOperationalState=mscFrAtmDlciOperationalState, mscFrAtmCaRowStatus=mscFrAtmCaRowStatus, mscFrAtmLmiProtocolStatus=mscFrAtmLmiProtocolStatus, mscFrAtmFrmToIfByQueueEntry=mscFrAtmFrmToIfByQueueEntry, mscFrAtmStatsEntry=mscFrAtmStatsEntry, mscFrAtmDlciSiwfSdStorageType=mscFrAtmDlciSiwfSdStorageType, mscFrAtmDlciNiwfRowStatus=mscFrAtmDlciNiwfRowStatus, mscFrAtmDlciSiwfVccClearCause=mscFrAtmDlciSiwfVccClearCause, mscFrAtmDlciSiwfSdCrToUuMapping=mscFrAtmDlciSiwfSdCrToUuMapping, mscFrAtmDlciSiwfRemoteAddress=mscFrAtmDlciSiwfRemoteAddress, mscFrAtmDlciABitStatusFromIf=mscFrAtmDlciABitStatusFromIf, mscFrAtmDlciSiwfNPvc=mscFrAtmDlciSiwfNPvc, mscFrAtmFramerNonOctetErrors=mscFrAtmFramerNonOctetErrors, mscFrAtmDlciExcessBytesFromIf=mscFrAtmDlciExcessBytesFromIf, mscFrAtmCaTpmComponentName=mscFrAtmCaTpmComponentName, mscFrAtmFramerProvEntry=mscFrAtmFramerProvEntry, mscFrAtmDlciNiwfNdRowStatus=mscFrAtmDlciNiwfNdRowStatus, mscFrAtmDlciAccountingEnabled=mscFrAtmDlciAccountingEnabled, mscFrAtmDlciSpCommittedInformationRate=mscFrAtmDlciSpCommittedInformationRate, mscFrAtmCaNdTable=mscFrAtmCaNdTable, mscFrAtmDlciEgSpRowStatusEntry=mscFrAtmDlciEgSpRowStatusEntry, mscFrAtmDlciSiwfStatsEntry=mscFrAtmDlciSiwfStatsEntry, mscFrAtmDlciFecnFrmFromIf=mscFrAtmDlciFecnFrmFromIf, mscFrAtmDlciNiwf=mscFrAtmDlciNiwf, mscFrAtmDlciSiwfQoSRowStatusEntry=mscFrAtmDlciSiwfQoSRowStatusEntry, mscFrAtmEmissionPriorityQsEntry=mscFrAtmEmissionPriorityQsEntry, mscFrAtmLmi=mscFrAtmLmi, mscFrAtmCaSdCrToUuMapping=mscFrAtmCaSdCrToUuMapping, mscFrAtmDlciEgSpRowStatus=mscFrAtmDlciEgSpRowStatus, mscFrAtmCaIfQoSEntry=mscFrAtmCaIfQoSEntry, mscFrAtmDlciExcessFrmFromIf=mscFrAtmDlciExcessFrmFromIf, mscFrAtmCaSoftPvcs=mscFrAtmCaSoftPvcs, mscFrAtmDlciEfciFrmFromNetwork=mscFrAtmDlciEfciFrmFromNetwork, mscFrAtmLmiSide=mscFrAtmLmiSide, mscFrAtmDlciSiwfAtmCon=mscFrAtmDlciSiwfAtmCon, mscFrAtmCaAccountClass=mscFrAtmCaAccountClass, mscFrAtmDlciRateEnforcement=mscFrAtmDlciRateEnforcement, mscFrAtmDlciNiwfAssignedBandwidthPool=mscFrAtmDlciNiwfAssignedBandwidthPool, mscFrAtmCaPoolAdmitBwValue=mscFrAtmCaPoolAdmitBwValue, mscFrAtmDlciSiwfSPvcRemoteAddress=mscFrAtmDlciSiwfSPvcRemoteAddress, mscFrAtmDlciDiscDeCongestedFromIfBytes=mscFrAtmDlciDiscDeCongestedFromIfBytes, mscFrAtmCustomerIdentifier=mscFrAtmCustomerIdentifier, mscFrAtmAddrAddrOpTable=mscFrAtmAddrAddrOpTable, mscFrAtmDlciSiwfAtmConIndex=mscFrAtmDlciSiwfAtmConIndex, mscFrAtmLmiIndex=mscFrAtmLmiIndex, mscFrAtmDlciAccountingEnd=mscFrAtmDlciAccountingEnd, mscFrAtmCaProvTable=mscFrAtmCaProvTable, mscFrAtmCaSdClpToDeMapping=mscFrAtmCaSdClpToDeMapping, mscFrAtmComponentName=mscFrAtmComponentName, mscFrAtmFramerIndex=mscFrAtmFramerIndex, mscFrAtmFramerUnderruns=mscFrAtmFramerUnderruns, mscFrAtmAddrMyAddress=mscFrAtmAddrMyAddress, mscFrAtmLmiOperationalState=mscFrAtmLmiOperationalState, mscFrAtmDlciNiwfQoSTransferPriority=mscFrAtmDlciNiwfQoSTransferPriority, mscFrAtmFramerStatsEntry=mscFrAtmFramerStatsEntry, mscFrAtmDlciSiwfAssignedBandwidthPool=mscFrAtmDlciSiwfAssignedBandwidthPool, mscFrAtmDlciDeFrmFromIf=mscFrAtmDlciDeFrmFromIf, mscFrAtmDlciStorageType=mscFrAtmDlciStorageType, mscFrAtmAddrRowStatusTable=mscFrAtmAddrRowStatusTable, mscFrAtmCaTroubledDlcis=mscFrAtmCaTroubledDlcis, mscFrAtmDlciSiwfRowStatusEntry=mscFrAtmDlciSiwfRowStatusEntry, mscFrAtmDlciSiwfSdComponentName=mscFrAtmDlciSiwfSdComponentName, mscFrAtmCaTpmStorageType=mscFrAtmCaTpmStorageType, mscFrAtmFramerDataInversion=mscFrAtmFramerDataInversion, mscFrAtmFramerLrcErrors=mscFrAtmFramerLrcErrors, mscFrAtmFramerFrmFromIf=mscFrAtmFramerFrmFromIf, mscFrAtmLmiAsyncStatusReport=mscFrAtmLmiAsyncStatusReport, mscFrAtmDlciSiwfAtmConOperTable=mscFrAtmDlciSiwfAtmConOperTable, mscFrAtmDlciCalldTable=mscFrAtmDlciCalldTable, mscFrAtmDlciNiwfQoSEmissionPriorityToIf=mscFrAtmDlciNiwfQoSEmissionPriorityToIf, mscFrAtmCaRowStatusEntry=mscFrAtmCaRowStatusEntry, mscFrAtmDlciEirEgressBytes=mscFrAtmDlciEirEgressBytes, mscFrAtmFramerUtilTable=mscFrAtmFramerUtilTable, mscFrAtmInvalidHeaderFramesFromIf=mscFrAtmInvalidHeaderFramesFromIf, mscFrAtmDlciNiwfSpvc=mscFrAtmDlciNiwfSpvc, mscFrAtmCaNdDeToClpMapping=mscFrAtmCaNdDeToClpMapping, mscFrAtmDlci=mscFrAtmDlci, mscFrAtmDlciEgSpMeasurementInterval=mscFrAtmDlciEgSpMeasurementInterval, mscFrAtmLmiLinkVerificationTimer=mscFrAtmLmiLinkVerificationTimer, mscFrAtmDlciTotalEgressBytes=mscFrAtmDlciTotalEgressBytes, mscFrAtmOperStatusEntry=mscFrAtmOperStatusEntry, mscFrAtmDlciSpMaximumFrameSize=mscFrAtmDlciSpMaximumFrameSize, frameRelayAtmGroupCA=frameRelayAtmGroupCA, mscFrAtmDlciTroubledReason=mscFrAtmDlciTroubledReason, mscFrAtmDlciNiwfSpvcRowStatusTable=mscFrAtmDlciNiwfSpvcRowStatusTable, mscFrAtmDlciNiwfNdDeToClpMapping=mscFrAtmDlciNiwfNdDeToClpMapping, mscFrAtmLmiPvcConfigParmsInFsr=mscFrAtmLmiPvcConfigParmsInFsr, mscFrAtmDlciDiscardedBytes=mscFrAtmDlciDiscardedBytes, mscFrAtmDlciDiscDeCongestedFromIf=mscFrAtmDlciDiscDeCongestedFromIf, mscFrAtmDlciDiscByteAbit=mscFrAtmDlciDiscByteAbit, mscFrAtmIfEntryEntry=mscFrAtmIfEntryEntry, mscFrAtmVFramerProvEntry=mscFrAtmVFramerProvEntry, mscFrAtmDlciBecnFrmToIf=mscFrAtmDlciBecnFrmToIf, mscFrAtmLmiStateTable=mscFrAtmLmiStateTable, mscFrAtmRowStatusTable=mscFrAtmRowStatusTable, mscFrAtmDlciErrorShortBytesFromIf=mscFrAtmDlciErrorShortBytesFromIf, mscFrAtmVFramerFrmToOtherVFramer=mscFrAtmVFramerFrmToOtherVFramer, mscFrAtmCaTpmAssignedBandwidthPool=mscFrAtmCaTpmAssignedBandwidthPool, mscFrAtmDlciSiwfSPvcRemoteConnectionIdentifier=mscFrAtmDlciSiwfSPvcRemoteConnectionIdentifier, mscFrAtmFramerFrameCrcType=mscFrAtmFramerFrameCrcType, mscFrAtmFramerAborts=mscFrAtmFramerAborts, mscFrAtmAddrAddress=mscFrAtmAddrAddress, mscFrAtmStateTable=mscFrAtmStateTable, mscFrAtmDlciSiwfMaximumBurstSize01=mscFrAtmDlciSiwfMaximumBurstSize01, mscFrAtmDlciSiwfSPvcIndex=mscFrAtmDlciSiwfSPvcIndex, mscFrAtmDlciSiwfIndex=mscFrAtmDlciSiwfIndex, mscFrAtmDlciSiwfSdRowStatusTable=mscFrAtmDlciSiwfSdRowStatusTable, mscFrAtmDlciEgSpCommittedBurstSize=mscFrAtmDlciEgSpCommittedBurstSize, mscFrAtmCaTpmProvEntry=mscFrAtmCaTpmProvEntry, mscFrAtmFramerStatsTable=mscFrAtmFramerStatsTable, mscFrAtmFramerFrmFromIf64=mscFrAtmFramerFrmFromIf64, mscFrAtmDlciBytesToIf=mscFrAtmDlciBytesToIf, mscFrAtmDlciNiwfRowStatusEntry=mscFrAtmDlciNiwfRowStatusEntry, mscFrAtmCaPoolAvailBwEntry=mscFrAtmCaPoolAvailBwEntry, mscFrAtmDlciIndex=mscFrAtmDlciIndex, mscFrAtmCaPoolProvBwIndex=mscFrAtmCaPoolProvBwIndex, mscFrAtmDlciSiwfNPvcSiwfNpvcOpEntry=mscFrAtmDlciSiwfNPvcSiwfNpvcOpEntry, mscFrAtmDlciSiwf=mscFrAtmDlciSiwf, mscFrAtmDlciSiwfSPvc=mscFrAtmDlciSiwfSPvc, mscFrAtmDlciFrmToIf=mscFrAtmDlciFrmToIf, mscFrAtmVFramerFrmFromOtherVFramer=mscFrAtmVFramerFrmFromOtherVFramer, mscFrAtmFramerStateTable=mscFrAtmFramerStateTable, mscFrAtmDlciMaximumFrameSize=mscFrAtmDlciMaximumFrameSize, mscFrAtmLmiKeepAliveStatusEnqFromIf=mscFrAtmLmiKeepAliveStatusEnqFromIf, mscFrAtmFramerStateEntry=mscFrAtmFramerStateEntry, mscFrAtmDlciDeBytesToIf=mscFrAtmDlciDeBytesToIf, mscFrAtmFramerRowStatusEntry=mscFrAtmFramerRowStatusEntry, mscFrAtmCaStorageType=mscFrAtmCaStorageType, mscFrAtmDlciSiwfStorageType=mscFrAtmDlciSiwfStorageType, mscFrAtmCaTpmAverageFrameSize=mscFrAtmCaTpmAverageFrameSize, mscFrAtmDlciEgSpRowStatusTable=mscFrAtmDlciEgSpRowStatusTable, mscFrAtmLmiFullStatusEnqFromIf=mscFrAtmLmiFullStatusEnqFromIf, mscFrAtmCaNdEntry=mscFrAtmCaNdEntry, mscFrAtmDlciSiwfNPvcRowStatusTable=mscFrAtmDlciSiwfNPvcRowStatusTable, mscFrAtmDlciSiwfAtmConOperEntry=mscFrAtmDlciSiwfAtmConOperEntry, mscFrAtmIfAdminStatus=mscFrAtmIfAdminStatus, mscFrAtmDlciNiwfComponentName=mscFrAtmDlciNiwfComponentName, mscFrAtmDlciErrorShortFrmFromIf=mscFrAtmDlciErrorShortFrmFromIf, mscFrAtmVFramerStateEntry=mscFrAtmVFramerStateEntry, mscFrAtmDlciSiwfQoSIndex=mscFrAtmDlciSiwfQoSIndex, mscFrAtmDlciDiscCongestedFromIfBytes=mscFrAtmDlciDiscCongestedFromIfBytes, mscFrAtmDlciSiwfConnOpEntry=mscFrAtmDlciSiwfConnOpEntry, mscFrAtmFrmToIfByQueueIndex=mscFrAtmFrmToIfByQueueIndex, mscFrAtmRowStatusEntry=mscFrAtmRowStatusEntry, mscFrAtmLmiFullStatusEnqToIf=mscFrAtmLmiFullStatusEnqToIf, mscFrAtmStandbyStatus=mscFrAtmStandbyStatus, mscFrAtmCaTpmProvTable=mscFrAtmCaTpmProvTable, mscFrAtmCaIndex=mscFrAtmCaIndex, mscFrAtmUnknownStatus=mscFrAtmUnknownStatus, mscFrAtmFramerNormPrioLinkUtilFromIf=mscFrAtmFramerNormPrioLinkUtilFromIf, mscFrAtmDlciDlciType=mscFrAtmDlciDlciType, mscFrAtmDlciSpRowStatus=mscFrAtmDlciSpRowStatus, mscFrAtmDlciNiwfSpvcRowStatusEntry=mscFrAtmDlciNiwfSpvcRowStatusEntry, mscFrAtmDlciNiwfDeToClpMapping=mscFrAtmDlciNiwfDeToClpMapping, mscFrAtmCaSdTable=mscFrAtmCaSdTable, mscFrAtmAdminState=mscFrAtmAdminState, mscFrAtmVFramerProvTable=mscFrAtmVFramerProvTable, mscFrAtmOctetToIfByQueueValue=mscFrAtmOctetToIfByQueueValue, mscFrAtmDlciStateTable=mscFrAtmDlciStateTable, mscFrAtmDlciSiwfRowStatusTable=mscFrAtmDlciSiwfRowStatusTable)
mibBuilder.exportSymbols("Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", mscFrAtmOperStatusTable=mscFrAtmOperStatusTable, mscFrAtmDlciElapsedDifference=mscFrAtmDlciElapsedDifference, mscFrAtmDlciEirEgressFrames=mscFrAtmDlciEirEgressFrames, mscFrAtmDlciSpRateEnforcement=mscFrAtmDlciSpRateEnforcement, frameRelayAtmGroupCA02A=frameRelayAtmGroupCA02A, mscFrAtmFramerRowStatus=mscFrAtmFramerRowStatus, mscFrAtmDlciSiwfUnknown1483Frames=mscFrAtmDlciSiwfUnknown1483Frames, mscFrAtmDlciSpRowStatusTable=mscFrAtmDlciSpRowStatusTable, mscFrAtmAddrIndex=mscFrAtmAddrIndex, mscFrAtmFramerStorageType=mscFrAtmFramerStorageType, mscFrAtmLmiPsiEntry=mscFrAtmLmiPsiEntry, mscFrAtmCaProvEntry=mscFrAtmCaProvEntry, mscFrAtmDlciStateEntry=mscFrAtmDlciStateEntry, mscFrAtmFramerOctetFromIf64=mscFrAtmFramerOctetFromIf64, mscFrAtmDlciNiwfAtmServiceCategory=mscFrAtmDlciNiwfAtmServiceCategory, mscFrAtmCaComponentName=mscFrAtmCaComponentName, mscFrAtmDlciDiscDeCongestedToIfBytes=mscFrAtmDlciDiscDeCongestedToIfBytes, frameRelayAtmCapabilitiesCA02=frameRelayAtmCapabilitiesCA02, mscFrAtmCaSdEntry=mscFrAtmCaSdEntry, mscFrAtmCaNiwfTransferPriority=mscFrAtmCaNiwfTransferPriority, mscFrAtmDlciDiscExcessFromIfBytes=mscFrAtmDlciDiscExcessFromIfBytes, mscFrAtmDlciSiwfNPvcCorrelationTag=mscFrAtmDlciSiwfNPvcCorrelationTag, mscFrAtmDlciSiwfAtmConRowStatus=mscFrAtmDlciSiwfAtmConRowStatus, mscFrAtmFramerComponentName=mscFrAtmFramerComponentName, mscFrAtmCaTpmIndex=mscFrAtmCaTpmIndex, mscFrAtmDlciDiscCongestedFromIf=mscFrAtmDlciDiscCongestedFromIf, mscFrAtmDlciSiwfSPvcRowStatusTable=mscFrAtmDlciSiwfSPvcRowStatusTable, mscFrAtmCaSdMode=mscFrAtmCaSdMode, mscFrAtmCaPoolAvailBwValue=mscFrAtmCaPoolAvailBwValue, mscFrAtmAddrComponentName=mscFrAtmAddrComponentName, mscFrAtmDlciSiwfQoSStorageType=mscFrAtmDlciSiwfQoSStorageType, mscFrAtmDlciSiwfInvalid1490Frames=mscFrAtmDlciSiwfInvalid1490Frames, mscFrAtmDlciErrorLongFrmFromIf=mscFrAtmDlciErrorLongFrmFromIf, mscFrAtmDlciSiwfPeakCellRate01=mscFrAtmDlciSiwfPeakCellRate01, mscFrAtmDlciSiwfSdRowStatusEntry=mscFrAtmDlciSiwfSdRowStatusEntry, mscFrAtmDlciSiwfNPvcAtmConnection=mscFrAtmDlciSiwfNPvcAtmConnection, mscFrAtmDlciSiwfSPvcRowStatus=mscFrAtmDlciSiwfSPvcRowStatus, mscFrAtmFramerOverruns=mscFrAtmFramerOverruns, mscFrAtmFramerInterfaceName=mscFrAtmFramerInterfaceName, mscFrAtmCaTpmTrafficParmConvPolicy=mscFrAtmCaTpmTrafficParmConvPolicy, mscFrAtmDlciEirIngressFrames=mscFrAtmDlciEirIngressFrames, mscFrAtmDlciABitEntry=mscFrAtmDlciABitEntry, mscFrAtmDlciSiwfNPvcStorageType=mscFrAtmDlciSiwfNPvcStorageType, mscFrAtmStateEntry=mscFrAtmStateEntry, mscFrAtmCaTpmRowStatusEntry=mscFrAtmCaTpmRowStatusEntry, mscFrAtmLmiProcedures=mscFrAtmLmiProcedures, mscFrAtmCaPoolProvBwEntry=mscFrAtmCaPoolProvBwEntry, mscFrAtmVFramerRowStatusTable=mscFrAtmVFramerRowStatusTable, mscFrAtmCaBwPoolIndex=mscFrAtmCaBwPoolIndex, mscFrAtmDlciDiscardedFrames=mscFrAtmDlciDiscardedFrames, mscFrAtmCaPoolAdmitBwTable=mscFrAtmCaPoolAdmitBwTable, mscFrAtmVFramerOctetFromOtherVFramer=mscFrAtmVFramerOctetFromOtherVFramer, mscFrAtmDlciSpProvEntry=mscFrAtmDlciSpProvEntry, mscFrAtmDlciDiscDeCongestedToIf=mscFrAtmDlciDiscDeCongestedToIf, mscFrAtmDlciNiwfRowStatusTable=mscFrAtmDlciNiwfRowStatusTable, mscFrAtmCaBwPoolEntry=mscFrAtmCaBwPoolEntry, mscFrAtmDlciComponentName=mscFrAtmDlciComponentName, mscFrAtmStorageType=mscFrAtmStorageType, mscFrAtmDlciSiwfSdIndex=mscFrAtmDlciSiwfSdIndex, mscFrAtmDlciNiwfAvgFrameSize=mscFrAtmDlciNiwfAvgFrameSize, mscFrAtmDlciNiwfNdClpToDeMapping=mscFrAtmDlciNiwfNdClpToDeMapping, mscFrAtmDlciSiwfNPvcConnectionToAtm=mscFrAtmDlciSiwfNPvcConnectionToAtm, mscFrAtmDlciNiwfIndex=mscFrAtmDlciNiwfIndex, mscFrAtmDlciMeasurementInterval=mscFrAtmDlciMeasurementInterval, mscFrAtmLmiStateEntry=mscFrAtmLmiStateEntry, mscFrAtmAvailabilityStatus=mscFrAtmAvailabilityStatus, mscFrAtmDlciStartTime=mscFrAtmDlciStartTime, mscFrAtmDlciNiwfSpvcCorrelationTag=mscFrAtmDlciNiwfSpvcCorrelationTag, mscFrAtmFramerLinkEntry=mscFrAtmFramerLinkEntry, mscFrAtmDlciSiwfQoSComponentName=mscFrAtmDlciSiwfQoSComponentName, mscFrAtmIfEntryTable=mscFrAtmIfEntryTable, mscFrAtmFramerFrmModeErrors=mscFrAtmFramerFrmModeErrors, mscFrAtmDlciSiwfSdRowStatus=mscFrAtmDlciSiwfSdRowStatus, mscFrAtmLmiErrorEventThreshold=mscFrAtmLmiErrorEventThreshold, mscFrAtmDlciSiwfInvalid1483Frames=mscFrAtmDlciSiwfInvalid1483Frames, mscFrAtmLmiNetworkSideEventHistory=mscFrAtmLmiNetworkSideEventHistory, mscFrAtmDlciSiwfDeToClpMapping=mscFrAtmDlciSiwfDeToClpMapping, mscFrAtmDlciSpEmissionPriorityToIf=mscFrAtmDlciSpEmissionPriorityToIf, mscFrAtmDlciNiwfTransferPriority=mscFrAtmDlciNiwfTransferPriority, mscFrAtmStatsTable=mscFrAtmStatsTable, mscFrAtmDlciNiwfSpvcRemoteAddress=mscFrAtmDlciNiwfSpvcRemoteAddress, mscFrAtmDlciSiwfSdOpTable=mscFrAtmDlciSiwfSdOpTable, mscFrAtmDlciSiwfAtmServiceCategory=mscFrAtmDlciSiwfAtmServiceCategory, mscFrAtmDlciTotalIngressBytes=mscFrAtmDlciTotalIngressBytes, mscFrAtmDlciNiwfNdProvTable=mscFrAtmDlciNiwfNdProvTable, mscFrAtmDlciSiwfNPvcSiwfNpvcOpTable=mscFrAtmDlciSiwfNPvcSiwfNpvcOpTable, mscFrAtmDlciSiwfSPvcCorrelationTag=mscFrAtmDlciSiwfSPvcCorrelationTag, mscFrAtmDlciNiwfSpvcRowStatus=mscFrAtmDlciNiwfSpvcRowStatus, mscFrAtmDlciNiwfSpvcProvTable=mscFrAtmDlciNiwfSpvcProvTable, mscFrAtmVFramerStateTable=mscFrAtmVFramerStateTable, mscFrAtmUnknownDlciFramesFromIf=mscFrAtmUnknownDlciFramesFromIf, mscFrAtmProceduralStatus=mscFrAtmProceduralStatus, mscFrAtmDlciEgSpProvTable=mscFrAtmDlciEgSpProvTable, mscFrAtmDlciSiwfAvgFrameSize=mscFrAtmDlciSiwfAvgFrameSize, mscFrAtmDlciSiwfTransferPriority=mscFrAtmDlciSiwfTransferPriority, mscFrAtmDlciSiwfSdProvEntry=mscFrAtmDlciSiwfSdProvEntry, mscFrAtmDlciSiwfSdOpEntry=mscFrAtmDlciSiwfSdOpEntry, mscFrAtmCaBwPoolValue=mscFrAtmCaBwPoolValue, mscFrAtmNumberOfEmissionQs=mscFrAtmNumberOfEmissionQs, mscFrAtmLmiUspParmsEntry=mscFrAtmLmiUspParmsEntry, mscFrAtmCaAccountingOptionsEntry=mscFrAtmCaAccountingOptionsEntry, mscFrAtmAddrRowStatusEntry=mscFrAtmAddrRowStatusEntry, mscFrAtmDlciTroubled=mscFrAtmDlciTroubled, mscFrAtmDlciNiwfQoSRowStatusEntry=mscFrAtmDlciNiwfQoSRowStatusEntry, mscFrAtmVFramerAdminState=mscFrAtmVFramerAdminState, mscFrAtmDlciSiwfRowStatus=mscFrAtmDlciSiwfRowStatus, mscFrAtmDlciNiwfNd=mscFrAtmDlciNiwfNd, mscFrAtmLmiPollingVerifTimeouts=mscFrAtmLmiPollingVerifTimeouts, mscFrAtmDlciNiwfOperEntry=mscFrAtmDlciNiwfOperEntry, mscFrAtmDlciNiwfNdRowStatusEntry=mscFrAtmDlciNiwfNdRowStatusEntry, mscFrAtmDlciSiwfNPvcIndex=mscFrAtmDlciSiwfNPvcIndex, mscFrAtmDlciSiwfSdMode=mscFrAtmDlciSiwfSdMode, mscFrAtmDlciDiscCongestedToIf=mscFrAtmDlciDiscCongestedToIf, mscFrAtmVFramerUsageState=mscFrAtmVFramerUsageState, mscFrAtmDlciNiwfTrafficParmConvPolicy=mscFrAtmDlciNiwfTrafficParmConvPolicy, mscFrAtmLmiProtocolErrors=mscFrAtmLmiProtocolErrors, mscFrAtmDlciIntTable=mscFrAtmDlciIntTable, mscFrAtmLmiStatsEntry=mscFrAtmLmiStatsEntry, mscFrAtmRowStatus=mscFrAtmRowStatus, mscFrAtmLmiEventCount=mscFrAtmLmiEventCount, frameRelayAtmGroupCA02=frameRelayAtmGroupCA02, mscFrAtmFrmToIfByQueueValue=mscFrAtmFrmToIfByQueueValue, mscFrAtmLmiUnexpectedIes=mscFrAtmLmiUnexpectedIes, mscFrAtmLmiUnexpectedReports=mscFrAtmLmiUnexpectedReports, mscFrAtmDlciSiwfLastUnknown1483ProtocolHeader=mscFrAtmDlciSiwfLastUnknown1483ProtocolHeader, mscFrAtmDlciSiwfStatsTable=mscFrAtmDlciSiwfStatsTable, mscFrAtmDlciStatsEntry=mscFrAtmDlciStatsEntry, mscFrAtmDlciBecnFrmSetByService=mscFrAtmDlciBecnFrmSetByService, mscFrAtmDlciSiwfAtmConNextHop=mscFrAtmDlciSiwfAtmConNextHop, mscFrAtmCaTpmRowStatus=mscFrAtmCaTpmRowStatus, mscFrAtmDlciDiscExcessFromIf=mscFrAtmDlciDiscExcessFromIf, mscFrAtmOperationalState=mscFrAtmOperationalState, mscFrAtmDlciNiwfQoSProvEntry=mscFrAtmDlciNiwfQoSProvEntry, mscFrAtmFramerFlagsBetweenFrames=mscFrAtmFramerFlagsBetweenFrames, mscFrAtmDlciCommittedInformationRate=mscFrAtmDlciCommittedInformationRate, mscFrAtmEmissionPriorityQsTable=mscFrAtmEmissionPriorityQsTable, mscFrAtmDlciSiwfTrafficParmConvPolicy=mscFrAtmDlciSiwfTrafficParmConvPolicy, mscFrAtmCaSiwfTransferPriority=mscFrAtmCaSiwfTransferPriority, mscFrAtmCaSiwfEmissionPriorityToIf=mscFrAtmCaSiwfEmissionPriorityToIf, mscFrAtmDlciNiwfQoSRowStatus=mscFrAtmDlciNiwfQoSRowStatus, mscFrAtmVFramerRowStatus=mscFrAtmVFramerRowStatus, mscFrAtmDlciSpOpTable=mscFrAtmDlciSpOpTable, mscFrAtmAddrProvTable=mscFrAtmAddrProvTable, mscFrAtmDlciSiwfSd=mscFrAtmDlciSiwfSd, mscFrAtmCaTpmRowStatusTable=mscFrAtmCaTpmRowStatusTable, mscFrAtmDlciCommittedBurstSize=mscFrAtmDlciCommittedBurstSize, mscFrAtmLmiUspParmsTable=mscFrAtmLmiUspParmsTable, mscFrAtmFramerOctetFromIf=mscFrAtmFramerOctetFromIf, mscFrAtmLmiMessageCountTimer=mscFrAtmLmiMessageCountTimer, mscFrAtmCaNiwfEmissionPriorityToIf=mscFrAtmCaNiwfEmissionPriorityToIf, mscFrAtmCaAccountingOptionsTable=mscFrAtmCaAccountingOptionsTable, mscFrAtmDlciNiwfClpToDeMapping=mscFrAtmDlciNiwfClpToDeMapping, mscFrAtmDlciSiwfSdDeToClpMapping=mscFrAtmDlciSiwfSdDeToClpMapping, mscFrAtmLmiComponentName=mscFrAtmLmiComponentName, mscFrAtmDlciFecnFrmToIf=mscFrAtmDlciFecnFrmToIf, mscFrAtmDlciSp=mscFrAtmDlciSp, mscFrAtmDlciSiwfLastUnknown1490ProtocolHeader=mscFrAtmDlciSiwfLastUnknown1490ProtocolHeader, mscFrAtmDlciBytesFromIf=mscFrAtmDlciBytesFromIf, mscFrAtmDlciSiwfEquivalentBitRate=mscFrAtmDlciSiwfEquivalentBitRate, mscFrAtmFrmToIfByQueueTable=mscFrAtmFrmToIfByQueueTable, mscFrAtmDlciSiwfClpToDeMapping=mscFrAtmDlciSiwfClpToDeMapping, mscFrAtmDlciStatsTable=mscFrAtmDlciStatsTable, mscFrAtmCaPoolAvailBwTable=mscFrAtmCaPoolAvailBwTable, mscFrAtmFramerLargeFrmErrors=mscFrAtmFramerLargeFrmErrors, mscFrAtmLmiCheckPointTimer=mscFrAtmLmiCheckPointTimer, mscFrAtmDlciSpCommittedBurstSize=mscFrAtmDlciSpCommittedBurstSize, mscFrAtmDlciSiwfAtmConComponentName=mscFrAtmDlciSiwfAtmConComponentName, mscFrAtmDlciNiwfNdRowStatusTable=mscFrAtmDlciNiwfNdRowStatusTable, mscFrAtmDlciSiwfNPvcRowStatusEntry=mscFrAtmDlciSiwfNPvcRowStatusEntry, mscFrAtmDlciFrmFromIf=mscFrAtmDlciFrmFromIf, mscFrAtmUsageState=mscFrAtmUsageState, mscFrAtmVFramerStorageType=mscFrAtmVFramerStorageType, mscFrAtmFramerNormPrioLinkUtilToIf=mscFrAtmFramerNormPrioLinkUtilToIf, mscFrAtmLmiParmsEntry=mscFrAtmLmiParmsEntry, mscFrAtmDlciUsageState=mscFrAtmDlciUsageState, mscFrAtmDlciSiwfSdClpToDeMapping=mscFrAtmDlciSiwfSdClpToDeMapping, mscFrAtmDlciEgSpCommittedInformationRate=mscFrAtmDlciEgSpCommittedInformationRate, mscFrAtmFramerProvTable=mscFrAtmFramerProvTable, mscFrAtmIfIndex=mscFrAtmIfIndex, mscFrAtm=mscFrAtm, mscFrAtmDlciSiwfVccCauseDiag=mscFrAtmDlciSiwfVccCauseDiag, frameRelayAtmCapabilities=frameRelayAtmCapabilities, mscFrAtmAddrProvEntry=mscFrAtmAddrProvEntry, mscFrAtmDlciNiwfNdProvEntry=mscFrAtmDlciNiwfNdProvEntry, mscFrAtmCaBwPoolTable=mscFrAtmCaBwPoolTable, mscFrAtmDlciNiwfQoSProvTable=mscFrAtmDlciNiwfQoSProvTable, mscFrAtmFramerRowStatusTable=mscFrAtmFramerRowStatusTable, mscFrAtmCaPoolAdmitBwEntry=mscFrAtmCaPoolAdmitBwEntry, mscFrAtmVFramerOperationalState=mscFrAtmVFramerOperationalState, mscFrAtmDlciSpMeasurementInterval=mscFrAtmDlciSpMeasurementInterval, mscFrAtmDlciSiwfSiwfSpvcOpTable=mscFrAtmDlciSiwfSiwfSpvcOpTable, mscFrAtmDlciSiwfNPvcComponentName=mscFrAtmDlciSiwfNPvcComponentName, mscFrAtmCaPoolAdmitBwIndex=mscFrAtmCaPoolAdmitBwIndex, mscFrAtmCidDataTable=mscFrAtmCidDataTable, mscFrAtmControlStatus=mscFrAtmControlStatus, mscFrAtmDlciSiwfSPvcRowStatusEntry=mscFrAtmDlciSiwfSPvcRowStatusEntry, mscFrAtmDlciSpProvTable=mscFrAtmDlciSpProvTable, mscFrAtmDlciSiwfDiscardPriority=mscFrAtmDlciSiwfDiscardPriority, mscFrAtmAddrRowStatus=mscFrAtmAddrRowStatus, mscFrAtmDlciSiwfSdProvTable=mscFrAtmDlciSiwfSdProvTable, mscFrAtmLmiNoStatusReportCount=mscFrAtmLmiNoStatusReportCount, mscFrAtmDlciSiwfAtmConRowStatusEntry=mscFrAtmDlciSiwfAtmConRowStatusEntry, mscFrAtmLmiFullStatusToIf=mscFrAtmLmiFullStatusToIf, mscFrAtmAddrAddrOpEntry=mscFrAtmAddrAddrOpEntry, mscFrAtmLmiAdminState=mscFrAtmLmiAdminState, mscFrAtmDlciSiwfSiwfSpvcOpEntry=mscFrAtmDlciSiwfSiwfSpvcOpEntry, mscFrAtmDlciSiwfPeakCellRate0=mscFrAtmDlciSiwfPeakCellRate0, mscFrAtmDlciNiwfNdTransferPriority=mscFrAtmDlciNiwfNdTransferPriority, mscFrAtmCaAccountCollection=mscFrAtmCaAccountCollection, mscFrAtmDlciSiwfMode=mscFrAtmDlciSiwfMode, mscFrAtmDlciSiwfNPvcProvTable=mscFrAtmDlciSiwfNPvcProvTable, mscFrAtmDlciNiwfStorageType=mscFrAtmDlciNiwfStorageType, mscFrAtmDlciSiwfNPvcProvEntry=mscFrAtmDlciSiwfNPvcProvEntry, mscFrAtmDlciSpIndex=mscFrAtmDlciSpIndex, mscFrAtmDlciRowStatusEntry=mscFrAtmDlciRowStatusEntry, mscFrAtmLmiKeepAliveStatusToIf=mscFrAtmLmiKeepAliveStatusToIf, mscFrAtmDlciEgSpComponentName=mscFrAtmDlciEgSpComponentName, mscFrAtmDlciNiwfEquivalentBitRate=mscFrAtmDlciNiwfEquivalentBitRate, mscFrAtmFramerAdminState=mscFrAtmFramerAdminState, frameRelayAtmCapabilitiesCA=frameRelayAtmCapabilitiesCA, mscFrAtmDlciDeFrmToIf=mscFrAtmDlciDeFrmToIf, mscFrAtmDlciSpRowStatusEntry=mscFrAtmDlciSpRowStatusEntry, mscFrAtmDlciSiwfQoSEmissionPriorityToIf=mscFrAtmDlciSiwfQoSEmissionPriorityToIf, mscFrAtmAlarmStatus=mscFrAtmAlarmStatus, mscFrAtmDlciNiwfQoSIndex=mscFrAtmDlciNiwfQoSIndex, mscFrAtmDlciNiwfNdIndex=mscFrAtmDlciNiwfNdIndex, mscFrAtmVFramerOtherVirtualFramer=mscFrAtmVFramerOtherVirtualFramer, mscFrAtmLmiUserSideEventHistory=mscFrAtmLmiUserSideEventHistory, mscFrAtmDlciSiwfSPvcProvTable=mscFrAtmDlciSiwfSPvcProvTable, mscFrAtmDlciNiwfQoS=mscFrAtmDlciNiwfQoS, mscFrAtmDlciEgSpProvEntry=mscFrAtmDlciEgSpProvEntry, mscFrAtmDlciSiwfQoS=mscFrAtmDlciSiwfQoS, mscFrAtmSnmpOperStatus=mscFrAtmSnmpOperStatus, mscFrAtmDlciDiscCongestedToIfBytes=mscFrAtmDlciDiscCongestedToIfBytes, mscFrAtmCaPoolProvBwTable=mscFrAtmCaPoolProvBwTable, mscFrAtmCaTpm=mscFrAtmCaTpm, mscFrAtmDlciSiwfMaximumBurstSize0=mscFrAtmDlciSiwfMaximumBurstSize0, mscFrAtmLmiRowStatusTable=mscFrAtmLmiRowStatusTable, mscFrAtmDlciRowStatus=mscFrAtmDlciRowStatus, mscFrAtmDlciNiwfNdStorageType=mscFrAtmDlciNiwfNdStorageType, mscFrAtmLmiStorageType=mscFrAtmLmiStorageType, mscFrAtmCidDataEntry=mscFrAtmCidDataEntry, mscFrAtmFramerCrcErrors=mscFrAtmFramerCrcErrors, mscFrAtmCaNailedUpPvcs=mscFrAtmCaNailedUpPvcs, mscFrAtmDlciSiwfSustainedCellRate01=mscFrAtmDlciSiwfSustainedCellRate01, mscFrAtmVFramerComponentName=mscFrAtmVFramerComponentName, mscFrAtmDlciSiwfRemoteConnectionIdentifier=mscFrAtmDlciSiwfRemoteConnectionIdentifier, mscFrAtmDlciNiwfQoSRowStatusTable=mscFrAtmDlciNiwfQoSRowStatusTable, mscFrAtmCaRowStatusTable=mscFrAtmCaRowStatusTable, mscFrAtmLmiStatsTable=mscFrAtmLmiStatsTable, mscFrAtmVFramer=mscFrAtmVFramer, mscFrAtmDlciNiwfOperTable=mscFrAtmDlciNiwfOperTable, mscFrAtmCaPoolProvBwValue=mscFrAtmCaPoolProvBwValue, mscFrAtmDlciSiwfQoSProvTable=mscFrAtmDlciSiwfQoSProvTable)
mibBuilder.exportSymbols("Nortel-MsCarrier-MscPassport-FrameRelayAtmMIB", mscFrAtmLastUnknownDlci=mscFrAtmLastUnknownDlci, mscFrAtmDlciSiwfType=mscFrAtmDlciSiwfType, mscFrAtmDlciSiwfUnknown1490Frames=mscFrAtmDlciSiwfUnknown1490Frames, mscFrAtmVFramerStatsEntry=mscFrAtmVFramerStatsEntry, mscFrAtmOctetToIfByQueueEntry=mscFrAtmOctetToIfByQueueEntry, mscFrAtmIndex=mscFrAtmIndex)

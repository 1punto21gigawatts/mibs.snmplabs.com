#
# PySNMP MIB module RFC1243-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/RFC1243-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:57:38 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueSizeConstraint, ValueRangeConstraint, ConstraintsUnion, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsUnion", "SingleValueConstraint")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
mib_2, IpAddress, Integer32, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, Counter64, ModuleIdentity, Unsigned32, Counter32, Bits, NotificationType, Gauge32, MibIdentifier, ObjectIdentity, iso = mibBuilder.importSymbols("SNMPv2-SMI", "mib-2", "IpAddress", "Integer32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "Counter64", "ModuleIdentity", "Unsigned32", "Counter32", "Bits", "NotificationType", "Gauge32", "MibIdentifier", "ObjectIdentity", "iso")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
appletalk = MibIdentifier((1, 3, 6, 1, 2, 1, 13))
class DdpAddress(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(3, 3)
    fixedLength = 3

llap = MibIdentifier((1, 3, 6, 1, 2, 1, 13, 1))
aarp = MibIdentifier((1, 3, 6, 1, 2, 1, 13, 2))
atport = MibIdentifier((1, 3, 6, 1, 2, 1, 13, 3))
ddp = MibIdentifier((1, 3, 6, 1, 2, 1, 13, 4))
rtmp = MibIdentifier((1, 3, 6, 1, 2, 1, 13, 5))
kip = MibIdentifier((1, 3, 6, 1, 2, 1, 13, 6))
zip = MibIdentifier((1, 3, 6, 1, 2, 1, 13, 7))
nbp = MibIdentifier((1, 3, 6, 1, 2, 1, 13, 8))
atecho = MibIdentifier((1, 3, 6, 1, 2, 1, 13, 9))
llapTable = MibTable((1, 3, 6, 1, 2, 1, 13, 1, 1), )
if mibBuilder.loadTexts: llapTable.setStatus('mandatory')
if mibBuilder.loadTexts: llapTable.setDescription('The list of LLAP entries.')
llapEntry = MibTableRow((1, 3, 6, 1, 2, 1, 13, 1, 1, 1), ).setIndexNames((0, "RFC1243-MIB", "llapIfIndex"))
if mibBuilder.loadTexts: llapEntry.setStatus('mandatory')
if mibBuilder.loadTexts: llapEntry.setDescription('An LLAP entry containing objects for the LocalTalk Link Access Protocol for a particular LocalTalk interface.')
llapIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: llapIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: llapIfIndex.setDescription('The LLAP interface to which this entry pertains. The interface identified by a particular value of this index is the same interface as identified by the same value of ifIndex.')
llapInPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 1, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: llapInPkts.setStatus('mandatory')
if mibBuilder.loadTexts: llapInPkts.setDescription('The total number of good packets received on this LocalTalk interface.')
llapOutPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 1, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: llapOutPkts.setStatus('mandatory')
if mibBuilder.loadTexts: llapOutPkts.setDescription('The total number of packets transmitted on this LocalTalk interface.')
llapInNoHandlers = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 1, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: llapInNoHandlers.setStatus('mandatory')
if mibBuilder.loadTexts: llapInNoHandlers.setDescription('The total number of good packets received on this LocalTalk interface for which there was no protocol handler.')
llapInLengthErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 1, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: llapInLengthErrors.setStatus('mandatory')
if mibBuilder.loadTexts: llapInLengthErrors.setDescription('The total number of packets received on this LocalTalk interface whose actual length did not match the length in the header.')
llapInErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 1, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: llapInErrors.setStatus('mandatory')
if mibBuilder.loadTexts: llapInErrors.setDescription('The total number of packets containing errors received on this LocalTalk interface.')
llapCollisions = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 1, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: llapCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: llapCollisions.setDescription('The total number of collisions assumed on this LocalTalk interface due to the lack of a lapCTS reply.')
llapDefers = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 1, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: llapDefers.setStatus('mandatory')
if mibBuilder.loadTexts: llapDefers.setDescription('The total number of times this LocalTalk interface deferred to other packets.')
llapNoDataErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 1, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: llapNoDataErrors.setStatus('mandatory')
if mibBuilder.loadTexts: llapNoDataErrors.setDescription('The total number of times this LocalTalk interface received a lapRTS packet and expected a data packet, but did not receive any data packet.')
llapRandomCTSErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 1, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: llapRandomCTSErrors.setStatus('mandatory')
if mibBuilder.loadTexts: llapRandomCTSErrors.setDescription('The total number of times this LocalTalk interface received a lapCTS packet that was not solicited by a lapRTS packet.')
llapFCSErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 1, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: llapFCSErrors.setStatus('mandatory')
if mibBuilder.loadTexts: llapFCSErrors.setDescription('The total number of times this LocalTalk interface received a packet with an FCS (Frame Check Sequence) error.')
aarpTable = MibTable((1, 3, 6, 1, 2, 1, 13, 2, 1), )
if mibBuilder.loadTexts: aarpTable.setStatus('mandatory')
if mibBuilder.loadTexts: aarpTable.setDescription('The AppleTalk Address Translation Table contains an equivalence of AppleTalk Network Addresses to the link layer physical address.')
aarpEntry = MibTableRow((1, 3, 6, 1, 2, 1, 13, 2, 1, 1), ).setIndexNames((0, "RFC1243-MIB", "aarpIfIndex"), (0, "RFC1243-MIB", "aarpNetAddress"))
if mibBuilder.loadTexts: aarpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: aarpEntry.setDescription('Each entry contains one AppleTalk Network Address to physical address equivalence.')
aarpIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aarpIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: aarpIfIndex.setDescription("The interface on which this entry's equivalence is effective. The interface identified by a particular value of this index is the same interface as identified by the same value of ifIndex.")
aarpPhysAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 2, 1, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aarpPhysAddress.setStatus('mandatory')
if mibBuilder.loadTexts: aarpPhysAddress.setDescription('The media-dependent physical address')
aarpNetAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 2, 1, 1, 3), DdpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aarpNetAddress.setStatus('mandatory')
if mibBuilder.loadTexts: aarpNetAddress.setDescription('The AppleTalk Network Address corresponding to the media-dependent physical address.')
atportTable = MibTable((1, 3, 6, 1, 2, 1, 13, 3, 1), )
if mibBuilder.loadTexts: atportTable.setStatus('mandatory')
if mibBuilder.loadTexts: atportTable.setDescription('A list of AppleTalk ports for this entity.')
atportEntry = MibTableRow((1, 3, 6, 1, 2, 1, 13, 3, 1, 1), ).setIndexNames((0, "RFC1243-MIB", "atportIndex"))
if mibBuilder.loadTexts: atportEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atportEntry.setDescription('The description of one of the AppleTalk ports on this entity.')
atportIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atportIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atportIndex.setDescription("A unique value for each AppleTalk port. Its value is between 1 and the total number of AppleTalk ports. The value for each port must remain constant at least from the re-initialization of the entity's network management system to the next re-initialization.")
atportDescr = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atportDescr.setStatus('mandatory')
if mibBuilder.loadTexts: atportDescr.setDescription('A text string containing information about the port. This string is intended for presentation to a human; it must not contain anything but printable ASCII characters.')
atportType = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("other", 1), ("localtalk", 2), ("ethertalk1", 3), ("ethertalk2", 4), ("tokentalk", 5), ("iptalk", 6), ("serial-ppp", 7), ("serial-nonstandard", 8), ("virtual", 9)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atportType.setStatus('mandatory')
if mibBuilder.loadTexts: atportType.setDescription('The type of port, distinguished by the protocol immediately below DDP in the protocol stack.')
atportNetStart = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 3, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atportNetStart.setStatus('mandatory')
if mibBuilder.loadTexts: atportNetStart.setDescription('The first AppleTalk network address in the range configured for this port. This is a two octet DDP network address in network byte order.')
atportNetEnd = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 3, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atportNetEnd.setStatus('mandatory')
if mibBuilder.loadTexts: atportNetEnd.setDescription('The last AppleTalk network address in the range configured for this port. This is a two octet DDP network address in network byte order. If the network to which this AppleTalk port is connected is a Phase 1 network or a non-extended network, the value for atportNetEnd shall be two octets of zero.')
atportNetAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 3, 1, 1, 6), DdpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atportNetAddress.setStatus('mandatory')
if mibBuilder.loadTexts: atportNetAddress.setDescription('The AppleTalk network address configured for this port.')
atportStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("operational", 1), ("unconfigured", 2), ("off", 3), ("invalid", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atportStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atportStatus.setDescription('The configuration status of this port. Setting this object to the value invalid(4) has the effect of invalidating the corresponding entry in the atportTable. That is, it effectively disassociates the mapping identified with said entry. It is an implementation-specific matter as to whether the agent removes an invalidated entry from the table. Accordingly, management stations must be prepared to receive from agents tabular information corresponding to entries not currently in use. Proper interpretation of such entries requires examination of the relevant atportStatus object.')
atportNetConfig = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("configured", 1), ("garnered", 2), ("guessed", 3), ("unconfigured", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atportNetConfig.setStatus('mandatory')
if mibBuilder.loadTexts: atportNetConfig.setDescription('The configuration status of this port.')
atportZoneConfig = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 3, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("configured", 1), ("garnered", 2), ("guessed", 3), ("unconfigured", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atportZoneConfig.setStatus('mandatory')
if mibBuilder.loadTexts: atportZoneConfig.setDescription('The configuration status of the zone information for this port.')
atportZone = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 3, 1, 1, 10), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atportZone.setStatus('mandatory')
if mibBuilder.loadTexts: atportZone.setDescription('The zone name configured for this AppleTalk port.')
atportIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 3, 1, 1, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atportIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atportIfIndex.setDescription('The physical interface associated with this AppleTalk port. The interface identified by a particular value of this index is the same interface as identified by the same value of ifIndex.')
ddpOutRequests = MibScalar((1, 3, 6, 1, 2, 1, 13, 4, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ddpOutRequests.setStatus('mandatory')
if mibBuilder.loadTexts: ddpOutRequests.setDescription('The total number of DDP datagrams which were supplied to DDP by local DDP clients in requests for transmission. Note that this counter does not include any datagrams counted in ddpForwRequests.')
ddpOutShorts = MibScalar((1, 3, 6, 1, 2, 1, 13, 4, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ddpOutShorts.setStatus('mandatory')
if mibBuilder.loadTexts: ddpOutShorts.setDescription('The total number of short DDP datagrams which were transmitted from this entity.')
ddpOutLongs = MibScalar((1, 3, 6, 1, 2, 1, 13, 4, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ddpOutLongs.setStatus('mandatory')
if mibBuilder.loadTexts: ddpOutLongs.setDescription('The total number of long DDP datagrams which were transmitted from this entity.')
ddpInReceives = MibScalar((1, 3, 6, 1, 2, 1, 13, 4, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ddpInReceives.setStatus('mandatory')
if mibBuilder.loadTexts: ddpInReceives.setDescription('The total number of input datagrams received by DDP, including those received in error.')
ddpForwRequests = MibScalar((1, 3, 6, 1, 2, 1, 13, 4, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ddpForwRequests.setStatus('mandatory')
if mibBuilder.loadTexts: ddpForwRequests.setDescription('The number of input datagrams for which this entity was not their final DDP destination, as a result of which an attempt was made to find a route to forward them to that final destination.')
ddpInLocalDatagrams = MibScalar((1, 3, 6, 1, 2, 1, 13, 4, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ddpInLocalDatagrams.setStatus('mandatory')
if mibBuilder.loadTexts: ddpInLocalDatagrams.setDescription('The total number of input DDP datagrams for which this entity was their final DDP destination.')
ddpNoProtocolHandlers = MibScalar((1, 3, 6, 1, 2, 1, 13, 4, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ddpNoProtocolHandlers.setStatus('mandatory')
if mibBuilder.loadTexts: ddpNoProtocolHandlers.setDescription('The total number of DDP datagrams addressed to this entity that were addressed to an upper layer protocol for which no protocol handler existed.')
ddpOutNoRoutes = MibScalar((1, 3, 6, 1, 2, 1, 13, 4, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ddpOutNoRoutes.setStatus('mandatory')
if mibBuilder.loadTexts: ddpOutNoRoutes.setDescription('The total number of DDP datagrams dropped because a route could not be found to their final destination.')
ddpTooShortErrors = MibScalar((1, 3, 6, 1, 2, 1, 13, 4, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ddpTooShortErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ddpTooShortErrors.setDescription('The total number of input DDP datagrams dropped because the received data length was less than the data length specified in the DDP header or the received data length was less than the length of the expected DDP header.')
ddpTooLongErrors = MibScalar((1, 3, 6, 1, 2, 1, 13, 4, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ddpTooLongErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ddpTooLongErrors.setDescription('The total number of input DDP datagrams dropped because the received data length was greater than the data length specified in the DDP header or because they exceeded the maximum DDP datagram size.')
ddpBroadcastErrors = MibScalar((1, 3, 6, 1, 2, 1, 13, 4, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ddpBroadcastErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ddpBroadcastErrors.setDescription('The total number of input DDP datagrams dropped because this entity was not their final destination and they were addressed to the link level broadcast.')
ddpShortDDPErrors = MibScalar((1, 3, 6, 1, 2, 1, 13, 4, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ddpShortDDPErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ddpShortDDPErrors.setDescription('The total number of input DDP datagrams dropped because this entity was not their final destination and their type was short DDP.')
ddpHopCountErrors = MibScalar((1, 3, 6, 1, 2, 1, 13, 4, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ddpHopCountErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ddpHopCountErrors.setDescription('The total number of input DDP datagrams dropped because this entity was not their final destination and their hop count would exceed 15.')
ddpChecksumErrors = MibScalar((1, 3, 6, 1, 2, 1, 13, 4, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ddpChecksumErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ddpChecksumErrors.setDescription('The total number of input DDP datagrams dropped because of a checksum error.')
rtmpTable = MibTable((1, 3, 6, 1, 2, 1, 13, 5, 1), )
if mibBuilder.loadTexts: rtmpTable.setStatus('mandatory')
if mibBuilder.loadTexts: rtmpTable.setDescription('A list of Routing Table Maintenance Protocol entries for this entity.')
rtmpEntry = MibTableRow((1, 3, 6, 1, 2, 1, 13, 5, 1, 1), ).setIndexNames((0, "RFC1243-MIB", "rtmpRangeStart"))
if mibBuilder.loadTexts: rtmpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rtmpEntry.setDescription('The route entry to a particular network range.')
rtmpRangeStart = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 5, 1, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtmpRangeStart.setStatus('mandatory')
if mibBuilder.loadTexts: rtmpRangeStart.setDescription('The first DDP network address in the network range to which this routing entry pertains. This is a two octet DDP network address in network byte order.')
rtmpRangeEnd = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 5, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtmpRangeEnd.setStatus('mandatory')
if mibBuilder.loadTexts: rtmpRangeEnd.setDescription('The last DDP network address in the network range to which this routing entry pertains. This is a two octet DDP network address in network byte order. If the network to which this routing entry pertains is a Phase 1 network or a non-extended network, the value for rtmpRangeEnd shall be two octets of zero.')
rtmpNextHop = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 5, 1, 1, 3), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtmpNextHop.setStatus('mandatory')
if mibBuilder.loadTexts: rtmpNextHop.setDescription("The next hop in the route to this entry's destination network. If the type of this route is Appletalk, this address takes the same form as DdpAddress.")
rtmpType = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 5, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("appletalk", 2), ("serial-ppp", 3), ("serial-nonstandard", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtmpType.setStatus('mandatory')
if mibBuilder.loadTexts: rtmpType.setDescription('The type of network over which this route points.')
rtmpPort = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 5, 1, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtmpPort.setStatus('mandatory')
if mibBuilder.loadTexts: rtmpPort.setDescription('The index of the AppleTalk port over which this route points.')
rtmpHops = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 5, 1, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtmpHops.setStatus('mandatory')
if mibBuilder.loadTexts: rtmpHops.setDescription('The number of hops required to reach the destination network to which this routing entry pertains.')
rtmpState = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 5, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("good", 1), ("suspect", 2), ("goingBad", 3), ("bad", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtmpState.setStatus('mandatory')
if mibBuilder.loadTexts: rtmpState.setDescription('The status of the information contained in this route entry. Setting this object to the value bad(4) has the effect of invalidating the corresponding entry in the rtmpTable. That is, it effectively disassociates the mapping identified with said entry. It is an implementation-specific matter as to whether the agent removes an invalidated entry from the table. Accordingly, management stations must be prepared to receive from agents tabular information corresponding to entries not currently in use. Proper interpretation of such entries requires examination of the relevant rtmpState object.')
kipTable = MibTable((1, 3, 6, 1, 2, 1, 13, 6, 1), )
if mibBuilder.loadTexts: kipTable.setStatus('mandatory')
if mibBuilder.loadTexts: kipTable.setDescription('The table of routing information for KIP networks.')
kipEntry = MibTableRow((1, 3, 6, 1, 2, 1, 13, 6, 1, 1), ).setIndexNames((0, "RFC1243-MIB", "kipNetStart"))
if mibBuilder.loadTexts: kipEntry.setStatus('mandatory')
if mibBuilder.loadTexts: kipEntry.setDescription('An entry in the routing table for KIP networks.')
kipNetStart = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 6, 1, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: kipNetStart.setStatus('mandatory')
if mibBuilder.loadTexts: kipNetStart.setDescription('The first AppleTalk network address in the range for this routing entry. This address is a two octet DDP network address in network byte order.')
kipNetEnd = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 6, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: kipNetEnd.setStatus('mandatory')
if mibBuilder.loadTexts: kipNetEnd.setDescription('The last AppleTalk network address in the range for this routing entry. This address is a two octet DDP network address in network byte order. If the network to which this AppleTalk port is connected is a Phase 1 network or a non-extended network, the value for kipNetEnd shall be two octets of zero.')
kipNextHop = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 6, 1, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: kipNextHop.setStatus('mandatory')
if mibBuilder.loadTexts: kipNextHop.setDescription("The IP address of the next hop in the route to this entry's destination network.")
kipHopCount = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 6, 1, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: kipHopCount.setStatus('mandatory')
if mibBuilder.loadTexts: kipHopCount.setDescription('The number of hops required to reach the destination network to which this entry pertains.')
kipBCastAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 6, 1, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: kipBCastAddr.setStatus('mandatory')
if mibBuilder.loadTexts: kipBCastAddr.setDescription('The form of the IP address used to broadcast on this network.')
kipCore = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 6, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("core", 1), ("notcore", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: kipCore.setStatus('mandatory')
if mibBuilder.loadTexts: kipCore.setDescription('The status of this network as a Kip Core network.')
kipType = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 6, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("kipRouter", 1), ("net", 2), ("host", 3), ("other", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: kipType.setStatus('mandatory')
if mibBuilder.loadTexts: kipType.setDescription('The type of the entity that this route points to.')
kipState = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 6, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("configured", 1), ("learned", 2), ("invalid", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: kipState.setStatus('mandatory')
if mibBuilder.loadTexts: kipState.setDescription('The state of this network entry. Setting this object to the value invalid(3) has the effect of invalidating the corresponding entry in the kipTable. That is, it effectively disassociates the mapping identified with said entry. It is an implementation-specific matter as to whether the agent removes an invalidated entry from the table. Accordingly, management stations must be prepared to receive from agents tabular information corresponding to entries not currently in use. Proper interpretation of such entries requires examination of the relevant kipState object.')
kipShare = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 6, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("shared", 1), ("private", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: kipShare.setStatus('mandatory')
if mibBuilder.loadTexts: kipShare.setDescription('If the information in this entry is propagated to other routers as part of a routing protocol, the value of this variable is equal to shared(1). Otherwise its value is private(2).')
zipTable = MibTable((1, 3, 6, 1, 2, 1, 13, 7, 1), )
if mibBuilder.loadTexts: zipTable.setStatus('mandatory')
if mibBuilder.loadTexts: zipTable.setDescription('The table of zone information for reachable AppleTalk networks.')
zipEntry = MibTableRow((1, 3, 6, 1, 2, 1, 13, 7, 1, 1), ).setIndexNames((0, "RFC1243-MIB", "zipZoneNetStart"), (0, "RFC1243-MIB", "zipZoneIndex"))
if mibBuilder.loadTexts: zipEntry.setStatus('mandatory')
if mibBuilder.loadTexts: zipEntry.setDescription('An entry of zone information for a particular zone and network combination.')
zipZoneName = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 7, 1, 1, 1), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: zipZoneName.setStatus('mandatory')
if mibBuilder.loadTexts: zipZoneName.setDescription('The ASCII zone name of this entry.')
zipZoneIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 7, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: zipZoneIndex.setStatus('mandatory')
if mibBuilder.loadTexts: zipZoneIndex.setDescription('An integer that is unique to the zipZoneName that is present in this entry. For any given zone name, every zipEntry that has an equal zone name will have the same zipZoneIndex.')
zipZoneNetStart = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 7, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: zipZoneNetStart.setStatus('mandatory')
if mibBuilder.loadTexts: zipZoneNetStart.setDescription('The network that starts the range for this entry. This address is a two octet DDP network address in network byte order.')
zipZoneNetEnd = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 7, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: zipZoneNetEnd.setStatus('mandatory')
if mibBuilder.loadTexts: zipZoneNetEnd.setDescription('The network that ends the range for this entry. This address is a two octet DDP network address in network byte order. If the network to which this zip entry pertains is a Phase 1 network or a non-extended network, the value for zipZoneNetEnd shall be two bytes of zero.')
zipZoneState = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 7, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: zipZoneState.setStatus('mandatory')
if mibBuilder.loadTexts: zipZoneState.setDescription('The state of this zip entry. Setting this object to the value invalid(2) has the effect of invalidating the corresponding entry in the zipTable. That is, it effectively disassociates the mapping identified with said entry. It is an implementation-specific matter as to whether the agent removes an invalidated entry from the table. Accordingly, management stations must be prepared to receive from agents tabular information corresponding to entries not currently in use. Proper interpretation of such entries requires examination of the relevant zipZoneState object.')
nbpTable = MibTable((1, 3, 6, 1, 2, 1, 13, 8, 1), )
if mibBuilder.loadTexts: nbpTable.setStatus('mandatory')
if mibBuilder.loadTexts: nbpTable.setDescription('The table of NBP services registered on this entity.')
nbpEntry = MibTableRow((1, 3, 6, 1, 2, 1, 13, 8, 1, 1), ).setIndexNames((0, "RFC1243-MIB", "nbpIndex"))
if mibBuilder.loadTexts: nbpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nbpEntry.setDescription('The description of an NBP service registered on this entity.')
nbpIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 8, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: nbpIndex.setDescription('The index of this NBP entry. This value ranges from 1 to the number of NBP entries currently registered on this entity.')
nbpObject = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 8, 1, 1, 2), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbpObject.setStatus('mandatory')
if mibBuilder.loadTexts: nbpObject.setDescription('The name of the service described by this entity.')
nbpType = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 8, 1, 1, 3), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbpType.setStatus('mandatory')
if mibBuilder.loadTexts: nbpType.setDescription('The type of the service described by this entity.')
nbpZone = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 8, 1, 1, 4), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbpZone.setStatus('mandatory')
if mibBuilder.loadTexts: nbpZone.setDescription('The zone the service described by this entity is registered in.')
nbpState = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 8, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbpState.setStatus('mandatory')
if mibBuilder.loadTexts: nbpState.setDescription('The state of this NBP entry. Setting this object to the value invalid(2) has the effect of invalidating the corresponding entry in the nbpTable. That is, it effectively disassociates the mapping identified with said entry. It is an implementation-specific matter as to whether the agent removes an invalidated entry from the table. Accordingly, management stations must be prepared to receive from agents tabular information corresponding to entries not currently in use. Proper interpretation of such entries requires examination of the relevant nbpState object.')
atechoRequests = MibScalar((1, 3, 6, 1, 2, 1, 13, 9, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atechoRequests.setStatus('mandatory')
if mibBuilder.loadTexts: atechoRequests.setDescription('The number of AppleTalk echo requests received.')
atechoReplies = MibScalar((1, 3, 6, 1, 2, 1, 13, 9, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atechoReplies.setStatus('mandatory')
if mibBuilder.loadTexts: atechoReplies.setDescription('The number of AppleTalk echo replies sent.')
mibBuilder.exportSymbols("RFC1243-MIB", atportEntry=atportEntry, kipShare=kipShare, ddpInLocalDatagrams=ddpInLocalDatagrams, atportNetAddress=atportNetAddress, rtmpRangeEnd=rtmpRangeEnd, ddpNoProtocolHandlers=ddpNoProtocolHandlers, llap=llap, atportNetEnd=atportNetEnd, llapCollisions=llapCollisions, aarpIfIndex=aarpIfIndex, nbpState=nbpState, kipNetEnd=kipNetEnd, kipType=kipType, atechoRequests=atechoRequests, kip=kip, nbp=nbp, llapTable=llapTable, llapDefers=llapDefers, aarpNetAddress=aarpNetAddress, ddpTooLongErrors=ddpTooLongErrors, rtmpEntry=rtmpEntry, atechoReplies=atechoReplies, rtmp=rtmp, kipCore=kipCore, rtmpState=rtmpState, zipTable=zipTable, rtmpRangeStart=rtmpRangeStart, aarpPhysAddress=aarpPhysAddress, kipBCastAddr=kipBCastAddr, nbpIndex=nbpIndex, atportDescr=atportDescr, nbpType=nbpType, zipZoneState=zipZoneState, nbpZone=nbpZone, kipTable=kipTable, zipZoneIndex=zipZoneIndex, zip=zip, zipZoneName=zipZoneName, aarpEntry=aarpEntry, atportStatus=atportStatus, kipNextHop=kipNextHop, appletalk=appletalk, kipEntry=kipEntry, ddpHopCountErrors=ddpHopCountErrors, kipHopCount=kipHopCount, atportIfIndex=atportIfIndex, ddpInReceives=ddpInReceives, rtmpHops=rtmpHops, nbpTable=nbpTable, llapEntry=llapEntry, rtmpPort=rtmpPort, ddpOutShorts=ddpOutShorts, rtmpNextHop=rtmpNextHop, llapNoDataErrors=llapNoDataErrors, DdpAddress=DdpAddress, llapInPkts=llapInPkts, kipState=kipState, ddpBroadcastErrors=ddpBroadcastErrors, ddpTooShortErrors=ddpTooShortErrors, kipNetStart=kipNetStart, atportZoneConfig=atportZoneConfig, atport=atport, aarp=aarp, llapIfIndex=llapIfIndex, aarpTable=aarpTable, llapInNoHandlers=llapInNoHandlers, ddpChecksumErrors=ddpChecksumErrors, ddpShortDDPErrors=ddpShortDDPErrors, llapFCSErrors=llapFCSErrors, ddp=ddp, llapInErrors=llapInErrors, ddpForwRequests=ddpForwRequests, atecho=atecho, llapRandomCTSErrors=llapRandomCTSErrors, llapOutPkts=llapOutPkts, atportIndex=atportIndex, atportNetStart=atportNetStart, atportNetConfig=atportNetConfig, rtmpType=rtmpType, zipEntry=zipEntry, nbpEntry=nbpEntry, ddpOutRequests=ddpOutRequests, atportType=atportType, zipZoneNetEnd=zipZoneNetEnd, atportTable=atportTable, zipZoneNetStart=zipZoneNetStart, rtmpTable=rtmpTable, ddpOutLongs=ddpOutLongs, llapInLengthErrors=llapInLengthErrors, ddpOutNoRoutes=ddpOutNoRoutes, atportZone=atportZone, nbpObject=nbpObject)

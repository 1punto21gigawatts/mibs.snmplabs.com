#
# PySNMP MIB module PACKETEER-RTM-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/PACKETEER-RTM-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:36:08 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsIntersection, ValueSizeConstraint, ValueRangeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsIntersection", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsUnion")
classIndex, psCommonMib = mibBuilder.importSymbols("PACKETEER-MIB", "classIndex", "psCommonMib")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
IpAddress, Counter32, iso, MibIdentifier, Gauge32, Unsigned32, Bits, Counter64, NotificationType, ObjectIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, ModuleIdentity, TimeTicks, Integer32 = mibBuilder.importSymbols("SNMPv2-SMI", "IpAddress", "Counter32", "iso", "MibIdentifier", "Gauge32", "Unsigned32", "Bits", "Counter64", "NotificationType", "ObjectIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ModuleIdentity", "TimeTicks", "Integer32")
DateAndTime, TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "DateAndTime", "TextualConvention", "DisplayString")
psClassResponseTimes = MibIdentifier((1, 3, 6, 1, 4, 1, 2334, 2, 1, 7))
classRTMConfigTable = MibTable((1, 3, 6, 1, 4, 1, 2334, 2, 1, 7, 1), )
if mibBuilder.loadTexts: classRTMConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: classRTMConfigTable.setDescription('A table of parameters configuring the Response Time Management feature for each class. *** NOTE that these parameters are used to compute the other data in this MIB, and thus changing any of them causes a reset of most RTM data. Only the histograms (classTotalDelayTable, classServerDelayTable, and classNetworkDelayTable ) are unaffected.')
classRTMConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2334, 2, 1, 7, 1, 1), ).setIndexNames((0, "PACKETEER-MIB", "classIndex"))
if mibBuilder.loadTexts: classRTMConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: classRTMConfigEntry.setDescription('An entry containing the configurable Response Time Management parameters for a given class')
classTotalDelayThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 2334, 2, 1, 7, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: classTotalDelayThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: classTotalDelayThreshold.setDescription('The time in milliseconds which constitutes the acceptable limit of aggregate delay for this class.')
classServiceLevelThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 2334, 2, 1, 7, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: classServiceLevelThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: classServiceLevelThreshold.setDescription('The percentage of transactions required NOT to be over threshold. If more than this percentage of transactions in an interval are over threshold, then this Interval is counted in the classIntervalsAboveTotalDelayThreshold variable. The default is 100.')
classTotalDelayTable = MibTable((1, 3, 6, 1, 4, 1, 2334, 2, 1, 7, 2), )
if mibBuilder.loadTexts: classTotalDelayTable.setStatus('mandatory')
if mibBuilder.loadTexts: classTotalDelayTable.setDescription("A list of traffic class aggregate delay entries. The table is indexed by two variables: the classIndex from classTable, and the lower limit of the bucket, in milliseconds. The histogram for any given class 'i' may thus be retrieved via GetNext of classTotalDelayBucketCount.i.0")
classTotalDelayEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2334, 2, 1, 7, 2, 1), ).setIndexNames((0, "PACKETEER-MIB", "classIndex"), (0, "PACKETEER-RTM-MIB", "classTotalDelayBucketLimit"))
if mibBuilder.loadTexts: classTotalDelayEntry.setStatus('mandatory')
if mibBuilder.loadTexts: classTotalDelayEntry.setDescription('An entry containing the count of observed network transactions in a given bucket. ')
classTotalDelayBucketLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 2334, 2, 1, 7, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: classTotalDelayBucketLimit.setStatus('mandatory')
if mibBuilder.loadTexts: classTotalDelayBucketLimit.setDescription("The lower limit, in milliseconds, of this bucket. NOTE: although the bucket limits are given for each class, this does NOT imply that they are different, and in fact they are the same for all classes. This is done to facilitate GetNext'ing through the table; for example the count of the next bucket larger than 1 second for class 'i' can be obtained by GetNext classTotalDelayBucketCount.i.1000. The complete histogram for class i, with the limits for each bucket, can be obtained by GetNext classTotalDelayBucketCount.i ")
classTotalDelayBucketCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2334, 2, 1, 7, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: classTotalDelayBucketCount.setStatus('mandatory')
if mibBuilder.loadTexts: classTotalDelayBucketCount.setDescription('The count of transactions whose aggregate delay fell in this bucket. Transactions are defined according to classTransactionDefinition.')
classNetworkDelayTable = MibTable((1, 3, 6, 1, 4, 1, 2334, 2, 1, 7, 3), )
if mibBuilder.loadTexts: classNetworkDelayTable.setStatus('mandatory')
if mibBuilder.loadTexts: classNetworkDelayTable.setDescription("A list of traffic class network delay entries. The table is indexed by two variables: the classIndex from classTable, and the lower limit of the bucket, in milliseconds. The histogram for any given class 'i' may thus be retrieved via GetNext of classNetworkDelayBucketCount.i.0")
classNetworkDelayEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2334, 2, 1, 7, 3, 1), ).setIndexNames((0, "PACKETEER-MIB", "classIndex"), (0, "PACKETEER-RTM-MIB", "classNetworkDelayBucketLimit"))
if mibBuilder.loadTexts: classNetworkDelayEntry.setStatus('mandatory')
if mibBuilder.loadTexts: classNetworkDelayEntry.setDescription('An entry containing the count of observed network delay transactions in a given bucket. Transactions are defined according to classTransactionDefinition.')
classNetworkDelayBucketLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 2334, 2, 1, 7, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: classNetworkDelayBucketLimit.setStatus('mandatory')
if mibBuilder.loadTexts: classNetworkDelayBucketLimit.setDescription("The lower limit, in milliseconds, of this bucket. NOTE: although the bucket limits are given for each class, this does NOT imply that they are different, and in fact they are the same for all classes. This is done to facilitate GetNext'ing through the table; for example the count of the next bucket larger than 1 second for class 'i' can be obtained by GetNext classNetworkDelayBucketCount.i.1000. The complete histogram for class i, with the limits for each bucket, can be obtained by GetNext classNetworkDelayBucketCount.i ")
classNetworkDelayBucketCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2334, 2, 1, 7, 3, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: classNetworkDelayBucketCount.setStatus('mandatory')
if mibBuilder.loadTexts: classNetworkDelayBucketCount.setDescription('The count of observed network transactions for the class in this bucket. Transactions are defined according to classTransactionDefinition.')
classServerDelayTable = MibTable((1, 3, 6, 1, 4, 1, 2334, 2, 1, 7, 4), )
if mibBuilder.loadTexts: classServerDelayTable.setStatus('mandatory')
if mibBuilder.loadTexts: classServerDelayTable.setDescription("A list of traffic class Server delay entries. The table is indexed by two variables: the classIndex from classTable, and the lower limit of the bucket, in milliseconds. The histogram for any given class 'i' may thus be retrieved via GetNext of classServerDelayBucketCount.i.0")
classServerDelayEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2334, 2, 1, 7, 4, 1), ).setIndexNames((0, "PACKETEER-MIB", "classIndex"), (0, "PACKETEER-RTM-MIB", "classServerDelayBucketLimit"))
if mibBuilder.loadTexts: classServerDelayEntry.setStatus('mandatory')
if mibBuilder.loadTexts: classServerDelayEntry.setDescription('An entry containing the count of observed network transactions in a given bucket. ')
classServerDelayBucketLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 2334, 2, 1, 7, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: classServerDelayBucketLimit.setStatus('mandatory')
if mibBuilder.loadTexts: classServerDelayBucketLimit.setDescription("The lower limit, in milliseconds, of this bucket. NOTE: although the bucket limits are given for each class, this does NOT imply that they are different, and in fact they are the same for all classes. This is done to facilitate GetNext'ing through the table; for example the count of the next bucket larger than 1 second for class 'i' can be obtained by GetNext classServerDelayBucketCount.i.1000. The complete histogram for class i, with the limits for each bucket, can be obtained by GetNext classServerDelayBucketCount.i ")
classServerDelayBucketCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2334, 2, 1, 7, 4, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: classServerDelayBucketCount.setStatus('mandatory')
if mibBuilder.loadTexts: classServerDelayBucketCount.setDescription('The count of observed network transactions for the class in this bucket. Transactions are defined according to classTransactionDefinition.')
classRTMTable = MibTable((1, 3, 6, 1, 4, 1, 2334, 2, 1, 7, 5), )
if mibBuilder.loadTexts: classRTMTable.setStatus('mandatory')
if mibBuilder.loadTexts: classRTMTable.setDescription('A table of readonly Response Time Management information about this class. All non-histogram information about RTM is kept in this table.')
classRTMEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2334, 2, 1, 7, 5, 1), ).setIndexNames((0, "PACKETEER-MIB", "classIndex"))
if mibBuilder.loadTexts: classRTMEntry.setStatus('mandatory')
if mibBuilder.loadTexts: classRTMEntry.setDescription('An entry containing readonly Response Time Management information about this class.')
classTotalDelayMedian = MibTableColumn((1, 3, 6, 1, 4, 1, 2334, 2, 1, 7, 5, 1, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: classTotalDelayMedian.setStatus('mandatory')
if mibBuilder.loadTexts: classTotalDelayMedian.setDescription('The median aggregate delay for this class, in milliseconds. Medians are calculated by an approximate method using the above histogram, whose error is at most 1/2 of the time interval spanned by the bucket into which the exact median falls.')
classTotalDelayAverage = MibTableColumn((1, 3, 6, 1, 4, 1, 2334, 2, 1, 7, 5, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: classTotalDelayAverage.setStatus('mandatory')
if mibBuilder.loadTexts: classTotalDelayAverage.setDescription('The average aggregate delay for this class, in milliseconds. Use the average in conjunction with the median, since averages can be distorted by a few very large samples.')
classTransactionsAboveTotalDelayThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 2334, 2, 1, 7, 5, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: classTransactionsAboveTotalDelayThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: classTransactionsAboveTotalDelayThreshold.setDescription('The number of network transactions whose aggregate delay was greater than the value of classTotalDelayThreshold. Transactions are defined according to classTransactionDefinition.')
classIntervalsAboveServiceLevelThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 2334, 2, 1, 7, 5, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: classIntervalsAboveServiceLevelThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: classIntervalsAboveServiceLevelThreshold.setDescription("The number of intervals over the aggregate delay threshold, defined as those intervals with 'classIntervalServiceLevelThreshold'% or fewer transactions with aggregate delay less than 'classTotalDelayThreshold'.")
classLastIntervalAboveServiceLevelThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 2334, 2, 1, 7, 5, 1, 5), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: classLastIntervalAboveServiceLevelThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: classLastIntervalAboveServiceLevelThreshold.setDescription('The time at which the last interval ended which failed the service level threshold, in other words, the interval in which classIntervalServiceLevelThreshold% of the total transactions, or fewer, had total response times less than classTotalDelayThreshold. If there was no such interval, then this is set to a zero value.')
classServerDelayMedian = MibTableColumn((1, 3, 6, 1, 4, 1, 2334, 2, 1, 7, 5, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: classServerDelayMedian.setStatus('mandatory')
if mibBuilder.loadTexts: classServerDelayMedian.setDescription('The median server delay for this class, in milliseconds. Medians are calculated by an approximate method using the above histogram, whose error is at most 1/2 of the time interval spanned by the bucket into which the exact median falls.')
classServerDelayAverage = MibTableColumn((1, 3, 6, 1, 4, 1, 2334, 2, 1, 7, 5, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: classServerDelayAverage.setStatus('mandatory')
if mibBuilder.loadTexts: classServerDelayAverage.setDescription('The average server delay for this class, in milliseconds. Use the average in conjunction with the median, since averages can be distorted by a few very large samples.')
classNetworkDelayMedian = MibTableColumn((1, 3, 6, 1, 4, 1, 2334, 2, 1, 7, 5, 1, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: classNetworkDelayMedian.setStatus('mandatory')
if mibBuilder.loadTexts: classNetworkDelayMedian.setDescription('The median network delay for this class, in milliseconds. Medians are calculated by an approximate method using the above histogram, whose error is at most 1/2 of the time interval spanned by the bucket into which the exact median falls.')
classNetworkDelayAverage = MibTableColumn((1, 3, 6, 1, 4, 1, 2334, 2, 1, 7, 5, 1, 12), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: classNetworkDelayAverage.setStatus('mandatory')
if mibBuilder.loadTexts: classNetworkDelayAverage.setDescription('The average network delay for this class, in milliseconds. Use the average in conjunction with the median, since averages can be distorted by a few very large samples.')
classTransactionBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 2334, 2, 1, 7, 5, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: classTransactionBytes.setStatus('mandatory')
if mibBuilder.loadTexts: classTransactionBytes.setDescription('The total number of bytes on this class involved in transactions, and thus eligible for RTM. Dividing this value by classTransactionsTotal provides the average size of a transaction for the class. This variable represents the low-order portion of a 64-bit value.')
classTransactionBytesHi = MibTableColumn((1, 3, 6, 1, 4, 1, 2334, 2, 1, 7, 5, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: classTransactionBytesHi.setStatus('mandatory')
if mibBuilder.loadTexts: classTransactionBytesHi.setDescription('The total number of bytes on this class involved in transactions, and thus eligible for RTM. Dividing this value by classTransactionsTotal provides the average size of a transaction for the class. This variable represents the high-order portion of a 64-bit value.')
classRoundTripTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2334, 2, 1, 7, 5, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: classRoundTripTime.setStatus('mandatory')
if mibBuilder.loadTexts: classRoundTripTime.setDescription('The time, in milliseconds, of a network round-trip, per transaction. Dividing this value by classTransactionsTotal gives an indication of the effective speed of the network for this class, which includes factors like queueing and retransmissions that may be controllable. This variable represents the low-order portion of a 64-bit value.')
classRoundTripTimeHi = MibTableColumn((1, 3, 6, 1, 4, 1, 2334, 2, 1, 7, 5, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: classRoundTripTimeHi.setStatus('mandatory')
if mibBuilder.loadTexts: classRoundTripTimeHi.setDescription('The time, in milliseconds, of a network round-trip, per transaction. Dividing this value by classTransactionsTotal gives an indication of the effective speed of the network for this class, which includes factors like queueing and retransmissions that may be controllable. This variable represents the high-order portion of a 64-bit value.')
classTransactionsTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 2334, 2, 1, 7, 5, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: classTransactionsTotal.setStatus('mandatory')
if mibBuilder.loadTexts: classTransactionsTotal.setDescription('The total number of transactions for this class. ')
classTotalDelayMsec = MibTableColumn((1, 3, 6, 1, 4, 1, 2334, 2, 1, 7, 5, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: classTotalDelayMsec.setStatus('mandatory')
if mibBuilder.loadTexts: classTotalDelayMsec.setDescription('The time, in milliseconds, of total delay, per transaction. This variable represents the low-order portion of a 64-bit value.')
classTotalDelayMsecHi = MibTableColumn((1, 3, 6, 1, 4, 1, 2334, 2, 1, 7, 5, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: classTotalDelayMsecHi.setStatus('mandatory')
if mibBuilder.loadTexts: classTotalDelayMsecHi.setDescription('The time, in milliseconds, of total delay, per transaction. This variable represents the high-order portion of a 64-bit value.')
classServerDelayMsec = MibTableColumn((1, 3, 6, 1, 4, 1, 2334, 2, 1, 7, 5, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: classServerDelayMsec.setStatus('mandatory')
if mibBuilder.loadTexts: classServerDelayMsec.setDescription('The time, in milliseconds, of server delay, per transaction. This variable represents the low-order portion of a 64-bit value.')
classServerDelayMsecHi = MibTableColumn((1, 3, 6, 1, 4, 1, 2334, 2, 1, 7, 5, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: classServerDelayMsecHi.setStatus('mandatory')
if mibBuilder.loadTexts: classServerDelayMsecHi.setDescription('The time, in milliseconds, of server delay, per transaction. This variable represents the high-order portion of a 64-bit value.')
classNetworkDelayMsec = MibTableColumn((1, 3, 6, 1, 4, 1, 2334, 2, 1, 7, 5, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: classNetworkDelayMsec.setStatus('mandatory')
if mibBuilder.loadTexts: classNetworkDelayMsec.setDescription('The time, in milliseconds, of network delay, per transaction. This variable represents the low-order portion of a 64-bit value.')
classNetworkDelayMsecHi = MibTableColumn((1, 3, 6, 1, 4, 1, 2334, 2, 1, 7, 5, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: classNetworkDelayMsecHi.setStatus('mandatory')
if mibBuilder.loadTexts: classNetworkDelayMsecHi.setDescription('The time, in milliseconds, of network delay, per transaction. This variable represents the high-order portion of a 64-bit value.')
classWorstServerTable = MibTable((1, 3, 6, 1, 4, 1, 2334, 2, 1, 7, 6), )
if mibBuilder.loadTexts: classWorstServerTable.setStatus('mandatory')
if mibBuilder.loadTexts: classWorstServerTable.setDescription("A list of the N servers which have handled more than M transactions, and are experiencing the worst behavior with respect to the response time threshold, if one has been set. 'N' and 'M' are fixed limits for any given release of PacketShaper software and are not settable. In release 4.0, N and M are 10. The table is ordered by classIndex and classWorstServerIndex.")
classWorstServerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2334, 2, 1, 7, 6, 1), ).setIndexNames((0, "PACKETEER-MIB", "classIndex"), (0, "PACKETEER-RTM-MIB", "classWorstServerIndex"))
if mibBuilder.loadTexts: classWorstServerEntry.setStatus('mandatory')
if mibBuilder.loadTexts: classWorstServerEntry.setDescription('An entry describing a server experiencing the worst behavior with respect to the response time threshold.')
classWorstServerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2334, 2, 1, 7, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: classWorstServerIndex.setStatus('mandatory')
if mibBuilder.loadTexts: classWorstServerIndex.setDescription('A unique index from 1 to N, where N is a fixed limit, and a lower value denotes a lower ratio of good transactions.')
classWorstServerAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2334, 2, 1, 7, 6, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: classWorstServerAddress.setStatus('mandatory')
if mibBuilder.loadTexts: classWorstServerAddress.setDescription('The address of this server.')
classWorstServerTransactionCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2334, 2, 1, 7, 6, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: classWorstServerTransactionCount.setStatus('mandatory')
if mibBuilder.loadTexts: classWorstServerTransactionCount.setDescription('The number of transactions recorded for this server.')
classWorstClientTable = MibTable((1, 3, 6, 1, 4, 1, 2334, 2, 1, 7, 7), )
if mibBuilder.loadTexts: classWorstClientTable.setStatus('mandatory')
if mibBuilder.loadTexts: classWorstClientTable.setDescription("A list of the N clients which have handled more than M transactions, and are experiencing the worst behavior with respect to the response time threshold, if one has been set. 'N' and 'M' are fixed limits for any given release of PacketShaper software and are not settable. In release 4.0, N and M are 10. The table is ordered by classIndex and classWorstClientIndex.")
classWorstClientEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2334, 2, 1, 7, 7, 1), ).setIndexNames((0, "PACKETEER-MIB", "classIndex"), (0, "PACKETEER-RTM-MIB", "classWorstClientIndex"))
if mibBuilder.loadTexts: classWorstClientEntry.setStatus('mandatory')
if mibBuilder.loadTexts: classWorstClientEntry.setDescription('An entry describing a client experiencing the most sessions over the response time threshold.')
classWorstClientIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2334, 2, 1, 7, 7, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: classWorstClientIndex.setStatus('mandatory')
if mibBuilder.loadTexts: classWorstClientIndex.setDescription('A unique index from 1 to N, where N is a fixed limit, and a lower value denotes a higher value of classWorstClientSessionCount.')
classWorstClientAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2334, 2, 1, 7, 7, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: classWorstClientAddress.setStatus('mandatory')
if mibBuilder.loadTexts: classWorstClientAddress.setDescription('The address of this client.')
classWorstClientTransactionCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2334, 2, 1, 7, 7, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: classWorstClientTransactionCount.setStatus('mandatory')
if mibBuilder.loadTexts: classWorstClientTransactionCount.setDescription('The number of transactions recorded for this client.')
mibBuilder.exportSymbols("PACKETEER-RTM-MIB", classLastIntervalAboveServiceLevelThreshold=classLastIntervalAboveServiceLevelThreshold, classTransactionsTotal=classTransactionsTotal, classWorstServerTransactionCount=classWorstServerTransactionCount, classNetworkDelayMsec=classNetworkDelayMsec, classNetworkDelayTable=classNetworkDelayTable, classTransactionBytesHi=classTransactionBytesHi, classTotalDelayMedian=classTotalDelayMedian, classWorstServerEntry=classWorstServerEntry, classWorstClientIndex=classWorstClientIndex, classTotalDelayThreshold=classTotalDelayThreshold, classWorstClientAddress=classWorstClientAddress, classWorstServerTable=classWorstServerTable, classRTMConfigTable=classRTMConfigTable, classWorstClientTransactionCount=classWorstClientTransactionCount, classTotalDelayMsecHi=classTotalDelayMsecHi, classServerDelayMsec=classServerDelayMsec, classNetworkDelayMedian=classNetworkDelayMedian, classTransactionBytes=classTransactionBytes, classNetworkDelayAverage=classNetworkDelayAverage, classRoundTripTimeHi=classRoundTripTimeHi, classTransactionsAboveTotalDelayThreshold=classTransactionsAboveTotalDelayThreshold, classTotalDelayAverage=classTotalDelayAverage, classTotalDelayBucketCount=classTotalDelayBucketCount, classServiceLevelThreshold=classServiceLevelThreshold, classRoundTripTime=classRoundTripTime, classWorstServerAddress=classWorstServerAddress, classTotalDelayTable=classTotalDelayTable, classServerDelayBucketCount=classServerDelayBucketCount, classNetworkDelayBucketLimit=classNetworkDelayBucketLimit, classIntervalsAboveServiceLevelThreshold=classIntervalsAboveServiceLevelThreshold, classWorstServerIndex=classWorstServerIndex, classTotalDelayBucketLimit=classTotalDelayBucketLimit, classServerDelayTable=classServerDelayTable, classTotalDelayEntry=classTotalDelayEntry, classRTMEntry=classRTMEntry, classRTMConfigEntry=classRTMConfigEntry, classServerDelayAverage=classServerDelayAverage, classServerDelayBucketLimit=classServerDelayBucketLimit, classWorstClientTable=classWorstClientTable, classNetworkDelayBucketCount=classNetworkDelayBucketCount, classRTMTable=classRTMTable, classWorstClientEntry=classWorstClientEntry, psClassResponseTimes=psClassResponseTimes, classNetworkDelayEntry=classNetworkDelayEntry, classNetworkDelayMsecHi=classNetworkDelayMsecHi, classTotalDelayMsec=classTotalDelayMsec, classServerDelayMedian=classServerDelayMedian, classServerDelayMsecHi=classServerDelayMsecHi, classServerDelayEntry=classServerDelayEntry)

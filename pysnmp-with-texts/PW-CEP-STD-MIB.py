#
# PySNMP MIB module PW-CEP-STD-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/PW-CEP-STD-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:42:41 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsIntersection, ValueSizeConstraint, ConstraintsUnion, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsIntersection", "ValueSizeConstraint", "ConstraintsUnion", "ValueRangeConstraint")
HCPerfTimeElapsed, HCPerfValidIntervals, HCPerfIntervalCount, HCPerfCurrentCount = mibBuilder.importSymbols("HC-PerfHist-TC-MIB", "HCPerfTimeElapsed", "HCPerfValidIntervals", "HCPerfIntervalCount", "HCPerfCurrentCount")
InterfaceIndex, InterfaceIndexOrZero = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex", "InterfaceIndexOrZero")
pwIndex, = mibBuilder.importSymbols("PW-STD-MIB", "pwIndex")
PwCfgIndexOrzero, = mibBuilder.importSymbols("PW-TC-STD-MIB", "PwCfgIndexOrzero")
PerfIntervalCount, PerfCurrentCount = mibBuilder.importSymbols("PerfHist-TC-MIB", "PerfIntervalCount", "PerfCurrentCount")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
NotificationGroup, ObjectGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ObjectGroup", "ModuleCompliance")
IpAddress, Counter64, iso, Unsigned32, mib_2, Integer32, ObjectIdentity, Counter32, ModuleIdentity, MibIdentifier, Gauge32, Bits, MibScalar, MibTable, MibTableRow, MibTableColumn, NotificationType, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "IpAddress", "Counter64", "iso", "Unsigned32", "mib-2", "Integer32", "ObjectIdentity", "Counter32", "ModuleIdentity", "MibIdentifier", "Gauge32", "Bits", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "NotificationType", "TimeTicks")
DisplayString, TruthValue, RowStatus, StorageType, TimeStamp, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TruthValue", "RowStatus", "StorageType", "TimeStamp", "TextualConvention")
pwCepStdMIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 200))
pwCepStdMIB.setRevisions(('2011-05-16 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: pwCepStdMIB.setRevisionsDescriptions(('This MIB module published as part of RFC 6240.',))
if mibBuilder.loadTexts: pwCepStdMIB.setLastUpdated('201105160000Z')
if mibBuilder.loadTexts: pwCepStdMIB.setOrganization('Pseudowire Emulation Edge-to-Edge (PWE3) Working Group')
if mibBuilder.loadTexts: pwCepStdMIB.setContactInfo('David Zelig (Ed.) Email: david_zelig@pmc-sierra.com Ron Cohen (Ed.) Email: ronc@resolutenetworks.com Thomas D. Nadeau (Ed.) Email: Thomas.Nadeau@ca.com The PWE3 Working Group Email: pwe3@ietf.org (email distribution) http://www.ietf.org/html.charters/pwe3-charter.html')
if mibBuilder.loadTexts: pwCepStdMIB.setDescription("This MIB module contains managed object definitions for Circuit Emulation over Packet (CEP) as in [RFC4842]: Malis, A., Prayson, P., Cohen, R., and D. Zelig. 'Synchronous Optical Network/Synchronous Digital Hierarchy (SONET/SDH) Circuit Emulation over Packet (CEP)', RFC 4842. Copyright (c) 2011 IETF Trust and the persons identified as authors of the code. All rights reserved. Redistribution and use in source and binary forms, with or without modification, is permitted pursuant to, and subject to the license terms contained in, the Simplified BSD License set forth in Section 4.c of the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info).")
class PwCepSonetEbm(TextualConvention, Unsigned32):
    description = 'Equipped Bit Mask (EBM) used for fractional STS-1/Virtual Circuit 3 (VC-3). The EBM bits are the 28 least significant bits out of the 32-bit value.'
    status = 'current'

class PwCepSdhVc4Ebm(TextualConvention, Unsigned32):
    description = 'Equipped Bit Mask (EBM) used for each Tributary Unit Group 3 (TUG-3) in fractional VC-4 circuits. The EBM bits are the 30 least significant bits out of the 32-bit value.'
    status = 'current'

class PwCepSonetVtgMap(TextualConvention, Unsigned32):
    description = 'The VT/VC types carried in the 7 VT groups (VTGs)/TUG-2s. The format is 28 bits in the form of an Equipped Bit Mask (EBM) for fractional STS-1/VC-3. The mapping specifies the maximal occupancies of VT/VC within each VTG/TUG-2. For example, all four bits are set to 1 in this object to represent a VTG carrying VT1.5/VC11s, while only three are set when VT2/VC12s are carried within this VTG. The relevant bits are the 28 least significant bits out of the 32-bit value.'
    status = 'current'

class PwCepFracAsyncMap(TextualConvention, Integer32):
    description = 'The type of asynchronous mapping carried inside STS-1, VC-3, or TUG-3 containing TU-3 circuit.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("other", 1), ("ds3", 2), ("e3", 3))

pwCepObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 200, 1))
pwCepConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 200, 2))
pwCepTable = MibTable((1, 3, 6, 1, 2, 1, 200, 1, 1), )
if mibBuilder.loadTexts: pwCepTable.setStatus('current')
if mibBuilder.loadTexts: pwCepTable.setDescription('This table contains objects and parameters for managing and monitoring the CEP PW.')
pwCepEntry = MibTableRow((1, 3, 6, 1, 2, 1, 200, 1, 1, 1), ).setIndexNames((0, "PW-STD-MIB", "pwIndex"))
if mibBuilder.loadTexts: pwCepEntry.setStatus('current')
if mibBuilder.loadTexts: pwCepEntry.setDescription("Each entry represents the association of a SONET/SDH path or VT to a PW. This table is indexed by the pwIndex of the applicable PW entry in the pwTable. An entry is created in this table by the agent for every entry in the pwTable with a pwType equal to 'cep'. All read-write objects in this table MAY be changed at any time; however, change of some objects (for example pwCepCfgIndex) during PW forwarding state may cause traffic disruption. Manual entries in this table SHOULD be preserved after a reboot. The agent MUST ensure the integrity of those entries. If the set of entries of a specific row are found to be inconsistent after reboot, the PW pwOperStatus MUST be declared as notPresent(5).")
pwCepType = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("spe", 1), ("vt", 2), ("fracSpe", 3))).clone('spe')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pwCepType.setStatus('current')
if mibBuilder.loadTexts: pwCepType.setDescription("Specifies the sub-type of CEP PW. Currently only structured types are supported: 'spe'(1) : SONET STS-Nc signals. 'vt' (2) : SONET VT-x (x=1.5,2,3,6) signals. 'fracSpe' (3) : SONET fractional STS-1 or SDH fractional VC-3 or VC-4 carrying tributaries or asynchronous signals. Support of 'vt' mode or 'fracSpe' mode is optional.")
pwCepSonetIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 1, 1, 2), InterfaceIndexOrZero()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pwCepSonetIfIndex.setStatus('current')
if mibBuilder.loadTexts: pwCepSonetIfIndex.setDescription('This is a unique index within the ifTable. It represents the interface index for the SONET path for SPE emulation ([RFC3592], Section 3.3), an interface index for the SONET VT ([RFC3592], Section 3.4) if the VT to be emulated is extracted from a SONET signal or locally mapped from a physical interface. A value of zero indicates an interface index that has yet to be determined. Once set, if the SONET ifIndex is (for some reason) later removed, the agent MAY delete the associated PW rows (e.g., this pwCepTableEntry). If the agent does not delete the rows, it is RECOMMENDED that the agent set this object to zero.')
pwCepSonetConfigErrorOrStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 1, 1, 3), Bits().clone(namedValues=NamedValues(("other", 0), ("timeslotInUse", 1), ("timeslotMisuse", 2), ("peerDbaIncompatible", 3), ("peerEbmIncompatible", 4), ("peerRtpIncompatible", 5), ("peerAsyncIncompatible", 6), ("peerDbaAsymmetric", 7), ("peerEbmAsymmetric", 8), ("peerRtpAsymmetric", 9), ("peerAsyncAsymmetric", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepSonetConfigErrorOrStatus.setReference("Malis, A., et al., 'Synchronous Optical Network/Synchronous Digital Hierarchy (SONET/SDH) Circuit Emulation over Packet (CEP)', RFC 4842, Section 12.")
if mibBuilder.loadTexts: pwCepSonetConfigErrorOrStatus.setStatus('current')
if mibBuilder.loadTexts: pwCepSonetConfigErrorOrStatus.setDescription("This object reports a configuration mismatch inside the local node or between the local node and the peer node. Some bits indicate an error, and some are simply status reports that do not affect the forwarding process. 'timeslotInUse'(1) is set when another CEP PW has already reserved a timeslot (or timeslots) that this CEP PW is attempting to reserve. 'timeslotMisuse'(2) is set when the stated timeslot this PW is trying to use is not legal, for example, if specifying a starting timeslot of 45 for a SONET path of an STS-12c width. The peerZZZIncompatible bits are set if the local configuration is not compatible with the peer configuration as available from the CEP option received from the peer through the signaling process and the local node cannot support such asymmetric configuration. The peerZZZAsymmetric bits are set if the local configuration is not compatible with the peer configuration as available from the CEP option received from the peer through the signaling process, but the local node can support such asymmetric configuration.")
pwCepCfgIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 1, 1, 4), PwCfgIndexOrzero()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pwCepCfgIndex.setStatus('current')
if mibBuilder.loadTexts: pwCepCfgIndex.setDescription('Index to CEP configuration table below. Multiple CEP PWs MAY share a single pwCepCfgEntry. The value 0 indicates that no entries are available.')
pwCepTimeElapsed = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 1, 1, 5), HCPerfTimeElapsed()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepTimeElapsed.setStatus('current')
if mibBuilder.loadTexts: pwCepTimeElapsed.setDescription("The number of seconds, including partial seconds, that have elapsed since the beginning of the current measurement period. If, for some reason such as an adjustment in the system's time-of-day clock, the current interval exceeds the maximum value, the agent will return the maximum value.")
pwCepValidIntervals = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 1, 1, 6), HCPerfValidIntervals()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepValidIntervals.setStatus('current')
if mibBuilder.loadTexts: pwCepValidIntervals.setDescription('The number (n) of previous 15-minute intervals for which data was collected. An agent with CEP capability MUST be capable of supporting at least 4 intervals. The RECOMMENDED default value for n is 32, and n MUST NOT exceed 96.')
pwCepIndications = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 1, 1, 7), Bits().clone(namedValues=NamedValues(("missingPkt", 0), ("ooRngDropped", 1), ("jtrBfrUnder", 2), ("pktMalformed", 3), ("lops", 4), ("cepRdi", 5), ("cepAis", 6), ("badHdrStack", 7), ("cepNeFailure", 8), ("cepFeFailure", 9)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pwCepIndications.setStatus('current')
if mibBuilder.loadTexts: pwCepIndications.setDescription("Definitions: 'missingPkt'(0) - While playing out a sequence of packets, at least one packet was determined to be missing based on a gap in the CEP sequence number. Note: If the implementation supports packet reordering, detecting gaps SHOULD take place as they are played out, not as they arrive. This provides time for misordered packets to arrive late. 'ooRngDropped'(1) - At least one packet arrived outside the range of the jitter buffer. This may be because the jitter buffer is full or the sequence number addresses a buffer outside the current jitter buffer range or an already occupied buffer within range. Whether or not packet reordering is supported by the implementation, this indication MUST be supported. 'jtrBfrUnder'(2) - The jitter buffer underflowed because not enough packets arrived as packets were being played out. 'pktMalformed'(3) - Any error related to unexpected packet format (except bad header stack) or unexpected length. 'lops'(4) - Loss of Packet Synchronization. 'cepRdi'(5) - Circuit Emulation over Packet Remote Defect Indication. Remote Defect Indication (RDI) is generated by the remote CEP de-packetizer when LOPS is detected. 'cepAis'(6) - Remote CEP packetizer has detected an Alarm Indication Signal (AIS) on its incoming SONET stream. cepAis MUST NOT (in itself) cause a CEP PW down notification. 'badHdrStack'(7) - Set when the number of CEP header extensions detected in incoming packets does not match the expected number. 'cepNeFailure'(8) - Set when CEP-NE failure is currently declared. 'cepFeFailure'(8) - Set when CEP-FE failure is currently declared. This object MUST hold the accumulated indications until the next SNMP write that clear the indication(s). Writing a non-zero value MUST fail. Currently, there is no hierarchy of CEP defects. The algorithm used to capture these indications is implementation specific.")
pwCepLastEsTimeStamp = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 1, 1, 8), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepLastEsTimeStamp.setStatus('current')
if mibBuilder.loadTexts: pwCepLastEsTimeStamp.setDescription('The value of sysUpTime on the most recent occasion at which the CEP PW entered the Errored Seconds (ES) or Severely Errored Seconds (SES) state.')
pwCepPeerCepOption = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 1, 1, 9), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepPeerCepOption.setStatus('current')
if mibBuilder.loadTexts: pwCepPeerCepOption.setDescription('The value of the CEP option parameter as received from the peer by the PW signaling protocol.')
pwCepCfgIndexNext = MibScalar((1, 3, 6, 1, 2, 1, 200, 1, 2), PwCfgIndexOrzero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepCfgIndexNext.setStatus('current')
if mibBuilder.loadTexts: pwCepCfgIndexNext.setDescription('This object contains an appropriate value to be used for pwCepCfgIndex when creating entries in the pwCepCfgTable. The value 0 indicates that no unassigned entries are available. To obtain the value of pwCepCfgIndex for a new entry in the pwCepCfgTable, the manager issues a management protocol retrieval operation to obtain the current value of pwCepCfgIndex. After each retrieval operation, the agent should modify the value to reflect the next unassigned index. After a manager retrieves a value, the agent will determine through its local policy when this index value will be made available for reuse.')
pwCepCfgTable = MibTable((1, 3, 6, 1, 2, 1, 200, 1, 3), )
if mibBuilder.loadTexts: pwCepCfgTable.setStatus('current')
if mibBuilder.loadTexts: pwCepCfgTable.setDescription('This table contains a set of parameters that may be referenced by one or more CEP PWs by pwCepTable.')
pwCepCfgEntry = MibTableRow((1, 3, 6, 1, 2, 1, 200, 1, 3, 1), ).setIndexNames((0, "PW-CEP-STD-MIB", "pwCepCfgTableIndex"))
if mibBuilder.loadTexts: pwCepCfgEntry.setStatus('current')
if mibBuilder.loadTexts: pwCepCfgEntry.setDescription("These parameters define the characteristics of a CEP PW. They are grouped here to ease Network Management System (NMS) burden. Once an entry is created here, it may be reused by many PWs. By default, all the read-create objects MUST NOT be changed after row activation unless specifically indicated in the individual object description. If the operator wishes to change value of a read-create object, the pwCepCfgRowStatus MUST be set to notInService(2). The agent MUST NOT allow the change of the pwCepCfgRowStatus from the active(1) state for pwCepCfgEntry, which is in use by at least one active PW. Manual entries in this table SHOULD be preserved after a reboot, the agent MUST ensure the integrity of those entries. If the set of entries of a specific row are found to be inconsistent after reboot, the affected PWs' pwOperStatus MUST be declared as notPresent(5).")
pwCepCfgTableIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 3, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: pwCepCfgTableIndex.setStatus('current')
if mibBuilder.loadTexts: pwCepCfgTableIndex.setDescription('Primary index to this table.')
pwCepSonetPayloadLength = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 3, 1, 2), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwCepSonetPayloadLength.setReference("Malis, A., et al., 'Synchronous Optical Network/Synchronous Digital Hierarchy (SONET/SDH) Circuit Emulation over Packet (CEP)', RFC 4842, Sections 5.1 and 12.1")
if mibBuilder.loadTexts: pwCepSonetPayloadLength.setStatus('current')
if mibBuilder.loadTexts: pwCepSonetPayloadLength.setDescription('The number of SONET bytes of the Path or VT carried as payload within one packet. For example, for STS-1/VC-3 SPE circuits, a value of 783 bytes indicates that each packet carries the payload equivalent to one frame. For VT1.5/VC11 circuits, a payload length of 104 bytes indicates that each packet carries payload equivalent to one VT1.5 super-frame. The actual payload size may be different due to bandwidth reduction modes, e.g., Dynamic Bandwidth Allocation (DBA) mode or dynamically assigned fractional SPE. This length applies to inbound and outbound packets carrying user payload. Although there is no control over inbound packets, those of illegal length are discarded and accounted for (see pwCepPerf...Malformed.) The default values are determined by the pwCepType: 783 for pwCepType equal to spe(2) or fracSpe(3). For vt(3) modes, the applicable super-frame payload size is the default value.')
pwCepCfgMinPktLength = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 3, 1, 3), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwCepCfgMinPktLength.setStatus('current')
if mibBuilder.loadTexts: pwCepCfgMinPktLength.setDescription("This object defines the minimum CEP packet length in number of bytes (including CEP header and payload). It applies to CEP's bandwidth-savings packets. Currently, DBA is the only bandwidth-savings packet type (in the future, CEP may support compression). Minimum packet length is necessary in some systems or networks. Setting zero here indicates that there is no minimum packet restriction.")
pwCepCfgPktReorder = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 3, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepCfgPktReorder.setStatus('current')
if mibBuilder.loadTexts: pwCepCfgPktReorder.setDescription("This object defines if reordering is applied for incoming packets. If set 'true', as inbound packets are queued in the jitter buffer, out-of-order packets are reordered. The maximum sequence number differential (i.e., the range in which resequencing can occur) is dependant on the depth of the jitter buffer. If the local agent supports packet reordering, the default value SHOULD be set to 'true'; otherwise, this value SHOULD be set to 'false'.")
pwCepCfgEnableDBA = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 3, 1, 5), Bits().clone(namedValues=NamedValues(("ais", 0), ("unequipped", 1)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwCepCfgEnableDBA.setReference("Malis, A., et al., 'Synchronous Optical Network/Synchronous Digital Hierarchy (SONET/SDH) Circuit Emulation over Packet (CEP)', RFC 4842, Section 11.1.")
if mibBuilder.loadTexts: pwCepCfgEnableDBA.setStatus('current')
if mibBuilder.loadTexts: pwCepCfgEnableDBA.setDescription("This object defines when DBA is applied for packets sent toward the PSN. Setting 'ais' MUST cause CEP packet payload suppression when AIS is detected on the associated SONET path. Similarly, 'unequipped' MUST cause payload suppression when an unequipped condition is detected on the SONET/SDH PATH/VT. During DBA condition, CEP packets will continue to be sent, but with indicators set in the CEP header instructing the remote to play all ones (for AIS) or all zeros (for unequipped) onto its SONET/SDH path. NOTE: Some implementations may not support this feature. In these cases, this object should be read-only.")
pwCepCfgRtpHdrSuppress = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 3, 1, 6), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwCepCfgRtpHdrSuppress.setReference("Malis, A., et al., 'Synchronous Optical Network/Synchronous Digital Hierarchy (SONET/SDH) Circuit Emulation over Packet (CEP)', RFC 4842, Section 5.3.")
if mibBuilder.loadTexts: pwCepCfgRtpHdrSuppress.setStatus('current')
if mibBuilder.loadTexts: pwCepCfgRtpHdrSuppress.setDescription("If this object is set to 'true', an RTP header is not prepended to the CEP packet.")
pwCepCfgJtrBfrDepth = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 3, 1, 7), Unsigned32()).setUnits('micro-seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwCepCfgJtrBfrDepth.setReference('The control of jitter and wander within digital networks which are based on the synchronous digital hierarchy (SDH), ITU-T Recommendation G.825.')
if mibBuilder.loadTexts: pwCepCfgJtrBfrDepth.setStatus('current')
if mibBuilder.loadTexts: pwCepCfgJtrBfrDepth.setDescription('This object defines the number of microseconds of expected packet delay variation for this CEP PW over the PSN. The actual jitter buffer MUST be at least twice this value for proper operation. If configured to a value not supported by the implementation, the agent MUST reject the SNMP Set operation.')
pwCepCfgConsecPktsInsync = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 3, 1, 8), Unsigned32().clone(2)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwCepCfgConsecPktsInsync.setReference("Malis, A., et al., 'Synchronous Optical Network/Synchronous Digital Hierarchy (SONET/SDH) Circuit Emulation over Packet (CEP)', RFC 4842, Section 6.2.2.")
if mibBuilder.loadTexts: pwCepCfgConsecPktsInsync.setStatus('current')
if mibBuilder.loadTexts: pwCepCfgConsecPktsInsync.setDescription('Consecutive packets with sequential sequence numbers required to exit the LOPS state.')
pwCepCfgConsecMissingOutSync = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 3, 1, 9), Unsigned32().clone(10)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwCepCfgConsecMissingOutSync.setReference("Malis, A., et al., 'Synchronous Optical Network/Synchronous Digital Hierarchy (SONET/SDH) Circuit Emulation over Packet (CEP)', RFC 4842, Section 6.2.2.")
if mibBuilder.loadTexts: pwCepCfgConsecMissingOutSync.setStatus('current')
if mibBuilder.loadTexts: pwCepCfgConsecMissingOutSync.setDescription('Consecutive missing packets required to enter the LOPS state.')
pwCepCfgPktErrorPlayOutValue = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 3, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(255)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwCepCfgPktErrorPlayOutValue.setStatus('current')
if mibBuilder.loadTexts: pwCepCfgPktErrorPlayOutValue.setDescription('This object defines the value played when inbound packets have over/underflowed the jitter buffer or are missing for any reason. This byte pattern is sent (played) on the SONET path.')
pwCepCfgMissingPktsToSes = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 3, 1, 11), Unsigned32().clone(3)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwCepCfgMissingPktsToSes.setReference("Malis, A., et al., 'Synchronous Optical Network/Synchronous Digital Hierarchy (SONET/SDH) Circuit Emulation over Packet (CEP)', RFC 4842, Section 10.1.")
if mibBuilder.loadTexts: pwCepCfgMissingPktsToSes.setStatus('current')
if mibBuilder.loadTexts: pwCepCfgMissingPktsToSes.setDescription('The number of missing packets detected (consecutive or not) within a 1-second window to cause a Severely Errored Second (SES) to be counted.')
pwCepCfgSesToUas = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 3, 1, 12), Unsigned32().clone(10)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwCepCfgSesToUas.setReference("Malis, A., et al., 'Synchronous Optical Network/Synchronous Digital Hierarchy (SONET/SDH) Circuit Emulation over Packet (CEP)', RFC 4842, Section 10.1.")
if mibBuilder.loadTexts: pwCepCfgSesToUas.setStatus('current')
if mibBuilder.loadTexts: pwCepCfgSesToUas.setDescription('The number of consecutive SESs before declaring PW in Unavailable Seconds (UAS) state (at which point pwCepPerfUASs starts counting). The SesToUas default value is 10 seconds. NOTE: Similar to [RFC3592], if the agent chooses to update the various performance statistics in real time, it MUST be prepared to retroactively reduce the ES and SES counts by this value and increase the UAS count by this value when it determines that UAS state has been entered. NOTE: See pwCepPerfSESs and pwCepPerfUASs.')
pwCepCfgSecsToExitUas = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 3, 1, 13), Unsigned32().clone(10)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwCepCfgSecsToExitUas.setReference("Malis, A., et al., 'Synchronous Optical Network/Synchronous Digital Hierarchy (SONET/SDH) Circuit Emulation over Packet (CEP)', RFC 4842, Section 10.1.")
if mibBuilder.loadTexts: pwCepCfgSecsToExitUas.setStatus('current')
if mibBuilder.loadTexts: pwCepCfgSecsToExitUas.setDescription('The number of consecutive nonSESs before declaring PW is NOT in UAS state (at which point pwCepPerfUASs stops counting).')
pwCepCfgName = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 3, 1, 14), SnmpAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwCepCfgName.setStatus('current')
if mibBuilder.loadTexts: pwCepCfgName.setDescription('This variable contains the name of the Configuration entry. This name may be used to help the NMS to display the purpose of the entry.')
pwCepCfgRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 3, 1, 15), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwCepCfgRowStatus.setStatus('current')
if mibBuilder.loadTexts: pwCepCfgRowStatus.setDescription("For creating, modifying, and deleting this row. None of the read-create objects' values can be changed when pwCepCfgRowStatus is in the active(1) state. Changes are allowed when the pwRowStatus is in notInService(2) or notReady(3) states only. If the operator needs to change one of the values for an active row (for example, in order to fix a mismatch in configuration between the local node and the peer), the pwCepCfgRowStatus should be first changed to notInService(2). The objects may be changed now and later changed to active(1) in order to re-initiate the signaling process with the new values in effect. Change of status from the active(1) state or deleting a row SHOULD be blocked by the local agent if the row is referenced by any pwCepEntry those pwRowStatus is in the active(1) state.")
pwCepCfgStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 3, 1, 16), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwCepCfgStorageType.setStatus('current')
if mibBuilder.loadTexts: pwCepCfgStorageType.setDescription('This object indicates the storage type for this row.')
pwCepFracTable = MibTable((1, 3, 6, 1, 2, 1, 200, 1, 4), )
if mibBuilder.loadTexts: pwCepFracTable.setStatus('current')
if mibBuilder.loadTexts: pwCepFracTable.setDescription('This table contains a set of parameters for CEP PWs with pwCepType FRAC type.')
pwCepFracEntry = MibTableRow((1, 3, 6, 1, 2, 1, 200, 1, 4, 1), ).setIndexNames((0, "PW-CEP-STD-MIB", "pwCepFracIndex"))
if mibBuilder.loadTexts: pwCepFracEntry.setStatus('current')
if mibBuilder.loadTexts: pwCepFracEntry.setDescription('There are two options for creating an entry in this table: - By the Element Management System (EMS) in advance for creating the PW. - By the agent automatically when the PW is set up. The first option is typically used when there is a native service processing (NSP) cross-connect option between the physical ports and the emulated (virtual ports), while the second MAY be used when there is a one-to-one mapping between the emulated signal and the physical signal.')
pwCepFracIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 4, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: pwCepFracIndex.setStatus('current')
if mibBuilder.loadTexts: pwCepFracIndex.setDescription('This is the index of this table. It is a unique index within the ifTable. It represents the interface index for the SONET path ([RFC3592], Section 3.3) for fractional SPE emulation. It may represent an internal (virtual) interface if an NSP function exists between the physical interface and the emulation process.')
pwCepFracMode = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notApplicable", 1), ("dynamic", 2), ("static", 3), ("staticWithEbm", 4), ("staticAsync", 5))).clone('dynamic')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwCepFracMode.setStatus('current')
if mibBuilder.loadTexts: pwCepFracMode.setDescription('Fractional mode for STS-1/VC-3 or VC-4 circuits: notApplicable - When this object is not applicable. dynamic - EBM carried within the CEP header. Unequipped VTs are removed from the payload on the fly. static - EBM not carried within the CEP header. Only VTs defined in the EBM are carried within the payload. staticWithEbm - EBM carried within the CEP header. Only VTs defined in the EBM are carried within the payload. staticAsync - Asynchronous E3/T3 fixed byte removal only.')
pwCepFracConfigError = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 4, 1, 3), Bits().clone(namedValues=NamedValues(("other", 0), ("vtgMapEbmConflict", 1), ("vtgMapAsyncConflict", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepFracConfigError.setStatus('current')
if mibBuilder.loadTexts: pwCepFracConfigError.setDescription('vtgMapEbmConflict(1) is set when the configured static EBM does not match the configured vtgMap for fractional STS-1/VC-3 circuits or when the TUG2Map is in conflict with the static EBM for VC-4 circuits, for example, if the vtgMap specifies that VTG#1 carries VT2 VTs while the EBM indicate that four VTs are equipped within VTG#1. vtgMapAsyncConflict(2) is set when there is a conflict between the mode, the async indication, and the vtgMap fields. For example, fractional mode is set to staticAsync while the VtgMap indicates that the STS-1/VC-3 carries VTs, or both async1 and Tug2Map are set in fractional VC-4 circuits.')
pwCepFracAsync = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 4, 1, 4), PwCepFracAsyncMap().clone('other')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwCepFracAsync.setStatus('current')
if mibBuilder.loadTexts: pwCepFracAsync.setDescription("This object defines the asynchronous payload carried within the STS-1/VC-3. This object is applicable when pwCepFracMode equals 'staticAsync' and MUST equal to 'other' otherwise.")
pwCepFracVtgMap = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 4, 1, 5), PwCepSonetVtgMap()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwCepFracVtgMap.setStatus('current')
if mibBuilder.loadTexts: pwCepFracVtgMap.setDescription("This object defines the VT/VC types of the seven VTG/TUG-2 within the STS-1/VC-3. This variable should be set when 'dynamic', 'static', or 'staticWithEbm' fractional STS-1/VC-3 pwCepFracMode is selected.")
pwCepFracEbm = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 4, 1, 6), PwCepSonetEbm()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwCepFracEbm.setStatus('current')
if mibBuilder.loadTexts: pwCepFracEbm.setDescription("This object holds the static Equipped Bit Mask (EBM) for STS-1/VC-3 channel. This variable MAY be set when 'static' or 'staticWithEbm' fractional STS-1/VC-3 pwCepFracMode is selected. It is possible that the configuration of other MIB modules will define the EBM value; in these cases, this object is read-only and reflects the actual EBM that would be used.")
pwCepFracPeerEbm = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 4, 1, 7), PwCepSonetEbm()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepFracPeerEbm.setStatus('current')
if mibBuilder.loadTexts: pwCepFracPeerEbm.setDescription('This object reports the Equipped Bit Mask (EBM) for STS-1/VC-3 channel as received from the peer within the CEP extension header.')
pwCepFracSdhVc4Mode = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 4, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("dynamic", 2), ("static", 3), ("staticWithEbm", 4))).clone('notApplicable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwCepFracSdhVc4Mode.setStatus('current')
if mibBuilder.loadTexts: pwCepFracSdhVc4Mode.setDescription('Fractional mode for VC-4 circuits: notApplicable - When this is not VC-4 circuit. dynamic - EBM carried within the CEP header. Unequipped VTs are removed from the payload on the fly. static - EBM not carried within the CEP header. Only VTs defined in the EBM are carried within the payload. staticWithEbm - EBM carried within the CEP header. Only VTs defined in the EBM are carried within the payload.')
pwCepFracSdhVc4Tu3Map1 = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 4, 1, 9), PwCepFracAsyncMap().clone('other')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwCepFracSdhVc4Tu3Map1.setStatus('current')
if mibBuilder.loadTexts: pwCepFracSdhVc4Tu3Map1.setDescription('The type of asynchronous mapping carried inside STS-1, VC-3, or TUG-3 containing TU-3 circuit.')
pwCepFracSdhVc4Tu3Map2 = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 4, 1, 10), PwCepFracAsyncMap().clone('other')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwCepFracSdhVc4Tu3Map2.setStatus('current')
if mibBuilder.loadTexts: pwCepFracSdhVc4Tu3Map2.setDescription('If the second TUG-3 within the VC-4 contains a TU-3, this variable must be set.')
pwCepFracSdhVc4Tu3Map3 = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 4, 1, 11), PwCepFracAsyncMap().clone('other')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwCepFracSdhVc4Tu3Map3.setStatus('current')
if mibBuilder.loadTexts: pwCepFracSdhVc4Tu3Map3.setDescription('If the third TUG-3 within the VC-4 contains a TU-3, this variable must be set.')
pwCepFracSdhVc4Tug2Map1 = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 4, 1, 12), PwCepSonetVtgMap()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwCepFracSdhVc4Tug2Map1.setStatus('current')
if mibBuilder.loadTexts: pwCepFracSdhVc4Tug2Map1.setDescription('The VC types of the seven TUG-2s within the first TUG-3 of the VC-4.')
pwCepFracSdhVc4Tug2Map2 = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 4, 1, 13), PwCepSonetVtgMap()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwCepFracSdhVc4Tug2Map2.setStatus('current')
if mibBuilder.loadTexts: pwCepFracSdhVc4Tug2Map2.setDescription('The VC types of the seven TUG-2s within the second TUG-3 of the VC-4.')
pwCepFracSdhVc4Tug2Map3 = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 4, 1, 14), PwCepSonetVtgMap()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwCepFracSdhVc4Tug2Map3.setStatus('current')
if mibBuilder.loadTexts: pwCepFracSdhVc4Tug2Map3.setDescription('The VC types of the seven TUG-2s within the third TUG-3 of the VC-4.')
pwCepFracSdhVc4Ebm1 = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 4, 1, 15), PwCepSdhVc4Ebm()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwCepFracSdhVc4Ebm1.setStatus('current')
if mibBuilder.loadTexts: pwCepFracSdhVc4Ebm1.setDescription("Static Equipped Bit Mask (EBM) for the first TUG-3 within the VC-4. This variable should be set when 'static' or 'staticWithEbm' fractional VC-4 pwCepFracMode is selected. It is possible that the EBM that would be used is available based on configuration of other MIB modules. In these cases, this object is read-only and reflects the actual EBM that would be used.")
pwCepFracSdhVc4Ebm2 = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 4, 1, 16), PwCepSdhVc4Ebm()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwCepFracSdhVc4Ebm2.setStatus('current')
if mibBuilder.loadTexts: pwCepFracSdhVc4Ebm2.setDescription("Static Equipped Bit Mask (EBM) for the second TUG-3 within the VC-4. This variable should be set when 'static' or 'staticWithEbm' fractional VC-4 pwCepFracMode is selected. It is possible that the EBM that would be used is available based on configuration of other MIB modules. In these cases, this object is read-only and reflects the actual EBM that would be used.")
pwCepFracSdhVc4Ebm3 = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 4, 1, 17), PwCepSdhVc4Ebm()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwCepFracSdhVc4Ebm3.setStatus('current')
if mibBuilder.loadTexts: pwCepFracSdhVc4Ebm3.setDescription("Static Equipped Bit Mask (EBM) for the third TUG-3 within the VC-4. This variable should be set when 'Static' or 'staticWithEbm' fractional VC-4 pwCepFracMode is selected. It is possible that the EBM that would be used is available based on configuration of other MIB modules. In these cases, this object is read-only and reflects the actual EBM that would be used.")
pwCepFracSdhVc4PeerEbm1 = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 4, 1, 18), PwCepSdhVc4Ebm()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepFracSdhVc4PeerEbm1.setStatus('current')
if mibBuilder.loadTexts: pwCepFracSdhVc4PeerEbm1.setDescription('Equipped Bit Mask (EBM) for the first TUG-3 within the fractional VC-4 channel received from the peer within the CEP extension header.')
pwCepFracSdhVc4PeerEbm2 = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 4, 1, 19), PwCepSdhVc4Ebm()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepFracSdhVc4PeerEbm2.setStatus('current')
if mibBuilder.loadTexts: pwCepFracSdhVc4PeerEbm2.setDescription('Equipped Bit Mask (EBM) for the second TUG-3 within the fractional VC-4 channel received from the peer within the CEP extension header.')
pwCepFracSdhVc4PeerEbm3 = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 4, 1, 20), PwCepSdhVc4Ebm()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepFracSdhVc4PeerEbm3.setStatus('current')
if mibBuilder.loadTexts: pwCepFracSdhVc4PeerEbm3.setDescription('Equipped Bit Mask (EBM) for the third TUG-3 within the fractional VC-4 channel received from the peer within the CEP extension header.')
pwCepFracRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 4, 1, 21), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwCepFracRowStatus.setStatus('current')
if mibBuilder.loadTexts: pwCepFracRowStatus.setDescription('For creating, modifying, and deleting this row. This object MAY be changed at any time.')
pwCepFracStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 4, 1, 22), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwCepFracStorageType.setStatus('current')
if mibBuilder.loadTexts: pwCepFracStorageType.setDescription('This variable indicates the storage type for this object.')
pwCepPerfCurrentTable = MibTable((1, 3, 6, 1, 2, 1, 200, 1, 5), )
if mibBuilder.loadTexts: pwCepPerfCurrentTable.setStatus('current')
if mibBuilder.loadTexts: pwCepPerfCurrentTable.setDescription('CEP bridges the SONET and packet worlds. In the packet world, counts typically start from the time of service creation and do not stop. In the SONET world, counts are kept in 15-minute intervals. The PW CEP MIB supports both methods. The current 15-minute interval counts are in this table. The interval and total stats are in tables following this. This table provides per-CEP PW performance information. High capacity (HC) counters are required for some counts due to the high speeds expected with CEP services. A SONET path of width 48 (STS-48c) can rollover non-HC counters in a few minutes.')
pwCepPerfCurrentEntry = MibTableRow((1, 3, 6, 1, 2, 1, 200, 1, 5, 1), ).setIndexNames((0, "PW-STD-MIB", "pwIndex"))
if mibBuilder.loadTexts: pwCepPerfCurrentEntry.setStatus('current')
if mibBuilder.loadTexts: pwCepPerfCurrentEntry.setDescription('An entry in this table is created by the agent for every pwCep entry. After 15 minutes, the contents of this table entry are copied to a new entry in the pwCepPerfInterval table, and the counts in this entry are reset to zero.')
pwCepPerfCurrentDbaInPacketsHC = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 5, 1, 1), HCPerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepPerfCurrentDbaInPacketsHC.setStatus('current')
if mibBuilder.loadTexts: pwCepPerfCurrentDbaInPacketsHC.setDescription('Number of DBA packets received.')
pwCepPerfCurrentDbaOutPacketsHC = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 5, 1, 2), HCPerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepPerfCurrentDbaOutPacketsHC.setStatus('current')
if mibBuilder.loadTexts: pwCepPerfCurrentDbaOutPacketsHC.setDescription('Number of DBA packets sent.')
pwCepPerfCurrentInNegPtrAdjust = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 5, 1, 3), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepPerfCurrentInNegPtrAdjust.setStatus('current')
if mibBuilder.loadTexts: pwCepPerfCurrentInNegPtrAdjust.setDescription('Number of negative pointer adjustments sent on the SONET path based on CEP pointer adjustments received.')
pwCepPerfCurrentInPosPtrAdjust = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 5, 1, 4), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepPerfCurrentInPosPtrAdjust.setStatus('current')
if mibBuilder.loadTexts: pwCepPerfCurrentInPosPtrAdjust.setDescription('Number of positive pointer adjustments sent on the SONET path based on CEP pointer adjustments received.')
pwCepPerfCurrentInPtrAdjustSecs = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 5, 1, 5), PerfCurrentCount()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepPerfCurrentInPtrAdjustSecs.setStatus('current')
if mibBuilder.loadTexts: pwCepPerfCurrentInPtrAdjustSecs.setDescription('Number of seconds in which a positive or negative pointer adjustment was sent on the SONET path.')
pwCepPerfCurrentOutNegPtrAdjust = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 5, 1, 6), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepPerfCurrentOutNegPtrAdjust.setStatus('current')
if mibBuilder.loadTexts: pwCepPerfCurrentOutNegPtrAdjust.setDescription('Number of negative pointer adjustments seen on the SONET path and encoded onto sent CEP packets.')
pwCepPerfCurrentOutPosPtrAdjust = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 5, 1, 7), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepPerfCurrentOutPosPtrAdjust.setStatus('current')
if mibBuilder.loadTexts: pwCepPerfCurrentOutPosPtrAdjust.setDescription('Number of positive pointer adjustments seen on the SONET path and encoded onto sent CEP packets.')
pwCepPerfCurrentOutPtrAdjustSecs = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 5, 1, 8), PerfCurrentCount()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepPerfCurrentOutPtrAdjustSecs.setStatus('current')
if mibBuilder.loadTexts: pwCepPerfCurrentOutPtrAdjustSecs.setDescription('Number of seconds in which a positive or negative pointer adjustment was seen on the SONET path.')
pwCepPerfCurrentAbsPtrAdjust = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 5, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepPerfCurrentAbsPtrAdjust.setStatus('current')
if mibBuilder.loadTexts: pwCepPerfCurrentAbsPtrAdjust.setDescription('Indicates the relative adjustment drift between inbound and outbound streams. It is calculated as absolute value of: (InPosPtrAdjust - InNegPtrAdjust ) - (OutPosPtrAdjust - OutNegPtrAdjust)')
pwCepPerfCurrentMissingPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 5, 1, 10), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepPerfCurrentMissingPkts.setStatus('current')
if mibBuilder.loadTexts: pwCepPerfCurrentMissingPkts.setDescription('Number of missing packets (as detected via CEP header sequence number gaps).')
pwCepPerfCurrentPktsOoseq = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 5, 1, 11), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepPerfCurrentPktsOoseq.setStatus('current')
if mibBuilder.loadTexts: pwCepPerfCurrentPktsOoseq.setDescription('Number of packets detected out of sequence (via CEP header sequence numbers) but successfully reordered. Note: Some implementations may not support this feature (see pwCepCfgPktReorder).')
pwCepPerfCurrentPktsOoRngDropped = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 5, 1, 12), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepPerfCurrentPktsOoRngDropped.setStatus('current')
if mibBuilder.loadTexts: pwCepPerfCurrentPktsOoRngDropped.setDescription('Number of packets detected out of range (via CEP header sequence numbers) and could not be reordered or could not fit in the jitter buffer.')
pwCepPerfCurrentJtrBfrUnderruns = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 5, 1, 13), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepPerfCurrentJtrBfrUnderruns.setStatus('current')
if mibBuilder.loadTexts: pwCepPerfCurrentJtrBfrUnderruns.setDescription('Number of times a packet needed to be played out and the jitter buffer was empty.')
pwCepPerfCurrentPktsMalformed = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 5, 1, 14), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepPerfCurrentPktsMalformed.setStatus('current')
if mibBuilder.loadTexts: pwCepPerfCurrentPktsMalformed.setDescription('Number of packets detected with unexpected size or bad headers stack.')
pwCepPerfCurrentSummaryErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 5, 1, 15), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepPerfCurrentSummaryErrors.setStatus('current')
if mibBuilder.loadTexts: pwCepPerfCurrentSummaryErrors.setDescription('A summary of all the packet-error types above (from missing packets to bad length packets).')
pwCepPerfCurrentESs = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 5, 1, 16), PerfCurrentCount()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepPerfCurrentESs.setStatus('current')
if mibBuilder.loadTexts: pwCepPerfCurrentESs.setDescription('The counter associated with the number of Errored Seconds encountered.')
pwCepPerfCurrentSESs = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 5, 1, 17), PerfCurrentCount()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepPerfCurrentSESs.setStatus('current')
if mibBuilder.loadTexts: pwCepPerfCurrentSESs.setDescription('The counter associated with the number of Severely Errored Seconds encountered.')
pwCepPerfCurrentUASs = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 5, 1, 18), PerfCurrentCount()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepPerfCurrentUASs.setStatus('current')
if mibBuilder.loadTexts: pwCepPerfCurrentUASs.setDescription('The counter associated with the number of Unavailable Seconds encountered.')
pwCepPerfCurrentFC = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 5, 1, 19), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepPerfCurrentFC.setStatus('current')
if mibBuilder.loadTexts: pwCepPerfCurrentFC.setDescription('CEP Failure Counts (FC-CEP). The number of CEP failure events. A failure event begins when the LOPS failure is declared and ends when the failure is cleared. A failure event that begins in one period and ends in another period is counted only in the period in which it begins.')
pwCepPerfIntervalTable = MibTable((1, 3, 6, 1, 2, 1, 200, 1, 6), )
if mibBuilder.loadTexts: pwCepPerfIntervalTable.setStatus('current')
if mibBuilder.loadTexts: pwCepPerfIntervalTable.setDescription('This table provides per-CEP PW performance information, much like the pwCepPerfCurrentTable above. However, these counts represent historical 15-minute intervals. Typically, this table will have a maximum of 96 entries for a 24-hour period but is not limited to this. NOTE: Counter64 objects are used here; Counter32 is too small for OC-768 CEP PWs.')
pwCepPerfIntervalEntry = MibTableRow((1, 3, 6, 1, 2, 1, 200, 1, 6, 1), ).setIndexNames((0, "PW-STD-MIB", "pwIndex"), (0, "PW-CEP-STD-MIB", "pwCepPerfIntervalNumber"))
if mibBuilder.loadTexts: pwCepPerfIntervalEntry.setStatus('current')
if mibBuilder.loadTexts: pwCepPerfIntervalEntry.setDescription('An entry in this table is created by the agent for every pwCepPerfCurrentEntry that is 15 minutes old. The contents of the Current entry are copied to the new entry here. The Current entry then resets its counts to zero for the next current 15-minute interval. pwCepIndex is found in the pwCepCfg table.')
pwCepPerfIntervalNumber = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 96)))
if mibBuilder.loadTexts: pwCepPerfIntervalNumber.setStatus('current')
if mibBuilder.loadTexts: pwCepPerfIntervalNumber.setDescription('A number (between 1 and 96 to cover a 24-hour period) that identifies the interval for which the set of statistics is available. The interval identified by 1 is the most recently completed 15-minute interval, and the interval identified by N is the interval immediately preceding the one identified by N-1. The minimum range of N is 1 through 4. The default range is 1 through 32. The maximum range of N is 1 through 96.')
pwCepPerfIntervalValidData = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 6, 1, 2), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepPerfIntervalValidData.setStatus('current')
if mibBuilder.loadTexts: pwCepPerfIntervalValidData.setDescription('This variable indicates if the data for this interval is valid.')
pwCepPerfIntervalReset = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("reset", 1), ("normal", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pwCepPerfIntervalReset.setStatus('current')
if mibBuilder.loadTexts: pwCepPerfIntervalReset.setDescription("Used in cases where the user knows that the errors within this interval should not be counted. Writing 'reset' sets all error counts to zero. The value of 0 is not used here due to issues with implementations.")
pwCepPerfIntervalTimeElapsed = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 6, 1, 4), HCPerfTimeElapsed()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepPerfIntervalTimeElapsed.setStatus('current')
if mibBuilder.loadTexts: pwCepPerfIntervalTimeElapsed.setDescription("The duration of a particular interval in seconds. Adjustments in the system's time-of-day clock may cause the interval to be greater or less than the normal value. Therefore, this actual interval value is provided.")
pwCepPerfIntervalDbaInPacketsHC = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 6, 1, 5), HCPerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepPerfIntervalDbaInPacketsHC.setStatus('current')
if mibBuilder.loadTexts: pwCepPerfIntervalDbaInPacketsHC.setDescription('Number of DBA packets received.')
pwCepPerfIntervalDbaOutPacketsHC = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 6, 1, 6), HCPerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepPerfIntervalDbaOutPacketsHC.setStatus('current')
if mibBuilder.loadTexts: pwCepPerfIntervalDbaOutPacketsHC.setDescription('Number of DBA packets sent.')
pwCepPerfIntervalInNegPtrAdjust = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 6, 1, 7), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepPerfIntervalInNegPtrAdjust.setStatus('current')
if mibBuilder.loadTexts: pwCepPerfIntervalInNegPtrAdjust.setDescription('Number of negative pointer adjustments sent on the SONET path based on CEP pointer adjustments received.')
pwCepPerfIntervalInPosPtrAdjust = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 6, 1, 8), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepPerfIntervalInPosPtrAdjust.setStatus('current')
if mibBuilder.loadTexts: pwCepPerfIntervalInPosPtrAdjust.setDescription('Number of positive pointer adjustments sent on the SONET path based on CEP pointer adjustments received.')
pwCepPerfIntervalInPtrAdjustSecs = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 6, 1, 9), PerfIntervalCount()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepPerfIntervalInPtrAdjustSecs.setStatus('current')
if mibBuilder.loadTexts: pwCepPerfIntervalInPtrAdjustSecs.setDescription('Number of seconds in which a positive or negative pointer adjustment was sent on the SONET path.')
pwCepPerfIntervalOutNegPtrAdjust = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 6, 1, 10), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepPerfIntervalOutNegPtrAdjust.setStatus('current')
if mibBuilder.loadTexts: pwCepPerfIntervalOutNegPtrAdjust.setDescription('Number of negative pointer adjustments seen on the SONET path and encoded onto sent CEP packets.')
pwCepPerfIntervalOutPosPtrAdjust = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 6, 1, 11), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepPerfIntervalOutPosPtrAdjust.setStatus('current')
if mibBuilder.loadTexts: pwCepPerfIntervalOutPosPtrAdjust.setDescription('Number of positive pointer adjustments seen on the SONET path and encoded onto sent CEP packets.')
pwCepPerfIntervalOutPtrAdjustSecs = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 6, 1, 12), PerfIntervalCount()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepPerfIntervalOutPtrAdjustSecs.setStatus('current')
if mibBuilder.loadTexts: pwCepPerfIntervalOutPtrAdjustSecs.setDescription('Number of seconds in which a positive or negative pointer adjustment was seen on the SONET path.')
pwCepPerfIntervalAbsPtrAdjust = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 6, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepPerfIntervalAbsPtrAdjust.setStatus('current')
if mibBuilder.loadTexts: pwCepPerfIntervalAbsPtrAdjust.setDescription('The relative adjustment drift between inbound and outbound streams. It is calculated as absolute value of: (InPosPtrAdjust - InNegPtrAdjust) - (OutPosPtrAdjust - OutNegPtrAdjust)')
pwCepPerfIntervalMissingPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 6, 1, 14), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepPerfIntervalMissingPkts.setStatus('current')
if mibBuilder.loadTexts: pwCepPerfIntervalMissingPkts.setDescription('Number of missing packets (as detected via CEP header sequence number gaps).')
pwCepPerfIntervalPktsOoseq = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 6, 1, 15), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepPerfIntervalPktsOoseq.setStatus('current')
if mibBuilder.loadTexts: pwCepPerfIntervalPktsOoseq.setDescription('Number of packets detected out of sequence (via CEP header sequence numbers) but successfully reordered. Note: Some implementations mat not support this feature (see pwCepCfgPktReorder).')
pwCepPerfIntervalPktsOoRngDropped = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 6, 1, 16), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepPerfIntervalPktsOoRngDropped.setStatus('current')
if mibBuilder.loadTexts: pwCepPerfIntervalPktsOoRngDropped.setDescription('Number of packets detected out of range (via CEP header sequence numbers) and could not be reordered or could not fit in the jitter buffer.')
pwCepPerfIntervalJtrBfrUnderruns = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 6, 1, 17), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepPerfIntervalJtrBfrUnderruns.setStatus('current')
if mibBuilder.loadTexts: pwCepPerfIntervalJtrBfrUnderruns.setDescription('Number of times a packet needed to be played out and the jitter buffer was empty.')
pwCepPerfIntervalPktsMalformed = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 6, 1, 18), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepPerfIntervalPktsMalformed.setStatus('current')
if mibBuilder.loadTexts: pwCepPerfIntervalPktsMalformed.setDescription('Number of packets detected with unexpected size or bad headers stack.')
pwCepPerfIntervalSummaryErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 6, 1, 19), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepPerfIntervalSummaryErrors.setStatus('current')
if mibBuilder.loadTexts: pwCepPerfIntervalSummaryErrors.setDescription('A summary of all the packet-error types above (from missing packets to bad length packets).')
pwCepPerfIntervalESs = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 6, 1, 20), PerfIntervalCount()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepPerfIntervalESs.setStatus('current')
if mibBuilder.loadTexts: pwCepPerfIntervalESs.setDescription('The counter associated with the number of Errored Seconds encountered.')
pwCepPerfIntervalSESs = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 6, 1, 21), PerfIntervalCount()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepPerfIntervalSESs.setStatus('current')
if mibBuilder.loadTexts: pwCepPerfIntervalSESs.setDescription('The counter associated with the number of Severely Errored Seconds encountered.')
pwCepPerfIntervalUASs = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 6, 1, 22), PerfIntervalCount()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepPerfIntervalUASs.setStatus('current')
if mibBuilder.loadTexts: pwCepPerfIntervalUASs.setDescription('The counter associated with the number of Unavailable Seconds encountered.')
pwCepPerfIntervalFC = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 6, 1, 23), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepPerfIntervalFC.setStatus('current')
if mibBuilder.loadTexts: pwCepPerfIntervalFC.setDescription('CEP Failure Counts (FC-CEP). The number of CEP failure events. A failure event begins when the LOPS failure is declared and ends when the failure is cleared. A failure event that begins in one period and ends in another period is counted only in the period in which it begins.')
pwCepPerf1DayIntervalTable = MibTable((1, 3, 6, 1, 2, 1, 200, 1, 7), )
if mibBuilder.loadTexts: pwCepPerf1DayIntervalTable.setStatus('current')
if mibBuilder.loadTexts: pwCepPerf1DayIntervalTable.setDescription("This table provides per CEP PW performance information, the current day's measurement, and the previous day's interval. In the extreme case where one of the error counters has overflowed during the one-day interval, the error counter MUST NOT wrap around and MUST return the maximum value.")
pwCepPerf1DayIntervalEntry = MibTableRow((1, 3, 6, 1, 2, 1, 200, 1, 7, 1), ).setIndexNames((0, "PW-STD-MIB", "pwIndex"), (0, "PW-CEP-STD-MIB", "pwCepPerf1DayIntervalNumber"))
if mibBuilder.loadTexts: pwCepPerf1DayIntervalEntry.setStatus('current')
if mibBuilder.loadTexts: pwCepPerf1DayIntervalEntry.setDescription('An entry is created in this table by the agent for every entry in the pwCepTable and for each day interval up to the number of supported historical intervals.')
pwCepPerf1DayIntervalNumber = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 7, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 31)))
if mibBuilder.loadTexts: pwCepPerf1DayIntervalNumber.setStatus('current')
if mibBuilder.loadTexts: pwCepPerf1DayIntervalNumber.setDescription('History Data Interval number. Interval 1 is the current day measurement period; interval 2 is the most recent previous day; and interval 30 is 31 days ago.')
pwCepPerf1DayIntervalValidData = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 7, 1, 2), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepPerf1DayIntervalValidData.setStatus('current')
if mibBuilder.loadTexts: pwCepPerf1DayIntervalValidData.setDescription('This variable indicates if the data for this interval is valid.')
pwCepPerf1DayIntervalMoniSecs = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 7, 1, 3), HCPerfTimeElapsed()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepPerf1DayIntervalMoniSecs.setStatus('current')
if mibBuilder.loadTexts: pwCepPerf1DayIntervalMoniSecs.setDescription('The amount of time in the 1-day interval over which the performance monitoring information is actually counted. This value will be the same as the interval duration except in situations where performance monitoring data could not be collected for any reason or the agent clock was adjusted.')
pwCepPerf1DayIntervalDbaInPacketsHC = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 7, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepPerf1DayIntervalDbaInPacketsHC.setStatus('current')
if mibBuilder.loadTexts: pwCepPerf1DayIntervalDbaInPacketsHC.setDescription('Number of DBA packets received.')
pwCepPerf1DayIntervalDbaOutPacketsHC = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 7, 1, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepPerf1DayIntervalDbaOutPacketsHC.setStatus('current')
if mibBuilder.loadTexts: pwCepPerf1DayIntervalDbaOutPacketsHC.setDescription('Number of DBA packets sent.')
pwCepPerf1DayIntervalInNegPtrAdjust = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 7, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepPerf1DayIntervalInNegPtrAdjust.setStatus('current')
if mibBuilder.loadTexts: pwCepPerf1DayIntervalInNegPtrAdjust.setDescription('Number of negative pointer adjustments sent on the SONET path based on CEP pointer adjustments received.')
pwCepPerf1DayIntervalInPosPtrAdjust = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 7, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepPerf1DayIntervalInPosPtrAdjust.setStatus('current')
if mibBuilder.loadTexts: pwCepPerf1DayIntervalInPosPtrAdjust.setDescription('Number of positive pointer adjustments sent on the SONET path based on CEP pointer adjustments received.')
pwCepPerf1DayIntervalInPtrAdjustSecs = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 7, 1, 8), Counter32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepPerf1DayIntervalInPtrAdjustSecs.setStatus('current')
if mibBuilder.loadTexts: pwCepPerf1DayIntervalInPtrAdjustSecs.setDescription('Number of seconds in which a positive or negative pointer adjustment was sent on the SONET path.')
pwCepPerf1DayIntervalOutNegPtrAdjust = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 7, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepPerf1DayIntervalOutNegPtrAdjust.setStatus('current')
if mibBuilder.loadTexts: pwCepPerf1DayIntervalOutNegPtrAdjust.setDescription('Number of negative pointer adjustments seen on the SONET path and encoded onto sent CEP packets.')
pwCepPerf1DayIntervalOutPosPtrAdjust = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 7, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepPerf1DayIntervalOutPosPtrAdjust.setStatus('current')
if mibBuilder.loadTexts: pwCepPerf1DayIntervalOutPosPtrAdjust.setDescription('Number of positive pointer adjustments seen on the SONET path and encoded onto sent CEP packets.')
pwCepPerf1DayIntervalOutPtrAdjustSecs = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 7, 1, 11), Counter32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepPerf1DayIntervalOutPtrAdjustSecs.setStatus('current')
if mibBuilder.loadTexts: pwCepPerf1DayIntervalOutPtrAdjustSecs.setDescription('Number of seconds in which a positive or negative pointer adjustment was seen on the SONET path.')
pwCepPerf1DayIntervalAbsPtrAdjust = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 7, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepPerf1DayIntervalAbsPtrAdjust.setStatus('current')
if mibBuilder.loadTexts: pwCepPerf1DayIntervalAbsPtrAdjust.setDescription('The relative adjustment of drift between inbound and outbound streams. It is calculated as absolute value of: (InPosPtrAdjust - InNegPtrAdjust) - (OutPosPtrAdjust - OutNegPtrAdjust)')
pwCepPerf1DayIntervalMissingPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 7, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepPerf1DayIntervalMissingPkts.setStatus('current')
if mibBuilder.loadTexts: pwCepPerf1DayIntervalMissingPkts.setDescription('Number of missing packets (as detected via CEP header sequence number gaps).')
pwCepPerf1DayIntervalPktsOoseq = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 7, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepPerf1DayIntervalPktsOoseq.setStatus('current')
if mibBuilder.loadTexts: pwCepPerf1DayIntervalPktsOoseq.setDescription('Number of packets detected out of sequence (via CEP header sequence numbers) but successfully reordered. Note: Some implementations may not support this feature (see pwCepCfgPktReorder).')
pwCepPerf1DayIntervalPktsOoRngDropped = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 7, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepPerf1DayIntervalPktsOoRngDropped.setStatus('current')
if mibBuilder.loadTexts: pwCepPerf1DayIntervalPktsOoRngDropped.setDescription('Number of packets detected out of range (via CEP header sequence numbers) and could not be reordered or could not fit in the jitter buffer.')
pwCepPerf1DayIntervalJtrBfrUnderruns = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 7, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepPerf1DayIntervalJtrBfrUnderruns.setStatus('current')
if mibBuilder.loadTexts: pwCepPerf1DayIntervalJtrBfrUnderruns.setDescription('Number of times a packet needed to be played out, and the jitter buffer was empty.')
pwCepPerf1DayIntervalPktsMalformed = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 7, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepPerf1DayIntervalPktsMalformed.setStatus('current')
if mibBuilder.loadTexts: pwCepPerf1DayIntervalPktsMalformed.setDescription('Number of packets detected with unexpected size or bad headers stack.')
pwCepPerf1DayIntervalSummaryErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 7, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepPerf1DayIntervalSummaryErrors.setStatus('current')
if mibBuilder.loadTexts: pwCepPerf1DayIntervalSummaryErrors.setDescription('A summary of all the packet-error types above (from missing packets to bad length packets).')
pwCepPerf1DayIntervalESs = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 7, 1, 19), Counter32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepPerf1DayIntervalESs.setStatus('current')
if mibBuilder.loadTexts: pwCepPerf1DayIntervalESs.setDescription('The counter associated with the number of Errored Seconds encountered.')
pwCepPerf1DayIntervalSESs = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 7, 1, 20), Counter32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepPerf1DayIntervalSESs.setStatus('current')
if mibBuilder.loadTexts: pwCepPerf1DayIntervalSESs.setDescription('The counter associated with the number of Severely Errored Seconds. See pwCepCfgMissingPktsToSes.')
pwCepPerf1DayIntervalUASs = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 7, 1, 21), Counter32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepPerf1DayIntervalUASs.setStatus('current')
if mibBuilder.loadTexts: pwCepPerf1DayIntervalUASs.setDescription('The counter associated with the number of unavailable seconds. See pwCepCfgSesToUAS. NOTE: When first entering the UAS state, the number of SesToUas is added to this object; then, as each additional UAS occurs, this object increments by one. NOTE: Similar to [RFC3592], if the agent chooses to update the various performance statistics in real time, it must be prepared to retroactively reduce the ES and SES counts (by the value of pwCepCfgSesToUas) and increase the UAS count (by that same value) when it determines that UAS state has been entered.')
pwCepPerf1DayIntervalFC = MibTableColumn((1, 3, 6, 1, 2, 1, 200, 1, 7, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pwCepPerf1DayIntervalFC.setStatus('current')
if mibBuilder.loadTexts: pwCepPerf1DayIntervalFC.setDescription('CEP Failure Counts (FC-CEP). The number of CEP failure events. A failure event begins when the LOPS failure is declared and ends when the failure is cleared.')
pwCepGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 200, 2, 1))
pwCepCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 200, 2, 2))
pwCepModuleFullCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 200, 2, 2, 1)).setObjects(("PW-CEP-STD-MIB", "pwCepGroup"), ("PW-CEP-STD-MIB", "pwCepCfgGroup"), ("PW-CEP-STD-MIB", "pwCepPerfCurrentGroup"), ("PW-CEP-STD-MIB", "pwCepPerfIntervalGroup"), ("PW-CEP-STD-MIB", "pwCepPerf1DayIntervalGroup"), ("PW-CEP-STD-MIB", "pwCepFractionalGroup"), ("PW-CEP-STD-MIB", "pwCepFractionalSts1Vc3Group"), ("PW-CEP-STD-MIB", "pwCepFractionalVc4Group"), ("PW-CEP-STD-MIB", "pwCepSignalingGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pwCepModuleFullCompliance = pwCepModuleFullCompliance.setStatus('current')
if mibBuilder.loadTexts: pwCepModuleFullCompliance.setDescription('The compliance statement for agents that support full CEP PW configuration through this MIB module.')
pwCepModuleReadOnlyCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 200, 2, 2, 2)).setObjects(("PW-CEP-STD-MIB", "pwCepGroup"), ("PW-CEP-STD-MIB", "pwCepCfgGroup"), ("PW-CEP-STD-MIB", "pwCepPerfCurrentGroup"), ("PW-CEP-STD-MIB", "pwCepPerfIntervalGroup"), ("PW-CEP-STD-MIB", "pwCepPerf1DayIntervalGroup"), ("PW-CEP-STD-MIB", "pwCepFractionalGroup"), ("PW-CEP-STD-MIB", "pwCepFractionalSts1Vc3Group"), ("PW-CEP-STD-MIB", "pwCepFractionalVc4Group"), ("PW-CEP-STD-MIB", "pwCepSignalingGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pwCepModuleReadOnlyCompliance = pwCepModuleReadOnlyCompliance.setStatus('current')
if mibBuilder.loadTexts: pwCepModuleReadOnlyCompliance.setDescription('The compliance statement for agents that provide read-only support for the PW CEP MIB Module. Such devices can be monitored but cannot be configured using this MIB module.')
pwCepGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 200, 2, 1, 1)).setObjects(("PW-CEP-STD-MIB", "pwCepType"), ("PW-CEP-STD-MIB", "pwCepSonetIfIndex"), ("PW-CEP-STD-MIB", "pwCepSonetConfigErrorOrStatus"), ("PW-CEP-STD-MIB", "pwCepCfgIndex"), ("PW-CEP-STD-MIB", "pwCepTimeElapsed"), ("PW-CEP-STD-MIB", "pwCepValidIntervals"), ("PW-CEP-STD-MIB", "pwCepIndications"), ("PW-CEP-STD-MIB", "pwCepLastEsTimeStamp"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pwCepGroup = pwCepGroup.setStatus('current')
if mibBuilder.loadTexts: pwCepGroup.setDescription('Collection of objects for basic CEP PW config and status.')
pwCepSignalingGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 200, 2, 1, 2)).setObjects(("PW-CEP-STD-MIB", "pwCepPeerCepOption"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pwCepSignalingGroup = pwCepSignalingGroup.setStatus('current')
if mibBuilder.loadTexts: pwCepSignalingGroup.setDescription('Collection of objects required if the network element support CEP connections signaling.')
pwCepCfgGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 200, 2, 1, 3)).setObjects(("PW-CEP-STD-MIB", "pwCepCfgIndexNext"), ("PW-CEP-STD-MIB", "pwCepSonetPayloadLength"), ("PW-CEP-STD-MIB", "pwCepCfgMinPktLength"), ("PW-CEP-STD-MIB", "pwCepCfgPktReorder"), ("PW-CEP-STD-MIB", "pwCepCfgEnableDBA"), ("PW-CEP-STD-MIB", "pwCepCfgRtpHdrSuppress"), ("PW-CEP-STD-MIB", "pwCepCfgJtrBfrDepth"), ("PW-CEP-STD-MIB", "pwCepCfgConsecPktsInsync"), ("PW-CEP-STD-MIB", "pwCepCfgConsecMissingOutSync"), ("PW-CEP-STD-MIB", "pwCepCfgPktErrorPlayOutValue"), ("PW-CEP-STD-MIB", "pwCepCfgMissingPktsToSes"), ("PW-CEP-STD-MIB", "pwCepCfgSesToUas"), ("PW-CEP-STD-MIB", "pwCepCfgSecsToExitUas"), ("PW-CEP-STD-MIB", "pwCepCfgName"), ("PW-CEP-STD-MIB", "pwCepCfgRowStatus"), ("PW-CEP-STD-MIB", "pwCepCfgStorageType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pwCepCfgGroup = pwCepCfgGroup.setStatus('current')
if mibBuilder.loadTexts: pwCepCfgGroup.setDescription('Collection of detailed objects needed to configure CEP PWs.')
pwCepPerfCurrentGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 200, 2, 1, 4)).setObjects(("PW-CEP-STD-MIB", "pwCepPerfCurrentDbaInPacketsHC"), ("PW-CEP-STD-MIB", "pwCepPerfCurrentDbaOutPacketsHC"), ("PW-CEP-STD-MIB", "pwCepPerfCurrentInNegPtrAdjust"), ("PW-CEP-STD-MIB", "pwCepPerfCurrentInPosPtrAdjust"), ("PW-CEP-STD-MIB", "pwCepPerfCurrentInPtrAdjustSecs"), ("PW-CEP-STD-MIB", "pwCepPerfCurrentOutNegPtrAdjust"), ("PW-CEP-STD-MIB", "pwCepPerfCurrentOutPosPtrAdjust"), ("PW-CEP-STD-MIB", "pwCepPerfCurrentOutPtrAdjustSecs"), ("PW-CEP-STD-MIB", "pwCepPerfCurrentAbsPtrAdjust"), ("PW-CEP-STD-MIB", "pwCepPerfCurrentMissingPkts"), ("PW-CEP-STD-MIB", "pwCepPerfCurrentPktsOoseq"), ("PW-CEP-STD-MIB", "pwCepPerfCurrentPktsOoRngDropped"), ("PW-CEP-STD-MIB", "pwCepPerfCurrentJtrBfrUnderruns"), ("PW-CEP-STD-MIB", "pwCepPerfCurrentPktsMalformed"), ("PW-CEP-STD-MIB", "pwCepPerfCurrentSummaryErrors"), ("PW-CEP-STD-MIB", "pwCepPerfCurrentESs"), ("PW-CEP-STD-MIB", "pwCepPerfCurrentSESs"), ("PW-CEP-STD-MIB", "pwCepPerfCurrentUASs"), ("PW-CEP-STD-MIB", "pwCepPerfCurrentFC"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pwCepPerfCurrentGroup = pwCepPerfCurrentGroup.setStatus('current')
if mibBuilder.loadTexts: pwCepPerfCurrentGroup.setDescription('Collection of statistics objects for CEP PWs.')
pwCepPerfIntervalGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 200, 2, 1, 5)).setObjects(("PW-CEP-STD-MIB", "pwCepPerfIntervalValidData"), ("PW-CEP-STD-MIB", "pwCepPerfIntervalReset"), ("PW-CEP-STD-MIB", "pwCepPerfIntervalTimeElapsed"), ("PW-CEP-STD-MIB", "pwCepPerfIntervalDbaInPacketsHC"), ("PW-CEP-STD-MIB", "pwCepPerfIntervalDbaOutPacketsHC"), ("PW-CEP-STD-MIB", "pwCepPerfIntervalInNegPtrAdjust"), ("PW-CEP-STD-MIB", "pwCepPerfIntervalInPosPtrAdjust"), ("PW-CEP-STD-MIB", "pwCepPerfIntervalInPtrAdjustSecs"), ("PW-CEP-STD-MIB", "pwCepPerfIntervalOutNegPtrAdjust"), ("PW-CEP-STD-MIB", "pwCepPerfIntervalOutPosPtrAdjust"), ("PW-CEP-STD-MIB", "pwCepPerfIntervalOutPtrAdjustSecs"), ("PW-CEP-STD-MIB", "pwCepPerfIntervalAbsPtrAdjust"), ("PW-CEP-STD-MIB", "pwCepPerfIntervalMissingPkts"), ("PW-CEP-STD-MIB", "pwCepPerfIntervalPktsOoseq"), ("PW-CEP-STD-MIB", "pwCepPerfIntervalPktsOoRngDropped"), ("PW-CEP-STD-MIB", "pwCepPerfIntervalJtrBfrUnderruns"), ("PW-CEP-STD-MIB", "pwCepPerfIntervalPktsMalformed"), ("PW-CEP-STD-MIB", "pwCepPerfIntervalSummaryErrors"), ("PW-CEP-STD-MIB", "pwCepPerfIntervalESs"), ("PW-CEP-STD-MIB", "pwCepPerfIntervalSESs"), ("PW-CEP-STD-MIB", "pwCepPerfIntervalUASs"), ("PW-CEP-STD-MIB", "pwCepPerfIntervalFC"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pwCepPerfIntervalGroup = pwCepPerfIntervalGroup.setStatus('current')
if mibBuilder.loadTexts: pwCepPerfIntervalGroup.setDescription('Collection of statistics objects for CEP PWs.')
pwCepPerf1DayIntervalGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 200, 2, 1, 6)).setObjects(("PW-CEP-STD-MIB", "pwCepPerf1DayIntervalValidData"), ("PW-CEP-STD-MIB", "pwCepPerf1DayIntervalMoniSecs"), ("PW-CEP-STD-MIB", "pwCepPerf1DayIntervalDbaInPacketsHC"), ("PW-CEP-STD-MIB", "pwCepPerf1DayIntervalDbaOutPacketsHC"), ("PW-CEP-STD-MIB", "pwCepPerf1DayIntervalInNegPtrAdjust"), ("PW-CEP-STD-MIB", "pwCepPerf1DayIntervalInPosPtrAdjust"), ("PW-CEP-STD-MIB", "pwCepPerf1DayIntervalInPtrAdjustSecs"), ("PW-CEP-STD-MIB", "pwCepPerf1DayIntervalOutNegPtrAdjust"), ("PW-CEP-STD-MIB", "pwCepPerf1DayIntervalOutPosPtrAdjust"), ("PW-CEP-STD-MIB", "pwCepPerf1DayIntervalOutPtrAdjustSecs"), ("PW-CEP-STD-MIB", "pwCepPerf1DayIntervalAbsPtrAdjust"), ("PW-CEP-STD-MIB", "pwCepPerf1DayIntervalMissingPkts"), ("PW-CEP-STD-MIB", "pwCepPerf1DayIntervalPktsOoseq"), ("PW-CEP-STD-MIB", "pwCepPerf1DayIntervalPktsOoRngDropped"), ("PW-CEP-STD-MIB", "pwCepPerf1DayIntervalJtrBfrUnderruns"), ("PW-CEP-STD-MIB", "pwCepPerf1DayIntervalPktsMalformed"), ("PW-CEP-STD-MIB", "pwCepPerf1DayIntervalSummaryErrors"), ("PW-CEP-STD-MIB", "pwCepPerf1DayIntervalESs"), ("PW-CEP-STD-MIB", "pwCepPerf1DayIntervalSESs"), ("PW-CEP-STD-MIB", "pwCepPerf1DayIntervalUASs"), ("PW-CEP-STD-MIB", "pwCepPerf1DayIntervalFC"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pwCepPerf1DayIntervalGroup = pwCepPerf1DayIntervalGroup.setStatus('current')
if mibBuilder.loadTexts: pwCepPerf1DayIntervalGroup.setDescription('Collection of statistics objects for CEP PWs.')
pwCepFractionalGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 200, 2, 1, 7)).setObjects(("PW-CEP-STD-MIB", "pwCepFracRowStatus"), ("PW-CEP-STD-MIB", "pwCepFracStorageType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pwCepFractionalGroup = pwCepFractionalGroup.setStatus('current')
if mibBuilder.loadTexts: pwCepFractionalGroup.setDescription('Collection of fractional SPE objects. These objects are optional and should be supported only if fractional SPE is supported within the network element.')
pwCepFractionalSts1Vc3Group = ObjectGroup((1, 3, 6, 1, 2, 1, 200, 2, 1, 8)).setObjects(("PW-CEP-STD-MIB", "pwCepFracMode"), ("PW-CEP-STD-MIB", "pwCepFracConfigError"), ("PW-CEP-STD-MIB", "pwCepFracAsync"), ("PW-CEP-STD-MIB", "pwCepFracVtgMap"), ("PW-CEP-STD-MIB", "pwCepFracEbm"), ("PW-CEP-STD-MIB", "pwCepFracPeerEbm"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pwCepFractionalSts1Vc3Group = pwCepFractionalSts1Vc3Group.setStatus('current')
if mibBuilder.loadTexts: pwCepFractionalSts1Vc3Group.setDescription('Collection of fractional STS-1/VC3 objects. These objects are optional and should be supported only if fractional STS-1/VC3 is supported within the network element.')
pwCepFractionalVc4Group = ObjectGroup((1, 3, 6, 1, 2, 1, 200, 2, 1, 9)).setObjects(("PW-CEP-STD-MIB", "pwCepFracSdhVc4Mode"), ("PW-CEP-STD-MIB", "pwCepFracSdhVc4Tu3Map1"), ("PW-CEP-STD-MIB", "pwCepFracSdhVc4Tu3Map2"), ("PW-CEP-STD-MIB", "pwCepFracSdhVc4Tu3Map3"), ("PW-CEP-STD-MIB", "pwCepFracSdhVc4Tug2Map1"), ("PW-CEP-STD-MIB", "pwCepFracSdhVc4Tug2Map2"), ("PW-CEP-STD-MIB", "pwCepFracSdhVc4Tug2Map3"), ("PW-CEP-STD-MIB", "pwCepFracSdhVc4Ebm1"), ("PW-CEP-STD-MIB", "pwCepFracSdhVc4Ebm2"), ("PW-CEP-STD-MIB", "pwCepFracSdhVc4Ebm3"), ("PW-CEP-STD-MIB", "pwCepFracSdhVc4PeerEbm1"), ("PW-CEP-STD-MIB", "pwCepFracSdhVc4PeerEbm2"), ("PW-CEP-STD-MIB", "pwCepFracSdhVc4PeerEbm3"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pwCepFractionalVc4Group = pwCepFractionalVc4Group.setStatus('current')
if mibBuilder.loadTexts: pwCepFractionalVc4Group.setDescription('Collection of fractional VC4 objects. These objects are optional and should be supported only if fractional VC4 is supported within the network element.')
mibBuilder.exportSymbols("PW-CEP-STD-MIB", pwCepCfgJtrBfrDepth=pwCepCfgJtrBfrDepth, pwCepPerfCurrentPktsOoseq=pwCepPerfCurrentPktsOoseq, pwCepFracSdhVc4Ebm3=pwCepFracSdhVc4Ebm3, pwCepSonetPayloadLength=pwCepSonetPayloadLength, pwCepFracEbm=pwCepFracEbm, pwCepPerf1DayIntervalFC=pwCepPerf1DayIntervalFC, pwCepPerf1DayIntervalEntry=pwCepPerf1DayIntervalEntry, pwCepPerf1DayIntervalJtrBfrUnderruns=pwCepPerf1DayIntervalJtrBfrUnderruns, pwCepSonetIfIndex=pwCepSonetIfIndex, pwCepPerfCurrentPktsMalformed=pwCepPerfCurrentPktsMalformed, pwCepPerf1DayIntervalMoniSecs=pwCepPerf1DayIntervalMoniSecs, pwCepFracSdhVc4Tu3Map1=pwCepFracSdhVc4Tu3Map1, pwCepPerfIntervalDbaOutPacketsHC=pwCepPerfIntervalDbaOutPacketsHC, pwCepPerf1DayIntervalValidData=pwCepPerf1DayIntervalValidData, pwCepLastEsTimeStamp=pwCepLastEsTimeStamp, PwCepFracAsyncMap=PwCepFracAsyncMap, pwCepPerfCurrentOutPosPtrAdjust=pwCepPerfCurrentOutPosPtrAdjust, pwCepCfgRowStatus=pwCepCfgRowStatus, pwCepPerf1DayIntervalInPtrAdjustSecs=pwCepPerf1DayIntervalInPtrAdjustSecs, pwCepPerfCurrentEntry=pwCepPerfCurrentEntry, pwCepCfgMinPktLength=pwCepCfgMinPktLength, pwCepPerfIntervalFC=pwCepPerfIntervalFC, pwCepFracIndex=pwCepFracIndex, pwCepPerf1DayIntervalInNegPtrAdjust=pwCepPerf1DayIntervalInNegPtrAdjust, pwCepPerfIntervalMissingPkts=pwCepPerfIntervalMissingPkts, pwCepPerfIntervalJtrBfrUnderruns=pwCepPerfIntervalJtrBfrUnderruns, pwCepPerfIntervalOutPosPtrAdjust=pwCepPerfIntervalOutPosPtrAdjust, PwCepSonetVtgMap=PwCepSonetVtgMap, pwCepGroups=pwCepGroups, pwCepCfgSecsToExitUas=pwCepCfgSecsToExitUas, pwCepPerfCurrentInNegPtrAdjust=pwCepPerfCurrentInNegPtrAdjust, pwCepGroup=pwCepGroup, pwCepPerfCurrentInPtrAdjustSecs=pwCepPerfCurrentInPtrAdjustSecs, pwCepCfgStorageType=pwCepCfgStorageType, pwCepPerfIntervalSESs=pwCepPerfIntervalSESs, pwCepPerfCurrentFC=pwCepPerfCurrentFC, pwCepPerf1DayIntervalGroup=pwCepPerf1DayIntervalGroup, pwCepPerfIntervalNumber=pwCepPerfIntervalNumber, pwCepCfgName=pwCepCfgName, pwCepPerf1DayIntervalAbsPtrAdjust=pwCepPerf1DayIntervalAbsPtrAdjust, pwCepPerf1DayIntervalESs=pwCepPerf1DayIntervalESs, pwCepTimeElapsed=pwCepTimeElapsed, pwCepFracTable=pwCepFracTable, pwCepFracAsync=pwCepFracAsync, pwCepFractionalGroup=pwCepFractionalGroup, pwCepObjects=pwCepObjects, pwCepFracSdhVc4Ebm1=pwCepFracSdhVc4Ebm1, pwCepConformance=pwCepConformance, pwCepIndications=pwCepIndications, pwCepPerfIntervalOutNegPtrAdjust=pwCepPerfIntervalOutNegPtrAdjust, pwCepPerfCurrentSESs=pwCepPerfCurrentSESs, pwCepPerfCurrentMissingPkts=pwCepPerfCurrentMissingPkts, pwCepSonetConfigErrorOrStatus=pwCepSonetConfigErrorOrStatus, pwCepPerf1DayIntervalDbaInPacketsHC=pwCepPerf1DayIntervalDbaInPacketsHC, pwCepCfgIndex=pwCepCfgIndex, pwCepFracStorageType=pwCepFracStorageType, pwCepCfgTableIndex=pwCepCfgTableIndex, pwCepFracSdhVc4Tug2Map3=pwCepFracSdhVc4Tug2Map3, pwCepFracSdhVc4Tu3Map3=pwCepFracSdhVc4Tu3Map3, pwCepCfgPktErrorPlayOutValue=pwCepCfgPktErrorPlayOutValue, pwCepPerfIntervalReset=pwCepPerfIntervalReset, pwCepPerfIntervalEntry=pwCepPerfIntervalEntry, pwCepPerf1DayIntervalTable=pwCepPerf1DayIntervalTable, pwCepPerfIntervalSummaryErrors=pwCepPerfIntervalSummaryErrors, pwCepModuleReadOnlyCompliance=pwCepModuleReadOnlyCompliance, pwCepFracSdhVc4Tug2Map2=pwCepFracSdhVc4Tug2Map2, pwCepPerfCurrentPktsOoRngDropped=pwCepPerfCurrentPktsOoRngDropped, pwCepPeerCepOption=pwCepPeerCepOption, pwCepPerf1DayIntervalMissingPkts=pwCepPerf1DayIntervalMissingPkts, pwCepPerf1DayIntervalOutNegPtrAdjust=pwCepPerf1DayIntervalOutNegPtrAdjust, pwCepFracEntry=pwCepFracEntry, pwCepFractionalVc4Group=pwCepFractionalVc4Group, pwCepPerfIntervalAbsPtrAdjust=pwCepPerfIntervalAbsPtrAdjust, pwCepType=pwCepType, pwCepCompliances=pwCepCompliances, pwCepPerfIntervalValidData=pwCepPerfIntervalValidData, pwCepPerf1DayIntervalSESs=pwCepPerf1DayIntervalSESs, pwCepPerfCurrentInPosPtrAdjust=pwCepPerfCurrentInPosPtrAdjust, pwCepPerfCurrentSummaryErrors=pwCepPerfCurrentSummaryErrors, pwCepFracSdhVc4Mode=pwCepFracSdhVc4Mode, pwCepPerfCurrentOutNegPtrAdjust=pwCepPerfCurrentOutNegPtrAdjust, PwCepSdhVc4Ebm=PwCepSdhVc4Ebm, pwCepPerf1DayIntervalPktsOoseq=pwCepPerf1DayIntervalPktsOoseq, pwCepEntry=pwCepEntry, pwCepPerfIntervalTable=pwCepPerfIntervalTable, pwCepTable=pwCepTable, pwCepFracPeerEbm=pwCepFracPeerEbm, pwCepPerfCurrentOutPtrAdjustSecs=pwCepPerfCurrentOutPtrAdjustSecs, pwCepPerfIntervalUASs=pwCepPerfIntervalUASs, pwCepPerf1DayIntervalNumber=pwCepPerf1DayIntervalNumber, pwCepPerf1DayIntervalDbaOutPacketsHC=pwCepPerf1DayIntervalDbaOutPacketsHC, pwCepPerfIntervalInNegPtrAdjust=pwCepPerfIntervalInNegPtrAdjust, pwCepPerfIntervalPktsOoRngDropped=pwCepPerfIntervalPktsOoRngDropped, pwCepCfgMissingPktsToSes=pwCepCfgMissingPktsToSes, pwCepPerfIntervalPktsMalformed=pwCepPerfIntervalPktsMalformed, pwCepFracSdhVc4Tu3Map2=pwCepFracSdhVc4Tu3Map2, pwCepFractionalSts1Vc3Group=pwCepFractionalSts1Vc3Group, pwCepModuleFullCompliance=pwCepModuleFullCompliance, pwCepCfgEnableDBA=pwCepCfgEnableDBA, pwCepFracSdhVc4Ebm2=pwCepFracSdhVc4Ebm2, pwCepFracSdhVc4PeerEbm1=pwCepFracSdhVc4PeerEbm1, pwCepCfgRtpHdrSuppress=pwCepCfgRtpHdrSuppress, pwCepCfgTable=pwCepCfgTable, pwCepFracMode=pwCepFracMode, pwCepPerfIntervalInPosPtrAdjust=pwCepPerfIntervalInPosPtrAdjust, pwCepPerf1DayIntervalOutPtrAdjustSecs=pwCepPerf1DayIntervalOutPtrAdjustSecs, pwCepPerfCurrentGroup=pwCepPerfCurrentGroup, PwCepSonetEbm=PwCepSonetEbm, pwCepFracRowStatus=pwCepFracRowStatus, pwCepPerfCurrentDbaInPacketsHC=pwCepPerfCurrentDbaInPacketsHC, pwCepPerf1DayIntervalPktsMalformed=pwCepPerf1DayIntervalPktsMalformed, pwCepPerf1DayIntervalUASs=pwCepPerf1DayIntervalUASs, pwCepPerf1DayIntervalOutPosPtrAdjust=pwCepPerf1DayIntervalOutPosPtrAdjust, pwCepPerf1DayIntervalPktsOoRngDropped=pwCepPerf1DayIntervalPktsOoRngDropped, pwCepValidIntervals=pwCepValidIntervals, pwCepCfgGroup=pwCepCfgGroup, pwCepFracConfigError=pwCepFracConfigError, pwCepCfgPktReorder=pwCepCfgPktReorder, pwCepPerfCurrentTable=pwCepPerfCurrentTable, pwCepPerf1DayIntervalSummaryErrors=pwCepPerf1DayIntervalSummaryErrors, pwCepPerfCurrentESs=pwCepPerfCurrentESs, pwCepPerfIntervalGroup=pwCepPerfIntervalGroup, pwCepCfgConsecMissingOutSync=pwCepCfgConsecMissingOutSync, pwCepPerfCurrentUASs=pwCepPerfCurrentUASs, pwCepFracSdhVc4PeerEbm3=pwCepFracSdhVc4PeerEbm3, pwCepSignalingGroup=pwCepSignalingGroup, pwCepPerf1DayIntervalInPosPtrAdjust=pwCepPerf1DayIntervalInPosPtrAdjust, PYSNMP_MODULE_ID=pwCepStdMIB, pwCepPerfCurrentAbsPtrAdjust=pwCepPerfCurrentAbsPtrAdjust, pwCepPerfIntervalESs=pwCepPerfIntervalESs, pwCepPerfCurrentJtrBfrUnderruns=pwCepPerfCurrentJtrBfrUnderruns, pwCepFracSdhVc4Tug2Map1=pwCepFracSdhVc4Tug2Map1, pwCepPerfIntervalInPtrAdjustSecs=pwCepPerfIntervalInPtrAdjustSecs, pwCepFracVtgMap=pwCepFracVtgMap, pwCepPerfIntervalTimeElapsed=pwCepPerfIntervalTimeElapsed, pwCepCfgEntry=pwCepCfgEntry, pwCepPerfIntervalDbaInPacketsHC=pwCepPerfIntervalDbaInPacketsHC, pwCepCfgIndexNext=pwCepCfgIndexNext, pwCepCfgConsecPktsInsync=pwCepCfgConsecPktsInsync, pwCepPerfCurrentDbaOutPacketsHC=pwCepPerfCurrentDbaOutPacketsHC, pwCepPerfIntervalPktsOoseq=pwCepPerfIntervalPktsOoseq, pwCepPerfIntervalOutPtrAdjustSecs=pwCepPerfIntervalOutPtrAdjustSecs, pwCepFracSdhVc4PeerEbm2=pwCepFracSdhVc4PeerEbm2, pwCepCfgSesToUas=pwCepCfgSesToUas, pwCepStdMIB=pwCepStdMIB)

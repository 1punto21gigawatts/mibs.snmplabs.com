#
# PySNMP MIB module ZHONE-COM-IP-REC-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/ZHONE-COM-IP-REC-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:27:07 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsIntersection, SingleValueConstraint, ConstraintsUnion, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsIntersection", "SingleValueConstraint", "ConstraintsUnion", "ValueSizeConstraint")
AtmVcIdentifier, AtmVpIdentifier = mibBuilder.importSymbols("ATM-TC-MIB", "AtmVcIdentifier", "AtmVpIdentifier")
InterfaceIndex, ifIndex, InterfaceIndexOrZero = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex", "ifIndex", "InterfaceIndexOrZero")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
ObjectIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, Bits, IpAddress, Unsigned32, Integer32, Counter64, Gauge32, NotificationType, MibIdentifier, Counter32, ModuleIdentity, iso, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "ObjectIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Bits", "IpAddress", "Unsigned32", "Integer32", "Counter64", "Gauge32", "NotificationType", "MibIdentifier", "Counter32", "ModuleIdentity", "iso", "TimeTicks")
TextualConvention, TruthValue, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "TruthValue", "DisplayString")
ZhoneRDIndex, = mibBuilder.importSymbols("ZHONE-COM-IP-RD-MIB", "ZhoneRDIndex")
zhoneIp, zhoneModules = mibBuilder.importSymbols("Zhone", "zhoneIp", "zhoneModules")
ZhoneAdminString, ZhoneRowStatus = mibBuilder.importSymbols("Zhone-TC", "ZhoneAdminString", "ZhoneRowStatus")
ipRecord = ModuleIdentity((1, 3, 6, 1, 4, 1, 5504, 6, 59))
ipRecord.setRevisions(('2010-09-01 09:17', '2010-05-04 02:24', '2008-06-27 08:14', '2006-02-17 17:37', '2006-01-23 09:26', '2005-07-20 17:22', '2004-07-21 08:46', '2004-05-27 09:56', '2004-04-28 14:02', '2003-04-18 10:03', '2002-04-17 16:48', '2002-02-11 16:57', '2001-10-30 10:44', '2001-06-06 16:00', '2001-03-15 10:28', '2001-02-26 13:58', '2001-02-13 11:13', '2001-01-19 18:16', '2001-01-17 16:18', '2000-11-20 10:18', '2000-10-05 15:12', '2000-09-15 14:30', '2000-09-12 10:06',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ipRecord.setRevisionsDescriptions(('Changed maxVideoStreams upper threshold to 1024.', 'Added a new field ipOnDemandStatsEnabled in ipInterfaceEntry.', 'Added cpemgr(5) enum value to ipaddrdynamic field in ipInterfaceTable.', 'Increased maxVideoStreams to 210.', 'V01.04.09 - added support for QinQ to ipRecord.', 'V01.04.08 - Added tosOption, tosCOS, vlanCOS to IpInterfaceEntry.', 'V01.04.07 - bumped upper limit of maxVideoStreams to (6).', 'V01.04.06 - added maxVideoStreams', 'V01.04.05 - Increased the mcastControList field length from ZhoneAdminString to SnmpAdminString', 'V01.04.04 - added subnetgroup and unnumberedindex in order to support point-to-multipoint feature.', 'V01.04.03 - Obsoleted lgId.', 'V01.04.02 - Added ipAddrDynamic enum unnumbered. Added ipUnnumbered object identifiers.', 'V01.04.01 - Add ipAddrDynamic,dhcpServerEnable fields in ipInterfaceEntry and deprecate ipIfDhcp MIB.', 'V01.04.00 - Deprecated ipIfLgId and added ipIfLowerIfIndex Added ipIfPppEnabled.', 'V01.03.03 - Removed ZHONE-KEYWORD markup from ipIfAliasAddr', 'V01.03.02 - Removed DEFVAL from ipIfLgId and made this a required object.', 'V01.03.01 - Set ipIfMru default to 1500', 'V01.03.00 - Added ipIfIngressFilterId and ipIfEgressFilterId. Deprecated ipIfIngressFilterName and ipIfEgressFilterName.', 'V01.02.01 - Changed NATEnabled default to false.', 'V01.02.00 - Added ipIfAdminStatus', 'V01.01.00 - Added ipIfAliasNetMask and ipIfAliasBcastAddr', 'V01.00.01 - Added ZHONE-KEYWORD markup', 'V01.00.00 - Initial Release',))
if mibBuilder.loadTexts: ipRecord.setLastUpdated('201008310224Z')
if mibBuilder.loadTexts: ipRecord.setOrganization('Zhone Technologies, Inc.')
if mibBuilder.loadTexts: ipRecord.setContactInfo(' Postal: Zhone Technologies, Inc. @ Zhone Way 7001 Oakport Street Oakland, CA 94621 USA Toll-Free: +1 877-ZHONE20 (+1 877-946-6320) Tel: +1-510-777-7000 Fax: +1-510-777-7001 E-mail: support@zhone.com')
if mibBuilder.loadTexts: ipRecord.setDescription('IP record MIB IP Software Minneapolis, MN ')
ipRecordObjects = ObjectIdentity((1, 3, 6, 1, 4, 1, 5504, 4, 1, 9))
if mibBuilder.loadTexts: ipRecordObjects.setStatus('current')
if mibBuilder.loadTexts: ipRecordObjects.setDescription('Object identity for naming')
ipInterfaceTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 4, 1, 9, 2), )
if mibBuilder.loadTexts: ipInterfaceTable.setStatus('current')
if mibBuilder.loadTexts: ipInterfaceTable.setDescription('This table comtains information required for the management of IP interfaces.')
ipInterfaceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 4, 1, 9, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: ipInterfaceEntry.setStatus('current')
if mibBuilder.loadTexts: ipInterfaceEntry.setDescription('An entry exists for each IP interface in the system. At a mininum the ifIndex, either ipIfLowerIfIndex or ipIfLgId (not both) and a valid IP address configuration are required for row creation. These are valid IP address configurations: 1. Dynamically configured IP address ipIfDhcp set to client or both 2. Statically configured non-point-to-point IP address ipIfAddr, ipIfNetMask, and ipIfBcast must be provided. ipIfAddr and ipIfBcastAddr must be in the same subnet determined by ipIfNetMask 3. Statically configured point-to-point IP address ipIfAddr, ipIfDestAddr, ipIfNetMask, ipIfPointToPoint, and ipIfBcastEnabled must be provided. ipIfNetMask must be 255.255.255.255, ipIfPointToPoint must be true and ipIfBcastEnabled must be false. ')
ipIfLgId = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 9, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipIfLgId.setReference('see genLineRedundancy MIB: lineGroupTable.lineGroupEntry.lgId')
if mibBuilder.loadTexts: ipIfLgId.setStatus('obsolete')
if mibBuilder.loadTexts: ipIfLgId.setDescription('This field has been deprecated and replaced by ipIfLowerIfIndex. The ID number of the Line Redundancy Group containing the physical line associated with this interface. There may be a single line or a line pair in a redundancy group. The value 0 is only allowed when the ip interface has not yet been bound to a physical port. Currently, IP interfaces are always bound to a physical port so the value of zero is not allowed.')
ipIfVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 9, 2, 1, 2), AtmVpIdentifier()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipIfVpi.setStatus('current')
if mibBuilder.loadTexts: ipIfVpi.setDescription('If this IP interface is on an ATM VC, the ATM VPI is specified here. If the IP interface is not an ATM VC, this field is ignored. The VPI value for a VPL or VCL. The value VPI=0 is only allowed for a VCL. For ATM UNIs supporting VPCs the VPI value ranges from 0 to 255. The VPI value 0 is supported for ATM UNIs conforming to the ATM Forum UNI 4.0 Annex 8 (Virtual UNIs) specification. For ATM UNIs supporting VCCs the VPI value ranges from 0 to 255. For ATM NNIs the VPI value ranges from 0 to 4095. The maximum VPI value cannot exceed the value allowable by atmInterfaceMaxVpiBits defined in ATM-MIB.')
ipIfVci = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 9, 2, 1, 3), AtmVcIdentifier()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipIfVci.setStatus('current')
if mibBuilder.loadTexts: ipIfVci.setDescription('If this IP interface is on an ATM VC, the ATM VCI is specified here. If the IP interface is not an ATM VC, this field is ignored. The maximum VCI value cannot exceed the value allowable by atmInterfaceMaxVciBits defined in ATM-MIB.')
ipIfRDIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 9, 2, 1, 4), ZhoneRDIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipIfRDIndex.setStatus('current')
if mibBuilder.loadTexts: ipIfRDIndex.setDescription('The Routing Domain Index. An IP address is unique only to the routing domain, therefore we must specify the routing domain in which this interface belongs.')
ipIfDhcp = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 9, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("noDhcp", 1), ("dhcpClient", 2), ("dhcpServer", 3), ("dhcpBoth", 4))).clone('noDhcp')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipIfDhcp.setStatus('deprecated')
if mibBuilder.loadTexts: ipIfDhcp.setDescription('This enumeration indicates whether this interface is a dhcp client, a dhcp server, both, or neither. The default value is noDhcp. ')
ipIfAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 9, 2, 1, 6), IpAddress().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipIfAddr.setReference('See RFC2011: ip.ipAddrTable.ipAddrEntry.ipAdEntAddr')
if mibBuilder.loadTexts: ipIfAddr.setStatus('current')
if mibBuilder.loadTexts: ipIfAddr.setDescription("The IP address to which this entry's addressing information pertains. ")
ipIfNetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 9, 2, 1, 7), IpAddress().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipIfNetMask.setReference('See RFC2011: ip.ipAddrTable.ipAddrEntry.ipAdEntNetMask')
if mibBuilder.loadTexts: ipIfNetMask.setStatus('current')
if mibBuilder.loadTexts: ipIfNetMask.setDescription('The subnet mask associated with the IP address of this entry. The value of the mask is an IP address with all the network bits set to 1 and all the hosts bits set to 0.')
ipIfBcastAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 9, 2, 1, 8), IpAddress().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipIfBcastAddr.setReference('See RFC2011: ip.ipAddrTable.ipAddrEntry.ipAdEntBcastAddr')
if mibBuilder.loadTexts: ipIfBcastAddr.setStatus('current')
if mibBuilder.loadTexts: ipIfBcastAddr.setDescription('The IP broadcast address used for sending datagrams on the (logical) interface associated with the IP address of this entry. ')
ipIfDestAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 9, 2, 1, 9), IpAddress().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipIfDestAddr.setReference('See RFC2011: ip.ipAddrTable.ipAddrEntry.ipAdEnDestAddr')
if mibBuilder.loadTexts: ipIfDestAddr.setStatus('current')
if mibBuilder.loadTexts: ipIfDestAddr.setDescription('The destination address for point-to-point ip interfaces. This object will be ignored for non point-to-point ip interfaces.')
ipIfFarEndAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 9, 2, 1, 10), IpAddress().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipIfFarEndAddr.setStatus('current')
if mibBuilder.loadTexts: ipIfFarEndAddr.setDescription('The IP address of the interface on the far end of this interface. This information is needed for Zhone Automatic Provisioning.')
ipIfMru = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 9, 2, 1, 11), Unsigned32().clone(1500)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipIfMru.setStatus('current')
if mibBuilder.loadTexts: ipIfMru.setDescription('The size of the largest packet which can be received on the interface, specified in octets. For interfaces that are used for network datagrams, this is the size of the largest network datagram that can be received on the interface.')
ipIfReasmMaxSize = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 9, 2, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(65535)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipIfReasmMaxSize.setReference('See RFC2011: ip.ipAddrTable.ipAddrEntry.ipAdEntReasmMaxSize')
if mibBuilder.loadTexts: ipIfReasmMaxSize.setStatus('current')
if mibBuilder.loadTexts: ipIfReasmMaxSize.setDescription('The size of the largest IP datagram which this entity can re-assemble from incoming IP fragmented datagrams received on this interface.')
ipIfIngressFilterName = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 9, 2, 1, 13), ZhoneAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipIfIngressFilterName.setReference('See comIpFilter.mib: filterSpecTable.filterSpecEntry.filterSpecName')
if mibBuilder.loadTexts: ipIfIngressFilterName.setStatus('deprecated')
if mibBuilder.loadTexts: ipIfIngressFilterName.setDescription('The name of the ingress filter associated with this interface. This object has been replaced by ipIfIngressFilterID.')
ipIfEgressFilterName = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 9, 2, 1, 14), ZhoneAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipIfEgressFilterName.setReference('See comIpFilter.mib: filterSpecTable.filterSpecEntry.filterSpecName')
if mibBuilder.loadTexts: ipIfEgressFilterName.setStatus('deprecated')
if mibBuilder.loadTexts: ipIfEgressFilterName.setDescription('The name of the egress filter associated with this interface. This object has been replaced by ipIfEgressFilterID.')
ipIfPointToPoint = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 9, 2, 1, 15), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipIfPointToPoint.setStatus('current')
if mibBuilder.loadTexts: ipIfPointToPoint.setDescription("This flag is set to 'true(1)' if the interface is point to point and the value 'false(2)' otherwise.")
ipIfMcastEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 9, 2, 1, 16), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipIfMcastEnabled.setStatus('current')
if mibBuilder.loadTexts: ipIfMcastEnabled.setDescription("This object has the value 'true(1)' If multicast is enabled on this interface and the value 'false(2)' otherwise.")
ipIfIpFwdEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 9, 2, 1, 17), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipIfIpFwdEnabled.setStatus('current')
if mibBuilder.loadTexts: ipIfIpFwdEnabled.setDescription("This object has the value 'true(1)' If ip forwarding is enabled on this interface and the value 'false(2)' otherwise.")
ipIfMcastFwdEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 9, 2, 1, 18), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipIfMcastFwdEnabled.setStatus('current')
if mibBuilder.loadTexts: ipIfMcastFwdEnabled.setDescription("This object has the value 'true(1)' If multicast forwarding is enabled on this interface and the value 'false(2)' otherwise.")
ipIfNATEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 9, 2, 1, 19), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipIfNATEnabled.setStatus('current')
if mibBuilder.loadTexts: ipIfNATEnabled.setDescription("This object has the value 'true(1)' if NAT is enabled on this interface and the value 'false(2)' otherwise. The default value is false.")
ipIfBcastEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 9, 2, 1, 20), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipIfBcastEnabled.setStatus('current')
if mibBuilder.loadTexts: ipIfBcastEnabled.setDescription("This object has the value 'true(1)' If broadcast is enabled on this interface and the value 'false(2)' otherwise.")
ipIfRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 9, 2, 1, 21), ZhoneRowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipIfRowStatus.setStatus('current')
if mibBuilder.loadTexts: ipIfRowStatus.setDescription('This object is used to create and remove rows in the table. See ipInterfaceEntry description for minimum requirements.')
ipIfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 9, 2, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipIfAdminStatus.setReference('See RFC2233: interfaces.ifTable.ifEntry.ifAdminStatus')
if mibBuilder.loadTexts: ipIfAdminStatus.setStatus('current')
if mibBuilder.loadTexts: ipIfAdminStatus.setDescription('The desired state of the interface. The testing(3) state indicates that no operational packets can be passed. When a managed system initializes, all interfaces start with ifAdminStatus in the down(2) state. As a result of either explicit management action or per configuration information retained by the managed system, ifAdminStatus is then changed to either the up(1) or testing(3) states (or remains in the down(2) state). This is the same as the ifAdminStatus in the ifTable (RFC2233). We require it to be in this table in order to set it on a row-create.')
ipIfIngressPacketRuleGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 9, 2, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipIfIngressPacketRuleGroupIndex.setReference('See comBridgeRec.mib: packetRuleTable.packetRuleEntry.packetRuleIndex')
if mibBuilder.loadTexts: ipIfIngressPacketRuleGroupIndex.setStatus('current')
if mibBuilder.loadTexts: ipIfIngressPacketRuleGroupIndex.setDescription('The group index of the ingress filter (packet rule entry /entries) provisioned for this interface. A value of 0 means there is no ingress filter provisioned for this interface. ')
ipIfEgressPacketRuleGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 9, 2, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipIfEgressPacketRuleGroupIndex.setReference('See comBridgeRec.mib: packetRuleTable.packetRuleEntry.packetRuleIndex')
if mibBuilder.loadTexts: ipIfEgressPacketRuleGroupIndex.setStatus('current')
if mibBuilder.loadTexts: ipIfEgressPacketRuleGroupIndex.setDescription('The group index of the egress filter (packet rule entry /entries) provisioned for this interface. A value of 0 means there is no egress filter provisioned for this interface. ')
ipIfLowerIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 9, 2, 1, 25), InterfaceIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipIfLowerIfIndex.setReference('See ifStackTable in rfc2233.mib.')
if mibBuilder.loadTexts: ipIfLowerIfIndex.setStatus('current')
if mibBuilder.loadTexts: ipIfLowerIfIndex.setDescription('The ifIndex of the lower layer interface to which this IP interface should be bound. If this IP interface is bound dynamically to a lower layer (e.g. for PPP), this object should be set to zero. Upon setting this field, the ifStack will be modified to reflect the appropriate binding. This object is required for row creation.')
ipIfPppEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 9, 2, 1, 26), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipIfPppEnabled.setReference('pppNCPExtensionsTable: comPpp.mib pppIpConfigTable: rfc1473.mib pppIpTable: rfc1473.mib')
if mibBuilder.loadTexts: ipIfPppEnabled.setStatus('current')
if mibBuilder.loadTexts: ipIfPppEnabled.setDescription("This field is used to indicate that this IP interface is to be bound to a PPP interface. When this object is set to 'true', rows will be created in the pppNCPExtensionsTable, pppIfConfigTable, and pppIfTable. When this object is set to 'false', these rows will be destroyed.")
ipAddrDynamic = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 9, 2, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("static", 1), ("ppp", 2), ("dhcpclient", 3), ("unnumbered", 4), ("cpemgr", 5))).clone('static')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipAddrDynamic.setStatus('current')
if mibBuilder.loadTexts: ipAddrDynamic.setDescription('This is the mode by which the IP address is discovered by the system. STATIC - Means,The IP address is Statically configured. DHCPCLIENT - IP address discovered from DHCPCLIENT PPP - Use PPP to get IP address. UNNUMBERED - this is an unnumbered interface. CPEMGR - IP address configured by CPE Manager.')
dhcpServerEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 9, 2, 1, 28), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dhcpServerEnable.setStatus('current')
if mibBuilder.loadTexts: dhcpServerEnable.setDescription('If this field is set to TRUE ,then ipAddrDynamic has to be STATIC and if and when Dhcp server is not enabled then ipAddrdynamic can set to STATIC,PPP or DHCPCLIENT.')
dhcpSubnetGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 9, 2, 1, 29), Integer32().clone(0)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpSubnetGroup.setStatus('current')
if mibBuilder.loadTexts: dhcpSubnetGroup.setDescription('This is the DHCP Subnet group ID, it indicates which address pool grouping may be used for the CPE subnet.Needed to support the point-to-multipoint model.')
unnumberedIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 9, 2, 1, 30), Integer32().clone(0)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: unnumberedIndex.setStatus('current')
if mibBuilder.loadTexts: unnumberedIndex.setDescription('The index of the ip-unnumbered-record to use to obtain the local side Unnumbered Address. This is need in order to support the IP point-to-multipoint model.')
mcastControlList = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 9, 2, 1, 31), SnmpAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mcastControlList.setStatus('current')
if mibBuilder.loadTexts: mcastControlList.setDescription('List of Mcast-control-ids this IP Interface record is associated with.')
vlanid = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 9, 2, 1, 32), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vlanid.setStatus('current')
if mibBuilder.loadTexts: vlanid.setDescription('This is the Virtual LAN Identifier for the IP Interface. If the VLAN ID specified is non-zero, all traffic destined to this interface should have the VLAN ID specified.')
maxVideoStreams = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 9, 2, 1, 33), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1024))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: maxVideoStreams.setStatus('current')
if mibBuilder.loadTexts: maxVideoStreams.setDescription('This is the maximum number of unique multicast (video) streams that this interface has subscribed to.')
tosOption = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 9, 2, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("tosOptionDisable", 1), ("tosOptionOriginate", 2), ("tosOptionAll", 3))).clone('tosOptionDisable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tosOption.setStatus('current')
if mibBuilder.loadTexts: tosOption.setDescription('Determines IP TOS Class-Of-Service bit setting on packets sent out this interface. The setting is stored in the tosCOS field. disable - COS setting is untouched. For packets we originate, COS value is set to 0. originate - Load COS bits only if we originate packet. COS for packets routed through this interface are not affected. all - Load COS bits on all packets.')
tosCOS = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 9, 2, 1, 35), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tosCOS.setStatus('current')
if mibBuilder.loadTexts: tosCOS.setDescription('The COS bit value to load based on tosOption setting.')
vlanCOS = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 9, 2, 1, 36), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vlanCOS.setStatus('current')
if mibBuilder.loadTexts: vlanCOS.setDescription('COS value loaded into VLAN header. Applicable only if the vlanid is non-zero.')
ipStagTPID = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 9, 2, 1, 37), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(33024, 33024), ValueRangeConstraint(34984, 34984), ValueRangeConstraint(37120, 37120), ValueRangeConstraint(37376, 37376), )).clone(33024)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipStagTPID.setStatus('current')
if mibBuilder.loadTexts: ipStagTPID.setDescription('The value of the tag protocol identifier that is being used for QinQ packets.( 0x8100 is default)')
ipStagId = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 9, 2, 1, 38), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipStagId.setStatus('current')
if mibBuilder.loadTexts: ipStagId.setDescription('The s-tag value that we are expecting to put on packets that are Rxed on this interface.')
ipStagIdCOS = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 9, 2, 1, 39), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipStagIdCOS.setStatus('current')
if mibBuilder.loadTexts: ipStagIdCOS.setDescription('The s-tag COS to be used when doing s-tag intertion.')
ipOnDemandStatsEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 9, 2, 1, 40), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipOnDemandStatsEnabled.setStatus('current')
if mibBuilder.loadTexts: ipOnDemandStatsEnabled.setDescription('If true, the on-demand stats collection for this Ip interface will be enabled.')
ipIfAliasTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 4, 1, 9, 5), )
if mibBuilder.loadTexts: ipIfAliasTable.setStatus('current')
if mibBuilder.loadTexts: ipIfAliasTable.setDescription('The table containing alias addresses for ip interfaces.')
ipIfAliasEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 4, 1, 9, 5, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ZHONE-COM-IP-REC-MIB", "ipIfAliasAddr"))
if mibBuilder.loadTexts: ipIfAliasEntry.setStatus('current')
if mibBuilder.loadTexts: ipIfAliasEntry.setDescription('Each row is indexed by an ifIndex and an ip alias address. At a mininum the ipIfAlias Addr must be present to create a row.')
ipIfAliasAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 9, 5, 1, 1), IpAddress())
if mibBuilder.loadTexts: ipIfAliasAddr.setStatus('current')
if mibBuilder.loadTexts: ipIfAliasAddr.setDescription('The ip alias address.')
ipIfAliasRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 9, 5, 1, 2), ZhoneRowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipIfAliasRowStatus.setStatus('current')
if mibBuilder.loadTexts: ipIfAliasRowStatus.setDescription('The row status for creating and destroying ip aliases. To create a row, both the ifIndex and the ipIfAliasAddr must be provided.')
ipIfAliasNetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 9, 5, 1, 3), IpAddress().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipIfAliasNetMask.setStatus('current')
if mibBuilder.loadTexts: ipIfAliasNetMask.setDescription('The subnet mask associated with the IP address of this interface alias entry. The value of the mask is an IP address with all the network bits set to 1 and all the hosts bits set to 0.')
ipIfAliasBcastAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 9, 5, 1, 4), IpAddress().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipIfAliasBcastAddr.setStatus('current')
if mibBuilder.loadTexts: ipIfAliasBcastAddr.setDescription('The IP broadcast address used for sending datagrams on the (logical) interface associated with the IP address of this interface alias entry. ')
ipUnnumbered = ObjectIdentity((1, 3, 6, 1, 4, 1, 5504, 4, 1, 10))
if mibBuilder.loadTexts: ipUnnumbered.setStatus('deprecated')
if mibBuilder.loadTexts: ipUnnumbered.setDescription('The user can specify the name of the interface to borrow for the local IP address of P-T-P links. The user sets ipUnnumberedEnabled to true and then sets the ipUnnumberedInterfaceIndex to the ifIndex of the ip-interface-record which contains the static address they want to use. This static address will be used for all unnumbered interfaces in the system.')
ipUnnumberedEnabled = MibScalar((1, 3, 6, 1, 4, 1, 5504, 4, 1, 10, 1), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipUnnumberedEnabled.setStatus('deprecated')
if mibBuilder.loadTexts: ipUnnumberedEnabled.setDescription('If set to True, this profile in enabled and the unit can be configured to support unnumbered point to point interfaces. If set to False, unnumbered interface support is disabled.')
ipUnnumberedInterfaceIndex = MibScalar((1, 3, 6, 1, 4, 1, 5504, 4, 1, 10, 2), InterfaceIndexOrZero()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipUnnumberedInterfaceIndex.setStatus('deprecated')
if mibBuilder.loadTexts: ipUnnumberedInterfaceIndex.setDescription("The name of the interface use to 'borrow' the IP address of for unnumbered interfaces. The source IP address of all outgoing packets on unnumbered interfaces will use the IP address of this interface.")
ipUnnumberedObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 5504, 4, 1, 14))
ipUnnumberedObjectNext = MibScalar((1, 3, 6, 1, 4, 1, 5504, 4, 1, 14, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipUnnumberedObjectNext.setStatus('current')
if mibBuilder.loadTexts: ipUnnumberedObjectNext.setDescription('A hint for the next free ipUnnumberedIndex that can be used.')
ipUnnumberedTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 4, 1, 14, 2), )
if mibBuilder.loadTexts: ipUnnumberedTable.setStatus('current')
if mibBuilder.loadTexts: ipUnnumberedTable.setDescription('The current set of ipUnnumbered binding for this box.')
ipUnnumberedEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 4, 1, 14, 2, 1), ).setIndexNames((0, "ZHONE-COM-IP-REC-MIB", "ipUnnumberedIndex"))
if mibBuilder.loadTexts: ipUnnumberedEntry.setStatus('current')
if mibBuilder.loadTexts: ipUnnumberedEntry.setDescription('An ipUnnumberedEntry.')
ipUnnumberedIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 14, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)))
if mibBuilder.loadTexts: ipUnnumberedIndex.setStatus('current')
if mibBuilder.loadTexts: ipUnnumberedIndex.setDescription('This value is only used to identify this particular entry in the table, it is not externally visible!')
ipUnnumberedRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 14, 2, 1, 2), ZhoneRowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipUnnumberedRowStatus.setStatus('current')
if mibBuilder.loadTexts: ipUnnumberedRowStatus.setDescription('RowStatus is used to create/delete entries in the table.')
ipUnnumberedIfIName = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 14, 2, 1, 3), InterfaceIndex().clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipUnnumberedIfIName.setStatus('current')
if mibBuilder.loadTexts: ipUnnumberedIfIName.setDescription('This value specifies where to borrow the local IP address of the P-T-M link.')
mibBuilder.exportSymbols("ZHONE-COM-IP-REC-MIB", ipIfNATEnabled=ipIfNATEnabled, ipIfAliasTable=ipIfAliasTable, ipIfBcastAddr=ipIfBcastAddr, ipAddrDynamic=ipAddrDynamic, ipIfBcastEnabled=ipIfBcastEnabled, vlanid=vlanid, ipIfPppEnabled=ipIfPppEnabled, vlanCOS=vlanCOS, ipIfNetMask=ipIfNetMask, ipUnnumberedObjectNext=ipUnnumberedObjectNext, ipIfAdminStatus=ipIfAdminStatus, maxVideoStreams=maxVideoStreams, ipRecordObjects=ipRecordObjects, ipStagId=ipStagId, ipIfAliasRowStatus=ipIfAliasRowStatus, ipIfReasmMaxSize=ipIfReasmMaxSize, ipStagIdCOS=ipStagIdCOS, tosOption=tosOption, PYSNMP_MODULE_ID=ipRecord, ipStagTPID=ipStagTPID, ipIfAliasNetMask=ipIfAliasNetMask, ipIfMcastEnabled=ipIfMcastEnabled, ipUnnumbered=ipUnnumbered, ipIfVci=ipIfVci, ipRecord=ipRecord, ipIfFarEndAddr=ipIfFarEndAddr, tosCOS=tosCOS, ipUnnumberedObjects=ipUnnumberedObjects, ipUnnumberedIfIName=ipUnnumberedIfIName, mcastControlList=mcastControlList, ipUnnumberedEnabled=ipUnnumberedEnabled, unnumberedIndex=unnumberedIndex, ipIfPointToPoint=ipIfPointToPoint, ipIfAliasBcastAddr=ipIfAliasBcastAddr, ipIfIngressPacketRuleGroupIndex=ipIfIngressPacketRuleGroupIndex, ipIfAliasEntry=ipIfAliasEntry, ipIfEgressPacketRuleGroupIndex=ipIfEgressPacketRuleGroupIndex, ipUnnumberedRowStatus=ipUnnumberedRowStatus, ipIfRowStatus=ipIfRowStatus, dhcpSubnetGroup=dhcpSubnetGroup, ipIfIngressFilterName=ipIfIngressFilterName, ipIfDestAddr=ipIfDestAddr, ipUnnumberedEntry=ipUnnumberedEntry, ipIfEgressFilterName=ipIfEgressFilterName, ipInterfaceTable=ipInterfaceTable, ipIfDhcp=ipIfDhcp, ipIfAddr=ipIfAddr, ipOnDemandStatsEnabled=ipOnDemandStatsEnabled, ipIfAliasAddr=ipIfAliasAddr, ipUnnumberedIndex=ipUnnumberedIndex, ipIfLgId=ipIfLgId, ipInterfaceEntry=ipInterfaceEntry, ipIfMru=ipIfMru, ipIfLowerIfIndex=ipIfLowerIfIndex, ipUnnumberedInterfaceIndex=ipUnnumberedInterfaceIndex, dhcpServerEnable=dhcpServerEnable, ipIfVpi=ipIfVpi, ipUnnumberedTable=ipUnnumberedTable, ipIfMcastFwdEnabled=ipIfMcastFwdEnabled, ipIfRDIndex=ipIfRDIndex, ipIfIpFwdEnabled=ipIfIpFwdEnabled)

#
# PySNMP MIB module TMU-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/TMU-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:23:46 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ConstraintsIntersection, ValueSizeConstraint, SingleValueConstraint, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ConstraintsIntersection", "ValueSizeConstraint", "SingleValueConstraint", "ValueRangeConstraint")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
internet, iso, Integer32, Gauge32, mgmt, IpAddress, Counter64, MibScalar, MibTable, MibTableRow, MibTableColumn, Unsigned32, MibIdentifier, TimeTicks, Bits, ModuleIdentity, NotificationType, ObjectIdentity, Counter32 = mibBuilder.importSymbols("SNMPv2-SMI", "internet", "iso", "Integer32", "Gauge32", "mgmt", "IpAddress", "Counter64", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Unsigned32", "MibIdentifier", "TimeTicks", "Bits", "ModuleIdentity", "NotificationType", "ObjectIdentity", "Counter32")
TextualConvention, MacAddress, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "MacAddress", "DisplayString")
mgmt = MibIdentifier((1, 3, 6, 1, 2))
private = MibIdentifier((1, 3, 6, 1, 4))
enterprises = MibIdentifier((1, 3, 6, 1, 4, 1))
fibronics = MibIdentifier((1, 3, 6, 1, 4, 1, 22))
tmu = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 60))
tmuSystem = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 60, 1))
tmuIntrfc = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 60, 2))
tmuMatch = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 60, 3))
tmuStations = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 60, 4))
tmuPorts = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 60, 5))
tmuProduction = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 60, 6))
tmuSecurity = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 60, 7))
tmuFunction = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 60, 8))
fibTmuFunctRtpGrpVrsRun = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 60, 8, 1))
fibTmuFunctRtpGrpVrsPerm = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 60, 8, 2))
fibTmuNumEventErrs = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuNumEventErrs.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuNumEventErrs.setDescription("Cyclic counter. Indicates how many times the event-handler procedure has been called with the 'ERR' severity level or higher.")
fibTmuArpAgeTime = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 1, 2), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuArpAgeTime.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuArpAgeTime.setDescription('The value of the system timer [in SYS-TICKs] at the last time ARP aging was carried out.')
fibTmuNumRarpUpdate = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuNumRarpUpdate.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuNumRarpUpdate.setDescription("Cyclic counter. Indicates how many times the system's IP address was updated because of a RARP message.")
fibTmuMainSwVersion = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuMainSwVersion.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuMainSwVersion.setDescription('United version for all software packages in this system.')
fibTmuEepromVersion = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuEepromVersion.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuEepromVersion.setDescription('Version of the eeprom package')
fibTmuEepromDeffective = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuEepromDeffective.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuEepromDeffective.setDescription('System information. Set when eeprom is found to be physically deffective and can not be read nor written to.')
fibTmuLastSysIfIndex = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuLastSysIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuLastSysIfIndex.setDescription('Number of inteface via which the last ip message was received. Currently interfaces 1->3 are token ring interfaces and interface 4 is the serial/slip interface.')
fibTmuTrDrvVersion = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuTrDrvVersion.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuTrDrvVersion.setDescription('The software version of the token ring driver as received from the driver at initialization.')
fibTmuSccDrvVersion = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuSccDrvVersion.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuSccDrvVersion.setDescription('The software version of the serial line driver as received from the driver at initialization.')
fibTmuSnmpUsrVersion = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuSnmpUsrVersion.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuSnmpUsrVersion.setDescription('The software version of the sw package employing udp/ip/snmp and the preliminary reduction of messages from any of the interfaces. Loaded at initialization.')
fibTmuDisplayDebugMode = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("regular-mode", 1), ("special-debug-mode", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fibTmuDisplayDebugMode.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuDisplayDebugMode.setDescription('Flag indicating whether system is in a special debug mode. In that mode, extra code is executed to output indications on system state.')
fibTmuEeFaultsFormat = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("full-mode", 1), ("concise-mode", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fibTmuEeFaultsFormat.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuEeFaultsFormat.setDescription("Flag indicating whether faults stored in eeprom will each take a small eeprom space or a large eeprom space. If the 'small' option is chosen, only so many first bytes of the fault text are stored but the number of stored faults is larger. This value is stored in eeprom and becomes effective only after the next reset.")
fibTmuRunFaultsFormat = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("full-mode", 1), ("concise-mode", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuRunFaultsFormat.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuRunFaultsFormat.setDescription('This is the run time value of flag described in eeFaultsFormat above.')
fibTmuFunctionalityVersion = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuFunctionalityVersion.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuFunctionalityVersion.setDescription('The software version of the sw package which realizes the recovery process when the token ring fails (e.g. beaconing). Loaded at initialization.')
fibTmuUtilitiesVersion = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuUtilitiesVersion.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuUtilitiesVersion.setDescription('The software version of the sw package containing operating system and hw utilities. Loaded at initialization.')
fibTmuWrapIn = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("no-wrap", 1), ("wrap-set-by-manager", 2), ("wrap-set-by-Tmu", 3), ("wrap-set-by-both", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fibTmuWrapIn.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuWrapIn.setDescription("Get: Read the state of the specified relay (wrap on 'ring in' port on trunk). Wrap may be set either by the manager or by the Tmu due to some errors on the trunk. Set: Only two values are allowed. 'no-wrap' indicates 'open the relay and attach the trunk' 'wrap-set-by-manager' indicates 'detach the trunk' ")
fibTmuWrapOut = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("no-wrap", 1), ("wrap-set-by-manager", 2), ("wrap-set-by-Tmu", 3), ("wrap-set-by-both", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fibTmuWrapOut.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuWrapOut.setDescription("Get: Read the state of the specified relay (wrap on 'ring Out' port on trunk). Wrap may be set either by the manager or by the Tmu due to some errors on the trunk. Set: Only two values are allowed. 'no-wrap' indicates 'open the relay and attach the trunk' 'wrap-set-by-manager' indicates 'detach the trunk' ")
fibTmuLoadEeDefaults = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dont-load-default", 1), ("load-defaults", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fibTmuLoadEeDefaults.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuLoadEeDefaults.setDescription("When this object is set, the Tmu system is instructed to load non volatile memory by default values at the next reset. Get: Read the value the system will use on the next reset. Set: If 'load-defults' is written then at the next system reset, non volatile ram will be loaded by default values and the object will automatically be loaded by 'dont-load-defaults'. Note that, among other things, Tmu will lose, in this case, its IP address.")
fibTmuDontResetFatal = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("reset-fatal", 1), ("dont-reset-fatal", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fibTmuDontResetFatal.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuDontResetFatal.setDescription("When this object is set, the Tmu system is instructed to reset the system when a fatal error has been detected. For debug purposes. In regular cases, this variable is set to 'reset-fatal'.")
fibTmuRIConnection = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("none", 0), ("copper", 1), ("fiber", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuRIConnection.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuRIConnection.setDescription('GET: Read what kind of trank is connected to Ring In port. At board type 9232/nn has no value.')
fibTmuROConnection = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("none", 0), ("copper", 1), ("fiber", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuROConnection.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuROConnection.setDescription('GET: Read what kind of trank is connected to Ring Out port. At board type 9232/nn has no value.')
fibTmuRealTimeClock = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 1, 22), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(23, 23)).setFixedLength(23)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fibTmuRealTimeClock.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuRealTimeClock.setDescription('Get: Read real time with format hh:mm:ss DDD dd/MMM/yy. Set: Recive Display string of format hh:mm:ss DDD dd/MMM/yy.')
fibTmuIntrfcTable = MibTable((1, 3, 6, 1, 4, 1, 22, 60, 2, 1), )
if mibBuilder.loadTexts: fibTmuIntrfcTable.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuIntrfcTable.setDescription('Table containing information and control items concerning a specific IP handling interface.')
fibTmuIntrfcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 22, 60, 2, 1, 1), ).setIndexNames((0, "TMU-MIB", "fibTmuIntrfcIndex"))
if mibBuilder.loadTexts: fibTmuIntrfcEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuIntrfcEntry.setDescription('Entry of information and control items concerning a specific IP handling interface.')
fibTmuIntrfcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuIntrfcIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuIntrfcIndex.setDescription('The value of this object identifies the IP interface for which this entry contains management information. The value of this object for a particular interface has the same value as the ifIndex object defined for the same interface.')
fibTmuNumRarpRcvd = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 2, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuNumRarpRcvd.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuNumRarpRcvd.setDescription('Cyclic counter. Contains the number of rarp response messages received via this interface. Meaningful for Token Ring interfaces only.')
fibTmuNumRxRjctMem = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 2, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuNumRxRjctMem.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuNumRxRjctMem.setDescription('Cyclic counter. Contains the number of non-mac messages which were received by the tr chip but rejected by the higher sw levels because there was no memory.')
fibTmuNumRxAccepted = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 2, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuNumRxAccepted.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuNumRxAccepted.setDescription('Cyclic counter. Contains the number of non-mac frames received by higher level sw.')
fibTmuNumRxBdcst = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 2, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuNumRxBdcst.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuNumRxBdcst.setDescription('Cyclic counter. Contains the number of non-mac broadcast frames received by higher level SW. Meaningful for Token Ring interfaces only.')
fibTmuNumRxSpecific = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 2, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuNumRxSpecific.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuNumRxSpecific.setDescription('Cyclic counter. Contains the number of non-mac specific [non-broadcast, non-functional, non-group] frames received by higher level SW. Meaningful for Token Ring interfaces only.')
fibTmuNumRifIncluded = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 2, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuNumRifIncluded.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuNumRifIncluded.setDescription('Cyclic counter. Contains the number of non-mac frames with routing info field received by higher level SW. Meaningful for Token Ring interfaces only.')
fibTmuNumNoRif = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 2, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuNumNoRif.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuNumNoRif.setDescription('Cyclic counter. Contains the number of non-mac frames without routing info field received by higher level SW. Meaningful for Token Ring interfaces only.')
fibTmuNumNonSnap = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 2, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuNumNonSnap.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuNumNonSnap.setDescription('Cyclic counter. Contains the number of non-mac frames which were not snap messages and which were handed over to higher level SW by the mac level SW. These messages are rejected. Meaningful for Token Ring interfaces only.')
fibTmuNumUnknownType = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 2, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuNumUnknownType.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuNumUnknownType.setDescription("Cyclic counter. Contains the number of non-mac frames which had an unknown 'TYPE' field in the snap header and which were handed over to higher level SW by the mac level SW. These messages are rejected. Meaningful for Token Ring interfaces only.")
fibTmuNumRifLong = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 2, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuNumRifLong.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuNumRifLong.setDescription('Cyclic counter. Contains the number of non-mac frames which had a routing information field [rif] which was longer than the UDPIP package can take [for learning]. Meaningful for Token Ring interfaces only.')
fibTmuNumRrpRjctIp = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 2, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuNumRrpRjctIp.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuNumRrpRjctIp.setDescription('Cyclic counter. Contains the number of rarp messages which were rejected because the message contents was illegal [e.g. illegal ip address]. Meaningful for Token Ring interfaces only.')
fibTmuNumArpRcvd = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 2, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuNumArpRcvd.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuNumArpRcvd.setDescription('Cyclic counter. Contains the number of arp response messages received via this interface. Meaningful for Token Ring interfaces only.')
fibTmuNumIpRcvd = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 2, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuNumIpRcvd.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuNumIpRcvd.setDescription('Cyclic counter. Contains the number of ip response messages received via this interface.')
fibTmuNumIfDown = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 2, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuNumIfDown.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuNumIfDown.setDescription("Cyclic counter. Number of times a message was directed to an interface which was 'down'.")
fibTmuNumOwnBrdcst = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 2, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuNumOwnBrdcst.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuNumOwnBrdcst.setDescription("Cyclic counter. Contains the number of broadcast frames which were received in one of the system's macs and which were very same messages sent by one of the system's macs. The mac hw receives broadcast messages even if they were sent by the mac's own 48 bits address. These messages are rejected. Meaningful for Token Ring interfaces only.")
fibTmuAc00Cntr = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 2, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuAc00Cntr.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuAc00Cntr.setDescription("Cyclic counter. Contains the number of frames which were received with the 'A' and 'C' bits both '0'. Meaningful for Token Ring interfaces only.")
fibTmuAc01Cntr = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 2, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuAc01Cntr.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuAc01Cntr.setDescription("Cyclic counter. contains the number of frames which were received with the 'A' and 'C' bits equal to '0' and '1'. Meaningful for Token Ring interfaces only.")
fibTmuAc10Cntr = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 2, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuAc10Cntr.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuAc10Cntr.setDescription("Cyclic counter. Contains the number of frames which were received with the 'A' and 'C' bits equal to '1' and '0'. Meaningful for Token Ring interfaces only.")
fibTmuAc11Cntr = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 2, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuAc11Cntr.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuAc11Cntr.setDescription("Cyclic counter. Contains the number of frames which were received with the 'A' and 'C' bits equal to '1' and '1'.")
fibTmuParityEc = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 2, 1, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuParityEc.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuParityEc.setDescription('Cyclic counter. Contains the number of times scc reported parity error [per character]. Meaningful for serial intefaces only.')
fibTmuFrameEc = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 2, 1, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuFrameEc.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuFrameEc.setDescription('Cyclic counter. Contains the number of times scc reported framing error [per character]. Meaningful for serial intefaces only.')
fibTmuRxNoiseEc = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 2, 1, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuRxNoiseEc.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuRxNoiseEc.setDescription('Cyclic counter. Contains the number of times scc reported noise error [per character]. Meaningful for serial intefaces only.')
fibTmuBreakEc = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 2, 1, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuBreakEc.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuBreakEc.setDescription('Cyclic counter. Contains the number of times scc reported break character was received. Meaningful for serial intefaces only.')
fibTmuNumConfigNotValid = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 2, 1, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuNumConfigNotValid.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuNumConfigNotValid.setDescription("Cyclic counter. Contains the number of times get-naun or get-config of tr driver reported 'MAC-ERR-CONFIG-NOT-VALID'. Meaningful for Token Ring interfaces only.")
fibTmuNumAddrNotFound = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 2, 1, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuNumAddrNotFound.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuNumAddrNotFound.setDescription("Cyclic counter. Contains the number of times get-naun or get-config of tr driver reported 'MAC-ERR-ADDR-NOT-FOUND'. Meaningful for Token Ring interfaces only.")
fibTmuNumProcessDisabled = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 2, 1, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuNumProcessDisabled.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuNumProcessDisabled.setDescription("Cyclic counter. Contains the number of times get-naun or get-config of tr driver reported 'MAC-ERR-PROCESS-DISABLED'. Meaningful for Token Ring interfaces only.")
fibTmuNumBeaconsRcvd = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 2, 1, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuNumBeaconsRcvd.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuNumBeaconsRcvd.setDescription(' Cyclic counter. Contains the number of times tr driver reported receiving a beacon on this interface. Meaningful for Token Ring interfaces only.')
fibTmuLastBeaconTime = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 2, 1, 1, 29), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuLastBeaconTime.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuLastBeaconTime.setDescription('Time [in sys timer units] when last beacon was reported on this intrerface. Meaningful for Token Ring interfaces only.')
fibTmuLastBeaconType = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 2, 1, 1, 30), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuLastBeaconType.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuLastBeaconType.setDescription('Type of the last beacon reported on this intrerface. Meaningful for Token Ring interfaces only.')
fibTmuLastBeaconAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 2, 1, 1, 31), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuLastBeaconAddr.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuLastBeaconAddr.setDescription("Mac address of the last station which reported 'beacon' on this interface. Meaningful for Token Ring interfaces only.")
fibTmuLastBeaconNaun = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 2, 1, 1, 32), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuLastBeaconNaun.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuLastBeaconNaun.setDescription("Mac address of the next upsream neighbour of the last station which reported 'beacon' on this interface. Meaningful for Token Ring interfaces only.")
fibTmuNumRxGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 2, 1, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuNumRxGroup.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuNumRxGroup.setDescription('Cyclic counter. Contains the number of non-mac group frames received by higher level SW. Meaningful for Token Ring interfaces only.')
fibTmuNumRxFunctional = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 2, 1, 1, 34), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuNumRxFunctional.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuNumRxFunctional.setDescription('Cyclic counter. Contains the number of non-mac functional frames received by higher level SW. Meaningful for Token Ring interfaces only.')
fibTmuMatchUpdateTime = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 3, 1), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuMatchUpdateTime.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuMatchUpdateTime.setDescription('Time [in sys timer units] from startup at which the table below has been updated. See remark in fibTmuMatchListValid below.')
fibTmuMatchNumEntries = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 3, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuMatchNumEntries.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuMatchNumEntries.setDescription('Number of meaningful entries in the match array. The index of the last meaningful entry is num-entries. See remark in fibTmuMatchListValid below.')
fibTmuMatchNumTmuEntries = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 3, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuMatchNumTmuEntries.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuMatchNumTmuEntries.setDescription('Number of meaningful entries in the match array which belong to stations attached to the tmu via tau ports. This does not include the two (or one) chipsets themselves. Example: if second chip index is 3 and first chip index is 1 then the number of cau entries is 1. See remark in fibTmuMatchListValid below.')
fibTmuMatchFirstChipIndex = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 3, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuMatchFirstChipIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuMatchFirstChipIndex.setDescription('The index in the match table at which the the first chipset is located (order of stations on match table is downstream, i.e. in the direction messages are transported). See remark in fibTmuMatchListValid below.')
fibTmuMatchSecondChipIndex = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 3, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuMatchSecondChipIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuMatchSecondChipIndex.setDescription('The index in the match table at which the the second chipset is located (order of stations on match table is downstream, i.e. in the direction messages are transported). See remark in fibTmuMatchListValid below.')
fibTmuMatchActMonIndex = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 3, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuMatchActMonIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuMatchActMonIndex.setDescription('The index in the match table at which the active monitor is located (order of stations on match table is downstream, i.e. in the direction messages are transported). See remark in fibTmuMatchListValid below.')
fibTmuMatchConfigChipIndex = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 3, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuMatchConfigChipIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuMatchConfigChipIndex.setDescription('The index in the match table from which the information for the configuration was collected (order of stations on match table is downstream, i.e. in the direction messages are transported). See remark in fibTmuMatchListValid below.')
fibTmuMatchListValid = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 3, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, -1))).clone(namedValues=NamedValues(("valid", 2), ("not-valid", -1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuMatchListValid.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuMatchListValid.setDescription("Flag indicating whether the information in the tmuMatch group is valid or not. If information is not valid, ALL objects will return with a 'no such object' response.")
fibTmuMatchUpToDate = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 3, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 1))).clone(namedValues=NamedValues(("up-to-date", 2), ("not-up-to-date", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuMatchUpToDate.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuMatchUpToDate.setDescription("Flag. If set '1' then the information in All objects of tmuMatch group is not up to date any more: Some changes have occurred and a new, up to date matching configuration can not be supplied. In that case, the information in tmuMatch group remains true for the update time as specified above but not for the current time. See remark in fibTmuMatchListValid above.")
fibTmuMatchNoMatchReason = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 3, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14))).clone(namedValues=NamedValues(("empty-reason", 1), ("malloc-fail", 2), ("segment-unstable", 3), ("no-chip-on-list", 4), ("inconsistency", 5), ("soft-01", 6), ("soft-02", 7), ("first-not-found", 8), ("second-not-found", 9), ("found-twice", 10), ("soft-03", 11), ("ports-gt-stations", 12), ("stations-gt-ports", 13), ("no-tr-list", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuMatchNoMatchReason.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuMatchNoMatchReason.setDescription("Indication meaningful only if fibTmuMatchUpToDate above is not up-to-date. empty-reason - Either there is a list or the reason for the fact that there is no list is yet unknown. malloc-fail - System could not provide memory for this list. segment-unstable - Indications from the token ring chip sets were that the ring has not reached a stable state yet. no-chip-on-list - Chip set handling software could not indicate which of the Tmu chips is on the portion of token ring which is on the Tau ports. inconsistency - Inconsistent responses from low level token ring handler indicate ring is not yet stable. soft-01 - Software error. system could not retrieve a mac address related to a specified tr interface. soft-02 - Software error. system could not retrieve a mac address related to a specified tr interface. first-not-found - First chip set of Tmu could not be found on the list of addresses supplied by the token ring driver. Ring is not stable yet. second-not-found - Second chip set of Tmu could not be found on the list of addresses supplied by the token ring driver. Ring is not stable yet. found-twice - One chip set of Tmu was found twice on the list of addresses supplied by the token ring driver. Ring is not stable yet. soft-03 - Software indicated a match could be found but could not supply the actula list. Internal sw error. ports-gt-stations - Number of ports was fould to be higher than the number of stations. This is only reason for not construction the 'match' table. stations-gt-ports - Number of stations was fould to be higher than the number of ports. This is only reason for not construction the 'match' table. no-tr-list - No configuration is currently available from the token ring driver. Ring is unstable or some sw error. See remark in fibTmuMatchListValid above.")
fibTmuMatchTable = MibTable((1, 3, 6, 1, 4, 1, 22, 60, 3, 20), )
if mibBuilder.loadTexts: fibTmuMatchTable.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuMatchTable.setDescription('Table containing information on the location of stations (identified by their physical address in terms of Tmu/Tau ports).')
fibTmuMatchEntry = MibTableRow((1, 3, 6, 1, 4, 1, 22, 60, 3, 20, 1), ).setIndexNames((0, "TMU-MIB", "fibTmuMatchIndex"))
if mibBuilder.loadTexts: fibTmuMatchEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuMatchEntry.setDescription('Entry of information concerning a single station and its port (on Tmu/Tau).')
fibTmuMatchIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 3, 20, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuMatchIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuMatchIndex.setDescription('The value of this object identifies the the number of the entry in the table. See remark in fibTmuMatchListValid above')
fibTmuMatchTauId = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 3, 20, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuMatchTauId.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuMatchTauId.setDescription('Number of the tau port on which station is attached. Tau ports are connectors on the tmu. The may have either a tau connected or a single station. See fibTmuMatchPortId below. If this object is not valid for the specified instance (station is not on the Tmu but on the trunk), return value is 0xFFFFFFFF (-1). See remark in fibTmuMatchListValid above')
fibTmuMatchPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 3, 20, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuMatchPortId.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuMatchPortId.setDescription("If greater than 1 then 'fibTmuMatchTauId' is the number of the port on the tmu and 'fibTmuMatchPortId' is the number of the port on the related Tau (starting with port #1 for fibTmuMatchPortId = 2). If less than or equal to 1 then it is a One-Station-Port Indicating that one station is directly attached to the port specified by 'fibTmuMatchTauId'. The information contained in values smaller than 2 may also be deduced from 'fibTmuMatchStationInfow' below. If this object is not valid for the specified instance (station is not on the Tmu but on the trunk), return value is 0xFFFFFFFF (-1). See remark in fibTmuMatchListValid above")
fibTmuMatchPhysAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 3, 20, 1, 4), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuMatchPhysAddr.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuMatchPhysAddr.setDescription('The token ring physical address of the station which is attached to the specified port. See remark in fibTmuMatchListValid above')
fibTmuMatchStationInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 3, 20, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuMatchStationInfo.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuMatchStationInfo.setDescription("Information on the attached station: If BIT0 is set (value = 0x01) then this is definitely a 'sniffer' port (i.e. a station which is sending 'trace tool present' messages is located on this port). If BIT1 is set (value = 0x02) then its location is doubtful (System has been unable to resolve the location of this station). If BIT2 is set (value = 0x04) then station is not attached to one of the tmu's ports but rather to the trunk. If bit3 is set (value = 0x08) then station is one of the tmu's chips. If BIT4 is set (value = 0x10) then this is a station attached to the tmu (and not on the trunk). See remark in fibTmuMatchListValid above")
fibTmuStationsUpdateTime = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 4, 1), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuStationsUpdateTime.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuStationsUpdateTime.setDescription('Time [in sys timer units] from startup at which the table below has been updated. See remark in fibTmuStationsListValid below.')
fibTmuStationsNumEntries = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 4, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuStationsNumEntries.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuStationsNumEntries.setDescription('Number of meaningful entries in the Stations array. The index of the last meaningful entry is num-entries. See remark in fibTmuStationsListValid below.')
fibTmuStationsNumTmuEntries = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 4, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuStationsNumTmuEntries.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuStationsNumTmuEntries.setDescription('Number of meaningful entries in the Stations array which belong to stations attached to the tmu via tau ports. This does not include the two (or one) chipsets themselves. Example: if second chip index is 3 and first chip index is 1 then the number of Tmu entries is 1. See remark in fibTmuStationsListValid below.')
fibTmuStationsFirstChipIndex = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 4, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuStationsFirstChipIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuStationsFirstChipIndex.setDescription('The index in the Stations table at which the the first chipset is located (order of stations on Stations table is downstream, i.e. in the direction messages are transported). See remark in fibTmuStationsListValid below.')
fibTmuStationsSecondChipIndex = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 4, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuStationsSecondChipIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuStationsSecondChipIndex.setDescription('The index in the Stations table at which the the second chipset is located (order of stations on Stations table is downstream, i.e. in the direction messages are transported). See remark in fibTmuStationsListValid below.')
fibTmuStationsActMonIndex = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 4, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuStationsActMonIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuStationsActMonIndex.setDescription('The index in the Stations table at which the active monitor is located (order of stations on Stations table is downstream, i.e. in the direction messages are transported). See remark in fibTmuStationsListValid below.')
fibTmuStationsConfigChipIndex = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 4, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuStationsConfigChipIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuStationsConfigChipIndex.setDescription('The index in the Stations table from which the information for the configuration was collected (order of stations on Stations table is downstream, i.e. in the direction messages are transported). See remark in fibTmuStationsListValid below.')
fibTmuStationsStationsListValid = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 4, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, -1))).clone(namedValues=NamedValues(("valid", 2), ("not-valid", -1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuStationsStationsListValid.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuStationsStationsListValid.setDescription("Flag indicating whether the information in the tmuStations group is valid or not. If information is not valid, ALL objects will return with a 'no such object' response.")
fibTmuStationsUpToDate = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 4, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 1))).clone(namedValues=NamedValues(("up-to-date", 2), ("not-up-to-date", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuStationsUpToDate.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuStationsUpToDate.setDescription("Flag. If set '1' then the information in All objects of tmuStations group is not up to date any more: Some changes have occurred and a new, up to date Stationsing configuration can not be supplied. In that case, the information in tmuStations group remains true for the update time as specified above but not for the current time. See remark in fibTmuStationsListValid above.")
fibTmuMatchNoStationsListReason = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 4, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 14))).clone(namedValues=NamedValues(("empty-reason", 1), ("malloc-fail", 2), ("segment-unstable", 3), ("no-chip-on-list", 4), ("inconsistency", 5), ("soft-01", 6), ("soft-02", 7), ("first-not-found", 8), ("second-not-found", 9), ("found-twice", 10), ("no-tr-list", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuMatchNoStationsListReason.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuMatchNoStationsListReason.setDescription('Indication meaningful only if fibTmuStationsUpToDate above is not up-to-date. empty-reason - Either there is a list or the reason for the fact that there is no list is yet unknown. malloc-fail - System could not provide memory for this list. segment-unstable - Indications from the token ring chip sets were that the ring has not reached a stable state yet. no-chip-on-list - Chip set handling software could not indicate which of the Tmu chips is on the portion of token ring which is on the Tau ports. inconsistency - Inconsistent responses from low level token ring handler indicate ring is not yet stable. soft-01 - Software error. system could not retrieve a mac address related to a specified tr interface. soft-02 - Software error. system could not retrieve a mac address related to a specified tr interface. first-not-found - First chip set of Tmu could not be found on the list of addresses supplied by the token ring driver. Ring is not stable yet. second-not-found - Second chip set of Tmu could not be found on the list of addresses supplied by the token ring driver. Ring is not stable yet. found-twice - One chip set of Tmu was found twice on the list of addresses supplied by the token ring driver. Ring is not stable yet. no-tr-list - No configuration is currently available from the token ring driver. Ring is unstable or some sw error. See remark in fibTmuStationsListValid above.')
fibTmuStationsTable = MibTable((1, 3, 6, 1, 4, 1, 22, 60, 4, 20), )
if mibBuilder.loadTexts: fibTmuStationsTable.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuStationsTable.setDescription('Table containing information on the location of stations (identified by their physical address).')
fibTmuStationsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 22, 60, 4, 20, 1), ).setIndexNames((0, "TMU-MIB", "fibTmuStationsIndex"))
if mibBuilder.loadTexts: fibTmuStationsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuStationsEntry.setDescription('Entry of information concerning a single station.')
fibTmuStationsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 4, 20, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuStationsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuStationsIndex.setDescription('The value of this object identifies the the number of the entry in the table. See remark in fibTmuStationsListValid above')
fibTmuStationsPhysAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 4, 20, 1, 2), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuStationsPhysAddr.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuStationsPhysAddr.setDescription('The token ring physical address of the station which is at the specified index. See remark in fibTmuStationsListValid above')
fibTmuStationsStationInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 4, 20, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuStationsStationInfo.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuStationsStationInfo.setDescription("Information on the attached station: If BIT0 is set (value = 0x01) then this is definitely a 'sniffer' port (i.e. a station which is sending 'trace tool present' messages is located on this port). If BIT1 is set (value = 0x02) then its location is doubtful (System has been unable to resolve the location of this station). If BIT2 is set (value = 0x04) then station is not attached to one of the tmu's ports but rather to the trunk. If bit3 is set (value = 0x08) then station is one of the tmu's chips. If BIT4 is set (value = 0x10) then this is a station attached to the tmu (and not on the trunk). See remark in fibTmuStationsListValid above")
fibTmuPortsNumRelayOpen = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 5, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuPortsNumRelayOpen.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuPortsNumRelayOpen.setDescription('Number of ports attached to single stations either directly on the tmu or on a tau which have their relay open. A relay remains open as long as there is an attached station and it not a source of some problem.')
fibTmuPortsNumPhantomPresent = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 5, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuPortsNumPhantomPresent.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuPortsNumPhantomPresent.setDescription('Number of ports attached to single stations (either directly on the tmu or on a tau) which have their phantom up.')
fibTmuPortsNumPortsPerTmu = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 5, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuPortsNumPortsPerTmu.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuPortsNumPortsPerTmu.setDescription('Number of ports on one tmu (both ports which support a tau and ports which may support only single stations).')
fibTmuPortsNumTausPerTmu = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 5, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuPortsNumTausPerTmu.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuPortsNumTausPerTmu.setDescription("The maximal number of Tau's which can be connected to one Tmu")
fibTmuPortsNumPortsPerTau = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 5, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuPortsNumPortsPerTau.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuPortsNumPortsPerTau.setDescription('The maximal number of ports on one Tau')
fibTmuPortsMaxNumTauErrs = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 5, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuPortsMaxNumTauErrs.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuPortsMaxNumTauErrs.setDescription('Number of errors (which cause temporary relay closing) allowed after phantom goes up on a single Tau port and before its relay is closed (port detached). Relay is reopened (port attached) after phantom goes down and up again.')
fibTmuPortsMaxFirstTimeout = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 5, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuPortsMaxFirstTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuPortsMaxFirstTimeout.setDescription('Number of timeouts allowed before it is decided that communication with Tau is really faulty. System moves from state of connection into no-connection and attempts will be made to determine the type of connection (Tau or single).')
fibTmuPortsTauTable = MibTable((1, 3, 6, 1, 4, 1, 22, 60, 5, 29), )
if mibBuilder.loadTexts: fibTmuPortsTauTable.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuPortsTauTable.setDescription("Table containing information on ports which are directly on Tmu and on Tau's which may be connected to them.")
fibTmuPortsTauEntry = MibTableRow((1, 3, 6, 1, 4, 1, 22, 60, 5, 29, 1), ).setIndexNames((0, "TMU-MIB", "fibTmuPortsTmuPort"))
if mibBuilder.loadTexts: fibTmuPortsTauEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuPortsTauEntry.setDescription('Entry of information concerning a single port on Tmu and the attached station/Tau.')
fibTmuPortsTmuPort = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 5, 29, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuPortsTmuPort.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuPortsTmuPort.setDescription('Number of port (on TMU) described in this array entry. Port numbers increase in the direction of the token.')
fibTmuPortsPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 5, 29, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("station-or-Tau", 1), ("station-only", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuPortsPortType.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuPortsPortType.setDescription('Flag indicating whether this port supports both a Tau and a single station or just a single station.')
fibTmuPortsEndConnection = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 5, 29, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("undefined", 1), ("tau-connected", 2), ("single-connected", 3), ("passive-connected", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuPortsEndConnection.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuPortsEndConnection.setDescription('Flag indicating whether this port is connected to a Tau or to a single station (or is in a state where it is not clear exactly what is connected to the specified port).')
fibTmuPortsPortStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 5, 29, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuPortsPortStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuPortsPortStatus.setDescription('Bit map indicating status of the port: Bit3 (0x08) - If set indicates that the relay of this port is open (and, therefore, the station/Tau connected to this port is on the token ring). Bit4 (0x10) - If set indicates that phantom signal was detected at this port (and, therefore, a station/Tau is connected to this port). Bit5 (0x20) - If set indicates that the relay of this port is closed because a command was received to do so from an snmp manager. Bit6 (0x40) - If set then port has been temporarily closed by Tmu because it was decided that either the Tau or the communication line is faulty. System may still revert to attaching the port if faulty state is overcome. This state may also be entered because Tmu received indication that the ring was not stable. As long as this is the only reason for the port to be closed, system will continually try to revert to attaching the port. Bit7 (0x80) - If set then port has been closed because it was found to create too many errors. Port will remain closed until phantom goes down and up again. Bit9 (0x200) - Port is detached because of security violation and will remain so until phantom goes down and up again or until manager releases the lock.')
fibTmuPortsManagerCloseRun = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 5, 29, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("open", 1), ("close", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fibTmuPortsManagerCloseRun.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuPortsManagerCloseRun.setDescription("When setting this object to the value of close (2) the indicated port on Tmu will be closed, the related led will start blinking at a slow rate and port will not be opened before it is set to the value of open (1). Setting to the value of open (1) does not guarantee the opening of the indicated Tmu port but will only allow the Tmu system to let this port into the ring if it obeys the rules of token ring. Reading this object returns the value last set by the manager (or the default value). This command holds only until the next system reset. To make sure it remains valid after reset, use 'fibTmuPortsManagerClosePerm'")
fibTmuPortsManagerClosePerm = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 5, 29, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("open", 1), ("close", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fibTmuPortsManagerClosePerm.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuPortsManagerClosePerm.setDescription("When setting this object to the value of close (2) the indicated port on Tmu will be closed after the next system reset. see 'fibTmuPortsManagerCloseRun'. Setting to the value of open (1) will only allow the Tmu system to let this port into the ring (after the next reset) if it obeys the rules of token ring. Reading this object returns the value last set by the manager (or the default value).")
fibTmuPortsNumConsequentErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 5, 29, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuPortsNumConsequentErrs.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuPortsNumConsequentErrs.setDescription("Counter. Number of times an error has been detected on this Tau port (one after the other, without a 'no error' state in between) since phantom last came up. When the number of errors reaches fibTmuPortsMaxNumTauErrs, relay is closed and is not opened until phantom goes down and up again.")
fibTmuPortsNumTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 5, 29, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuPortsNumTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuPortsNumTimeout.setDescription('Number of times communication with Tau has been attempted immediately after pahntom has gone up. Attempt go on for MaxFirstTimeout times. After that, it is decided that a regular station is connected and this will remain the state until phantom goes down and up again.')
fibTmuPortsTauPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 5, 29, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("no-connection", 1), ("waiting-to-open", 2), ("active-connection", 3), ("getting-config", 4), ("initializing", 5), ("pre-active", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuPortsTauPortState.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuPortsTauPortState.setDescription('This is a status byte. it indicates the state of the port as far as software is concerned. A port which may only carry a single station can possibly be in one of two states: no-connection (1) waiting-to-open (2) active-connection (3) A port which may carry either a Tau or a single station can possibly be in one of the following states: no-connection (1) getting-config (4) initializing (5) pre-active (6) active-connection (3)')
fibTmuPortsNumPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 5, 29, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuPortsNumPorts.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuPortsNumPorts.setDescription("The number of ports on the Tau connected to this port. Set to '1' when a station is directly connected to this port. Only meaningful when 'fibTmuPortsTauPortState' is 'active-connection'")
fibTmuPortsNumAttached = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 5, 29, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuPortsNumAttached.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuPortsNumAttached.setDescription("This is the number of ports on the connected Tau (if there is any) that have their relay open (station is attached to the ring). Only meaningful when 'fibTmuPortsTauPortState' is 'active-connection'")
fibTmuPortsNumPhantomUp = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 5, 29, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuPortsNumPhantomUp.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuPortsNumPhantomUp.setDescription("This is the number of ports on the connected Tau (if there is any) that have their phantom in 'up' state. Only meaningful when 'fibTmuPortsTauPortState' is 'active-connection'")
fibTmuPortsTauRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 5, 29, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuPortsTauRevision.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuPortsTauRevision.setDescription("This is the Tau revision as reported by the Tau itself (if there is one). Only meaningful when 'fibTmuPortsTauPortState' is 'active-connection'.")
fibTmuPortsModuleId = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 5, 29, 1, 17), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuPortsModuleId.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuPortsModuleId.setDescription("This is a hw id attached to each of its modules by the Tau. each octet is related to one module (up to 4 modules). Number of meaningful octets is determined by fibTmuPortsNumModules below. Only meaningful when 'fibTmuPortsTauPortState' is 'active-connection'")
fibTmuPortsNumModules = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 5, 29, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuPortsNumModules.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuPortsNumModules.setDescription("This is the number of modules on the attached Tau as reported by the Tau itself. Only meaningful when 'fibTmuPortsTauPortState' is 'active-connection'.")
fibTmuPortsTauMode = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 5, 29, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuPortsTauMode.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuPortsTauMode.setDescription("This is a bit map of information on the status of the Tau and the way it is set. Details of the various bits: Bit0 (= 0x01) If '1' then Tau is set to a rate of 16 mega bits per second on token ring. Otherwise, it is set to a rate of 4 mega bits per second. Only meaningful when 'fibTmuPortsTauPortState' is 'active-connection'.")
fibTmuPortsLedState = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 5, 29, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("slow-rate", 1), ("fast-rate", 2), ("fixed-on", 3), ("fixed-off", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuPortsLedState.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuPortsLedState.setDescription('State of the indication led related to this port. Values can be: slow-rate (1) fast-rate (2) fixed-on (3) fixed-off (4)')
fibTmuPortsRequestType = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 5, 29, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 17, 33, 49, 65, 81, 97, 113, 129, 145, 161))).clone(namedValues=NamedValues(("no-Tau-msg", 1), ("get-configuration-msg", 17), ("get-phantom-msg", 33), ("get-relay-msg", 49), ("attach-detach-msg", 65), ("set-beacon-msg", 81), ("set-active-msg", 97), ("get-all-msg", 113), ("get-changes-msg", 129), ("reset-Tau-msg", 145), ("self-test-Tau-msg", 161)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuPortsRequestType.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuPortsRequestType.setDescription("This is the type of the message sent to the attached Tau for which a response is required. If request-type is 'no-Tau-msg' then no message was sent and, therefore, no request is expected. no-Tau-msg (=0x01) get-configuration-msg (=0x11) get-phantom-msg (=0x21) get-relay-msg (=0x31) attach-detach-msg (=0x41) set-beacon-msg (=0x51) set-active-msg (=0x61) get-all-msg (=0x71) get-changes-msg (=0x81) reset-Tau-msg (=0x91) self-test-Tau-msg (=0xA1)")
fibTmuPortsLastTxTime = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 5, 29, 1, 22), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuPortsLastTxTime.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuPortsLastTxTime.setDescription('This is the system timer value at the last tx-to-Tau on this Tau port (provided a Tau is attached to it).')
fibTmuPortsLastPollTime = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 5, 29, 1, 23), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuPortsLastPollTime.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuPortsLastPollTime.setDescription('This is the system timer value at the last poll response on this Tau port (provided a Tau is attached to it). If no polling has so far been carried out, a value of 0 is returned.')
fibTmuPortsUpdateTime = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 5, 29, 1, 24), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuPortsUpdateTime.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuPortsUpdateTime.setDescription('This is the system timer value when phantom was last probed on this Tau port.')
fibTmuPortsAllowedAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 5, 29, 1, 25), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fibTmuPortsAllowedAddr.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuPortsAllowedAddr.setDescription('This is the one physical address allowed to be on this Tmu port (provided a single station is attached to it and not a Tau). The value loaded in fibTmuPortsAllowedAddrLoaded below determines the state of this object. Writing to this object stores the address in non-volatile memory. It also makes security on this port active provided fibTmuSecurityModeRun has bit0 set. Loading will not be carried out if fibTmuNumStationLeft is 0 (no more space in non-volatile memory). In that case, an error will be returned (genErr = 5).')
fibTmuPortsAllowedAddrLoaded = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 5, 29, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("addr-not-loaded", 1), ("loaded-not-active", 2), ("loaded-and-active", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fibTmuPortsAllowedAddrLoaded.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuPortsAllowedAddrLoaded.setDescription("This is the status of fibTmuPortsAllowedAddr. When reading, the possible values are as follows: addr-not-loaded indicates the value in fibTmuPortsAllowedAddr is meaningless. No security address has been loaded for this port. loaded-not-active indicates the value in fibTmuPortsAllowedAddr is stored in non volatile memory but security action for this port is not active. This happens when address is loaded while security action for the Tmu system is disabled (fibTmuSecurityModeRun has bit0 reset). loaded-and-active indicates the value in fibTmuPortsAllowedAddr is loaded in non volatile memory and security is active on this port. This means that if a station is directly connected to this port then it must have the specified physical address or this port will automatically close. As for writing, this object can be written only if its value is either 'loaded-not-active' or 'loaded-and-active' and the only value allowed is addr-not-loaded. In that case, 'fibTmuPortsAllowedAddr' is erased from the non-volatile memory and 'fibTmuNumStationLeft' is incremented. If port has been closed because of security (fibTmuPortsPortStatus had bit9 set) then it will open (provided it has not been closed because of some other reason).")
fibTmuPortsAllTable = MibTable((1, 3, 6, 1, 4, 1, 22, 60, 5, 30), )
if mibBuilder.loadTexts: fibTmuPortsAllTable.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuPortsAllTable.setDescription('Table containing information on ports which are directly connected to stations and on Tau ports which may be connected to stations.')
fibTmuPortsAllEntry = MibTableRow((1, 3, 6, 1, 4, 1, 22, 60, 5, 30, 1), ).setIndexNames((0, "TMU-MIB", "fibTmuPortsTmuPortIndex"), (0, "TMU-MIB", "fibTmuPortsTauPortIndex"))
if mibBuilder.loadTexts: fibTmuPortsAllEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuPortsAllEntry.setDescription('Entry of information concerning a single port on Tmu or on Tau.')
fibTmuPortsTmuPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 5, 30, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuPortsTmuPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuPortsTmuPortIndex.setDescription('Number of port on Tmu. Port numbers increase in the direction of the token. range of valid values: 1->fibTmuPortsNumTausPerTmu')
fibTmuPortsTauPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 5, 30, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuPortsTauPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuPortsTauPortIndex.setDescription('Number of port on Tau. Port numbers increase in the direction of the token. range of valid values: 1->fibTmuPortsNumTausPerTau')
fibTmuPortsPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 5, 30, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuPortsPortState.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuPortsPortState.setDescription("Bit map describing the indicated port: Bit1 (0x02) - No such port. Index is out of bounds. Either a Tau is connected and the specified port number is larger than the number of ports on the Tau currently connected or a single station is directly attached and the specified port number is larger than 1. Bit2 (0x04) - It has not yet been determined what is connected to the specified Tmu port. It may later be found to be either a single station of a Tau. Bit3 (0x08) - Port is attached. This means that the token ring goes through the station related to this port. Bit4 (0x10) - Phantom signal is 'on' for this port. Bit5 (0x20) - Port is detached because of a request from manager. Bit6 (0x40) - Port is temporarily detached because of a temporary error or because it is in a transition state. Bit7 (0x80) - Port is detached because of an error and will remain so until phantom goes down and up again. Bit8 (0x100) - Port is a Tmu port attached to a single station. Bit9 (0x200) - Port is detached because of security violation and will remain so until phantom goes down and up again or until manager releases the lock.")
fibTmuPortsGenCloseRun = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 5, 30, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("open", 1), ("close", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fibTmuPortsGenCloseRun.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuPortsGenCloseRun.setDescription("When setting this object to the value of close (2) the indicated port on Tau will be closed, the related led will start blinking at a slow rate and port will not be opened before it is set to the value of open (1). Setting to the value of open (1) does not guarantee the opening of the indicated Tau port but will only allow the Tmu system to let this port into the ring if it obeys the rules of token ring. Reading this object returns the value last set by the manager (or the default value). This command holds only until the next system reset. To make sure it remains valid after reset, use 'fibTmuPortsGenClosePerm'. This command only affects ports on Tau. If there is no Tau attached when command is issued, then it is stored in memory and goes into effect when a Tau is attached. This command will have no effect of a station directly attached to the Tmu. To detach a directly attached station, use 'fibTmuPortsManagerCloseRun' (See above).")
fibTmuPortsGenClosePerm = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 5, 30, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("open", 1), ("close", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fibTmuPortsGenClosePerm.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuPortsGenClosePerm.setDescription("When setting this object to the value of close (2) the indicated port on Tau is instructed to be closed after the next reset. Setting to the value of open (1) does not guarantee the opening of the indicated Tau port after the next reset but will only allow the Tmu system to let this port into the ring if it obeys the rules of token ring. Reading this object returns the value last set by the manager (or the default value). This command only affects ports on Tau. If there is no Tau attached at startup (after reset), then it is stored in memory and goes into effect when a Tau is attached. This command will have no effect of a station directly attached to the Tmu. To permanently detach a directly attached station, use 'fibTmuPortsManagerClosePerm' (See above).")
fibTmuPortsPhysAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 5, 30, 1, 6), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuPortsPhysAddr.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuPortsPhysAddr.setDescription("The token ring physical address of the station which is attached to the specified port. If station is not identified (e.g. fibTmuMatchListValid, see above, is not 'TRUE') then a string of 0xFF characters is returned.")
fibTmuPortsStationInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 5, 30, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuPortsStationInfo.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuPortsStationInfo.setDescription("Information on the attached station: If BIT0 is set (value = 0x01) then this is definitely a 'sniffer' port (i.e. a station which is sending 'trace tool present' messages is located on this port). If BIT1 is set (value = 0x02) then its location is doubtful (System has been unable to resolve the location of this station). If BIT2 is set (value = 0x04) then station is not attached to one of the tmu's ports but rather to the trunk. If bit3 is set (value = 0x08) then station is one of the tmu's chips. If BIT4 is set (value = 0x10) then this is a station attached to the tmu (and not on the trunk). If station is not identified (e.g. fibTmuMatchListValid, see above, is not 'TRUE') then -1 (0xFFFFFFFF) is returned.")
fibTmuPortsTauAllowedAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 5, 30, 1, 8), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fibTmuPortsTauAllowedAddr.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuPortsTauAllowedAddr.setDescription("This is the one physical address allowed to be on this port on Tau. The value loaded in fibTmuPortsTauAllowedAddrLoaded below determines the state of this object. Writing to this object stores the address in non-volatile memory. It also makes security on this port active provided fibTmuSecurityModeRun has bit0 set. Loading will not be carried out if fibTmuNumStationLeft is 0 (no more space in non-volatile memory). In that case, an error will be returned (genErr = 5). This command only affects ports on Tau. If there is no Tau attached when command is issued, then it is stored in memory and goes into effect when a Tau is attached. This command will have no effect of a station directly attached to the Tmu. To affect such ports, use 'fibTmuPortsAllowedAddr'")
fibTmuPortsTauAllowedAddrLoaded = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 60, 5, 30, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("addr-not-loaded", 1), ("loaded-not-active", 2), ("loaded-and-active", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fibTmuPortsTauAllowedAddrLoaded.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuPortsTauAllowedAddrLoaded.setDescription("This is the status of fibTmuPortsTauAllowedAddr. When reading, the possible values are as follows: addr-not-loaded indicates the value in fibTmuPortsTauAllowedAddr is meaningless. No security address has been loaded for this port. loaded-not-active indicates the value in fibTmuPortsTauAllowedAddr is stored in non volatile memory but security action for this port is not active. This happens when address is loaded while security action for the Tmu system is disabled (fibTmuSecurityModeRun has bit0 reset). loaded-and-active indicates the value in fibTmuPortsTauAllowedAddr is loaded in non volatile memory and security is active on this port. This means that if a station is directly connected to this port then it must have the specified physical address or this port will automatically close. As for writing, this object can be written only if its value is either 'loaded-not-active' or 'loaded-and-active' and the only value allowed is addr-not-loaded. In that case, 'fibTmuPortsTauAllowedAddr' is erased from the non-volatile memory and 'fibTmuNumStationLeft' is incremented. If port has been closed because of security (fibTmuPortsPortState had bit9 set) then it will open (provided it has not been closed because of some other reason). This command only affects ports on Tau. If there is no Tau attached when command is issued, then it is stored in memory and goes into effect when a Tau is attached. This command will have no effect of a station directly attached to the Tmu. To affect such ports, use 'fibTmuPortsAllowedAddrLoaded'")
fibTmuProductionAddr48No1 = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 6, 1), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fibTmuProductionAddr48No1.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuProductionAddr48No1.setDescription('48 bit address of the chip set which is located at the primary in port.')
fibTmuProductionAddr48No2 = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 6, 2), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fibTmuProductionAddr48No2.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuProductionAddr48No2.setDescription('48 bit address of the chip set which is located at the primary out port.')
fibTmuProductionAddr48No3 = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 6, 3), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fibTmuProductionAddr48No3.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuProductionAddr48No3.setDescription('48 bit address of the chip set which is located at the secondary ring port.')
fibTmuProductionRomType = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 6, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("rom-27c020", 2), ("rom-27c040", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fibTmuProductionRomType.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuProductionRomType.setDescription('Type of EPROM used in the Tmu system.')
fibTmuProductionRamType = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 6, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("unknown", 1), ("ram-128k8", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fibTmuProductionRamType.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuProductionRamType.setDescription('Type of RAM used in the Tmu system.')
fibTmuProductionFlashType = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 6, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unknown", 1), ("flash-28f010", 2), ("flash-28f020", 3), ("flash-29f010", 4), ("flash-29f040", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fibTmuProductionFlashType.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuProductionFlashType.setDescription('Type of FLASH used in the Tmu system.')
fibTmuProductionEepromType = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 6, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("with-page-mode", 2), ("without-page-mode", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fibTmuProductionEepromType.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuProductionEepromType.setDescription('Type of EEPROM used in the Tmu system.')
fibTmuProductionSerialNum = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 6, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(3, 3)).setFixedLength(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fibTmuProductionSerialNum.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuProductionSerialNum.setDescription('Serial number of Tmu HW system.')
fibTmuProductionRamSize = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 6, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(3, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fibTmuProductionRamSize.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuProductionRamSize.setDescription("Size of RAM used in the Tmu system in units of 32K bytes. A value of '3' indicates size is not known.")
fibTmuProductionFlash0Size = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 6, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(3, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fibTmuProductionFlash0Size.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuProductionFlash0Size.setDescription("Size of FLASH memory bank #0 used in the Tmu system in units of 32K bytes. A value of '3' indicates size is not known.")
fibTmuProductionFlash1Size = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 6, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fibTmuProductionFlash1Size.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuProductionFlash1Size.setDescription("Size of FLASH memory bank #1 used in the Tmu system in units of 32K bytes. A value of '3' indicates size is not known. A value of '2' indicates chip is not installed.")
fibTmuProductionEepromSize = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 6, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(3, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fibTmuProductionEepromSize.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuProductionEepromSize.setDescription("Size of EEPROM memory used in the Tmu system in units of 0.5K bytes. A value of '3' indicates size is not known.")
fibTmuProductionHwInfo = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 6, 13), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fibTmuProductionHwInfo.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuProductionHwInfo.setDescription("General encoded information concerning Tmu system's hardware.")
fibTmuProductionBoardType = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 6, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("unknown", 1), ("board-9230", 2), ("board-9230-16", 3), ("board-9230-32", 4), ("board-9230-16F", 5), ("board-9230-32F", 6), ("board-9232-16", 7), ("board-9232-32", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuProductionBoardType.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuProductionBoardType.setDescription('Type of TMU Board.')
fibTmuSecurityModeRun = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 7, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuSecurityModeRun.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuSecurityModeRun.setDescription('The currently effective security mode. This is a bit map. This object is only loaded once after reset. To change it, fibTmuSecurityModeRun must be loaded and then system must be reset. BIT(0) - Station security. If set then some ports are marked as being allowed to have only specific stations (station per port). The list of port is specified below. REST - T.B.D.')
fibTmuSecurityModePerm = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 7, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fibTmuSecurityModePerm.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuSecurityModePerm.setDescription('The value currently in non volatile memory of the security mode. This is a bit map. See detals in fibTmuSecurityModeRun above. This object is only loaded into fibTmuSecurityModeRun once after reset. Changing it effects the system only after reset.')
fibTmuNumStationSecurity = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 7, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuNumStationSecurity.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuNumStationSecurity.setDescription("Maximal number of ports for which the security mode 'station security' (see fibTmuSecurityModeRun above) can be specified.")
fibTmuNumStationLeft = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 7, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuNumStationLeft.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuNumStationLeft.setDescription("Number of ports for which the security mode 'station security' (see fibTmuSecurityModeRun above) can still be specified. This is the difference between 'fibTmuNumStationSecurity' and the number of port for which the allowed station has already been specified.")
fibTmuFunctBeacon2AutotestRun = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 8, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(160, 200))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuFunctBeacon2AutotestRun.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuFunctBeacon2AutotestRun.setDescription("The time period for starting the 'autoremove' test after start of beaconing. In units of milliseconds. Minimal value: 160. maximal value 200. Factory default: 160. To change this object, load 'fibTmuFunctBeacon2AutotestPerm' into non-volatile ram. The value written into non volatile memory is loaded into the current value only after reset.")
fibTmuFunctBeacon2OkRun = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 8, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(40, 200))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuFunctBeacon2OkRun.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuFunctBeacon2OkRun.setDescription("The upper bound for time period starting at the removal of a problem till ring status indicates no beaconing. In units of milliseconds. Minimal value: 40. maximal value 200. Factory default: 50. To change this object, load 'fibTmuFunctBeacon2OkPerm' into non-volatile ram. The value written into non volatile memory is loaded into the current value only after reset.")
fibTmuFunctOk2BeaconRun = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 8, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1100, 2500))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuFunctOk2BeaconRun.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuFunctOk2BeaconRun.setDescription("The upper bound for time period starting at the insertion of a problem till ring status indicates beaconing. In units of milliseconds. Minimal value: 1100. maximal value 2500. Factory default: 2000. To change this object, load 'fibTmuFunctOk2BeaconPerm' into non-volatile ram. The value written into non volatile memory is loaded into the current value only after reset.")
fibTmuFunctWrapCwtRun = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 8, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 200))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuFunctWrapCwtRun.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuFunctWrapCwtRun.setDescription("Time delay to apply, after changing warp relay state. In units of milliseconds. Intended to let TMS get the real ring status. Minimal value: 0. maximal value 200. Factory default: 100. To change this object, load 'fibTmuFunctWrapCwtPerm' into non-volatile ram. The value written into non volatile memory is loaded into the current value only after reset.")
fibTmuFunctWrapWnrRun = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 8, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("wnr-dont-release-cpu", 1), ("wnr-release-cpu", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuFunctWrapWnrRun.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuFunctWrapWnrRun.setDescription("Flag indicating whether to release CPU while waiting after warp change. Values: 1 - FALSE, 2 - TRUE. Factory default: TRUE. To change this object, load 'fibTmuFunctWrapWnrPerm' into non-volatile ram. The value written into non volatile memory is loaded into the current value only after reset.")
fibTmuFunctRingIstRun = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 8, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 200))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuFunctRingIstRun.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuFunctRingIstRun.setDescription("Time to poll for consistent Tmu ring status before continuing recovery. In units of milliseconds. Minimal value: 0. maximal value 200. Factory default: 0 To change this object, load 'fibTmuFunctRingIstPerm' into non-volatile ram. The value written into non volatile memory is loaded into the current value only after reset.")
fibTmuFunctRingIstnrRun = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 8, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("istnr-dont-release-cpu", 1), ("istnr-release-cpu", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuFunctRingIstnrRun.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuFunctRingIstnrRun.setDescription("Flag indicating whether to release CPU while waiting for consistent Tmu ring status. Values: 1 - FALSE, 2 - TRUE. Factory default: TRUE. To change this object, load 'fibTmuFunctRingIstnrPerm' into non-volatile ram. The value written into non volatile memory is loaded into the current value only after reset.")
fibTmuFunctCheckAogTauRun = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 8, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dont-check-ring", 1), ("check-ring", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuFunctCheckAogTauRun.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuFunctCheckAogTauRun.setDescription("Flag is used during BRUTAL recovery (single problem). If TRUE (checck-ring) then check whether the ring is BEACONING after opening the good TAU's (This check takes fibTmuFunctOk2BeaconRun milli sec. and not needed in most cases). Values: 1 - FALSE, 2 - TRUE. Factory default: FALSE. To change this object, load 'fibTmuFunctCheckAogTauPerm' into non-volatile ram. The value written into non volatile memory is loaded into the current value only after reset.")
fibTmuFunctMaxNoiRun = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 8, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 300))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuFunctMaxNoiRun.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuFunctMaxNoiRun.setDescription("When several station wants to insert into the ring, this parameter sets the limit on the maximal number of stations which are allowed to insert (other stations are delayed until the next round). If 0 then enable all stations are allowed to insert. Minimal value: 0. maximal value 300. Factory default: 1 To change this object, load 'fibTmuFunctRingIstPerm' into non-volatile ram. The value written into non volatile memory is loaded into the current value only after reset.")
fibTmuFunctLinkPtifRun = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 8, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dont-link-to-last", 1), ("link-to-last", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuFunctLinkPtifRun.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuFunctLinkPtifRun.setDescription("When problem in TMU segment is discovered then if this flag is TRUE, first of all try to find problem between last inserted stations. Values: 1 - FALSE, 2 - TRUE. Factory default: TRUE. To change this object, load 'fibTmuFunctLinkPtifPerm' into non-volatile ram. The value written into non volatile memory is loaded into the current value only after reset.")
fibTmuFunctInsPatRun = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 8, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1500, 4000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuFunctInsPatRun.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuFunctInsPatRun.setDescription("Parameter for controlling the aging of the 'inseretion-pool' (Should be long enough to make sure that the station is not malfunctioning). Units: milli seconds. Minimal value: 1500. maximal value 4000. Factory default: 3000 To change this object, load 'fibTmuFunctInsPatPerm' into non-volatile ram. The value written into non volatile memory is loaded into the current value only after reset.")
fibTmuFunctUseMismatchRun = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 8, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dont-use-mismatch", 1), ("use-mismatch", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuFunctUseMismatchRun.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuFunctUseMismatchRun.setDescription("Indication on whether to apply recovery when the number of stations is larger than the number of open ports. Values: 1 - FALSE, 2 - TRUE. Factory default: TRUE. To change this object, load 'fibTmuFunctUseMismatchPerm' into non-volatile ram. The value written into non volatile memory is loaded into the current value only after reset.")
fibTmuFunctChkRingInsRun = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 8, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dont-check-ring", 1), ("check-ring", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuFunctChkRingInsRun.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuFunctChkRingInsRun.setDescription("Indication on whether to check ring status (for possible problems caused by the currently inserted stations) or not. Setting 'TRUE' results in quicker discovery of stations with invalid frequency but inflicts higher overhead on legitimate frequency stations. Values: 1 - FALSE, 2 - TRUE. Factory default: FALSE. To change this object, load 'fibTmuFunctChkRingInsPerm' into non-volatile ram. The value written into non volatile memory is loaded into the current value only after reset.")
fibTmuFunctChkRingPerRun = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 8, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1500, 4000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuFunctChkRingPerRun.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuFunctChkRingPerRun.setDescription("Parameter indicating the elapsed time after letting a station into the ring after which a station is considered to be o.k. See 'fibTmuFunctChkRingInsRun' Units: milli seconds. Minimal value: 1500. maximal value 4000. Factory default: 3000 To change this object, load 'fibTmuFunctChkRingPerPerm' into non-volatile ram. The value written into non volatile memory is loaded into the current value only after reset.")
fibTmuFunctClaimTimeOutRun = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 8, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(150, 500))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuFunctClaimTimeOutRun.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuFunctClaimTimeOutRun.setDescription("Parameter indicating the elapsed time between the detection of a problem and the beginning of sending 'claim'. Units: milli seconds. Minimal value: 150. maximal value 500. Factory default: 250 To change this object, load 'fibTmuFunctClaimTimeOutPerm' into non-volatile ram. The value written into non volatile memory is loaded into the current value only after reset.")
fibTmuFunctAnotherCheckRun = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 8, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no-another-check", 1), ("another-check", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuFunctAnotherCheckRun.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuFunctAnotherCheckRun.setDescription("Indication on whether to perform another check before disabling a port as a cross check. Values: 1 - FALSE, 2 - TRUE. Factory default: FALSE. To change this object, load 'fibTmuFunctAnotherCheckPerm' into non-volatile ram. The value written into non volatile memory is loaded into the current value only after reset.")
fibTmuFunctTmsOnOutRun = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 8, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuFunctTmsOnOutRun.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuFunctTmsOnOutRun.setDescription("Parameter indicating the tms to leave out of the ring when carrying out 'warp out': It could be TMS no. 2 (TMS OUT) or the TMS which is on the secondary ring. values: (TMS OUT) 1, (TMS SECONDARY) 2 Factory default: (TMS OUT) 1 To change this object, load 'fibTmuFunctTmsOnOutPerm' into non-volatile ram. The value written into non volatile memory is loaded into the current value only after reset.")
fibTmuFunctUseJitterRun = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 8, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no-jitter-buster", 1), ("use-jitter-buster", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuFunctUseJitterRun.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuFunctUseJitterRun.setDescription("Indication on whether to use the jitter buster hardware module or not. Values: 1 - FALSE, 2 - TRUE. Factory default: TRUE. To change this object, load 'fibTmuFunctUseJitterPerm' into non-volatile ram. The value written into non volatile memory is loaded into the current value only after reset.")
fibTmuFunctForceStpRiRun = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 8, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("do-not-force-ri-stp", 1), ("force-ri-stp", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuFunctForceStpRiRun.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuFunctForceStpRiRun.setDescription("This object is used to control the type of the trunk (OPTIC or STP). Algorithm: if (optic-module-exists && do-not-force-ri-stp) { ri-trunk-type = OPTIC ; } else { /* * This is the case of: NO-OPTIC-MODULE or * FORCING-THE-TRUNK-TO-STP */ ri-trunk-type = STP ; } Factory default: FALSE (1). To change this object, load 'fibTmuFunctForceStpRiPerm' into non-volatile ram. The value written into non volatile memory is loaded into the current value only after reset.")
fibTmuFunctForceStpRoRun = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 8, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("do-not-force-ro-stp", 1), ("force-ro-stp", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuFunctForceStpRoRun.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuFunctForceStpRoRun.setDescription("This object is used to control the type of the trunk (OPTIC or STP). Algorithm: if (optic-module-exists && do-not-force-ro-stp) { ro-trunk-type = OPTIC ; } else { /* * This is the case of: NO-OPTIC-MODULE or * FORCING-THE-TRUNK-TO-STP */ ro-trunk-type = STP ; } Factory default: FALSE (1). To change this object, load 'fibTmuFunctForceStpRoPerm' into non-volatile ram. The value written into non volatile memory is loaded into the current value only after reset.")
fibTmuFunctMaxSavRecRun = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 8, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuFunctMaxSavRecRun.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuFunctMaxSavRecRun.setDescription("Parameter indicating how many elements to save in the fifo buffer of containing the history of recovery. Minimal value: 5. maximal value 20. Factory default: 20 To change this object, load 'fibTmuFunctMaxSavRecPerm' into non-volatile ram. The value written into non volatile memory is loaded into the current value only after reset.")
fibTmuFunctReadPerRun = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 8, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuFunctReadPerRun.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuFunctReadPerRun.setDescription("Parameter indicating the elapsed time between two readings of the error counter of a TMS. Too large a period may result in counter overflow. A value of '0' indicates 'read every TR driver poll' Units: milli seconds. Minimal value: 0. maximal value 5000. Factory default: 5000. To change this object, load 'fibTmuFunctReadPerPerm' into non-volatile ram. The value written into non volatile memory is loaded into the current value only after reset.")
fibTmuFunctDmaThreshRun = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 8, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuFunctDmaThreshRun.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuFunctDmaThreshRun.setDescription("Parameter indicating the number of times DMA will attempt retry in case of bus error before giving up. Minimal value: 0. maximal value 30. Factory default: 30. To change this object, load 'fibTmuFunctDmaThreshPerm' into non-volatile ram. The value written into non volatile memory is loaded into the current value only after reset.")
fibTmuFunctRemWrapTypeRun = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 8, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuFunctRemWrapTypeRun.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuFunctRemWrapTypeRun.setDescription("Parameter indicating the criterion for removing 'wrap': It could be removed when the ring is not beaconing and it could be removed when the ring is not claiming. values: (NOT BEACONING) 1, (NOT CLAIMING) 2 Factory default: (NOT BEACONING) 1 To change this object, load 'fibTmuFunctRemWrapTypePerm' into non-volatile ram. The value written into non volatile memory is loaded into the current value only after reset.")
fibTmuFunctRemWrapLenRun = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 8, 1, 27), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fibTmuFunctRemWrapLenRun.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuFunctRemWrapLenRun.setDescription("Parameter indicating the elapsed time between the time it is decided that wrap can be removed and the actual removal. See 'fibTmuFunctRemWrapTypeRun'. Units: milli seconds. Minimal value: 0. maximal value 2000. Factory default: 0. To change this object, load 'fibTmuFunctRemWrapLenPerm' into non-volatile ram. The value written into non volatile memory is loaded into the current value only after reset.")
fibTmuFunctBeacon2AutotestPerm = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 8, 2, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(160, 200))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fibTmuFunctBeacon2AutotestPerm.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuFunctBeacon2AutotestPerm.setDescription("The time period for starting the 'autoremove' test after start of beaconing. In units of milliseconds. Minimal value: 160. maximal value 200. Factory default: 160. Setting this variable loads it into non volatile memory. The value written into non volatile memory is loaded into the current value only after reset.")
fibTmuFunctBeacon2OkPerm = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 8, 2, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(40, 200))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fibTmuFunctBeacon2OkPerm.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuFunctBeacon2OkPerm.setDescription('The upper bound for time period starting at the removal of a problem till ring status indicates no beaconing. In units of milliseconds. Minimal value: 40. maximal value 200. Factory default: 50. Setting this variable loads it into non volatile memory. The value written into non volatile memory is loaded into the current value only after reset.')
fibTmuFunctOk2BeaconPerm = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 8, 2, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1100, 2500))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fibTmuFunctOk2BeaconPerm.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuFunctOk2BeaconPerm.setDescription('The upper bound for time period starting at the insertion of a problem till ring status indicates beaconing. In units of milliseconds. Minimal value: 1100. maximal value 2500. Factory default: 2000. Setting this variable loads it into non volatile memory. The value written into non volatile memory is loaded into the current value only after reset.')
fibTmuFunctWrapCwtPerm = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 8, 2, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 200))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fibTmuFunctWrapCwtPerm.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuFunctWrapCwtPerm.setDescription('Time delay to apply, after changing warp relay state. In units of milliseconds. Intended to let TMS get the real ring status. Minimal value: 0. maximal value 200. Factory default: 100. Setting this variable loads it into non volatile memory. The value written into non volatile memory is loaded into the current value only after reset.')
fibTmuFunctWrapWnrPerm = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 8, 2, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dont-release-cpu", 1), ("release-cpu", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fibTmuFunctWrapWnrPerm.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuFunctWrapWnrPerm.setDescription('Flag indicating whether to release CPU while waiting after warp change. Values: 1 - FALSE, 2 - TRUE. Factory default: TRUE. Setting this variable loads it into non volatile memory. The value written into non volatile memory is loaded into the current value only after reset.')
fibTmuFunctRingIstPerm = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 8, 2, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 200))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fibTmuFunctRingIstPerm.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuFunctRingIstPerm.setDescription('Time to poll for consistent Tmu ring status before continuing recovery. In units of milliseconds. Minimal value: 0. maximal value 200. Factory default: 0 Setting this variable loads it into non volatile memory. The value written into non volatile memory is loaded into the current value only after reset.')
fibTmuFunctRingIstnrPerm = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 8, 2, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("istnr-dont-release-cpu", 1), ("istnr-release-cpu", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fibTmuFunctRingIstnrPerm.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuFunctRingIstnrPerm.setDescription('Flag indicating whether to release CPU while waiting for consistent Tmu ring status. Values: 1 - FALSE, 2 - TRUE. Factory default: TRUE. Setting this variable loads it into non volatile memory. The value written into non volatile memory is loaded into the current value only after reset.')
fibTmuFunctCheckAogTauPerm = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 8, 2, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dont-check-ring", 1), ("check-ring", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fibTmuFunctCheckAogTauPerm.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuFunctCheckAogTauPerm.setDescription("Flag is used during BRUTAL recovery (single problem). If TRUE (checck-ring) then check whether the ring is BEACONING after opening the good TAU's (This check takes fibTmuFunctOk2BeaconRun milli sec. and not needed in most cases). Values: 1 - FALSE, 2 - TRUE. Factory default: FALSE. Setting this variable loads it into non volatile memory. The value written into non volatile memory is loaded into the current value only after reset.")
fibTmuFunctMaxNoiPerm = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 8, 2, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 300))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fibTmuFunctMaxNoiPerm.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuFunctMaxNoiPerm.setDescription('When several station wants to insert into the ring, this parameter sets the limit on the maximal number of stations which are allowed to insert (other stations are delayed until the next round). If 0 then enable all stations are allowed to insert. Minimal value: 0. maximal value 300. Factory default: 1 Setting this variable loads it into non volatile memory. The value written into non volatile memory is loaded into the current value only after reset.')
fibTmuFunctLinkPtifPerm = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 8, 2, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dont-link-to-last", 1), ("link-to-last", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fibTmuFunctLinkPtifPerm.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuFunctLinkPtifPerm.setDescription('When problem in TMU segment is discovered then if this flag is TRUE, first of all try to find problem between last inserted stations. Values: 1 - FALSE, 2 - TRUE. Factory default: TRUE. Setting this variable loads it into non volatile memory. The value written into non volatile memory is loaded into the current value only after reset.')
fibTmuFunctInsPatPerm = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 8, 2, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1500, 4000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fibTmuFunctInsPatPerm.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuFunctInsPatPerm.setDescription("Parameter for controlling the aging of the 'inseretion-pool' (Should be long enough to make sure that the station is not malfunctioning). Units: milli seconds. Minimal value: 1500. maximal value 4000. Factory default: 3000 Setting this variable loads it into non volatile memory. The value written into non volatile memory is loaded into the current value only after reset.")
fibTmuFunctUseMismatchPerm = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 8, 2, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dont-use-mismatch", 1), ("use-mismatch", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fibTmuFunctUseMismatchPerm.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuFunctUseMismatchPerm.setDescription('Indication on whether to apply recovery when the number of stations is larger than the number of open ports. Values: 1 - FALSE, 2 - TRUE. Factory default: TRUE. Setting this variable loads it into non volatile memory. The value written into non volatile memory is loaded into the current value only after reset.')
fibTmuFunctChkRingInsPerm = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 8, 2, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dont-check-ring", 1), ("check-ring", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fibTmuFunctChkRingInsPerm.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuFunctChkRingInsPerm.setDescription("Indication on whether to check ring status (for possible problems caused by the currently inserted stations) or not. Setting 'TRUE' results in quicker discovery of stations with invalid frequency but inflicts higher overhead on legitimate frequency stations. Values: 1 - FALSE, 2 - TRUE. Factory default: FALSE. Setting this variable loads it into non volatile memory. The value written into non volatile memory is loaded into the current value only after reset.")
fibTmuFunctChkRingPerPerm = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 8, 2, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1500, 4000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fibTmuFunctChkRingPerPerm.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuFunctChkRingPerPerm.setDescription("Parameter indicating the elapsed time after letting a station into the ring after which a station is considered to be o.k. See 'fibTmuFunctChkRingInsPerm' Units: milli seconds. Minimal value: 1500. maximal value 4000. Factory default: 3000 Setting this variable loads it into non volatile memory. The value written into non volatile memory is loaded into the current value only after reset.")
fibTmuFunctClaimTimeOutPerm = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 8, 2, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(150, 500))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fibTmuFunctClaimTimeOutPerm.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuFunctClaimTimeOutPerm.setDescription("Parameter indicating the elapsed time between the detection of a problem and the beginning of sending 'claim'. Units: milli seconds. Minimal value: 150. maximal value 500. Factory default: 250 Setting this variable loads it into non volatile memory. The value written into non volatile memory is loaded into the current value only after reset.")
fibTmuFunctAnotherCheckPerm = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 8, 2, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no-another-check", 1), ("another-check", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fibTmuFunctAnotherCheckPerm.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuFunctAnotherCheckPerm.setDescription('Indication on whether to perform another check before disabling a port as a cross check. Values: 1 - FALSE, 2 - TRUE. Factory default: FALSE. Setting this variable loads it into non volatile memory. The value written into non volatile memory is loaded into the current value only after reset.')
fibTmuFunctTmsOnOutPerm = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 8, 2, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fibTmuFunctTmsOnOutPerm.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuFunctTmsOnOutPerm.setDescription("Parameter indicating the tms to leave out of the ring when carrying out 'warp out': It could be TMS no. 2 (TMS OUT) or the TMS which is on the secondary ring. values: (TMS OUT) 1, (TMS SECONDARY) 2 Factory default: (TMS OUT) 1 Setting this variable loads it into non volatile memory. The value written into non volatile memory is loaded into the current value only after reset.")
fibTmuFunctUseJitterPerm = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 8, 2, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no-jitter-buster", 1), ("use-jitter-buster", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fibTmuFunctUseJitterPerm.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuFunctUseJitterPerm.setDescription('Indication on whether to use the jitter buster hardware module or not. Values: 1 - FALSE, 2 - TRUE. Factory default: TRUE. Setting this variable loads it into non volatile memory. The value written into non volatile memory is loaded into the current value only after reset.')
fibTmuFunctForceStpRiPerm = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 8, 2, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("do-not-force-ri-stp", 1), ("force-ri-stp", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fibTmuFunctForceStpRiPerm.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuFunctForceStpRiPerm.setDescription('This object is used to control the type of the trunk (OPTIC or STP). Algorithm: if (optic-module-exists && do-not-force-ri-stp) { ri-trunk-type = OPTIC ; } else { /* * This is the case of: NO-OPTIC-MODULE or * FORCING-THE-TRUNK-TO-STP */ ri-trunk-type = STP ; } Factory default: FALSE (1). Setting this variable loads it into non volatile memory. The value written into non volatile memory is loaded into the current value only after reset.')
fibTmuFunctForceStpRoPerm = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 8, 2, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("do-not-force-ro-stp", 1), ("force-ro-stp", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fibTmuFunctForceStpRoPerm.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuFunctForceStpRoPerm.setDescription('This object is used to control the type of the trunk (OPTIC or STP). Algorithm: if (optic-module-exists && do-not-force-ro-stp) { ro-trunk-type = OPTIC ; } else { /* * This is the case of: NO-OPTIC-MODULE or * FORCING-THE-TRUNK-TO-STP */ ro-trunk-type = STP ; } Factory default: FALSE (1). Setting this variable loads it into non volatile memory. The value written into non volatile memory is loaded into the current value only after reset.')
fibTmuFunctMaxSavRecPerm = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 8, 2, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fibTmuFunctMaxSavRecPerm.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuFunctMaxSavRecPerm.setDescription('Parameter indicating how many elements to save in the fifo buffer of containing the history of recovery. Minimal value: 5. maximal value 20. Factory default: 20 Setting this variable loads it into non volatile memory. The value written into non volatile memory is loaded into the current value only after reset.')
fibTmuFunctReadPerPerm = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 8, 2, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fibTmuFunctReadPerPerm.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuFunctReadPerPerm.setDescription("Parameter indicating the elapsed time between two readings of the error counter of a TMS. Too large a period may result in counter overflow. A value of '0' indicates 'read every TR driver poll' Units: milli seconds. Minimal value: 0. maximal value 5000. Factory default: 5000. Setting this variable loads it into non volatile memory. The value written into non volatile memory is loaded into the current value only after reset.")
fibTmuFunctDmaThreshPerm = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 8, 2, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fibTmuFunctDmaThreshPerm.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuFunctDmaThreshPerm.setDescription('Parameter indicating the number of times DMA will attempt retry in case of bus error before giving up. Minimal value: 0. maximal value 30. Factory default: 30. Setting this variable loads it into non volatile memory. The value written into non volatile memory is loaded into the current value only after reset.')
fibTmuFunctRemWrapTypePerm = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 8, 2, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fibTmuFunctRemWrapTypePerm.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuFunctRemWrapTypePerm.setDescription("Parameter indicating the criterion for removing 'wrap': It could be removed when the ring is not beaconing and it could be removed when the ring is not claiming. values: (NOT BEACONING) 1, (NOT CLAIMING) 2 Factory default: (NOT BEACONING) 1 Setting this variable loads it into non volatile memory. The value written into non volatile memory is loaded into the current value only after reset.")
fibTmuFunctRemWrapLenPerm = MibScalar((1, 3, 6, 1, 4, 1, 22, 60, 8, 2, 27), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fibTmuFunctRemWrapLenPerm.setStatus('mandatory')
if mibBuilder.loadTexts: fibTmuFunctRemWrapLenPerm.setDescription("Parameter indicating the elapsed time between the time it is decided that wrap can be removed and the actual removal. See 'fibTmuFunctRemWrapTypePerm'. Units: milli seconds. Minimal value: 0. maximal value 2000. Factory default: 0. Setting this variable loads it into non volatile memory. The value written into non volatile memory is loaded into the current value only after reset.")
mibBuilder.exportSymbols("TMU-MIB", fibTmuNumRxSpecific=fibTmuNumRxSpecific, fibTmuArpAgeTime=fibTmuArpAgeTime, fibTmuFunctInsPatRun=fibTmuFunctInsPatRun, fibTmuFunctRingIstPerm=fibTmuFunctRingIstPerm, fibTmuMatchIndex=fibTmuMatchIndex, fibTmuMatchNoMatchReason=fibTmuMatchNoMatchReason, fibTmuNumUnknownType=fibTmuNumUnknownType, fibTmuNumRxBdcst=fibTmuNumRxBdcst, fibTmuPortsNumPorts=fibTmuPortsNumPorts, fibTmuIntrfcEntry=fibTmuIntrfcEntry, fibTmuFunctForceStpRiRun=fibTmuFunctForceStpRiRun, fibTmuParityEc=fibTmuParityEc, fibTmuStationsTable=fibTmuStationsTable, fibTmuEepromVersion=fibTmuEepromVersion, fibTmuPortsLastPollTime=fibTmuPortsLastPollTime, fibTmuNumRifLong=fibTmuNumRifLong, fibTmuPortsPortState=fibTmuPortsPortState, fibTmuPortsTauAllowedAddr=fibTmuPortsTauAllowedAddr, fibTmuStationsStationsListValid=fibTmuStationsStationsListValid, fibTmuFunctWrapCwtRun=fibTmuFunctWrapCwtRun, fibTmuProductionFlash0Size=fibTmuProductionFlash0Size, fibTmuFunctBeacon2OkPerm=fibTmuFunctBeacon2OkPerm, fibTmuRunFaultsFormat=fibTmuRunFaultsFormat, fibTmuNumBeaconsRcvd=fibTmuNumBeaconsRcvd, fibTmuPortsTmuPortIndex=fibTmuPortsTmuPortIndex, fibTmuProductionRomType=fibTmuProductionRomType, fibTmuLoadEeDefaults=fibTmuLoadEeDefaults, fibTmuFunctRingIstnrPerm=fibTmuFunctRingIstnrPerm, fibTmuPortsTauAllowedAddrLoaded=fibTmuPortsTauAllowedAddrLoaded, fibTmuMatchPortId=fibTmuMatchPortId, fibTmuPortsTauMode=fibTmuPortsTauMode, fibTmuRxNoiseEc=fibTmuRxNoiseEc, fibTmuFunctMaxSavRecRun=fibTmuFunctMaxSavRecRun, fibTmuFunctWrapCwtPerm=fibTmuFunctWrapCwtPerm, fibTmuSccDrvVersion=fibTmuSccDrvVersion, fibTmuFunctUseJitterPerm=fibTmuFunctUseJitterPerm, fibTmuMatchConfigChipIndex=fibTmuMatchConfigChipIndex, fibTmuMatchNumEntries=fibTmuMatchNumEntries, fibTmuNumNonSnap=fibTmuNumNonSnap, private=private, fibTmuFunctRingIstnrRun=fibTmuFunctRingIstnrRun, fibTmuFunctReadPerRun=fibTmuFunctReadPerRun, fibTmuStationsPhysAddr=fibTmuStationsPhysAddr, fibTmuPortsLedState=fibTmuPortsLedState, fibTmuMatchListValid=fibTmuMatchListValid, fibTmuStationsSecondChipIndex=fibTmuStationsSecondChipIndex, fibTmuPortsTmuPort=fibTmuPortsTmuPort, fibTmuFunctChkRingInsPerm=fibTmuFunctChkRingInsPerm, fibTmuDisplayDebugMode=fibTmuDisplayDebugMode, fibTmuFunctWrapWnrPerm=fibTmuFunctWrapWnrPerm, fibTmuFunctAnotherCheckPerm=fibTmuFunctAnotherCheckPerm, enterprises=enterprises, fibTmuPortsAllTable=fibTmuPortsAllTable, tmuStations=tmuStations, fibTmuProductionAddr48No1=fibTmuProductionAddr48No1, fibTmuFunctRtpGrpVrsRun=fibTmuFunctRtpGrpVrsRun, fibTmuNumArpRcvd=fibTmuNumArpRcvd, fibTmuEeFaultsFormat=fibTmuEeFaultsFormat, fibTmuNumRrpRjctIp=fibTmuNumRrpRjctIp, fibTmuNumRxRjctMem=fibTmuNumRxRjctMem, fibTmuMatchNumTmuEntries=fibTmuMatchNumTmuEntries, fibTmuDontResetFatal=fibTmuDontResetFatal, fibTmuFunctBeacon2OkRun=fibTmuFunctBeacon2OkRun, mgmt=mgmt, fibTmuFunctDmaThreshPerm=fibTmuFunctDmaThreshPerm, fibTmuLastBeaconTime=fibTmuLastBeaconTime, fibTmuProductionEepromType=fibTmuProductionEepromType, fibTmuSnmpUsrVersion=fibTmuSnmpUsrVersion, fibTmuPortsAllowedAddrLoaded=fibTmuPortsAllowedAddrLoaded, fibTmuStationsNumTmuEntries=fibTmuStationsNumTmuEntries, fibTmuEepromDeffective=fibTmuEepromDeffective, fibTmuRealTimeClock=fibTmuRealTimeClock, fibTmuAc00Cntr=fibTmuAc00Cntr, fibTmuStationsNumEntries=fibTmuStationsNumEntries, fibTmuPortsUpdateTime=fibTmuPortsUpdateTime, fibTmuPortsTauPortIndex=fibTmuPortsTauPortIndex, fibTmuFunctChkRingInsRun=fibTmuFunctChkRingInsRun, fibTmuProductionBoardType=fibTmuProductionBoardType, fibTmuFunctClaimTimeOutPerm=fibTmuFunctClaimTimeOutPerm, fibTmuFunctRingIstRun=fibTmuFunctRingIstRun, fibTmuNumNoRif=fibTmuNumNoRif, fibTmuStationsFirstChipIndex=fibTmuStationsFirstChipIndex, fibTmuPortsNumPortsPerTmu=fibTmuPortsNumPortsPerTmu, fibTmuIntrfcIndex=fibTmuIntrfcIndex, fibTmuNumStationLeft=fibTmuNumStationLeft, fibTmuFunctCheckAogTauPerm=fibTmuFunctCheckAogTauPerm, fibTmuPortsTauRevision=fibTmuPortsTauRevision, fibTmuFunctOk2BeaconPerm=fibTmuFunctOk2BeaconPerm, fibTmuFunctRemWrapLenRun=fibTmuFunctRemWrapLenRun, fibTmuProductionFlash1Size=fibTmuProductionFlash1Size, fibTmuFunctLinkPtifRun=fibTmuFunctLinkPtifRun, fibTmuFunctTmsOnOutPerm=fibTmuFunctTmsOnOutPerm, fibTmuPortsNumTausPerTmu=fibTmuPortsNumTausPerTmu, fibTmuPortsGenClosePerm=fibTmuPortsGenClosePerm, fibTmuSecurityModePerm=fibTmuSecurityModePerm, fibTmuFunctAnotherCheckRun=fibTmuFunctAnotherCheckRun, fibTmuAc01Cntr=fibTmuAc01Cntr, fibTmuProductionRamType=fibTmuProductionRamType, fibTmuNumProcessDisabled=fibTmuNumProcessDisabled, fibTmuMatchSecondChipIndex=fibTmuMatchSecondChipIndex, fibTmuStationsUpToDate=fibTmuStationsUpToDate, fibTmuProductionAddr48No2=fibTmuProductionAddr48No2, fibTmuMatchEntry=fibTmuMatchEntry, fibTmuFunctClaimTimeOutRun=fibTmuFunctClaimTimeOutRun, fibTmuFunctLinkPtifPerm=fibTmuFunctLinkPtifPerm, fibTmuMatchTable=fibTmuMatchTable, fibTmuStationsEntry=fibTmuStationsEntry, fibTmuFunctRemWrapTypeRun=fibTmuFunctRemWrapTypeRun, fibTmuFunctBeacon2AutotestRun=fibTmuFunctBeacon2AutotestRun, fibTmuSecurityModeRun=fibTmuSecurityModeRun, fibTmuNumStationSecurity=fibTmuNumStationSecurity, fibTmuPortsNumPortsPerTau=fibTmuPortsNumPortsPerTau, fibTmuStationsUpdateTime=fibTmuStationsUpdateTime, fibTmuNumIfDown=fibTmuNumIfDown, fibTmuPortsNumModules=fibTmuPortsNumModules, fibTmuPortsTauTable=fibTmuPortsTauTable, fibTmuFunctForceStpRiPerm=fibTmuFunctForceStpRiPerm, tmuSecurity=tmuSecurity, fibTmuMatchActMonIndex=fibTmuMatchActMonIndex, fibronics=fibronics, fibTmuPortsTauEntry=fibTmuPortsTauEntry, fibTmuTrDrvVersion=fibTmuTrDrvVersion, fibTmuFunctCheckAogTauRun=fibTmuFunctCheckAogTauRun, fibTmuProductionHwInfo=fibTmuProductionHwInfo, fibTmuFunctTmsOnOutRun=fibTmuFunctTmsOnOutRun, fibTmuMatchUpdateTime=fibTmuMatchUpdateTime, fibTmuUtilitiesVersion=fibTmuUtilitiesVersion, fibTmuProductionRamSize=fibTmuProductionRamSize, fibTmuPortsModuleId=fibTmuPortsModuleId, fibTmuAc10Cntr=fibTmuAc10Cntr, fibTmuMainSwVersion=fibTmuMainSwVersion, fibTmuMatchFirstChipIndex=fibTmuMatchFirstChipIndex, fibTmuFunctReadPerPerm=fibTmuFunctReadPerPerm, fibTmuLastBeaconNaun=fibTmuLastBeaconNaun, fibTmuNumRifIncluded=fibTmuNumRifIncluded, fibTmuMatchUpToDate=fibTmuMatchUpToDate, fibTmuAc11Cntr=fibTmuAc11Cntr, fibTmuNumIpRcvd=fibTmuNumIpRcvd, fibTmuPortsManagerClosePerm=fibTmuPortsManagerClosePerm, fibTmuPortsMaxNumTauErrs=fibTmuPortsMaxNumTauErrs, fibTmuRIConnection=fibTmuRIConnection, fibTmuNumRxAccepted=fibTmuNumRxAccepted, fibTmuProductionAddr48No3=fibTmuProductionAddr48No3, fibTmuPortsNumPhantomUp=fibTmuPortsNumPhantomUp, fibTmuBreakEc=fibTmuBreakEc, fibTmuPortsLastTxTime=fibTmuPortsLastTxTime, fibTmuFunctInsPatPerm=fibTmuFunctInsPatPerm, fibTmuPortsNumPhantomPresent=fibTmuPortsNumPhantomPresent, fibTmuMatchTauId=fibTmuMatchTauId, fibTmuIntrfcTable=fibTmuIntrfcTable, fibTmuPortsStationInfo=fibTmuPortsStationInfo, fibTmuWrapIn=fibTmuWrapIn, fibTmuPortsPortStatus=fibTmuPortsPortStatus, fibTmuPortsTauPortState=fibTmuPortsTauPortState, fibTmuStationsIndex=fibTmuStationsIndex, fibTmuPortsPhysAddr=fibTmuPortsPhysAddr, fibTmuFunctBeacon2AutotestPerm=fibTmuFunctBeacon2AutotestPerm, fibTmuMatchPhysAddr=fibTmuMatchPhysAddr, fibTmuROConnection=fibTmuROConnection, fibTmuFrameEc=fibTmuFrameEc, tmuMatch=tmuMatch, fibTmuFunctForceStpRoRun=fibTmuFunctForceStpRoRun, fibTmuPortsMaxFirstTimeout=fibTmuPortsMaxFirstTimeout, tmu=tmu, fibTmuNumAddrNotFound=fibTmuNumAddrNotFound, fibTmuFunctRemWrapLenPerm=fibTmuFunctRemWrapLenPerm, fibTmuFunctWrapWnrRun=fibTmuFunctWrapWnrRun, fibTmuPortsNumRelayOpen=fibTmuPortsNumRelayOpen, fibTmuNumConfigNotValid=fibTmuNumConfigNotValid, fibTmuLastBeaconAddr=fibTmuLastBeaconAddr, fibTmuMatchStationInfo=fibTmuMatchStationInfo, fibTmuNumEventErrs=fibTmuNumEventErrs, fibTmuLastBeaconType=fibTmuLastBeaconType, fibTmuFunctForceStpRoPerm=fibTmuFunctForceStpRoPerm, fibTmuNumRxGroup=fibTmuNumRxGroup, fibTmuFunctionalityVersion=fibTmuFunctionalityVersion, tmuFunction=tmuFunction, fibTmuFunctUseMismatchPerm=fibTmuFunctUseMismatchPerm, fibTmuProductionFlashType=fibTmuProductionFlashType, fibTmuNumOwnBrdcst=fibTmuNumOwnBrdcst, fibTmuProductionEepromSize=fibTmuProductionEepromSize, fibTmuFunctDmaThreshRun=fibTmuFunctDmaThreshRun, fibTmuFunctChkRingPerPerm=fibTmuFunctChkRingPerPerm, fibTmuNumRarpUpdate=fibTmuNumRarpUpdate, fibTmuLastSysIfIndex=fibTmuLastSysIfIndex, tmuProduction=tmuProduction, fibTmuNumRarpRcvd=fibTmuNumRarpRcvd, fibTmuPortsNumTimeout=fibTmuPortsNumTimeout, fibTmuStationsConfigChipIndex=fibTmuStationsConfigChipIndex, fibTmuStationsStationInfo=fibTmuStationsStationInfo, fibTmuPortsRequestType=fibTmuPortsRequestType, fibTmuPortsAllowedAddr=fibTmuPortsAllowedAddr, fibTmuProductionSerialNum=fibTmuProductionSerialNum, fibTmuPortsNumConsequentErrs=fibTmuPortsNumConsequentErrs, fibTmuPortsGenCloseRun=fibTmuPortsGenCloseRun, fibTmuPortsNumAttached=fibTmuPortsNumAttached, fibTmuFunctUseJitterRun=fibTmuFunctUseJitterRun, fibTmuStationsActMonIndex=fibTmuStationsActMonIndex, fibTmuFunctChkRingPerRun=fibTmuFunctChkRingPerRun, fibTmuFunctMaxNoiRun=fibTmuFunctMaxNoiRun, fibTmuFunctMaxSavRecPerm=fibTmuFunctMaxSavRecPerm, fibTmuNumRxFunctional=fibTmuNumRxFunctional, fibTmuFunctOk2BeaconRun=fibTmuFunctOk2BeaconRun, fibTmuPortsPortType=fibTmuPortsPortType, fibTmuPortsManagerCloseRun=fibTmuPortsManagerCloseRun, fibTmuFunctMaxNoiPerm=fibTmuFunctMaxNoiPerm, tmuSystem=tmuSystem, fibTmuPortsEndConnection=fibTmuPortsEndConnection, fibTmuFunctRemWrapTypePerm=fibTmuFunctRemWrapTypePerm, fibTmuWrapOut=fibTmuWrapOut, fibTmuFunctUseMismatchRun=fibTmuFunctUseMismatchRun, fibTmuMatchNoStationsListReason=fibTmuMatchNoStationsListReason, fibTmuPortsAllEntry=fibTmuPortsAllEntry, tmuPorts=tmuPorts, fibTmuFunctRtpGrpVrsPerm=fibTmuFunctRtpGrpVrsPerm, tmuIntrfc=tmuIntrfc)

#
# PySNMP MIB module IPAD-ATM-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/IPAD-ATM-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:55:41 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueRangeConstraint, ConstraintsUnion, ValueSizeConstraint, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueRangeConstraint", "ConstraintsUnion", "ValueSizeConstraint", "SingleValueConstraint")
ipad, = mibBuilder.importSymbols("IPADv2-MIB", "ipad")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
ModuleIdentity, ObjectIdentity, Unsigned32, NotificationType, IpAddress, Counter32, Integer32, MibIdentifier, TimeTicks, Gauge32, Bits, Counter64, MibScalar, MibTable, MibTableRow, MibTableColumn, iso = mibBuilder.importSymbols("SNMPv2-SMI", "ModuleIdentity", "ObjectIdentity", "Unsigned32", "NotificationType", "IpAddress", "Counter32", "Integer32", "MibIdentifier", "TimeTicks", "Gauge32", "Bits", "Counter64", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "iso")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
ipadAtm = ModuleIdentity((1, 3, 6, 1, 4, 1, 321, 100, 1, 25))
if mibBuilder.loadTexts: ipadAtm.setLastUpdated('0003270001Z')
if mibBuilder.loadTexts: ipadAtm.setOrganization('Verilink Corporation')
if mibBuilder.loadTexts: ipadAtm.setContactInfo('support@verilink.com 1-800-926-0085')
if mibBuilder.loadTexts: ipadAtm.setDescription('The IPAD ATM MIB.')
ipadAtmParms = MibIdentifier((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 1))
ipadAtmStatsParms = MibIdentifier((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 2))
ipadAtmVccParms = MibIdentifier((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 3))
ipadAtmVccStatsParms = MibIdentifier((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 4))
ipadAtmCesParms = MibIdentifier((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 5))
ipadAtmFrParms = MibIdentifier((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 6))
ipadAtmTable = MibTable((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 1, 1), )
if mibBuilder.loadTexts: ipadAtmTable.setStatus('current')
if mibBuilder.loadTexts: ipadAtmTable.setDescription('Table of ATM parameters.')
ipadAtmTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 1, 1, 1), ).setIndexNames((0, "IPAD-ATM-MIB", "ipadAtmIfIndex"))
if mibBuilder.loadTexts: ipadAtmTableEntry.setStatus('current')
if mibBuilder.loadTexts: ipadAtmTableEntry.setDescription('An entry in the ipad ATM parameter table.')
ipadAtmIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmIfIndex.setStatus('current')
if mibBuilder.loadTexts: ipadAtmIfIndex.setDescription('The index into the ATM table.')
ipadAtmOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("down", 2), ("upNoCellSync", 3), ("upCellSync", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmOperStatus.setStatus('current')
if mibBuilder.loadTexts: ipadAtmOperStatus.setDescription('The up/down status of this atm interface.')
ipadAtmVccsOpenedOK = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 1, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmVccsOpenedOK.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccsOpenedOK.setDescription('The current number of successfully opened VCCs on this ATM interface.')
ipadAtmVccsNotOpened = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 1, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmVccsNotOpened.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccsNotOpened.setDescription('The current number of VCCs that were not successfully opened on this ATM interface.')
ipadAtmAlarmReset = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("clearAlarms", 2), ("clearStats", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipadAtmAlarmReset.setStatus('current')
if mibBuilder.loadTexts: ipadAtmAlarmReset.setDescription('Reset the alarms or statistics of this ATM interface.')
ipadAtmOverSubscriptionFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipadAtmOverSubscriptionFactor.setStatus('current')
if mibBuilder.loadTexts: ipadAtmOverSubscriptionFactor.setDescription("The current over-subscription-factor for this ATM interface. Used for VBR and UBR VC connection admission control to allow the either VBR or UBR service category connections to collectively use more bandwidth than is available in order to make use of the statistical multiplexing of the connections. The PCR of each individual VC is limited to the interface's line rate. However when multiple VCs are configured, the sum of their PCR values can go up to (OverSubscriptionFactor * (line-rate) / 53*8). A value of 1 indicates no oversubscription allowed. A value of 5 indicates 5 times oversubscription allowed. Note that CBR connections cannot be oversubscribed. Also, if CES is in use on the interface, all AAL5 connections have their PCR limited to the amount which the line rate can support above the commitment for CES, and the oversubscription applies only to that bandwidth above the CES commitment.")
ipadAtmLineBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 1, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmLineBandwidth.setStatus('current')
if mibBuilder.loadTexts: ipadAtmLineBandwidth.setDescription('The current ATM Line interface Bandwidth in cells per second.')
ipadAtmAAL5Bandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 1, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmAAL5Bandwidth.setStatus('current')
if mibBuilder.loadTexts: ipadAtmAAL5Bandwidth.setDescription('The current AAL5 Bandwidth in cells per second.')
ipadAtmOverSubBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 1, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmOverSubBandwidth.setStatus('current')
if mibBuilder.loadTexts: ipadAtmOverSubBandwidth.setDescription('The AAL5 Oversubscription Bandwidth in cells per second. This value is ipadAtmAAL5Bandwidth multiplied by the ipadAtmOversubscriptionFactor.')
ipadAtmCbrUsedBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 1, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmCbrUsedBandwidth.setStatus('current')
if mibBuilder.loadTexts: ipadAtmCbrUsedBandwidth.setDescription('The amount of AAL5 Bandwidth allocated to CBR VCs in cells per second.')
ipadAtmVbrUsedBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 1, 1, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmVbrUsedBandwidth.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVbrUsedBandwidth.setDescription('The amount of AAL5 Bandwidth allocated to VBR VCs in cells per second. When OversubscriptionFactor is greater than 1, this value can exceed ipadAtmAAL5Bandwidth.')
ipadAtmUbrUsedBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 1, 1, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmUbrUsedBandwidth.setStatus('current')
if mibBuilder.loadTexts: ipadAtmUbrUsedBandwidth.setDescription('The amount of AAL5 Bandwidth allocated to UBR VCs in cells per second. When OversubscriptionFactor is greater than 1, this value can exceed ipadAtmAAL5Bandwidth.')
ipadAtmQos0Pcr = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 1, 1, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmQos0Pcr.setStatus('current')
if mibBuilder.loadTexts: ipadAtmQos0Pcr.setDescription('The value of PCR to be used for each VC which has no specified QOS profile (0). The VC is configured as UBR with the given Peak Cell Rate.')
ipadAtmStatsTable = MibTable((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 2, 1), )
if mibBuilder.loadTexts: ipadAtmStatsTable.setStatus('current')
if mibBuilder.loadTexts: ipadAtmStatsTable.setDescription('Table of ATM statistics.')
ipadAtmStatsTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 2, 1, 1), ).setIndexNames((0, "IPAD-ATM-MIB", "ipadAtmStatsIndex"), (0, "IPAD-ATM-MIB", "ipadAtmStatsPeriodIndex"))
if mibBuilder.loadTexts: ipadAtmStatsTableEntry.setStatus('current')
if mibBuilder.loadTexts: ipadAtmStatsTableEntry.setDescription('An entry in the ipad ATM Stats parameter table.')
ipadAtmStatsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmStatsIndex.setStatus('current')
if mibBuilder.loadTexts: ipadAtmStatsIndex.setDescription('The index representing the ATM interface.')
ipadAtmStatsPeriodIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 2, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmStatsPeriodIndex.setStatus('current')
if mibBuilder.loadTexts: ipadAtmStatsPeriodIndex.setDescription('The index representing the period for the ATM stats entry.')
ipadAtmStatsTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 2, 1, 1, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmStatsTimeStamp.setStatus('current')
if mibBuilder.loadTexts: ipadAtmStatsTimeStamp.setDescription('The value of sysUpTime the last time the statistics were updated.')
ipadAtmStatsRxFramesOK = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 2, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmStatsRxFramesOK.setStatus('current')
if mibBuilder.loadTexts: ipadAtmStatsRxFramesOK.setDescription('The number of error-free frames received during the period.')
ipadAtmStatsTxFramesOK = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 2, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmStatsTxFramesOK.setStatus('current')
if mibBuilder.loadTexts: ipadAtmStatsTxFramesOK.setDescription('The number of frames successfully transmitted during the period.')
ipadAtmStatsRxFramesError = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 2, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmStatsRxFramesError.setStatus('current')
if mibBuilder.loadTexts: ipadAtmStatsRxFramesError.setDescription('The number of errored frames received during the period.')
ipadAtmStatsTxFramesError = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 2, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmStatsTxFramesError.setStatus('current')
if mibBuilder.loadTexts: ipadAtmStatsTxFramesError.setDescription('The number of transmitted frames that were errored.')
ipadAtmStatsRxBytesOK = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 2, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmStatsRxBytesOK.setStatus('current')
if mibBuilder.loadTexts: ipadAtmStatsRxBytesOK.setDescription('The number of error-free bytes received during the period.')
ipadAtmStatsTxBytesOK = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 2, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmStatsTxBytesOK.setStatus('current')
if mibBuilder.loadTexts: ipadAtmStatsTxBytesOK.setDescription('The number of successfully transmitted bytes during the period.')
ipadAtmStatsLostSync = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 2, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmStatsLostSync.setStatus('current')
if mibBuilder.loadTexts: ipadAtmStatsLostSync.setDescription('The number of times sync has been lost or recovered.')
ipadAtmStatsOamCellsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 2, 1, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmStatsOamCellsRx.setStatus('current')
if mibBuilder.loadTexts: ipadAtmStatsOamCellsRx.setDescription('The number of OAM cells received on this ATM link.')
ipadAtmStatsOamCellsTx = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 2, 1, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmStatsOamCellsTx.setStatus('current')
if mibBuilder.loadTexts: ipadAtmStatsOamCellsTx.setDescription('The number of OAM cells transmitted on this ATM link.')
ipadAtmVccTable = MibTable((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 3, 1), )
if mibBuilder.loadTexts: ipadAtmVccTable.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccTable.setDescription('Table of Virtual Channel parameters.')
ipadAtmVccTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 3, 1, 1), ).setIndexNames((0, "IPAD-ATM-MIB", "ipadAtmVccIndex"), (0, "IPAD-ATM-MIB", "ipadAtmVccVpiIndex"), (0, "IPAD-ATM-MIB", "ipadAtmVccVciIndex"))
if mibBuilder.loadTexts: ipadAtmVccTableEntry.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccTableEntry.setDescription('An entry in the ipad ATM Vcc parameter table.')
ipadAtmVccIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmVccIndex.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccIndex.setDescription('The index into the ATM VCC table, corresponding to ifIndex.')
ipadAtmVccVpiIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 3, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmVccVpiIndex.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccVpiIndex.setDescription('The VPI for the VCC.')
ipadAtmVccVciIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 3, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmVccVciIndex.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccVciIndex.setDescription('The VCI for the VCC.')
ipadAtmVccEncapsulationType = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("other", 1), ("serialPPPoA", 2), ("vcMux", 3), ("llcMux", 4), ("serialHDLCoA", 5), ("frf5", 6), ("frf8", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipadAtmVccEncapsulationType.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccEncapsulationType.setDescription('The encapsulation method used on this VCC. vcMux indicates null encapsulation and may be used for IP routing or PPP applications. llcMux indicates LLC encapsulation and may be used for IP routing, bridging, and PPP applications. serialPPPoA and serialHDLCoA indicate serial port applications.')
ipadAtmVccTrafficType = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("cbr", 2), ("rtVbr", 3), ("nrtVbr", 4), ("abr", 5), ("ubr", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmVccTrafficType.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccTrafficType.setDescription('The traffic type of this VCC.')
ipadAtmVccChannelRate = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 3, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmVccChannelRate.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccChannelRate.setDescription('The channel rate for this VCC.')
ipadAtmVccAlarmReset = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("clearAlarms", 2), ("clearStats", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipadAtmVccAlarmReset.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccAlarmReset.setDescription('Reset the alarms or statistics of this VCC.')
ipadAtmVccSLATimer = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 3, 1, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipadAtmVccSLATimer.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccSLATimer.setDescription('The time in seconds between SLA measurement packets being sent.')
ipadAtmVccRemoteFramesOffered = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 3, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmVccRemoteFramesOffered.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccRemoteFramesOffered.setDescription('The number of frames offered by the remote device.')
ipadAtmVccFramesReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 3, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmVccFramesReceived.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccFramesReceived.setDescription('The number of frames received by this device.')
ipadAtmVccRemoteDataOffered = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 3, 1, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmVccRemoteDataOffered.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccRemoteDataOffered.setDescription('The number of data bytes offered by the remote device.')
ipadAtmVccDataReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 3, 1, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmVccDataReceived.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccDataReceived.setDescription('The number of data bytes received by this device.')
ipadAtmVccRemoteActive = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 3, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("inactive", 2), ("active", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmVccRemoteActive.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccRemoteActive.setDescription('The current state of the remote device as detected by the local device.')
ipadAtmVccRemoteVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 3, 1, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmVccRemoteVpi.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccRemoteVpi.setDescription('The remote VPI.')
ipadAtmVccRemoteVci = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 3, 1, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmVccRemoteVci.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccRemoteVci.setDescription('The remote VCI.')
ipadAtmVccRemoteIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 3, 1, 1, 16), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmVccRemoteIPAddress.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccRemoteIPAddress.setDescription('The IP Address of the device connected to the remote end of this VCC.')
ipadAtmVccRemoteUnitId = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 3, 1, 1, 17), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmVccRemoteUnitId.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccRemoteUnitId.setDescription('The Unit ID assigned to the devie connected to the remote end of this VCC.')
ipadAtmVccEtoeLoopbackCommand = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 3, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("start", 2), ("stop", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipadAtmVccEtoeLoopbackCommand.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccEtoeLoopbackCommand.setDescription('A command to issue on the VCC Loopback. The start command is used to start an OAM F5 VCC loopback. The stop command is used to terminate the OAM loopback. The statistics variables associated with the OAM loopback are automatically cleared when a loopback is started.')
ipadAtmVccEtoeLoopbackState = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 3, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("inactive", 1), ("active", 2), ("loopback", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmVccEtoeLoopbackState.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccEtoeLoopbackState.setDescription('The state of this VCC loopback function. The active state means OAM F5 loopback cells are being sent from this endpoint once every 5 seconds. The loopback state means that OAM F5 loopback cells are being received and returned from this endpoint.')
ipadAtmVccEtoeLoopbackCellsTx = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 3, 1, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmVccEtoeLoopbackCellsTx.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccEtoeLoopbackCellsTx.setDescription('The number of OAM F5 Loopback cells transmitted for this VCC.')
ipadAtmVccEtoeLoopbackCellsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 3, 1, 1, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmVccEtoeLoopbackCellsRx.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccEtoeLoopbackCellsRx.setDescription('The number of OAM F5 Loopback cells received for this VCC.')
ipadAtmVccEtoeLoopbackRttMin = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 3, 1, 1, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmVccEtoeLoopbackRttMin.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccEtoeLoopbackRttMin.setDescription('The minimum round trip time in milliseconds between sending a loopback cell and receiving the returned loopback cell.')
ipadAtmVccEtoeLoopbackRttMax = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 3, 1, 1, 23), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmVccEtoeLoopbackRttMax.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccEtoeLoopbackRttMax.setDescription('The maximum round trip time in milliseconds between sending a loopback cell and receiving the returned loopback cell.')
ipadAtmVccEtoeLoopbackRttAvg = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 3, 1, 1, 24), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmVccEtoeLoopbackRttAvg.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccEtoeLoopbackRttAvg.setDescription('The average round trip time in milliseconds between sending a loopback cell and receiving the returned loopback cell.')
ipadAtmVccSegLoopbackCommand = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 3, 1, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("start", 2), ("stop", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipadAtmVccSegLoopbackCommand.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccSegLoopbackCommand.setDescription('A command to issue on the VCC Loopback. The start command is used to start an OAM F5 VCC loopback. The stop command is used to terminate the OAM loopback. The statistics variables associated with the OAM loopback are automatically cleared when a loopback is started.')
ipadAtmVccSegLoopbackState = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 3, 1, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("inactive", 1), ("active", 2), ("loopback", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmVccSegLoopbackState.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccSegLoopbackState.setDescription('The state of this VCC loopback function. The active state means OAM F5 loopback cells are being sent from this endpoint once every 5 seconds. The loopback state means that OAM F5 loopback cells are being received and returned from this endpoint.')
ipadAtmVccSegLoopbackCellsTx = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 3, 1, 1, 27), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmVccSegLoopbackCellsTx.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccSegLoopbackCellsTx.setDescription('The number of OAM F5 Loopback cells transmitted for this VCC.')
ipadAtmVccSegLoopbackCellsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 3, 1, 1, 28), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmVccSegLoopbackCellsRx.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccSegLoopbackCellsRx.setDescription('The number of OAM F5 Loopback cells received for this VCC.')
ipadAtmVccSegLoopbackRttMin = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 3, 1, 1, 29), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmVccSegLoopbackRttMin.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccSegLoopbackRttMin.setDescription('The minimum round trip time in milliseconds between sending a loopback cell and receiving the returned loopback cell.')
ipadAtmVccSegLoopbackRttMax = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 3, 1, 1, 30), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmVccSegLoopbackRttMax.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccSegLoopbackRttMax.setDescription('The maximum round trip time in milliseconds between sending a loopback cell and receiving the returned loopback cell.')
ipadAtmVccSegLoopbackRttAvg = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 3, 1, 1, 31), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmVccSegLoopbackRttAvg.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccSegLoopbackRttAvg.setDescription('The average round trip time in milliseconds between sending a loopback cell and receiving the returned loopback cell.')
ipadAtmVccEtoeContCheckCommand = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 3, 1, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("activate", 2), ("deactivate", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipadAtmVccEtoeContCheckCommand.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccEtoeContCheckCommand.setDescription('ipadAtmVccEtoeContCheckCommand is used to request activation or deactivation of the End-to-End continuity check on this VCC.')
ipadAtmVccEtoeContCheckAutoActivate = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 3, 1, 1, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disable", 2), ("enable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipadAtmVccEtoeContCheckAutoActivate.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccEtoeContCheckAutoActivate.setDescription('ipadAtmVccEtoeContCheckAutoActivate indicates whether End-to-End continuity check is automatically activated on this VCC. A Value of disable means CC is not automatically activated. A value of enable permits CC to be automatically activated after the VCC connection is established.')
ipadAtmVccEtoeContCheckType = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 3, 1, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("sink", 2), ("source", 3), ("sinkAndSource", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmVccEtoeContCheckType.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccEtoeContCheckType.setDescription('Default Continuity Check Type used for this VCC. A value of none selects no continuity check. A value of sink, source, or sinkAndSource selects the respective continuity check functions. ipadAtmVccEtoeContCheckType can only be changed when CC is not currently active.')
ipadAtmVccEtoeContCheckTypeInUse = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 3, 1, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("sink", 2), ("source", 3), ("sinkAndSource", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmVccEtoeContCheckTypeInUse.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccEtoeContCheckTypeInUse.setDescription('The current Continuity Check Type in use for this VCC. ipadAtmVccEtoeContCheckTypeInUse may differ from ipadAtmVccEtoeContCheckType if CC is activated via inband OAM.')
ipadAtmVccEtoeContCheckStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 3, 1, 1, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("ready", 1), ("active", 2), ("activationFailed", 3), ("activating", 4), ("deactivating", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmVccEtoeContCheckStatus.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccEtoeContCheckStatus.setDescription('The current state of Continuity Check for this VCC. In the ready state, no CC is being performed. The ready state indicates CC is permitted to be activated. The activating state indicates CC has been requested and is being activated. During activation, an OAM activation cell is sent to the opposite endpoint to request CC. Once an activation confirmed cell is received, the state is then changed to active. Reception of an activation denied response or a multiple of 3 ten-second time outs waiting for a confirmation will result in an activationFailed state. CC sourcing is performed when state is active or activating. CC sinking is performed when state is active.')
ipadAtmVccEtoeContCheckCellsTx = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 3, 1, 1, 37), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmVccEtoeContCheckCellsTx.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccEtoeContCheckCellsTx.setDescription('The number of CC cells transmitted for this VCC for CC Sourcing function.')
ipadAtmVccEtoeContCheckCellsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 3, 1, 1, 38), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmVccEtoeContCheckCellsRx.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccEtoeContCheckCellsRx.setDescription('The number of CC cells received for this VCC for the CC Sinking function.')
ipadAtmVccEtoeAisStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 3, 1, 1, 39), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noAis", 1), ("ais", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmVccEtoeAisStatus.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccEtoeAisStatus.setDescription('The current e-t-e_VC-AIS state.')
ipadAtmVccEtoeRdiStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 3, 1, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noRdi", 1), ("rdi", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmVccEtoeRdiStatus.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccEtoeRdiStatus.setDescription('The current e-t-e_VC-RDI state.')
ipadAtmVccStatsTable = MibTable((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 4, 1), )
if mibBuilder.loadTexts: ipadAtmVccStatsTable.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccStatsTable.setDescription('Table of ATM statistics.')
ipadAtmVccStatsTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 4, 1, 1), ).setIndexNames((0, "IPAD-ATM-MIB", "ipadAtmVccStatsIndex"), (0, "IPAD-ATM-MIB", "ipadAtmVccStatsVpiIndex"), (0, "IPAD-ATM-MIB", "ipadAtmVccStatsVciIndex"), (0, "IPAD-ATM-MIB", "ipadAtmVccStatsPeriodIndex"))
if mibBuilder.loadTexts: ipadAtmVccStatsTableEntry.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccStatsTableEntry.setDescription('An entry in the ipad ATM VccStats parameter table.')
ipadAtmVccStatsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 4, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmVccStatsIndex.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccStatsIndex.setDescription('The index representing the ATM interface.')
ipadAtmVccStatsVpiIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 4, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmVccStatsVpiIndex.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccStatsVpiIndex.setDescription('The index representing the VPI of the VCC.')
ipadAtmVccStatsVciIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 4, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmVccStatsVciIndex.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccStatsVciIndex.setDescription('The index representing the VCI of the VCC.')
ipadAtmVccStatsPeriodIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 4, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmVccStatsPeriodIndex.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccStatsPeriodIndex.setDescription('The index representing the period for the VCC stats entry.')
ipadAtmVccStatsTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 4, 1, 1, 5), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmVccStatsTimeStamp.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccStatsTimeStamp.setDescription('The value of sysUpTime the last time the statistics were updated.')
ipadAtmVccStatsRxFramesOK = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 4, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmVccStatsRxFramesOK.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccStatsRxFramesOK.setDescription('The number of error-free frames received this period.')
ipadAtmVccStatsTxFramesOK = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 4, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmVccStatsTxFramesOK.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccStatsTxFramesOK.setDescription('The number of frames successfully transmitted during this period.')
ipadAtmVccStatsRxFramesError = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 4, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmVccStatsRxFramesError.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccStatsRxFramesError.setDescription('The number of errored frames received this period.')
ipadAtmVccStatsTxFramesError = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 4, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmVccStatsTxFramesError.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccStatsTxFramesError.setDescription('The number of frames that were not successfully transmitted during this period.')
ipadAtmVccStatsRxFramesCLP = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 4, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmVccStatsRxFramesCLP.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccStatsRxFramesCLP.setDescription('The number of frames received with CLP set during the period.')
ipadAtmVccStatsRxFramesCI = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 4, 1, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmVccStatsRxFramesCI.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccStatsRxFramesCI.setDescription('The number of frames received with congestion set during the period.')
ipadAtmVccStatsRxFramesAbort = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 4, 1, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmVccStatsRxFramesAbort.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccStatsRxFramesAbort.setDescription('The number of frames whose reception was aborted during the period.')
ipadAtmVccStatsRxFramesLenViolation = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 4, 1, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmVccStatsRxFramesLenViolation.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccStatsRxFramesLenViolation.setDescription('The number of frames received with a length violation during the period.')
ipadAtmVccStatsRxFramesCRCError = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 4, 1, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmVccStatsRxFramesCRCError.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccStatsRxFramesCRCError.setDescription('The number of frames received with CRC errors during the period.')
ipadAtmVccStatsRxFramesTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 4, 1, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmVccStatsRxFramesTimeout.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccStatsRxFramesTimeout.setDescription('The number of frames whose reception timed out during the period.')
ipadAtmVccStatsRxFramesHCSError = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 4, 1, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmVccStatsRxFramesHCSError.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccStatsRxFramesHCSError.setDescription('The number of frames received with an HCS error in a cell.')
ipadAtmVccStatsRxFramesNoBuffer = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 4, 1, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmVccStatsRxFramesNoBuffer.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccStatsRxFramesNoBuffer.setDescription('The number of frames discarded due to the lack of buffers.')
ipadAtmVccStatsRxCellsOK = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 4, 1, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmVccStatsRxCellsOK.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccStatsRxCellsOK.setDescription('The number of cells successfully received.')
ipadAtmVccStatsTxCellsOK = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 4, 1, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmVccStatsTxCellsOK.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccStatsTxCellsOK.setDescription('The number of cells successfully transmitted.')
ipadAtmVccStatsRxBytesOK = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 4, 1, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmVccStatsRxBytesOK.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccStatsRxBytesOK.setDescription('The number of bytes successfully received.')
ipadAtmVccStatsTxBytesOK = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 4, 1, 1, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmVccStatsTxBytesOK.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccStatsTxBytesOK.setDescription('The number of bytes successfully transmitted.')
ipadAtmVccStatsDelayPeak = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 4, 1, 1, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmVccStatsDelayPeak.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccStatsDelayPeak.setDescription('The peak delay measured during this period.')
ipadAtmVccStatsDelayAverage = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 4, 1, 1, 23), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmVccStatsDelayAverage.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccStatsDelayAverage.setDescription('The average delay measured during this period.')
ipadAtmVccStatsRoundTripTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 4, 1, 1, 24), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmVccStatsRoundTripTimeouts.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccStatsRoundTripTimeouts.setDescription('The number of round trip delay message timeouts measured.')
ipadAtmVccStatsRemoteFramesOffered = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 4, 1, 1, 25), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmVccStatsRemoteFramesOffered.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccStatsRemoteFramesOffered.setDescription('The number of frames offered by the remote device.')
ipadAtmVccStatsFramesReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 4, 1, 1, 26), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmVccStatsFramesReceived.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccStatsFramesReceived.setDescription('The number of frames received by the local device.')
ipadAtmVccStatsFDR = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 4, 1, 1, 27), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmVccStatsFDR.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccStatsFDR.setDescription('The calculated frame delivery ratio.')
ipadAtmVccStatsRemoteDataOffered = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 4, 1, 1, 28), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmVccStatsRemoteDataOffered.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccStatsRemoteDataOffered.setDescription('The number of data bytes offered by the remote device.')
ipadAtmVccStatsDataReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 4, 1, 1, 29), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmVccStatsDataReceived.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccStatsDataReceived.setDescription('The number of data bytes received by the local device.')
ipadAtmVccStatsDDR = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 4, 1, 1, 30), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmVccStatsDDR.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccStatsDDR.setDescription('The calculated data delivery ratio.')
ipadAtmVccStatsUAS = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 4, 1, 1, 31), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmVccStatsUAS.setStatus('current')
if mibBuilder.loadTexts: ipadAtmVccStatsUAS.setDescription('The number of seconds which the remote device was unavailable.')
ipadAtmCesTable = MibTable((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 5, 1), )
if mibBuilder.loadTexts: ipadAtmCesTable.setStatus('current')
if mibBuilder.loadTexts: ipadAtmCesTable.setDescription('Table of CES parameters.')
ipadAtmCesTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 5, 1, 1), ).setIndexNames((0, "IPAD-ATM-MIB", "ipadAtmCesIndex"))
if mibBuilder.loadTexts: ipadAtmCesTableEntry.setStatus('current')
if mibBuilder.loadTexts: ipadAtmCesTableEntry.setDescription('An entry in the ipad ATM CES parameter table.')
ipadAtmCesIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 5, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmCesIndex.setStatus('current')
if mibBuilder.loadTexts: ipadAtmCesIndex.setDescription('The index into the ATM CES table.')
ipadAtmCesPayloadScrambling = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disable", 2), ("enable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipadAtmCesPayloadScrambling.setStatus('current')
if mibBuilder.loadTexts: ipadAtmCesPayloadScrambling.setDescription('ipadAtmCesPayloadScrambling indicates whether CES payload scrambling is enabled.')
ipadAtmCesAutoChannelConfiguration = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 5, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disable", 2), ("enable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipadAtmCesAutoChannelConfiguration.setStatus('current')
if mibBuilder.loadTexts: ipadAtmCesAutoChannelConfiguration.setDescription('ipadAtmCesAutoChannelConfiguration indicates whether the CES channel configuration should be dynamic based on available line bandwidth.')
ipadAtmFrf5SvcTable = MibTable((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 6, 1), )
if mibBuilder.loadTexts: ipadAtmFrf5SvcTable.setStatus('current')
if mibBuilder.loadTexts: ipadAtmFrf5SvcTable.setDescription('Table of ATM FRF5 profile parameters.')
ipadAtmFrf5SvcTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 6, 1, 1), ).setIndexNames((0, "IPAD-ATM-MIB", "ipadAtmFrf5SvcIfIndex"), (0, "IPAD-ATM-MIB", "ipadAtmFrf5SvcVpiIndex"), (0, "IPAD-ATM-MIB", "ipadAtmFrf5SvcVciIndex"))
if mibBuilder.loadTexts: ipadAtmFrf5SvcTableEntry.setStatus('current')
if mibBuilder.loadTexts: ipadAtmFrf5SvcTableEntry.setDescription('An entry in the ipad ATM FRF5 service table.')
ipadAtmFrf5SvcIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 6, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmFrf5SvcIfIndex.setStatus('current')
if mibBuilder.loadTexts: ipadAtmFrf5SvcIfIndex.setDescription('The index representing the ATM interface.')
ipadAtmFrf5SvcVpiIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 6, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmFrf5SvcVpiIndex.setStatus('current')
if mibBuilder.loadTexts: ipadAtmFrf5SvcVpiIndex.setDescription('The index representing the VPI of the VCC.')
ipadAtmFrf5SvcVciIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 6, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmFrf5SvcVciIndex.setStatus('current')
if mibBuilder.loadTexts: ipadAtmFrf5SvcVciIndex.setDescription('The index representing the VCI of the VCC.')
ipadAtmFrf5SvcDeToClpMappingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 6, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("mode1", 1), ("mode2Const0", 2), ("mode2Const1", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipadAtmFrf5SvcDeToClpMappingMode.setStatus('current')
if mibBuilder.loadTexts: ipadAtmFrf5SvcDeToClpMappingMode.setDescription('Discard Eligibility to Cell Loss Priority mapping mode. mode1: The Discard Eligibility (DE) field in the Q.922 core frame shall be copied unchanged into the DE field in the FR-SSCS PDU header and mapped to the ATM Cell Loss Priority (CLP) of every ATM cell generated by the segmentation process of that frame. mode2Const0: The DE field in the Q.922 core frame shall be copied unchanged into the DE field in the FR-SSCS PDU header and the ATM Cell Loss Priority of every ATM cell generated by the segmentation process of that frame shall be set to the constant value 0. mode2Const1: The DE field in the Q.922 core frame shall be copied unchanged into the DE field in the FR-SSCS PDU header and the ATM Cell Loss Priority of every ATM cell generated by the segmentation process of that frame shall be set to the constant value 1.')
ipadAtmFrf5SvcClpToDeMappingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 6, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("mode1", 1), ("mode2", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipadAtmFrf5SvcClpToDeMappingMode.setStatus('current')
if mibBuilder.loadTexts: ipadAtmFrf5SvcClpToDeMappingMode.setDescription('Cell Loss Priority to Discard Eligibility mapping mode. mode1: If one or more ATM cells belonging to a frame has its CLP field set to one or if the DE field of the FR-SSCS PDU is set to one, the IWF shall set the DE field of the Q.922 core frame. mode2: No mapping is performed from the ATM layer to Q.922 core layer. The FR-SSCS PDU DE field is copied unchanged to the Q.922 core frame DE field, independent of CLP indications(s) received at the ATM layer.')
ipadAtmFrf5SvcN1 = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 6, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipadAtmFrf5SvcN1.setStatus('current')
if mibBuilder.loadTexts: ipadAtmFrf5SvcN1.setDescription('Number of keep alive requests between full status requests.')
ipadAtmFrf5SvcN2 = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 6, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipadAtmFrf5SvcN2.setStatus('current')
if mibBuilder.loadTexts: ipadAtmFrf5SvcN2.setDescription('Number of errors before alarm.')
ipadAtmFrf5SvcN3 = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 6, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipadAtmFrf5SvcN3.setStatus('current')
if mibBuilder.loadTexts: ipadAtmFrf5SvcN3.setDescription('Number of events to sample N2.')
ipadAtmFrf5SvcT1 = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 6, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 240))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipadAtmFrf5SvcT1.setStatus('current')
if mibBuilder.loadTexts: ipadAtmFrf5SvcT1.setDescription('Delay before issuing a poll sequence.')
ipadAtmFrf5SvcT2 = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 6, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 245))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipadAtmFrf5SvcT2.setStatus('current')
if mibBuilder.loadTexts: ipadAtmFrf5SvcT2.setDescription('T2 timer')
ipadAtmFrf5SvcActive = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 6, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("no", 2), ("yes", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmFrf5SvcActive.setStatus('current')
if mibBuilder.loadTexts: ipadAtmFrf5SvcActive.setDescription('Specifies if the frf5 service is active.')
ipadAtmFrf5SvcAddDLCI = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 6, 1, 1, 12), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipadAtmFrf5SvcAddDLCI.setStatus('current')
if mibBuilder.loadTexts: ipadAtmFrf5SvcAddDLCI.setDescription('Identifies a DLCI number to be added.')
ipadAtmFrf5SvcDeleteDLCI = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 6, 1, 1, 13), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipadAtmFrf5SvcDeleteDLCI.setStatus('current')
if mibBuilder.loadTexts: ipadAtmFrf5SvcDeleteDLCI.setDescription('Identifies a DLCI number to be deleted.')
ipadAtmFrf5DlciTable = MibTable((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 6, 2), )
if mibBuilder.loadTexts: ipadAtmFrf5DlciTable.setStatus('current')
if mibBuilder.loadTexts: ipadAtmFrf5DlciTable.setDescription('Table of Mapped DLCIs for VCCs. This table is used for FRF5 to map one or more DLCIs to a VCC. When only one DLCI is mapped, a one-to-one relationship exists between the DLCI and the VCC. When more than one DLCI is mapped, a many-to-one DLCI/VCC relationship exists.')
ipadAtmFrf5DlciTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 6, 2, 1), ).setIndexNames((0, "IPAD-ATM-MIB", "ipadAtmFrf5DlciIfIndex"), (0, "IPAD-ATM-MIB", "ipadAtmFrf5DlciVpiIndex"), (0, "IPAD-ATM-MIB", "ipadAtmFrf5DlciVciIndex"), (0, "IPAD-ATM-MIB", "ipadAtmFrf5DlciIndex"))
if mibBuilder.loadTexts: ipadAtmFrf5DlciTableEntry.setStatus('current')
if mibBuilder.loadTexts: ipadAtmFrf5DlciTableEntry.setDescription('An entry in the ipad ATM Vcc parameter table.')
ipadAtmFrf5DlciIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 6, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmFrf5DlciIfIndex.setStatus('current')
if mibBuilder.loadTexts: ipadAtmFrf5DlciIfIndex.setDescription('The index into the ATM FRF5 DLCI table, corresponding to ifIndex.')
ipadAtmFrf5DlciVpiIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 6, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmFrf5DlciVpiIndex.setStatus('current')
if mibBuilder.loadTexts: ipadAtmFrf5DlciVpiIndex.setDescription('The VPI index into the ATM FRF5 DLCI table.')
ipadAtmFrf5DlciVciIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 6, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmFrf5DlciVciIndex.setStatus('current')
if mibBuilder.loadTexts: ipadAtmFrf5DlciVciIndex.setDescription('The VCI index into the ATM FRF5 DLCI table.')
ipadAtmFrf5DlciIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 6, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmFrf5DlciIndex.setStatus('current')
if mibBuilder.loadTexts: ipadAtmFrf5DlciIndex.setDescription('The DLCI index into the ATM FRF5 DLCI table.')
ipadAtmFrf5DlciEndpointName = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 6, 2, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 11))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipadAtmFrf5DlciEndpointName.setStatus('current')
if mibBuilder.loadTexts: ipadAtmFrf5DlciEndpointName.setDescription('Identifies the attached endpoint for this FRF5 DLCI.')
ipadAtmFrf5DlciStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 6, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("inactive", 1), ("inactiveLearned", 2), ("active", 3), ("activeLearned", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmFrf5DlciStatus.setStatus('current')
if mibBuilder.loadTexts: ipadAtmFrf5DlciStatus.setDescription('The current status of this mapped entry.')
ipadAtmFrf5DlciCongestion = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 6, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("no", 2), ("yes", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmFrf5DlciCongestion.setStatus('current')
if mibBuilder.loadTexts: ipadAtmFrf5DlciCongestion.setDescription('Specifies if the dlci is receiving frames with FECN or BECN bit set.')
ipadAtmFrf8SvcTable = MibTable((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 6, 3), )
if mibBuilder.loadTexts: ipadAtmFrf8SvcTable.setStatus('current')
if mibBuilder.loadTexts: ipadAtmFrf8SvcTable.setDescription('Table of ATM FRF8 profile parameters.')
ipadAtmFrf8SvcTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 6, 3, 1), ).setIndexNames((0, "IPAD-ATM-MIB", "ipadAtmFrf8SvcIfIndex"), (0, "IPAD-ATM-MIB", "ipadAtmFrf8SvcVpiIndex"), (0, "IPAD-ATM-MIB", "ipadAtmFrf8SvcVciIndex"))
if mibBuilder.loadTexts: ipadAtmFrf8SvcTableEntry.setStatus('current')
if mibBuilder.loadTexts: ipadAtmFrf8SvcTableEntry.setDescription('An entry in the ipad ATM FRF8 service table.')
ipadAtmFrf8SvcIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 6, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmFrf8SvcIfIndex.setStatus('current')
if mibBuilder.loadTexts: ipadAtmFrf8SvcIfIndex.setDescription('The index representing the ATM interface.')
ipadAtmFrf8SvcVpiIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 6, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmFrf8SvcVpiIndex.setStatus('current')
if mibBuilder.loadTexts: ipadAtmFrf8SvcVpiIndex.setDescription('The index representing the VPI of the VCC.')
ipadAtmFrf8SvcVciIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 6, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipadAtmFrf8SvcVciIndex.setStatus('current')
if mibBuilder.loadTexts: ipadAtmFrf8SvcVciIndex.setDescription('The index representing the VCI of the VCC.')
ipadAtmFrf8SvcDeToClpMappingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 6, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("mode1", 1), ("mode2Const0", 2), ("mode2Const1", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipadAtmFrf8SvcDeToClpMappingMode.setStatus('current')
if mibBuilder.loadTexts: ipadAtmFrf8SvcDeToClpMappingMode.setDescription('This object describes which mode of translation is in use for loss priority mapping in the frame relay to ATM direction. mode1(1) = the DE field in the Q.922 core frame shall be mapped to the ATM CLP field of every cell generated by the segmentation process of the AAL5 PDU containing the information of that frame. mode2Contst0(2) = the ATM CLP field of every cell generated by the segmentation process of the AAL5 PDU containing the information of that frame shall be set to constant 0. mode2Contst1(3) = the ATM CLP field of every cell generated by the segmentation process of the AAL5 PDU containing the information of that frame shall be set to constant 1.')
ipadAtmFrf8SvcClpToDeMappingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 6, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("mode1", 1), ("mode2Const0", 2), ("mode2Const1", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipadAtmFrf8SvcClpToDeMappingMode.setStatus('current')
if mibBuilder.loadTexts: ipadAtmFrf8SvcClpToDeMappingMode.setDescription('This object describes which mode of translation is in use for loss priority mapping in the ATM to frame relay direction. mode1(1) = if one or more cells in a frame has its CLP field set, the DE field of the Q.922 core frame should be set. mode2Const0(2) = the DE field of the Q.922 core frame should be set to the constant 0. mode2Const1(3) = the DE field of the Q.922 core frame should be set to the constant 1.')
ipadAtmFrf8SvcCongestionMappingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 6, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("mode1", 1), ("mode2", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipadAtmFrf8SvcCongestionMappingMode.setStatus('current')
if mibBuilder.loadTexts: ipadAtmFrf8SvcCongestionMappingMode.setDescription("This object describes which mode of translation is in use for forward congestion indication mapping in the frame relay to ATM direction. mode1(1) = The FECN field in the Q.922 core frame shall be mapped to the ATM EFCI field of every cell generated by the segmentation process of the AAL5 PDU containing the information of that frame. mode2(2) = The FECN field in the Q.922 core frame shall not be mapped to the ATM EFCI field of cells generated by the segmentation process of the AAL5 PDU containing the information of that frame. The EFCI field is always set to 'congestion not experienced'. In both of the modes above, if there is congestion in the forward direction in the ATM layer within the IWF, then the IWF can set the EFCI field to 'congestion experienced'.")
ipadAtmFrf8SvcEncapsulationMappingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 6, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("transparentMode", 1), ("translationMode", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipadAtmFrf8SvcEncapsulationMappingMode.setStatus('current')
if mibBuilder.loadTexts: ipadAtmFrf8SvcEncapsulationMappingMode.setDescription('This object indicates whether the mapping of upper layer protocol encapsulation is enabled on this interworking connection. transparentMode(1) = Forward the encapsulations unaltered. translationMode(2) = Perform mapping between the two encapsulations due to the incompatibilities of the two methods.')
ipadAtmFrf8SvcEndpointName = MibTableColumn((1, 3, 6, 1, 4, 1, 321, 100, 1, 25, 6, 3, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 11))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipadAtmFrf8SvcEndpointName.setStatus('current')
if mibBuilder.loadTexts: ipadAtmFrf8SvcEndpointName.setDescription('Identifies the Frame Relay endpoint for this FRF8 Service.')
mibBuilder.exportSymbols("IPAD-ATM-MIB", ipadAtmStatsParms=ipadAtmStatsParms, ipadAtmCesAutoChannelConfiguration=ipadAtmCesAutoChannelConfiguration, ipadAtmVccEtoeAisStatus=ipadAtmVccEtoeAisStatus, ipadAtmIfIndex=ipadAtmIfIndex, ipadAtmVccSegLoopbackCellsRx=ipadAtmVccSegLoopbackCellsRx, ipadAtmVccStatsRxBytesOK=ipadAtmVccStatsRxBytesOK, ipadAtmVccEtoeLoopbackRttMax=ipadAtmVccEtoeLoopbackRttMax, ipadAtmStatsIndex=ipadAtmStatsIndex, ipadAtmStatsTxFramesError=ipadAtmStatsTxFramesError, ipadAtmVccTableEntry=ipadAtmVccTableEntry, ipadAtmVccStatsTxCellsOK=ipadAtmVccStatsTxCellsOK, ipadAtmVccsNotOpened=ipadAtmVccsNotOpened, ipadAtmFrf5DlciIndex=ipadAtmFrf5DlciIndex, ipadAtmVccTable=ipadAtmVccTable, ipadAtmVccStatsDataReceived=ipadAtmVccStatsDataReceived, ipadAtmVccStatsRxFramesTimeout=ipadAtmVccStatsRxFramesTimeout, ipadAtmStatsTimeStamp=ipadAtmStatsTimeStamp, ipadAtmFrf5DlciStatus=ipadAtmFrf5DlciStatus, ipadAtmOverSubBandwidth=ipadAtmOverSubBandwidth, ipadAtmCesTable=ipadAtmCesTable, ipadAtmFrf8SvcDeToClpMappingMode=ipadAtmFrf8SvcDeToClpMappingMode, ipadAtmVccStatsRxFramesHCSError=ipadAtmVccStatsRxFramesHCSError, ipadAtmVccStatsVciIndex=ipadAtmVccStatsVciIndex, ipadAtmStatsTxFramesOK=ipadAtmStatsTxFramesOK, ipadAtmFrf5DlciEndpointName=ipadAtmFrf5DlciEndpointName, ipadAtmFrf5DlciIfIndex=ipadAtmFrf5DlciIfIndex, ipadAtmVccStatsRxFramesCLP=ipadAtmVccStatsRxFramesCLP, ipadAtmVccEtoeLoopbackCellsRx=ipadAtmVccEtoeLoopbackCellsRx, ipadAtmStatsRxFramesOK=ipadAtmStatsRxFramesOK, ipadAtmFrf8SvcEncapsulationMappingMode=ipadAtmFrf8SvcEncapsulationMappingMode, ipadAtmVccStatsDDR=ipadAtmVccStatsDDR, ipadAtmVccParms=ipadAtmVccParms, ipadAtmVccStatsRxFramesNoBuffer=ipadAtmVccStatsRxFramesNoBuffer, ipadAtmVccStatsTxBytesOK=ipadAtmVccStatsTxBytesOK, ipadAtmVbrUsedBandwidth=ipadAtmVbrUsedBandwidth, ipadAtmVccStatsTableEntry=ipadAtmVccStatsTableEntry, ipadAtmVccVpiIndex=ipadAtmVccVpiIndex, ipadAtmCesTableEntry=ipadAtmCesTableEntry, ipadAtmFrf5SvcVpiIndex=ipadAtmFrf5SvcVpiIndex, ipadAtmVccSegLoopbackCellsTx=ipadAtmVccSegLoopbackCellsTx, ipadAtmVccEtoeContCheckCellsTx=ipadAtmVccEtoeContCheckCellsTx, ipadAtmQos0Pcr=ipadAtmQos0Pcr, ipadAtmVccSLATimer=ipadAtmVccSLATimer, ipadAtmCbrUsedBandwidth=ipadAtmCbrUsedBandwidth, ipadAtmVccFramesReceived=ipadAtmVccFramesReceived, ipadAtmFrf5SvcIfIndex=ipadAtmFrf5SvcIfIndex, ipadAtmVccStatsParms=ipadAtmVccStatsParms, ipadAtmVccStatsTxFramesError=ipadAtmVccStatsTxFramesError, ipadAtmVccRemoteIPAddress=ipadAtmVccRemoteIPAddress, ipadAtmVccRemoteUnitId=ipadAtmVccRemoteUnitId, ipadAtmVccStatsRemoteFramesOffered=ipadAtmVccStatsRemoteFramesOffered, ipadAtmUbrUsedBandwidth=ipadAtmUbrUsedBandwidth, ipadAtmStatsTxBytesOK=ipadAtmStatsTxBytesOK, ipadAtmFrf5SvcT1=ipadAtmFrf5SvcT1, ipadAtmVccEtoeLoopbackCellsTx=ipadAtmVccEtoeLoopbackCellsTx, ipadAtmVccStatsRoundTripTimeouts=ipadAtmVccStatsRoundTripTimeouts, ipadAtmVccStatsTable=ipadAtmVccStatsTable, ipadAtmCesIndex=ipadAtmCesIndex, ipadAtmVccStatsFramesReceived=ipadAtmVccStatsFramesReceived, ipadAtmVccEtoeContCheckAutoActivate=ipadAtmVccEtoeContCheckAutoActivate, ipadAtmVccStatsDelayAverage=ipadAtmVccStatsDelayAverage, ipadAtmVccTrafficType=ipadAtmVccTrafficType, ipadAtmFrf5SvcDeleteDLCI=ipadAtmFrf5SvcDeleteDLCI, ipadAtmVccEtoeLoopbackState=ipadAtmVccEtoeLoopbackState, ipadAtmFrf5SvcN1=ipadAtmFrf5SvcN1, ipadAtmFrf5SvcDeToClpMappingMode=ipadAtmFrf5SvcDeToClpMappingMode, ipadAtmFrf8SvcTableEntry=ipadAtmFrf8SvcTableEntry, ipadAtmVccsOpenedOK=ipadAtmVccsOpenedOK, ipadAtmVccDataReceived=ipadAtmVccDataReceived, ipadAtmVccStatsRxFramesLenViolation=ipadAtmVccStatsRxFramesLenViolation, ipadAtmAlarmReset=ipadAtmAlarmReset, ipadAtmStatsTable=ipadAtmStatsTable, ipadAtmFrf5SvcAddDLCI=ipadAtmFrf5SvcAddDLCI, ipadAtmFrf5SvcVciIndex=ipadAtmFrf5SvcVciIndex, ipadAtmVccSegLoopbackState=ipadAtmVccSegLoopbackState, ipadAtmStatsOamCellsTx=ipadAtmStatsOamCellsTx, ipadAtmVccStatsTimeStamp=ipadAtmVccStatsTimeStamp, ipadAtmTableEntry=ipadAtmTableEntry, ipadAtmVccEtoeContCheckCommand=ipadAtmVccEtoeContCheckCommand, ipadAtmVccRemoteDataOffered=ipadAtmVccRemoteDataOffered, ipadAtmParms=ipadAtmParms, ipadAtmStatsRxBytesOK=ipadAtmStatsRxBytesOK, ipadAtmStatsLostSync=ipadAtmStatsLostSync, ipadAtmVccEtoeLoopbackCommand=ipadAtmVccEtoeLoopbackCommand, ipadAtmFrf5SvcN2=ipadAtmFrf5SvcN2, ipadAtmVccEtoeContCheckStatus=ipadAtmVccEtoeContCheckStatus, ipadAtmVccStatsVpiIndex=ipadAtmVccStatsVpiIndex, ipadAtmVccStatsRemoteDataOffered=ipadAtmVccStatsRemoteDataOffered, ipadAtmVccStatsDelayPeak=ipadAtmVccStatsDelayPeak, ipadAtmVccChannelRate=ipadAtmVccChannelRate, ipadAtmCesPayloadScrambling=ipadAtmCesPayloadScrambling, ipadAtmVccStatsRxFramesOK=ipadAtmVccStatsRxFramesOK, ipadAtmVccEtoeContCheckTypeInUse=ipadAtmVccEtoeContCheckTypeInUse, ipadAtmFrf5SvcTableEntry=ipadAtmFrf5SvcTableEntry, ipadAtmFrf8SvcCongestionMappingMode=ipadAtmFrf8SvcCongestionMappingMode, ipadAtmFrf5DlciCongestion=ipadAtmFrf5DlciCongestion, ipadAtmVccStatsPeriodIndex=ipadAtmVccStatsPeriodIndex, ipadAtmFrf5SvcN3=ipadAtmFrf5SvcN3, ipadAtmStatsTableEntry=ipadAtmStatsTableEntry, ipadAtmVccSegLoopbackRttMax=ipadAtmVccSegLoopbackRttMax, ipadAtmVccIndex=ipadAtmVccIndex, ipadAtmVccRemoteActive=ipadAtmVccRemoteActive, ipadAtmFrf5SvcActive=ipadAtmFrf5SvcActive, ipadAtmVccRemoteVci=ipadAtmVccRemoteVci, ipadAtmVccEtoeLoopbackRttAvg=ipadAtmVccEtoeLoopbackRttAvg, ipadAtmVccAlarmReset=ipadAtmVccAlarmReset, ipadAtmOverSubscriptionFactor=ipadAtmOverSubscriptionFactor, ipadAtmFrf8SvcEndpointName=ipadAtmFrf8SvcEndpointName, ipadAtmVccStatsRxFramesCRCError=ipadAtmVccStatsRxFramesCRCError, ipadAtmFrf5SvcT2=ipadAtmFrf5SvcT2, ipadAtmFrf5DlciVpiIndex=ipadAtmFrf5DlciVpiIndex, ipadAtmVccStatsUAS=ipadAtmVccStatsUAS, ipadAtmVccStatsRxFramesError=ipadAtmVccStatsRxFramesError, ipadAtmFrf8SvcIfIndex=ipadAtmFrf8SvcIfIndex, ipadAtmVccStatsTxFramesOK=ipadAtmVccStatsTxFramesOK, ipadAtmFrf5DlciVciIndex=ipadAtmFrf5DlciVciIndex, ipadAtmFrf8SvcVciIndex=ipadAtmFrf8SvcVciIndex, ipadAtmVccEncapsulationType=ipadAtmVccEncapsulationType, ipadAtmCesParms=ipadAtmCesParms, ipadAtm=ipadAtm, ipadAtmVccEtoeContCheckType=ipadAtmVccEtoeContCheckType, ipadAtmVccEtoeContCheckCellsRx=ipadAtmVccEtoeContCheckCellsRx, ipadAtmLineBandwidth=ipadAtmLineBandwidth, ipadAtmVccStatsRxFramesAbort=ipadAtmVccStatsRxFramesAbort, ipadAtmFrf5DlciTable=ipadAtmFrf5DlciTable, ipadAtmTable=ipadAtmTable, PYSNMP_MODULE_ID=ipadAtm, ipadAtmVccSegLoopbackCommand=ipadAtmVccSegLoopbackCommand, ipadAtmFrf5SvcTable=ipadAtmFrf5SvcTable, ipadAtmVccStatsRxFramesCI=ipadAtmVccStatsRxFramesCI, ipadAtmOperStatus=ipadAtmOperStatus, ipadAtmVccEtoeRdiStatus=ipadAtmVccEtoeRdiStatus, ipadAtmVccVciIndex=ipadAtmVccVciIndex, ipadAtmVccRemoteVpi=ipadAtmVccRemoteVpi, ipadAtmVccStatsIndex=ipadAtmVccStatsIndex, ipadAtmFrParms=ipadAtmFrParms, ipadAtmStatsRxFramesError=ipadAtmStatsRxFramesError, ipadAtmStatsOamCellsRx=ipadAtmStatsOamCellsRx, ipadAtmVccStatsFDR=ipadAtmVccStatsFDR, ipadAtmFrf8SvcClpToDeMappingMode=ipadAtmFrf8SvcClpToDeMappingMode, ipadAtmFrf5DlciTableEntry=ipadAtmFrf5DlciTableEntry, ipadAtmAAL5Bandwidth=ipadAtmAAL5Bandwidth, ipadAtmVccSegLoopbackRttMin=ipadAtmVccSegLoopbackRttMin, ipadAtmFrf8SvcTable=ipadAtmFrf8SvcTable, ipadAtmFrf5SvcClpToDeMappingMode=ipadAtmFrf5SvcClpToDeMappingMode, ipadAtmStatsPeriodIndex=ipadAtmStatsPeriodIndex, ipadAtmVccRemoteFramesOffered=ipadAtmVccRemoteFramesOffered, ipadAtmVccSegLoopbackRttAvg=ipadAtmVccSegLoopbackRttAvg, ipadAtmVccStatsRxCellsOK=ipadAtmVccStatsRxCellsOK, ipadAtmFrf8SvcVpiIndex=ipadAtmFrf8SvcVpiIndex, ipadAtmVccEtoeLoopbackRttMin=ipadAtmVccEtoeLoopbackRttMin)

#
# PySNMP MIB module CISCO-FC-ROUTE-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-FC-ROUTE-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:58:09 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsIntersection, SingleValueConstraint, ValueSizeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsIntersection", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsUnion")
ciscoMgmt, = mibBuilder.importSymbols("CISCO-SMI", "ciscoMgmt")
VsanIndex, FcAddressId = mibBuilder.importSymbols("CISCO-ST-TC", "VsanIndex", "FcAddressId")
vsanIndex, = mibBuilder.importSymbols("CISCO-VSAN-MIB", "vsanIndex")
entPhysicalIndex, PhysicalIndex = mibBuilder.importSymbols("ENTITY-MIB", "entPhysicalIndex", "PhysicalIndex")
InterfaceIndex, = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
NotificationGroup, ModuleCompliance, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance", "ObjectGroup")
Unsigned32, Counter32, iso, NotificationType, Counter64, Bits, Gauge32, IpAddress, MibScalar, MibTable, MibTableRow, MibTableColumn, Integer32, MibIdentifier, TimeTicks, ModuleIdentity, ObjectIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "Unsigned32", "Counter32", "iso", "NotificationType", "Counter64", "Bits", "Gauge32", "IpAddress", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Integer32", "MibIdentifier", "TimeTicks", "ModuleIdentity", "ObjectIdentity")
TextualConvention, TruthValue, TestAndIncr, DisplayString, TimeStamp, RowStatus = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "TruthValue", "TestAndIncr", "DisplayString", "TimeStamp", "RowStatus")
ciscoFcRouteMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 9, 284))
ciscoFcRouteMIB.setRevisions(('2003-09-04 00:00', '2002-11-01 00:00', '2002-10-02 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ciscoFcRouteMIB.setRevisionsDescriptions(('Updated fcRouteDomainId & fcRouteMetric range and added compliance statement for fcRouteDomainId and fcRouteMetric.', 'Updated fcRouteProto. ', 'Initial version of this MIB module.',))
if mibBuilder.loadTexts: ciscoFcRouteMIB.setLastUpdated('200309040000Z')
if mibBuilder.loadTexts: ciscoFcRouteMIB.setOrganization('Cisco Systems Inc. ')
if mibBuilder.loadTexts: ciscoFcRouteMIB.setContactInfo(' Cisco Systems Customer Service Postal: 170 W Tasman Drive San Jose, CA 95134 USA Tel: +1 800 553 -NETS E-mail: cs-san@cisco.com')
if mibBuilder.loadTexts: ciscoFcRouteMIB.setDescription('The MIB module for configuring and displaying FC (Fibre Channel) Route Information.')
ciscoFcRouteMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 284, 1))
fcRouteMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 284, 2))
fcRouteConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 284, 1, 1))
fcRouteStatistics = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 284, 1, 2))
fcRouteNotification = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 284, 1, 3))
fcRouteNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 284, 1, 3, 0))
fcRouteLastChangeTime = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 284, 1, 1, 1), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcRouteLastChangeTime.setStatus('current')
if mibBuilder.loadTexts: fcRouteLastChangeTime.setDescription('The value of sysUpTime at the most recent time when a conceptual row was created, modified, or deleted in fcRouteTable. If no change has occurred since the last restart of the management system, then the value of this object is 0. ')
fcRoutePreference = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 284, 1, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcRoutePreference.setStatus('current')
if mibBuilder.loadTexts: fcRoutePreference.setDescription('The value of route preference.Route preference is the value used to select one route over other when more than one route to the same destination is learned from different protocols, peers, or static routes from end-users. The preference value is an arbitrary assigned value used to determine the order of routes to the same destination in a single routing database(RIB). The active route is chosen by the lowest preference value. ')
fcRouteVerifyAction = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 284, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("none", 1), ("verify", 2))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcRouteVerifyAction.setStatus('current')
if mibBuilder.loadTexts: fcRouteVerifyAction.setDescription("The action to perform a consistency check of fcRouteTable. none (1) - no action verify (2) - perform verify action Writing verify(2) does a consistency check of the fcRouteTable with either one of the following: - with routeTable in the persistent database if the fcRouteVerifyType value is pss(1) - with forwarding information base software tables on the module specified by fcRouteVerifyModule, if the fcRouteVerifyType value is fibShadow(2). - with forwarding information base hardware tables on the module specified by fcRouteVerifyModule if the fcRouteVerifyType value is fibHardware(3). This verify action is performed on the fcRouteTable for the VSAN specified by fcRouteVerifyVsanID and for the route entries of the type specified by fcRouteVerifyRouteType. The result is shown by fcRouteVerifyResult. If a verify, due to a previous action performed, is in progress in the agent, then setting the fcRouteVerifyAction to verify(2) again will fail. No verification is performed if the value is set to none(1). When read, this object always has the value 'none(1)'. ")
fcRouteVerifyType = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 284, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("pss", 1), ("fibShadow", 2), ("fibHardware", 3))).clone('fibHardware')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcRouteVerifyType.setStatus('current')
if mibBuilder.loadTexts: fcRouteVerifyType.setDescription('The value used by fcRouteVerifyAction to perform the consistency check of fcRouteTable with: - route table in persistent database if value is pss(1) - forwarding information base software tables if value is fibShadow(2) - forwarding information base hardware tables if value is fibHardware(3). ')
fcRouteVerifyModule = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 284, 1, 1, 5), PhysicalIndex()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcRouteVerifyModule.setStatus('current')
if mibBuilder.loadTexts: fcRouteVerifyModule.setDescription("This value identifies a particular line card module according to that module's value of entPhysicalIndex in the entPhysicalTable of the ENTITY-MIB (RFC 2737). The forwarding information base present on this module is checked for consistency with the fcRouteTable. The value of this object is relevant only if fcRouteVerifyType is either fibShadow(2) or fibHardware(3). ")
fcRouteVerifyVsanID = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 284, 1, 1, 6), VsanIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 4093))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcRouteVerifyVsanID.setStatus('current')
if mibBuilder.loadTexts: fcRouteVerifyVsanID.setDescription('The value specifies the VSAN id. The fcRouteTable entries and the entries in the table specified by fcRouteVerifyType is checked for consistency for the same VSAN id specified by this object. ')
fcRouteVerifyRouteType = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 284, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unicast", 1), ("multicast", 2), ("label", 3))).clone('unicast')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcRouteVerifyRouteType.setStatus('current')
if mibBuilder.loadTexts: fcRouteVerifyRouteType.setDescription('The value used by fcRouteVerifyAction to perform the consistency check of fcRouteTable. If the value is unicast(1) then only unicast entries in fcRouteTable and the entries in the table specified by fcRouteVerifyType are checked. If value is multicast(2) then only multicast entries in fcRouteTable and the entries in the table specified by fcRouteVerifyType are checked. If value is label(3) then only label entries in fcRouteTable and the entries in the table specified by fcRouteVerifyType are checked. ')
fcRouteVerifyResult = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 284, 1, 1, 8), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcRouteVerifyResult.setStatus('current')
if mibBuilder.loadTexts: fcRouteVerifyResult.setDescription('The object displays the details of the first inconsistency that occured from the check. If the check passes successfully then this will be a zero-length string. ')
fcRouteVerifyLock = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 284, 1, 1, 9), TestAndIncr()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcRouteVerifyLock.setStatus('current')
if mibBuilder.loadTexts: fcRouteVerifyLock.setDescription("This object is used to facilitate the verify action performed using 'fcRouteVerifyAction' by multiple managers. The procedure to perform the action by the NMS is as follows: 1. Retrieve the value of fcRouteVerifyLock. 2. Set the value of fcRouteVerifyLock to the retrieved value, and in the same PDU provide the following values: fcRouteVerifyAction to 'verify(2)' fcRouteVerifyType,fcRouteVerifyVsanID, fcRouteVerifyRouteType and fcRouteVerifyModule. Note, fcRouteVerifyModule is relevent only if fcRouteVerifyType is either 'fibShadow(2)' or fibHardware(3). 3. If the set fails repeat steps 1-2. 4. Retrieve the value of fcRouteVerifyLock and fcRouteVerifyResult in the same pdu. 5. If 'fcRouteVerifyLock' value is not one greater than the retrieved value of 'fcRouteVerifyLock' in step-1 than repeat steps 1-4. ")
fcRouteTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 284, 1, 1, 10), )
if mibBuilder.loadTexts: fcRouteTable.setStatus('current')
if mibBuilder.loadTexts: fcRouteTable.setDescription("The local system's Fibre Channel Routing table. This table lists all the routes that is configured/ calculated at the local system. Traffic through the TL-Port (translation port) uses the R-CTL field in the FC protocol header. During forwarding, this R-CTL field is part of the the value looked-up in the route table for matching. The value of the object fcRoutePreference is used to select one route over other when more than one route to the same destination is learned from different protocols, peers, or static routes from end-users. Only the entries configured by the user, which are fcRouteProto of type netmgmt(3), can be deleted by the user. ")
fcRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 284, 1, 1, 10, 1), ).setIndexNames((0, "CISCO-VSAN-MIB", "vsanIndex"), (0, "CISCO-FC-ROUTE-MIB", "fcRouteDestAddrId"), (0, "CISCO-FC-ROUTE-MIB", "fcRouteDestMask"), (0, "CISCO-FC-ROUTE-MIB", "fcRouteProto"), (0, "CISCO-FC-ROUTE-MIB", "fcRouteInterface"))
if mibBuilder.loadTexts: fcRouteEntry.setStatus('current')
if mibBuilder.loadTexts: fcRouteEntry.setDescription('Each entry contains a route to a particular destination in a particular VSAN via a particular output interface, and learned in a particular manner. ')
fcRouteDestAddrId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 284, 1, 1, 10, 1, 1), FcAddressId())
if mibBuilder.loadTexts: fcRouteDestAddrId.setStatus('current')
if mibBuilder.loadTexts: fcRouteDestAddrId.setDescription('The destination FC-ID of this route. ')
fcRouteDestMask = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 284, 1, 1, 10, 1, 2), FcAddressId())
if mibBuilder.loadTexts: fcRouteDestMask.setStatus('current')
if mibBuilder.loadTexts: fcRouteDestMask.setDescription('Indicate the mask to be logical-ANDed with the destination address Id before being compared to the value in the fcRouteDestAddrId field. This can only be 255.255.255 or 255.255.0 or 255.0.0 . ')
fcRouteProto = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 284, 1, 1, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("local", 2), ("netmgmt", 3), ("fspf", 4), ("mpls", 5), ("multicast", 6))))
if mibBuilder.loadTexts: fcRouteProto.setStatus('current')
if mibBuilder.loadTexts: fcRouteProto.setDescription('The routing mechanism via which this route was learned. other(1) - not specified local(2) - local interface netmgmt(3)- static route The following are all dynamic routing protocols fspf(4) - Fibre Shortest Path First mpls(5) - Multiple Protocol Label Switching. multicast(6) - multicast routes.')
fcRouteInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 284, 1, 1, 10, 1, 4), InterfaceIndex())
if mibBuilder.loadTexts: fcRouteInterface.setStatus('current')
if mibBuilder.loadTexts: fcRouteInterface.setDescription('The ifIndex value, which identifies the local interface through which the next hop of this route should be reached. If the interface type is TL-Port then R-CTL field in the FC protocol header is also used for look-up in the route table during forwarding. Only interfaces of type Fibre Channel and Port Channel are allowed. ')
fcRouteDomainId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 284, 1, 1, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 239))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: fcRouteDomainId.setStatus('current')
if mibBuilder.loadTexts: fcRouteDomainId.setDescription("The domain ID of next hop switch. However this object, when read, could have a value zero if value of fcRouteProto is 'local'.")
fcRouteMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 284, 1, 1, 10, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: fcRouteMetric.setStatus('current')
if mibBuilder.loadTexts: fcRouteMetric.setDescription('The routing metric for this route. The use of this object is dependent on fcRouteProto used. ')
fcRouteType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 284, 1, 1, 10, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("local", 1), ("remote", 2))).clone('local')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: fcRouteType.setStatus('current')
if mibBuilder.loadTexts: fcRouteType.setDescription('The type of route. local(1): refers to a route for which the next hop is the final destination; remote(2): refers to a route for which the next hop is not the final destination. This object is not relevent for multicast and broadcast route entries. ')
fcRoutePermanent = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 284, 1, 1, 10, 1, 8), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: fcRoutePermanent.setStatus('current')
if mibBuilder.loadTexts: fcRoutePermanent.setDescription("The value if true(1), indicates the route is not to be removed from the relevant Forwarding information base even if the port is operationally 'down'. If false(2), the route is removed from the relevant Forwarding information base (FIB) if the port is operationally 'down'. This object is not relevent for multicast and broadcast route entries. ")
fcRouteRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 284, 1, 1, 10, 1, 9), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: fcRouteRowStatus.setStatus('current')
if mibBuilder.loadTexts: fcRouteRowStatus.setDescription('The status of this conceptual row. ')
fcRouteFlowStatTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 284, 1, 2, 1), )
if mibBuilder.loadTexts: fcRouteFlowStatTable.setStatus('current')
if mibBuilder.loadTexts: fcRouteFlowStatTable.setDescription('The table to configure and show the ingress traffic counters on physical components (e.g., Linecards). The user has the option of configuring counters depending on the bits selected for the object fcRouteFlowType. If the user selects only vsanId(0) bit for all the entries, then no more than 1024 entries can be created. If the user selects all the 4 bits, vsanId(0), destId(1), srcId(2), port(3), for some entries, then additional entries can be created, up to a maximum of 2048 entries. For statistics collection R-CTL is not part of the the value looked-up in the route table, so the counters are updated immaterial of R-CTL field. ')
fcRouteFlowStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 284, 1, 2, 1, 1), ).setIndexNames((0, "ENTITY-MIB", "entPhysicalIndex"), (0, "CISCO-FC-ROUTE-MIB", "fcRouteFlowIndex"))
if mibBuilder.loadTexts: fcRouteFlowStatEntry.setStatus('current')
if mibBuilder.loadTexts: fcRouteFlowStatEntry.setDescription('Each entry provides information on the ingress traffic counters at the physical component indicated by entPhysicalIndex. Entries can only be created for physical components, e.g.,line cards, which support this type of ingress traffic counters. ')
fcRouteFlowIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 284, 1, 2, 1, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: fcRouteFlowIndex.setStatus('current')
if mibBuilder.loadTexts: fcRouteFlowIndex.setDescription('The index of this entry.')
fcRouteFlowType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 284, 1, 2, 1, 1, 2), Bits().clone(namedValues=NamedValues(("vsanId", 0), ("destId", 1), ("srcId", 2), ("port", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: fcRouteFlowType.setStatus('current')
if mibBuilder.loadTexts: fcRouteFlowType.setDescription("The matching criteria by which flows are selected to be included in the traffic which is instrumented by the ingress traffic counters. For each bit which is set, the corresponding object must be configured by the network manager when creating an entry. vsanId(0) represents object fcRouteFlowVsanId, destId(1) represents fcRouteFlowDestId, srcId(2) represents fcRouteFlowSrcId, port(3) represents fcRouteFlowPort.It is optional to provide fcRouteFlowMask. If fcRouteFlowMask is not provided then the default value 255.255.255 is used. This object cannot be modified while the corresponding value of fcRouteFlowRowStatus is equal to 'active'. ")
fcRouteFlowVsanId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 284, 1, 2, 1, 1, 3), VsanIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 4093))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: fcRouteFlowVsanId.setStatus('current')
if mibBuilder.loadTexts: fcRouteFlowVsanId.setDescription("The id of VSAN. This object cannot be modified while the corresponding value of fcRouteFlowRowStatus is equal to 'active'. ")
fcRouteFlowDestId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 284, 1, 2, 1, 1, 4), FcAddressId()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: fcRouteFlowDestId.setStatus('current')
if mibBuilder.loadTexts: fcRouteFlowDestId.setDescription("The destination fibre channel address id. This object cannot be modified while the corresponding value of fcRouteFlowRowStatus is equal to 'active'. ")
fcRouteFlowSrcId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 284, 1, 2, 1, 1, 5), FcAddressId()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: fcRouteFlowSrcId.setStatus('current')
if mibBuilder.loadTexts: fcRouteFlowSrcId.setDescription("The source fibre channel address id. This object cannot be modified while the corresponding value of fcRouteFlowRowStatus is equal to 'active'. ")
fcRouteFlowMask = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 284, 1, 2, 1, 1, 6), FcAddressId()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: fcRouteFlowMask.setStatus('current')
if mibBuilder.loadTexts: fcRouteFlowMask.setDescription("The mask for source and destination fibre channel address id. This object cannot be modified while the corresponding value of fcRouteFlowRowStatus is equal to 'active'.")
fcRouteFlowPort = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 284, 1, 2, 1, 1, 7), InterfaceIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: fcRouteFlowPort.setStatus('current')
if mibBuilder.loadTexts: fcRouteFlowPort.setDescription("The physical ingress port to which this counter applies. This object cannot be modified while the corresponding value of fcRouteFlowRowStatus is equal to 'active'. ")
fcRouteFlowFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 284, 1, 2, 1, 1, 8), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcRouteFlowFrames.setStatus('current')
if mibBuilder.loadTexts: fcRouteFlowFrames.setDescription('The number of received frames for the flow created by the network manager. ')
fcRouteFlowBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 284, 1, 2, 1, 1, 9), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcRouteFlowBytes.setStatus('current')
if mibBuilder.loadTexts: fcRouteFlowBytes.setDescription('The number of received frame bytes for the flow created by the network manager. ')
fcRouteFlowCreationTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 284, 1, 2, 1, 1, 11), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcRouteFlowCreationTime.setStatus('current')
if mibBuilder.loadTexts: fcRouteFlowCreationTime.setDescription('The timestamp indicating the time the row was created or modified. ')
fcRouteFlowRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 284, 1, 2, 1, 1, 12), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: fcRouteFlowRowStatus.setStatus('current')
if mibBuilder.loadTexts: fcRouteFlowRowStatus.setDescription('The status of this conceptual row. ')
fcRouteMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 284, 2, 1))
fcRouteMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 284, 2, 2))
fcRouteMIBCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 284, 2, 1, 1)).setObjects(("CISCO-FC-ROUTE-MIB", "fcRouteGroup"), ("CISCO-FC-ROUTE-MIB", "fcRouteTableGroup"), ("CISCO-FC-ROUTE-MIB", "fcRouteStatGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    fcRouteMIBCompliance = fcRouteMIBCompliance.setStatus('deprecated')
if mibBuilder.loadTexts: fcRouteMIBCompliance.setDescription('The compliance statement for entities which implement the fc Route mib.')
fcRouteMIBCompliance1 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 284, 2, 1, 2)).setObjects(("CISCO-FC-ROUTE-MIB", "fcRouteGroup"), ("CISCO-FC-ROUTE-MIB", "fcRouteTableGroup"), ("CISCO-FC-ROUTE-MIB", "fcRouteStatGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    fcRouteMIBCompliance1 = fcRouteMIBCompliance1.setStatus('current')
if mibBuilder.loadTexts: fcRouteMIBCompliance1.setDescription('The compliance statement for entities which implement the fc Route mib.')
fcRouteGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 284, 2, 2, 1)).setObjects(("CISCO-FC-ROUTE-MIB", "fcRouteLastChangeTime"), ("CISCO-FC-ROUTE-MIB", "fcRoutePreference"), ("CISCO-FC-ROUTE-MIB", "fcRouteVerifyAction"), ("CISCO-FC-ROUTE-MIB", "fcRouteVerifyType"), ("CISCO-FC-ROUTE-MIB", "fcRouteVerifyModule"), ("CISCO-FC-ROUTE-MIB", "fcRouteVerifyVsanID"), ("CISCO-FC-ROUTE-MIB", "fcRouteVerifyRouteType"), ("CISCO-FC-ROUTE-MIB", "fcRouteVerifyResult"), ("CISCO-FC-ROUTE-MIB", "fcRouteVerifyLock"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    fcRouteGroup = fcRouteGroup.setStatus('current')
if mibBuilder.loadTexts: fcRouteGroup.setDescription('A collection of objects giving route information.')
fcRouteTableGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 284, 2, 2, 2)).setObjects(("CISCO-FC-ROUTE-MIB", "fcRouteDomainId"), ("CISCO-FC-ROUTE-MIB", "fcRouteMetric"), ("CISCO-FC-ROUTE-MIB", "fcRouteType"), ("CISCO-FC-ROUTE-MIB", "fcRoutePermanent"), ("CISCO-FC-ROUTE-MIB", "fcRouteRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    fcRouteTableGroup = fcRouteTableGroup.setStatus('current')
if mibBuilder.loadTexts: fcRouteTableGroup.setDescription("A collection of objects for displaying and configuring route's.")
fcRouteStatGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 284, 2, 2, 3)).setObjects(("CISCO-FC-ROUTE-MIB", "fcRouteFlowType"), ("CISCO-FC-ROUTE-MIB", "fcRouteFlowVsanId"), ("CISCO-FC-ROUTE-MIB", "fcRouteFlowDestId"), ("CISCO-FC-ROUTE-MIB", "fcRouteFlowSrcId"), ("CISCO-FC-ROUTE-MIB", "fcRouteFlowMask"), ("CISCO-FC-ROUTE-MIB", "fcRouteFlowPort"), ("CISCO-FC-ROUTE-MIB", "fcRouteFlowFrames"), ("CISCO-FC-ROUTE-MIB", "fcRouteFlowBytes"), ("CISCO-FC-ROUTE-MIB", "fcRouteFlowCreationTime"), ("CISCO-FC-ROUTE-MIB", "fcRouteFlowRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    fcRouteStatGroup = fcRouteStatGroup.setStatus('current')
if mibBuilder.loadTexts: fcRouteStatGroup.setDescription('A collection of objects for displaying and configuring ingress traffic flow counters.')
mibBuilder.exportSymbols("CISCO-FC-ROUTE-MIB", fcRouteFlowDestId=fcRouteFlowDestId, fcRouteFlowBytes=fcRouteFlowBytes, fcRouteFlowPort=fcRouteFlowPort, fcRouteVerifyType=fcRouteVerifyType, fcRouteVerifyAction=fcRouteVerifyAction, fcRouteVerifyModule=fcRouteVerifyModule, fcRouteStatGroup=fcRouteStatGroup, fcRouteLastChangeTime=fcRouteLastChangeTime, fcRouteDestMask=fcRouteDestMask, fcRouteFlowType=fcRouteFlowType, fcRouteDestAddrId=fcRouteDestAddrId, fcRouteFlowIndex=fcRouteFlowIndex, fcRouteType=fcRouteType, fcRouteFlowStatTable=fcRouteFlowStatTable, fcRouteRowStatus=fcRouteRowStatus, fcRouteMIBConformance=fcRouteMIBConformance, fcRouteFlowFrames=fcRouteFlowFrames, fcRouteVerifyRouteType=fcRouteVerifyRouteType, fcRouteDomainId=fcRouteDomainId, fcRoutePermanent=fcRoutePermanent, fcRouteVerifyResult=fcRouteVerifyResult, fcRouteEntry=fcRouteEntry, fcRouteNotification=fcRouteNotification, fcRouteTableGroup=fcRouteTableGroup, ciscoFcRouteMIBObjects=ciscoFcRouteMIBObjects, fcRouteMIBGroups=fcRouteMIBGroups, fcRouteTable=fcRouteTable, fcRouteFlowMask=fcRouteFlowMask, fcRoutePreference=fcRoutePreference, fcRouteFlowSrcId=fcRouteFlowSrcId, fcRouteProto=fcRouteProto, fcRouteGroup=fcRouteGroup, fcRouteNotifications=fcRouteNotifications, fcRouteVerifyVsanID=fcRouteVerifyVsanID, fcRouteMIBCompliances=fcRouteMIBCompliances, fcRouteVerifyLock=fcRouteVerifyLock, fcRouteFlowStatEntry=fcRouteFlowStatEntry, fcRouteFlowCreationTime=fcRouteFlowCreationTime, PYSNMP_MODULE_ID=ciscoFcRouteMIB, fcRouteConfig=fcRouteConfig, fcRouteMIBCompliance=fcRouteMIBCompliance, fcRouteFlowVsanId=fcRouteFlowVsanId, fcRouteInterface=fcRouteInterface, ciscoFcRouteMIB=ciscoFcRouteMIB, fcRouteMetric=fcRouteMetric, fcRouteFlowRowStatus=fcRouteFlowRowStatus, fcRouteStatistics=fcRouteStatistics, fcRouteMIBCompliance1=fcRouteMIBCompliance1)

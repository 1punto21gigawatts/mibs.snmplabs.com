#
# PySNMP MIB module Wellfleet-SYNC-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Wellfleet-SYNC-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:41:48 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, SingleValueConstraint, ConstraintsIntersection, ValueRangeConstraint, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "SingleValueConstraint", "ConstraintsIntersection", "ValueRangeConstraint", "ValueSizeConstraint")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
ModuleIdentity, iso, Unsigned32, MibIdentifier, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, Integer32, Counter32, Bits, ObjectIdentity, TimeTicks, IpAddress, Counter64, Gauge32 = mibBuilder.importSymbols("SNMPv2-SMI", "ModuleIdentity", "iso", "Unsigned32", "MibIdentifier", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Integer32", "Counter32", "Bits", "ObjectIdentity", "TimeTicks", "IpAddress", "Counter64", "Gauge32")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
wfLine, = mibBuilder.importSymbols("Wellfleet-COMMON-MIB", "wfLine")
wfSyncTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 5), )
if mibBuilder.loadTexts: wfSyncTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncTable.setDescription('SYNC line record')
wfSyncEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1), ).setIndexNames((0, "Wellfleet-SYNC-MIB", "wfSyncSlot"), (0, "Wellfleet-SYNC-MIB", "wfSyncConnector"))
if mibBuilder.loadTexts: wfSyncEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncEntry.setDescription('An entry in the SYNC table')
wfSyncDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncDelete.setDescription('Create/Delete parameter')
wfSyncDisable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncDisable.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncDisable.setDescription('Enable/Disable parameter')
wfSyncState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 19, 20))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("init", 3), ("wait", 4), ("notpresent", 5), ("dsrwait", 6), ("holddown", 7), ("remoteloop", 8), ("lineloopbofltest", 19), ("notpres", 20))).clone('notpres')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncState.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncState.setDescription('Line Driver state variable, Reflects the current state of the Line Driver. NOTPRESENT is an obsoleted state. It is replaced with NOTPRES.')
wfSyncSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncSlot.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncSlot.setDescription('Instance ID Slot, filled in by driver')
wfSyncConnector = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncConnector.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncConnector.setDescription("Instance ID Connector, filled in by driver. For the ASN this attribute is an encoded value and is equal to 'module'*10 + 'connector'. Where 'module' is defined in attribute 86 and 'connector' is defined in attribute 78 of this table. For non-ASN platforms this attribute is the physical connector number on the slot.")
wfSyncCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1023))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncCct.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncCct.setDescription('CCT number for this line instance')
wfSyncBofl = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncBofl.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncBofl.setDescription('breath of life parameter')
wfSyncBoflTmo = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncBoflTmo.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncBoflTmo.setDescription('breath of life timeout in seconds')
wfSyncMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(3, 4608)).clone(1600)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncMtu.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncMtu.setDescription('MTU parameter, this is buffer size for SYNC media, fixed')
wfSyncMadr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 10), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncMadr.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncMadr.setDescription('Line MAC address, fixed - line driver fills in from the 48 bit address stored in the serial number prom for this connector.')
wfSyncPromiscuous = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncPromiscuous.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncPromiscuous.setDescription('The promiscuous parameter allows address filtering based on the local and remote addresses. When enabled, all frames are received, disabled indicates only frames destined for this local address are received')
wfSyncXid = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncXid.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncXid.setDescription('XID enable/disable parameter. This parameter is used to enable or disable transmission/reception of Test XID frames.')
wfSyncClkSource = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("internal", 1), ("external", 2))).clone('external')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncClkSource.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncClkSource.setDescription('Tx/Rx clock source is either internally or external generated.')
wfSyncClkSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1200, 2401, 4807, 7204, 9615, 19230, 32051, 38461, 56818, 64102, 125000, 227272, 416666, 625000, 833333, 1250000, 2500000, 5000000))).clone(namedValues=NamedValues(("clk1200b", 1200), ("clk2400b", 2401), ("clk4800b", 4807), ("clk7200b", 7204), ("clk9600b", 9615), ("clk19200b", 19230), ("clk32000b", 32051), ("clk38400b", 38461), ("clk56k", 56818), ("clk64k", 64102), ("clk125k", 125000), ("clk230k", 227272), ("clk420k", 416666), ("clk625k", 625000), ("clk833k", 833333), ("clk1mb", 1250000), ("clk2mb", 2500000), ("clk5mb", 5000000))).clone('clk64k')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncClkSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncClkSpeed.setDescription('Internal Tx/Rx clock speed. This speed selection is valid only when internal clocking is selected.')
wfSyncSignalMode = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("balanced", 1), ("unbalanced", 2))).clone('balanced')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncSignalMode.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncSignalMode.setDescription('The signal mode parameter indicates the line paramter balanced or unbalanced.')
wfSyncRtsEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("kg84aenabled", 3))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncRtsEnable.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncRtsEnable.setDescription('Note: In KG84 support, RTS has a different meaning')
wfSyncBurstCount = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("unlimited", 3))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncBurstCount.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncBurstCount.setDescription('Allows control over the DMA burst cycle duration on MK5025 based products. This attribute is ignored for AN and ASN products. The default is always 8 short word bursts (ENABLED). There are only two cases in which this attribute should be changed. Case 1: In certain cases with DSDE and DSE link modules when one or both of the ethernet ports are suffering from excessive TxUflo or RxOflo errors, the BurstCount of one or both SYNC interfaces can be set to single short word bursts (DISABLED). The only modules for which this may be necessary are the DSDE (5430 - Dual Sync, Dual Enet) (module ID 112) and the DSE (5420 - Dual Sync, Single Enet) (module ID 116). If after making the change, the TxUflo or RxOflo errors persist on the ethernet or this SYNC interface starts to get UnderFlowTx or OverFlowRx errors, then the Link Module is overloaded and a more significant software configuration change or a hardware configuration change is needed. Case 2: When a SYNC interface on an mk5025 based Link Module is getting UnderFlowTx or OverFlowRx errors while running at bandwidths greater than 2Mbps, the errors may be eliminated by setting this attribute to unlimited burst mode (UNLIMITED). If after making the change, the errors persist or the same errors start on another SYNC interface or one of the ethernet interfaces on the same module starts to get TxUflo or RxOflo errors, then the Link Module is overloaded and a more significant software configuration change or a hardware configuration change is needed. For 6Mbps full duplex operation, this attribute will most likely need to be set to UNLIMITED and all other interfaces on this module will most likely have to be deconfigured.')
wfSyncService = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("transparent", 1), ("llc1", 2), ("llc2", 3))).clone('llc1')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncService.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncService.setDescription('Service type for this circuit. Transparent is raw HDLC mode, LLC1 will prefix the HDLC address and control fields to the frame. The LLC2 service provides the LAPB protocol service.')
wfSyncRetryCount = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64)).clone(16)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncRetryCount.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncRetryCount.setDescription('The Retry count parameter indicates the number of retransmission attempts which will be tried per frame before a line is determined to be down. The retry count is max attempts following expiration of the T1 timer. This parameter is equal to the N2 counter in ICB.')
wfSyncLinkIdleTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 9999)).clone(9)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncLinkIdleTimer.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncLinkIdleTimer.setDescription('The link idle parameter is the number of seconds before a line has been determined to be idle. An idle line is considered disconnectd This value is expressed in seconds.')
wfSyncRetryTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 9999)).clone(30)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncRetryTimer.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncRetryTimer.setDescription('The Retry Timer parameter indicates the timeout in tenths of seconds for a response to be heard form the link. Link control frames are sent at the expiration of this timer value. The frames will be resent up to retry count (N2) at which time the link will be disconnected.')
wfSyncExtendedAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncExtendedAddress.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncExtendedAddress.setDescription('This parameter controls length determination of the address field. When this parameter is enabled, the first bit of the address field be tested to determine the length of address field in octets.')
wfSyncExtendedAddressForce = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncExtendedAddressForce.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncExtendedAddressForce.setDescription('When this parameter is enabled, the receiver will assume that all address fields are 2 octets in length regardless of the first two bits of the control field. Usefull only in Transparent Mode.')
wfSyncExtendedControl = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncExtendedControl.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncExtendedControl.setDescription('This parameter allows the control fields of all S and I frames to become 2 octets in length instead of one. Numbering of all I frame become modulo 128 instead of modulo 8. The control field of U frames remains one octet in length.')
wfSyncExtendedControlForce = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncExtendedControlForce.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncExtendedControlForce.setDescription('This parameter when enabled will force all control fields to become two octets in length regardless the first two bits in the control field. Usefull only in Transparent Mode. (LLC1)')
wfSyncConnectAttempts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 9999)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncConnectAttempts.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncConnectAttempts.setDescription('This parameter controls the number of connection attempts which will be made during a LAPB connection request. This parameter is applicable only during LLC2 service.')
wfSyncWindowSizeTx = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 27), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 7)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncWindowSizeTx.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncWindowSizeTx.setDescription('The window size parameter controls the number of I frames which may be transmitted without acknowledgement. Non EXTC mode.')
wfSyncWindowSizeTxExtc = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 28), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 7)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncWindowSizeTxExtc.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncWindowSizeTxExtc.setDescription('The window size parameter controls the number of I frames which may be transmitted without acknowledgement in EXTC mode.')
wfSyncMinFrameSpace = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 29), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncMinFrameSpace.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncMinFrameSpace.setDescription('The minimum frame spacing parameter defines the number of flags that are transmitted between adjacent frames.')
wfSyncLocalAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 1, 7))).clone(namedValues=NamedValues(("addressdte", 3), ("addressdce", 1), ("addressexplicit", 7))).clone('addressexplicit')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncLocalAddress.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncLocalAddress.setDescription('The local address parameter contains the DTE,DCE or EXPLICIT value expressed as a single octet. It may be extended to 2 octets if EXTA has been set.')
wfSyncRemoteAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 1, 7))).clone(namedValues=NamedValues(("addressdte", 3), ("addressdce", 1), ("addressexplicit", 7))).clone('addressexplicit')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncRemoteAddress.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncRemoteAddress.setDescription('The remote address parameter contains the DTE,DCE or EXPLICIT value expressed as a single octet. It may be extended to 2 octets if EXTA has been set.')
wfSyncPassThruLocalMadr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 32), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncPassThruLocalMadr.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncPassThruLocalMadr.setDescription('48 bit MAC address of Local end of Sync Passthru circuit')
wfSyncPassThruRemoteMadr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 33), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncPassThruRemoteMadr.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncPassThruRemoteMadr.setDescription('48 bit MAC address of Remote end of Sync Passthru circuit')
wfSyncWanProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("standard", 1), ("passthru", 2), ("ppp", 3), ("smds", 4), ("framerelay", 5), ("x25", 6), ("switch", 7), ("sw", 8), ("atm", 9), ("lapb", 10), ("sdlc", 11), ("aot", 12))).clone('standard')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncWanProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncWanProtocol.setDescription('WAN protocol selection is provided via this parameter. The supported protocols can be selected per interface.')
wfSyncCrcSize = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("crc16bit", 1), ("crc32bit", 2))).clone('crc16bit')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncCrcSize.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncCrcSize.setDescription('CRC size parameter, 16 bit standard CCITT or extended 32 bit CRC')
wfSyncRxOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 36), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncRxOctets.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncRxOctets.setDescription('Number of octets received without error')
wfSyncRxFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 37), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncRxFrames.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncRxFrames.setDescription('Number of frames received without error')
wfSyncTxOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 38), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncTxOctets.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncTxOctets.setDescription('Number of octets transmitted without error')
wfSyncTxFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 39), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncTxFrames.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncTxFrames.setDescription('Number of frames transmitted without error')
wfSyncRxErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 40), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncRxErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncRxErrors.setDescription('Number of receive errors')
wfSyncTxErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 41), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncTxErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncTxErrors.setDescription('Number of transmission errors')
wfSyncLackRescRx = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 42), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncLackRescRx.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncLackRescRx.setDescription('Number of Rx frames dropped due to lack of buffer resources')
wfSyncLackRescTx = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 43), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncLackRescTx.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncLackRescTx.setDescription("Number of frames clipped in driver's transmit routine due to transmit congestion.")
wfSyncUnderFlowTx = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 44), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncUnderFlowTx.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncUnderFlowTx.setDescription('Number of transmission underflows, device FIFO went empty before next DMA request was granted.')
wfSyncRejectsTx = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 45), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncRejectsTx.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncRejectsTx.setDescription('For the mk50 driver: Number of reject frames which were transmitted For the quicsync driver: Not used For the quicsync driver in Async mode: Number of frames that grew, due to escaping, larger than a buffer')
wfSyncRejectsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 46), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncRejectsRx.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncRejectsRx.setDescription('For the mk50 driver: Number of reject frames which were received For the quicsync driver: Number of HDLC frames received with a non-matching address For the quicsync driver in Async mode: Number of frames received that did not fit within a buffer')
wfSyncOverFlowRx = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 47), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncOverFlowRx.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncOverFlowRx.setDescription('Number of receive overflows, device FIFO overflowed before next DMA cycle granted. No buffer resources available.')
wfSyncFramesIncompRx = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 48), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncFramesIncompRx.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncFramesIncompRx.setDescription('Number of frames which were incompletely received. These are frames which may have resulted from FRMRR errors.')
wfSyncBadFramesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 49), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncBadFramesRx.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncBadFramesRx.setDescription('Number of bad receive frames, caused by FCS errors or non octet aligned.')
wfSyncFrameRejectsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 50), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncFrameRejectsRx.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncFrameRejectsRx.setDescription('Number of Frame Rejects received')
wfSyncRuntsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 51), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncRuntsRx.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncRuntsRx.setDescription('Number of runt frames received or number of frames where the Carrier Detect signal was lost during reception.')
wfSyncT1Timeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 52), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncT1Timeouts.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncT1Timeouts.setDescription("Number of T1 timeout's detected. The T1 timer is the link retransmission timer. Link control frames will be retransmitted when T1 expires. This is a count of the number of timeouts.")
wfSyncMemoryErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 53), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncMemoryErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncMemoryErrors.setDescription('Number of memory access errors detected. A MERR is the expiration of a DMA cycle without the bus being granted within 26us.')
wfSyncMediaType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 54), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("default", 1), ("t1", 2), ("e1", 3), ("raisedtr", 4), ("v25bis", 5), ("bri", 6), ("isdnleased", 7), ("hayes", 8))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncMediaType.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncMediaType.setDescription('Media type selection is provided via this parameter')
wfSyncCfgTxQueueLength = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 55), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncCfgTxQueueLength.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncCfgTxQueueLength.setDescription('Configured Transmit Queue Length. Values other than zero over-ride the router selected values. A value of zero has a special meaning. Zero causes router based default values to be used. Values larger than the compiled ring size are truncated to the compiled ring size. ')
wfSyncCfgRxQueueLength = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 56), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncCfgRxQueueLength.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncCfgRxQueueLength.setDescription('Configured Receive Queue Length. Values other than zero over-ride the router selected values. A value of zero has a special meaning. Zero causes router based default values to be used. Values larger than the compiled ring size are truncated to the compiled ring size. ')
wfSyncTxQueueLength = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 57), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncTxQueueLength.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncTxQueueLength.setDescription('Current Transmit Queue Length.')
wfSyncRxQueueLength = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 58), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncRxQueueLength.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncRxQueueLength.setDescription('Current Receive Queue Length.')
wfSyncRxReplenMisses = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 59), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncRxReplenMisses.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncRxReplenMisses.setDescription('Number of packet buffer misses while attempting to replenish driver receive ring.')
wfSyncStartUpMode = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 60), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("passive", 2))).clone('active')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncStartUpMode.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncStartUpMode.setDescription('Initiation of link level for LLC2 running LAPB')
wfSyncIdleRRFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 61), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncIdleRRFrames.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncIdleRRFrames.setDescription("Transmit Link level RR's (Reciever Readys) during idle time. Every wfSyncLinkIdleTimer expiration an RR will be sent.")
wfSyncMultilineMode = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 62), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("standard", 1), ("monitor", 2), ("primary", 3), ("secondary", 4))).clone('standard')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncMultilineMode.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncMultilineMode.setDescription('This indicates the roll the sync line plays in a Bandwidth on Demand multiline circuit. If this is not BOD, the mode is standard.')
wfSyncBODExamPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 63), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 200)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncBODExamPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncBODExamPeriod.setDescription('This indicates the interval that the line should be polled for possible congestion. This value is in tenths of a second')
wfSyncBODFullThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 64), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 100)).clone(70)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncBODFullThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncBODFullThreshold.setDescription('This is the percentage of the theoretical maximum line throughput that must be reached or exceeded before the line is considered congested.')
wfSyncBODRecoverThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 65), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 100)).clone(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncBODRecoverThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncBODRecoverThreshold.setDescription('This is the recovery threshold expressed as a percentage of the theoretical maximum line throughput. The actual throughput must fall below this percentage in order for the BOD circuit to revert back to the primary line only. This value should be set to less than one half the value of wfSyncBODFullThreshold to avoid toggling the secondary.')
wfSyncBODPeriodsToFail = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 66), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncBODPeriodsToFail.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncBODPeriodsToFail.setDescription('This is the number of consecutive periods where the line throughput is above the congestion threshold required to declare the line congested.')
wfSyncKG84ACycle = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 67), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 10, 25, 50, 100, 200, 500))).clone(namedValues=NamedValues(("cycle5ms", 5), ("cycle10ms", 10), ("cycle25ms", 25), ("cycle50ms", 50), ("cycle100ms", 100), ("cycle200ms", 200), ("cycle500ms", 500))).clone('cycle100ms')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncKG84ACycle.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncKG84ACycle.setDescription('Monitor sample time in milliseconds')
wfSyncKG84ASyncLossInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 68), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 5, 10, 25, 50, 100, 200, 500))).clone(namedValues=NamedValues(("num2cycles", 2), ("num5cycles", 5), ("num10cycles", 10), ("num25cycles", 25), ("num50cycles", 50), ("num100cycles", 100), ("num200cycles", 200), ("num500cycles", 500))).clone('num50cycles')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncKG84ASyncLossInterval.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncKG84ASyncLossInterval.setDescription('timer starts when FCS error detected; if no good frame received during this time, declare loss of synchronization')
wfSyncKG84ARemoteResyncWait = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 69), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 5, 10, 25, 50, 100, 200, 500))).clone(namedValues=NamedValues(("num2cycles", 2), ("num5cycles", 5), ("num10cycles", 10), ("num25cycles", 25), ("num50cycles", 50), ("num100cycles", 100), ("num200cycles", 200), ("num500cycles", 500))).clone('num200cycles')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncKG84ARemoteResyncWait.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncKG84ARemoteResyncWait.setDescription('when loss of synchronization is detected, and CTS is low, start timer; if CTS is not high when timer expires, force sync request')
wfSyncKG84ASyncPulse = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 70), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 4096)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncKG84ASyncPulse.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncKG84ASyncPulse.setDescription('interval to pulse KG84a SYNC signal, in milliseconds')
wfSyncKG84AResyncs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 71), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncKG84AResyncs.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncKG84AResyncs.setDescription('number of KG84 resyncs performed')
wfSyncKG84AResyncsDetected = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 72), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncKG84AResyncsDetected.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncKG84AResyncsDetected.setDescription('number of KG84 resyncs detected')
wfSyncKG84ABsu = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 73), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncKG84ABsu.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncKG84ABsu.setDescription('value taken from mk5025 sync chip control block')
wfSyncKG84AState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 74), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("idle", 1), ("local", 2), ("remote", 3), ("sync", 4))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncKG84AState.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncKG84AState.setDescription('state of sync')
wfSyncKG84AOkFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 75), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncKG84AOkFrames.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncKG84AOkFrames.setDescription('count of valid frames received. This value taken from normal sync processing, updated by timer routine when FCE error detected')
wfSyncPollingEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 76), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncPollingEnable.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncPollingEnable.setDescription('Enable or Disable Sync Polling. When Sync Polling is enabled, the the Sync Driver will be disabled if the DSR lead is dropped. If disabled, the DSR lead is ignored.')
wfSyncBackupPool = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 77), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncBackupPool.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncBackupPool.setDescription('Backup pool id containing this line driver')
wfSyncDemandPool = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 78), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncDemandPool.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncDemandPool.setDescription('Dial on demand pool id containing this line driver')
wfSyncLineNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 79), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncLineNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncLineNumber.setDescription('line number for this line instance')
wfSyncHoldDownTime = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 80), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncHoldDownTime.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncHoldDownTime.setDescription('Wait this number of seconds before bringing the line up. This prevents line waffling if this is a reactivated primary line in a backup configuration and it is a dirty line')
wfSyncNetworkType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 81), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("gosip", 1), ("net2", 2), ("c03", 3))).clone('net2')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncNetworkType.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncNetworkType.setDescription('Specific Network Link Level to be executed, LAPB mode only. The types GOSIP and NET2 are used in conjunction with an MK5025 chip revision C04. If a customer must be NET2 compliant and is using an MK5025 chip revision C03, the C03 option must be used.')
wfSyncActiveCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 82), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1023))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncActiveCct.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncActiveCct.setDescription('Active CCT number for this line instance')
wfSyncCableType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 83), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncCableType.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncCableType.setDescription('Type of Cable attached to the sync port - this is needed for V.25bis and Raise DTR to properly communicate with the modem')
wfSyncRxDropPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 84), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncRxDropPackets.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncRxDropPackets.setDescription('Number of Rx packets dropped by driver.')
wfSyncTxDropPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 85), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncTxDropPackets.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncTxDropPackets.setDescription('Number of Tx packets dropped by driver.')
wfSyncModule = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 86), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("one", 1), ("two", 2), ("three", 3), ("four", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncModule.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncModule.setDescription('Module number for ASN platform, filled in by driver. For non-ASN platforms this attribute will not be used.')
wfSyncActualConnector = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 87), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("one", 1), ("two", 2), ("three", 3), ("four", 4), ("five", 5), ("six", 6), ("seven", 7), ("eight", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncActualConnector.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncActualConnector.setDescription('Actual connector number for ASN platform, filled in by driver. For non-ASN platforms, this attribute will not be used.')
wfSyncLineCoding = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 88), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("nrz", 1), ("nrzi", 2), ("nrzimark", 3))).clone('nrz')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncLineCoding.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncLineCoding.setDescription('Line Coding for sync interface. Can be either NRZ or NRZI.')
wfSyncLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 89), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncLastChange.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncLastChange.setDescription("The value of SysUpTime at the time the interface entered it's current operational state (UP state). SysUpTime is defined as the time (in hundredths of a second) since the network management portion of the system was last re-initialized. Usually the time since boot.")
wfSyncOutQLen = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 90), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncOutQLen.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncOutQLen.setDescription('The instantaneous current length of the output packet queue (in packets).')
wfSyncRemoteLpbkDetection = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 91), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncRemoteLpbkDetection.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncRemoteLpbkDetection.setDescription('This attribute enables Remote Loopback Detection. When enabled along with wfSyncBofl, the device driver will detect when it is receiving its own BOFL packets and will bring the interface down assuming that somewhere down stream the link has been put into loopback. ')
wfSyncLastState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 92), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 20))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("init", 3), ("wait", 4), ("notpresent", 5), ("dsrwait", 6), ("holddown", 7), ("remoteloop", 8), ("notpres", 20)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncLastState.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncLastState.setDescription('The state which the driver was in prior to the most recent re-initialization.')
wfSyncExternalClkSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 93), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1200, 6000000)).clone(64102)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncExternalClkSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncExternalClkSpeed.setDescription('External Clock Speed. If external clocking is configured, this attribute should be set to the clock speed of the externally supplied clock. Depending on the protocols configured on this interface, this value may control internal decision making within the router. In some cases, router software uses this attribute for route selection. If Priority Queuing is configured, it chooses queue depths based on this attribute. This attribute has no effect when Internal clocking is configured.')
wfSyncBChannelOverride = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 94), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("bchannel1", 1), ("bchannel2", 2), ("default", 3), ("floatingb", 4))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncBChannelOverride.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncBChannelOverride.setDescription("For ISDN, indicates which B Channel we're using. By default, we'd like the B Channel tied to the connector defined in the instance id, but the user may override that here, which gives the ability of connecting the B Channel to specific SCC's.")
wfSyncBChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 95), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("bchannel1", 1), ("bchannel2", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncBChannel.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncBChannel.setDescription('Indicates which B Channel is running')
wfSyncForceIFTF = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 96), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("default", 1), ("forcehdlcflags", 2), ("forceidles", 3), ("flagstreaming", 4))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncForceIFTF.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncForceIFTF.setDescription('Specifies the Inter Frame Time Fill (IFTF) pattern which gets transmitted when no data is being transmitted on a particular channel. For SDLC Lines, DEFAULT and FORCE_HDLC_FLAGS both result in HDLC Flags (0x7E) as the fill character. FLAGSTREAMING will cause the fill character to alternate between Flags (0x7E) and Idles (0xFF), depending upon the current state of the line. For ISDN BRI Lines, DEFAULT, FORCE IDLES and FLAGSTREAMING all result in Idles (0xFF) as the fill character. For all other line types, DEFAULT, FORCE HDLC FLAGS and FLAGSTREAMING all result in HDLC Flags (0x7E) as the fill character. Leave this field at the default unless required for the attached device. The AS/400 high speed serial controller requires the use of FLAGSTREAMING for error-free operation.')
wfSyncPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 97), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 50)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncPriority.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncPriority.setDescription('Used by dial/switched services to assign priority of lines within the same demand or backup pool')
wfSyncTurboBofl = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 98), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncTurboBofl.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncTurboBofl.setDescription('DEBUG parameter - Turbo bofl enabled or disabled')
wfSyncBoflNum = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 99), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncBoflNum.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncBoflNum.setDescription('DEBUG parameter - Number of breath of life packets per breath of life')
wfSyncBoflLen = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 100), Integer32().subtype(subtypeSpec=ValueRangeConstraint(22, 4450)).clone(200)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncBoflLen.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncBoflLen.setDescription('DEBUG parameter - breath of life packet length')
wfSyncTurboBoflMisses = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 101), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncTurboBoflMisses.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncTurboBoflMisses.setDescription('DEBUG parameter - breath of life allocation failures')
wfSyncTurboBoflInvocations = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 102), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncTurboBoflInvocations.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncTurboBoflInvocations.setDescription('DEBUG parameter - breath of life invocations')
wfSyncBandwidthOnDemandPool = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 103), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncBandwidthOnDemandPool.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncBandwidthOnDemandPool.setDescription('Bandwidth pool id containing this line driver')
wfSyncBODRecoverPeriodsToPass = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 104), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncBODRecoverPeriodsToPass.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncBODRecoverPeriodsToPass.setDescription('This is the number of consecutive periods where the queue depth is below the congestion threshold required to declare the line congested. It is used for recovery. That is, once a line is declared as congested, this is the number of consecutive examination periods where the queue depth is below the recovery threshold value required to delare that the line is no longer congested.')
wfSyncBODHistory = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 105), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncBODHistory.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncBODHistory.setDescription('DEBUG parameter - This is the SBOD history buffer.')
wfSyncBODDebugFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 106), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncBODDebugFlag.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncBODDebugFlag.setDescription('DEBUG parameter - This is the SBOD Debug flag, used to control debug code for SBOD.')
wfSyncBChRateAdaption = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 107), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("adaption64k", 1), ("adaption128k", 2))).clone('adaption64k')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncBChRateAdaption.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncBChRateAdaption.setDescription("This attribute is only relevant when this Synchronous device driver is performing as an ISDN B channel over a BRI interface in leased line mode. This attribute specifies the piece of ISDN line's bandwidth which data from this driver will occupy. ")
wfSyncBChActualRateAdaption = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 108), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("adaption64k", 1), ("adaption128k", 2), ("adaption56kmsb", 3), ("adaption56klsb", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncBChActualRateAdaption.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncBChActualRateAdaption.setDescription('Indicates the current B Channel Rate Adaption in use. This attribute is only relevant when this Synchronous device driver is performing as an ISDN B channel over a BRI interface in leased line or dial-up mode. This attribute indicates the speed of this B-channel. It also specifies their bit positions for the case of 56K selections.')
wfSyncWanType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 109), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("synchronous", 1), ("asynchronous", 2), ("pasynchronous", 3))).clone('synchronous')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncWanType.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncWanType.setDescription('This attribute indicates whether this port should be configured as a SYNCHRONOUS or UART/ASYNCHRONOUS interface.')
wfSyncAsyncBaudRate = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 110), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1200, 2400, 4800, 7200, 9600, 12000, 14400, 19200, 28800, 38400, 57600, 64000, 76800, 96000, 115200))).clone(namedValues=NamedValues(("baudrate1200b", 1200), ("baudrate2400b", 2400), ("baudrate4800b", 4800), ("baudrate7200b", 7200), ("baudrate9600b", 9600), ("baudrate12000b", 12000), ("baudrate14400b", 14400), ("baudrate19200b", 19200), ("baudrate28800b", 28800), ("baudrate38k", 38400), ("baudrate56k", 57600), ("baudrate64k", 64000), ("baudrate76k", 76800), ("baudrate96k", 96000), ("baudrate115k", 115200))).clone('baudrate9600b')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncAsyncBaudRate.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncAsyncBaudRate.setDescription('Indicates the baud rate of the Tx/Rx character stream. This value should always be >= than speed at which the modems connect, but is independent of that speed. For instance, for V34 modems, the maximum modular connection speed is 28800 kbps. If your modems can do V.42 bis or MNP 5 data compression, with high (4 to 1) compression ratios you could fill a 115Kbps pipe.')
wfSyncCfgAsyncCmndMaxIdles = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 111), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 500))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncCfgAsyncCmndMaxIdles.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncCfgAsyncCmndMaxIdles.setDescription("Maximum number of idles we'll receive (in Command Mode) between ASYNC frames. Values other than zero over-ride the router selected values. A value of zero has a special meaning. Zero causes router based defaults to be used. This attribute is used to delineate frames when the QUICC is configured for UART/ASYNCHRONOUS mode.")
wfSyncAsyncCmndMaxIdles = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 112), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncAsyncCmndMaxIdles.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncAsyncCmndMaxIdles.setDescription("Maximum number of idles we'll receive (in Command Mode) (i.e. when the modems have not yet connected & entered data state), before closing the ASYNC frame. This value is used to delineate frames when receiving data when the SYNC port is configured for UART/ASYNCHRONOUS mode.")
wfSyncCfgAsyncDataMaxIdles = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 113), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 500))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncCfgAsyncDataMaxIdles.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncCfgAsyncDataMaxIdles.setDescription("Maximum number of idles we'll receive (in Data Mode) between ASYNC frames. Values other than zero over-ride the router selected values. A value of zero has a special meaning. Zero causes router based defaults to be used. This attribute is used to delineate frames when the QUICC is configured for UART/ASYNCHRONOUS mode.")
wfSyncAsyncDataMaxIdles = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 114), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncAsyncDataMaxIdles.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncAsyncDataMaxIdles.setDescription("Maximum number of idles we'll receive (in Command Mode) (i.e. when the modems have connected & entered data state), before closing the ASYNC frame. This value is used to delineate frames when receiving data when the SYNC port is configured for UART/ASYNCHRONOUS mode.")
wfSyncFramesAbortTx = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 115), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncFramesAbortTx.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncFramesAbortTx.setDescription('Number of frames where CTS was lost during transmission.')
wfSyncPasyncParityType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 116), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("odd", 1), ("even", 2), ("high", 3), ("low", 4), ("none", 5))).clone('even')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncPasyncParityType.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncPasyncParityType.setDescription('Type of parity chosen for Polled Async')
wfSyncPasyncCharacterLength = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 117), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 7, 8))).clone(namedValues=NamedValues(("five", 5), ("six", 6), ("seven", 7), ("eight", 8))).clone('eight')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncPasyncCharacterLength.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncPasyncCharacterLength.setDescription('Number of data bits chosen for Polled Async')
wfSyncPasyncStopLength = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 118), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("one", 1), ("two", 2))).clone('two')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncPasyncStopLength.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncPasyncStopLength.setDescription('Number of stop bits chosen for Polled Async')
wfSyncPasyncBaudRate = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 119), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(150, 300, 600, 1200, 2400, 4800, 7200, 9600, 12000, 14400, 19200, 28800, 38400, 57600, 64000, 76800, 96000, 115200))).clone(namedValues=NamedValues(("baudrate150b", 150), ("baudrate300b", 300), ("baudrate600b", 600), ("baudrate1200b", 1200), ("baudrate2400b", 2400), ("baudrate4800b", 4800), ("baudrate7200b", 7200), ("baudrate9600b", 9600), ("baudrate12000b", 12000), ("baudrate14400b", 14400), ("baudrate19200b", 19200), ("baudrate28800b", 28800), ("baudrate38k", 38400), ("baudrate56k", 57600), ("baudrate64k", 64000), ("baudrate76k", 76800), ("baudrate96k", 96000), ("baudrate115k", 115200))).clone('baudrate600b')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncPasyncBaudRate.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncPasyncBaudRate.setDescription('Indicates the baud rate of the Tx/Rx character stream. This value should always be >= than speed at which the modems connect, but is independent of that speed. For instance, for V34 modems, the maximum modular connection speed is 28800 kbps. If your modems can do V.42 bis or MNP 5 data compression, with high (4 to 1) compression ratios you could fill a 115Kbps pipe.')
wfSyncLocalConnectionState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 120), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("unknown", 3))).clone('unknown')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncLocalConnectionState.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncLocalConnectionState.setDescription('The state of the cable at the router end.')
wfSyncRemoteConnectionState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 121), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("devicestreaming", 3), ("unknown", 4))).clone('unknown')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncRemoteConnectionState.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncRemoteConnectionState.setDescription('The state of the cable at the device end.')
wfSyncTimeSlotAssignment = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 122), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncTimeSlotAssignment.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncTimeSlotAssignment.setDescription('Lists the time-slots which constitute this channel. Read only attribute that contains a list of time-slots from 1 to 24 used by the channel assigned to the FT1 card. It contains a list of the timeslots from 1 to 32 for the G.703 card.')
wfSyncEiaStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 123), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 8, 16, 32, 64, 128, 256, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 16777216))).clone(namedValues=NamedValues(("txd", 1), ("rxd", 2), ("rts", 4), ("cts", 8), ("dsr", 16), ("dcd", 32), ("txc", 64), ("rxc", 128), ("dtr", 256), ("txdToggled", 65536), ("rxdToggled", 131072), ("rtsToggled", 262144), ("ctsToggled", 524288), ("dsrToggled", 1048576), ("dcdToggled", 2097152), ("txcToggled", 4194304), ("rxcToggled", 8388608), ("dtrToggled", 16777216)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncEiaStatus.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncEiaStatus.setDescription('The state of the EIA signals at the router interface. The signals are designated as bits in this entry. If the signal is asserted, it is marked as a 1. If not asserted, it is marked as a 0. The state of each signal will be updated every second. Bits 0-15 are reserved for actual signal state. Bits 16-31 are reserved for indicating toggling of the signal. Toggling signals are indicated as a 1. Signals not toggling are indicated with a 0. The following signals are defined and monitored: The bit definition as as follows with bit #0 being the LSB. * signal status - bits 0-15 * bit 0 = TXD transmit data 1 = RXD receive data 2 = RTS request to send 3 = CTS clear to send 4 = DSR data set ready 5 = DCD data carrier detect 6 = TXC transmit clock 7 = RXC receive clock 8 = DTR data terminal ready. * signal toggle status bits 16-31 * bit 16 = TXD transmit data 17 = RXD receive data 18 = RTS request to send 19 = CTS clear to send 20 = DSR data set ready 21 = DCD data carrier detect 22 = TXC transmit clock 23 = RXC receive clock 24 = DTR data terminal ready.')
wfSyncEiaStatusReset = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 124), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 21))).clone(namedValues=NamedValues(("reset", 1), ("noaction", 21))).clone('noaction')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncEiaStatusReset.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncEiaStatusReset.setDescription('Reset The EIA status for the EIA signals in wfSyncEiaStatus. This is particularly useful for clearing the toggle status. ')
wfSyncUcastMap = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 125), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncUcastMap.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncUcastMap.setDescription('Used to map ifEntry.ifInUcastPkts to wfSyncRxFrames and ifEntry.ifOutUcastPkts to wfSyncTxFrames.')
wfSyncAsyncCfgMaxIdleTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 126), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("baudrate", 1), ("threechars", 2))).clone('baudrate')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncAsyncCfgMaxIdleTimer.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncAsyncCfgMaxIdleTimer.setDescription('Determines if Async Max Idle Timer should be based on the baudrate or on the time needed to receive three characters.')
mibBuilder.exportSymbols("Wellfleet-SYNC-MIB", wfSyncCfgTxQueueLength=wfSyncCfgTxQueueLength, wfSyncRemoteConnectionState=wfSyncRemoteConnectionState, wfSyncBChannelOverride=wfSyncBChannelOverride, wfSyncRejectsRx=wfSyncRejectsRx, wfSyncFramesAbortTx=wfSyncFramesAbortTx, wfSyncClkSpeed=wfSyncClkSpeed, wfSyncTxFrames=wfSyncTxFrames, wfSyncPasyncStopLength=wfSyncPasyncStopLength, wfSyncBadFramesRx=wfSyncBadFramesRx, wfSyncEiaStatus=wfSyncEiaStatus, wfSyncClkSource=wfSyncClkSource, wfSyncKG84AResyncs=wfSyncKG84AResyncs, wfSyncConnectAttempts=wfSyncConnectAttempts, wfSyncCfgRxQueueLength=wfSyncCfgRxQueueLength, wfSyncLackRescTx=wfSyncLackRescTx, wfSyncPromiscuous=wfSyncPromiscuous, wfSyncStartUpMode=wfSyncStartUpMode, wfSyncModule=wfSyncModule, wfSyncUnderFlowTx=wfSyncUnderFlowTx, wfSyncForceIFTF=wfSyncForceIFTF, wfSyncLastState=wfSyncLastState, wfSyncKG84AState=wfSyncKG84AState, wfSyncRemoteAddress=wfSyncRemoteAddress, wfSyncBoflTmo=wfSyncBoflTmo, wfSyncUcastMap=wfSyncUcastMap, wfSyncMemoryErrors=wfSyncMemoryErrors, wfSyncPollingEnable=wfSyncPollingEnable, wfSyncKG84AOkFrames=wfSyncKG84AOkFrames, wfSyncEiaStatusReset=wfSyncEiaStatusReset, wfSyncBODFullThreshold=wfSyncBODFullThreshold, wfSyncDelete=wfSyncDelete, wfSyncLinkIdleTimer=wfSyncLinkIdleTimer, wfSyncKG84ASyncPulse=wfSyncKG84ASyncPulse, wfSyncMinFrameSpace=wfSyncMinFrameSpace, wfSyncAsyncCmndMaxIdles=wfSyncAsyncCmndMaxIdles, wfSyncExtendedAddressForce=wfSyncExtendedAddressForce, wfSyncCableType=wfSyncCableType, wfSyncTimeSlotAssignment=wfSyncTimeSlotAssignment, wfSyncIdleRRFrames=wfSyncIdleRRFrames, wfSyncState=wfSyncState, wfSyncBoflNum=wfSyncBoflNum, wfSyncBChRateAdaption=wfSyncBChRateAdaption, wfSyncRetryTimer=wfSyncRetryTimer, wfSyncLastChange=wfSyncLastChange, wfSyncExtendedControlForce=wfSyncExtendedControlForce, wfSyncCfgAsyncDataMaxIdles=wfSyncCfgAsyncDataMaxIdles, wfSyncKG84ARemoteResyncWait=wfSyncKG84ARemoteResyncWait, wfSyncBurstCount=wfSyncBurstCount, wfSyncHoldDownTime=wfSyncHoldDownTime, wfSyncKG84AResyncsDetected=wfSyncKG84AResyncsDetected, wfSyncTurboBoflMisses=wfSyncTurboBoflMisses, wfSyncKG84ASyncLossInterval=wfSyncKG84ASyncLossInterval, wfSyncExtendedControl=wfSyncExtendedControl, wfSyncAsyncCfgMaxIdleTimer=wfSyncAsyncCfgMaxIdleTimer, wfSyncWanProtocol=wfSyncWanProtocol, wfSyncActiveCct=wfSyncActiveCct, wfSyncRemoteLpbkDetection=wfSyncRemoteLpbkDetection, wfSyncLocalAddress=wfSyncLocalAddress, wfSyncOverFlowRx=wfSyncOverFlowRx, wfSyncLineCoding=wfSyncLineCoding, wfSyncTxQueueLength=wfSyncTxQueueLength, wfSyncBChActualRateAdaption=wfSyncBChActualRateAdaption, wfSyncFrameRejectsRx=wfSyncFrameRejectsRx, wfSyncPasyncBaudRate=wfSyncPasyncBaudRate, wfSyncExternalClkSpeed=wfSyncExternalClkSpeed, wfSyncLocalConnectionState=wfSyncLocalConnectionState, wfSyncTxOctets=wfSyncTxOctets, wfSyncFramesIncompRx=wfSyncFramesIncompRx, wfSyncNetworkType=wfSyncNetworkType, wfSyncEntry=wfSyncEntry, wfSyncRxQueueLength=wfSyncRxQueueLength, wfSyncBandwidthOnDemandPool=wfSyncBandwidthOnDemandPool, wfSyncSignalMode=wfSyncSignalMode, wfSyncBChannel=wfSyncBChannel, wfSyncRxErrors=wfSyncRxErrors, wfSyncMediaType=wfSyncMediaType, wfSyncDisable=wfSyncDisable, wfSyncBODRecoverPeriodsToPass=wfSyncBODRecoverPeriodsToPass, wfSyncCfgAsyncCmndMaxIdles=wfSyncCfgAsyncCmndMaxIdles, wfSyncRejectsTx=wfSyncRejectsTx, wfSyncPriority=wfSyncPriority, wfSyncActualConnector=wfSyncActualConnector, wfSyncPassThruLocalMadr=wfSyncPassThruLocalMadr, wfSyncBODExamPeriod=wfSyncBODExamPeriod, wfSyncWanType=wfSyncWanType, wfSyncXid=wfSyncXid, wfSyncBODDebugFlag=wfSyncBODDebugFlag, wfSyncTurboBoflInvocations=wfSyncTurboBoflInvocations, wfSyncRetryCount=wfSyncRetryCount, wfSyncRxReplenMisses=wfSyncRxReplenMisses, wfSyncMadr=wfSyncMadr, wfSyncBofl=wfSyncBofl, wfSyncSlot=wfSyncSlot, wfSyncBODRecoverThreshold=wfSyncBODRecoverThreshold, wfSyncAsyncDataMaxIdles=wfSyncAsyncDataMaxIdles, wfSyncBoflLen=wfSyncBoflLen, wfSyncWindowSizeTx=wfSyncWindowSizeTx, wfSyncCct=wfSyncCct, wfSyncOutQLen=wfSyncOutQLen, wfSyncBODHistory=wfSyncBODHistory, wfSyncPassThruRemoteMadr=wfSyncPassThruRemoteMadr, wfSyncKG84ACycle=wfSyncKG84ACycle, wfSyncExtendedAddress=wfSyncExtendedAddress, wfSyncPasyncParityType=wfSyncPasyncParityType, wfSyncRxDropPackets=wfSyncRxDropPackets, wfSyncMtu=wfSyncMtu, wfSyncRxFrames=wfSyncRxFrames, wfSyncCrcSize=wfSyncCrcSize, wfSyncTable=wfSyncTable, wfSyncRuntsRx=wfSyncRuntsRx, wfSyncT1Timeouts=wfSyncT1Timeouts, wfSyncKG84ABsu=wfSyncKG84ABsu, wfSyncMultilineMode=wfSyncMultilineMode, wfSyncService=wfSyncService, wfSyncPasyncCharacterLength=wfSyncPasyncCharacterLength, wfSyncBODPeriodsToFail=wfSyncBODPeriodsToFail, wfSyncTxErrors=wfSyncTxErrors, wfSyncBackupPool=wfSyncBackupPool, wfSyncWindowSizeTxExtc=wfSyncWindowSizeTxExtc, wfSyncLineNumber=wfSyncLineNumber, wfSyncTxDropPackets=wfSyncTxDropPackets, wfSyncTurboBofl=wfSyncTurboBofl, wfSyncRxOctets=wfSyncRxOctets, wfSyncConnector=wfSyncConnector, wfSyncAsyncBaudRate=wfSyncAsyncBaudRate, wfSyncLackRescRx=wfSyncLackRescRx, wfSyncRtsEnable=wfSyncRtsEnable, wfSyncDemandPool=wfSyncDemandPool)

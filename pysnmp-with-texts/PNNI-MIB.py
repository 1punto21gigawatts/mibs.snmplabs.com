#
# PySNMP MIB module PNNI-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/PNNI-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:31:27 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsIntersection, ValueRangeConstraint, SingleValueConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsIntersection", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsUnion")
AtmTrafficDescrParamIndex, = mibBuilder.importSymbols("ATM-TC-MIB", "AtmTrafficDescrParamIndex")
ifIndex, InterfaceIndex = mibBuilder.importSymbols("IF-MIB", "ifIndex", "InterfaceIndex")
NotificationGroup, ObjectGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ObjectGroup", "ModuleCompliance")
IpAddress, MibIdentifier, iso, Bits, Unsigned32, zeroDotZero, Counter64, Counter32, Gauge32, ObjectIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, Integer32, TimeTicks, enterprises, ModuleIdentity, NotificationType = mibBuilder.importSymbols("SNMPv2-SMI", "IpAddress", "MibIdentifier", "iso", "Bits", "Unsigned32", "zeroDotZero", "Counter64", "Counter32", "Gauge32", "ObjectIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Integer32", "TimeTicks", "enterprises", "ModuleIdentity", "NotificationType")
TextualConvention, TruthValue, RowStatus, DisplayString, TimeStamp = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "TruthValue", "RowStatus", "DisplayString", "TimeStamp")
pnniMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 353, 5, 4, 1))
pnniMIB.setRevisions(('2002-04-24 00:00', '1997-03-01 00:00', '1996-02-27 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: pnniMIB.setRevisionsDescriptions(('Removed Following TEXTUAL CONVENTION definitions: Unsigned32 zeroDotZero. Importing Following from SNMPv2-SMI. Unsigned32 zeroDotZero.', 'Updated version of the PNNI MIB released with the PNNI V1.0 Errata and PICS (af-pnni-81.00).', 'Initial version of the MIB for monitoring and controlling PNNI routing.',))
if mibBuilder.loadTexts: pnniMIB.setLastUpdated('200204240000Z')
if mibBuilder.loadTexts: pnniMIB.setOrganization('The ATM Forum')
if mibBuilder.loadTexts: pnniMIB.setContactInfo('The ATM Forum 2570 West El Camino Real, Suite 304 Mountain View, CA 94040-1313 USA Phone: +1 415-949-6700 Fax: +1 415-949-6705 info@atmforum.com')
if mibBuilder.loadTexts: pnniMIB.setDescription('The MIB module for managing ATM Forum PNNI routing.')
atmForum = MibIdentifier((1, 3, 6, 1, 4, 1, 353))
atmForumNetworkManagement = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5))
atmfPnni = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 4))
pnniMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1))
class PnniAtmAddr(TextualConvention, OctetString):
    reference = 'ATM Forum PNNI 1.0 Section 5.2'
    description = 'The ATM address used by the network entity. The address types are: no address (0 octets), and NSAP (20 octets).'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(20, 20), )
class PnniNodeIndex(TextualConvention, Integer32):
    description = 'An index that identifies a logical PNNI entity within the managed system. The distinguished value zero indicates the null instance or no instance in the PnniNodeCfgParentNodeIndex. In all other cases, the distinguished value zero indicates a logical entity within the switching system that manages routes only over non-PNNI interfaces. By default, only the node identified by node index one is created, and all PNNI interfaces are associated with that node.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 65535)

class PnniNodeId(TextualConvention, OctetString):
    reference = 'ATM Forum PNNI 1.0 Section 5.3.3'
    description = 'A PNNI node ID - this is used to identify the logical PNNI node.'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(22, 22)
    fixedLength = 22

class PnniPortId(TextualConvention, Unsigned32):
    reference = 'ATM Forum PNNI 1.0 Section 5.3.4'
    description = 'A PNNI port ID - this is used to identify a point of attachment of a logical link to a given logical node. The values 0 and 0xffffffff have special meanings in certain contexts and do not identify a specific port. The distinguished value 0 indicates that no port is specified.'
    status = 'current'

class PnniAggrToken(TextualConvention, Unsigned32):
    reference = 'ATM Forum PNNI 1.0 Section 5.3.5'
    description = 'A PNNI aggregation token - this is used to determine which links to a given neighbor node are to be aggregated and advertised as a single logical link.'
    status = 'current'

class PnniPeerGroupId(TextualConvention, OctetString):
    reference = 'ATM Forum PNNI 1.0 Section 5.3.2'
    description = 'A PNNI peer group ID.'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(14, 14)
    fixedLength = 14

class PnniLevel(TextualConvention, Integer32):
    reference = 'ATM Forum PNNI 1.0 Section 5.3.1'
    description = 'A PNNI routing level indicator.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 104)

class PnniSvccRccIndex(TextualConvention, Integer32):
    description = 'The value of this object identifies the SVCC-based RCC for which the entry contains management information.'
    status = 'current'

class AtmAddrPrefix(TextualConvention, OctetString):
    reference = 'ATM Forum PNNI 1.0 Section 5.2'
    description = 'A prefix of one or more ATM End System Addresses. The significant portion of a prefix is padded with zeros on the right to fill 19 octets.'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(19, 19)
    fixedLength = 19

class PnniPrefixLength(TextualConvention, Integer32):
    reference = 'ATM Forum PNNI 1.0 Section 5.2'
    description = 'The number of bits that are significant in an ATM address prefix used by PNNI.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 152)

class PnniMetricsTag(TextualConvention, Integer32):
    description = 'An index into the pnniMetricsTable. The suffix tag is used to indicate that there may be many related entries in the table further discriminated by other index terms. The distinguished value zero indicates that no metrics are associated with the described entity.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 2147483647)

class ServiceCategory(TextualConvention, Integer32):
    reference = 'ATM Forum Traffic Management 4.0 Section 2'
    description = 'Indicates the service category.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))
    namedValues = NamedValues(("other", 1), ("cbr", 2), ("rtVbr", 3), ("nrtVbr", 4), ("abr", 5), ("ubr", 6))

class ClpType(TextualConvention, Integer32):
    description = 'Indicates the CLP type of a traffic stream.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("clpEqual0", 1), ("clpEqual0Or1", 2))

class TnsType(TextualConvention, Integer32):
    reference = 'ATM Forum UNI Signalling 4.0 Section 2 4.5.22/Q.2931'
    description = 'Indicates the type of network identification of a specified transit network.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(2, 8))
    namedValues = NamedValues(("nationalNetworkIdentification", 2), ("other", 8))

class TnsPlan(TextualConvention, Integer32):
    reference = 'ATM Forum UNI Signalling 4.0 Section 2 4.5.22/Q.2931'
    description = 'Indicates the network identification plan of a specified transit network.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 16))
    namedValues = NamedValues(("carrierIdentificationCode", 1), ("other", 16))

class PnniVersion(TextualConvention, Integer32):
    reference = 'ATM Forum PNNI 1.0 Section 5.6.1'
    description = 'Indicates a version of the PNNI protocol.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("unsupported", 1), ("version1point0", 2))

class PnniHelloState(TextualConvention, Integer32):
    reference = 'ATM Forum PNNI 1.0 Section 5.6.2.1.2'
    description = 'The state of an instance of the PNNI Hello State machine.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))
    namedValues = NamedValues(("notApplicable", 1), ("down", 2), ("attempt", 3), ("oneWayInside", 4), ("twoWayInside", 5), ("oneWayOutside", 6), ("twoWayOutside", 7), ("commonOutside", 8))

pnniBaseGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 1))
pnniHighestVersion = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 1, 1), PnniVersion()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniHighestVersion.setReference('ATM Forum PNNI 1.0 Section 5.6.1')
if mibBuilder.loadTexts: pnniHighestVersion.setStatus('current')
if mibBuilder.loadTexts: pnniHighestVersion.setDescription('The highest version of the PNNI protocol that the software in this switching system is capable of executing.')
pnniLowestVersion = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 1, 2), PnniVersion()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniLowestVersion.setReference('ATM Forum PNNI 1.0 Section 5.6.1')
if mibBuilder.loadTexts: pnniLowestVersion.setStatus('current')
if mibBuilder.loadTexts: pnniLowestVersion.setDescription('The lowest version of the PNNI Protocol that the software in this switching system is capable of executing.')
pnniDtlCountOriginator = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniDtlCountOriginator.setStatus('current')
if mibBuilder.loadTexts: pnniDtlCountOriginator.setDescription('The total number of DTL stacks that this switching system has originated as the DTLOriginator and placed into signalling messages. This includes the initial DTL stacks computed by this system as well as any alternate route (second, third choice etc.) DTL stacks computed by this switching system in response to crankbacks.')
pnniDtlCountBorder = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniDtlCountBorder.setStatus('current')
if mibBuilder.loadTexts: pnniDtlCountBorder.setDescription('The number of partial DTL stacks that this switching system has added into signalling messages as an entry border node. This includes the initial partial DTL stacks computed by this system as well as any alternate route (second, third choice etc.) partial DTL stacks computed by this switching system in response to crankbacks.')
pnniCrankbackCountOriginator = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniCrankbackCountOriginator.setStatus('current')
if mibBuilder.loadTexts: pnniCrankbackCountOriginator.setDescription('The count of the total number of connection setup messages including DTL stacks originated by this switching system that have cranked back to this switching system at all levels of the hierarchy.')
pnniCrankbackCountBorder = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniCrankbackCountBorder.setStatus('current')
if mibBuilder.loadTexts: pnniCrankbackCountBorder.setDescription('The count of the total number of connection setup messages including DTLs added by this switching system as an entry border node that have cranked back to this switching system at all levels of the hierarchy. This count does not include Crankbacks for which this switching system was not the crankback destination, only those crankbacks that were directed to this switching system are counted here.')
pnniAltRouteCountOriginator = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniAltRouteCountOriginator.setStatus('current')
if mibBuilder.loadTexts: pnniAltRouteCountOriginator.setDescription('The total number of alternate DTL stacks that this switching system has computed and placed into signalling messages as the DTLOriginator.')
pnniAltRouteCountBorder = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniAltRouteCountBorder.setStatus('current')
if mibBuilder.loadTexts: pnniAltRouteCountBorder.setDescription('The total number of alternate partial DTL stacks that this switching system has computed and placed into signalling messages as an entry border node.')
pnniRouteFailCountOriginator = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniRouteFailCountOriginator.setStatus('current')
if mibBuilder.loadTexts: pnniRouteFailCountOriginator.setDescription('The total number of times where the switching system failed to compute a viable DTL stack as the DTLOriginator for some call. It indicates the number of times a call was cleared from this switching system due to originator routing failure.')
pnniRouteFailCountBorder = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniRouteFailCountBorder.setStatus('current')
if mibBuilder.loadTexts: pnniRouteFailCountBorder.setDescription('The total number of times where the switching system failed to compute a viable partial DTL stack as an entry border node for some call. It indicates the number of times a call was either cleared or cranked back from this switching system due to border routing failure.')
pnniRouteFailUnreachableOriginator = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniRouteFailUnreachableOriginator.setStatus('current')
if mibBuilder.loadTexts: pnniRouteFailUnreachableOriginator.setDescription("The total number of times where the switching system failed to compute a viable DTL stack as the DTLOriginator because the destination was unreachable, i.e., those calls that are cleared with cause #2 `specified transit network unreachable' or cause #3 `destination unreachable' in the cause IE.")
pnniRouteFailUnreachableBorder = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniRouteFailUnreachableBorder.setStatus('current')
if mibBuilder.loadTexts: pnniRouteFailUnreachableBorder.setDescription("The total number of times where the switching system failed to compute a viable partial DTL stack as an entry border node because the target of the path calculation was unreachable, i.e., those calls that are cleared or cranked back with cause #2 `specified transit network unreachable' or cause #3 `destination unreachable' in the cause IE.")
pnniNodeTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 2), )
if mibBuilder.loadTexts: pnniNodeTable.setReference('ATM Forum PNNI 1.0 Annex F')
if mibBuilder.loadTexts: pnniNodeTable.setStatus('current')
if mibBuilder.loadTexts: pnniNodeTable.setDescription('The pnniNodeTable collects attributes that affect the operation of a PNNI logical node. There is a single row in this table for each PNNI peer group that the managed system is expected or eligible to become a member of.')
pnniNodeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 2, 1), ).setIndexNames((0, "PNNI-MIB", "pnniNodeIndex"))
if mibBuilder.loadTexts: pnniNodeEntry.setReference('ATM Forum PNNI 1.0 Annex F')
if mibBuilder.loadTexts: pnniNodeEntry.setStatus('current')
if mibBuilder.loadTexts: pnniNodeEntry.setDescription('An entry in the table, containing information about a PNNI logical node in this switching system.')
pnniNodeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 2, 1, 1), PnniNodeIndex())
if mibBuilder.loadTexts: pnniNodeIndex.setStatus('current')
if mibBuilder.loadTexts: pnniNodeIndex.setDescription('A value assigned to a node in this switching system that uniquely identifies it in the MIB.')
pnniNodeLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 2, 1, 2), PnniLevel().clone(96)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniNodeLevel.setReference('ATM Forum PNNI 1.0 Section 5.3.1, Annex F')
if mibBuilder.loadTexts: pnniNodeLevel.setStatus('current')
if mibBuilder.loadTexts: pnniNodeLevel.setDescription('The level of PNNI hierarchy at which this node exists. This attribute is used to determine the default node ID and the default peer group ID for this node. This object may only be written when pnniNodeAdminStatus has the value down.')
pnniNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 2, 1, 3), PnniNodeId()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniNodeId.setReference('ATM Forum PNNI 1.0 Section 5.3.3, Annex F')
if mibBuilder.loadTexts: pnniNodeId.setStatus('current')
if mibBuilder.loadTexts: pnniNodeId.setDescription('The value the switching system is using to represent itself as this node. This object may only be written when pnniNodeAdminStatus has the value down. If pnniNodeLowest is true, then the default node ID takes the form defined in Section 5.3.3 for lowest level nodes, with the first octet equal to pnniNodeLevel, the second octet equal to 160, and the last 20 octets equal to pnniNodeAtmAddress. If pnniNodeLowest is false, then the default node ID takes the form defined in Section 5.3.3 for logical group nodes, with the first octet equal to pnniNodeLevel, the next fourteen octets equal to the value of pnniNodePeerGroupId for the child node whose election as PGL causes this LGN to be instantiated, the next six octets equal to the ESI of pnniNodeAtmAddress, and the last octet equal to zero.')
pnniNodeLowest = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 2, 1, 4), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniNodeLowest.setStatus('current')
if mibBuilder.loadTexts: pnniNodeLowest.setDescription("Indicates whether this node acts as a lowest level node or whether this node is a logical group node that becomes active when one of the other nodes in this switching system becomes a peer group leader. The value 'false' must not be used with nodes that are not PGL/LGN capable. This object may only be written when pnniNodeAdminStatus has the value down.")
pnniNodeAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2))).clone('up')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniNodeAdminStatus.setStatus('current')
if mibBuilder.loadTexts: pnniNodeAdminStatus.setDescription('Indicates whether the administrative status of the node is up (the node is allowed to become active) or down (the node is forced to be inactive). When pnniNodeAdminStatus is down, then pnniNodeOperStatus must also be down.')
pnniNodeOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniNodeOperStatus.setStatus('current')
if mibBuilder.loadTexts: pnniNodeOperStatus.setDescription('Indicates whether the node is active or whether the node has yet to become operational. When the value is down, all state has been cleared from the node and the node is not communicating with any of its neighbor nodes.')
pnniNodeDomainName = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 2, 1, 7), DisplayString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniNodeDomainName.setStatus('current')
if mibBuilder.loadTexts: pnniNodeDomainName.setDescription('The name of the PNNI routing domain in which this node participates. All lowest-level PNNI nodes with the same pnniNodeDomainName are presumed to be connected.')
pnniNodeAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 2, 1, 8), PnniAtmAddr()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniNodeAtmAddress.setReference('ATM Forum PNNI 1.0 Section 5.2.2')
if mibBuilder.loadTexts: pnniNodeAtmAddress.setStatus('current')
if mibBuilder.loadTexts: pnniNodeAtmAddress.setDescription("This node's ATM End System Address. Remote systems wishing to exchange PNNI protocol packets with this node should direct packets or calls to this address. This attribute may only be written when pnniNodeAdminStatus has the value down.")
pnniNodePeerGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 2, 1, 9), PnniPeerGroupId()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniNodePeerGroupId.setReference('ATM Forum PNNI 1.0 Section 5.3.2, Annex F')
if mibBuilder.loadTexts: pnniNodePeerGroupId.setStatus('current')
if mibBuilder.loadTexts: pnniNodePeerGroupId.setDescription('The Peer Group Identifier of the peer group that the given node is to become a member of. The default value of this attribute has the first octet equal to pnniNodeLevel, the next pnniNodeLevel bits equal to the pnniNodeLevel bits starting from the third octet of pnniNodeId, and the remainder padded with zeros. This object may only be written when pnniNodeAdminStatus has the value down.')
pnniNodeRestrictedTransit = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 2, 1, 10), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniNodeRestrictedTransit.setReference('ATM Forum PNNI 1.0 Section 5.8.1.2.3')
if mibBuilder.loadTexts: pnniNodeRestrictedTransit.setStatus('current')
if mibBuilder.loadTexts: pnniNodeRestrictedTransit.setDescription('Specifies whether the node is restricted to not allowing support of SVCs transiting this node. This attribute determines the setting of the restricted transit bit in the nodal information group originated by this node.')
pnniNodeComplexRep = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 2, 1, 11), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniNodeComplexRep.setReference('ATM Forum PNNI 1.0 Section 5.8.1.2.3')
if mibBuilder.loadTexts: pnniNodeComplexRep.setStatus('current')
if mibBuilder.loadTexts: pnniNodeComplexRep.setDescription("Specifies whether this node uses the complex node representation. A value of `true' indicates that the complex node representation is used, whereas a value of `false' indicates that the simple node representation is used. This attribute determines the setting of the nodal representation bit in the nodal information group originated by this node.")
pnniNodeRestrictedBranching = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 2, 1, 12), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniNodeRestrictedBranching.setReference('ATM Forum PNNI 1.0 Section 5.8.1.2.3')
if mibBuilder.loadTexts: pnniNodeRestrictedBranching.setStatus('current')
if mibBuilder.loadTexts: pnniNodeRestrictedBranching.setDescription("Indicates whether the node is able to support additional point-to-multipoint branches. A value of 'false' indicates that additional branches can be supported, and a value of 'true' indicates that additional branches cannot be supported. This attribute reflects the setting of the restricted branching bit in the nodal information group originated by this node.")
pnniNodeDatabaseOverload = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 2, 1, 13), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniNodeDatabaseOverload.setReference('ATM Forum PNNI 1.0 Section 5.8.1.2.3')
if mibBuilder.loadTexts: pnniNodeDatabaseOverload.setStatus('current')
if mibBuilder.loadTexts: pnniNodeDatabaseOverload.setDescription('Specifies whether the node is currently operating in topology database overload state. This attribute has the same value as the Non-transit for PGL Election bit in the nodal information group originated by this node.')
pnniNodePtses = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 2, 1, 14), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniNodePtses.setStatus('current')
if mibBuilder.loadTexts: pnniNodePtses.setDescription("Gauges the total number of PTSEs currently in this node's topology database(s).")
pnniNodeRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 2, 1, 15), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniNodeRowStatus.setStatus('current')
if mibBuilder.loadTexts: pnniNodeRowStatus.setDescription('To create, delete, activate and de-activate a Node.')
pnniNodePglTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 3), )
if mibBuilder.loadTexts: pnniNodePglTable.setReference('ATM Forum PNNI 1.0 Section 5.10.1')
if mibBuilder.loadTexts: pnniNodePglTable.setStatus('current')
if mibBuilder.loadTexts: pnniNodePglTable.setDescription('Peer group leader election information for a PNNI node in this switching system.')
pnniNodePglEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 3, 1), )
if mibBuilder.loadTexts: pnniNodePglEntry.setReference('ATM Forum PNNI 1.0 Section 5.10.1')
pnniNodeEntry.registerAugmentions(("PNNI-MIB", "pnniNodePglEntry"))
pnniNodePglEntry.setIndexNames(*pnniNodeEntry.getIndexNames())
if mibBuilder.loadTexts: pnniNodePglEntry.setStatus('current')
if mibBuilder.loadTexts: pnniNodePglEntry.setDescription('An entry in the table, containing PGL election information of a PNNI logical node in this switching system.')
pnniNodePglLeadershipPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 205))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniNodePglLeadershipPriority.setReference('ATM Forum PNNI 1.0 Section 5.10.1.2')
if mibBuilder.loadTexts: pnniNodePglLeadershipPriority.setStatus('current')
if mibBuilder.loadTexts: pnniNodePglLeadershipPriority.setDescription('The Leadership priority value this node should advertise in its nodal information group for the given peer group. Only the value zero can be used with nodes that are not PGL/LGN capable. If there is no configured parent node index or no corresponding entry in the pnniNodeTable, then the advertised leadership priority is zero regardless of this value.')
pnniNodeCfgParentNodeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 3, 1, 2), PnniNodeIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniNodeCfgParentNodeIndex.setReference('ATM Forum PNNI 1.0 Annex F')
if mibBuilder.loadTexts: pnniNodeCfgParentNodeIndex.setStatus('current')
if mibBuilder.loadTexts: pnniNodeCfgParentNodeIndex.setDescription('The local node index used to identify the node that will represent this peer group at the next higher level of hierarchy, if this node becomes peer group leader. The value 0 indicates that there is no parent node.')
pnniNodePglInitTime = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 3, 1, 3), Integer32().clone(15)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniNodePglInitTime.setReference('ATM Forum PNNI 1.0 Annex G PGLInitTime')
if mibBuilder.loadTexts: pnniNodePglInitTime.setStatus('current')
if mibBuilder.loadTexts: pnniNodePglInitTime.setDescription('The amount of time in seconds this node will delay advertising its choice of preferred PGL after having initialized operation and reached the full state with at least one neighbor in the peer group.')
pnniNodePglOverrideDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 3, 1, 4), Integer32().clone(30)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniNodePglOverrideDelay.setReference('ATM Forum PNNI 1.0 Annex G OverrideDelay')
if mibBuilder.loadTexts: pnniNodePglOverrideDelay.setStatus('current')
if mibBuilder.loadTexts: pnniNodePglOverrideDelay.setDescription('The amount of time in seconds a node will wait for itself to be declared the preferred PGL by unanimous agreement among its peers. In the absence of unanimous agreement this will be the amount of time that will pass before this node considers a two thirds majority as sufficient agreement to declare itself peer group leader, abandoning the attempt to get unanimous agreement.')
pnniNodePglReelectTime = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 3, 1, 5), Integer32().clone(15)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniNodePglReelectTime.setReference('ATM Forum PNNI 1.0 Annex G ReElectionInterval')
if mibBuilder.loadTexts: pnniNodePglReelectTime.setStatus('current')
if mibBuilder.loadTexts: pnniNodePglReelectTime.setDescription('The amount of time in seconds after losing connectivity to the current peer group leader, that this node will wait before re-starting the process of electing a new peer group leader.')
pnniNodePglState = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("starting", 1), ("awaiting", 2), ("awaitingFull", 3), ("initialDelay", 4), ("calculating", 5), ("awaitUnanimity", 6), ("operPgl", 7), ("operNotPgl", 8), ("hungElection", 9), ("awaitReElection", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniNodePglState.setReference('ATM Forum PNNI 1.0 Section 5.10.1.1.2')
if mibBuilder.loadTexts: pnniNodePglState.setStatus('current')
if mibBuilder.loadTexts: pnniNodePglState.setDescription("Indicates the state that this node is in with respect to the Peer Group Leader election that takes place in the node's peer group. The values are enumerated in the Peer Group Leader State Machine.")
pnniNodePreferredPgl = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 3, 1, 7), PnniNodeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniNodePreferredPgl.setReference('ATM Forum PNNI 1.0 Section 5.10.1.1.6')
if mibBuilder.loadTexts: pnniNodePreferredPgl.setStatus('current')
if mibBuilder.loadTexts: pnniNodePreferredPgl.setDescription("The Node ID of the node which the local node believes should be or become the peer group leader. This is also the value the local node is currently advertising in the `Preferred Peer Group Leader Node ID' field of its nodal information group within the given peer group. If a Preferred PGL has not been chosen, this attribute's value is set to (all) zero(s).")
pnniNodePeerGroupLeader = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 3, 1, 8), PnniNodeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniNodePeerGroupLeader.setStatus('current')
if mibBuilder.loadTexts: pnniNodePeerGroupLeader.setDescription("The Node Identifier of the node which is currently operating as peer group leader of the peer group this node belongs to. If a PGL has not been elected, this attribute's value is set to (all) zero(s).")
pnniNodePglTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 3, 1, 9), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniNodePglTimeStamp.setStatus('current')
if mibBuilder.loadTexts: pnniNodePglTimeStamp.setDescription('The time at which the current Peer Group Leader established itself.')
pnniNodeActiveParentNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 3, 1, 10), PnniNodeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniNodeActiveParentNodeId.setStatus('current')
if mibBuilder.loadTexts: pnniNodeActiveParentNodeId.setDescription('The Node Identifier value being used by the Peer Group Leader to represent this peer group at the next higher level of the hierarchy. If this node is at the highest level of the hierarchy or if no PGL has yet been elected the PNNI Protocol Entity sets the value of this attribute to (all) zero(s).')
pnniNodeTimerTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 4), )
if mibBuilder.loadTexts: pnniNodeTimerTable.setStatus('current')
if mibBuilder.loadTexts: pnniNodeTimerTable.setDescription('A table of initial PNNI timer values and significant change thresholds.')
pnniNodeTimerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 4, 1), )
pnniNodeEntry.registerAugmentions(("PNNI-MIB", "pnniNodeTimerEntry"))
pnniNodeTimerEntry.setIndexNames(*pnniNodeEntry.getIndexNames())
if mibBuilder.loadTexts: pnniNodeTimerEntry.setStatus('current')
if mibBuilder.loadTexts: pnniNodeTimerEntry.setDescription('An entry in the table, containing initial PNNI timer values and significant change thresholds of a PNNI logical node in this switching system.')
pnniNodePtseHolddown = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 4, 1, 1), Integer32().clone(10)).setUnits('100 milliseconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniNodePtseHolddown.setReference('ATM Forum PNNI 1.0 Annex G MinPTSEInterval')
if mibBuilder.loadTexts: pnniNodePtseHolddown.setStatus('current')
if mibBuilder.loadTexts: pnniNodePtseHolddown.setDescription('The initial value for the PTSE hold down timer that will be used by the given node to limit the rate at which it can re-originate PTSEs. It must be a positive non-zero number.')
pnniNodeHelloHolddown = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 4, 1, 2), Integer32().clone(10)).setUnits('100 milliseconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniNodeHelloHolddown.setReference('ATM Forum PNNI 1.0 Annex G MinHelloInterval')
if mibBuilder.loadTexts: pnniNodeHelloHolddown.setStatus('current')
if mibBuilder.loadTexts: pnniNodeHelloHolddown.setDescription('The initial value for the Hello hold down timer that will be used by the given node to limit the rate at which it sends Hellos. It must be a positive non-zero number.')
pnniNodeHelloInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 4, 1, 3), Integer32().clone(15)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniNodeHelloInterval.setReference('ATM Forum PNNI 1.0 Annex G HelloInterval')
if mibBuilder.loadTexts: pnniNodeHelloInterval.setStatus('current')
if mibBuilder.loadTexts: pnniNodeHelloInterval.setDescription('The initial value for the Hello Timer. In the absence of triggered Hellos, this node will send one Hello packet on each of its ports on this interval.')
pnniNodeHelloInactivityFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 4, 1, 4), Integer32().clone(5)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniNodeHelloInactivityFactor.setReference('ATM Forum PNNI 1.0 Annex G InactivityFactor')
if mibBuilder.loadTexts: pnniNodeHelloInactivityFactor.setStatus('current')
if mibBuilder.loadTexts: pnniNodeHelloInactivityFactor.setDescription('The value for the Hello Inactivity factor that this node will use to determine when a neighbor has gone down.')
pnniNodeHlinkInact = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 4, 1, 5), Integer32().clone(120)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniNodeHlinkInact.setReference('ATM Forum PNNI 1.0 Annex G HorizontalLinkInactivityTime')
if mibBuilder.loadTexts: pnniNodeHlinkInact.setStatus('current')
if mibBuilder.loadTexts: pnniNodeHlinkInact.setDescription('The amount of time a node will continue to advertise a horizontal (logical) link for which it has not received and processed a LGN Horizontal Link information group.')
pnniNodePtseRefreshInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 4, 1, 6), Integer32().clone(1800)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniNodePtseRefreshInterval.setReference('ATM Forum PNNI 1.0 Annex G PTSERefreshInterval')
if mibBuilder.loadTexts: pnniNodePtseRefreshInterval.setStatus('current')
if mibBuilder.loadTexts: pnniNodePtseRefreshInterval.setDescription('The initial value for the Refresh timer that this node will use to drive (re-)origination of PTSEs in the absence of triggered updates.')
pnniNodePtseLifetimeFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 4, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(101, 1000)).clone(200)).setUnits('percent').setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniNodePtseLifetimeFactor.setReference('ATM Forum PNNI 1.0 Annex G PTSELifetimeFactor')
if mibBuilder.loadTexts: pnniNodePtseLifetimeFactor.setStatus('current')
if mibBuilder.loadTexts: pnniNodePtseLifetimeFactor.setDescription('The value for the lifetime multiplier, expressed as a percentage. The result of multiplying the pnniNodePtseRefreshInterval attribute value by this attribute value is used as the initial lifetime that this node places into self-originated PTSEs.')
pnniNodeRxmtInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 4, 1, 8), Integer32().clone(5)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniNodeRxmtInterval.setReference('ATM Forum PNNI 1.0 Annex G DSRxmtInterval, RequestRxmtInterval, PTSERetransmissionInterval')
if mibBuilder.loadTexts: pnniNodeRxmtInterval.setStatus('current')
if mibBuilder.loadTexts: pnniNodeRxmtInterval.setDescription('The period between retransmissions of unacknowledged Database Summary packets, PTSE Request packets, and PTSPs.')
pnniNodePeerDelayedAckInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 4, 1, 9), Integer32().clone(10)).setUnits('100 milliseconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniNodePeerDelayedAckInterval.setReference('ATM Forum PNNI 1.0 Annex G PeerDelayedAckInterval, Appendix G')
if mibBuilder.loadTexts: pnniNodePeerDelayedAckInterval.setStatus('current')
if mibBuilder.loadTexts: pnniNodePeerDelayedAckInterval.setDescription('The minimum amount of time between transmissions of delayed PTSE acknowledgement packets.')
pnniNodeAvcrPm = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 4, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99)).clone(50)).setUnits('percent').setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniNodeAvcrPm.setReference('ATM Forum PNNI 1.0 Section 5.8.5.2.5.4, Annex G AvCR_PM')
if mibBuilder.loadTexts: pnniNodeAvcrPm.setStatus('current')
if mibBuilder.loadTexts: pnniNodeAvcrPm.setDescription('The proportional multiplier used in the algorithms that determine significant change for AvCR parameters, expressed as a percentage.')
pnniNodeAvcrMt = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 4, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99)).clone(3)).setUnits('percent').setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniNodeAvcrMt.setReference('ATM Forum PNNI 1.0 Section 5.8.5.2.5.4, Annex G AvCR_mT')
if mibBuilder.loadTexts: pnniNodeAvcrMt.setStatus('current')
if mibBuilder.loadTexts: pnniNodeAvcrMt.setDescription('The minimum threshold used in the algorithms that determine significant change for AvCR parameters, expressed as a percentage.')
pnniNodeCdvPm = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 4, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99)).clone(25)).setUnits('percent').setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniNodeCdvPm.setReference('ATM Forum PNNI 1.0 Section 5.8.5.2.5.6, Annex G CDV_PM')
if mibBuilder.loadTexts: pnniNodeCdvPm.setStatus('current')
if mibBuilder.loadTexts: pnniNodeCdvPm.setDescription('The proportional multiplier used in the algorithms that determine significant change for CDV metrics, expressed as a percentage.')
pnniNodeCtdPm = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 4, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99)).clone(50)).setUnits('percent').setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniNodeCtdPm.setReference('ATM Forum PNNI 1.0 Section 5.8.5.2.5.5, Annex G maxCTD_PM')
if mibBuilder.loadTexts: pnniNodeCtdPm.setStatus('current')
if mibBuilder.loadTexts: pnniNodeCtdPm.setDescription('The proportional multiplier used in the algorithms that determine significant change for CTD metrics, expressed as a percentage.')
pnniNodeSvccTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 5), )
if mibBuilder.loadTexts: pnniNodeSvccTable.setReference('ATM Forum PNNI 1.0 Section 5.5')
if mibBuilder.loadTexts: pnniNodeSvccTable.setStatus('current')
if mibBuilder.loadTexts: pnniNodeSvccTable.setDescription('A table of variables related to SVCC-based routing control channels.')
pnniNodeSvccEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 5, 1), )
if mibBuilder.loadTexts: pnniNodeSvccEntry.setReference('ATM Forum PNNI 1.0 Section 5.5')
pnniNodeEntry.registerAugmentions(("PNNI-MIB", "pnniNodeSvccEntry"))
pnniNodeSvccEntry.setIndexNames(*pnniNodeEntry.getIndexNames())
if mibBuilder.loadTexts: pnniNodeSvccEntry.setStatus('current')
if mibBuilder.loadTexts: pnniNodeSvccEntry.setDescription('An entry in the table, containing SVCC-based RCC variables of a PNNI logical node in this switching system.')
pnniNodeSvccInitTime = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 5, 1, 1), Integer32().clone(4)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniNodeSvccInitTime.setReference('ATM Forum PNNI 1.0 Annex G InitialLGNSVCTimeout')
if mibBuilder.loadTexts: pnniNodeSvccInitTime.setStatus('current')
if mibBuilder.loadTexts: pnniNodeSvccInitTime.setDescription('The amount of time this node will delay initiating establishment of an SVCC to a neighbor with a numerically lower ATM address, after determining that such an SVCC should be established.')
pnniNodeSvccRetryTime = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 5, 1, 2), Integer32().clone(30)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniNodeSvccRetryTime.setReference('ATM Forum PNNI 1.0 Annex G RetryLGNSVCTimeout')
if mibBuilder.loadTexts: pnniNodeSvccRetryTime.setStatus('current')
if mibBuilder.loadTexts: pnniNodeSvccRetryTime.setDescription('The amount of time this node will delay after an apparently still necessary and viable SVCC-based RCC is unexpectedly torn down, before attempting to re-establish it.')
pnniNodeSvccCallingIntegrityTime = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 5, 1, 3), Integer32().clone(35)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniNodeSvccCallingIntegrityTime.setReference('ATM Forum PNNI 1.0 Annex G SVCCallingIntegrityTime')
if mibBuilder.loadTexts: pnniNodeSvccCallingIntegrityTime.setStatus('current')
if mibBuilder.loadTexts: pnniNodeSvccCallingIntegrityTime.setDescription('The amount of time this node will wait for an SVCC, which it has initiated establishment of as the calling party, to become fully established before giving up and tearing it down.')
pnniNodeSvccCalledIntegrityTime = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 5, 1, 4), Integer32().clone(50)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniNodeSvccCalledIntegrityTime.setReference('ATM Forum PNNI 1.0 Annex G SVCCalledIntegrityTime')
if mibBuilder.loadTexts: pnniNodeSvccCalledIntegrityTime.setStatus('current')
if mibBuilder.loadTexts: pnniNodeSvccCalledIntegrityTime.setDescription('The amount of time this node will wait for an SVCC, which it has decided to accept as the called party, to become fully established before giving up and tearing it down.')
pnniNodeSvccTrafficDescriptorIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 5, 1, 5), AtmTrafficDescrParamIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniNodeSvccTrafficDescriptorIndex.setReference('ATM Forum PNNI 1.0 Section 5.5.2, Annex G RCCMaximumBurstSize, RCCPeakCellRate, RCCSustainableCellRate')
if mibBuilder.loadTexts: pnniNodeSvccTrafficDescriptorIndex.setStatus('current')
if mibBuilder.loadTexts: pnniNodeSvccTrafficDescriptorIndex.setDescription('An index into the atmTrafficDescrParamTable defined in RFC 1695. This traffic descriptor is used when establishing switched virtual channels for use as SVCC-based RCCs to/from PNNI logical group nodes.')
pnniScopeMappingTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 6), )
if mibBuilder.loadTexts: pnniScopeMappingTable.setReference('ATM Forum PNNI 1.0 Section 5.3.6')
if mibBuilder.loadTexts: pnniScopeMappingTable.setStatus('current')
if mibBuilder.loadTexts: pnniScopeMappingTable.setDescription('The pnniScopeTable contains the mappings of membership and connection scope from organizational scope values (used at UNI interfaces) to PNNI scope (i.e. in terms of PNNI routing level indicators).')
pnniScopeMappingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 6, 1), )
if mibBuilder.loadTexts: pnniScopeMappingEntry.setReference('ATM Forum PNNI 1.0 Section 5.3.6')
pnniNodeEntry.registerAugmentions(("PNNI-MIB", "pnniScopeMappingEntry"))
pnniScopeMappingEntry.setIndexNames(*pnniNodeEntry.getIndexNames())
if mibBuilder.loadTexts: pnniScopeMappingEntry.setStatus('current')
if mibBuilder.loadTexts: pnniScopeMappingEntry.setDescription('An entry in the table, containing scope mapping information for a PNNI logical node in this switching system.')
pnniScopeLocalNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 6, 1, 1), PnniLevel().clone(96)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniScopeLocalNetwork.setStatus('current')
if mibBuilder.loadTexts: pnniScopeLocalNetwork.setDescription('The highest level of PNNI hierarchy (i.e. smallest PNNI routing level) that lies within the organizational scope value localNetwork(1).')
pnniScopeLocalNetworkPlusOne = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 6, 1, 2), PnniLevel().clone(96)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniScopeLocalNetworkPlusOne.setStatus('current')
if mibBuilder.loadTexts: pnniScopeLocalNetworkPlusOne.setDescription('The highest level of PNNI hierarchy (i.e. smallest PNNI routing level) that lies within the organizational scope value localNetworkPlusOne(2).')
pnniScopeLocalNetworkPlusTwo = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 6, 1, 3), PnniLevel().clone(96)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniScopeLocalNetworkPlusTwo.setStatus('current')
if mibBuilder.loadTexts: pnniScopeLocalNetworkPlusTwo.setDescription('The highest level of PNNI hierarchy (i.e. smallest PNNI routing level) that lies within the organizational scope value localNetworkPlusTwo(3).')
pnniScopeSiteMinusOne = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 6, 1, 4), PnniLevel().clone(80)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniScopeSiteMinusOne.setStatus('current')
if mibBuilder.loadTexts: pnniScopeSiteMinusOne.setDescription('The highest level of PNNI hierarchy (i.e. smallest PNNI routing level) that lies within the organizational scope value siteMinusOne(4).')
pnniScopeIntraSite = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 6, 1, 5), PnniLevel().clone(80)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniScopeIntraSite.setStatus('current')
if mibBuilder.loadTexts: pnniScopeIntraSite.setDescription('The highest level of PNNI hierarchy (i.e. smallest PNNI routing level) that lies within the organizational scope value intraSite(5).')
pnniScopeSitePlusOne = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 6, 1, 6), PnniLevel().clone(72)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniScopeSitePlusOne.setStatus('current')
if mibBuilder.loadTexts: pnniScopeSitePlusOne.setDescription('The highest level of PNNI hierarchy (i.e. smallest PNNI routing level) that lies within the organizational scope value sitePlusOne(6).')
pnniScopeOrganizationMinusOne = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 6, 1, 7), PnniLevel().clone(72)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniScopeOrganizationMinusOne.setStatus('current')
if mibBuilder.loadTexts: pnniScopeOrganizationMinusOne.setDescription('The highest level of PNNI hierarchy (i.e. smallest PNNI routing level) that lies within the organizational scope value organizationMinusOne(7).')
pnniScopeIntraOrganization = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 6, 1, 8), PnniLevel().clone(64)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniScopeIntraOrganization.setStatus('current')
if mibBuilder.loadTexts: pnniScopeIntraOrganization.setDescription('The highest level of PNNI hierarchy (i.e. smallest PNNI routing level) that lies within the organizational scope value intraOrganization(8).')
pnniScopeOrganizationPlusOne = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 6, 1, 9), PnniLevel().clone(64)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniScopeOrganizationPlusOne.setStatus('current')
if mibBuilder.loadTexts: pnniScopeOrganizationPlusOne.setDescription('The highest level of PNNI hierarchy (i.e. smallest PNNI routing level) that lies within the organizational scope value organizationPlusOne(9).')
pnniScopeCommunityMinusOne = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 6, 1, 10), PnniLevel().clone(64)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniScopeCommunityMinusOne.setStatus('current')
if mibBuilder.loadTexts: pnniScopeCommunityMinusOne.setDescription('The highest level of PNNI hierarchy (i.e. smallest PNNI routing level) that lies within the organizational scope value communityMinusOne(10).')
pnniScopeIntraCommunity = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 6, 1, 11), PnniLevel().clone(48)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniScopeIntraCommunity.setStatus('current')
if mibBuilder.loadTexts: pnniScopeIntraCommunity.setDescription('The highest level of PNNI hierarchy (i.e. smallest PNNI routing level) that lies within the organizational scope value intraCommunity(11).')
pnniScopeCommunityPlusOne = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 6, 1, 12), PnniLevel().clone(48)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniScopeCommunityPlusOne.setStatus('current')
if mibBuilder.loadTexts: pnniScopeCommunityPlusOne.setDescription('The highest level of PNNI hierarchy (i.e. smallest PNNI routing level) that lies within the organizational scope value communityPlusOne(12).')
pnniScopeRegional = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 6, 1, 13), PnniLevel().clone(32)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniScopeRegional.setStatus('current')
if mibBuilder.loadTexts: pnniScopeRegional.setDescription('The highest level of PNNI hierarchy (i.e. smallest PNNI routing level) that lies within the organizational scope value regional(13).')
pnniScopeInterRegional = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 6, 1, 14), PnniLevel().clone(32)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniScopeInterRegional.setStatus('current')
if mibBuilder.loadTexts: pnniScopeInterRegional.setDescription('The highest level of PNNI hierarchy (i.e. smallest PNNI routing level) that lies within the organizational scope value interRegional(14).')
pnniScopeGlobal = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 6, 1, 15), PnniLevel()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniScopeGlobal.setStatus('current')
if mibBuilder.loadTexts: pnniScopeGlobal.setDescription('The highest level of PNNI hierarchy (i.e. smallest PNNI routing level) that lies within the organizational scope value global(15).')
pnniSummaryTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 7), )
if mibBuilder.loadTexts: pnniSummaryTable.setReference('ATM Forum PNNI 1.0 Section 5.9.2')
if mibBuilder.loadTexts: pnniSummaryTable.setStatus('deprecated')
if mibBuilder.loadTexts: pnniSummaryTable.setDescription('A list of the summary address prefixes that may be advertised by the specified logical PNNI entity.')
pnniSummaryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 7, 1), ).setIndexNames((0, "PNNI-MIB", "pnniNodeIndex"), (0, "PNNI-MIB", "pnniSummaryAddress"), (0, "PNNI-MIB", "pnniSummaryPrefixLength"))
if mibBuilder.loadTexts: pnniSummaryEntry.setReference('ATM Forum PNNI 1.0 Section 5.9.2')
if mibBuilder.loadTexts: pnniSummaryEntry.setStatus('deprecated')
if mibBuilder.loadTexts: pnniSummaryEntry.setDescription('An entry in the table, containing summary address prefix information in this switching system.')
pnniSummaryAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 7, 1, 1), AtmAddrPrefix())
if mibBuilder.loadTexts: pnniSummaryAddress.setStatus('deprecated')
if mibBuilder.loadTexts: pnniSummaryAddress.setDescription('The ATM End System Address prefix for the summary.')
pnniSummaryPrefixLength = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 7, 1, 2), PnniPrefixLength())
if mibBuilder.loadTexts: pnniSummaryPrefixLength.setStatus('deprecated')
if mibBuilder.loadTexts: pnniSummaryPrefixLength.setDescription('The prefix length for the summary.')
pnniSummaryType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 7, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("internal", 1), ("exterior", 2))).clone('internal')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniSummaryType.setStatus('deprecated')
if mibBuilder.loadTexts: pnniSummaryType.setDescription('The type (e.g. internal or exterior) of summary being described.')
pnniSummarySuppress = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 7, 1, 4), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniSummarySuppress.setStatus('deprecated')
if mibBuilder.loadTexts: pnniSummarySuppress.setDescription("Determines what is done with addresses that are being summarized by the instance. The default value (e.g. false) will indicate that the summary should propagate into the peer group. Network Management will be able to set the value of this attribute to `suppress' (e.g. true), which suppresses the summary and any reachable addresses it summarizes from being advertised into the peer group.")
pnniSummaryState = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 7, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("advertising", 1), ("suppressing", 2), ("inactive", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSummaryState.setStatus('deprecated')
if mibBuilder.loadTexts: pnniSummaryState.setDescription('Indicates whether the summary is currently being advertised by the node within the local switching system into its peer group.')
pnniSummaryRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 7, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniSummaryRowStatus.setStatus('deprecated')
if mibBuilder.loadTexts: pnniSummaryRowStatus.setDescription('To create, delete, activate and de-activate a summary.')
pnniSummaryAddressTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 20), )
if mibBuilder.loadTexts: pnniSummaryAddressTable.setReference('ATM Forum PNNI 1.0 Section 5.9.2')
if mibBuilder.loadTexts: pnniSummaryAddressTable.setStatus('current')
if mibBuilder.loadTexts: pnniSummaryAddressTable.setDescription('A list of the summary address prefixes that may be advertised by the specified logical PNNI entity.')
pnniSummaryAddressEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 20, 1), ).setIndexNames((0, "PNNI-MIB", "pnniNodeIndex"), (0, "PNNI-MIB", "pnniSummaryAddressType"), (0, "PNNI-MIB", "pnniSummaryAddressAddress"), (0, "PNNI-MIB", "pnniSummaryAddressPrefixLength"))
if mibBuilder.loadTexts: pnniSummaryAddressEntry.setReference('ATM Forum PNNI 1.0 Section 5.9.2')
if mibBuilder.loadTexts: pnniSummaryAddressEntry.setStatus('current')
if mibBuilder.loadTexts: pnniSummaryAddressEntry.setDescription('An entry in the table, containing summary address prefix information in this switching system.')
pnniSummaryAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 20, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("internal", 1), ("exterior", 2))))
if mibBuilder.loadTexts: pnniSummaryAddressType.setStatus('current')
if mibBuilder.loadTexts: pnniSummaryAddressType.setDescription('The type (e.g. internal or exterior) of summary being described.')
pnniSummaryAddressAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 20, 1, 2), AtmAddrPrefix())
if mibBuilder.loadTexts: pnniSummaryAddressAddress.setStatus('current')
if mibBuilder.loadTexts: pnniSummaryAddressAddress.setDescription('The ATM End System Address prefix for the summary.')
pnniSummaryAddressPrefixLength = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 20, 1, 3), PnniPrefixLength())
if mibBuilder.loadTexts: pnniSummaryAddressPrefixLength.setStatus('current')
if mibBuilder.loadTexts: pnniSummaryAddressPrefixLength.setDescription('The prefix length for the summary.')
pnniSummaryAddressSuppress = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 20, 1, 4), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniSummaryAddressSuppress.setStatus('current')
if mibBuilder.loadTexts: pnniSummaryAddressSuppress.setDescription("Determines what is done with addresses that are being summarized by the instance. The default value (e.g. false) will indicate that the summary should propagate into the peer group. Network Management will be able to set the value of this attribute to `suppress' (e.g. true), which suppresses the summary and any reachable addresses it summarizes from being advertised into the peer group.")
pnniSummaryAddressState = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 20, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("advertising", 1), ("suppressing", 2), ("inactive", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSummaryAddressState.setStatus('current')
if mibBuilder.loadTexts: pnniSummaryAddressState.setDescription('Indicates whether the summary is currently being advertised by the node within the local switching system into its peer group.')
pnniSummaryAddressRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 20, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniSummaryAddressRowStatus.setStatus('current')
if mibBuilder.loadTexts: pnniSummaryAddressRowStatus.setDescription('To create, delete, activate and de-activate a summary.')
pnniIfTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 8), )
if mibBuilder.loadTexts: pnniIfTable.setStatus('current')
if mibBuilder.loadTexts: pnniIfTable.setDescription("The pnniIfTable contains the attributes necessary to configure a physical interface on a switching system which is capable of being used for PNNI routing. Interfaces may represent physical connection points (i.e. copper/fiber connection points) or VPCs which have been configured for PNNI's use. Each interface is attached to a specific lowest-level node within the switching system. An ifIndex is used as the instance ID to uniquely identify the interface on the local switching system. This index has the same value as the ifIndex object defined in RFC 1573 for the same interface, since this table correlates with the ifTable in RFC 1573. One row in this table is created by the managed system for each row in the ifTable that has an ifType of atm(37) or atmLogical(80).")
pnniIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 8, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: pnniIfEntry.setStatus('current')
if mibBuilder.loadTexts: pnniIfEntry.setDescription('An entry in the table, containing PNNI specific interface information in this switching system.')
pnniIfNodeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 8, 1, 1), PnniNodeIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnniIfNodeIndex.setStatus('current')
if mibBuilder.loadTexts: pnniIfNodeIndex.setDescription('Identifies the node within the switching system that the interface is directly attached to. The value zero is not a valid value.')
pnniIfPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 8, 1, 2), PnniPortId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniIfPortId.setReference('ATM Forum PNNI 1.0 Section 5.3.4')
if mibBuilder.loadTexts: pnniIfPortId.setStatus('current')
if mibBuilder.loadTexts: pnniIfPortId.setDescription('The Port Identifier of the port as selected by the PNNI protocol entity for the given interface. This value has meaning only within the context of the node to which the port is attached. The distinguished value zero indicates that no PNNI Port Identifier has been assigned for this interface (for example, this value may be used when the interface is not running PNNI).')
pnniIfAggrToken = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 8, 1, 3), PnniAggrToken()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnniIfAggrToken.setReference('ATM Forum PNNI 1.0 Sections 5.3.5, 5.10.3.1')
if mibBuilder.loadTexts: pnniIfAggrToken.setStatus('current')
if mibBuilder.loadTexts: pnniIfAggrToken.setDescription('The configured aggregation token for this interface. The aggregation token controls what other links the link associated with this interface will be aggregated together with.')
pnniIfVPCapability = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 8, 1, 4), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnniIfVPCapability.setReference('ATM Forum PNNI 1.0 Section 5.14.9.1 Table 5-34')
if mibBuilder.loadTexts: pnniIfVPCapability.setStatus('current')
if mibBuilder.loadTexts: pnniIfVPCapability.setDescription("Indicates whether the interface is capable of having VPCs established within it or not. This object may only have the value `true' for physical ATM interfaces, i.e. those with an ifType of atm(37).")
pnniIfAdmWeightCbr = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 8, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 16777215)).clone(5040)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnniIfAdmWeightCbr.setReference('ATM Forum PNNI 1.0 Section 5.8.1.1.3.4')
if mibBuilder.loadTexts: pnniIfAdmWeightCbr.setStatus('current')
if mibBuilder.loadTexts: pnniIfAdmWeightCbr.setDescription('The administrative weight of this interface for the constant bit rate service category.')
pnniIfAdmWeightRtVbr = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 8, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 16777215)).clone(5040)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnniIfAdmWeightRtVbr.setReference('ATM Forum PNNI 1.0 Section 5.8.1.1.3.4')
if mibBuilder.loadTexts: pnniIfAdmWeightRtVbr.setStatus('current')
if mibBuilder.loadTexts: pnniIfAdmWeightRtVbr.setDescription('The administrative weight of this interface for the real-time variable bit rate service category.')
pnniIfAdmWeightNrtVbr = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 8, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 16777215)).clone(5040)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnniIfAdmWeightNrtVbr.setReference('ATM Forum PNNI 1.0 Section 5.8.1.1.3.4')
if mibBuilder.loadTexts: pnniIfAdmWeightNrtVbr.setStatus('current')
if mibBuilder.loadTexts: pnniIfAdmWeightNrtVbr.setDescription('The administrative weight of this interface for the non-real-time variable bit rate service category.')
pnniIfAdmWeightAbr = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 8, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 16777215)).clone(5040)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnniIfAdmWeightAbr.setReference('ATM Forum PNNI 1.0 Section 5.8.1.1.3.4')
if mibBuilder.loadTexts: pnniIfAdmWeightAbr.setStatus('current')
if mibBuilder.loadTexts: pnniIfAdmWeightAbr.setDescription('The administrative weight of this interface for the available bit rate service category.')
pnniIfAdmWeightUbr = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 8, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 16777215)).clone(5040)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnniIfAdmWeightUbr.setReference('ATM Forum PNNI 1.0 Section 5.8.1.1.3.4')
if mibBuilder.loadTexts: pnniIfAdmWeightUbr.setStatus('current')
if mibBuilder.loadTexts: pnniIfAdmWeightUbr.setDescription('The administrative weight of this interface for the unspecified bit rate service category.')
pnniIfRccServiceCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 8, 1, 10), ServiceCategory()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnniIfRccServiceCategory.setReference('ATM Forum PNNI 1.0 Sections 5.5.2, 5.5.3')
if mibBuilder.loadTexts: pnniIfRccServiceCategory.setStatus('current')
if mibBuilder.loadTexts: pnniIfRccServiceCategory.setDescription('The service category used for the PNNI routing control channel (VCI=18) on this interface.')
pnniIfRccTrafficDescrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 8, 1, 11), AtmTrafficDescrParamIndex()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnniIfRccTrafficDescrIndex.setReference('ATM Forum PNNI 1.0 Sections 5.5.2, 5.5.3, Annex G RCCMaximumBurstSize, RCCPeakCellRate, RCCSustainableCellRate')
if mibBuilder.loadTexts: pnniIfRccTrafficDescrIndex.setStatus('current')
if mibBuilder.loadTexts: pnniIfRccTrafficDescrIndex.setDescription('The traffic descriptor index referring to the entry in the atmTrafficDescrParamTable defined in RFC 1695 that specifies the traffic allocation for the PNNI routing control channel (VCI=18) on this interface.')
pnniLinkTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 9), )
if mibBuilder.loadTexts: pnniLinkTable.setReference('ATM Forum PNNI 1.0 Section 5.6')
if mibBuilder.loadTexts: pnniLinkTable.setStatus('current')
if mibBuilder.loadTexts: pnniLinkTable.setDescription('This table contains the attributes necessary to describe the operation of logical links attached to the local switching system and the relationship with the neighbor nodes on the other end of the links. Links are attached to a specific node within the switching system. A concatenation of the Node Index of the node within the local switching system and the port ID are used as the instance ID to uniquely identify the link. Links may represent horizontal links between lowest level neighboring peers, outside links, uplinks, or horizontal links to/from LGNs. The entire pnniLink object is read-only, reflecting the fact that this information is discovered dynamically by the PNNI protocol rather than configured.')
pnniLinkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 9, 1), ).setIndexNames((0, "PNNI-MIB", "pnniNodeIndex"), (0, "PNNI-MIB", "pnniLinkPortId"))
if mibBuilder.loadTexts: pnniLinkEntry.setReference('ATM Forum PNNI 1.0 Section 5.6')
if mibBuilder.loadTexts: pnniLinkEntry.setStatus('current')
if mibBuilder.loadTexts: pnniLinkEntry.setDescription('An entry in the table, containing information about a link attached to a PNNI logical node in this switching system.')
pnniLinkPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 9, 1, 1), PnniPortId())
if mibBuilder.loadTexts: pnniLinkPortId.setStatus('current')
if mibBuilder.loadTexts: pnniLinkPortId.setDescription('The Port Identifier of the link as selected by the local node. This value has meaning only within the context of the node to which the port is attached.')
pnniLinkType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 9, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("unknown", 1), ("lowestLevelHorizontalLink", 2), ("horizontalLinkToFromLgn", 3), ("lowestLevelOutsideLink", 4), ("uplink", 5), ("outsideLinkAndUplink", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniLinkType.setStatus('current')
if mibBuilder.loadTexts: pnniLinkType.setDescription('Indicates the type of link being described.')
pnniLinkVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 9, 1, 3), PnniVersion()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniLinkVersion.setStatus('current')
if mibBuilder.loadTexts: pnniLinkVersion.setDescription("For horizontal and outside links between lowest-level nodes and for links of unknown type, this attribute indicates the version of PNNI routing protocol used to exchange information over this link. If communication with the neighbor node has not yet been established, then the Version is set to `unknown'. For uplinks (where the port ID is not also used for the underlying outside link) or links to/from LGNs, the Version is set to `unknown'.")
pnniLinkHelloState = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 9, 1, 4), PnniHelloState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniLinkHelloState.setReference('ATM Forum PNNI 1.0 Section 5.6.2.1.2')
if mibBuilder.loadTexts: pnniLinkHelloState.setStatus('current')
if mibBuilder.loadTexts: pnniLinkHelloState.setDescription('For horizontal and outside links between lowest-level nodes and for links of unknown type, this attribute indicates the state of the Hello protocol exchange over this link. For links to/from LGNs, this attribute indicates the state of the corresponding LGN Horizontal Link Hello State Machine. For uplinks (where the port ID is not also used for the underlying outside link), this attribute is set to notApplicable.')
pnniLinkRemoteNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 9, 1, 5), PnniNodeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniLinkRemoteNodeId.setStatus('current')
if mibBuilder.loadTexts: pnniLinkRemoteNodeId.setDescription("Indicates the node identifier of the remote (neighboring) node on the other end of the link. If the pnniLinkType is `outside link and uplink', this is the node identifier of the lowest-level neighbor node on the other end of the outside link. If the remote node ID is unknown or if the pnniLinkType is `uplink', this attribute is set to all zeros.")
pnniLinkRemotePortId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 9, 1, 6), PnniPortId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniLinkRemotePortId.setStatus('current')
if mibBuilder.loadTexts: pnniLinkRemotePortId.setDescription("Indicates the port identifier of the port at the remote end of the link as assigned by the remote node. If the pnniLinkType is `outside link and uplink', this is the port identifier assigned by the lowest-level neighbor node to identify the outside link. If the remote port ID is unknown or if the pnniLinkType is `uplink', this attribute is set to zero.")
pnniLinkDerivedAggrToken = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 9, 1, 7), PnniAggrToken()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniLinkDerivedAggrToken.setReference('ATM Forum PNNI 1.0 Section 5.10.3.1')
if mibBuilder.loadTexts: pnniLinkDerivedAggrToken.setStatus('current')
if mibBuilder.loadTexts: pnniLinkDerivedAggrToken.setDescription('Indicates the derived aggregation token value used on this link. For horizontal links between lowest-level nodes and when the link type is not yet known, this attribute takes the value of zero.')
pnniLinkUpnodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 9, 1, 8), PnniNodeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniLinkUpnodeId.setStatus('current')
if mibBuilder.loadTexts: pnniLinkUpnodeId.setDescription("For outside links and uplinks, this attribute contains the Node Identifier of the upnode (the neighbor node's identity at the level of the common peer group). When the upnode has not yet been identified, this attribute is set to zero. For horizontal links or when the link type is not yet known, this attribute is set to zero.")
pnniLinkUpnodeAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 9, 1, 9), PnniAtmAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniLinkUpnodeAtmAddress.setStatus('current')
if mibBuilder.loadTexts: pnniLinkUpnodeAtmAddress.setDescription('For outside links and uplinks, this attribute contains the ATM End System Address used to establish connections to the upnode. When the upnode has not yet been identified, this attribute is set to zero. For horizontal links or when the link type is not yet known, this attribute is set to zero.')
pnniLinkCommonPeerGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 9, 1, 10), PnniPeerGroupId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniLinkCommonPeerGroupId.setStatus('current')
if mibBuilder.loadTexts: pnniLinkCommonPeerGroupId.setDescription('For outside links and uplinks, this attribute contains the peer group identifier of the lowest level common Peer Group in the ancestry of the neighboring node and the node within the local switching system. The value of this attribute takes on a value determined by the Hello exchange of hierarchical information that occurs between the two lowest-level border nodes. When the common peer group has not yet been identified, this attribute is set to zero. For horizontal links or when the link type is not yet known, this attribute is set to all zeros.')
pnniLinkIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 9, 1, 11), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniLinkIfIndex.setStatus('current')
if mibBuilder.loadTexts: pnniLinkIfIndex.setDescription('For horizontal and outside links between lowest-level nodes and for links of unknown type, this attribute identifies the interface to which the logical link corresponds. For all other cases, the value of this object is zero.')
pnniLinkSvccRccIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 9, 1, 12), PnniSvccRccIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniLinkSvccRccIndex.setStatus('current')
if mibBuilder.loadTexts: pnniLinkSvccRccIndex.setDescription("For horizontal links to/from LGNs, this attribute identifies the SVCC-based RCC used to exchange information with the neighboring peer logical group node. If the pnniLinkType is not `horizontal link to/from LGN', this attribute shall take the value of zero.")
pnniLinkRcvHellos = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 9, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniLinkRcvHellos.setStatus('current')
if mibBuilder.loadTexts: pnniLinkRcvHellos.setDescription("For horizontal and outside links between lowest-level nodes and for links of unknown type, this attribute contains a count of the number of Hello Packets received over this link. If the pnniLinkType is `horizontal link to/from LGN' or `uplink', this attribute is set to zero.")
pnniLinkXmtHellos = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 9, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniLinkXmtHellos.setStatus('current')
if mibBuilder.loadTexts: pnniLinkXmtHellos.setDescription("For horizontal and outside links between lowest-level nodes and for links of unknown type, this attribute contains a count of the number of Hello Packets transmitted over this link. If the pnniLinkType is `horizontal link to/from LGN' or `uplink', this attribute is set to zero.")
pnniNbrPeerTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 10), )
if mibBuilder.loadTexts: pnniNbrPeerTable.setReference('ATM Forum PNNI 1.0 Sections 5.7, 5.8')
if mibBuilder.loadTexts: pnniNbrPeerTable.setStatus('current')
if mibBuilder.loadTexts: pnniNbrPeerTable.setDescription("The pnniNbrPeer Object contains all the attributes necessary to describe the relationship a node in this switching system has with a neighboring node within the same peer group. A concatenation of the Node Identifier of the node within the local switching system and the neighboring peer's Node Identifier is used to form the instance ID for this object. The entire pnniNbrPeer object is read-only, reflecting the fact that neighboring peers are discovered dynamically by the PNNI protocol rather than configured.")
pnniNbrPeerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 10, 1), ).setIndexNames((0, "PNNI-MIB", "pnniNodeIndex"), (0, "PNNI-MIB", "pnniNbrPeerRemoteNodeId"))
if mibBuilder.loadTexts: pnniNbrPeerEntry.setReference('ATM Forum PNNI 1.0 Sections 5.7, 5.8')
if mibBuilder.loadTexts: pnniNbrPeerEntry.setStatus('current')
if mibBuilder.loadTexts: pnniNbrPeerEntry.setDescription("An entry in the table, containing information about this node's relationship with a neighboring peer node.")
pnniNbrPeerRemoteNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 10, 1, 1), PnniNodeId())
if mibBuilder.loadTexts: pnniNbrPeerRemoteNodeId.setStatus('current')
if mibBuilder.loadTexts: pnniNbrPeerRemoteNodeId.setDescription('The Node Identifier of the neighboring peer node.')
pnniNbrPeerState = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("npdown", 1), ("negotiating", 2), ("exchanging", 3), ("loading", 4), ("full", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniNbrPeerState.setReference('ATM Forum PNNI 1.0 Section 5.7.2')
if mibBuilder.loadTexts: pnniNbrPeerState.setStatus('current')
if mibBuilder.loadTexts: pnniNbrPeerState.setDescription("Indicates the state of this node's Neighboring Peer State Machine associated with pnniNbrPeerRemoteNodeId.")
pnniNbrPeerSvccRccIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 10, 1, 3), PnniSvccRccIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniNbrPeerSvccRccIndex.setStatus('current')
if mibBuilder.loadTexts: pnniNbrPeerSvccRccIndex.setDescription('Identifies the SVCC-based RCC being used to communicate with the neighboring peer if one exists. If both the local node and the neighboring peer node are lowest-level nodes, this attribute is set to zero.')
pnniNbrPeerPortCount = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 10, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniNbrPeerPortCount.setStatus('current')
if mibBuilder.loadTexts: pnniNbrPeerPortCount.setDescription('A count of the total number of ports that connect to the neighboring peer. If the neighboring peer only communicates via an SVCC-based RCC, the value of this attribute is set to zero. Otherwise it is set to the total number of ports to the neighboring peer in the Hello state 2-WayInside.')
pnniNbrPeerRcvDbSums = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 10, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniNbrPeerRcvDbSums.setStatus('current')
if mibBuilder.loadTexts: pnniNbrPeerRcvDbSums.setDescription('A count of the number of Database Summary Packets received from the neighboring peer.')
pnniNbrPeerXmtDbSums = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 10, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniNbrPeerXmtDbSums.setStatus('current')
if mibBuilder.loadTexts: pnniNbrPeerXmtDbSums.setDescription('A count of the number of Database Summary Packets transmitted to the neighboring peer.')
pnniNbrPeerRcvPtsps = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 10, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniNbrPeerRcvPtsps.setStatus('current')
if mibBuilder.loadTexts: pnniNbrPeerRcvPtsps.setDescription('A count of the number of PTSPs received from the neighboring peer.')
pnniNbrPeerXmtPtsps = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 10, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniNbrPeerXmtPtsps.setStatus('current')
if mibBuilder.loadTexts: pnniNbrPeerXmtPtsps.setDescription('A count of the number of PTSPs (re)transmitted to the neighboring peer.')
pnniNbrPeerRcvPtseReqs = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 10, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniNbrPeerRcvPtseReqs.setStatus('current')
if mibBuilder.loadTexts: pnniNbrPeerRcvPtseReqs.setDescription('A count of the number of PTSE Request packets received from the neighboring peer.')
pnniNbrPeerXmtPtseReqs = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 10, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniNbrPeerXmtPtseReqs.setStatus('current')
if mibBuilder.loadTexts: pnniNbrPeerXmtPtseReqs.setDescription('A count of the number of PTSE Request packets transmitted to the neighboring peer.')
pnniNbrPeerRcvPtseAcks = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 10, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniNbrPeerRcvPtseAcks.setStatus('current')
if mibBuilder.loadTexts: pnniNbrPeerRcvPtseAcks.setDescription('A count of the number of PTSE Ack packets received from the neighboring peer.')
pnniNbrPeerXmtPtseAcks = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 10, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniNbrPeerXmtPtseAcks.setStatus('current')
if mibBuilder.loadTexts: pnniNbrPeerXmtPtseAcks.setDescription('A count of the number of PTSE Ack packets transmitted to the neighboring peer.')
pnniNbrPeerPortTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 11), )
if mibBuilder.loadTexts: pnniNbrPeerPortTable.setReference('ATM Forum PNNI 1.0 Section 5.7.1 Port ID List')
if mibBuilder.loadTexts: pnniNbrPeerPortTable.setStatus('current')
if mibBuilder.loadTexts: pnniNbrPeerPortTable.setDescription("A table of all ports in Hello state 2-Way Inside to a given neighboring peer node. A concatenation of the Node Index of the node within the local switching system, the neighbor's Node Identifier and the Interface Index of the port being described forms the instance ID for this object. This object is only used for lowest-level nodes.")
pnniNbrPeerPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 11, 1), ).setIndexNames((0, "PNNI-MIB", "pnniNodeIndex"), (0, "PNNI-MIB", "pnniNbrPeerRemoteNodeId"), (0, "PNNI-MIB", "pnniNbrPeerPortId"))
if mibBuilder.loadTexts: pnniNbrPeerPortEntry.setStatus('current')
if mibBuilder.loadTexts: pnniNbrPeerPortEntry.setDescription('An entry in the table, containing information about a port in the Hello state 2-Way Inside from a PNNI logical node in this switching system to a neighboring peer node.')
pnniNbrPeerPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 11, 1, 1), PnniPortId())
if mibBuilder.loadTexts: pnniNbrPeerPortId.setStatus('current')
if mibBuilder.loadTexts: pnniNbrPeerPortId.setDescription('The port ID of a port to the neighboring peer that is in the Hello state 2-Way Inside.')
pnniNbrPeerPortFloodStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 11, 1, 2), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniNbrPeerPortFloodStatus.setStatus('current')
if mibBuilder.loadTexts: pnniNbrPeerPortFloodStatus.setDescription('Indicates whether the port is being used for transmission of flooding and database synchronization information to the neighboring peer.')
pnniSvccRccTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 12), )
if mibBuilder.loadTexts: pnniSvccRccTable.setReference('ATM Forum PNNI 1.0 Sections 5.5.6, 5.6.3.1')
if mibBuilder.loadTexts: pnniSvccRccTable.setStatus('current')
if mibBuilder.loadTexts: pnniSvccRccTable.setDescription('A table containing the attributes necessary to analyze the operation of the PNNI protocol on SVCC-based Routing Control Channels. This entire object is read-only, reflecting the fact that SVCC-based RCCs are established dynamically during operation of the PNNI protocol rather than configured.')
pnniSvccRccEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 12, 1), ).setIndexNames((0, "PNNI-MIB", "pnniNodeIndex"), (0, "PNNI-MIB", "pnniSvccRccIndex"))
if mibBuilder.loadTexts: pnniSvccRccEntry.setReference('ATM Forum PNNI 1.0 Sections 5.5.6, 5.6.3.1')
if mibBuilder.loadTexts: pnniSvccRccEntry.setStatus('current')
if mibBuilder.loadTexts: pnniSvccRccEntry.setDescription('An entry in the table, containing information about an SVCC-based RCC from a PNNI logical node in this switching system.')
pnniSvccRccIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 12, 1, 1), PnniSvccRccIndex())
if mibBuilder.loadTexts: pnniSvccRccIndex.setStatus('current')
if mibBuilder.loadTexts: pnniSvccRccIndex.setDescription("An index into the node's tables of SVCC-based RCCs.")
pnniSvccRccVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 12, 1, 2), PnniVersion()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSvccRccVersion.setStatus('current')
if mibBuilder.loadTexts: pnniSvccRccVersion.setDescription('The version of the PNNI routing protocol used to exchange information with the neighbor node.')
pnniSvccRccHelloState = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 12, 1, 3), PnniHelloState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSvccRccHelloState.setStatus('current')
if mibBuilder.loadTexts: pnniSvccRccHelloState.setDescription('The state of the Hello protocol exchange over the SVCC-based RCC. Note: the Down state indicates that the SVCC establishment is in progress.')
pnniSvccRccRemoteNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 12, 1, 4), PnniNodeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSvccRccRemoteNodeId.setStatus('current')
if mibBuilder.loadTexts: pnniSvccRccRemoteNodeId.setDescription('The remote node at which the SVCC-based RCC terminates.')
pnniSvccRccRemoteAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 12, 1, 5), PnniAtmAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSvccRccRemoteAtmAddress.setStatus('current')
if mibBuilder.loadTexts: pnniSvccRccRemoteAtmAddress.setDescription('The ATM End System Address to which SVCC establishment is attempted.')
pnniSvccRccRcvHellos = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 12, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSvccRccRcvHellos.setStatus('current')
if mibBuilder.loadTexts: pnniSvccRccRcvHellos.setDescription('A count of the number of Hello Packets received over this SVCC-based RCC.')
pnniSvccRccXmtHellos = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 12, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSvccRccXmtHellos.setStatus('current')
if mibBuilder.loadTexts: pnniSvccRccXmtHellos.setDescription('A count of the number of Hello Packets transmitted over this SVCC-based RCC.')
pnniSvccRccIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 12, 1, 8), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSvccRccIfIndex.setStatus('current')
if mibBuilder.loadTexts: pnniSvccRccIfIndex.setDescription('The interface from which the SVCC-based RCC leaves the switching system. If the SVCC-based RCC has not yet been established, then this attribute takes the value of zero.')
pnniSvccRccVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 12, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSvccRccVpi.setStatus('current')
if mibBuilder.loadTexts: pnniSvccRccVpi.setDescription('The VPI used at the interface from which the SVCC-based RCC leaves the switching system. If the SVCC-based RCC has not yet been established, then this attribute takes the value of zero ')
pnniSvccRccVci = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 12, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniSvccRccVci.setStatus('current')
if mibBuilder.loadTexts: pnniSvccRccVci.setDescription('The VCI used at the interface from which the SVCC-based RCC leaves the switching system. If the SVCC-based RCC has not yet been established, then this attribute takes the value of zero ')
pnniPtseTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 13), )
if mibBuilder.loadTexts: pnniPtseTable.setReference('ATM Forum PNNI 1.0 Section 5.8.2')
if mibBuilder.loadTexts: pnniPtseTable.setStatus('current')
if mibBuilder.loadTexts: pnniPtseTable.setDescription("The pnniPtse object contains the attributes that describe the most recent instances of PTSEs in a node's topology database. A concatenation of the Node Identifier of the local node that received the PTSE, the originating Node's Node Identifier and the PTSE Identifier are used to form the instance ID for an instance of this object.")
pnniPtseEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 13, 1), ).setIndexNames((0, "PNNI-MIB", "pnniNodeIndex"), (0, "PNNI-MIB", "pnniPtseOriginatingNodeId"), (0, "PNNI-MIB", "pnniPtseId"))
if mibBuilder.loadTexts: pnniPtseEntry.setReference('ATM Forum PNNI 1.0 Section 5.8.2')
if mibBuilder.loadTexts: pnniPtseEntry.setStatus('current')
if mibBuilder.loadTexts: pnniPtseEntry.setDescription('An entry in the table, containing information about a PTSE in the topology database of a PNNI logical node in this switching system.')
pnniPtseOriginatingNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 13, 1, 1), PnniNodeId())
if mibBuilder.loadTexts: pnniPtseOriginatingNodeId.setStatus('current')
if mibBuilder.loadTexts: pnniPtseOriginatingNodeId.setDescription('The Node Identifier of the node that originated the PTSE.')
pnniPtseId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 13, 1, 2), Unsigned32())
if mibBuilder.loadTexts: pnniPtseId.setStatus('current')
if mibBuilder.loadTexts: pnniPtseId.setDescription('The value of the PTSE Identifier assigned to the PTSE by its originator.')
pnniPtseType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 13, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 96, 97, 224, 256, 288, 289))).clone(namedValues=NamedValues(("other", 1), ("nodalStateParameters", 96), ("nodalInformation", 97), ("internalReachableAddresses", 224), ("exteriorReachableAddresses", 256), ("horizontalLinks", 288), ("uplinks", 289)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniPtseType.setStatus('current')
if mibBuilder.loadTexts: pnniPtseType.setDescription('The type of information contained in the PTSE.')
pnniPtseSequenceNum = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 13, 1, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniPtseSequenceNum.setStatus('current')
if mibBuilder.loadTexts: pnniPtseSequenceNum.setDescription('The sequence number of the instance of the PTSE as it appears in the local topology database.')
pnniPtseChecksum = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 13, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniPtseChecksum.setStatus('current')
if mibBuilder.loadTexts: pnniPtseChecksum.setDescription('The value of the PTSE checksum as it appears in the local topology database.')
pnniPtseLifeTime = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 13, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniPtseLifeTime.setStatus('current')
if mibBuilder.loadTexts: pnniPtseLifeTime.setDescription('The value of the remaining lifetime for the given PTSE as it appears in the local topology database.')
pnniPtseInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 13, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniPtseInfo.setStatus('current')
if mibBuilder.loadTexts: pnniPtseInfo.setDescription('An unformatted hexadecimal dump of the PTSE contents in full. Note: If the size of the PTSE contents is larger than the maximum size of SNMP packets then this is truncated.')
pnniMapTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 14), )
if mibBuilder.loadTexts: pnniMapTable.setStatus('current')
if mibBuilder.loadTexts: pnniMapTable.setDescription('A table containing attributes necessary to find and analyze the operation of all links and nodes within the PNNI hierarchy, as seen from the perspective of a local node. An instance of a pnniMap Object describes a link in terms of a node at one end of the link. Normally there will be two instances of the pnniMap object in the MIB for each horizontal link. The two instances provide information for Network management to map port identifiers from the nodes at both ends to the link between them. A concatenation of the Local Node Index, Originating Node Identifier and Originating Port Identifier are used to form the instance ID for this object. This entire object is read-only, reflecting the fact that the map is discovered dynamically during operation of the PNNI protocol rather than configured.')
pnniMapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 14, 1), ).setIndexNames((0, "PNNI-MIB", "pnniNodeIndex"), (0, "PNNI-MIB", "pnniMapOriginatingNodeId"), (0, "PNNI-MIB", "pnniMapOriginatingPortId"), (0, "PNNI-MIB", "pnniMapIndex"))
if mibBuilder.loadTexts: pnniMapEntry.setStatus('current')
if mibBuilder.loadTexts: pnniMapEntry.setDescription('An entry in the table, containing connectivity information about a node or link in the PNNI routing domain, as seen from the perspective of a PNNI logical node in this switching system.')
pnniMapOriginatingNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 14, 1, 1), PnniNodeId())
if mibBuilder.loadTexts: pnniMapOriginatingNodeId.setStatus('current')
if mibBuilder.loadTexts: pnniMapOriginatingNodeId.setDescription('The node identifier of the node whose connectivity within itself or to other nodes is being described.')
pnniMapOriginatingPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 14, 1, 2), PnniPortId())
if mibBuilder.loadTexts: pnniMapOriginatingPortId.setStatus('current')
if mibBuilder.loadTexts: pnniMapOriginatingPortId.setDescription('The port identifier of the port as assigned by the originating node, to which the port is attached.')
pnniMapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 14, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: pnniMapIndex.setStatus('current')
if mibBuilder.loadTexts: pnniMapIndex.setDescription('An index into the set of link and nodal connectivity associated with the originating node and port. This index is needed since there may be multiple entries for nodal connectivity from a specific node and port pair, in addition to any entry for a horizontal link or uplink.')
pnniMapType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 14, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("horizontalLink", 1), ("uplink", 2), ("node", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniMapType.setStatus('current')
if mibBuilder.loadTexts: pnniMapType.setDescription('The type of PNNI entity being described by this entry in the table.')
pnniMapPeerGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 14, 1, 5), PnniPeerGroupId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniMapPeerGroupId.setStatus('current')
if mibBuilder.loadTexts: pnniMapPeerGroupId.setDescription('Identifies the peer group of the originating node.')
pnniMapAggrToken = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 14, 1, 6), PnniAggrToken()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniMapAggrToken.setStatus('current')
if mibBuilder.loadTexts: pnniMapAggrToken.setDescription('For horizontal links to/from LGNs and for uplinks, this attribute contains the derived aggregation token value for this link. For nodes and for horizontal links between lowest-level nodes, this attribute is set to zero.')
pnniMapRemoteNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 14, 1, 7), PnniNodeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniMapRemoteNodeId.setStatus('current')
if mibBuilder.loadTexts: pnniMapRemoteNodeId.setDescription("For horizontal links and uplinks, this attribute contains the node identifier of the node at the other end of the link from the originating node. If unknown, the PNNI protocol entity sets this attribute's value to (all) zero(s). For nodes, this attribute's value is set to (all) zero(s).")
pnniMapRemotePortId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 14, 1, 8), PnniPortId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniMapRemotePortId.setStatus('current')
if mibBuilder.loadTexts: pnniMapRemotePortId.setDescription("For horizontal links and uplinks, this attribute contains the port identifier of the port at the remote end of the link as assigned by the remote node. If unknown, the PNNI protocol entity sets this attribute's value to zero. For nodes, this attribute contains the port identifier of the port at the other end of the spoke or bypass from the originating port. When the originating port ID is zero, a value of zero indicates the default radius. When the originating port ID is non-zero, a value of zero indicates the nodal nucleus.")
pnniMapVPCapability = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 14, 1, 9), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniMapVPCapability.setStatus('current')
if mibBuilder.loadTexts: pnniMapVPCapability.setDescription('Indicates whether VPCs can be established across the PNNI entity being described by this entry in the pnniMapTable.')
pnniMapPtseId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 14, 1, 10), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniMapPtseId.setStatus('current')
if mibBuilder.loadTexts: pnniMapPtseId.setDescription('The value of the PTSE Identifier for the PTSE being originated by the originating node which contains the information group(s) describing the PNNI entity.')
pnniMapMetricsTag = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 14, 1, 11), PnniMetricsTag()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniMapMetricsTag.setStatus('current')
if mibBuilder.loadTexts: pnniMapMetricsTag.setDescription('An arbitrary integer that is used to associate a set of traffic parameters that are always advertised together. Within this set, the parameters are distinguished by the service categories and direction to which a set of parameters apply. This value is used as an index into the pnniMetricsTable. The distinguished value zero indicates that no metrics are associated with the link or nodal connectivity.')
pnniMapNodeTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 15), )
if mibBuilder.loadTexts: pnniMapNodeTable.setStatus('current')
if mibBuilder.loadTexts: pnniMapNodeTable.setDescription('A list of nodes as seen from the perspective of a local node. The pnniMapNodeTable contains all information learned by the local node from nodal information PTSEs. This entire object is read-only, reflecting the fact that the map is discovered dynamically during operation of the PNNI protocol rather than configured.')
pnniMapNodeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 15, 1), ).setIndexNames((0, "PNNI-MIB", "pnniNodeIndex"), (0, "PNNI-MIB", "pnniMapNodeId"))
if mibBuilder.loadTexts: pnniMapNodeEntry.setStatus('current')
if mibBuilder.loadTexts: pnniMapNodeEntry.setDescription('An entry in the table, containing information about a node in the PNNI routing domain, as seen from the perspective of a logical node in this switching system.')
pnniMapNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 15, 1, 1), PnniNodeId())
if mibBuilder.loadTexts: pnniMapNodeId.setStatus('current')
if mibBuilder.loadTexts: pnniMapNodeId.setDescription('Identifies the node whose nodal information is being described.')
pnniMapNodePeerGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 15, 1, 2), PnniPeerGroupId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniMapNodePeerGroupId.setStatus('current')
if mibBuilder.loadTexts: pnniMapNodePeerGroupId.setDescription('Identifies the peer group of the originating node.')
pnniMapNodeAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 15, 1, 3), PnniAtmAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniMapNodeAtmAddress.setStatus('current')
if mibBuilder.loadTexts: pnniMapNodeAtmAddress.setDescription('The ATM End System Address of the originating node.')
pnniMapNodeRestrictedTransit = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 15, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniMapNodeRestrictedTransit.setStatus('current')
if mibBuilder.loadTexts: pnniMapNodeRestrictedTransit.setDescription("Indicates whether the originating node is restricted to only allow support of SVCs originating or terminating at this node. A value of `true' indicates that the transit capabilities are restricted, i.e., transit connections are not allowed, whereas a value of `false' indicates that transit connections are allowed. This attribute reflects the setting of the restricted transit bit received in the nodal information PTSE of the originating node.")
pnniMapNodeComplexRep = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 15, 1, 5), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniMapNodeComplexRep.setStatus('current')
if mibBuilder.loadTexts: pnniMapNodeComplexRep.setDescription("Indicates whether the originating node uses the complex node representation. If the value is `true', the spokes and bypasses that make up the complex node representation should be found in the pnniMapTable. This attribute reflects the setting of the nodal representation bit received in the nodal information PTSE of the originating node.")
pnniMapNodeRestrictedBranching = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 15, 1, 6), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniMapNodeRestrictedBranching.setStatus('current')
if mibBuilder.loadTexts: pnniMapNodeRestrictedBranching.setDescription("Indicates whether the originating node is able to support additional branches. If the value is 'false', then it can support additional branches. This attribute reflects the setting of the restricted branching bit received in the nodal information PTSE of the originating node.")
pnniMapNodeDatabaseOverload = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 15, 1, 7), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniMapNodeDatabaseOverload.setStatus('current')
if mibBuilder.loadTexts: pnniMapNodeDatabaseOverload.setDescription('Indicates whether the originating node is currently operating in topology database overload state. This attribute has the same value as the Non-transit for PGL Election bit in the nodal information group originated by this node.')
pnniMapNodeIAmLeader = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 15, 1, 8), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniMapNodeIAmLeader.setStatus('current')
if mibBuilder.loadTexts: pnniMapNodeIAmLeader.setDescription("Indicates whether the originating node claims to be peer group leader of its peer group. This attribute reflects the setting of the 'I am Leader' bit received in the nodal information PTSE of the originating node.")
pnniMapNodeLeadershipPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 15, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniMapNodeLeadershipPriority.setStatus('current')
if mibBuilder.loadTexts: pnniMapNodeLeadershipPriority.setDescription('The Leadership priority value advertised by the originating node.')
pnniMapNodePreferredPgl = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 15, 1, 10), PnniNodeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniMapNodePreferredPgl.setStatus('current')
if mibBuilder.loadTexts: pnniMapNodePreferredPgl.setDescription("Identifies the node which the originating node believes should be or is peer group leader of its peer group. If the originating node has not chosen a Preferred PGL, this attribute's value is set to (all) zero(s).")
pnniMapNodeParentNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 15, 1, 11), PnniNodeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniMapNodeParentNodeId.setStatus('current')
if mibBuilder.loadTexts: pnniMapNodeParentNodeId.setDescription("When the originating node is a peer group leader, indicates the node ID of the parent LGN. If the originating node is not peer group leader of its peer group, this attribute's value is set to (all) zero(s).")
pnniMapNodeParentAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 15, 1, 12), PnniAtmAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniMapNodeParentAtmAddress.setStatus('current')
if mibBuilder.loadTexts: pnniMapNodeParentAtmAddress.setDescription("When the originating node is a peer group leader, indicates the ATM address of the parent LGN. If the originating node is not peer group leader of its peer group, this attribute's value is set to (all) zero(s).")
pnniMapNodeParentPeerGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 15, 1, 13), PnniPeerGroupId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniMapNodeParentPeerGroupId.setStatus('current')
if mibBuilder.loadTexts: pnniMapNodeParentPeerGroupId.setDescription("When the originating node is a peer group leader, indicates the node's parent peer group ID. If the originating node is not peer group leader of its peer group, this attribute's value is set to (all) zero(s).")
pnniMapNodeParentPglNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 15, 1, 14), PnniNodeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniMapNodeParentPglNodeId.setStatus('current')
if mibBuilder.loadTexts: pnniMapNodeParentPglNodeId.setDescription("When the originating node is a peer group leader, identifies the node elected as peer group leader of the parent peer group. If the originating node is not peer group leader of its peer group, this attribute's value is set to (all) zero(s).")
pnniMapAddrTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 16), )
if mibBuilder.loadTexts: pnniMapAddrTable.setStatus('current')
if mibBuilder.loadTexts: pnniMapAddrTable.setDescription('The pnniMapAddr MIB Object contains a list of all reachable addresses from each node visible to the local node. The Local Node Index, Advertising Node ID, Advertised Port ID, Reachable Address, and Address prefix length are combined to form an instance ID for this object. The entire object is read-only, reflecting the fact that reachable addresses are discovered during dynamic operation of the PNNI protocol rather than configured.')
pnniMapAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 16, 1), ).setIndexNames((0, "PNNI-MIB", "pnniNodeIndex"), (0, "PNNI-MIB", "pnniMapAddrAdvertisingNodeId"), (0, "PNNI-MIB", "pnniMapAddrAdvertisedPortId"), (0, "PNNI-MIB", "pnniMapAddrIndex"))
if mibBuilder.loadTexts: pnniMapAddrEntry.setStatus('current')
if mibBuilder.loadTexts: pnniMapAddrEntry.setDescription('An entry in the table, containing information about an address prefix reachable from a node in the PNNI routing domain, as seen from the perspective of a PNNI logical node in this switching system.')
pnniMapAddrAdvertisingNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 16, 1, 1), PnniNodeId())
if mibBuilder.loadTexts: pnniMapAddrAdvertisingNodeId.setStatus('current')
if mibBuilder.loadTexts: pnniMapAddrAdvertisingNodeId.setDescription('The node ID of a node advertising reachability to the address prefix.')
pnniMapAddrAdvertisedPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 16, 1, 2), PnniPortId())
if mibBuilder.loadTexts: pnniMapAddrAdvertisedPortId.setStatus('current')
if mibBuilder.loadTexts: pnniMapAddrAdvertisedPortId.setDescription('The port identifier used from the advertising node to reach the given address prefix.')
pnniMapAddrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 16, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: pnniMapAddrIndex.setStatus('current')
if mibBuilder.loadTexts: pnniMapAddrIndex.setDescription('An arbitrary index that is used to enumerate all of the addresses advertised by the specified node.')
pnniMapAddrAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 16, 1, 4), AtmAddrPrefix()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniMapAddrAddress.setStatus('current')
if mibBuilder.loadTexts: pnniMapAddrAddress.setDescription('The value of the ATM End System Address prefix.')
pnniMapAddrPrefixLength = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 16, 1, 5), PnniPrefixLength()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniMapAddrPrefixLength.setStatus('current')
if mibBuilder.loadTexts: pnniMapAddrPrefixLength.setDescription('The Prefix length to be applied to the ATM End System Address prefix.')
pnniMapTnsTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 17), )
if mibBuilder.loadTexts: pnniMapTnsTable.setStatus('current')
if mibBuilder.loadTexts: pnniMapTnsTable.setDescription('A list of all reachable transit networks from each node visible to the local node. The Local Node Index, Advertising Node ID, Advertised Port ID, Transit Network Type, Transit Network Plan, and Transit Network ID are combined to form an instance ID for this object. The entire object is read-only, reflecting the fact that reachable transit networks are discovered during dynamic operation of the PNNI protocol rather than configured.')
pnniMapTnsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 17, 1), ).setIndexNames((0, "PNNI-MIB", "pnniNodeIndex"), (0, "PNNI-MIB", "pnniMapTnsAdvertisingNodeId"), (0, "PNNI-MIB", "pnniMapTnsAdvertisedPortId"), (0, "PNNI-MIB", "pnniMapTnsType"), (0, "PNNI-MIB", "pnniMapTnsPlan"), (0, "PNNI-MIB", "pnniMapTnsId"))
if mibBuilder.loadTexts: pnniMapTnsEntry.setStatus('current')
if mibBuilder.loadTexts: pnniMapTnsEntry.setDescription('An entry in the table, containing information about a transit network reachable from a node in the PNNI routing domain, as seen from the perspective of a PNNI logical node in this switching system.')
pnniMapTnsAdvertisingNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 17, 1, 1), PnniNodeId())
if mibBuilder.loadTexts: pnniMapTnsAdvertisingNodeId.setStatus('current')
if mibBuilder.loadTexts: pnniMapTnsAdvertisingNodeId.setDescription('The node ID of a node advertising reachability to the transit network.')
pnniMapTnsAdvertisedPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 17, 1, 2), PnniPortId())
if mibBuilder.loadTexts: pnniMapTnsAdvertisedPortId.setStatus('current')
if mibBuilder.loadTexts: pnniMapTnsAdvertisedPortId.setDescription('The port identifier used from the advertising node to reach the given transit network.')
pnniMapTnsType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 17, 1, 3), TnsType())
if mibBuilder.loadTexts: pnniMapTnsType.setStatus('current')
if mibBuilder.loadTexts: pnniMapTnsType.setDescription('The type of network identification used for this transit network.')
pnniMapTnsPlan = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 17, 1, 4), TnsPlan())
if mibBuilder.loadTexts: pnniMapTnsPlan.setStatus('current')
if mibBuilder.loadTexts: pnniMapTnsPlan.setDescription('The network identification plan according to which network identification has been assigned.')
pnniMapTnsId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 17, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniMapTnsId.setStatus('current')
if mibBuilder.loadTexts: pnniMapTnsId.setDescription('The value of the transit network identifier.')
pnniMetricsTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 18), )
if mibBuilder.loadTexts: pnniMetricsTable.setReference('ATM Forum PNNI 1.0 Section 5.8.1.1.3')
if mibBuilder.loadTexts: pnniMetricsTable.setStatus('current')
if mibBuilder.loadTexts: pnniMetricsTable.setDescription("This entity's table of PNNI parameters either associated with a PNNI entity or for the connectivity between a PNNI node and a reachable address or transit network.")
pnniMetricsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 18, 1), ).setIndexNames((0, "PNNI-MIB", "pnniNodeIndex"), (0, "PNNI-MIB", "pnniMetricsTag"), (0, "PNNI-MIB", "pnniMetricsDirection"), (0, "PNNI-MIB", "pnniMetricsIndex"))
if mibBuilder.loadTexts: pnniMetricsEntry.setReference('ATM Forum PNNI 1.0 Section 5.8.1.1.3')
if mibBuilder.loadTexts: pnniMetricsEntry.setStatus('current')
if mibBuilder.loadTexts: pnniMetricsEntry.setDescription('A set of parameters that applies to the connectivity from a certain node and port to another node or port or to one or more reachable address prefixes and/or transit networks, for one (or more) particular service category(s). Note that there can be multiple sets of parameters with the same tag, in which case all sets apply to the specified connectivity.')
pnniMetricsTag = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 18, 1, 1), PnniMetricsTag().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: pnniMetricsTag.setStatus('current')
if mibBuilder.loadTexts: pnniMetricsTag.setDescription('An arbitrary integer that is used to associate a set of traffic parameters that are always advertised together. Within this set, the parameters are distinguished by the service categories and direction to which a set of parameters apply.')
pnniMetricsDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 18, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("incoming", 1), ("outgoing", 2))))
if mibBuilder.loadTexts: pnniMetricsDirection.setStatus('current')
if mibBuilder.loadTexts: pnniMetricsDirection.setDescription('The direction, with respect to the advertising node, in which the parameters in this entry apply.')
pnniMetricsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 18, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: pnniMetricsIndex.setStatus('current')
if mibBuilder.loadTexts: pnniMetricsIndex.setDescription('An index into the set of parameters associated with the given tag and direction.')
pnniMetricsClasses = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 18, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniMetricsClasses.setReference('ATM Forum Traffic Management 4.0 Section 2, ATM Forum PNNI 1.0 Section 5.8.1.1.3.1')
if mibBuilder.loadTexts: pnniMetricsClasses.setStatus('current')
if mibBuilder.loadTexts: pnniMetricsClasses.setDescription('The service categories to which this set of parameters applies. This is an integer used as a bit mask with each bit that is set representing a single service category for which the resources indicated are available. Bit 5 represents CBR, bit 4 represents real-time VBR, bit 3 represents non-real-time VBR, bit 2 represents ABR, and bit 1 (LSB) represents UBR.')
pnniMetricsGcacClp = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 18, 1, 5), ClpType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniMetricsGcacClp.setReference('ATM Forum PNNI 1.0 Sections 5.8.1.1.3.1, 5.13.4.1')
if mibBuilder.loadTexts: pnniMetricsGcacClp.setStatus('current')
if mibBuilder.loadTexts: pnniMetricsGcacClp.setDescription('Indicates whether the advertised GCAC parameters apply for CLP=0 traffic or for CLP=0+1 traffic.')
pnniMetricsAdminWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 18, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 16777215)).clone(5040)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniMetricsAdminWeight.setReference('ATM Forum PNNI 1.0 Section 5.8.1.1.3.4')
if mibBuilder.loadTexts: pnniMetricsAdminWeight.setStatus('current')
if mibBuilder.loadTexts: pnniMetricsAdminWeight.setDescription('The administrative weight from the advertising node to the remote end of the PNNI entity or to the reachable address or transit network, for the specified service categories.')
pnniMetrics1 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 18, 1, 7), Unsigned32().clone(4294967295)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniMetrics1.setReference('ATM Forum PNNI 1.0 Section 5.8.1.1.3.7')
if mibBuilder.loadTexts: pnniMetrics1.setStatus('current')
if mibBuilder.loadTexts: pnniMetrics1.setDescription('An alternate routing parameter from the advertising node to the remote end of the PNNI entity or to the reachable address or transit network, for the specified service categories. For information learned from PNNI nodes, this is the maximum cell rate in cells per second for the specified service categories. If this parameter is not used, its value should be set to 0xFFFFFFFF.')
pnniMetrics2 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 18, 1, 8), Unsigned32().clone(4294967295)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniMetrics2.setReference('ATM Forum PNNI 1.0 Section 5.8.1.1.3.8')
if mibBuilder.loadTexts: pnniMetrics2.setStatus('current')
if mibBuilder.loadTexts: pnniMetrics2.setDescription('An alternate routing parameter from the advertising node to the remote end of the PNNI entity or to the reachable address or transit network, for the specified service categories. For information learned from PNNI nodes, this is the available cell rate in cells per second for the specified service categories. If this parameter is not used, its value should be set to 0xFFFFFFFF.')
pnniMetrics3 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 18, 1, 9), Unsigned32().clone(4294967295)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniMetrics3.setReference('ATM Forum PNNI 1.0 Section 5.8.1.1.3.3')
if mibBuilder.loadTexts: pnniMetrics3.setStatus('current')
if mibBuilder.loadTexts: pnniMetrics3.setDescription('An alternate routing parameter from the advertising node to the remote end of the PNNI entity or to the reachable address or transit network, for the specified service categories. For information learned from PNNI nodes, this is the maximum cell transfer delay in microseconds for the specified service categories. If this parameter is not used, its value should be set to 0xFFFFFFFF.')
pnniMetrics4 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 18, 1, 10), Unsigned32().clone(4294967295)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniMetrics4.setReference('ATM Forum PNNI 1.0 Section 5.8.1.1.3.2')
if mibBuilder.loadTexts: pnniMetrics4.setStatus('current')
if mibBuilder.loadTexts: pnniMetrics4.setDescription('An alternate routing parameter from the advertising node to the remote end of the PNNI entity or to the reachable address or transit network, for the specified service categories. For information learned from PNNI nodes, this is the cell delay variation in microseconds for the specified service categories. If this parameter is not used, its value should be set to 0xFFFFFFFF.')
pnniMetrics5 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 18, 1, 11), Unsigned32().clone(4294967295)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniMetrics5.setReference('ATM Forum PNNI 1.0 Section 5.8.1.1.3.5')
if mibBuilder.loadTexts: pnniMetrics5.setStatus('current')
if mibBuilder.loadTexts: pnniMetrics5.setDescription("An alternate routing parameter from the advertising node to the remote end of the PNNI entity or to the reachable address or transit network, for the specified service categories. For PNNI, this is the cell loss ratio for CLP=0 traffic for the specified service categories. The cell loss ratio value is computed as 10**(-n) where 'n' is the value returned in this variable. If this parameter is not used, its value should be set to 0xFFFFFFFF.")
pnniMetrics6 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 18, 1, 12), Unsigned32().clone(4294967295)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniMetrics6.setReference('ATM Forum PNNI 1.0 Section 5.8.1.1.3.6')
if mibBuilder.loadTexts: pnniMetrics6.setStatus('current')
if mibBuilder.loadTexts: pnniMetrics6.setDescription("An alternate routing parameter from the advertising node to the remote end of the PNNI entity or to the reachable address or transit network, for the specified service categories. For PNNI, this is the cell loss ratio for CLP=0+1 traffic for the specified service categories. The cell loss ratio value is computed as 10**(-n) where 'n' is the value returned in this variable. If this parameter is not used, its value should be set to 0xFFFFFFFF.")
pnniMetrics7 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 18, 1, 13), Unsigned32().clone(4294967295)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniMetrics7.setReference('ATM Forum PNNI 1.0 Section 5.8.1.1.3.9')
if mibBuilder.loadTexts: pnniMetrics7.setStatus('current')
if mibBuilder.loadTexts: pnniMetrics7.setDescription('An alternate routing parameter from the advertising node to the remote end of the PNNI entity or to the reachable address or transit network, for the specified service categories. For information learned from PNNI nodes, this is the cell rate margin in cells per second for the specified service categories. If this parameter is not used, its value should be set to 0xFFFFFFFF.')
pnniMetrics8 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 18, 1, 14), Unsigned32().clone(4294967295)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniMetrics8.setReference('ATM Forum PNNI 1.0 Section 5.8.1.1.3.10')
if mibBuilder.loadTexts: pnniMetrics8.setStatus('current')
if mibBuilder.loadTexts: pnniMetrics8.setDescription('An alternate routing parameter from the advertising node to the remote end of the PNNI entity or to the reachable address or transit network, for the specified service categories. For information learned from PNNI nodes, this is the variance factor in units of 2**(-8) for the specified service categories. If this parameter is not used, its value should be set to 0xFFFFFFFF.')
pnniMetricsRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 18, 1, 15), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniMetricsRowStatus.setStatus('current')
if mibBuilder.loadTexts: pnniMetricsRowStatus.setDescription('To create, delete, activate and de-activate a set of metrics.')
pnniRoutingGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19))
pnniRouteBaseGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 1))
pnniRouteNodeNumber = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 1, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniRouteNodeNumber.setStatus('current')
if mibBuilder.loadTexts: pnniRouteNodeNumber.setDescription('The number of current precalculated PNNI routes to PNNI nodes that are not invalid.')
pnniRouteAddrNumber = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniRouteAddrNumber.setStatus('current')
if mibBuilder.loadTexts: pnniRouteAddrNumber.setDescription('The number of current PNNI routes from nodes in the PNNI routing domain to addresses and transit networks that are not invalid.')
pnniRouteNodeTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 2), )
if mibBuilder.loadTexts: pnniRouteNodeTable.setStatus('current')
if mibBuilder.loadTexts: pnniRouteNodeTable.setDescription("This entity's PNNI Routing table (of routes to other nodes).")
pnniRouteNodeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 2, 1), ).setIndexNames((0, "PNNI-MIB", "pnniNodeIndex"), (0, "PNNI-MIB", "pnniRouteNodeClass"), (0, "PNNI-MIB", "pnniRouteNodeDestNodeId"), (0, "PNNI-MIB", "pnniRouteNodeDTL"))
if mibBuilder.loadTexts: pnniRouteNodeEntry.setStatus('current')
if mibBuilder.loadTexts: pnniRouteNodeEntry.setDescription('A particular route to a particular destination node, under a particular policy.')
pnniRouteNodeClass = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 2, 1, 1), ServiceCategory())
if mibBuilder.loadTexts: pnniRouteNodeClass.setStatus('current')
if mibBuilder.loadTexts: pnniRouteNodeClass.setDescription('Indicates the service category with which this forwarding table entry is associated.')
pnniRouteNodeDestNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 2, 1, 2), PnniNodeId())
if mibBuilder.loadTexts: pnniRouteNodeDestNodeId.setStatus('current')
if mibBuilder.loadTexts: pnniRouteNodeDestNodeId.setDescription('The node ID of the destination node to which this route proceeds, and at which the DTL stack for this route terminates.')
pnniRouteNodeDTL = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: pnniRouteNodeDTL.setStatus('current')
if mibBuilder.loadTexts: pnniRouteNodeDTL.setDescription("The index into the owning PNNI node's DTL table of the DTL stack that goes with this route.")
pnniRouteNodeDestPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 2, 1, 4), PnniPortId()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteNodeDestPortId.setStatus('current')
if mibBuilder.loadTexts: pnniRouteNodeDestPortId.setDescription('The port ID of the destination node at which the route terminates. A port ID of zero indicates the node nucleus. When the destination node is represented by the simple node representation, this value should be set to zero.')
pnniRouteNodeProto = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("local", 2), ("mgmt", 3), ("pnni", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniRouteNodeProto.setStatus('current')
if mibBuilder.loadTexts: pnniRouteNodeProto.setDescription('The routing mechanism via which this route was learned.')
pnniRouteNodeTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 2, 1, 6), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniRouteNodeTimeStamp.setStatus('current')
if mibBuilder.loadTexts: pnniRouteNodeTimeStamp.setDescription("The time at which this route was last updated or otherwise determined to be correct. Note that no semantics of `too old' can be implied except through knowledge of the routing protocol by which the route was learned.")
pnniRouteNodeInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 2, 1, 7), ObjectIdentifier().clone((0, 0))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteNodeInfo.setStatus('current')
if mibBuilder.loadTexts: pnniRouteNodeInfo.setDescription("A reference to MIB definitions specific to the particular routing protocol which is responsible for this route, as determined by the value specified in the route's pnniRouteNodeProto value. If this information is not present, its value should be set to the OBJECT IDENTIFIER zeroDotZero.")
pnniRouteNodeGcacClp = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 2, 1, 8), ClpType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteNodeGcacClp.setStatus('current')
if mibBuilder.loadTexts: pnniRouteNodeGcacClp.setDescription('For PNNI, indicates whether any advertised GCAC parameters apply for CLP=0 traffic or for CLP=0+1 traffic.')
pnniRouteNodeFwdMetricAW = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 2, 1, 9), Unsigned32().clone(4294967295)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteNodeFwdMetricAW.setReference('ATM Forum PNNI 1.0 Section 5.8.1.1.3.4')
if mibBuilder.loadTexts: pnniRouteNodeFwdMetricAW.setStatus('current')
if mibBuilder.loadTexts: pnniRouteNodeFwdMetricAW.setDescription('The cumulative administrative weight calculated for the forward direction of this route. If this metric is not used, its value should be set to 0xFFFFFFFF.')
pnniRouteNodeFwdMetric1 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 2, 1, 10), Unsigned32().clone(4294967295)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteNodeFwdMetric1.setReference('ATM Forum PNNI 1.0 Section 5.8.1.1.3.7')
if mibBuilder.loadTexts: pnniRouteNodeFwdMetric1.setStatus('current')
if mibBuilder.loadTexts: pnniRouteNodeFwdMetric1.setDescription('An alternate routing parameter for the forward direction of this route. For information learned from PNNI nodes, this is the maximum possible cell rate (in cells per second) for the forward direction of the route. If this parameter is not used, its value should be set to 0xFFFFFFFF.')
pnniRouteNodeFwdMetric2 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 2, 1, 11), Unsigned32().clone(4294967295)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteNodeFwdMetric2.setReference('ATM Forum PNNI 1.0 Section 5.8.1.1.3.8')
if mibBuilder.loadTexts: pnniRouteNodeFwdMetric2.setStatus('current')
if mibBuilder.loadTexts: pnniRouteNodeFwdMetric2.setDescription('An alternate routing parameter for the forward direction of this route. For information learned from PNNI nodes, this is the Available cell rate (in cells per second) for the forward direction of the route. Further information on available bandwidth may be obtainable by reference to the nodal advertisements of the nodes in the path. If this parameter is not used, its value should be set to 0xFFFFFFFF.')
pnniRouteNodeFwdMetric3 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 2, 1, 12), Unsigned32().clone(4294967295)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteNodeFwdMetric3.setReference('ATM Forum PNNI 1.0 Section 5.8.1.1.3.3')
if mibBuilder.loadTexts: pnniRouteNodeFwdMetric3.setStatus('current')
if mibBuilder.loadTexts: pnniRouteNodeFwdMetric3.setDescription('An alternate routing parameter for the forward direction of this route. For information learned from PNNI nodes, this is the cumulative Maximum Cell Transfer Delay (in microseconds) for the forward direction of the route. If this parameter is not used, its value should be set to 0xFFFFFFFF.')
pnniRouteNodeFwdMetric4 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 2, 1, 13), Unsigned32().clone(4294967295)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteNodeFwdMetric4.setReference('ATM Forum PNNI 1.0 Section 5.8.1.1.3.2')
if mibBuilder.loadTexts: pnniRouteNodeFwdMetric4.setStatus('current')
if mibBuilder.loadTexts: pnniRouteNodeFwdMetric4.setDescription('An alternate routing parameter for the forward direction of this route. For information learned from PNNI nodes, this is the cumulative Cell Delay Variation (in microseconds) for the forward direction of the route. If this parameter is not used, its value should be set to 0xFFFFFFFF.')
pnniRouteNodeFwdMetric5 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 2, 1, 14), Unsigned32().clone(4294967295)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteNodeFwdMetric5.setReference('ATM Forum PNNI 1.0 Section 5.8.1.1.3.5')
if mibBuilder.loadTexts: pnniRouteNodeFwdMetric5.setStatus('current')
if mibBuilder.loadTexts: pnniRouteNodeFwdMetric5.setDescription("An alternate routing parameter for the forward direction of this route. For information learned from PNNI nodes, this is the cumulative Cell Loss Ratio for CLP=0 traffic for the forward direction of the route. The cell loss ratio value is computed as 10**(-n) where 'n' is the value returned in this variable. If this parameter is not used, its value should be set to 0xFFFFFFFF.")
pnniRouteNodeFwdMetric6 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 2, 1, 15), Unsigned32().clone(4294967295)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteNodeFwdMetric6.setReference('ATM Forum PNNI 1.0 Section 5.8.1.1.3.6')
if mibBuilder.loadTexts: pnniRouteNodeFwdMetric6.setStatus('current')
if mibBuilder.loadTexts: pnniRouteNodeFwdMetric6.setDescription("An alternate routing parameter for the forward direction of this route. For information learned from PNNI nodes, this is the cumulative Cell Loss Ratio for CLP=0+1 traffic for the forward direction of the route. The cell loss ratio value is computed as 10**(-n) where 'n' is the value returned in this variable. If this parameter is not used, its value should be set to 0xFFFFFFFF.")
pnniRouteNodeFwdMetric7 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 2, 1, 16), Unsigned32().clone(4294967295)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteNodeFwdMetric7.setReference('ATM Forum PNNI 1.0 Section 5.8.1.1.3.9')
if mibBuilder.loadTexts: pnniRouteNodeFwdMetric7.setStatus('current')
if mibBuilder.loadTexts: pnniRouteNodeFwdMetric7.setDescription('An alternate routing parameter for the forward direction of this route. For information learned from PNNI nodes, this is the Cell Rate Margin (in cells per second) for the forward direction of the route. If this parameter is not used, its value should be set to 0xFFFFFFFF.')
pnniRouteNodeFwdMetric8 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 2, 1, 17), Unsigned32().clone(4294967295)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteNodeFwdMetric8.setReference('ATM Forum PNNI 1.0 Section 5.8.1.1.3.10')
if mibBuilder.loadTexts: pnniRouteNodeFwdMetric8.setStatus('current')
if mibBuilder.loadTexts: pnniRouteNodeFwdMetric8.setDescription('An alternate routing parameter for the forward direction of this route. For information learned from PNNI nodes, this is the Variance Factor (in units of 2**(-8)) for the forward direction of the route. If this parameter is not used, its value should be set to 0xFFFFFFFF.')
pnniRouteNodeBwdMetricAW = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 2, 1, 18), Unsigned32().clone(4294967295)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteNodeBwdMetricAW.setReference('ATM Forum PNNI 1.0 Section 5.8.1.1.3.4')
if mibBuilder.loadTexts: pnniRouteNodeBwdMetricAW.setStatus('current')
if mibBuilder.loadTexts: pnniRouteNodeBwdMetricAW.setDescription('The administrative weight calculated for the backward direction of this route. If this metric is not used, its value should be set to 0xFFFFFFFF.')
pnniRouteNodeBwdMetric1 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 2, 1, 19), Unsigned32().clone(4294967295)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteNodeBwdMetric1.setReference('ATM Forum PNNI 1.0 Section 5.8.1.1.3.7')
if mibBuilder.loadTexts: pnniRouteNodeBwdMetric1.setStatus('current')
if mibBuilder.loadTexts: pnniRouteNodeBwdMetric1.setDescription('An alternate routing parameter for the backward direction of this route. For information learned from PNNI nodes, this is the maximum possible cell rate (in cells per second) for the backward direction of the route. If this parameter is not used, its value should be set to 0xFFFFFFFF.')
pnniRouteNodeBwdMetric2 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 2, 1, 20), Unsigned32().clone(4294967295)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteNodeBwdMetric2.setReference('ATM Forum PNNI 1.0 Section 5.8.1.1.3.8')
if mibBuilder.loadTexts: pnniRouteNodeBwdMetric2.setStatus('current')
if mibBuilder.loadTexts: pnniRouteNodeBwdMetric2.setDescription('An alternate routing parameter for the backward direction of this route. For information learned from PNNI nodes, this is the Available cell rate (in cells per second) for the backward direction of the route. Further information on available bandwidth may be obtainable by reference to the nodal advertisements of the nodes in the path. If this parameter is not used, its value should be set to 0xFFFFFFFF.')
pnniRouteNodeBwdMetric3 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 2, 1, 21), Unsigned32().clone(4294967295)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteNodeBwdMetric3.setReference('ATM Forum PNNI 1.0 Section 5.8.1.1.3.3')
if mibBuilder.loadTexts: pnniRouteNodeBwdMetric3.setStatus('current')
if mibBuilder.loadTexts: pnniRouteNodeBwdMetric3.setDescription('An alternate routing parameter for the backward direction of this route. For information learned from PNNI nodes, this is the cumulative Maximum Cell Transfer Delay (in microseconds) for the backward direction of the route. If this parameter is not used, its value should be set to 0xFFFFFFFF.')
pnniRouteNodeBwdMetric4 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 2, 1, 22), Unsigned32().clone(4294967295)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteNodeBwdMetric4.setReference('ATM Forum PNNI 1.0 Section 5.8.1.1.3.2')
if mibBuilder.loadTexts: pnniRouteNodeBwdMetric4.setStatus('current')
if mibBuilder.loadTexts: pnniRouteNodeBwdMetric4.setDescription('An alternate routing parameter for the backward direction of this route. For information learned from PNNI nodes, this is the cumulative Cell Delay Variation (in microseconds) for the backward direction of the route. If this parameter is not used, its value should be set to 0xFFFFFFFF.')
pnniRouteNodeBwdMetric5 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 2, 1, 23), Unsigned32().clone(4294967295)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteNodeBwdMetric5.setReference('ATM Forum PNNI 1.0 Section 5.8.1.1.3.5')
if mibBuilder.loadTexts: pnniRouteNodeBwdMetric5.setStatus('current')
if mibBuilder.loadTexts: pnniRouteNodeBwdMetric5.setDescription("An alternate routing parameter for the backward direction of this route. For information learned from PNNI nodes, this is the cumulative Cell Loss Ratio for CLP=0 traffic for the backward direction of the route. The cell loss ratio value is computed as 10**(-n) where 'n' is the value returned in this variable. If this parameter is not used, its value should be set to 0xFFFFFFFF.")
pnniRouteNodeBwdMetric6 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 2, 1, 24), Unsigned32().clone(4294967295)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteNodeBwdMetric6.setReference('ATM Forum PNNI 1.0 Section 5.8.1.1.3.6')
if mibBuilder.loadTexts: pnniRouteNodeBwdMetric6.setStatus('current')
if mibBuilder.loadTexts: pnniRouteNodeBwdMetric6.setDescription("An alternate routing parameter for the backward direction of this route. For information learned from PNNI nodes, this is the cumulative Cell Loss Ratio for CLP=0+1 traffic for the backward direction of the route. The cell loss ratio value is computed as 10**(-n) where 'n' is the value returned in this variable. If this parameter is not used, its value should be set to 0xFFFFFFFF.")
pnniRouteNodeBwdMetric7 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 2, 1, 25), Unsigned32().clone(4294967295)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteNodeBwdMetric7.setReference('ATM Forum PNNI 1.0 Section 5.8.1.1.3.9')
if mibBuilder.loadTexts: pnniRouteNodeBwdMetric7.setStatus('current')
if mibBuilder.loadTexts: pnniRouteNodeBwdMetric7.setDescription('An alternate routing parameter for the backward direction of this route. For information learned from PNNI nodes, this is the Cell Rate Margin (in cells per second) for the backward direction of the route. If this parameter is not used, its value should be set to 0xFFFFFFFF.')
pnniRouteNodeBwdMetric8 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 2, 1, 26), Unsigned32().clone(4294967295)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteNodeBwdMetric8.setReference('ATM Forum PNNI 1.0 Section 5.8.1.1.3.10')
if mibBuilder.loadTexts: pnniRouteNodeBwdMetric8.setStatus('current')
if mibBuilder.loadTexts: pnniRouteNodeBwdMetric8.setDescription('An alternate routing parameter for the backward direction of this route. For information learned from PNNI nodes, this is the Variance Factor (in units of 2**(-8)) for the backward direction of the route. If this parameter is not used, its value should be set to 0xFFFFFFFF.')
pnniRouteNodeVPCapability = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 2, 1, 27), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteNodeVPCapability.setStatus('current')
if mibBuilder.loadTexts: pnniRouteNodeVPCapability.setDescription('This attribute indicates whether a VPC setup on this route is possible.')
pnniRouteNodeStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 2, 1, 28), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteNodeStatus.setStatus('current')
if mibBuilder.loadTexts: pnniRouteNodeStatus.setDescription('The row status variable, used according to row installation and removal conventions.')
pnniDTLTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 3), )
if mibBuilder.loadTexts: pnniDTLTable.setStatus('current')
if mibBuilder.loadTexts: pnniDTLTable.setDescription('The set of all DTL stacks used for the pre-computed routes maintained by this managed entity.')
pnniDTLEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 3, 1), ).setIndexNames((0, "PNNI-MIB", "pnniNodeIndex"), (0, "PNNI-MIB", "pnniDTLIndex"), (0, "PNNI-MIB", "pnniDTLEntryIndex"))
if mibBuilder.loadTexts: pnniDTLEntry.setStatus('current')
if mibBuilder.loadTexts: pnniDTLEntry.setDescription('A segment of a DTL stack. The complete DTL stack is formed by traversing the rows of the table for which the pnniDTLIndex is the same. Level transitions are indicated using the pnniDLTLinkType column.')
pnniDTLIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: pnniDTLIndex.setStatus('current')
if mibBuilder.loadTexts: pnniDTLIndex.setDescription("The index in the node's DTL table of this DTL stack.")
pnniDTLEntryIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 200)))
if mibBuilder.loadTexts: pnniDTLEntryIndex.setStatus('current')
if mibBuilder.loadTexts: pnniDTLEntryIndex.setDescription('The index in the current DTL stack of this entry.')
pnniDTLNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 3, 1, 3), PnniNodeId()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniDTLNodeId.setStatus('current')
if mibBuilder.loadTexts: pnniDTLNodeId.setDescription('The node which is this hop in the DTL stack.')
pnniDTLPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 3, 1, 4), PnniPortId()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniDTLPortId.setStatus('current')
if mibBuilder.loadTexts: pnniDTLPortId.setDescription('The port from the pnniDTLNodeId to use as the exit. If the DTL stack does not care, this is coded as zero.')
pnniDTLLinkType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("invalid", 1), ("horizontal", 2), ("uplink", 3), ("last", 4)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniDTLLinkType.setStatus('current')
if mibBuilder.loadTexts: pnniDTLLinkType.setDescription('The type of link out from this node (pnniDTLNodeId). This is well defined even if the specific port is not specified.')
pnniDTLStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 3, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniDTLStatus.setStatus('current')
if mibBuilder.loadTexts: pnniDTLStatus.setDescription('The row status variable, used according to row installation and removal conventions.')
pnniRouteAddrTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 4), )
if mibBuilder.loadTexts: pnniRouteAddrTable.setReference('ATM Forum PNNI 1.0 Section 5.8.1.3')
if mibBuilder.loadTexts: pnniRouteAddrTable.setStatus('current')
if mibBuilder.loadTexts: pnniRouteAddrTable.setDescription('A table containing all the attributes necessary to determine what the PNNI entity believes is reachable in terms of ATM End System Addresses and to determine which nodes are advertising this reachability. This table is also used to configure static routes to reachable address prefixes. The local node index that received the reachability information, reachable address, address prefix length, and an index that distinguishes between multiple listings of connectivity to a given address prefix from a given local node are combined to form an instance ID for this object.')
pnniRouteAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 4, 1), ).setIndexNames((0, "PNNI-MIB", "pnniNodeIndex"), (0, "PNNI-MIB", "pnniRouteAddrAddress"), (0, "PNNI-MIB", "pnniRouteAddrPrefixLength"), (0, "PNNI-MIB", "pnniRouteAddrIndex"))
if mibBuilder.loadTexts: pnniRouteAddrEntry.setReference('ATM Forum PNNI 1.0 Section 5.8.1.3')
if mibBuilder.loadTexts: pnniRouteAddrEntry.setStatus('current')
if mibBuilder.loadTexts: pnniRouteAddrEntry.setDescription('An entry in the table, containing information about a reachable address prefix.')
pnniRouteAddrAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 4, 1, 1), AtmAddrPrefix())
if mibBuilder.loadTexts: pnniRouteAddrAddress.setStatus('current')
if mibBuilder.loadTexts: pnniRouteAddrAddress.setDescription('The value of the ATM End System Address prefix.')
pnniRouteAddrPrefixLength = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 4, 1, 2), PnniPrefixLength())
if mibBuilder.loadTexts: pnniRouteAddrPrefixLength.setStatus('current')
if mibBuilder.loadTexts: pnniRouteAddrPrefixLength.setDescription('The prefix length to be applied to the ATM End System Address prefix.')
pnniRouteAddrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: pnniRouteAddrIndex.setStatus('current')
if mibBuilder.loadTexts: pnniRouteAddrIndex.setDescription('An index into the set of listings of connectivity to a given address prefix from a given local node.')
pnniRouteAddrIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 4, 1, 4), InterfaceIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteAddrIfIndex.setStatus('current')
if mibBuilder.loadTexts: pnniRouteAddrIfIndex.setDescription("The local interface over which the reachable address can be reached. The value zero indicates an unknown interface or reachability through a remote node. This object may only have a non-zero value if the value of the corresponding instance of pnniRouteAddrProto is other than 'pnni', pnniRouteAddrType is other than 'reject', and the node identified by pnniRouteAddrAdvertisingNodeId is instantiated within this switching system.")
pnniRouteAddrAdvertisingNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 4, 1, 5), PnniNodeId()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteAddrAdvertisingNodeId.setStatus('current')
if mibBuilder.loadTexts: pnniRouteAddrAdvertisingNodeId.setDescription('The node ID of a node advertising reachability to the address prefix. If the local node index is zero, then the advertising node ID must be set to all zeros.')
pnniRouteAddrAdvertisedPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 4, 1, 6), PnniPortId()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteAddrAdvertisedPortId.setStatus('current')
if mibBuilder.loadTexts: pnniRouteAddrAdvertisedPortId.setDescription('The port identifier used from the advertising node to reach the given address prefix.')
pnniRouteAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 4, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("reject", 2), ("internal", 3), ("exterior", 4))).clone('exterior')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteAddrType.setReference('ATM Forum PNNI 1.0 Section 5.8.1.3')
if mibBuilder.loadTexts: pnniRouteAddrType.setStatus('current')
if mibBuilder.loadTexts: pnniRouteAddrType.setDescription('The type (e.g. internal or exterior) of reachability from the advertising node to the address prefix. Reject(2) refers to an address prefix which, if matched, indicates that the message should be discarded as unreachable. This is used in some protocols as a means of correctly aggregating routes.')
pnniRouteAddrProto = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 4, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("local", 2), ("mgmt", 3), ("pnni", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniRouteAddrProto.setStatus('current')
if mibBuilder.loadTexts: pnniRouteAddrProto.setDescription('The routing mechanism via which the connectivity from the advertising node to the reachable address prefix was learned.')
pnniRouteAddrPnniScope = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 4, 1, 9), PnniLevel()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteAddrPnniScope.setReference('ATM Forum PNNI 1.0 Sections 5.3.6, 5.9.1')
if mibBuilder.loadTexts: pnniRouteAddrPnniScope.setStatus('current')
if mibBuilder.loadTexts: pnniRouteAddrPnniScope.setDescription('The PNNI scope of advertisement (i.e. level of PNNI hierarchy) of the reachability from the advertising node to the address prefix.')
pnniRouteAddrVPCapability = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 4, 1, 10), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteAddrVPCapability.setReference('ATM Forum PNNI 1.0 Section 5.14.9.1 Table 5-34')
if mibBuilder.loadTexts: pnniRouteAddrVPCapability.setStatus('current')
if mibBuilder.loadTexts: pnniRouteAddrVPCapability.setDescription('Indicates whether VPCs can be established from the advertising node to the reachable address prefix.')
pnniRouteAddrMetricsTag = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 4, 1, 11), PnniMetricsTag()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteAddrMetricsTag.setStatus('current')
if mibBuilder.loadTexts: pnniRouteAddrMetricsTag.setDescription('The index into the pnniMetricsTable for the traffic parameter values that apply for the connectivity from the advertising node to the reachable address prefix. There will be one or more entries in the pnniMetricsTable whose first instance identifier matches the value of this variable. If there are no parameters associated with this reachable address prefix then the distinguished value zero is used.')
pnniRouteAddrPtseId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 4, 1, 12), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniRouteAddrPtseId.setReference('ATM Forum PNNI 1.0 Section 5.8.2')
if mibBuilder.loadTexts: pnniRouteAddrPtseId.setStatus('current')
if mibBuilder.loadTexts: pnniRouteAddrPtseId.setDescription('For reachable addresses learned via PNNI, this attribute contains the value of the PTSE Identifier for the PTSE being originated by the originating node which contains the information group(s) describing the reachable address. For reachable addresses learned by means other than PNNI, this attribute is set to zero.')
pnniRouteAddrOriginateAdvertisement = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 4, 1, 13), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteAddrOriginateAdvertisement.setStatus('current')
if mibBuilder.loadTexts: pnniRouteAddrOriginateAdvertisement.setDescription("Whether or not the reachable address specified by this entry is to be advertised by the local node into its PNNI routing domain. This object may only take on the value 'true' when the value of the corresponding instance of pnniRouteAddrProto is other than 'pnni'.")
pnniRouteAddrInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 4, 1, 14), ObjectIdentifier().clone((0, 0))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteAddrInfo.setStatus('current')
if mibBuilder.loadTexts: pnniRouteAddrInfo.setDescription("A reference to MIB definitions specific to the particular routing protocol which is responsible for this reachable address prefix, as determined by the value specified in the route's pnniRouteAddrProto value. If this information is not present, its value should be set to the OBJECT IDENTIFIER zeroDotZero.")
pnniRouteAddrOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 4, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("inactive", 1), ("active", 2), ("advertised", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniRouteAddrOperStatus.setStatus('current')
if mibBuilder.loadTexts: pnniRouteAddrOperStatus.setDescription('Indicates whether the reachable address prefix is operationally valid and whether it is being advertised by this node.')
pnniRouteAddrTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 4, 1, 16), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniRouteAddrTimeStamp.setStatus('current')
if mibBuilder.loadTexts: pnniRouteAddrTimeStamp.setDescription('Indicates when the connectivity from the advertising node to the reachable address prefix became known to the local node.')
pnniRouteAddrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 4, 1, 17), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteAddrRowStatus.setStatus('current')
if mibBuilder.loadTexts: pnniRouteAddrRowStatus.setDescription('To create, delete, activate and de-activate a reachable address prefix.')
pnniRouteTnsTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 5), )
if mibBuilder.loadTexts: pnniRouteTnsTable.setReference('ATM Forum PNNI 1.0 Section 5.8.1.3.2')
if mibBuilder.loadTexts: pnniRouteTnsTable.setStatus('current')
if mibBuilder.loadTexts: pnniRouteTnsTable.setDescription('A table containing all the attributes necessary to determine what transit networks the PNNI entity believes are reachable and to determine which nodes are advertising this reachability. This table is also used to add static routes to reachable transit networks. The local node index which received the reachability information, type of network identification, network identification plan, transit network identifier, and an index that distinguishes between multiple listings of connectivity to a given transit network from a given local node are combined to form an instance ID for this object.')
pnniRouteTnsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 5, 1), ).setIndexNames((0, "PNNI-MIB", "pnniNodeIndex"), (0, "PNNI-MIB", "pnniRouteTnsType"), (0, "PNNI-MIB", "pnniRouteTnsPlan"), (0, "PNNI-MIB", "pnniRouteTnsId"), (0, "PNNI-MIB", "pnniRouteTnsIndex"))
if mibBuilder.loadTexts: pnniRouteTnsEntry.setReference('ATM Forum PNNI 1.0 Section 5.8.1.3.2')
if mibBuilder.loadTexts: pnniRouteTnsEntry.setStatus('current')
if mibBuilder.loadTexts: pnniRouteTnsEntry.setDescription('An entry in the table, containing information about a reachable transit network.')
pnniRouteTnsType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 5, 1, 1), TnsType())
if mibBuilder.loadTexts: pnniRouteTnsType.setStatus('current')
if mibBuilder.loadTexts: pnniRouteTnsType.setDescription('The type of network identification used for this transit network.')
pnniRouteTnsPlan = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 5, 1, 2), TnsPlan())
if mibBuilder.loadTexts: pnniRouteTnsPlan.setStatus('current')
if mibBuilder.loadTexts: pnniRouteTnsPlan.setDescription('The network identification plan according to which network identification has been assigned.')
pnniRouteTnsId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 5, 1, 3), DisplayString())
if mibBuilder.loadTexts: pnniRouteTnsId.setStatus('current')
if mibBuilder.loadTexts: pnniRouteTnsId.setDescription('The value of the transit network identifier.')
pnniRouteTnsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 5, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: pnniRouteTnsIndex.setStatus('current')
if mibBuilder.loadTexts: pnniRouteTnsIndex.setDescription('An index into the set of listings of connectivity to a given transit network from a given local node.')
pnniRouteTnsIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 5, 1, 5), InterfaceIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteTnsIfIndex.setStatus('current')
if mibBuilder.loadTexts: pnniRouteTnsIfIndex.setDescription("The local interface over which the transit network can be reached. The value zero indicates an unknown interface or reachability through a remote node. This object may only have a non-zero value if the value of the corresponding instance of pnniRouteTnsProto is other than 'pnni' and the node identified by pnniRouteTnsAdvertisingNodeId is instantiated within this switching system.")
pnniRouteTnsAdvertisingNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 5, 1, 6), PnniNodeId()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteTnsAdvertisingNodeId.setStatus('current')
if mibBuilder.loadTexts: pnniRouteTnsAdvertisingNodeId.setDescription('The node ID of a node advertising reachability to the transit network. If the local node index is zero, then the advertising node ID must also be set to zero.')
pnniRouteTnsAdvertisedPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 5, 1, 7), PnniPortId()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteTnsAdvertisedPortId.setStatus('current')
if mibBuilder.loadTexts: pnniRouteTnsAdvertisedPortId.setDescription('The port identifier used from the advertising node to reach the given transit network.')
pnniRouteTnsRouteType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 5, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4))).clone(namedValues=NamedValues(("other", 1), ("exterior", 4))).clone('exterior')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteTnsRouteType.setReference('ATM Forum PNNI 1.0 Section 5.8.1.3')
if mibBuilder.loadTexts: pnniRouteTnsRouteType.setStatus('current')
if mibBuilder.loadTexts: pnniRouteTnsRouteType.setDescription('The type (e.g. exterior or other) of reachability from the advertising node to the transit network.')
pnniRouteTnsProto = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 5, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("local", 2), ("mgmt", 3), ("pnni", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniRouteTnsProto.setStatus('current')
if mibBuilder.loadTexts: pnniRouteTnsProto.setDescription('The routing mechanism via which the connectivity from the advertising node to the transit network was learned.')
pnniRouteTnsPnniScope = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 5, 1, 10), PnniLevel()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteTnsPnniScope.setReference('ATM Forum PNNI 1.0 Section 5.3.6')
if mibBuilder.loadTexts: pnniRouteTnsPnniScope.setStatus('current')
if mibBuilder.loadTexts: pnniRouteTnsPnniScope.setDescription('The PNNI scope of advertisement (i.e. level of PNNI hierarchy) of the reachability from the advertising node to the transit network.')
pnniRouteTnsVPCapability = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 5, 1, 11), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteTnsVPCapability.setReference('ATM Forum PNNI 1.0 Section 5.14.9.1 Table 5-34')
if mibBuilder.loadTexts: pnniRouteTnsVPCapability.setStatus('current')
if mibBuilder.loadTexts: pnniRouteTnsVPCapability.setDescription('Indicates whether VPCs can be established from the advertising node to the reachable transit network.')
pnniRouteTnsMetricsTag = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 5, 1, 12), PnniMetricsTag()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteTnsMetricsTag.setStatus('current')
if mibBuilder.loadTexts: pnniRouteTnsMetricsTag.setDescription('The index into the pnniMetricsTable for the traffic parameter values that apply for the connectivity from the advertising node to the transit network. There will be one or more entries in the pnniMetricsTable whose first instance identifier matches the value of this variable. If there are no parameters associated with this transit network then the distinguished value zero is used.')
pnniRouteTnsPtseId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 5, 1, 13), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniRouteTnsPtseId.setReference('ATM Forum PNNI 1.0 Section 5.8.2')
if mibBuilder.loadTexts: pnniRouteTnsPtseId.setStatus('current')
if mibBuilder.loadTexts: pnniRouteTnsPtseId.setDescription('For reachable transit networks learned via PNNI, this attribute contains the value of the PTSE Identifier for the PTSE being originated by the originating node which contains the information group(s) describing the transit network. For reachable transit networks learned by means other than PNNI, this attribute is set to zero.')
pnniRouteTnsOriginateAdvertisement = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 5, 1, 14), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteTnsOriginateAdvertisement.setStatus('current')
if mibBuilder.loadTexts: pnniRouteTnsOriginateAdvertisement.setDescription("Whether or not the transit network specified by this entry is to be advertised by the local node into its PNNI routing domain. This object may only take on the value 'true' when the value of the corresponding instance of pnniRouteNodeProto is other than 'pnni'.")
pnniRouteTnsInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 5, 1, 15), ObjectIdentifier().clone((0, 0))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteTnsInfo.setStatus('current')
if mibBuilder.loadTexts: pnniRouteTnsInfo.setDescription("A reference to MIB definitions specific to the particular routing protocol which is responsible for this transit network, as determined by the value specified in the route's pnniRouteTnsProto value. If this information is not present, its value should be set to the OBJECT IDENTIFIER zeroDotZero.")
pnniRouteTnsOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 5, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("inactive", 1), ("active", 2), ("advertised", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniRouteTnsOperStatus.setStatus('current')
if mibBuilder.loadTexts: pnniRouteTnsOperStatus.setDescription('Indicates whether the reachable transit network is operationally valid and whether it is being advertised by this node.')
pnniRouteTnsTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 5, 1, 17), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnniRouteTnsTimeStamp.setStatus('current')
if mibBuilder.loadTexts: pnniRouteTnsTimeStamp.setDescription('Indicates how long the connectivity from the advertising node to the reachable transit network has been known to the local node.')
pnniRouteTnsRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 1, 19, 5, 1, 18), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pnniRouteTnsRowStatus.setStatus('current')
if mibBuilder.loadTexts: pnniRouteTnsRowStatus.setDescription('To create, delete, activate and de-activate a reachable transit network.')
pnniMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 2))
pnniMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 2, 1))
pnniMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 2, 2))
pnniMIBCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 2, 1, 1)).setObjects(("PNNI-MIB", "pnniGeneralMinGroup"), ("PNNI-MIB", "pnniNodeMinGroup"), ("PNNI-MIB", "pnniNodePglMinGroup"), ("PNNI-MIB", "pnniNodeTimerMinGroup"), ("PNNI-MIB", "pnniScopeMinGroup"), ("PNNI-MIB", "pnniIfMinGroup"), ("PNNI-MIB", "pnniLinkMinGroup"), ("PNNI-MIB", "pnniNbrPeerMinGroup"), ("PNNI-MIB", "pnniNbrPeerPortMinGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pnniMIBCompliance = pnniMIBCompliance.setStatus('current')
if mibBuilder.loadTexts: pnniMIBCompliance.setDescription('The compliance statement for entities which implement the PNNI MIB. Groups of PNNI objects required for management of a minimum function node are identified by the suffix MinGroup. Groups of PNNI objects required for management of a border node are identified by the suffix BorderGroup. Groups of PNNI objects required for management of a PGL/LGN capable node are identified by the suffix LgnGroup. Groups of optional PNNI objects are identified by the suffix OptionalGroup.')
pnniGeneralMinGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 2, 2, 1)).setObjects(("PNNI-MIB", "pnniHighestVersion"), ("PNNI-MIB", "pnniLowestVersion"), ("PNNI-MIB", "pnniDtlCountOriginator"), ("PNNI-MIB", "pnniCrankbackCountOriginator"), ("PNNI-MIB", "pnniAltRouteCountOriginator"), ("PNNI-MIB", "pnniRouteFailCountOriginator"), ("PNNI-MIB", "pnniRouteFailUnreachableOriginator"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pnniGeneralMinGroup = pnniGeneralMinGroup.setStatus('current')
if mibBuilder.loadTexts: pnniGeneralMinGroup.setDescription('A collection of general PNNI objects required for management of a minimum function switching system.')
pnniGeneralBorderGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 2, 2, 2)).setObjects(("PNNI-MIB", "pnniDtlCountBorder"), ("PNNI-MIB", "pnniCrankbackCountBorder"), ("PNNI-MIB", "pnniAltRouteCountBorder"), ("PNNI-MIB", "pnniRouteFailCountBorder"), ("PNNI-MIB", "pnniRouteFailUnreachableBorder"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pnniGeneralBorderGroup = pnniGeneralBorderGroup.setStatus('current')
if mibBuilder.loadTexts: pnniGeneralBorderGroup.setDescription('A collection of general PNNI objects required for management of a border node.')
pnniNodeMinGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 2, 2, 3)).setObjects(("PNNI-MIB", "pnniNodeLevel"), ("PNNI-MIB", "pnniNodeId"), ("PNNI-MIB", "pnniNodeLowest"), ("PNNI-MIB", "pnniNodeAdminStatus"), ("PNNI-MIB", "pnniNodeOperStatus"), ("PNNI-MIB", "pnniNodeDomainName"), ("PNNI-MIB", "pnniNodeAtmAddress"), ("PNNI-MIB", "pnniNodePeerGroupId"), ("PNNI-MIB", "pnniNodeRestrictedTransit"), ("PNNI-MIB", "pnniNodeComplexRep"), ("PNNI-MIB", "pnniNodeRestrictedBranching"), ("PNNI-MIB", "pnniNodeDatabaseOverload"), ("PNNI-MIB", "pnniNodePtses"), ("PNNI-MIB", "pnniNodeRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pnniNodeMinGroup = pnniNodeMinGroup.setStatus('current')
if mibBuilder.loadTexts: pnniNodeMinGroup.setDescription('A collection of per node PNNI objects required for management of a minimum function switching system.')
pnniNodePglMinGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 2, 2, 4)).setObjects(("PNNI-MIB", "pnniNodePglLeadershipPriority"), ("PNNI-MIB", "pnniNodePglInitTime"), ("PNNI-MIB", "pnniNodePglReelectTime"), ("PNNI-MIB", "pnniNodePglState"), ("PNNI-MIB", "pnniNodePreferredPgl"), ("PNNI-MIB", "pnniNodePeerGroupLeader"), ("PNNI-MIB", "pnniNodePglTimeStamp"), ("PNNI-MIB", "pnniNodeActiveParentNodeId"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pnniNodePglMinGroup = pnniNodePglMinGroup.setStatus('current')
if mibBuilder.loadTexts: pnniNodePglMinGroup.setDescription('A collection of per node PGL election related PNNI objects required for management of a minimum function switching system.')
pnniNodePglLgnGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 2, 2, 5)).setObjects(("PNNI-MIB", "pnniNodeCfgParentNodeIndex"), ("PNNI-MIB", "pnniNodePglOverrideDelay"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pnniNodePglLgnGroup = pnniNodePglLgnGroup.setStatus('current')
if mibBuilder.loadTexts: pnniNodePglLgnGroup.setDescription('A collection of per node PGL election related PNNI objects required for management of a PGL/LGN capable switching system.')
pnniNodeTimerMinGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 2, 2, 6)).setObjects(("PNNI-MIB", "pnniNodePtseHolddown"), ("PNNI-MIB", "pnniNodeHelloHolddown"), ("PNNI-MIB", "pnniNodeHelloInterval"), ("PNNI-MIB", "pnniNodeHelloInactivityFactor"), ("PNNI-MIB", "pnniNodePtseRefreshInterval"), ("PNNI-MIB", "pnniNodePtseLifetimeFactor"), ("PNNI-MIB", "pnniNodeRxmtInterval"), ("PNNI-MIB", "pnniNodePeerDelayedAckInterval"), ("PNNI-MIB", "pnniNodeAvcrPm"), ("PNNI-MIB", "pnniNodeAvcrMt"), ("PNNI-MIB", "pnniNodeCdvPm"), ("PNNI-MIB", "pnniNodeCtdPm"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pnniNodeTimerMinGroup = pnniNodeTimerMinGroup.setStatus('current')
if mibBuilder.loadTexts: pnniNodeTimerMinGroup.setDescription('A collection of per node PNNI objects required for management of timers and significant change thresholds in a minimum function switching system.')
pnniNodeTimerLgnGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 2, 2, 7)).setObjects(("PNNI-MIB", "pnniNodeHlinkInact"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pnniNodeTimerLgnGroup = pnniNodeTimerLgnGroup.setStatus('current')
if mibBuilder.loadTexts: pnniNodeTimerLgnGroup.setDescription('A collection of per node PNNI objects required for management of timers in a PGL/LGN capable switching system.')
pnniNodeSvccLgnGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 2, 2, 8)).setObjects(("PNNI-MIB", "pnniNodeSvccInitTime"), ("PNNI-MIB", "pnniNodeSvccRetryTime"), ("PNNI-MIB", "pnniNodeSvccCallingIntegrityTime"), ("PNNI-MIB", "pnniNodeSvccCalledIntegrityTime"), ("PNNI-MIB", "pnniNodeSvccTrafficDescriptorIndex"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pnniNodeSvccLgnGroup = pnniNodeSvccLgnGroup.setStatus('current')
if mibBuilder.loadTexts: pnniNodeSvccLgnGroup.setDescription('A collection of per node SVCC-based RCC related PNNI objects required for management of a PGL/LGN capable switching system.')
pnniScopeMinGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 2, 2, 9)).setObjects(("PNNI-MIB", "pnniScopeLocalNetwork"), ("PNNI-MIB", "pnniScopeLocalNetworkPlusOne"), ("PNNI-MIB", "pnniScopeLocalNetworkPlusTwo"), ("PNNI-MIB", "pnniScopeSiteMinusOne"), ("PNNI-MIB", "pnniScopeIntraSite"), ("PNNI-MIB", "pnniScopeSitePlusOne"), ("PNNI-MIB", "pnniScopeOrganizationMinusOne"), ("PNNI-MIB", "pnniScopeIntraOrganization"), ("PNNI-MIB", "pnniScopeOrganizationPlusOne"), ("PNNI-MIB", "pnniScopeCommunityMinusOne"), ("PNNI-MIB", "pnniScopeIntraCommunity"), ("PNNI-MIB", "pnniScopeCommunityPlusOne"), ("PNNI-MIB", "pnniScopeRegional"), ("PNNI-MIB", "pnniScopeInterRegional"), ("PNNI-MIB", "pnniScopeGlobal"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pnniScopeMinGroup = pnniScopeMinGroup.setStatus('current')
if mibBuilder.loadTexts: pnniScopeMinGroup.setDescription('A collection of per node scope mapping related PNNI objects required for management of a minimum function switching system.')
pnniSummaryLgnGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 2, 2, 10)).setObjects(("PNNI-MIB", "pnniSummaryType"), ("PNNI-MIB", "pnniSummarySuppress"), ("PNNI-MIB", "pnniSummaryState"), ("PNNI-MIB", "pnniSummaryRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pnniSummaryLgnGroup = pnniSummaryLgnGroup.setStatus('deprecated')
if mibBuilder.loadTexts: pnniSummaryLgnGroup.setDescription('A collection of PNNI objects required for controlling address summarization.')
pnniSummaryAddressLgnGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 2, 2, 31)).setObjects(("PNNI-MIB", "pnniSummaryAddressSuppress"), ("PNNI-MIB", "pnniSummaryAddressState"), ("PNNI-MIB", "pnniSummaryAddressRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pnniSummaryAddressLgnGroup = pnniSummaryAddressLgnGroup.setStatus('current')
if mibBuilder.loadTexts: pnniSummaryAddressLgnGroup.setDescription('A collection of PNNI objects required for controlling address summarization.')
pnniIfMinGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 2, 2, 11)).setObjects(("PNNI-MIB", "pnniIfNodeIndex"), ("PNNI-MIB", "pnniIfPortId"), ("PNNI-MIB", "pnniIfVPCapability"), ("PNNI-MIB", "pnniIfAdmWeightCbr"), ("PNNI-MIB", "pnniIfAdmWeightRtVbr"), ("PNNI-MIB", "pnniIfAdmWeightNrtVbr"), ("PNNI-MIB", "pnniIfAdmWeightAbr"), ("PNNI-MIB", "pnniIfAdmWeightUbr"), ("PNNI-MIB", "pnniIfRccServiceCategory"), ("PNNI-MIB", "pnniIfRccTrafficDescrIndex"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pnniIfMinGroup = pnniIfMinGroup.setStatus('current')
if mibBuilder.loadTexts: pnniIfMinGroup.setDescription('A collection of per interface PNNI objects required for management of a minimum function switching system.')
pnniIfBorderGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 2, 2, 12)).setObjects(("PNNI-MIB", "pnniIfAggrToken"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pnniIfBorderGroup = pnniIfBorderGroup.setStatus('current')
if mibBuilder.loadTexts: pnniIfBorderGroup.setDescription('A collection of per interface PNNI objects required for management of a border node.')
pnniLinkMinGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 2, 2, 13)).setObjects(("PNNI-MIB", "pnniLinkType"), ("PNNI-MIB", "pnniLinkVersion"), ("PNNI-MIB", "pnniLinkHelloState"), ("PNNI-MIB", "pnniLinkRemoteNodeId"), ("PNNI-MIB", "pnniLinkRemotePortId"), ("PNNI-MIB", "pnniLinkIfIndex"), ("PNNI-MIB", "pnniLinkRcvHellos"), ("PNNI-MIB", "pnniLinkXmtHellos"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pnniLinkMinGroup = pnniLinkMinGroup.setStatus('current')
if mibBuilder.loadTexts: pnniLinkMinGroup.setDescription('A collection of per link PNNI objects required for management of a minimum function switching system.')
pnniLinkBorderOrLgnGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 2, 2, 14)).setObjects(("PNNI-MIB", "pnniLinkDerivedAggrToken"), ("PNNI-MIB", "pnniLinkUpnodeId"), ("PNNI-MIB", "pnniLinkUpnodeAtmAddress"), ("PNNI-MIB", "pnniLinkCommonPeerGroupId"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pnniLinkBorderOrLgnGroup = pnniLinkBorderOrLgnGroup.setStatus('current')
if mibBuilder.loadTexts: pnniLinkBorderOrLgnGroup.setDescription('A collection of per link PNNI objects required for management of a border node or a PGL/LGN capable switching system.')
pnniLinkLgnGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 2, 2, 15)).setObjects(("PNNI-MIB", "pnniLinkSvccRccIndex"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pnniLinkLgnGroup = pnniLinkLgnGroup.setStatus('current')
if mibBuilder.loadTexts: pnniLinkLgnGroup.setDescription('A collection of per link PNNI objects required for management of a PGL/LGN capable switching system.')
pnniNbrPeerMinGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 2, 2, 16)).setObjects(("PNNI-MIB", "pnniNbrPeerState"), ("PNNI-MIB", "pnniNbrPeerPortCount"), ("PNNI-MIB", "pnniNbrPeerRcvDbSums"), ("PNNI-MIB", "pnniNbrPeerXmtDbSums"), ("PNNI-MIB", "pnniNbrPeerRcvPtsps"), ("PNNI-MIB", "pnniNbrPeerXmtPtsps"), ("PNNI-MIB", "pnniNbrPeerRcvPtseReqs"), ("PNNI-MIB", "pnniNbrPeerXmtPtseReqs"), ("PNNI-MIB", "pnniNbrPeerRcvPtseAcks"), ("PNNI-MIB", "pnniNbrPeerXmtPtseAcks"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pnniNbrPeerMinGroup = pnniNbrPeerMinGroup.setStatus('current')
if mibBuilder.loadTexts: pnniNbrPeerMinGroup.setDescription('A collection of per neighboring peer PNNI objects required for management of a minimum function switching system.')
pnniNbrPeerLgnGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 2, 2, 17)).setObjects(("PNNI-MIB", "pnniNbrPeerSvccRccIndex"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pnniNbrPeerLgnGroup = pnniNbrPeerLgnGroup.setStatus('current')
if mibBuilder.loadTexts: pnniNbrPeerLgnGroup.setDescription('A collection of per neighboring peer PNNI objects required for management of a PGL/LGN capable switching system.')
pnniNbrPeerPortMinGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 2, 2, 18)).setObjects(("PNNI-MIB", "pnniNbrPeerPortFloodStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pnniNbrPeerPortMinGroup = pnniNbrPeerPortMinGroup.setStatus('current')
if mibBuilder.loadTexts: pnniNbrPeerPortMinGroup.setDescription('A collection of per port to neighboring peer PNNI objects required for management of a minimum function switching system.')
pnniSvccRccLgnGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 2, 2, 19)).setObjects(("PNNI-MIB", "pnniSvccRccVersion"), ("PNNI-MIB", "pnniSvccRccHelloState"), ("PNNI-MIB", "pnniSvccRccRemoteNodeId"), ("PNNI-MIB", "pnniSvccRccRemoteAtmAddress"), ("PNNI-MIB", "pnniSvccRccRcvHellos"), ("PNNI-MIB", "pnniSvccRccXmtHellos"), ("PNNI-MIB", "pnniSvccRccIfIndex"), ("PNNI-MIB", "pnniSvccRccVpi"), ("PNNI-MIB", "pnniSvccRccVci"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pnniSvccRccLgnGroup = pnniSvccRccLgnGroup.setStatus('current')
if mibBuilder.loadTexts: pnniSvccRccLgnGroup.setDescription('A collection of per SVCC-based RCC PNNI objects required for management of a PGL/LGN capable switching system.')
pnniPtseOptionalGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 2, 2, 20)).setObjects(("PNNI-MIB", "pnniPtseType"), ("PNNI-MIB", "pnniPtseSequenceNum"), ("PNNI-MIB", "pnniPtseChecksum"), ("PNNI-MIB", "pnniPtseLifeTime"), ("PNNI-MIB", "pnniPtseInfo"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pnniPtseOptionalGroup = pnniPtseOptionalGroup.setStatus('current')
if mibBuilder.loadTexts: pnniPtseOptionalGroup.setDescription('A collection of optional per PTSE PNNI objects.')
pnniMapOptionalGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 2, 2, 21)).setObjects(("PNNI-MIB", "pnniMapType"), ("PNNI-MIB", "pnniMapPeerGroupId"), ("PNNI-MIB", "pnniMapAggrToken"), ("PNNI-MIB", "pnniMapRemoteNodeId"), ("PNNI-MIB", "pnniMapRemotePortId"), ("PNNI-MIB", "pnniMapVPCapability"), ("PNNI-MIB", "pnniMapPtseId"), ("PNNI-MIB", "pnniMapMetricsTag"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pnniMapOptionalGroup = pnniMapOptionalGroup.setStatus('current')
if mibBuilder.loadTexts: pnniMapOptionalGroup.setDescription('A collection of optional PNNI objects used to create a map of nodes and links in the PNNI routing domain.')
pnniMapNodeOptionalGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 2, 2, 22)).setObjects(("PNNI-MIB", "pnniMapNodePeerGroupId"), ("PNNI-MIB", "pnniMapNodeAtmAddress"), ("PNNI-MIB", "pnniMapNodeRestrictedTransit"), ("PNNI-MIB", "pnniMapNodeComplexRep"), ("PNNI-MIB", "pnniMapNodeRestrictedBranching"), ("PNNI-MIB", "pnniMapNodeDatabaseOverload"), ("PNNI-MIB", "pnniMapNodeIAmLeader"), ("PNNI-MIB", "pnniMapNodeLeadershipPriority"), ("PNNI-MIB", "pnniMapNodePreferredPgl"), ("PNNI-MIB", "pnniMapNodeParentNodeId"), ("PNNI-MIB", "pnniMapNodeParentAtmAddress"), ("PNNI-MIB", "pnniMapNodeParentPeerGroupId"), ("PNNI-MIB", "pnniMapNodeParentPglNodeId"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pnniMapNodeOptionalGroup = pnniMapNodeOptionalGroup.setStatus('current')
if mibBuilder.loadTexts: pnniMapNodeOptionalGroup.setDescription('A collection of optional PNNI objects used to create a map of nodes in the PNNI routing domain.')
pnniMapAddrOptionalGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 2, 2, 23)).setObjects(("PNNI-MIB", "pnniMapAddrAddress"), ("PNNI-MIB", "pnniMapAddrPrefixLength"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pnniMapAddrOptionalGroup = pnniMapAddrOptionalGroup.setStatus('current')
if mibBuilder.loadTexts: pnniMapAddrOptionalGroup.setDescription('A collection of optional PNNI objects used to create a map of reachable addresses in the PNNI routing domain.')
pnniMapTnsOptionalGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 2, 2, 24)).setObjects(("PNNI-MIB", "pnniMapTnsId"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pnniMapTnsOptionalGroup = pnniMapTnsOptionalGroup.setStatus('current')
if mibBuilder.loadTexts: pnniMapTnsOptionalGroup.setDescription('A collection of optional PNNI objects used to create a map of reachable transit networks in the PNNI routing domain.')
pnniMetricsOptionalGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 2, 2, 25)).setObjects(("PNNI-MIB", "pnniMetricsClasses"), ("PNNI-MIB", "pnniMetricsGcacClp"), ("PNNI-MIB", "pnniMetricsAdminWeight"), ("PNNI-MIB", "pnniMetrics1"), ("PNNI-MIB", "pnniMetrics2"), ("PNNI-MIB", "pnniMetrics3"), ("PNNI-MIB", "pnniMetrics4"), ("PNNI-MIB", "pnniMetrics5"), ("PNNI-MIB", "pnniMetrics6"), ("PNNI-MIB", "pnniMetrics7"), ("PNNI-MIB", "pnniMetrics8"), ("PNNI-MIB", "pnniMetricsRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pnniMetricsOptionalGroup = pnniMetricsOptionalGroup.setStatus('current')
if mibBuilder.loadTexts: pnniMetricsOptionalGroup.setDescription('A collection of optional PNNI objects used to manage metrics and attributes associated with PNNI entities.')
pnniRouteGeneralOptionalGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 2, 2, 26)).setObjects(("PNNI-MIB", "pnniRouteNodeNumber"), ("PNNI-MIB", "pnniRouteAddrNumber"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pnniRouteGeneralOptionalGroup = pnniRouteGeneralOptionalGroup.setStatus('current')
if mibBuilder.loadTexts: pnniRouteGeneralOptionalGroup.setDescription('A collection of optional PNNI objects.')
pnniRouteNodeOptionalGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 2, 2, 27)).setObjects(("PNNI-MIB", "pnniRouteNodeDestPortId"), ("PNNI-MIB", "pnniRouteNodeProto"), ("PNNI-MIB", "pnniRouteNodeTimeStamp"), ("PNNI-MIB", "pnniRouteNodeInfo"), ("PNNI-MIB", "pnniRouteNodeGcacClp"), ("PNNI-MIB", "pnniRouteNodeFwdMetricAW"), ("PNNI-MIB", "pnniRouteNodeFwdMetric1"), ("PNNI-MIB", "pnniRouteNodeFwdMetric2"), ("PNNI-MIB", "pnniRouteNodeFwdMetric3"), ("PNNI-MIB", "pnniRouteNodeFwdMetric4"), ("PNNI-MIB", "pnniRouteNodeFwdMetric5"), ("PNNI-MIB", "pnniRouteNodeFwdMetric6"), ("PNNI-MIB", "pnniRouteNodeFwdMetric7"), ("PNNI-MIB", "pnniRouteNodeFwdMetric8"), ("PNNI-MIB", "pnniRouteNodeBwdMetricAW"), ("PNNI-MIB", "pnniRouteNodeBwdMetric1"), ("PNNI-MIB", "pnniRouteNodeBwdMetric2"), ("PNNI-MIB", "pnniRouteNodeBwdMetric3"), ("PNNI-MIB", "pnniRouteNodeBwdMetric4"), ("PNNI-MIB", "pnniRouteNodeBwdMetric5"), ("PNNI-MIB", "pnniRouteNodeBwdMetric6"), ("PNNI-MIB", "pnniRouteNodeBwdMetric7"), ("PNNI-MIB", "pnniRouteNodeBwdMetric8"), ("PNNI-MIB", "pnniRouteNodeVPCapability"), ("PNNI-MIB", "pnniRouteNodeStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pnniRouteNodeOptionalGroup = pnniRouteNodeOptionalGroup.setStatus('current')
if mibBuilder.loadTexts: pnniRouteNodeOptionalGroup.setDescription('A collection of optional PNNI objects used to manage precalculated routes to nodes in the PNNI routing domain.')
pnniDTLOptionalGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 2, 2, 28)).setObjects(("PNNI-MIB", "pnniDTLNodeId"), ("PNNI-MIB", "pnniDTLPortId"), ("PNNI-MIB", "pnniDTLLinkType"), ("PNNI-MIB", "pnniDTLStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pnniDTLOptionalGroup = pnniDTLOptionalGroup.setStatus('current')
if mibBuilder.loadTexts: pnniDTLOptionalGroup.setDescription('A collection of optional PNNI objects used to manage precalculated routes to nodes in the PNNI routing domain.')
pnniRouteAddrOptionalGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 2, 2, 29)).setObjects(("PNNI-MIB", "pnniRouteAddrIfIndex"), ("PNNI-MIB", "pnniRouteAddrAdvertisingNodeId"), ("PNNI-MIB", "pnniRouteAddrAdvertisedPortId"), ("PNNI-MIB", "pnniRouteAddrType"), ("PNNI-MIB", "pnniRouteAddrProto"), ("PNNI-MIB", "pnniRouteAddrPnniScope"), ("PNNI-MIB", "pnniRouteAddrVPCapability"), ("PNNI-MIB", "pnniRouteAddrMetricsTag"), ("PNNI-MIB", "pnniRouteAddrPtseId"), ("PNNI-MIB", "pnniRouteAddrOriginateAdvertisement"), ("PNNI-MIB", "pnniRouteAddrInfo"), ("PNNI-MIB", "pnniRouteAddrOperStatus"), ("PNNI-MIB", "pnniRouteAddrTimeStamp"), ("PNNI-MIB", "pnniRouteAddrRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pnniRouteAddrOptionalGroup = pnniRouteAddrOptionalGroup.setStatus('current')
if mibBuilder.loadTexts: pnniRouteAddrOptionalGroup.setDescription('A collection of optional PNNI objects used to manage routes to reachable addresses in the PNNI routing domain.')
pnniRouteTnsOptionalGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 4, 1, 2, 2, 30)).setObjects(("PNNI-MIB", "pnniRouteTnsIfIndex"), ("PNNI-MIB", "pnniRouteTnsAdvertisingNodeId"), ("PNNI-MIB", "pnniRouteTnsAdvertisedPortId"), ("PNNI-MIB", "pnniRouteTnsRouteType"), ("PNNI-MIB", "pnniRouteTnsProto"), ("PNNI-MIB", "pnniRouteTnsPnniScope"), ("PNNI-MIB", "pnniRouteTnsVPCapability"), ("PNNI-MIB", "pnniRouteTnsMetricsTag"), ("PNNI-MIB", "pnniRouteTnsPtseId"), ("PNNI-MIB", "pnniRouteTnsOriginateAdvertisement"), ("PNNI-MIB", "pnniRouteTnsInfo"), ("PNNI-MIB", "pnniRouteTnsOperStatus"), ("PNNI-MIB", "pnniRouteTnsTimeStamp"), ("PNNI-MIB", "pnniRouteTnsRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pnniRouteTnsOptionalGroup = pnniRouteTnsOptionalGroup.setStatus('current')
if mibBuilder.loadTexts: pnniRouteTnsOptionalGroup.setDescription('A collection of optional PNNI objects used to manage routes to reachable transit networks in the PNNI routing domain.')
mibBuilder.exportSymbols("PNNI-MIB", pnniPtseSequenceNum=pnniPtseSequenceNum, pnniRouteTnsMetricsTag=pnniRouteTnsMetricsTag, pnniMapNodePeerGroupId=pnniMapNodePeerGroupId, pnniRouteTnsIndex=pnniRouteTnsIndex, pnniNbrPeerState=pnniNbrPeerState, pnniMapPtseId=pnniMapPtseId, pnniLinkDerivedAggrToken=pnniLinkDerivedAggrToken, pnniRouteAddrOriginateAdvertisement=pnniRouteAddrOriginateAdvertisement, pnniRouteAddrAddress=pnniRouteAddrAddress, pnniMapNodePreferredPgl=pnniMapNodePreferredPgl, pnniNodeHelloInterval=pnniNodeHelloInterval, pnniRouteTnsId=pnniRouteTnsId, pnniRouteTnsType=pnniRouteTnsType, pnniNbrPeerMinGroup=pnniNbrPeerMinGroup, pnniMapTnsTable=pnniMapTnsTable, pnniRouteAddrIndex=pnniRouteAddrIndex, pnniPtseChecksum=pnniPtseChecksum, PnniNodeId=PnniNodeId, pnniRouteAddrInfo=pnniRouteAddrInfo, pnniRouteNodeFwdMetric2=pnniRouteNodeFwdMetric2, pnniNodeLowest=pnniNodeLowest, pnniLinkCommonPeerGroupId=pnniLinkCommonPeerGroupId, pnniDtlCountOriginator=pnniDtlCountOriginator, pnniSvccRccRcvHellos=pnniSvccRccRcvHellos, pnniMapNodeAtmAddress=pnniMapNodeAtmAddress, pnniScopeSiteMinusOne=pnniScopeSiteMinusOne, pnniNodeAvcrMt=pnniNodeAvcrMt, pnniLinkRcvHellos=pnniLinkRcvHellos, pnniNodeId=pnniNodeId, pnniMetricsClasses=pnniMetricsClasses, pnniRouteTnsVPCapability=pnniRouteTnsVPCapability, pnniSummaryAddressTable=pnniSummaryAddressTable, pnniMapPeerGroupId=pnniMapPeerGroupId, pnniMapTable=pnniMapTable, pnniNbrPeerRcvPtseReqs=pnniNbrPeerRcvPtseReqs, pnniRouteNodeBwdMetricAW=pnniRouteNodeBwdMetricAW, pnniMapAggrToken=pnniMapAggrToken, pnniNodeTimerLgnGroup=pnniNodeTimerLgnGroup, pnniRouteTnsAdvertisedPortId=pnniRouteTnsAdvertisedPortId, pnniIfAdmWeightUbr=pnniIfAdmWeightUbr, pnniRouteNodeEntry=pnniRouteNodeEntry, pnniRouteAddrRowStatus=pnniRouteAddrRowStatus, pnniRouteAddrNumber=pnniRouteAddrNumber, PnniVersion=PnniVersion, pnniRouteTnsPtseId=pnniRouteTnsPtseId, pnniSummaryAddressPrefixLength=pnniSummaryAddressPrefixLength, pnniIfAdmWeightCbr=pnniIfAdmWeightCbr, pnniMapNodeParentAtmAddress=pnniMapNodeParentAtmAddress, PnniAtmAddr=PnniAtmAddr, pnniNodeTimerTable=pnniNodeTimerTable, pnniNodeSvccEntry=pnniNodeSvccEntry, pnniNbrPeerEntry=pnniNbrPeerEntry, pnniNbrPeerTable=pnniNbrPeerTable, pnniScopeIntraOrganization=pnniScopeIntraOrganization, pnniNodeCtdPm=pnniNodeCtdPm, pnniNbrPeerRcvDbSums=pnniNbrPeerRcvDbSums, pnniMapAddrAddress=pnniMapAddrAddress, pnniNodePglLeadershipPriority=pnniNodePglLeadershipPriority, pnniRouteNodeVPCapability=pnniRouteNodeVPCapability, pnniScopeLocalNetwork=pnniScopeLocalNetwork, pnniSvccRccRemoteNodeId=pnniSvccRccRemoteNodeId, PYSNMP_MODULE_ID=pnniMIB, pnniRouteAddrOptionalGroup=pnniRouteAddrOptionalGroup, pnniMetricsAdminWeight=pnniMetricsAdminWeight, pnniRouteFailUnreachableOriginator=pnniRouteFailUnreachableOriginator, pnniDTLTable=pnniDTLTable, pnniIfEntry=pnniIfEntry, pnniNodeRowStatus=pnniNodeRowStatus, pnniNodeSvccInitTime=pnniNodeSvccInitTime, pnniMapAddrOptionalGroup=pnniMapAddrOptionalGroup, pnniNodeOperStatus=pnniNodeOperStatus, pnniNodeMinGroup=pnniNodeMinGroup, pnniMapAddrEntry=pnniMapAddrEntry, pnniNodePtseRefreshInterval=pnniNodePtseRefreshInterval, pnniSvccRccVpi=pnniSvccRccVpi, pnniIfRccTrafficDescrIndex=pnniIfRccTrafficDescrIndex, pnniMapOptionalGroup=pnniMapOptionalGroup, pnniSummaryAddressState=pnniSummaryAddressState, pnniRouteNodeDTL=pnniRouteNodeDTL, pnniNbrPeerRcvPtsps=pnniNbrPeerRcvPtsps, pnniNodeHlinkInact=pnniNodeHlinkInact, pnniNodeDomainName=pnniNodeDomainName, pnniNodeHelloHolddown=pnniNodeHelloHolddown, pnniMetricsTable=pnniMetricsTable, ServiceCategory=ServiceCategory, pnniIfAdmWeightAbr=pnniIfAdmWeightAbr, pnniMapEntry=pnniMapEntry, pnniRouteNodeFwdMetric7=pnniRouteNodeFwdMetric7, pnniMetricsTag=pnniMetricsTag, pnniRouteBaseGroup=pnniRouteBaseGroup, pnniScopeOrganizationMinusOne=pnniScopeOrganizationMinusOne, pnniMapAddrAdvertisedPortId=pnniMapAddrAdvertisedPortId, pnniRouteAddrEntry=pnniRouteAddrEntry, pnniDTLNodeId=pnniDTLNodeId, pnniSummaryLgnGroup=pnniSummaryLgnGroup, pnniGeneralMinGroup=pnniGeneralMinGroup, pnniNodePglState=pnniNodePglState, pnniRouteNodeGcacClp=pnniRouteNodeGcacClp, pnniMapMetricsTag=pnniMapMetricsTag, pnniMetrics1=pnniMetrics1, pnniMapVPCapability=pnniMapVPCapability, pnniRouteTnsRouteType=pnniRouteTnsRouteType, pnniRouteNodeStatus=pnniRouteNodeStatus, pnniSvccRccIfIndex=pnniSvccRccIfIndex, pnniNodeSvccCallingIntegrityTime=pnniNodeSvccCallingIntegrityTime, pnniRouteNodeOptionalGroup=pnniRouteNodeOptionalGroup, pnniSummaryAddressSuppress=pnniSummaryAddressSuppress, pnniNodePglReelectTime=pnniNodePglReelectTime, pnniSummarySuppress=pnniSummarySuppress, pnniRouteTnsOriginateAdvertisement=pnniRouteTnsOriginateAdvertisement, pnniLinkIfIndex=pnniLinkIfIndex, pnniSvccRccHelloState=pnniSvccRccHelloState, pnniScopeMappingTable=pnniScopeMappingTable, pnniRouteNodeInfo=pnniRouteNodeInfo, pnniIfAdmWeightNrtVbr=pnniIfAdmWeightNrtVbr, pnniMapNodeLeadershipPriority=pnniMapNodeLeadershipPriority, pnniRouteNodeDestPortId=pnniRouteNodeDestPortId, PnniAggrToken=PnniAggrToken, pnniRouteTnsIfIndex=pnniRouteTnsIfIndex, pnniRouteAddrPrefixLength=pnniRouteAddrPrefixLength, pnniNodeAtmAddress=pnniNodeAtmAddress, pnniNodePtseLifetimeFactor=pnniNodePtseLifetimeFactor, pnniBaseGroup=pnniBaseGroup, pnniRouteFailCountOriginator=pnniRouteFailCountOriginator, pnniNodeTimerEntry=pnniNodeTimerEntry, pnniCrankbackCountBorder=pnniCrankbackCountBorder, pnniScopeInterRegional=pnniScopeInterRegional, pnniScopeGlobal=pnniScopeGlobal, pnniSummaryPrefixLength=pnniSummaryPrefixLength, pnniRouteNodeBwdMetric2=pnniRouteNodeBwdMetric2, pnniMapNodeParentPeerGroupId=pnniMapNodeParentPeerGroupId, pnniScopeCommunityPlusOne=pnniScopeCommunityPlusOne, pnniNodeHelloInactivityFactor=pnniNodeHelloInactivityFactor, pnniIfRccServiceCategory=pnniIfRccServiceCategory, pnniDTLStatus=pnniDTLStatus, pnniRouteTnsPlan=pnniRouteTnsPlan, pnniSvccRccRemoteAtmAddress=pnniSvccRccRemoteAtmAddress, pnniScopeMinGroup=pnniScopeMinGroup, pnniSvccRccXmtHellos=pnniSvccRccXmtHellos, pnniMetrics8=pnniMetrics8, pnniRouteTnsOperStatus=pnniRouteTnsOperStatus, pnniNodePeerGroupId=pnniNodePeerGroupId, pnniScopeLocalNetworkPlusTwo=pnniScopeLocalNetworkPlusTwo, pnniMapType=pnniMapType, PnniNodeIndex=PnniNodeIndex, pnniMapNodeParentNodeId=pnniMapNodeParentNodeId, pnniRouteAddrPtseId=pnniRouteAddrPtseId, pnniMapNodeTable=pnniMapNodeTable, pnniNodeCfgParentNodeIndex=pnniNodeCfgParentNodeIndex, pnniLowestVersion=pnniLowestVersion, pnniMapNodeParentPglNodeId=pnniMapNodeParentPglNodeId, pnniMIBGroups=pnniMIBGroups, pnniPtseLifeTime=pnniPtseLifeTime, pnniSvccRccVersion=pnniSvccRccVersion, pnniRouteTnsAdvertisingNodeId=pnniRouteTnsAdvertisingNodeId, pnniMapTnsOptionalGroup=pnniMapTnsOptionalGroup, pnniNodeAdminStatus=pnniNodeAdminStatus, pnniPtseOptionalGroup=pnniPtseOptionalGroup, pnniLinkSvccRccIndex=pnniLinkSvccRccIndex, pnniMapTnsAdvertisedPortId=pnniMapTnsAdvertisedPortId, pnniMapAddrIndex=pnniMapAddrIndex, pnniRouteFailUnreachableBorder=pnniRouteFailUnreachableBorder, pnniScopeCommunityMinusOne=pnniScopeCommunityMinusOne, pnniNbrPeerRcvPtseAcks=pnniNbrPeerRcvPtseAcks, pnniLinkMinGroup=pnniLinkMinGroup, pnniMIBObjects=pnniMIBObjects, pnniMetricsOptionalGroup=pnniMetricsOptionalGroup, pnniRouteNodeFwdMetricAW=pnniRouteNodeFwdMetricAW, pnniMetrics7=pnniMetrics7, pnniNodePglInitTime=pnniNodePglInitTime, pnniRouteAddrProto=pnniRouteAddrProto, pnniRouteFailCountBorder=pnniRouteFailCountBorder, pnniMIB=pnniMIB, pnniRouteAddrType=pnniRouteAddrType, TnsPlan=TnsPlan, pnniSummaryEntry=pnniSummaryEntry, PnniLevel=PnniLevel, pnniAltRouteCountBorder=pnniAltRouteCountBorder, atmForumNetworkManagement=atmForumNetworkManagement, pnniRouteNodeBwdMetric5=pnniRouteNodeBwdMetric5, pnniLinkLgnGroup=pnniLinkLgnGroup, pnniRouteTnsProto=pnniRouteTnsProto, pnniRouteGeneralOptionalGroup=pnniRouteGeneralOptionalGroup, pnniMapTnsEntry=pnniMapTnsEntry, pnniNbrPeerPortFloodStatus=pnniNbrPeerPortFloodStatus, pnniMIBCompliances=pnniMIBCompliances, PnniSvccRccIndex=PnniSvccRccIndex, pnniIfAggrToken=pnniIfAggrToken, pnniSummaryAddressRowStatus=pnniSummaryAddressRowStatus, pnniPtseId=pnniPtseId, pnniMetrics5=pnniMetrics5, PnniPeerGroupId=PnniPeerGroupId, pnniMetrics3=pnniMetrics3, pnniNodeSvccRetryTime=pnniNodeSvccRetryTime, pnniSvccRccLgnGroup=pnniSvccRccLgnGroup, pnniNbrPeerXmtDbSums=pnniNbrPeerXmtDbSums, pnniSummaryAddressAddress=pnniSummaryAddressAddress, pnniMapNodeIAmLeader=pnniMapNodeIAmLeader, pnniLinkRemotePortId=pnniLinkRemotePortId, pnniRouteNodeNumber=pnniRouteNodeNumber, PnniHelloState=PnniHelloState, pnniRouteAddrMetricsTag=pnniRouteAddrMetricsTag, pnniSummaryAddressType=pnniSummaryAddressType, pnniRouteTnsEntry=pnniRouteTnsEntry, pnniNbrPeerPortMinGroup=pnniNbrPeerPortMinGroup, AtmAddrPrefix=AtmAddrPrefix, pnniMapTnsId=pnniMapTnsId, pnniIfAdmWeightRtVbr=pnniIfAdmWeightRtVbr, pnniRouteNodeDestNodeId=pnniRouteNodeDestNodeId, pnniNbrPeerRemoteNodeId=pnniNbrPeerRemoteNodeId, pnniRouteNodeFwdMetric8=pnniRouteNodeFwdMetric8, pnniDTLOptionalGroup=pnniDTLOptionalGroup, pnniNbrPeerXmtPtsps=pnniNbrPeerXmtPtsps, pnniMetricsRowStatus=pnniMetricsRowStatus, pnniNbrPeerXmtPtseAcks=pnniNbrPeerXmtPtseAcks, pnniLinkVersion=pnniLinkVersion, pnniMapNodeComplexRep=pnniMapNodeComplexRep, pnniMapAddrAdvertisingNodeId=pnniMapAddrAdvertisingNodeId, pnniNodePglTimeStamp=pnniNodePglTimeStamp, pnniSvccRccVci=pnniSvccRccVci, pnniSummaryRowStatus=pnniSummaryRowStatus, pnniRouteNodeBwdMetric8=pnniRouteNodeBwdMetric8, pnniMapTnsAdvertisingNodeId=pnniMapTnsAdvertisingNodeId, TnsType=TnsType, pnniPtseEntry=pnniPtseEntry, pnniMapIndex=pnniMapIndex, pnniMapAddrPrefixLength=pnniMapAddrPrefixLength, pnniMapTnsType=pnniMapTnsType, pnniNodePglOverrideDelay=pnniNodePglOverrideDelay, pnniMapNodeRestrictedBranching=pnniMapNodeRestrictedBranching, pnniRouteNodeBwdMetric1=pnniRouteNodeBwdMetric1, pnniRouteNodeFwdMetric6=pnniRouteNodeFwdMetric6, pnniIfVPCapability=pnniIfVPCapability, pnniLinkUpnodeId=pnniLinkUpnodeId, PnniPortId=PnniPortId, pnniNodeAvcrPm=pnniNodeAvcrPm, pnniMetricsIndex=pnniMetricsIndex, pnniRouteTnsRowStatus=pnniRouteTnsRowStatus, pnniNodeCdvPm=pnniNodeCdvPm, pnniNbrPeerPortCount=pnniNbrPeerPortCount, pnniMIBConformance=pnniMIBConformance, pnniRouteNodeClass=pnniRouteNodeClass, pnniNodeEntry=pnniNodeEntry, pnniLinkPortId=pnniLinkPortId, pnniSvccRccIndex=pnniSvccRccIndex, pnniMapAddrTable=pnniMapAddrTable, pnniDTLPortId=pnniDTLPortId, pnniNodePeerGroupLeader=pnniNodePeerGroupLeader, pnniRouteAddrTimeStamp=pnniRouteAddrTimeStamp, atmForum=atmForum, pnniRouteTnsOptionalGroup=pnniRouteTnsOptionalGroup, pnniLinkBorderOrLgnGroup=pnniLinkBorderOrLgnGroup, pnniMIBCompliance=pnniMIBCompliance, pnniSvccRccEntry=pnniSvccRccEntry)
mibBuilder.exportSymbols("PNNI-MIB", pnniNodeSvccTable=pnniNodeSvccTable, pnniMapNodeEntry=pnniMapNodeEntry, pnniSvccRccTable=pnniSvccRccTable, pnniHighestVersion=pnniHighestVersion, pnniIfNodeIndex=pnniIfNodeIndex, pnniScopeMappingEntry=pnniScopeMappingEntry, pnniSummaryAddressEntry=pnniSummaryAddressEntry, pnniScopeSitePlusOne=pnniScopeSitePlusOne, pnniNodePreferredPgl=pnniNodePreferredPgl, pnniDTLEntryIndex=pnniDTLEntryIndex, pnniNodeRestrictedBranching=pnniNodeRestrictedBranching, pnniPtseInfo=pnniPtseInfo, pnniRouteNodeFwdMetric3=pnniRouteNodeFwdMetric3, pnniSummaryState=pnniSummaryState, pnniPtseTable=pnniPtseTable, pnniMapRemotePortId=pnniMapRemotePortId, pnniNodeSvccTrafficDescriptorIndex=pnniNodeSvccTrafficDescriptorIndex, pnniIfPortId=pnniIfPortId, pnniMapNodeId=pnniMapNodeId, pnniAltRouteCountOriginator=pnniAltRouteCountOriginator, pnniNodeComplexRep=pnniNodeComplexRep, pnniIfTable=pnniIfTable, pnniScopeIntraSite=pnniScopeIntraSite, pnniDTLLinkType=pnniDTLLinkType, pnniIfMinGroup=pnniIfMinGroup, pnniScopeOrganizationPlusOne=pnniScopeOrganizationPlusOne, pnniNbrPeerXmtPtseReqs=pnniNbrPeerXmtPtseReqs, pnniNodeSvccLgnGroup=pnniNodeSvccLgnGroup, pnniNodePglLgnGroup=pnniNodePglLgnGroup, pnniRouteTnsTable=pnniRouteTnsTable, pnniMapTnsPlan=pnniMapTnsPlan, pnniRouteNodeTable=pnniRouteNodeTable, pnniRouteNodeFwdMetric4=pnniRouteNodeFwdMetric4, pnniNbrPeerPortId=pnniNbrPeerPortId, pnniIfBorderGroup=pnniIfBorderGroup, pnniDTLIndex=pnniDTLIndex, pnniMetrics6=pnniMetrics6, pnniLinkEntry=pnniLinkEntry, pnniPtseOriginatingNodeId=pnniPtseOriginatingNodeId, pnniRouteTnsTimeStamp=pnniRouteTnsTimeStamp, pnniRouteAddrPnniScope=pnniRouteAddrPnniScope, pnniMapOriginatingPortId=pnniMapOriginatingPortId, pnniRouteAddrIfIndex=pnniRouteAddrIfIndex, pnniRouteTnsPnniScope=pnniRouteTnsPnniScope, pnniRouteNodeProto=pnniRouteNodeProto, pnniCrankbackCountOriginator=pnniCrankbackCountOriginator, pnniLinkTable=pnniLinkTable, pnniSummaryTable=pnniSummaryTable, pnniRouteAddrAdvertisingNodeId=pnniRouteAddrAdvertisingNodeId, pnniNodePtseHolddown=pnniNodePtseHolddown, pnniNodeDatabaseOverload=pnniNodeDatabaseOverload, PnniMetricsTag=PnniMetricsTag, pnniRouteNodeTimeStamp=pnniRouteNodeTimeStamp, pnniRouteNodeBwdMetric3=pnniRouteNodeBwdMetric3, pnniNbrPeerLgnGroup=pnniNbrPeerLgnGroup, pnniScopeLocalNetworkPlusOne=pnniScopeLocalNetworkPlusOne, pnniMapNodeRestrictedTransit=pnniMapNodeRestrictedTransit, pnniLinkXmtHellos=pnniLinkXmtHellos, pnniLinkHelloState=pnniLinkHelloState, pnniMapRemoteNodeId=pnniMapRemoteNodeId, pnniDTLEntry=pnniDTLEntry, pnniDtlCountBorder=pnniDtlCountBorder, pnniNbrPeerPortTable=pnniNbrPeerPortTable, pnniMetrics4=pnniMetrics4, pnniSummaryAddressLgnGroup=pnniSummaryAddressLgnGroup, pnniSummaryType=pnniSummaryType, pnniNodePglEntry=pnniNodePglEntry, pnniPtseType=pnniPtseType, PnniPrefixLength=PnniPrefixLength, pnniRouteNodeBwdMetric7=pnniRouteNodeBwdMetric7, pnniMetricsEntry=pnniMetricsEntry, pnniScopeIntraCommunity=pnniScopeIntraCommunity, pnniNodeTable=pnniNodeTable, pnniRouteAddrOperStatus=pnniRouteAddrOperStatus, pnniMetricsGcacClp=pnniMetricsGcacClp, pnniNodeLevel=pnniNodeLevel, pnniNodeIndex=pnniNodeIndex, pnniNodePglMinGroup=pnniNodePglMinGroup, pnniNodeActiveParentNodeId=pnniNodeActiveParentNodeId, pnniRouteNodeBwdMetric4=pnniRouteNodeBwdMetric4, pnniRouteNodeFwdMetric5=pnniRouteNodeFwdMetric5, pnniNodeRxmtInterval=pnniNodeRxmtInterval, pnniRouteNodeBwdMetric6=pnniRouteNodeBwdMetric6, pnniRouteAddrAdvertisedPortId=pnniRouteAddrAdvertisedPortId, pnniNodePeerDelayedAckInterval=pnniNodePeerDelayedAckInterval, pnniNbrPeerPortEntry=pnniNbrPeerPortEntry, pnniLinkUpnodeAtmAddress=pnniLinkUpnodeAtmAddress, pnniScopeRegional=pnniScopeRegional, pnniMetrics2=pnniMetrics2, atmfPnni=atmfPnni, pnniRouteAddrVPCapability=pnniRouteAddrVPCapability, pnniRouteNodeFwdMetric1=pnniRouteNodeFwdMetric1, pnniNodeRestrictedTransit=pnniNodeRestrictedTransit, pnniNodePtses=pnniNodePtses, ClpType=ClpType, pnniRouteTnsInfo=pnniRouteTnsInfo, pnniLinkType=pnniLinkType, pnniMetricsDirection=pnniMetricsDirection, pnniMapNodeDatabaseOverload=pnniMapNodeDatabaseOverload, pnniRoutingGroup=pnniRoutingGroup, pnniNodePglTable=pnniNodePglTable, pnniNbrPeerSvccRccIndex=pnniNbrPeerSvccRccIndex, pnniMapOriginatingNodeId=pnniMapOriginatingNodeId, pnniRouteAddrTable=pnniRouteAddrTable, pnniSummaryAddress=pnniSummaryAddress, pnniNodeTimerMinGroup=pnniNodeTimerMinGroup, pnniGeneralBorderGroup=pnniGeneralBorderGroup, pnniLinkRemoteNodeId=pnniLinkRemoteNodeId, pnniNodeSvccCalledIntegrityTime=pnniNodeSvccCalledIntegrityTime, pnniMapNodeOptionalGroup=pnniMapNodeOptionalGroup)
